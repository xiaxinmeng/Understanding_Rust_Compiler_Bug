{"sha": "843db01bd925279da0a56efde532c9e3ecf73610", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0M2RiMDFiZDkyNTI3OWRhMGE1NmVmZGU1MzJjOWUzZWNmNzM2MTA=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-14T23:57:29Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-05-13T02:19:51Z"}, "message": "eddyb's changes for DST coercions\n\n+ lots of rebasing", "tree": {"sha": "eed89761dcb0ddeb578ca24357ef680787eabb43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eed89761dcb0ddeb578ca24357ef680787eabb43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/843db01bd925279da0a56efde532c9e3ecf73610", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/843db01bd925279da0a56efde532c9e3ecf73610", "html_url": "https://github.com/rust-lang/rust/commit/843db01bd925279da0a56efde532c9e3ecf73610", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/843db01bd925279da0a56efde532c9e3ecf73610/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "html_url": "https://github.com/rust-lang/rust/commit/c2b30b86df6b34ba19e87e63402e43d9e81a64fb"}], "stats": {"total": 1521, "additions": 1013, "deletions": 508}, "files": [{"sha": "757c799d85cb95f0408b35ec61d7f7227fe12d62", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -62,6 +62,11 @@ use core::ops::{Deref, DerefMut};\n use core::ptr::{Unique};\n use core::raw::{TraitObject};\n \n+#[cfg(not(stage0))] // SNAP c64d671\n+use core::marker::Unsize;\n+#[cfg(not(stage0))] // SNAP c64d671\n+use core::ops::CoerceUnsized;\n+\n /// A value that represents the heap. This is the default place that the `box`\n /// keyword allocates into when no place is supplied.\n ///\n@@ -390,3 +395,6 @@ impl<'a,A,R> FnOnce<A> for Box<FnBox<A,Output=R>+Send+'a> {\n         self.call_box(args)\n     }\n }\n+\n+#[cfg(not(stage0))] // SNAP c64d671\n+impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}"}, {"sha": "a1b5e6e6baf1e6b8601bd68a40775e49fa50a30d", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -173,9 +173,9 @@ use core::intrinsics::assume;\n use heap::deallocate;\n \n struct RcBox<T> {\n-    value: T,\n     strong: Cell<usize>,\n-    weak: Cell<usize>\n+    weak: Cell<usize>,\n+    value: T\n }\n \n /// A reference-counted pointer type over an immutable value."}, {"sha": "d94b8884112d66e35a113aeec90d5c619844edcc", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -193,6 +193,13 @@ extern \"rust-intrinsic\" {\n     pub fn min_align_of<T>() -> usize;\n     pub fn pref_align_of<T>() -> usize;\n \n+    #[cfg(not(stage0))]\n+    pub fn size_of_val<T: ?Sized>(_: &T) -> usize;\n+    #[cfg(not(stage0))]\n+    pub fn min_align_of_val<T: ?Sized>(_: &T) -> usize;\n+    #[cfg(not(stage0))]\n+    pub fn drop_in_place<T: ?Sized>(_: *mut T);\n+\n     /// Gets a static string slice containing the name of a type.\n     pub fn type_name<T: ?Sized>() -> &'static str;\n "}, {"sha": "968f68a78a7e4c15dcaad902219727c8affead56", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -53,6 +53,14 @@ pub trait Sized {\n     // Empty.\n }\n \n+/// Types that can be \"unsized\" to a dynamically sized type.\n+#[unstable(feature = \"core\")]\n+#[cfg(not(stage0))] // SNAP c64d671\n+#[lang=\"unsize\"]\n+pub trait Unsize<T> {\n+    // Empty.\n+}\n+\n /// Types that can be copied by simply copying bits (i.e. `memcpy`).\n ///\n /// By default, variable bindings have 'move semantics.' In other"}, {"sha": "bb94cd886d74d3197f4afc5116405d0fa0fd6d95", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -86,6 +86,22 @@ pub fn size_of<T>() -> usize {\n     unsafe { intrinsics::size_of::<T>() }\n }\n \n+/// Returns the size of the type that `val` points to in bytes.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::size_of_val(&5i32));\n+/// ```\n+#[cfg(not(stage0))] // SNAP c64d671\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn size_of_val<T: ?Sized>(val: &T) -> usize {\n+    unsafe { intrinsics::size_of_val(val) }\n+}\n+\n /// Returns the size of the type that `_val` points to in bytes.\n ///\n /// # Examples\n@@ -95,6 +111,7 @@ pub fn size_of<T>() -> usize {\n ///\n /// assert_eq!(4, mem::size_of_val(&5i32));\n /// ```\n+#[cfg(stage0)] // SNAP c64d671\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn size_of_val<T>(_val: &T) -> usize {\n@@ -118,6 +135,22 @@ pub fn min_align_of<T>() -> usize {\n     unsafe { intrinsics::min_align_of::<T>() }\n }\n \n+/// Returns the ABI-required minimum alignment of the type of the value that `val` points to\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::min_align_of_val(&5i32));\n+/// ```\n+#[cfg(not(stage0))] // SNAP c64d671\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n+    unsafe { intrinsics::min_align_of_val(val) }\n+}\n+\n /// Returns the ABI-required minimum alignment of the type of the value that `_val` points to\n ///\n /// # Examples\n@@ -127,6 +160,7 @@ pub fn min_align_of<T>() -> usize {\n ///\n /// assert_eq!(4, mem::min_align_of_val(&5i32));\n /// ```\n+#[cfg(stage0)] // SNAP c64d671\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn min_align_of_val<T>(_val: &T) -> usize {"}, {"sha": "85957382826a10d0b4ffcd23bb774ac3f0e592d7", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -12,6 +12,8 @@\n \n use marker::Sized;\n use ops::Deref;\n+#[cfg(not(stage0))] // SNAP c64d671\n+use ops::CoerceUnsized;\n \n /// Unsafe trait to indicate what types are usable with the NonZero struct\n pub unsafe trait Zeroable {}\n@@ -54,3 +56,6 @@ impl<T: Zeroable> Deref for NonZero<T> {\n         inner\n     }\n }\n+\n+#[cfg(not(stage0))] // SNAP c64d671\n+impl<T: Zeroable+CoerceUnsized<U>, U: Zeroable> CoerceUnsized<NonZero<U>> for NonZero<T> {}"}, {"sha": "1a2473fda41a536c4e547a97f9a13bedb1a55156", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -70,6 +70,9 @@\n use marker::Sized;\n use fmt;\n \n+#[cfg(not(stage0))] // SNAP c64d671\n+use marker::Unsize;\n+\n /// The `Drop` trait is used to run some code when a value goes out of scope. This\n /// is sometimes called a 'destructor'.\n ///\n@@ -1207,3 +1210,34 @@ mod impls {\n         }\n     }\n }\n+\n+/// Trait that indicates that this is a pointer or a wrapper for one,\n+/// where unsizing can be performed on the pointee.\n+#[unstable(feature = \"core\")]\n+#[cfg(not(stage0))] // SNAP c64d671\n+#[lang=\"coerce_unsized\"]\n+pub trait CoerceUnsized<T> {\n+    // Empty.\n+}\n+\n+#[cfg(not(stage0))] // SNAP c64d671\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a mut U> for &'a mut T {}\n+#[cfg(not(stage0))] // SNAP c64d671\n+impl<'a, 'b: 'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b mut T {}\n+#[cfg(not(stage0))] // SNAP c64d671\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for &'a mut T {}\n+#[cfg(not(stage0))] // SNAP c64d671\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a mut T {}\n+\n+#[cfg(not(stage0))] // SNAP c64d671\n+impl<'a, 'b: 'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n+#[cfg(not(stage0))] // SNAP c64d671\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a T {}\n+\n+#[cfg(not(stage0))] // SNAP c64d671\n+impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n+#[cfg(not(stage0))] // SNAP c64d671\n+impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *mut T {}\n+\n+#[cfg(not(stage0))] // SNAP c64d671\n+impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}"}, {"sha": "c8788f760811791e42de4260f79ae0de05b28151", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -807,6 +807,9 @@ register_diagnostics! {\n     E0017,\n     E0019,\n     E0022,\n+    E0038,\n+    E0079, // enum variant: expected signed integer constant\n+    E0080, // enum variant: constant evaluation error\n     E0109,\n     E0110,\n     E0134,"}, {"sha": "f410626714f4805752e5579368e504a90ece5d4b", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -259,3 +259,5 @@ pub const tag_codemap_filemap: usize = 0xa2;\n pub const tag_item_super_predicates: usize = 0xa3;\n \n pub const tag_defaulted_trait: usize = 0xa4;\n+\n+pub const tag_impl_coerce_unsized_kind: usize = 0xa5;"}, {"sha": "8a35c0120049024a49f105571b21c78d8026948d", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -279,6 +279,14 @@ pub fn get_impl_polarity<'tcx>(tcx: &ty::ctxt<'tcx>,\n     decoder::get_impl_polarity(&*cdata, def.node)\n }\n \n+pub fn get_custom_coerce_unsized_kind<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                            def: ast::DefId)\n+                                            -> Option<ty::CustomCoerceUnsized> {\n+    let cstore = &tcx.sess.cstore;\n+    let cdata = cstore.get_crate_data(def.krate);\n+    decoder::get_custom_coerce_unsized_kind(&*cdata, def.node)\n+}\n+\n // Given a def_id for an impl, return the trait it implements,\n // if there is one.\n pub fn get_impl_trait<'tcx>(tcx: &ty::ctxt<'tcx>,"}, {"sha": "2f2a5d31c9f77aaf25087c681d255061bbd3acbf", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -489,6 +489,16 @@ pub fn get_impl_polarity<'tcx>(cdata: Cmd,\n     }\n }\n \n+pub fn get_custom_coerce_unsized_kind<'tcx>(cdata: Cmd,\n+                                            id: ast::NodeId)\n+                                            -> Option<ty::CustomCoerceUnsized> {\n+    let item_doc = lookup_item(id, cdata.data());\n+    reader::maybe_get_doc(item_doc, tag_impl_coerce_unsized_kind).map(|kind_doc| {\n+        let mut decoder = reader::Decoder::new(kind_doc);\n+        Decodable::decode(&mut decoder).unwrap()\n+    })\n+}\n+\n pub fn get_impl_trait<'tcx>(cdata: Cmd,\n                             id: ast::NodeId,\n                             tcx: &ty::ctxt<'tcx>)"}, {"sha": "86f33257e09036101239e8f0920348268612043c", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -1219,6 +1219,16 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_attributes(rbml_w, &item.attrs);\n         encode_unsafety(rbml_w, unsafety);\n         encode_polarity(rbml_w, polarity);\n+\n+        match tcx.custom_coerce_unsized_kinds.borrow().get(&local_def(item.id)) {\n+            Some(&kind) => {\n+                rbml_w.start_tag(tag_impl_coerce_unsized_kind);\n+                kind.encode(rbml_w);\n+                rbml_w.end_tag();\n+            }\n+            None => {}\n+        }\n+\n         match ty.node {\n             ast::TyPath(None, ref path) if path.segments.len() == 1 => {\n                 let name = path.segments.last().unwrap().identifier.name;"}, {"sha": "7366ad9453498df06de1420ce02609040bcb3fb2", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -890,10 +890,6 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n         };\n \n-        debug!(\"walk_autoref: expr.id={} cmt_base={}\",\n-               expr.id,\n-               cmt_base.repr(self.tcx()));\n-\n         match *autoref {\n             ty::AutoPtr(r, m) => {\n                 self.delegate.borrow(expr.id,"}, {"sha": "273cd6b4f85b4b29dee9d68e38bf08dc166a6527", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -261,11 +261,14 @@ lets_do_this! {\n \n     SendTraitLangItem,               \"send\",                    send_trait;\n     SizedTraitLangItem,              \"sized\",                   sized_trait;\n+    UnsizeTraitLangItem,             \"unsize\",                  unsize_trait;\n     CopyTraitLangItem,               \"copy\",                    copy_trait;\n     SyncTraitLangItem,               \"sync\",                    sync_trait;\n \n     DropTraitLangItem,               \"drop\",                    drop_trait;\n \n+    CoerceUnsizedTraitLangItem,      \"coerce_unsized\",          coerce_unsized_trait;\n+\n     AddTraitLangItem,                \"add\",                     add_trait;\n     SubTraitLangItem,                \"sub\",                     sub_trait;\n     MulTraitLangItem,                \"mul\",                     mul_trait;"}, {"sha": "2b82987480d6ea70ad5dbc3ef7fac4153a22000e", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 52, "deletions": 4, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -15,8 +15,12 @@ use super::{\n     Obligation,\n     ObligationCauseCode,\n     OutputTypeParameterMismatch,\n+    TraitNotObjectSafe,\n     PredicateObligation,\n     SelectionError,\n+    ObjectSafetyViolation,\n+    MethodViolationCode,\n+    object_safety_violations,\n };\n \n use fmt_macros::{Parser, Piece, Position};\n@@ -252,6 +256,54 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                     note_obligation_cause(infcx, obligation);\n             }\n         }\n+\n+        TraitNotObjectSafe(did) => {\n+            span_err!(infcx.tcx.sess, obligation.cause.span, E0038,\n+                \"cannot convert to a trait object because trait `{}` is not object-safe\",\n+                ty::item_path_str(infcx.tcx, did));\n+\n+            for violation in object_safety_violations(infcx.tcx, did) {\n+                match violation {\n+                    ObjectSafetyViolation::SizedSelf => {\n+                        infcx.tcx.sess.span_note(\n+                            obligation.cause.span,\n+                            \"the trait cannot require that `Self : Sized`\");\n+                    }\n+\n+                    ObjectSafetyViolation::SupertraitSelf => {\n+                        infcx.tcx.sess.span_note(\n+                            obligation.cause.span,\n+                            \"the trait cannot use `Self` as a type parameter \\\n+                            in the supertrait listing\");\n+                    }\n+\n+                    ObjectSafetyViolation::Method(method,\n+                            MethodViolationCode::StaticMethod) => {\n+                        infcx.tcx.sess.span_note(\n+                            obligation.cause.span,\n+                            &format!(\"method `{}` has no receiver\",\n+                                    method.name.user_string(infcx.tcx)));\n+                    }\n+\n+                    ObjectSafetyViolation::Method(method,\n+                            MethodViolationCode::ReferencesSelf) => {\n+                        infcx.tcx.sess.span_note(\n+                            obligation.cause.span,\n+                            &format!(\"method `{}` references the `Self` type \\\n+                                    in its arguments or return type\",\n+                                    method.name.user_string(infcx.tcx)));\n+                    }\n+\n+                    ObjectSafetyViolation::Method(method,\n+                            MethodViolationCode::Generic) => {\n+                        infcx.tcx.sess.span_note(\n+                            obligation.cause.span,\n+                            &format!(\"method `{}` has generic type parameters\",\n+                                    method.name.user_string(infcx.tcx)));\n+                    }\n+                }\n+            }\n+        }\n     }\n }\n \n@@ -403,10 +455,6 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n                        \"only the last field of a struct or enum variant \\\n                        may have a dynamically sized type\")\n         }\n-        ObligationCauseCode::ObjectSized => {\n-            span_note!(tcx.sess, cause_span,\n-                       \"only sized types can be made into objects\");\n-        }\n         ObligationCauseCode::SharedStatic => {\n             span_note!(tcx.sess, cause_span,\n                        \"shared static variables must have a type that implements `Sync`\");"}, {"sha": "fe61bb5e4ea6f7b0841bf978abd26ba4e6904ccf", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -28,6 +28,7 @@ use util::ppaux::Repr;\n \n pub use self::error_reporting::report_fulfillment_errors;\n pub use self::error_reporting::report_overflow_error;\n+pub use self::error_reporting::report_selection_error;\n pub use self::error_reporting::suggest_new_overflow_limit;\n pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n@@ -48,6 +49,7 @@ pub use self::select::{MethodMatchedData}; // intentionally don't export variant\n pub use self::util::elaborate_predicates;\n pub use self::util::get_vtable_index_of_object_method;\n pub use self::util::trait_ref_for_builtin_bound;\n+pub use self::util::predicate_for_trait_def;\n pub use self::util::supertraits;\n pub use self::util::Supertraits;\n pub use self::util::supertrait_def_ids;\n@@ -121,9 +123,6 @@ pub enum ObligationCauseCode<'tcx> {\n     // Types of fields (other than the last) in a struct must be sized.\n     FieldSized,\n \n-    // Only Sized types can be made into objects\n-    ObjectSized,\n-\n     // static items must have `Sync` type\n     SharedStatic,\n \n@@ -159,6 +158,7 @@ pub enum SelectionError<'tcx> {\n     OutputTypeParameterMismatch(ty::PolyTraitRef<'tcx>,\n                                 ty::PolyTraitRef<'tcx>,\n                                 ty::type_err<'tcx>),\n+    TraitNotObjectSafe(ast::DefId),\n }\n \n pub struct FulfillmentError<'tcx> {\n@@ -536,7 +536,9 @@ impl<'tcx, N> Vtable<'tcx, N> {\n         }\n     }\n \n-    pub fn map_nested<M, F>(&self, op: F) -> Vtable<'tcx, M> where F: FnMut(&N) -> M {\n+    pub fn map_nested<M, F>(&self, op: F) -> Vtable<'tcx, M> where\n+        F: FnMut(&N) -> M,\n+    {\n         match *self {\n             VtableImpl(ref i) => VtableImpl(i.map_nested(op)),\n             VtableDefaultImpl(ref t) => VtableDefaultImpl(t.map_nested(op)),"}, {"sha": "2541bba5d9a1f750c5396a47d6d9c7c57b2c7096", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 236, "deletions": 7, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -25,6 +25,8 @@ use super::{PredicateObligation, TraitObligation, ObligationCause};\n use super::report_overflow_error;\n use super::{ObligationCauseCode, BuiltinDerivedObligation, ImplDerivedObligation};\n use super::{SelectionError, Unimplemented, OutputTypeParameterMismatch};\n+use super::{ObjectCastObligation, Obligation};\n+use super::TraitNotObjectSafe;\n use super::Selection;\n use super::SelectionResult;\n use super::{VtableBuiltin, VtableImpl, VtableParam, VtableClosure,\n@@ -35,7 +37,7 @@ use super::util;\n \n use middle::fast_reject;\n use middle::subst::{Subst, Substs, TypeSpace, VecPerParamSpace};\n-use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n+use middle::ty::{self, AsPredicate, RegionEscape, ToPolyTraitRef, Ty};\n use middle::infer;\n use middle::infer::{InferCtxt, TypeFreshener};\n use middle::ty_fold::TypeFoldable;\n@@ -207,6 +209,8 @@ enum SelectionCandidate<'tcx> {\n \n     BuiltinObjectCandidate,\n \n+    BuiltinUnsizeCandidate,\n+\n     ErrorCandidate,\n }\n \n@@ -904,6 +908,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 try!(self.assemble_builtin_bound_candidates(bound, stack, &mut candidates));\n             }\n \n+            None if self.tcx().lang_items.unsize_trait() ==\n+                    Some(obligation.predicate.def_id()) => {\n+                self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n+            }\n+\n             Some(ty::BoundSend) |\n             Some(ty::BoundSync) |\n             None => {\n@@ -1356,6 +1365,64 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }).unwrap();\n     }\n \n+    /// Search for unsizing that might apply to `obligation`.\n+    fn assemble_candidates_for_unsizing(&mut self,\n+                                        obligation: &TraitObligation<'tcx>,\n+                                        candidates: &mut SelectionCandidateSet<'tcx>) {\n+        // TODO is it Ok to skip the binder here?\n+        let source = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n+        let target = self.infcx.shallow_resolve(obligation.predicate.0.input_types()[0]);\n+\n+        debug!(\"assemble_candidates_for_unsizing(source={}, target={})\",\n+               source.repr(self.tcx()), target.repr(self.tcx()));\n+\n+        let may_apply = match (&source.sty, &target.sty) {\n+            // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n+            (&ty::ty_trait(ref data_a), &ty::ty_trait(ref data_b)) => {\n+                // Upcasts permit two things:\n+                //\n+                // 1. Dropping builtin bounds, e.g. `Foo+Send` to `Foo`\n+                // 2. Tightening the region bound, e.g. `Foo+'a` to `Foo+'b` if `'a : 'b`\n+                //\n+                // Note that neither of these changes requires any\n+                // change at runtime.  Eventually this will be\n+                // generalized.\n+                //\n+                // We always upcast when we can because of reason\n+                // #2 (region bounds).\n+                data_a.principal.def_id() == data_a.principal.def_id() &&\n+                data_a.bounds.builtin_bounds.is_superset(&data_b.bounds.builtin_bounds)\n+            }\n+\n+            // T -> Trait.\n+            (_, &ty::ty_trait(_)) => true,\n+\n+            // Ambiguous handling is below T -> Trait, because inference\n+            // variables can still implement Unsize<Trait> and nested\n+            // obligations will have the final say (likely deferred).\n+            (&ty::ty_infer(ty::TyVar(_)), _) |\n+            (_, &ty::ty_infer(ty::TyVar(_))) => {\n+                debug!(\"assemble_candidates_for_unsizing: ambiguous\");\n+                candidates.ambiguous = true;\n+                false\n+            }\n+\n+            // [T; n] -> [T].\n+            (&ty::ty_vec(_, Some(_)), &ty::ty_vec(_, None)) => true,\n+\n+            // Struct<T> -> Struct<U>.\n+            (&ty::ty_struct(def_id_a, _), &ty::ty_struct(def_id_b, _)) => {\n+                def_id_a == def_id_b\n+            }\n+\n+            _ => false\n+        };\n+\n+        if may_apply {\n+            candidates.vec.push(BuiltinUnsizeCandidate);\n+        }\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // WINNOW\n     //\n@@ -1427,6 +1494,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 &ClosureCandidate(..) |\n                 &FnPointerCandidate(..) |\n                 &BuiltinObjectCandidate(..) |\n+                &&BuiltinUnsizeCandidate(..) |\n                 &DefaultImplObjectCandidate(..) |\n                 &BuiltinCandidate(..) => {\n                     // We have a where-clause so don't go around looking\n@@ -1855,11 +1923,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                   obligation.recursion_depth + 1,\n                                                   &skol_ty);\n                 let skol_obligation =\n-                    try!(util::predicate_for_trait_def(self.tcx(),\n-                                                       derived_cause.clone(),\n-                                                       trait_def_id,\n-                                                       obligation.recursion_depth + 1,\n-                                                       normalized_ty));\n+                    util::predicate_for_trait_def(self.tcx(),\n+                                                  derived_cause.clone(),\n+                                                  trait_def_id,\n+                                                  obligation.recursion_depth + 1,\n+                                                  normalized_ty,\n+                                                  vec![]);\n                 obligations.push(skol_obligation);\n                 Ok(self.infcx().plug_leaks(skol_map, snapshot, &obligations))\n             })\n@@ -1949,6 +2018,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.confirm_projection_candidate(obligation);\n                 Ok(VtableParam(Vec::new()))\n             }\n+\n+            BuiltinUnsizeCandidate => {\n+                let data = try!(self.confirm_builtin_unsize_candidate(obligation));\n+                Ok(VtableBuiltin(data))\n+            }\n         }\n     }\n \n@@ -2322,6 +2396,159 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n+    fn confirm_builtin_unsize_candidate(&mut self,\n+                                        obligation: &TraitObligation<'tcx>,)\n+                                        -> Result<VtableBuiltinData<PredicateObligation<'tcx>>,\n+                                                  SelectionError<'tcx>> {\n+        let tcx = self.tcx();\n+\n+        // TODO is this skip_binder Ok?\n+        let source = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n+        let target = self.infcx.shallow_resolve(obligation.predicate.0.input_types()[0]);\n+\n+        debug!(\"confirm_builtin_unsize_candidate(source={}, target={})\",\n+               source.repr(tcx), target.repr(tcx));\n+\n+        let mut nested = vec![];\n+        match (&source.sty, &target.sty) {\n+            // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n+            (&ty::ty_trait(ref data_a), &ty::ty_trait(ref data_b)) => {\n+                // See assemble_candidates_for_unsizing for more info.\n+                let bounds = ty::ExistentialBounds {\n+                    region_bound: data_b.bounds.region_bound,\n+                    builtin_bounds: data_b.bounds.builtin_bounds,\n+                    projection_bounds: data_a.bounds.projection_bounds.clone(),\n+                };\n+\n+                let new_trait = ty::mk_trait(tcx, data_a.principal.clone(), bounds);\n+                let origin = infer::Misc(obligation.cause.span);\n+                if self.infcx.sub_types(false, origin, new_trait, target).is_err() {\n+                    return Err(Unimplemented);\n+                }\n+\n+                // Register one obligation for 'a: 'b.\n+                let cause = ObligationCause::new(obligation.cause.span,\n+                                                 obligation.cause.body_id,\n+                                                 ObjectCastObligation(target));\n+                let outlives = ty::OutlivesPredicate(data_a.bounds.region_bound,\n+                                                     data_b.bounds.region_bound);\n+                nested.push(Obligation::with_depth(cause,\n+                                                   obligation.recursion_depth + 1,\n+                                                   ty::Binder(outlives).as_predicate()));\n+            }\n+\n+            // T -> Trait.\n+            (_, &ty::ty_trait(ref data)) => {\n+                let object_did = data.principal_def_id();\n+                if !object_safety::is_object_safe(tcx, object_did) {\n+                    return Err(TraitNotObjectSafe(object_did));\n+                }\n+\n+                let cause = ObligationCause::new(obligation.cause.span,\n+                                                 obligation.cause.body_id,\n+                                                 ObjectCastObligation(target));\n+                let mut push = |predicate| {\n+                    nested.push(Obligation::with_depth(cause.clone(),\n+                                                       obligation.recursion_depth + 1,\n+                                                       predicate));\n+                };\n+\n+                // Create the obligation for casting from T to Trait.\n+                push(data.principal_trait_ref_with_self_ty(tcx, source).as_predicate());\n+\n+                // We can only make objects from sized types.\n+                let mut builtin_bounds = data.bounds.builtin_bounds;\n+                builtin_bounds.insert(ty::BoundSized);\n+\n+                // Create additional obligations for all the various builtin\n+                // bounds attached to the object cast. (In other words, if the\n+                // object type is Foo+Send, this would create an obligation\n+                // for the Send check.)\n+                for bound in &builtin_bounds {\n+                    if let Ok(tr) = util::trait_ref_for_builtin_bound(tcx, bound, source) {\n+                        push(tr.as_predicate());\n+                    } else {\n+                        return Err(Unimplemented);\n+                    }\n+                }\n+\n+                // Create obligations for the projection predicates.\n+                for bound in data.projection_bounds_with_self_ty(tcx, source) {\n+                    push(bound.as_predicate());\n+                }\n+\n+                // If the type is `Foo+'a`, ensures that the type\n+                // being cast to `Foo+'a` outlives `'a`:\n+                let outlives = ty::OutlivesPredicate(source,\n+                                                     data.bounds.region_bound);\n+                push(ty::Binder(outlives).as_predicate());\n+            }\n+\n+            // [T; n] -> [T].\n+            (&ty::ty_vec(a, Some(_)), &ty::ty_vec(b, None)) => {\n+                let origin = infer::Misc(obligation.cause.span);\n+                if self.infcx.sub_types(false, origin, a, b).is_err() {\n+                    return Err(Unimplemented);\n+                }\n+            }\n+\n+            // Struct<T> -> Struct<U>.\n+            (&ty::ty_struct(def_id, substs_a), &ty::ty_struct(_, substs_b)) => {\n+                let fields = ty::lookup_struct_fields(tcx, def_id).iter().map(|f| {\n+                    ty::lookup_field_type_unsubstituted(tcx, def_id, f.id)\n+                }).collect::<Vec<_>>();\n+\n+                // The last field of the structure has to exist and be a\n+                // type parameter (for now, to avoid tracking edge cases).\n+                let i = if let Some(&ty::ty_param(p)) = fields.last().map(|ty| &ty.sty) {\n+                    assert!(p.space == TypeSpace);\n+                    p.idx as usize\n+                } else {\n+                    return Err(Unimplemented);\n+                };\n+\n+                // Replace the type parameter chosen for unsizing with\n+                // ty_err and ensure it does not affect any other fields.\n+                // This could be checked after type collection for any struct\n+                // with a potentially unsized trailing field.\n+                let mut new_substs = substs_a.clone();\n+                new_substs.types.get_mut_slice(TypeSpace)[i] = tcx.types.err;\n+                for &ty in fields.init() {\n+                    if ty::type_is_error(ty.subst(tcx, &new_substs)) {\n+                        return Err(Unimplemented);\n+                    }\n+                }\n+\n+                // Extract T and U from Struct<T> and Struct<U>.\n+                let inner_source = *substs_a.types.get(TypeSpace, i);\n+                let inner_target = *substs_b.types.get(TypeSpace, i);\n+\n+                // Check that all the source structure with the unsized\n+                // type parameter is a subtype of the target.\n+                new_substs.types.get_mut_slice(TypeSpace)[i] = inner_target;\n+                let new_struct = ty::mk_struct(tcx, def_id, tcx.mk_substs(new_substs));\n+                let origin = infer::Misc(obligation.cause.span);\n+                if self.infcx.sub_types(false, origin, new_struct, target).is_err() {\n+                    return Err(Unimplemented);\n+                }\n+\n+                // Construct the nested T: Unsize<U> predicate.\n+                nested.push(util::predicate_for_trait_def(tcx,\n+                    obligation.cause.clone(),\n+                    obligation.predicate.def_id(),\n+                    obligation.recursion_depth + 1,\n+                    inner_source,\n+                    vec![inner_target]));\n+            }\n+\n+            _ => unreachable!()\n+        };\n+\n+        Ok(VtableBuiltinData {\n+            nested: VecPerParamSpace::new(nested, vec![], vec![])\n+        })\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // Matching\n     //\n@@ -2683,6 +2910,7 @@ impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n             ErrorCandidate => format!(\"ErrorCandidate\"),\n             BuiltinCandidate(b) => format!(\"BuiltinCandidate({:?})\", b),\n             BuiltinObjectCandidate => format!(\"BuiltinObjectCandidate\"),\n+            BuiltinUnsizeCandidate => format!(\"BuiltinUnsizeCandidate\"),\n             ParamCandidate(ref a) => format!(\"ParamCandidate({})\", a.repr(tcx)),\n             ImplCandidate(a) => format!(\"ImplCandidate({})\", a.repr(tcx)),\n             DefaultImplCandidate(t) => format!(\"DefaultImplCandidate({:?})\", t),\n@@ -2756,7 +2984,8 @@ impl<'tcx> EvaluationResult<'tcx> {\n         match *self {\n             EvaluatedToOk |\n             EvaluatedToAmbig |\n-            EvaluatedToErr(OutputTypeParameterMismatch(..)) =>\n+            EvaluatedToErr(OutputTypeParameterMismatch(..)) |\n+            EvaluatedToErr(TraitNotObjectSafe(_)) =>\n                 true,\n \n             EvaluatedToErr(Unimplemented) =>"}, {"sha": "ea4bc029ed6595fca0c73149c51a5a289d9bd6cc", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -356,27 +356,28 @@ pub fn predicate_for_trait_ref<'tcx>(\n     cause: ObligationCause<'tcx>,\n     trait_ref: ty::TraitRef<'tcx>,\n     recursion_depth: usize)\n-    -> Result<PredicateObligation<'tcx>, ErrorReported>\n+    -> PredicateObligation<'tcx>\n {\n-    Ok(Obligation {\n+    Obligation {\n         cause: cause,\n         recursion_depth: recursion_depth,\n         predicate: trait_ref.as_predicate(),\n-    })\n+    }\n }\n \n pub fn predicate_for_trait_def<'tcx>(\n     tcx: &ty::ctxt<'tcx>,\n     cause: ObligationCause<'tcx>,\n     trait_def_id: ast::DefId,\n     recursion_depth: usize,\n-    param_ty: Ty<'tcx>)\n-    -> Result<PredicateObligation<'tcx>, ErrorReported>\n+    param_ty: Ty<'tcx>,\n+    ty_params: Vec<Ty<'tcx>>)\n+    -> PredicateObligation<'tcx>\n {\n     let trait_ref = ty::TraitRef {\n         def_id: trait_def_id,\n-        substs: tcx.mk_substs(Substs::empty().with_self_ty(param_ty))\n-    };\n+        substs: tcx.mk_substs(Substs::new_trait(ty_params, vec![], param_ty))\n+    });\n     predicate_for_trait_ref(cause, trait_ref, recursion_depth)\n }\n \n@@ -389,7 +390,7 @@ pub fn predicate_for_builtin_bound<'tcx>(\n     -> Result<PredicateObligation<'tcx>, ErrorReported>\n {\n     let trait_ref = try!(trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty));\n-    predicate_for_trait_ref(cause, trait_ref, recursion_depth)\n+    Ok(predicate_for_trait_ref(cause, trait_ref, recursion_depth))\n }\n \n /// Cast a trait reference into a reference to one of its super\n@@ -561,6 +562,10 @@ impl<'tcx> Repr<'tcx> for super::SelectionError<'tcx> {\n                         a.repr(tcx),\n                         b.repr(tcx),\n                         c.repr(tcx)),\n+\n+            super::TraitNotObjectSafe(ref tr) =>\n+                format!(\"TraitNotObjectSafe({})\",\n+                        tr.repr(tcx))\n         }\n     }\n }"}, {"sha": "961f8a79324114b372da92cdcdfb3a098b12762c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 45, "deletions": 7, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -404,6 +404,12 @@ pub enum AutoRef<'tcx> {\n     AutoUnsafe(ast::Mutability),\n }\n \n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+pub enum CustomCoerceUnsized {\n+    /// Records the index of the field being coerced.\n+    Struct(usize)\n+}\n+\n #[derive(Clone, Copy, RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Debug)]\n pub struct param_index {\n     pub space: subst::ParamSpace,\n@@ -818,6 +824,9 @@ pub struct ctxt<'tcx> {\n \n     /// Maps Expr NodeId's to their constant qualification.\n     pub const_qualif_map: RefCell<NodeMap<check_const::ConstQualif>>,\n+\n+    /// Caches CoerceUnsized kinds for impls on custom types.\n+    pub custom_coerce_unsized_kinds: RefCell<DefIdMap<CustomCoerceUnsized>>,\n }\n \n impl<'tcx> ctxt<'tcx> {\n@@ -2809,6 +2818,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         type_impls_copy_cache: RefCell::new(HashMap::new()),\n         type_impls_sized_cache: RefCell::new(HashMap::new()),\n         const_qualif_map: RefCell::new(NodeMap()),\n+        custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n    }\n }\n \n@@ -5351,6 +5361,26 @@ pub fn trait_impl_polarity<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n      }\n }\n \n+pub fn custom_coerce_unsized_kind<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n+                                        -> CustomCoerceUnsized {\n+    memoized(&cx.custom_coerce_unsized_kinds, did, |did: DefId| {\n+        let (kind, src) = if did.krate != ast::LOCAL_CRATE {\n+            (csearch::get_custom_coerce_unsized_kind(cx, did), \"external\")\n+        } else {\n+            (None, \"local\")\n+        };\n+\n+        match kind {\n+            Some(kind) => kind,\n+            None => {\n+                cx.sess.bug(&format!(\"custom_coerce_unsized_kind: \\\n+                                      {} impl `{}` is missing its kind\",\n+                                     src, item_path_str(cx, did)));\n+            }\n+        }\n+    })\n+}\n+\n pub fn impl_or_trait_item<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                                 -> ImplOrTraitItem<'tcx> {\n     lookup_locally_or_in_crate_store(\"impl_or_trait_items\",\n@@ -6012,20 +6042,28 @@ pub fn lookup_repr_hints(tcx: &ctxt, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n     })\n }\n \n+// Look up a field ID, whether or not it's local\n+pub fn lookup_field_type_unsubstituted<'tcx>(tcx: &ctxt<'tcx>,\n+                                             struct_id: DefId,\n+                                             id: DefId)\n+                                             -> Ty<'tcx> {\n+    if id.krate == ast::LOCAL_CRATE {\n+        node_id_to_type(tcx, id.node)\n+    } else {\n+        let mut tcache = tcx.tcache.borrow_mut();\n+        tcache.entry(id).or_insert_with(|| csearch::get_field_type(tcx, struct_id, id)).ty\n+    }\n+}\n+\n+\n // Look up a field ID, whether or not it's local\n // Takes a list of type substs in case the struct is generic\n pub fn lookup_field_type<'tcx>(tcx: &ctxt<'tcx>,\n                                struct_id: DefId,\n                                id: DefId,\n                                substs: &Substs<'tcx>)\n                                -> Ty<'tcx> {\n-    let ty = if id.krate == ast::LOCAL_CRATE {\n-        node_id_to_type(tcx, id.node)\n-    } else {\n-        let mut tcache = tcx.tcache.borrow_mut();\n-        tcache.entry(id).or_insert_with(|| csearch::get_field_type(tcx, struct_id, id)).ty\n-    };\n-    ty.subst(tcx, substs)\n+    lookup_field_type_unsubstituted(tcx, struct_id, id).subst(tcx, substs)\n }\n \n // Look up the list of field names and IDs for a given struct."}, {"sha": "0343571562faaa1ab7f40e0a0826d783505464a6", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 138, "deletions": 62, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -56,8 +56,10 @@ use back::abi;\n use llvm::{self, ValueRef};\n use middle::check_const;\n use middle::def;\n+use middle::lang_items::CoerceUnsizedTraitLangItem;\n use middle::mem_categorization::Typer;\n-use middle::subst::{self, Substs};\n+use middle::subst::{Subst, Substs, VecPerParamSpace};\n+use middle::traits;\n use trans::{_match, adt, asm, base, callee, closure, consts, controlflow};\n use trans::base::*;\n use trans::build::*;\n@@ -304,7 +306,7 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n                                 source: Ty<'tcx>,\n                                 target: Ty<'tcx>,\n                                 old_info: Option<ValueRef>,\n-                                param_substs: &'tcx subst::Substs<'tcx>)\n+                                param_substs: &'tcx Substs<'tcx>)\n                                 -> ValueRef {\n     let (source, target) = ty::struct_lockstep_tails(ccx.tcx(), source, target);\n     match (&source.sty, &target.sty) {\n@@ -390,81 +392,155 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // (You might think there is a more elegant way to do this than a\n             // skip_reborrows bool, but then you remember that the borrow checker exists).\n             if skip_reborrows == 0 && adj.autoref.is_some() {\n-                datum = unpack_datum!(bcx, apply_autoref(bcx, expr, datum));\n+                if !type_is_sized(bcx.tcx(), datum.ty) {\n+                    // Arrange cleanup\n+                    let lval = unpack_datum!(bcx,\n+                        datum.to_lvalue_datum(bcx, \"ref_fat_ptr\", expr.id));\n+                    datum = unpack_datum!(bcx, ref_fat_ptr(bcx, lval));\n+                } else {\n+                    datum = unpack_datum!(bcx, auto_ref(bcx, datum, expr));\n+                }\n             }\n \n             if let Some(target) = adj.unsize {\n-                datum = unpack_datum!(bcx, unsize_pointer(bcx, datum,\n-                                                          bcx.monomorphize(&target)));\n+                // We do not arrange cleanup ourselves; if we already are an\n+                // L-value, then cleanup will have already been scheduled (and\n+                // the `datum.to_rvalue_datum` call below will emit code to zero\n+                // the drop flag when moving out of the L-value). If we are an\n+                // R-value, then we do not need to schedule cleanup.\n+                let source_datum = unpack_datum!(bcx,\n+                    datum.to_rvalue_datum(bcx, \"__coerce_source\"));\n+\n+                let target = bcx.monomorphize(&target);\n+                let llty = type_of::type_of(bcx.ccx(), target);\n+\n+                // HACK(eddyb) get around issues with lifetime intrinsics.\n+                let scratch = alloca_no_lifetime(bcx, llty, \"__coerce_target\");\n+                let target_datum = Datum::new(scratch, target,\n+                                              Rvalue::new(ByRef));\n+                bcx = coerce_unsized(bcx, expr.span, source_datum, target_datum);\n+                datum = Datum::new(scratch, target,\n+                                   RvalueExpr(Rvalue::new(ByRef)));\n             }\n         }\n     }\n     debug!(\"after adjustments, datum={}\", datum.to_string(bcx.ccx()));\n-    return DatumBlock::new(bcx, datum);\n+    DatumBlock::new(bcx, datum)\n+}\n \n-    fn apply_autoref<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                 expr: &ast::Expr,\n-                                 datum: Datum<'tcx, Expr>)\n-                                 -> DatumBlock<'blk, 'tcx, Expr> {\n-        let mut bcx = bcx;\n+fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              span: codemap::Span,\n+                              source: Datum<'tcx, Rvalue>,\n+                              target: Datum<'tcx, Rvalue>)\n+                              -> Block<'blk, 'tcx> {\n+    let mut bcx = bcx;\n+    debug!(\"coerce_unsized({} -> {})\",\n+           source.to_string(bcx.ccx()),\n+           target.to_string(bcx.ccx()));\n+\n+    match (&source.ty.sty, &target.ty.sty) {\n+        (&ty::ty_uniq(a), &ty::ty_uniq(b)) |\n+        (&ty::ty_rptr(_, ty::mt { ty: a, .. }), &ty::ty_rptr(_, ty::mt { ty: b, .. })) |\n+        (&ty::ty_rptr(_, ty::mt { ty: a, .. }), &ty::ty_ptr(ty::mt { ty: b, .. })) |\n+        (&ty::ty_ptr(ty::mt { ty: a, .. }), &ty::ty_ptr(ty::mt { ty: b, .. })) => {\n+            let (inner_source, inner_target) = (a, b);\n+\n+            let (base, old_info) = if !type_is_sized(bcx.tcx(), inner_source) {\n+                // Normally, the source is a thin pointer and we are\n+                // adding extra info to make a fat pointer. The exception\n+                // is when we are upcasting an existing object fat pointer\n+                // to use a different vtable. In that case, we want to\n+                // load out the original data pointer so we can repackage\n+                // it.\n+                (Load(bcx, get_dataptr(bcx, source.val)),\n+                Some(Load(bcx, get_len(bcx, source.val))))\n+            } else {\n+                let val = if source.kind.is_by_ref() {\n+                    load_ty(bcx, source.val, source.ty)\n+                } else {\n+                    source.val\n+                };\n+                (val, None)\n+            };\n \n-        if !type_is_sized(bcx.tcx(), datum.ty) {\n-            // Arrange cleanup\n-            let lval = unpack_datum!(bcx,\n-                datum.to_lvalue_datum(bcx, \"ref_fat_ptr\", expr.id));\n-            ref_fat_ptr(bcx, lval)\n-        } else {\n-            auto_ref(bcx, datum, expr)\n+            let info = unsized_info(bcx.ccx(), inner_source, inner_target,\n+                                    old_info, bcx.fcx.param_substs);\n+\n+            // Compute the base pointer. This doesn't change the pointer value,\n+            // but merely its type.\n+            let ptr_ty = type_of::in_memory_type_of(bcx.ccx(), inner_target).ptr_to();\n+            let base = PointerCast(bcx, base, ptr_ty);\n+\n+            Store(bcx, base, get_dataptr(bcx, target.val));\n+            Store(bcx, info, get_len(bcx, target.val));\n         }\n-    }\n \n-    fn unsize_pointer<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                  datum: Datum<'tcx, Expr>,\n-                                  target: Ty<'tcx>)\n-                                  -> DatumBlock<'blk, 'tcx, Expr> {\n-        let mut bcx = bcx;\n-        let unsized_ty = ty::deref(target, true)\n-            .expect(\"expr::unsize got non-pointer target type\").ty;\n-        debug!(\"unsize_lvalue(unsized_ty={})\", unsized_ty.repr(bcx.tcx()));\n-\n-        // We do not arrange cleanup ourselves; if we already are an\n-        // L-value, then cleanup will have already been scheduled (and\n-        // the `datum.to_rvalue_datum` call below will emit code to zero\n-        // the drop flag when moving out of the L-value). If we are an\n-        // R-value, then we do not need to schedule cleanup.\n-        let datum = unpack_datum!(bcx, datum.to_rvalue_datum(bcx, \"__unsize_ref\"));\n-\n-        let pointee_ty = ty::deref(datum.ty, true)\n-            .expect(\"expr::unsize got non-pointer datum type\").ty;\n-        let (base, old_info) = if !type_is_sized(bcx.tcx(), pointee_ty) {\n-            // Normally, the source is a thin pointer and we are\n-            // adding extra info to make a fat pointer. The exception\n-            // is when we are upcasting an existing object fat pointer\n-            // to use a different vtable. In that case, we want to\n-            // load out the original data pointer so we can repackage\n-            // it.\n-            (Load(bcx, get_dataptr(bcx, datum.val)),\n-             Some(Load(bcx, get_len(bcx, datum.val))))\n-        } else {\n-            (datum.val, None)\n-        };\n+        // This can be extended to enums and tuples in the future.\n+        // (&ty::ty_enum(def_id_a, substs_a), &ty::ty_enum(def_id_b, substs_b)) |\n+        (&ty::ty_struct(def_id_a, substs_a), &ty::ty_struct(def_id_b, substs_b)) => {\n+            assert_eq!(def_id_a, def_id_b);\n \n-        let info = unsized_info(bcx.ccx(), pointee_ty, unsized_ty,\n-                                old_info, bcx.fcx.param_substs);\n+            // The target is already by-ref because it's to be written to.\n+            let source = unpack_datum!(bcx, source.to_ref_datum(bcx));\n+            assert!(target.kind.is_by_ref());\n \n-        // Compute the base pointer. This doesn't change the pointer value,\n-        // but merely its type.\n-        let ptr_ty = type_of::in_memory_type_of(bcx.ccx(), unsized_ty).ptr_to();\n-        let base = PointerCast(bcx, base, ptr_ty);\n+            let trait_substs = Substs::erased(VecPerParamSpace::new(vec![target.ty],\n+                                                                    vec![source.ty],\n+                                                                    Vec::new()));\n+            let trait_ref = ty::Binder(Rc::new(ty::TraitRef {\n+                def_id: langcall(bcx, Some(span), \"coercion\",\n+                                 CoerceUnsizedTraitLangItem),\n+                substs: bcx.tcx().mk_substs(trait_substs)\n+            }));\n+\n+            let kind = match fulfill_obligation(bcx.ccx(), span, trait_ref) {\n+                traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {\n+                    ty::custom_coerce_unsized_kind(bcx.tcx(), impl_def_id)\n+                }\n+                vtable => {\n+                    bcx.sess().span_bug(span, &format!(\"invalid CoerceUnsized vtable: {}\",\n+                                                       vtable.repr(bcx.tcx())));\n+                }\n+            };\n \n-        let llty = type_of::type_of(bcx.ccx(), target);\n-        // HACK(eddyb) get around issues with lifetime intrinsics.\n-        let scratch = alloca_no_lifetime(bcx, llty, \"__fat_ptr\");\n-        Store(bcx, base, get_dataptr(bcx, scratch));\n-        Store(bcx, info, get_len(bcx, scratch));\n+            let repr_source = adt::represent_type(bcx.ccx(), source.ty);\n+            let repr_target = adt::represent_type(bcx.ccx(), target.ty);\n+            let fields = ty::lookup_struct_fields(bcx.tcx(), def_id_a);\n \n-        DatumBlock::new(bcx, Datum::new(scratch, target, RvalueExpr(Rvalue::new(ByRef))))\n+            let coerce_index = match kind {\n+                ty::CustomCoerceUnsized::Struct(i) => i\n+            };\n+            assert!(coerce_index < fields.len());\n+\n+            for (i, field) in fields.iter().enumerate() {\n+                let ll_source = adt::trans_field_ptr(bcx, &repr_source, source.val, 0, i);\n+                let ll_target = adt::trans_field_ptr(bcx, &repr_target, target.val, 0, i);\n+\n+                let ty = ty::lookup_field_type_unsubstituted(bcx.tcx(),\n+                                                             def_id_a,\n+                                                             field.id);\n+                let field_source = ty.subst(bcx.tcx(), substs_a);\n+                let field_target = ty.subst(bcx.tcx(), substs_b);\n+\n+                // If this is the field we need to coerce, recurse on it.\n+                if i == coerce_index {\n+                    coerce_unsized(bcx, span,\n+                                   Datum::new(ll_source, field_source,\n+                                              Rvalue::new(ByRef)),\n+                                   Datum::new(ll_target, field_target,\n+                                              Rvalue::new(ByRef)));\n+                } else {\n+                    // Otherwise, simply copy the data from the source.\n+                    assert_eq!(field_source, field_target);\n+                    memcpy_ty(bcx, ll_target, ll_source, field_source);\n+                }\n+            }\n+        }\n+        _ => bcx.sess().bug(&format!(\"coerce_unsized: invalid coercion {} -> {}\",\n+                                     source.ty.repr(bcx.tcx()),\n+                                     target.ty.repr(bcx.tcx())))\n     }\n+    bcx\n }\n \n /// Translates an expression in \"lvalue\" mode -- meaning that it returns a reference to the memory\n@@ -1178,7 +1254,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn trans_def_fn_unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                          ref_expr: &ast::Expr,\n                                          def: def::Def,\n-                                         param_substs: &'tcx subst::Substs<'tcx>)\n+                                         param_substs: &'tcx Substs<'tcx>)\n                                          -> Datum<'tcx, Rvalue> {\n     let _icx = push_ctxt(\"trans_def_datum_unadjusted\");\n "}, {"sha": "fd1f22e1d9d35864364a43b6161eda4e2df378ff", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -392,8 +392,8 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     bcx.fcx.pop_and_trans_custom_cleanup_scope(bcx, contents_scope)\n }\n \n-fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n-                                     -> (ValueRef, ValueRef) {\n+pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n+                                         -> (ValueRef, ValueRef) {\n     debug!(\"calculate size of DST: {}; with lost info: {}\",\n            bcx.ty_to_string(t), bcx.val_to_string(info));\n     if type_is_sized(bcx.tcx(), t) {"}, {"sha": "951d30c4fb8db3fab13d3c25fcd958f5addee67d", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -326,10 +326,31 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             C_uint(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n         }\n+        (_, \"size_of_val\") => {\n+            let tp_ty = *substs.types.get(FnSpace, 0);\n+            if !type_is_sized(tcx, tp_ty) {\n+                let info = Load(bcx, expr::get_len(bcx, llargs[0]));\n+                let (llsize, _) = glue::size_and_align_of_dst(bcx, tp_ty, info);\n+                llsize\n+            } else {\n+                let lltp_ty = type_of::type_of(ccx, tp_ty);\n+                C_uint(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n+            }\n+        }\n         (_, \"min_align_of\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             C_uint(ccx, type_of::align_of(ccx, tp_ty))\n         }\n+        (_, \"min_align_of_val\") => {\n+            let tp_ty = *substs.types.get(FnSpace, 0);\n+            if !type_is_sized(tcx, tp_ty) {\n+                let info = Load(bcx, expr::get_len(bcx, llargs[0]));\n+                let (_, llalign) = glue::size_and_align_of_dst(bcx, tp_ty, info);\n+                llalign\n+            } else {\n+                C_uint(ccx, type_of::align_of(ccx, tp_ty))\n+            }\n+        }\n         (_, \"pref_align_of\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n@@ -351,6 +372,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             bcx = src.store_to(bcx, llargs[0]);\n             C_nil(ccx)\n         }\n+        (_, \"drop_in_place\") => {\n+            let tp_ty = *substs.types.get(FnSpace, 0);\n+            glue::drop_ty(bcx, llargs[0], tp_ty, call_debug_location);\n+            C_nil(ccx)\n+        }\n         (_, \"type_name\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             let ty_name = token::intern_and_get_ident(&ty_to_string(ccx.tcx(), tp_ty));"}, {"sha": "d33553f3859ee548b790fd57423db5a32499bbac", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 88, "deletions": 174, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -61,25 +61,24 @@\n //! we may want to adjust precisely when coercions occur.\n \n use check::{autoderef, FnCtxt, NoPreference, PreferMutLvalue, UnresolvedTypeAction};\n-use check::vtable;\n \n use middle::infer::{self, Coercion};\n-use middle::subst;\n-use middle::traits;\n+use middle::traits::{self, ObligationCause};\n+use middle::traits::{predicate_for_trait_def, report_selection_error};\n use middle::ty::{AutoDerefRef, AdjustDerefRef};\n use middle::ty::{self, mt, Ty};\n use middle::ty_relate::RelateResult;\n use util::common::indent;\n-use util::ppaux;\n use util::ppaux::Repr;\n \n-use std::cell::Cell;\n+use std::cell::RefCell;\n+use std::collections::VecDeque;\n use syntax::ast;\n \n struct Coerce<'a, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     origin: infer::TypeOrigin,\n-    unsizing_obligation: Cell<Option<Ty<'tcx>>>\n+    unsizing_obligations: RefCell<Vec<traits::PredicateObligation<'tcx>>>,\n }\n \n type CoerceResult<'tcx> = RelateResult<'tcx, Option<ty::AutoAdjustment<'tcx>>>;\n@@ -94,15 +93,6 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         Ok(None) // No coercion required.\n     }\n \n-    fn outlives(&self,\n-                origin: infer::SubregionOrigin<'tcx>,\n-                a: ty::Region,\n-                b: ty::Region)\n-                -> RelateResult<'tcx, ()> {\n-        infer::mk_subr(self.fcx.infcx(), origin, b, a);\n-        Ok(())\n-    }\n-\n     fn unpack_actual_value<T, F>(&self, a: Ty<'tcx>, f: F) -> T where\n         F: FnOnce(Ty<'tcx>) -> T,\n     {\n@@ -248,51 +238,94 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     // or &mut [T, ..n] -> &mut [T]\n     // or &Concrete -> &Trait, etc.\n     fn coerce_unsized(&self,\n-                      a: Ty<'tcx>,\n-                      b: Ty<'tcx>)\n+                      source: Ty<'tcx>,\n+                      target: Ty<'tcx>)\n                       -> CoerceResult<'tcx> {\n-        debug!(\"coerce_unsized(a={}, b={})\",\n-               a.repr(self.tcx()),\n-               b.repr(self.tcx()));\n+        debug!(\"coerce_unsized(source={}, target={})\",\n+               source.repr(self.tcx()),\n+               target.repr(self.tcx()));\n+\n+        let traits = (self.tcx().lang_items.unsize_trait(),\n+                      self.tcx().lang_items.coerce_unsized_trait());\n+        let (unsize_did, coerce_unsized_did) = if let (Some(u), Some(cu)) = traits {\n+            (u, cu)\n+        } else {\n+            debug!(\"Missing Unsize or CoerceUnsized traits\");\n+            return Err(ty::terr_mismatch);\n+        };\n \n         // Note, we want to avoid unnecessary unsizing. We don't want to coerce to\n         // a DST unless we have to. This currently comes out in the wash since\n         // we can't unify [T] with U. But to properly support DST, we need to allow\n-        // that, at which point we will need extra checks on b here.\n+        // that, at which point we will need extra checks on the target here.\n \n-        let (reborrow, target) = match (&a.sty, &b.sty) {\n+        // Handle reborrows before selecting `Source: CoerceUnsized<Target>`.\n+        let (source, reborrow) = match (&source.sty, &target.sty) {\n             (&ty::ty_rptr(_, mt_a), &ty::ty_rptr(_, mt_b)) => {\n-                if let Some(target) = self.unsize_ty(mt_a.ty, mt_b.ty) {\n-                    try!(coerce_mutbls(mt_a.mutbl, mt_b.mutbl));\n-\n-                    let coercion = Coercion(self.origin.span());\n-                    let r_borrow = self.fcx.infcx().next_region_var(coercion);\n-                    let region = self.tcx().mk_region(r_borrow);\n-                    (Some(ty::AutoPtr(region, mt_b.mutbl)), target)\n-                } else {\n-                    return Err(ty::terr_mismatch);\n-                }\n+                try!(coerce_mutbls(mt_a.mutbl, mt_b.mutbl));\n+\n+                let coercion = Coercion(self.origin.span());\n+                let r_borrow = self.fcx.infcx().next_region_var(coercion);\n+                let region = self.tcx().mk_region(r_borrow);\n+                (mt_a.ty, Some(ty::AutoPtr(region, mt_b.mutbl)))\n             }\n             (&ty::ty_rptr(_, mt_a), &ty::ty_ptr(mt_b)) => {\n-                if let Some(target) = self.unsize_ty(mt_a.ty, mt_b.ty) {\n-                    try!(coerce_mutbls(mt_a.mutbl, mt_b.mutbl));\n-                    (Some(ty::AutoUnsafe(mt_b.mutbl)), target)\n-                } else {\n-                    return Err(ty::terr_mismatch);\n-                }\n+                try!(coerce_mutbls(mt_a.mutbl, mt_b.mutbl));\n+                (mt_a.ty, Some(ty::AutoUnsafe(mt_b.mutbl)))\n             }\n-            (&ty::ty_uniq(t_a), &ty::ty_uniq(t_b)) => {\n-                if let Some(target) = self.unsize_ty(t_a, t_b) {\n-                    (None, ty::mk_uniq(self.tcx(), target))\n-                } else {\n+            _ => (source, None)\n+        };\n+        let source = ty::adjust_ty_for_autoref(self.tcx(), source, reborrow);\n+\n+        let mut selcx = traits::SelectionContext::new(self.fcx.infcx(), self.fcx);\n+\n+        // Use a FIFO queue for this custom fulfillment procedure.\n+        let mut queue = VecDeque::new();\n+        let mut leftover_predicates = vec![];\n+\n+        // Create an obligation for `Source: CoerceUnsized<Target>`.\n+        let cause = ObligationCause::misc(self.origin.span(), self.fcx.body_id);\n+        queue.push_back(predicate_for_trait_def(self.tcx(), cause, coerce_unsized_did,\n+                                                0, source, vec![target]));\n+\n+        // Keep resolving `CoerceUnsized` and `Unsize` predicates to avoid\n+        // emitting a coercion in cases like `Foo<$1>` -> `Foo<$2>`, where\n+        // inference might unify those two inner type variables later.\n+        let traits = [coerce_unsized_did, unsize_did];\n+        while let Some(obligation) = queue.pop_front() {\n+            let trait_ref =  match obligation.predicate {\n+                ty::Predicate::Trait(ref tr) if traits.contains(&tr.def_id()) => {\n+                    tr.clone()\n+                }\n+                _ => {\n+                    leftover_predicates.push(obligation);\n+                    continue;\n+                }\n+            };\n+            match selcx.select(&obligation.with(trait_ref)) {\n+                // Uncertain or unimplemented.\n+                Ok(None) | Err(traits::Unimplemented) => {\n                     return Err(ty::terr_mismatch);\n                 }\n+\n+                // Object safety violations or miscellaneous.\n+                Err(err) => {\n+                    report_selection_error(self.fcx.infcx(), &obligation, &err);\n+                    // Treat this like an obligation and follow through\n+                    // with the unsizing - the lack of a coercion should\n+                    // be silent, as it causes a type mismatch later.\n+                }\n+\n+                Ok(Some(vtable)) => {\n+                    vtable.map_move_nested(|o| queue.push_back(o));\n+                }\n             }\n-            _ => return Err(ty::terr_mismatch)\n-        };\n+        }\n+\n+        let mut obligations = self.unsizing_obligations.borrow_mut();\n+        assert!(obligations.is_empty());\n+        *obligations = leftover_predicates;\n \n-        let target = ty::adjust_ty_for_autoref(self.tcx(), target, reborrow);\n-        try!(self.subtype(target, b));\n         let adjustment = AutoDerefRef {\n             autoderefs: if reborrow.is_some() { 1 } else { 0 },\n             autoref: reborrow,\n@@ -302,108 +335,6 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         Ok(Some(AdjustDerefRef(adjustment)))\n     }\n \n-    // Takes a type and returns an unsized version.\n-    // E.g., `[T, ..n]` -> `[T]`.\n-    fn unsize_ty(&self,\n-                 ty_a: Ty<'tcx>,\n-                 ty_b: Ty<'tcx>)\n-                 -> Option<Ty<'tcx>> {\n-        let tcx = self.tcx();\n-\n-        self.unpack_actual_value(ty_a, |a| self.unpack_actual_value(ty_b, |b| {\n-            debug!(\"unsize_ty(a={}, b={})\", a.repr(self.tcx()), b.repr(self.tcx()));\n-            match (&a.sty, &b.sty) {\n-                (&ty::ty_vec(t_a, Some(_)), &ty::ty_vec(_, None)) => {\n-                    Some(ty::mk_vec(tcx, t_a, None))\n-                }\n-                (&ty::ty_trait(ref data_a), &ty::ty_trait(ref data_b)) => {\n-                    // Upcasts permit two things:\n-                    //\n-                    // 1. Dropping builtin bounds, e.g. `Foo+Send` to `Foo`\n-                    // 2. Tightening the region bound, e.g. `Foo+'a` to `Foo+'b` if `'a : 'b`\n-                    //\n-                    // Note that neither of these changes requires any\n-                    // change at runtime.  Eventually this will be\n-                    // generalized.\n-                    //\n-                    // We always upcast when we can because of reason\n-                    // #2 (region bounds).\n-                    if data_a.bounds.builtin_bounds.is_superset(&data_b.bounds.builtin_bounds) {\n-                        // construct a type `a1` which is a version of\n-                        // `a` using the upcast bounds from `b`\n-                        let bounds_a1 = ty::ExistentialBounds {\n-                            // From type b\n-                            region_bound: data_b.bounds.region_bound,\n-                            builtin_bounds: data_b.bounds.builtin_bounds,\n-\n-                            // From type a\n-                            projection_bounds: data_a.bounds.projection_bounds.clone(),\n-                        };\n-                        let ty_a1 = ty::mk_trait(tcx, data_a.principal.clone(), bounds_a1);\n-\n-                        // relate `a1` to `b`\n-                        let result = self.fcx.infcx().commit_if_ok(|_| {\n-                            // it's ok to upcast from Foo+'a to Foo+'b so long as 'a : 'b\n-                            try!(self.outlives(infer::RelateObjectBound(self.origin.span()),\n-                                               data_a.bounds.region_bound,\n-                                               data_b.bounds.region_bound));\n-                            self.subtype(ty_a1, ty_b)\n-                        });\n-\n-                        // if that was successful, we have a coercion\n-                        match result {\n-                            Ok(_) => Some(ty_b),\n-                            Err(_) => None,\n-                        }\n-                    } else {\n-                        None\n-                    }\n-                }\n-                (_, &ty::ty_trait(_)) => {\n-                    assert!(self.unsizing_obligation.get().is_none());\n-                    self.unsizing_obligation.set(Some(a));\n-                    Some(ty_b)\n-                }\n-                (&ty::ty_struct(did_a, substs_a), &ty::ty_struct(did_b, substs_b))\n-                  if did_a == did_b => {\n-                    debug!(\"unsizing a struct\");\n-                    // Try unsizing each type param in turn to see if we end up with ty_b.\n-                    let ty_substs_a = substs_a.types.get_slice(subst::TypeSpace);\n-                    let ty_substs_b = substs_b.types.get_slice(subst::TypeSpace);\n-                    assert!(ty_substs_a.len() == ty_substs_b.len());\n-\n-                    let tps = ty_substs_a.iter().zip(ty_substs_b.iter()).enumerate();\n-                    for (i, (tp_a, tp_b)) in tps {\n-                        if self.subtype(*tp_a, *tp_b).is_ok() {\n-                            continue;\n-                        }\n-                        if let Some(new_tp) = self.unsize_ty(tp_a, tp_b) {\n-                            // Check that the whole types match.\n-                            let mut new_substs = substs_a.clone();\n-                            new_substs.types.get_mut_slice(subst::TypeSpace)[i] = new_tp;\n-                            let ty = ty::mk_struct(tcx, did_a, tcx.mk_substs(new_substs));\n-                            if self.subtype(ty, ty_b).is_err() {\n-                                debug!(\"Unsized type parameter '{}', but still \\\n-                                        could not match types {} and {}\",\n-                                        ppaux::ty_to_string(tcx, tp_a),\n-                                        ppaux::ty_to_string(tcx, ty),\n-                                        ppaux::ty_to_string(tcx, ty_b));\n-                                // We can only unsize a single type parameter, so\n-                                // if we unsize one and it doesn't give us the\n-                                // type we want, then we won't succeed later.\n-                                break;\n-                            }\n-\n-                            return Some(ty);\n-                        }\n-                    }\n-                    None\n-                }\n-                _ => None\n-            }\n-        }))\n-    }\n-\n     fn coerce_from_fn_pointer(&self,\n                            a: Ty<'tcx>,\n                            fn_ty_a: &'tcx ty::BareFnTy<'tcx>,\n@@ -496,41 +427,24 @@ pub fn mk_assignty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                              b: Ty<'tcx>)\n                              -> RelateResult<'tcx, ()> {\n     debug!(\"mk_assignty({} -> {})\", a.repr(fcx.tcx()), b.repr(fcx.tcx()));\n-    let (adjustment, unsizing_obligation) = try!(indent(|| {\n+    let mut unsizing_obligations = vec![];\n+    let adjustment = try!(indent(|| {\n         fcx.infcx().commit_if_ok(|_| {\n             let coerce = Coerce {\n                 fcx: fcx,\n                 origin: infer::ExprAssignable(expr.span),\n-                unsizing_obligation: Cell::new(None)\n+                unsizing_obligations: RefCell::new(vec![])\n             };\n-            Ok((try!(coerce.coerce(expr, a, b)),\n-                coerce.unsizing_obligation.get()))\n+            let adjustment = try!(coerce.coerce(expr, a, b));\n+            unsizing_obligations = coerce.unsizing_obligations.into_inner();\n+            Ok(adjustment)\n         })\n     }));\n \n     if let Some(AdjustDerefRef(auto)) = adjustment {\n-        if let (Some(source), Some(target)) = (unsizing_obligation, auto.unsize) {\n-            let target = ty::deref(target, true)\n-                            .expect(\"coercion: unsizing got non-pointer target type\").ty;\n-            let target = ty::struct_tail(fcx.tcx(), target);\n-            if let ty::ty_trait(ref ty_trait) = target.sty {\n-                vtable::check_object_safety(fcx.tcx(), ty_trait, expr.span);\n-\n-                // If the type is `Foo+'a`, ensures that the type\n-                // being cast to `Foo+'a` implements `Foo`:\n-                vtable::register_object_cast_obligations(fcx,\n-                                                         expr.span,\n-                                                         ty_trait,\n-                                                         source);\n-\n-                // If the type is `Foo+'a`, ensures that the type\n-                // being cast to `Foo+'a` outlives `'a`:\n-                let cause = traits::ObligationCause {\n-                    span: expr.span,\n-                    body_id: fcx.body_id,\n-                    code: traits::ObjectCastObligation(source)\n-                };\n-                fcx.register_region_obligation(source, ty_trait.bounds.region_bound, cause);\n+        if auto.unsize.is_some() {\n+            for obligation in unsizing_obligations {\n+                fcx.register_predicate(obligation);\n             }\n         }\n     }"}, {"sha": "fb2ad444005c3d7225e20ff2d609bf6738a3feb5", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -12,8 +12,6 @@\n \n use astconv::AstConv;\n use check::FnCtxt;\n-use check::vtable;\n-use check::vtable::select_new_fcx_obligations;\n use middle::def;\n use middle::privacy::{AllPublic, DependsOn, LastPrivate, LastMod};\n use middle::subst;\n@@ -233,7 +231,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // FIXME(#18653) -- Try to resolve obligations, giving us more\n     // typing information, which can sometimes be needed to avoid\n     // pathological region inference failures.\n-    vtable::select_new_fcx_obligations(fcx);\n+    fcx.select_new_obligations();\n \n     // Insert any adjustments needed (always an autoref of some mutability).\n     match self_expr {"}, {"sha": "554f3d4b5a0c7dad1be1e0ac98fdc0ff088d4f91", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 73, "deletions": 13, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -93,7 +93,7 @@ use middle::pat_util::{self, pat_id_map};\n use middle::privacy::{AllPublic, LastMod};\n use middle::region::{self, CodeExtent};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace, TypeSpace};\n-use middle::traits;\n+use middle::traits::{self, report_fulfillment_errors};\n use middle::ty::{FnSig, GenericPredicates, TypeScheme};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty::{self, HasProjectionTypes, RegionEscape, ToPolyTraitRef, Ty};\n@@ -129,7 +129,6 @@ use syntax::visit::{self, Visitor};\n mod assoc;\n pub mod dropck;\n pub mod _match;\n-pub mod vtable;\n pub mod writeback;\n pub mod regionck;\n pub mod coercion;\n@@ -525,9 +524,9 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             let fcx = check_fn(ccx, fn_ty.unsafety, fn_id, &fn_sig,\n                                decl, fn_id, body, &inh);\n \n-            vtable::select_all_fcx_obligations_and_apply_defaults(&fcx);\n+            fcx.select_all_obligations_and_apply_defaults();\n             upvar::closure_analyze_fn(&fcx, fn_id, decl, body);\n-            vtable::select_all_fcx_obligations_or_error(&fcx);\n+            fcx.select_all_obligations_or_error();\n             fcx.check_casts();\n             regionck::regionck_fn(&fcx, fn_id, fn_span, decl, body);\n             writeback::resolve_type_vars_in_fn(&fcx, decl, body);\n@@ -1290,7 +1289,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         // If not, try resolving any new fcx obligations that have cropped up.\n-        vtable::select_new_fcx_obligations(self);\n+        self.select_new_obligations();\n         ty = self.infcx().resolve_type_vars_if_possible(&ty);\n         if !ty::type_has_ty_infer(ty) {\n             debug!(\"resolve_type_vars_if_possible: ty={}\", ty.repr(self.tcx()));\n@@ -1301,7 +1300,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // possible. This can help substantially when there are\n         // indirect dependencies that don't seem worth tracking\n         // precisely.\n-        vtable::select_fcx_obligations_where_possible(self);\n+        self.select_obligations_where_possible();\n         ty = self.infcx().resolve_type_vars_if_possible(&ty);\n \n         debug!(\"resolve_type_vars_if_possible: ty={}\", ty.repr(self.tcx()));\n@@ -1817,6 +1816,57 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         deferred_cast_checks.clear();\n     }\n+\n+    fn select_all_obligations_and_apply_defaults(&self) {\n+        debug!(\"select_all_obligations_and_apply_defaults\");\n+\n+        self.select_obligations_where_possible();\n+        self.default_type_parameters();\n+        self.select_obligations_where_possible();\n+    }\n+\n+    fn select_all_obligations_or_error(&self) {\n+        debug!(\"select_all_obligations_or_error\");\n+\n+        // upvar inference should have ensured that all deferred call\n+        // resolutions are handled by now.\n+        assert!(self.inh.deferred_call_resolutions.borrow().is_empty());\n+\n+        self.select_all_obligations_and_apply_defaults();\n+        let mut fulfillment_cx = self.inh.fulfillment_cx.borrow_mut();\n+        match fulfillment_cx.select_all_or_error(self.infcx(), self) {\n+            Ok(()) => { }\n+            Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }\n+        }\n+    }\n+\n+    /// Select as many obligations as we can at present.\n+    fn select_obligations_where_possible(&self) {\n+        match\n+            self.inh.fulfillment_cx\n+            .borrow_mut()\n+            .select_where_possible(self.infcx(), self)\n+        {\n+            Ok(()) => { }\n+            Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }\n+        }\n+    }\n+\n+    /// Try to select any fcx obligation that we haven't tried yet, in an effort\n+    /// to improve inference. You could just call\n+    /// `select_obligations_where_possible` except that it leads to repeated\n+    /// work.\n+    fn select_new_obligations(&self) {\n+        match\n+            self.inh.fulfillment_cx\n+            .borrow_mut()\n+            .select_new_obligations(self.infcx(), self)\n+        {\n+            Ok(()) => { }\n+            Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }\n+        }\n+    }\n+\n }\n \n impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx> {\n@@ -1880,11 +1930,7 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n     for autoderefs in 0..fcx.tcx().sess.recursion_limit.get() {\n         let resolved_t = match unresolved_type_action {\n             UnresolvedTypeAction::Error => {\n-                let resolved_t = structurally_resolved_type(fcx, sp, t);\n-                if ty::type_is_error(resolved_t) {\n-                    return (resolved_t, autoderefs, None);\n-                }\n-                resolved_t\n+                structurally_resolved_type(fcx, sp, t)\n             }\n             UnresolvedTypeAction::Ignore => {\n                 // We can continue even when the type cannot be resolved\n@@ -1894,6 +1940,9 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 fcx.resolve_type_vars_if_possible(t)\n             }\n         };\n+        if ty::type_is_error(resolved_t) {\n+            return (resolved_t, autoderefs, None);\n+        }\n \n         match should_stop(resolved_t, autoderefs) {\n             Some(x) => return (resolved_t, autoderefs, Some(x)),\n@@ -2263,7 +2312,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         // an \"opportunistic\" vtable resolution of any trait bounds on\n         // the call. This helps coercions.\n         if check_blocks {\n-            vtable::select_new_fcx_obligations(fcx);\n+            fcx.select_new_obligations();\n         }\n \n         // For variadic functions, we don't have a declared type for all of\n@@ -4059,7 +4108,7 @@ fn check_const_with_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     check_expr_with_hint(fcx, e, declty);\n     demand::coerce(fcx, e.span, declty, e);\n-    vtable::select_all_fcx_obligations_or_error(fcx);\n+    fcx.select_all_obligations_or_error();\n     fcx.check_casts();\n     regionck::regionck_expr(fcx, e);\n     writeback::resolve_type_vars_in_expr(fcx, e);\n@@ -4928,6 +4977,14 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"breakpoint\" => (0, Vec::new(), ty::mk_nil(tcx)),\n             \"size_of\" |\n             \"pref_align_of\" | \"min_align_of\" => (1, Vec::new(), ccx.tcx.types.usize),\n+            \"size_of_val\" |  \"min_align_of_val\" => {\n+                (1, vec![\n+                    ty::mk_imm_rptr(tcx,\n+                                    tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n+                                                                  ty::BrAnon(0))),\n+                                    param(ccx, 0))\n+                 ], ccx.tcx.types.usize)\n+            }\n             \"init\" | \"init_dropped\" => (1, Vec::new(), param(ccx, 0)),\n             \"uninit\" => (1, Vec::new(), param(ccx, 0)),\n             \"forget\" => (1, vec!( param(ccx, 0) ), ty::mk_nil(tcx)),\n@@ -4943,6 +5000,9 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                   ),\n                ty::mk_nil(tcx))\n             }\n+            \"drop_in_place\" => {\n+                (1, vec![ty::mk_mut_ptr(tcx, param(ccx, 0))], ty::mk_nil(tcx))\n+            }\n             \"needs_drop\" => (1, Vec::new(), ccx.tcx.types.bool),\n \n             \"type_name\" => (1, Vec::new(), ty::mk_str_slice(tcx, tcx.mk_region(ty::ReStatic),"}, {"sha": "337088c313d73ae0961d01cb15e1bcfe472185c6", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -85,8 +85,6 @@\n use astconv::AstConv;\n use check::dropck;\n use check::FnCtxt;\n-use check::vtable;\n-use middle::free_region::FreeRegionMap;\n use middle::implicator;\n use middle::mem_categorization as mc;\n use middle::region::CodeExtent;\n@@ -312,7 +310,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         // region checking can introduce new pending obligations\n         // which, when processed, might generate new region\n         // obligations. So make sure we process those.\n-        vtable::select_all_fcx_obligations_or_error(self.fcx);\n+        self.fcx.select_all_obligations_or_error();\n \n         // Make a copy of the region obligations vec because we'll need\n         // to be able to borrow the fulfillment-cx below when projecting."}, {"sha": "a9094fce57c61e24f4c42a468d7dac9fa0ebd02f", "filename": "src/librustc_typeck/check/vtable.rs", "status": "removed", "additions": 0, "deletions": 186, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "patch": "@@ -1,186 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use check::FnCtxt;\n-use middle::traits::{self, ObjectSafetyViolation, MethodViolationCode};\n-use middle::traits::{Obligation, ObligationCause};\n-use middle::traits::report_fulfillment_errors;\n-use middle::ty::{self, Ty, AsPredicate};\n-use syntax::codemap::Span;\n-use util::ppaux::{Repr, UserString};\n-\n-\n-// Check that a trait is 'object-safe'. This should be checked whenever a trait object\n-// is created (by casting or coercion, etc.). A trait is object-safe if all its\n-// methods are object-safe. A trait method is object-safe if it does not take\n-// self by value, has no type parameters and does not use the `Self` type, except\n-// in self position.\n-pub fn check_object_safety<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                 object_trait: &ty::TyTrait<'tcx>,\n-                                 span: Span)\n-{\n-    let trait_def_id = object_trait.principal_def_id();\n-\n-    if traits::is_object_safe(tcx, trait_def_id) {\n-        return;\n-    }\n-\n-    span_err!(tcx.sess, span, E0038,\n-              \"cannot convert to a trait object because trait `{}` is not object-safe\",\n-              ty::item_path_str(tcx, trait_def_id));\n-\n-    let violations = traits::object_safety_violations(tcx, trait_def_id);\n-    for violation in violations {\n-        match violation {\n-            ObjectSafetyViolation::SizedSelf => {\n-                tcx.sess.span_note(\n-                    span,\n-                    \"the trait cannot require that `Self : Sized`\");\n-            }\n-\n-            ObjectSafetyViolation::SupertraitSelf => {\n-                tcx.sess.span_note(\n-                    span,\n-                    \"the trait cannot use `Self` as a type parameter \\\n-                     in the supertrait listing\");\n-            }\n-\n-            ObjectSafetyViolation::Method(method, MethodViolationCode::StaticMethod) => {\n-                tcx.sess.span_note(\n-                    span,\n-                    &format!(\"method `{}` has no receiver\",\n-                             method.name.user_string(tcx)));\n-            }\n-\n-            ObjectSafetyViolation::Method(method, MethodViolationCode::ReferencesSelf) => {\n-                tcx.sess.span_note(\n-                    span,\n-                    &format!(\"method `{}` references the `Self` type \\\n-                              in its arguments or return type\",\n-                             method.name.user_string(tcx)));\n-            }\n-\n-            ObjectSafetyViolation::Method(method, MethodViolationCode::Generic) => {\n-                tcx.sess.span_note(\n-                    span,\n-                    &format!(\"method `{}` has generic type parameters\",\n-                             method.name.user_string(tcx)));\n-            }\n-        }\n-    }\n-}\n-\n-pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                                  span: Span,\n-                                                  object_trait: &ty::TyTrait<'tcx>,\n-                                                  referent_ty: Ty<'tcx>)\n-                                                  -> ty::PolyTraitRef<'tcx>\n-{\n-    // We can only make objects from sized types.\n-    fcx.register_builtin_bound(\n-        referent_ty,\n-        ty::BoundSized,\n-        traits::ObligationCause::new(span, fcx.body_id, traits::ObjectSized));\n-\n-    // This is just for better error reporting. Kinda goofy. The object type stuff\n-    // needs some refactoring so there is a more convenient type to pass around.\n-    let object_trait_ty =\n-        ty::mk_trait(fcx.tcx(),\n-                     object_trait.principal.clone(),\n-                     object_trait.bounds.clone());\n-\n-    debug!(\"register_object_cast_obligations: referent_ty={} object_trait_ty={}\",\n-           referent_ty.repr(fcx.tcx()),\n-           object_trait_ty.repr(fcx.tcx()));\n-\n-    let cause = ObligationCause::new(span,\n-                                     fcx.body_id,\n-                                     traits::ObjectCastObligation(object_trait_ty));\n-\n-    // Create the obligation for casting from T to Trait.\n-    let object_trait_ref =\n-        object_trait.principal_trait_ref_with_self_ty(fcx.tcx(), referent_ty);\n-    let object_obligation =\n-        Obligation::new(cause.clone(), object_trait_ref.as_predicate());\n-    fcx.register_predicate(object_obligation);\n-\n-    // Create additional obligations for all the various builtin\n-    // bounds attached to the object cast. (In other words, if the\n-    // object type is Foo+Send, this would create an obligation\n-    // for the Send check.)\n-    for builtin_bound in &object_trait.bounds.builtin_bounds {\n-        fcx.register_builtin_bound(\n-            referent_ty,\n-            builtin_bound,\n-            cause.clone());\n-    }\n-\n-    // Create obligations for the projection predicates.\n-    let projection_bounds =\n-        object_trait.projection_bounds_with_self_ty(fcx.tcx(), referent_ty);\n-    for projection_bound in &projection_bounds {\n-        let projection_obligation =\n-            Obligation::new(cause.clone(), projection_bound.as_predicate());\n-        fcx.register_predicate(projection_obligation);\n-    }\n-\n-    object_trait_ref\n-}\n-\n-pub fn select_all_fcx_obligations_and_apply_defaults(fcx: &FnCtxt) {\n-    debug!(\"select_all_fcx_obligations_and_apply_defaults\");\n-\n-    select_fcx_obligations_where_possible(fcx);\n-    fcx.default_type_parameters();\n-    select_fcx_obligations_where_possible(fcx);\n-}\n-\n-pub fn select_all_fcx_obligations_or_error(fcx: &FnCtxt) {\n-    debug!(\"select_all_fcx_obligations_or_error\");\n-\n-    // upvar inference should have ensured that all deferred call\n-    // resolutions are handled by now.\n-    assert!(fcx.inh.deferred_call_resolutions.borrow().is_empty());\n-\n-    select_all_fcx_obligations_and_apply_defaults(fcx);\n-    let mut fulfillment_cx = fcx.inh.fulfillment_cx.borrow_mut();\n-    let r = fulfillment_cx.select_all_or_error(fcx.infcx(), fcx);\n-    match r {\n-        Ok(()) => { }\n-        Err(errors) => { report_fulfillment_errors(fcx.infcx(), &errors); }\n-    }\n-}\n-\n-/// Select as many obligations as we can at present.\n-pub fn select_fcx_obligations_where_possible(fcx: &FnCtxt)\n-{\n-    match\n-        fcx.inh.fulfillment_cx\n-        .borrow_mut()\n-        .select_where_possible(fcx.infcx(), fcx)\n-    {\n-        Ok(()) => { }\n-        Err(errors) => { report_fulfillment_errors(fcx.infcx(), &errors); }\n-    }\n-}\n-\n-/// Try to select any fcx obligation that we haven't tried yet, in an effort to improve inference.\n-/// You could just call `select_fcx_obligations_where_possible` except that it leads to repeated\n-/// work.\n-pub fn select_new_fcx_obligations(fcx: &FnCtxt) {\n-    match\n-        fcx.inh.fulfillment_cx\n-        .borrow_mut()\n-        .select_new_obligations(fcx.infcx(), fcx)\n-    {\n-        Ok(()) => { }\n-        Err(errors) => { report_fulfillment_errors(fcx.infcx(), &errors); }\n-    }\n-}"}, {"sha": "79736c08f37967bb4a6cdf09d09b0362129c371f", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use astconv::AstConv;\n-use check::{FnCtxt, Inherited, blank_fn_ctxt, vtable, regionck};\n+use check::{FnCtxt, Inherited, blank_fn_ctxt, regionck};\n use constrained_type_params::{identify_constrained_type_params, Parameter};\n use CrateCtxt;\n use middle::region;\n@@ -151,7 +151,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let inh = Inherited::new(ccx.tcx, param_env);\n         let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(type_scheme.ty), item.id);\n         f(self, &fcx);\n-        vtable::select_all_fcx_obligations_or_error(&fcx);\n+        fcx.select_all_obligations_or_error();\n         regionck::regionck_item(&fcx, item);\n     }\n "}, {"sha": "c6e0bb676f73572c554a449ef3340bb491f65422", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 170, "deletions": 2, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -16,7 +16,9 @@\n // mappings. That mapping code resides here.\n \n \n+use middle::lang_items::UnsizeTraitLangItem;\n use middle::subst::{self, Subst};\n+use middle::traits;\n use middle::ty::RegionEscape;\n use middle::ty::{ImplContainer, ImplOrTraitItemId, ConstTraitItemId};\n use middle::ty::{MethodTraitItemId, TypeTraitItemId, ParameterEnvironment};\n@@ -28,8 +30,7 @@ use middle::ty::{ty_uint, ty_closure, ty_uniq, ty_bare_fn};\n use middle::ty::ty_projection;\n use middle::ty;\n use CrateCtxt;\n-use middle::infer::InferCtxt;\n-use middle::infer::new_infer_ctxt;\n+use middle::infer::{self, InferCtxt, new_infer_ctxt};\n use std::cell::RefCell;\n use std::rc::Rc;\n use syntax::ast::{Crate, DefId};\n@@ -133,6 +134,10 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n         // Check to make sure implementations of `Copy` are legal.\n         self.check_implementations_of_copy();\n+\n+        // Check to make sure implementations of `CoerceUnsized` are legal\n+        // and collect the necessary information from them.\n+        self.check_implementations_of_coerce_unsized();\n     }\n \n     fn check_implementation(&self, item: &Item, opt_trait: Option<&TraitRef>) {\n@@ -419,6 +424,169 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             }\n         });\n     }\n+\n+    /// Process implementations of the built-in trait `CoerceUnsized`.\n+    fn check_implementations_of_coerce_unsized(&self) {\n+        let tcx = self.crate_context.tcx;\n+        let coerce_unsized_trait = match tcx.lang_items.coerce_unsized_trait() {\n+            Some(id) => id,\n+            None => return,\n+        };\n+        let unsize_trait = match tcx.lang_items.require(UnsizeTraitLangItem) {\n+            Ok(id) => id,\n+            Err(err) => {\n+                tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n+            }\n+        };\n+\n+        let trait_impls = match tcx.trait_impls\n+                                   .borrow()\n+                                   .get(&coerce_unsized_trait)\n+                                   .cloned() {\n+            None => {\n+                debug!(\"check_implementations_of_coerce_unsized(): no types \\\n+                        with implementations of `CoerceUnsized` found\");\n+                return\n+            }\n+            Some(found_impls) => found_impls\n+        };\n+\n+        // Clone first to avoid a double borrow error.\n+        let trait_impls = trait_impls.borrow().clone();\n+\n+        for &impl_did in &trait_impls {\n+            debug!(\"check_implementations_of_coerce_unsized: impl_did={}\",\n+                   impl_did.repr(tcx));\n+\n+            if impl_did.krate != ast::LOCAL_CRATE {\n+                debug!(\"check_implementations_of_coerce_unsized(): impl not \\\n+                        in this crate\");\n+                continue\n+            }\n+\n+            let source = self.get_self_type_for_implementation(impl_did).ty;\n+            let trait_ref = ty::impl_id_to_trait_ref(self.crate_context.tcx,\n+                                                     impl_did.node);\n+            let target = *trait_ref.substs.types.get(subst::TypeSpace, 0);\n+            debug!(\"check_implementations_of_coerce_unsized: {} -> {} (bound)\",\n+                   source.repr(tcx), target.repr(tcx));\n+\n+            let span = tcx.map.span(impl_did.node);\n+            let param_env = ParameterEnvironment::for_item(tcx, impl_did.node);\n+            let source = source.subst(tcx, &param_env.free_substs);\n+            let target = target.subst(tcx, &param_env.free_substs);\n+            assert!(!source.has_escaping_regions());\n+\n+            debug!(\"check_implementations_of_coerce_unsized: {} -> {} (free)\",\n+                   source.repr(tcx), target.repr(tcx));\n+\n+            let infcx = new_infer_ctxt(tcx);\n+\n+            let check_mutbl = |mt_a: ty::mt<'tcx>, mt_b: ty::mt<'tcx>,\n+                               mk_ptr: &Fn(Ty<'tcx>) -> Ty<'tcx>| {\n+                if (mt_a.mutbl, mt_b.mutbl) == (ast::MutImmutable, ast::MutMutable) {\n+                    infcx.report_mismatched_types(span, mk_ptr(mt_b.ty),\n+                                                  target, &ty::terr_mutability);\n+                }\n+                (mt_a.ty, mt_b.ty, unsize_trait, None)\n+            };\n+            let (source, target, trait_def_id, kind) = match (&source.sty, &target.sty) {\n+                (&ty::ty_uniq(a), &ty::ty_uniq(b)) => (a, b, unsize_trait, None),\n+\n+                (&ty::ty_rptr(r_a, mt_a), &ty::ty_rptr(r_b, mt_b)) => {\n+                    infer::mk_subr(&infcx, infer::RelateObjectBound(span), *r_b, *r_a);\n+                    check_mutbl(mt_a, mt_b, &|ty| ty::mk_imm_rptr(tcx, r_b, ty))\n+                }\n+\n+                (&ty::ty_rptr(_, mt_a), &ty::ty_ptr(mt_b)) |\n+                (&ty::ty_ptr(mt_a), &ty::ty_ptr(mt_b)) => {\n+                    check_mutbl(mt_a, mt_b, &|ty| ty::mk_imm_ptr(tcx, ty))\n+                }\n+\n+                (&ty::ty_struct(def_id_a, substs_a), &ty::ty_struct(def_id_b, substs_b)) => {\n+                    if def_id_a != def_id_b {\n+                        let source_path = ty::item_path_str(tcx, def_id_a);\n+                        let target_path = ty::item_path_str(tcx, def_id_b);\n+                        span_err!(tcx.sess, span, E0373,\n+                                  \"the trait `CoerceUnsized` may only be implemented \\\n+                                   for a coercion between structures with the same \\\n+                                   definition; expected {}, found {}\",\n+                                  source_path, target_path);\n+                        continue;\n+                    }\n+\n+                    let origin = infer::Misc(span);\n+                    let fields = ty::lookup_struct_fields(tcx, def_id_a);\n+                    let diff_fields = fields.iter().enumerate().filter_map(|(i, f)| {\n+                        let ty = ty::lookup_field_type_unsubstituted(tcx, def_id_a, f.id);\n+                        let (a, b) = (ty.subst(tcx, substs_a), ty.subst(tcx, substs_b));\n+                        if infcx.sub_types(false, origin, b, a).is_ok() {\n+                            None\n+                        } else {\n+                            Some((i, a, b))\n+                        }\n+                    }).collect::<Vec<_>>();\n+\n+                    if diff_fields.is_empty() {\n+                        span_err!(tcx.sess, span, E0374,\n+                                  \"the trait `CoerceUnsized` may only be implemented \\\n+                                   for a coercion between structures with one field \\\n+                                   being coerced, none found\");\n+                        continue;\n+                    } else if diff_fields.len() > 1 {\n+                        span_err!(tcx.sess, span, E0375,\n+                                  \"the trait `CoerceUnsized` may only be implemented \\\n+                                   for a coercion between structures with one field \\\n+                                   being coerced, but {} fields need coercions: {}\",\n+                                   diff_fields.len(), diff_fields.iter().map(|&(i, a, b)| {\n+                                        let name = fields[i].name;\n+                                        format!(\"{} ({} to {})\",\n+                                                if name == token::special_names::unnamed_field {\n+                                                    i.to_string()\n+                                                } else {\n+                                                    token::get_name(name).to_string()\n+                                                },\n+                                                a.repr(tcx),\n+                                                b.repr(tcx))\n+                                   }).collect::<Vec<_>>().connect(\", \"));\n+                        continue;\n+                    }\n+\n+                    let (i, a, b) = diff_fields[0];\n+                    let kind = ty::CustomCoerceUnsized::Struct(i);\n+                    (a, b, coerce_unsized_trait, Some(kind))\n+                }\n+\n+                _ => {\n+                    span_err!(tcx.sess, span, E0376,\n+                              \"the trait `CoerceUnsized` may only be implemented \\\n+                               for a coercion between structures\");\n+                    continue;\n+                }\n+            };\n+\n+            let mut fulfill_cx = traits::FulfillmentContext::new();\n+\n+            // Register an obligation for `A: Trait<B>`.\n+            let cause = traits::ObligationCause::misc(span, impl_did.node);\n+            let predicate = traits::predicate_for_trait_def(tcx, cause, trait_def_id,\n+                                                            0, source, vec![target]);\n+            fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+\n+            // Check that all transitive obligations are satisfied.\n+            if let Err(errors) = fulfill_cx.select_all_or_error(&infcx, &param_env) {\n+                traits::report_fulfillment_errors(&infcx, &errors);\n+            }\n+\n+            // Finally, resolve all regions. This catches wily misuses of lifetime\n+            // parameters.\n+            infcx.resolve_regions_and_report_errors(impl_did.node);\n+\n+            if let Some(kind) = kind {\n+                tcx.custom_coerce_unsized_kinds.borrow_mut().insert(impl_did, kind);\n+            }\n+        }\n+    }\n }\n \n fn enforce_trait_manually_implementable(tcx: &ty::ctxt, sp: Span, trait_def_id: ast::DefId) {"}, {"sha": "c75a0d816a8a5f6157506096702b8324bb11bf7e", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -316,12 +316,17 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                     }\n                 }\n \n-                // Disallow *all* explicit impls of `Sized` for now.\n+                // Disallow *all* explicit impls of `Sized` and `Unsize` for now.\n                 if Some(trait_def_id) == self.tcx.lang_items.sized_trait() {\n                     span_err!(self.tcx.sess, item.span, E0322,\n                               \"explicit impls for the `Sized` trait are not permitted\");\n                     return;\n                 }\n+                if Some(trait_def_id) == self.tcx.lang_items.unsize_trait() {\n+                    span_err!(self.tcx.sess, item.span, E0323,\n+                              \"explicit impls for the `Unsize` trait are not permitted\");\n+                    return;\n+                }\n             }\n             ast::ItemDefaultImpl(..) => {\n                 // \"Trait\" impl"}, {"sha": "ac10a4e7121a84a2ae916c67c4bbad11b2866a06", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -445,10 +445,20 @@ register_diagnostics! {\n     E0325, // implemented an associated type when another trait item expected\n     E0326, // associated const implemented with different type from trait\n     E0327, // referred to method instead of constant in match pattern\n+    E0328, // cannot implement Unsize explicitly\n     E0366, // dropck forbid specialization to concrete type or region\n     E0367, // dropck forbid specialization to predicate not in struct/enum\n     E0368, // binary operation `<op>=` cannot be applied to types\n     E0369, // binary operation `<op>` cannot be applied to types\n     E0371, // impl Trait for Trait is illegal\n-    E0372  // impl Trait for Trait where Trait is not object safe\n+    E0372, // impl Trait for Trait where Trait is not object safe\n+    E0373, // the trait `CoerceUnsized` may only be implemented for a coercion\n+           // between structures with the same definition\n+    E0374, // the trait `CoerceUnsized` may only be implemented for a coercion\n+           // between structures with one field being coerced, none found\n+    E0375, // the trait `CoerceUnsized` may only be implemented for a coercion\n+           // between structures with one field being coerced, but multiple\n+           // fields need coercions\n+    E0376  // the trait `CoerceUnsized` may only be implemented for a coercion\n+           // between structures\n }"}, {"sha": "3f455e148a09be30fb0919dfd00f1279f3b0491e", "filename": "src/test/compile-fail/destructure-trait-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -35,7 +35,7 @@ fn main() {\n     // n == m\n     let &x = &1 as &T;      //~ ERROR type `&T` cannot be dereferenced\n     let &&x = &(&1 as &T);  //~ ERROR type `&T` cannot be dereferenced\n-    let box x = box 1 as Box<T>; //~ ERROR type `Box<T>` cannot be dereferenced\n+    let box x = box 1 as Box<T>; //~ ERROR the trait `core::marker::Sized` is not implemented\n \n     // n > m\n     let &&x = &1 as &T;"}, {"sha": "b7a07e487994d41cce8463c2929ce00298bf7ced", "filename": "src/test/compile-fail/dst-bad-coercions.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -33,18 +33,4 @@ pub fn main() {\n     let x: &mut T = &S; //~ ERROR mismatched types\n     let x: *mut T = &S; //~ ERROR mismatched types\n     let x: *mut S = &S; //~ ERROR mismatched types\n-\n-    // The below four sets of tests test that we cannot implicitly deref a *-ptr\n-    // during a coercion.\n-    let x: *const S = &S;\n-    let y: *const T = x;  //~ ERROR mismatched types\n-\n-    let x: *mut S = &mut S;\n-    let y: *mut T = x;  //~ ERROR mismatched types\n-\n-    let x: *const Foo<S> = &Foo {f: S};\n-    let y: *const Foo<T> = x;  //~ ERROR mismatched types\n-\n-    let x: *mut Foo<S> = &mut Foo {f: S};\n-    let y: *mut Foo<T> = x;  //~ ERROR mismatched types\n }"}, {"sha": "7b84ba0343a33adccd780b05e0155d0a1c363359", "filename": "src/test/compile-fail/issue-19692.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Ftest%2Fcompile-fail%2Fissue-19692.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Ftest%2Fcompile-fail%2Fissue-19692.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19692.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -12,7 +12,7 @@ struct Homura;\n \n fn akemi(homura: Homura) {\n     let Some(ref madoka) = Some(homura.kaname()); //~ ERROR does not implement any method\n-    madoka.clone();\n+    madoka.clone(); //~ ERROR the type of this value must be known in this context\n }\n \n fn main() { }"}, {"sha": "42fd856ad8784ee54766dd517208a7c8b2512362", "filename": "src/test/compile-fail/issue-20261.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Ftest%2Fcompile-fail%2Fissue-20261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Ftest%2Fcompile-fail%2Fissue-20261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20261.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -12,6 +12,5 @@ fn main() {\n     for (ref i,) in [].iter() { //~ ERROR: type mismatch resolving\n         i.clone();\n         //~^ ERROR: the type of this value must be known in this context\n-        //~| ERROR: reached the recursion limit while auto-dereferencing\n     }\n }"}, {"sha": "8b258180e830fb25822bf79b6ea70c5c6cda922f", "filename": "src/test/compile-fail/issue-22034.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Ftest%2Fcompile-fail%2Fissue-22034.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Ftest%2Fcompile-fail%2Fissue-22034.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22034.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -14,6 +14,7 @@ fn main() {\n     let ptr: *mut () = 0 as *mut _;\n     let _: &mut Fn() = unsafe {\n         &mut *(ptr as *mut Fn())\n-        //~^ ERROR illegal cast\n+        //~^ ERROR the trait `core::ops::Fn<()>` is not implemented\n+        //~| ERROR the trait `core::ops::FnOnce<()>` is not implemented\n     };\n }"}, {"sha": "75ee0bdc9c7aed27de547fc41f3b50fbcb3a10be", "filename": "src/test/compile-fail/object-lifetime-default-elision.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-elision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-elision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-elision.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -81,7 +81,7 @@ fn load3<'a,'b>(ss: &'a SomeTrait) -> &'b SomeTrait {\n     // which fails to type check.\n \n     ss\n-        //~^ ERROR lifetime of the source pointer does not outlive lifetime bound\n+        //~^ ERROR lifetime bound not satisfied\n         //~| ERROR cannot infer\n }\n "}, {"sha": "dd94dfe1e0823463701bafc0f68dba06963dc831", "filename": "src/test/compile-fail/object-lifetime-default-from-box-error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-box-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-box-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-box-error.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -25,7 +25,7 @@ fn load(ss: &mut SomeStruct) -> Box<SomeTrait> {\n     // `Box<SomeTrait>` defaults to a `'static` bound, so this return\n     // is illegal.\n \n-    ss.r //~ ERROR lifetime of the source pointer does not outlive lifetime bound\n+    ss.r //~ ERROR lifetime bound not satisfied\n }\n \n fn store(ss: &mut SomeStruct, b: Box<SomeTrait>) {\n@@ -38,7 +38,7 @@ fn store(ss: &mut SomeStruct, b: Box<SomeTrait>) {\n fn store1<'b>(ss: &mut SomeStruct, b: Box<SomeTrait+'b>) {\n     // Here we override the lifetimes explicitly, and so naturally we get an error.\n \n-    ss.r = b; //~ ERROR lifetime of the source pointer does not outlive lifetime bound\n+    ss.r = b; //~ ERROR lifetime bound not satisfied\n }\n \n fn main() {"}, {"sha": "c5cf43e355d5aae777bef840103e56e29cf40c33", "filename": "src/test/compile-fail/regions-close-over-type-parameter-multiple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-multiple.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -27,7 +27,7 @@ fn make_object_good2<'a,'b,A:SomeTrait+'a+'b>(v: A) -> Box<SomeTrait+'b> {\n \n fn make_object_bad<'a,'b,'c,A:SomeTrait+'a+'b>(v: A) -> Box<SomeTrait+'c> {\n     // A outlives 'a AND 'b...but not 'c.\n-    box v as Box<SomeTrait+'a> //~ ERROR lifetime of the source pointer does not outlive\n+    box v as Box<SomeTrait+'a> //~ ERROR lifetime bound not satisfied\n }\n \n fn main() {"}, {"sha": "b4e527972e4765b6339e457ed769e6ab1e844301", "filename": "src/test/compile-fail/regions-trait-object-subtyping.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/843db01bd925279da0a56efde532c9e3ecf73610/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843db01bd925279da0a56efde532c9e3ecf73610/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs?ref=843db01bd925279da0a56efde532c9e3ecf73610", "patch": "@@ -22,7 +22,7 @@ fn foo2<'a:'b,'b>(x: &'b mut (Dummy+'a)) -> &'b mut (Dummy+'b) {\n \n fn foo3<'a,'b>(x: &'a mut Dummy) -> &'b mut Dummy {\n     // Without knowing 'a:'b, we can't coerce\n-    x //~ ERROR lifetime of the source pointer does not outlive\n+    x //~ ERROR lifetime bound not satisfied\n      //~^ ERROR cannot infer\n }\n "}]}