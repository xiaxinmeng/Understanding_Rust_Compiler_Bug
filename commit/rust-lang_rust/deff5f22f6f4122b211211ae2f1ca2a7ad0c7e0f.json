{"sha": "deff5f22f6f4122b211211ae2f1ca2a7ad0c7e0f", "node_id": "C_kwDOAAsO6NoAKGRlZmY1ZjIyZjZmNDEyMmIyMTEyMTFhZTJmMWNhMmE3YWQwYzdlMGY", "commit": {"author": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2023-01-26T15:19:35Z"}, "committer": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2023-01-29T15:20:22Z"}, "message": "Tweak change collapsing", "tree": {"sha": "b1bcec1ace0edfcfec89b09d91a18fc4635bef55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1bcec1ace0edfcfec89b09d91a18fc4635bef55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/deff5f22f6f4122b211211ae2f1ca2a7ad0c7e0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/deff5f22f6f4122b211211ae2f1ca2a7ad0c7e0f", "html_url": "https://github.com/rust-lang/rust/commit/deff5f22f6f4122b211211ae2f1ca2a7ad0c7e0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/deff5f22f6f4122b211211ae2f1ca2a7ad0c7e0f/comments", "author": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd673eea33079a3bf194fad25a6aec2e824e9041", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd673eea33079a3bf194fad25a6aec2e824e9041", "html_url": "https://github.com/rust-lang/rust/commit/dd673eea33079a3bf194fad25a6aec2e824e9041"}], "stats": {"total": 98, "additions": 48, "deletions": 50}, "files": [{"sha": "aca6c92357070752258d6b05dd6e7de61b671c31", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 48, "deletions": 50, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/deff5f22f6f4122b211211ae2f1ca2a7ad0c7e0f/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deff5f22f6f4122b211211ae2f1ca2a7ad0c7e0f/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=deff5f22f6f4122b211211ae2f1ca2a7ad0c7e0f", "patch": "@@ -3,7 +3,7 @@\n //!\n //! Each tick provides an immutable snapshot of the state as `WorldSnapshot`.\n \n-use std::{mem, sync::Arc, time::Instant};\n+use std::{sync::Arc, time::Instant};\n \n use crossbeam_channel::{unbounded, Receiver, Sender};\n use flycheck::FlycheckHandle;\n@@ -179,10 +179,9 @@ impl GlobalState {\n \n     pub(crate) fn process_changes(&mut self) -> bool {\n         let _p = profile::span(\"GlobalState::process_changes\");\n-        // A file was added or deleted\n-        let mut has_structure_changes = false;\n         let mut workspace_structure_change = None;\n \n+        let mut file_changes = FxHashMap::default();\n         let (change, changed_files) = {\n             let mut change = Change::new();\n             let (vfs, line_endings_map) = &mut *self.vfs.write();\n@@ -191,57 +190,56 @@ impl GlobalState {\n                 return false;\n             }\n \n-            // important: this needs to be a stable sort, the order between changes is relevant\n-            // for the same file ids\n-            changed_files.sort_by_key(|file| file.file_id);\n-            // We need to fix up the changed events a bit, if we have a create or modify for a file\n-            // id that is followed by a delete we actually no longer observe the file text from the\n-            // create or modify which may cause problems later on\n-            let mut collapsed_create_delete = false;\n-            changed_files.dedup_by(|a, b| {\n+            // We need to fix up the changed events a bit. If we have a create or modify for a file\n+            // id that is followed by a delete we actually skip observing the file text from the\n+            // earlier event, to avoid problems later on.\n+            for changed_file in &changed_files {\n                 use vfs::ChangeKind::*;\n \n-                let has_collapsed_create_delete = mem::replace(&mut collapsed_create_delete, false);\n+                file_changes\n+                    .entry(changed_file.file_id)\n+                    .and_modify(|(change, just_created)| {\n+                        // None -> Delete => keep\n+                        // Create -> Delete => collapse\n+                        //\n+                        match (change, just_created, changed_file.change_kind) {\n+                            // latter `Delete` wins\n+                            (change, _, Delete) => *change = Delete,\n+                            // merge `Create` with `Create` or `Modify`\n+                            (Create, _, Create | Modify) => {}\n+                            // collapse identical `Modify`es\n+                            (Modify, _, Modify) => {}\n+                            // equivalent to `Modify`\n+                            (change @ Delete, just_created, Create) => {\n+                                *change = Modify;\n+                                *just_created = true;\n+                            }\n+                            // shouldn't occur, but collapse into `Create`\n+                            (change @ Delete, just_created, Modify) => {\n+                                *change = Create;\n+                                *just_created = true;\n+                            }\n+                            // shouldn't occur, but collapse into `Modify`\n+                            (Modify, _, Create) => {}\n+                        }\n+                    })\n+                    .or_insert((\n+                        changed_file.change_kind,\n+                        matches!(changed_file.change_kind, Create),\n+                    ));\n+            }\n \n-                if a.file_id != b.file_id {\n-                    return false;\n-                }\n+            changed_files.extend(\n+                file_changes\n+                    .into_iter()\n+                    .filter(|(_, (change_kind, just_created))| {\n+                        !matches!((change_kind, just_created), (vfs::ChangeKind::Delete, true))\n+                    })\n+                    .map(|(file_id, (change_kind, _))| vfs::ChangedFile { file_id, change_kind }),\n+            );\n \n-                // true => delete the second element (a), we swap them here as they are inverted by dedup_by\n-                match (b.change_kind, a.change_kind) {\n-                    // duplicate can be merged\n-                    (Create, Create) | (Modify, Modify) | (Delete, Delete) => true,\n-                    // just leave the create, modify is irrelevant\n-                    (Create, Modify) => true,\n-                    // modify becomes irrelevant if the file is deleted\n-                    (Modify, Delete) => {\n-                        mem::swap(a, b);\n-                        true\n-                    }\n-                    // Remove the create message, and in the following loop, also remove the delete\n-                    (Create, Delete) => {\n-                        collapsed_create_delete = true;\n-                        b.change_kind = Delete;\n-                        true\n-                    }\n-                    // trailing delete from earlier\n-                    (Delete, Create | Modify) if has_collapsed_create_delete => {\n-                        b.change_kind = Create;\n-                        true\n-                    }\n-                    // this is equivalent to a modify\n-                    (Delete, Create) => {\n-                        b.change_kind = Modify;\n-                        true\n-                    }\n-                    // can't really occur\n-                    (Modify, Create) => false,\n-                    (Delete, Modify) => false,\n-                }\n-            });\n-            if collapsed_create_delete {\n-                changed_files.pop();\n-            }\n+            // A file was added or deleted\n+            let mut has_structure_changes = false;\n             for file in &changed_files {\n                 if let Some(path) = vfs.file_path(file.file_id).as_path() {\n                     let path = path.to_path_buf();"}]}