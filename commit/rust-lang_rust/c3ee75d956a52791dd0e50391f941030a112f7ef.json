{"sha": "c3ee75d956a52791dd0e50391f941030a112f7ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzZWU3NWQ5NTZhNTI3OTFkZDBlNTAzOTFmOTQxMDMwYTExMmY3ZWY=", "commit": {"author": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2020-06-27T17:55:15Z"}, "committer": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2020-07-14T23:08:44Z"}, "message": "rustdoc: glue tokens before highlighting\n\nFixes #72684.\n\nThis commit also modifies the signature of `Classifier::new` to avoid\ncopying the source being highlighted.", "tree": {"sha": "a35aa136151e1bd86218bcf497b0bf71d3cc89cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a35aa136151e1bd86218bcf497b0bf71d3cc89cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3ee75d956a52791dd0e50391f941030a112f7ef", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQFKBAABCAA0FiEELriChyEaiMu0yCg7viIhAz7bw3QFAl8OOv8WHGFydXNzZWxs\nMTIzQGdtYWlsLmNvbQAKCRC+IiEDPtvDdJNCB/9uqpE63Me8Dt/fWzAXI/P8IDGn\nsZIssHEb93PxFImlAt4x0CD+Nymn6/RC900DqQvOhH/x15eVC95MBWDCHmz84gOL\n+ntyuDTIwH1Tr95F4VMqKV8cTNJpRH7rAP2sRoPW7VqWa5H1lekVVVNCJCosQwiJ\n0TaUxdhCsfmDgNIcPnZLbRQVET3W+4RXEsgw9touIkzHlZ41JB1/RIoWMcGnbbi1\nw/knC/w+3VE/hhE2FNTLfdfKT7pKktMA516pVbpTFT7iBT1Tfqr6JKNhyH4dgcrv\nHg1UdSkjPMlrmAy3/+9YjiVoU8U7eEO1caXCzVf3ONsVc/m56JOmolVeoYoO\n=8EbC\n-----END PGP SIGNATURE-----", "payload": "tree a35aa136151e1bd86218bcf497b0bf71d3cc89cc\nparent 2002ebacfbca288830a3c308ddc8189705c608fe\nauthor Andy Russell <arussell123@gmail.com> 1593280515 -0400\ncommitter Andy Russell <arussell123@gmail.com> 1594768124 -0400\n\nrustdoc: glue tokens before highlighting\n\nFixes #72684.\n\nThis commit also modifies the signature of `Classifier::new` to avoid\ncopying the source being highlighted.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3ee75d956a52791dd0e50391f941030a112f7ef", "html_url": "https://github.com/rust-lang/rust/commit/c3ee75d956a52791dd0e50391f941030a112f7ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3ee75d956a52791dd0e50391f941030a112f7ef/comments", "author": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "committer": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2002ebacfbca288830a3c308ddc8189705c608fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/2002ebacfbca288830a3c308ddc8189705c608fe", "html_url": "https://github.com/rust-lang/rust/commit/2002ebacfbca288830a3c308ddc8189705c608fe"}], "stats": {"total": 155, "additions": 133, "deletions": 22}, "files": [{"sha": "d4302d0cb546b8bf49ac5ca4e45e7c707d54ad32", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 37, "deletions": 14, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c3ee75d956a52791dd0e50391f941030a112f7ef/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3ee75d956a52791dd0e50391f941030a112f7ef/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=c3ee75d956a52791dd0e50391f941030a112f7ef", "patch": "@@ -12,15 +12,17 @@ use std::io;\n use std::io::prelude::*;\n \n use rustc_ast::token::{self, Token};\n+use rustc_data_structures::sync::Lrc;\n use rustc_parse::lexer;\n use rustc_session::parse::ParseSess;\n+use rustc_span::hygiene::SyntaxContext;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym};\n-use rustc_span::{FileName, Span};\n+use rustc_span::{BytePos, FileName, SourceFile, Span};\n \n /// Highlights `src`, returning the HTML output.\n pub fn render_with_highlighting(\n-    src: &str,\n+    src: String,\n     class: Option<&str>,\n     playground_button: Option<&str>,\n     tooltip: Option<(&str, &str)>,\n@@ -38,12 +40,13 @@ pub fn render_with_highlighting(\n     }\n \n     let sess = ParseSess::with_silent_emitter();\n-    let sf = sess\n+    let source_file = sess\n         .source_map()\n-        .new_source_file(FileName::Custom(String::from(\"rustdoc-highlighting\")), src.to_owned());\n+        .new_source_file(FileName::Custom(String::from(\"rustdoc-highlighting\")), src);\n+\n+    let classifier_source_file = Lrc::clone(&source_file);\n     let highlight_result = rustc_driver::catch_fatal_errors(|| {\n-        let lexer = lexer::StringReader::new(&sess, sf, None);\n-        let mut classifier = Classifier::new(lexer, sess.source_map());\n+        let mut classifier = Classifier::new(&sess, classifier_source_file);\n \n         let mut highlighted_source = vec![];\n         if classifier.write_source(&mut highlighted_source).is_err() {\n@@ -61,9 +64,17 @@ pub fn render_with_highlighting(\n             write_footer(&mut out, playground_button).unwrap();\n         }\n         Err(()) => {\n+            // Get the source back out of the source map to avoid a copy in the happy path.\n+            let span =\n+                Span::new(BytePos(0), BytePos(source_file.byte_length()), SyntaxContext::root());\n+            let src = sess\n+                .source_map()\n+                .span_to_snippet(span)\n+                .expect(\"could not retrieve snippet from artificial source file\");\n+\n             // If errors are encountered while trying to highlight, just emit\n             // the unhighlighted source.\n-            write!(out, \"<pre><code>{}</code></pre>\", Escape(src)).unwrap();\n+            write!(out, \"<pre><code>{}</code></pre>\", Escape(&src)).unwrap();\n         }\n     }\n \n@@ -73,10 +84,10 @@ pub fn render_with_highlighting(\n /// Processes a program (nested in the internal `lexer`), classifying strings of\n /// text by highlighting category (`Class`). Calls out to a `Writer` to write\n /// each span of text in sequence.\n-struct Classifier<'a> {\n-    lexer: lexer::StringReader<'a>,\n+struct Classifier<'sess> {\n+    lexer: lexer::StringReader<'sess>,\n     peek_token: Option<Token>,\n-    source_map: &'a SourceMap,\n+    source_map: &'sess SourceMap,\n \n     // State of the classifier.\n     in_attribute: bool,\n@@ -154,6 +165,7 @@ impl<U: Write> Writer for U {\n     }\n }\n \n+#[derive(Debug)]\n enum HighlightError {\n     LexError,\n     IoError(io::Error),\n@@ -165,12 +177,14 @@ impl From<io::Error> for HighlightError {\n     }\n }\n \n-impl<'a> Classifier<'a> {\n-    fn new(lexer: lexer::StringReader<'a>, source_map: &'a SourceMap) -> Classifier<'a> {\n+impl<'sess> Classifier<'sess> {\n+    fn new(sess: &ParseSess, source_file: Lrc<SourceFile>) -> Classifier<'_> {\n+        let lexer = lexer::StringReader::new(sess, source_file, None);\n+\n         Classifier {\n             lexer,\n             peek_token: None,\n-            source_map,\n+            source_map: sess.source_map(),\n             in_attribute: false,\n             in_macro: false,\n             in_macro_nonterminal: false,\n@@ -209,11 +223,17 @@ impl<'a> Classifier<'a> {\n     /// source.\n     fn write_source<W: Writer>(&mut self, out: &mut W) -> Result<(), HighlightError> {\n         loop {\n-            let next = self.try_next_token()?;\n+            let mut next = self.try_next_token()?;\n             if next == token::Eof {\n                 break;\n             }\n \n+            // Glue any tokens that need to be glued.\n+            if let Some(joint) = next.glue(self.peek()?) {\n+                next = joint;\n+                let _ = self.try_next_token()?;\n+            }\n+\n             self.write_token(out, next)?;\n         }\n \n@@ -429,3 +449,6 @@ fn write_header(class: Option<&str>, out: &mut dyn Write) -> io::Result<()> {\n fn write_footer(out: &mut dyn Write, playground_button: Option<&str>) -> io::Result<()> {\n     write!(out, \"</pre>{}</div>\\n\", if let Some(button) = playground_button { button } else { \"\" })\n }\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "01b25fd6be4ac9bce04084b695ef2423dd9cfd96", "filename": "src/librustdoc/html/highlight/tests.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/c3ee75d956a52791dd0e50391f941030a112f7ef/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3ee75d956a52791dd0e50391f941030a112f7ef/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs?ref=c3ee75d956a52791dd0e50391f941030a112f7ef", "patch": "@@ -0,0 +1,82 @@\n+use rustc_ast::attr::with_session_globals;\n+use rustc_session::parse::ParseSess;\n+use rustc_span::edition::Edition;\n+use rustc_span::FileName;\n+\n+use super::Classifier;\n+\n+fn highlight(src: &str) -> String {\n+    let mut out = vec![];\n+\n+    with_session_globals(Edition::Edition2018, || {\n+        let sess = ParseSess::with_silent_emitter();\n+        let source_file = sess.source_map().new_source_file(\n+            FileName::Custom(String::from(\"rustdoc-highlighting\")),\n+            src.to_owned(),\n+        );\n+\n+        let mut classifier = Classifier::new(&sess, source_file);\n+        classifier.write_source(&mut out).unwrap();\n+    });\n+\n+    String::from_utf8(out).unwrap()\n+}\n+\n+#[test]\n+fn function() {\n+    assert_eq!(\n+        highlight(\"fn main() {}\"),\n+        r#\"<span class=\"kw\">fn</span> <span class=\"ident\">main</span>() {}\"#,\n+    );\n+}\n+\n+#[test]\n+fn statement() {\n+    assert_eq!(\n+        highlight(\"let foo = true;\"),\n+        concat!(\n+            r#\"<span class=\"kw\">let</span> <span class=\"ident\">foo</span> \"#,\n+            r#\"<span class=\"op\">=</span> <span class=\"bool-val\">true</span>;\"#,\n+        ),\n+    );\n+}\n+\n+#[test]\n+fn inner_attr() {\n+    assert_eq!(\n+        highlight(r##\"#![crate_type = \"lib\"]\"##),\n+        concat!(\n+            r##\"<span class=\"attribute\">#![<span class=\"ident\">crate_type</span> \"##,\n+            r##\"<span class=\"op\">=</span> <span class=\"string\">&quot;lib&quot;</span>]</span>\"##,\n+        ),\n+    );\n+}\n+\n+#[test]\n+fn outer_attr() {\n+    assert_eq!(\n+        highlight(r##\"#[cfg(target_os = \"linux\")]\"##),\n+        concat!(\n+            r##\"<span class=\"attribute\">#[<span class=\"ident\">cfg</span>(\"##,\n+            r##\"<span class=\"ident\">target_os</span> <span class=\"op\">=</span> \"##,\n+            r##\"<span class=\"string\">&quot;linux&quot;</span>)]</span>\"##,\n+        ),\n+    );\n+}\n+\n+#[test]\n+fn mac() {\n+    assert_eq!(\n+        highlight(\"mac!(foo bar)\"),\n+        concat!(\n+            r#\"<span class=\"macro\">mac</span><span class=\"macro\">!</span>(\"#,\n+            r#\"<span class=\"ident\">foo</span> <span class=\"ident\">bar</span>)\"#,\n+        ),\n+    );\n+}\n+\n+// Regression test for #72684\n+#[test]\n+fn andand() {\n+    assert_eq!(highlight(\"&&\"), r#\"<span class=\"op\">&amp;&amp;</span>\"#);\n+}"}, {"sha": "d09fe454e137df46d36235e818252492a62d471c", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3ee75d956a52791dd0e50391f941030a112f7ef/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3ee75d956a52791dd0e50391f941030a112f7ef/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=c3ee75d956a52791dd0e50391f941030a112f7ef", "patch": "@@ -292,7 +292,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n \n         if let Some((s1, s2)) = tooltip {\n             s.push_str(&highlight::render_with_highlighting(\n-                &text,\n+                text,\n                 Some(&format!(\n                     \"rust-example-rendered{}\",\n                     if ignore != Ignore::None {\n@@ -313,7 +313,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n             Some(Event::Html(s.into()))\n         } else {\n             s.push_str(&highlight::render_with_highlighting(\n-                &text,\n+                text,\n                 Some(&format!(\n                     \"rust-example-rendered{}\",\n                     if ignore != Ignore::None {"}, {"sha": "7d05caa3aea843ca3ed4aa2a4a7630bc1d8bb75a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c3ee75d956a52791dd0e50391f941030a112f7ef/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3ee75d956a52791dd0e50391f941030a112f7ef/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=c3ee75d956a52791dd0e50391f941030a112f7ef", "patch": "@@ -4525,7 +4525,12 @@ fn sidebar_foreign_type(buf: &mut Buffer, it: &clean::Item) {\n \n fn item_macro(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Macro) {\n     wrap_into_docblock(w, |w| {\n-        w.write_str(&highlight::render_with_highlighting(&t.source, Some(\"macro\"), None, None))\n+        w.write_str(&highlight::render_with_highlighting(\n+            t.source.clone(),\n+            Some(\"macro\"),\n+            None,\n+            None,\n+        ))\n     });\n     document(w, cx, it)\n }"}, {"sha": "e3215921f125c7bfe1b313c776ee1dac19b07e23", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c3ee75d956a52791dd0e50391f941030a112f7ef/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3ee75d956a52791dd0e50391f941030a112f7ef/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=c3ee75d956a52791dd0e50391f941030a112f7ef", "patch": "@@ -75,16 +75,17 @@ impl<'a> SourceCollector<'a> {\n             return Ok(());\n         }\n \n-        let contents = match fs::read_to_string(&p) {\n+        let mut contents = match fs::read_to_string(&p) {\n             Ok(contents) => contents,\n             Err(e) => {\n                 return Err(Error::new(e, &p));\n             }\n         };\n \n         // Remove the utf-8 BOM if any\n-        let contents =\n-            if contents.starts_with(\"\\u{feff}\") { &contents[3..] } else { &contents[..] };\n+        if contents.starts_with(\"\\u{feff}\") {\n+            contents.drain(..3);\n+        }\n \n         // Create the intermediate directories\n         let mut cur = self.dst.clone();\n@@ -122,7 +123,7 @@ impl<'a> SourceCollector<'a> {\n             &self.scx.layout,\n             &page,\n             \"\",\n-            |buf: &mut _| print_src(buf, &contents),\n+            |buf: &mut _| print_src(buf, contents),\n             &self.scx.style_files,\n         );\n         self.scx.fs.write(&cur, v.as_bytes())?;\n@@ -160,7 +161,7 @@ where\n \n /// Wrapper struct to render the source code of a file. This will do things like\n /// adding line numbers to the left-hand side.\n-fn print_src(buf: &mut Buffer, s: &str) {\n+fn print_src(buf: &mut Buffer, s: String) {\n     let lines = s.lines().count();\n     let mut cols = 0;\n     let mut tmp = lines;"}]}