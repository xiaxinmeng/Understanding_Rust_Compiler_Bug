{"sha": "2f16d9ef0044ec6197ef1876dfb960ced2882064", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMTZkOWVmMDA0NGVjNjE5N2VmMTg3NmRmYjk2MGNlZDI4ODIwNjQ=", "commit": {"author": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2014-06-28T13:59:45Z"}, "committer": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2014-06-30T19:35:47Z"}, "message": "Fix JSON documentation\n\nFixed some errors, removed some code examples and added usage of the\n`encode` and `decode` functions.", "tree": {"sha": "5f17188b38ec7d3d1e52a0bdb70c77a972457806", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f17188b38ec7d3d1e52a0bdb70c77a972457806"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f16d9ef0044ec6197ef1876dfb960ced2882064", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f16d9ef0044ec6197ef1876dfb960ced2882064", "html_url": "https://github.com/rust-lang/rust/commit/2f16d9ef0044ec6197ef1876dfb960ced2882064", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f16d9ef0044ec6197ef1876dfb960ced2882064/comments", "author": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "954c3234a0c871856908ab0cabaf1b8ccbba9cbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/954c3234a0c871856908ab0cabaf1b8ccbba9cbc", "html_url": "https://github.com/rust-lang/rust/commit/954c3234a0c871856908ab0cabaf1b8ccbba9cbc"}], "stats": {"total": 167, "additions": 40, "deletions": 127}, "files": [{"sha": "041715ecb6d8176b9e79285deb9ec794db078701", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 40, "deletions": 127, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/2f16d9ef0044ec6197ef1876dfb960ced2882064/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f16d9ef0044ec6197ef1876dfb960ced2882064/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=2f16d9ef0044ec6197ef1876dfb960ced2882064", "patch": "@@ -20,12 +20,19 @@ JSON parsing and serialization\n # What is JSON?\n \n JSON (JavaScript Object Notation) is a way to write data in Javascript.\n-Like XML it allows one to encode structured data in a text format that can be read by humans easily.\n-Its native compatibility with JavaScript and its simple syntax make it used widely.\n+Like XML, it allows to encode structured data in a text format that can be easily read by humans.\n+Its simple syntax and native compatibility with JavaScript have made it a widely used format.\n+\n+Data types that can be encoded are JavaScript types (see the `Json` enum for more details):\n+\n+* `Boolean`: equivalent to rust's `bool`\n+* `Number`: equivalent to rust's `f64`\n+* `String`: equivalent to rust's `String`\n+* `Array`: equivalent to rust's `Vec<T>`, but also allowing objects of different types in the same\n+array\n+* `Object`: equivalent to rust's `Treemap<String, json::Json>`\n+* `Null`\n \n-Json data are encoded in a form of \"key\":\"value\".\n-Data types that can be encoded are JavaScript types :\n-boolean (`true` or `false`), number (`f64`), string, array, object, null.\n An object is a series of string keys mapping to values, in `\"key\": value` format.\n Arrays are enclosed in square brackets ([ ... ]) and objects in curly brackets ({ ... }).\n A simple JSON document encoding a person, his/her age, address and phone numbers could look like:\n@@ -49,105 +56,20 @@ A simple JSON document encoding a person, his/her age, address and phone numbers\n \n # Rust Type-based Encoding and Decoding\n \n-Rust provides a mechanism for low boilerplate encoding & decoding\n-of values to and from JSON via the serialization API.\n+Rust provides a mechanism for low boilerplate encoding & decoding of values to and from JSON via\n+the serialization API.\n To be able to encode a piece of data, it must implement the `serialize::Encodable` trait.\n To be able to decode a piece of data, it must implement the `serialize::Decodable` trait.\n-The Rust compiler provides an annotation to automatically generate\n-the code for these traits: `#[deriving(Decodable, Encodable)]`\n-\n-To encode using Encodable :\n-\n-```rust\n-use std::io;\n-use serialize::{json, Encodable};\n-\n- #[deriving(Encodable)]\n- pub struct TestStruct   {\n-    data_str: String,\n- }\n-\n-fn main() {\n-    let to_encode_object = TestStruct{data_str:\"example of string to encode\".to_string()};\n-    let mut m = io::MemWriter::new();\n-    {\n-        let mut encoder = json::Encoder::new(&mut m as &mut Writer);\n-        match to_encode_object.encode(&mut encoder) {\n-            Ok(()) => (),\n-            Err(e) => fail!(\"json encoding error: {}\", e)\n-        };\n-    }\n-}\n-```\n-\n-Two wrapper functions are provided to encode a Encodable object\n-into a string (String) or buffer (vec![u8]): `str_encode(&m)` and `buffer_encode(&m)`.\n+The Rust compiler provides an annotation to automatically generate the code for these traits:\n+`#[deriving(Decodable, Encodable)]`\n \n-```rust\n-use serialize::json;\n-let to_encode_object = \"example of string to encode\".to_string();\n-let encoded_str: String = json::Encoder::str_encode(&to_encode_object);\n-```\n-\n-JSON API provide an enum `json::Json` and a trait `ToJson` to encode object.\n-The trait `ToJson` encode object into a container `json::Json` and the API provide writer\n-to encode them into a stream or a string ...\n+The JSON API provides an enum `json::Json` and a trait `ToJson` to encode objects.\n+The `ToJson` trait provides a `to_json` method to convert an object into a `json::Json` value.\n+A `json::Json` value can be encoded as a string or buffer using the functions described above.\n+You can also use the `json::Encoder` object, which implements the `Encoder` trait.\n \n When using `ToJson` the `Encodable` trait implementation is not mandatory.\n \n-A basic `ToJson` example using a TreeMap of attribute name / attribute value:\n-\n-\n-```rust\n-use std::collections::TreeMap;\n-use serialize::json;\n-use serialize::json::ToJson;\n-\n-pub struct MyStruct  {\n-    attr1: u8,\n-    attr2: String,\n-}\n-\n-impl ToJson for MyStruct {\n-    fn to_json( &self ) -> json::Json {\n-        let mut d = box TreeMap::new();\n-        d.insert(\"attr1\".to_string(), self.attr1.to_json());\n-        d.insert(\"attr2\".to_string(), self.attr2.to_json());\n-        json::Object(d)\n-    }\n-}\n-\n-fn main() {\n-    let test2: MyStruct = MyStruct {attr1: 1, attr2:\"test\".to_string()};\n-    let tjson: json::Json = test2.to_json();\n-    let json_str: String = tjson.to_str().into_string();\n-}\n-```\n-\n-To decode a JSON string using `Decodable` trait :\n-\n-```rust\n-extern crate serialize;\n-use serialize::{json, Decodable};\n-\n-#[deriving(Decodable)]\n-pub struct MyStruct  {\n-     attr1: u8,\n-     attr2: String,\n-}\n-\n-fn main() {\n-    let json_str_to_decode: String =\n-            \"{\\\"attr1\\\":1,\\\"attr2\\\":\\\"toto\\\"}\".to_string();\n-    let json_object = json::from_str(json_str_to_decode.as_slice());\n-    let mut decoder = json::Decoder::new(json_object.unwrap());\n-    let decoded_object: MyStruct = match Decodable::decode(&mut decoder) {\n-        Ok(v) => v,\n-        Err(e) => fail!(\"Decoding error: {}\", e)\n-    }; // create the final object\n-}\n-```\n-\n # Examples of use\n \n ## Using Autoserialization\n@@ -157,41 +79,37 @@ using the serialization API, using the derived serialization code.\n \n ```rust\n extern crate serialize;\n-use serialize::{json, Encodable, Decodable};\n+use serialize::json;\n \n- #[deriving(Decodable, Encodable)] //generate Decodable, Encodable impl.\n- pub struct TestStruct1  {\n+#[deriving(Decodable, Encodable)] //generate Decodable, Encodable impl.\n+pub struct TestStruct1  {\n     data_int: u8,\n     data_str: String,\n     data_vector: Vec<u8>,\n- }\n+}\n \n-// To serialize use the `json::str_encode` to encode an object in a string.\n-// It calls the generated `Encodable` impl.\n fn main() {\n-    let to_encode_object = TestStruct1\n+    let object = TestStruct1\n          {data_int: 1, data_str:\"toto\".to_string(), data_vector:vec![2,3,4,5]};\n-    let encoded_str: String = json::Encoder::str_encode(&to_encode_object);\n \n-    // To deserialize use the `json::from_str` and `json::Decoder`\n+    // Serialize using `json::encode`\n+    let encoded = json::encode(&object);\n \n-    let json_object = json::from_str(encoded_str.as_slice());\n-    let mut decoder = json::Decoder::new(json_object.unwrap());\n-    let decoded1: TestStruct1 = Decodable::decode(&mut decoder).unwrap(); // create the final object\n+    // Deserialize using `json::decode`\n+    let decoded: TestStruct1 = json::decode(encoded.as_slice()).unwrap();\n }\n ```\n \n ## Using `ToJson`\n \n-This example uses the ToJson impl to deserialize the JSON string.\n-Example of `ToJson` trait implementation for TestStruct1.\n+This example uses the `ToJson` trait to generate the JSON string.\n \n ```rust\n use std::collections::TreeMap;\n use serialize::json::ToJson;\n-use serialize::{json, Encodable, Decodable};\n+use serialize::json;\n \n-#[deriving(Decodable, Encodable)] // generate Decodable, Encodable impl.\n+#[deriving(Decodable)]\n pub struct TestStruct1  {\n     data_int: u8,\n     data_str: String,\n@@ -200,7 +118,7 @@ pub struct TestStruct1  {\n \n impl ToJson for TestStruct1 {\n     fn to_json( &self ) -> json::Json {\n-        let mut d = box TreeMap::new();\n+        let mut d = TreeMap::new();\n         d.insert(\"data_int\".to_string(), self.data_int.to_json());\n         d.insert(\"data_str\".to_string(), self.data_str.to_json());\n         d.insert(\"data_vector\".to_string(), self.data_vector.to_json());\n@@ -209,19 +127,13 @@ impl ToJson for TestStruct1 {\n }\n \n fn main() {\n-    // Serialization using our impl of to_json\n-\n-    let test2: TestStruct1 = TestStruct1 {data_int: 1, data_str:\"toto\".to_string(),\n-                                          data_vector:vec![2,3,4,5]};\n+    // Serialize using `ToJson`\n+    let test2 = TestStruct1 {data_int: 1, data_str:\"toto\".to_string(), data_vector:vec![2,3,4,5]};\n     let tjson: json::Json = test2.to_json();\n-    let json_str: String = tjson.to_str().into_string();\n-\n-    // Deserialize like before.\n+    let json_str: String = tjson.to_str();\n \n-    let mut decoder =\n-        json::Decoder::new(json::from_str(json_str.as_slice()).unwrap());\n-    // create the final object\n-    let decoded2: TestStruct1 = Decodable::decode(&mut decoder).unwrap();\n+    // Deserialize like before\n+    let decoded: TestStruct1 = json::decode(json_str.as_slice()).unwrap();\n }\n ```\n \n@@ -1058,7 +970,8 @@ impl Stack {\n         match *self.stack.get(idx) {\n             InternalIndex(i) => { Index(i) }\n             InternalKey(start, size) => {\n-                Key(str::from_utf8(self.str_buffer.slice(start as uint, (start+size) as uint)).unwrap())\n+                Key(str::from_utf8(\n+                    self.str_buffer.slice(start as uint, start as uint + size as uint)).unwrap())\n             }\n         }\n     }"}]}