{"sha": "2a819ae465c5f375df00ead0b3f4c9009da23f25", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhODE5YWU0NjVjNWYzNzVkZjAwZWFkMGIzZjRjOTAwOWRhMjNmMjU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-23T22:11:28Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-23T22:11:28Z"}, "message": "core::rt: Tasks to not require an unwinder\n\nA task without an unwinder will abort the process on failure.\nI'm using this in the runtime tests to guarantee that a call to\n`assert!` actually triggers some kind of failure (an abort)\ninstead of silently doing nothing. This is essentially in lieu\nof a working linked failure implementation.", "tree": {"sha": "7b0653aeac4be8708634ea0887713fe8a72811e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b0653aeac4be8708634ea0887713fe8a72811e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a819ae465c5f375df00ead0b3f4c9009da23f25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a819ae465c5f375df00ead0b3f4c9009da23f25", "html_url": "https://github.com/rust-lang/rust/commit/2a819ae465c5f375df00ead0b3f4c9009da23f25", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a819ae465c5f375df00ead0b3f4c9009da23f25/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4af40a1db4862cfe1f17311e3e39cfff3324d82", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4af40a1db4862cfe1f17311e3e39cfff3324d82", "html_url": "https://github.com/rust-lang/rust/commit/f4af40a1db4862cfe1f17311e3e39cfff3324d82"}], "stats": {"total": 173, "additions": 126, "deletions": 47}, "files": [{"sha": "a3b2cb4aaf959d675730306f59151eb4db4351e1", "filename": "src/libcore/core.rc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a819ae465c5f375df00ead0b3f4c9009da23f25/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2a819ae465c5f375df00ead0b3f4c9009da23f25/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=2a819ae465c5f375df00ead0b3f4c9009da23f25", "patch": "@@ -114,6 +114,9 @@ pub mod linkhack {\n     }\n }\n \n+// Internal macros\n+mod macros;\n+\n /* The Prelude. */\n \n pub mod prelude;"}, {"sha": "e1276a75e0557eb8e35113d36a8e5ab58ba6b14b", "filename": "src/libcore/macros.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2a819ae465c5f375df00ead0b3f4c9009da23f25/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a819ae465c5f375df00ead0b3f4c9009da23f25/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=2a819ae465c5f375df00ead0b3f4c9009da23f25", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_escape];\n+\n+// Some basic logging\n+macro_rules! rtdebug (\n+    ($( $arg:expr),+) => ( {\n+        dumb_println(fmt!( $($arg),+ ));\n+\n+        fn dumb_println(s: &str) {\n+            use io::WriterUtil;\n+            let dbg = ::libc::STDERR_FILENO as ::io::fd_t;\n+            dbg.write_str(s);\n+            dbg.write_str(\"\\n\");\n+        }\n+\n+    } )\n+)\n+\n+// An alternate version with no output, for turning off logging\n+macro_rules! rtdebug_ (\n+    ($( $arg:expr),+) => ( $(let _ = $arg)*; )\n+)\n+\n+macro_rules! abort(\n+    ($( $msg:expr),+) => ( {\n+        rtdebug!($($msg),+);\n+\n+        unsafe { ::libc::abort(); }\n+    } )\n+)"}, {"sha": "d09d082c8581c14b5897f688e57341aa1da91029", "filename": "src/libcore/rt/local_services.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2a819ae465c5f375df00ead0b3f4c9009da23f25/src%2Flibcore%2Frt%2Flocal_services.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a819ae465c5f375df00ead0b3f4c9009da23f25/src%2Flibcore%2Frt%2Flocal_services.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_services.rs?ref=2a819ae465c5f375df00ead0b3f4c9009da23f25", "patch": "@@ -29,7 +29,7 @@ pub struct LocalServices {\n     gc: GarbageCollector,\n     storage: LocalStorage,\n     logger: Logger,\n-    unwinder: Unwinder,\n+    unwinder: Option<Unwinder>,\n     destroyed: bool\n }\n \n@@ -48,7 +48,18 @@ impl LocalServices {\n             gc: GarbageCollector,\n             storage: LocalStorage(ptr::null(), None),\n             logger: Logger,\n-            unwinder: Unwinder { unwinding: false },\n+            unwinder: Some(Unwinder { unwinding: false }),\n+            destroyed: false\n+        }\n+    }\n+\n+    pub fn without_unwinding() -> LocalServices {\n+        LocalServices {\n+            heap: LocalHeap::new(),\n+            gc: GarbageCollector,\n+            storage: LocalStorage(ptr::null(), None),\n+            logger: Logger,\n+            unwinder: None,\n             destroyed: false\n         }\n     }\n@@ -60,7 +71,16 @@ impl LocalServices {\n             assert!(ptr::ref_eq(sched, self));\n         }\n \n-        self.unwinder.try(f);\n+        match self.unwinder {\n+            Some(ref mut unwinder) => {\n+                // If there's an unwinder then set up the catch block\n+                unwinder.try(f);\n+            }\n+            None => {\n+                // Otherwise, just run the body\n+                f()\n+            }\n+        }\n         self.destroy();\n     }\n \n@@ -189,9 +209,9 @@ mod test {\n     #[test]\n     fn unwind() {\n         do run_in_newsched_task() {\n-            let result = spawn_try(||());\n+            let result = spawntask_try(||());\n             assert!(result.is_ok());\n-            let result = spawn_try(|| fail!());\n+            let result = spawntask_try(|| fail!());\n             assert!(result.is_err());\n         }\n     }"}, {"sha": "ab89a4c26a54d0e349502a6d59944a8623989906", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2a819ae465c5f375df00ead0b3f4c9009da23f25/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a819ae465c5f375df00ead0b3f4c9009da23f25/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=2a819ae465c5f375df00ead0b3f4c9009da23f25", "patch": "@@ -12,26 +12,6 @@\n \n use libc::c_char;\n \n-// Some basic logging\n-macro_rules! rtdebug_ (\n-    ($( $arg:expr),+) => ( {\n-        dumb_println(fmt!( $($arg),+ ));\n-\n-        fn dumb_println(s: &str) {\n-            use io::WriterUtil;\n-            let dbg = ::libc::STDERR_FILENO as ::io::fd_t;\n-            dbg.write_str(s);\n-            dbg.write_str(\"\\n\");\n-        }\n-\n-    } )\n-)\n-\n-// An alternate version with no output, for turning off logging\n-macro_rules! rtdebug (\n-    ($( $arg:expr),+) => ( $(let _ = $arg)*; )\n-)\n-\n #[path = \"sched/mod.rs\"]\n mod sched;\n mod rtio;"}, {"sha": "f7b9bd8266844080e0551728560e1dca534afbe1", "filename": "src/libcore/rt/sched/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2a819ae465c5f375df00ead0b3f4c9009da23f25/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a819ae465c5f375df00ead0b3f4c9009da23f25/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched%2Fmod.rs?ref=2a819ae465c5f375df00ead0b3f4c9009da23f25", "patch": "@@ -149,7 +149,7 @@ pub impl Scheduler {\n             }\n         }\n \n-        // Control never reaches here\n+        abort!(\"control reached end of task\");\n     }\n \n     fn schedule_new_task(~self, task: ~Task) {\n@@ -333,14 +333,20 @@ pub struct Task {\n \n pub impl Task {\n     fn new(stack_pool: &mut StackPool, start: ~fn()) -> Task {\n+        Task::with_local(stack_pool, LocalServices::new(), start)\n+    }\n+\n+    fn with_local(stack_pool: &mut StackPool,\n+                  local_services: LocalServices,\n+                  start: ~fn()) -> Task {\n         let start = Task::build_start_wrapper(start);\n         let mut stack = stack_pool.take_segment(TASK_MIN_STACK_SIZE);\n         // NB: Context holds a pointer to that ~fn\n         let initial_context = Context::new(start, &mut stack);\n         return Task {\n             current_stack_segment: stack,\n             saved_context: initial_context,\n-            local_services: LocalServices::new()\n+            local_services: local_services\n         };\n     }\n "}, {"sha": "f7ba881f84edb4529cca5c85be6ce7e685dc57bd", "filename": "src/libcore/rt/test.rs", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2a819ae465c5f375df00ead0b3f4c9009da23f25/src%2Flibcore%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a819ae465c5f375df00ead0b3f4c9009da23f25/src%2Flibcore%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftest.rs?ref=2a819ae465c5f375df00ead0b3f4c9009da23f25", "patch": "@@ -8,38 +8,56 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use cell::Cell;\n use result::{Result, Ok, Err};\n use super::io::net::ip::{IpAddr, Ipv4};\n+use rt::local_services::LocalServices;\n \n /// Creates a new scheduler in a new thread and runs a task in it,\n-/// then waits for the scheduler to exit.\n+/// then waits for the scheduler to exit. Failure of the task\n+/// will abort the process.\n pub fn run_in_newsched_task(f: ~fn()) {\n-    use cell::Cell;\n     use unstable::run_in_bare_thread;\n     use super::sched::Task;\n     use super::uvio::UvEventLoop;\n \n-    let f = Cell(Cell(f));\n+    let f = Cell(f);\n \n     do run_in_bare_thread {\n         let mut sched = ~UvEventLoop::new_scheduler();\n-        let f = f.take();\n-        let task = ~do Task::new(&mut sched.stack_pool) {\n-            (f.take())();\n-        };\n+        let task = ~Task::with_local(&mut sched.stack_pool,\n+                                     LocalServices::without_unwinding(),\n+                                     f.take());\n         sched.task_queue.push_back(task);\n         sched.run();\n     }\n }\n \n-/// Create a new task and run it right now\n-pub fn spawn_immediately(f: ~fn()) {\n-    use cell::Cell;\n+/// Test tasks will abort on failure instead of unwinding\n+pub fn spawntask(f: ~fn()) {\n+    use super::*;\n+    use super::sched::*;\n+\n+    let mut sched = local_sched::take();\n+    let task = ~Task::with_local(&mut sched.stack_pool,\n+                                 LocalServices::without_unwinding(),\n+                                 f);\n+    do sched.switch_running_tasks_and_then(task) |task| {\n+        let task = Cell(task);\n+        let sched = local_sched::take();\n+        sched.schedule_new_task(task.take());\n+    }\n+}\n+\n+/// Create a new task and run it right now. Aborts on failure\n+pub fn spawntask_immediately(f: ~fn()) {\n     use super::*;\n     use super::sched::*;\n \n     let mut sched = local_sched::take();\n-    let task = ~Task::new(&mut sched.stack_pool, f);\n+    let task = ~Task::with_local(&mut sched.stack_pool,\n+                                 LocalServices::without_unwinding(),\n+                                 f);\n     do sched.switch_running_tasks_and_then(task) |task| {\n         let task = Cell(task);\n         do local_sched::borrow |sched| {\n@@ -49,7 +67,7 @@ pub fn spawn_immediately(f: ~fn()) {\n }\n \n /// Spawn a task and wait for it to finish, returning whether it completed successfully or failed\n-pub fn spawn_try(f: ~fn()) -> Result<(), ()> {\n+pub fn spawntask_try(f: ~fn()) -> Result<(), ()> {\n     use cell::Cell;\n     use super::sched::*;\n     use task;"}, {"sha": "4cceb048cbc75fb4207ef8f7be4c198d97a85c41", "filename": "src/libcore/rt/uvio.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2a819ae465c5f375df00ead0b3f4c9009da23f25/src%2Flibcore%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a819ae465c5f375df00ead0b3f4c9009da23f25/src%2Flibcore%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvio.rs?ref=2a819ae465c5f375df00ead0b3f4c9009da23f25", "patch": "@@ -350,7 +350,7 @@ fn test_simple_tcp_server_and_client() {\n         let addr = next_test_ip4();\n \n         // Start the server first so it's listening when we connect\n-        do spawn_immediately {\n+        do spawntask_immediately {\n             unsafe {\n                 let io = local_sched::unsafe_borrow_io();\n                 let mut listener = io.bind(addr).unwrap();\n@@ -367,7 +367,7 @@ fn test_simple_tcp_server_and_client() {\n             }\n         }\n \n-        do spawn_immediately {\n+        do spawntask_immediately {\n             unsafe {\n                 let io = local_sched::unsafe_borrow_io();\n                 let mut stream = io.connect(addr).unwrap();\n@@ -383,7 +383,7 @@ fn test_read_and_block() {\n     do run_in_newsched_task {\n         let addr = next_test_ip4();\n \n-        do spawn_immediately {\n+        do spawntask_immediately {\n             let io = unsafe { local_sched::unsafe_borrow_io() };\n             let mut listener = io.bind(addr).unwrap();\n             let mut stream = listener.listen().unwrap();\n@@ -421,7 +421,7 @@ fn test_read_and_block() {\n             listener.close();\n         }\n \n-        do spawn_immediately {\n+        do spawntask_immediately {\n             let io = unsafe { local_sched::unsafe_borrow_io() };\n             let mut stream = io.connect(addr).unwrap();\n             stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n@@ -440,7 +440,7 @@ fn test_read_read_read() {\n         let addr = next_test_ip4();\n         static MAX: uint = 500000;\n         \n-        do spawn_immediately {\n+        do spawntask_immediately {\n             unsafe {\n                 let io = local_sched::unsafe_borrow_io();\n                 let mut listener = io.bind(addr).unwrap();\n@@ -456,7 +456,7 @@ fn test_read_read_read() {\n             }\n         }\n \n-        do spawn_immediately {\n+        do spawntask_immediately {\n             let io = unsafe { local_sched::unsafe_borrow_io() };\n             let mut stream = io.connect(addr).unwrap();\n             let mut buf = [0, .. 2048];"}, {"sha": "2c3670ad498e2e4bdf5be8bff9b2b19c3f29931b", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a819ae465c5f375df00ead0b3f4c9009da23f25/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a819ae465c5f375df00ead0b3f4c9009da23f25/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=2a819ae465c5f375df00ead0b3f4c9009da23f25", "patch": "@@ -10,6 +10,7 @@\n \n //! Misc low level stuff\n \n+use option::{Some, None};\n use cast;\n use cmp::{Eq, Ord};\n use gc;\n@@ -154,7 +155,10 @@ pub fn begin_unwind(msg: ~str, file: ~str, line: uint) -> ! {\n             gc::cleanup_stack_for_failure();\n             unsafe {\n                 let local_services = unsafe_borrow_local_services();\n-                local_services.unwinder.begin_unwind();\n+                match local_services.unwinder {\n+                    Some(ref mut unwinder) => unwinder.begin_unwind(),\n+                    None => abort!(\"failure without unwinder. aborting process\")\n+                }\n             }\n         }\n     }"}, {"sha": "d31a511eca8c9dc49a6b9868c1957138cafee480", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2a819ae465c5f375df00ead0b3f4c9009da23f25/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a819ae465c5f375df00ead0b3f4c9009da23f25/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=2a819ae465c5f375df00ead0b3f4c9009da23f25", "patch": "@@ -570,7 +570,16 @@ pub fn failing() -> bool {\n         _ => {\n             let mut unwinding = false;\n             do borrow_local_services |local| {\n-                unwinding = local.unwinder.unwinding;\n+                unwinding = match local.unwinder {\n+                    Some(unwinder) => {\n+                        unwinder.unwinding\n+                    }\n+                    None => {\n+                        // Because there is no unwinder we can't be unwinding.\n+                        // (The process will abort on failure)\n+                        false\n+                    }\n+                }\n             }\n             return unwinding;\n         }"}]}