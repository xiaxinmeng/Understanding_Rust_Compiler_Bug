{"sha": "a486f3404884a664b71dfdf01fd6208fe56902b7", "node_id": "C_kwDOAAsO6NoAKGE0ODZmMzQwNDg4NGE2NjRiNzFkZmRmMDFmZDYyMDhmZTU2OTAyYjc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-29T12:49:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-29T12:49:24Z"}, "message": "Auto merge of #14434 - Veykril:ty-tail-norm, r=Veykril\n\nfix: Use struct_tail_without_normalization in Expectation::rvalue_hint", "tree": {"sha": "19d22f00822f116eac78ea7ed1ffe07e8d6536ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19d22f00822f116eac78ea7ed1ffe07e8d6536ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a486f3404884a664b71dfdf01fd6208fe56902b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a486f3404884a664b71dfdf01fd6208fe56902b7", "html_url": "https://github.com/rust-lang/rust/commit/a486f3404884a664b71dfdf01fd6208fe56902b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a486f3404884a664b71dfdf01fd6208fe56902b7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a98e24777d127c8d3cdb322aa7e9ea4f4dba5e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a98e24777d127c8d3cdb322aa7e9ea4f4dba5e3", "html_url": "https://github.com/rust-lang/rust/commit/7a98e24777d127c8d3cdb322aa7e9ea4f4dba5e3"}, {"sha": "bea1c71f833ad9b8dacd98b1f950000ff9ab2f74", "url": "https://api.github.com/repos/rust-lang/rust/commits/bea1c71f833ad9b8dacd98b1f950000ff9ab2f74", "html_url": "https://github.com/rust-lang/rust/commit/bea1c71f833ad9b8dacd98b1f950000ff9ab2f74"}], "stats": {"total": 85, "additions": 71, "deletions": 14}, "files": [{"sha": "ab08593bcf6779b5eaf306568b0a90b2f8b9d2c2", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 62, "deletions": 4, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a486f3404884a664b71dfdf01fd6208fe56902b7/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a486f3404884a664b71dfdf01fd6208fe56902b7/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=a486f3404884a664b71dfdf01fd6208fe56902b7", "patch": "@@ -13,8 +13,8 @@\n //! to certain types. To record this, we use the union-find implementation from\n //! the `ena` crate, which is extracted from rustc.\n \n-use std::ops::Index;\n use std::sync::Arc;\n+use std::{convert::identity, ops::Index};\n \n use chalk_ir::{cast::Cast, ConstValue, DebruijnIndex, Mutability, Safety, Scalar, TypeFlags};\n use either::Either;\n@@ -791,6 +791,65 @@ impl<'a> InferenceContext<'a> {\n         self.table.unify(ty1, ty2)\n     }\n \n+    /// Attempts to returns the deeply last field of nested structures, but\n+    /// does not apply any normalization in its search. Returns the same type\n+    /// if input `ty` is not a structure at all.\n+    fn struct_tail_without_normalization(&mut self, ty: Ty) -> Ty {\n+        self.struct_tail_with_normalize(ty, identity)\n+    }\n+\n+    /// Returns the deeply last field of nested structures, or the same type if\n+    /// not a structure at all. Corresponds to the only possible unsized field,\n+    /// and its type can be used to determine unsizing strategy.\n+    ///\n+    /// This is parameterized over the normalization strategy (i.e. how to\n+    /// handle `<T as Trait>::Assoc` and `impl Trait`); pass the identity\n+    /// function to indicate no normalization should take place.\n+    fn struct_tail_with_normalize(\n+        &mut self,\n+        mut ty: Ty,\n+        mut normalize: impl FnMut(Ty) -> Ty,\n+    ) -> Ty {\n+        // FIXME: fetch the limit properly\n+        let recursion_limit = 10;\n+        for iteration in 0.. {\n+            if iteration > recursion_limit {\n+                return self.err_ty();\n+            }\n+            match ty.kind(Interner) {\n+                TyKind::Adt(chalk_ir::AdtId(hir_def::AdtId::StructId(struct_id)), substs) => {\n+                    match self.db.field_types((*struct_id).into()).values().next_back().cloned() {\n+                        Some(field) => {\n+                            ty = field.substitute(Interner, substs);\n+                        }\n+                        None => break,\n+                    }\n+                }\n+                TyKind::Adt(..) => break,\n+                TyKind::Tuple(_, substs) => {\n+                    match substs\n+                        .as_slice(Interner)\n+                        .split_last()\n+                        .and_then(|(last_ty, _)| last_ty.ty(Interner))\n+                    {\n+                        Some(last_ty) => ty = last_ty.clone(),\n+                        None => break,\n+                    }\n+                }\n+                TyKind::Alias(..) => {\n+                    let normalized = normalize(ty.clone());\n+                    if ty == normalized {\n+                        return ty;\n+                    } else {\n+                        ty = normalized;\n+                    }\n+                }\n+                _ => break,\n+            }\n+        }\n+        ty\n+    }\n+\n     /// Recurses through the given type, normalizing associated types mentioned\n     /// in it by replacing them by type variables and registering obligations to\n     /// resolve later. This should be done once for every type we get from some\n@@ -1138,9 +1197,8 @@ impl Expectation {\n     /// which still is useful, because it informs integer literals and the like.\n     /// See the test case `test/ui/coerce-expect-unsized.rs` and #20169\n     /// for examples of where this comes up,.\n-    fn rvalue_hint(table: &mut unify::InferenceTable<'_>, ty: Ty) -> Self {\n-        // FIXME: do struct_tail_without_normalization\n-        match table.resolve_ty_shallow(&ty).kind(Interner) {\n+    fn rvalue_hint(ctx: &mut InferenceContext<'_>, ty: Ty) -> Self {\n+        match ctx.struct_tail_without_normalization(ty.clone()).kind(Interner) {\n             TyKind::Slice(_) | TyKind::Str | TyKind::Dyn(_) => Expectation::RValueLikeUnsized(ty),\n             _ => Expectation::has_type(ty),\n         }"}, {"sha": "35372ee9a90491fbb0c00f3372dfc1db579c0ec3", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a486f3404884a664b71dfdf01fd6208fe56902b7/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a486f3404884a664b71dfdf01fd6208fe56902b7/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=a486f3404884a664b71dfdf01fd6208fe56902b7", "patch": "@@ -643,7 +643,7 @@ impl<'a> InferenceContext<'a> {\n                         // FIXME: record type error - expected reference but found ptr,\n                         // which cannot be coerced\n                     }\n-                    Expectation::rvalue_hint(&mut self.table, Ty::clone(exp_inner))\n+                    Expectation::rvalue_hint(self, Ty::clone(exp_inner))\n                 } else {\n                     Expectation::none()\n                 };\n@@ -998,7 +998,7 @@ impl<'a> InferenceContext<'a> {\n                 .filter(|(e_adt, _)| e_adt == &box_id)\n                 .map(|(_, subts)| {\n                     let g = subts.at(Interner, 0);\n-                    Expectation::rvalue_hint(table, Ty::clone(g.assert_ty_ref(Interner)))\n+                    Expectation::rvalue_hint(self, Ty::clone(g.assert_ty_ref(Interner)))\n                 })\n                 .unwrap_or_else(Expectation::none);\n \n@@ -1593,7 +1593,7 @@ impl<'a> InferenceContext<'a> {\n                 // the parameter to coerce to the expected type (for example in\n                 // `coerce_unsize_expected_type_4`).\n                 let param_ty = self.normalize_associated_types_in(param_ty);\n-                let expected = Expectation::rvalue_hint(&mut self.table, expected_ty);\n+                let expected = Expectation::rvalue_hint(self, expected_ty);\n                 // infer with the expected type we have...\n                 let ty = self.infer_expr_inner(arg, &expected);\n "}, {"sha": "ce1a22cc51be3a7754f1f4a6cc52cc6b1a9ff7dc", "filename": "crates/hir-ty/src/tests/coercion.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a486f3404884a664b71dfdf01fd6208fe56902b7/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a486f3404884a664b71dfdf01fd6208fe56902b7/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=a486f3404884a664b71dfdf01fd6208fe56902b7", "patch": "@@ -536,7 +536,6 @@ fn test() {\n \n #[test]\n fn coerce_unsize_generic() {\n-    // FIXME: fix the type mismatches here\n     check(\n         r#\"\n //- minicore: coerce_unsized\n@@ -545,9 +544,9 @@ struct Bar<T>(Foo<T>);\n \n fn test() {\n     let _: &Foo<[usize]> = &Foo { t: [1, 2, 3] };\n-                                   //^^^^^^^^^ expected [usize], got [usize; 3]\n+                         //^^^^^^^^^^^^^^^^^^^^^ expected &Foo<[usize]>, got &Foo<[i32; 3]>\n     let _: &Bar<[usize]> = &Bar(Foo { t: [1, 2, 3] });\n-                                       //^^^^^^^^^ expected [usize], got [usize; 3]\n+                         //^^^^^^^^^^^^^^^^^^^^^^^^^^ expected &Bar<[usize]>, got &Bar<[i32; 3]>\n }\n \"#,\n     );"}, {"sha": "610f7d92d654ea0f2f81626cec682d8418c7fa7b", "filename": "lib/la-arena/src/map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a486f3404884a664b71dfdf01fd6208fe56902b7/lib%2Fla-arena%2Fsrc%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a486f3404884a664b71dfdf01fd6208fe56902b7/lib%2Fla-arena%2Fsrc%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Fla-arena%2Fsrc%2Fmap.rs?ref=a486f3404884a664b71dfdf01fd6208fe56902b7", "patch": "@@ -72,17 +72,17 @@ impl<T, V> ArenaMap<Idx<T>, V> {\n     }\n \n     /// Returns an iterator over the values in the map.\n-    pub fn values(&self) -> impl Iterator<Item = &V> {\n+    pub fn values(&self) -> impl Iterator<Item = &V> + DoubleEndedIterator {\n         self.v.iter().filter_map(|o| o.as_ref())\n     }\n \n     /// Returns an iterator over mutable references to the values in the map.\n-    pub fn values_mut(&mut self) -> impl Iterator<Item = &mut V> {\n+    pub fn values_mut(&mut self) -> impl Iterator<Item = &mut V> + DoubleEndedIterator {\n         self.v.iter_mut().filter_map(|o| o.as_mut())\n     }\n \n     /// Returns an iterator over the arena indexes and values in the map.\n-    pub fn iter(&self) -> impl Iterator<Item = (Idx<T>, &V)> {\n+    pub fn iter(&self) -> impl Iterator<Item = (Idx<T>, &V)> + DoubleEndedIterator {\n         self.v.iter().enumerate().filter_map(|(idx, o)| Some((Self::from_idx(idx), o.as_ref()?)))\n     }\n \n@@ -96,7 +96,7 @@ impl<T, V> ArenaMap<Idx<T>, V> {\n \n     /// Returns an iterator over the arena indexes and values in the map.\n     // FIXME: Implement `IntoIterator` trait.\n-    pub fn into_iter(self) -> impl Iterator<Item = (Idx<T>, V)> {\n+    pub fn into_iter(self) -> impl Iterator<Item = (Idx<T>, V)> + DoubleEndedIterator {\n         self.v.into_iter().enumerate().filter_map(|(idx, o)| Some((Self::from_idx(idx), o?)))\n     }\n "}]}