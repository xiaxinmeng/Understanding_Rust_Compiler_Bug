{"sha": "452181c69d2a106d9d5a1262b69e68a765c4b3e3", "node_id": "C_kwDOAAsO6NoAKDQ1MjE4MWM2OWQyYTEwNmQ5ZDVhMTI2MmI2OWU2OGE3NjVjNGIzZTM", "commit": {"author": {"name": "Yechan Bae", "email": "yechan@gatech.edu", "date": "2021-09-17T06:55:26Z"}, "committer": {"name": "Yechan Bae", "email": "yechan@gatech.edu", "date": "2021-10-09T09:38:19Z"}, "message": "Implement uninit_vec lint", "tree": {"sha": "d4296a1462a2e3e9441fa7a13018e5ca2eb52b9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4296a1462a2e3e9441fa7a13018e5ca2eb52b9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/452181c69d2a106d9d5a1262b69e68a765c4b3e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/452181c69d2a106d9d5a1262b69e68a765c4b3e3", "html_url": "https://github.com/rust-lang/rust/commit/452181c69d2a106d9d5a1262b69e68a765c4b3e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/452181c69d2a106d9d5a1262b69e68a765c4b3e3/comments", "author": {"login": "Qwaz", "id": 5073807, "node_id": "MDQ6VXNlcjUwNzM4MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/5073807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Qwaz", "html_url": "https://github.com/Qwaz", "followers_url": "https://api.github.com/users/Qwaz/followers", "following_url": "https://api.github.com/users/Qwaz/following{/other_user}", "gists_url": "https://api.github.com/users/Qwaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Qwaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Qwaz/subscriptions", "organizations_url": "https://api.github.com/users/Qwaz/orgs", "repos_url": "https://api.github.com/users/Qwaz/repos", "events_url": "https://api.github.com/users/Qwaz/events{/privacy}", "received_events_url": "https://api.github.com/users/Qwaz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Qwaz", "id": 5073807, "node_id": "MDQ6VXNlcjUwNzM4MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/5073807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Qwaz", "html_url": "https://github.com/Qwaz", "followers_url": "https://api.github.com/users/Qwaz/followers", "following_url": "https://api.github.com/users/Qwaz/following{/other_user}", "gists_url": "https://api.github.com/users/Qwaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Qwaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Qwaz/subscriptions", "organizations_url": "https://api.github.com/users/Qwaz/orgs", "repos_url": "https://api.github.com/users/Qwaz/repos", "events_url": "https://api.github.com/users/Qwaz/events{/privacy}", "received_events_url": "https://api.github.com/users/Qwaz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22144c02c2d790c2e3b74dc0363000511284f6d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/22144c02c2d790c2e3b74dc0363000511284f6d8", "html_url": "https://github.com/rust-lang/rust/commit/22144c02c2d790c2e3b74dc0363000511284f6d8"}], "stats": {"total": 290, "additions": 278, "deletions": 12}, "files": [{"sha": "2c69432f31c3dc829b09d4acb70093467200002a", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/452181c69d2a106d9d5a1262b69e68a765c4b3e3/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/452181c69d2a106d9d5a1262b69e68a765c4b3e3/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=452181c69d2a106d9d5a1262b69e68a765c4b3e3", "patch": "@@ -3038,6 +3038,7 @@ Released 2018-09-13\n [`unicode_not_nfc`]: https://rust-lang.github.io/rust-clippy/master/index.html#unicode_not_nfc\n [`unimplemented`]: https://rust-lang.github.io/rust-clippy/master/index.html#unimplemented\n [`uninit_assumed_init`]: https://rust-lang.github.io/rust-clippy/master/index.html#uninit_assumed_init\n+[`uninit_vec`]: https://rust-lang.github.io/rust-clippy/master/index.html#uninit_vec\n [`unit_arg`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_arg\n [`unit_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_cmp\n [`unit_return_expecting_ord`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_return_expecting_ord"}, {"sha": "f0ef0befea03723e7dfa97dad04805e0b7972ce5", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/452181c69d2a106d9d5a1262b69e68a765c4b3e3/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/452181c69d2a106d9d5a1262b69e68a765c4b3e3/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=452181c69d2a106d9d5a1262b69e68a765c4b3e3", "patch": "@@ -278,6 +278,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(types::VEC_BOX),\n     LintId::of(undropped_manually_drops::UNDROPPED_MANUALLY_DROPS),\n     LintId::of(unicode::INVISIBLE_CHARACTERS),\n+    LintId::of(uninit_vec::UNINIT_VEC),\n     LintId::of(unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD),\n     LintId::of(unit_types::UNIT_ARG),\n     LintId::of(unit_types::UNIT_CMP),"}, {"sha": "8eb662195e2314561f6b3f687366b14d58f0de33", "filename": "clippy_lints/src/lib.register_correctness.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/452181c69d2a106d9d5a1262b69e68a765c4b3e3/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/452181c69d2a106d9d5a1262b69e68a765c4b3e3/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_correctness.rs?ref=452181c69d2a106d9d5a1262b69e68a765c4b3e3", "patch": "@@ -63,6 +63,7 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(transmuting_null::TRANSMUTING_NULL),\n     LintId::of(undropped_manually_drops::UNDROPPED_MANUALLY_DROPS),\n     LintId::of(unicode::INVISIBLE_CHARACTERS),\n+    LintId::of(uninit_vec::UNINIT_VEC),\n     LintId::of(unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD),\n     LintId::of(unit_types::UNIT_CMP),\n     LintId::of(unnamed_address::FN_ADDRESS_COMPARISONS),"}, {"sha": "401c5b78b38308a3e37e94f06824062ca053c8b3", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/452181c69d2a106d9d5a1262b69e68a765c4b3e3/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/452181c69d2a106d9d5a1262b69e68a765c4b3e3/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=452181c69d2a106d9d5a1262b69e68a765c4b3e3", "patch": "@@ -470,6 +470,7 @@ store.register_lints(&[\n     unicode::INVISIBLE_CHARACTERS,\n     unicode::NON_ASCII_LITERAL,\n     unicode::UNICODE_NOT_NFC,\n+    uninit_vec::UNINIT_VEC,\n     unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD,\n     unit_types::LET_UNIT_VALUE,\n     unit_types::UNIT_ARG,"}, {"sha": "829d5acdfde364c399a823b78013dfaa05c447d9", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/452181c69d2a106d9d5a1262b69e68a765c4b3e3/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/452181c69d2a106d9d5a1262b69e68a765c4b3e3/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=452181c69d2a106d9d5a1262b69e68a765c4b3e3", "patch": "@@ -361,6 +361,7 @@ mod types;\n mod undocumented_unsafe_blocks;\n mod undropped_manually_drops;\n mod unicode;\n+mod uninit_vec;\n mod unit_return_expecting_ord;\n mod unit_types;\n mod unnamed_address;\n@@ -518,6 +519,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(blocks_in_if_conditions::BlocksInIfConditions));\n     store.register_late_pass(|| Box::new(collapsible_match::CollapsibleMatch));\n     store.register_late_pass(|| Box::new(unicode::Unicode));\n+    store.register_late_pass(|| Box::new(uninit_vec::UninitVec));\n     store.register_late_pass(|| Box::new(unit_return_expecting_ord::UnitReturnExpectingOrd));\n     store.register_late_pass(|| Box::new(strings::StringAdd));\n     store.register_late_pass(|| Box::new(implicit_return::ImplicitReturn));"}, {"sha": "dbd91fb6d9de130dbf87c60d3b10c1e360cbd38e", "filename": "clippy_lints/src/methods/uninit_assumed_init.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/452181c69d2a106d9d5a1262b69e68a765c4b3e3/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/452181c69d2a106d9d5a1262b69e68a765c4b3e3/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs?ref=452181c69d2a106d9d5a1262b69e68a765c4b3e3", "patch": "@@ -1,9 +1,8 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{is_expr_path_def_path, match_def_path, paths};\n+use clippy_utils::{is_expr_path_def_path, is_uninit_ty_valid, paths};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n-use rustc_middle::ty::{self, Ty};\n \n use super::UNINIT_ASSUMED_INIT;\n \n@@ -13,7 +12,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n         if let hir::ExprKind::Call(callee, args) = recv.kind;\n         if args.is_empty();\n         if is_expr_path_def_path(cx, callee, &paths::MEM_MAYBEUNINIT_UNINIT);\n-        if !is_maybe_uninit_ty_valid(cx, cx.typeck_results().expr_ty_adjusted(expr));\n+        if !is_uninit_ty_valid(cx, cx.typeck_results().expr_ty_adjusted(expr));\n         then {\n             span_lint(\n                 cx,\n@@ -24,12 +23,3 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n         }\n     }\n }\n-\n-fn is_maybe_uninit_ty_valid(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n-    match ty.kind() {\n-        ty::Array(component, _) => is_maybe_uninit_ty_valid(cx, component),\n-        ty::Tuple(types) => types.types().all(|ty| is_maybe_uninit_ty_valid(cx, ty)),\n-        ty::Adt(adt, _) => match_def_path(cx, adt.did, &paths::MEM_MAYBEUNINIT),\n-        _ => false,\n-    }\n-}"}, {"sha": "ff302289a1fe8356c30c8041903f126f424a069d", "filename": "clippy_lints/src/uninit_vec.rs", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/452181c69d2a106d9d5a1262b69e68a765c4b3e3/clippy_lints%2Fsrc%2Funinit_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/452181c69d2a106d9d5a1262b69e68a765c4b3e3/clippy_lints%2Fsrc%2Funinit_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funinit_vec.rs?ref=452181c69d2a106d9d5a1262b69e68a765c4b3e3", "patch": "@@ -0,0 +1,174 @@\n+use clippy_utils::diagnostics::span_lint_and_note;\n+use clippy_utils::{is_uninit_ty_valid, match_def_path, path_to_local_id, paths, peel_hir_expr_while, SpanlessEq};\n+use rustc_hir::def::Res;\n+use rustc_hir::{Block, Expr, ExprKind, HirId, PatKind, Stmt, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for the creation of uninitialized `Vec<T>` by calling `set_len()`\n+    /// immediately after `with_capacity()` or `reserve()`.\n+    ///\n+    /// ### Why is this bad?\n+    /// It creates `Vec<T>` that contains uninitialized data, which leads to an\n+    /// undefined behavior with most safe operations.\n+    /// Notably, using uninitialized `Vec<u8>` with generic `Read` is unsound.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// let mut vec: Vec<u8> = Vec::with_capacity(1000);\n+    /// unsafe { vec.set_len(1000); }\n+    /// reader.read(&mut vec); // undefined behavior!\n+    /// ```\n+    /// Use an initialized buffer:\n+    /// ```rust,ignore\n+    /// let mut vec: Vec<u8> = vec![0; 1000];\n+    /// reader.read(&mut vec);\n+    /// ```\n+    /// Or, wrap the content in `MaybeUninit`:\n+    /// ```rust,ignore\n+    /// let mut vec: Vec<MaybeUninit<T>> = Vec::with_capacity(1000);\n+    /// unsafe { vec.set_len(1000); }\n+    /// ```\n+    pub UNINIT_VEC,\n+    correctness,\n+    \"Vec with uninitialized data\"\n+}\n+\n+declare_lint_pass!(UninitVec => [UNINIT_VEC]);\n+\n+impl<'tcx> LateLintPass<'tcx> for UninitVec {\n+    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx Block<'_>) {\n+        for w in block.stmts.windows(2) {\n+            if let StmtKind::Expr(expr) | StmtKind::Semi(expr) = w[1].kind {\n+                handle_pair(cx, &w[0], expr);\n+            }\n+        }\n+\n+        if let (Some(stmt), Some(expr)) = (block.stmts.last(), block.expr) {\n+            handle_pair(cx, stmt, expr);\n+        }\n+    }\n+}\n+\n+fn handle_pair(cx: &LateContext<'tcx>, first: &'tcx Stmt<'tcx>, second: &'tcx Expr<'tcx>) {\n+    if_chain! {\n+        if let Some(vec) = extract_with_capacity_or_reserve_target(cx, first);\n+        if let Some((set_len_self, call_span)) = extract_set_len_self(cx, second);\n+        if vec.eq_expr(cx, set_len_self);\n+        if let ty::Ref(_, vec_ty, _) = cx.typeck_results().expr_ty_adjusted(set_len_self).kind();\n+        if let ty::Adt(_, substs) = vec_ty.kind();\n+        // Check T of Vec<T>\n+        if !is_uninit_ty_valid(cx, substs.type_at(0));\n+        then {\n+            span_lint_and_note(\n+                cx,\n+                UNINIT_VEC,\n+                call_span,\n+                \"calling `set_len()` immediately after reserving a buffer creates uninitialized values\",\n+                Some(first.span),\n+                \"the buffer is reserved here\"\n+            );\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+enum LocalOrExpr<'tcx> {\n+    Local(HirId),\n+    Expr(&'tcx Expr<'tcx>),\n+}\n+\n+impl<'tcx> LocalOrExpr<'tcx> {\n+    fn eq_expr(self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+        match self {\n+            LocalOrExpr::Local(hir_id) => path_to_local_id(expr, hir_id),\n+            LocalOrExpr::Expr(self_expr) => SpanlessEq::new(cx).eq_expr(self_expr, expr),\n+        }\n+    }\n+}\n+\n+/// Returns the target vec of Vec::with_capacity() or Vec::reserve()\n+fn extract_with_capacity_or_reserve_target(cx: &LateContext<'_>, stmt: &'tcx Stmt<'_>) -> Option<LocalOrExpr<'tcx>> {\n+    match stmt.kind {\n+        StmtKind::Local(local) => {\n+            // let mut x = Vec::with_capacity()\n+            if_chain! {\n+                if let Some(init_expr) = local.init;\n+                if let PatKind::Binding(_, hir_id, _, None) = local.pat.kind;\n+                if is_with_capacity(cx, init_expr);\n+                then {\n+                    Some(LocalOrExpr::Local(hir_id))\n+                } else {\n+                    None\n+                }\n+            }\n+        },\n+        StmtKind::Expr(expr) | StmtKind::Semi(expr) => {\n+            match expr.kind {\n+                ExprKind::Assign(lhs, rhs, _span) if is_with_capacity(cx, rhs) => {\n+                    // self.vec = Vec::with_capacity()\n+                    Some(LocalOrExpr::Expr(lhs))\n+                },\n+                ExprKind::MethodCall(_, _, [vec_expr, _], _) => {\n+                    // self.vec.reserve()\n+                    if_chain! {\n+                        if let Some(id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+                        if match_def_path(cx, id, &paths::VEC_RESERVE);\n+                        then {\n+                            Some(LocalOrExpr::Expr(vec_expr))\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                },\n+                _ => None,\n+            }\n+        },\n+        _ => None,\n+    }\n+}\n+\n+fn is_with_capacity(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> bool {\n+    if_chain! {\n+        if let ExprKind::Call(path_expr, _) = &expr.kind;\n+        if let ExprKind::Path(qpath) = &path_expr.kind;\n+        if let Res::Def(_, def_id) = cx.qpath_res(qpath, path_expr.hir_id);\n+        then {\n+            match_def_path(cx, def_id, &paths::VEC_WITH_CAPACITY)\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+/// Returns self if the expression is Vec::set_len()\n+fn extract_set_len_self(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Option<(&'tcx Expr<'tcx>, Span)> {\n+    // peel unsafe blocks in `unsafe { vec.set_len() }`\n+    let expr = peel_hir_expr_while(expr, |e| {\n+        if let ExprKind::Block(block, _) = e.kind {\n+            match (block.stmts.get(0).map(|stmt| &stmt.kind), block.expr) {\n+                (None, Some(expr)) => Some(expr),\n+                (Some(StmtKind::Expr(expr) | StmtKind::Semi(expr)), None) => Some(expr),\n+                _ => None,\n+            }\n+        } else {\n+            None\n+        }\n+    });\n+    match expr.kind {\n+        ExprKind::MethodCall(_, _, [vec_expr, _], _) => {\n+            cx.typeck_results().type_dependent_def_id(expr.hir_id).and_then(|id| {\n+                if match_def_path(cx, id, &paths::VEC_SET_LEN) {\n+                    Some((vec_expr, expr.span))\n+                } else {\n+                    None\n+                }\n+            })\n+        },\n+        _ => None,\n+    }\n+}"}, {"sha": "00d2098a021b6adb36a957e9d0ca3fee2fb4580c", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/452181c69d2a106d9d5a1262b69e68a765c4b3e3/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/452181c69d2a106d9d5a1262b69e68a765c4b3e3/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=452181c69d2a106d9d5a1262b69e68a765c4b3e3", "patch": "@@ -1470,6 +1470,16 @@ pub fn is_self_ty(slf: &hir::Ty<'_>) -> bool {\n     false\n }\n \n+/// Checks if a given type looks safe to be uninitialized.\n+pub fn is_uninit_ty_valid(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n+    match ty.kind() {\n+        rustc_ty::Array(component, _) => is_uninit_ty_valid(cx, component),\n+        rustc_ty::Tuple(types) => types.types().all(|ty| is_uninit_ty_valid(cx, ty)),\n+        rustc_ty::Adt(adt, _) => match_def_path(cx, adt.did, &paths::MEM_MAYBEUNINIT),\n+        _ => false,\n+    }\n+}\n+\n pub fn iter_input_pats<'tcx>(decl: &FnDecl<'_>, body: &'tcx Body<'_>) -> impl Iterator<Item = &'tcx Param<'tcx>> {\n     (0..decl.inputs.len()).map(move |i| &body.params[i])\n }"}, {"sha": "dffe30910dd51e81c98d74c9a448b33f30733b4f", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/452181c69d2a106d9d5a1262b69e68a765c4b3e3/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/452181c69d2a106d9d5a1262b69e68a765c4b3e3/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=452181c69d2a106d9d5a1262b69e68a765c4b3e3", "patch": "@@ -183,5 +183,8 @@ pub const VEC_AS_SLICE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"as_slice\"];\n pub const VEC_FROM_ELEM: [&str; 3] = [\"alloc\", \"vec\", \"from_elem\"];\n pub const VEC_NEW: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"new\"];\n pub const VEC_RESIZE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"resize\"];\n+pub const VEC_RESERVE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"reserve\"];\n+pub const VEC_WITH_CAPACITY: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"with_capacity\"];\n+pub const VEC_SET_LEN: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"set_len\"];\n pub const WEAK_ARC: [&str; 3] = [\"alloc\", \"sync\", \"Weak\"];\n pub const WEAK_RC: [&str; 3] = [\"alloc\", \"rc\", \"Weak\"];"}, {"sha": "5e67288405adcbb01f72d367f5603351051720a6", "filename": "tests/ui/uninit_vec.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/452181c69d2a106d9d5a1262b69e68a765c4b3e3/tests%2Fui%2Funinit_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/452181c69d2a106d9d5a1262b69e68a765c4b3e3/tests%2Fui%2Funinit_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinit_vec.rs?ref=452181c69d2a106d9d5a1262b69e68a765c4b3e3", "patch": "@@ -0,0 +1,32 @@\n+#![warn(clippy::uninit_vec)]\n+\n+use std::mem::MaybeUninit;\n+\n+fn main() {\n+    // with_capacity() -> set_len() should be detected\n+    let mut vec: Vec<u8> = Vec::with_capacity(1000);\n+    unsafe {\n+        vec.set_len(200);\n+    }\n+\n+    // reserve() -> set_len() should be detected\n+    vec.reserve(1000);\n+    unsafe {\n+        vec.set_len(200);\n+    }\n+\n+    // test when both calls are enclosed in the same unsafe block\n+    unsafe {\n+        let mut vec: Vec<u8> = Vec::with_capacity(1000);\n+        vec.set_len(200);\n+\n+        vec.reserve(1000);\n+        vec.set_len(200);\n+    }\n+\n+    // MaybeUninit-wrapped types should not be detected\n+    let mut vec: Vec<MaybeUninit<u8>> = Vec::with_capacity(1000);\n+    unsafe {\n+        vec.set_len(200);\n+    }\n+}"}, {"sha": "1d7807fcf7d0ed82ad9415dae749cb3fa33fd8e9", "filename": "tests/ui/uninit_vec.stderr", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/452181c69d2a106d9d5a1262b69e68a765c4b3e3/tests%2Fui%2Funinit_vec.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/452181c69d2a106d9d5a1262b69e68a765c4b3e3/tests%2Fui%2Funinit_vec.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinit_vec.stderr?ref=452181c69d2a106d9d5a1262b69e68a765c4b3e3", "patch": "@@ -0,0 +1,51 @@\n+error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n+  --> $DIR/uninit_vec.rs:9:9\n+   |\n+LL |         vec.set_len(200);\n+   |         ^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::uninit-vec` implied by `-D warnings`\n+note: the buffer is reserved here\n+  --> $DIR/uninit_vec.rs:7:5\n+   |\n+LL |     let mut vec: Vec<u8> = Vec::with_capacity(1000);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n+  --> $DIR/uninit_vec.rs:15:9\n+   |\n+LL |         vec.set_len(200);\n+   |         ^^^^^^^^^^^^^^^^\n+   |\n+note: the buffer is reserved here\n+  --> $DIR/uninit_vec.rs:13:5\n+   |\n+LL |     vec.reserve(1000);\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n+  --> $DIR/uninit_vec.rs:21:9\n+   |\n+LL |         vec.set_len(200);\n+   |         ^^^^^^^^^^^^^^^^\n+   |\n+note: the buffer is reserved here\n+  --> $DIR/uninit_vec.rs:20:9\n+   |\n+LL |         let mut vec: Vec<u8> = Vec::with_capacity(1000);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n+  --> $DIR/uninit_vec.rs:24:9\n+   |\n+LL |         vec.set_len(200);\n+   |         ^^^^^^^^^^^^^^^^\n+   |\n+note: the buffer is reserved here\n+  --> $DIR/uninit_vec.rs:23:9\n+   |\n+LL |         vec.reserve(1000);\n+   |         ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}]}