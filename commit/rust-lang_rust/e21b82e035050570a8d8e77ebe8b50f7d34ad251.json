{"sha": "e21b82e035050570a8d8e77ebe8b50f7d34ad251", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyMWI4MmUwMzUwNTA1NzBhOGQ4ZTc3ZWJlOGI1MGY3ZDM0YWQyNTE=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-11-15T19:32:58Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-11-16T12:11:29Z"}, "message": "Upgrade Chalk\n\nAssociated type values (in impls) are now a separate entity in Chalk, so we have\nto intern separate IDs for them.", "tree": {"sha": "a72782de07c150cc3677259633bdf695aed9b8d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a72782de07c150cc3677259633bdf695aed9b8d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e21b82e035050570a8d8e77ebe8b50f7d34ad251", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e21b82e035050570a8d8e77ebe8b50f7d34ad251", "html_url": "https://github.com/rust-lang/rust/commit/e21b82e035050570a8d8e77ebe8b50f7d34ad251", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e21b82e035050570a8d8e77ebe8b50f7d34ad251/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9d99369b2765eaef7f49cd519990769191c3381", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9d99369b2765eaef7f49cd519990769191c3381", "html_url": "https://github.com/rust-lang/rust/commit/d9d99369b2765eaef7f49cd519990769191c3381"}], "stats": {"total": 380, "additions": 240, "deletions": 140}, "files": [{"sha": "88fb66a56d495d0bc7cd98413c4d3eb81b35fb87", "filename": "Cargo.lock", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e21b82e035050570a8d8e77ebe8b50f7d34ad251/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e21b82e035050570a8d8e77ebe8b50f7d34ad251/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e21b82e035050570a8d8e77ebe8b50f7d34ad251", "patch": "@@ -123,7 +123,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n [[package]]\n name = \"chalk-derive\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05#50f9f636123bd88d0cc1b958749981d6702e4d05\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d#102eba3659fc26a2451ed845f9ca4ceb8f79c22d\"\n dependencies = [\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -133,52 +133,52 @@ dependencies = [\n [[package]]\n name = \"chalk-engine\"\n version = \"0.9.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05#50f9f636123bd88d0cc1b958749981d6702e4d05\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d#102eba3659fc26a2451ed845f9ca4ceb8f79c22d\"\n dependencies = [\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"stacker 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chalk-ir\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05#50f9f636123bd88d0cc1b958749981d6702e4d05\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d#102eba3659fc26a2451ed845f9ca4ceb8f79c22d\"\n dependencies = [\n- \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n+ \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d)\",\n+ \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d)\",\n  \"lalrpop-intern 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chalk-macros\"\n version = \"0.1.1\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05#50f9f636123bd88d0cc1b958749981d6702e4d05\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d#102eba3659fc26a2451ed845f9ca4ceb8f79c22d\"\n dependencies = [\n  \"lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chalk-rust-ir\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05#50f9f636123bd88d0cc1b958749981d6702e4d05\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d#102eba3659fc26a2451ed845f9ca4ceb8f79c22d\"\n dependencies = [\n- \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n+ \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d)\",\n+ \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d)\",\n ]\n \n [[package]]\n name = \"chalk-solve\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05#50f9f636123bd88d0cc1b958749981d6702e4d05\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d#102eba3659fc26a2451ed845f9ca4ceb8f79c22d\"\n dependencies = [\n- \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n+ \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d)\",\n+ \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d)\",\n  \"ena 0.13.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"petgraph 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1016,9 +1016,9 @@ name = \"ra_hir\"\n version = \"0.1.0\"\n dependencies = [\n  \"arrayvec 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d)\",\n+ \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d)\",\n+ \"chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d)\",\n  \"ena 0.13.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"insta 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lalrpop-intern 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1873,12 +1873,12 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum cargo_metadata 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8d2d1617e838936c0d2323a65cc151e03ae19a7678dd24f72bccf27119b90a5d\"\n \"checksum cc 1.0.47 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aa87058dce70a3ff5621797f1506cb837edd02ac4c0ae642b4542dce802908b8\"\n \"checksum cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n-\"checksum chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\" = \"<none>\"\n-\"checksum chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\" = \"<none>\"\n-\"checksum chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\" = \"<none>\"\n-\"checksum chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\" = \"<none>\"\n-\"checksum chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\" = \"<none>\"\n-\"checksum chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\" = \"<none>\"\n+\"checksum chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d)\" = \"<none>\"\n+\"checksum chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d)\" = \"<none>\"\n+\"checksum chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d)\" = \"<none>\"\n+\"checksum chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d)\" = \"<none>\"\n+\"checksum chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d)\" = \"<none>\"\n+\"checksum chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=102eba3659fc26a2451ed845f9ca4ceb8f79c22d)\" = \"<none>\"\n \"checksum chrono 0.4.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e8493056968583b0193c1bb04d6f7684586f3726992d6c573261941a895dbd68\"\n \"checksum clicolors-control 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"90082ee5dcdd64dc4e9e0d37fbf3ee325419e39c0092191e0393df65518f741e\"\n \"checksum cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ddfc5b9aa5d4507acaf872de71051dfd0e309860e88966e1051e462a077aac4f\""}, {"sha": "57b7da1a8906505cd1d19516935f0f925302f7f4", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e21b82e035050570a8d8e77ebe8b50f7d34ad251/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e21b82e035050570a8d8e77ebe8b50f7d34ad251/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=e21b82e035050570a8d8e77ebe8b50f7d34ad251", "patch": "@@ -23,9 +23,9 @@ hir_def = { path = \"../ra_hir_def\", package = \"ra_hir_def\" }\n test_utils = { path = \"../test_utils\" }\n ra_prof = { path = \"../ra_prof\" }\n \n-chalk-solve = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"50f9f636123bd88d0cc1b958749981d6702e4d05\" }\n-chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"50f9f636123bd88d0cc1b958749981d6702e4d05\" }\n-chalk-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"50f9f636123bd88d0cc1b958749981d6702e4d05\" }\n+chalk-solve = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"102eba3659fc26a2451ed845f9ca4ceb8f79c22d\" }\n+chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"102eba3659fc26a2451ed845f9ca4ceb8f79c22d\" }\n+chalk-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"102eba3659fc26a2451ed845f9ca4ceb8f79c22d\" }\n lalrpop-intern = \"0.15.1\"\n \n [dev-dependencies]"}, {"sha": "d9fad0ae2bbc98d6a5ad0a40a6b92edadfefe4c8", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e21b82e035050570a8d8e77ebe8b50f7d34ad251/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e21b82e035050570a8d8e77ebe8b50f7d34ad251/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=e21b82e035050570a8d8e77ebe8b50f7d34ad251", "patch": "@@ -13,8 +13,10 @@ use crate::{\n     lang_item::{LangItemTarget, LangItems},\n     traits::TraitData,\n     ty::{\n-        method_resolution::CrateImplBlocks, traits::Impl, CallableDef, FnSig, GenericPredicate,\n-        InferenceResult, Namespace, Substs, Ty, TypableDef, TypeCtor,\n+        method_resolution::CrateImplBlocks,\n+        traits::{AssocTyValue, Impl},\n+        CallableDef, FnSig, GenericPredicate, InferenceResult, Namespace, Substs, Ty, TypableDef,\n+        TypeCtor,\n     },\n     type_alias::TypeAliasData,\n     Const, ConstData, Crate, DefWithBody, FnData, Function, ImplBlock, Module, Static, StructField,\n@@ -119,6 +121,8 @@ pub trait HirDatabase: DefDatabase + AstDatabase {\n     fn intern_type_ctor(&self, type_ctor: TypeCtor) -> ids::TypeCtorId;\n     #[salsa::interned]\n     fn intern_chalk_impl(&self, impl_: Impl) -> ids::GlobalImplId;\n+    #[salsa::interned]\n+    fn intern_assoc_ty_value(&self, assoc_ty_value: AssocTyValue) -> ids::AssocTyValueId;\n \n     #[salsa::invoke(crate::ty::traits::chalk::associated_ty_data_query)]\n     fn associated_ty_data(&self, id: chalk_ir::TypeId) -> Arc<chalk_rust_ir::AssociatedTyDatum>;\n@@ -140,6 +144,13 @@ pub trait HirDatabase: DefDatabase + AstDatabase {\n     #[salsa::invoke(crate::ty::traits::chalk::impl_datum_query)]\n     fn impl_datum(&self, krate: Crate, impl_id: chalk_ir::ImplId) -> Arc<chalk_rust_ir::ImplDatum>;\n \n+    #[salsa::invoke(crate::ty::traits::chalk::associated_ty_value_query)]\n+    fn associated_ty_value(\n+        &self,\n+        krate: Crate,\n+        id: chalk_rust_ir::AssociatedTyValueId,\n+    ) -> Arc<chalk_rust_ir::AssociatedTyValue>;\n+\n     #[salsa::invoke(crate::ty::traits::trait_solve_query)]\n     fn trait_solve(\n         &self,"}, {"sha": "2b59365fb6a43a3ffa45286bb2fe628998075789", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e21b82e035050570a8d8e77ebe8b50f7d34ad251/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e21b82e035050570a8d8e77ebe8b50f7d34ad251/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=e21b82e035050570a8d8e77ebe8b50f7d34ad251", "patch": "@@ -37,3 +37,9 @@ impl_intern_key!(TypeCtorId);\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct GlobalImplId(salsa::InternId);\n impl_intern_key!(GlobalImplId);\n+\n+/// This exists just for Chalk, because it needs a unique ID for each associated\n+/// type value in an impl (even synthetic ones).\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct AssocTyValueId(salsa::InternId);\n+impl_intern_key!(AssocTyValueId);"}, {"sha": "771525deb8a7dfa1e737ed9c801ed41744f090bc", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e21b82e035050570a8d8e77ebe8b50f7d34ad251/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e21b82e035050570a8d8e77ebe8b50f7d34ad251/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=e21b82e035050570a8d8e77ebe8b50f7d34ad251", "patch": "@@ -8,7 +8,7 @@ use ra_prof::profile;\n use rustc_hash::FxHashSet;\n \n use super::{Canonical, GenericPredicate, HirDisplay, ProjectionTy, TraitRef, Ty, TypeWalk};\n-use crate::{db::HirDatabase, expr::ExprId, Crate, DefWithBody, ImplBlock, Trait};\n+use crate::{db::HirDatabase, expr::ExprId, Crate, DefWithBody, ImplBlock, Trait, TypeAlias};\n \n use self::chalk::{from_chalk, ToChalk};\n \n@@ -300,3 +300,14 @@ pub enum Impl {\n     /// Closure types implement the Fn traits synthetically.\n     ClosureFnTraitImpl(ClosureFnTraitImplData),\n }\n+\n+/// An associated type value. Usually this comes from a `type` declaration\n+/// inside an impl block, but for built-in impls we have to synthesize it.\n+/// (We only need this because Chalk wants a unique ID for each of these.)\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum AssocTyValue {\n+    /// A normal assoc type value from an impl block.\n+    TypeAlias(TypeAlias),\n+    /// The output type of the Fn trait implementation.\n+    ClosureFnTraitImplOutput(ClosureFnTraitImplData),\n+}"}, {"sha": "e39e8aaca8e1f4f1dc9cf729fc1161cd58323dd6", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 179, "deletions": 107, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/e21b82e035050570a8d8e77ebe8b50f7d34ad251/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e21b82e035050570a8d8e77ebe8b50f7d34ad251/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=e21b82e035050570a8d8e77ebe8b50f7d34ad251", "patch": "@@ -7,22 +7,19 @@ use chalk_ir::{\n     cast::Cast, family::ChalkIr, Identifier, ImplId, Parameter, PlaceholderIndex, TypeId,\n     TypeKindId, TypeName, UniverseIndex,\n };\n-use chalk_rust_ir::{AssociatedTyDatum, ImplDatum, StructDatum, TraitDatum};\n+use chalk_rust_ir::{AssociatedTyDatum, AssociatedTyValue, ImplDatum, StructDatum, TraitDatum};\n \n use hir_expand::name;\n \n use ra_db::salsa::{InternId, InternKey};\n \n-use super::{Canonical, ChalkContext, Impl, Obligation};\n+use super::{AssocTyValue, Canonical, ChalkContext, Impl, Obligation};\n use crate::{\n     db::HirDatabase,\n     generics::{GenericDef, HasGenericParams},\n     ty::display::HirDisplay,\n-    ty::{\n-        ApplicationTy, GenericPredicate, Namespace, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n-        TypeWalk,\n-    },\n-    AssocItem, Crate, HasBody, ImplBlock, Trait, TypeAlias,\n+    ty::{ApplicationTy, GenericPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk},\n+    Crate, HasBody, ImplBlock, Trait, TypeAlias,\n };\n \n /// This represents a trait whose name we could not resolve.\n@@ -59,29 +56,29 @@ impl ToChalk for Ty {\n                     }\n                 };\n                 let parameters = apply_ty.parameters.to_chalk(db);\n-                chalk_ir::ApplicationTy { name, parameters }.cast()\n+                chalk_ir::ApplicationTy { name, parameters }.cast().intern()\n             }\n             Ty::Projection(proj_ty) => {\n                 let associated_ty_id = proj_ty.associated_ty.to_chalk(db);\n                 let parameters = proj_ty.parameters.to_chalk(db);\n-                chalk_ir::ProjectionTy { associated_ty_id, parameters }.cast()\n+                chalk_ir::ProjectionTy { associated_ty_id, parameters }.cast().intern()\n             }\n             Ty::Param { idx, .. } => {\n                 PlaceholderIndex { ui: UniverseIndex::ROOT, idx: idx as usize }.to_ty::<ChalkIr>()\n             }\n-            Ty::Bound(idx) => chalk_ir::Ty::BoundVar(idx as usize),\n+            Ty::Bound(idx) => chalk_ir::TyData::BoundVar(idx as usize).intern(),\n             Ty::Infer(_infer_ty) => panic!(\"uncanonicalized infer ty\"),\n             // FIXME use Chalk's Dyn/Opaque once the bugs with that are fixed\n             Ty::Unknown | Ty::Dyn(_) | Ty::Opaque(_) => {\n                 let parameters = Vec::new();\n                 let name = TypeName::Error;\n-                chalk_ir::ApplicationTy { name, parameters }.cast()\n+                chalk_ir::ApplicationTy { name, parameters }.cast().intern()\n             }\n         }\n     }\n     fn from_chalk(db: &impl HirDatabase, chalk: chalk_ir::Ty<ChalkIr>) -> Self {\n-        match chalk {\n-            chalk_ir::Ty::Apply(apply_ty) => {\n+        match chalk.data().clone() {\n+            chalk_ir::TyData::Apply(apply_ty) => {\n                 // FIXME this is kind of hacky due to the fact that\n                 // TypeName::Placeholder is a Ty::Param on our side\n                 match apply_ty.name {\n@@ -104,21 +101,21 @@ impl ToChalk for Ty {\n                     }\n                 }\n             }\n-            chalk_ir::Ty::Projection(proj) => {\n+            chalk_ir::TyData::Projection(proj) => {\n                 let associated_ty = from_chalk(db, proj.associated_ty_id);\n                 let parameters = from_chalk(db, proj.parameters);\n                 Ty::Projection(ProjectionTy { associated_ty, parameters })\n             }\n-            chalk_ir::Ty::ForAll(_) => unimplemented!(),\n-            chalk_ir::Ty::BoundVar(idx) => Ty::Bound(idx as u32),\n-            chalk_ir::Ty::InferenceVar(_iv) => Ty::Unknown,\n-            chalk_ir::Ty::Dyn(where_clauses) => {\n+            chalk_ir::TyData::ForAll(_) => unimplemented!(),\n+            chalk_ir::TyData::BoundVar(idx) => Ty::Bound(idx as u32),\n+            chalk_ir::TyData::InferenceVar(_iv) => Ty::Unknown,\n+            chalk_ir::TyData::Dyn(where_clauses) => {\n                 assert_eq!(where_clauses.binders.len(), 1);\n                 let predicates =\n                     where_clauses.value.into_iter().map(|c| from_chalk(db, c)).collect();\n                 Ty::Dyn(predicates)\n             }\n-            chalk_ir::Ty::Opaque(where_clauses) => {\n+            chalk_ir::TyData::Opaque(where_clauses) => {\n                 assert_eq!(where_clauses.binders.len(), 1);\n                 let predicates =\n                     where_clauses.value.into_iter().map(|c| from_chalk(db, c)).collect();\n@@ -211,6 +208,21 @@ impl ToChalk for TypeAlias {\n     }\n }\n \n+impl ToChalk for AssocTyValue {\n+    type Chalk = chalk_rust_ir::AssociatedTyValueId;\n+\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_rust_ir::AssociatedTyValueId {\n+        db.intern_assoc_ty_value(self).into()\n+    }\n+\n+    fn from_chalk(\n+        db: &impl HirDatabase,\n+        assoc_ty_value_id: chalk_rust_ir::AssociatedTyValueId,\n+    ) -> AssocTyValue {\n+        db.lookup_intern_assoc_ty_value(assoc_ty_value_id.into())\n+    }\n+}\n+\n impl ToChalk for GenericPredicate {\n     type Chalk = chalk_ir::QuantifiedWhereClause<ChalkIr>;\n \n@@ -462,13 +474,11 @@ where\n     fn type_name(&self, _id: TypeKindId) -> Identifier {\n         unimplemented!()\n     }\n-    fn split_projection<'p>(\n+    fn associated_ty_value(\n         &self,\n-        projection: &'p chalk_ir::ProjectionTy<ChalkIr>,\n-    ) -> (Arc<AssociatedTyDatum>, &'p [Parameter<ChalkIr>], &'p [Parameter<ChalkIr>]) {\n-        debug!(\"split_projection {:?}\", projection);\n-        // we don't support GATs, so I think this should always be correct currently\n-        (self.db.associated_ty_data(projection.associated_ty_id), &projection.parameters, &[])\n+        id: chalk_rust_ir::AssociatedTyValueId,\n+    ) -> Arc<AssociatedTyValue> {\n+        self.db.associated_ty_value(self.krate, id)\n     }\n     fn custom_clauses(&self) -> Vec<chalk_ir::ProgramClause<ChalkIr>> {\n         vec![]\n@@ -493,19 +503,16 @@ pub(crate) fn associated_ty_data_query(\n         _ => panic!(\"associated type not in trait\"),\n     };\n     let generic_params = type_alias.generic_params(db);\n-    let parameter_kinds = generic_params\n-        .params_including_parent()\n-        .into_iter()\n-        .map(|p| chalk_ir::ParameterKind::Ty(lalrpop_intern::intern(&p.name.to_string())))\n-        .collect();\n+    let bound_data = chalk_rust_ir::AssociatedTyDatumBound {\n+        // FIXME add bounds and where clauses\n+        bounds: vec![],\n+        where_clauses: vec![],\n+    };\n     let datum = AssociatedTyDatum {\n         trait_id: trait_.to_chalk(db),\n         id,\n         name: lalrpop_intern::intern(&type_alias.name(db).to_string()),\n-        parameter_kinds,\n-        // FIXME add bounds and where clauses\n-        bounds: vec![],\n-        where_clauses: vec![],\n+        binders: make_binders(bound_data, generic_params.count_params_including_parent()),\n     };\n     Arc::new(datum)\n }\n@@ -517,33 +524,32 @@ pub(crate) fn trait_datum_query(\n ) -> Arc<TraitDatum> {\n     debug!(\"trait_datum {:?}\", trait_id);\n     if trait_id == UNKNOWN_TRAIT {\n-        let trait_datum_bound = chalk_rust_ir::TraitDatumBound {\n-            trait_ref: chalk_ir::TraitRef {\n-                trait_id: UNKNOWN_TRAIT,\n-                parameters: vec![chalk_ir::Ty::BoundVar(0).cast()],\n-            },\n-            associated_ty_ids: Vec::new(),\n-            where_clauses: Vec::new(),\n-        };\n+        let trait_datum_bound = chalk_rust_ir::TraitDatumBound { where_clauses: Vec::new() };\n \n         let flags = chalk_rust_ir::TraitFlags {\n             auto: false,\n             marker: false,\n             upstream: true,\n             fundamental: false,\n             non_enumerable: true,\n+            coinductive: false,\n         };\n-        return Arc::new(TraitDatum { binders: make_binders(trait_datum_bound, 1), flags });\n+        return Arc::new(TraitDatum {\n+            id: trait_id,\n+            binders: make_binders(trait_datum_bound, 1),\n+            flags,\n+            associated_ty_ids: vec![],\n+        });\n     }\n     let trait_: Trait = from_chalk(db, trait_id);\n     debug!(\"trait {:?} = {:?}\", trait_id, trait_.name(db));\n     let generic_params = trait_.generic_params(db);\n     let bound_vars = Substs::bound_vars(&generic_params);\n-    let trait_ref = trait_.trait_ref(db).subst(&bound_vars).to_chalk(db);\n     let flags = chalk_rust_ir::TraitFlags {\n         auto: trait_.is_auto(db),\n         upstream: trait_.module(db).krate() != krate,\n         non_enumerable: true,\n+        coinductive: false, // only relevant for Chalk testing\n         // FIXME set these flags correctly\n         marker: false,\n         fundamental: false,\n@@ -558,10 +564,13 @@ pub(crate) fn trait_datum_query(\n         })\n         .map(|type_alias| type_alias.to_chalk(db))\n         .collect();\n-    let trait_datum_bound =\n-        chalk_rust_ir::TraitDatumBound { trait_ref, where_clauses, associated_ty_ids };\n-    let trait_datum =\n-        TraitDatum { binders: make_binders(trait_datum_bound, bound_vars.len()), flags };\n+    let trait_datum_bound = chalk_rust_ir::TraitDatumBound { where_clauses };\n+    let trait_datum = TraitDatum {\n+        id: trait_id,\n+        binders: make_binders(trait_datum_bound, bound_vars.len()),\n+        flags,\n+        associated_ty_ids,\n+    };\n     Arc::new(trait_datum)\n }\n \n@@ -588,17 +597,12 @@ pub(crate) fn struct_datum_query(\n         // FIXME set fundamental flag correctly\n         fundamental: false,\n     };\n-    let self_ty = chalk_ir::ApplicationTy {\n-        name: TypeName::TypeKindId(type_ctor.to_chalk(db).into()),\n-        parameters: (0..num_params).map(|i| chalk_ir::Ty::BoundVar(i).cast()).collect(),\n-    };\n     let struct_datum_bound = chalk_rust_ir::StructDatumBound {\n-        self_ty,\n         fields: Vec::new(), // FIXME add fields (only relevant for auto traits)\n         where_clauses,\n-        flags,\n     };\n-    let struct_datum = StructDatum { binders: make_binders(struct_datum_bound, num_params) };\n+    let struct_datum =\n+        StructDatum { id: struct_id, binders: make_binders(struct_datum_bound, num_params), flags };\n     Arc::new(struct_datum)\n }\n \n@@ -612,24 +616,21 @@ pub(crate) fn impl_datum_query(\n     let impl_: Impl = from_chalk(db, impl_id);\n     match impl_ {\n         Impl::ImplBlock(impl_block) => impl_block_datum(db, krate, impl_id, impl_block),\n-        Impl::ClosureFnTraitImpl(data) => {\n-            closure_fn_trait_impl_datum(db, krate, impl_id, data).unwrap_or_else(invalid_impl_datum)\n-        }\n+        Impl::ClosureFnTraitImpl(data) => closure_fn_trait_impl_datum(db, krate, data),\n     }\n+    .unwrap_or_else(invalid_impl_datum)\n }\n \n fn impl_block_datum(\n     db: &impl HirDatabase,\n     krate: Crate,\n     impl_id: ImplId,\n     impl_block: ImplBlock,\n-) -> Arc<ImplDatum> {\n+) -> Option<Arc<ImplDatum>> {\n     let generic_params = impl_block.generic_params(db);\n     let bound_vars = Substs::bound_vars(&generic_params);\n-    let trait_ref = impl_block\n-        .target_trait_ref(db)\n-        .expect(\"FIXME handle unresolved impl block trait ref\")\n-        .subst(&bound_vars);\n+    let trait_ref = impl_block.target_trait_ref(db)?.subst(&bound_vars);\n+    let trait_ = trait_ref.trait_;\n     let impl_type = if impl_block.krate(db) == krate {\n         chalk_rust_ir::ImplType::Local\n     } else {\n@@ -644,76 +645,69 @@ fn impl_block_datum(\n         trait_ref.display(db),\n         where_clauses\n     );\n-    let trait_ = trait_ref.trait_;\n     let trait_ref = trait_ref.to_chalk(db);\n-    let associated_ty_values = impl_block\n-        .items(db)\n-        .into_iter()\n-        .filter_map(|item| match item {\n-            AssocItem::TypeAlias(t) => Some(t),\n-            _ => None,\n-        })\n-        .filter_map(|t| {\n-            let assoc_ty = trait_.associated_type_by_name(db, &t.name(db))?;\n-            let ty = db.type_for_def(t.into(), Namespace::Types).subst(&bound_vars);\n-            Some(chalk_rust_ir::AssociatedTyValue {\n-                impl_id,\n-                associated_ty_id: assoc_ty.to_chalk(db),\n-                value: chalk_ir::Binders {\n-                    value: chalk_rust_ir::AssociatedTyValueBound { ty: ty.to_chalk(db) },\n-                    binders: vec![], // we don't support GATs yet\n-                },\n-            })\n-        })\n-        .collect();\n \n     let polarity = if negative {\n         chalk_rust_ir::Polarity::Negative\n     } else {\n         chalk_rust_ir::Polarity::Positive\n     };\n \n-    let impl_datum_bound =\n-        chalk_rust_ir::ImplDatumBound { trait_ref, where_clauses, associated_ty_values };\n+    let impl_datum_bound = chalk_rust_ir::ImplDatumBound { trait_ref, where_clauses };\n+    let associated_ty_value_ids = impl_block\n+        .items(db)\n+        .into_iter()\n+        .filter_map(|item| match item {\n+            crate::AssocItem::TypeAlias(type_alias) => Some(type_alias),\n+            _ => None,\n+        })\n+        .filter(|type_alias| {\n+            // don't include associated types that don't exist in the trait\n+            trait_.associated_type_by_name(db, &type_alias.name(db)).is_some()\n+        })\n+        .map(|type_alias| AssocTyValue::TypeAlias(type_alias).to_chalk(db))\n+        .collect();\n     debug!(\"impl_datum: {:?}\", impl_datum_bound);\n     let impl_datum = ImplDatum {\n         binders: make_binders(impl_datum_bound, bound_vars.len()),\n         impl_type,\n         polarity,\n+        associated_ty_value_ids,\n     };\n-    Arc::new(impl_datum)\n+    Some(Arc::new(impl_datum))\n }\n \n fn invalid_impl_datum() -> Arc<ImplDatum> {\n     let trait_ref = chalk_ir::TraitRef {\n         trait_id: UNKNOWN_TRAIT,\n-        parameters: vec![chalk_ir::Ty::BoundVar(0).cast()],\n-    };\n-    let impl_datum_bound = chalk_rust_ir::ImplDatumBound {\n-        trait_ref,\n-        where_clauses: Vec::new(),\n-        associated_ty_values: Vec::new(),\n+        parameters: vec![chalk_ir::TyData::BoundVar(0).cast().intern().cast()],\n     };\n+    let impl_datum_bound = chalk_rust_ir::ImplDatumBound { trait_ref, where_clauses: Vec::new() };\n     let impl_datum = ImplDatum {\n         binders: make_binders(impl_datum_bound, 1),\n         impl_type: chalk_rust_ir::ImplType::External,\n         polarity: chalk_rust_ir::Polarity::Positive,\n+        associated_ty_value_ids: Vec::new(),\n     };\n     Arc::new(impl_datum)\n }\n \n fn closure_fn_trait_impl_datum(\n     db: &impl HirDatabase,\n     krate: Crate,\n-    impl_id: ImplId,\n     data: super::ClosureFnTraitImplData,\n ) -> Option<Arc<ImplDatum>> {\n     // for some closure |X, Y| -> Z:\n     // impl<T, U, V> Fn<(T, U)> for closure<fn(T, U) -> V> { Output = V }\n \n-    let fn_once_trait = get_fn_trait(db, krate, super::FnTrait::FnOnce)?;\n     let trait_ = get_fn_trait(db, krate, data.fn_trait)?; // get corresponding fn trait\n \n+    // validate FnOnce trait, since we need it in the assoc ty value definition\n+    // and don't want to return a valid value only to find out later that FnOnce\n+    // is broken\n+    let fn_once_trait = get_fn_trait(db, krate, super::FnTrait::FnOnce)?;\n+    fn_once_trait.associated_type_by_name(db, &name::OUTPUT_TYPE)?;\n+\n     let num_args: u16 = match &data.def.body(db)[data.expr] {\n         crate::expr::Expr::Lambda { args, .. } => args.len() as u16,\n         _ => {\n@@ -726,7 +720,6 @@ fn closure_fn_trait_impl_datum(\n         TypeCtor::Tuple { cardinality: num_args },\n         Substs::builder(num_args as usize).fill_with_bound_vars(0).build(),\n     );\n-    let output_ty = Ty::Bound(num_args.into());\n     let sig_ty = Ty::apply(\n         TypeCtor::FnPtr { num_args },\n         Substs::builder(num_args as usize + 1).fill_with_bound_vars(0).build(),\n@@ -739,32 +732,99 @@ fn closure_fn_trait_impl_datum(\n         substs: Substs::build_for_def(db, trait_).push(self_ty).push(arg_ty).build(),\n     };\n \n-    let output_ty_id = fn_once_trait.associated_type_by_name(db, &name::OUTPUT_TYPE)?;\n-\n-    let output_ty_value = chalk_rust_ir::AssociatedTyValue {\n-        associated_ty_id: output_ty_id.to_chalk(db),\n-        impl_id,\n-        value: make_binders(\n-            chalk_rust_ir::AssociatedTyValueBound { ty: output_ty.to_chalk(db) },\n-            0,\n-        ),\n-    };\n+    let output_ty_id = AssocTyValue::ClosureFnTraitImplOutput(data.clone()).to_chalk(db);\n \n     let impl_type = chalk_rust_ir::ImplType::External;\n \n     let impl_datum_bound = chalk_rust_ir::ImplDatumBound {\n         trait_ref: trait_ref.to_chalk(db),\n         where_clauses: Vec::new(),\n-        associated_ty_values: vec![output_ty_value],\n     };\n     let impl_datum = ImplDatum {\n         binders: make_binders(impl_datum_bound, num_args as usize + 1),\n         impl_type,\n         polarity: chalk_rust_ir::Polarity::Positive,\n+        associated_ty_value_ids: vec![output_ty_id],\n     };\n     Some(Arc::new(impl_datum))\n }\n \n+pub(crate) fn associated_ty_value_query(\n+    db: &impl HirDatabase,\n+    krate: Crate,\n+    id: chalk_rust_ir::AssociatedTyValueId,\n+) -> Arc<chalk_rust_ir::AssociatedTyValue> {\n+    let data: AssocTyValue = from_chalk(db, id);\n+    match data {\n+        AssocTyValue::TypeAlias(type_alias) => {\n+            type_alias_associated_ty_value(db, krate, type_alias)\n+        }\n+        AssocTyValue::ClosureFnTraitImplOutput(data) => {\n+            closure_fn_trait_output_assoc_ty_value(db, krate, data)\n+        }\n+    }\n+}\n+\n+fn type_alias_associated_ty_value(\n+    db: &impl HirDatabase,\n+    _krate: Crate,\n+    type_alias: TypeAlias,\n+) -> Arc<AssociatedTyValue> {\n+    let impl_block = type_alias.impl_block(db).expect(\"assoc ty value should be in impl\");\n+    let impl_id = Impl::ImplBlock(impl_block).to_chalk(db);\n+    let trait_ = impl_block\n+        .target_trait_ref(db)\n+        .expect(\"assoc ty value should not exist\") // we don't return any assoc ty values if the impl'd trait can't be resolved\n+        .trait_;\n+    let assoc_ty = trait_\n+        .associated_type_by_name(db, &type_alias.name(db))\n+        .expect(\"assoc ty value should not exist\"); // validated when building the impl data as well\n+    let generic_params = impl_block.generic_params(db);\n+    let bound_vars = Substs::bound_vars(&generic_params);\n+    let ty = db.type_for_def(type_alias.into(), crate::ty::Namespace::Types).subst(&bound_vars);\n+    let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: ty.to_chalk(db) };\n+    let value = chalk_rust_ir::AssociatedTyValue {\n+        impl_id,\n+        associated_ty_id: assoc_ty.to_chalk(db),\n+        value: make_binders(value_bound, bound_vars.len()),\n+    };\n+    Arc::new(value)\n+}\n+\n+fn closure_fn_trait_output_assoc_ty_value(\n+    db: &impl HirDatabase,\n+    krate: Crate,\n+    data: super::ClosureFnTraitImplData,\n+) -> Arc<AssociatedTyValue> {\n+    let impl_id = Impl::ClosureFnTraitImpl(data.clone()).to_chalk(db);\n+\n+    let num_args: u16 = match &data.def.body(db)[data.expr] {\n+        crate::expr::Expr::Lambda { args, .. } => args.len() as u16,\n+        _ => {\n+            log::warn!(\"closure for closure type {:?} not found\", data);\n+            0\n+        }\n+    };\n+\n+    let output_ty = Ty::Bound(num_args.into());\n+\n+    let fn_once_trait =\n+        get_fn_trait(db, krate, super::FnTrait::FnOnce).expect(\"assoc ty value should not exist\");\n+\n+    let output_ty_id = fn_once_trait\n+        .associated_type_by_name(db, &name::OUTPUT_TYPE)\n+        .expect(\"assoc ty value should not exist\");\n+\n+    let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: output_ty.to_chalk(db) };\n+\n+    let value = chalk_rust_ir::AssociatedTyValue {\n+        associated_ty_id: output_ty_id.to_chalk(db),\n+        impl_id,\n+        value: make_binders(value_bound, num_args as usize + 1),\n+    };\n+    Arc::new(value)\n+}\n+\n fn get_fn_trait(db: &impl HirDatabase, krate: Crate, fn_trait: super::FnTrait) -> Option<Trait> {\n     let target = db.lang_item(krate, fn_trait.lang_item_name().into())?;\n     match target {\n@@ -803,3 +863,15 @@ impl From<crate::ids::GlobalImplId> for chalk_ir::ImplId {\n         chalk_ir::ImplId(id_to_chalk(impl_id))\n     }\n }\n+\n+impl From<chalk_rust_ir::AssociatedTyValueId> for crate::ids::AssocTyValueId {\n+    fn from(id: chalk_rust_ir::AssociatedTyValueId) -> Self {\n+        id_from_chalk(id.0)\n+    }\n+}\n+\n+impl From<crate::ids::AssocTyValueId> for chalk_rust_ir::AssociatedTyValueId {\n+    fn from(assoc_ty_value_id: crate::ids::AssocTyValueId) -> Self {\n+        chalk_rust_ir::AssociatedTyValueId(id_to_chalk(assoc_ty_value_id))\n+    }\n+}"}]}