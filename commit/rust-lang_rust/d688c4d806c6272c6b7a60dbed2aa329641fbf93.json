{"sha": "d688c4d806c6272c6b7a60dbed2aa329641fbf93", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ODhjNGQ4MDZjNjI3MmM2YjdhNjBkYmVkMmFhMzI5NjQxZmJmOTM=", "commit": {"author": {"name": "lukaramu", "email": "lukaramu@users.noreply.github.com", "date": "2017-04-13T19:30:59Z"}, "committer": {"name": "lukaramu", "email": "lukaramu@users.noreply.github.com", "date": "2017-04-13T20:51:05Z"}, "message": "Various fixes throughout std::collections' docs\n\n* Added links where possible (limited because of facading)\n* Changed references to methods from `foo()` to `foo` in module docs\n* Changed references to methods from `HashMap::foo` to just `foo` in\n  top-level docs for `HashMap` and the `default` doc for `DefaultHasher`\n* Various small other fixes", "tree": {"sha": "5bd27ca824bc37b3a70432a9f45212311ba9cf22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5bd27ca824bc37b3a70432a9f45212311ba9cf22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d688c4d806c6272c6b7a60dbed2aa329641fbf93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d688c4d806c6272c6b7a60dbed2aa329641fbf93", "html_url": "https://github.com/rust-lang/rust/commit/d688c4d806c6272c6b7a60dbed2aa329641fbf93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d688c4d806c6272c6b7a60dbed2aa329641fbf93/comments", "author": null, "committer": null, "parents": [{"sha": "d64de94efa8a2aeb1a104c367be1b5c03b148987", "url": "https://api.github.com/repos/rust-lang/rust/commits/d64de94efa8a2aeb1a104c367be1b5c03b148987", "html_url": "https://github.com/rust-lang/rust/commit/d64de94efa8a2aeb1a104c367be1b5c03b148987"}], "stats": {"total": 180, "additions": 106, "deletions": 74}, "files": [{"sha": "89d9576cba2a4b0060242fba3541ec47562eb59f", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d688c4d806c6272c6b7a60dbed2aa329641fbf93/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d688c4d806c6272c6b7a60dbed2aa329641fbf93/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=d688c4d806c6272c6b7a60dbed2aa329641fbf93", "patch": "@@ -20,11 +20,12 @@\n //!\n //! This is a larger example that implements [Dijkstra's algorithm][dijkstra]\n //! to solve the [shortest path problem][sssp] on a [directed graph][dir_graph].\n-//! It shows how to use `BinaryHeap` with custom types.\n+//! It shows how to use [`BinaryHeap`] with custom types.\n //!\n //! [dijkstra]: http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\n //! [sssp]: http://en.wikipedia.org/wiki/Shortest_path_problem\n //! [dir_graph]: http://en.wikipedia.org/wiki/Directed_graph\n+//! [`BinaryHeap`]: struct.BinaryHeap.html\n //!\n //! ```\n //! use std::cmp::Ordering;\n@@ -438,7 +439,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// given `BinaryHeap`. Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it requests. Therefore\n-    /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n+    /// capacity can not be relied upon to be precisely minimal. Prefer [`reserve`] if future\n     /// insertions are expected.\n     ///\n     /// # Panics\n@@ -456,6 +457,8 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert!(heap.capacity() >= 100);\n     /// heap.push(4);\n     /// ```\n+    ///\n+    /// [`reserve`]: #method.reserve\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: usize) {\n         self.data.reserve_exact(additional);"}, {"sha": "ffca6964c5fdfe95190d0a1f16f7091ce6328f7a", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d688c4d806c6272c6b7a60dbed2aa329641fbf93/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d688c4d806c6272c6b7a60dbed2aa329641fbf93/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=d688c4d806c6272c6b7a60dbed2aa329641fbf93", "patch": "@@ -734,7 +734,7 @@ impl<T> IntoIterator for BTreeSet<T> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n \n-    /// Gets an iterator for moving out the BtreeSet's contents.\n+    /// Gets an iterator for moving out the `BTreeSet`'s contents.\n     ///\n     /// # Examples\n     ///"}, {"sha": "bfb03a5b23f1d29e11ffe6834da44f990904a28a", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d688c4d806c6272c6b7a60dbed2aa329641fbf93/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d688c4d806c6272c6b7a60dbed2aa329641fbf93/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=d688c4d806c6272c6b7a60dbed2aa329641fbf93", "patch": "@@ -636,12 +636,12 @@ impl<T> LinkedList<T> {\n     /// Splits the list into two at the given index. Returns everything after the given index,\n     /// including the index.\n     ///\n+    /// This operation should compute in O(n) time.\n+    ///\n     /// # Panics\n     ///\n     /// Panics if `at > len`.\n     ///\n-    /// This operation should compute in O(n) time.\n-    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "7b8f4f4c6c826d1159f7bc168245c1c00c3696de", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d688c4d806c6272c6b7a60dbed2aa329641fbf93/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d688c4d806c6272c6b7a60dbed2aa329641fbf93/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=d688c4d806c6272c6b7a60dbed2aa329641fbf93", "patch": "@@ -46,10 +46,15 @@ const MAXIMUM_ZST_CAPACITY: usize = 1 << (64 - 1); // Largest possible power of\n /// `VecDeque` is a growable ring buffer, which can be used as a double-ended\n /// queue efficiently.\n ///\n-/// The \"default\" usage of this type as a queue is to use `push_back` to add to\n-/// the queue, and `pop_front` to remove from the queue. `extend` and `append`\n+/// The \"default\" usage of this type as a queue is to use [`push_back`] to add to\n+/// the queue, and [`pop_front`] to remove from the queue. [`extend`] and [`append`]\n /// push onto the back in this manner, and iterating over `VecDeque` goes front\n /// to back.\n+///\n+/// [`push_back`]: #method.push_back\n+/// [`pop_front`]: #method.pop_front\n+/// [`extend`]: #method.extend\n+/// [`append`]: #method.append\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct VecDeque<T> {\n     // tail and head are pointers into the buffer. Tail always points\n@@ -506,7 +511,7 @@ impl<T> VecDeque<T> {\n     /// given `VecDeque`. Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it requests. Therefore\n-    /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n+    /// capacity can not be relied upon to be precisely minimal. Prefer [`reserve`] if future\n     /// insertions are expected.\n     ///\n     /// # Panics\n@@ -522,6 +527,8 @@ impl<T> VecDeque<T> {\n     /// buf.reserve_exact(10);\n     /// assert!(buf.capacity() >= 11);\n     /// ```\n+    ///\n+    /// [`reserve`]: #method.reserve\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: usize) {\n         self.reserve(additional);"}, {"sha": "9e71ec1d25df5f4da075e39711bf9bf37b5ad7df", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d688c4d806c6272c6b7a60dbed2aa329641fbf93/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d688c4d806c6272c6b7a60dbed2aa329641fbf93/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=d688c4d806c6272c6b7a60dbed2aa329641fbf93", "patch": "@@ -235,9 +235,8 @@ const DISPLACEMENT_THRESHOLD: usize = 128;\n /// attacks such as HashDoS.\n ///\n /// The hashing algorithm can be replaced on a per-`HashMap` basis using the\n-/// [`HashMap::default`], [`HashMap::with_hasher`], and\n-/// [`HashMap::with_capacity_and_hasher`] methods. Many alternative algorithms\n-/// are available on crates.io, such as the [`fnv`] crate.\n+/// [`default`], [`with_hasher`], and [`with_capacity_and_hasher`] methods. Many\n+/// alternative algorithms are available on crates.io, such as the [`fnv`] crate.\n ///\n /// It is required that the keys implement the [`Eq`] and [`Hash`] traits, although\n /// this can frequently be achieved by using `#[derive(PartialEq, Eq, Hash)]`.\n@@ -339,9 +338,9 @@ const DISPLACEMENT_THRESHOLD: usize = 128;\n /// [`PartialEq`]: ../../std/cmp/trait.PartialEq.html\n /// [`RefCell`]: ../../std/cell/struct.RefCell.html\n /// [`Cell`]: ../../std/cell/struct.Cell.html\n-/// [`HashMap::default`]: #method.default\n-/// [`HashMap::with_hasher`]: #method.with_hasher\n-/// [`HashMap::with_capacity_and_hasher`]: #method.with_capacity_and_hasher\n+/// [`default`]: #method.default\n+/// [`with_hasher`]: #method.with_hasher\n+/// [`with_capacity_and_hasher`]: #method.with_capacity_and_hasher\n /// [`fnv`]: https://crates.io/crates/fnv\n ///\n /// ```\n@@ -373,7 +372,7 @@ const DISPLACEMENT_THRESHOLD: usize = 128;\n /// }\n /// ```\n ///\n-/// A HashMap with fixed list of elements can be initialized from an array:\n+/// A `HashMap` with fixed list of elements can be initialized from an array:\n ///\n /// ```\n /// use std::collections::HashMap;\n@@ -654,12 +653,13 @@ impl<K, V, S> HashMap<K, V, S>\n         }\n     }\n \n-    /// Creates an empty `HashMap` with the specified capacity, using `hasher`\n+    /// Creates an empty `HashMap` with the specified capacity, using `hash_builder`\n     /// to hash the keys.\n     ///\n     /// The hash map will be able to hold at least `capacity` elements without\n     /// reallocating. If `capacity` is 0, the hash map will not allocate.\n-    /// Warning: `hasher` is normally randomly generated, and\n+    ///\n+    /// Warning: `hash_builder` is normally randomly generated, and\n     /// is designed to allow HashMaps to be resistant to attacks that\n     /// cause many collisions and very poor performance. Setting it\n     /// manually using this function can expose a DoS attack vector.\n@@ -686,7 +686,9 @@ impl<K, V, S> HashMap<K, V, S>\n         }\n     }\n \n-    /// Returns a reference to the map's hasher.\n+    /// Returns a reference to the map's [`BuildHasher`].\n+    ///\n+    /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n     #[stable(feature = \"hashmap_public_hasher\", since = \"1.9.0\")]\n     pub fn hasher(&self) -> &S {\n         &self.hash_builder\n@@ -849,7 +851,7 @@ impl<K, V, S> HashMap<K, V, S>\n     }\n \n     /// An iterator visiting all keys in arbitrary order.\n-    /// Iterator element type is `&'a K`.\n+    /// The iterator element type is `&'a K`.\n     ///\n     /// # Examples\n     ///\n@@ -871,7 +873,7 @@ impl<K, V, S> HashMap<K, V, S>\n     }\n \n     /// An iterator visiting all values in arbitrary order.\n-    /// Iterator element type is `&'a V`.\n+    /// The iterator element type is `&'a V`.\n     ///\n     /// # Examples\n     ///\n@@ -893,7 +895,7 @@ impl<K, V, S> HashMap<K, V, S>\n     }\n \n     /// An iterator visiting all values mutably in arbitrary order.\n-    /// Iterator element type is `&'a mut V`.\n+    /// The iterator element type is `&'a mut V`.\n     ///\n     /// # Examples\n     ///\n@@ -920,7 +922,7 @@ impl<K, V, S> HashMap<K, V, S>\n     }\n \n     /// An iterator visiting all key-value pairs in arbitrary order.\n-    /// Iterator element type is `(&'a K, &'a V)`.\n+    /// The iterator element type is `(&'a K, &'a V)`.\n     ///\n     /// # Examples\n     ///\n@@ -943,7 +945,7 @@ impl<K, V, S> HashMap<K, V, S>\n \n     /// An iterator visiting all key-value pairs in arbitrary order,\n     /// with mutable references to the values.\n-    /// Iterator element type is `(&'a K, &'a mut V)`.\n+    /// The iterator element type is `(&'a K, &'a mut V)`.\n     ///\n     /// # Examples\n     ///\n@@ -2408,10 +2410,9 @@ impl DefaultHasher {\n \n #[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n impl Default for DefaultHasher {\n-    /// Creates a new `DefaultHasher` using [`DefaultHasher::new`]. See\n-    /// [`DefaultHasher::new`] documentation for more information.\n+    /// Creates a new `DefaultHasher` using [`new`]. See its documentation for more.\n     ///\n-    /// [`DefaultHasher::new`]: #method.new\n+    /// [`new`]: #method.new\n     fn default() -> DefaultHasher {\n         DefaultHasher::new()\n     }"}, {"sha": "e56470c617f87dd645b7379fa85a38d87f666687", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 41, "deletions": 20, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d688c4d806c6272c6b7a60dbed2aa329641fbf93/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d688c4d806c6272c6b7a60dbed2aa329641fbf93/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=d688c4d806c6272c6b7a60dbed2aa329641fbf93", "patch": "@@ -25,10 +25,10 @@ use super::map::{self, HashMap, Keys, RandomState};\n // to get rid of it properly.\n \n /// An implementation of a hash set using the underlying representation of a\n-/// HashMap where the value is ().\n+/// `HashMap` where the value is ().\n ///\n-/// As with the `HashMap` type, a `HashSet` requires that the elements\n-/// implement the `Eq` and `Hash` traits. This can frequently be achieved by\n+/// As with the [`HashMap`] type, a `HashSet` requires that the elements\n+/// implement the [`Eq`] and [`Hash`] traits. This can frequently be achieved by\n /// using `#[derive(PartialEq, Eq, Hash)]`. If you implement these yourself,\n /// it is important that the following property holds:\n ///\n@@ -40,9 +40,9 @@ use super::map::{self, HashMap, Keys, RandomState};\n ///\n ///\n /// It is a logic error for an item to be modified in such a way that the\n-/// item's hash, as determined by the `Hash` trait, or its equality, as\n-/// determined by the `Eq` trait, changes while it is in the set. This is\n-/// normally only possible through `Cell`, `RefCell`, global state, I/O, or\n+/// item's hash, as determined by the [`Hash`] trait, or its equality, as\n+/// determined by the [`Eq`] trait, changes while it is in the set. This is\n+/// normally only possible through [`Cell`], [`RefCell`], global state, I/O, or\n /// unsafe code.\n ///\n /// # Examples\n@@ -75,8 +75,8 @@ use super::map::{self, HashMap, Keys, RandomState};\n /// ```\n ///\n /// The easiest way to use `HashSet` with a custom type is to derive\n-/// `Eq` and `Hash`. We must also derive `PartialEq`, this will in the\n-/// future be implied by `Eq`.\n+/// [`Eq`] and [`Hash`]. We must also derive [`PartialEq`], this will in the\n+/// future be implied by [`Eq`].\n ///\n /// ```\n /// use std::collections::HashSet;\n@@ -99,7 +99,7 @@ use super::map::{self, HashMap, Keys, RandomState};\n /// }\n /// ```\n ///\n-/// HashSet with fixed list of elements can be initialized from an array:\n+/// A `HashSet` with fixed list of elements can be initialized from an array:\n ///\n /// ```\n /// use std::collections::HashSet;\n@@ -110,6 +110,13 @@ use super::map::{self, HashMap, Keys, RandomState};\n ///     // use the values stored in the set\n /// }\n /// ```\n+///\n+/// [`Cell`]: ../../std/cell/struct.Cell.html\n+/// [`Eq`]: ../../std/cmp/trait.Eq.html\n+/// [`Hash`]: ../../std/hash/trait.Hash.html\n+/// [`HashMap`]: struct.HashMap.html\n+/// [`PartialEq`]: ../../std/cmp/trait.PartialEq.html\n+/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n \n \n #[derive(Clone)]\n@@ -181,7 +188,7 @@ impl<T, S> HashSet<T, S>\n         HashSet { map: HashMap::with_hasher(hasher) }\n     }\n \n-    /// Creates an empty HashSet with with the specified capacity, using\n+    /// Creates an empty `HashSet` with with the specified capacity, using\n     /// `hasher` to hash the keys.\n     ///\n     /// The hash set will be able to hold at least `capacity` elements without\n@@ -208,7 +215,9 @@ impl<T, S> HashSet<T, S>\n         HashSet { map: HashMap::with_capacity_and_hasher(capacity, hasher) }\n     }\n \n-    /// Returns a reference to the set's hasher.\n+    /// Returns a reference to the set's [`BuildHasher`].\n+    ///\n+    /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n     #[stable(feature = \"hashmap_public_hasher\", since = \"1.9.0\")]\n     pub fn hasher(&self) -> &S {\n         self.map.hasher()\n@@ -271,7 +280,7 @@ impl<T, S> HashSet<T, S>\n     }\n \n     /// An iterator visiting all elements in arbitrary order.\n-    /// Iterator element type is &'a T.\n+    /// The iterator element type is `&'a T`.\n     ///\n     /// # Examples\n     ///\n@@ -291,7 +300,7 @@ impl<T, S> HashSet<T, S>\n         Iter { iter: self.map.keys() }\n     }\n \n-    /// Visit the values representing the difference,\n+    /// Visits the values representing the difference,\n     /// i.e. the values that are in `self` but not in `other`.\n     ///\n     /// # Examples\n@@ -322,7 +331,7 @@ impl<T, S> HashSet<T, S>\n         }\n     }\n \n-    /// Visit the values representing the symmetric difference,\n+    /// Visits the values representing the symmetric difference,\n     /// i.e. the values that are in `self` or in `other` but not in both.\n     ///\n     /// # Examples\n@@ -350,7 +359,7 @@ impl<T, S> HashSet<T, S>\n         SymmetricDifference { iter: self.difference(other).chain(other.difference(self)) }\n     }\n \n-    /// Visit the values representing the intersection,\n+    /// Visits the values representing the intersection,\n     /// i.e. the values that are both in `self` and `other`.\n     ///\n     /// # Examples\n@@ -376,7 +385,7 @@ impl<T, S> HashSet<T, S>\n         }\n     }\n \n-    /// Visit the values representing the union,\n+    /// Visits the values representing the union,\n     /// i.e. all the values in `self` or `other`, without duplicates.\n     ///\n     /// # Examples\n@@ -460,7 +469,7 @@ impl<T, S> HashSet<T, S>\n     /// Returns `true` if the set contains a value.\n     ///\n     /// The value may be any borrowed form of the set's value type, but\n-    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n     /// the value type.\n     ///\n     /// # Examples\n@@ -472,6 +481,9 @@ impl<T, S> HashSet<T, S>\n     /// assert_eq!(set.contains(&1), true);\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n+    ///\n+    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n+    /// [`Hash`]: ../../std/hash/trait.Hash.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n         where T: Borrow<Q>,\n@@ -483,8 +495,11 @@ impl<T, S> HashSet<T, S>\n     /// Returns a reference to the value in the set, if any, that is equal to the given value.\n     ///\n     /// The value may be any borrowed form of the set's value type, but\n-    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n     /// the value type.\n+    ///\n+    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n+    /// [`Hash`]: ../../std/hash/trait.Hash.html\n     #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n         where T: Borrow<Q>,\n@@ -596,7 +611,7 @@ impl<T, S> HashSet<T, S>\n     /// present in the set.\n     ///\n     /// The value may be any borrowed form of the set's value type, but\n-    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n     /// the value type.\n     ///\n     /// # Examples\n@@ -610,6 +625,9 @@ impl<T, S> HashSet<T, S>\n     /// assert_eq!(set.remove(&2), true);\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n+    ///\n+    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n+    /// [`Hash`]: ../../std/hash/trait.Hash.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n         where T: Borrow<Q>,\n@@ -621,8 +639,11 @@ impl<T, S> HashSet<T, S>\n     /// Removes and returns the value in the set, if any, that is equal to the given one.\n     ///\n     /// The value may be any borrowed form of the set's value type, but\n-    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n     /// the value type.\n+    ///\n+    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n+    /// [`Hash`]: ../../std/hash/trait.Hash.html\n     #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n         where T: Borrow<Q>,"}, {"sha": "73acf69c72cd81da6d4667049f9695e6251f348f", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d688c4d806c6272c6b7a60dbed2aa329641fbf93/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d688c4d806c6272c6b7a60dbed2aa329641fbf93/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=d688c4d806c6272c6b7a60dbed2aa329641fbf93", "patch": "@@ -157,29 +157,29 @@\n //! information to do this itself. Therefore, it is up to us programmers to give\n //! it hints.\n //!\n-//! Any `with_capacity()` constructor will instruct the collection to allocate\n+//! Any `with_capacity` constructor will instruct the collection to allocate\n //! enough space for the specified number of elements. Ideally this will be for\n //! exactly that many elements, but some implementation details may prevent\n //! this. [`Vec`] and [`VecDeque`] can be relied on to allocate exactly the\n-//! requested amount, though. Use `with_capacity()` when you know exactly how many\n+//! requested amount, though. Use `with_capacity` when you know exactly how many\n //! elements will be inserted, or at least have a reasonable upper-bound on that\n //! number.\n //!\n-//! When anticipating a large influx of elements, the `reserve()` family of\n+//! When anticipating a large influx of elements, the `reserve` family of\n //! methods can be used to hint to the collection how much room it should make\n-//! for the coming items. As with `with_capacity()`, the precise behavior of\n+//! for the coming items. As with `with_capacity`, the precise behavior of\n //! these methods will be specific to the collection of interest.\n //!\n //! For optimal performance, collections will generally avoid shrinking\n //! themselves. If you believe that a collection will not soon contain any more\n-//! elements, or just really need the memory, the `shrink_to_fit()` method prompts\n+//! elements, or just really need the memory, the `shrink_to_fit` method prompts\n //! the collection to shrink the backing array to the minimum size capable of\n //! holding its elements.\n //!\n //! Finally, if ever you're interested in what the actual capacity of the\n-//! collection is, most collections provide a `capacity()` method to query this\n+//! collection is, most collections provide a `capacity` method to query this\n //! information on demand. This can be useful for debugging purposes, or for\n-//! use with the `reserve()` methods.\n+//! use with the `reserve` methods.\n //!\n //! ## Iterators\n //!\n@@ -194,11 +194,11 @@\n //!\n //! All of the standard collections provide several iterators for performing\n //! bulk manipulation of their contents. The three primary iterators almost\n-//! every collection should provide are `iter()`, `iter_mut()`, and `into_iter()`.\n+//! every collection should provide are `iter`, `iter_mut`, and `into_iter`.\n //! Some of these are not provided on collections where it would be unsound or\n //! unreasonable to provide them.\n //!\n-//! `iter()` provides an iterator of immutable references to all the contents of a\n+//! `iter` provides an iterator of immutable references to all the contents of a\n //! collection in the most \"natural\" order. For sequence collections like [`Vec`],\n //! this means the items will be yielded in increasing order of index starting\n //! at 0. For ordered collections like [`BTreeMap`], this means that the items\n@@ -214,8 +214,8 @@\n //! }\n //! ```\n //!\n-//! `iter_mut()` provides an iterator of *mutable* references in the same order as\n-//! `iter()`. This is great for mutating all the contents of the collection.\n+//! `iter_mut` provides an iterator of *mutable* references in the same order as\n+//! `iter`. This is great for mutating all the contents of the collection.\n //!\n //! ```\n //! let mut vec = vec![1, 2, 3, 4];\n@@ -224,12 +224,12 @@\n //! }\n //! ```\n //!\n-//! `into_iter()` transforms the actual collection into an iterator over its\n+//! `into_iter` transforms the actual collection into an iterator over its\n //! contents by-value. This is great when the collection itself is no longer\n-//! needed, and the values are needed elsewhere. Using `extend()` with `into_iter()`\n+//! needed, and the values are needed elsewhere. Using `extend` with `into_iter`\n //! is the main way that contents of one collection are moved into another.\n-//! `extend()` automatically calls `into_iter()`, and takes any `T: `[`IntoIterator`].\n-//! Calling `collect()` on an iterator itself is also a great way to convert one\n+//! `extend` automatically calls `into_iter`, and takes any `T: `[`IntoIterator`].\n+//! Calling `collect` on an iterator itself is also a great way to convert one\n //! collection into another. Both of these methods should internally use the\n //! capacity management tools discussed in the previous section to do this as\n //! efficiently as possible.\n@@ -248,9 +248,9 @@\n //! ```\n //!\n //! Iterators also provide a series of *adapter* methods for performing common\n-//! threads to sequences. Among the adapters are functional favorites like `map()`,\n-//! `fold()`, `skip()` and `take()`. Of particular interest to collections is the\n-//! `rev()` adapter, that reverses any iterator that supports this operation. Most\n+//! threads to sequences. Among the adapters are functional favorites like `map`,\n+//! `fold`, `skip` and `take`. Of particular interest to collections is the\n+//! `rev` adapter, that reverses any iterator that supports this operation. Most\n //! collections provide reversible iterators as the way to iterate over them in\n //! reverse order.\n //!\n@@ -263,42 +263,42 @@\n //!\n //! Several other collection methods also return iterators to yield a sequence\n //! of results but avoid allocating an entire collection to store the result in.\n-//! This provides maximum flexibility as `collect()` or `extend()` can be called to\n+//! This provides maximum flexibility as `collect` or `extend` can be called to\n //! \"pipe\" the sequence into any collection if desired. Otherwise, the sequence\n //! can be looped over with a `for` loop. The iterator can also be discarded\n //! after partial use, preventing the computation of the unused items.\n //!\n //! ## Entries\n //!\n-//! The `entry()` API is intended to provide an efficient mechanism for\n+//! The `entry` API is intended to provide an efficient mechanism for\n //! manipulating the contents of a map conditionally on the presence of a key or\n //! not. The primary motivating use case for this is to provide efficient\n //! accumulator maps. For instance, if one wishes to maintain a count of the\n //! number of times each key has been seen, they will have to perform some\n //! conditional logic on whether this is the first time the key has been seen or\n-//! not. Normally, this would require a `find()` followed by an `insert()`,\n+//! not. Normally, this would require a `find` followed by an `insert`,\n //! effectively duplicating the search effort on each insertion.\n //!\n //! When a user calls `map.entry(&key)`, the map will search for the key and\n //! then yield a variant of the `Entry` enum.\n //!\n //! If a `Vacant(entry)` is yielded, then the key *was not* found. In this case\n-//! the only valid operation is to `insert()` a value into the entry. When this is\n+//! the only valid operation is to `insert` a value into the entry. When this is\n //! done, the vacant entry is consumed and converted into a mutable reference to\n //! the value that was inserted. This allows for further manipulation of the\n //! value beyond the lifetime of the search itself. This is useful if complex\n //! logic needs to be performed on the value regardless of whether the value was\n //! just inserted.\n //!\n //! If an `Occupied(entry)` is yielded, then the key *was* found. In this case,\n-//! the user has several options: they can `get()`, `insert()` or `remove()` the\n+//! the user has several options: they can `get`, `insert` or `remove` the\n //! value of the occupied entry. Additionally, they can convert the occupied\n //! entry into a mutable reference to its value, providing symmetry to the\n-//! vacant `insert()` case.\n+//! vacant `insert` case.\n //!\n //! ### Examples\n //!\n-//! Here are the two primary ways in which `entry()` is used. First, a simple\n+//! Here are the two primary ways in which `entry` is used. First, a simple\n //! example where the logic performed on the values is trivial.\n //!\n //! #### Counting the number of times each character in a string occurs\n@@ -322,7 +322,7 @@\n //! ```\n //!\n //! When the logic to be performed on the value is more complex, we may simply\n-//! use the `entry()` API to ensure that the value is initialized and perform the\n+//! use the `entry` API to ensure that the value is initialized and perform the\n //! logic afterwards.\n //!\n //! #### Tracking the inebriation of customers at a bar\n@@ -360,7 +360,7 @@\n //!\n //! # Insert and complex keys\n //!\n-//! If we have a more complex key, calls to `insert()` will\n+//! If we have a more complex key, calls to `insert` will\n //! not update the value of the key. For example:\n //!\n //! ```\n@@ -451,7 +451,7 @@ pub mod hash_map {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod hash_set {\n     //! An implementation of a hash set using the underlying representation of a\n-    //! HashMap where the value is ().\n+    //! `HashMap` where the value is ().\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub use super::hash::set::*;\n }"}]}