{"sha": "f5ce0e5fe960d09db01cf912c475cd1a52131120", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1Y2UwZTVmZTk2MGQwOWRiMDFjZjkxMmM0NzVjZDFhNTIxMzExMjA=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-06-25T23:56:23Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-06-25T23:56:23Z"}, "message": "rustc_lint: only query `typeck_tables_of` when a lint needs it.", "tree": {"sha": "4c518b2c5be8ec71515b04612e697abbeb163835", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c518b2c5be8ec71515b04612e697abbeb163835"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5ce0e5fe960d09db01cf912c475cd1a52131120", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5ce0e5fe960d09db01cf912c475cd1a52131120", "html_url": "https://github.com/rust-lang/rust/commit/f5ce0e5fe960d09db01cf912c475cd1a52131120", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5ce0e5fe960d09db01cf912c475cd1a52131120/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80bcbf521c7ff95e38a7567432b5519cc18e5b2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/80bcbf521c7ff95e38a7567432b5519cc18e5b2a", "html_url": "https://github.com/rust-lang/rust/commit/80bcbf521c7ff95e38a7567432b5519cc18e5b2a"}], "stats": {"total": 727, "additions": 361, "deletions": 366}, "files": [{"sha": "cc09b99cf1dd198b1e327e294a15683a78d16a2c", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n                     _ => (),\n                 }\n \n-                let (l_ty, r_ty) = (cx.tables.expr_ty(l), cx.tables.expr_ty(r));\n+                let (l_ty, r_ty) = (cx.tables().expr_ty(l), cx.tables().expr_ty(r));\n                 if l_ty.peel_refs().is_integral() && r_ty.peel_refs().is_integral() {\n                     span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n                     self.expr_span = Some(expr.span);\n@@ -96,8 +96,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n                 }\n             },\n             hir::ExprKind::Unary(hir::UnOp::UnNeg, arg) => {\n-                let ty = cx.tables.expr_ty(arg);\n-                if constant_simple(cx, cx.tables, expr).is_none() {\n+                let ty = cx.tables().expr_ty(arg);\n+                if constant_simple(cx, cx.tables(), expr).is_none() {\n                     if ty.is_integral() {\n                         span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n                         self.expr_span = Some(expr.span);"}, {"sha": "c4536b57f8a99d8fa13b9792847e3a0a5b3cd126", "filename": "clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssertionsOnConstants {\n             }\n             if_chain! {\n                 if let ExprKind::Unary(_, ref lit) = e.kind;\n-                if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.tables, lit);\n+                if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.tables(), lit);\n                 if is_true;\n                 then {\n                     lint_true(true);\n@@ -121,7 +121,7 @@ fn match_assert_with_message<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx E\n         if let ExprKind::DropTemps(ref expr) = expr.kind;\n         if let ExprKind::Unary(UnOp::UnNot, ref expr) = expr.kind;\n         // bind the first argument of the `assert!` macro\n-        if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.tables, expr);\n+        if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.tables(), expr);\n         // arm 1 pattern\n         if let PatKind::Lit(ref lit_expr) = arms[0].pat.kind;\n         if let ExprKind::Lit(ref lit) = lit_expr.kind;"}, {"sha": "51a7647d3208f70a7a7ca80232d91328ad02eba3", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -82,8 +82,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n             hir::ExprKind::Assign(assignee, e, _) => {\n                 if let hir::ExprKind::Binary(op, l, r) = &e.kind {\n                     let lint = |assignee: &hir::Expr<'_>, rhs: &hir::Expr<'_>| {\n-                        let ty = cx.tables.expr_ty(assignee);\n-                        let rty = cx.tables.expr_ty(rhs);\n+                        let ty = cx.tables().expr_ty(assignee);\n+                        let rty = cx.tables().expr_ty(rhs);\n                         macro_rules! ops {\n                             ($op:expr,\n                              $cx:expr,\n@@ -167,7 +167,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                         // a = b commutative_op a\n                         // Limited to primitive type as these ops are know to be commutative\n                         if SpanlessEq::new(cx).ignore_fn().eq_expr(assignee, r)\n-                            && cx.tables.expr_ty(assignee).is_primitive_ty()\n+                            && cx.tables().expr_ty(assignee).is_primitive_ty()\n                         {\n                             match op.node {\n                                 hir::BinOpKind::Add"}, {"sha": "65e1e2c519c268dba0b9ad3ead327cb8d43b22b0", "filename": "clippy_lints/src/atomic_ordering.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fatomic_ordering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fatomic_ordering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fatomic_ordering.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -53,7 +53,7 @@ const ATOMIC_TYPES: [&str; 12] = [\n ];\n \n fn type_is_atomic(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n-    if let ty::Adt(&ty::AdtDef { did, .. }, _) = cx.tables.expr_ty(expr).kind {\n+    if let ty::Adt(&ty::AdtDef { did, .. }, _) = cx.tables().expr_ty(expr).kind {\n         ATOMIC_TYPES\n             .iter()\n             .any(|ty| match_def_path(cx, did, &[\"core\", \"sync\", \"atomic\", ty]))\n@@ -76,7 +76,7 @@ fn check_atomic_load_store(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n         if method == \"load\" || method == \"store\";\n         let ordering_arg = if method == \"load\" { &args[1] } else { &args[2] };\n         if let ExprKind::Path(ref ordering_qpath) = ordering_arg.kind;\n-        if let Some(ordering_def_id) = cx.tables.qpath_res(ordering_qpath, ordering_arg.hir_id).opt_def_id();\n+        if let Some(ordering_def_id) = cx.tables().qpath_res(ordering_qpath, ordering_arg.hir_id).opt_def_id();\n         then {\n             if method == \"load\" &&\n                 match_ordering_def_path(cx, ordering_def_id, &[\"Release\", \"AcqRel\"]) {\n@@ -107,12 +107,12 @@ fn check_memory_fence(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n     if_chain! {\n         if let ExprKind::Call(ref func, ref args) = expr.kind;\n         if let ExprKind::Path(ref func_qpath) = func.kind;\n-        if let Some(def_id) = cx.tables.qpath_res(func_qpath, func.hir_id).opt_def_id();\n+        if let Some(def_id) = cx.tables().qpath_res(func_qpath, func.hir_id).opt_def_id();\n         if [\"fence\", \"compiler_fence\"]\n             .iter()\n             .any(|func| match_def_path(cx, def_id, &[\"core\", \"sync\", \"atomic\", func]));\n         if let ExprKind::Path(ref ordering_qpath) = &args[0].kind;\n-        if let Some(ordering_def_id) = cx.tables.qpath_res(ordering_qpath, args[0].hir_id).opt_def_id();\n+        if let Some(ordering_def_id) = cx.tables().qpath_res(ordering_qpath, args[0].hir_id).opt_def_id();\n         if match_ordering_def_path(cx, ordering_def_id, &[\"Relaxed\"]);\n         then {\n             span_lint_and_help("}, {"sha": "a53f3249b85b6baf69534dbc4436676f49c9b17b", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -319,7 +319,7 @@ fn check_ineffective_gt(cx: &LateContext<'_, '_>, span: Span, m: u128, c: u128,\n }\n \n fn fetch_int_literal(cx: &LateContext<'_, '_>, lit: &Expr<'_>) -> Option<u128> {\n-    match constant(cx, cx.tables, lit)?.0 {\n+    match constant(cx, cx.tables(), lit)?.0 {\n         Constant::Int(n) => Some(n),\n         _ => None,\n     }"}, {"sha": "cc399a1f8a00946dba1a0c31d820925a8541beb3", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -248,7 +248,7 @@ fn simplify_not(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Option<String> {\n             })\n         },\n         ExprKind::MethodCall(path, _, args, _) if args.len() == 1 => {\n-            let type_of_receiver = cx.tables.expr_ty(&args[0]);\n+            let type_of_receiver = cx.tables().expr_ty(&args[0]);\n             if !is_type_diagnostic_item(cx, type_of_receiver, sym!(option_type))\n                 && !is_type_diagnostic_item(cx, type_of_receiver, sym!(result_type))\n             {\n@@ -450,7 +450,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n                 self.bool_expr(e)\n             },\n             ExprKind::Unary(UnOp::UnNot, inner) => {\n-                if self.cx.tables.node_types()[inner.hir_id].is_bool() {\n+                if self.cx.tables().node_types()[inner.hir_id].is_bool() {\n                     self.bool_expr(e);\n                 } else {\n                     walk_expr(self, e);\n@@ -465,7 +465,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n }\n \n fn implements_ord<'a, 'tcx>(cx: &'a LateContext<'a, 'tcx>, expr: &Expr<'_>) -> bool {\n-    let ty = cx.tables.expr_ty(expr);\n+    let ty = cx.tables().expr_ty(expr);\n     get_trait_def_id(cx, &paths::ORD).map_or(false, |id| implements_trait(cx, ty, id, &[]))\n }\n "}, {"sha": "c00bb23069bf4af91454cbd23fd17a1f458e0aec", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -53,7 +53,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n                     if let ExprKind::Binary(ref op, ref l, ref r) = body.value.kind;\n                     if op.node == BinOpKind::Eq;\n                     if match_type(cx,\n-                               walk_ptrs_ty(cx.tables.expr_ty(&filter_args[0])),\n+                               walk_ptrs_ty(cx.tables().expr_ty(&filter_args[0])),\n                                &paths::SLICE_ITER);\n                     then {\n                         let needle = match get_path_name(l) {\n@@ -63,7 +63,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n                                 _ => { return; }\n                             }\n                         };\n-                        if ty::Uint(UintTy::U8) != walk_ptrs_ty(cx.tables.expr_ty(needle)).kind {\n+                        if ty::Uint(UintTy::U8) != walk_ptrs_ty(cx.tables().expr_ty(needle)).kind {\n                             return;\n                         }\n                         let haystack = if let ExprKind::MethodCall(ref path, _, ref args, _) ="}, {"sha": "78e509d2ecd83f3def224dea25fc18624ed6fb32", "filename": "clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -60,7 +60,7 @@ impl CognitiveComplexity {\n         let mut helper = CCHelper { cc: 1, returns: 0 };\n         helper.visit_expr(expr);\n         let CCHelper { cc, returns } = helper;\n-        let ret_ty = cx.tables.node_type(expr.hir_id);\n+        let ret_ty = cx.tables().node_type(expr.hir_id);\n         let ret_adjust = if is_type_diagnostic_item(cx, ret_ty, sym!(result_type)) {\n             returns\n         } else {"}, {"sha": "9c0d33f92801537baac83fb8693844fb8c79d772", "filename": "clippy_lints/src/comparison_chain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcomparison_chain.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ComparisonChain {\n                 }\n \n                 // Check that the type being compared implements `core::cmp::Ord`\n-                let ty = cx.tables.expr_ty(lhs1);\n+                let ty = cx.tables().expr_ty(lhs1);\n                 let is_ord = get_trait_def_id(cx, &paths::ORD).map_or(false, |id| implements_trait(cx, ty, id, &[]));\n \n                 if !is_ord {"}, {"sha": "efd4a31f5596068fa4ac250778e4a52c574e6314", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -192,7 +192,7 @@ fn lint_same_then_else(cx: &LateContext<'_, '_>, blocks: &[&Block<'_>]) {\n /// Implementation of `IFS_SAME_COND`.\n fn lint_same_cond(cx: &LateContext<'_, '_>, conds: &[&Expr<'_>]) {\n     let hash: &dyn Fn(&&Expr<'_>) -> u64 = &|expr| -> u64 {\n-        let mut h = SpanlessHash::new(cx, cx.tables);\n+        let mut h = SpanlessHash::new(cx, cx.tables());\n         h.hash_expr(expr);\n         h.finish()\n     };\n@@ -215,7 +215,7 @@ fn lint_same_cond(cx: &LateContext<'_, '_>, conds: &[&Expr<'_>]) {\n /// Implementation of `SAME_FUNCTIONS_IN_IF_CONDITION`.\n fn lint_same_fns_in_if_cond(cx: &LateContext<'_, '_>, conds: &[&Expr<'_>]) {\n     let hash: &dyn Fn(&&Expr<'_>) -> u64 = &|expr| -> u64 {\n-        let mut h = SpanlessHash::new(cx, cx.tables);\n+        let mut h = SpanlessHash::new(cx, cx.tables());\n         h.hash_expr(expr);\n         h.finish()\n     };\n@@ -251,7 +251,7 @@ fn lint_match_arms<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &Expr<'_>) {\n \n     if let ExprKind::Match(_, ref arms, MatchSource::Normal) = expr.kind {\n         let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n-            let mut h = SpanlessHash::new(cx, cx.tables);\n+            let mut h = SpanlessHash::new(cx, cx.tables());\n             h.hash_expr(&arm.body);\n             h.finish()\n         };\n@@ -320,7 +320,7 @@ fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat<'_>) -> FxHashMap<Sy\n             },\n             PatKind::Binding(.., ident, ref as_pat) => {\n                 if let Entry::Vacant(v) = map.entry(ident.name) {\n-                    v.insert(cx.tables.pat_ty(pat));\n+                    v.insert(cx.tables().pat_ty(pat));\n                 }\n                 if let Some(ref as_pat) = *as_pat {\n                     bindings_impl(cx, as_pat, map);"}, {"sha": "69ae509fb23e925213df20409b058da08449ed76", "filename": "clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DefaultTraitAccess {\n             if let ExprKind::Call(ref path, ..) = expr.kind;\n             if !any_parent_is_automatically_derived(cx.tcx, expr.hir_id);\n             if let ExprKind::Path(ref qpath) = path.kind;\n-            if let Some(def_id) = cx.tables.qpath_res(qpath, path.hir_id).opt_def_id();\n+            if let Some(def_id) = cx.tables().qpath_res(qpath, path.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::DEFAULT_TRAIT_METHOD);\n             then {\n                 match qpath {\n@@ -54,7 +54,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DefaultTraitAccess {\n \n                         // TODO: Work out a way to put \"whatever the imported way of referencing\n                         // this type in this file\" rather than a fully-qualified type.\n-                        let expr_ty = cx.tables.expr_ty(expr);\n+                        let expr_ty = cx.tables().expr_ty(expr);\n                         if let ty::Adt(..) = expr_ty.kind {\n                             let replacement = format!(\"{}::default()\", expr_ty);\n                             span_lint_and_sugg("}, {"sha": "1c6cc936900969786b9ce1c7791e089c2aec1c07", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -73,12 +73,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Dereferencing {\n fn lint_deref(cx: &LateContext<'_, '_>, method_name: &str, call_expr: &Expr<'_>, var_span: Span, expr_span: Span) {\n     match method_name {\n         \"deref\" => {\n-            if cx\n-                .tcx\n-                .lang_items()\n-                .deref_trait()\n-                .map_or(false, |id| implements_trait(cx, cx.tables.expr_ty(&call_expr), id, &[]))\n-            {\n+            if cx.tcx.lang_items().deref_trait().map_or(false, |id| {\n+                implements_trait(cx, cx.tables().expr_ty(&call_expr), id, &[])\n+            }) {\n                 span_lint_and_sugg(\n                     cx,\n                     EXPLICIT_DEREF_METHODS,\n@@ -91,12 +88,9 @@ fn lint_deref(cx: &LateContext<'_, '_>, method_name: &str, call_expr: &Expr<'_>,\n             }\n         },\n         \"deref_mut\" => {\n-            if cx\n-                .tcx\n-                .lang_items()\n-                .deref_mut_trait()\n-                .map_or(false, |id| implements_trait(cx, cx.tables.expr_ty(&call_expr), id, &[]))\n-            {\n+            if cx.tcx.lang_items().deref_mut_trait().map_or(false, |id| {\n+                implements_trait(cx, cx.tables().expr_ty(&call_expr), id, &[])\n+            }) {\n                 span_lint_and_sugg(\n                     cx,\n                     EXPLICIT_DEREF_METHODS,"}, {"sha": "014873eb1325531035d5c049a699bbe34bdda0ad", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -119,7 +119,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DropForgetRef {\n                 let lint;\n                 let msg;\n                 let arg = &args[0];\n-                let arg_ty = cx.tables.expr_ty(arg);\n+                let arg_ty = cx.tables().expr_ty(arg);\n \n                 if let ty::Ref(..) = arg_ty.kind {\n                     if match_def_path(cx, def_id, &paths::DROP) {"}, {"sha": "5eb320ceca2478c172615249e132ac9055be73e4", "filename": "clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fduration_subsec.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -43,8 +43,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DurationSubsec {\n         if_chain! {\n             if let ExprKind::Binary(Spanned { node: BinOpKind::Div, .. }, ref left, ref right) = expr.kind;\n             if let ExprKind::MethodCall(ref method_path, _ , ref args, _) = left.kind;\n-            if match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(&args[0])), &paths::DURATION);\n-            if let Some((Constant::Int(divisor), _)) = constant(cx, cx.tables, right);\n+            if match_type(cx, walk_ptrs_ty(cx.tables().expr_ty(&args[0])), &paths::DURATION);\n+            if let Some((Constant::Int(divisor), _)) = constant(cx, cx.tables(), right);\n             then {\n                 let suggested_fn = match (method_path.ident.as_str().as_ref(), divisor) {\n                     (\"subsec_micros\", 1_000) | (\"subsec_nanos\", 1_000_000) => \"subsec_millis\","}, {"sha": "e37e23b8944d791391a5f0cdbe5dc9a695d3c28b", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -109,7 +109,7 @@ fn check_cond<'a, 'tcx, 'b>(\n         if let ExprKind::AddrOf(BorrowKind::Ref, _, ref key) = params[1].kind;\n         then {\n             let map = &params[0];\n-            let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(map));\n+            let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(map));\n \n             return if match_type(cx, obj_ty, &paths::BTREEMAP) {\n                 Some((\"BTreeMap\", map, key))"}, {"sha": "98757624a13b5c82517d774e536d30f92b47106c", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -103,8 +103,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                     (&ExprKind::Lit(..), _) | (_, &ExprKind::Lit(..)) => {},\n                     // &foo == &bar\n                     (&ExprKind::AddrOf(BorrowKind::Ref, _, ref l), &ExprKind::AddrOf(BorrowKind::Ref, _, ref r)) => {\n-                        let lty = cx.tables.expr_ty(l);\n-                        let rty = cx.tables.expr_ty(r);\n+                        let lty = cx.tables().expr_ty(l);\n+                        let rty = cx.tables().expr_ty(r);\n                         let lcpy = is_copy(cx, lty);\n                         let rcpy = is_copy(cx, rty);\n                         // either operator autorefs or both args are copyable\n@@ -126,7 +126,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                             )\n                         } else if lcpy\n                             && !rcpy\n-                            && implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right).into()])\n+                            && implements_trait(cx, lty, trait_id, &[cx.tables().expr_ty(right).into()])\n                         {\n                             span_lint_and_then(\n                                 cx,\n@@ -145,7 +145,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                             )\n                         } else if !lcpy\n                             && rcpy\n-                            && implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty.into()])\n+                            && implements_trait(cx, cx.tables().expr_ty(left), trait_id, &[rty.into()])\n                         {\n                             span_lint_and_then(\n                                 cx,\n@@ -166,10 +166,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                     },\n                     // &foo == bar\n                     (&ExprKind::AddrOf(BorrowKind::Ref, _, ref l), _) => {\n-                        let lty = cx.tables.expr_ty(l);\n+                        let lty = cx.tables().expr_ty(l);\n                         let lcpy = is_copy(cx, lty);\n                         if (requires_ref || lcpy)\n-                            && implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right).into()])\n+                            && implements_trait(cx, lty, trait_id, &[cx.tables().expr_ty(right).into()])\n                         {\n                             span_lint_and_then(\n                                 cx,\n@@ -190,10 +190,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                     },\n                     // foo == &bar\n                     (_, &ExprKind::AddrOf(BorrowKind::Ref, _, ref r)) => {\n-                        let rty = cx.tables.expr_ty(r);\n+                        let rty = cx.tables().expr_ty(r);\n                         let rcpy = is_copy(cx, rty);\n                         if (requires_ref || rcpy)\n-                            && implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty.into()])\n+                            && implements_trait(cx, cx.tables().expr_ty(left), trait_id, &[rty.into()])\n                         {\n                             span_lint_and_then(cx, OP_REF, e.span, \"taken reference of right operand\", |diag| {\n                                 let rsnip = snippet(cx, r.span, \"...\").to_string();"}, {"sha": "804a9c1904b73bf33ec8d71a84dbc211a5a02afc", "filename": "clippy_lints/src/erasing_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ferasing_op.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -48,7 +48,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ErasingOp {\n }\n \n fn check(cx: &LateContext<'_, '_>, e: &Expr<'_>, span: Span) {\n-    if let Some(Constant::Int(0)) = constant_simple(cx, cx.tables, e) {\n+    if let Some(Constant::Int(0)) = constant_simple(cx, cx.tables(), e) {\n         span_lint(\n             cx,\n             ERASING_OP,"}, {"sha": "bb74f193a48e7482005216d4a5ff6eae12b3ad42", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -84,7 +84,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxedLocal {\n \n         let fn_def_id = cx.tcx.hir().local_def_id(hir_id);\n         cx.tcx.infer_ctxt().enter(|infcx| {\n-            ExprUseVisitor::new(&mut v, &infcx, fn_def_id, cx.param_env, cx.tables).consume_body(body);\n+            ExprUseVisitor::new(&mut v, &infcx, fn_def_id, cx.param_env, cx.tables()).consume_body(body);\n         });\n \n         for node in v.set {"}, {"sha": "0ac8b95de8d61163578d856556276406ee9f86d2", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -97,7 +97,7 @@ fn check_closure(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n             // Are the expression or the arguments type-adjusted? Then we need the closure\n             if !(is_adjusted(cx, ex) || args.iter().any(|arg| is_adjusted(cx, arg)));\n \n-            let fn_ty = cx.tables.expr_ty(caller);\n+            let fn_ty = cx.tables().expr_ty(caller);\n \n             if matches!(fn_ty.kind, ty::FnDef(_, _) | ty::FnPtr(_) | ty::Closure(_, _));\n \n@@ -128,7 +128,7 @@ fn check_closure(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n             // Are the expression or the arguments type-adjusted? Then we need the closure\n             if !(is_adjusted(cx, ex) || args.iter().skip(1).any(|arg| is_adjusted(cx, arg)));\n \n-            let method_def_id = cx.tables.type_dependent_def_id(ex.hir_id).unwrap();\n+            let method_def_id = cx.tables().type_dependent_def_id(ex.hir_id).unwrap();\n             if !type_is_unsafe_function(cx, cx.tcx.type_of(method_def_id));\n \n             if compare_inputs(&mut iter_input_pats(decl, body), &mut args.iter());\n@@ -153,7 +153,7 @@ fn check_closure(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n /// Tries to determine the type for universal function call to be used instead of the closure\n fn get_ufcs_type_name(cx: &LateContext<'_, '_>, method_def_id: def_id::DefId, self_arg: &Expr<'_>) -> Option<String> {\n     let expected_type_of_self = &cx.tcx.fn_sig(method_def_id).inputs_and_output().skip_binder()[0];\n-    let actual_type_of_self = &cx.tables.node_type(self_arg.hir_id);\n+    let actual_type_of_self = &cx.tables().node_type(self_arg.hir_id);\n \n     if let Some(trait_id) = cx.tcx.trait_of_item(method_def_id) {\n         if match_borrow_depth(expected_type_of_self, &actual_type_of_self)"}, {"sha": "04af6c2c1f85d45797ea8121c660df310978b9db", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -75,7 +75,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EvalOrderDependence {\n                 if let ExprKind::Path(ref qpath) = lhs.kind {\n                     if let QPath::Resolved(_, ref path) = *qpath {\n                         if path.segments.len() == 1 {\n-                            if let def::Res::Local(var) = cx.tables.qpath_res(qpath, lhs.hir_id) {\n+                            if let def::Res::Local(var) = cx.tables().qpath_res(qpath, lhs.hir_id) {\n                                 let mut visitor = ReadVisitor {\n                                     cx,\n                                     var,\n@@ -137,7 +137,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n         match e.kind {\n             ExprKind::Continue(_) | ExprKind::Break(_, _) | ExprKind::Ret(_) => self.report_diverging_sub_expr(e),\n             ExprKind::Call(ref func, _) => {\n-                let typ = self.cx.tables.expr_ty(func);\n+                let typ = self.cx.tables().expr_ty(func);\n                 match typ.kind {\n                     ty::FnDef(..) | ty::FnPtr(_) => {\n                         let sig = typ.fn_sig(self.cx.tcx);\n@@ -149,7 +149,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n                 }\n             },\n             ExprKind::MethodCall(..) => {\n-                let borrowed_table = self.cx.tables;\n+                let borrowed_table = self.cx.tables();\n                 if borrowed_table.expr_ty(e).is_never() {\n                     self.report_diverging_sub_expr(e);\n                 }\n@@ -309,7 +309,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n                 if_chain! {\n                     if let QPath::Resolved(None, ref path) = *qpath;\n                     if path.segments.len() == 1;\n-                    if let def::Res::Local(local_id) = self.cx.tables.qpath_res(qpath, expr.hir_id);\n+                    if let def::Res::Local(local_id) = self.cx.tables().qpath_res(qpath, expr.hir_id);\n                     if local_id == self.var;\n                     // Check that this is a read, not a write.\n                     if !is_in_assignment_position(self.cx, expr);"}, {"sha": "cd3d443ec58ef06dd2ec2956566ddf61f727e64d", "filename": "clippy_lints/src/float_literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Ffloat_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Ffloat_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloat_literal.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -61,7 +61,7 @@ declare_lint_pass!(FloatLiteral => [EXCESSIVE_PRECISION, LOSSY_FLOAT_LITERAL]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FloatLiteral {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n-            let ty = cx.tables.expr_ty(expr);\n+            let ty = cx.tables().expr_ty(expr);\n             if let ty::Float(fty) = ty.kind;\n             if let hir::ExprKind::Lit(ref lit) = expr.kind;\n             if let LitKind::Float(sym, lit_float_ty) = lit.node;"}, {"sha": "76713cb1afc41b0c4d968203102e88d25829ba28", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -112,7 +112,7 @@ declare_lint_pass!(FloatingPointArithmetic => [\n // Returns the specialized log method for a given base if base is constant\n // and is one of 2, 10 and e\n fn get_specialized_log_method(cx: &LateContext<'_, '_>, base: &Expr<'_>) -> Option<&'static str> {\n-    if let Some((value, _)) = constant(cx, cx.tables, base) {\n+    if let Some((value, _)) = constant(cx, cx.tables(), base) {\n         if F32(2.0) == value || F64(2.0) == value {\n             return Some(\"log2\");\n         } else if F32(10.0) == value || F64(10.0) == value {\n@@ -136,7 +136,7 @@ fn prepare_receiver_sugg<'a>(cx: &LateContext<'_, '_>, mut expr: &'a Expr<'a>) -\n     if_chain! {\n         // if the expression is a float literal and it is unsuffixed then\n         // add a suffix so the suggestion is valid and unambiguous\n-        if let ty::Float(float_ty) = cx.tables.expr_ty(expr).kind;\n+        if let ty::Float(float_ty) = cx.tables().expr_ty(expr).kind;\n         if let ExprKind::Lit(lit) = &expr.kind;\n         if let ast::LitKind::Float(sym, ast::LitFloatType::Unsuffixed) = lit.node;\n         then {\n@@ -188,7 +188,7 @@ fn check_ln1p(cx: &LateContext<'_, '_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n         rhs,\n     ) = &args[0].kind\n     {\n-        let recv = match (constant(cx, cx.tables, lhs), constant(cx, cx.tables, rhs)) {\n+        let recv = match (constant(cx, cx.tables(), lhs), constant(cx, cx.tables(), rhs)) {\n             (Some((value, _)), _) if F32(1.0) == value || F64(1.0) == value => rhs,\n             (_, Some((value, _))) if F32(1.0) == value || F64(1.0) == value => lhs,\n             _ => return,\n@@ -233,7 +233,7 @@ fn get_integer_from_float_constant(value: &Constant) -> Option<i32> {\n \n fn check_powf(cx: &LateContext<'_, '_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n     // Check receiver\n-    if let Some((value, _)) = constant(cx, cx.tables, &args[0]) {\n+    if let Some((value, _)) = constant(cx, cx.tables(), &args[0]) {\n         let method = if F32(f32_consts::E) == value || F64(f64_consts::E) == value {\n             \"exp\"\n         } else if F32(2.0) == value || F64(2.0) == value {\n@@ -254,7 +254,7 @@ fn check_powf(cx: &LateContext<'_, '_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n     }\n \n     // Check argument\n-    if let Some((value, _)) = constant(cx, cx.tables, &args[1]) {\n+    if let Some((value, _)) = constant(cx, cx.tables(), &args[1]) {\n         let (lint, help, suggestion) = if F32(1.0 / 2.0) == value || F64(1.0 / 2.0) == value {\n             (\n                 SUBOPTIMAL_FLOPS,\n@@ -298,11 +298,11 @@ fn check_powf(cx: &LateContext<'_, '_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n fn check_expm1(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n     if_chain! {\n         if let ExprKind::Binary(Spanned { node: BinOpKind::Sub, .. }, ref lhs, ref rhs) = expr.kind;\n-        if cx.tables.expr_ty(lhs).is_floating_point();\n-        if let Some((value, _)) = constant(cx, cx.tables, rhs);\n+        if cx.tables().expr_ty(lhs).is_floating_point();\n+        if let Some((value, _)) = constant(cx, cx.tables(), rhs);\n         if F32(1.0) == value || F64(1.0) == value;\n         if let ExprKind::MethodCall(ref path, _, ref method_args, _) = lhs.kind;\n-        if cx.tables.expr_ty(&method_args[0]).is_floating_point();\n+        if cx.tables().expr_ty(&method_args[0]).is_floating_point();\n         if path.ident.name.as_str() == \"exp\";\n         then {\n             span_lint_and_sugg(\n@@ -324,8 +324,8 @@ fn check_expm1(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n fn is_float_mul_expr<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr<'a>) -> Option<(&'a Expr<'a>, &'a Expr<'a>)> {\n     if_chain! {\n         if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref lhs, ref rhs) = &expr.kind;\n-        if cx.tables.expr_ty(lhs).is_floating_point();\n-        if cx.tables.expr_ty(rhs).is_floating_point();\n+        if cx.tables().expr_ty(lhs).is_floating_point();\n+        if cx.tables().expr_ty(rhs).is_floating_point();\n         then {\n             return Some((lhs, rhs));\n         }\n@@ -404,7 +404,7 @@ fn are_exprs_equal(cx: &LateContext<'_, '_>, expr1: &Expr<'_>, expr2: &Expr<'_>)\n \n /// Returns true iff expr is some zero literal\n fn is_zero(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n-    match constant_simple(cx, cx.tables, expr) {\n+    match constant_simple(cx, cx.tables(), expr) {\n         Some(Constant::Int(i)) => i == 0,\n         Some(Constant::F32(f)) => f == 0.0,\n         Some(Constant::F64(f)) => f == 0.0,\n@@ -482,7 +482,7 @@ fn check_custom_abs(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FloatingPointArithmetic {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::MethodCall(ref path, _, args, _) = &expr.kind {\n-            let recv_ty = cx.tables.expr_ty(&args[0]);\n+            let recv_ty = cx.tables().expr_ty(&args[0]);\n \n             if recv_ty.is_floating_point() {\n                 match &*path.ident.name.as_str() {"}, {"sha": "58cf0027ea4d4183f9c4468f3ac0de3a425e0638", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -88,13 +88,13 @@ fn on_argumentv1_new<'a, 'tcx>(\n         // matches `core::fmt::Display::fmt`\n         if args.len() == 2;\n         if let ExprKind::Path(ref qpath) = args[1].kind;\n-        if let Some(did) = cx.tables.qpath_res(qpath, args[1].hir_id).opt_def_id();\n+        if let Some(did) = cx.tables().qpath_res(qpath, args[1].hir_id).opt_def_id();\n         if match_def_path(cx, did, &paths::DISPLAY_FMT_METHOD);\n         // check `(arg0,)` in match block\n         if let PatKind::Tuple(ref pats, None) = arms[0].pat.kind;\n         if pats.len() == 1;\n         then {\n-            let ty = walk_ptrs_ty(cx.tables.pat_ty(&pats[0]));\n+            let ty = walk_ptrs_ty(cx.tables().pat_ty(&pats[0]));\n             if ty.kind != rustc_middle::ty::Str && !is_type_diagnostic_item(cx, ty, sym!(string_type)) {\n                 return None;\n             }"}, {"sha": "57a7fbb56567913ffd82f66c27ba847a7ba54bbc", "filename": "clippy_lints/src/get_last_with_len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fget_last_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fget_last_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fget_last_with_len.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -54,7 +54,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for GetLastWithLen {\n \n             // Argument 0 (the struct we're calling the method on) is a vector\n             if let Some(struct_calling_on) = args.get(0);\n-            let struct_ty = cx.tables.expr_ty(struct_calling_on);\n+            let struct_ty = cx.tables().expr_ty(struct_calling_on);\n             if is_type_diagnostic_item(cx, struct_ty, sym!(vec_type));\n \n             // Argument to \"get\" is a subtraction"}, {"sha": "1c25e050997ea0365bc1864db5773b69e2eae7cd", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -62,8 +62,8 @@ fn is_allowed(cx: &LateContext<'_, '_>, cmp: BinOp, left: &Expr<'_>, right: &Exp\n     // `1 << 0` is a common pattern in bit manipulation code\n     if_chain! {\n         if let BinOpKind::Shl = cmp.node;\n-        if let Some(Constant::Int(0)) = constant_simple(cx, cx.tables, right);\n-        if let Some(Constant::Int(1)) = constant_simple(cx, cx.tables, left);\n+        if let Some(Constant::Int(0)) = constant_simple(cx, cx.tables(), right);\n+        if let Some(Constant::Int(1)) = constant_simple(cx, cx.tables(), left);\n         then {\n             return true;\n         }\n@@ -74,8 +74,8 @@ fn is_allowed(cx: &LateContext<'_, '_>, cmp: BinOp, left: &Expr<'_>, right: &Exp\n \n #[allow(clippy::cast_possible_wrap)]\n fn check(cx: &LateContext<'_, '_>, e: &Expr<'_>, m: i8, span: Span, arg: Span) {\n-    if let Some(Constant::Int(v)) = constant_simple(cx, cx.tables, e) {\n-        let check = match cx.tables.expr_ty(e).kind {\n+    if let Some(Constant::Int(v)) = constant_simple(cx, cx.tables(), e) {\n+        let check = match cx.tables().expr_ty(e).kind {\n             ty::Int(ity) => unsext(cx.tcx, -1_i128, ity),\n             ty::Uint(uty) => clip(cx.tcx, !0, uty),\n             _ => return,"}, {"sha": "e357c7b3b2eb265200c6446d04f04e28af33b382", "filename": "clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -149,7 +149,7 @@ fn is_mutex_lock_call<'a>(cx: &LateContext<'a, '_>, expr: &'a Expr<'_>) -> Optio\n     if_chain! {\n         if let ExprKind::MethodCall(path, _span, args, _) = &expr.kind;\n         if path.ident.to_string() == \"lock\";\n-        let ty = cx.tables.expr_ty(&args[0]);\n+        let ty = cx.tables().expr_ty(&args[0]);\n         if is_type_diagnostic_item(cx, ty, sym!(mutex_type));\n         then {\n             Some(&args[0])"}, {"sha": "3f1ae9b86d38784e9bfaa1e283b87c35152f3636", "filename": "clippy_lints/src/if_let_some_result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_some_result.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -45,7 +45,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OkIfLet {\n             if let ExprKind::MethodCall(_, ok_span, ref result_types, _) = op.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n             if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pat.kind; //get operation\n             if method_chain_args(op, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n-            if is_type_diagnostic_item(cx, cx.tables.expr_ty(&result_types[0]), sym!(result_type));\n+            if is_type_diagnostic_item(cx, cx.tables().expr_ty(&result_types[0]), sym!(result_type));\n             if rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(x, false)) == \"Some\";\n \n             then {"}, {"sha": "5a0531ff749e9d4b41a7c0c62016446d315be1e9", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -108,7 +108,7 @@ fn expr_match(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n         ExprKind::Call(expr, ..) => {\n             if_chain! {\n                 if let ExprKind::Path(qpath) = &expr.kind;\n-                if let Some(path_def_id) = cx.tables.qpath_res(qpath, expr.hir_id).opt_def_id();\n+                if let Some(path_def_id) = cx.tables().qpath_res(qpath, expr.hir_id).opt_def_id();\n                 if match_def_path(cx, path_def_id, &BEGIN_PANIC) ||\n                     match_def_path(cx, path_def_id, &BEGIN_PANIC_FMT);\n                 then { }"}, {"sha": "1a6cb0b0c566e11b9b6d2ac96b856ece277896b3", "filename": "clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -81,7 +81,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitSaturatingSub {\n                 };\n \n                 // Check if the variable in the condition statement is an integer\n-                if !cx.tables.expr_ty(cond_var).is_integral() {\n+                if !cx.tables().expr_ty(cond_var).is_integral() {\n                     return;\n                 }\n \n@@ -93,7 +93,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitSaturatingSub {\n                     ExprKind::Lit(ref cond_lit) => {\n                         // Check if the constant is zero\n                         if let LitKind::Int(0, _) = cond_lit.node {\n-                            if cx.tables.expr_ty(cond_left).is_signed() {\n+                            if cx.tables().expr_ty(cond_left).is_signed() {\n                             } else {\n                                 print_lint_and_sugg(cx, &var_name, expr);\n                             };"}, {"sha": "c5e4abc94a8a669e9962a6715f3e1279dcd54474", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -88,7 +88,7 @@ declare_lint_pass!(IndexingSlicing => [INDEXING_SLICING, OUT_OF_BOUNDS_INDEXING]\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Index(ref array, ref index) = &expr.kind {\n-            let ty = cx.tables.expr_ty(array);\n+            let ty = cx.tables().expr_ty(array);\n             if let Some(range) = higher::range(cx, index) {\n                 // Ranged indexes, i.e., &x[n..m], &x[n..], &x[..n] and &x[..]\n                 if let ty::Array(_, s) = ty.kind {\n@@ -143,7 +143,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n                 // Catchall non-range index, i.e., [n] or [n << m]\n                 if let ty::Array(..) = ty.kind {\n                     // Index is a constant uint.\n-                    if let Some(..) = constant(cx, cx.tables, index) {\n+                    if let Some(..) = constant(cx, cx.tables(), index) {\n                         // Let rustc's `const_err` lint handle constant `usize` indexing on arrays.\n                         return;\n                     }\n@@ -169,14 +169,14 @@ fn to_const_range<'a, 'tcx>(\n     range: higher::Range<'_>,\n     array_size: u128,\n ) -> (Option<u128>, Option<u128>) {\n-    let s = range.start.map(|expr| constant(cx, cx.tables, expr).map(|(c, _)| c));\n+    let s = range.start.map(|expr| constant(cx, cx.tables(), expr).map(|(c, _)| c));\n     let start = match s {\n         Some(Some(Constant::Int(x))) => Some(x),\n         Some(_) => None,\n         None => Some(0),\n     };\n \n-    let e = range.end.map(|expr| constant(cx, cx.tables, expr).map(|(c, _)| c));\n+    let e = range.end.map(|expr| constant(cx, cx.tables(), expr).map(|(c, _)| c));\n     let end = match e {\n         Some(Some(Constant::Int(x))) => {\n             if range.limits == RangeLimits::Closed {"}, {"sha": "38f086c9221fea82c0a39ea71e140b0f2c143e17", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -230,13 +230,14 @@ fn complete_infinite_iter(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Finitene\n                 }\n             }\n             if method.ident.name == sym!(last) && args.len() == 1 {\n-                let not_double_ended = get_trait_def_id(cx, &paths::DOUBLE_ENDED_ITERATOR)\n-                    .map_or(false, |id| !implements_trait(cx, cx.tables.expr_ty(&args[0]), id, &[]));\n+                let not_double_ended = get_trait_def_id(cx, &paths::DOUBLE_ENDED_ITERATOR).map_or(false, |id| {\n+                    !implements_trait(cx, cx.tables().expr_ty(&args[0]), id, &[])\n+                });\n                 if not_double_ended {\n                     return is_infinite(cx, &args[0]);\n                 }\n             } else if method.ident.name == sym!(collect) {\n-                let ty = cx.tables.expr_ty(expr);\n+                let ty = cx.tables().expr_ty(expr);\n                 if INFINITE_COLLECTORS.iter().any(|path| match_type(cx, ty, path)) {\n                     return is_infinite(cx, &args[0]);\n                 }"}, {"sha": "83ae1c1a971e165fd28cdba9753b717ea6bddcc1", "filename": "clippy_lints/src/integer_division.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Finteger_division.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Finteger_division.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finteger_division.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -50,7 +50,7 @@ fn is_integer_division<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Ex\n         if let hir::ExprKind::Binary(binop, left, right) = &expr.kind;\n         if let hir::BinOpKind::Div = &binop.node;\n         then {\n-            let (left_ty, right_ty) = (cx.tables.expr_ty(left), cx.tables.expr_ty(right));\n+            let (left_ty, right_ty) = (cx.tables().expr_ty(left), cx.tables().expr_ty(right));\n             return left_ty.is_integral() && right_ty.is_integral();\n         }\n     }"}, {"sha": "0301f263489f4938610cb264a3889bb4a833f6bb", "filename": "clippy_lints/src/large_stack_arrays.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_stack_arrays.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -42,7 +42,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeStackArrays {\n     fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Repeat(_, _) = expr.kind;\n-            if let ty::Array(element_type, cst) = cx.tables.expr_ty(expr).kind;\n+            if let ty::Array(element_type, cst) = cx.tables().expr_ty(expr).kind;\n             if let ConstKind::Value(val) = cst.val;\n             if let ConstValue::Scalar(element_count) = val;\n             if let Ok(element_count) = element_count.to_machine_usize(&cx.tcx);"}, {"sha": "e17297e9695164b38821f46d1b2a57d4c3fcdf6b", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -300,7 +300,7 @@ fn has_is_empty(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n         return false;\n     }\n \n-    let ty = &walk_ptrs_ty(cx.tables.expr_ty(expr));\n+    let ty = &walk_ptrs_ty(cx.tables().expr_ty(expr));\n     match ty.kind {\n         ty::Dynamic(ref tt, ..) => {\n             if let Some(principal) = tt.principal() {"}, {"sha": "299202981b1f3ad2b72e161eb737f507a0d15455", "filename": "clippy_lints/src/let_and_return.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Flet_and_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Flet_and_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_and_return.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -100,14 +100,14 @@ struct BorrowVisitor<'a, 'tcx> {\n impl BorrowVisitor<'_, '_> {\n     fn fn_def_id(&self, expr: &Expr<'_>) -> Option<DefId> {\n         match &expr.kind {\n-            ExprKind::MethodCall(..) => self.cx.tables.type_dependent_def_id(expr.hir_id),\n+            ExprKind::MethodCall(..) => self.cx.tables().type_dependent_def_id(expr.hir_id),\n             ExprKind::Call(\n                 Expr {\n                     kind: ExprKind::Path(qpath),\n                     ..\n                 },\n                 ..,\n-            ) => self.cx.tables.qpath_res(qpath, expr.hir_id).opt_def_id(),\n+            ) => self.cx.tables().qpath_res(qpath, expr.hir_id).opt_def_id(),\n             _ => None,\n         }\n     }"}, {"sha": "7b03812b8226098a6db41294b7da5a9272cd6451", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -73,7 +73,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetIfSeq {\n                 then {\n                     let span = stmt.span.to(if_.span);\n \n-                    let has_interior_mutability = !cx.tables.node_type(canonical_id).is_freeze(\n+                    let has_interior_mutability = !cx.tables().node_type(canonical_id).is_freeze(\n                         cx.tcx.at(span),\n                         cx.param_env,\n                     );"}, {"sha": "0864bbe0f91272e2c845eefc128a1daa51e247e0", "filename": "clippy_lints/src/let_underscore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_underscore.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -76,7 +76,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetUnderscore {\n             if let PatKind::Wild = local.pat.kind;\n             if let Some(ref init) = local.init;\n             then {\n-                let init_ty = cx.tables.expr_ty(init);\n+                let init_ty = cx.tables().expr_ty(init);\n                 let contains_sync_guard = init_ty.walk().any(|inner| match inner.unpack() {\n                     GenericArgKind::Type(inner_ty) => {\n                         SYNC_GUARD_PATHS.iter().any(|path| match_type(cx, inner_ty, path))\n@@ -94,7 +94,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetUnderscore {\n                         \"consider using an underscore-prefixed named \\\n                             binding or dropping explicitly with `std::mem::drop`\"\n                     )\n-                } else if is_must_use_ty(cx, cx.tables.expr_ty(init)) {\n+                } else if is_must_use_ty(cx, cx.tables().expr_ty(init)) {\n                     span_lint_and_help(\n                         cx,\n                         LET_UNDERSCORE_MUST_USE,"}, {"sha": "6840e82d4bf1b1790ed7518b586a2dd1d4784407", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -343,7 +343,7 @@ impl<'v, 't> RefVisitor<'v, 't> {\n                 })\n             {\n                 let hir_id = ty.hir_id;\n-                match self.cx.tables.qpath_res(qpath, hir_id) {\n+                match self.cx.tables().qpath_res(qpath, hir_id) {\n                     Res::Def(DefKind::TyAlias | DefKind::Struct, def_id) => {\n                         let generics = self.cx.tcx.generics_of(def_id);\n                         for _ in generics.params.as_slice() {"}, {"sha": "18b979176a0a0f6cfe9b77f27b21fdabf0454961", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -535,7 +535,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Loops {\n                 if_chain! {\n                     if let ExprKind::MethodCall(..) | ExprKind::Call(..) = iter_expr.kind;\n                     if let Some(iter_def_id) = get_trait_def_id(cx, &paths::ITERATOR);\n-                    if implements_trait(cx, cx.tables.expr_ty(iter_expr), iter_def_id, &[]);\n+                    if implements_trait(cx, cx.tables().expr_ty(iter_expr), iter_def_id, &[]);\n                     then {\n                         return;\n                     }\n@@ -985,8 +985,8 @@ fn detect_manual_memcpy<'a, 'tcx>(\n                         if_chain! {\n                             if let ExprKind::Index(seqexpr_left, idx_left) = lhs.kind;\n                             if let ExprKind::Index(seqexpr_right, idx_right) = rhs.kind;\n-                            if is_slice_like(cx, cx.tables.expr_ty(seqexpr_left))\n-                                && is_slice_like(cx, cx.tables.expr_ty(seqexpr_right));\n+                            if is_slice_like(cx, cx.tables().expr_ty(seqexpr_left))\n+                                && is_slice_like(cx, cx.tables().expr_ty(seqexpr_right));\n                             if let Some(offset_left) = get_offset(cx, &idx_left, canonical_id);\n                             if let Some(offset_right) = get_offset(cx, &idx_right, canonical_id);\n \n@@ -1254,8 +1254,8 @@ fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat<'_>, arg: &Expr<'_>, e\n                     lint_iter_method(cx, args, arg, method_name);\n                 }\n             } else if method_name == \"into_iter\" && match_trait_method(cx, arg, &paths::INTO_ITERATOR) {\n-                let receiver_ty = cx.tables.expr_ty(&args[0]);\n-                let receiver_ty_adjusted = cx.tables.expr_ty_adjusted(&args[0]);\n+                let receiver_ty = cx.tables().expr_ty(&args[0]);\n+                let receiver_ty_adjusted = cx.tables().expr_ty_adjusted(&args[0]);\n                 if TyS::same_type(receiver_ty, receiver_ty_adjusted) {\n                     let mut applicability = Applicability::MachineApplicable;\n                     let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n@@ -1300,7 +1300,7 @@ fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat<'_>, arg: &Expr<'_>, e\n \n /// Checks for `for` loops over `Option`s and `Result`s.\n fn check_arg_type(cx: &LateContext<'_, '_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n-    let ty = cx.tables.expr_ty(arg);\n+    let ty = cx.tables().expr_ty(arg);\n     if is_type_diagnostic_item(cx, ty, sym!(option_type)) {\n         span_lint_and_help(\n             cx,\n@@ -1405,7 +1405,7 @@ fn check_for_loop_explicit_counter<'a, 'tcx>(\n /// actual `Iterator` that the loop uses.\n fn make_iterator_snippet(cx: &LateContext<'_, '_>, arg: &Expr<'_>, applic_ref: &mut Applicability) -> String {\n     let impls_iterator = get_trait_def_id(cx, &paths::ITERATOR)\n-        .map_or(false, |id| implements_trait(cx, cx.tables.expr_ty(arg), id, &[]));\n+        .map_or(false, |id| implements_trait(cx, cx.tables().expr_ty(arg), id, &[]));\n     if impls_iterator {\n         format!(\n             \"{}\",\n@@ -1416,7 +1416,7 @@ fn make_iterator_snippet(cx: &LateContext<'_, '_>, arg: &Expr<'_>, applic_ref: &\n         // (&mut x).into_iter() ==> x.iter_mut()\n         match &arg.kind {\n             ExprKind::AddrOf(BorrowKind::Ref, mutability, arg_inner)\n-                if has_iter_method(cx, cx.tables.expr_ty(&arg_inner)).is_some() =>\n+                if has_iter_method(cx, cx.tables().expr_ty(&arg_inner)).is_some() =>\n             {\n                 let meth_name = match mutability {\n                     Mutability::Mut => \"iter_mut\",\n@@ -1449,7 +1449,7 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n     if let PatKind::Tuple(ref pat, _) = pat.kind {\n         if pat.len() == 2 {\n             let arg_span = arg.span;\n-            let (new_pat_span, kind, ty, mutbl) = match cx.tables.expr_ty(arg).kind {\n+            let (new_pat_span, kind, ty, mutbl) = match cx.tables().expr_ty(arg).kind {\n                 ty::Ref(_, ty, mutbl) => match (&pat[0].kind, &pat[1].kind) {\n                     (key, _) if pat_is_wild(key, body) => (pat[1].span, \"value\", ty, mutbl),\n                     (_, value) if pat_is_wild(value, body) => (pat[0].span, \"key\", ty, Mutability::Not),\n@@ -1594,7 +1594,7 @@ fn check_for_mutation<'a, 'tcx>(\n     };\n     let def_id = body.hir_id.owner.to_def_id();\n     cx.tcx.infer_ctxt().enter(|infcx| {\n-        ExprUseVisitor::new(&mut delegate, &infcx, def_id.expect_local(), cx.param_env, cx.tables).walk_expr(body);\n+        ExprUseVisitor::new(&mut delegate, &infcx, def_id.expect_local(), cx.param_env, cx.tables()).walk_expr(body);\n     });\n     delegate.mutation_span()\n }\n@@ -1688,7 +1688,7 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                             if index_used_directly {\n                                 self.indexed_directly.insert(\n                                     seqvar.segments[0].ident.name,\n-                                    (Some(extent), self.cx.tables.node_type(seqexpr.hir_id)),\n+                                    (Some(extent), self.cx.tables().node_type(seqexpr.hir_id)),\n                                 );\n                             }\n                             return false;  // no need to walk further *on the variable*\n@@ -1700,7 +1700,7 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                             if index_used_directly {\n                                 self.indexed_directly.insert(\n                                     seqvar.segments[0].ident.name,\n-                                    (None, self.cx.tables.node_type(seqexpr.hir_id)),\n+                                    (None, self.cx.tables().node_type(seqexpr.hir_id)),\n                                 );\n                             }\n                             return false;  // no need to walk further *on the variable*\n@@ -1768,7 +1768,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n             ExprKind::Call(ref f, args) => {\n                 self.visit_expr(f);\n                 for expr in args {\n-                    let ty = self.cx.tables.expr_ty_adjusted(expr);\n+                    let ty = self.cx.tables().expr_ty_adjusted(expr);\n                     self.prefer_mutable = false;\n                     if let ty::Ref(_, _, mutbl) = ty.kind {\n                         if mutbl == Mutability::Mut {\n@@ -1779,7 +1779,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                 }\n             },\n             ExprKind::MethodCall(_, _, args, _) => {\n-                let def_id = self.cx.tables.type_dependent_def_id(expr.hir_id).unwrap();\n+                let def_id = self.cx.tables().type_dependent_def_id(expr.hir_id).unwrap();\n                 for (ty, expr) in self.cx.tcx.fn_sig(def_id).inputs().skip_binder().iter().zip(args) {\n                     self.prefer_mutable = false;\n                     if let ty::Ref(_, _, mutbl) = ty.kind {\n@@ -1866,7 +1866,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor<'a, 'tcx> {\n fn is_ref_iterable_type(cx: &LateContext<'_, '_>, e: &Expr<'_>) -> bool {\n     // no walk_ptrs_ty: calling iter() on a reference can make sense because it\n     // will allow further borrows afterwards\n-    let ty = cx.tables.expr_ty(e);\n+    let ty = cx.tables().expr_ty(e);\n     is_iterable_array(ty, cx) ||\n     is_type_diagnostic_item(cx, ty, sym!(vec_type)) ||\n     match_type(cx, ty, &paths::LINKED_LIST) ||\n@@ -2241,7 +2241,7 @@ fn path_name(e: &Expr<'_>) -> Option<Name> {\n }\n \n fn check_infinite_loop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, cond: &'tcx Expr<'_>, expr: &'tcx Expr<'_>) {\n-    if constant(cx, cx.tables, cond).is_some() {\n+    if constant(cx, cx.tables(), cond).is_some() {\n         // A pure constant condition (e.g., `while false`) is not linted.\n         return;\n     }\n@@ -2377,7 +2377,7 @@ fn check_needless_collect<'a, 'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'a, '\n         if let Some(ref generic_args) = chain_method.args;\n         if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n         then {\n-            let ty = cx.tables.node_type(ty.hir_id);\n+            let ty = cx.tables().node_type(ty.hir_id);\n             if is_type_diagnostic_item(cx, ty, sym!(vec_type)) ||\n                 is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n                 match_type(cx, ty, &paths::BTREEMAP) ||"}, {"sha": "9109de9458f1c940a9ded826978d6fc232ddc131", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MapClone {\n             if let hir::ExprKind::MethodCall(ref method, _, ref args, _) = e.kind;\n             if args.len() == 2;\n             if method.ident.as_str() == \"map\";\n-            let ty = cx.tables.expr_ty(&args[0]);\n+            let ty = cx.tables().expr_ty(&args[0]);\n             if is_type_diagnostic_item(cx, ty, sym!(option_type)) || match_trait_method(cx, e, &paths::ITERATOR);\n             if let hir::ExprKind::Closure(_, _, body_id, _, _) = args[1].kind;\n             let closure_body = cx.tcx.hir().body(body_id);\n@@ -70,7 +70,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MapClone {\n                         match closure_expr.kind {\n                             hir::ExprKind::Unary(hir::UnOp::UnDeref, ref inner) => {\n                                 if ident_eq(name, inner) {\n-                                    if let ty::Ref(.., Mutability::Not) = cx.tables.expr_ty(inner).kind {\n+                                    if let ty::Ref(.., Mutability::Not) = cx.tables().expr_ty(inner).kind {\n                                         lint(cx, e.span, args[0].span, true);\n                                     }\n                                 }\n@@ -79,7 +79,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MapClone {\n                                 if ident_eq(name, &obj[0]) && method.ident.as_str() == \"clone\"\n                                     && match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) {\n \n-                                    let obj_ty = cx.tables.expr_ty(&obj[0]);\n+                                    let obj_ty = cx.tables().expr_ty(&obj[0]);\n                                     if let ty::Ref(_, ty, _) = obj_ty.kind {\n                                         let copy = is_copy(cx, ty);\n                                         lint(cx, e.span, args[0].span, copy);"}, {"sha": "a4550f707ee224d9993641469195d506168097ea", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -101,7 +101,7 @@ fn is_unit_type(ty: Ty<'_>) -> bool {\n }\n \n fn is_unit_function(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) -> bool {\n-    let ty = cx.tables.expr_ty(expr);\n+    let ty = cx.tables().expr_ty(expr);\n \n     if let ty::FnDef(id, _) = ty.kind {\n         if let Some(fn_type) = cx.tcx.fn_sig(id).no_bound_vars() {\n@@ -112,7 +112,7 @@ fn is_unit_function(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) -> bool {\n }\n \n fn is_unit_expression(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) -> bool {\n-    is_unit_type(cx.tables.expr_ty(expr))\n+    is_unit_type(cx.tables().expr_ty(expr))\n }\n \n /// The expression inside a closure may or may not have surrounding braces and\n@@ -205,9 +205,9 @@ fn suggestion_msg(function_type: &str, map_type: &str) -> String {\n fn lint_map_unit_fn(cx: &LateContext<'_, '_>, stmt: &hir::Stmt<'_>, expr: &hir::Expr<'_>, map_args: &[hir::Expr<'_>]) {\n     let var_arg = &map_args[0];\n \n-    let (map_type, variant, lint) = if is_type_diagnostic_item(cx, cx.tables.expr_ty(var_arg), sym!(option_type)) {\n+    let (map_type, variant, lint) = if is_type_diagnostic_item(cx, cx.tables().expr_ty(var_arg), sym!(option_type)) {\n         (\"Option\", \"Some\", OPTION_MAP_UNIT_FN)\n-    } else if is_type_diagnostic_item(cx, cx.tables.expr_ty(var_arg), sym!(result_type)) {\n+    } else if is_type_diagnostic_item(cx, cx.tables().expr_ty(var_arg), sym!(result_type)) {\n         (\"Result\", \"Ok\", RESULT_MAP_UNIT_FN)\n     } else {\n         return;"}, {"sha": "4a025e0621f9643f9903c2c32ae9ab277588b86e", "filename": "clippy_lints/src/match_on_vec_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatch_on_vec_items.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -88,13 +88,13 @@ fn is_vec_indexing<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'tcx>)\n }\n \n fn is_vector(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n-    let ty = cx.tables.expr_ty(expr);\n+    let ty = cx.tables().expr_ty(expr);\n     let ty = walk_ptrs_ty(ty);\n     is_type_diagnostic_item(cx, ty, sym!(vec_type))\n }\n \n fn is_full_range(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n-    let ty = cx.tables.expr_ty(expr);\n+    let ty = cx.tables().expr_ty(expr);\n     let ty = walk_ptrs_ty(ty);\n     match_type(cx, ty, &utils::paths::RANGE_FULL)\n }"}, {"sha": "0c91d8885d9242adaabb0974840da4ac23da261e", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -540,7 +540,7 @@ fn check_single_match(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>],\n             // allow match arms with just expressions\n             return;\n         };\n-        let ty = cx.tables.expr_ty(ex);\n+        let ty = cx.tables().expr_ty(ex);\n         if ty.kind != ty::Bool || is_allowed(cx, MATCH_BOOL, ex.hir_id) {\n             check_single_match_single_pattern(cx, ex, arms, expr, els);\n             check_single_match_opt_like(cx, ex, arms, expr, ty, els);\n@@ -632,7 +632,7 @@ fn check_single_match_opt_like(\n \n fn check_match_bool(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     // Type of expression is `bool`.\n-    if cx.tables.expr_ty(ex).kind == ty::Bool {\n+    if cx.tables().expr_ty(ex).kind == ty::Bool {\n         span_lint_and_then(\n             cx,\n             MATCH_BOOL,\n@@ -695,8 +695,8 @@ fn check_match_bool(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>], e\n }\n \n fn check_overlapping_arms<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ex: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) {\n-    if arms.len() >= 2 && cx.tables.expr_ty(ex).is_integral() {\n-        let ranges = all_ranges(cx, arms, cx.tables.expr_ty(ex));\n+    if arms.len() >= 2 && cx.tables().expr_ty(ex).is_integral() {\n+        let ranges = all_ranges(cx, arms, cx.tables().expr_ty(ex));\n         let type_ranges = type_ranges(&ranges);\n         if !type_ranges.is_empty() {\n             if let Some((start, end)) = overlapping(&type_ranges) {\n@@ -714,7 +714,7 @@ fn check_overlapping_arms<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ex: &'tcx Expr<'\n }\n \n fn check_wild_err_arm(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n-    let ex_ty = walk_ptrs_ty(cx.tables.expr_ty(ex));\n+    let ex_ty = walk_ptrs_ty(cx.tables().expr_ty(ex));\n     if is_type_diagnostic_item(cx, ex_ty, sym!(result_type)) {\n         for arm in arms {\n             if let PatKind::TupleStruct(ref path, ref inner, _) = arm.pat.kind {\n@@ -755,7 +755,7 @@ fn check_wild_err_arm(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n }\n \n fn check_wild_enum_match(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n-    let ty = cx.tables.expr_ty(ex);\n+    let ty = cx.tables().expr_ty(ex);\n     if !ty.is_enum() {\n         // If there isn't a nice closed set of possible values that can be conveniently enumerated,\n         // don't complain about not enumerating the mall.\n@@ -935,8 +935,8 @@ fn check_match_as_ref(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>],\n                 \"as_mut\"\n             };\n \n-            let output_ty = cx.tables.expr_ty(expr);\n-            let input_ty = cx.tables.expr_ty(ex);\n+            let output_ty = cx.tables().expr_ty(expr);\n+            let input_ty = cx.tables().expr_ty(ex);\n \n             let cast = if_chain! {\n                 if let ty::Adt(_, substs) = input_ty.kind;\n@@ -1006,13 +1006,13 @@ fn check_match_single_binding<'a>(cx: &LateContext<'_, 'a>, ex: &Expr<'a>, arms:\n     match match_body.kind {\n         ExprKind::Block(block, _) => {\n             // macro + expr_ty(body) == ()\n-            if block.span.from_expansion() && cx.tables.expr_ty(&match_body).is_unit() {\n+            if block.span.from_expansion() && cx.tables().expr_ty(&match_body).is_unit() {\n                 snippet_body.push(';');\n             }\n         },\n         _ => {\n             // expr_ty(body) == ()\n-            if cx.tables.expr_ty(&match_body).is_unit() {\n+            if cx.tables().expr_ty(&match_body).is_unit() {\n                 snippet_body.push(';');\n             }\n         },\n@@ -1111,11 +1111,11 @@ fn all_ranges<'a, 'tcx>(\n             {\n                 if let PatKind::Range(ref lhs, ref rhs, range_end) = pat.kind {\n                     let lhs = match lhs {\n-                        Some(lhs) => constant(cx, cx.tables, lhs)?.0,\n+                        Some(lhs) => constant(cx, cx.tables(), lhs)?.0,\n                         None => miri_to_const(ty.numeric_min_val(cx.tcx)?)?,\n                     };\n                     let rhs = match rhs {\n-                        Some(rhs) => constant(cx, cx.tables, rhs)?.0,\n+                        Some(rhs) => constant(cx, cx.tables(), rhs)?.0,\n                         None => miri_to_const(ty.numeric_max_val(cx.tcx)?)?,\n                     };\n                     let rhs = match range_end {\n@@ -1129,7 +1129,7 @@ fn all_ranges<'a, 'tcx>(\n                 }\n \n                 if let PatKind::Lit(ref value) = pat.kind {\n-                    let value = constant(cx, cx.tables, value)?.0;\n+                    let value = constant(cx, cx.tables(), value)?.0;\n                     return Some(SpannedRange {\n                         span: pat.span,\n                         node: (value.clone(), Bound::Included(value)),"}, {"sha": "d315c5ef89a8830b626d9166c05c44b078b2b0a4", "filename": "clippy_lints/src/mem_discriminant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_discriminant.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -35,10 +35,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemDiscriminant {\n             if let ExprKind::Call(ref func, ref func_args) = expr.kind;\n             // is `mem::discriminant`\n             if let ExprKind::Path(ref func_qpath) = func.kind;\n-            if let Some(def_id) = cx.tables.qpath_res(func_qpath, func.hir_id).opt_def_id();\n+            if let Some(def_id) = cx.tables().qpath_res(func_qpath, func.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::MEM_DISCRIMINANT);\n             // type is non-enum\n-            let ty_param = cx.tables.node_substs(func.hir_id).type_at(0);\n+            let ty_param = cx.tables().node_substs(func.hir_id).type_at(0);\n             if !ty_param.is_enum();\n \n             then {"}, {"sha": "1821bd9135f981d91aca4fdd230826215197187e", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -31,7 +31,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemForget {\n             if let ExprKind::Path(ref qpath) = path_expr.kind {\n                 if let Some(def_id) = qpath_res(cx, qpath, path_expr.hir_id).opt_def_id() {\n                     if match_def_path(cx, def_id, &paths::MEM_FORGET) {\n-                        let forgot_ty = cx.tables.expr_ty(&args[0]);\n+                        let forgot_ty = cx.tables().expr_ty(&args[0]);\n \n                         if forgot_ty.ty_adt_def().map_or(false, |def| def.has_dtor(cx.tcx)) {\n                             span_lint(cx, MEM_FORGET, e.span, \"usage of `mem::forget` on `Drop` type\");"}, {"sha": "16d31fc8346ea71ca6960e5639a5e8170320d2d9", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -138,7 +138,7 @@ fn check_replace_option_with_none(cx: &LateContext<'_, '_>, src: &Expr<'_>, dest\n fn check_replace_with_uninit(cx: &LateContext<'_, '_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n     if_chain! {\n         // check if replacement is mem::MaybeUninit::uninit().assume_init()\n-        if let Some(method_def_id) = cx.tables.type_dependent_def_id(src.hir_id);\n+        if let Some(method_def_id) = cx.tables().type_dependent_def_id(src.hir_id);\n         if cx.tcx.is_diagnostic_item(sym::assume_init, method_def_id);\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n@@ -162,7 +162,7 @@ fn check_replace_with_uninit(cx: &LateContext<'_, '_>, src: &Expr<'_>, dest: &Ex\n         if let ExprKind::Call(ref repl_func, ref repl_args) = src.kind;\n         if repl_args.is_empty();\n         if let ExprKind::Path(ref repl_func_qpath) = repl_func.kind;\n-        if let Some(repl_def_id) = cx.tables.qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n+        if let Some(repl_def_id) = cx.tables().qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n         then {\n             if cx.tcx.is_diagnostic_item(sym::mem_uninitialized, repl_def_id) {\n                 let mut applicability = Applicability::MachineApplicable;\n@@ -179,7 +179,7 @@ fn check_replace_with_uninit(cx: &LateContext<'_, '_>, src: &Expr<'_>, dest: &Ex\n                     applicability,\n                 );\n             } else if cx.tcx.is_diagnostic_item(sym::mem_zeroed, repl_def_id) &&\n-                    !cx.tables.expr_ty(src).is_primitive() {\n+                    !cx.tables().expr_ty(src).is_primitive() {\n                 span_lint_and_help(\n                     cx,\n                     MEM_REPLACE_WITH_UNINIT,\n@@ -198,7 +198,7 @@ fn check_replace_with_default(cx: &LateContext<'_, '_>, src: &Expr<'_>, dest: &E\n         if_chain! {\n             if !in_external_macro(cx.tcx.sess, expr_span);\n             if let ExprKind::Path(ref repl_func_qpath) = repl_func.kind;\n-            if let Some(repl_def_id) = cx.tables.qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n+            if let Some(repl_def_id) = cx.tables().qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n             if match_def_path(cx, repl_def_id, &paths::DEFAULT_TRAIT_METHOD);\n             then {\n                 span_lint_and_then(\n@@ -230,7 +230,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemReplace {\n             // Check that `expr` is a call to `mem::replace()`\n             if let ExprKind::Call(ref func, ref func_args) = expr.kind;\n             if let ExprKind::Path(ref func_qpath) = func.kind;\n-            if let Some(def_id) = cx.tables.qpath_res(func_qpath, func.hir_id).opt_def_id();\n+            if let Some(def_id) = cx.tables().qpath_res(func_qpath, func.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::MEM_REPLACE);\n             if let [dest, src] = &**func_args;\n             then {"}, {"sha": "092702c8b8c7bf5ddf0e6b1bd9b9e340789b505b", "filename": "clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -157,7 +157,7 @@ pub(crate) trait BindInsteadOfMap {\n \n     /// Lint use of `_.and_then(|x| Some(y))` for `Option`s\n     fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n-        if !match_type(cx, cx.tables.expr_ty(&args[0]), Self::TYPE_QPATH) {\n+        if !match_type(cx, cx.tables().expr_ty(&args[0]), Self::TYPE_QPATH) {\n             return;\n         }\n "}, {"sha": "d29b9adcb7d43375e8df5d6bbdacf31bb2a89de0", "filename": "clippy_lints/src/methods/inefficient_to_string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -11,9 +11,9 @@ use rustc_middle::ty::{self, Ty};\n /// Checks for the `INEFFICIENT_TO_STRING` lint\n pub fn lint<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'tcx>) {\n     if_chain! {\n-        if let Some(to_string_meth_did) = cx.tables.type_dependent_def_id(expr.hir_id);\n+        if let Some(to_string_meth_did) = cx.tables().type_dependent_def_id(expr.hir_id);\n         if match_def_path(cx, to_string_meth_did, &paths::TO_STRING_METHOD);\n-        if let Some(substs) = cx.tables.node_substs_opt(expr.hir_id);\n+        if let Some(substs) = cx.tables().node_substs_opt(expr.hir_id);\n         let self_ty = substs.type_at(0);\n         let (deref_self_ty, deref_count) = walk_ptrs_ty_depth(self_ty);\n         if deref_count >= 1;"}, {"sha": "eb02314f4680a8246a2ff6477355a005d97209b9", "filename": "clippy_lints/src/methods/manual_saturating_arithmetic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -11,7 +11,7 @@ pub fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[&[hir::Expr<\n     let arith_lhs = &args[1][0];\n     let arith_rhs = &args[1][1];\n \n-    let ty = cx.tables.expr_ty(arith_lhs);\n+    let ty = cx.tables().expr_ty(arith_lhs);\n     if !ty.is_integral() {\n         return;\n     }\n@@ -101,7 +101,7 @@ fn is_min_or_max<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &hir::Expr<'_>) -> Opti\n         }\n     }\n \n-    let ty = cx.tables.expr_ty(expr);\n+    let ty = cx.tables().expr_ty(expr);\n     let ty_str = ty.to_string();\n \n     // `std::T::MAX` `std::T::MIN` constants"}, {"sha": "c4e707ecf03adfabeb7dbb92dda27cd377b0fc25", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 57, "deletions": 54, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -1433,7 +1433,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n                 lint_or_fun_call(cx, expr, *method_span, &method_call.ident.as_str(), args);\n                 lint_expect_fun_call(cx, expr, *method_span, &method_call.ident.as_str(), args);\n \n-                let self_ty = cx.tables.expr_ty_adjusted(&args[0]);\n+                let self_ty = cx.tables().expr_ty_adjusted(&args[0]);\n                 if args.len() == 1 && method_call.ident.name == sym!(clone) {\n                     lint_clone_on_copy(cx, expr, &args[0], self_ty);\n                     lint_clone_on_ref_ptr(cx, expr, &args[0]);\n@@ -1639,7 +1639,7 @@ fn lint_or_fun_call<'a, 'tcx>(\n             if let hir::ExprKind::Path(ref qpath) = fun.kind;\n             let path = &*last_path_segment(qpath).ident.as_str();\n             if [\"default\", \"new\"].contains(&path);\n-            let arg_ty = cx.tables.expr_ty(arg);\n+            let arg_ty = cx.tables().expr_ty(arg);\n             if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT);\n             if implements_trait(cx, arg_ty, default_trait_id, &[]);\n \n@@ -1679,7 +1679,7 @@ fn lint_or_fun_call<'a, 'tcx>(\n     ) {\n         if let hir::ExprKind::MethodCall(ref path, _, ref args, _) = &arg.kind {\n             if path.ident.as_str() == \"len\" {\n-                let ty = walk_ptrs_ty(cx.tables.expr_ty(&args[0]));\n+                let ty = walk_ptrs_ty(cx.tables().expr_ty(&args[0]));\n \n                 match ty.kind {\n                     ty::Slice(_) | ty::Array(_, _) => return,\n@@ -1707,7 +1707,7 @@ fn lint_or_fun_call<'a, 'tcx>(\n             if { finder.visit_expr(&arg); finder.found };\n             if !contains_return(&arg);\n \n-            let self_ty = cx.tables.expr_ty(self_expr);\n+            let self_ty = cx.tables().expr_ty(self_expr);\n \n             if let Some(&(_, fn_has_arguments, poss, suffix)) =\n                 know_types.iter().find(|&&i| match_type(cx, self_ty, i.0));\n@@ -1786,7 +1786,7 @@ fn lint_expect_fun_call(\n                     if call_args.len() == 1\n                         && (method_name.ident.name == sym!(as_str) || method_name.ident.name == sym!(as_ref))\n                         && {\n-                            let arg_type = cx.tables.expr_ty(&call_args[0]);\n+                            let arg_type = cx.tables().expr_ty(&call_args[0]);\n                             let base_type = walk_ptrs_ty(arg_type);\n                             base_type.kind == ty::Str || is_type_diagnostic_item(cx, base_type, sym!(string_type))\n                         }\n@@ -1805,7 +1805,7 @@ fn lint_expect_fun_call(\n     // Only `&'static str` or `String` can be used directly in the `panic!`. Other types should be\n     // converted to string.\n     fn requires_to_string(cx: &LateContext<'_, '_>, arg: &hir::Expr<'_>) -> bool {\n-        let arg_ty = cx.tables.expr_ty(arg);\n+        let arg_ty = cx.tables().expr_ty(arg);\n         if is_type_diagnostic_item(cx, arg_ty, sym!(string_type)) {\n             return false;\n         }\n@@ -1824,7 +1824,7 @@ fn lint_expect_fun_call(\n             hir::ExprKind::Lit(_) => true,\n             hir::ExprKind::Call(fun, _) => {\n                 if let hir::ExprKind::Path(ref p) = fun.kind {\n-                    match cx.tables.qpath_res(p, fun.hir_id) {\n+                    match cx.tables().qpath_res(p, fun.hir_id) {\n                         hir::def::Res::Def(hir::def::DefKind::Fn | hir::def::DefKind::AssocFn, def_id) => matches!(\n                             cx.tcx.fn_sig(def_id).output().skip_binder().kind,\n                             ty::Ref(ty::ReStatic, ..)\n@@ -1835,13 +1835,16 @@ fn lint_expect_fun_call(\n                     false\n                 }\n             },\n-            hir::ExprKind::MethodCall(..) => cx.tables.type_dependent_def_id(arg.hir_id).map_or(false, |method_id| {\n-                matches!(\n-                    cx.tcx.fn_sig(method_id).output().skip_binder().kind,\n-                    ty::Ref(ty::ReStatic, ..)\n-                )\n-            }),\n-            hir::ExprKind::Path(ref p) => match cx.tables.qpath_res(p, arg.hir_id) {\n+            hir::ExprKind::MethodCall(..) => cx\n+                .tables()\n+                .type_dependent_def_id(arg.hir_id)\n+                .map_or(false, |method_id| {\n+                    matches!(\n+                        cx.tcx.fn_sig(method_id).output().skip_binder().kind,\n+                        ty::Ref(ty::ReStatic, ..)\n+                    )\n+                }),\n+            hir::ExprKind::Path(ref p) => match cx.tables().qpath_res(p, arg.hir_id) {\n                 hir::def::Res::Def(hir::def::DefKind::Const | hir::def::DefKind::Static, _) => true,\n                 _ => false,\n             },\n@@ -1888,7 +1891,7 @@ fn lint_expect_fun_call(\n         return;\n     }\n \n-    let receiver_type = cx.tables.expr_ty_adjusted(&args[0]);\n+    let receiver_type = cx.tables().expr_ty_adjusted(&args[0]);\n     let closure_args = if is_type_diagnostic_item(cx, receiver_type, sym!(option_type)) {\n         \"||\"\n     } else if is_type_diagnostic_item(cx, receiver_type, sym!(result_type)) {\n@@ -1954,7 +1957,7 @@ fn lint_expect_fun_call(\n \n /// Checks for the `CLONE_ON_COPY` lint.\n fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'_>) {\n-    let ty = cx.tables.expr_ty(expr);\n+    let ty = cx.tables().expr_ty(expr);\n     if let ty::Ref(_, inner, _) = arg_ty.kind {\n         if let ty::Ref(_, innermost, _) = inner.kind {\n             span_lint_and_then(\n@@ -2018,11 +2021,11 @@ fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, arg: &hir:\n             }\n \n             // x.clone() might have dereferenced x, possibly through Deref impls\n-            if cx.tables.expr_ty(arg) == ty {\n+            if cx.tables().expr_ty(arg) == ty {\n                 snip = Some((\"try removing the `clone` call\", format!(\"{}\", snippet)));\n             } else {\n                 let deref_count = cx\n-                    .tables\n+                    .tables()\n                     .expr_adjustments(arg)\n                     .iter()\n                     .filter(|adj| {\n@@ -2048,7 +2051,7 @@ fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, arg: &hir:\n }\n \n fn lint_clone_on_ref_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n-    let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(arg));\n+    let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(arg));\n \n     if let ty::Adt(_, subst) = obj_ty.kind {\n         let caller_type = if is_type_diagnostic_item(cx, obj_ty, sym::Rc) {\n@@ -2082,7 +2085,7 @@ fn lint_string_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[hi\n     let arg = &args[1];\n     if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n         let target = &arglists[0][0];\n-        let self_ty = walk_ptrs_ty(cx.tables.expr_ty(target));\n+        let self_ty = walk_ptrs_ty(cx.tables().expr_ty(target));\n         let ref_str = if self_ty.kind == ty::Str {\n             \"\"\n         } else if is_type_diagnostic_item(cx, self_ty, sym!(string_type)) {\n@@ -2110,15 +2113,15 @@ fn lint_string_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[hi\n }\n \n fn lint_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n-    let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&args[0]));\n+    let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(&args[0]));\n     if is_type_diagnostic_item(cx, obj_ty, sym!(string_type)) {\n         lint_string_extend(cx, expr, args);\n     }\n }\n \n fn lint_cstring_as_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, source: &hir::Expr<'_>, unwrap: &hir::Expr<'_>) {\n     if_chain! {\n-        let source_type = cx.tables.expr_ty(source);\n+        let source_type = cx.tables().expr_ty(source);\n         if let ty::Adt(def, substs) = source_type.kind;\n         if cx.tcx.is_diagnostic_item(sym!(result_type), def.did);\n         if match_type(cx, substs.type_at(0), &paths::CSTRING);\n@@ -2142,8 +2145,8 @@ fn lint_iter_cloned_collect<'a, 'tcx>(\n     iter_args: &'tcx [hir::Expr<'_>],\n ) {\n     if_chain! {\n-        if is_type_diagnostic_item(cx, cx.tables.expr_ty(expr), sym!(vec_type));\n-        if let Some(slice) = derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0]));\n+        if is_type_diagnostic_item(cx, cx.tables().expr_ty(expr), sym!(vec_type));\n+        if let Some(slice) = derefs_to_slice(cx, &iter_args[0], cx.tables().expr_ty(&iter_args[0]));\n         if let Some(to_replace) = expr.span.trim_start(slice.span.source_callsite());\n \n         then {\n@@ -2250,7 +2253,7 @@ fn lint_unnecessary_fold(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, fold_ar\n \n fn lint_step_by<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr<'_>, args: &'tcx [hir::Expr<'_>]) {\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        if let Some((Constant::Int(0), _)) = constant(cx, cx.tables, &args[1]) {\n+        if let Some((Constant::Int(0), _)) = constant(cx, cx.tables(), &args[1]) {\n             span_lint(\n                 cx,\n                 ITERATOR_STEP_BY_ZERO,\n@@ -2274,7 +2277,7 @@ fn lint_iter_next<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_\n         parent_expr_opt = get_parent_expr(cx, parent_expr);\n     }\n \n-    if derefs_to_slice(cx, caller_expr, cx.tables.expr_ty(caller_expr)).is_some() {\n+    if derefs_to_slice(cx, caller_expr, cx.tables().expr_ty(caller_expr)).is_some() {\n         // caller is a Slice\n         if_chain! {\n             if let hir::ExprKind::Index(ref caller_var, ref index_expr) = &caller_expr.kind;\n@@ -2295,8 +2298,8 @@ fn lint_iter_next<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_\n                 );\n             }\n         }\n-    } else if is_type_diagnostic_item(cx, cx.tables.expr_ty(caller_expr), sym!(vec_type))\n-        || matches!(&walk_ptrs_ty(cx.tables.expr_ty(caller_expr)).kind, ty::Array(_, _))\n+    } else if is_type_diagnostic_item(cx, cx.tables().expr_ty(caller_expr), sym!(vec_type))\n+        || matches!(&walk_ptrs_ty(cx.tables().expr_ty(caller_expr)).kind, ty::Array(_, _))\n     {\n         // caller is a Vec or an Array\n         let mut applicability = Applicability::MachineApplicable;\n@@ -2323,11 +2326,11 @@ fn lint_iter_nth<'a, 'tcx>(\n ) {\n     let iter_args = nth_and_iter_args[1];\n     let mut_str = if is_mut { \"_mut\" } else { \"\" };\n-    let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some() {\n+    let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.tables().expr_ty(&iter_args[0])).is_some() {\n         \"slice\"\n-    } else if is_type_diagnostic_item(cx, cx.tables.expr_ty(&iter_args[0]), sym!(vec_type)) {\n+    } else if is_type_diagnostic_item(cx, cx.tables().expr_ty(&iter_args[0]), sym!(vec_type)) {\n         \"Vec\"\n-    } else if is_type_diagnostic_item(cx, cx.tables.expr_ty(&iter_args[0]), sym!(vecdeque_type)) {\n+    } else if is_type_diagnostic_item(cx, cx.tables().expr_ty(&iter_args[0]), sym!(vecdeque_type)) {\n         \"VecDeque\"\n     } else {\n         let nth_args = nth_and_iter_args[0];\n@@ -2348,7 +2351,7 @@ fn lint_iter_nth<'a, 'tcx>(\n fn lint_iter_nth_zero<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr<'_>, nth_args: &'tcx [hir::Expr<'_>]) {\n     if_chain! {\n         if match_trait_method(cx, expr, &paths::ITERATOR);\n-        if let Some((Constant::Int(0), _)) = constant(cx, cx.tables, &nth_args[1]);\n+        if let Some((Constant::Int(0), _)) = constant(cx, cx.tables(), &nth_args[1]);\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n@@ -2373,7 +2376,7 @@ fn lint_get_unwrap<'a, 'tcx>(\n     // Note: we don't want to lint `get_mut().unwrap` for `HashMap` or `BTreeMap`,\n     // because they do not implement `IndexMut`\n     let mut applicability = Applicability::MachineApplicable;\n-    let expr_ty = cx.tables.expr_ty(&get_args[0]);\n+    let expr_ty = cx.tables().expr_ty(&get_args[0]);\n     let get_args_str = if get_args.len() > 1 {\n         snippet_with_applicability(cx, get_args[1].span, \"_\", &mut applicability)\n     } else {\n@@ -2479,7 +2482,7 @@ fn derefs_to_slice<'a, 'tcx>(\n     }\n \n     if let hir::ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind {\n-        if path.ident.name == sym!(iter) && may_slice(cx, cx.tables.expr_ty(&args[0])) {\n+        if path.ident.name == sym!(iter) && may_slice(cx, cx.tables().expr_ty(&args[0])) {\n             Some(&args[0])\n         } else {\n             None\n@@ -2502,7 +2505,7 @@ fn derefs_to_slice<'a, 'tcx>(\n \n /// lint use of `unwrap()` for `Option`s and `Result`s\n fn lint_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, unwrap_args: &[hir::Expr<'_>]) {\n-    let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&unwrap_args[0]));\n+    let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(&unwrap_args[0]));\n \n     let mess = if is_type_diagnostic_item(cx, obj_ty, sym!(option_type)) {\n         Some((UNWRAP_USED, \"an Option\", \"None\"))\n@@ -2530,7 +2533,7 @@ fn lint_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, unwrap_args: &[hi\n \n /// lint use of `expect()` for `Option`s and `Result`s\n fn lint_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, expect_args: &[hir::Expr<'_>]) {\n-    let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&expect_args[0]));\n+    let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(&expect_args[0]));\n \n     let mess = if is_type_diagnostic_item(cx, obj_ty, sym!(option_type)) {\n         Some((EXPECT_USED, \"an Option\", \"None\"))\n@@ -2556,8 +2559,8 @@ fn lint_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, expect_args: &[hi\n fn lint_ok_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, ok_args: &[hir::Expr<'_>]) {\n     if_chain! {\n         // lint if the caller of `ok()` is a `Result`\n-        if is_type_diagnostic_item(cx, cx.tables.expr_ty(&ok_args[0]), sym!(result_type));\n-        let result_type = cx.tables.expr_ty(&ok_args[0]);\n+        if is_type_diagnostic_item(cx, cx.tables().expr_ty(&ok_args[0]), sym!(result_type));\n+        let result_type = cx.tables().expr_ty(&ok_args[0]);\n         if let Some(error_type) = get_error_type(cx, result_type);\n         if has_debug_impl(error_type, cx);\n \n@@ -2595,7 +2598,7 @@ fn lint_map_flatten<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<\n     }\n \n     // lint if caller of `.map().flatten()` is an Option\n-    if is_type_diagnostic_item(cx, cx.tables.expr_ty(&map_args[0]), sym!(option_type)) {\n+    if is_type_diagnostic_item(cx, cx.tables().expr_ty(&map_args[0]), sym!(option_type)) {\n         let msg = \"called `map(..).flatten()` on an `Option`. \\\n                     This is more succinctly expressed by calling `.and_then(..)`\";\n         let self_snippet = snippet(cx, map_args[0].span, \"..\");\n@@ -2621,8 +2624,8 @@ fn lint_map_unwrap_or_else<'a, 'tcx>(\n     unwrap_args: &'tcx [hir::Expr<'_>],\n ) {\n     // lint if the caller of `map()` is an `Option`\n-    let is_option = is_type_diagnostic_item(cx, cx.tables.expr_ty(&map_args[0]), sym!(option_type));\n-    let is_result = is_type_diagnostic_item(cx, cx.tables.expr_ty(&map_args[0]), sym!(result_type));\n+    let is_option = is_type_diagnostic_item(cx, cx.tables().expr_ty(&map_args[0]), sym!(option_type));\n+    let is_result = is_type_diagnostic_item(cx, cx.tables().expr_ty(&map_args[0]), sym!(result_type));\n \n     if is_option || is_result {\n         // Don't make a suggestion that may fail to compile due to mutably borrowing\n@@ -2676,8 +2679,8 @@ fn lint_map_or_none<'a, 'tcx>(\n     expr: &'tcx hir::Expr<'_>,\n     map_or_args: &'tcx [hir::Expr<'_>],\n ) {\n-    let is_option = is_type_diagnostic_item(cx, cx.tables.expr_ty(&map_or_args[0]), sym!(option_type));\n-    let is_result = is_type_diagnostic_item(cx, cx.tables.expr_ty(&map_or_args[0]), sym!(result_type));\n+    let is_option = is_type_diagnostic_item(cx, cx.tables().expr_ty(&map_or_args[0]), sym!(option_type));\n+    let is_result = is_type_diagnostic_item(cx, cx.tables().expr_ty(&map_or_args[0]), sym!(result_type));\n \n     // There are two variants of this `map_or` lint:\n     // (1) using `map_or` as an adapter from `Result<T,E>` to `Option<T>`\n@@ -3042,7 +3045,7 @@ fn lint_chars_cmp(\n         if segment.ident.name == sym!(Some);\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n-            let self_ty = walk_ptrs_ty(cx.tables.expr_ty_adjusted(&args[0][0]));\n+            let self_ty = walk_ptrs_ty(cx.tables().expr_ty_adjusted(&args[0][0]));\n \n             if self_ty.kind != ty::Str {\n                 return false;\n@@ -3174,8 +3177,8 @@ fn lint_asref(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, call_name: &str, a\n     if match_trait_method(cx, expr, &paths::ASREF_TRAIT) || match_trait_method(cx, expr, &paths::ASMUT_TRAIT) {\n         // check if the type after `as_ref` or `as_mut` is the same as before\n         let recvr = &as_ref_args[0];\n-        let rcv_ty = cx.tables.expr_ty(recvr);\n-        let res_ty = cx.tables.expr_ty(expr);\n+        let rcv_ty = cx.tables().expr_ty(recvr);\n+        let res_ty = cx.tables().expr_ty(expr);\n         let (base_res_ty, res_depth) = walk_ptrs_ty_depth(res_ty);\n         let (base_rcv_ty, rcv_depth) = walk_ptrs_ty_depth(rcv_ty);\n         if base_rcv_ty == base_res_ty && rcv_depth >= res_depth {\n@@ -3244,7 +3247,7 @@ fn lint_maybe_uninit(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, outer: &hir\n         if args.is_empty();\n         if let hir::ExprKind::Path(ref path) = callee.kind;\n         if match_qpath(path, &paths::MEM_MAYBEUNINIT_UNINIT);\n-        if !is_maybe_uninit_ty_valid(cx, cx.tables.expr_ty_adjusted(outer));\n+        if !is_maybe_uninit_ty_valid(cx, cx.tables().expr_ty_adjusted(outer));\n         then {\n             span_lint(\n                 cx,\n@@ -3286,7 +3289,7 @@ fn lint_option_as_ref_deref<'a, 'tcx>(\n ) {\n     let same_mutability = |m| (is_mut && m == &hir::Mutability::Mut) || (!is_mut && m == &hir::Mutability::Not);\n \n-    let option_ty = cx.tables.expr_ty(&as_ref_args[0]);\n+    let option_ty = cx.tables().expr_ty(&as_ref_args[0]);\n     if !is_type_diagnostic_item(cx, option_ty, sym!(option_type)) {\n         return;\n     }\n@@ -3314,12 +3317,12 @@ fn lint_option_as_ref_deref<'a, 'tcx>(\n                     if_chain! {\n                         if args.len() == 1;\n                         if let hir::ExprKind::Path(qpath) = &args[0].kind;\n-                        if let hir::def::Res::Local(local_id) = cx.tables.qpath_res(qpath, args[0].hir_id);\n+                        if let hir::def::Res::Local(local_id) = cx.tables().qpath_res(qpath, args[0].hir_id);\n                         if closure_body.params[0].pat.hir_id == local_id;\n-                        let adj = cx.tables.expr_adjustments(&args[0]).iter().map(|x| &x.kind).collect::<Box<[_]>>();\n+                        let adj = cx.tables().expr_adjustments(&args[0]).iter().map(|x| &x.kind).collect::<Box<[_]>>();\n                         if let [ty::adjustment::Adjust::Deref(None), ty::adjustment::Adjust::Borrow(_)] = *adj;\n                         then {\n-                            let method_did = cx.tables.type_dependent_def_id(closure_expr.hir_id).unwrap();\n+                            let method_did = cx.tables().type_dependent_def_id(closure_expr.hir_id).unwrap();\n                             deref_aliases.iter().any(|path| match_def_path(cx, method_did, path))\n                         } else {\n                             false\n@@ -3331,7 +3334,7 @@ fn lint_option_as_ref_deref<'a, 'tcx>(\n                         if let hir::ExprKind::Unary(hir::UnOp::UnDeref, ref inner1) = inner.kind;\n                         if let hir::ExprKind::Unary(hir::UnOp::UnDeref, ref inner2) = inner1.kind;\n                         if let hir::ExprKind::Path(ref qpath) = inner2.kind;\n-                        if let hir::def::Res::Local(local_id) = cx.tables.qpath_res(qpath, inner2.hir_id);\n+                        if let hir::def::Res::Local(local_id) = cx.tables().qpath_res(qpath, inner2.hir_id);\n                         then {\n                             closure_body.params[0].pat.hir_id == local_id\n                         } else {\n@@ -3614,7 +3617,7 @@ fn contains_return(expr: &hir::Expr<'_>) -> bool {\n fn check_pointer_offset(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     if_chain! {\n         if args.len() == 2;\n-        if let ty::RawPtr(ty::TypeAndMut { ref ty, .. }) = cx.tables.expr_ty(&args[0]).kind;\n+        if let ty::RawPtr(ty::TypeAndMut { ref ty, .. }) = cx.tables().expr_ty(&args[0]).kind;\n         if let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(ty));\n         if layout.is_zst();\n         then {\n@@ -3624,7 +3627,7 @@ fn check_pointer_offset(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[\n }\n \n fn lint_filetype_is_file(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n-    let ty = cx.tables.expr_ty(&args[0]);\n+    let ty = cx.tables().expr_ty(&args[0]);\n \n     if !match_type(cx, ty, &paths::FILE_TYPE) {\n         return;"}, {"sha": "7f4529a5870ac142f5ad06b821ebcbf15d0dddce", "filename": "clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -20,8 +20,8 @@ pub(super) fn lint<'a, 'tcx>(\n     map_span: Span,\n ) {\n     // lint if the caller of `map()` is an `Option`\n-    if is_type_diagnostic_item(cx, cx.tables.expr_ty(&map_args[0]), sym!(option_type)) {\n-        if !is_copy(cx, cx.tables.expr_ty(&unwrap_args[1])) {\n+    if is_type_diagnostic_item(cx, cx.tables().expr_ty(&map_args[0]), sym!(option_type)) {\n+        if !is_copy(cx, cx.tables().expr_ty(&unwrap_args[1])) {\n             // Do not lint if the `map` argument uses identifiers in the `map`\n             // argument that are also used in the `unwrap_or` argument\n "}, {"sha": "88243a88d9dd7a91c71c9cf33c47968b62fc1407", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -65,7 +65,7 @@ fn check_expression<'a, 'tcx>(\n                     if match_qpath(path, &paths::OPTION_SOME) {\n                         if_chain! {\n                             if let hir::ExprKind::Path(path) = &args[0].kind;\n-                            if let Res::Local(ref local) = cx.tables.qpath_res(path, args[0].hir_id);\n+                            if let Res::Local(ref local) = cx.tables().qpath_res(path, args[0].hir_id);\n                             then {\n                                 if arg_id == *local {\n                                     return (false, false)"}, {"sha": "8e6f3925d66050fd819b8fddfda818d609773590", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MinMaxPass {\n                 }\n                 match (\n                     outer_max,\n-                    Constant::partial_cmp(cx.tcx, cx.tables.expr_ty(ie), &outer_c, &inner_c),\n+                    Constant::partial_cmp(cx.tcx, cx.tables().expr_ty(ie), &outer_c, &inner_c),\n                 ) {\n                     (_, None) | (MinMax::Max, Some(Ordering::Less)) | (MinMax::Min, Some(Ordering::Greater)) => (),\n                     _ => {\n@@ -62,15 +62,18 @@ enum MinMax {\n fn min_max<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr<'a>) -> Option<(MinMax, Constant, &'a Expr<'a>)> {\n     if let ExprKind::Call(ref path, ref args) = expr.kind {\n         if let ExprKind::Path(ref qpath) = path.kind {\n-            cx.tables.qpath_res(qpath, path.hir_id).opt_def_id().and_then(|def_id| {\n-                if match_def_path(cx, def_id, &paths::CMP_MIN) {\n-                    fetch_const(cx, args, MinMax::Min)\n-                } else if match_def_path(cx, def_id, &paths::CMP_MAX) {\n-                    fetch_const(cx, args, MinMax::Max)\n-                } else {\n-                    None\n-                }\n-            })\n+            cx.tables()\n+                .qpath_res(qpath, path.hir_id)\n+                .opt_def_id()\n+                .and_then(|def_id| {\n+                    if match_def_path(cx, def_id, &paths::CMP_MIN) {\n+                        fetch_const(cx, args, MinMax::Min)\n+                    } else if match_def_path(cx, def_id, &paths::CMP_MAX) {\n+                        fetch_const(cx, args, MinMax::Max)\n+                    } else {\n+                        None\n+                    }\n+                })\n         } else {\n             None\n         }\n@@ -87,14 +90,14 @@ fn fetch_const<'a>(\n     if args.len() != 2 {\n         return None;\n     }\n-    if let Some(c) = constant_simple(cx, cx.tables, &args[0]) {\n-        if constant_simple(cx, cx.tables, &args[1]).is_none() {\n+    if let Some(c) = constant_simple(cx, cx.tables(), &args[0]) {\n+        if constant_simple(cx, cx.tables(), &args[1]).is_none() {\n             // otherwise ignore\n             Some((m, c, &args[1]))\n         } else {\n             None\n         }\n-    } else if let Some(c) = constant_simple(cx, cx.tables, &args[1]) {\n+    } else if let Some(c) = constant_simple(cx, cx.tables(), &args[1]) {\n         Some((m, c, &args[0]))\n     } else {\n         None"}, {"sha": "99cd864cae4e35b62955871bdc6d924a3c19671d", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -436,7 +436,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MiscLints {\n                     binding != \"_result\" && // FIXME: #944\n                     is_used(cx, expr) &&\n                     // don't lint if the declaration is in a macro\n-                    non_macro_local(cx, cx.tables.qpath_res(qpath, expr.hir_id))\n+                    non_macro_local(cx, cx.tables().qpath_res(qpath, expr.hir_id))\n                 {\n                     Some(binding)\n                 } else {\n@@ -496,7 +496,7 @@ fn get_lint_and_message(\n fn check_nan(cx: &LateContext<'_, '_>, expr: &Expr<'_>, cmp_expr: &Expr<'_>) {\n     if_chain! {\n         if !in_constant(cx, cmp_expr.hir_id);\n-        if let Some((value, _)) = constant(cx, cx.tables, expr);\n+        if let Some((value, _)) = constant(cx, cx.tables(), expr);\n         then {\n             let needs_lint = match value {\n                 Constant::F32(num) => num.is_nan(),\n@@ -517,15 +517,15 @@ fn check_nan(cx: &LateContext<'_, '_>, expr: &Expr<'_>, cmp_expr: &Expr<'_>) {\n }\n \n fn is_named_constant<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    if let Some((_, res)) = constant(cx, cx.tables, expr) {\n+    if let Some((_, res)) = constant(cx, cx.tables(), expr) {\n         res\n     } else {\n         false\n     }\n }\n \n fn is_allowed<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    match constant(cx, cx.tables, expr) {\n+    match constant(cx, cx.tables(), expr) {\n         Some((Constant::F32(f), _)) => f == 0.0 || f.is_infinite(),\n         Some((Constant::F64(f), _)) => f == 0.0 || f.is_infinite(),\n         Some((Constant::Vec(vec), _)) => vec.iter().all(|f| match f {\n@@ -557,7 +557,7 @@ fn is_signum(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n }\n \n fn is_float(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n-    let value = &walk_ptrs_ty(cx.tables.expr_ty(expr)).kind;\n+    let value = &walk_ptrs_ty(cx.tables().expr_ty(expr)).kind;\n \n     if let ty::Array(arr_ty, _) = value {\n         return matches!(arr_ty.kind, ty::Float(_));\n@@ -567,22 +567,22 @@ fn is_float(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n }\n \n fn is_array(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n-    matches!(&walk_ptrs_ty(cx.tables.expr_ty(expr)).kind, ty::Array(_, _))\n+    matches!(&walk_ptrs_ty(cx.tables().expr_ty(expr)).kind, ty::Array(_, _))\n }\n \n fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr<'_>, other: &Expr<'_>) {\n     let (arg_ty, snip) = match expr.kind {\n         ExprKind::MethodCall(.., ref args, _) if args.len() == 1 => {\n             if match_trait_method(cx, expr, &paths::TO_STRING) || match_trait_method(cx, expr, &paths::TO_OWNED) {\n-                (cx.tables.expr_ty_adjusted(&args[0]), snippet(cx, args[0].span, \"..\"))\n+                (cx.tables().expr_ty_adjusted(&args[0]), snippet(cx, args[0].span, \"..\"))\n             } else {\n                 return;\n             }\n         },\n         ExprKind::Call(ref path, ref v) if v.len() == 1 => {\n             if let ExprKind::Path(ref path) = path.kind {\n                 if match_qpath(path, &[\"String\", \"from_str\"]) || match_qpath(path, &[\"String\", \"from\"]) {\n-                    (cx.tables.expr_ty_adjusted(&v[0]), snippet(cx, v[0].span, \"..\"))\n+                    (cx.tables().expr_ty_adjusted(&v[0]), snippet(cx, v[0].span, \"..\"))\n                 } else {\n                     return;\n                 }\n@@ -593,7 +593,7 @@ fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr<'_>, other: &Expr<'_>) {\n         _ => return,\n     };\n \n-    let other_ty = cx.tables.expr_ty_adjusted(other);\n+    let other_ty = cx.tables().expr_ty_adjusted(other);\n     let partial_eq_trait_id = match cx.tcx.lang_items().eq_trait() {\n         Some(id) => id,\n         None => return,"}, {"sha": "f76e4721e1f63dd315045bf0ef2c1a64cdb22f9f", "filename": "clippy_lints/src/modulo_arithmetic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmodulo_arithmetic.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -37,8 +37,8 @@ struct OperandInfo {\n }\n \n fn analyze_operand(operand: &Expr<'_>, cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Option<OperandInfo> {\n-    match constant(cx, cx.tables, operand) {\n-        Some((Constant::Int(v), _)) => match cx.tables.expr_ty(expr).kind {\n+    match constant(cx, cx.tables(), operand) {\n+        Some((Constant::Int(v), _)) => match cx.tables().expr_ty(expr).kind {\n             ty::Int(ity) => {\n                 let value = sext(cx.tcx, v, ity);\n                 return Some(OperandInfo {\n@@ -106,7 +106,7 @@ fn check_const_operands<'a, 'tcx>(\n }\n \n fn check_non_const_operands<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>, operand: &Expr<'_>) {\n-    let operand_type = cx.tables.expr_ty(operand);\n+    let operand_type = cx.tables().expr_ty(operand);\n     if might_have_negative_value(operand_type) {\n         span_lint_and_then(\n             cx,"}, {"sha": "755b196c698c2ed0a050d0d442ec1d2fd848a718", "filename": "clippy_lints/src/mut_key.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_key.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -76,7 +76,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableKeyType {\n         if let hir::PatKind::Wild = local.pat.kind {\n             return;\n         }\n-        check_ty(cx, local.span, cx.tables.pat_ty(&*local.pat));\n+        check_ty(cx, local.span, cx.tables().pat_ty(&*local.pat));\n     }\n }\n "}, {"sha": "6aa77b4df83aa9409cd3a9d9e97397e8239cf798", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n                     expr.span,\n                     \"generally you want to avoid `&mut &mut _` if possible\",\n                 );\n-            } else if let ty::Ref(_, _, hir::Mutability::Mut) = self.cx.tables.expr_ty(e).kind {\n+            } else if let ty::Ref(_, _, hir::Mutability::Mut) = self.cx.tables().expr_ty(e).kind {\n                 span_lint(\n                     self.cx,\n                     MUT_MUT,"}, {"sha": "dbe257069c3e25a6716efab7d3433c1a9d5fac1a", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -37,14 +37,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n                     check_arguments(\n                         cx,\n                         arguments,\n-                        cx.tables.expr_ty(fn_expr),\n+                        cx.tables().expr_ty(fn_expr),\n                         &rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false)),\n                     );\n                 }\n             },\n             ExprKind::MethodCall(ref path, _, ref arguments, _) => {\n-                let def_id = cx.tables.type_dependent_def_id(e.hir_id).unwrap();\n-                let substs = cx.tables.node_substs(e.hir_id);\n+                let def_id = cx.tables().type_dependent_def_id(e.hir_id).unwrap();\n+                let substs = cx.tables().node_substs(e.hir_id);\n                 let method_type = cx.tcx.type_of(def_id).subst(cx.tcx, substs);\n                 check_arguments(cx, arguments, method_type, &path.ident.as_str())\n             },"}, {"sha": "45db5140711ad9d0cf9f307c084c44ec4aa161a5", "filename": "clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -135,7 +135,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MutArgVisitor<'a, 'tcx> {\n                 return;\n             },\n             ExprKind::Path(_) => {\n-                if let Some(adj) = self.cx.tables.adjustments().get(expr.hir_id) {\n+                if let Some(adj) = self.cx.tables().adjustments().get(expr.hir_id) {\n                     if adj\n                         .iter()\n                         .any(|a| matches!(a.target.kind, ty::Ref(_, _, Mutability::Mut)))"}, {"sha": "c227dc54f293945d353056d14e1f1a00667d7eb5", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -66,7 +66,7 @@ declare_lint_pass!(Mutex => [MUTEX_ATOMIC, MUTEX_INTEGER]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Mutex {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n-        let ty = cx.tables.expr_ty(expr);\n+        let ty = cx.tables().expr_ty(expr);\n         if let ty::Adt(_, subst) = ty.kind {\n             if is_type_diagnostic_item(cx, ty, sym!(mutex_type)) {\n                 let mutex_param = subst.type_at(0);"}, {"sha": "653f9e2ae8625b2710386b628d8b1548e7607674", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -229,7 +229,7 @@ fn check_comparison<'a, 'tcx>(\n     use self::Expression::{Bool, Other};\n \n     if let ExprKind::Binary(op, ref left_side, ref right_side) = e.kind {\n-        let (l_ty, r_ty) = (cx.tables.expr_ty(left_side), cx.tables.expr_ty(right_side));\n+        let (l_ty, r_ty) = (cx.tables().expr_ty(left_side), cx.tables().expr_ty(right_side));\n         if l_ty.is_bool() && r_ty.is_bool() {\n             let mut applicability = Applicability::MachineApplicable;\n "}, {"sha": "6bb06defb70348511723fa0a535564659e064c64", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -46,8 +46,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n             return;\n         }\n         if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, ref inner) = e.kind {\n-            if let ty::Ref(..) = cx.tables.expr_ty(inner).kind {\n-                for adj3 in cx.tables.expr_adjustments(e).windows(3) {\n+            if let ty::Ref(..) = cx.tables().expr_ty(inner).kind {\n+                for adj3 in cx.tables().expr_adjustments(e).windows(3) {\n                     if let [Adjustment {\n                         kind: Adjust::Deref(_), ..\n                     }, Adjustment {\n@@ -85,7 +85,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n         }\n         if_chain! {\n             if let PatKind::Binding(BindingAnnotation::Ref, .., name, _) = pat.kind;\n-            if let ty::Ref(_, tam, mutbl) = cx.tables.pat_ty(pat).kind;\n+            if let ty::Ref(_, tam, mutbl) = cx.tables().pat_ty(pat).kind;\n             if mutbl == Mutability::Not;\n             if let ty::Ref(_, _, mutbl) = tam.kind;\n             // only lint immutable refs, because borrowed `&mut T` cannot be moved out"}, {"sha": "6954f0cc683f1a135fbd9010384195444f9d07c7", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -135,7 +135,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         } = {\n             let mut ctx = MovedVariablesCtxt::default();\n             cx.tcx.infer_ctxt().enter(|infcx| {\n-                euv::ExprUseVisitor::new(&mut ctx, &infcx, fn_def_id, cx.param_env, cx.tables).consume_body(body);\n+                euv::ExprUseVisitor::new(&mut ctx, &infcx, fn_def_id, cx.param_env, cx.tables()).consume_body(body);\n             });\n             ctx\n         };\n@@ -173,13 +173,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                     !preds.is_empty() && {\n                         let ty_empty_region = cx.tcx.mk_imm_ref(cx.tcx.lifetimes.re_root_empty, ty);\n                         preds.iter().all(|t| {\n-                            let ty_params = &t\n-                                .skip_binder()\n-                                .trait_ref\n-                                .substs\n-                                .iter()\n-                                .skip(1)\n-                                .collect::<Vec<_>>();\n+                            let ty_params = &t.skip_binder().trait_ref.substs.iter().skip(1).collect::<Vec<_>>();\n                             implements_trait(cx, ty_empty_region, t.def_id(), ty_params)\n                         })\n                     },"}, {"sha": "9b556dbb8540e41db97a0232d6b72aac37a81b9b", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -47,7 +47,7 @@ declare_lint_pass!(NeedlessUpdate => [NEEDLESS_UPDATE]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessUpdate {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Struct(_, ref fields, Some(ref base)) = expr.kind {\n-            let ty = cx.tables.expr_ty(expr);\n+            let ty = cx.tables().expr_ty(expr);\n             if let ty::Adt(def, _) = ty.kind {\n                 if fields.len() == def.non_enum_variant().fields.len() {\n                     span_lint("}, {"sha": "0f56daa3659e8726ea8ef6739942b427c491c470", "filename": "clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -56,7 +56,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NoNegCompOpForPartialOrd {\n \n             then {\n \n-                let ty = cx.tables.expr_ty(left);\n+                let ty = cx.tables().expr_ty(left);\n \n                 let implements_ord = {\n                     if let Some(id) = utils::get_trait_def_id(cx, &paths::ORD) {"}, {"sha": "a9ce01b67b097b5e334b0a79790373c5ade26cdb", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -44,8 +44,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NegMultiply {\n fn check_mul(cx: &LateContext<'_, '_>, span: Span, lit: &Expr<'_>, exp: &Expr<'_>) {\n     if_chain! {\n         if let ExprKind::Lit(ref l) = lit.kind;\n-        if let Constant::Int(1) = consts::lit_to_constant(&l.node, cx.tables.expr_ty_opt(lit));\n-        if cx.tables.expr_ty(exp).is_integral();\n+        if let Constant::Int(1) = consts::lit_to_constant(&l.node, cx.tables().expr_ty_opt(lit));\n+        if cx.tables().expr_ty(exp).is_integral();\n         then {\n             span_lint(cx, NEG_MULTIPLY, span, \"Negation by multiplying with `-1`\");\n         }"}, {"sha": "5fdc656580f29c1c4ca0d343f6e89e0ee338af1a", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -48,7 +48,7 @@ fn has_no_effect(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n     }\n     match expr.kind {\n         ExprKind::Lit(..) | ExprKind::Closure(..) => true,\n-        ExprKind::Path(..) => !has_drop(cx, cx.tables.expr_ty(expr)),\n+        ExprKind::Path(..) => !has_drop(cx, cx.tables().expr_ty(expr)),\n         ExprKind::Index(ref a, ref b) | ExprKind::Binary(_, ref a, ref b) => {\n             has_no_effect(cx, a) && has_no_effect(cx, b)\n         },\n@@ -61,7 +61,7 @@ fn has_no_effect(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n         | ExprKind::AddrOf(_, _, ref inner)\n         | ExprKind::Box(ref inner) => has_no_effect(cx, inner),\n         ExprKind::Struct(_, ref fields, ref base) => {\n-            !has_drop(cx, cx.tables.expr_ty(expr))\n+            !has_drop(cx, cx.tables().expr_ty(expr))\n                 && fields.iter().all(|field| has_no_effect(cx, &field.expr))\n                 && base.as_ref().map_or(true, |base| has_no_effect(cx, base))\n         },\n@@ -70,7 +70,7 @@ fn has_no_effect(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n                 let res = qpath_res(cx, qpath, callee.hir_id);\n                 match res {\n                     Res::Def(DefKind::Struct | DefKind::Variant | DefKind::Ctor(..), ..) => {\n-                        !has_drop(cx, cx.tables.expr_ty(expr)) && args.iter().all(|arg| has_no_effect(cx, arg))\n+                        !has_drop(cx, cx.tables().expr_ty(expr)) && args.iter().all(|arg| has_no_effect(cx, arg))\n                     },\n                     _ => false,\n                 }\n@@ -137,7 +137,7 @@ fn reduce_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr<'a>) -> Option\n         | ExprKind::AddrOf(_, _, ref inner)\n         | ExprKind::Box(ref inner) => reduce_expression(cx, inner).or_else(|| Some(vec![inner])),\n         ExprKind::Struct(_, ref fields, ref base) => {\n-            if has_drop(cx, cx.tables.expr_ty(expr)) {\n+            if has_drop(cx, cx.tables().expr_ty(expr)) {\n                 None\n             } else {\n                 Some(fields.iter().map(|f| &f.expr).chain(base).map(Deref::deref).collect())\n@@ -148,7 +148,7 @@ fn reduce_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr<'a>) -> Option\n                 let res = qpath_res(cx, qpath, callee.hir_id);\n                 match res {\n                     Res::Def(DefKind::Struct | DefKind::Variant | DefKind::Ctor(..), ..)\n-                        if !has_drop(cx, cx.tables.expr_ty(expr)) =>\n+                        if !has_drop(cx, cx.tables().expr_ty(expr)) =>\n                     {\n                         Some(args.iter().collect())\n                     },"}, {"sha": "21d7a7439f25c58a6ccddd54cde6caa850f1d32e", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -237,13 +237,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n             }\n \n             let ty = if needs_check_adjustment {\n-                let adjustments = cx.tables.expr_adjustments(dereferenced_expr);\n+                let adjustments = cx.tables().expr_adjustments(dereferenced_expr);\n                 if let Some(i) = adjustments.iter().position(|adj| match adj.kind {\n                     Adjust::Borrow(_) | Adjust::Deref(_) => true,\n                     _ => false,\n                 }) {\n                     if i == 0 {\n-                        cx.tables.expr_ty(dereferenced_expr)\n+                        cx.tables().expr_ty(dereferenced_expr)\n                     } else {\n                         adjustments[i - 1].target\n                     }\n@@ -252,7 +252,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n                     return;\n                 }\n             } else {\n-                cx.tables.expr_ty(dereferenced_expr)\n+                cx.tables().expr_ty(dereferenced_expr)\n             };\n \n             verify_ty_bound(cx, ty, Source::Expr { expr: expr.span });"}, {"sha": "2467a14cea12fda73d53fe22c280c13ff25a48c9", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -30,7 +30,7 @@ declare_lint_pass!(OpenOptions => [NONSENSICAL_OPEN_OPTIONS]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OpenOptions {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n         if let ExprKind::MethodCall(ref path, _, ref arguments, _) = e.kind {\n-            let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&arguments[0]));\n+            let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(&arguments[0]));\n             if path.ident.name == sym!(open) && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n                 let mut options = Vec::new();\n                 get_open_options(cx, &arguments[0], &mut options);\n@@ -58,7 +58,7 @@ enum OpenOption {\n \n fn get_open_options(cx: &LateContext<'_, '_>, argument: &Expr<'_>, options: &mut Vec<(OpenOption, Argument)>) {\n     if let ExprKind::MethodCall(ref path, _, ref arguments, _) = argument.kind {\n-        let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&arguments[0]));\n+        let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(&arguments[0]));\n \n         // Only proceed if this is a call on some object of type std::fs::OpenOptions\n         if match_type(cx, obj_ty, &paths::OPEN_OPTIONS) && arguments.len() >= 2 {"}, {"sha": "5984b09120d0e741d7e9741ff8961cd7a58cdac8", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -36,8 +36,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OverflowCheckConditional {\n             if let ExprKind::Path(QPath::Resolved(_, ref path2)) = ident2.kind;\n             if let ExprKind::Path(QPath::Resolved(_, ref path3)) = second.kind;\n             if eq(&path1.segments[0], &path3.segments[0]) || eq(&path2.segments[0], &path3.segments[0]);\n-            if cx.tables.expr_ty(ident1).is_integral();\n-            if cx.tables.expr_ty(ident2).is_integral();\n+            if cx.tables().expr_ty(ident1).is_integral();\n+            if cx.tables().expr_ty(ident2).is_integral();\n             then {\n                 if let BinOpKind::Lt = op.node {\n                     if let BinOpKind::Add = op2.node {\n@@ -61,8 +61,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OverflowCheckConditional {\n             if let ExprKind::Path(QPath::Resolved(_, ref path2)) = ident2.kind;\n             if let ExprKind::Path(QPath::Resolved(_, ref path3)) = first.kind;\n             if eq(&path1.segments[0], &path3.segments[0]) || eq(&path2.segments[0], &path3.segments[0]);\n-            if cx.tables.expr_ty(ident1).is_integral();\n-            if cx.tables.expr_ty(ident2).is_integral();\n+            if cx.tables().expr_ty(ident1).is_integral();\n+            if cx.tables().expr_ty(ident2).is_integral();\n             then {\n                 if let BinOpKind::Gt = op.node {\n                     if let BinOpKind::Add = op2.node {"}, {"sha": "f26a5258782a72755f9b022e86dec45c41f06131", "filename": "clippy_lints/src/path_buf_push_overwrite.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PathBufPushOverwrite {\n             if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n             if path.ident.name == sym!(push);\n             if args.len() == 2;\n-            if match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(&args[0])), &paths::PATH_BUF);\n+            if match_type(cx, walk_ptrs_ty(cx.tables().expr_ty(&args[0])), &paths::PATH_BUF);\n             if let Some(get_index_arg) = args.get(1);\n             if let ExprKind::Lit(ref lit) = get_index_arg.kind;\n             if let LitKind::Str(ref path_lit, _) = lit.node;"}, {"sha": "b35a7e64bff2740bddfe01b7299da39f4d014162", "filename": "clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -105,12 +105,12 @@ fn expr_as_ptr_offset_call<'a, 'tcx>(\n \n // Is the type of the expression a usize?\n fn is_expr_ty_usize<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr<'_>) -> bool {\n-    cx.tables.expr_ty(expr) == cx.tcx.types.usize\n+    cx.tables().expr_ty(expr) == cx.tcx.types.usize\n }\n \n // Is the type of the expression a raw pointer?\n fn is_expr_ty_raw_ptr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr<'_>) -> bool {\n-    cx.tables.expr_ty(expr).is_unsafe_ptr()\n+    cx.tables().expr_ty(expr).is_unsafe_ptr()\n }\n \n fn build_suggestion<'a, 'tcx>("}, {"sha": "4a6395da01c99ffcfb05a7d587d5c1de16583b8f", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -135,13 +135,13 @@ impl QuestionMark {\n     }\n \n     fn moves_by_default(cx: &LateContext<'_, '_>, expression: &Expr<'_>) -> bool {\n-        let expr_ty = cx.tables.expr_ty(expression);\n+        let expr_ty = cx.tables().expr_ty(expression);\n \n         !expr_ty.is_copy_modulo_regions(cx.tcx.at(expression.span), cx.param_env)\n     }\n \n     fn is_option(cx: &LateContext<'_, '_>, expression: &Expr<'_>) -> bool {\n-        let expr_ty = cx.tables.expr_ty(expression);\n+        let expr_ty = cx.tables().expr_ty(expression);\n \n         is_type_diagnostic_item(cx, expr_ty, sym!(option_type))\n     }\n@@ -158,7 +158,7 @@ impl QuestionMark {\n             ExprKind::Ret(Some(ref expr)) => Self::expression_returns_none(cx, expr),\n             ExprKind::Path(ref qp) => {\n                 if let Res::Def(DefKind::Ctor(def::CtorOf::Variant, def::CtorKind::Const), def_id) =\n-                    cx.tables.qpath_res(qp, expression.hir_id)\n+                    cx.tables().qpath_res(qp, expression.hir_id)\n                 {\n                     return match_def_path(cx, def_id, &paths::OPTION_NONE);\n                 }"}, {"sha": "43ef236a92420aa855225b6567aa2d7a682cd71e", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -272,10 +272,10 @@ fn check_reversed_empty_range(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n \n     if_chain! {\n         if let Some(higher::Range { start: Some(start), end: Some(end), limits }) = higher::range(cx, expr);\n-        let ty = cx.tables.expr_ty(start);\n+        let ty = cx.tables().expr_ty(start);\n         if let ty::Int(_) | ty::Uint(_) = ty.kind;\n-        if let Some((start_idx, _)) = constant(cx, cx.tables, start);\n-        if let Some((end_idx, _)) = constant(cx, cx.tables, end);\n+        if let Some((start_idx, _)) = constant(cx, cx.tables(), start);\n+        if let Some((end_idx, _)) = constant(cx, cx.tables(), end);\n         if let Some(ordering) = Constant::partial_cmp(cx.tcx, ty, &start_idx, &end_idx);\n         if is_empty_range(limits, ordering);\n         then {"}, {"sha": "9c54c3cbac02b6dda9cfe8ab865011a2cbf3ac76", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -82,7 +82,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Regex {\n         if_chain! {\n             if self.last.is_none();\n             if let Some(ref expr) = block.expr;\n-            if match_type(cx, cx.tables.expr_ty(expr), &paths::REGEX);\n+            if match_type(cx, cx.tables().expr_ty(expr), &paths::REGEX);\n             if let Some(span) = is_expn_of(expr.span, \"regex\");\n             then {\n                 if !self.spans.contains(&span) {\n@@ -111,7 +111,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Regex {\n             if let ExprKind::Call(ref fun, ref args) = expr.kind;\n             if let ExprKind::Path(ref qpath) = fun.kind;\n             if args.len() == 1;\n-            if let Some(def_id) = cx.tables.qpath_res(qpath, fun.hir_id).opt_def_id();\n+            if let Some(def_id) = cx.tables().qpath_res(qpath, fun.hir_id).opt_def_id();\n             then {\n                 if match_def_path(cx, def_id, &paths::REGEX_NEW) ||\n                    match_def_path(cx, def_id, &paths::REGEX_BUILDER_NEW) {\n@@ -140,7 +140,7 @@ fn str_span(base: Span, c: regex_syntax::ast::Span, offset: u16) -> Span {\n }\n \n fn const_str<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) -> Option<String> {\n-    constant(cx, cx.tables, e).and_then(|(c, _)| match c {\n+    constant(cx, cx.tables(), e).and_then(|(c, _)| match c {\n         Constant::Str(s) => Some(s),\n         _ => None,\n     })"}, {"sha": "4780249bcb8e3fe4840622eab86bb2dd034f7c40", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -164,7 +164,7 @@ fn check_local<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, local: &'tcx Local<'_>, bin\n }\n \n fn is_binding(cx: &LateContext<'_, '_>, pat_id: HirId) -> bool {\n-    let var_ty = cx.tables.node_type_opt(pat_id);\n+    let var_ty = cx.tables().node_type_opt(pat_id);\n     if let Some(var_ty) = var_ty {\n         match var_ty.kind {\n             ty::Adt(..) => false,"}, {"sha": "ef66850358e57715a82e52b2481e2a74d7834a22", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -134,7 +134,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringAdd {\n }\n \n fn is_string(cx: &LateContext<'_, '_>, e: &Expr<'_>) -> bool {\n-    is_type_diagnostic_item(cx, walk_ptrs_ty(cx.tables.expr_ty(e)), sym!(string_type))\n+    is_type_diagnostic_item(cx, walk_ptrs_ty(cx.tables().expr_ty(e)), sym!(string_type))\n }\n \n fn is_add(cx: &LateContext<'_, '_>, src: &Expr<'_>, target: &Expr<'_>) -> bool {"}, {"sha": "7fdc872c01f54c4589afac09b8ac29a4e5267818", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -194,7 +194,7 @@ fn check_for_slice<'a>(cx: &LateContext<'_, '_>, lhs1: &'a Expr<'_>, lhs2: &'a E\n     if let ExprKind::Index(ref lhs1, ref idx1) = lhs1.kind {\n         if let ExprKind::Index(ref lhs2, ref idx2) = lhs2.kind {\n             if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, lhs2) {\n-                let ty = walk_ptrs_ty(cx.tables.expr_ty(lhs1));\n+                let ty = walk_ptrs_ty(cx.tables().expr_ty(lhs1));\n \n                 if matches!(ty.kind, ty::Slice(_))\n                     || matches!(ty.kind, ty::Array(_, _))"}, {"sha": "f2bbf19bea92ff86e5f7705c05dacb3771b0b60a", "filename": "clippy_lints/src/temporary_assignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftemporary_assignment.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -26,7 +26,7 @@ fn is_temporary(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n     match &expr.kind {\n         ExprKind::Struct(..) | ExprKind::Tup(..) => true,\n         ExprKind::Path(qpath) => {\n-            if let Res::Def(DefKind::Const, ..) = cx.tables.qpath_res(qpath, expr.hir_id) {\n+            if let Res::Def(DefKind::Const, ..) = cx.tables().qpath_res(qpath, expr.hir_id) {\n                 true\n             } else {\n                 false"}, {"sha": "1efba3580fef09506e468cf8091b1efa4da9d382", "filename": "clippy_lints/src/to_digit_is_some.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fto_digit_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fto_digit_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fto_digit_is_some.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -43,7 +43,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ToDigitIsSome {\n                         if_chain! {\n                             if let [char_arg, radix_arg] = &**to_digit_args;\n                             if to_digits_path.ident.name.as_str() == \"to_digit\";\n-                            let char_arg_ty = cx.tables.expr_ty_adjusted(char_arg);\n+                            let char_arg_ty = cx.tables().expr_ty_adjusted(char_arg);\n                             if char_arg_ty.kind == ty::Char;\n                             then {\n                                 Some((true, char_arg, radix_arg))\n@@ -56,7 +56,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ToDigitIsSome {\n                         if_chain! {\n                             if let [char_arg, radix_arg] = &**to_digit_args;\n                             if let hir::ExprKind::Path(to_digits_path) = &to_digits_call.kind;\n-                            if let to_digits_call_res = cx.tables.qpath_res(to_digits_path, to_digits_call.hir_id);\n+                            if let to_digits_call_res = cx.tables().qpath_res(to_digits_path, to_digits_call.hir_id);\n                             if let Some(to_digits_def_id) = to_digits_call_res.opt_def_id();\n                             if match_def_path(cx, to_digits_def_id, &[\"core\", \"char\", \"methods\", \"<impl char>\", \"to_digit\"]);\n                             then {"}, {"sha": "1b233b8302f9313e2c1cb839b43149d9d0d86609", "filename": "clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -37,7 +37,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TraitBounds {\n             return;\n         }\n         let hash = |ty| -> u64 {\n-            let mut hasher = SpanlessHash::new(cx, cx.tables);\n+            let mut hasher = SpanlessHash::new(cx, cx.tables());\n             hasher.hash_ty(ty);\n             hasher.finish()\n         };"}, {"sha": "9b1344949470a91d4f18c3719cace1e314e7e5b6", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -299,11 +299,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n         if_chain! {\n             if let ExprKind::Call(ref path_expr, ref args) = e.kind;\n             if let ExprKind::Path(ref qpath) = path_expr.kind;\n-            if let Some(def_id) = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id();\n+            if let Some(def_id) = cx.tables().qpath_res(qpath, path_expr.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::TRANSMUTE);\n             then {\n-                let from_ty = cx.tables.expr_ty(&args[0]);\n-                let to_ty = cx.tables.expr_ty(e);\n+                let from_ty = cx.tables().expr_ty(&args[0]);\n+                let to_ty = cx.tables().expr_ty(e);\n \n                 match (&from_ty.kind, &to_ty.kind) {\n                     _ if from_ty == to_ty => span_lint("}, {"sha": "3351488a45c4ddba8e335ed572f3561df71b239a", "filename": "clippy_lints/src/transmuting_null.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmuting_null.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -44,7 +44,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TransmutingNull {\n             then {\n \n                 // Catching transmute over constants that resolve to `null`.\n-                let mut const_eval_context = constant_context(cx, cx.tables);\n+                let mut const_eval_context = constant_context(cx, cx.tables());\n                 if_chain! {\n                     if let ExprKind::Path(ref _qpath) = args[0].kind;\n                     let x = const_eval_context.expr(&args[0]);"}, {"sha": "e129dd84d15a6dd0ab24c82b821129acb695a7d4", "filename": "clippy_lints/src/try_err.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftry_err.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -68,7 +68,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TryErr {\n             if let Some(return_type) = find_err_return_type(cx, &expr.kind);\n \n             then {\n-                let err_type = cx.tables.expr_ty(err_arg);\n+                let err_type = cx.tables().expr_ty(err_arg);\n                 let origin_snippet = if err_arg.span.from_expansion() {\n                     snippet_with_macro_callsite(cx, err_arg.span, \"_\")\n                 } else {\n@@ -114,7 +114,7 @@ fn find_err_return_type_arm<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arm: &'tcx Arm\n         if match_qpath(from_error_fn, &paths::TRY_FROM_ERROR);\n         if let Some(from_error_arg) = from_error_args.get(0);\n         then {\n-            Some(cx.tables.expr_ty(from_error_arg))\n+            Some(cx.tables().expr_ty(from_error_arg))\n         } else {\n             None\n         }"}, {"sha": "ecfb6ee2a7de9e02e3c3a396bd12410a88a02c87", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -603,7 +603,7 @@ declare_lint_pass!(LetUnitValue => [LET_UNIT_VALUE]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetUnitValue {\n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt<'_>) {\n         if let StmtKind::Local(ref local) = stmt.kind {\n-            if is_unit(cx.tables.pat_ty(&local.pat)) {\n+            if is_unit(cx.tables().pat_ty(&local.pat)) {\n                 if in_external_macro(cx.sess(), stmt.span) || local.pat.span.from_expansion() {\n                     return;\n                 }\n@@ -688,7 +688,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitCmp {\n                 if let ExpnKind::Macro(MacroKind::Bang, symbol) = callee.kind {\n                     if let ExprKind::Binary(ref cmp, ref left, _) = expr.kind {\n                         let op = cmp.node;\n-                        if op.is_comparison() && is_unit(cx.tables.expr_ty(left)) {\n+                        if op.is_comparison() && is_unit(cx.tables().expr_ty(left)) {\n                             let result = match &*symbol.as_str() {\n                                 \"assert_eq\" | \"debug_assert_eq\" => \"succeed\",\n                                 \"assert_ne\" | \"debug_assert_ne\" => \"fail\",\n@@ -712,7 +712,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitCmp {\n         }\n         if let ExprKind::Binary(ref cmp, ref left, _) = expr.kind {\n             let op = cmp.node;\n-            if op.is_comparison() && is_unit(cx.tables.expr_ty(left)) {\n+            if op.is_comparison() && is_unit(cx.tables().expr_ty(left)) {\n                 let result = match op {\n                     BinOpKind::Eq | BinOpKind::Le | BinOpKind::Ge => \"true\",\n                     _ => \"false\",\n@@ -782,7 +782,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitArg {\n                 let args_to_recover = args\n                     .iter()\n                     .filter(|arg| {\n-                        if is_unit(cx.tables.expr_ty(arg)) && !is_unit_literal(arg) {\n+                        if is_unit(cx.tables().expr_ty(arg)) && !is_unit_literal(arg) {\n                             if let ExprKind::Match(.., MatchSource::TryDesugar) = &arg.kind {\n                                 false\n                             } else {\n@@ -1250,7 +1250,7 @@ fn check_loss_of_sign(cx: &LateContext<'_, '_>, expr: &Expr<'_>, op: &Expr<'_>,\n     }\n \n     // don't lint for positive constants\n-    let const_val = constant(cx, &cx.tables, op);\n+    let const_val = constant(cx, &cx.tables(), op);\n     if_chain! {\n         if let Some((const_val, _)) = const_val;\n         if let Constant::Int(n) = const_val;\n@@ -1416,7 +1416,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Casts {\n             return;\n         }\n         if let ExprKind::Cast(ref ex, _) = expr.kind {\n-            let (cast_from, cast_to) = (cx.tables.expr_ty(ex), cx.tables.expr_ty(expr));\n+            let (cast_from, cast_to) = (cx.tables().expr_ty(ex), cx.tables().expr_ty(expr));\n             lint_fn_to_numeric_cast(cx, expr, ex, cast_from, cast_to);\n             if let ExprKind::Lit(ref lit) = ex.kind {\n                 if_chain! {\n@@ -1804,7 +1804,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CharLitAsU8 {\n             if let ExprKind::Cast(e, _) = &expr.kind;\n             if let ExprKind::Lit(l) = &e.kind;\n             if let LitKind::Char(c) = l.node;\n-            if ty::Uint(UintTy::U8) == cx.tables.expr_ty(expr).kind;\n+            if ty::Uint(UintTy::U8) == cx.tables().expr_ty(expr).kind;\n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let snippet = snippet_with_applicability(cx, e.span, \"'x'\", &mut applicability);\n@@ -1880,8 +1880,8 @@ enum AbsurdComparisonResult {\n \n fn is_cast_between_fixed_and_target<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n     if let ExprKind::Cast(ref cast_exp, _) = expr.kind {\n-        let precast_ty = cx.tables.expr_ty(cast_exp);\n-        let cast_ty = cx.tables.expr_ty(expr);\n+        let precast_ty = cx.tables().expr_ty(cast_exp);\n+        let cast_ty = cx.tables().expr_ty(expr);\n \n         return is_isize_or_usize(precast_ty) != is_isize_or_usize(cast_ty);\n     }\n@@ -1901,7 +1901,7 @@ fn detect_absurd_comparison<'a, 'tcx>(\n \n     // absurd comparison only makes sense on primitive types\n     // primitive types don't implement comparison operators with each other\n-    if cx.tables.expr_ty(lhs) != cx.tables.expr_ty(rhs) {\n+    if cx.tables().expr_ty(lhs) != cx.tables().expr_ty(rhs) {\n         return None;\n     }\n \n@@ -1939,9 +1939,9 @@ fn detect_absurd_comparison<'a, 'tcx>(\n fn detect_extreme_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) -> Option<ExtremeExpr<'tcx>> {\n     use crate::types::ExtremeType::{Maximum, Minimum};\n \n-    let ty = cx.tables.expr_ty(expr);\n+    let ty = cx.tables().expr_ty(expr);\n \n-    let cv = constant(cx, cx.tables, expr)?.0;\n+    let cv = constant(cx, cx.tables(), expr)?.0;\n \n     let which = match (&ty.kind, cv) {\n         (&ty::Bool, Constant::Bool(false)) | (&ty::Uint(_), Constant::Int(0)) => Minimum,\n@@ -2071,8 +2071,8 @@ impl Ord for FullInt {\n \n fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr<'_>) -> Option<(FullInt, FullInt)> {\n     if let ExprKind::Cast(ref cast_exp, _) = expr.kind {\n-        let pre_cast_ty = cx.tables.expr_ty(cast_exp);\n-        let cast_ty = cx.tables.expr_ty(expr);\n+        let pre_cast_ty = cx.tables().expr_ty(cast_exp);\n+        let cast_ty = cx.tables().expr_ty(expr);\n         // if it's a cast from i32 to u32 wrapping will invalidate all these checks\n         if cx.layout_of(pre_cast_ty).ok().map(|l| l.size) == cx.layout_of(cast_ty).ok().map(|l| l.size) {\n             return None;\n@@ -2102,9 +2102,9 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr<'_>)\n }\n \n fn node_as_const_fullint<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) -> Option<FullInt> {\n-    let val = constant(cx, cx.tables, expr)?.0;\n+    let val = constant(cx, cx.tables(), expr)?.0;\n     if let Constant::Int(const_int) = val {\n-        match cx.tables.expr_ty(expr).kind {\n+        match cx.tables().expr_ty(expr).kind {\n             ty::Int(ity) => Some(FullInt::S(sext(cx.tcx, const_int, ity))),\n             ty::Uint(_) => Some(FullInt::U(const_int)),\n             _ => None,\n@@ -2499,7 +2499,7 @@ impl<'a, 'b, 'tcx> ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n     fn new(cx: &'a LateContext<'a, 'tcx>, target: &'b ImplicitHasherType<'tcx>) -> Self {\n         Self {\n             cx,\n-            body: cx.tables,\n+            body: cx.tables(),\n             target,\n             suggestions: BTreeMap::new(),\n         }\n@@ -2608,7 +2608,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RefToMut {\n             if let TyKind::Ptr(MutTy { mutbl: Mutability::Mut, .. }) = t.kind;\n             if let ExprKind::Cast(e, t) = &e.kind;\n             if let TyKind::Ptr(MutTy { mutbl: Mutability::Not, .. }) = t.kind;\n-            if let ty::Ref(..) = cx.tables.node_type(e.hir_id).kind;\n+            if let ty::Ref(..) = cx.tables().node_type(e.hir_id).kind;\n             then {\n                 span_lint(\n                     cx,"}, {"sha": "53e47f09ae55ce256890e20d57228f1558772065", "filename": "clippy_lints/src/unnamed_address.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Funnamed_address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Funnamed_address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnamed_address.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -65,14 +65,14 @@ impl LateLintPass<'_, '_> for UnnamedAddress {\n         }\n \n         fn is_trait_ptr(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n-            match cx.tables.expr_ty_adjusted(expr).kind {\n+            match cx.tables().expr_ty_adjusted(expr).kind {\n                 ty::RawPtr(ty::TypeAndMut { ty, .. }) => ty.is_trait(),\n                 _ => false,\n             }\n         }\n \n         fn is_fn_def(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n-            if let ty::FnDef(..) = cx.tables.expr_ty(expr).kind {\n+            if let ty::FnDef(..) = cx.tables().expr_ty(expr).kind {\n                 true\n             } else {\n                 false\n@@ -98,11 +98,11 @@ impl LateLintPass<'_, '_> for UnnamedAddress {\n         if_chain! {\n             if let ExprKind::Call(ref func, [ref _left, ref _right]) = expr.kind;\n             if let ExprKind::Path(ref func_qpath) = func.kind;\n-            if let Some(def_id) = cx.tables.qpath_res(func_qpath, func.hir_id).opt_def_id();\n+            if let Some(def_id) = cx.tables().qpath_res(func_qpath, func.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::PTR_EQ) ||\n                 match_def_path(cx, def_id, &paths::RC_PTR_EQ) ||\n                 match_def_path(cx, def_id, &paths::ARC_PTR_EQ);\n-            let ty_param = cx.tables.node_substs(func.hir_id).type_at(0);\n+            let ty_param = cx.tables().node_substs(func.hir_id).type_at(0);\n             if ty_param.is_trait();\n             then {\n                 span_lint_and_help(\n@@ -119,8 +119,8 @@ impl LateLintPass<'_, '_> for UnnamedAddress {\n         if_chain! {\n             if let ExprKind::Binary(binop, ref left, ref right) = expr.kind;\n             if is_comparison(binop.node);\n-            if cx.tables.expr_ty_adjusted(left).is_fn_ptr() &&\n-                cx.tables.expr_ty_adjusted(right).is_fn_ptr();\n+            if cx.tables().expr_ty_adjusted(left).is_fn_ptr() &&\n+                cx.tables().expr_ty_adjusted(right).is_fn_ptr();\n             if is_fn_def(cx, left) || is_fn_def(cx, right);\n             then {\n                 span_lint("}, {"sha": "bb68e50b331953b0f71b847feeb3916ccc66e4d3", "filename": "clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -177,7 +177,7 @@ fn detect_lint(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Option<LintTrigger>\n         if let name = name_ident.ident.name.to_ident_string();\n         if name == \"sort_by\" || name == \"sort_unstable_by\";\n         if let [vec, Expr { kind: ExprKind::Closure(_, _, closure_body_id, _, _), .. }] = args;\n-        if utils::match_type(cx, &cx.tables.expr_ty(vec), &paths::VEC);\n+        if utils::match_type(cx, &cx.tables().expr_ty(vec), &paths::VEC);\n         if let closure_body = cx.tcx.hir().body(*closure_body_id);\n         if let &[\n             Param { pat: Pat { kind: PatKind::Binding(_, _, left_ident, _), .. }, ..},"}, {"sha": "be55982f90556749412dd237feb916098c163ff6", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -114,7 +114,7 @@ fn collect_unwrap_info<'a, 'tcx>(\n         if_chain! {\n             if let ExprKind::MethodCall(method_name, _, args, _) = &expr.kind;\n             if let ExprKind::Path(QPath::Resolved(None, path)) = &args[0].kind;\n-            let ty = cx.tables.expr_ty(&args[0]);\n+            let ty = cx.tables().expr_ty(&args[0]);\n             let name = method_name.ident.as_str();\n             if is_relevant_option_call(cx, ty, &name) || is_relevant_result_call(cx, ty, &name);\n             then {"}, {"sha": "5d150ad4f03e45114cec6b596f3af082a2449136", "filename": "clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -63,8 +63,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessConversion {\n \n             ExprKind::MethodCall(ref name, .., ref args, _) => {\n                 if match_trait_method(cx, e, &paths::INTO) && &*name.ident.as_str() == \"into\" {\n-                    let a = cx.tables.expr_ty(e);\n-                    let b = cx.tables.expr_ty(&args[0]);\n+                    let a = cx.tables().expr_ty(e);\n+                    let b = cx.tables().expr_ty(&args[0]);\n                     if TyS::same_type(a, b) {\n                         let sugg = snippet_with_macro_callsite(cx, args[0].span, \"<expr>\").to_string();\n                         span_lint_and_sugg(\n@@ -79,8 +79,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessConversion {\n                     }\n                 }\n                 if match_trait_method(cx, e, &paths::INTO_ITERATOR) && &*name.ident.as_str() == \"into_iter\" {\n-                    let a = cx.tables.expr_ty(e);\n-                    let b = cx.tables.expr_ty(&args[0]);\n+                    let a = cx.tables().expr_ty(e);\n+                    let b = cx.tables().expr_ty(&args[0]);\n                     if TyS::same_type(a, b) {\n                         let sugg = snippet(cx, args[0].span, \"<expr>\").into_owned();\n                         span_lint_and_sugg(\n@@ -96,8 +96,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessConversion {\n                 }\n                 if match_trait_method(cx, e, &paths::TRY_INTO_TRAIT) && &*name.ident.as_str() == \"try_into\" {\n                     if_chain! {\n-                        let a = cx.tables.expr_ty(e);\n-                        let b = cx.tables.expr_ty(&args[0]);\n+                        let a = cx.tables().expr_ty(e);\n+                        let b = cx.tables().expr_ty(&args[0]);\n                         if is_type_diagnostic_item(cx, a, sym!(result_type));\n                         if let ty::Adt(_, substs) = a.kind;\n                         if let Some(a_type) = substs.types().next();\n@@ -121,9 +121,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessConversion {\n                 if_chain! {\n                     if args.len() == 1;\n                     if let ExprKind::Path(ref qpath) = path.kind;\n-                    if let Some(def_id) = cx.tables.qpath_res(qpath, path.hir_id).opt_def_id();\n-                    let a = cx.tables.expr_ty(e);\n-                    let b = cx.tables.expr_ty(&args[0]);\n+                    if let Some(def_id) = cx.tables().qpath_res(qpath, path.hir_id).opt_def_id();\n+                    let a = cx.tables().expr_ty(e);\n+                    let b = cx.tables().expr_ty(&args[0]);\n \n                     then {\n                         if_chain! {"}, {"sha": "0e78f35a1290ad3f769dd2c5121c1c6e4b8a8940", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -56,7 +56,7 @@ pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr<'_>)\n         Some(expr)\n     }\n \n-    let def_path = match cx.tables.expr_ty(expr).kind {\n+    let def_path = match cx.tables().expr_ty(expr).kind {\n         ty::Adt(def, _) => cx.tcx.def_path(def.did),\n         _ => return None,\n     };\n@@ -262,7 +262,7 @@ pub fn vec_macro<'e>(cx: &LateContext<'_, '_>, expr: &'e hir::Expr<'_>) -> Optio\n         if let hir::ExprKind::Call(ref fun, ref args) = expr.kind;\n         if let hir::ExprKind::Path(ref qpath) = fun.kind;\n         if is_expn_of(fun.span, \"vec\").is_some();\n-        if let Some(fun_def_id) = cx.tables.qpath_res(qpath, fun.hir_id).opt_def_id();\n+        if let Some(fun_def_id) = cx.tables().qpath_res(qpath, fun.hir_id).opt_def_id();\n         then {\n             return if match_def_path(cx, fun_def_id, &paths::VEC_FROM_ELEM) && args.len() == 2 {\n                 // `vec![elem; size]` case"}, {"sha": "a74ab18a063b267343cd87af5ba667a956f6ce9e", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -32,15 +32,15 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     pub fn new(cx: &'a LateContext<'a, 'tcx>) -> Self {\n         Self {\n             cx,\n-            tables: cx.tables,\n+            tables: cx.tables(),\n             ignore_fn: false,\n         }\n     }\n \n     pub fn ignore_fn(self) -> Self {\n         Self {\n             cx: self.cx,\n-            tables: self.cx.tables,\n+            tables: self.cx.tables(),\n             ignore_fn: true,\n         }\n     }"}, {"sha": "3f5659c3d8c0fd13e65d57204ec25fc425d59e7f", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DeepCodeInspector {\n         }\n         match stmt.kind {\n             hir::StmtKind::Local(ref local) => {\n-                println!(\"local variable of type {}\", cx.tables.node_type(local.hir_id));\n+                println!(\"local variable of type {}\", cx.tables().node_type(local.hir_id));\n                 println!(\"pattern:\");\n                 print_pat(cx, &local.pat, 0);\n                 if let Some(ref e) = local.init {\n@@ -144,8 +144,8 @@ fn has_attr(sess: &Session, attrs: &[Attribute]) -> bool {\n fn print_expr(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, indent: usize) {\n     let ind = \"  \".repeat(indent);\n     println!(\"{}+\", ind);\n-    println!(\"{}ty: {}\", ind, cx.tables.expr_ty(expr));\n-    println!(\"{}adjustments: {:?}\", ind, cx.tables.adjustments().get(expr.hir_id));\n+    println!(\"{}ty: {}\", ind, cx.tables().expr_ty(expr));\n+    println!(\"{}adjustments: {:?}\", ind, cx.tables().adjustments().get(expr.hir_id));\n     match expr.kind {\n         hir::ExprKind::Box(ref e) => {\n             println!(\"{}Box\", ind);"}, {"sha": "38468181d0261e00f64776d3f27e8539b18d28c7", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -347,7 +347,7 @@ fn is_lint_ref_type<'tcx>(cx: &LateContext<'_, 'tcx>, ty: &Ty<'_>) -> bool {\n     ) = ty.kind\n     {\n         if let TyKind::Path(ref path) = inner.kind {\n-            if let Res::Def(DefKind::Struct, def_id) = cx.tables.qpath_res(path, inner.hir_id) {\n+            if let Res::Def(DefKind::Struct, def_id) = cx.tables().qpath_res(path, inner.hir_id) {\n                 return match_def_path(cx, def_id, &paths::LINT);\n             }\n         }\n@@ -405,7 +405,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CompilerLintFunctions {\n             if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n             let fn_name = path.ident;\n             if let Some(sugg) = self.map.get(&*fn_name.as_str());\n-            let ty = walk_ptrs_ty(cx.tables.expr_ty(&args[0]));\n+            let ty = walk_ptrs_ty(cx.tables().expr_ty(&args[0]));\n             if match_type(cx, ty, &paths::EARLY_CONTEXT)\n                 || match_type(cx, ty, &paths::LATE_CONTEXT);\n             then {\n@@ -438,7 +438,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OuterExpnDataPass {\n             let args = arg_lists[1];\n             if args.len() == 1;\n             let self_arg = &args[0];\n-            let self_ty = walk_ptrs_ty(cx.tables.expr_ty(self_arg));\n+            let self_ty = walk_ptrs_ty(cx.tables().expr_ty(self_arg));\n             if match_type(cx, self_ty, &paths::SYNTAX_CONTEXT);\n             then {\n                 span_lint_and_sugg("}, {"sha": "69ec4b7ad6d18253d66c50406973c3b99846ee78", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -151,7 +151,7 @@ pub fn is_type_diagnostic_item(cx: &LateContext<'_, '_>, ty: Ty<'_>, diag_item:\n \n /// Checks if the method call given in `expr` belongs to the given trait.\n pub fn match_trait_method(cx: &LateContext<'_, '_>, expr: &Expr<'_>, path: &[&str]) -> bool {\n-    let def_id = cx.tables.type_dependent_def_id(expr.hir_id).unwrap();\n+    let def_id = cx.tables().type_dependent_def_id(expr.hir_id).unwrap();\n     let trt_id = cx.tcx.trait_of_item(def_id);\n     if let Some(trt_id) = trt_id {\n         match_def_path(cx, trt_id, path)\n@@ -824,7 +824,7 @@ pub fn is_integer_literal(expr: &Expr<'_>, value: u128) -> bool {\n /// See `rustc_middle::ty::adjustment::Adjustment` and `rustc_typeck::check::coercion` for more\n /// information on adjustments and coercions.\n pub fn is_adjusted(cx: &LateContext<'_, '_>, e: &Expr<'_>) -> bool {\n-    cx.tables.adjustments().get(e.hir_id).is_some()\n+    cx.tables().adjustments().get(e.hir_id).is_some()\n }\n \n /// Returns the pre-expansion span if is this comes from an expansion of the\n@@ -898,7 +898,7 @@ pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n pub fn is_ctor_or_promotable_const_function(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n     if let ExprKind::Call(ref fun, _) = expr.kind {\n         if let ExprKind::Path(ref qp) = fun.kind {\n-            let res = cx.tables.qpath_res(qp, fun.hir_id);\n+            let res = cx.tables().qpath_res(qp, fun.hir_id);\n             return match res {\n                 def::Res::Def(DefKind::Variant | DefKind::Ctor(..), ..) => true,\n                 def::Res::Def(_, def_id) => cx.tcx.is_promotable_const_fn(def_id),\n@@ -914,7 +914,7 @@ pub fn is_ctor_or_promotable_const_function(cx: &LateContext<'_, '_>, expr: &Exp\n pub fn is_refutable(cx: &LateContext<'_, '_>, pat: &Pat<'_>) -> bool {\n     fn is_enum_variant(cx: &LateContext<'_, '_>, qpath: &QPath<'_>, id: HirId) -> bool {\n         matches!(\n-            cx.tables.qpath_res(qpath, id),\n+            cx.tables().qpath_res(qpath, id),\n             def::Res::Def(DefKind::Variant, ..) | Res::Def(DefKind::Ctor(def::CtorOf::Variant, _), _)\n         )\n     }\n@@ -941,7 +941,7 @@ pub fn is_refutable(cx: &LateContext<'_, '_>, pat: &Pat<'_>) -> bool {\n             is_enum_variant(cx, qpath, pat.hir_id) || are_refutable(cx, pats.iter().map(|pat| &**pat))\n         },\n         PatKind::Slice(ref head, ref middle, ref tail) => {\n-            match &cx.tables.node_type(pat.hir_id).kind {\n+            match &cx.tables().node_type(pat.hir_id).kind {\n                 ty::Slice(..) => {\n                     // [..] is the only irrefutable slice pattern.\n                     !head.is_empty() || middle.is_none() || !tail.is_empty()\n@@ -1190,7 +1190,7 @@ pub fn match_function_call<'a, 'tcx>(\n     if_chain! {\n         if let ExprKind::Call(ref fun, ref args) = expr.kind;\n         if let ExprKind::Path(ref qpath) = fun.kind;\n-        if let Some(fun_def_id) = cx.tables.qpath_res(qpath, fun.hir_id).opt_def_id();\n+        if let Some(fun_def_id) = cx.tables().qpath_res(qpath, fun.hir_id).opt_def_id();\n         if match_def_path(cx, fun_def_id, path);\n         then {\n             return Some(&args)\n@@ -1317,14 +1317,14 @@ pub fn is_must_use_func_call(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool\n     let did = match expr.kind {\n         ExprKind::Call(ref path, _) => if_chain! {\n             if let ExprKind::Path(ref qpath) = path.kind;\n-            if let def::Res::Def(_, did) = cx.tables.qpath_res(qpath, path.hir_id);\n+            if let def::Res::Def(_, did) = cx.tables().qpath_res(qpath, path.hir_id);\n             then {\n                 Some(did)\n             } else {\n                 None\n             }\n         },\n-        ExprKind::MethodCall(_, _, _, _) => cx.tables.type_dependent_def_id(expr.hir_id),\n+        ExprKind::MethodCall(_, _, _, _) => cx.tables().type_dependent_def_id(expr.hir_id),\n         _ => None,\n     };\n "}, {"sha": "d280fe4ab4e02ca1ffce8ab23f7f0c6ca9c95711", "filename": "clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -18,7 +18,7 @@ pub fn mutated_variables<'a, 'tcx>(expr: &'tcx Expr<'_>, cx: &'a LateContext<'a,\n     };\n     let def_id = expr.hir_id.owner.to_def_id();\n     cx.tcx.infer_ctxt().enter(|infcx| {\n-        ExprUseVisitor::new(&mut delegate, &infcx, def_id.expect_local(), cx.param_env, cx.tables).walk_expr(expr);\n+        ExprUseVisitor::new(&mut delegate, &infcx, def_id.expect_local(), cx.param_env, cx.tables()).walk_expr(expr);\n     });\n \n     if delegate.skip {"}, {"sha": "080785b177d650df47a1e549a2d0e51b0a410229", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -37,7 +37,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessVec {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         // search for `&vec![_]` expressions where the adjusted type is `&[_]`\n         if_chain! {\n-            if let ty::Ref(_, ty, _) = cx.tables.expr_ty_adjusted(expr).kind;\n+            if let ty::Ref(_, ty, _) = cx.tables().expr_ty_adjusted(expr).kind;\n             if let ty::Slice(..) = ty.kind;\n             if let ExprKind::AddrOf(BorrowKind::Ref, _, ref addressee) = expr.kind;\n             if let Some(vec_args) = higher::vec_macro(cx, addressee);\n@@ -50,7 +50,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessVec {\n         if_chain! {\n             if let Some((_, arg, _)) = higher::for_loop(expr);\n             if let Some(vec_args) = higher::vec_macro(cx, arg);\n-            if is_copy(cx, vec_type(cx.tables.expr_ty_adjusted(arg)));\n+            if is_copy(cx, vec_type(cx.tables().expr_ty_adjusted(arg)));\n             then {\n                 // report the error around the `vec!` not inside `<std macros>:`\n                 let span = arg.span\n@@ -70,7 +70,7 @@ fn check_vec_macro<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, vec_args: &higher::VecA\n     let mut applicability = Applicability::MachineApplicable;\n     let snippet = match *vec_args {\n         higher::VecArgs::Repeat(elem, len) => {\n-            if constant(cx, cx.tables, len).is_some() {\n+            if constant(cx, cx.tables(), len).is_some() {\n                 format!(\n                     \"&[{}; {}]\",\n                     snippet_with_applicability(cx, elem.span, \"elem\", &mut applicability),"}, {"sha": "bb315e64e5de13237ff1c12d54562630ec3e5ce6", "filename": "clippy_lints/src/vec_resize_to_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec_resize_to_zero.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -32,7 +32,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VecResizeToZero {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let hir::ExprKind::MethodCall(path_segment, _, ref args, _) = expr.kind;\n-            if let Some(method_def_id) = cx.tables.type_dependent_def_id(expr.hir_id);\n+            if let Some(method_def_id) = cx.tables().type_dependent_def_id(expr.hir_id);\n             if match_def_path(cx, method_def_id, &paths::VEC_RESIZE) && args.len() == 3;\n             if let ExprKind::Lit(Spanned { node: LitKind::Int(0, _), .. }) = args[1].kind;\n             if let ExprKind::Lit(Spanned { node: LitKind::Int(..), .. }) = args[2].kind;"}, {"sha": "85f92084574485b12103985aec6266986b8b33b9", "filename": "clippy_lints/src/verbose_file_reads.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fverbose_file_reads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fverbose_file_reads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fverbose_file_reads.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -62,7 +62,7 @@ fn is_file_read_to_end<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'t\n         if let ExprKind::MethodCall(method_name, _, exprs, _) = expr.kind;\n         if method_name.ident.as_str() == \"read_to_end\";\n         if let ExprKind::Path(QPath::Resolved(None, _)) = &exprs[0].kind;\n-        let ty = cx.tables.expr_ty(&exprs[0]);\n+        let ty = cx.tables().expr_ty(&exprs[0]);\n         if match_type(cx, ty, &paths::FILE);\n         then {\n             return true\n@@ -76,7 +76,7 @@ fn is_file_read_to_string<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr\n         if let ExprKind::MethodCall(method_name, _, exprs, _) = expr.kind;\n         if method_name.ident.as_str() == \"read_to_string\";\n         if let ExprKind::Path(QPath::Resolved(None, _)) = &exprs[0].kind;\n-        let ty = cx.tables.expr_ty(&exprs[0]);\n+        let ty = cx.tables().expr_ty(&exprs[0]);\n         if match_type(cx, ty, &paths::FILE);\n         then {\n             return true"}, {"sha": "f0cf17c3b95495e75b243ec5aebd0e546abf08f7", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -36,8 +36,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ZeroDiv {\n             // TODO - constant_simple does not fold many operations involving floats.\n             // That's probably fine for this lint - it's pretty unlikely that someone would\n             // do something like 0.0/(2.0 - 2.0), but it would be nice to warn on that case too.\n-            if let Some(lhs_value) = constant_simple(cx, cx.tables, left);\n-            if let Some(rhs_value) = constant_simple(cx, cx.tables, right);\n+            if let Some(lhs_value) = constant_simple(cx, cx.tables(), left);\n+            if let Some(rhs_value) = constant_simple(cx, cx.tables(), right);\n             if Constant::F32(0.0) == lhs_value || Constant::F64(0.0) == lhs_value;\n             if Constant::F32(0.0) == rhs_value || Constant::F64(0.0) == rhs_value;\n             then {"}, {"sha": "d06e359bc7aa557bf4ed736a26d73348921e4428", "filename": "doc/common_tools_writing_lints.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f5ce0e5fe960d09db01cf912c475cd1a52131120/doc%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/f5ce0e5fe960d09db01cf912c475cd1a52131120/doc%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fcommon_tools_writing_lints.md?ref=f5ce0e5fe960d09db01cf912c475cd1a52131120", "patch": "@@ -19,19 +19,19 @@ Useful Rustc dev guide links:\n Sometimes you may want to retrieve the type `Ty` of an expression `Expr`, for example to answer following questions:\n \n - which type does this expression correspond to (using its [`TyKind`][TyKind])?\n-- is it a sized type? \n+- is it a sized type?\n - is it a primitive type?\n - does it implement a trait?\n \n-This operation is performed using the [`expr_ty()`][expr_ty] method from the [`TypeckTables`][TypeckTables] struct, \n+This operation is performed using the [`expr_ty()`][expr_ty] method from the [`TypeckTables`][TypeckTables] struct,\n that gives you access to the underlying structure [`TyS`][TyS].\n \n Example of use:\n ```rust\n impl LateLintPass<'_, '_> for MyStructLint {\n     fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n         // Get type of `expr`\n-        let ty = cx.tables.expr_ty(expr);\n+        let ty = cx.tables().expr_ty(expr);\n         // Match its kind to enter its type\n         match ty.kind {\n             ty::Adt(adt_def, _) if adt_def.is_struct() => println!(\"Our `expr` is a struct!\"),\n@@ -41,14 +41,14 @@ impl LateLintPass<'_, '_> for MyStructLint {\n }\n ```\n \n-Similarly in [`TypeckTables`][TypeckTables] methods, you have the [`pat_ty()`][pat_ty] method \n+Similarly in [`TypeckTables`][TypeckTables] methods, you have the [`pat_ty()`][pat_ty] method\n to retrieve a type from a pattern.\n \n Two noticeable items here:\n-- `cx` is the lint context [`LateContext`][LateContext]. \n-  The two most useful data structures in this context are `tcx` and `tables`, \n+- `cx` is the lint context [`LateContext`][LateContext].\n+  The two most useful data structures in this context are `tcx` and `tables`,\n   allowing us to jump to type definitions and other compilation stages such as HIR.\n-- `tables` is [`TypeckTables`][TypeckTables] and is created by type checking step, \n+- `tables` is [`TypeckTables`][TypeckTables] and is created by type checking step,\n   it includes useful information such as types of expressions, ways to resolve methods and so on.\n \n # Checking if an expr is calling a specific method\n@@ -87,7 +87,7 @@ impl LateLintPass<'_, '_> for MyStructLint {\n         }\n \n         // 2. Using type context `TyCtxt`\n-        let ty = cx.tables.expr_ty(expr);\n+        let ty = cx.tables().expr_ty(expr);\n         if cx.tcx.lang_items()\n             // we are looking for the `DefId` of `Drop` trait in lang items\n             .drop_trait()"}]}