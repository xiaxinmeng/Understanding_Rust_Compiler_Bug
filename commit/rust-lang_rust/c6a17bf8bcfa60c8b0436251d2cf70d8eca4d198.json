{"sha": "c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198", "node_id": "C_kwDOAAsO6NoAKGM2YTE3YmY4YmNmYTYwYzhiMDQzNjI1MWQyY2Y3MGQ4ZWNhNGQxOTg", "commit": {"author": {"name": "Ali MJ Al-Nasrawy", "email": "alimjalnasrawy@gmail.com", "date": "2022-11-16T10:11:44Z"}, "committer": {"name": "Ali MJ Al-Nasrawy", "email": "alimjalnasrawy@gmail.com", "date": "2023-01-07T10:41:41Z"}, "message": "make ascribe_user_type a TypeOp\n\nProjection types in user annotations may contain inference variables.\nThis makes the normalization depend on the unification with the actual\ntype and thus requires a separate TypeOp to track the obligations.\nOtherwise simply calling `TypeChecker::normalize` would ICE with\n\"unexpected ambiguity\"", "tree": {"sha": "e52979baba2e361406595ae5ade5e2cd52600bc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e52979baba2e361406595ae5ade5e2cd52600bc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198", "html_url": "https://github.com/rust-lang/rust/commit/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/comments", "author": {"login": "aliemjay", "id": 28497461, "node_id": "MDQ6VXNlcjI4NDk3NDYx", "avatar_url": "https://avatars.githubusercontent.com/u/28497461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aliemjay", "html_url": "https://github.com/aliemjay", "followers_url": "https://api.github.com/users/aliemjay/followers", "following_url": "https://api.github.com/users/aliemjay/following{/other_user}", "gists_url": "https://api.github.com/users/aliemjay/gists{/gist_id}", "starred_url": "https://api.github.com/users/aliemjay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aliemjay/subscriptions", "organizations_url": "https://api.github.com/users/aliemjay/orgs", "repos_url": "https://api.github.com/users/aliemjay/repos", "events_url": "https://api.github.com/users/aliemjay/events{/privacy}", "received_events_url": "https://api.github.com/users/aliemjay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aliemjay", "id": 28497461, "node_id": "MDQ6VXNlcjI4NDk3NDYx", "avatar_url": "https://avatars.githubusercontent.com/u/28497461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aliemjay", "html_url": "https://github.com/aliemjay", "followers_url": "https://api.github.com/users/aliemjay/followers", "following_url": "https://api.github.com/users/aliemjay/following{/other_user}", "gists_url": "https://api.github.com/users/aliemjay/gists{/gist_id}", "starred_url": "https://api.github.com/users/aliemjay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aliemjay/subscriptions", "organizations_url": "https://api.github.com/users/aliemjay/orgs", "repos_url": "https://api.github.com/users/aliemjay/repos", "events_url": "https://api.github.com/users/aliemjay/events{/privacy}", "received_events_url": "https://api.github.com/users/aliemjay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37b40e471a62425cb34781bad763b5cb5047f13c", "url": "https://api.github.com/repos/rust-lang/rust/commits/37b40e471a62425cb34781bad763b5cb5047f13c", "html_url": "https://github.com/rust-lang/rust/commit/37b40e471a62425cb34781bad763b5cb5047f13c"}], "stats": {"total": 536, "additions": 350, "deletions": 186}, "files": [{"sha": "02222c0a03cb350f9dcfdebc2b963db3f1edfcd5", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 74, "deletions": 4, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198", "patch": "@@ -1,13 +1,13 @@\n use std::fmt;\n \n-use rustc_infer::infer::canonical::Canonical;\n-use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::infer::{canonical::Canonical, InferOk};\n use rustc_middle::mir::ConstraintCategory;\n-use rustc_middle::ty::{self, ToPredicate, TypeFoldable};\n+use rustc_middle::ty::{self, ToPredicate, Ty, TypeFoldable};\n use rustc_span::def_id::DefId;\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::type_op::{self, TypeOpOutput};\n-use rustc_trait_selection::traits::query::Fallible;\n+use rustc_trait_selection::traits::query::{Fallible, NoSolution};\n+use rustc_trait_selection::traits::{ObligationCause, ObligationCtxt};\n \n use crate::diagnostics::{ToUniverseInfo, UniverseInfo};\n \n@@ -177,4 +177,74 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             value\n         })\n     }\n+\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub(super) fn ascribe_user_type(\n+        &mut self,\n+        mir_ty: Ty<'tcx>,\n+        user_ty: ty::UserType<'tcx>,\n+        span: Span,\n+    ) {\n+        // FIXME: Ideally MIR types are normalized, but this is not always true.\n+        let mir_ty = self.normalize(mir_ty, Locations::All(span));\n+\n+        self.fully_perform_op(\n+            Locations::All(span),\n+            ConstraintCategory::Boring,\n+            self.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(mir_ty, user_ty)),\n+        )\n+        .unwrap_or_else(|err| {\n+            span_mirbug!(\n+                self,\n+                span,\n+                \"ascribe_user_type `{mir_ty:?}=={user_ty:?}` failed with `{err:?}`\",\n+            );\n+        });\n+    }\n+\n+    /// *Incorrectly* skips the WF checks we normally do in `ascribe_user_type`.\n+    ///\n+    /// FIXME(#104478, #104477): This is a hack for backward-compatibility.\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub(super) fn ascribe_user_type_skip_wf(\n+        &mut self,\n+        mir_ty: Ty<'tcx>,\n+        user_ty: ty::UserType<'tcx>,\n+        span: Span,\n+    ) {\n+        let ty::UserType::Ty(user_ty) = user_ty else { bug!() };\n+\n+        // A fast path for a common case with closure input/output types.\n+        if let ty::Infer(_) = user_ty.kind() {\n+            self.eq_types(user_ty, mir_ty, Locations::All(span), ConstraintCategory::Boring)\n+                .unwrap();\n+            return;\n+        }\n+\n+        let mir_ty = self.normalize(mir_ty, Locations::All(span));\n+        let cause = ObligationCause::dummy_with_span(span);\n+        let param_env = self.param_env;\n+        let op = |infcx: &'_ _| {\n+            let ocx = ObligationCtxt::new_in_snapshot(infcx);\n+            let user_ty = ocx.normalize(&cause, param_env, user_ty);\n+            ocx.eq(&cause, param_env, user_ty, mir_ty)?;\n+            if !ocx.select_all_or_error().is_empty() {\n+                return Err(NoSolution);\n+            }\n+            Ok(InferOk { value: (), obligations: vec![] })\n+        };\n+\n+        self.fully_perform_op(\n+            Locations::All(span),\n+            ConstraintCategory::Boring,\n+            type_op::custom::CustomTypeOp::new(op, || \"ascribe_user_type_skip_wf\".to_string()),\n+        )\n+        .unwrap_or_else(|err| {\n+            span_mirbug!(\n+                self,\n+                span,\n+                \"ascribe_user_type_skip_wf `{mir_ty:?}=={user_ty:?}` failed with `{err:?}`\",\n+            );\n+        });\n+    }\n }"}, {"sha": "fa9ea769a14f79607e86c7d69dafbec2216b5c1a", "filename": "compiler/rustc_borrowck/src/type_check/input_output.rs", "status": "modified", "additions": 47, "deletions": 79, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs?ref=c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198", "patch": "@@ -10,14 +10,60 @@\n use rustc_index::vec::Idx;\n use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::Ty;\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n \n use crate::universal_regions::UniversalRegions;\n \n use super::{Locations, TypeChecker};\n \n impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n+    /// Check explicit closure signature annotation,\n+    /// e.g., `|x: FxHashMap<_, &'static u32>| ...`.\n+    #[instrument(skip(self, body), level = \"debug\")]\n+    pub(super) fn check_signature_annotation(&mut self, body: &Body<'tcx>) {\n+        let mir_def_id = body.source.def_id().expect_local();\n+        if !self.tcx().is_closure(mir_def_id.to_def_id()) {\n+            return;\n+        }\n+        let Some(user_provided_poly_sig) =\n+            self.tcx().typeck(mir_def_id).user_provided_sigs.get(&mir_def_id)\n+        else {\n+            return;\n+        };\n+\n+        // Instantiate the canonicalized variables from user-provided signature\n+        // (e.g., the `_` in the code above) with fresh variables.\n+        // Then replace the bound items in the fn sig with fresh variables,\n+        // so that they represent the view from \"inside\" the closure.\n+        let user_provided_sig = self\n+            .instantiate_canonical_with_fresh_inference_vars(body.span, &user_provided_poly_sig);\n+        let user_provided_sig = self.infcx.replace_bound_vars_with_fresh_vars(\n+            body.span,\n+            LateBoundRegionConversionTime::FnCall,\n+            user_provided_sig,\n+        );\n+\n+        for (&user_ty, arg_decl) in user_provided_sig.inputs().iter().zip(\n+            // In MIR, closure args begin with an implicit `self`. Skip it!\n+            body.args_iter().skip(1).map(|local| &body.local_decls[local]),\n+        ) {\n+            self.ascribe_user_type_skip_wf(\n+                arg_decl.ty,\n+                ty::UserType::Ty(user_ty),\n+                arg_decl.source_info.span,\n+            );\n+        }\n+\n+        // If the user explicitly annotated the output type, enforce it.\n+        let output_decl = &body.local_decls[RETURN_PLACE];\n+        self.ascribe_user_type_skip_wf(\n+            output_decl.ty,\n+            ty::UserType::Ty(user_provided_sig.output()),\n+            output_decl.source_info.span,\n+        );\n+    }\n+\n     #[instrument(skip(self, body, universal_regions), level = \"debug\")]\n     pub(super) fn equate_inputs_and_outputs(\n         &mut self,\n@@ -31,39 +77,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         debug!(?normalized_output_ty);\n         debug!(?normalized_input_tys);\n \n-        let mir_def_id = body.source.def_id().expect_local();\n-\n-        // If the user explicitly annotated the input types, extract\n-        // those.\n-        //\n-        // e.g., `|x: FxHashMap<_, &'static u32>| ...`\n-        let user_provided_sig = if !self.tcx().is_closure(mir_def_id.to_def_id()) {\n-            None\n-        } else {\n-            let typeck_results = self.tcx().typeck(mir_def_id);\n-\n-            typeck_results.user_provided_sigs.get(&mir_def_id).map(|user_provided_poly_sig| {\n-                // Instantiate the canonicalized variables from\n-                // user-provided signature (e.g., the `_` in the code\n-                // above) with fresh variables.\n-                let poly_sig = self.instantiate_canonical_with_fresh_inference_vars(\n-                    body.span,\n-                    &user_provided_poly_sig,\n-                );\n-\n-                // Replace the bound items in the fn sig with fresh\n-                // variables, so that they represent the view from\n-                // \"inside\" the closure.\n-                self.infcx.replace_bound_vars_with_fresh_vars(\n-                    body.span,\n-                    LateBoundRegionConversionTime::FnCall,\n-                    poly_sig,\n-                )\n-            })\n-        };\n-\n-        debug!(?normalized_input_tys, ?body.local_decls);\n-\n         // Equate expected input tys with those in the MIR.\n         for (argument_index, &normalized_input_ty) in normalized_input_tys.iter().enumerate() {\n             if argument_index + 1 >= body.local_decls.len() {\n@@ -86,28 +99,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             );\n         }\n \n-        if let Some(user_provided_sig) = user_provided_sig {\n-            for (argument_index, &user_provided_input_ty) in\n-                user_provided_sig.inputs().iter().enumerate()\n-            {\n-                // In MIR, closures begin an implicit `self`, so\n-                // argument N is stored in local N+2.\n-                let local = Local::new(argument_index + 2);\n-                let mir_input_ty = body.local_decls[local].ty;\n-                let mir_input_span = body.local_decls[local].source_info.span;\n-\n-                // If the user explicitly annotated the input types, enforce those.\n-                let user_provided_input_ty =\n-                    self.normalize(user_provided_input_ty, Locations::All(mir_input_span));\n-\n-                self.equate_normalized_input_or_output(\n-                    user_provided_input_ty,\n-                    mir_input_ty,\n-                    mir_input_span,\n-                );\n-            }\n-        }\n-\n         debug!(\n             \"equate_inputs_and_outputs: body.yield_ty {:?}, universal_regions.yield_ty {:?}\",\n             body.yield_ty(),\n@@ -153,29 +144,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 terr\n             );\n         };\n-\n-        // If the user explicitly annotated the output types, enforce those.\n-        // Note that this only happens for closures.\n-        if let Some(user_provided_sig) = user_provided_sig {\n-            let user_provided_output_ty = user_provided_sig.output();\n-            let user_provided_output_ty =\n-                self.normalize(user_provided_output_ty, Locations::All(output_span));\n-            if let Err(err) = self.eq_types(\n-                user_provided_output_ty,\n-                mir_output_ty,\n-                Locations::All(output_span),\n-                ConstraintCategory::BoringNoLocation,\n-            ) {\n-                span_mirbug!(\n-                    self,\n-                    Location::START,\n-                    \"equate_inputs_and_outputs: `{:?}=={:?}` failed with `{:?}`\",\n-                    mir_output_ty,\n-                    user_provided_output_ty,\n-                    err\n-                );\n-            }\n-        }\n     }\n \n     #[instrument(skip(self), level = \"debug\")]"}, {"sha": "8778a19eeda1bf37080e516c9816889ff9e3c74e", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 9, "deletions": 67, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198", "patch": "@@ -38,7 +38,6 @@ use rustc_middle::ty::{\n use rustc_span::def_id::CRATE_DEF_ID;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::VariantIdx;\n-use rustc_trait_selection::traits::query::type_op;\n use rustc_trait_selection::traits::query::type_op::custom::scrape_region_constraints;\n use rustc_trait_selection::traits::query::type_op::custom::CustomTypeOp;\n use rustc_trait_selection::traits::query::type_op::{TypeOp, TypeOpOutput};\n@@ -197,6 +196,8 @@ pub(crate) fn type_check<'mir, 'tcx>(\n     }\n \n     checker.equate_inputs_and_outputs(&body, universal_regions, &normalized_inputs_and_output);\n+    checker.check_signature_annotation(&body);\n+\n     liveness::generate(\n         &mut checker,\n         body,\n@@ -391,23 +392,14 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                         check_err(self, promoted_body, ty, promoted_ty);\n                     }\n                 } else {\n-                    if let Err(terr) = self.cx.fully_perform_op(\n-                        locations,\n-                        ConstraintCategory::Boring,\n-                        self.cx.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(\n-                            constant.literal.ty(),\n+                    self.cx.ascribe_user_type(\n+                        constant.literal.ty(),\n+                        UserType::TypeOf(\n                             uv.def.did,\n                             UserSubsts { substs: uv.substs, user_self_ty: None },\n-                        )),\n-                    ) {\n-                        span_mirbug!(\n-                            self,\n-                            constant,\n-                            \"bad constant type {:?} ({:?})\",\n-                            constant,\n-                            terr\n-                        );\n-                    }\n+                        ),\n+                        locations.span(&self.cx.body),\n+                    );\n                 }\n             } else if let Some(static_def_id) = constant.check_static_ptr(tcx) {\n                 let unnormalized_ty = tcx.type_of(static_def_id);\n@@ -1041,58 +1033,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         debug!(?self.user_type_annotations);\n         for user_annotation in self.user_type_annotations {\n             let CanonicalUserTypeAnnotation { span, ref user_ty, inferred_ty } = *user_annotation;\n-            let inferred_ty = self.normalize(inferred_ty, Locations::All(span));\n             let annotation = self.instantiate_canonical_with_fresh_inference_vars(span, user_ty);\n-            debug!(?annotation);\n-            match annotation {\n-                UserType::Ty(mut ty) => {\n-                    ty = self.normalize(ty, Locations::All(span));\n-\n-                    if let Err(terr) = self.eq_types(\n-                        ty,\n-                        inferred_ty,\n-                        Locations::All(span),\n-                        ConstraintCategory::BoringNoLocation,\n-                    ) {\n-                        span_mirbug!(\n-                            self,\n-                            user_annotation,\n-                            \"bad user type ({:?} = {:?}): {:?}\",\n-                            ty,\n-                            inferred_ty,\n-                            terr\n-                        );\n-                    }\n-\n-                    self.prove_predicate(\n-                        ty::Binder::dummy(ty::PredicateKind::WellFormed(inferred_ty.into())),\n-                        Locations::All(span),\n-                        ConstraintCategory::TypeAnnotation,\n-                    );\n-                }\n-                UserType::TypeOf(def_id, user_substs) => {\n-                    if let Err(terr) = self.fully_perform_op(\n-                        Locations::All(span),\n-                        ConstraintCategory::BoringNoLocation,\n-                        self.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(\n-                            inferred_ty,\n-                            def_id,\n-                            user_substs,\n-                        )),\n-                    ) {\n-                        span_mirbug!(\n-                            self,\n-                            user_annotation,\n-                            \"bad user type AscribeUserType({:?}, {:?} {:?}, type_of={:?}): {:?}\",\n-                            inferred_ty,\n-                            def_id,\n-                            user_substs,\n-                            self.tcx().type_of(def_id),\n-                            terr,\n-                        );\n-                    }\n-                }\n-            }\n+            self.ascribe_user_type(inferred_ty, annotation, span);\n         }\n     }\n "}, {"sha": "543f5b87e00bccd3a0c887f9c06f31ce3149f923", "filename": "compiler/rustc_middle/src/traits/query.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs?ref=c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198", "patch": "@@ -15,22 +15,19 @@ use rustc_span::source_map::Span;\n \n pub mod type_op {\n     use crate::ty::fold::TypeFoldable;\n-    use crate::ty::subst::UserSubsts;\n-    use crate::ty::{Predicate, Ty};\n-    use rustc_hir::def_id::DefId;\n+    use crate::ty::{Predicate, Ty, UserType};\n     use std::fmt;\n \n     #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, Lift)]\n     #[derive(TypeFoldable, TypeVisitable)]\n     pub struct AscribeUserType<'tcx> {\n         pub mir_ty: Ty<'tcx>,\n-        pub def_id: DefId,\n-        pub user_substs: UserSubsts<'tcx>,\n+        pub user_ty: UserType<'tcx>,\n     }\n \n     impl<'tcx> AscribeUserType<'tcx> {\n-        pub fn new(mir_ty: Ty<'tcx>, def_id: DefId, user_substs: UserSubsts<'tcx>) -> Self {\n-            Self { mir_ty, def_id, user_substs }\n+        pub fn new(mir_ty: Ty<'tcx>, user_ty: UserType<'tcx>) -> Self {\n+            Self { mir_ty, user_ty }\n         }\n     }\n "}, {"sha": "bc7895c39707a6125006489697673f3e8cad45d3", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198", "patch": "@@ -679,7 +679,7 @@ impl<'tcx> CanonicalUserType<'tcx> {\n /// from constants that are named via paths, like `Foo::<A>::new` and\n /// so forth.\n #[derive(Copy, Clone, Debug, PartialEq, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n+#[derive(Eq, Hash, HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub enum UserType<'tcx> {\n     Ty(Ty<'tcx>),\n "}, {"sha": "aa5c83ac2e6557cd98e40f7d29cbc18db5a99853", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 42, "deletions": 11, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198", "patch": "@@ -4,8 +4,8 @@ use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n use rustc_infer::traits::ObligationCauseCode;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, FnSig, Lift, PolyFnSig, Ty, TyCtxt, TypeFoldable};\n-use rustc_middle::ty::{ParamEnvAnd, Predicate, ToPredicate};\n-use rustc_middle::ty::{UserSelfTy, UserSubsts};\n+use rustc_middle::ty::{ParamEnvAnd, Predicate};\n+use rustc_middle::ty::{UserSelfTy, UserSubsts, UserType};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n use rustc_trait_selection::traits::query::normalize::QueryNormalizeExt;\n@@ -50,13 +50,46 @@ pub fn type_op_ascribe_user_type_with_span<'tcx>(\n     key: ParamEnvAnd<'tcx, AscribeUserType<'tcx>>,\n     span: Option<Span>,\n ) -> Result<(), NoSolution> {\n-    let (param_env, AscribeUserType { mir_ty, def_id, user_substs }) = key.into_parts();\n-    debug!(\n-        \"type_op_ascribe_user_type: mir_ty={:?} def_id={:?} user_substs={:?}\",\n-        mir_ty, def_id, user_substs\n-    );\n+    let (param_env, AscribeUserType { mir_ty, user_ty }) = key.into_parts();\n+    debug!(\"type_op_ascribe_user_type: mir_ty={:?} user_ty={:?}\", mir_ty, user_ty);\n     let span = span.unwrap_or(DUMMY_SP);\n+    match user_ty {\n+        UserType::Ty(user_ty) => relate_mir_and_user_ty(ocx, param_env, span, mir_ty, user_ty)?,\n+        UserType::TypeOf(def_id, user_substs) => {\n+            relate_mir_and_user_substs(ocx, param_env, span, mir_ty, def_id, user_substs)?\n+        }\n+    };\n+    Ok(())\n+}\n+\n+#[instrument(level = \"debug\", skip(ocx, param_env, span))]\n+fn relate_mir_and_user_ty<'tcx>(\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    span: Span,\n+    mir_ty: Ty<'tcx>,\n+    user_ty: Ty<'tcx>,\n+) -> Result<(), NoSolution> {\n+    let cause = ObligationCause::dummy_with_span(span);\n+    let user_ty = ocx.normalize(&cause, param_env, user_ty);\n+    ocx.eq(&cause, param_env, mir_ty, user_ty)?;\n \n+    // FIXME(#104764): We should check well-formedness before normalization.\n+    let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(user_ty.into()));\n+    ocx.register_obligation(Obligation::new(ocx.infcx.tcx, cause, param_env, predicate));\n+\n+    Ok(())\n+}\n+\n+#[instrument(level = \"debug\", skip(ocx, param_env, span))]\n+fn relate_mir_and_user_substs<'tcx>(\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    span: Span,\n+    mir_ty: Ty<'tcx>,\n+    def_id: hir::def_id::DefId,\n+    user_substs: UserSubsts<'tcx>,\n+) -> Result<(), NoSolution> {\n     let UserSubsts { user_self_ty, substs } = user_substs;\n     let tcx = ocx.infcx.tcx;\n     let cause = ObligationCause::dummy_with_span(span);\n@@ -97,8 +130,7 @@ pub fn type_op_ascribe_user_type_with_span<'tcx>(\n \n         ocx.eq(&cause, param_env, self_ty, impl_self_ty)?;\n \n-        let predicate: Predicate<'tcx> =\n-            ty::Binder::dummy(ty::PredicateKind::WellFormed(impl_self_ty.into())).to_predicate(tcx);\n+        let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(impl_self_ty.into()));\n         ocx.register_obligation(Obligation::new(tcx, cause.clone(), param_env, predicate));\n     }\n \n@@ -113,8 +145,7 @@ pub fn type_op_ascribe_user_type_with_span<'tcx>(\n     // them?  This would only be relevant if some input\n     // type were ill-formed but did not appear in `ty`,\n     // which...could happen with normalization...\n-    let predicate: Predicate<'tcx> =\n-        ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into())).to_predicate(tcx);\n+    let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into()));\n     ocx.register_obligation(Obligation::new(tcx, cause, param_env, predicate));\n     Ok(())\n }"}, {"sha": "da3bc20832286aab2f63f8e0e2fc1e6b5e0febd6", "filename": "src/test/ui/nll/ty-outlives/wf-unreachable.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fwf-unreachable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fwf-unreachable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fwf-unreachable.stderr?ref=c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198", "patch": "@@ -5,7 +5,7 @@ LL | fn uninit<'a>() {\n    |           -- lifetime `'a` defined here\n LL |     return;\n LL |     let x: &'static &'a ();\n-   |            ^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n+   |            ^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n \n error: lifetime may not live long enough\n   --> $DIR/wf-unreachable.rs:11:12\n@@ -14,15 +14,15 @@ LL | fn var_type<'a>() {\n    |             -- lifetime `'a` defined here\n LL |     return;\n LL |     let x: &'static &'a () = &&();\n-   |            ^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n+   |            ^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n \n error: lifetime may not live long enough\n   --> $DIR/wf-unreachable.rs:15:12\n    |\n LL | fn uninit_infer<'a>() {\n    |                 -- lifetime `'a` defined here\n LL |     let x: &'static &'a _;\n-   |            ^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n+   |            ^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n \n error: lifetime may not live long enough\n   --> $DIR/wf-unreachable.rs:21:12\n@@ -31,7 +31,7 @@ LL | fn infer<'a>() {\n    |          -- lifetime `'a` defined here\n LL |     return;\n LL |     let x: &'static &'a _ = &&();\n-   |            ^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n+   |            ^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n \n error: lifetime may not live long enough\n   --> $DIR/wf-unreachable.rs:26:12\n@@ -40,7 +40,7 @@ LL | fn uninit_no_var<'a>() {\n    |                  -- lifetime `'a` defined here\n LL |     return;\n LL |     let _: &'static &'a ();\n-   |            ^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n+   |            ^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n \n error: lifetime may not live long enough\n   --> $DIR/wf-unreachable.rs:31:12\n@@ -49,7 +49,7 @@ LL | fn no_var<'a>() {\n    |           -- lifetime `'a` defined here\n LL |     return;\n LL |     let _: &'static &'a () = &&();\n-   |            ^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n+   |            ^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n \n error: lifetime may not live long enough\n   --> $DIR/wf-unreachable.rs:36:12\n@@ -58,7 +58,7 @@ LL | fn infer_no_var<'a>() {\n    |                 -- lifetime `'a` defined here\n LL |     return;\n LL |     let _: &'static &'a _ = &&();\n-   |            ^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n+   |            ^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n \n error: lifetime may not live long enough\n   --> $DIR/wf-unreachable.rs:49:12\n@@ -67,7 +67,7 @@ LL | fn required_substs<'a>() {\n    |                    -- lifetime `'a` defined here\n LL |     return;\n LL |     let _: C<'static, 'a, _> = C((), &(), &());\n-   |            ^^^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n+   |            ^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n \n error: aborting due to 8 previous errors\n "}, {"sha": "4dbd3fd8d81e287c48cbee1c6fcc8d9594b42673", "filename": "src/test/ui/nll/user-annotations/closure-sig.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fclosure-sig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fclosure-sig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fclosure-sig.rs?ref=c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198", "patch": "@@ -0,0 +1,15 @@\n+// This test fails if #104478 is fixed before #104477.\n+\n+// check-pass\n+\n+struct Printer<'a, 'b>(&'a (), &'b ());\n+\n+impl Printer<'_, '_> {\n+    fn test(self) {\n+        let clo = |_: &'_ Self| {};\n+        clo(&self);\n+        clo(&self);\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "8bfc272d4ba095660caa925a52bd15c1862bc2b8", "filename": "src/test/ui/nll/user-annotations/normalization-infer.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-infer.rs?ref=c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198", "patch": "@@ -0,0 +1,40 @@\n+// Annnotations may contain projection types with inference variables as input.\n+// Make sure we don't get ambiguities when normalizing them.\n+\n+// check-fail\n+\n+// Single impl.\n+fn test1<A, B, C, D>(a: A, b: B, c: C) {\n+    trait Tr { type Ty; }\n+    impl<T: 'static> Tr for (T,) { type Ty = T; }\n+\n+    let _: <(_,) as Tr>::Ty = a; //~ ERROR type `A`\n+    Some::<<(_,) as Tr>::Ty>(b); //~ ERROR type `B`\n+    || -> <(_,) as Tr>::Ty { c }; //~ ERROR type `C`\n+    |d: <(_,) as Tr>::Ty| -> D { d }; //~ ERROR type `D`\n+}\n+\n+\n+// Two impls. The selected impl depends on the actual type.\n+fn test2<A, B, C>(a: A, b: B, c: C) {\n+    trait Tr { type Ty; }\n+    impl<T: 'static> Tr for (u8, T) { type Ty = T; }\n+    impl<T>          Tr for (i8, T) { type Ty = T; }\n+    type Alias<X, Y> = (<(X, Y) as Tr>::Ty, X);\n+\n+    fn temp() -> String { todo!() }\n+\n+    // `u8` impl, requires static.\n+    let _: Alias<_, _> = (a, 0u8); //~ ERROR type `A`\n+    Some::<Alias<_, _>>((b, 0u8)); //~ ERROR type `B`\n+    || -> Alias<_, _> { (c, 0u8) }; //~ ERROR type `C`\n+\n+    let _: Alias<_, _> = (&temp(), 0u8); //~ ERROR temporary value\n+    Some::<Alias<_, _>>((&temp(), 0u8)); //~ ERROR temporary value\n+\n+    // `i8` impl, no region constraints.\n+    let _: Alias<_, _> = (&temp(), 0i8);\n+    Some::<Alias<_, _>>((&temp(), 0i8));\n+}\n+\n+fn main() {}"}, {"sha": "12854ab6816b7e074991b0a6b993b629f2c3845f", "filename": "src/test/ui/nll/user-annotations/normalization-infer.stderr", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-infer.stderr?ref=c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198", "patch": "@@ -0,0 +1,101 @@\n+error[E0310]: the parameter type `A` may not live long enough\n+  --> $DIR/normalization-infer.rs:11:12\n+   |\n+LL |     let _: <(_,) as Tr>::Ty = a;\n+   |            ^^^^^^^^^^^^^^^^ ...so that the type `A` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn test1<A: 'static, B, C, D>(a: A, b: B, c: C) {\n+   |           +++++++++\n+\n+error[E0310]: the parameter type `B` may not live long enough\n+  --> $DIR/normalization-infer.rs:12:5\n+   |\n+LL |     Some::<<(_,) as Tr>::Ty>(b);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `B` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn test1<A, B: 'static, C, D>(a: A, b: B, c: C) {\n+   |              +++++++++\n+\n+error[E0310]: the parameter type `C` may not live long enough\n+  --> $DIR/normalization-infer.rs:13:11\n+   |\n+LL |     || -> <(_,) as Tr>::Ty { c };\n+   |           ^^^^^^^^^^^^^^^^ ...so that the type `C` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn test1<A, B, C: 'static, D>(a: A, b: B, c: C) {\n+   |                 +++++++++\n+\n+error[E0310]: the parameter type `D` may not live long enough\n+  --> $DIR/normalization-infer.rs:14:6\n+   |\n+LL |     |d: <(_,) as Tr>::Ty| -> D { d };\n+   |      ^ ...so that the type `D` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn test1<A, B, C, D: 'static>(a: A, b: B, c: C) {\n+   |                    +++++++++\n+\n+error[E0310]: the parameter type `A` may not live long enough\n+  --> $DIR/normalization-infer.rs:28:12\n+   |\n+LL |     let _: Alias<_, _> = (a, 0u8);\n+   |            ^^^^^^^^^^^ ...so that the type `A` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn test2<A: 'static, B, C>(a: A, b: B, c: C) {\n+   |           +++++++++\n+\n+error[E0310]: the parameter type `B` may not live long enough\n+  --> $DIR/normalization-infer.rs:29:5\n+   |\n+LL |     Some::<Alias<_, _>>((b, 0u8));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `B` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn test2<A, B: 'static, C>(a: A, b: B, c: C) {\n+   |              +++++++++\n+\n+error[E0310]: the parameter type `C` may not live long enough\n+  --> $DIR/normalization-infer.rs:30:11\n+   |\n+LL |     || -> Alias<_, _> { (c, 0u8) };\n+   |           ^^^^^^^^^^^ ...so that the type `C` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn test2<A, B, C: 'static>(a: A, b: B, c: C) {\n+   |                 +++++++++\n+\n+error[E0716]: temporary value dropped while borrowed\n+  --> $DIR/normalization-infer.rs:32:28\n+   |\n+LL |     let _: Alias<_, _> = (&temp(), 0u8);\n+   |            -----------     ^^^^^^ creates a temporary value which is freed while still in use\n+   |            |\n+   |            type annotation requires that borrow lasts for `'static`\n+...\n+LL | }\n+   | - temporary value is freed at the end of this statement\n+\n+error[E0716]: temporary value dropped while borrowed\n+  --> $DIR/normalization-infer.rs:33:27\n+   |\n+LL |     Some::<Alias<_, _>>((&temp(), 0u8));\n+   |                         --^^^^^^------ - temporary value is freed at the end of this statement\n+   |                         | |\n+   |                         | creates a temporary value which is freed while still in use\n+   |                         this usage requires that borrow lasts for `'static`\n+\n+error: aborting due to 9 previous errors\n+\n+Some errors have detailed explanations: E0310, E0716.\n+For more information about an error, try `rustc --explain E0310`."}, {"sha": "2a26252036181ceb696733b2902ac6b0f628ab49", "filename": "src/test/ui/regions/regions-assoc-type-in-supertrait-outlives-container.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-in-supertrait-outlives-container.stderr?ref=c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198", "patch": "@@ -7,7 +7,7 @@ LL | fn with_assoc<'a,'b>() {\n    |               lifetime `'a` defined here\n ...\n LL |     let _: &'a WithAssoc<TheType<'b>> = loop { };\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n "}, {"sha": "cdf70d2a5be974245001d8deb05d352a991fd56e", "filename": "src/test/ui/regions/regions-free-region-ordering-caller.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller.stderr?ref=c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198", "patch": "@@ -6,7 +6,7 @@ LL | fn call2<'a, 'b>(a: &'a usize, b: &'b usize) {\n    |          |\n    |          lifetime `'a` defined here\n LL |     let z: Option<&'b &'a usize> = None;\n-   |            ^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'b`\n+   |            ^^^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'b`\n    |\n    = help: consider adding the following bound: `'a: 'b`\n \n@@ -19,7 +19,7 @@ LL | fn call3<'a, 'b>(a: &'a usize, b: &'b usize) {\n    |          lifetime `'a` defined here\n LL |     let y: Paramd<'a> = Paramd { x: a };\n LL |     let z: Option<&'b Paramd<'a>> = None;\n-   |            ^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'b`\n+   |            ^^^^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'b`\n    |\n    = help: consider adding the following bound: `'a: 'b`\n \n@@ -31,7 +31,7 @@ LL | fn call4<'a, 'b>(a: &'a usize, b: &'b usize) {\n    |          |\n    |          lifetime `'a` defined here\n LL |     let z: Option<&'a &'b usize> = None;\n-   |            ^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n+   |            ^^^^^^^^^^^^^^^^^^^^^ requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n "}, {"sha": "6a7c908fa40092873b4d5518f83471530903448d", "filename": "src/test/ui/regions/regions-outlives-projection-container-hrtb.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.stderr?ref=c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198", "patch": "@@ -7,7 +7,7 @@ LL | fn with_assoc<'a,'b>() {\n    |               lifetime `'a` defined here\n ...\n LL |     let _: &'a WithHrAssoc<TheType<'b>> = loop { };\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n \n@@ -20,7 +20,7 @@ LL | fn with_assoc_sub<'a,'b>() {\n    |                   lifetime `'a` defined here\n ...\n LL |     let _: &'a WithHrAssocSub<TheType<'b>> = loop { };\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n "}, {"sha": "eba2a0d585346a0fb49d36811c3cc8ff731af218", "filename": "src/test/ui/regions/regions-outlives-projection-container-wc.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.stderr?ref=c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198", "patch": "@@ -7,7 +7,7 @@ LL | fn with_assoc<'a,'b>() {\n    |               lifetime `'a` defined here\n ...\n LL |     let _: &'a WithAssoc<TheType<'b>> = loop { };\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n "}, {"sha": "d20a2f06adfeccf818141a5dca2c4cf98ae799c4", "filename": "src/test/ui/regions/regions-outlives-projection-container.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.stderr?ref=c6a17bf8bcfa60c8b0436251d2cf70d8eca4d198", "patch": "@@ -7,7 +7,7 @@ LL | fn with_assoc<'a,'b>() {\n    |               lifetime `'a` defined here\n ...\n LL |     let _x: &'a WithAssoc<TheType<'b>> = loop { };\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n \n@@ -20,7 +20,7 @@ LL | fn without_assoc<'a,'b>() {\n    |                  lifetime `'a` defined here\n ...\n LL |     let _x: &'a WithoutAssoc<TheType<'b>> = loop { };\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n "}]}