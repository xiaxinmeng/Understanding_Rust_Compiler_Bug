{"sha": "7a42e46eec5590314b64bb82027a22d66545e627", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhNDJlNDZlZWM1NTkwMzE0YjY0YmI4MjAyN2EyMmQ2NjU0NWU2Mjc=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-15T02:34:32Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-26T23:23:06Z"}, "message": "Refactor the `syntax::config::fold_*` functions into methods", "tree": {"sha": "5c3c6b27d5da93a1b4cdc11a48558916e4eb81cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c3c6b27d5da93a1b4cdc11a48558916e4eb81cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a42e46eec5590314b64bb82027a22d66545e627", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a42e46eec5590314b64bb82027a22d66545e627", "html_url": "https://github.com/rust-lang/rust/commit/7a42e46eec5590314b64bb82027a22d66545e627", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a42e46eec5590314b64bb82027a22d66545e627/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29c105964bc303448611b6329ecb36a7470b796b", "url": "https://api.github.com/repos/rust-lang/rust/commits/29c105964bc303448611b6329ecb36a7470b796b", "html_url": "https://github.com/rust-lang/rust/commit/29c105964bc303448611b6329ecb36a7470b796b"}], "stats": {"total": 228, "additions": 81, "deletions": 147}, "files": [{"sha": "0491a8c5494275c89142bf2c6e9ba105d506a441", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 81, "deletions": 147, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/7a42e46eec5590314b64bb82027a22d66545e627/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a42e46eec5590314b64bb82027a22d66545e627/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=7a42e46eec5590314b64bb82027a22d66545e627", "patch": "@@ -50,11 +50,71 @@ pub fn strip_unconfigured_items(diagnostic: &Handler, krate: ast::Crate,\n \n impl<'a, F> fold::Folder for Context<'a, F> where F: FnMut(&[ast::Attribute]) -> bool {\n     fn fold_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n-        fold_foreign_mod(self, foreign_mod)\n+        ast::ForeignMod {\n+            abi: foreign_mod.abi,\n+            items: foreign_mod.items.into_iter().filter(|item| {\n+                (self.in_cfg)(&item.attrs)\n+            }).collect(),\n+        }\n     }\n+\n     fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n-        fold_item_kind(self, item)\n+        let fold_struct = |this: &mut Self, vdata| match vdata {\n+            ast::VariantData::Struct(fields, id) => {\n+                ast::VariantData::Struct(fields.into_iter().filter(|m| {\n+                    (this.in_cfg)(&m.attrs)\n+                }).collect(), id)\n+            }\n+            ast::VariantData::Tuple(fields, id) => {\n+                ast::VariantData::Tuple(fields.into_iter().filter(|m| {\n+                    (this.in_cfg)(&m.attrs)\n+                }).collect(), id)\n+            }\n+            ast::VariantData::Unit(id) => ast::VariantData::Unit(id)\n+        };\n+\n+        let item = match item {\n+            ast::ItemKind::Impl(u, o, a, b, c, impl_items) => {\n+                let impl_items = impl_items.into_iter()\n+                                           .filter(|ii| (self.in_cfg)(&ii.attrs))\n+                                           .collect();\n+                ast::ItemKind::Impl(u, o, a, b, c, impl_items)\n+            }\n+            ast::ItemKind::Trait(u, a, b, methods) => {\n+                let methods = methods.into_iter()\n+                                     .filter(|ti| (self.in_cfg)(&ti.attrs))\n+                                     .collect();\n+                ast::ItemKind::Trait(u, a, b, methods)\n+            }\n+            ast::ItemKind::Struct(def, generics) => {\n+                ast::ItemKind::Struct(fold_struct(self, def), generics)\n+            }\n+            ast::ItemKind::Enum(def, generics) => {\n+                let variants = def.variants.into_iter().filter_map(|v| {\n+                    if !(self.in_cfg)(&v.node.attrs) {\n+                        None\n+                    } else {\n+                        Some(Spanned {\n+                            node: ast::Variant_ {\n+                                name: v.node.name,\n+                                attrs: v.node.attrs,\n+                                data: fold_struct(self, v.node.data),\n+                                disr_expr: v.node.disr_expr,\n+                            },\n+                            span: v.span\n+                        })\n+                    }\n+                });\n+                ast::ItemKind::Enum(ast::EnumDef {\n+                    variants: variants.collect(),\n+                }, generics)\n+            }\n+            item => item,\n+        };\n+\n+        fold::noop_fold_item_kind(item, self)\n     }\n+\n     fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n         // If an expr is valid to cfg away it will have been removed by the\n         // outer stmt or expression folder before descending in here.\n@@ -69,17 +129,33 @@ impl<'a, F> fold::Folder for Context<'a, F> where F: FnMut(&[ast::Attribute]) ->\n         }\n         fold_expr(self, expr)\n     }\n+\n     fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-        fold_opt_expr(self, expr)\n+        if (self.in_cfg)(expr.attrs()) {\n+            Some(fold_expr(self, expr))\n+        } else {\n+            None\n+        }\n     }\n+\n     fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n-        fold_stmt(self, stmt)\n+        if (self.in_cfg)(stmt.node.attrs()) {\n+            fold::noop_fold_stmt(stmt, self)\n+        } else {\n+            SmallVector::zero()\n+        }\n     }\n+\n     fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n         fold::noop_fold_mac(mac, self)\n     }\n+\n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n-        fold_item(self, item)\n+        if (self.in_cfg)(&item.attrs) {\n+            SmallVector::one(item.map(|i| self.fold_item_simple(i)))\n+        } else {\n+            SmallVector::zero()\n+        }\n     }\n }\n \n@@ -94,114 +170,6 @@ pub fn strip_items<'a, F>(diagnostic: &'a Handler,\n     ctxt.fold_crate(krate)\n }\n \n-fn filter_foreign_item<F>(cx: &mut Context<F>,\n-                          item: ast::ForeignItem)\n-                          -> Option<ast::ForeignItem> where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    if foreign_item_in_cfg(cx, &item) {\n-        Some(item)\n-    } else {\n-        None\n-    }\n-}\n-\n-fn fold_foreign_mod<F>(cx: &mut Context<F>,\n-                       ast::ForeignMod {abi, items}: ast::ForeignMod)\n-                       -> ast::ForeignMod where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    ast::ForeignMod {\n-        abi: abi,\n-        items: items.into_iter()\n-                    .filter_map(|a| filter_foreign_item(cx, a))\n-                    .collect()\n-    }\n-}\n-\n-fn fold_item<F>(cx: &mut Context<F>, item: P<ast::Item>) -> SmallVector<P<ast::Item>> where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    if item_in_cfg(cx, &item) {\n-        SmallVector::one(item.map(|i| cx.fold_item_simple(i)))\n-    } else {\n-        SmallVector::zero()\n-    }\n-}\n-\n-fn fold_item_kind<F>(cx: &mut Context<F>, item: ast::ItemKind) -> ast::ItemKind where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    let item = match item {\n-        ast::ItemKind::Impl(u, o, a, b, c, impl_items) => {\n-            let impl_items = impl_items.into_iter()\n-                                       .filter(|ii| (cx.in_cfg)(&ii.attrs))\n-                                       .collect();\n-            ast::ItemKind::Impl(u, o, a, b, c, impl_items)\n-        }\n-        ast::ItemKind::Trait(u, a, b, methods) => {\n-            let methods = methods.into_iter()\n-                                 .filter(|ti| (cx.in_cfg)(&ti.attrs))\n-                                 .collect();\n-            ast::ItemKind::Trait(u, a, b, methods)\n-        }\n-        ast::ItemKind::Struct(def, generics) => {\n-            ast::ItemKind::Struct(fold_struct(cx, def), generics)\n-        }\n-        ast::ItemKind::Enum(def, generics) => {\n-            let variants = def.variants.into_iter().filter_map(|v| {\n-                if !(cx.in_cfg)(&v.node.attrs) {\n-                    None\n-                } else {\n-                    Some(Spanned {\n-                        node: ast::Variant_ {\n-                            name: v.node.name,\n-                            attrs: v.node.attrs,\n-                            data: fold_struct(cx, v.node.data),\n-                            disr_expr: v.node.disr_expr,\n-                        },\n-                        span: v.span\n-                    })\n-                }\n-            });\n-            ast::ItemKind::Enum(ast::EnumDef {\n-                variants: variants.collect(),\n-            }, generics)\n-        }\n-        item => item,\n-    };\n-\n-    fold::noop_fold_item_kind(item, cx)\n-}\n-\n-fn fold_struct<F>(cx: &mut Context<F>, vdata: ast::VariantData) -> ast::VariantData where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    match vdata {\n-        ast::VariantData::Struct(fields, id) => {\n-            ast::VariantData::Struct(fields.into_iter().filter(|m| {\n-                (cx.in_cfg)(&m.attrs)\n-            }).collect(), id)\n-        }\n-        ast::VariantData::Tuple(fields, id) => {\n-            ast::VariantData::Tuple(fields.into_iter().filter(|m| {\n-                (cx.in_cfg)(&m.attrs)\n-            }).collect(), id)\n-        }\n-        ast::VariantData::Unit(id) => ast::VariantData::Unit(id)\n-    }\n-}\n-\n-fn fold_opt_expr<F>(cx: &mut Context<F>, expr: P<ast::Expr>) -> Option<P<ast::Expr>>\n-    where F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    if expr_in_cfg(cx, &expr) {\n-        Some(fold_expr(cx, expr))\n-    } else {\n-        None\n-    }\n-}\n-\n fn fold_expr<F>(cx: &mut Context<F>, expr: P<ast::Expr>) -> P<ast::Expr> where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n@@ -222,40 +190,6 @@ fn fold_expr<F>(cx: &mut Context<F>, expr: P<ast::Expr>) -> P<ast::Expr> where\n     })\n }\n \n-fn fold_stmt<F>(cx: &mut Context<F>, stmt: ast::Stmt) -> SmallVector<ast::Stmt>\n-    where F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    if stmt_in_cfg(cx, &stmt) {\n-        fold::noop_fold_stmt(stmt, cx)\n-    } else {\n-        SmallVector::zero()\n-    }\n-}\n-\n-fn stmt_in_cfg<F>(cx: &mut Context<F>, stmt: &ast::Stmt) -> bool where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    (cx.in_cfg)(stmt.node.attrs())\n-}\n-\n-fn expr_in_cfg<F>(cx: &mut Context<F>, expr: &ast::Expr) -> bool where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    (cx.in_cfg)(expr.attrs())\n-}\n-\n-fn item_in_cfg<F>(cx: &mut Context<F>, item: &ast::Item) -> bool where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    return (cx.in_cfg)(&item.attrs);\n-}\n-\n-fn foreign_item_in_cfg<F>(cx: &mut Context<F>, item: &ast::ForeignItem) -> bool where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    return (cx.in_cfg)(&item.attrs);\n-}\n-\n fn is_cfg(attr: &ast::Attribute) -> bool {\n     attr.check_name(\"cfg\")\n }"}]}