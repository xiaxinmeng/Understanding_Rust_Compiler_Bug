{"sha": "1025db84a68b948139b5adcd55da31bce32da8f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwMjVkYjg0YTY4Yjk0ODEzOWI1YWRjZDU1ZGEzMWJjZTMyZGE4ZjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-14T16:58:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-14T16:58:30Z"}, "message": "Auto merge of #85211 - Aaron1011:metadata-invalid-span, r=michaelwoerister\n\nPreserve `SyntaxContext` for invalid/dummy spans in crate metadata\n\nFixes #85197\n\nWe already preserved the `SyntaxContext` for invalid/dummy spans in the\nincremental cache, but we weren't doing the same for crate metadata.\nIf an invalid (lo/hi from different files) span is written to the\nincremental cache, we will decode it with a 'dummy' location, but keep\nthe original `SyntaxContext`. Since the crate metadata encoder was only\nchecking for `DUMMY_SP` (dummy location + root `SyntaxContext`),\nthe metadata encoder would treat it as a normal span, encoding the\n`SyntaxContext`. As a result, the final span encoded to the metadata\nwould change across sessions, even if the crate itself was unchanged.\n\nThis could lead to an 'unstable fingerprint' ICE under the following conditions:\n1. We compile a crate with an invalid span using incremental compilation. The metadata encoder discards the `SyntaxContext` since the span is invalid, while the incremental cache encoder preserves the `SyntaxContext`\n2. From another crate, we execute a foreign query, decoding the invalid span from the metadata as `DUMMY_SP` (e.g. with `SyntaxContext::root()`). This span gets hashed into the query fingerprint. So far, this has always happened through the `optimized_mir` query.\n3. We recompile the first crate using our populated incremental cache, without changing anything. We load the (previously) invalid span from our incremental cache - it gets converted to a span with a dummy (but valid) location, along with the original `SyntaxContext`. This span gets written out to the crate metadata - since it now has a valid location, we preserve its `SyntaxContext`.\n4. We recompile the second crate, again using a populated incremental cache. We now re-run the foreign query `optimized_mir` - the foreign crate hash is unchanged, but we end up decoding a different span (it now ha a non-root `SyntaxContext`). This results in the fingerprint changing, resulting in an ICE.\n\nThis PR updates our encoding of spans in the crate metadata to mirror\nthe encoding of spans into the incremental cache. We now always encode a\n`SyntaxContext`, and encode location information for spans with a\nnon-dummy location.", "tree": {"sha": "67d5db064ab62d2206d0a7bcf34172865263bb0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67d5db064ab62d2206d0a7bcf34172865263bb0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1025db84a68b948139b5adcd55da31bce32da8f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1025db84a68b948139b5adcd55da31bce32da8f3", "html_url": "https://github.com/rust-lang/rust/commit/1025db84a68b948139b5adcd55da31bce32da8f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1025db84a68b948139b5adcd55da31bce32da8f3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75da570d784a798a34ff1e5048cd9a6a2fb23170", "url": "https://api.github.com/repos/rust-lang/rust/commits/75da570d784a798a34ff1e5048cd9a6a2fb23170", "html_url": "https://github.com/rust-lang/rust/commit/75da570d784a798a34ff1e5048cd9a6a2fb23170"}, {"sha": "cdca3c81c1eed6f09733beea4dc2517e6f3d71f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdca3c81c1eed6f09733beea4dc2517e6f3d71f6", "html_url": "https://github.com/rust-lang/rust/commit/cdca3c81c1eed6f09733beea4dc2517e6f3d71f6"}], "stats": {"total": 158, "additions": 113, "deletions": 45}, "files": [{"sha": "b27eef376c49e6f7a5e714d6512e4e41d3ee9758", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1025db84a68b948139b5adcd55da31bce32da8f3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1025db84a68b948139b5adcd55da31bce32da8f3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=1025db84a68b948139b5adcd55da31bce32da8f3", "patch": "@@ -406,17 +406,17 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for ExpnId {\n \n impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Span {\n     fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Result<Span, String> {\n+        let ctxt = SyntaxContext::decode(decoder)?;\n         let tag = u8::decode(decoder)?;\n \n-        if tag == TAG_INVALID_SPAN {\n-            return Ok(DUMMY_SP);\n+        if tag == TAG_PARTIAL_SPAN {\n+            return Ok(DUMMY_SP.with_ctxt(ctxt));\n         }\n \n         debug_assert!(tag == TAG_VALID_SPAN_LOCAL || tag == TAG_VALID_SPAN_FOREIGN);\n \n         let lo = BytePos::decode(decoder)?;\n         let len = BytePos::decode(decoder)?;\n-        let ctxt = SyntaxContext::decode(decoder)?;\n         let hi = lo + len;\n \n         let sess = if let Some(sess) = decoder.sess {"}, {"sha": "29fcbffa0b95298f8bfecde67a3888b0474ad383", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/1025db84a68b948139b5adcd55da31bce32da8f3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1025db84a68b948139b5adcd55da31bce32da8f3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=1025db84a68b948139b5adcd55da31bce32da8f3", "patch": "@@ -187,11 +187,48 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for ExpnId {\n \n impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n     fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n-        if *self == rustc_span::DUMMY_SP {\n-            return TAG_INVALID_SPAN.encode(s);\n+        let span = self.data();\n+\n+        // Don't serialize any `SyntaxContext`s from a proc-macro crate,\n+        // since we don't load proc-macro dependencies during serialization.\n+        // This means that any hygiene information from macros used *within*\n+        // a proc-macro crate (e.g. invoking a macro that expands to a proc-macro\n+        // definition) will be lost.\n+        //\n+        // This can show up in two ways:\n+        //\n+        // 1. Any hygiene information associated with identifier of\n+        // a proc macro (e.g. `#[proc_macro] pub fn $name`) will be lost.\n+        // Since proc-macros can only be invoked from a different crate,\n+        // real code should never need to care about this.\n+        //\n+        // 2. Using `Span::def_site` or `Span::mixed_site` will not\n+        // include any hygiene information associated with the definition\n+        // site. This means that a proc-macro cannot emit a `$crate`\n+        // identifier which resolves to one of its dependencies,\n+        // which also should never come up in practice.\n+        //\n+        // Additionally, this affects `Span::parent`, and any other\n+        // span inspection APIs that would otherwise allow traversing\n+        // the `SyntaxContexts` associated with a span.\n+        //\n+        // None of these user-visible effects should result in any\n+        // cross-crate inconsistencies (getting one behavior in the same\n+        // crate, and a different behavior in another crate) due to the\n+        // limited surface that proc-macros can expose.\n+        //\n+        // IMPORTANT: If this is ever changed, be sure to update\n+        // `rustc_span::hygiene::raw_encode_expn_id` to handle\n+        // encoding `ExpnData` for proc-macro crates.\n+        if s.is_proc_macro {\n+            SyntaxContext::root().encode(s)?;\n+        } else {\n+            span.ctxt.encode(s)?;\n         }\n \n-        let span = self.data();\n+        if self.is_dummy() {\n+            return TAG_PARTIAL_SPAN.encode(s);\n+        }\n \n         // The Span infrastructure should make sure that this invariant holds:\n         debug_assert!(span.lo <= span.hi);\n@@ -206,7 +243,7 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n         if !s.source_file_cache.0.contains(span.hi) {\n             // Unfortunately, macro expansion still sometimes generates Spans\n             // that malformed in this way.\n-            return TAG_INVALID_SPAN.encode(s);\n+            return TAG_PARTIAL_SPAN.encode(s);\n         }\n \n         let source_files = s.required_source_files.as_mut().expect(\"Already encoded SourceMap!\");\n@@ -262,43 +299,6 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n         let len = hi - lo;\n         len.encode(s)?;\n \n-        // Don't serialize any `SyntaxContext`s from a proc-macro crate,\n-        // since we don't load proc-macro dependencies during serialization.\n-        // This means that any hygiene information from macros used *within*\n-        // a proc-macro crate (e.g. invoking a macro that expands to a proc-macro\n-        // definition) will be lost.\n-        //\n-        // This can show up in two ways:\n-        //\n-        // 1. Any hygiene information associated with identifier of\n-        // a proc macro (e.g. `#[proc_macro] pub fn $name`) will be lost.\n-        // Since proc-macros can only be invoked from a different crate,\n-        // real code should never need to care about this.\n-        //\n-        // 2. Using `Span::def_site` or `Span::mixed_site` will not\n-        // include any hygiene information associated with the definition\n-        // site. This means that a proc-macro cannot emit a `$crate`\n-        // identifier which resolves to one of its dependencies,\n-        // which also should never come up in practice.\n-        //\n-        // Additionally, this affects `Span::parent`, and any other\n-        // span inspection APIs that would otherwise allow traversing\n-        // the `SyntaxContexts` associated with a span.\n-        //\n-        // None of these user-visible effects should result in any\n-        // cross-crate inconsistencies (getting one behavior in the same\n-        // crate, and a different behavior in another crate) due to the\n-        // limited surface that proc-macros can expose.\n-        //\n-        // IMPORTANT: If this is ever changed, be sure to update\n-        // `rustc_span::hygiene::raw_encode_expn_id` to handle\n-        // encoding `ExpnData` for proc-macro crates.\n-        if s.is_proc_macro {\n-            SyntaxContext::root().encode(s)?;\n-        } else {\n-            span.ctxt.encode(s)?;\n-        }\n-\n         if tag == TAG_VALID_SPAN_FOREIGN {\n             // This needs to be two lines to avoid holding the `s.source_file_cache`\n             // while calling `cnum.encode(s)`"}, {"sha": "1fb68fd5fc309f438f240b1110a7e7ca2147eb77", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1025db84a68b948139b5adcd55da31bce32da8f3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1025db84a68b948139b5adcd55da31bce32da8f3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=1025db84a68b948139b5adcd55da31bce32da8f3", "patch": "@@ -451,4 +451,4 @@ struct GeneratorData<'tcx> {\n // Tags used for encoding Spans:\n const TAG_VALID_SPAN_LOCAL: u8 = 0;\n const TAG_VALID_SPAN_FOREIGN: u8 = 1;\n-const TAG_INVALID_SPAN: u8 = 2;\n+const TAG_PARTIAL_SPAN: u8 = 2;"}, {"sha": "2453af5b6b47b8a989c3b2255a065c9a5df876f6", "filename": "src/test/incremental/issue-85197-invalid-span/auxiliary/invalid-span-helper-lib.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1025db84a68b948139b5adcd55da31bce32da8f3/src%2Ftest%2Fincremental%2Fissue-85197-invalid-span%2Fauxiliary%2Finvalid-span-helper-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1025db84a68b948139b5adcd55da31bce32da8f3/src%2Ftest%2Fincremental%2Fissue-85197-invalid-span%2Fauxiliary%2Finvalid-span-helper-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-85197-invalid-span%2Fauxiliary%2Finvalid-span-helper-lib.rs?ref=1025db84a68b948139b5adcd55da31bce32da8f3", "patch": "@@ -0,0 +1,11 @@\n+// revisions: rpass1 rpass2\n+\n+extern crate respan;\n+\n+#[macro_use]\n+#[path = \"invalid-span-helper-mod.rs\"]\n+mod invalid_span_helper_mod;\n+\n+// Invoke a macro from a different file - this\n+// allows us to get tokens with spans from different files\n+helper!(1);"}, {"sha": "747174b1ebf1573957c7955da446138e07c18859", "filename": "src/test/incremental/issue-85197-invalid-span/auxiliary/invalid-span-helper-mod.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1025db84a68b948139b5adcd55da31bce32da8f3/src%2Ftest%2Fincremental%2Fissue-85197-invalid-span%2Fauxiliary%2Finvalid-span-helper-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1025db84a68b948139b5adcd55da31bce32da8f3/src%2Ftest%2Fincremental%2Fissue-85197-invalid-span%2Fauxiliary%2Finvalid-span-helper-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-85197-invalid-span%2Fauxiliary%2Finvalid-span-helper-mod.rs?ref=1025db84a68b948139b5adcd55da31bce32da8f3", "patch": "@@ -0,0 +1,14 @@\n+#[macro_export]\n+macro_rules! helper {\n+    // Use `:tt` instead of `:ident` so that we don't get a `None`-delimited group\n+    ($first:tt) => {\n+        pub fn foo<T>() {\n+            // The span of `$first` comes from another file,\n+            // so the expression `1 + $first` ends up with an\n+            // 'invalid' span that starts and ends in different files.\n+            // We use the `respan!` macro to give all tokens the same\n+            // `SyntaxContext`, so that the parser will try to merge the spans.\n+            respan::respan!(let a = 1 + $first;);\n+        }\n+    }\n+}"}, {"sha": "5088eab62946f7a722dcd392f1c2ce720fd95a5b", "filename": "src/test/incremental/issue-85197-invalid-span/auxiliary/respan.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1025db84a68b948139b5adcd55da31bce32da8f3/src%2Ftest%2Fincremental%2Fissue-85197-invalid-span%2Fauxiliary%2Frespan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1025db84a68b948139b5adcd55da31bce32da8f3/src%2Ftest%2Fincremental%2Fissue-85197-invalid-span%2Fauxiliary%2Frespan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-85197-invalid-span%2Fauxiliary%2Frespan.rs?ref=1025db84a68b948139b5adcd55da31bce32da8f3", "patch": "@@ -0,0 +1,19 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::TokenStream;\n+\n+\n+/// Copies the resolution information (the `SyntaxContext`) of the first\n+/// token to all other tokens in the stream. Does not recurse into groups.\n+#[proc_macro]\n+pub fn respan(input: TokenStream) -> TokenStream {\n+    let first_span = input.clone().into_iter().next().unwrap().span();\n+    input.into_iter().map(|mut tree| {\n+        tree.set_span(tree.span().resolved_at(first_span));\n+        tree\n+    }).collect()\n+}"}, {"sha": "f358460b33825975fff40fc8142884ceecc427ca", "filename": "src/test/incremental/issue-85197-invalid-span/invalid_span_main.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1025db84a68b948139b5adcd55da31bce32da8f3/src%2Ftest%2Fincremental%2Fissue-85197-invalid-span%2Finvalid_span_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1025db84a68b948139b5adcd55da31bce32da8f3/src%2Ftest%2Fincremental%2Fissue-85197-invalid-span%2Finvalid_span_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-85197-invalid-span%2Finvalid_span_main.rs?ref=1025db84a68b948139b5adcd55da31bce32da8f3", "patch": "@@ -0,0 +1,24 @@\n+// revisions: rpass1 rpass2\n+// aux-build:respan.rs\n+// aux-build:invalid-span-helper-lib.rs\n+\n+// This issue has several different parts. The high level idea is:\n+// 1. We create an 'invalid' span with the help of the `respan` proc-macro,\n+// The compiler attempts to prevent the creation of invalid spans by\n+// refusing to join spans with different `SyntaxContext`s. We work around\n+// this by applying the same `SyntaxContext` to the span of every token,\n+// using `Span::resolved_at`\n+// 2. We using this invalid span in the body of a function, causing it to get\n+// encoded into the `optimized_mir`\n+// 3. We call the function from a different crate - since the function is generic,\n+// monomorphization runs, causing `optimized_mir` to get called.\n+// 4. We re-run compilation using our populated incremental cache, but without\n+// making any changes. When we recompile the crate containing our generic function\n+// (`invalid_span_helper_lib`), we load the span from the incremental cache, and\n+// write it into the crate metadata.\n+\n+extern crate invalid_span_helper_lib;\n+\n+fn main() {\n+    invalid_span_helper_lib::foo::<u8>();\n+}"}]}