{"sha": "722489e3ff4c16dc179d30e729847314c918511f", "node_id": "C_kwDOAAsO6NoAKDcyMjQ4OWUzZmY0YzE2ZGMxNzlkMzBlNzI5ODQ3MzE0YzkxODUxMWY", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-10-27T14:24:42Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-10-27T14:53:39Z"}, "message": "Remove filtered completion list usage in completion tests", "tree": {"sha": "d3ede66f4fbb7f14ad4c5eb1cc05596011fe42d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3ede66f4fbb7f14ad4c5eb1cc05596011fe42d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/722489e3ff4c16dc179d30e729847314c918511f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/722489e3ff4c16dc179d30e729847314c918511f", "html_url": "https://github.com/rust-lang/rust/commit/722489e3ff4c16dc179d30e729847314c918511f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/722489e3ff4c16dc179d30e729847314c918511f/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "142b6dc650deed819d52602f2a30105d668d7308", "url": "https://api.github.com/repos/rust-lang/rust/commits/142b6dc650deed819d52602f2a30105d668d7308", "html_url": "https://github.com/rust-lang/rust/commit/142b6dc650deed819d52602f2a30105d668d7308"}], "stats": {"total": 3092, "additions": 1746, "deletions": 1346}, "files": [{"sha": "9649667bd76bc7860248d6398897c33b939e96d3", "filename": "crates/ide_completion/src/completions/dot.rs", "status": "modified", "additions": 359, "deletions": 12, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=722489e3ff4c16dc179d30e729847314c918511f", "patch": "@@ -99,13 +99,10 @@ fn complete_methods(\n mod tests {\n     use expect_test::{expect, Expect};\n \n-    use crate::{\n-        tests::{check_edit, filtered_completion_list},\n-        CompletionKind,\n-    };\n+    use crate::tests::{check_edit, completion_list_no_kw};\n \n     fn check(ra_fixture: &str, expect: Expect) {\n-        let actual = filtered_completion_list(ra_fixture, CompletionKind::Reference);\n+        let actual = completion_list_no_kw(ra_fixture);\n         expect.assert_eq(&actual);\n     }\n \n@@ -122,6 +119,18 @@ fn foo(s: S) { s.$0 }\n             expect![[r#\"\n                 fd foo   u32\n                 me bar() fn(&self)\n+                sn ref   &expr\n+                sn refm  &mut expr\n+                sn match match expr {}\n+                sn box   Box::new(expr)\n+                sn ok    Ok(expr)\n+                sn err   Err(expr)\n+                sn some  Some(expr)\n+                sn dbg   dbg!(expr)\n+                sn dbgr  dbg!(&expr)\n+                sn call  function(expr)\n+                sn let   let\n+                sn letm  let mut\n             \"#]],\n         );\n     }\n@@ -138,6 +147,18 @@ impl S {\n             expect![[r#\"\n                 fd the_field (u32,)\n                 me foo()     fn(self)\n+                sn ref       &expr\n+                sn refm      &mut expr\n+                sn match     match expr {}\n+                sn box       Box::new(expr)\n+                sn ok        Ok(expr)\n+                sn err       Err(expr)\n+                sn some      Some(expr)\n+                sn dbg       dbg!(expr)\n+                sn dbgr      dbg!(&expr)\n+                sn call      function(expr)\n+                sn let       let\n+                sn letm      let mut\n             \"#]],\n         )\n     }\n@@ -154,6 +175,18 @@ impl A {\n             expect![[r#\"\n                 fd the_field (u32, i32)\n                 me foo()     fn(&self)\n+                sn ref       &expr\n+                sn refm      &mut expr\n+                sn match     match expr {}\n+                sn box       Box::new(expr)\n+                sn ok        Ok(expr)\n+                sn err       Err(expr)\n+                sn some      Some(expr)\n+                sn dbg       dbg!(expr)\n+                sn dbgr      dbg!(&expr)\n+                sn call      function(expr)\n+                sn let       let\n+                sn letm      let mut\n             \"#]],\n         )\n     }\n@@ -166,7 +199,18 @@ impl A {\n struct A { the_field: u32 }\n fn foo(a: A) { a.$0() }\n \"#,\n-            expect![[\"\"]],\n+            expect![[r#\"\n+                sn ref   &expr\n+                sn refm  &mut expr\n+                sn match match expr {}\n+                sn box   Box::new(expr)\n+                sn ok    Ok(expr)\n+                sn err   Err(expr)\n+                sn some  Some(expr)\n+                sn dbg   dbg!(expr)\n+                sn dbgr  dbg!(&expr)\n+                sn call  function(expr)\n+            \"#]],\n         );\n     }\n \n@@ -191,6 +235,18 @@ fn foo(a: lib::m::A) { a.$0 }\n                 fd pub_field     u32\n                 fd crate_field   u32\n                 fd super_field   u32\n+                sn ref           &expr\n+                sn refm          &mut expr\n+                sn match         match expr {}\n+                sn box           Box::new(expr)\n+                sn ok            Ok(expr)\n+                sn err           Err(expr)\n+                sn some          Some(expr)\n+                sn dbg           dbg!(expr)\n+                sn dbgr          dbg!(&expr)\n+                sn call          function(expr)\n+                sn let           let\n+                sn letm          let mut\n             \"#]],\n         );\n \n@@ -210,6 +266,18 @@ fn foo(a: lib::m::A) { a.$0 }\n \"#,\n             expect![[r#\"\n                 fd pub_field u32\n+                sn ref       &expr\n+                sn refm      &mut expr\n+                sn match     match expr {}\n+                sn box       Box::new(expr)\n+                sn ok        Ok(expr)\n+                sn err       Err(expr)\n+                sn some      Some(expr)\n+                sn dbg       dbg!(expr)\n+                sn dbgr      dbg!(&expr)\n+                sn call      function(expr)\n+                sn let       let\n+                sn letm      let mut\n             \"#]],\n         );\n \n@@ -226,7 +294,19 @@ pub mod m {\n fn foo(a: lib::m::A) { a.$0 }\n \"#,\n             expect![[r#\"\n-                fd 1 f64\n+                fd 1     f64\n+                sn ref   &expr\n+                sn refm  &mut expr\n+                sn match match expr {}\n+                sn box   Box::new(expr)\n+                sn ok    Ok(expr)\n+                sn err   Err(expr)\n+                sn some  Some(expr)\n+                sn dbg   dbg!(expr)\n+                sn dbgr  dbg!(&expr)\n+                sn call  function(expr)\n+                sn let   let\n+                sn letm  let mut\n             \"#]],\n         );\n \n@@ -248,6 +328,18 @@ fn foo(a: lib::A) { a.$0 }\n                 me private_method() fn(&self)\n                 me crate_method()   fn(&self)\n                 me pub_method()     fn(&self)\n+                sn ref              &expr\n+                sn refm             &mut expr\n+                sn match            match expr {}\n+                sn box              Box::new(expr)\n+                sn ok               Ok(expr)\n+                sn err              Err(expr)\n+                sn some             Some(expr)\n+                sn dbg              dbg!(expr)\n+                sn dbgr             dbg!(&expr)\n+                sn call             function(expr)\n+                sn let              let\n+                sn letm             let mut\n             \"#]],\n         );\n         check(\n@@ -266,6 +358,18 @@ fn foo(a: lib::A) { a.$0 }\n \"#,\n             expect![[r#\"\n                 me pub_method() fn(&self)\n+                sn ref          &expr\n+                sn refm         &mut expr\n+                sn match        match expr {}\n+                sn box          Box::new(expr)\n+                sn ok           Ok(expr)\n+                sn err          Err(expr)\n+                sn some         Some(expr)\n+                sn dbg          dbg!(expr)\n+                sn dbgr         dbg!(&expr)\n+                sn call         function(expr)\n+                sn let          let\n+                sn letm         let mut\n             \"#]],\n         );\n     }\n@@ -293,6 +397,18 @@ impl A {\n             expect![[r#\"\n                 fd pub_field    u32\n                 me pub_method() fn(&self)\n+                sn ref          &expr\n+                sn refm         &mut expr\n+                sn match        match expr {}\n+                sn box          Box::new(expr)\n+                sn ok           Ok(expr)\n+                sn err          Err(expr)\n+                sn some         Some(expr)\n+                sn dbg          dbg!(expr)\n+                sn dbgr         dbg!(&expr)\n+                sn call         function(expr)\n+                sn let          let\n+                sn letm         let mut\n             \"#]],\n         )\n     }\n@@ -307,6 +423,18 @@ fn foo(u: U) { u.$0 }\n             expect![[r#\"\n                 fd field u8\n                 fd other u16\n+                sn ref   &expr\n+                sn refm  &mut expr\n+                sn match match expr {}\n+                sn box   Box::new(expr)\n+                sn ok    Ok(expr)\n+                sn err   Err(expr)\n+                sn some  Some(expr)\n+                sn dbg   dbg!(expr)\n+                sn dbgr  dbg!(&expr)\n+                sn call  function(expr)\n+                sn let   let\n+                sn letm  let mut\n             \"#]],\n         );\n     }\n@@ -326,6 +454,18 @@ fn foo(a: A<u32>) { a.$0 }\n \"#,\n             expect![[r#\"\n                 me the_method() fn(&self)\n+                sn ref          &expr\n+                sn refm         &mut expr\n+                sn match        match expr {}\n+                sn box          Box::new(expr)\n+                sn ok           Ok(expr)\n+                sn err          Err(expr)\n+                sn some         Some(expr)\n+                sn dbg          dbg!(expr)\n+                sn dbgr         dbg!(&expr)\n+                sn call         function(expr)\n+                sn let          let\n+                sn letm         let mut\n             \"#]],\n         )\n     }\n@@ -341,6 +481,18 @@ fn foo(a: A) { a.$0 }\n \"#,\n             expect![[r#\"\n                 me the_method() (as Trait) fn(&self)\n+                sn ref                    &expr\n+                sn refm                   &mut expr\n+                sn match                  match expr {}\n+                sn box                    Box::new(expr)\n+                sn ok                     Ok(expr)\n+                sn err                    Err(expr)\n+                sn some                   Some(expr)\n+                sn dbg                    dbg!(expr)\n+                sn dbgr                   dbg!(&expr)\n+                sn call                   function(expr)\n+                sn let                    let\n+                sn letm                   let mut\n             \"#]],\n         );\n         check_edit(\n@@ -371,6 +523,18 @@ fn foo(a: &A) { a.$0 }\n \",\n             expect![[r#\"\n                 me the_method() (as Trait) fn(&self)\n+                sn ref                    &expr\n+                sn refm                   &mut expr\n+                sn match                  match expr {}\n+                sn box                    Box::new(expr)\n+                sn ok                     Ok(expr)\n+                sn err                    Err(expr)\n+                sn some                   Some(expr)\n+                sn dbg                    dbg!(expr)\n+                sn dbgr                   dbg!(&expr)\n+                sn call                   function(expr)\n+                sn let                    let\n+                sn letm                   let mut\n             \"#]],\n         );\n     }\n@@ -389,6 +553,18 @@ fn foo(a: A) { a.$0 }\n \",\n             expect![[r#\"\n                 me the_method() (as Trait) fn(&self)\n+                sn ref                    &expr\n+                sn refm                   &mut expr\n+                sn match                  match expr {}\n+                sn box                    Box::new(expr)\n+                sn ok                     Ok(expr)\n+                sn err                    Err(expr)\n+                sn some                   Some(expr)\n+                sn dbg                    dbg!(expr)\n+                sn dbgr                   dbg!(&expr)\n+                sn call                   function(expr)\n+                sn let                    let\n+                sn letm                   let mut\n             \"#]],\n         );\n     }\n@@ -405,7 +581,20 @@ fn foo(a: A) {\n    a.$0\n }\n \"#,\n-            expect![[\"\"]],\n+            expect![[r#\"\n+                sn ref   &expr\n+                sn refm  &mut expr\n+                sn match match expr {}\n+                sn box   Box::new(expr)\n+                sn ok    Ok(expr)\n+                sn err   Err(expr)\n+                sn some  Some(expr)\n+                sn dbg   dbg!(expr)\n+                sn dbgr  dbg!(&expr)\n+                sn call  function(expr)\n+                sn let   let\n+                sn letm  let mut\n+            \"#]],\n         );\n     }\n \n@@ -419,8 +608,20 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n-                fd 0 i32\n-                fd 1 f64\n+                fd 0     i32\n+                fd 1     f64\n+                sn ref   &expr\n+                sn refm  &mut expr\n+                sn match match expr {}\n+                sn box   Box::new(expr)\n+                sn ok    Ok(expr)\n+                sn err   Err(expr)\n+                sn some  Some(expr)\n+                sn dbg   dbg!(expr)\n+                sn dbgr  dbg!(&expr)\n+                sn call  function(expr)\n+                sn let   let\n+                sn letm  let mut\n             \"#]],\n         );\n     }\n@@ -436,8 +637,20 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n-                fd 0 i32\n-                fd 1 f64\n+                fd 0     i32\n+                fd 1     f64\n+                sn ref   &expr\n+                sn refm  &mut expr\n+                sn match match expr {}\n+                sn box   Box::new(expr)\n+                sn ok    Ok(expr)\n+                sn err   Err(expr)\n+                sn some  Some(expr)\n+                sn dbg   dbg!(expr)\n+                sn dbgr  dbg!(&expr)\n+                sn call  function(expr)\n+                sn let   let\n+                sn letm  let mut\n             \"#]],\n         );\n     }\n@@ -460,6 +673,18 @@ impl T {\n \"#,\n             expect![[r#\"\n                 me blah() fn(&self)\n+                sn ref    &expr\n+                sn refm   &mut expr\n+                sn match  match expr {}\n+                sn box    Box::new(expr)\n+                sn ok     Ok(expr)\n+                sn err    Err(expr)\n+                sn some   Some(expr)\n+                sn dbg    dbg!(expr)\n+                sn dbgr   dbg!(&expr)\n+                sn call   function(expr)\n+                sn let    let\n+                sn letm   let mut\n             \"#]],\n         );\n     }\n@@ -475,6 +700,18 @@ const X: u32 = {\n \"#,\n             expect![[r#\"\n                 fd the_field u32\n+                sn ref       &expr\n+                sn refm      &mut expr\n+                sn match     match expr {}\n+                sn box       Box::new(expr)\n+                sn ok        Ok(expr)\n+                sn err       Err(expr)\n+                sn some      Some(expr)\n+                sn dbg       dbg!(expr)\n+                sn dbgr      dbg!(&expr)\n+                sn call      function(expr)\n+                sn let       let\n+                sn letm      let mut\n             \"#]],\n         );\n     }\n@@ -491,6 +728,16 @@ fn foo(a: A) {\n \"#,\n             expect![[r#\"\n                 fd the_field u32\n+                sn ref       &expr\n+                sn refm      &mut expr\n+                sn match     match expr {}\n+                sn box       Box::new(expr)\n+                sn ok        Ok(expr)\n+                sn err       Err(expr)\n+                sn some      Some(expr)\n+                sn dbg       dbg!(expr)\n+                sn dbgr      dbg!(&expr)\n+                sn call      function(expr)\n             \"#]],\n         );\n     }\n@@ -508,6 +755,16 @@ fn foo(a: A) {\n \"#,\n             expect![[r#\"\n                 fd the_field u32\n+                sn ref       &expr\n+                sn refm      &mut expr\n+                sn match     match expr {}\n+                sn box       Box::new(expr)\n+                sn ok        Ok(expr)\n+                sn err       Err(expr)\n+                sn some      Some(expr)\n+                sn dbg       dbg!(expr)\n+                sn dbgr      dbg!(&expr)\n+                sn call      function(expr)\n             \"#]],\n         );\n     }\n@@ -524,6 +781,16 @@ fn foo(a: A) {\n \"#,\n             expect![[r#\"\n                 fd the_field u32\n+                sn ref       &expr\n+                sn refm      &mut expr\n+                sn match     match expr {}\n+                sn box       Box::new(expr)\n+                sn ok        Ok(expr)\n+                sn err       Err(expr)\n+                sn some      Some(expr)\n+                sn dbg       dbg!(expr)\n+                sn dbgr      dbg!(&expr)\n+                sn call      function(expr)\n             \"#]],\n         );\n     }\n@@ -550,6 +817,16 @@ fn foo(a: A) {\n \"#,\n             expect![[r#\"\n                 fd the_field u32\n+                sn ref       &expr\n+                sn refm      &mut expr\n+                sn match     match expr {}\n+                sn box       Box::new(expr)\n+                sn ok        Ok(expr)\n+                sn err       Err(expr)\n+                sn some      Some(expr)\n+                sn dbg       dbg!(expr)\n+                sn dbgr      dbg!(&expr)\n+                sn call      function(expr)\n             \"#]],\n         );\n     }\n@@ -569,6 +846,18 @@ fn foo() {\n \"#,\n             expect![[r#\"\n                 me the_method() fn(&self)\n+                sn ref          &expr\n+                sn refm         &mut expr\n+                sn match        match expr {}\n+                sn box          Box::new(expr)\n+                sn ok           Ok(expr)\n+                sn err          Err(expr)\n+                sn some         Some(expr)\n+                sn dbg          dbg!(expr)\n+                sn dbgr         dbg!(&expr)\n+                sn call         function(expr)\n+                sn let          let\n+                sn letm         let mut\n             \"#]],\n         );\n     }\n@@ -584,6 +873,18 @@ fn main() { make_s!().f$0; }\n \"#,\n             expect![[r#\"\n                 me foo() fn(&self)\n+                sn ref   &expr\n+                sn refm  &mut expr\n+                sn match match expr {}\n+                sn box   Box::new(expr)\n+                sn ok    Ok(expr)\n+                sn err   Err(expr)\n+                sn some  Some(expr)\n+                sn dbg   dbg!(expr)\n+                sn dbgr  dbg!(&expr)\n+                sn call  function(expr)\n+                sn let   let\n+                sn letm  let mut\n             \"#]],\n         )\n     }\n@@ -612,6 +913,18 @@ mod foo {\n         \"#,\n             expect![[r#\"\n                 me private() fn(&self)\n+                sn ref       &expr\n+                sn refm      &mut expr\n+                sn match     match expr {}\n+                sn box       Box::new(expr)\n+                sn ok        Ok(expr)\n+                sn err       Err(expr)\n+                sn some      Some(expr)\n+                sn dbg       dbg!(expr)\n+                sn dbgr      dbg!(&expr)\n+                sn call      function(expr)\n+                sn let       let\n+                sn letm      let mut\n             \"#]],\n         );\n     }\n@@ -639,6 +952,16 @@ impl S {\n         \"#,\n             expect![[r#\"\n                 me foo() fn(&self) -> &[u8]\n+                sn ref   &expr\n+                sn refm  &mut expr\n+                sn match match expr {}\n+                sn box   Box::new(expr)\n+                sn ok    Ok(expr)\n+                sn err   Err(expr)\n+                sn some  Some(expr)\n+                sn dbg   dbg!(expr)\n+                sn dbgr  dbg!(&expr)\n+                sn call  function(expr)\n             \"#]],\n         );\n     }\n@@ -654,6 +977,7 @@ impl Foo { fn foo(&self) { $0 } }\"#,\n                 lc self       &Foo\n                 sp Self\n                 st Foo\n+                bt u32\n                 fd self.field i32\n                 me self.foo() fn(&self)\n             \"#]],\n@@ -667,6 +991,7 @@ impl Foo { fn foo(&mut self) { $0 } }\"#,\n                 lc self       &mut Foo\n                 sp Self\n                 st Foo\n+                bt u32\n                 fd self.0     i32\n                 me self.foo() fn(&mut self)\n             \"#]],\n@@ -694,6 +1019,16 @@ fn f() {\n     \"#,\n             expect![[r#\"\n                 me method() fn(&self)\n+                sn ref      &expr\n+                sn refm     &mut expr\n+                sn match    match expr {}\n+                sn box      Box::new(expr)\n+                sn ok       Ok(expr)\n+                sn err      Err(expr)\n+                sn some     Some(expr)\n+                sn dbg      dbg!(expr)\n+                sn dbgr     dbg!(&expr)\n+                sn call     function(expr)\n             \"#]],\n         );\n     }\n@@ -716,6 +1051,18 @@ fn main() {\n \"#,\n             expect![[r#\"\n                 me into_iter() (as IntoIterator) fn(self) -> <Self as IntoIterator>::IntoIter\n+                sn ref                    &expr\n+                sn refm                   &mut expr\n+                sn match                  match expr {}\n+                sn box                    Box::new(expr)\n+                sn ok                     Ok(expr)\n+                sn err                    Err(expr)\n+                sn some                   Some(expr)\n+                sn dbg                    dbg!(expr)\n+                sn dbgr                   dbg!(&expr)\n+                sn call                   function(expr)\n+                sn let                    let\n+                sn letm                   let mut\n             \"#]],\n         )\n     }"}, {"sha": "486cbff685988cb54c0ebc5aad08b14da2fe3f47", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 0, "deletions": 1015, "changes": 1015, "blob_url": "https://github.com/rust-lang/rust/blob/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=722489e3ff4c16dc179d30e729847314c918511f", "patch": "@@ -219,1018 +219,3 @@ fn compute_fuzzy_completion_order_key(\n         None => usize::MAX,\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use expect_test::{expect, Expect};\n-\n-    use crate::{\n-        item::CompletionKind,\n-        tests::{check_edit, check_edit_with_config, filtered_completion_list, TEST_CONFIG},\n-    };\n-\n-    fn check(ra_fixture: &str, expect: Expect) {\n-        let actual = filtered_completion_list(ra_fixture, CompletionKind::Magic);\n-        expect.assert_eq(&actual);\n-    }\n-\n-    #[test]\n-    fn function_fuzzy_completion() {\n-        check_edit(\n-            \"stdin\",\n-            r#\"\n-//- /lib.rs crate:dep\n-pub mod io {\n-    pub fn stdin() {}\n-};\n-\n-//- /main.rs crate:main deps:dep\n-fn main() {\n-    stdi$0\n-}\n-\"#,\n-            r#\"\n-use dep::io::stdin;\n-\n-fn main() {\n-    stdin()$0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn macro_fuzzy_completion() {\n-        check_edit(\n-            \"macro_with_curlies!\",\n-            r#\"\n-//- /lib.rs crate:dep\n-/// Please call me as macro_with_curlies! {}\n-#[macro_export]\n-macro_rules! macro_with_curlies {\n-    () => {}\n-}\n-\n-//- /main.rs crate:main deps:dep\n-fn main() {\n-    curli$0\n-}\n-\"#,\n-            r#\"\n-use dep::macro_with_curlies;\n-\n-fn main() {\n-    macro_with_curlies! {$0}\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn struct_fuzzy_completion() {\n-        check_edit(\n-            \"ThirdStruct\",\n-            r#\"\n-//- /lib.rs crate:dep\n-pub struct FirstStruct;\n-pub mod some_module {\n-    pub struct SecondStruct;\n-    pub struct ThirdStruct;\n-}\n-\n-//- /main.rs crate:main deps:dep\n-use dep::{FirstStruct, some_module::SecondStruct};\n-\n-fn main() {\n-    this$0\n-}\n-\"#,\n-            r#\"\n-use dep::{FirstStruct, some_module::{SecondStruct, ThirdStruct}};\n-\n-fn main() {\n-    ThirdStruct\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn short_paths_are_ignored() {\n-        cov_mark::check!(ignore_short_input_for_path);\n-\n-        check(\n-            r#\"\n-//- /lib.rs crate:dep\n-pub struct FirstStruct;\n-pub mod some_module {\n-    pub struct SecondStruct;\n-    pub struct ThirdStruct;\n-}\n-\n-//- /main.rs crate:main deps:dep\n-use dep::{FirstStruct, some_module::SecondStruct};\n-\n-fn main() {\n-    t$0\n-}\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn fuzzy_completions_come_in_specific_order() {\n-        cov_mark::check!(certain_fuzzy_order_test);\n-        check(\n-            r#\"\n-//- /lib.rs crate:dep\n-pub struct FirstStruct;\n-pub mod some_module {\n-    // already imported, omitted\n-    pub struct SecondStruct;\n-    // does not contain all letters from the query, omitted\n-    pub struct UnrelatedOne;\n-    // contains all letters from the query, but not in sequence, displayed last\n-    pub struct ThiiiiiirdStruct;\n-    // contains all letters from the query, but not in the beginning, displayed second\n-    pub struct AfterThirdStruct;\n-    // contains all letters from the query in the begginning, displayed first\n-    pub struct ThirdStruct;\n-}\n-\n-//- /main.rs crate:main deps:dep\n-use dep::{FirstStruct, some_module::SecondStruct};\n-\n-fn main() {\n-    hir$0\n-}\n-\"#,\n-            expect![[r#\"\n-                st ThirdStruct (use dep::some_module::ThirdStruct)\n-                st AfterThirdStruct (use dep::some_module::AfterThirdStruct)\n-                st ThiiiiiirdStruct (use dep::some_module::ThiiiiiirdStruct)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn trait_function_fuzzy_completion() {\n-        let fixture = r#\"\n-        //- /lib.rs crate:dep\n-        pub mod test_mod {\n-            pub trait TestTrait {\n-                const SPECIAL_CONST: u8;\n-                type HumbleType;\n-                fn weird_function();\n-                fn random_method(&self);\n-            }\n-            pub struct TestStruct {}\n-            impl TestTrait for TestStruct {\n-                const SPECIAL_CONST: u8 = 42;\n-                type HumbleType = ();\n-                fn weird_function() {}\n-                fn random_method(&self) {}\n-            }\n-        }\n-\n-        //- /main.rs crate:main deps:dep\n-        fn main() {\n-            dep::test_mod::TestStruct::wei$0\n-        }\n-        \"#;\n-\n-        check(\n-            fixture,\n-            expect![[r#\"\n-                fn weird_function() (use dep::test_mod::TestTrait) fn()\n-            \"#]],\n-        );\n-\n-        check_edit(\n-            \"weird_function\",\n-            fixture,\n-            r#\"\n-use dep::test_mod::TestTrait;\n-\n-fn main() {\n-    dep::test_mod::TestStruct::weird_function()$0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn trait_const_fuzzy_completion() {\n-        let fixture = r#\"\n-        //- /lib.rs crate:dep\n-        pub mod test_mod {\n-            pub trait TestTrait {\n-                const SPECIAL_CONST: u8;\n-                type HumbleType;\n-                fn weird_function();\n-                fn random_method(&self);\n-            }\n-            pub struct TestStruct {}\n-            impl TestTrait for TestStruct {\n-                const SPECIAL_CONST: u8 = 42;\n-                type HumbleType = ();\n-                fn weird_function() {}\n-                fn random_method(&self) {}\n-            }\n-        }\n-\n-        //- /main.rs crate:main deps:dep\n-        fn main() {\n-            dep::test_mod::TestStruct::spe$0\n-        }\n-        \"#;\n-\n-        check(\n-            fixture,\n-            expect![[r#\"\n-            ct SPECIAL_CONST (use dep::test_mod::TestTrait)\n-        \"#]],\n-        );\n-\n-        check_edit(\n-            \"SPECIAL_CONST\",\n-            fixture,\n-            r#\"\n-use dep::test_mod::TestTrait;\n-\n-fn main() {\n-    dep::test_mod::TestStruct::SPECIAL_CONST\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn trait_method_fuzzy_completion() {\n-        let fixture = r#\"\n-        //- /lib.rs crate:dep\n-        pub mod test_mod {\n-            pub trait TestTrait {\n-                const SPECIAL_CONST: u8;\n-                type HumbleType;\n-                fn weird_function();\n-                fn random_method(&self);\n-            }\n-            pub struct TestStruct {}\n-            impl TestTrait for TestStruct {\n-                const SPECIAL_CONST: u8 = 42;\n-                type HumbleType = ();\n-                fn weird_function() {}\n-                fn random_method(&self) {}\n-            }\n-        }\n-\n-        //- /main.rs crate:main deps:dep\n-        fn main() {\n-            let test_struct = dep::test_mod::TestStruct {};\n-            test_struct.ran$0\n-        }\n-        \"#;\n-\n-        check(\n-            fixture,\n-            expect![[r#\"\n-                me random_method() (use dep::test_mod::TestTrait) fn(&self)\n-            \"#]],\n-        );\n-\n-        check_edit(\n-            \"random_method\",\n-            fixture,\n-            r#\"\n-use dep::test_mod::TestTrait;\n-\n-fn main() {\n-    let test_struct = dep::test_mod::TestStruct {};\n-    test_struct.random_method()$0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_trait_type_fuzzy_completion() {\n-        check(\n-            r#\"\n-//- /lib.rs crate:dep\n-pub mod test_mod {\n-    pub trait TestTrait {\n-        const SPECIAL_CONST: u8;\n-        type HumbleType;\n-        fn weird_function();\n-        fn random_method(&self);\n-    }\n-    pub struct TestStruct {}\n-    impl TestTrait for TestStruct {\n-        const SPECIAL_CONST: u8 = 42;\n-        type HumbleType = ();\n-        fn weird_function() {}\n-        fn random_method(&self) {}\n-    }\n-}\n-\n-//- /main.rs crate:main deps:dep\n-fn main() {\n-    dep::test_mod::TestStruct::hum$0\n-}\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn does_not_propose_names_in_scope() {\n-        check(\n-            r#\"\n-//- /lib.rs crate:dep\n-pub mod test_mod {\n-    pub trait TestTrait {\n-        const SPECIAL_CONST: u8;\n-        type HumbleType;\n-        fn weird_function();\n-        fn random_method(&self);\n-    }\n-    pub struct TestStruct {}\n-    impl TestTrait for TestStruct {\n-        const SPECIAL_CONST: u8 = 42;\n-        type HumbleType = ();\n-        fn weird_function() {}\n-        fn random_method(&self) {}\n-    }\n-}\n-\n-//- /main.rs crate:main deps:dep\n-use dep::test_mod::TestStruct;\n-fn main() {\n-    TestSt$0\n-}\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn does_not_propose_traits_in_scope() {\n-        check(\n-            r#\"\n-//- /lib.rs crate:dep\n-pub mod test_mod {\n-    pub trait TestTrait {\n-        const SPECIAL_CONST: u8;\n-        type HumbleType;\n-        fn weird_function();\n-        fn random_method(&self);\n-    }\n-    pub struct TestStruct {}\n-    impl TestTrait for TestStruct {\n-        const SPECIAL_CONST: u8 = 42;\n-        type HumbleType = ();\n-        fn weird_function() {}\n-        fn random_method(&self) {}\n-    }\n-}\n-\n-//- /main.rs crate:main deps:dep\n-use dep::test_mod::{TestStruct, TestTrait};\n-fn main() {\n-    dep::test_mod::TestStruct::hum$0\n-}\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn blanket_trait_impl_import() {\n-        check_edit(\n-            \"another_function\",\n-            r#\"\n-//- /lib.rs crate:dep\n-pub mod test_mod {\n-    pub struct TestStruct {}\n-    pub trait TestTrait {\n-        fn another_function();\n-    }\n-    impl<T> TestTrait for T {\n-        fn another_function() {}\n-    }\n-}\n-\n-//- /main.rs crate:main deps:dep\n-fn main() {\n-    dep::test_mod::TestStruct::ano$0\n-}\n-\"#,\n-            r#\"\n-use dep::test_mod::TestTrait;\n-\n-fn main() {\n-    dep::test_mod::TestStruct::another_function()$0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn zero_input_deprecated_assoc_item_completion() {\n-        check(\n-            r#\"\n-//- /lib.rs crate:dep\n-pub mod test_mod {\n-    #[deprecated]\n-    pub trait TestTrait {\n-        const SPECIAL_CONST: u8;\n-        type HumbleType;\n-        fn weird_function();\n-        fn random_method(&self);\n-    }\n-    pub struct TestStruct {}\n-    impl TestTrait for TestStruct {\n-        const SPECIAL_CONST: u8 = 42;\n-        type HumbleType = ();\n-        fn weird_function() {}\n-        fn random_method(&self) {}\n-    }\n-}\n-\n-//- /main.rs crate:main deps:dep\n-fn main() {\n-    let test_struct = dep::test_mod::TestStruct {};\n-    test_struct.$0\n-}\n-        \"#,\n-            expect![[r#\"\n-                me random_method() (use dep::test_mod::TestTrait) fn(&self) DEPRECATED\n-            \"#]],\n-        );\n-\n-        check(\n-            r#\"\n-//- /lib.rs crate:dep\n-pub mod test_mod {\n-    #[deprecated]\n-    pub trait TestTrait {\n-        const SPECIAL_CONST: u8;\n-        type HumbleType;\n-        fn weird_function();\n-        fn random_method(&self);\n-    }\n-    pub struct TestStruct {}\n-    impl TestTrait for TestStruct {\n-        const SPECIAL_CONST: u8 = 42;\n-        type HumbleType = ();\n-        fn weird_function() {}\n-        fn random_method(&self) {}\n-    }\n-}\n-\n-//- /main.rs crate:main deps:dep\n-fn main() {\n-    dep::test_mod::TestStruct::$0\n-}\n-\"#,\n-            expect![[r#\"\n-                fn weird_function() (use dep::test_mod::TestTrait) fn() DEPRECATED\n-                ct SPECIAL_CONST (use dep::test_mod::TestTrait) DEPRECATED\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn no_completions_in_use_statements() {\n-        check(\n-            r#\"\n-//- /lib.rs crate:dep\n-pub mod io {\n-    pub fn stdin() {}\n-};\n-\n-//- /main.rs crate:main deps:dep\n-use stdi$0\n-\n-fn main() {}\n-\"#,\n-            expect![[]],\n-        );\n-    }\n-\n-    #[test]\n-    fn prefix_config_usage() {\n-        let fixture = r#\"\n-mod foo {\n-    pub mod bar {\n-        pub struct Item;\n-    }\n-}\n-\n-use crate::foo::bar;\n-\n-fn main() {\n-    Ite$0\n-}\"#;\n-        let mut config = TEST_CONFIG;\n-\n-        config.insert_use.prefix_kind = hir::PrefixKind::ByCrate;\n-        check_edit_with_config(\n-            config.clone(),\n-            \"Item\",\n-            fixture,\n-            r#\"\n-mod foo {\n-    pub mod bar {\n-        pub struct Item;\n-    }\n-}\n-\n-use crate::foo::bar::{self, Item};\n-\n-fn main() {\n-    Item\n-}\"#,\n-        );\n-\n-        config.insert_use.prefix_kind = hir::PrefixKind::BySelf;\n-        check_edit_with_config(\n-            config.clone(),\n-            \"Item\",\n-            fixture,\n-            r#\"\n-mod foo {\n-    pub mod bar {\n-        pub struct Item;\n-    }\n-}\n-\n-use crate::foo::bar;\n-\n-use self::foo::bar::Item;\n-\n-fn main() {\n-    Item\n-}\"#,\n-        );\n-\n-        config.insert_use.prefix_kind = hir::PrefixKind::Plain;\n-        check_edit_with_config(\n-            config,\n-            \"Item\",\n-            fixture,\n-            r#\"\n-mod foo {\n-    pub mod bar {\n-        pub struct Item;\n-    }\n-}\n-\n-use foo::bar::Item;\n-\n-use crate::foo::bar;\n-\n-fn main() {\n-    Item\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unresolved_qualifier() {\n-        let fixture = r#\"\n-mod foo {\n-    pub mod bar {\n-        pub mod baz {\n-            pub struct Item;\n-        }\n-    }\n-}\n-\n-fn main() {\n-    bar::baz::Ite$0\n-}\"#;\n-\n-        check(\n-            fixture,\n-            expect![[r#\"\n-        st Item (use foo::bar::baz::Item)\n-        \"#]],\n-        );\n-\n-        check_edit(\n-            \"Item\",\n-            fixture,\n-            r#\"\n-        use foo::bar;\n-\n-        mod foo {\n-            pub mod bar {\n-                pub mod baz {\n-                    pub struct Item;\n-                }\n-            }\n-        }\n-\n-        fn main() {\n-            bar::baz::Item\n-        }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unresolved_assoc_item_container() {\n-        let fixture = r#\"\n-mod foo {\n-    pub struct Item;\n-\n-    impl Item {\n-        pub const TEST_ASSOC: usize = 3;\n-    }\n-}\n-\n-fn main() {\n-    Item::TEST_A$0\n-}\"#;\n-\n-        check(\n-            fixture,\n-            expect![[r#\"\n-        ct TEST_ASSOC (use foo::Item)\n-        \"#]],\n-        );\n-\n-        check_edit(\n-            \"TEST_ASSOC\",\n-            fixture,\n-            r#\"\n-use foo::Item;\n-\n-mod foo {\n-    pub struct Item;\n-\n-    impl Item {\n-        pub const TEST_ASSOC: usize = 3;\n-    }\n-}\n-\n-fn main() {\n-    Item::TEST_ASSOC\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unresolved_assoc_item_container_with_path() {\n-        let fixture = r#\"\n-mod foo {\n-    pub mod bar {\n-        pub struct Item;\n-\n-        impl Item {\n-            pub const TEST_ASSOC: usize = 3;\n-        }\n-    }\n-}\n-\n-fn main() {\n-    bar::Item::TEST_A$0\n-}\"#;\n-\n-        check(\n-            fixture,\n-            expect![[r#\"\n-        ct TEST_ASSOC (use foo::bar::Item)\n-    \"#]],\n-        );\n-\n-        check_edit(\n-            \"TEST_ASSOC\",\n-            fixture,\n-            r#\"\n-use foo::bar;\n-\n-mod foo {\n-    pub mod bar {\n-        pub struct Item;\n-\n-        impl Item {\n-            pub const TEST_ASSOC: usize = 3;\n-        }\n-    }\n-}\n-\n-fn main() {\n-    bar::Item::TEST_ASSOC\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn fuzzy_unresolved_path() {\n-        check(\n-            r#\"\n-mod foo {\n-    pub mod bar {\n-        pub struct Item;\n-\n-        impl Item {\n-            pub const TEST_ASSOC: usize = 3;\n-        }\n-    }\n-}\n-\n-fn main() {\n-    bar::ASS$0\n-}\"#,\n-            expect![[]],\n-        )\n-    }\n-\n-    #[test]\n-    fn unqualified_assoc_items_are_omitted() {\n-        check(\n-            r#\"\n-mod something {\n-    pub trait BaseTrait {\n-        fn test_function() -> i32;\n-    }\n-\n-    pub struct Item1;\n-    pub struct Item2;\n-\n-    impl BaseTrait for Item1 {\n-        fn test_function() -> i32 {\n-            1\n-        }\n-    }\n-\n-    impl BaseTrait for Item2 {\n-        fn test_function() -> i32 {\n-            2\n-        }\n-    }\n-}\n-\n-fn main() {\n-    test_f$0\n-}\"#,\n-            expect![[]],\n-        )\n-    }\n-\n-    #[test]\n-    fn case_matters() {\n-        check(\n-            r#\"\n-mod foo {\n-    pub const TEST_CONST: usize = 3;\n-    pub fn test_function() -> i32 {\n-        4\n-    }\n-}\n-\n-fn main() {\n-    TE$0\n-}\"#,\n-            expect![[r#\"\n-        ct TEST_CONST (use foo::TEST_CONST)\n-    \"#]],\n-        );\n-\n-        check(\n-            r#\"\n-mod foo {\n-    pub const TEST_CONST: usize = 3;\n-    pub fn test_function() -> i32 {\n-        4\n-    }\n-}\n-\n-fn main() {\n-    te$0\n-}\"#,\n-            expect![[r#\"\n-        ct TEST_CONST (use foo::TEST_CONST)\n-        fn test_function() (use foo::test_function) fn() -> i32\n-    \"#]],\n-        );\n-\n-        check(\n-            r#\"\n-mod foo {\n-    pub const TEST_CONST: usize = 3;\n-    pub fn test_function() -> i32 {\n-        4\n-    }\n-}\n-\n-fn main() {\n-    Te$0\n-}\"#,\n-            expect![[]],\n-        );\n-    }\n-\n-    #[test]\n-    fn no_fuzzy_during_fields_of_record_lit_syntax() {\n-        check(\n-            r#\"\n-mod m {\n-    pub fn some_fn() -> i32 {\n-        42\n-    }\n-}\n-struct Foo {\n-    some_field: i32,\n-}\n-fn main() {\n-    let _ = Foo { so$0 };\n-}\n-\"#,\n-            expect![[]],\n-        );\n-    }\n-\n-    #[test]\n-    fn fuzzy_after_fields_of_record_lit_syntax() {\n-        check(\n-            r#\"\n-mod m {\n-    pub fn some_fn() -> i32 {\n-        42\n-    }\n-}\n-struct Foo {\n-    some_field: i32,\n-}\n-fn main() {\n-    let _ = Foo { some_field: so$0 };\n-}\n-\"#,\n-            expect![[r#\"\n-                fn some_fn() (use m::some_fn) fn() -> i32\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn no_flyimports_in_traits_and_impl_declarations() {\n-        check(\n-            r#\"\n-mod m {\n-    pub fn some_fn() -> i32 {\n-        42\n-    }\n-}\n-trait Foo {\n-    som$0\n-}\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-\n-        check(\n-            r#\"\n-mod m {\n-    pub fn some_fn() -> i32 {\n-        42\n-    }\n-}\n-struct Foo;\n-impl Foo {\n-    som$0\n-}\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-\n-        check(\n-            r#\"\n-mod m {\n-    pub fn some_fn() -> i32 {\n-        42\n-    }\n-}\n-struct Foo;\n-trait Bar {}\n-impl Bar for Foo {\n-    som$0\n-}\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn no_inherent_candidates_proposed() {\n-        check(\n-            r#\"\n-mod baz {\n-    pub trait DefDatabase {\n-        fn method1(&self);\n-    }\n-    pub trait HirDatabase: DefDatabase {\n-        fn method2(&self);\n-    }\n-}\n-\n-mod bar {\n-    fn test(db: &dyn crate::baz::HirDatabase) {\n-        db.metho$0\n-    }\n-}\n-            \"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn respects_doc_hidden() {\n-        check(\n-            r#\"\n-//- /lib.rs crate:lib deps:dep\n-fn f() {\n-    ().fro$0\n-}\n-\n-//- /dep.rs crate:dep\n-#[doc(hidden)]\n-pub trait Private {\n-    fn frob(&self) {}\n-}\n-\n-impl<T> Private for T {}\n-            \"#,\n-            expect![[r#\"\"#]],\n-        );\n-        check(\n-            r#\"\n-//- /lib.rs crate:lib deps:dep\n-fn f() {\n-    ().fro$0\n-}\n-\n-//- /dep.rs crate:dep\n-pub trait Private {\n-    #[doc(hidden)]\n-    fn frob(&self) {}\n-}\n-\n-impl<T> Private for T {}\n-            \"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn regression_9760() {\n-        check(\n-            r#\"\n-struct Struct;\n-fn main() {}\n-\n-mod mud {\n-    fn func() {\n-        let struct_instance = Stru$0\n-    }\n-}\n-\"#,\n-            expect![[r#\"\n-                st Struct (use crate::Struct)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn flyimport_pattern() {\n-        check(\n-            r#\"\n-mod module {\n-    pub struct Struct;\n-}\n-fn function() {\n-    let Str$0\n-}\n-\"#,\n-            expect![[r#\"\n-                st Struct (use module::Struct)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn flyimport_rename() {\n-        check(\n-            r#\"\n-mod module {\n-    pub struct Struct;\n-}\n-use self as Str$0;\n-    \"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-}"}, {"sha": "4fd622f3995592d24a5c548d5370da047eb02232", "filename": "crates/ide_completion/src/completions/keyword.rs", "status": "modified", "additions": 29, "deletions": 266, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=722489e3ff4c16dc179d30e729847314c918511f", "patch": "@@ -181,115 +181,15 @@ fn add_keyword(ctx: &CompletionContext, acc: &mut Completions, kw: &str, snippet\n mod tests {\n     use expect_test::{expect, Expect};\n \n-    use crate::{\n-        tests::{check_edit, filtered_completion_list},\n-        CompletionKind,\n-    };\n+    use crate::tests::{check_edit, completion_list};\n \n     fn check(ra_fixture: &str, expect: Expect) {\n-        let actual = filtered_completion_list(ra_fixture, CompletionKind::Keyword);\n+        let actual = completion_list(ra_fixture);\n         expect.assert_eq(&actual)\n     }\n \n     #[test]\n-    fn test_keywords_in_function() {\n-        check(\n-            r\"fn quux() { $0 }\",\n-            expect![[r#\"\n-                kw unsafe\n-                kw fn\n-                kw const\n-                kw type\n-                kw impl\n-                kw extern\n-                kw use\n-                kw trait\n-                kw static\n-                kw mod\n-                kw match\n-                kw while\n-                kw while let\n-                kw loop\n-                kw if\n-                kw if let\n-                kw for\n-                kw true\n-                kw false\n-                kw let\n-                kw return\n-                kw self\n-                kw super\n-                kw crate\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_keywords_inside_block() {\n-        check(\n-            r\"fn quux() { if true { $0 } }\",\n-            expect![[r#\"\n-                kw unsafe\n-                kw fn\n-                kw const\n-                kw type\n-                kw impl\n-                kw extern\n-                kw use\n-                kw trait\n-                kw static\n-                kw mod\n-                kw match\n-                kw while\n-                kw while let\n-                kw loop\n-                kw if\n-                kw if let\n-                kw for\n-                kw true\n-                kw false\n-                kw let\n-                kw return\n-                kw self\n-                kw super\n-                kw crate\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_keywords_after_if() {\n-        check(\n-            r#\"fn quux() { if true { () } $0 }\"#,\n-            expect![[r#\"\n-                kw unsafe\n-                kw fn\n-                kw const\n-                kw type\n-                kw impl\n-                kw extern\n-                kw use\n-                kw trait\n-                kw static\n-                kw mod\n-                kw match\n-                kw while\n-                kw while let\n-                kw loop\n-                kw if\n-                kw if let\n-                kw for\n-                kw true\n-                kw false\n-                kw let\n-                kw else\n-                kw else if\n-                kw return\n-                kw self\n-                kw super\n-                kw crate\n-            \"#]],\n-        );\n+    fn test_else_edit_after_if() {\n         check_edit(\n             \"else\",\n             r#\"fn quux() { if true { () } $0 }\"#,\n@@ -299,68 +199,6 @@ mod tests {\n         );\n     }\n \n-    #[test]\n-    fn test_keywords_in_match_arm() {\n-        check(\n-            r#\"\n-fn quux() -> i32 {\n-    match () { () => $0 }\n-}\n-\"#,\n-            expect![[r#\"\n-                kw unsafe\n-                kw match\n-                kw while\n-                kw while let\n-                kw loop\n-                kw if\n-                kw if let\n-                kw for\n-                kw true\n-                kw false\n-                kw return\n-                kw self\n-                kw super\n-                kw crate\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_keywords_in_loop() {\n-        check(\n-            r\"fn my() { loop { $0 } }\",\n-            expect![[r#\"\n-                kw unsafe\n-                kw fn\n-                kw const\n-                kw type\n-                kw impl\n-                kw extern\n-                kw use\n-                kw trait\n-                kw static\n-                kw mod\n-                kw match\n-                kw while\n-                kw while let\n-                kw loop\n-                kw if\n-                kw if let\n-                kw for\n-                kw true\n-                kw false\n-                kw let\n-                kw continue\n-                kw break\n-                kw return\n-                kw self\n-                kw super\n-                kw crate\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn test_keywords_after_unsafe_in_block_expr() {\n         check(\n@@ -369,38 +207,12 @@ fn quux() -> i32 {\n                 kw fn\n                 kw trait\n                 kw impl\n+                sn pd\n+                sn ppd\n             \"#]],\n         );\n     }\n \n-    #[test]\n-    fn no_keyword_completion_in_comments() {\n-        cov_mark::check!(no_keyword_completion_in_comments);\n-        check(\n-            r#\"\n-fn test() {\n-    let x = 2; // A comment$0\n-}\n-\"#,\n-            expect![[\"\"]],\n-        );\n-        check(\n-            r#\"\n-/*\n-Some multi-line comment$0\n-*/\n-\"#,\n-            expect![[\"\"]],\n-        );\n-        check(\n-            r#\"\n-/// Some doc comment\n-/// let test$0 = 1\n-\"#,\n-            expect![[\"\"]],\n-        );\n-    }\n-\n     #[test]\n     fn test_completion_await_impls_future() {\n         check(\n@@ -413,6 +225,18 @@ fn foo(a: A) { a.$0 }\n \"#,\n             expect![[r#\"\n                 kw await expr.await\n+                sn ref   &expr\n+                sn refm  &mut expr\n+                sn match match expr {}\n+                sn box   Box::new(expr)\n+                sn ok    Ok(expr)\n+                sn err   Err(expr)\n+                sn some  Some(expr)\n+                sn dbg   dbg!(expr)\n+                sn dbgr  dbg!(&expr)\n+                sn call  function(expr)\n+                sn let   let\n+                sn letm  let mut\n             \"#]],\n         );\n \n@@ -427,83 +251,22 @@ fn foo() {\n \"#,\n             expect![[r#\"\n                 kw await expr.await\n+                sn ref   &expr\n+                sn refm  &mut expr\n+                sn match match expr {}\n+                sn box   Box::new(expr)\n+                sn ok    Ok(expr)\n+                sn err   Err(expr)\n+                sn some  Some(expr)\n+                sn dbg   dbg!(expr)\n+                sn dbgr  dbg!(&expr)\n+                sn call  function(expr)\n+                sn let   let\n+                sn letm  let mut\n             \"#]],\n         )\n     }\n \n-    #[test]\n-    fn after_let() {\n-        check(\n-            r#\"fn main() { let _ = $0 }\"#,\n-            expect![[r#\"\n-                kw unsafe\n-                kw match\n-                kw while\n-                kw while let\n-                kw loop\n-                kw if\n-                kw if let\n-                kw for\n-                kw true\n-                kw false\n-                kw return\n-                kw self\n-                kw super\n-                kw crate\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn skip_struct_initializer() {\n-        cov_mark::check!(no_keyword_completion_in_record_lit);\n-        check(\n-            r#\"\n-struct Foo {\n-    pub f: i32,\n-}\n-fn foo() {\n-    Foo {\n-        $0\n-    }\n-}\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn struct_initializer_field_expr() {\n-        check(\n-            r#\"\n-struct Foo {\n-    pub f: i32,\n-}\n-fn foo() {\n-    Foo {\n-        f: $0\n-    }\n-}\n-\"#,\n-            expect![[r#\"\n-                kw unsafe\n-                kw match\n-                kw while\n-                kw while let\n-                kw loop\n-                kw if\n-                kw if let\n-                kw for\n-                kw true\n-                kw false\n-                kw return\n-                kw self\n-                kw super\n-                kw crate\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn let_semi() {\n         cov_mark::check!(let_semi);"}, {"sha": "c26fa42d1b6b77150cbcf269cf69bad411104179", "filename": "crates/ide_completion/src/completions/mod_.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fmod_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fmod_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fmod_.rs?ref=722489e3ff4c16dc179d30e729847314c918511f", "patch": "@@ -141,9 +141,10 @@ fn module_chain_to_containing_module_file(\n \n #[cfg(test)]\n mod tests {\n-    use crate::tests::completion_list;\n     use expect_test::{expect, Expect};\n \n+    use crate::tests::completion_list;\n+\n     fn check(ra_fixture: &str, expect: Expect) {\n         let actual = completion_list(ra_fixture);\n         expect.assert_eq(&actual);"}, {"sha": "87b5d6c4720cb48b2e524e70b3c8785d0c680e6d", "filename": "crates/ide_completion/src/completions/postfix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs?ref=722489e3ff4c16dc179d30e729847314c918511f", "patch": "@@ -270,12 +270,12 @@ mod tests {\n     use expect_test::{expect, Expect};\n \n     use crate::{\n-        tests::{check_edit, check_edit_with_config, filtered_completion_list, TEST_CONFIG},\n-        CompletionConfig, CompletionKind, Snippet,\n+        tests::{check_edit, check_edit_with_config, completion_list, TEST_CONFIG},\n+        CompletionConfig, Snippet,\n     };\n \n     fn check(ra_fixture: &str, expect: Expect) {\n-        let actual = filtered_completion_list(ra_fixture, CompletionKind::Postfix);\n+        let actual = completion_list(ra_fixture);\n         expect.assert_eq(&actual)\n     }\n "}, {"sha": "e9d39edc43a28a48f047688d77c2a957109cb694", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=722489e3ff4c16dc179d30e729847314c918511f", "patch": "@@ -250,13 +250,10 @@ fn add_enum_variants(acc: &mut Completions, ctx: &CompletionContext, e: hir::Enu\n mod tests {\n     use expect_test::{expect, Expect};\n \n-    use crate::{\n-        tests::{check_edit, filtered_completion_list},\n-        CompletionKind,\n-    };\n+    use crate::tests::{check_edit, completion_list_no_kw};\n \n     fn check(ra_fixture: &str, expect: Expect) {\n-        let actual = filtered_completion_list(ra_fixture, CompletionKind::Reference);\n+        let actual = completion_list_no_kw(ra_fixture);\n         expect.assert_eq(&actual);\n     }\n "}, {"sha": "37fa001e0cd09fe058ca0c4a90ffee67ee569f4f", "filename": "crates/ide_completion/src/completions/trait_impl.rs", "status": "modified", "additions": 64, "deletions": 15, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs?ref=722489e3ff4c16dc179d30e729847314c918511f", "patch": "@@ -290,13 +290,10 @@ fn replacement_range(ctx: &CompletionContext, item: &SyntaxNode) -> TextRange {\n mod tests {\n     use expect_test::{expect, Expect};\n \n-    use crate::{\n-        tests::{check_edit, filtered_completion_list},\n-        CompletionKind,\n-    };\n+    use crate::tests::{check_edit, completion_list_no_kw};\n \n     fn check(ra_fixture: &str, expect: Expect) {\n-        let actual = filtered_completion_list(ra_fixture, CompletionKind::Magic);\n+        let actual = completion_list_no_kw(ra_fixture);\n         expect.assert_eq(&actual)\n     }\n \n@@ -313,7 +310,12 @@ impl Test for T {\n     }\n }\n \",\n-            expect![[\"\"]],\n+            expect![[r#\"\n+                sp Self\n+                tt Test\n+                st T\n+                bt u32\n+            \"#]],\n         );\n \n         check(\n@@ -356,7 +358,23 @@ impl Test for T {\n     }\n }\n \",\n-            expect![[\"\"]],\n+            expect![[r#\"\n+                sn if    if expr {}\n+                sn while while expr {}\n+                sn not   !expr\n+                sn ref   &expr\n+                sn refm  &mut expr\n+                sn match match expr {}\n+                sn box   Box::new(expr)\n+                sn ok    Ok(expr)\n+                sn err   Err(expr)\n+                sn some  Some(expr)\n+                sn dbg   dbg!(expr)\n+                sn dbgr  dbg!(&expr)\n+                sn call  function(expr)\n+                sn let   let\n+                sn letm  let mut\n+            \"#]],\n         );\n \n         check(\n@@ -368,7 +386,10 @@ impl Test for T {\n     fn test(t$0)\n }\n \",\n-            expect![[\"\"]],\n+            expect![[r#\"\n+                sp Self\n+                st T\n+            \"#]],\n         );\n \n         check(\n@@ -380,7 +401,10 @@ impl Test for T {\n     fn test(f: fn $0)\n }\n \",\n-            expect![[\"\"]],\n+            expect![[r#\"\n+                sp Self\n+                st T\n+            \"#]],\n         );\n     }\n \n@@ -395,7 +419,7 @@ impl Test for T {\n     const TEST: fn $0\n }\n \",\n-            expect![[\"\"]],\n+            expect![[r#\"\"#]],\n         );\n \n         check(\n@@ -407,7 +431,12 @@ impl Test for T {\n     const TEST: T$0\n }\n \",\n-            expect![[\"\"]],\n+            expect![[r#\"\n+                sp Self\n+                tt Test\n+                st T\n+                bt u32\n+            \"#]],\n         );\n \n         check(\n@@ -419,7 +448,12 @@ impl Test for T {\n     const TEST: u32 = f$0\n }\n \",\n-            expect![[\"\"]],\n+            expect![[r#\"\n+                sp Self\n+                tt Test\n+                st T\n+                bt u32\n+            \"#]],\n         );\n \n         check(\n@@ -433,7 +467,12 @@ impl Test for T {\n     };\n }\n \",\n-            expect![[\"\"]],\n+            expect![[r#\"\n+                sp Self\n+                tt Test\n+                st T\n+                bt u32\n+            \"#]],\n         );\n \n         check(\n@@ -476,7 +515,12 @@ impl Test for T {\n     type Test = T$0;\n }\n \",\n-            expect![[\"\"]],\n+            expect![[r#\"\n+                sp Self\n+                tt Test\n+                st T\n+                bt u32\n+            \"#]],\n         );\n \n         check(\n@@ -488,7 +532,12 @@ impl Test for T {\n     type Test = fn $0;\n }\n \",\n-            expect![[\"\"]],\n+            expect![[r#\"\n+                sp Self\n+                tt Test\n+                st T\n+                bt u32\n+            \"#]],\n         );\n     }\n "}, {"sha": "825fae587b1d3084ab14e4b79a4bc50b088a41a2", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=722489e3ff4c16dc179d30e729847314c918511f", "patch": "@@ -117,24 +117,15 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n mod tests {\n     use expect_test::{expect, Expect};\n \n-    use crate::{\n-        tests::{check_edit, filtered_completion_list_with_config, TEST_CONFIG},\n-        CompletionConfig, CompletionKind,\n-    };\n+    use crate::tests::{check_edit, completion_list_no_kw};\n \n     fn check(ra_fixture: &str, expect: Expect) {\n-        check_with_config(TEST_CONFIG, ra_fixture, expect);\n-    }\n-\n-    fn check_with_config(config: CompletionConfig, ra_fixture: &str, expect: Expect) {\n-        let actual =\n-            filtered_completion_list_with_config(config, ra_fixture, CompletionKind::Reference);\n+        let actual = completion_list_no_kw(ra_fixture);\n         expect.assert_eq(&actual)\n     }\n \n     #[test]\n     fn completes_if_prefix_is_keyword() {\n-        cov_mark::check!(completes_if_prefix_is_keyword);\n         check_edit(\n             \"wherewolf\",\n             r#\"\n@@ -188,6 +179,7 @@ pub mod prelude {\n \"#,\n             expect![[r#\"\n                 md std\n+                bt u32\n                 st Option\n             \"#]],\n         );\n@@ -217,6 +209,7 @@ mod macros {\n                 fn f()        fn()\n                 ma concat!(\u2026) #[macro_export] macro_rules! concat\n                 md std\n+                bt u32\n             \"##]],\n         );\n     }\n@@ -245,6 +238,7 @@ pub mod prelude {\n             expect![[r#\"\n                 md std\n                 md core\n+                bt u32\n                 st String\n             \"#]],\n         );\n@@ -273,6 +267,7 @@ pub mod prelude {\n             expect![[r#\"\n                 fn f() fn()\n                 md std\n+                bt u32\n             \"#]],\n         );\n     }"}, {"sha": "0cb484d50755d4a4b868d7f6ff37595db7121e2b", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=722489e3ff4c16dc179d30e729847314c918511f", "patch": "@@ -134,7 +134,6 @@ impl<'a> CompletionContext<'a> {\n         // check kind of macro-expanded token, but use range of original token\n         let kind = self.token.kind();\n         if kind == IDENT || kind == LIFETIME_IDENT || kind == UNDERSCORE || kind.is_keyword() {\n-            cov_mark::hit!(completes_if_prefix_is_keyword);\n             self.original_token.text_range()\n         } else if kind == CHAR {\n             // assume we are completing a lifetime but the user has only typed the '"}, {"sha": "fee61e0bfcf64f96cefc9a770c1edaaff9d2fe3b", "filename": "crates/ide_completion/src/tests.rs", "status": "modified", "additions": 47, "deletions": 16, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests.rs?ref=722489e3ff4c16dc179d30e729847314c918511f", "patch": "@@ -20,6 +20,7 @@ mod record;\n mod type_pos;\n mod use_tree;\n mod visibility;\n+mod flyimport;\n \n use std::mem;\n \n@@ -77,10 +78,18 @@ pub(crate) const TEST_CONFIG: CompletionConfig = CompletionConfig {\n };\n \n pub(crate) fn completion_list(ra_fixture: &str) -> String {\n-    completion_list_with_config(TEST_CONFIG, ra_fixture)\n+    completion_list_with_config(TEST_CONFIG, ra_fixture, true)\n }\n \n-fn completion_list_with_config(config: CompletionConfig, ra_fixture: &str) -> String {\n+pub(crate) fn completion_list_no_kw(ra_fixture: &str) -> String {\n+    completion_list_with_config(TEST_CONFIG, ra_fixture, false)\n+}\n+\n+fn completion_list_with_config(\n+    config: CompletionConfig,\n+    ra_fixture: &str,\n+    include_keywords: bool,\n+) -> String {\n     // filter out all but one builtintype completion for smaller test outputs\n     let items = get_all_items(config, ra_fixture);\n     let mut bt_seen = false;\n@@ -89,6 +98,8 @@ fn completion_list_with_config(config: CompletionConfig, ra_fixture: &str) -> St\n         .filter(|it| {\n             it.completion_kind != CompletionKind::BuiltinType || !mem::replace(&mut bt_seen, true)\n         })\n+        .filter(|it| include_keywords || it.completion_kind != CompletionKind::Keyword)\n+        .filter(|it| include_keywords || it.completion_kind != CompletionKind::Snippet)\n         .collect();\n     render_completion_list(items)\n }\n@@ -120,20 +131,6 @@ pub(crate) fn do_completion_with_config(\n         .collect()\n }\n \n-pub(crate) fn filtered_completion_list(code: &str, kind: CompletionKind) -> String {\n-    filtered_completion_list_with_config(TEST_CONFIG, code, kind)\n-}\n-\n-pub(crate) fn filtered_completion_list_with_config(\n-    config: CompletionConfig,\n-    code: &str,\n-    kind: CompletionKind,\n-) -> String {\n-    let kind_completions: Vec<CompletionItem> =\n-        get_all_items(config, code).into_iter().filter(|c| c.completion_kind == kind).collect();\n-    render_completion_list(kind_completions)\n-}\n-\n fn render_completion_list(completions: Vec<CompletionItem>) -> String {\n     fn monospace_width(s: &str) -> usize {\n         s.chars().count()\n@@ -254,3 +251,37 @@ fn foo() {\n \"#,\n     );\n }\n+\n+#[test]\n+fn no_completions_in_comments() {\n+    cov_mark::check!(no_keyword_completion_in_comments);\n+    assert_eq!(\n+        completion_list(\n+            r#\"\n+fn test() {\n+let x = 2; // A comment$0\n+}\n+\"#,\n+        ),\n+        String::new(),\n+    );\n+    assert_eq!(\n+        completion_list(\n+            r#\"\n+/*\n+Some multi-line comment$0\n+*/\n+\"#,\n+        ),\n+        String::new(),\n+    );\n+    assert_eq!(\n+        completion_list(\n+            r#\"\n+/// Some doc comment\n+/// let test$0 = 1\n+\"#,\n+        ),\n+        String::new(),\n+    );\n+}"}, {"sha": "a63480873447ac2fb03540f730e62e99516ebb23", "filename": "crates/ide_completion/src/tests/expression.rs", "status": "modified", "additions": 218, "deletions": 1, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Ftests%2Fexpression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Ftests%2Fexpression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fexpression.rs?ref=722489e3ff4c16dc179d30e729847314c918511f", "patch": "@@ -110,7 +110,7 @@ fn func(param0 @ (param1, param2): (i32, i32)) {\n }\n \n #[test]\n-fn completes_all_the_things() {\n+fn completes_all_the_things_in_fn_body() {\n     cov_mark::check!(unqualified_skip_lifetime_completion);\n     check(\n         r#\"\n@@ -206,6 +206,223 @@ impl Unit {\n     );\n }\n \n+#[test]\n+fn complete_in_block() {\n+    check_empty(\n+        r#\"\n+    fn foo() {\n+        if true {\n+            $0\n+        }\n+    }\n+\"#,\n+        expect![[r#\"\n+            kw unsafe\n+            kw fn\n+            kw const\n+            kw type\n+            kw impl\n+            kw extern\n+            kw use\n+            kw trait\n+            kw static\n+            kw mod\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw let\n+            kw return\n+            sn pd\n+            sn ppd\n+            kw self\n+            kw super\n+            kw crate\n+            fn foo()     fn()\n+            bt u32\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn complete_after_if_expr() {\n+    check_empty(\n+        r#\"\n+    fn foo() {\n+        if true {}\n+        $0\n+    }\n+\"#,\n+        expect![[r#\"\n+            kw unsafe\n+            kw fn\n+            kw const\n+            kw type\n+            kw impl\n+            kw extern\n+            kw use\n+            kw trait\n+            kw static\n+            kw mod\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw let\n+            kw else\n+            kw else if\n+            kw return\n+            sn pd\n+            sn ppd\n+            kw self\n+            kw super\n+            kw crate\n+            fn foo()     fn()\n+            bt u32\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn complete_in_match_arm() {\n+    check_empty(\n+        r#\"\n+    fn foo() {\n+        match () {\n+            () => $0\n+        }\n+    }\n+\"#,\n+        expect![[r#\"\n+            kw unsafe\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw return\n+            kw self\n+            kw super\n+            kw crate\n+            fn foo()     fn()\n+            bt u32\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn completes_in_loop_ctx() {\n+    check_empty(\n+        r\"fn my() { loop { $0 } }\",\n+        expect![[r#\"\n+            kw unsafe\n+            kw fn\n+            kw const\n+            kw type\n+            kw impl\n+            kw extern\n+            kw use\n+            kw trait\n+            kw static\n+            kw mod\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw let\n+            kw continue\n+            kw break\n+            kw return\n+            sn pd\n+            sn ppd\n+            kw self\n+            kw super\n+            kw crate\n+            fn my()      fn()\n+            bt u32\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn completes_in_let_initializer() {\n+    check_empty(\n+        r#\"fn main() { let _ = $0 }\"#,\n+        expect![[r#\"\n+            kw unsafe\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw return\n+            kw self\n+            kw super\n+            kw crate\n+            fn main()    fn()\n+            bt u32\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn struct_initializer_field_expr() {\n+    check_empty(\n+        r#\"\n+struct Foo {\n+    pub f: i32,\n+}\n+fn foo() {\n+    Foo {\n+        f: $0\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            kw unsafe\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw return\n+            kw self\n+            kw super\n+            kw crate\n+            st Foo\n+            fn foo()     fn()\n+            bt u32\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn shadowing_shows_single_completion() {\n     cov_mark::check!(shadowing_shows_single_completion);"}, {"sha": "201443e10c2f0c56ac00bd5781a7fc65fb8a1e71", "filename": "crates/ide_completion/src/tests/flyimport.rs", "status": "added", "additions": 1014, "deletions": 0, "changes": 1014, "blob_url": "https://github.com/rust-lang/rust/blob/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Ftests%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Ftests%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fflyimport.rs?ref=722489e3ff4c16dc179d30e729847314c918511f", "patch": "@@ -0,0 +1,1014 @@\n+use expect_test::{expect, Expect};\n+\n+use crate::tests::{check_edit, check_edit_with_config, TEST_CONFIG};\n+\n+fn check(ra_fixture: &str, expect: Expect) {\n+    let config = TEST_CONFIG;\n+    let (db, position) = crate::tests::position(ra_fixture);\n+    let ctx = crate::context::CompletionContext::new(&db, position, &config).unwrap();\n+\n+    let mut acc = crate::completions::Completions::default();\n+    crate::completions::flyimport::import_on_the_fly(&mut acc, &ctx);\n+\n+    expect.assert_eq(&super::render_completion_list(Vec::from(acc)));\n+}\n+\n+#[test]\n+fn function_fuzzy_completion() {\n+    check_edit(\n+        \"stdin\",\n+        r#\"\n+//- /lib.rs crate:dep\n+pub mod io {\n+    pub fn stdin() {}\n+};\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    stdi$0\n+}\n+\"#,\n+        r#\"\n+use dep::io::stdin;\n+\n+fn main() {\n+    stdin()$0\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn macro_fuzzy_completion() {\n+    check_edit(\n+        \"macro_with_curlies!\",\n+        r#\"\n+//- /lib.rs crate:dep\n+/// Please call me as macro_with_curlies! {}\n+#[macro_export]\n+macro_rules! macro_with_curlies {\n+    () => {}\n+}\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    curli$0\n+}\n+\"#,\n+        r#\"\n+use dep::macro_with_curlies;\n+\n+fn main() {\n+    macro_with_curlies! {$0}\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn struct_fuzzy_completion() {\n+    check_edit(\n+        \"ThirdStruct\",\n+        r#\"\n+//- /lib.rs crate:dep\n+pub struct FirstStruct;\n+pub mod some_module {\n+    pub struct SecondStruct;\n+    pub struct ThirdStruct;\n+}\n+\n+//- /main.rs crate:main deps:dep\n+use dep::{FirstStruct, some_module::SecondStruct};\n+\n+fn main() {\n+    this$0\n+}\n+\"#,\n+        r#\"\n+use dep::{FirstStruct, some_module::{SecondStruct, ThirdStruct}};\n+\n+fn main() {\n+    ThirdStruct\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn short_paths_are_ignored() {\n+    cov_mark::check!(ignore_short_input_for_path);\n+\n+    check(\n+        r#\"\n+//- /lib.rs crate:dep\n+pub struct FirstStruct;\n+pub mod some_module {\n+    pub struct SecondStruct;\n+    pub struct ThirdStruct;\n+}\n+\n+//- /main.rs crate:main deps:dep\n+use dep::{FirstStruct, some_module::SecondStruct};\n+\n+fn main() {\n+    t$0\n+}\n+\"#,\n+        expect![[r#\"\"#]],\n+    );\n+}\n+\n+#[test]\n+fn fuzzy_completions_come_in_specific_order() {\n+    cov_mark::check!(certain_fuzzy_order_test);\n+    check(\n+        r#\"\n+//- /lib.rs crate:dep\n+pub struct FirstStruct;\n+pub mod some_module {\n+    // already imported, omitted\n+    pub struct SecondStruct;\n+    // does not contain all letters from the query, omitted\n+    pub struct UnrelatedOne;\n+    // contains all letters from the query, but not in sequence, displayed last\n+    pub struct ThiiiiiirdStruct;\n+    // contains all letters from the query, but not in the beginning, displayed second\n+    pub struct AfterThirdStruct;\n+    // contains all letters from the query in the begginning, displayed first\n+    pub struct ThirdStruct;\n+}\n+\n+//- /main.rs crate:main deps:dep\n+use dep::{FirstStruct, some_module::SecondStruct};\n+\n+fn main() {\n+    hir$0\n+}\n+\"#,\n+        expect![[r#\"\n+                st ThirdStruct (use dep::some_module::ThirdStruct)\n+                st AfterThirdStruct (use dep::some_module::AfterThirdStruct)\n+                st ThiiiiiirdStruct (use dep::some_module::ThiiiiiirdStruct)\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn trait_function_fuzzy_completion() {\n+    let fixture = r#\"\n+        //- /lib.rs crate:dep\n+        pub mod test_mod {\n+            pub trait TestTrait {\n+                const SPECIAL_CONST: u8;\n+                type HumbleType;\n+                fn weird_function();\n+                fn random_method(&self);\n+            }\n+            pub struct TestStruct {}\n+            impl TestTrait for TestStruct {\n+                const SPECIAL_CONST: u8 = 42;\n+                type HumbleType = ();\n+                fn weird_function() {}\n+                fn random_method(&self) {}\n+            }\n+        }\n+\n+        //- /main.rs crate:main deps:dep\n+        fn main() {\n+            dep::test_mod::TestStruct::wei$0\n+        }\n+        \"#;\n+\n+    check(\n+        fixture,\n+        expect![[r#\"\n+                fn weird_function() (use dep::test_mod::TestTrait) fn()\n+            \"#]],\n+    );\n+\n+    check_edit(\n+        \"weird_function\",\n+        fixture,\n+        r#\"\n+use dep::test_mod::TestTrait;\n+\n+fn main() {\n+    dep::test_mod::TestStruct::weird_function()$0\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn trait_const_fuzzy_completion() {\n+    let fixture = r#\"\n+        //- /lib.rs crate:dep\n+        pub mod test_mod {\n+            pub trait TestTrait {\n+                const SPECIAL_CONST: u8;\n+                type HumbleType;\n+                fn weird_function();\n+                fn random_method(&self);\n+            }\n+            pub struct TestStruct {}\n+            impl TestTrait for TestStruct {\n+                const SPECIAL_CONST: u8 = 42;\n+                type HumbleType = ();\n+                fn weird_function() {}\n+                fn random_method(&self) {}\n+            }\n+        }\n+\n+        //- /main.rs crate:main deps:dep\n+        fn main() {\n+            dep::test_mod::TestStruct::spe$0\n+        }\n+        \"#;\n+\n+    check(\n+        fixture,\n+        expect![[r#\"\n+            ct SPECIAL_CONST (use dep::test_mod::TestTrait)\n+        \"#]],\n+    );\n+\n+    check_edit(\n+        \"SPECIAL_CONST\",\n+        fixture,\n+        r#\"\n+use dep::test_mod::TestTrait;\n+\n+fn main() {\n+    dep::test_mod::TestStruct::SPECIAL_CONST\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn trait_method_fuzzy_completion() {\n+    let fixture = r#\"\n+        //- /lib.rs crate:dep\n+        pub mod test_mod {\n+            pub trait TestTrait {\n+                const SPECIAL_CONST: u8;\n+                type HumbleType;\n+                fn weird_function();\n+                fn random_method(&self);\n+            }\n+            pub struct TestStruct {}\n+            impl TestTrait for TestStruct {\n+                const SPECIAL_CONST: u8 = 42;\n+                type HumbleType = ();\n+                fn weird_function() {}\n+                fn random_method(&self) {}\n+            }\n+        }\n+\n+        //- /main.rs crate:main deps:dep\n+        fn main() {\n+            let test_struct = dep::test_mod::TestStruct {};\n+            test_struct.ran$0\n+        }\n+        \"#;\n+\n+    check(\n+        fixture,\n+        expect![[r#\"\n+                me random_method() (use dep::test_mod::TestTrait) fn(&self)\n+            \"#]],\n+    );\n+\n+    check_edit(\n+        \"random_method\",\n+        fixture,\n+        r#\"\n+use dep::test_mod::TestTrait;\n+\n+fn main() {\n+    let test_struct = dep::test_mod::TestStruct {};\n+    test_struct.random_method()$0\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn no_trait_type_fuzzy_completion() {\n+    check(\n+        r#\"\n+//- /lib.rs crate:dep\n+pub mod test_mod {\n+    pub trait TestTrait {\n+        const SPECIAL_CONST: u8;\n+        type HumbleType;\n+        fn weird_function();\n+        fn random_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        const SPECIAL_CONST: u8 = 42;\n+        type HumbleType = ();\n+        fn weird_function() {}\n+        fn random_method(&self) {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    dep::test_mod::TestStruct::hum$0\n+}\n+\"#,\n+        expect![[r#\"\"#]],\n+    );\n+}\n+\n+#[test]\n+fn does_not_propose_names_in_scope() {\n+    check(\n+        r#\"\n+//- /lib.rs crate:dep\n+pub mod test_mod {\n+    pub trait TestTrait {\n+        const SPECIAL_CONST: u8;\n+        type HumbleType;\n+        fn weird_function();\n+        fn random_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        const SPECIAL_CONST: u8 = 42;\n+        type HumbleType = ();\n+        fn weird_function() {}\n+        fn random_method(&self) {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:dep\n+use dep::test_mod::TestStruct;\n+fn main() {\n+    TestSt$0\n+}\n+\"#,\n+        expect![[r#\"\"#]],\n+    );\n+}\n+\n+#[test]\n+fn does_not_propose_traits_in_scope() {\n+    check(\n+        r#\"\n+//- /lib.rs crate:dep\n+pub mod test_mod {\n+    pub trait TestTrait {\n+        const SPECIAL_CONST: u8;\n+        type HumbleType;\n+        fn weird_function();\n+        fn random_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        const SPECIAL_CONST: u8 = 42;\n+        type HumbleType = ();\n+        fn weird_function() {}\n+        fn random_method(&self) {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:dep\n+use dep::test_mod::{TestStruct, TestTrait};\n+fn main() {\n+    dep::test_mod::TestStruct::hum$0\n+}\n+\"#,\n+        expect![[r#\"\"#]],\n+    );\n+}\n+\n+#[test]\n+fn blanket_trait_impl_import() {\n+    check_edit(\n+        \"another_function\",\n+        r#\"\n+//- /lib.rs crate:dep\n+pub mod test_mod {\n+    pub struct TestStruct {}\n+    pub trait TestTrait {\n+        fn another_function();\n+    }\n+    impl<T> TestTrait for T {\n+        fn another_function() {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    dep::test_mod::TestStruct::ano$0\n+}\n+\"#,\n+        r#\"\n+use dep::test_mod::TestTrait;\n+\n+fn main() {\n+    dep::test_mod::TestStruct::another_function()$0\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn zero_input_deprecated_assoc_item_completion() {\n+    check(\n+        r#\"\n+//- /lib.rs crate:dep\n+pub mod test_mod {\n+    #[deprecated]\n+    pub trait TestTrait {\n+        const SPECIAL_CONST: u8;\n+        type HumbleType;\n+        fn weird_function();\n+        fn random_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        const SPECIAL_CONST: u8 = 42;\n+        type HumbleType = ();\n+        fn weird_function() {}\n+        fn random_method(&self) {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    let test_struct = dep::test_mod::TestStruct {};\n+    test_struct.$0\n+}\n+        \"#,\n+        expect![[r#\"\n+                me random_method() (use dep::test_mod::TestTrait) fn(&self) DEPRECATED\n+            \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+//- /lib.rs crate:dep\n+pub mod test_mod {\n+    #[deprecated]\n+    pub trait TestTrait {\n+        const SPECIAL_CONST: u8;\n+        type HumbleType;\n+        fn weird_function();\n+        fn random_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        const SPECIAL_CONST: u8 = 42;\n+        type HumbleType = ();\n+        fn weird_function() {}\n+        fn random_method(&self) {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    dep::test_mod::TestStruct::$0\n+}\n+\"#,\n+        expect![[r#\"\n+                fn weird_function() (use dep::test_mod::TestTrait) fn() DEPRECATED\n+                ct SPECIAL_CONST (use dep::test_mod::TestTrait) DEPRECATED\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn no_completions_in_use_statements() {\n+    check(\n+        r#\"\n+//- /lib.rs crate:dep\n+pub mod io {\n+    pub fn stdin() {}\n+};\n+\n+//- /main.rs crate:main deps:dep\n+use stdi$0\n+\n+fn main() {}\n+\"#,\n+        expect![[]],\n+    );\n+}\n+\n+#[test]\n+fn prefix_config_usage() {\n+    let fixture = r#\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Item;\n+    }\n+}\n+\n+use crate::foo::bar;\n+\n+fn main() {\n+    Ite$0\n+}\"#;\n+    let mut config = TEST_CONFIG;\n+\n+    config.insert_use.prefix_kind = hir::PrefixKind::ByCrate;\n+    check_edit_with_config(\n+        config.clone(),\n+        \"Item\",\n+        fixture,\n+        r#\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Item;\n+    }\n+}\n+\n+use crate::foo::bar::{self, Item};\n+\n+fn main() {\n+    Item\n+}\"#,\n+    );\n+\n+    config.insert_use.prefix_kind = hir::PrefixKind::BySelf;\n+    check_edit_with_config(\n+        config.clone(),\n+        \"Item\",\n+        fixture,\n+        r#\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Item;\n+    }\n+}\n+\n+use crate::foo::bar;\n+\n+use self::foo::bar::Item;\n+\n+fn main() {\n+    Item\n+}\"#,\n+    );\n+\n+    config.insert_use.prefix_kind = hir::PrefixKind::Plain;\n+    check_edit_with_config(\n+        config,\n+        \"Item\",\n+        fixture,\n+        r#\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Item;\n+    }\n+}\n+\n+use foo::bar::Item;\n+\n+use crate::foo::bar;\n+\n+fn main() {\n+    Item\n+}\"#,\n+    );\n+}\n+\n+#[test]\n+fn unresolved_qualifier() {\n+    let fixture = r#\"\n+mod foo {\n+    pub mod bar {\n+        pub mod baz {\n+            pub struct Item;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    bar::baz::Ite$0\n+}\"#;\n+\n+    check(\n+        fixture,\n+        expect![[r#\"\n+        st Item (use foo::bar::baz::Item)\n+        \"#]],\n+    );\n+\n+    check_edit(\n+        \"Item\",\n+        fixture,\n+        r#\"\n+        use foo::bar;\n+\n+        mod foo {\n+            pub mod bar {\n+                pub mod baz {\n+                    pub struct Item;\n+                }\n+            }\n+        }\n+\n+        fn main() {\n+            bar::baz::Item\n+        }\"#,\n+    );\n+}\n+\n+#[test]\n+fn unresolved_assoc_item_container() {\n+    let fixture = r#\"\n+mod foo {\n+    pub struct Item;\n+\n+    impl Item {\n+        pub const TEST_ASSOC: usize = 3;\n+    }\n+}\n+\n+fn main() {\n+    Item::TEST_A$0\n+}\"#;\n+\n+    check(\n+        fixture,\n+        expect![[r#\"\n+        ct TEST_ASSOC (use foo::Item)\n+        \"#]],\n+    );\n+\n+    check_edit(\n+        \"TEST_ASSOC\",\n+        fixture,\n+        r#\"\n+use foo::Item;\n+\n+mod foo {\n+    pub struct Item;\n+\n+    impl Item {\n+        pub const TEST_ASSOC: usize = 3;\n+    }\n+}\n+\n+fn main() {\n+    Item::TEST_ASSOC\n+}\"#,\n+    );\n+}\n+\n+#[test]\n+fn unresolved_assoc_item_container_with_path() {\n+    let fixture = r#\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Item;\n+\n+        impl Item {\n+            pub const TEST_ASSOC: usize = 3;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    bar::Item::TEST_A$0\n+}\"#;\n+\n+    check(\n+        fixture,\n+        expect![[r#\"\n+        ct TEST_ASSOC (use foo::bar::Item)\n+    \"#]],\n+    );\n+\n+    check_edit(\n+        \"TEST_ASSOC\",\n+        fixture,\n+        r#\"\n+use foo::bar;\n+\n+mod foo {\n+    pub mod bar {\n+        pub struct Item;\n+\n+        impl Item {\n+            pub const TEST_ASSOC: usize = 3;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    bar::Item::TEST_ASSOC\n+}\"#,\n+    );\n+}\n+\n+#[test]\n+fn fuzzy_unresolved_path() {\n+    check(\n+        r#\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Item;\n+\n+        impl Item {\n+            pub const TEST_ASSOC: usize = 3;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    bar::ASS$0\n+}\"#,\n+        expect![[]],\n+    )\n+}\n+\n+#[test]\n+fn unqualified_assoc_items_are_omitted() {\n+    check(\n+        r#\"\n+mod something {\n+    pub trait BaseTrait {\n+        fn test_function() -> i32;\n+    }\n+\n+    pub struct Item1;\n+    pub struct Item2;\n+\n+    impl BaseTrait for Item1 {\n+        fn test_function() -> i32 {\n+            1\n+        }\n+    }\n+\n+    impl BaseTrait for Item2 {\n+        fn test_function() -> i32 {\n+            2\n+        }\n+    }\n+}\n+\n+fn main() {\n+    test_f$0\n+}\"#,\n+        expect![[]],\n+    )\n+}\n+\n+#[test]\n+fn case_matters() {\n+    check(\n+        r#\"\n+mod foo {\n+    pub const TEST_CONST: usize = 3;\n+    pub fn test_function() -> i32 {\n+        4\n+    }\n+}\n+\n+fn main() {\n+    TE$0\n+}\"#,\n+        expect![[r#\"\n+        ct TEST_CONST (use foo::TEST_CONST)\n+    \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+mod foo {\n+    pub const TEST_CONST: usize = 3;\n+    pub fn test_function() -> i32 {\n+        4\n+    }\n+}\n+\n+fn main() {\n+    te$0\n+}\"#,\n+        expect![[r#\"\n+        ct TEST_CONST (use foo::TEST_CONST)\n+        fn test_function() (use foo::test_function) fn() -> i32\n+    \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+mod foo {\n+    pub const TEST_CONST: usize = 3;\n+    pub fn test_function() -> i32 {\n+        4\n+    }\n+}\n+\n+fn main() {\n+    Te$0\n+}\"#,\n+        expect![[]],\n+    );\n+}\n+\n+#[test]\n+fn no_fuzzy_during_fields_of_record_lit_syntax() {\n+    check(\n+        r#\"\n+mod m {\n+    pub fn some_fn() -> i32 {\n+        42\n+    }\n+}\n+struct Foo {\n+    some_field: i32,\n+}\n+fn main() {\n+    let _ = Foo { so$0 };\n+}\n+\"#,\n+        expect![[]],\n+    );\n+}\n+\n+#[test]\n+fn fuzzy_after_fields_of_record_lit_syntax() {\n+    check(\n+        r#\"\n+mod m {\n+    pub fn some_fn() -> i32 {\n+        42\n+    }\n+}\n+struct Foo {\n+    some_field: i32,\n+}\n+fn main() {\n+    let _ = Foo { some_field: so$0 };\n+}\n+\"#,\n+        expect![[r#\"\n+                fn some_fn() (use m::some_fn) fn() -> i32\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn no_flyimports_in_traits_and_impl_declarations() {\n+    check(\n+        r#\"\n+mod m {\n+    pub fn some_fn() -> i32 {\n+        42\n+    }\n+}\n+trait Foo {\n+    som$0\n+}\n+\"#,\n+        expect![[r#\"\"#]],\n+    );\n+\n+    check(\n+        r#\"\n+mod m {\n+    pub fn some_fn() -> i32 {\n+        42\n+    }\n+}\n+struct Foo;\n+impl Foo {\n+    som$0\n+}\n+\"#,\n+        expect![[r#\"\"#]],\n+    );\n+\n+    check(\n+        r#\"\n+mod m {\n+    pub fn some_fn() -> i32 {\n+        42\n+    }\n+}\n+struct Foo;\n+trait Bar {}\n+impl Bar for Foo {\n+    som$0\n+}\n+\"#,\n+        expect![[r#\"\"#]],\n+    );\n+}\n+\n+#[test]\n+fn no_inherent_candidates_proposed() {\n+    check(\n+        r#\"\n+mod baz {\n+    pub trait DefDatabase {\n+        fn method1(&self);\n+    }\n+    pub trait HirDatabase: DefDatabase {\n+        fn method2(&self);\n+    }\n+}\n+\n+mod bar {\n+    fn test(db: &dyn crate::baz::HirDatabase) {\n+        db.metho$0\n+    }\n+}\n+            \"#,\n+        expect![[r#\"\"#]],\n+    );\n+}\n+\n+#[test]\n+fn respects_doc_hidden() {\n+    check(\n+        r#\"\n+//- /lib.rs crate:lib deps:dep\n+fn f() {\n+    ().fro$0\n+}\n+\n+//- /dep.rs crate:dep\n+#[doc(hidden)]\n+pub trait Private {\n+    fn frob(&self) {}\n+}\n+\n+impl<T> Private for T {}\n+            \"#,\n+        expect![[r#\"\"#]],\n+    );\n+    check(\n+        r#\"\n+//- /lib.rs crate:lib deps:dep\n+fn f() {\n+    ().fro$0\n+}\n+\n+//- /dep.rs crate:dep\n+pub trait Private {\n+    #[doc(hidden)]\n+    fn frob(&self) {}\n+}\n+\n+impl<T> Private for T {}\n+            \"#,\n+        expect![[r#\"\"#]],\n+    );\n+}\n+\n+#[test]\n+fn regression_9760() {\n+    check(\n+        r#\"\n+struct Struct;\n+fn main() {}\n+\n+mod mud {\n+    fn func() {\n+        let struct_instance = Stru$0\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+                st Struct (use crate::Struct)\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn flyimport_pattern() {\n+    check(\n+        r#\"\n+mod module {\n+    pub struct Struct;\n+}\n+fn function() {\n+    let Str$0\n+}\n+\"#,\n+        expect![[r#\"\n+                st Struct (use module::Struct)\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn flyimport_rename() {\n+    check(\n+        r#\"\n+mod module {\n+    pub struct Struct;\n+}\n+use self as Str$0;\n+    \"#,\n+        expect![[r#\"\"#]],\n+    );\n+}"}, {"sha": "e09e99aad5e7b1558ebe85edb1eda35b8c33fd31", "filename": "crates/ide_completion/src/tests/record.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Ftests%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722489e3ff4c16dc179d30e729847314c918511f/crates%2Fide_completion%2Fsrc%2Ftests%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Frecord.rs?ref=722489e3ff4c16dc179d30e729847314c918511f", "patch": "@@ -9,6 +9,7 @@ fn check(ra_fixture: &str, expect: Expect) {\n \n #[test]\n fn without_default_impl() {\n+    cov_mark::check!(no_keyword_completion_in_record_lit);\n     check(\n         r#\"\n struct Struct { foo: u32, bar: usize }"}, {"sha": "5debb9fb3d1910014e3cac675dcf76dd367d8d06", "filename": "crates/rust-analyzer/tests/slow-tests/tidy.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/722489e3ff4c16dc179d30e729847314c918511f/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722489e3ff4c16dc179d30e729847314c918511f/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs?ref=722489e3ff4c16dc179d30e729847314c918511f", "patch": "@@ -313,6 +313,7 @@ fn check_dbg(path: &Path, text: &str) {\n         \"handlers/remove_dbg.rs\",\n         // We have .dbg postfix\n         \"ide_completion/src/completions/postfix.rs\",\n+        \"ide_completion/src/completions/keyword.rs\",\n         \"ide_completion/src/tests/proc_macros.rs\",\n         // The documentation in string literals may contain anything for its own purposes\n         \"ide_completion/src/lib.rs\","}]}