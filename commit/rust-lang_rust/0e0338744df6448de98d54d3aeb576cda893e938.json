{"sha": "0e0338744df6448de98d54d3aeb576cda893e938", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlMDMzODc0NGRmNjQ0OGRlOThkNTRkM2FlYjU3NmNkYTg5M2U5Mzg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2021-04-22T18:53:33Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2021-06-04T17:05:20Z"}, "message": "rustc: Store metadata-in-rlibs in object files\n\nThis commit updates how rustc compiler metadata is stored in rlibs.\nPreviously metadata was stored as a raw file that has the same format as\n`--emit metadata`. After this commit, however, the metadata is encoded\ninto a small object file which has one section which is the contents of\nthe metadata.\n\nThe motivation for this commit is to fix a common case where #83730\narises. The problem is that when rustc crates a `dylib` crate type it\nneeds to include entire rlib files into the dylib, so it passes\n`--whole-archive` (or the equivalent) to the linker. The problem with\nthis, though, is that the linker will attempt to read all files in the\narchive. If the metadata file were left as-is (today) then the linker\nwould generate an error saying it can't read the file. The previous\nsolution was to alter the rlib just before linking, creating a new\narchive in a temporary directory which has the metadata file removed.\n\nThis problem from before this commit is now removed if the metadata file\nis stored in an object file that the linker can read. The only caveat we\nhave to take care of is to ensure that the linker never actually\nincludes the contents of the object file into the final output. We apply\nsimilar tricks as the `.llvmbc` bytecode sections to do this.\n\nThis involved changing the metadata loading code a bit, namely updating\nsome of the LLVM C APIs used to use non-deprecated ones and fiddling\nwith the lifetimes a bit to get everything to work out. Otherwise though\nthis isn't intended to be a functional change really, only that metadata\nis stored differently in archives now.\n\nThis should end up fixing #83730 because by default dylibs will no\nlonger have their rlib dependencies \"altered\" meaning that\nsplit-debuginfo will continue to have valid paths pointing at the\noriginal rlibs. (note that we still \"alter\" rlibs if LTO is enabled to\nremove Rust object files and we also \"alter\" for the #[link(cfg)]\nfeature, but that's rarely used).\n\nCloses #83730", "tree": {"sha": "21a1d323cba9c36b8aba04b36ffba7bf840b8fee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21a1d323cba9c36b8aba04b36ffba7bf840b8fee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e0338744df6448de98d54d3aeb576cda893e938", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e0338744df6448de98d54d3aeb576cda893e938", "html_url": "https://github.com/rust-lang/rust/commit/0e0338744df6448de98d54d3aeb576cda893e938", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e0338744df6448de98d54d3aeb576cda893e938/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "835150e70288535bc57bb624792229b9dc94991d", "url": "https://api.github.com/repos/rust-lang/rust/commits/835150e70288535bc57bb624792229b9dc94991d", "html_url": "https://github.com/rust-lang/rust/commit/835150e70288535bc57bb624792229b9dc94991d"}], "stats": {"total": 394, "additions": 212, "deletions": 182}, "files": [{"sha": "f1769f3da037e13a8ab0048179e0d0dd91b7cb21", "filename": "Cargo.lock", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0e0338744df6448de98d54d3aeb576cda893e938/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0e0338744df6448de98d54d3aeb576cda893e938/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0e0338744df6448de98d54d3aeb576cda893e938", "patch": "@@ -2159,9 +2159,9 @@ dependencies = [\n \n [[package]]\n name = \"memchr\"\n-version = \"2.3.3\"\n+version = \"2.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3728d817d99e5ac407411fa471ff9800a778d88a24685968b36824eaf4bee400\"\n+checksum = \"b16bd47d9e329435e309c58469fe0791c2d0d1ba96ec0954152a5ae2b04387dc\"\n \n [[package]]\n name = \"memmap2\"\n@@ -2364,6 +2364,17 @@ dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n+[[package]]\n+name = \"object\"\n+version = \"0.25.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f8bc1d42047cf336f0f939c99e97183cf31551bf0f2865a2ec9c8d91fd4ffb5e\"\n+dependencies = [\n+ \"crc32fast\",\n+ \"indexmap\",\n+ \"memchr\",\n+]\n+\n [[package]]\n name = \"once_cell\"\n version = \"1.7.2\"\n@@ -3706,7 +3717,7 @@ dependencies = [\n  \"itertools 0.9.0\",\n  \"jobserver\",\n  \"libc\",\n- \"object\",\n+ \"object 0.25.2\",\n  \"pathdiff\",\n  \"rustc_apfloat\",\n  \"rustc_ast\",\n@@ -4923,7 +4934,7 @@ dependencies = [\n  \"hermit-abi\",\n  \"libc\",\n  \"miniz_oxide\",\n- \"object\",\n+ \"object 0.22.0\",\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"profiler_builtins\","}, {"sha": "2ec4f8d04a1d6cf29759f0d6ddfbc718af5f0639", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0e0338744df6448de98d54d3aeb576cda893e938/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e0338744df6448de98d54d3aeb576cda893e938/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=0e0338744df6448de98d54d3aeb576cda893e938", "patch": "@@ -582,11 +582,6 @@ pub struct PassManager<'a>(InvariantOpaque<'a>);\n extern \"C\" {\n     pub type PassManagerBuilder;\n }\n-extern \"C\" {\n-    pub type ObjectFile;\n-}\n-#[repr(C)]\n-pub struct SectionIterator<'a>(InvariantOpaque<'a>);\n extern \"C\" {\n     pub type Pass;\n }\n@@ -1703,35 +1698,6 @@ extern \"C\" {\n \n     pub fn LLVMDisposeMessage(message: *mut c_char);\n \n-    // Stuff that's in llvm-wrapper/ because it's not upstream yet.\n-\n-    /// Opens an object file.\n-    pub fn LLVMCreateObjectFile(\n-        MemBuf: &'static mut MemoryBuffer,\n-    ) -> Option<&'static mut ObjectFile>;\n-    /// Closes an object file.\n-    pub fn LLVMDisposeObjectFile(ObjFile: &'static mut ObjectFile);\n-\n-    /// Enumerates the sections in an object file.\n-    pub fn LLVMGetSections(ObjFile: &'a ObjectFile) -> &'a mut SectionIterator<'a>;\n-    /// Destroys a section iterator.\n-    pub fn LLVMDisposeSectionIterator(SI: &'a mut SectionIterator<'a>);\n-    /// Returns `true` if the section iterator is at the end of the section\n-    /// list:\n-    pub fn LLVMIsSectionIteratorAtEnd(ObjFile: &'a ObjectFile, SI: &SectionIterator<'a>) -> Bool;\n-    /// Moves the section iterator to point to the next section.\n-    pub fn LLVMMoveToNextSection(SI: &SectionIterator<'_>);\n-    /// Returns the current section size.\n-    pub fn LLVMGetSectionSize(SI: &SectionIterator<'_>) -> c_ulonglong;\n-    /// Returns the current section contents as a string buffer.\n-    pub fn LLVMGetSectionContents(SI: &SectionIterator<'_>) -> *const c_char;\n-\n-    /// Reads the given file and returns it as a memory buffer. Use\n-    /// LLVMDisposeMemoryBuffer() to get rid of it.\n-    pub fn LLVMRustCreateMemoryBufferWithContentsOfFile(\n-        Path: *const c_char,\n-    ) -> Option<&'static mut MemoryBuffer>;\n-\n     pub fn LLVMStartMultithreaded() -> Bool;\n \n     /// Returns a string describing the last error caused by an LLVMRust* call.\n@@ -2236,12 +2202,6 @@ extern \"C\" {\n     pub fn LLVMRustArchiveIteratorFree(AIR: &'a mut ArchiveIterator<'a>);\n     pub fn LLVMRustDestroyArchive(AR: &'static mut Archive);\n \n-    #[allow(improper_ctypes)]\n-    pub fn LLVMRustGetSectionName(\n-        SI: &SectionIterator<'_>,\n-        data: &mut Option<std::ptr::NonNull<c_char>>,\n-    ) -> size_t;\n-\n     #[allow(improper_ctypes)]\n     pub fn LLVMRustWriteTwineToString(T: &Twine, s: &RustString);\n "}, {"sha": "38d56f872116933dccdae216c772ecb547b0aa1a", "filename": "compiler/rustc_codegen_llvm/src/llvm/mod.rs", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0e0338744df6448de98d54d3aeb576cda893e938/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e0338744df6448de98d54d3aeb576cda893e938/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs?ref=0e0338744df6448de98d54d3aeb576cda893e938", "patch": "@@ -150,50 +150,6 @@ impl Attribute {\n     }\n }\n \n-// Memory-managed interface to object files.\n-\n-pub struct ObjectFile {\n-    pub llof: &'static mut ffi::ObjectFile,\n-}\n-\n-unsafe impl Send for ObjectFile {}\n-\n-impl ObjectFile {\n-    // This will take ownership of llmb\n-    pub fn new(llmb: &'static mut MemoryBuffer) -> Option<ObjectFile> {\n-        unsafe {\n-            let llof = LLVMCreateObjectFile(llmb)?;\n-            Some(ObjectFile { llof })\n-        }\n-    }\n-}\n-\n-impl Drop for ObjectFile {\n-    fn drop(&mut self) {\n-        unsafe {\n-            LLVMDisposeObjectFile(&mut *(self.llof as *mut _));\n-        }\n-    }\n-}\n-\n-// Memory-managed interface to section iterators.\n-\n-pub struct SectionIter<'a> {\n-    pub llsi: &'a mut SectionIterator<'a>,\n-}\n-\n-impl Drop for SectionIter<'a> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            LLVMDisposeSectionIterator(&mut *(self.llsi as *mut _));\n-        }\n-    }\n-}\n-\n-pub fn mk_section_iter(llof: &ffi::ObjectFile) -> SectionIter<'_> {\n-    unsafe { SectionIter { llsi: LLVMGetSections(llof) } }\n-}\n-\n pub fn set_section(llglobal: &Value, section_name: &str) {\n     let section_name_cstr = CString::new(section_name).expect(\"unexpected CString error\");\n     unsafe {"}, {"sha": "9bd5764f0730dbff3e4772db5a50b0947b2afbe7", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e0338744df6448de98d54d3aeb576cda893e938/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0e0338744df6448de98d54d3aeb576cda893e938/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=0e0338744df6448de98d54d3aeb576cda893e938", "patch": "@@ -35,6 +35,6 @@ rustc_target = { path = \"../rustc_target\" }\n rustc_session = { path = \"../rustc_session\" }\n \n [dependencies.object]\n-version = \"0.22.0\"\n+version = \"0.25.2\"\n default-features = false\n-features = [\"read_core\", \"elf\", \"macho\", \"pe\", \"unaligned\", \"archive\"]\n+features = [\"read_core\", \"elf\", \"macho\", \"pe\", \"unaligned\", \"archive\", \"write\"]"}, {"sha": "87eb51342d4c5c05ac00d292c7d4c80997e6aff3", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 167, "deletions": 43, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/0e0338744df6448de98d54d3aeb576cda893e938/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e0338744df6448de98d54d3aeb576cda893e938/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=0e0338744df6448de98d54d3aeb576cda893e938", "patch": "@@ -3,7 +3,7 @@ use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_errors::Handler;\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n use rustc_hir::def_id::CrateNum;\n-use rustc_middle::middle::cstore::{EncodedMetadata, LibSource};\n+use rustc_middle::middle::cstore::LibSource;\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_session::config::{self, CFGuard, CrateType, DebugInfo};\n use rustc_session::config::{OutputFilenames, OutputType, PrintRequest};\n@@ -14,6 +14,7 @@ use rustc_session::utils::NativeLibKind;\n /// need out of the shared crate context before we get rid of it.\n use rustc_session::{filesearch, Session};\n use rustc_span::symbol::Symbol;\n+use rustc_target::abi::Endian;\n use rustc_target::spec::crt_objects::{CrtObjects, CrtObjectsFallback};\n use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor, SplitDebuginfo};\n use rustc_target::spec::{PanicStrategy, RelocModel, RelroLevel, SanitizerSet, Target};\n@@ -28,6 +29,9 @@ use crate::{\n };\n \n use cc::windows_registry;\n+use object::elf;\n+use object::write::Object;\n+use object::{Architecture, BinaryFormat, Endianness, FileFlags, SectionFlags, SectionKind};\n use tempfile::Builder as TempFileBuilder;\n \n use std::ffi::OsString;\n@@ -278,9 +282,9 @@ pub fn each_linked_rlib(\n /// building an `.rlib` (stomping over one another), or writing an `.rmeta` into a\n /// directory being searched for `extern crate` (observing an incomplete file).\n /// The returned path is the temporary file containing the complete metadata.\n-pub fn emit_metadata(sess: &Session, metadata: &EncodedMetadata, tmpdir: &MaybeTempDir) -> PathBuf {\n+pub fn emit_metadata(sess: &Session, metadata: &[u8], tmpdir: &MaybeTempDir) -> PathBuf {\n     let out_filename = tmpdir.as_ref().join(METADATA_FILENAME);\n-    let result = fs::write(&out_filename, &metadata.raw_data);\n+    let result = fs::write(&out_filename, metadata);\n \n     if let Err(e) = result {\n         sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n@@ -366,9 +370,11 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n     // code above.\n     match flavor {\n         RlibFlavor::Normal => {\n-            // Instead of putting the metadata in an object file section, rlibs\n-            // contain the metadata in a separate file.\n-            ab.add_file(&emit_metadata(sess, &codegen_results.metadata, tmpdir));\n+            // metadata in rlib files is wrapped in a \"dummy\" object file for\n+            // the target platform so the rlib can be processed entirely by\n+            // normal linkers for the platform.\n+            let metadata = create_metadata_file(sess, &codegen_results.metadata.raw_data);\n+            ab.add_file(&emit_metadata(sess, &metadata, tmpdir));\n \n             // After adding all files to the archive, we need to update the\n             // symbol table of the archive. This currently dies on macOS (see\n@@ -385,8 +391,137 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n             }\n         }\n     }\n+    return ab;\n \n-    ab\n+    // For rlibs we \"pack\" rustc metadata into a dummy object file. When rustc\n+    // creates a dylib crate type it will pass `--whole-archive` (or the\n+    // platform equivalent) to include all object files from an rlib into the\n+    // final dylib itself. This causes linkers to iterate and try to include all\n+    // files located in an archive, so if metadata is stored in an archive then\n+    // it needs to be of a form that the linker will be able to process.\n+    //\n+    // Note, though, that we don't actually want this metadata to show up in any\n+    // final output of the compiler. Instead this is purely for rustc's own\n+    // metadata tracking purposes.\n+    //\n+    // With the above in mind, each \"flavor\" of object format gets special\n+    // handling here depending on the target:\n+    //\n+    // * MachO - macos-like targets will insert the metadata into a section that\n+    //   is sort of fake dwarf debug info. Inspecting the source of the macos\n+    //   linker this causes these sections to be skipped automatically because\n+    //   it's not in an allowlist of otherwise well known dwarf section names to\n+    //   go into the final artifact.\n+    //\n+    // * WebAssembly - we actually don't have any container format for this\n+    //   target. WebAssembly doesn't support the `dylib` crate type anyway so\n+    //   there's no need for us to support this at this time. Consequently the\n+    //   metadata bytes are simply stored as-is into an rlib.\n+    //\n+    // * COFF - Windows-like targets create an object with a section that has\n+    //   the `IMAGE_SCN_LNK_REMOVE` flag set which ensures that if the linker\n+    //   ever sees the section it doesn't process it and it's removed.\n+    //\n+    // * ELF - All other targets are similar to Windows in that there's a\n+    //   `SHF_EXCLUDE` flag we can set on sections in an object file to get\n+    //   automatically removed from the final output.\n+    //\n+    // Note that this metdata format is kept in sync with\n+    // `rustc_codegen_ssa/src/back/metadata.rs`.\n+    fn create_metadata_file(sess: &Session, metadata: &[u8]) -> Vec<u8> {\n+        let endianness = match sess.target.options.endian {\n+            Endian::Little => Endianness::Little,\n+            Endian::Big => Endianness::Big,\n+        };\n+        let architecture = match &sess.target.arch[..] {\n+            \"arm\" => Architecture::Arm,\n+            \"aarch64\" => Architecture::Aarch64,\n+            \"x86\" => Architecture::I386,\n+            \"s390x\" => Architecture::S390x,\n+            \"mips\" => Architecture::Mips,\n+            \"mips64\" => Architecture::Mips64,\n+            \"x86_64\" => {\n+                if sess.target.pointer_width == 32 {\n+                    Architecture::X86_64_X32\n+                } else {\n+                    Architecture::X86_64\n+                }\n+            }\n+            \"powerpc\" => Architecture::PowerPc,\n+            \"powerpc64\" => Architecture::PowerPc64,\n+            \"riscv32\" => Architecture::Riscv32,\n+            \"riscv64\" => Architecture::Riscv64,\n+            \"sparc64\" => Architecture::Sparc64,\n+\n+            // This is used to handle all \"other\" targets. This includes targets\n+            // in two categories:\n+            //\n+            // * Some targets don't have support in the `object` crate just yet\n+            //   to write an object file. These targets are likely to get filled\n+            //   out over time.\n+            //\n+            // * Targets like WebAssembly don't support dylibs, so the purpose\n+            //   of putting metadata in object files, to support linking rlibs\n+            //   into dylibs, is moot.\n+            //\n+            // In both of these cases it means that linking into dylibs will\n+            // not be supported by rustc. This doesn't matter for targets like\n+            // WebAssembly and for targets not supported by the `object` crate\n+            // yet it means that work will need to be done in the `object` crate\n+            // to add a case above.\n+            _ => return metadata.to_vec(),\n+        };\n+\n+        if sess.target.is_like_osx {\n+            let mut file = Object::new(BinaryFormat::MachO, architecture, endianness);\n+\n+            let section =\n+                file.add_section(b\"__DWARF\".to_vec(), b\".rmeta\".to_vec(), SectionKind::Debug);\n+            file.append_section_data(section, metadata, 1);\n+            file.write().unwrap()\n+        } else if sess.target.is_like_windows {\n+            const IMAGE_SCN_LNK_REMOVE: u32 = 0;\n+            let mut file = Object::new(BinaryFormat::Coff, architecture, endianness);\n+\n+            let section = file.add_section(Vec::new(), b\".rmeta\".to_vec(), SectionKind::Debug);\n+            file.section_mut(section).flags =\n+                SectionFlags::Coff { characteristics: IMAGE_SCN_LNK_REMOVE };\n+            file.append_section_data(section, metadata, 1);\n+            file.write().unwrap()\n+        } else {\n+            const SHF_EXCLUDE: u64 = 0x80000000;\n+            let mut file = Object::new(BinaryFormat::Elf, architecture, endianness);\n+\n+            match &sess.target.arch[..] {\n+                // copied from `mipsel-linux-gnu-gcc foo.c -c` and\n+                // inspecting the resulting `e_flags` field.\n+                \"mips\" => {\n+                    let e_flags = elf::EF_MIPS_ARCH_32R2 | elf::EF_MIPS_CPIC | elf::EF_MIPS_PIC;\n+                    file.flags = FileFlags::Elf { e_flags };\n+                }\n+                // copied from `mips64el-linux-gnuabi64-gcc foo.c -c`\n+                \"mips64\" => {\n+                    let e_flags = elf::EF_MIPS_ARCH_64R2 | elf::EF_MIPS_CPIC | elf::EF_MIPS_PIC;\n+                    file.flags = FileFlags::Elf { e_flags };\n+                }\n+\n+                // copied from `riscv64-linux-gnu-gcc foo.c -c`, note though\n+                // that the `+d` target feature represents whether the double\n+                // float abi is enabled.\n+                \"riscv64\" if sess.target.options.features.contains(\"+d\") => {\n+                    let e_flags = elf::EF_RISCV_RVC | elf::EF_RISCV_FLOAT_ABI_DOUBLE;\n+                    file.flags = FileFlags::Elf { e_flags };\n+                }\n+\n+                _ => {}\n+            }\n+\n+            let section = file.add_section(Vec::new(), b\".rmeta\".to_vec(), SectionKind::Debug);\n+            file.section_mut(section).flags = SectionFlags::Elf { sh_flags: SHF_EXCLUDE };\n+            file.append_section_data(section, metadata, 1);\n+            file.write().unwrap()\n+        }\n+    }\n }\n \n /// Create a static archive.\n@@ -1964,11 +2099,8 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n     }\n \n     // Adds the static \"rlib\" versions of all crates to the command line.\n-    // There's a bit of magic which happens here specifically related to LTO and\n-    // dynamic libraries. Specifically:\n-    //\n-    // * For LTO, we remove upstream object files.\n-    // * For dylibs we remove metadata and bytecode from upstream rlibs\n+    // There's a bit of magic which happens here specifically related to LTO,\n+    // namely that we remove upstream object files.\n     //\n     // When performing LTO, almost(*) all of the bytecode from the upstream\n     // libraries has already been included in our object file output. As a\n@@ -1981,20 +2113,9 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n     // their bytecode wasn't included. The object files in those libraries must\n     // still be passed to the linker.\n     //\n-    // When making a dynamic library, linkers by default don't include any\n-    // object files in an archive if they're not necessary to resolve the link.\n-    // We basically want to convert the archive (rlib) to a dylib, though, so we\n-    // *do* want everything included in the output, regardless of whether the\n-    // linker thinks it's needed or not. As a result we must use the\n-    // --whole-archive option (or the platform equivalent). When using this\n-    // option the linker will fail if there are non-objects in the archive (such\n-    // as our own metadata and/or bytecode). All in all, for rlibs to be\n-    // entirely included in dylibs, we need to remove all non-object files.\n-    //\n-    // Note, however, that if we're not doing LTO or we're not producing a dylib\n-    // (aka we're making an executable), we can just pass the rlib blindly to\n-    // the linker (fast) because it's fine if it's not actually included as\n-    // we're at the end of the dependency chain.\n+    // Note, however, that if we're not doing LTO we can just pass the rlib\n+    // blindly to the linker (fast) because it's fine if it's not actually\n+    // included as we're at the end of the dependency chain.\n     fn add_static_crate<'a, B: ArchiveBuilder<'a>>(\n         cmd: &mut dyn Linker,\n         sess: &'a Session,\n@@ -2006,6 +2127,24 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n         let src = &codegen_results.crate_info.used_crate_source[&cnum];\n         let cratepath = &src.rlib.as_ref().unwrap().0;\n \n+        let mut link_upstream = |path: &Path| {\n+            // If we're creating a dylib, then we need to include the\n+            // whole of each object in our archive into that artifact. This is\n+            // because a `dylib` can be reused as an intermediate artifact.\n+            //\n+            // Note, though, that we don't want to include the whole of a\n+            // compiler-builtins crate (e.g., compiler-rt) because it'll get\n+            // repeatedly linked anyway.\n+            let path = fix_windows_verbatim_for_gcc(path);\n+            if crate_type == CrateType::Dylib\n+                && codegen_results.crate_info.compiler_builtins != Some(cnum)\n+            {\n+                cmd.link_whole_rlib(&path);\n+            } else {\n+                cmd.link_rlib(&path);\n+            }\n+        };\n+\n         // See the comment above in `link_staticlib` and `link_rlib` for why if\n         // there's a static library that's not relevant we skip all object\n         // files.\n@@ -2017,10 +2156,9 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n \n         if (!are_upstream_rust_objects_already_included(sess)\n             || ignored_for_lto(sess, &codegen_results.crate_info, cnum))\n-            && crate_type != CrateType::Dylib\n             && !skip_native\n         {\n-            cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n+            link_upstream(cratepath);\n             return;\n         }\n \n@@ -2070,21 +2208,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n                 return;\n             }\n             archive.build();\n-\n-            // If we're creating a dylib, then we need to include the\n-            // whole of each object in our archive into that artifact. This is\n-            // because a `dylib` can be reused as an intermediate artifact.\n-            //\n-            // Note, though, that we don't want to include the whole of a\n-            // compiler-builtins crate (e.g., compiler-rt) because it'll get\n-            // repeatedly linked anyway.\n-            if crate_type == CrateType::Dylib\n-                && codegen_results.crate_info.compiler_builtins != Some(cnum)\n-            {\n-                cmd.link_whole_rlib(&fix_windows_verbatim_for_gcc(&dst));\n-            } else {\n-                cmd.link_rlib(&fix_windows_verbatim_for_gcc(&dst));\n-            }\n+            link_upstream(&dst);\n         });\n     }\n "}, {"sha": "0fff3195808834e50a7c443d020f1138f1df2d8f", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0e0338744df6448de98d54d3aeb576cda893e938/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e0338744df6448de98d54d3aeb576cda893e938/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=0e0338744df6448de98d54d3aeb576cda893e938", "patch": "@@ -3,6 +3,7 @@\n use std::fs::File;\n use std::path::Path;\n \n+use object::{Object, ObjectSection};\n use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::owning_ref::OwningRef;\n use rustc_data_structures::rustc_erase_owner;\n@@ -46,7 +47,10 @@ impl MetadataLoader for DefaultMetadataLoader {\n                 let entry = entry_result\n                     .map_err(|e| format!(\"failed to parse rlib '{}': {}\", path.display(), e))?;\n                 if entry.name() == METADATA_FILENAME.as_bytes() {\n-                    return Ok(entry.data());\n+                    let data = entry\n+                        .data(data)\n+                        .map_err(|e| format!(\"failed to parse rlib '{}': {}\", path.display(), e))?;\n+                    return search_for_metadata(path, data, \".rmeta\");\n                 }\n             }\n \n@@ -55,17 +59,27 @@ impl MetadataLoader for DefaultMetadataLoader {\n     }\n \n     fn get_dylib_metadata(&self, _target: &Target, path: &Path) -> Result<MetadataRef, String> {\n-        use object::{Object, ObjectSection};\n-\n-        load_metadata_with(path, |data| {\n-            let file = object::File::parse(&data)\n-                .map_err(|e| format!(\"failed to parse dylib '{}': {}\", path.display(), e))?;\n-            file.section_by_name(\".rustc\")\n-                .ok_or_else(|| format!(\"no .rustc section in '{}'\", path.display()))?\n-                .data()\n-                .map_err(|e| {\n-                    format!(\"failed to read .rustc section in '{}': {}\", path.display(), e)\n-                })\n-        })\n+        load_metadata_with(path, |data| search_for_metadata(path, data, \".rustc\"))\n     }\n }\n+\n+fn search_for_metadata<'a>(\n+    path: &Path,\n+    bytes: &'a [u8],\n+    section: &str,\n+) -> Result<&'a [u8], String> {\n+    let file = match object::File::parse(bytes) {\n+        Ok(f) => f,\n+        // The parse above could fail for odd reasons like corruption, but for\n+        // now we just interpret it as this target doesn't support metadata\n+        // emission in object files so the entire byte slice itself is probably\n+        // a metadata file. Ideally though if necessary we could at least check\n+        // the prefix of bytes to see if it's an actual metadata object and if\n+        // not forward the error along here.\n+        Err(_) => return Ok(bytes),\n+    };\n+    file.section_by_name(section)\n+        .ok_or_else(|| format!(\"no `{}` section in '{}'\", section, path.display()))?\n+        .data()\n+        .map_err(|e| format!(\"failed to read {} section in '{}': {}\", section, path.display(), e))\n+}"}, {"sha": "b1f89fd42cced97cf74ee32be82a748c4f22be31", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e0338744df6448de98d54d3aeb576cda893e938/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e0338744df6448de98d54d3aeb576cda893e938/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=0e0338744df6448de98d54d3aeb576cda893e938", "patch": "@@ -985,7 +985,7 @@ fn encode_and_write_metadata(\n             .tempdir_in(out_filename.parent().unwrap())\n             .unwrap_or_else(|err| tcx.sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n         let metadata_tmpdir = MaybeTempDir::new(metadata_tmpdir, tcx.sess.opts.cg.save_temps);\n-        let metadata_filename = emit_metadata(tcx.sess, &metadata, &metadata_tmpdir);\n+        let metadata_filename = emit_metadata(tcx.sess, &metadata.raw_data, &metadata_tmpdir);\n         if let Err(e) = util::non_durable_rename(&metadata_filename, &out_filename) {\n             tcx.sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n         }"}, {"sha": "548b3471ba714f8e8241462846f54945e65798e3", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0e0338744df6448de98d54d3aeb576cda893e938/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0e0338744df6448de98d54d3aeb576cda893e938/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=0e0338744df6448de98d54d3aeb576cda893e938", "patch": "@@ -70,17 +70,6 @@ extern \"C\" void LLVMRustInstallFatalErrorHandler() {\n   install_fatal_error_handler(FatalErrorHandler);\n }\n \n-extern \"C\" LLVMMemoryBufferRef\n-LLVMRustCreateMemoryBufferWithContentsOfFile(const char *Path) {\n-  ErrorOr<std::unique_ptr<MemoryBuffer>> BufOr =\n-      MemoryBuffer::getFile(Path, -1, false);\n-  if (!BufOr) {\n-    LLVMRustSetLastError(BufOr.getError().message().c_str());\n-    return nullptr;\n-  }\n-  return wrap(BufOr.get().release());\n-}\n-\n extern \"C\" char *LLVMRustGetLastError(void) {\n   char *Ret = LastError;\n   LastError = nullptr;\n@@ -1077,30 +1066,6 @@ extern \"C\" void LLVMRustWriteValueToString(LLVMValueRef V,\n   }\n }\n \n-// Note that the two following functions look quite similar to the\n-// LLVMGetSectionName function. Sadly, it appears that this function only\n-// returns a char* pointer, which isn't guaranteed to be null-terminated. The\n-// function provided by LLVM doesn't return the length, so we've created our own\n-// function which returns the length as well as the data pointer.\n-//\n-// For an example of this not returning a null terminated string, see\n-// lib/Object/COFFObjectFile.cpp in the getSectionName function. One of the\n-// branches explicitly creates a StringRef without a null terminator, and then\n-// that's returned.\n-\n-inline section_iterator *unwrap(LLVMSectionIteratorRef SI) {\n-  return reinterpret_cast<section_iterator *>(SI);\n-}\n-\n-extern \"C\" size_t LLVMRustGetSectionName(LLVMSectionIteratorRef SI,\n-                                         const char **Ptr) {\n-  auto NameOrErr = (*unwrap(SI))->getName();\n-  if (!NameOrErr)\n-    report_fatal_error(NameOrErr.takeError());\n-  *Ptr = NameOrErr->data();\n-  return NameOrErr->size();\n-}\n-\n // LLVMArrayType function does not support 64-bit ElementCount\n extern \"C\" LLVMTypeRef LLVMRustArrayType(LLVMTypeRef ElementTy,\n                                          uint64_t ElementCount) {"}]}