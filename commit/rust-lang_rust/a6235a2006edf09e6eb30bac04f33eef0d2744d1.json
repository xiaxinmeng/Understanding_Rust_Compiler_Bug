{"sha": "a6235a2006edf09e6eb30bac04f33eef0d2744d1", "node_id": "C_kwDOAAsO6NoAKGE2MjM1YTIwMDZlZGYwOWU2ZWIzMGJhYzA0ZjMzZWVmMGQyNzQ0ZDE", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2023-01-16T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2023-01-17T11:36:58Z"}, "message": "Refactor basic blocks control flow caches", "tree": {"sha": "cc7b2aa47db8781983fce4f82a65157b35f6e133", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc7b2aa47db8781983fce4f82a65157b35f6e133"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6235a2006edf09e6eb30bac04f33eef0d2744d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6235a2006edf09e6eb30bac04f33eef0d2744d1", "html_url": "https://github.com/rust-lang/rust/commit/a6235a2006edf09e6eb30bac04f33eef0d2744d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6235a2006edf09e6eb30bac04f33eef0d2744d1/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "159ba8a92c9e2fa4121f106176309521f4af87e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/159ba8a92c9e2fa4121f106176309521f4af87e9", "html_url": "https://github.com/rust-lang/rust/commit/159ba8a92c9e2fa4121f106176309521f4af87e9"}], "stats": {"total": 370, "additions": 74, "deletions": 296}, "files": [{"sha": "b3354e6e9d2a2e4c7712350e8b1a11b84113d58f", "filename": "compiler/rustc_middle/src/mir/basic_blocks.rs", "status": "modified", "additions": 74, "deletions": 24, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/a6235a2006edf09e6eb30bac04f33eef0d2744d1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6235a2006edf09e6eb30bac04f33eef0d2744d1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs?ref=a6235a2006edf09e6eb30bac04f33eef0d2744d1", "patch": "@@ -1,38 +1,44 @@\n-use crate::mir::graph_cyclic_cache::GraphIsCyclicCache;\n-use crate::mir::predecessors::{PredecessorCache, Predecessors};\n-use crate::mir::switch_sources::{SwitchSourceCache, SwitchSources};\n-use crate::mir::traversal::PostorderCache;\n-use crate::mir::{BasicBlock, BasicBlockData, Successors, START_BLOCK};\n+use crate::mir::traversal::Postorder;\n+use crate::mir::{BasicBlock, BasicBlockData, Successors, Terminator, TerminatorKind, START_BLOCK};\n \n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph;\n use rustc_data_structures::graph::dominators::{dominators, Dominators};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::sync::OnceCell;\n use rustc_index::vec::IndexVec;\n+use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n+use smallvec::SmallVec;\n \n #[derive(Clone, TyEncodable, TyDecodable, Debug, HashStable, TypeFoldable, TypeVisitable)]\n pub struct BasicBlocks<'tcx> {\n     basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n-    predecessor_cache: PredecessorCache,\n-    switch_source_cache: SwitchSourceCache,\n-    is_cyclic: GraphIsCyclicCache,\n-    postorder_cache: PostorderCache,\n+    cache: Cache,\n+}\n+\n+// Typically 95%+ of basic blocks have 4 or fewer predecessors.\n+pub type Predecessors = IndexVec<BasicBlock, SmallVec<[BasicBlock; 4]>>;\n+\n+pub type SwitchSources = FxHashMap<(BasicBlock, BasicBlock), SmallVec<[Option<u128>; 1]>>;\n+\n+#[derive(Clone, Default, Debug)]\n+struct Cache {\n+    predecessors: OnceCell<Predecessors>,\n+    switch_sources: OnceCell<SwitchSources>,\n+    is_cyclic: OnceCell<bool>,\n+    postorder: OnceCell<Vec<BasicBlock>>,\n }\n \n impl<'tcx> BasicBlocks<'tcx> {\n     #[inline]\n     pub fn new(basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>) -> Self {\n-        BasicBlocks {\n-            basic_blocks,\n-            predecessor_cache: PredecessorCache::new(),\n-            switch_source_cache: SwitchSourceCache::new(),\n-            is_cyclic: GraphIsCyclicCache::new(),\n-            postorder_cache: PostorderCache::new(),\n-        }\n+        BasicBlocks { basic_blocks, cache: Cache::default() }\n     }\n \n     /// Returns true if control-flow graph contains a cycle reachable from the `START_BLOCK`.\n     #[inline]\n     pub fn is_cfg_cyclic(&self) -> bool {\n-        self.is_cyclic.is_cyclic(self)\n+        *self.cache.is_cyclic.get_or_init(|| graph::is_cyclic(self))\n     }\n \n     #[inline]\n@@ -43,20 +49,46 @@ impl<'tcx> BasicBlocks<'tcx> {\n     /// Returns predecessors for each basic block.\n     #[inline]\n     pub fn predecessors(&self) -> &Predecessors {\n-        self.predecessor_cache.compute(&self.basic_blocks)\n+        self.cache.predecessors.get_or_init(|| {\n+            let mut preds = IndexVec::from_elem(SmallVec::new(), &self.basic_blocks);\n+            for (bb, data) in self.basic_blocks.iter_enumerated() {\n+                if let Some(term) = &data.terminator {\n+                    for succ in term.successors() {\n+                        preds[succ].push(bb);\n+                    }\n+                }\n+            }\n+            preds\n+        })\n     }\n \n     /// Returns basic blocks in a postorder.\n     #[inline]\n     pub fn postorder(&self) -> &[BasicBlock] {\n-        self.postorder_cache.compute(&self.basic_blocks)\n+        self.cache.postorder.get_or_init(|| {\n+            Postorder::new(&self.basic_blocks, START_BLOCK).map(|(bb, _)| bb).collect()\n+        })\n     }\n \n     /// `switch_sources()[&(target, switch)]` returns a list of switch\n     /// values that lead to a `target` block from a `switch` block.\n     #[inline]\n     pub fn switch_sources(&self) -> &SwitchSources {\n-        self.switch_source_cache.compute(&self.basic_blocks)\n+        self.cache.switch_sources.get_or_init(|| {\n+            let mut switch_sources: SwitchSources = FxHashMap::default();\n+            for (bb, data) in self.basic_blocks.iter_enumerated() {\n+                if let Some(Terminator {\n+                    kind: TerminatorKind::SwitchInt { targets, .. }, ..\n+                }) = &data.terminator\n+                {\n+                    for (value, target) in targets.iter() {\n+                        switch_sources.entry((target, bb)).or_default().push(Some(value));\n+                    }\n+                    switch_sources.entry((targets.otherwise(), bb)).or_default().push(None);\n+                }\n+            }\n+            switch_sources\n+        })\n     }\n \n     /// Returns mutable reference to basic blocks. Invalidates CFG cache.\n@@ -88,10 +120,7 @@ impl<'tcx> BasicBlocks<'tcx> {\n     /// All other methods that allow you to mutate the basic blocks also call this method\n     /// themselves, thereby avoiding any risk of accidentally cache invalidation.\n     pub fn invalidate_cfg_cache(&mut self) {\n-        self.predecessor_cache.invalidate();\n-        self.switch_source_cache.invalidate();\n-        self.is_cyclic.invalidate();\n-        self.postorder_cache.invalidate();\n+        self.cache = Cache::default();\n     }\n }\n \n@@ -145,3 +174,24 @@ impl<'tcx> graph::WithPredecessors for BasicBlocks<'tcx> {\n         self.predecessors()[node].iter().copied()\n     }\n }\n+\n+TrivialTypeTraversalAndLiftImpls! {\n+    Cache,\n+}\n+\n+impl<S: Encoder> Encodable<S> for Cache {\n+    #[inline]\n+    fn encode(&self, _s: &mut S) {}\n+}\n+\n+impl<D: Decoder> Decodable<D> for Cache {\n+    #[inline]\n+    fn decode(_: &mut D) -> Self {\n+        Default::default()\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for Cache {\n+    #[inline]\n+    fn hash_stable(&self, _: &mut CTX, _: &mut StableHasher) {}\n+}"}, {"sha": "f97bf2883b3691b3f9b10f5899dd2b629f25899c", "filename": "compiler/rustc_middle/src/mir/graph_cyclic_cache.rs", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/159ba8a92c9e2fa4121f106176309521f4af87e9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraph_cyclic_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159ba8a92c9e2fa4121f106176309521f4af87e9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraph_cyclic_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraph_cyclic_cache.rs?ref=159ba8a92c9e2fa4121f106176309521f4af87e9", "patch": "@@ -1,63 +0,0 @@\n-use rustc_data_structures::graph::{\n-    self, DirectedGraph, WithNumNodes, WithStartNode, WithSuccessors,\n-};\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::sync::OnceCell;\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n-\n-/// Helper type to cache the result of `graph::is_cyclic`.\n-#[derive(Clone, Debug)]\n-pub(super) struct GraphIsCyclicCache {\n-    cache: OnceCell<bool>,\n-}\n-\n-impl GraphIsCyclicCache {\n-    #[inline]\n-    pub(super) fn new() -> Self {\n-        GraphIsCyclicCache { cache: OnceCell::new() }\n-    }\n-\n-    pub(super) fn is_cyclic<G>(&self, graph: &G) -> bool\n-    where\n-        G: ?Sized + DirectedGraph + WithStartNode + WithSuccessors + WithNumNodes,\n-    {\n-        *self.cache.get_or_init(|| graph::is_cyclic(graph))\n-    }\n-\n-    /// Invalidates the cache.\n-    #[inline]\n-    pub(super) fn invalidate(&mut self) {\n-        // Invalidating the cache requires mutating the MIR, which in turn requires a unique\n-        // reference (`&mut`) to the `mir::Body`. Because of this, we can assume that all\n-        // callers of `invalidate` have a unique reference to the MIR and thus to the\n-        // cache. This means we never need to do synchronization when `invalidate` is called,\n-        // we can simply reinitialize the `OnceCell`.\n-        self.cache = OnceCell::new();\n-    }\n-}\n-\n-impl<S: Encoder> Encodable<S> for GraphIsCyclicCache {\n-    #[inline]\n-    fn encode(&self, s: &mut S) {\n-        Encodable::encode(&(), s);\n-    }\n-}\n-\n-impl<D: Decoder> Decodable<D> for GraphIsCyclicCache {\n-    #[inline]\n-    fn decode(d: &mut D) -> Self {\n-        let () = Decodable::decode(d);\n-        Self::new()\n-    }\n-}\n-\n-impl<CTX> HashStable<CTX> for GraphIsCyclicCache {\n-    #[inline]\n-    fn hash_stable(&self, _: &mut CTX, _: &mut StableHasher) {\n-        // do nothing\n-    }\n-}\n-\n-TrivialTypeTraversalAndLiftImpls! {\n-    GraphIsCyclicCache,\n-}"}, {"sha": "0424d949cc00c7522ce0a794d7470f45bee0c5ba", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6235a2006edf09e6eb30bac04f33eef0d2744d1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6235a2006edf09e6eb30bac04f33eef0d2744d1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=a6235a2006edf09e6eb30bac04f33eef0d2744d1", "patch": "@@ -47,18 +47,15 @@ mod basic_blocks;\n pub mod coverage;\n mod generic_graph;\n pub mod generic_graphviz;\n-mod graph_cyclic_cache;\n pub mod graphviz;\n pub mod interpret;\n pub mod mono;\n pub mod patch;\n-mod predecessors;\n pub mod pretty;\n mod query;\n pub mod spanview;\n mod syntax;\n pub use syntax::*;\n-mod switch_sources;\n pub mod tcx;\n pub mod terminator;\n pub use terminator::*;"}, {"sha": "5f1fadaf3bc4ceafe376b5fe3590d07589ad53ef", "filename": "compiler/rustc_middle/src/mir/predecessors.rs", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/159ba8a92c9e2fa4121f106176309521f4af87e9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpredecessors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159ba8a92c9e2fa4121f106176309521f4af87e9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpredecessors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpredecessors.rs?ref=159ba8a92c9e2fa4121f106176309521f4af87e9", "patch": "@@ -1,78 +0,0 @@\n-//! Lazily compute the reverse control-flow graph for the MIR.\n-\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::sync::OnceCell;\n-use rustc_index::vec::IndexVec;\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n-use smallvec::SmallVec;\n-\n-use crate::mir::{BasicBlock, BasicBlockData};\n-\n-// Typically 95%+ of basic blocks have 4 or fewer predecessors.\n-pub type Predecessors = IndexVec<BasicBlock, SmallVec<[BasicBlock; 4]>>;\n-\n-#[derive(Clone, Debug)]\n-pub(super) struct PredecessorCache {\n-    cache: OnceCell<Predecessors>,\n-}\n-\n-impl PredecessorCache {\n-    #[inline]\n-    pub(super) fn new() -> Self {\n-        PredecessorCache { cache: OnceCell::new() }\n-    }\n-\n-    /// Invalidates the predecessor cache.\n-    #[inline]\n-    pub(super) fn invalidate(&mut self) {\n-        // Invalidating the predecessor cache requires mutating the MIR, which in turn requires a\n-        // unique reference (`&mut`) to the `mir::Body`. Because of this, we can assume that all\n-        // callers of `invalidate` have a unique reference to the MIR and thus to the predecessor\n-        // cache. This means we never need to do synchronization when `invalidate` is called, we can\n-        // simply reinitialize the `OnceCell`.\n-        self.cache = OnceCell::new();\n-    }\n-\n-    /// Returns the predecessor graph for this MIR.\n-    #[inline]\n-    pub(super) fn compute(\n-        &self,\n-        basic_blocks: &IndexVec<BasicBlock, BasicBlockData<'_>>,\n-    ) -> &Predecessors {\n-        self.cache.get_or_init(|| {\n-            let mut preds = IndexVec::from_elem(SmallVec::new(), basic_blocks);\n-            for (bb, data) in basic_blocks.iter_enumerated() {\n-                if let Some(term) = &data.terminator {\n-                    for succ in term.successors() {\n-                        preds[succ].push(bb);\n-                    }\n-                }\n-            }\n-\n-            preds\n-        })\n-    }\n-}\n-\n-impl<S: Encoder> Encodable<S> for PredecessorCache {\n-    #[inline]\n-    fn encode(&self, _s: &mut S) {}\n-}\n-\n-impl<D: Decoder> Decodable<D> for PredecessorCache {\n-    #[inline]\n-    fn decode(_: &mut D) -> Self {\n-        Self::new()\n-    }\n-}\n-\n-impl<CTX> HashStable<CTX> for PredecessorCache {\n-    #[inline]\n-    fn hash_stable(&self, _: &mut CTX, _: &mut StableHasher) {\n-        // do nothing\n-    }\n-}\n-\n-TrivialTypeTraversalAndLiftImpls! {\n-    PredecessorCache,\n-}"}, {"sha": "b91c0c25782f410763a25aaf7da196cce73b824d", "filename": "compiler/rustc_middle/src/mir/switch_sources.rs", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/159ba8a92c9e2fa4121f106176309521f4af87e9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fswitch_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159ba8a92c9e2fa4121f106176309521f4af87e9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fswitch_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fswitch_sources.rs?ref=159ba8a92c9e2fa4121f106176309521f4af87e9", "patch": "@@ -1,78 +0,0 @@\n-//! Lazily compute the inverse of each `SwitchInt`'s switch targets. Modeled after\n-//! `Predecessors`/`PredecessorCache`.\n-\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::sync::OnceCell;\n-use rustc_index::vec::IndexVec;\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n-use smallvec::SmallVec;\n-\n-use crate::mir::{BasicBlock, BasicBlockData, Terminator, TerminatorKind};\n-\n-pub type SwitchSources = FxHashMap<(BasicBlock, BasicBlock), SmallVec<[Option<u128>; 1]>>;\n-\n-#[derive(Clone, Debug)]\n-pub(super) struct SwitchSourceCache {\n-    cache: OnceCell<SwitchSources>,\n-}\n-\n-impl SwitchSourceCache {\n-    #[inline]\n-    pub(super) fn new() -> Self {\n-        SwitchSourceCache { cache: OnceCell::new() }\n-    }\n-\n-    /// Invalidates the switch source cache.\n-    #[inline]\n-    pub(super) fn invalidate(&mut self) {\n-        self.cache = OnceCell::new();\n-    }\n-\n-    /// Returns the switch sources for this MIR.\n-    #[inline]\n-    pub(super) fn compute(\n-        &self,\n-        basic_blocks: &IndexVec<BasicBlock, BasicBlockData<'_>>,\n-    ) -> &SwitchSources {\n-        self.cache.get_or_init(|| {\n-            let mut switch_sources: SwitchSources = FxHashMap::default();\n-            for (bb, data) in basic_blocks.iter_enumerated() {\n-                if let Some(Terminator {\n-                    kind: TerminatorKind::SwitchInt { targets, .. }, ..\n-                }) = &data.terminator\n-                {\n-                    for (value, target) in targets.iter() {\n-                        switch_sources.entry((target, bb)).or_default().push(Some(value));\n-                    }\n-                    switch_sources.entry((targets.otherwise(), bb)).or_default().push(None);\n-                }\n-            }\n-\n-            switch_sources\n-        })\n-    }\n-}\n-\n-impl<S: Encoder> Encodable<S> for SwitchSourceCache {\n-    #[inline]\n-    fn encode(&self, _s: &mut S) {}\n-}\n-\n-impl<D: Decoder> Decodable<D> for SwitchSourceCache {\n-    #[inline]\n-    fn decode(_: &mut D) -> Self {\n-        Self::new()\n-    }\n-}\n-\n-impl<CTX> HashStable<CTX> for SwitchSourceCache {\n-    #[inline]\n-    fn hash_stable(&self, _: &mut CTX, _: &mut StableHasher) {\n-        // do nothing\n-    }\n-}\n-\n-TrivialTypeTraversalAndLiftImpls! {\n-    SwitchSourceCache,\n-}"}, {"sha": "f37222cb29758cf827fe943b47d613b9be389bc9", "filename": "compiler/rustc_middle/src/mir/traversal.rs", "status": "modified", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a6235a2006edf09e6eb30bac04f33eef0d2744d1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6235a2006edf09e6eb30bac04f33eef0d2744d1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs?ref=a6235a2006edf09e6eb30bac04f33eef0d2744d1", "patch": "@@ -1,7 +1,4 @@\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::sync::OnceCell;\n use rustc_index::bit_set::BitSet;\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n \n use super::*;\n \n@@ -339,50 +336,3 @@ pub fn reverse_postorder<'a, 'tcx>(body: &'a Body<'tcx>) -> ReversePostorderIter\n     let len = blocks.len();\n     ReversePostorderIter { body, blocks, idx: len }\n }\n-\n-#[derive(Clone, Debug)]\n-pub(super) struct PostorderCache {\n-    cache: OnceCell<Vec<BasicBlock>>,\n-}\n-\n-impl PostorderCache {\n-    #[inline]\n-    pub(super) fn new() -> Self {\n-        PostorderCache { cache: OnceCell::new() }\n-    }\n-\n-    /// Invalidates the postorder cache.\n-    #[inline]\n-    pub(super) fn invalidate(&mut self) {\n-        self.cache = OnceCell::new();\n-    }\n-\n-    /// Returns the `&[BasicBlocks]` represents the postorder graph for this MIR.\n-    #[inline]\n-    pub(super) fn compute(&self, body: &IndexVec<BasicBlock, BasicBlockData<'_>>) -> &[BasicBlock] {\n-        self.cache.get_or_init(|| Postorder::new(body, START_BLOCK).map(|(bb, _)| bb).collect())\n-    }\n-}\n-\n-impl<S: Encoder> Encodable<S> for PostorderCache {\n-    #[inline]\n-    fn encode(&self, _s: &mut S) {}\n-}\n-\n-impl<D: Decoder> Decodable<D> for PostorderCache {\n-    #[inline]\n-    fn decode(_: &mut D) -> Self {\n-        Self::new()\n-    }\n-}\n-\n-impl<CTX> HashStable<CTX> for PostorderCache {\n-    #[inline]\n-    fn hash_stable(&self, _: &mut CTX, _: &mut StableHasher) {\n-        // do nothing\n-    }\n-}\n-\n-TrivialTypeTraversalAndLiftImpls! {\n-    PostorderCache,\n-}"}]}