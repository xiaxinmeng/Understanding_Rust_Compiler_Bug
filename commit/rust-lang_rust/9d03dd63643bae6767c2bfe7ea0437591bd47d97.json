{"sha": "9d03dd63643bae6767c2bfe7ea0437591bd47d97", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkMDNkZDYzNjQzYmFlNjc2N2MyYmZlN2VhMDQzNzU5MWJkNDdkOTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-08T13:21:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-08T13:21:05Z"}, "message": "Auto merge of #977 - christianpoveda:last-error-ptr, r=oli-obk\n\nMove last error into memory\n\nThese changes move the `Evaluator::last_error` into miri's memory and implement the `__errno_location()` shim (which is used by the file handling functions when they fail).", "tree": {"sha": "c4b26640224d83a2f40a9c5a923354ba45e8e37f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4b26640224d83a2f40a9c5a923354ba45e8e37f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d03dd63643bae6767c2bfe7ea0437591bd47d97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d03dd63643bae6767c2bfe7ea0437591bd47d97", "html_url": "https://github.com/rust-lang/rust/commit/9d03dd63643bae6767c2bfe7ea0437591bd47d97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d03dd63643bae6767c2bfe7ea0437591bd47d97/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de4a8460275bedf616bd51a0167216e2339f5b67", "url": "https://api.github.com/repos/rust-lang/rust/commits/de4a8460275bedf616bd51a0167216e2339f5b67", "html_url": "https://github.com/rust-lang/rust/commit/de4a8460275bedf616bd51a0167216e2339f5b67"}, {"sha": "459c65a4f9b2e462037e600a511b785c78dd8f0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/459c65a4f9b2e462037e600a511b785c78dd8f0e", "html_url": "https://github.com/rust-lang/rust/commit/459c65a4f9b2e462037e600a511b785c78dd8f0e"}], "stats": {"total": 456, "additions": 276, "deletions": 180}, "files": [{"sha": "aa876d6617ce8af8ff63b3825dff4b21529bf82b", "filename": "src/eval.rs", "status": "modified", "additions": 44, "deletions": 27, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9d03dd63643bae6767c2bfe7ea0437591bd47d97/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d03dd63643bae6767c2bfe7ea0437591bd47d97/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=9d03dd63643bae6767c2bfe7ea0437591bd47d97", "patch": "@@ -3,16 +3,15 @@\n use rand::rngs::StdRng;\n use rand::SeedableRng;\n \n-use syntax::source_map::DUMMY_SP;\n-use rustc::ty::{self, TyCtxt};\n-use rustc::ty::layout::{LayoutOf, Size, Align};\n use rustc::hir::def_id::DefId;\n+use rustc::ty::layout::{Align, LayoutOf, Size};\n+use rustc::ty::{self, TyCtxt};\n+use syntax::source_map::DUMMY_SP;\n \n use crate::{\n-    InterpResult, InterpError, InterpCx, StackPopCleanup, struct_error,\n-    Scalar, Tag, Pointer, FnVal,\n-    MemoryExtra, MiriMemoryKind, Evaluator, TlsEvalContextExt, HelpersEvalContextExt,\n-    EnvVars,\n+    struct_error, EnvVars, Evaluator, FnVal, HelpersEvalContextExt, InterpCx, InterpError,\n+    InterpResult, MemoryExtra, MiriMemoryKind, Pointer, Scalar, StackPopCleanup, Tag,\n+    TlsEvalContextExt,\n };\n \n /// Configuration needed to spawn a Miri instance.\n@@ -40,7 +39,10 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         tcx.at(syntax::source_map::DUMMY_SP),\n         ty::ParamEnv::reveal_all(),\n         Evaluator::new(config.communicate),\n-        MemoryExtra::new(StdRng::seed_from_u64(config.seed.unwrap_or(0)), config.validate),\n+        MemoryExtra::new(\n+            StdRng::seed_from_u64(config.seed.unwrap_or(0)),\n+            config.validate,\n+        ),\n     );\n     // Complete initialization.\n     EnvVars::init(&mut ecx, config.excluded_env_vars);\n@@ -50,9 +52,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     let main_mir = ecx.load_mir(main_instance.def, None)?;\n \n     if !main_mir.return_ty().is_unit() || main_mir.arg_count != 0 {\n-        throw_unsup_format!(\n-            \"miri does not support main functions without `fn()` type signatures\"\n-        );\n+        throw_unsup_format!(\"miri does not support main functions without `fn()` type signatures\");\n     }\n \n     let start_id = tcx.lang_items().start_fn().unwrap();\n@@ -62,9 +62,10 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         ecx.tcx.tcx,\n         ty::ParamEnv::reveal_all(),\n         start_id,\n-        ecx.tcx.mk_substs(\n-            ::std::iter::once(ty::subst::GenericArg::from(main_ret_ty)))\n-        ).unwrap();\n+        ecx.tcx\n+            .mk_substs(::std::iter::once(ty::subst::GenericArg::from(main_ret_ty))),\n+    )\n+    .unwrap();\n     let start_mir = ecx.load_mir(start_instance.def, None)?;\n \n     if start_mir.arg_count != 3 {\n@@ -91,7 +92,9 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     let mut args = ecx.frame().body.args_iter();\n \n     // First argument: pointer to `main()`.\n-    let main_ptr = ecx.memory_mut().create_fn_alloc(FnVal::Instance(main_instance));\n+    let main_ptr = ecx\n+        .memory_mut()\n+        .create_fn_alloc(FnVal::Instance(main_instance));\n     let dest = ecx.local_place(args.next().unwrap())?;\n     ecx.write_scalar(Scalar::Ptr(main_ptr), dest)?;\n \n@@ -124,16 +127,23 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         // Add `0` terminator.\n         let mut arg = arg.into_bytes();\n         arg.push(0);\n-        argvs.push(ecx.memory_mut().allocate_static_bytes(arg.as_slice(), MiriMemoryKind::Static.into()));\n+        argvs.push(\n+            ecx.memory_mut()\n+                .allocate_static_bytes(arg.as_slice(), MiriMemoryKind::Static.into()),\n+        );\n     }\n     // Make an array with all these pointers, in the Miri memory.\n-    let argvs_layout = ecx.layout_of(ecx.tcx.mk_array(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8), argvs.len() as u64))?;\n+    let argvs_layout = ecx.layout_of(\n+        ecx.tcx\n+            .mk_array(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8), argvs.len() as u64),\n+    )?;\n     let argvs_place = ecx.allocate(argvs_layout, MiriMemoryKind::Env.into());\n     for (idx, arg) in argvs.into_iter().enumerate() {\n         let place = ecx.mplace_field(argvs_place, idx as u64)?;\n         ecx.write_scalar(Scalar::Ptr(arg), place.into())?;\n     }\n-    ecx.memory_mut().mark_immutable(argvs_place.ptr.assert_ptr().alloc_id)?;\n+    ecx.memory_mut()\n+        .mark_immutable(argvs_place.ptr.assert_ptr().alloc_id)?;\n     // Write a pointer to that place as the argument.\n     let argv = argvs_place.ptr;\n     ecx.write_scalar(argv, dest)?;\n@@ -145,7 +155,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     }\n     // Store command line as UTF-16 for Windows `GetCommandLineW`.\n     {\n-        let tcx = &{ecx.tcx.tcx};\n+        let tcx = &{ ecx.tcx.tcx };\n         let cmd_utf16: Vec<u16> = cmd.encode_utf16().collect();\n         let cmd_ptr = ecx.memory_mut().allocate(\n             Size::from_bytes(cmd_utf16.len() as u64 * 2),\n@@ -168,16 +178,22 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         }\n     }\n \n-    assert!(args.next().is_none(), \"start lang item has more arguments than expected\");\n+    assert!(\n+        args.next().is_none(),\n+        \"start lang item has more arguments than expected\"\n+    );\n+\n+    // Set the last_error to 0\n+    let errno_layout = ecx.layout_of(ecx.tcx.types.u32)?;\n+    let errno_place = ecx.allocate(errno_layout, MiriMemoryKind::Static.into());\n+    ecx.write_scalar(Scalar::from_u32(0), errno_place.into())?;\n+    let errno_ptr = ecx.check_mplace_access(errno_place.into(), Some(Size::from_bits(32)))?;\n+    ecx.machine.last_error = errno_ptr;\n \n     Ok(ecx)\n }\n \n-pub fn eval_main<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    main_id: DefId,\n-    config: MiriConfig,\n-) {\n+pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) {\n     let mut ecx = match create_ecx(tcx, main_id, config) {\n         Ok(ecx) => ecx,\n         Err(mut err) => {\n@@ -228,8 +244,9 @@ pub fn eval_main<'tcx>(\n                 // We iterate with indices because we need to look at the next frame (the caller).\n                 for idx in 0..frames.len() {\n                     let frame_info = &frames[idx];\n-                    let call_site_is_local = frames.get(idx+1).map_or(false,\n-                        |caller_info| caller_info.instance.def_id().is_local());\n+                    let call_site_is_local = frames.get(idx + 1).map_or(false, |caller_info| {\n+                        caller_info.instance.def_id().is_local()\n+                    });\n                     if call_site_is_local {\n                         err.span_note(frame_info.call_site, &frame_info.to_string());\n                     } else {"}, {"sha": "c22b3805d46ba2c12b9560e9db78f70d21b414be", "filename": "src/machine.rs", "status": "modified", "additions": 45, "deletions": 26, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9d03dd63643bae6767c2bfe7ea0437591bd47d97/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d03dd63643bae6767c2bfe7ea0437591bd47d97/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=9d03dd63643bae6767c2bfe7ea0437591bd47d97", "patch": "@@ -1,24 +1,28 @@\n //! Global machine state as well as implementation of the interpreter engine\n //! `Machine` trait.\n \n-use std::rc::Rc;\n use std::borrow::Cow;\n use std::cell::RefCell;\n+use std::rc::Rc;\n \n use rand::rngs::StdRng;\n \n-use syntax::attr;\n-use syntax::symbol::sym;\n use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, Ty, TyCtxt, layout::{Size, LayoutOf}};\n use rustc::mir;\n+use rustc::ty::{\n+    self,\n+    layout::{LayoutOf, Size},\n+    Ty, TyCtxt,\n+};\n+use syntax::attr;\n+use syntax::symbol::sym;\n \n use crate::*;\n \n // Some global facts about the emulated machine.\n-pub const PAGE_SIZE: u64 = 4*1024; // FIXME: adjust to target architecture\n-pub const STACK_ADDR: u64 = 32*PAGE_SIZE; // not really about the \"stack\", but where we start assigning integer addresses to allocations\n-pub const STACK_SIZE: u64 = 16*PAGE_SIZE; // whatever\n+pub const PAGE_SIZE: u64 = 4 * 1024; // FIXME: adjust to target architecture\n+pub const STACK_ADDR: u64 = 32 * PAGE_SIZE; // not really about the \"stack\", but where we start assigning integer addresses to allocations\n+pub const STACK_SIZE: u64 = 16 * PAGE_SIZE; // whatever\n pub const NUM_CPUS: u64 = 1;\n \n /// Extra memory kinds\n@@ -88,7 +92,7 @@ pub struct Evaluator<'tcx> {\n     pub(crate) cmd_line: Option<Pointer<Tag>>,\n \n     /// Last OS error.\n-    pub(crate) last_error: u32,\n+    pub(crate) last_error: Option<Pointer<Tag>>,\n \n     /// TLS state.\n     pub(crate) tls: TlsData<'tcx>,\n@@ -109,7 +113,7 @@ impl<'tcx> Evaluator<'tcx> {\n             argc: None,\n             argv: None,\n             cmd_line: None,\n-            last_error: 0,\n+            last_error: None,\n             tls: TlsData::default(),\n             communicate,\n             file_handler: Default::default(),\n@@ -146,7 +150,13 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     type PointerTag = Tag;\n     type ExtraFnVal = Dlsym;\n \n-    type MemoryMap = MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<Tag, Self::AllocExtra>)>;\n+    type MemoryMap = MonoHashMap<\n+        AllocId,\n+        (\n+            MemoryKind<MiriMemoryKind>,\n+            Allocation<Tag, Self::AllocExtra>,\n+        ),\n+    >;\n \n     const STATIC_KIND: Option<MiriMemoryKind> = Some(MiriMemoryKind::Static);\n \n@@ -264,8 +274,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     }\n \n     #[inline(always)]\n-    fn before_terminator(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx>\n-    {\n+    fn before_terminator(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n         // We are not interested in detecting loops.\n         Ok(())\n     }\n@@ -275,7 +284,10 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         kind: Option<MemoryKind<Self::MemoryKinds>>,\n-    ) -> (Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>, Self::PointerTag) {\n+    ) -> (\n+        Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>,\n+        Self::PointerTag,\n+    ) {\n         let kind = kind.expect(\"we set our STATIC_KIND so this cannot be None\");\n         let alloc = alloc.into_owned();\n         let (stacks, base_tag) = if !memory_extra.validate {\n@@ -291,12 +303,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         };\n         let mut stacked_borrows = memory_extra.stacked_borrows.borrow_mut();\n         let alloc: Allocation<Tag, Self::AllocExtra> = alloc.with_tags_and_extra(\n-            |alloc| if !memory_extra.validate {\n-                Tag::Untagged\n-            } else {\n-                // Only statics may already contain pointers at this point\n-                assert_eq!(kind, MiriMemoryKind::Static.into());\n-                stacked_borrows.static_base_ptr(alloc)\n+            |alloc| {\n+                if !memory_extra.validate {\n+                    Tag::Untagged\n+                } else {\n+                    // Only statics may already contain pointers at this point\n+                    assert_eq!(kind, MiriMemoryKind::Static.into());\n+                    stacked_borrows.static_base_ptr(alloc)\n+                }\n             },\n             AllocExtra {\n                 stacked_borrows: stacks,\n@@ -306,14 +320,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     }\n \n     #[inline(always)]\n-    fn tag_static_base_pointer(\n-        memory_extra: &MemoryExtra,\n-        id: AllocId,\n-    ) -> Self::PointerTag {\n+    fn tag_static_base_pointer(memory_extra: &MemoryExtra, id: AllocId) -> Self::PointerTag {\n         if !memory_extra.validate {\n             Tag::Untagged\n         } else {\n-            memory_extra.stacked_borrows.borrow_mut().static_base_ptr(id)\n+            memory_extra\n+                .stacked_borrows\n+                .borrow_mut()\n+                .static_base_ptr(id)\n         }\n     }\n \n@@ -325,7 +339,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     ) -> InterpResult<'tcx> {\n         if !Self::enforce_validity(ecx) {\n             // No tracking.\n-             Ok(())\n+            Ok(())\n         } else {\n             ecx.retag(kind, place)\n         }\n@@ -343,7 +357,12 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         extra: stacked_borrows::CallId,\n     ) -> InterpResult<'tcx> {\n-        Ok(ecx.memory().extra.stacked_borrows.borrow_mut().end_call(extra))\n+        Ok(ecx\n+            .memory()\n+            .extra\n+            .stacked_borrows\n+            .borrow_mut()\n+            .end_call(extra))\n     }\n \n     #[inline(always)]"}, {"sha": "f4b6a7c4dbac74427bbeffcd72c84b468e825e61", "filename": "src/shims/env.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d03dd63643bae6767c2bfe7ea0437591bd47d97/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d03dd63643bae6767c2bfe7ea0437591bd47d97/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=9d03dd63643bae6767c2bfe7ea0437591bd47d97", "patch": "@@ -143,12 +143,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         .write_bytes(tcx, buf, &bytes)?;\n                     return Ok(Scalar::Ptr(buf));\n                 }\n-                this.machine.last_error = this\n-                    .eval_path_scalar(&[\"libc\", \"ERANGE\"])?\n-                    .unwrap()\n-                    .to_u32()?;\n+                let erange = this.eval_libc(\"ERANGE\")?;\n+                this.set_last_error(erange)?;\n             }\n-            Err(e) => this.machine.last_error = e.raw_os_error().unwrap() as u32,\n+            Err(e) => this.consume_io_error(e)?,\n         }\n         Ok(Scalar::ptr_null(&*this.tcx))\n     }\n@@ -172,7 +170,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match env::set_current_dir(path) {\n             Ok(()) => Ok(0),\n             Err(e) => {\n-                this.machine.last_error = e.raw_os_error().unwrap() as u32;\n+                this.consume_io_error(e)?;\n                 Ok(-1)\n             }\n         }"}, {"sha": "3298eef85353c78c1abbf58bbfb71c94d43f2b00", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 178, "deletions": 118, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/9d03dd63643bae6767c2bfe7ea0437591bd47d97/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d03dd63643bae6767c2bfe7ea0437591bd47d97/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=9d03dd63643bae6767c2bfe7ea0437591bd47d97", "patch": "@@ -1,9 +1,9 @@\n use std::convert::TryInto;\n \n-use rustc_apfloat::Float;\n-use rustc::ty::layout::{Align, LayoutOf, Size};\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n+use rustc::ty::layout::{Align, LayoutOf, Size};\n+use rustc_apfloat::Float;\n use syntax::attr;\n use syntax::symbol::sym;\n \n@@ -40,42 +40,33 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Align::from_bytes(prev_power_of_two(size)).unwrap()\n     }\n \n-    fn malloc(\n-        &mut self,\n-        size: u64,\n-        zero_init: bool,\n-        kind: MiriMemoryKind,\n-    ) -> Scalar<Tag> {\n+    fn malloc(&mut self, size: u64, zero_init: bool, kind: MiriMemoryKind) -> Scalar<Tag> {\n         let this = self.eval_context_mut();\n-        let tcx = &{this.tcx.tcx};\n+        let tcx = &{ this.tcx.tcx };\n         if size == 0 {\n             Scalar::from_int(0, this.pointer_size())\n         } else {\n             let align = this.min_align(size, kind);\n-            let ptr = this.memory_mut().allocate(Size::from_bytes(size), align, kind.into());\n+            let ptr = this\n+                .memory_mut()\n+                .allocate(Size::from_bytes(size), align, kind.into());\n             if zero_init {\n                 // We just allocated this, the access cannot fail\n                 this.memory_mut()\n-                    .get_mut(ptr.alloc_id).unwrap()\n-                    .write_repeat(tcx, ptr, 0, Size::from_bytes(size)).unwrap();\n+                    .get_mut(ptr.alloc_id)\n+                    .unwrap()\n+                    .write_repeat(tcx, ptr, 0, Size::from_bytes(size))\n+                    .unwrap();\n             }\n             Scalar::Ptr(ptr)\n         }\n     }\n \n-    fn free(\n-        &mut self,\n-        ptr: Scalar<Tag>,\n-        kind: MiriMemoryKind,\n-    ) -> InterpResult<'tcx> {\n+    fn free(&mut self, ptr: Scalar<Tag>, kind: MiriMemoryKind) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         if !this.is_null(ptr)? {\n             let ptr = this.force_ptr(ptr)?;\n-            this.memory_mut().deallocate(\n-                ptr,\n-                None,\n-                kind.into(),\n-            )?;\n+            this.memory_mut().deallocate(ptr, None, kind.into())?;\n         }\n         Ok(())\n     }\n@@ -92,22 +83,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             if new_size == 0 {\n                 Ok(Scalar::from_int(0, this.pointer_size()))\n             } else {\n-                let new_ptr = this.memory_mut().allocate(\n-                    Size::from_bytes(new_size),\n-                    new_align,\n-                    kind.into()\n-                );\n+                let new_ptr =\n+                    this.memory_mut()\n+                        .allocate(Size::from_bytes(new_size), new_align, kind.into());\n                 Ok(Scalar::Ptr(new_ptr))\n             }\n         } else {\n             let old_ptr = this.force_ptr(old_ptr)?;\n             let memory = this.memory_mut();\n             if new_size == 0 {\n-                memory.deallocate(\n-                    old_ptr,\n-                    None,\n-                    kind.into(),\n-                )?;\n+                memory.deallocate(old_ptr, None, kind.into())?;\n                 Ok(Scalar::from_int(0, this.pointer_size()))\n             } else {\n                 let new_ptr = memory.reallocate(\n@@ -139,7 +124,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         };\n         // Strip linker suffixes (seen on 32-bit macOS).\n         let link_name = link_name.trim_end_matches(\"$UNIX2003\");\n-        let tcx = &{this.tcx.tcx};\n+        let tcx = &{ this.tcx.tcx };\n \n         // First: functions that diverge.\n         match link_name {\n@@ -151,8 +136,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let code = this.read_scalar(args[0])?.to_i32()?;\n                 return Err(InterpError::Exit(code).into());\n             }\n-            _ => if dest.is_none() {\n-                throw_unsup_format!(\"can't call (diverging) foreign function: {}\", link_name);\n+            _ => {\n+                if dest.is_none() {\n+                    throw_unsup_format!(\"can't call (diverging) foreign function: {}\", link_name);\n+                }\n             }\n         }\n \n@@ -168,7 +155,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"calloc\" => {\n                 let items = this.read_scalar(args[0])?.to_usize(this)?;\n                 let len = this.read_scalar(args[1])?.to_usize(this)?;\n-                let size = items.checked_mul(len).ok_or_else(|| err_panic!(Overflow(mir::BinOp::Mul)))?;\n+                let size = items\n+                    .checked_mul(len)\n+                    .ok_or_else(|| err_panic!(Overflow(mir::BinOp::Mul)))?;\n                 let res = this.malloc(size, /*zero_init:*/ true, MiriMemoryKind::C);\n                 this.write_scalar(res, dest)?;\n             }\n@@ -193,7 +182,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     let ptr = this.memory_mut().allocate(\n                         Size::from_bytes(size),\n                         Align::from_bytes(align).unwrap(),\n-                        MiriMemoryKind::C.into()\n+                        MiriMemoryKind::C.into(),\n                     );\n                     this.write_scalar(Scalar::Ptr(ptr), ret.into())?;\n                 }\n@@ -219,12 +208,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 if !align.is_power_of_two() {\n                     throw_unsup!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let ptr = this.memory_mut()\n-                    .allocate(\n-                        Size::from_bytes(size),\n-                        Align::from_bytes(align).unwrap(),\n-                        MiriMemoryKind::Rust.into()\n-                    );\n+                let ptr = this.memory_mut().allocate(\n+                    Size::from_bytes(size),\n+                    Align::from_bytes(align).unwrap(),\n+                    MiriMemoryKind::Rust.into(),\n+                );\n                 this.write_scalar(Scalar::Ptr(ptr), dest)?;\n             }\n             \"__rust_alloc_zeroed\" => {\n@@ -236,16 +224,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 if !align.is_power_of_two() {\n                     throw_unsup!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let ptr = this.memory_mut()\n-                    .allocate(\n-                        Size::from_bytes(size),\n-                        Align::from_bytes(align).unwrap(),\n-                        MiriMemoryKind::Rust.into()\n-                    );\n+                let ptr = this.memory_mut().allocate(\n+                    Size::from_bytes(size),\n+                    Align::from_bytes(align).unwrap(),\n+                    MiriMemoryKind::Rust.into(),\n+                );\n                 // We just allocated this, the access cannot fail\n                 this.memory_mut()\n-                    .get_mut(ptr.alloc_id).unwrap()\n-                    .write_repeat(tcx, ptr, 0, Size::from_bytes(size)).unwrap();\n+                    .get_mut(ptr.alloc_id)\n+                    .unwrap()\n+                    .write_repeat(tcx, ptr, 0, Size::from_bytes(size))\n+                    .unwrap();\n                 this.write_scalar(Scalar::Ptr(ptr), dest)?;\n             }\n             \"__rust_dealloc\" => {\n@@ -261,7 +250,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let ptr = this.force_ptr(ptr)?;\n                 this.memory_mut().deallocate(\n                     ptr,\n-                    Some((Size::from_bytes(old_size), Align::from_bytes(align).unwrap())),\n+                    Some((\n+                        Size::from_bytes(old_size),\n+                        Align::from_bytes(align).unwrap(),\n+                    )),\n                     MiriMemoryKind::Rust.into(),\n                 )?;\n             }\n@@ -288,7 +280,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             \"syscall\" => {\n-                let sys_getrandom = this.eval_path_scalar(&[\"libc\", \"SYS_getrandom\"])?\n+                let sys_getrandom = this\n+                    .eval_path_scalar(&[\"libc\", \"SYS_getrandom\"])?\n                     .expect(\"Failed to get libc::SYS_getrandom\")\n                     .to_usize(this)?;\n \n@@ -300,9 +293,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         // so skip over it.\n                         linux_getrandom(this, &args[1..], dest)?;\n                     }\n-                    id => {\n-                        throw_unsup_format!(\"miri does not support syscall ID {}\", id)\n-                    }\n+                    id => throw_unsup_format!(\"miri does not support syscall ID {}\", id),\n                 }\n             }\n \n@@ -342,7 +333,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // TODO: consider making this reusable? `InterpCx::step` does something similar\n                 // for the TLS destructors, and of course `eval_main`.\n                 let mir = this.load_mir(f_instance.def, None)?;\n-                let ret_place = MPlaceTy::dangling(this.layout_of(this.tcx.mk_unit())?, this).into();\n+                let ret_place =\n+                    MPlaceTy::dangling(this.layout_of(this.tcx.mk_unit())?, this).into();\n                 this.push_stack_frame(\n                     f_instance,\n                     mir.span,\n@@ -353,12 +345,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 )?;\n                 let mut args = this.frame().body.args_iter();\n \n-                let arg_local = args.next()\n+                let arg_local = args\n+                    .next()\n                     .expect(\"Argument to __rust_maybe_catch_panic does not take enough arguments.\");\n                 let arg_dest = this.local_place(arg_local)?;\n                 this.write_scalar(data, arg_dest)?;\n \n-                assert!(args.next().is_none(), \"__rust_maybe_catch_panic argument has more arguments than expected\");\n+                assert!(\n+                    args.next().is_none(),\n+                    \"__rust_maybe_catch_panic argument has more arguments than expected\"\n+                );\n \n                 // We ourselves will return `0`, eventually (because we will not return if we paniced).\n                 this.write_null(dest)?;\n@@ -384,18 +380,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     }\n                 };\n \n-                this.write_scalar(\n-                    Scalar::from_int(result, Size::from_bits(32)),\n-                    dest,\n-                )?;\n+                this.write_scalar(Scalar::from_int(result, Size::from_bits(32)), dest)?;\n             }\n \n             \"memrchr\" => {\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n                 let val = this.read_scalar(args[1])?.to_i32()? as u8;\n                 let num = this.read_scalar(args[2])?.to_usize(this)?;\n-                if let Some(idx) = this.memory().read_bytes(ptr, Size::from_bytes(num))?\n-                    .iter().rev().position(|&c| c == val)\n+                if let Some(idx) = this\n+                    .memory()\n+                    .read_bytes(ptr, Size::from_bytes(num))?\n+                    .iter()\n+                    .rev()\n+                    .position(|&c| c == val)\n                 {\n                     let new_ptr = ptr.ptr_offset(Size::from_bytes(num - idx as u64 - 1), this)?;\n                     this.write_scalar(new_ptr, dest)?;\n@@ -421,6 +418,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n \n+            \"__errno_location\" => {\n+                let errno_scalar: Scalar<Tag> = this.machine.last_error.unwrap().into();\n+                this.write_scalar(errno_scalar, dest)?;\n+            }\n+\n             \"getenv\" => {\n                 let result = this.getenv(args[0])?;\n                 this.write_scalar(result, dest)?;\n@@ -497,10 +499,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     this.write(args[0], args[1], args[2])?\n                 };\n                 // Now, `result` is the value we return back to the program.\n-                this.write_scalar(\n-                    Scalar::from_int(result, dest.layout.size),\n-                    dest,\n-                )?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n \n             \"strlen\" => {\n@@ -510,8 +509,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             // math functions\n-\n-            \"cbrtf\" | \"coshf\" | \"sinhf\" |\"tanf\" => {\n+            \"cbrtf\" | \"coshf\" | \"sinhf\" | \"tanf\" => {\n                 // FIXME: Using host floats.\n                 let f = f32::from_bits(this.read_scalar(args[0])?.to_u32()?);\n                 let f = match link_name {\n@@ -591,9 +589,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 trace!(\"sysconf() called with name {}\", name);\n                 // TODO: Cache the sysconf integers via Miri's global cache.\n                 let paths = &[\n-                    (&[\"libc\", \"_SC_PAGESIZE\"], Scalar::from_int(PAGE_SIZE, dest.layout.size)),\n-                    (&[\"libc\", \"_SC_GETPW_R_SIZE_MAX\"], Scalar::from_int(-1, dest.layout.size)),\n-                    (&[\"libc\", \"_SC_NPROCESSORS_ONLN\"], Scalar::from_int(NUM_CPUS, dest.layout.size)),\n+                    (\n+                        &[\"libc\", \"_SC_PAGESIZE\"],\n+                        Scalar::from_int(PAGE_SIZE, dest.layout.size),\n+                    ),\n+                    (\n+                        &[\"libc\", \"_SC_GETPW_R_SIZE_MAX\"],\n+                        Scalar::from_int(-1, dest.layout.size),\n+                    ),\n+                    (\n+                        &[\"libc\", \"_SC_NPROCESSORS_ONLN\"],\n+                        Scalar::from_int(NUM_CPUS, dest.layout.size),\n+                    ),\n                 ];\n                 let mut result = None;\n                 for &(path, path_value) in paths {\n@@ -603,7 +610,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                             result = Some(path_value);\n                             break;\n                         }\n-\n                     }\n                 }\n                 if let Some(result) = result {\n@@ -644,11 +650,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n                 // Create key and write it into the memory where `key_ptr` wants it.\n                 let key = this.machine.tls.create_tls_key(dtor) as u128;\n-                if key_layout.size.bits() < 128 && key >= (1u128 << key_layout.size.bits() as u128) {\n+                if key_layout.size.bits() < 128 && key >= (1u128 << key_layout.size.bits() as u128)\n+                {\n                     throw_unsup!(OutOfTls);\n                 }\n \n-                let key_ptr = this.memory().check_ptr_access(key_ptr, key_layout.size, key_layout.align.abi)?\n+                let key_ptr = this\n+                    .memory()\n+                    .check_ptr_access(key_ptr, key_layout.size, key_layout.align.abi)?\n                     .expect(\"cannot be a ZST\");\n                 this.memory_mut().get_mut(key_ptr.alloc_id)?.write_scalar(\n                     tcx,\n@@ -681,8 +690,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             // Stack size/address stuff.\n-            \"pthread_attr_init\" | \"pthread_attr_destroy\" | \"pthread_self\" |\n-            \"pthread_attr_setstacksize\" => {\n+            \"pthread_attr_init\"\n+            | \"pthread_attr_destroy\"\n+            | \"pthread_self\"\n+            | \"pthread_attr_setstacksize\" => {\n                 this.write_null(dest)?;\n             }\n             \"pthread_attr_getstack\" => {\n@@ -708,12 +719,22 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             // Stub out calls for condvar, mutex and rwlock, to just return `0`.\n-            \"pthread_mutexattr_init\" | \"pthread_mutexattr_settype\" | \"pthread_mutex_init\" |\n-            \"pthread_mutexattr_destroy\" | \"pthread_mutex_lock\" | \"pthread_mutex_unlock\" |\n-            \"pthread_mutex_destroy\" | \"pthread_rwlock_rdlock\" | \"pthread_rwlock_unlock\" |\n-            \"pthread_rwlock_wrlock\" | \"pthread_rwlock_destroy\" | \"pthread_condattr_init\" |\n-            \"pthread_condattr_setclock\" | \"pthread_cond_init\" | \"pthread_condattr_destroy\" |\n-            \"pthread_cond_destroy\" => {\n+            \"pthread_mutexattr_init\"\n+            | \"pthread_mutexattr_settype\"\n+            | \"pthread_mutex_init\"\n+            | \"pthread_mutexattr_destroy\"\n+            | \"pthread_mutex_lock\"\n+            | \"pthread_mutex_unlock\"\n+            | \"pthread_mutex_destroy\"\n+            | \"pthread_rwlock_rdlock\"\n+            | \"pthread_rwlock_unlock\"\n+            | \"pthread_rwlock_wrlock\"\n+            | \"pthread_rwlock_destroy\"\n+            | \"pthread_condattr_init\"\n+            | \"pthread_condattr_setclock\"\n+            | \"pthread_cond_init\"\n+            | \"pthread_condattr_destroy\"\n+            | \"pthread_cond_destroy\" => {\n                 this.write_null(dest)?;\n             }\n \n@@ -745,13 +766,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"_tlv_atexit\" => {\n                 // FIXME: register the destructor.\n-            },\n+            }\n             \"_NSGetArgc\" => {\n                 this.write_scalar(Scalar::Ptr(this.machine.argc.unwrap()), dest)?;\n-            },\n+            }\n             \"_NSGetArgv\" => {\n                 this.write_scalar(Scalar::Ptr(this.machine.argv.unwrap()), dest)?;\n-            },\n+            }\n             \"SecRandomCopyBytes\" => {\n                 let len = this.read_scalar(args[1])?.to_usize(this)?;\n                 let ptr = this.read_scalar(args[2])?.not_undef()?;\n@@ -792,42 +813,45 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             \"SetLastError\" => {\n-                let err = this.read_scalar(args[0])?.to_u32()?;\n-                this.machine.last_error = err;\n+                this.set_last_error(this.read_scalar(args[0])?.not_undef()?)?;\n             }\n             \"GetLastError\" => {\n-                this.write_scalar(Scalar::from_u32(this.machine.last_error), dest)?;\n+                let last_error = this.get_last_error()?;\n+                this.write_scalar(last_error, dest)?;\n             }\n \n             \"AddVectoredExceptionHandler\" => {\n                 // Any non zero value works for the stdlib. This is just used for stack overflows anyway.\n                 this.write_scalar(Scalar::from_int(1, dest.layout.size), dest)?;\n-            },\n-            \"InitializeCriticalSection\" |\n-            \"EnterCriticalSection\" |\n-            \"LeaveCriticalSection\" |\n-            \"DeleteCriticalSection\" => {\n+            }\n+            \"InitializeCriticalSection\"\n+            | \"EnterCriticalSection\"\n+            | \"LeaveCriticalSection\"\n+            | \"DeleteCriticalSection\" => {\n                 // Nothing to do, not even a return value.\n-            },\n-            \"GetModuleHandleW\" |\n-            \"GetProcAddress\" |\n-            \"TryEnterCriticalSection\" |\n-            \"GetConsoleScreenBufferInfo\" |\n-            \"SetConsoleTextAttribute\" => {\n+            }\n+            \"GetModuleHandleW\"\n+            | \"GetProcAddress\"\n+            | \"TryEnterCriticalSection\"\n+            | \"GetConsoleScreenBufferInfo\"\n+            | \"SetConsoleTextAttribute\" => {\n                 // Pretend these do not exist / nothing happened, by returning zero.\n                 this.write_null(dest)?;\n-            },\n+            }\n             \"GetSystemInfo\" => {\n                 let system_info = this.deref_operand(args[0])?;\n-                let system_info_ptr = this.check_mplace_access(system_info, None)?\n+                let system_info_ptr = this\n+                    .check_mplace_access(system_info, None)?\n                     .expect(\"cannot be a ZST\");\n                 // Initialize with `0`.\n-                this.memory_mut().get_mut(system_info_ptr.alloc_id)?\n+                this.memory_mut()\n+                    .get_mut(system_info_ptr.alloc_id)?\n                     .write_repeat(tcx, system_info_ptr, 0, system_info.layout.size)?;\n                 // Set number of processors.\n                 let dword_size = Size::from_bytes(4);\n-                let offset = 2*dword_size + 3*tcx.pointer_size();\n-                this.memory_mut().get_mut(system_info_ptr.alloc_id)?\n+                let offset = 2 * dword_size + 3 * tcx.pointer_size();\n+                this.memory_mut()\n+                    .get_mut(system_info_ptr.alloc_id)?\n                     .write_scalar(\n                         tcx,\n                         system_info_ptr.offset(offset, tcx)?,\n@@ -844,7 +868,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n                 // Figure out how large a TLS key actually is. This is `c::DWORD`.\n                 if dest.layout.size.bits() < 128\n-                        && key >= (1u128 << dest.layout.size.bits() as u128) {\n+                    && key >= (1u128 << dest.layout.size.bits() as u128)\n+                {\n                     throw_unsup!(OutOfTls);\n                 }\n                 this.write_scalar(Scalar::from_uint(key, dest.layout.size), dest)?;\n@@ -879,7 +904,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     // stdout/stderr\n                     use std::io::{self, Write};\n \n-                    let buf_cont = this.memory().read_bytes(buf, Size::from_bytes(u64::from(n)))?;\n+                    let buf_cont = this\n+                        .memory()\n+                        .read_bytes(buf, Size::from_bytes(u64::from(n)))?;\n                     let res = if handle == -11 {\n                         io::stdout().write(buf_cont)\n                     } else {\n@@ -907,7 +934,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"GetEnvironmentVariableW\" => {\n                 // This is not the env var you are looking for.\n-                this.machine.last_error = 203; // ERROR_ENVVAR_NOT_FOUND\n+                this.set_last_error(Scalar::from_u32(203))?; // ERROR_ENVVAR_NOT_FOUND\n                 this.write_null(dest)?;\n             }\n             \"GetCommandLineW\" => {\n@@ -922,9 +949,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             // We can't execute anything else.\n-            _ => {\n-                throw_unsup_format!(\"can't call foreign function: {}\", link_name)\n-            }\n+            _ => throw_unsup_format!(\"can't call foreign function: {}\", link_name),\n         }\n \n         this.goto_block(Some(ret))?;\n@@ -934,7 +959,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     /// Evaluates the scalar at the specified path. Returns Some(val)\n     /// if the path could be resolved, and None otherwise\n-    fn eval_path_scalar(&mut self, path: &[&str]) -> InterpResult<'tcx, Option<ScalarMaybeUndef<Tag>>> {\n+    fn eval_path_scalar(\n+        &mut self,\n+        path: &[&str],\n+    ) -> InterpResult<'tcx, Option<ScalarMaybeUndef<Tag>>> {\n         let this = self.eval_context_mut();\n         if let Ok(instance) = this.resolve_path(path) {\n             let cid = GlobalId {\n@@ -948,12 +976,44 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         return Ok(None);\n     }\n \n-    fn eval_libc_i32(&mut self, name: &str) -> InterpResult<'tcx, i32> {\n-        self\n-            .eval_context_mut()\n+    fn eval_libc(&mut self, name: &str) -> InterpResult<'tcx, Scalar<Tag>> {\n+        self.eval_context_mut()\n             .eval_path_scalar(&[\"libc\", name])?\n             .ok_or_else(|| err_unsup_format!(\"Path libc::{} cannot be resolved.\", name).into())\n-            .and_then(|scalar| scalar.to_i32())\n+            .and_then(|scalar| scalar.not_undef())\n+    }\n+\n+    fn eval_libc_i32(&mut self, name: &str) -> InterpResult<'tcx, i32> {\n+        self.eval_libc(name).and_then(|scalar| scalar.to_i32())\n+    }\n+\n+    fn set_last_error(&mut self, scalar: Scalar<Tag>) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let tcx = &{ this.tcx.tcx };\n+        let errno_ptr = this.machine.last_error.unwrap();\n+        this.memory_mut().get_mut(errno_ptr.alloc_id)?.write_scalar(\n+            tcx,\n+            errno_ptr,\n+            scalar.into(),\n+            Size::from_bits(32),\n+        )\n+    }\n+\n+    fn get_last_error(&mut self) -> InterpResult<'tcx, Scalar<Tag>> {\n+        let this = self.eval_context_mut();\n+        let tcx = &{ this.tcx.tcx };\n+        let errno_ptr = this.machine.last_error.unwrap();\n+        this.memory()\n+            .get(errno_ptr.alloc_id)?\n+            .read_scalar(tcx, errno_ptr, Size::from_bits(32))?\n+            .not_undef()\n+    }\n+\n+    fn consume_io_error(&mut self, e: std::io::Error) -> InterpResult<'tcx> {\n+        self.eval_context_mut().set_last_error(Scalar::from_int(\n+            e.raw_os_error().unwrap(),\n+            Size::from_bits(32),\n+        ))\n     }\n }\n "}, {"sha": "ca3f500f5a47ff54c1b79ea3d4417710e2edcaa2", "filename": "src/shims/io.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d03dd63643bae6767c2bfe7ea0437591bd47d97/src%2Fshims%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d03dd63643bae6767c2bfe7ea0437591bd47d97/src%2Fshims%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fio.rs?ref=9d03dd63643bae6767c2bfe7ea0437591bd47d97", "patch": "@@ -221,7 +221,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if let Some(handle) = this.machine.file_handler.handles.get(&fd) {\n             f(handle)\n         } else {\n-            this.machine.last_error = this.eval_libc_i32(\"EBADF\")? as u32;\n+            let ebadf = this.eval_libc(\"EBADF\")?;\n+            this.set_last_error(ebadf)?;\n             Ok((-1).into())\n         }\n     }\n@@ -244,7 +245,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if let Some(handle) = this.machine.file_handler.handles.remove(&fd) {\n             f(handle, this)\n         } else {\n-            this.machine.last_error = this.eval_libc_i32(\"EBADF\")? as u32;\n+            let ebadf = this.eval_libc(\"EBADF\")?;\n+            this.set_last_error(ebadf)?;\n             Ok((-1).into())\n         }\n     }\n@@ -262,7 +264,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match result {\n             Ok(ok) => Ok(ok),\n             Err(e) => {\n-                self.eval_context_mut().machine.last_error = e.raw_os_error().unwrap() as u32;\n+                self.eval_context_mut().consume_io_error(e)?;\n                 Ok((-1).into())\n             }\n         }"}]}