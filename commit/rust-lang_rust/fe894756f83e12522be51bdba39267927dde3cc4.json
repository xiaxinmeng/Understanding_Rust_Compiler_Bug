{"sha": "fe894756f83e12522be51bdba39267927dde3cc4", "node_id": "C_kwDOAAsO6NoAKGZlODk0NzU2ZjgzZTEyNTIyYmU1MWJkYmEzOTI2NzkyN2RkZTNjYzQ", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-08-02T06:02:04Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-08-04T13:50:56Z"}, "message": "Add `traits::fully_solve_obligation` that acts like `traits::fully_normalize`\n\nIt spawns up a trait engine, registers the single obligation, then fully\nsolves it", "tree": {"sha": "50e45d4091a5200cfae95a6b4ee1b3e59ebb4e0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50e45d4091a5200cfae95a6b4ee1b3e59ebb4e0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe894756f83e12522be51bdba39267927dde3cc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe894756f83e12522be51bdba39267927dde3cc4", "html_url": "https://github.com/rust-lang/rust/commit/fe894756f83e12522be51bdba39267927dde3cc4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe894756f83e12522be51bdba39267927dde3cc4/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e48434cc7041ac7c136d7bd1e7cadc3521f8abc", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e48434cc7041ac7c136d7bd1e7cadc3521f8abc", "html_url": "https://github.com/rust-lang/rust/commit/3e48434cc7041ac7c136d7bd1e7cadc3521f8abc"}], "stats": {"total": 175, "additions": 78, "deletions": 97}, "files": [{"sha": "45dadcfff2e5b9a5ebafdeba23b8574ce29eee1c", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe894756f83e12522be51bdba39267927dde3cc4/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe894756f83e12522be51bdba39267927dde3cc4/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=fe894756f83e12522be51bdba39267927dde3cc4", "patch": "@@ -5,12 +5,11 @@\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::LangItem;\n use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::traits::TraitEngine;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, subst::SubstsRef, AdtDef, Ty};\n use rustc_span::DUMMY_SP;\n use rustc_trait_selection::traits::{\n-    self, ImplSource, Obligation, ObligationCause, SelectionContext, TraitEngineExt,\n+    self, ImplSource, Obligation, ObligationCause, SelectionContext,\n };\n \n use super::ConstCx;\n@@ -189,15 +188,8 @@ impl Qualif for NeedsNonConstDrop {\n                 return false;\n             }\n \n-            // If we successfully found one, then select all of the predicates\n-            // implied by our const drop impl.\n-            let mut fcx = <dyn TraitEngine<'tcx>>::new(cx.tcx);\n-            for nested in impl_src.nested_obligations() {\n-                fcx.register_predicate_obligation(&infcx, nested);\n-            }\n-\n             // If we had any errors, then it's bad\n-            !fcx.select_all_or_error(&infcx).is_empty()\n+            !traits::fully_solve_obligations(&infcx, impl_src.nested_obligations()).is_empty()\n         })\n     }\n "}, {"sha": "6b230210888503d1c34412684eff79fbacd4f186", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe894756f83e12522be51bdba39267927dde3cc4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe894756f83e12522be51bdba39267927dde3cc4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=fe894756f83e12522be51bdba39267927dde3cc4", "patch": "@@ -205,10 +205,8 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n             // At this point, we already have all of the bounds we need. FulfillmentContext is used\n             // to store all of the necessary region/lifetime bounds in the InferContext, as well as\n             // an additional sanity check.\n-            let mut fulfill = <dyn TraitEngine<'tcx>>::new(tcx);\n-            fulfill.register_bound(&infcx, full_env, ty, trait_did, ObligationCause::dummy());\n-            let errors = fulfill.select_all_or_error(&infcx);\n-\n+            let errors =\n+                super::fully_solve_bound(&infcx, ObligationCause::dummy(), full_env, ty, trait_did);\n             if !errors.is_empty() {\n                 panic!(\"Unable to fulfill trait {:?} for '{:?}': {:?}\", trait_did, ty, errors);\n             }"}, {"sha": "8ab1aa65d3a9f43dccd5460bbdc5f3dce4af1a1e", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe894756f83e12522be51bdba39267927dde3cc4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe894756f83e12522be51bdba39267927dde3cc4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=fe894756f83e12522be51bdba39267927dde3cc4", "patch": "@@ -10,14 +10,14 @@ use crate::traits::select::IntercrateAmbiguityCause;\n use crate::traits::util::impl_subject_and_oblig;\n use crate::traits::SkipLeakCheck;\n use crate::traits::{\n-    self, FulfillmentContext, Normalized, Obligation, ObligationCause, PredicateObligation,\n-    PredicateObligations, SelectionContext, TraitEngineExt,\n+    self, Normalized, Obligation, ObligationCause, PredicateObligation, PredicateObligations,\n+    SelectionContext,\n };\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n-use rustc_infer::traits::{util, TraitEngine};\n+use rustc_infer::traits::util;\n use rustc_middle::traits::specialization_graph::OverlapMode;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::subst::Subst;\n@@ -384,16 +384,11 @@ fn resolve_negative_obligation<'cx, 'tcx>(\n         return false;\n     };\n \n-    let mut fulfillment_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n-    fulfillment_cx.register_predicate_obligation(infcx, o);\n-\n-    let errors = fulfillment_cx.select_all_or_error(infcx);\n-\n+    let errors = super::fully_solve_obligation(infcx, o);\n     if !errors.is_empty() {\n         return false;\n     }\n \n-    // FIXME -- also add \"assumed to be well formed\" types into the `outlives_env`\n     let outlives_env = OutlivesEnvironment::new(param_env);\n     infcx.process_registered_region_obligations(outlives_env.region_bound_pairs(), param_env);\n "}, {"sha": "5fc0128d8c6b4bf2fd0d02666203061042c052d3", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 36, "deletions": 7, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fe894756f83e12522be51bdba39267927dde3cc4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe894756f83e12522be51bdba39267927dde3cc4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=fe894756f83e12522be51bdba39267927dde3cc4", "patch": "@@ -30,6 +30,7 @@ use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n+use rustc_infer::traits::TraitEngineExt as _;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n use rustc_middle::ty::visit::TypeVisitable;\n@@ -161,22 +162,20 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'tcx>(\n         // this function's result remains infallible, we must confirm\n         // that guess. While imperfect, I believe this is sound.\n \n-        // The handling of regions in this area of the code is terrible,\n-        // see issue #29149. We should be able to improve on this with\n-        // NLL.\n-        let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n-\n         // We can use a dummy node-id here because we won't pay any mind\n         // to region obligations that arise (there shouldn't really be any\n         // anyhow).\n         let cause = ObligationCause::misc(span, hir::CRATE_HIR_ID);\n \n-        fulfill_cx.register_bound(infcx, param_env, ty, def_id, cause);\n+        // The handling of regions in this area of the code is terrible,\n+        // see issue #29149. We should be able to improve on this with\n+        // NLL.\n+        let errors = fully_solve_bound(infcx, cause, param_env, ty, def_id);\n \n         // Note: we only assume something is `Copy` if we can\n         // *definitively* show that it implements `Copy`. Otherwise,\n         // assume it is move; linear is always ok.\n-        match fulfill_cx.select_all_or_error(infcx).as_slice() {\n+        match &errors[..] {\n             [] => {\n                 debug!(\n                     \"type_known_to_meet_bound_modulo_regions: ty={:?} bound={} success\",\n@@ -413,6 +412,36 @@ where\n     Ok(resolved_value)\n }\n \n+pub fn fully_solve_obligation<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n+    obligation: PredicateObligation<'tcx>,\n+) -> Vec<FulfillmentError<'tcx>> {\n+    let mut engine = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n+    engine.register_predicate_obligation(infcx, obligation);\n+    engine.select_all_or_error(infcx)\n+}\n+\n+pub fn fully_solve_obligations<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n+    obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>,\n+) -> Vec<FulfillmentError<'tcx>> {\n+    let mut engine = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n+    engine.register_predicate_obligations(infcx, obligations);\n+    engine.select_all_or_error(infcx)\n+}\n+\n+pub fn fully_solve_bound<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    ty: Ty<'tcx>,\n+    bound: DefId,\n+) -> Vec<FulfillmentError<'tcx>> {\n+    let mut engine = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n+    engine.register_bound(infcx, param_env, ty, bound, cause);\n+    engine.select_all_or_error(infcx)\n+}\n+\n /// Normalizes the predicates and checks whether they hold in an empty environment. If this\n /// returns true, then either normalize encountered an error or one of the predicates did not\n /// hold. Used when creating vtables to check for unsatisfiable methods."}, {"sha": "f6e196e31414ccc64f54044256fcc90e64108328", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/custom.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe894756f83e12522be51bdba39267927dde3cc4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe894756f83e12522be51bdba39267927dde3cc4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=fe894756f83e12522be51bdba39267927dde3cc4", "patch": "@@ -1,11 +1,9 @@\n use crate::infer::canonical::query_response;\n use crate::infer::{InferCtxt, InferOk};\n-use crate::traits::engine::TraitEngineExt as _;\n+use crate::traits;\n use crate::traits::query::type_op::TypeOpOutput;\n use crate::traits::query::Fallible;\n-use crate::traits::TraitEngine;\n use rustc_infer::infer::region_constraints::RegionConstraintData;\n-use rustc_infer::traits::TraitEngineExt as _;\n use rustc_span::source_map::DUMMY_SP;\n \n use std::fmt;\n@@ -62,8 +60,6 @@ pub fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n     infcx: &InferCtxt<'_, 'tcx>,\n     op: impl FnOnce() -> Fallible<InferOk<'tcx, R>>,\n ) -> Fallible<(TypeOpOutput<'tcx, Op>, RegionConstraintData<'tcx>)> {\n-    let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-\n     // During NLL, we expect that nobody will register region\n     // obligations **except** as part of a custom type op (and, at the\n     // end of each custom type op, we scrape out the region\n@@ -77,8 +73,7 @@ pub fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n     );\n \n     let InferOk { value, obligations } = infcx.commit_if_ok(|_| op())?;\n-    fulfill_cx.register_predicate_obligations(infcx, obligations);\n-    let errors = fulfill_cx.select_all_or_error(infcx);\n+    let errors = traits::fully_solve_obligations(infcx, obligations);\n     if !errors.is_empty() {\n         infcx.tcx.sess.diagnostic().delay_span_bug(\n             DUMMY_SP,"}, {"sha": "0f76fef0eee228168c49a3d5128776dd1338574f", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe894756f83e12522be51bdba39267927dde3cc4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe894756f83e12522be51bdba39267927dde3cc4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=fe894756f83e12522be51bdba39267927dde3cc4", "patch": "@@ -14,9 +14,7 @@ use specialization_graph::GraphExt;\n \n use crate::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use crate::traits::select::IntercrateAmbiguityCause;\n-use crate::traits::{\n-    self, coherence, FutureCompatOverlapErrorKind, ObligationCause, TraitEngine, TraitEngineExt,\n-};\n+use crate::traits::{self, coherence, FutureCompatOverlapErrorKind, ObligationCause};\n use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_errors::{struct_span_err, EmissionGuarantee, LintDiagnosticBuilder};\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -26,8 +24,8 @@ use rustc_session::lint::builtin::COHERENCE_LEAK_CHECK;\n use rustc_session::lint::builtin::ORDER_DEPENDENT_TRAIT_OBJECTS;\n use rustc_span::{Span, DUMMY_SP};\n \n+use super::util;\n use super::SelectionContext;\n-use super::{util, FulfillmentContext};\n \n /// Information pertinent to an overlapping impl error.\n #[derive(Debug)]\n@@ -210,11 +208,8 @@ fn fulfill_implication<'a, 'tcx>(\n     // (which are packed up in penv)\n \n     infcx.save_and_restore_in_snapshot_flag(|infcx| {\n-        let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n-        for oblig in obligations.chain(more_obligations) {\n-            fulfill_cx.register_predicate_obligation(&infcx, oblig);\n-        }\n-        match fulfill_cx.select_all_or_error(infcx).as_slice() {\n+        let errors = traits::fully_solve_obligations(&infcx, obligations.chain(more_obligations));\n+        match &errors[..] {\n             [] => {\n                 debug!(\n                     \"fulfill_implication: an impl for {:?} specializes {:?}\","}, {"sha": "043e21fc1e32b320728035a9963ed879046a1123", "filename": "compiler/rustc_typeck/src/coherence/builtin.rs", "status": "modified", "additions": 19, "deletions": 30, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/fe894756f83e12522be51bdba39267927dde3cc4/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe894756f83e12522be51bdba39267927dde3cc4/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=fe894756f83e12522be51bdba39267927dde3cc4", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::ty::{self, suggest_constraining_type_params, Ty, TyCtxt, TypeV\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n use rustc_trait_selection::traits::misc::{can_type_implement_copy, CopyImplementationError};\n use rustc_trait_selection::traits::predicate_for_trait_def;\n-use rustc_trait_selection::traits::{self, ObligationCause, TraitEngine, TraitEngineExt};\n+use rustc_trait_selection::traits::{self, ObligationCause};\n use std::collections::BTreeMap;\n \n pub fn check_trait(tcx: TyCtxt<'_>, trait_def_id: DefId) {\n@@ -109,15 +109,13 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n                 // it is not immediately clear why Copy is not implemented for a field, since\n                 // all we point at is the field itself.\n                 tcx.infer_ctxt().ignoring_regions().enter(|infcx| {\n-                    let mut fulfill_cx = <dyn TraitEngine<'_>>::new(tcx);\n-                    fulfill_cx.register_bound(\n+                    for error in traits::fully_solve_bound(\n                         &infcx,\n+                        traits::ObligationCause::dummy_with_span(field_ty_span),\n                         param_env,\n                         ty,\n                         tcx.lang_items().copy_trait().unwrap(),\n-                        traits::ObligationCause::dummy_with_span(field_ty_span),\n-                    );\n-                    for error in fulfill_cx.select_all_or_error(&infcx) {\n+                    ) {\n                         let error_predicate = error.obligation.predicate;\n                         // Only note if it's not the root obligation, otherwise it's trivial and\n                         // should be self-explanatory (i.e. a field literally doesn't implement Copy).\n@@ -315,24 +313,20 @@ fn visit_implementation_of_dispatch_from_dyn<'tcx>(tcx: TyCtxt<'tcx>, impl_did:\n                     ))\n                     .emit();\n                 } else {\n-                    let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-\n-                    for field in coerced_fields {\n-                        let predicate = predicate_for_trait_def(\n-                            tcx,\n-                            param_env,\n-                            cause.clone(),\n-                            dispatch_from_dyn_trait,\n-                            0,\n-                            field.ty(tcx, substs_a),\n-                            &[field.ty(tcx, substs_b).into()],\n-                        );\n-\n-                        fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-                    }\n-\n-                    // Check that all transitive obligations are satisfied.\n-                    let errors = fulfill_cx.select_all_or_error(&infcx);\n+                    let errors = traits::fully_solve_obligations(\n+                        &infcx,\n+                        coerced_fields.into_iter().map(|field| {\n+                            predicate_for_trait_def(\n+                                tcx,\n+                                param_env,\n+                                cause.clone(),\n+                                dispatch_from_dyn_trait,\n+                                0,\n+                                field.ty(tcx, substs_a),\n+                                &[field.ty(tcx, substs_b).into()],\n+                            )\n+                        }),\n+                    );\n                     if !errors.is_empty() {\n                         infcx.report_fulfillment_errors(&errors, None, false);\n                     }\n@@ -573,8 +567,6 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n             }\n         };\n \n-        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-\n         // Register an obligation for `A: Trait<B>`.\n         let cause = traits::ObligationCause::misc(span, impl_hir_id);\n         let predicate = predicate_for_trait_def(\n@@ -586,10 +578,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n             source,\n             &[target.into()],\n         );\n-        fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-\n-        // Check that all transitive obligations are satisfied.\n-        let errors = fulfill_cx.select_all_or_error(&infcx);\n+        let errors = traits::fully_solve_obligation(&infcx, predicate);\n         if !errors.is_empty() {\n             infcx.report_fulfillment_errors(&errors, None, false);\n         }"}, {"sha": "fd9715e6ca37481b7f6b038a5838a2ba465abec8", "filename": "compiler/rustc_typeck/src/hir_wf_check.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe894756f83e12522be51bdba39267927dde3cc4/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe894756f83e12522be51bdba39267927dde3cc4/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs?ref=fe894756f83e12522be51bdba39267927dde3cc4", "patch": "@@ -3,11 +3,10 @@ use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{ForeignItem, ForeignItemKind, HirId};\n use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::traits::TraitEngine;\n use rustc_infer::traits::{ObligationCause, WellFormedLoc};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Region, ToPredicate, TyCtxt, TypeFoldable, TypeFolder};\n-use rustc_trait_selection::traits::{self, TraitEngineExt};\n+use rustc_trait_selection::traits;\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers { diagnostic_hir_wf_check, ..*providers };\n@@ -66,15 +65,14 @@ fn diagnostic_hir_wf_check<'tcx>(\n     impl<'tcx> Visitor<'tcx> for HirWfCheck<'tcx> {\n         fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n             self.tcx.infer_ctxt().enter(|infcx| {\n-                let mut fulfill = <dyn TraitEngine<'tcx>>::new(self.tcx);\n                 let tcx_ty =\n                     self.icx.to_ty(ty).fold_with(&mut EraseAllBoundRegions { tcx: self.tcx });\n                 let cause = traits::ObligationCause::new(\n                     ty.span,\n                     self.hir_id,\n                     traits::ObligationCauseCode::WellFormed(None),\n                 );\n-                fulfill.register_predicate_obligation(\n+                let errors = traits::fully_solve_obligation(\n                     &infcx,\n                     traits::Obligation::new(\n                         cause,\n@@ -83,8 +81,6 @@ fn diagnostic_hir_wf_check<'tcx>(\n                             .to_predicate(self.tcx),\n                     ),\n                 );\n-\n-                let errors = fulfill.select_all_or_error(&infcx);\n                 if !errors.is_empty() {\n                     debug!(\"Wf-check got errors for {:?}: {:?}\", ty, errors);\n                     for error in errors {"}, {"sha": "1563f3552c54133457088b77ce526b58e8fc8139", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe894756f83e12522be51bdba39267927dde3cc4/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe894756f83e12522be51bdba39267927dde3cc4/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=fe894756f83e12522be51bdba39267927dde3cc4", "patch": "@@ -104,7 +104,6 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{Node, CRATE_HIR_ID};\n use rustc_infer::infer::{InferOk, TyCtxtInferExt};\n-use rustc_infer::traits::TraitEngineExt as _;\n use rustc_middle::middle;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -113,9 +112,7 @@ use rustc_session::config::EntryFnType;\n use rustc_span::{symbol::sym, Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n-use rustc_trait_selection::traits::{\n-    self, ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt as _,\n-};\n+use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n \n use std::iter;\n \n@@ -147,18 +144,15 @@ fn require_same_types<'tcx>(\n ) -> bool {\n     tcx.infer_ctxt().enter(|ref infcx| {\n         let param_env = ty::ParamEnv::empty();\n-        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-        match infcx.at(cause, param_env).eq(expected, actual) {\n-            Ok(InferOk { obligations, .. }) => {\n-                fulfill_cx.register_predicate_obligations(infcx, obligations);\n-            }\n+        let errors = match infcx.at(cause, param_env).eq(expected, actual) {\n+            Ok(InferOk { obligations, .. }) => traits::fully_solve_obligations(infcx, obligations),\n             Err(err) => {\n                 infcx.report_mismatched_types(cause, expected, actual, err).emit();\n                 return false;\n             }\n-        }\n+        };\n \n-        match fulfill_cx.select_all_or_error(infcx).as_slice() {\n+        match &errors[..] {\n             [] => true,\n             errors => {\n                 infcx.report_fulfillment_errors(errors, None, false);"}, {"sha": "ef7d75aa8ed9b56a264ace501e0e36e21426d9e5", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe894756f83e12522be51bdba39267927dde3cc4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe894756f83e12522be51bdba39267927dde3cc4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=fe894756f83e12522be51bdba39267927dde3cc4", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::ty::{EarlyBinder, Opaque, PredicateKind::Trait};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n use rustc_trait_selection::traits::error_reporting::suggestions::InferCtxtExt;\n-use rustc_trait_selection::traits::{self, FulfillmentError, TraitEngine};\n+use rustc_trait_selection::traits::{self, FulfillmentError};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -80,9 +80,7 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n                 let span = decl.output.span();\n                 let send_errors = cx.tcx.infer_ctxt().enter(|infcx| {\n                     let cause = traits::ObligationCause::misc(span, hir_id);\n-                    let mut fulfillment_cx = traits::FulfillmentContext::new();\n-                    fulfillment_cx.register_bound(&infcx, cx.param_env, ret_ty, send_trait, cause);\n-                    fulfillment_cx.select_all_or_error(&infcx)\n+                    traits::fully_solve_bound(&infcx, cause, cx.param_env, ret_ty, send_trait)\n                 });\n                 if !send_errors.is_empty() {\n                     span_lint_and_then("}]}