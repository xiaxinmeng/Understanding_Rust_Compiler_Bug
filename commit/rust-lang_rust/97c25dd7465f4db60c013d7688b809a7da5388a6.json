{"sha": "97c25dd7465f4db60c013d7688b809a7da5388a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3YzI1ZGQ3NDY1ZjRkYjYwYzAxM2Q3Njg4YjgwOWE3ZGE1Mzg4YTY=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-07-24T02:54:19Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-07-24T17:37:36Z"}, "message": "Add lane count marker type", "tree": {"sha": "4051bef1cbb11b4c9c53acc0ea26eefcbd6503b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4051bef1cbb11b4c9c53acc0ea26eefcbd6503b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97c25dd7465f4db60c013d7688b809a7da5388a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97c25dd7465f4db60c013d7688b809a7da5388a6", "html_url": "https://github.com/rust-lang/rust/commit/97c25dd7465f4db60c013d7688b809a7da5388a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97c25dd7465f4db60c013d7688b809a7da5388a6/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f93bef35f35579b60c8b919844a2021f3f035daa", "url": "https://api.github.com/repos/rust-lang/rust/commits/f93bef35f35579b60c8b919844a2021f3f035daa", "html_url": "https://github.com/rust-lang/rust/commit/f93bef35f35579b60c8b919844a2021f3f035daa"}], "stats": {"total": 778, "additions": 367, "deletions": 411}, "files": [{"sha": "c5e9be9015fe6bcc8b039de325e8dda0ab0311a3", "filename": "crates/core_simd/src/comparisons.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs?ref=97c25dd7465f4db60c013d7688b809a7da5388a6", "patch": "@@ -1,13 +1,11 @@\n-use crate::Vector;\n+use crate::{LaneCount, SupportedLaneCount};\n \n macro_rules! implement_mask_ops {\n     { $($vector:ident => $mask:ident ($inner_ty:ident),)* } => {\n         $(\n             impl<const LANES: usize> crate::$vector<LANES>\n             where\n-                crate::$vector<LANES>: Vector,\n-                crate::$inner_ty<LANES>: Vector,\n-                crate::$mask<LANES>: crate::Mask,\n+                LaneCount<LANES>: SupportedLaneCount,\n             {\n                 /// Test if each lane is equal to the corresponding lane in `other`.\n                 #[inline]"}, {"sha": "78ae5ce3fceab275831199b94a9b5f69bb992e3f", "filename": "crates/core_simd/src/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Ffmt.rs?ref=97c25dd7465f4db60c013d7688b809a7da5388a6", "patch": "@@ -35,7 +35,7 @@ macro_rules! impl_fmt_trait {\n             $( // repeat trait\n                 impl<const LANES: usize> core::fmt::$trait for crate::$type<LANES>\n                 where\n-                    Self: crate::Vector,\n+                    crate::LaneCount<LANES>: crate::SupportedLaneCount,\n                 {\n                     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                         $format(self.as_ref(), f)"}, {"sha": "0020ea5f2016f56017357fc78038f1e08aa9b3fd", "filename": "crates/core_simd/src/iter.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fiter.rs?ref=97c25dd7465f4db60c013d7688b809a7da5388a6", "patch": "@@ -1,8 +1,10 @@\n+use crate::{LaneCount, SupportedLaneCount};\n+\n macro_rules! impl_traits {\n     { $type:ident } => {\n         impl<const LANES: usize> core::iter::Sum<Self> for crate::$type<LANES>\n         where\n-            Self: crate::Vector,\n+            LaneCount<LANES>: SupportedLaneCount,\n         {\n             fn sum<I: core::iter::Iterator<Item = Self>>(iter: I) -> Self {\n                 iter.fold(Default::default(), core::ops::Add::add)\n@@ -11,7 +13,7 @@ macro_rules! impl_traits {\n \n         impl<const LANES: usize> core::iter::Product<Self> for crate::$type<LANES>\n         where\n-            Self: crate::Vector,\n+            LaneCount<LANES>: SupportedLaneCount,\n         {\n             fn product<I: core::iter::Iterator<Item = Self>>(iter: I) -> Self {\n                 iter.fold(Default::default(), core::ops::Mul::mul)\n@@ -20,7 +22,7 @@ macro_rules! impl_traits {\n \n         impl<'a, const LANES: usize> core::iter::Sum<&'a Self> for crate::$type<LANES>\n         where\n-            Self: crate::Vector,\n+            LaneCount<LANES>: SupportedLaneCount,\n         {\n             fn sum<I: core::iter::Iterator<Item = &'a Self>>(iter: I) -> Self {\n                 iter.fold(Default::default(), core::ops::Add::add)\n@@ -29,7 +31,7 @@ macro_rules! impl_traits {\n \n         impl<'a, const LANES: usize> core::iter::Product<&'a Self> for crate::$type<LANES>\n         where\n-            Self: crate::Vector,\n+            LaneCount<LANES>: SupportedLaneCount,\n         {\n             fn product<I: core::iter::Iterator<Item = &'a Self>>(iter: I) -> Self {\n                 iter.fold(Default::default(), core::ops::Mul::mul)"}, {"sha": "8fe204dff98e458f2c943cca4d34332950d95e64", "filename": "crates/core_simd/src/lane_count.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Flane_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Flane_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flane_count.rs?ref=97c25dd7465f4db60c013d7688b809a7da5388a6", "patch": "@@ -0,0 +1,43 @@\n+mod sealed {\n+    pub trait Sealed {}\n+}\n+use sealed::Sealed;\n+\n+/// A type representing a vector lane count.\n+pub struct LaneCount<const LANES: usize>;\n+\n+/// Helper trait for vector lane counts.\n+pub trait SupportedLaneCount: Sealed {\n+    /// The bitmask representation of a mask.\n+    type BitMask: Copy + Default + AsRef<[u8]> + AsMut<[u8]>;\n+\n+    #[doc(hidden)]\n+    type IntBitMask;\n+}\n+\n+impl<const LANES: usize> Sealed for LaneCount<LANES> {}\n+\n+impl SupportedLaneCount for LaneCount<1> {\n+    type BitMask = [u8; 1];\n+    type IntBitMask = u8;\n+}\n+impl SupportedLaneCount for LaneCount<2> {\n+    type BitMask = [u8; 1];\n+    type IntBitMask = u8;\n+}\n+impl SupportedLaneCount for LaneCount<4> {\n+    type BitMask = [u8; 1];\n+    type IntBitMask = u8;\n+}\n+impl SupportedLaneCount for LaneCount<8> {\n+    type BitMask = [u8; 1];\n+    type IntBitMask = u8;\n+}\n+impl SupportedLaneCount for LaneCount<16> {\n+    type BitMask = [u8; 2];\n+    type IntBitMask = u16;\n+}\n+impl SupportedLaneCount for LaneCount<32> {\n+    type BitMask = [u8; 4];\n+    type IntBitMask = u32;\n+}"}, {"sha": "d8149efe9c7f8a25138f11c6fa60579dbe012cca", "filename": "crates/core_simd/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flib.rs?ref=97c25dd7465f4db60c013d7688b809a7da5388a6", "patch": "@@ -27,11 +27,13 @@ mod comparisons;\n mod fmt;\n mod intrinsics;\n mod iter;\n+mod math;\n mod ops;\n mod round;\n mod vendor;\n \n-mod math;\n+mod lane_count;\n+pub use lane_count::*;\n \n mod masks;\n pub use masks::*;"}, {"sha": "d3338a6d366eec7559880bcaea466ac4e386dde5", "filename": "crates/core_simd/src/masks.rs", "status": "modified", "additions": 54, "deletions": 96, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks.rs?ref=97c25dd7465f4db60c013d7688b809a7da5388a6", "patch": "@@ -12,20 +12,20 @@\n )]\n mod mask_impl;\n \n-use crate::{SimdI16, SimdI32, SimdI64, SimdI8, SimdIsize, Vector};\n+use crate::{SimdI16, SimdI32, SimdI64, SimdI8, SimdIsize};\n \n mod sealed {\n     pub trait Sealed {}\n }\n \n /// Helper trait for mask types.\n pub trait Mask: sealed::Sealed {\n-    /// The bitmask representation of a mask.\n-    type BitMask: Copy + Default + AsRef<[u8]> + AsMut<[u8]>;\n+    /// The number of lanes for this mask.\n+    const LANES: usize;\n \n-    // TODO remove this when rustc intrinsics are more flexible\n-    #[doc(hidden)]\n-    type IntBitMask;\n+    /// Generates a mask with the same value in every lane.\n+    #[must_use]\n+    fn splat(val: bool) -> Self;\n }\n \n macro_rules! define_opaque_mask {\n@@ -38,45 +38,30 @@ macro_rules! define_opaque_mask {\n         #[allow(non_camel_case_types)]\n         pub struct $name<const LANES: usize>($inner_ty)\n         where\n-            $bits_ty<LANES>: Vector,\n-            Self: Mask;\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount;\n \n         impl<const LANES: usize> sealed::Sealed for $name<LANES>\n         where\n-            $bits_ty<LANES>: Vector,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {}\n-        impl Mask for $name<1> {\n-            type BitMask = [u8; 1];\n-            type IntBitMask = u8;\n-        }\n-        impl Mask for $name<2> {\n-            type BitMask = [u8; 1];\n-            type IntBitMask = u8;\n-        }\n-        impl Mask for $name<4> {\n-            type BitMask = [u8; 1];\n-            type IntBitMask = u8;\n-        }\n-        impl Mask for $name<8> {\n-            type BitMask = [u8; 1];\n-            type IntBitMask = u8;\n-        }\n-        impl Mask for $name<16> {\n-            type BitMask = [u8; 2];\n-            type IntBitMask = u16;\n-        }\n-        impl Mask for $name<32> {\n-            type BitMask = [u8; 4];\n-            type IntBitMask = u32;\n+\n+        impl<const LANES: usize> Mask for $name<LANES>\n+        where\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n+        {\n+            const LANES: usize = LANES;\n+\n+            #[inline]\n+            fn splat(value: bool) -> Self {\n+                Self::splat(value)\n+            }\n         }\n \n         impl_opaque_mask_reductions! { $name, $bits_ty }\n \n         impl<const LANES: usize> $name<LANES>\n         where\n-            $bits_ty<LANES>: Vector,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             /// Construct a mask by setting all lanes to the given value.\n             pub fn splat(value: bool) -> Self {\n@@ -175,21 +160,20 @@ macro_rules! define_opaque_mask {\n             }\n \n             /// Convert this mask to a bitmask, with one bit set per lane.\n-            pub fn to_bitmask(self) -> <Self as Mask>::BitMask {\n-                self.0.to_bitmask::<Self>()\n+            pub fn to_bitmask(self) -> <crate::LaneCount<LANES> as crate::SupportedLaneCount>::BitMask {\n+                self.0.to_bitmask()\n             }\n \n             /// Convert a bitmask to a mask.\n-            pub fn from_bitmask(bitmask: <Self as Mask>::BitMask) -> Self {\n-                Self(<$inner_ty>::from_bitmask::<Self>(bitmask))\n+            pub fn from_bitmask(bitmask: <crate::LaneCount<LANES> as crate::SupportedLaneCount>::BitMask) -> Self {\n+                Self(<$inner_ty>::from_bitmask(bitmask))\n             }\n         }\n \n         // vector/array conversion\n         impl<const LANES: usize> From<[bool; LANES]> for $name<LANES>\n         where\n-            $bits_ty<LANES>: crate::Vector,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             fn from(array: [bool; LANES]) -> Self {\n                 Self::from_array(array)\n@@ -198,8 +182,7 @@ macro_rules! define_opaque_mask {\n \n         impl <const LANES: usize> From<$name<LANES>> for [bool; LANES]\n         where\n-            $bits_ty<LANES>: crate::Vector,\n-            $name<LANES>: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             fn from(vector: $name<LANES>) -> Self {\n                 vector.to_array()\n@@ -208,14 +191,12 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> Copy for $name<LANES>\n         where\n-            $bits_ty<LANES>: Vector,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {}\n \n         impl<const LANES: usize> Clone for $name<LANES>\n         where\n-            $bits_ty<LANES>: Vector,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[inline]\n             fn clone(&self) -> Self {\n@@ -225,8 +206,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> Default for $name<LANES>\n         where\n-            $bits_ty<LANES>: Vector,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[inline]\n             fn default() -> Self {\n@@ -236,8 +216,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> PartialEq for $name<LANES>\n         where\n-            $bits_ty<LANES>: Vector,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[inline]\n             fn eq(&self, other: &Self) -> bool {\n@@ -247,8 +226,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> PartialOrd for $name<LANES>\n         where\n-            $bits_ty<LANES>: Vector,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[inline]\n             fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n@@ -258,8 +236,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::fmt::Debug for $name<LANES>\n         where\n-            $bits_ty<LANES>: crate::Vector,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                 f.debug_list()\n@@ -270,8 +247,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitAnd for $name<LANES>\n         where\n-            $bits_ty<LANES>: Vector,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = Self;\n             #[inline]\n@@ -282,8 +258,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitAnd<bool> for $name<LANES>\n         where\n-            $bits_ty<LANES>: Vector,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = Self;\n             #[inline]\n@@ -294,8 +269,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitAnd<$name<LANES>> for bool\n         where\n-            $bits_ty<LANES>: Vector,\n-            $name<LANES>: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -306,8 +280,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitOr for $name<LANES>\n         where\n-            $bits_ty<LANES>: Vector,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = Self;\n             #[inline]\n@@ -318,8 +291,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitOr<bool> for $name<LANES>\n         where\n-            $bits_ty<LANES>: Vector,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = Self;\n             #[inline]\n@@ -330,8 +302,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitOr<$name<LANES>> for bool\n         where\n-            $bits_ty<LANES>: Vector,\n-            $name<LANES>: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -342,8 +313,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitXor for $name<LANES>\n         where\n-            $bits_ty<LANES>: Vector,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = Self;\n             #[inline]\n@@ -354,8 +324,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitXor<bool> for $name<LANES>\n         where\n-            $bits_ty<LANES>: Vector,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = Self;\n             #[inline]\n@@ -366,8 +335,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitXor<$name<LANES>> for bool\n         where\n-            $bits_ty<LANES>: Vector,\n-            $name<LANES>: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -378,8 +346,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::Not for $name<LANES>\n         where\n-            $bits_ty<LANES>: Vector,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -390,8 +357,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitAndAssign for $name<LANES>\n         where\n-            $bits_ty<LANES>: Vector,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: Self) {\n@@ -401,8 +367,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitAndAssign<bool> for $name<LANES>\n         where\n-            $bits_ty<LANES>: Vector,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: bool) {\n@@ -412,8 +377,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitOrAssign for $name<LANES>\n         where\n-            $bits_ty<LANES>: Vector,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: Self) {\n@@ -423,8 +387,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitOrAssign<bool> for $name<LANES>\n         where\n-            $bits_ty<LANES>: Vector,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: bool) {\n@@ -434,8 +397,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitXorAssign for $name<LANES>\n         where\n-            $bits_ty<LANES>: Vector,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: Self) {\n@@ -445,8 +407,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitXorAssign<bool> for $name<LANES>\n         where\n-            $bits_ty<LANES>: Vector,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: bool) {\n@@ -460,39 +421,39 @@ define_opaque_mask! {\n     /// Mask for vectors with `LANES` 8-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask8<const LANES: usize>(mask_impl::Mask8<Self, LANES>);\n+    struct Mask8<const LANES: usize>(mask_impl::Mask8<LANES>);\n     @bits SimdI8\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 16-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask16<const LANES: usize>(mask_impl::Mask16<Self, LANES>);\n+    struct Mask16<const LANES: usize>(mask_impl::Mask16<LANES>);\n     @bits SimdI16\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 32-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask32<const LANES: usize>(mask_impl::Mask32<Self, LANES>);\n+    struct Mask32<const LANES: usize>(mask_impl::Mask32<LANES>);\n     @bits SimdI32\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 64-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask64<const LANES: usize>(mask_impl::Mask64<Self, LANES>);\n+    struct Mask64<const LANES: usize>(mask_impl::Mask64<LANES>);\n     @bits SimdI64\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` pointer-width elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct MaskSize<const LANES: usize>(mask_impl::MaskSize<Self, LANES>);\n+    struct MaskSize<const LANES: usize>(mask_impl::MaskSize<LANES>);\n     @bits SimdIsize\n }\n \n@@ -555,10 +516,7 @@ macro_rules! impl_from {\n         $(\n         impl<const LANES: usize> From<$from<LANES>> for $to<LANES>\n         where\n-            crate::$from_inner<LANES>: crate::Vector,\n-            crate::$to_inner<LANES>: crate::Vector,\n-            $from<LANES>: Mask,\n-            Self: Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             fn from(value: $from<LANES>) -> Self {\n                 Self(value.0.into())"}, {"sha": "b6897728988b8b66a270b35bebe03535f78e09ab", "filename": "crates/core_simd/src/masks/bitmask.rs", "status": "modified", "additions": 82, "deletions": 69, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=97c25dd7465f4db60c013d7688b809a7da5388a6", "patch": "@@ -1,50 +1,81 @@\n-use crate::Mask;\n-use core::marker::PhantomData;\n+use crate::{LaneCount, SupportedLaneCount};\n \n /// Helper trait for limiting int conversion types\n pub trait ConvertToInt {}\n-impl<const LANES: usize> ConvertToInt for crate::SimdI8<LANES> where Self: crate::Vector {}\n-impl<const LANES: usize> ConvertToInt for crate::SimdI16<LANES> where Self: crate::Vector {}\n-impl<const LANES: usize> ConvertToInt for crate::SimdI32<LANES> where Self: crate::Vector {}\n-impl<const LANES: usize> ConvertToInt for crate::SimdI64<LANES> where Self: crate::Vector {}\n-impl<const LANES: usize> ConvertToInt for crate::SimdIsize<LANES> where Self: crate::Vector {}\n+impl<const LANES: usize> ConvertToInt for crate::SimdI8<LANES> where\n+    LaneCount<LANES>: SupportedLaneCount\n+{\n+}\n+impl<const LANES: usize> ConvertToInt for crate::SimdI16<LANES> where\n+    LaneCount<LANES>: SupportedLaneCount\n+{\n+}\n+impl<const LANES: usize> ConvertToInt for crate::SimdI32<LANES> where\n+    LaneCount<LANES>: SupportedLaneCount\n+{\n+}\n+impl<const LANES: usize> ConvertToInt for crate::SimdI64<LANES> where\n+    LaneCount<LANES>: SupportedLaneCount\n+{\n+}\n+impl<const LANES: usize> ConvertToInt for crate::SimdIsize<LANES> where\n+    LaneCount<LANES>: SupportedLaneCount\n+{\n+}\n \n /// A mask where each lane is represented by a single bit.\n #[repr(transparent)]\n-pub struct BitMask<T: Mask, const LANES: usize>(T::BitMask, PhantomData<[(); LANES]>);\n+pub struct BitMask<const LANES: usize>(<LaneCount<LANES> as SupportedLaneCount>::BitMask)\n+where\n+    LaneCount<LANES>: SupportedLaneCount;\n \n-impl<T: Mask, const LANES: usize> Copy for BitMask<T, LANES> {}\n+impl<const LANES: usize> Copy for BitMask<LANES> where LaneCount<LANES>: SupportedLaneCount {}\n \n-impl<T: Mask, const LANES: usize> Clone for BitMask<T, LANES> {\n+impl<const LANES: usize> Clone for BitMask<LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n     fn clone(&self) -> Self {\n         *self\n     }\n }\n \n-impl<T: Mask, const LANES: usize> PartialEq for BitMask<T, LANES> {\n+impl<const LANES: usize> PartialEq for BitMask<LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n     fn eq(&self, other: &Self) -> bool {\n         self.0.as_ref() == other.0.as_ref()\n     }\n }\n \n-impl<T: Mask, const LANES: usize> PartialOrd for BitMask<T, LANES> {\n+impl<const LANES: usize> PartialOrd for BitMask<LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n     fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n         self.0.as_ref().partial_cmp(other.0.as_ref())\n     }\n }\n \n-impl<T: Mask, const LANES: usize> Eq for BitMask<T, LANES> {}\n+impl<const LANES: usize> Eq for BitMask<LANES> where LaneCount<LANES>: SupportedLaneCount {}\n \n-impl<T: Mask, const LANES: usize> Ord for BitMask<T, LANES> {\n+impl<const LANES: usize> Ord for BitMask<LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n     fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n         self.0.as_ref().cmp(other.0.as_ref())\n     }\n }\n \n-impl<T: Mask, const LANES: usize> BitMask<T, LANES> {\n+impl<const LANES: usize> BitMask<LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n     #[inline]\n     pub fn splat(value: bool) -> Self {\n-        let mut mask = T::BitMask::default();\n+        let mut mask = <LaneCount<LANES> as SupportedLaneCount>::BitMask::default();\n         if value {\n             mask.as_mut().fill(u8::MAX)\n         } else {\n@@ -53,12 +84,12 @@ impl<T: Mask, const LANES: usize> BitMask<T, LANES> {\n         if LANES % 8 > 0 {\n             *mask.as_mut().last_mut().unwrap() &= u8::MAX >> (8 - LANES % 8);\n         }\n-        Self(mask, PhantomData)\n+        Self(mask)\n     }\n \n     #[inline]\n     pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n-        (self.0.as_ref()[lane / 8] >> lane % 8) & 0x1 > 0\n+        (self.0.as_ref()[lane / 8] >> (lane % 8)) & 0x1 > 0\n     }\n \n     #[inline]\n@@ -72,7 +103,8 @@ impl<T: Mask, const LANES: usize> BitMask<T, LANES> {\n         V: ConvertToInt + Default + core::ops::Not<Output = V>,\n     {\n         unsafe {\n-            let mask: T::IntBitMask = core::mem::transmute_copy(&self);\n+            let mask: <LaneCount<LANES> as SupportedLaneCount>::IntBitMask =\n+                core::mem::transmute_copy(&self);\n             crate::intrinsics::simd_select_bitmask(mask, !V::default(), V::default())\n         }\n     }\n@@ -84,29 +116,25 @@ impl<T: Mask, const LANES: usize> BitMask<T, LANES> {\n     {\n         // TODO remove the transmute when rustc is more flexible\n         assert_eq!(\n-            core::mem::size_of::<T::IntBitMask>(),\n-            core::mem::size_of::<T::BitMask>()\n+            core::mem::size_of::<<crate::LaneCount::<LANES> as crate::SupportedLaneCount>::BitMask>(\n+            ),\n+            core::mem::size_of::<\n+                <crate::LaneCount::<LANES> as crate::SupportedLaneCount>::IntBitMask,\n+            >(),\n         );\n-        let mask: T::IntBitMask = crate::intrinsics::simd_bitmask(value);\n-        Self(core::mem::transmute_copy(&mask), PhantomData)\n+        let mask: <LaneCount<LANES> as SupportedLaneCount>::IntBitMask =\n+            crate::intrinsics::simd_bitmask(value);\n+        Self(core::mem::transmute_copy(&mask))\n     }\n \n     #[inline]\n-    pub fn to_bitmask<U: Mask>(self) -> U::BitMask {\n-        assert_eq!(\n-            core::mem::size_of::<T::BitMask>(),\n-            core::mem::size_of::<U::BitMask>()\n-        );\n-        unsafe { core::mem::transmute_copy(&self.0) }\n+    pub fn to_bitmask(self) -> <LaneCount<LANES> as SupportedLaneCount>::BitMask {\n+        self.0\n     }\n \n     #[inline]\n-    pub fn from_bitmask<U: Mask>(bitmask: U::BitMask) -> Self {\n-        assert_eq!(\n-            core::mem::size_of::<T::BitMask>(),\n-            core::mem::size_of::<U::BitMask>()\n-        );\n-        unsafe { core::mem::transmute_copy(&bitmask) }\n+    pub fn from_bitmask(bitmask: <LaneCount<LANES> as SupportedLaneCount>::BitMask) -> Self {\n+        Self(bitmask)\n     }\n \n     #[inline]\n@@ -120,9 +148,10 @@ impl<T: Mask, const LANES: usize> BitMask<T, LANES> {\n     }\n }\n \n-impl<T: Mask, const LANES: usize> core::ops::BitAnd for BitMask<T, LANES>\n+impl<const LANES: usize> core::ops::BitAnd for BitMask<LANES>\n where\n-    T::BitMask: Default + AsRef<[u8]> + AsMut<[u8]>,\n+    LaneCount<LANES>: SupportedLaneCount,\n+    <LaneCount<LANES> as SupportedLaneCount>::BitMask: Default + AsRef<[u8]> + AsMut<[u8]>,\n {\n     type Output = Self;\n     #[inline]\n@@ -134,9 +163,10 @@ where\n     }\n }\n \n-impl<T: Mask, const LANES: usize> core::ops::BitOr for BitMask<T, LANES>\n+impl<const LANES: usize> core::ops::BitOr for BitMask<LANES>\n where\n-    T::BitMask: Default + AsRef<[u8]> + AsMut<[u8]>,\n+    LaneCount<LANES>: SupportedLaneCount,\n+    <LaneCount<LANES> as SupportedLaneCount>::BitMask: Default + AsRef<[u8]> + AsMut<[u8]>,\n {\n     type Output = Self;\n     #[inline]\n@@ -148,7 +178,10 @@ where\n     }\n }\n \n-impl<T: Mask, const LANES: usize> core::ops::BitXor for BitMask<T, LANES> {\n+impl<const LANES: usize> core::ops::BitXor for BitMask<LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n     type Output = Self;\n     #[inline]\n     fn bitxor(mut self, rhs: Self) -> Self::Output {\n@@ -159,7 +192,10 @@ impl<T: Mask, const LANES: usize> core::ops::BitXor for BitMask<T, LANES> {\n     }\n }\n \n-impl<T: Mask, const LANES: usize> core::ops::Not for BitMask<T, LANES> {\n+impl<const LANES: usize> core::ops::Not for BitMask<LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n     type Output = Self;\n     #[inline]\n     fn not(mut self) -> Self::Output {\n@@ -173,31 +209,8 @@ impl<T: Mask, const LANES: usize> core::ops::Not for BitMask<T, LANES> {\n     }\n }\n \n-pub type Mask8<T, const LANES: usize> = BitMask<T, LANES>;\n-pub type Mask16<T, const LANES: usize> = BitMask<T, LANES>;\n-pub type Mask32<T, const LANES: usize> = BitMask<T, LANES>;\n-pub type Mask64<T, const LANES: usize> = BitMask<T, LANES>;\n-pub type MaskSize<T, const LANES: usize> = BitMask<T, LANES>;\n-\n-macro_rules! impl_from {\n-    { $from:ident ($from_inner:ident) => $($to:ident ($to_inner:ident)),* } => {\n-        $(\n-        impl<const LANES: usize> From<$from<crate::$from<LANES>, LANES>> for $to<crate::$to<LANES>, LANES>\n-        where\n-            crate::$from_inner<LANES>: crate::Vector,\n-            crate::$to_inner<LANES>: crate::Vector,\n-            crate::$from<LANES>: crate::Mask,\n-            crate::$to<LANES>: crate::Mask,\n-        {\n-            fn from(value: $from<crate::$from<LANES>, LANES>) -> Self {\n-                unsafe { core::mem::transmute_copy(&value) }\n-            }\n-        }\n-        )*\n-    }\n-}\n-impl_from! { Mask8 (SimdI8) => Mask16 (SimdI16), Mask32 (SimdI32), Mask64 (SimdI64), MaskSize (SimdIsize) }\n-impl_from! { Mask16 (SimdI16) => Mask32 (SimdI32), Mask64 (SimdI64), MaskSize (SimdIsize), Mask8 (SimdI8) }\n-impl_from! { Mask32 (SimdI32) => Mask64 (SimdI64), MaskSize (SimdIsize), Mask8 (SimdI8), Mask16 (SimdI16) }\n-impl_from! { Mask64 (SimdI64) => MaskSize (SimdIsize), Mask8 (SimdI8), Mask16 (SimdI16), Mask32 (SimdI32) }\n-impl_from! { MaskSize (SimdIsize) => Mask8 (SimdI8), Mask16 (SimdI16), Mask32 (SimdI32), Mask64 (SimdI64) }\n+pub type Mask8<const LANES: usize> = BitMask<LANES>;\n+pub type Mask16<const LANES: usize> = BitMask<LANES>;\n+pub type Mask32<const LANES: usize> = BitMask<LANES>;\n+pub type Mask64<const LANES: usize> = BitMask<LANES>;\n+pub type MaskSize<const LANES: usize> = BitMask<LANES>;"}, {"sha": "af36571134eeeac1f9a312542cc18f32db0e6d89", "filename": "crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 50, "deletions": 51, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=97c25dd7465f4db60c013d7688b809a7da5388a6", "patch": "@@ -1,8 +1,5 @@\n //! Masks that take up full SIMD vector registers.\n \n-use crate::Mask;\n-use core::marker::PhantomData;\n-\n macro_rules! define_mask {\n     {\n         $(#[$attr:meta])*\n@@ -12,62 +9,62 @@ macro_rules! define_mask {\n     } => {\n         $(#[$attr])*\n         #[repr(transparent)]\n-        pub struct $name<T: Mask, const $lanes: usize>(crate::$type<$lanes2>, PhantomData<T>)\n+        pub struct $name<const $lanes: usize>(crate::$type<$lanes>)\n         where\n-            crate::$type<LANES>: crate::Vector;\n+            crate::LaneCount<$lanes>: crate::SupportedLaneCount;\n \n         impl_full_mask_reductions! { $name, $type }\n \n-        impl<T: Mask, const LANES: usize> Copy for $name<T, LANES>\n+        impl<const LANES: usize> Copy for $name<LANES>\n         where\n-            crate::$type<LANES>: crate::Vector,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {}\n \n-        impl<T: Mask, const LANES: usize> Clone for $name<T, LANES>\n+        impl<const LANES: usize> Clone for $name<LANES>\n         where\n-            crate::$type<LANES>: crate::Vector,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[inline]\n             fn clone(&self) -> Self {\n                 *self\n             }\n         }\n \n-        impl<T: Mask, const LANES: usize> PartialEq for $name<T, LANES>\n+        impl<const LANES: usize> PartialEq for $name<LANES>\n         where\n-            crate::$type<LANES>: crate::Vector,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             fn eq(&self, other: &Self) -> bool {\n                 self.0 == other.0\n             }\n         }\n \n-        impl<T: Mask, const LANES: usize> PartialOrd for $name<T, LANES>\n+        impl<const LANES: usize> PartialOrd for $name<LANES>\n         where\n-            crate::$type<LANES>: crate::Vector,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n                 self.0.partial_cmp(&other.0)\n             }\n         }\n \n-        impl<T: Mask, const LANES: usize> Eq for $name<T, LANES>\n+        impl<const LANES: usize> Eq for $name<LANES>\n         where\n-            crate::$type<LANES>: crate::Vector,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {}\n \n-        impl<T: Mask, const LANES: usize> Ord for $name<T, LANES>\n+        impl<const LANES: usize> Ord for $name<LANES>\n         where\n-            crate::$type<LANES>: crate::Vector,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n                 self.0.cmp(&other.0)\n             }\n         }\n \n-        impl<T: Mask, const LANES: usize> $name<T, LANES>\n+        impl<const LANES: usize> $name<LANES>\n         where\n-            crate::$type<LANES>: crate::Vector,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             pub fn splat(value: bool) -> Self {\n                 Self(\n@@ -78,7 +75,6 @@ macro_rules! define_mask {\n                             0\n                         }\n                     ),\n-                    PhantomData,\n                 )\n             }\n \n@@ -103,16 +99,19 @@ macro_rules! define_mask {\n \n             #[inline]\n             pub unsafe fn from_int_unchecked(value: crate::$type<LANES>) -> Self {\n-                Self(value, PhantomData)\n+                Self(value)\n             }\n \n             #[inline]\n-            pub fn to_bitmask<U: crate::Mask>(self) -> U::BitMask {\n+            pub fn to_bitmask(self) -> <crate::LaneCount::<LANES> as crate::SupportedLaneCount>::BitMask {\n                 unsafe {\n-                    // TODO remove the transmute when rustc is more flexible\n-                    assert_eq!(core::mem::size_of::<U::IntBitMask>(), core::mem::size_of::<U::BitMask>());\n-                    let mask: U::IntBitMask = crate::intrinsics::simd_bitmask(self.0);\n-                    let mut bitmask: U::BitMask = core::mem::transmute_copy(&mask);\n+                    // TODO remove the transmute when rustc can use arrays of u8 as bitmasks\n+                    assert_eq!(\n+                        core::mem::size_of::<<crate::LaneCount::<LANES> as crate::SupportedLaneCount>::BitMask>(),\n+                        core::mem::size_of::<<crate::LaneCount::<LANES> as crate::SupportedLaneCount>::IntBitMask>(),\n+                    );\n+                    let bitmask: <crate::LaneCount::<LANES> as crate::SupportedLaneCount>::IntBitMask = crate::intrinsics::simd_bitmask(self.0);\n+                    let mut bitmask: <crate::LaneCount::<LANES> as crate::SupportedLaneCount>::BitMask = core::mem::transmute_copy(&bitmask);\n \n                     // There is a bug where LLVM appears to implement this operation with the wrong\n                     // bit order.\n@@ -128,7 +127,7 @@ macro_rules! define_mask {\n             }\n \n             #[inline]\n-            pub fn from_bitmask<U: crate::Mask>(mut bitmask: U::BitMask) -> Self {\n+            pub fn from_bitmask(mut bitmask: <crate::LaneCount::<LANES> as crate::SupportedLaneCount>::BitMask) -> Self {\n                 unsafe {\n                     // There is a bug where LLVM appears to implement this operation with the wrong\n                     // bit order.\n@@ -139,9 +138,12 @@ macro_rules! define_mask {\n                         }\n                     }\n \n-                    // TODO remove the transmute when rustc is more flexible\n-                    assert_eq!(core::mem::size_of::<U::IntBitMask>(), core::mem::size_of::<U::BitMask>());\n-                    let bitmask: U::IntBitMask = core::mem::transmute_copy(&bitmask);\n+                    // TODO remove the transmute when rustc can use arrays of u8 as bitmasks\n+                    assert_eq!(\n+                        core::mem::size_of::<<crate::LaneCount::<LANES> as crate::SupportedLaneCount>::BitMask>(),\n+                        core::mem::size_of::<<crate::LaneCount::<LANES> as crate::SupportedLaneCount>::IntBitMask>(),\n+                    );\n+                    let bitmask: <crate::LaneCount::<LANES> as crate::SupportedLaneCount>::IntBitMask = core::mem::transmute_copy(&bitmask);\n \n                     Self::from_int_unchecked(crate::intrinsics::simd_select_bitmask(\n                         bitmask,\n@@ -152,56 +154,56 @@ macro_rules! define_mask {\n             }\n         }\n \n-        impl<T: Mask, const LANES: usize> core::convert::From<$name<T, LANES>> for crate::$type<LANES>\n+        impl<const LANES: usize> core::convert::From<$name<LANES>> for crate::$type<LANES>\n         where\n-            crate::$type<LANES>: crate::Vector,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n-            fn from(value: $name<T, LANES>) -> Self {\n+            fn from(value: $name<LANES>) -> Self {\n                 value.0\n             }\n         }\n \n-        impl<T: Mask, const LANES: usize> core::ops::BitAnd for $name<T, LANES>\n+        impl<const LANES: usize> core::ops::BitAnd for $name<LANES>\n         where\n-            crate::$type<LANES>: crate::Vector,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = Self;\n             #[inline]\n             fn bitand(self, rhs: Self) -> Self {\n-                Self(self.0 & rhs.0, PhantomData)\n+                Self(self.0 & rhs.0)\n             }\n         }\n \n-        impl<T: Mask, const LANES: usize> core::ops::BitOr for $name<T, LANES>\n+        impl<const LANES: usize> core::ops::BitOr for $name<LANES>\n         where\n-            crate::$type<LANES>: crate::Vector,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = Self;\n             #[inline]\n             fn bitor(self, rhs: Self) -> Self {\n-                Self(self.0 | rhs.0, PhantomData)\n+                Self(self.0 | rhs.0)\n             }\n         }\n \n-        impl<T: Mask, const LANES: usize> core::ops::BitXor for $name<T, LANES>\n+        impl<const LANES: usize> core::ops::BitXor for $name<LANES>\n         where\n-            crate::$type<LANES>: crate::Vector,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = Self;\n             #[inline]\n             fn bitxor(self, rhs: Self) -> Self::Output {\n-                Self(self.0 ^ rhs.0, PhantomData)\n+                Self(self.0 ^ rhs.0)\n             }\n         }\n \n-        impl<T: Mask, const LANES: usize> core::ops::Not for $name<T, LANES>\n+        impl<const LANES: usize> core::ops::Not for $name<LANES>\n         where\n-            crate::$type<LANES>: crate::Vector,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             type Output = Self;\n             #[inline]\n             fn not(self) -> Self::Output {\n-                Self(!self.0, PhantomData)\n+                Self(!self.0)\n             }\n         }\n     }\n@@ -240,14 +242,11 @@ define_mask! {\n macro_rules! impl_from {\n     { $from:ident ($from_inner:ident) => $($to:ident ($to_inner:ident)),* } => {\n         $(\n-        impl<const LANES: usize, T, U> From<$from<T, LANES>> for $to<U, LANES>\n+        impl<const LANES: usize> From<$from<LANES>> for $to<LANES>\n         where\n-            crate::$from_inner<LANES>: crate::Vector,\n-            crate::$to_inner<LANES>: crate::Vector,\n-            T: crate::Mask,\n-            U: crate::Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n-            fn from(value: $from<T, LANES>) -> Self {\n+            fn from(value: $from<LANES>) -> Self {\n                 let mut new = Self::splat(false);\n                 for i in 0..LANES {\n                     unsafe { new.set_unchecked(i, value.test_unchecked(i)) }"}, {"sha": "28720eb13e3c5167ba5a7d10b9a01e9f5a2d6443", "filename": "crates/core_simd/src/math.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmath.rs?ref=97c25dd7465f4db60c013d7688b809a7da5388a6", "patch": "@@ -1,6 +1,6 @@\n macro_rules! impl_uint_arith {\n     ($(($name:ident, $n:ident)),+) => {\n-        $( impl<const LANES: usize> $name<LANES> where Self: crate::Vector {\n+        $( impl<const LANES: usize> $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n \n             /// Lanewise saturating add.\n             ///\n@@ -44,7 +44,7 @@ macro_rules! impl_uint_arith {\n \n macro_rules! impl_int_arith {\n     ($(($name:ident, $n:ident)),+) => {\n-        $( impl<const LANES: usize> $name<LANES> where Self: crate::Vector {\n+        $( impl<const LANES: usize> $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n \n             /// Lanewise saturating add.\n             ///"}, {"sha": "c75090aab9c5048f5d74f28040f188f1a7906560", "filename": "crates/core_simd/src/ops.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fops.rs?ref=97c25dd7465f4db60c013d7688b809a7da5388a6", "patch": "@@ -1,4 +1,4 @@\n-use crate::Vector;\n+use crate::{LaneCount, SupportedLaneCount};\n \n /// Checks if the right-hand side argument of a left- or right-shift would cause overflow.\n fn invalid_shift_rhs<T>(rhs: T) -> bool\n@@ -16,7 +16,7 @@ macro_rules! impl_ref_ops {\n     {\n         impl<const $lanes:ident: usize> core::ops::$trait:ident<$rhs:ty> for $type:ty\n         where\n-            $($bound:path: Vector,)*\n+            LaneCount<$lanes2:ident>: SupportedLaneCount,\n         {\n             type Output = $output:ty;\n \n@@ -26,7 +26,7 @@ macro_rules! impl_ref_ops {\n     } => {\n         impl<const $lanes: usize> core::ops::$trait<$rhs> for $type\n         where\n-            $($bound: Vector,)*\n+            LaneCount<$lanes2>: SupportedLaneCount,\n         {\n             type Output = $output;\n \n@@ -36,7 +36,7 @@ macro_rules! impl_ref_ops {\n \n         impl<const $lanes: usize> core::ops::$trait<&'_ $rhs> for $type\n         where\n-            $($bound: Vector,)*\n+            LaneCount<$lanes2>: SupportedLaneCount,\n         {\n             type Output = <$type as core::ops::$trait<$rhs>>::Output;\n \n@@ -48,7 +48,7 @@ macro_rules! impl_ref_ops {\n \n         impl<const $lanes: usize> core::ops::$trait<$rhs> for &'_ $type\n         where\n-            $($bound: Vector,)*\n+            LaneCount<$lanes2>: SupportedLaneCount,\n         {\n             type Output = <$type as core::ops::$trait<$rhs>>::Output;\n \n@@ -60,7 +60,7 @@ macro_rules! impl_ref_ops {\n \n         impl<const $lanes: usize> core::ops::$trait<&'_ $rhs> for &'_ $type\n         where\n-            $($bound: Vector,)*\n+            LaneCount<$lanes2>: SupportedLaneCount,\n         {\n             type Output = <$type as core::ops::$trait<$rhs>>::Output;\n \n@@ -75,23 +75,23 @@ macro_rules! impl_ref_ops {\n     {\n         impl<const $lanes:ident: usize> core::ops::$trait:ident<$rhs:ty> for $type:ty\n         where\n-            $($bound:path: Vector,)*\n+            LaneCount<$lanes2:ident>: SupportedLaneCount,\n         {\n             $(#[$attrs:meta])*\n             fn $fn:ident(&mut $self_tok:ident, $rhs_arg:ident: $rhs_arg_ty:ty) $body:tt\n         }\n     } => {\n         impl<const $lanes: usize> core::ops::$trait<$rhs> for $type\n         where\n-            $($bound: Vector,)*\n+            LaneCount<$lanes2>: SupportedLaneCount,\n         {\n             $(#[$attrs])*\n             fn $fn(&mut $self_tok, $rhs_arg: $rhs_arg_ty) $body\n         }\n \n         impl<const $lanes: usize> core::ops::$trait<&'_ $rhs> for $type\n         where\n-            $($bound: Vector,)*\n+            LaneCount<$lanes2>: SupportedLaneCount,\n         {\n             $(#[$attrs])*\n             fn $fn(&mut $self_tok, $rhs_arg: &$rhs_arg_ty) {\n@@ -104,23 +104,23 @@ macro_rules! impl_ref_ops {\n     {\n         impl<const $lanes:ident: usize> core::ops::$trait:ident for $type:ty\n         where\n-            $($bound:path: Vector,)*\n+            LaneCount<$lanes2:ident>: SupportedLaneCount,\n         {\n             type Output = $output:ty;\n             fn $fn:ident($self_tok:ident) -> Self::Output $body:tt\n         }\n     } => {\n         impl<const $lanes: usize> core::ops::$trait for $type\n         where\n-            $($bound: Vector,)*\n+            LaneCount<$lanes2>: SupportedLaneCount,\n         {\n             type Output = $output;\n             fn $fn($self_tok) -> Self::Output $body\n         }\n \n         impl<const $lanes: usize> core::ops::$trait for &'_ $type\n         where\n-            $($bound: Vector,)*\n+            LaneCount<$lanes2>: SupportedLaneCount,\n         {\n             type Output = <$type as core::ops::$trait>::Output;\n             fn $fn($self_tok) -> Self::Output {\n@@ -167,7 +167,7 @@ macro_rules! impl_op {\n         impl_ref_ops! {\n             impl<const LANES: usize> core::ops::Not for crate::$type<LANES>\n             where\n-                crate::$type<LANES>: Vector,\n+                LaneCount<LANES>: SupportedLaneCount,\n             {\n                 type Output = Self;\n                 fn not(self) -> Self::Output {\n@@ -181,7 +181,7 @@ macro_rules! impl_op {\n         impl_ref_ops! {\n             impl<const LANES: usize> core::ops::Neg for crate::$type<LANES>\n             where\n-                crate::$type<LANES>: Vector,\n+                LaneCount<LANES>: SupportedLaneCount,\n             {\n                 type Output = Self;\n                 fn neg(self) -> Self::Output {\n@@ -194,7 +194,7 @@ macro_rules! impl_op {\n     { impl Index for $type:ident, $scalar:ty } => {\n         impl<I, const LANES: usize> core::ops::Index<I> for crate::$type<LANES>\n         where\n-            Self: Vector,\n+            LaneCount<LANES>: SupportedLaneCount,\n             I: core::slice::SliceIndex<[$scalar]>,\n         {\n             type Output = I::Output;\n@@ -206,7 +206,7 @@ macro_rules! impl_op {\n \n         impl<I, const LANES: usize> core::ops::IndexMut<I> for crate::$type<LANES>\n         where\n-            Self: Vector,\n+            LaneCount<LANES>: SupportedLaneCount,\n             I: core::slice::SliceIndex<[$scalar]>,\n         {\n             fn index_mut(&mut self, index: I) -> &mut Self::Output {\n@@ -221,7 +221,7 @@ macro_rules! impl_op {\n         impl_ref_ops! {\n             impl<const LANES: usize> core::ops::$trait<Self> for crate::$type<LANES>\n             where\n-                crate::$type<LANES>: Vector,\n+                LaneCount<LANES>: SupportedLaneCount,\n             {\n                 type Output = Self;\n \n@@ -237,7 +237,7 @@ macro_rules! impl_op {\n         impl_ref_ops! {\n             impl<const LANES: usize> core::ops::$trait<$scalar> for crate::$type<LANES>\n             where\n-                crate::$type<LANES>: Vector,\n+                LaneCount<LANES>: SupportedLaneCount,\n             {\n                 type Output = Self;\n \n@@ -251,7 +251,7 @@ macro_rules! impl_op {\n         impl_ref_ops! {\n             impl<const LANES: usize> core::ops::$trait<crate::$type<LANES>> for $scalar\n             where\n-                crate::$type<LANES>: Vector,\n+                LaneCount<LANES>: SupportedLaneCount,\n             {\n                 type Output = crate::$type<LANES>;\n \n@@ -265,7 +265,7 @@ macro_rules! impl_op {\n         impl_ref_ops! {\n             impl<const LANES: usize> core::ops::$assign_trait<Self> for crate::$type<LANES>\n             where\n-                crate::$type<LANES>: Vector,\n+                LaneCount<LANES>: SupportedLaneCount,\n             {\n                 #[inline]\n                 fn $assign_trait_fn(&mut self, rhs: Self) {\n@@ -279,7 +279,7 @@ macro_rules! impl_op {\n         impl_ref_ops! {\n             impl<const LANES: usize> core::ops::$assign_trait<$scalar> for crate::$type<LANES>\n             where\n-                crate::$type<LANES>: Vector,\n+                LaneCount<LANES>: SupportedLaneCount,\n             {\n                 #[inline]\n                 fn $assign_trait_fn(&mut self, rhs: $scalar) {\n@@ -325,7 +325,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Div<Self> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: Vector,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         type Output = Self;\n \n@@ -353,7 +353,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Div<$scalar> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: Vector,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         type Output = Self;\n \n@@ -376,7 +376,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Div<crate::$vector<LANES>> for $scalar\n                     where\n-                        crate::$vector<LANES>: Vector,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         type Output = crate::$vector<LANES>;\n \n@@ -390,7 +390,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::DivAssign<Self> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: Vector,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         #[inline]\n                         fn div_assign(&mut self, rhs: Self) {\n@@ -402,7 +402,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::DivAssign<$scalar> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: Vector,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         #[inline]\n                         fn div_assign(&mut self, rhs: $scalar) {\n@@ -415,7 +415,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Rem<Self> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: Vector,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         type Output = Self;\n \n@@ -443,7 +443,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Rem<$scalar> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: Vector,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         type Output = Self;\n \n@@ -466,7 +466,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Rem<crate::$vector<LANES>> for $scalar\n                     where\n-                        crate::$vector<LANES>: Vector,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         type Output = crate::$vector<LANES>;\n \n@@ -480,7 +480,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::RemAssign<Self> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: Vector,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         #[inline]\n                         fn rem_assign(&mut self, rhs: Self) {\n@@ -492,7 +492,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::RemAssign<$scalar> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: Vector,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         #[inline]\n                         fn rem_assign(&mut self, rhs: $scalar) {\n@@ -505,7 +505,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Shl<Self> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: Vector,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         type Output = Self;\n \n@@ -527,7 +527,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Shl<$scalar> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: Vector,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         type Output = Self;\n \n@@ -546,7 +546,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::ShlAssign<Self> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: Vector,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         #[inline]\n                         fn shl_assign(&mut self, rhs: Self) {\n@@ -558,7 +558,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::ShlAssign<$scalar> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: Vector,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         #[inline]\n                         fn shl_assign(&mut self, rhs: $scalar) {\n@@ -570,7 +570,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Shr<Self> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: Vector,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         type Output = Self;\n \n@@ -592,7 +592,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::Shr<$scalar> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: Vector,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         type Output = Self;\n \n@@ -611,7 +611,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::ShrAssign<Self> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: Vector,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         #[inline]\n                         fn shr_assign(&mut self, rhs: Self) {\n@@ -623,7 +623,7 @@ macro_rules! impl_unsigned_int_ops {\n                 impl_ref_ops! {\n                     impl<const LANES: usize> core::ops::ShrAssign<$scalar> for crate::$vector<LANES>\n                     where\n-                        crate::$vector<LANES>: Vector,\n+                        LaneCount<LANES>: SupportedLaneCount,\n                     {\n                         #[inline]\n                         fn shr_assign(&mut self, rhs: $scalar) {"}, {"sha": "df227d09e3420860a1a5d1ecc76b8142ce7a105a", "filename": "crates/core_simd/src/reduction.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Freduction.rs?ref=97c25dd7465f4db60c013d7688b809a7da5388a6", "patch": "@@ -2,7 +2,7 @@ macro_rules! impl_integer_reductions {\n     { $name:ident, $scalar:ty } => {\n         impl<const LANES: usize> crate::$name<LANES>\n         where\n-            Self: crate::Vector\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             /// Horizontal wrapping add.  Returns the sum of the lanes of the vector, with wrapping addition.\n             #[inline]\n@@ -56,7 +56,7 @@ macro_rules! impl_float_reductions {\n     { $name:ident, $scalar:ty } => {\n         impl<const LANES: usize> crate::$name<LANES>\n         where\n-            Self: crate::Vector\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n \n             /// Horizontal add.  Returns the sum of the lanes of the vector.\n@@ -104,9 +104,9 @@ macro_rules! impl_float_reductions {\n \n macro_rules! impl_full_mask_reductions {\n     { $name:ident, $bits_ty:ident } => {\n-        impl<T: crate::Mask, const LANES: usize> $name<T, LANES>\n+        impl<const LANES: usize> $name<LANES>\n         where\n-            crate::$bits_ty<LANES>: crate::Vector\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[inline]\n             pub fn any(self) -> bool {\n@@ -125,8 +125,7 @@ macro_rules! impl_opaque_mask_reductions {\n     { $name:ident, $bits_ty:ident } => {\n         impl<const LANES: usize> $name<LANES>\n         where\n-            crate::$bits_ty<LANES>: crate::Vector,\n-            $name<LANES>: crate::Mask,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             /// Returns true if any lane is set, or false otherwise.\n             #[inline]"}, {"sha": "74cae0cf989830779f4bc5ee2bf4e5c575828d06", "filename": "crates/core_simd/src/round.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fround.rs?ref=97c25dd7465f4db60c013d7688b809a7da5388a6", "patch": "@@ -5,7 +5,7 @@ macro_rules! implement {\n         #[cfg(feature = \"std\")]\n         impl<const LANES: usize> crate::$type<LANES>\n         where\n-            Self: crate::Vector,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             /// Returns the smallest integer greater than or equal to each lane.\n             #[must_use = \"method returns a new vector and does not mutate the original value\"]\n@@ -41,13 +41,7 @@ macro_rules! implement {\n             pub fn fract(self) -> Self {\n                 self - self.trunc()\n             }\n-        }\n \n-        impl<const LANES: usize> crate::$type<LANES>\n-        where\n-            Self: crate::Vector,\n-            crate::$int_type<LANES>: crate::Vector,\n-        {\n             /// Rounds toward zero and converts to the same-width integer type, assuming that\n             /// the value is finite and fits in that type.\n             ///"}, {"sha": "d70e8a66b95fcedb15fa1572ab26e1c845de74cc", "filename": "crates/core_simd/src/select.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fselect.rs?ref=97c25dd7465f4db60c013d7688b809a7da5388a6", "patch": "@@ -14,12 +14,10 @@ macro_rules! impl_select {\n         $mask:ident ($bits_ty:ident): $($type:ident),*\n     } => {\n         $(\n-        impl<const LANES: usize> Sealed for crate::$type<LANES> where Self: crate::Vector {}\n+        impl<const LANES: usize> Sealed for crate::$type<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {}\n         impl<const LANES: usize> Select<crate::$mask<LANES>> for crate::$type<LANES>\n         where\n-            crate::$mask<LANES>: crate::Mask,\n-            crate::$bits_ty<LANES>: crate::Vector,\n-            Self: crate::Vector,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[doc(hidden)]\n             #[inline]\n@@ -31,13 +29,12 @@ macro_rules! impl_select {\n \n         impl<const LANES: usize> Sealed for crate::$mask<LANES>\n         where\n-            Self: crate::Mask,\n-            crate::$bits_ty<LANES>: crate::Vector,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {}\n+\n         impl<const LANES: usize> Select<Self> for crate::$mask<LANES>\n         where\n-            Self: crate::Mask,\n-            crate::$bits_ty<LANES>: crate::Vector,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             #[doc(hidden)]\n             #[inline]\n@@ -48,8 +45,7 @@ macro_rules! impl_select {\n \n         impl<const LANES: usize> crate::$mask<LANES>\n         where\n-            Self: crate::Mask,\n-            crate::$bits_ty<LANES>: crate::Vector,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n         {\n             /// Choose lanes from two vectors.\n             ///"}, {"sha": "0823391049fdcbca0bed9846f312b0fd9fb32eae", "filename": "crates/core_simd/src/to_bytes.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fto_bytes.rs?ref=97c25dd7465f4db60c013d7688b809a7da5388a6", "patch": "@@ -18,11 +18,14 @@ pub trait ToBytes: Sealed {\n macro_rules! impl_to_bytes {\n     { $name:ident, $($int_width:literal -> $byte_width:literal),* } => {\n         $(\n-        impl Sealed for crate::$name<$int_width> where Self: crate::Vector {}\n+        impl Sealed for crate::$name<$int_width>\n+        where\n+            crate::LaneCount<$int_width>: crate::SupportedLaneCount,\n+        {}\n+\n         impl ToBytes for crate::$name<$int_width>\n         where\n-            Self: crate::Vector,\n-            crate::SimdU8<$byte_width>: crate::Vector,\n+            crate::LaneCount<$int_width>: crate::SupportedLaneCount,\n         {\n             type Bytes = crate::SimdU8<$byte_width>;\n             fn to_bytes_impl(self) -> Self::Bytes {\n@@ -36,7 +39,8 @@ macro_rules! impl_to_bytes {\n \n         impl<const LANES: usize> crate::$name<LANES>\n         where\n-            Self: ToBytes + crate::Vector,\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n+            Self: ToBytes,\n         {\n             /// Return the memory representation of this integer as a byte array in native byte\n             /// order."}, {"sha": "1f6df533767e0b360c469aa5e9de4625b2a5fe69", "filename": "crates/core_simd/src/vector.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=97c25dd7465f4db60c013d7688b809a7da5388a6", "patch": "@@ -26,10 +26,6 @@ pub trait Vector: sealed::Sealed {\n     /// The number of lanes for this vector.\n     const LANES: usize;\n \n-    // Implementation detail until the compiler can support bitmasks of any integer width\n-    #[doc(hidden)]\n-    type BitMask: Into<u64>;\n-\n     /// Generates a SIMD vector with the same value in every lane.\n     #[must_use]\n     fn splat(val: Self::Scalar) -> Self;"}, {"sha": "bdeccd037a80e3d0907ef2073c86a6ac5f335f7a", "filename": "crates/core_simd/src/vector/float.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=97c25dd7465f4db60c013d7688b809a7da5388a6", "patch": "@@ -1,5 +1,7 @@\n #![allow(non_camel_case_types)]\n \n+use crate::{LaneCount, SupportedLaneCount};\n+\n /// Implements inherent methods for a float vector `$name` containing multiple\n /// `$lanes` of float `$type`, which uses `$bits_ty` as its binary\n /// representation. Called from `define_float_vector!`.\n@@ -10,8 +12,7 @@ macro_rules! impl_float_vector {\n \n         impl<const LANES: usize> $name<LANES>\n         where\n-            Self: crate::Vector,\n-            crate::$bits_ty<LANES>: crate::Vector,\n+            LaneCount<LANES>: SupportedLaneCount,\n         {\n             /// Raw transmutation to an unsigned integer vector type with the\n             /// same size and number of lanes.\n@@ -74,15 +75,7 @@ macro_rules! impl_float_vector {\n             pub fn to_radians(self) -> Self {\n                 self * Self::splat($type::to_radians(1.))\n             }\n-        }\n \n-        impl<const LANES: usize> $name<LANES>\n-        where\n-            Self: crate::Vector,\n-            crate::$bits_ty<LANES>: crate::Vector,\n-            crate::$mask_impl_ty<LANES>: crate::Vector,\n-            crate::$mask_ty<LANES>: crate::Mask,\n-        {\n             /// Returns true for each lane if it has a positive sign, including\n             /// `+0.0`, `NaN`s with positive sign bit and positive infinity.\n             #[inline]\n@@ -197,15 +190,15 @@ macro_rules! impl_float_vector {\n #[repr(simd)]\n pub struct SimdF32<const LANES: usize>([f32; LANES])\n where\n-    Self: crate::Vector;\n+    LaneCount<LANES>: SupportedLaneCount;\n \n impl_float_vector! { SimdF32, f32, SimdU32, Mask32, SimdI32 }\n \n /// A SIMD vector of containing `LANES` `f64` values.\n #[repr(simd)]\n pub struct SimdF64<const LANES: usize>([f64; LANES])\n where\n-    Self: crate::Vector;\n+    LaneCount<LANES>: SupportedLaneCount;\n \n impl_float_vector! { SimdF64, f64, SimdU64, Mask64, SimdI64 }\n "}, {"sha": "73c737762fb6003b76fbad02e83a54eba19f5c91", "filename": "crates/core_simd/src/vector/int.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs?ref=97c25dd7465f4db60c013d7688b809a7da5388a6", "patch": "@@ -1,22 +1,27 @@\n #![allow(non_camel_case_types)]\n \n+use crate::{LaneCount, SupportedLaneCount};\n+\n /// Implements additional integer traits (Eq, Ord, Hash) on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n macro_rules! impl_integer_vector {\n     { $name:ident, $type:ty, $mask_ty:ident, $mask_impl_ty:ident } => {\n         impl_vector! { $name, $type }\n         impl_integer_reductions! { $name, $type }\n \n-        impl<const LANES: usize> Eq for $name<LANES> where Self: crate::Vector {}\n+        impl<const LANES: usize> Eq for $name<LANES> where LaneCount<LANES>: SupportedLaneCount {}\n \n-        impl<const LANES: usize> Ord for $name<LANES> where Self: crate::Vector {\n+        impl<const LANES: usize> Ord for $name<LANES> where LaneCount<LANES>: SupportedLaneCount {\n             #[inline]\n             fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n                 // TODO use SIMD cmp\n                 self.as_array().cmp(other.as_ref())\n             }\n         }\n \n-        impl<const LANES: usize> core::hash::Hash for $name<LANES> where Self: crate::Vector {\n+        impl<const LANES: usize> core::hash::Hash for $name<LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n             #[inline]\n             fn hash<H>(&self, state: &mut H)\n             where\n@@ -28,9 +33,7 @@ macro_rules! impl_integer_vector {\n \n         impl<const LANES: usize> $name<LANES>\n         where\n-            Self: crate::Vector,\n-            crate::$mask_impl_ty<LANES>: crate::Vector,\n-            crate::$mask_ty<LANES>: crate::Mask,\n+            LaneCount<LANES>: SupportedLaneCount,\n         {\n             /// Returns true for each positive lane and false if it is zero or negative.\n             #[inline]\n@@ -63,39 +66,39 @@ macro_rules! impl_integer_vector {\n #[repr(simd)]\n pub struct SimdIsize<const LANES: usize>([isize; LANES])\n where\n-    Self: crate::Vector;\n+    LaneCount<LANES>: SupportedLaneCount;\n \n impl_integer_vector! { SimdIsize, isize, MaskSize, SimdIsize }\n \n /// A SIMD vector of containing `LANES` `i16` values.\n #[repr(simd)]\n pub struct SimdI16<const LANES: usize>([i16; LANES])\n where\n-    Self: crate::Vector;\n+    LaneCount<LANES>: SupportedLaneCount;\n \n impl_integer_vector! { SimdI16, i16, Mask16, SimdI16 }\n \n /// A SIMD vector of containing `LANES` `i32` values.\n #[repr(simd)]\n pub struct SimdI32<const LANES: usize>([i32; LANES])\n where\n-    Self: crate::Vector;\n+    LaneCount<LANES>: SupportedLaneCount;\n \n impl_integer_vector! { SimdI32, i32, Mask32, SimdI32 }\n \n /// A SIMD vector of containing `LANES` `i64` values.\n #[repr(simd)]\n pub struct SimdI64<const LANES: usize>([i64; LANES])\n where\n-    Self: crate::Vector;\n+    LaneCount<LANES>: SupportedLaneCount;\n \n impl_integer_vector! { SimdI64, i64, Mask64, SimdI64 }\n \n /// A SIMD vector of containing `LANES` `i8` values.\n #[repr(simd)]\n pub struct SimdI8<const LANES: usize>([i8; LANES])\n where\n-    Self: crate::Vector;\n+    LaneCount<LANES>: SupportedLaneCount;\n \n impl_integer_vector! { SimdI8, i8, Mask8, SimdI8 }\n "}, {"sha": "9dd1bfd0f3659daf3d0fd54509971d088119a79a", "filename": "crates/core_simd/src/vector/ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs?ref=97c25dd7465f4db60c013d7688b809a7da5388a6", "patch": "@@ -1,5 +1,5 @@\n //! Private implementation details of public gather/scatter APIs.\n-use crate::SimdUsize;\n+use crate::{LaneCount, SimdUsize, SupportedLaneCount};\n use core::mem;\n \n /// A vector of *const T.\n@@ -9,7 +9,7 @@ pub(crate) struct SimdConstPtr<T, const LANES: usize>([*const T; LANES]);\n \n impl<T, const LANES: usize> SimdConstPtr<T, LANES>\n where\n-    SimdUsize<LANES>: crate::Vector,\n+    LaneCount<LANES>: SupportedLaneCount,\n     T: Sized,\n {\n     #[inline]\n@@ -35,7 +35,7 @@ pub(crate) struct SimdMutPtr<T, const LANES: usize>([*mut T; LANES]);\n \n impl<T, const LANES: usize> SimdMutPtr<T, LANES>\n where\n-    SimdUsize<LANES>: crate::Vector,\n+    LaneCount<LANES>: SupportedLaneCount,\n     T: Sized,\n {\n     #[inline]"}, {"sha": "b19f694872aecbc9c9461e464fb97230b2371ccc", "filename": "crates/core_simd/src/vector/uint.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs?ref=97c25dd7465f4db60c013d7688b809a7da5388a6", "patch": "@@ -1,22 +1,27 @@\n #![allow(non_camel_case_types)]\n \n+use crate::{LaneCount, SupportedLaneCount};\n+\n /// Implements additional integer traits (Eq, Ord, Hash) on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n macro_rules! impl_unsigned_vector {\n     { $name:ident, $type:ty } => {\n         impl_vector! { $name, $type }\n         impl_integer_reductions! { $name, $type }\n \n-        impl<const LANES: usize> Eq for $name<LANES> where Self: crate::Vector {}\n+        impl<const LANES: usize> Eq for $name<LANES> where LaneCount<LANES>: SupportedLaneCount {}\n \n-        impl<const LANES: usize> Ord for $name<LANES> where Self: crate::Vector {\n+        impl<const LANES: usize> Ord for $name<LANES> where LaneCount<LANES>: SupportedLaneCount {\n             #[inline]\n             fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n                 // TODO use SIMD cmp\n                 self.as_array().cmp(other.as_ref())\n             }\n         }\n \n-        impl<const LANES: usize> core::hash::Hash for $name<LANES> where Self: crate::Vector {\n+        impl<const LANES: usize> core::hash::Hash for $name<LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n             #[inline]\n             fn hash<H>(&self, state: &mut H)\n             where\n@@ -32,39 +37,39 @@ macro_rules! impl_unsigned_vector {\n #[repr(simd)]\n pub struct SimdUsize<const LANES: usize>([usize; LANES])\n where\n-    Self: crate::Vector;\n+    LaneCount<LANES>: SupportedLaneCount;\n \n impl_unsigned_vector! { SimdUsize, usize }\n \n /// A SIMD vector of containing `LANES` `u16` values.\n #[repr(simd)]\n pub struct SimdU16<const LANES: usize>([u16; LANES])\n where\n-    Self: crate::Vector;\n+    LaneCount<LANES>: SupportedLaneCount;\n \n impl_unsigned_vector! { SimdU16, u16 }\n \n /// A SIMD vector of containing `LANES` `u32` values.\n #[repr(simd)]\n pub struct SimdU32<const LANES: usize>([u32; LANES])\n where\n-    Self: crate::Vector;\n+    LaneCount<LANES>: SupportedLaneCount;\n \n impl_unsigned_vector! { SimdU32, u32 }\n \n /// A SIMD vector of containing `LANES` `u64` values.\n #[repr(simd)]\n pub struct SimdU64<const LANES: usize>([u64; LANES])\n where\n-    Self: crate::Vector;\n+    LaneCount<LANES>: SupportedLaneCount;\n \n impl_unsigned_vector! { SimdU64, u64 }\n \n /// A SIMD vector of containing `LANES` `u8` values.\n #[repr(simd)]\n pub struct SimdU8<const LANES: usize>([u8; LANES])\n where\n-    Self: crate::Vector;\n+    LaneCount<LANES>: SupportedLaneCount;\n \n impl_unsigned_vector! { SimdU8, u8 }\n "}, {"sha": "58ea244adfcb097637604c53eb72f508ffaf2729", "filename": "crates/core_simd/src/vector/vector_impl.rs", "status": "modified", "additions": 28, "deletions": 45, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fvector%2Fvector_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Fcore_simd%2Fsrc%2Fvector%2Fvector_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fvector_impl.rs?ref=97c25dd7465f4db60c013d7688b809a7da5388a6", "patch": "@@ -1,37 +1,28 @@\n-macro_rules! impl_vector_trait {\n-    ($simd:ident {type Scalar = $scalar:ty;}) => {\n-        impl_vector_trait! { $simd<1> { type Scalar = $scalar; type BitMask = u8; } }\n-        impl_vector_trait! { $simd<2> { type Scalar = $scalar; type BitMask = u8; } }\n-        impl_vector_trait! { $simd<4> { type Scalar = $scalar; type BitMask = u8; } }\n-        impl_vector_trait! { $simd<8> { type Scalar = $scalar; type BitMask = u8; } }\n-        impl_vector_trait! { $simd<16> { type Scalar = $scalar; type BitMask = u16; } }\n-        impl_vector_trait! { $simd<32> { type Scalar = $scalar; type BitMask = u32; } }\n-    };\n-    ($simd:ident<$lanes:literal> {type Scalar = $scalar:ty; type BitMask = $bitmask:ident; }) => {\n-        impl crate::vector::sealed::Sealed for $simd<$lanes> {}\n-\n-        impl crate::vector::Vector for $simd<$lanes> {\n-            type Scalar = $scalar;\n-            const LANES: usize = $lanes;\n+/// Implements common traits on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n+macro_rules! impl_vector {\n+    { $name:ident, $type:ty } => {\n+        impl<const LANES: usize> crate::vector::sealed::Sealed for $name<LANES>\n+        where\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n+        {}\n \n-            type BitMask = $bitmask;\n+        impl<const LANES: usize> crate::vector::Vector for $name<LANES>\n+        where\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n+        {\n+            type Scalar = $type;\n+            const LANES: usize = LANES;\n \n             #[inline]\n             fn splat(val: Self::Scalar) -> Self {\n                 Self::splat(val)\n             }\n         }\n-    };\n-}\n-\n-/// Implements common traits on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n-macro_rules! impl_vector {\n-    { $name:ident, $type:ty } => {\n-        impl_vector_trait! {\n-            $name { type Scalar = $type; }\n-        }\n \n-        impl<const LANES: usize> $name<LANES> where Self: crate::Vector {\n+        impl<const LANES: usize> $name<LANES>\n+        where\n+            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n+        {\n             /// Construct a SIMD vector by setting all lanes to the given value.\n             pub const fn splat(value: $type) -> Self {\n                 Self([value; LANES])\n@@ -56,15 +47,7 @@ macro_rules! impl_vector {\n             pub const fn to_array(self) -> [$type; LANES] {\n                 self.0\n             }\n-        }\n \n-        impl<const LANES: usize> $name<LANES>\n-        where\n-            Self: crate::Vector,\n-            crate::MaskSize<LANES>: crate::Mask,\n-            crate::SimdIsize<LANES>: crate::Vector,\n-            crate::SimdUsize<LANES>: crate::Vector,\n-        {\n             /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n             /// If an index is out of bounds, that lane instead selects the value from the \"or\" vector.\n             /// ```\n@@ -194,31 +177,31 @@ macro_rules! impl_vector {\n             }\n         }\n \n-        impl<const LANES: usize> Copy for $name<LANES> where Self: crate::Vector {}\n+        impl<const LANES: usize> Copy for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {}\n \n-        impl<const LANES: usize> Clone for $name<LANES> where Self: crate::Vector {\n+        impl<const LANES: usize> Clone for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n             #[inline]\n             fn clone(&self) -> Self {\n                 *self\n             }\n         }\n \n-        impl<const LANES: usize> Default for $name<LANES> where Self: crate::Vector {\n+        impl<const LANES: usize> Default for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n             #[inline]\n             fn default() -> Self {\n                 Self::splat(<$type>::default())\n             }\n         }\n \n-        impl<const LANES: usize> PartialEq for $name<LANES> where Self: crate::Vector {\n+        impl<const LANES: usize> PartialEq for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n             #[inline]\n             fn eq(&self, other: &Self) -> bool {\n                 // TODO use SIMD equality\n                 self.to_array() == other.to_array()\n             }\n         }\n \n-        impl<const LANES: usize> PartialOrd for $name<LANES> where Self: crate::Vector {\n+        impl<const LANES: usize> PartialOrd for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n             #[inline]\n             fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n                 // TODO use SIMD equalitya\n@@ -227,43 +210,43 @@ macro_rules! impl_vector {\n         }\n \n         // array references\n-        impl<const LANES: usize> AsRef<[$type; LANES]> for $name<LANES> where Self: crate::Vector {\n+        impl<const LANES: usize> AsRef<[$type; LANES]> for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n             #[inline]\n             fn as_ref(&self) -> &[$type; LANES] {\n                 &self.0\n             }\n         }\n \n-        impl<const LANES: usize> AsMut<[$type; LANES]> for $name<LANES> where Self: crate::Vector {\n+        impl<const LANES: usize> AsMut<[$type; LANES]> for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n             #[inline]\n             fn as_mut(&mut self) -> &mut [$type; LANES] {\n                 &mut self.0\n             }\n         }\n \n         // slice references\n-        impl<const LANES: usize> AsRef<[$type]> for $name<LANES> where Self: crate::Vector {\n+        impl<const LANES: usize> AsRef<[$type]> for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n             #[inline]\n             fn as_ref(&self) -> &[$type] {\n                 &self.0\n             }\n         }\n \n-        impl<const LANES: usize> AsMut<[$type]> for $name<LANES> where Self: crate::Vector {\n+        impl<const LANES: usize> AsMut<[$type]> for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n             #[inline]\n             fn as_mut(&mut self) -> &mut [$type] {\n                 &mut self.0\n             }\n         }\n \n         // vector/array conversion\n-        impl<const LANES: usize> From<[$type; LANES]> for $name<LANES> where Self: crate::Vector {\n+        impl<const LANES: usize> From<[$type; LANES]> for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n             fn from(array: [$type; LANES]) -> Self {\n                 Self(array)\n             }\n         }\n \n-        impl <const LANES: usize> From<$name<LANES>> for [$type; LANES] where $name<LANES>: crate::Vector {\n+        impl <const LANES: usize> From<$name<LANES>> for [$type; LANES] where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n             fn from(vector: $name<LANES>) -> Self {\n                 vector.to_array()\n             }"}, {"sha": "5c6478876f30be88797794d6c571fceb62193a1a", "filename": "crates/test_helpers/src/lib.rs", "status": "modified", "additions": 2, "deletions": 34, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c25dd7465f4db60c013d7688b809a7da5388a6/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Flib.rs?ref=97c25dd7465f4db60c013d7688b809a7da5388a6", "patch": "@@ -335,23 +335,7 @@ macro_rules! test_lanes {\n \n                 fn implementation<const $lanes: usize>()\n                 where\n-                    core_simd::SimdU8<$lanes>: core_simd::Vector,\n-                    core_simd::SimdU16<$lanes>: core_simd::Vector,\n-                    core_simd::SimdU32<$lanes>: core_simd::Vector,\n-                    core_simd::SimdU64<$lanes>: core_simd::Vector,\n-                    core_simd::SimdUsize<$lanes>: core_simd::Vector,\n-                    core_simd::SimdI8<$lanes>: core_simd::Vector,\n-                    core_simd::SimdI16<$lanes>: core_simd::Vector,\n-                    core_simd::SimdI32<$lanes>: core_simd::Vector,\n-                    core_simd::SimdI64<$lanes>: core_simd::Vector,\n-                    core_simd::SimdIsize<$lanes>: core_simd::Vector,\n-                    core_simd::SimdF32<$lanes>: core_simd::Vector,\n-                    core_simd::SimdF64<$lanes>: core_simd::Vector,\n-                    core_simd::Mask8<$lanes>: core_simd::Mask,\n-                    core_simd::Mask16<$lanes>: core_simd::Mask,\n-                    core_simd::Mask32<$lanes>: core_simd::Mask,\n-                    core_simd::Mask64<$lanes>: core_simd::Mask,\n-                    core_simd::MaskSize<$lanes>: core_simd::Mask,\n+                    core_simd::LaneCount<$lanes>: core_simd::SupportedLaneCount,\n                 $body\n \n                 #[cfg(target_arch = \"wasm32\")]\n@@ -409,23 +393,7 @@ macro_rules! test_lanes_panic {\n \n                 fn implementation<const $lanes: usize>()\n                 where\n-                    core_simd::SimdU8<$lanes>: core_simd::Vector,\n-                    core_simd::SimdU16<$lanes>: core_simd::Vector,\n-                    core_simd::SimdU32<$lanes>: core_simd::Vector,\n-                    core_simd::SimdU64<$lanes>: core_simd::Vector,\n-                    core_simd::SimdUsize<$lanes>: core_simd::Vector,\n-                    core_simd::SimdI8<$lanes>: core_simd::Vector,\n-                    core_simd::SimdI16<$lanes>: core_simd::Vector,\n-                    core_simd::SimdI32<$lanes>: core_simd::Vector,\n-                    core_simd::SimdI64<$lanes>: core_simd::Vector,\n-                    core_simd::SimdIsize<$lanes>: core_simd::Vector,\n-                    core_simd::SimdF32<$lanes>: core_simd::Vector,\n-                    core_simd::SimdF64<$lanes>: core_simd::Vector,\n-                    core_simd::Mask8<$lanes>: core_simd::Mask,\n-                    core_simd::Mask16<$lanes>: core_simd::Mask,\n-                    core_simd::Mask32<$lanes>: core_simd::Mask,\n-                    core_simd::Mask64<$lanes>: core_simd::Mask,\n-                    core_simd::MaskSize<$lanes>: core_simd::Mask,\n+                    core_simd::LaneCount<$lanes>: core_simd::SupportedLaneCount,\n                 $body\n \n                 #[test]"}]}