{"sha": "39e593ab14c53fda63c3f2756716c5ad3cbb6465", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ZTU5M2FiMTRjNTNmZGE2M2MzZjI3NTY3MTZjNWFkM2NiYjY0NjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-09T18:19:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-09T18:19:34Z"}, "message": "Auto merge of #75137 - Aaron1011:fix/hygiene-skip-expndata, r=petrochenkov\n\nDon't serialize ExpnData for foreign crates\n\nWhen we encode an ExpnId into the crate metadata, we write out the\nCrateNum of the crate that 'owns' the corresponding `ExpnData`, which\nis later used to decode the `ExpnData` from its owning crate.\n\nHowever, we current serialize the `ExpnData` for all `ExpnIds` that we\nserialize, even if the `ExpnData` was already serialized into a foreign\ncrate. This commit skips encoding this kind of `ExpnData`, which should\nhopefully speed up metadata encoding and reduce the total metadata size.", "tree": {"sha": "eb47a430c721ac4c8c0702b2295fe821289c60b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb47a430c721ac4c8c0702b2295fe821289c60b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39e593ab14c53fda63c3f2756716c5ad3cbb6465", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39e593ab14c53fda63c3f2756716c5ad3cbb6465", "html_url": "https://github.com/rust-lang/rust/commit/39e593ab14c53fda63c3f2756716c5ad3cbb6465", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39e593ab14c53fda63c3f2756716c5ad3cbb6465/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "543f03d24118d3af784aa98c507c00e30c796a0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/543f03d24118d3af784aa98c507c00e30c796a0e", "html_url": "https://github.com/rust-lang/rust/commit/543f03d24118d3af784aa98c507c00e30c796a0e"}, {"sha": "ef49032297b90e7010b08db04d569dd8a5f0a8f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef49032297b90e7010b08db04d569dd8a5f0a8f2", "html_url": "https://github.com/rust-lang/rust/commit/ef49032297b90e7010b08db04d569dd8a5f0a8f2"}], "stats": {"total": 29, "additions": 25, "deletions": 4}, "files": [{"sha": "f75f0b74a0e1e19eed3290bd55e477826e1e6f50", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39e593ab14c53fda63c3f2756716c5ad3cbb6465/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39e593ab14c53fda63c3f2756716c5ad3cbb6465/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=39e593ab14c53fda63c3f2756716c5ad3cbb6465", "patch": "@@ -279,6 +279,10 @@ impl<'a, 'tcx> SpecializedEncoder<Span> for EncodeContext<'a, 'tcx> {\n         // cross-crate inconsistencies (getting one behavior in the same\n         // crate, and a different behavior in another crate) due to the\n         // limited surface that proc-macros can expose.\n+        //\n+        // IMPORTANT: If this is ever changed, be sure to update\n+        // `rustc_span::hygiene::raw_encode_expn_id` to handle\n+        // encoding `ExpnData` for proc-macro crates.\n         if self.is_proc_macro {\n             SyntaxContext::root().encode(self)?;\n         } else {"}, {"sha": "f52b2195c2f6e25d6bc797e24511808c43a08374", "filename": "src/librustc_span/hygiene.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/39e593ab14c53fda63c3f2756716c5ad3cbb6465/src%2Flibrustc_span%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39e593ab14c53fda63c3f2756716c5ad3cbb6465/src%2Flibrustc_span%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fhygiene.rs?ref=39e593ab14c53fda63c3f2756716c5ad3cbb6465", "patch": "@@ -1172,13 +1172,30 @@ pub fn raw_encode_expn_id<E: Encoder>(\n     mode: ExpnDataEncodeMode,\n     e: &mut E,\n ) -> Result<(), E::Error> {\n-    if !context.serialized_expns.lock().contains(&expn) {\n-        context.latest_expns.lock().insert(expn);\n-    }\n+    // Record the fact that we need to serialize the corresponding\n+    // `ExpnData`\n+    let needs_data = || {\n+        if !context.serialized_expns.lock().contains(&expn) {\n+            context.latest_expns.lock().insert(expn);\n+        }\n+    };\n+\n     match mode {\n-        ExpnDataEncodeMode::IncrComp => expn.0.encode(e),\n+        ExpnDataEncodeMode::IncrComp => {\n+            // Always serialize the `ExpnData` in incr comp mode\n+            needs_data();\n+            expn.0.encode(e)\n+        }\n         ExpnDataEncodeMode::Metadata => {\n             let data = expn.expn_data();\n+            // We only need to serialize the ExpnData\n+            // if it comes from this crate.\n+            // We currently don't serialize any hygiene information data for\n+            // proc-macro crates: see the `SpecializedEncoder<Span>` impl\n+            // for crate metadata.\n+            if data.krate == LOCAL_CRATE {\n+                needs_data();\n+            }\n             data.orig_id.expect(\"Missing orig_id\").encode(e)?;\n             data.krate.encode(e)\n         }"}]}