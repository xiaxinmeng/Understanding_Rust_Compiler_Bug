{"sha": "d0011b0c057d39dd9a6a1a671a22aad43b38535c", "node_id": "C_kwDOAAsO6NoAKGQwMDExYjBjMDU3ZDM5ZGQ5YTZhMWE2NzFhMjJhYWQ0M2IzODUzNWM", "commit": {"author": {"name": "Joshua Nelson", "email": "jnelson@cloudflare.com", "date": "2022-06-27T02:07:27Z"}, "committer": {"name": "Joshua Nelson", "email": "jnelson@cloudflare.com", "date": "2022-07-03T00:29:39Z"}, "message": "Allow building single crates for the compiler and standard library\n\n- Add `Interned<Vec<String>>` and use it for tail args\n- Refactor `cache.rs` not to need a separate impl for each internable type", "tree": {"sha": "7ba2a065710d5113bf22195852672f83f36807bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ba2a065710d5113bf22195852672f83f36807bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0011b0c057d39dd9a6a1a671a22aad43b38535c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0011b0c057d39dd9a6a1a671a22aad43b38535c", "html_url": "https://github.com/rust-lang/rust/commit/d0011b0c057d39dd9a6a1a671a22aad43b38535c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0011b0c057d39dd9a6a1a671a22aad43b38535c/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0566ade0b13fa5e4e09ea6d72fe7cb92a1cb13e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0566ade0b13fa5e4e09ea6d72fe7cb92a1cb13e3", "html_url": "https://github.com/rust-lang/rust/commit/0566ade0b13fa5e4e09ea6d72fe7cb92a1cb13e3"}], "stats": {"total": 292, "additions": 182, "deletions": 110}, "files": [{"sha": "49f4847c7c767417b0c0bda787469b05bdfc997d", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d0011b0c057d39dd9a6a1a671a22aad43b38535c/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0011b0c057d39dd9a6a1a671a22aad43b38535c/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=d0011b0c057d39dd9a6a1a671a22aad43b38535c", "patch": "@@ -13,7 +13,6 @@ use std::process::{Command, Stdio};\n use std::time::{Duration, Instant};\n \n use crate::cache::{Cache, Interned, INTERNER};\n-use crate::compile;\n use crate::config::{SplitDebuginfo, TargetSelection};\n use crate::dist;\n use crate::doc;\n@@ -26,6 +25,7 @@ use crate::tool::{self, SourceType};\n use crate::util::{self, add_dylib_path, add_link_lib_path, exe, libdir, output, t};\n use crate::EXTRA_CHECK_CFGS;\n use crate::{check, Config};\n+use crate::{compile, Crate};\n use crate::{Build, CLang, DocTests, GitRepo, Mode};\n \n pub use crate::Compiler;\n@@ -422,8 +422,16 @@ impl<'a> ShouldRun<'a> {\n     /// any of its (local) dependencies.\n     ///\n     /// `make_run` will be called a single time with all matching command-line paths.\n-    pub fn krate(mut self, name: &str) -> Self {\n-        for krate in self.builder.in_tree_crates(name, None) {\n+    pub fn crate_or_deps(self, name: &str) -> Self {\n+        let crates = self.builder.in_tree_crates(name, None);\n+        self.crates(crates)\n+    }\n+\n+    /// Indicates it should run if the command-line selects any of the given crates.\n+    ///\n+    /// `make_run` will be called a single time with all matching command-line paths.\n+    pub(crate) fn crates(mut self, crates: Vec<&Crate>) -> Self {\n+        for krate in crates {\n             let path = krate.local_path(self.builder);\n             self.paths.insert(PathSet::one(path, self.kind));\n         }\n@@ -579,6 +587,7 @@ impl<'a> Builder<'a> {\n         match kind {\n             Kind::Build => describe!(\n                 compile::Std,\n+                compile::Rustc,\n                 compile::Assemble,\n                 compile::CodegenBackend,\n                 compile::StartupObjects,"}, {"sha": "c084e77d3a9943c120395d961e2272788c938e43", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 63, "deletions": 62, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/d0011b0c057d39dd9a6a1a671a22aad43b38535c/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0011b0c057d39dd9a6a1a671a22aad43b38535c/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=d0011b0c057d39dd9a6a1a671a22aad43b38535c", "patch": "@@ -57,6 +57,24 @@ fn check_cli<const N: usize>(paths: [&str; N]) {\n     );\n }\n \n+macro_rules! std {\n+    ($host:ident => $target:ident, stage = $stage:literal) => {\n+        compile::Std::new(\n+            Compiler { host: TargetSelection::from_user(stringify!($host)), stage: $stage },\n+            TargetSelection::from_user(stringify!($target)),\n+        )\n+    };\n+}\n+\n+macro_rules! rustc {\n+    ($host:ident => $target:ident, stage = $stage:literal) => {\n+        compile::Rustc::new(\n+            Compiler { host: TargetSelection::from_user(stringify!($host)), stage: $stage },\n+            TargetSelection::from_user(stringify!($target)),\n+        )\n+    };\n+}\n+\n #[test]\n fn test_valid() {\n     // make sure multi suite paths are accepted\n@@ -117,6 +135,17 @@ fn test_exclude_kind() {\n     assert!(run_build(&[path], config).contains::<tool::CargoTest>());\n }\n \n+/// Ensure that if someone passes both a single crate and `library`, all library crates get built.\n+#[test]\n+fn alias_and_path_for_library() {\n+    let mut cache =\n+        run_build(&[\"library\".into(), \"core\".into()], configure(\"build\", &[\"A\"], &[\"A\"]));\n+    assert_eq!(\n+        first(cache.all::<compile::Std>()),\n+        &[std!(A => A, stage = 0), std!(A => A, stage = 1)]\n+    );\n+}\n+\n mod defaults {\n     use super::{configure, first, run_build};\n     use crate::builder::*;\n@@ -130,10 +159,7 @@ mod defaults {\n         let a = TargetSelection::from_user(\"A\");\n         assert_eq!(\n             first(cache.all::<compile::Std>()),\n-            &[\n-                compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n-                compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n-            ]\n+            &[std!(A => A, stage = 0), std!(A => A, stage = 1),]\n         );\n         assert!(!cache.all::<compile::Assemble>().is_empty());\n         // Make sure rustdoc is only built once.\n@@ -143,10 +169,7 @@ mod defaults {\n             // - this is the compiler it's _linked_ to, not built with.\n             &[tool::Rustdoc { compiler: Compiler { host: a, stage: 1 } }],\n         );\n-        assert_eq!(\n-            first(cache.all::<compile::Rustc>()),\n-            &[compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },]\n-        );\n+        assert_eq!(first(cache.all::<compile::Rustc>()), &[rustc!(A => A, stage = 0)],);\n     }\n \n     #[test]\n@@ -155,10 +178,7 @@ mod defaults {\n         let mut cache = run_build(&[], config);\n \n         let a = TargetSelection::from_user(\"A\");\n-        assert_eq!(\n-            first(cache.all::<compile::Std>()),\n-            &[compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },]\n-        );\n+        assert_eq!(first(cache.all::<compile::Std>()), &[std!(A => A, stage = 0)]);\n         assert!(!cache.all::<compile::Assemble>().is_empty());\n         assert_eq!(\n             first(cache.all::<tool::Rustdoc>()),\n@@ -185,10 +205,10 @@ mod defaults {\n         assert_eq!(\n             first(cache.all::<compile::Std>()),\n             &[\n-                compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n-                compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n-                compile::Std { compiler: Compiler { host: a, stage: 0 }, target: b },\n-                compile::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n+                std!(A => A, stage = 0),\n+                std!(A => A, stage = 1),\n+                std!(A => B, stage = 0),\n+                std!(A => B, stage = 1),\n             ]\n         );\n         assert_eq!(\n@@ -208,10 +228,7 @@ mod defaults {\n         );\n         assert_eq!(\n             first(cache.all::<compile::Rustc>()),\n-            &[\n-                compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },\n-                compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: b },\n-            ]\n+            &[rustc!(A => A, stage = 0), rustc!(A => B, stage = 0),]\n         );\n     }\n \n@@ -334,19 +351,18 @@ mod dist {\n         assert_eq!(\n             first(cache.all::<compile::Std>()),\n             &[\n-                compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n-                compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n-                compile::Std { compiler: Compiler { host: a, stage: 2 }, target: a },\n-                compile::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n-                compile::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n+                std!(A => A, stage = 0),\n+                std!(A => A, stage = 1),\n+                std!(A => A, stage = 2),\n+                std!(A => B, stage = 1),\n+                std!(A => B, stage = 2),\n             ],\n         );\n         assert_eq!(first(cache.all::<dist::Src>()), &[dist::Src]);\n     }\n \n     #[test]\n     fn dist_only_cross_host() {\n-        let a = TargetSelection::from_user(\"A\");\n         let b = TargetSelection::from_user(\"B\");\n         let mut config = configure(&[\"A\", \"B\"], &[\"A\", \"B\"]);\n         config.docs = false;\n@@ -360,10 +376,7 @@ mod dist {\n         );\n         assert_eq!(\n             first(cache.all::<compile::Rustc>()),\n-            &[\n-                compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },\n-                compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: b },\n-            ]\n+            &[rustc!(A => A, stage = 0), rustc!(A => B, stage = 1),]\n         );\n     }\n \n@@ -450,11 +463,11 @@ mod dist {\n         assert_eq!(\n             first(cache.all::<compile::Std>()),\n             &[\n-                compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n-                compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n-                compile::Std { compiler: Compiler { host: a, stage: 2 }, target: a },\n-                compile::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n-                compile::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n+                std!(A => A, stage = 0),\n+                std!(A => A, stage = 1),\n+                std!(A => A, stage = 2),\n+                std!(A => B, stage = 1),\n+                std!(A => B, stage = 2),\n             ]\n         );\n         assert_eq!(\n@@ -474,33 +487,29 @@ mod dist {\n         let mut builder = Builder::new(&build);\n         builder.run_step_descriptions(\n             &Builder::get_step_descriptions(Kind::Build),\n-            &[\"compiler/rustc\".into(), \"library/std\".into()],\n+            &[\"compiler/rustc\".into(), \"library\".into()],\n         );\n \n-        let a = TargetSelection::from_user(\"A\");\n-        let b = TargetSelection::from_user(\"B\");\n-        let c = TargetSelection::from_user(\"C\");\n-\n         assert_eq!(\n             first(builder.cache.all::<compile::Std>()),\n             &[\n-                compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n-                compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n-                compile::Std { compiler: Compiler { host: a, stage: 2 }, target: a },\n-                compile::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n-                compile::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n-                compile::Std { compiler: Compiler { host: a, stage: 2 }, target: c },\n+                std!(A => A, stage = 0),\n+                std!(A => A, stage = 1),\n+                std!(A => A, stage = 2),\n+                std!(A => B, stage = 1),\n+                std!(A => B, stage = 2),\n+                std!(A => C, stage = 2),\n             ]\n         );\n-        assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n+        assert_eq!(builder.cache.all::<compile::Assemble>().len(), 5);\n         assert_eq!(\n             first(builder.cache.all::<compile::Rustc>()),\n             &[\n-                compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },\n-                compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: a },\n-                compile::Rustc { compiler: Compiler { host: a, stage: 2 }, target: a },\n-                compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: b },\n-                compile::Rustc { compiler: Compiler { host: a, stage: 2 }, target: b },\n+                rustc!(A => A, stage = 0),\n+                rustc!(A => A, stage = 1),\n+                rustc!(A => A, stage = 2),\n+                rustc!(A => B, stage = 1),\n+                rustc!(A => B, stage = 2),\n             ]\n         );\n     }\n@@ -513,15 +522,10 @@ mod dist {\n         builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n \n         let a = TargetSelection::from_user(\"A\");\n-        let c = TargetSelection::from_user(\"C\");\n \n         assert_eq!(\n             first(builder.cache.all::<compile::Std>()),\n-            &[\n-                compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n-                compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n-                compile::Std { compiler: Compiler { host: a, stage: 2 }, target: c },\n-            ]\n+            &[std!(A => A, stage = 0), std!(A => A, stage = 1), std!(A => C, stage = 2),]\n         );\n         assert_eq!(\n             first(builder.cache.all::<compile::Assemble>()),\n@@ -533,10 +537,7 @@ mod dist {\n         );\n         assert_eq!(\n             first(builder.cache.all::<compile::Rustc>()),\n-            &[\n-                compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },\n-                compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: a },\n-            ]\n+            &[rustc!(A => A, stage = 0), rustc!(A => A, stage = 1),]\n         );\n     }\n "}, {"sha": "be5c9bb07880891cbe23550c952f2aed26a93c9a", "filename": "src/bootstrap/cache.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d0011b0c057d39dd9a6a1a671a22aad43b38535c/src%2Fbootstrap%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0011b0c057d39dd9a6a1a671a22aad43b38535c/src%2Fbootstrap%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcache.rs?ref=d0011b0c057d39dd9a6a1a671a22aad43b38535c", "patch": "@@ -162,6 +162,7 @@ impl<T: Hash + Clone + Eq> TyIntern<T> {\n pub struct Interner {\n     strs: Mutex<TyIntern<String>>,\n     paths: Mutex<TyIntern<PathBuf>>,\n+    lists: Mutex<TyIntern<Vec<String>>>,\n }\n \n trait Internable: Clone + Eq + Hash + 'static {\n@@ -184,6 +185,12 @@ impl Internable for PathBuf {\n     }\n }\n \n+impl Internable for Vec<String> {\n+    fn intern_cache() -> &'static Mutex<TyIntern<Self>> {\n+        &INTERNER.lists\n+    }\n+}\n+\n impl Interner {\n     pub fn intern_str(&self, s: &str) -> Interned<String> {\n         self.strs.lock().unwrap().intern_borrow(s)\n@@ -195,6 +202,10 @@ impl Interner {\n     pub fn intern_path(&self, s: PathBuf) -> Interned<PathBuf> {\n         self.paths.lock().unwrap().intern(s)\n     }\n+\n+    pub fn intern_list(&self, v: Vec<String>) -> Interned<Vec<String>> {\n+        self.lists.lock().unwrap().intern(v)\n+    }\n }\n \n pub static INTERNER: Lazy<Interner> = Lazy::new(Interner::default);"}, {"sha": "4985b0546789d23ed51937391155a0fc9d924c3e", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0011b0c057d39dd9a6a1a671a22aad43b38535c/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0011b0c057d39dd9a6a1a671a22aad43b38535c/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=d0011b0c057d39dd9a6a1a671a22aad43b38535c", "patch": "@@ -184,8 +184,8 @@ impl Step for Rustc {\n             // the sysroot for the compiler to find. Otherwise, we're going to\n             // fail when building crates that need to generate code (e.g., build\n             // scripts and their dependencies).\n-            builder.ensure(crate::compile::Std { target: compiler.host, compiler });\n-            builder.ensure(crate::compile::Std { target, compiler });\n+            builder.ensure(crate::compile::Std::new(compiler, compiler.host));\n+            builder.ensure(crate::compile::Std::new(compiler, target));\n         } else {\n             builder.ensure(Std { target });\n         }"}, {"sha": "399be26d5ac14e808a817ee7cc6c29b6adbd1794", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/d0011b0c057d39dd9a6a1a671a22aad43b38535c/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0011b0c057d39dd9a6a1a671a22aad43b38535c/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=d0011b0c057d39dd9a6a1a671a22aad43b38535c", "patch": "@@ -29,10 +29,31 @@ use crate::util::{exe, is_debug_info, is_dylib, output, symlink_dir, t, up_to_da\n use crate::LLVM_TOOLS;\n use crate::{CLang, Compiler, DependencyType, GitRepo, Mode};\n \n-#[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct Std {\n     pub target: TargetSelection,\n     pub compiler: Compiler,\n+    /// Whether to build only a subset of crates in the standard library.\n+    ///\n+    /// This shouldn't be used from other steps; see the comment on [`Rustc`].\n+    crates: Interned<Vec<String>>,\n+}\n+\n+impl Std {\n+    pub fn new(compiler: Compiler, target: TargetSelection) -> Self {\n+        Self { target, compiler, crates: Default::default() }\n+    }\n+}\n+\n+/// Return a `-p=x -p=y` string suitable for passing to a cargo invocation.\n+fn build_crates_in_set(run: &RunConfig<'_>) -> Interned<Vec<String>> {\n+    let mut crates = Vec::new();\n+    for krate in &run.paths {\n+        let path = krate.assert_single_path();\n+        let crate_name = run.builder.crate_paths[&path.path];\n+        crates.push(format!(\"-p={crate_name}\"));\n+    }\n+    INTERNER.intern_list(crates)\n }\n \n impl Step for Std {\n@@ -43,15 +64,22 @@ impl Step for Std {\n         // When downloading stage1, the standard library has already been copied to the sysroot, so\n         // there's no need to rebuild it.\n         let builder = run.builder;\n-        run.all_krates(\"test\")\n+        run.crate_or_deps(\"test\")\n             .path(\"library\")\n             .lazy_default_condition(Box::new(|| !builder.download_rustc()))\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n+        // Normally, people will pass *just* library if they pass it.\n+        // But it's possible (although strange) to pass something like `library std core`.\n+        // Build all crates anyway, as if they hadn't passed the other args.\n+        let has_library =\n+            run.paths.iter().any(|set| set.assert_single_path().path.ends_with(\"library\"));\n+        let crates = if has_library { Default::default() } else { build_crates_in_set(&run) };\n         run.builder.ensure(Std {\n             compiler: run.builder.compiler(run.builder.top_stage, run.build_triple()),\n             target: run.target,\n+            crates,\n         });\n     }\n \n@@ -86,7 +114,7 @@ impl Step for Std {\n \n         let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n         if compiler_to_use != compiler {\n-            builder.ensure(Std { compiler: compiler_to_use, target });\n+            builder.ensure(Std::new(compiler_to_use, target));\n             builder.info(&format!(\"Uplifting stage1 std ({} -> {})\", compiler_to_use.host, target));\n \n             // Even if we're not building std this stage, the new sysroot must\n@@ -115,7 +143,7 @@ impl Step for Std {\n         run_cargo(\n             builder,\n             cargo,\n-            vec![],\n+            self.crates.to_vec(),\n             &libstd_stamp(builder, compiler, target),\n             target_deps,\n             false,\n@@ -524,6 +552,18 @@ impl Step for StartupObjects {\n pub struct Rustc {\n     pub target: TargetSelection,\n     pub compiler: Compiler,\n+    /// Whether to build a subset of crates, rather than the whole compiler.\n+    ///\n+    /// This should only be requested by the user, not used within rustbuild itself.\n+    /// Using it within rustbuild can lead to confusing situation where lints are replayed\n+    /// in two different steps.\n+    crates: Interned<Vec<String>>,\n+}\n+\n+impl Rustc {\n+    pub fn new(compiler: Compiler, target: TargetSelection) -> Self {\n+        Self { target, compiler, crates: Default::default() }\n+    }\n }\n \n impl Step for Rustc {\n@@ -532,13 +572,22 @@ impl Step for Rustc {\n     const DEFAULT: bool = false;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.never()\n+        let mut crates = run.builder.in_tree_crates(\"rustc-main\", None);\n+        for (i, krate) in crates.iter().enumerate() {\n+            if krate.name == \"rustc-main\" {\n+                crates.swap_remove(i);\n+                break;\n+            }\n+        }\n+        run.crates(crates)\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n+        let crates = build_crates_in_set(&run);\n         run.builder.ensure(Rustc {\n             compiler: run.builder.compiler(run.builder.top_stage, run.build_triple()),\n             target: run.target,\n+            crates,\n         });\n     }\n \n@@ -560,7 +609,7 @@ impl Step for Rustc {\n             return;\n         }\n \n-        builder.ensure(Std { compiler, target });\n+        builder.ensure(Std::new(compiler, target));\n \n         if builder.config.keep_stage.contains(&compiler.stage) {\n             builder.info(\"Warning: Using a potentially old librustc. This may not behave well.\");\n@@ -571,7 +620,7 @@ impl Step for Rustc {\n \n         let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n         if compiler_to_use != compiler {\n-            builder.ensure(Rustc { compiler: compiler_to_use, target });\n+            builder.ensure(Rustc::new(compiler_to_use, target));\n             builder\n                 .info(&format!(\"Uplifting stage1 rustc ({} -> {})\", builder.config.build, target));\n             builder.ensure(RustcLink {\n@@ -583,10 +632,10 @@ impl Step for Rustc {\n         }\n \n         // Ensure that build scripts and proc macros have a std / libproc_macro to link against.\n-        builder.ensure(Std {\n-            compiler: builder.compiler(self.compiler.stage, builder.config.build),\n-            target: builder.config.build,\n-        });\n+        builder.ensure(Std::new(\n+            builder.compiler(self.compiler.stage, builder.config.build),\n+            builder.config.build,\n+        ));\n \n         let mut cargo = builder.cargo(compiler, Mode::Rustc, SourceType::InTree, target, \"build\");\n         rustc_cargo(builder, &mut cargo, target);\n@@ -633,7 +682,7 @@ impl Step for Rustc {\n         run_cargo(\n             builder,\n             cargo,\n-            vec![],\n+            self.crates.to_vec(),\n             &librustc_stamp(builder, compiler, target),\n             vec![],\n             false,\n@@ -821,7 +870,7 @@ impl Step for CodegenBackend {\n         let target = self.target;\n         let backend = self.backend;\n \n-        builder.ensure(Rustc { compiler, target });\n+        builder.ensure(Rustc::new(compiler, target));\n \n         if builder.config.keep_stage.contains(&compiler.stage) {\n             builder.info(\n@@ -1103,7 +1152,7 @@ impl Step for Assemble {\n         // link to these. (FIXME: Is that correct? It seems to be correct most\n         // of the time but I think we do link to these for stage2/bin compilers\n         // when not performing a full bootstrap).\n-        builder.ensure(Rustc { compiler: build_compiler, target: target_compiler.host });\n+        builder.ensure(Rustc::new(build_compiler, target_compiler.host));\n \n         for &backend in builder.config.rust_codegen_backends.iter() {\n             if backend == \"llvm\" {"}, {"sha": "65ad32670d841832ce2d1ebb72a10d67062e3656", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0011b0c057d39dd9a6a1a671a22aad43b38535c/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0011b0c057d39dd9a6a1a671a22aad43b38535c/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=d0011b0c057d39dd9a6a1a671a22aad43b38535c", "patch": "@@ -557,7 +557,7 @@ impl Step for Std {\n             return None;\n         }\n \n-        builder.ensure(compile::Std { compiler, target });\n+        builder.ensure(compile::Std::new(compiler, target));\n \n         let mut tarball = Tarball::new(builder, \"rust-std\", &target.triple);\n         tarball.include_target_in_component_name(true);\n@@ -603,7 +603,7 @@ impl Step for RustcDev {\n             return None;\n         }\n \n-        builder.ensure(compile::Rustc { compiler, target });\n+        builder.ensure(compile::Rustc::new(compiler, target));\n \n         let tarball = Tarball::new(builder, \"rustc-dev\", &target.triple);\n \n@@ -666,7 +666,7 @@ impl Step for Analysis {\n             return None;\n         }\n \n-        builder.ensure(compile::Std { compiler, target });\n+        builder.ensure(compile::Std::new(compiler, target));\n         let src = builder\n             .stage_out(compiler, Mode::Std)\n             .join(target.triple)"}, {"sha": "59c5651acdb9190e2e83dac25462a75234912b97", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d0011b0c057d39dd9a6a1a671a22aad43b38535c/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0011b0c057d39dd9a6a1a671a22aad43b38535c/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=d0011b0c057d39dd9a6a1a671a22aad43b38535c", "patch": "@@ -534,7 +534,9 @@ impl Step for Rustc {\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n-        run.krate(\"rustc-main\").path(\"compiler\").default_condition(builder.config.compiler_docs)\n+        run.crate_or_deps(\"rustc-main\")\n+            .path(\"compiler\")\n+            .default_condition(builder.config.compiler_docs)\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -567,7 +569,7 @@ impl Step for Rustc {\n         // Build the standard library, so that proc-macros can use it.\n         // (Normally, only the metadata would be necessary, but proc-macros are special since they run at compile-time.)\n         let compiler = builder.compiler(stage, builder.config.build);\n-        builder.ensure(compile::Std { compiler, target: builder.config.build });\n+        builder.ensure(compile::Std::new(compiler, builder.config.build));\n \n         builder.info(&format!(\"Documenting stage{} compiler ({})\", stage, target));\n \n@@ -656,7 +658,7 @@ macro_rules! tool_doc {\n \n             fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n                 let builder = run.builder;\n-                run.krate($should_run).default_condition(builder.config.compiler_docs)\n+                run.crate_or_deps($should_run).default_condition(builder.config.compiler_docs)\n             }\n \n             fn make_run(run: RunConfig<'_>) {\n@@ -683,7 +685,7 @@ macro_rules! tool_doc {\n                 // FIXME: is there a way to only ensure `check::Rustc` here? Last time I tried it failed\n                 // with strange errors, but only on a full bors test ...\n                 let compiler = builder.compiler(stage, builder.config.build);\n-                builder.ensure(compile::Rustc { compiler, target });\n+                builder.ensure(compile::Rustc::new(compiler, target));\n \n                 builder.info(\n                     &format!(\n@@ -866,7 +868,7 @@ impl Step for RustcBook {\n         let rustc = builder.rustc(self.compiler);\n         // The tool runs `rustc` for extracting output examples, so it needs a\n         // functional sysroot.\n-        builder.ensure(compile::Std { compiler: self.compiler, target: self.target });\n+        builder.ensure(compile::Std::new(self.compiler, self.target));\n         let mut cmd = builder.tool_cmd(Tool::LintDocs);\n         cmd.arg(\"--src\");\n         cmd.arg(builder.src.join(\"compiler\"));"}, {"sha": "00550560ec22a5bfc78a5941154e8e3df7787c95", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d0011b0c057d39dd9a6a1a671a22aad43b38535c/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0011b0c057d39dd9a6a1a671a22aad43b38535c/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=d0011b0c057d39dd9a6a1a671a22aad43b38535c", "patch": "@@ -225,7 +225,7 @@ impl Step for Cargotest {\n     /// test` to ensure that we don't regress the test suites there.\n     fn run(self, builder: &Builder<'_>) {\n         let compiler = builder.compiler(self.stage, self.host);\n-        builder.ensure(compile::Rustc { compiler, target: compiler.host });\n+        builder.ensure(compile::Rustc::new(compiler, compiler.host));\n         let cargo = builder.ensure(tool::Cargo { compiler, target: compiler.host });\n \n         // Note that this is a short, cryptic, and not scoped directory name. This\n@@ -603,7 +603,7 @@ impl Step for CompiletestTest {\n \n         // We need `ToolStd` for the locally-built sysroot because\n         // compiletest uses unstable features of the `test` crate.\n-        builder.ensure(compile::Std { compiler, target: host });\n+        builder.ensure(compile::Std::new(compiler, host));\n         let cargo = tool::prepare_tool_cargo(\n             builder,\n             compiler,\n@@ -896,7 +896,7 @@ impl Step for RustdocGUI {\n         let nodejs = builder.config.nodejs.as_ref().expect(\"nodejs isn't available\");\n         let npm = builder.config.npm.as_ref().expect(\"npm isn't available\");\n \n-        builder.ensure(compile::Std { compiler: self.compiler, target: self.target });\n+        builder.ensure(compile::Std::new(self.compiler, self.target));\n \n         // The goal here is to check if the necessary packages are installed, and if not, we\n         // panic.\n@@ -1273,12 +1273,12 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n         }\n \n         if suite.ends_with(\"fulldeps\") {\n-            builder.ensure(compile::Rustc { compiler, target });\n+            builder.ensure(compile::Rustc::new(compiler, target));\n         }\n \n-        builder.ensure(compile::Std { compiler, target });\n+        builder.ensure(compile::Std::new(compiler, target));\n         // ensure that `libproc_macro` is available on the host.\n-        builder.ensure(compile::Std { compiler, target: compiler.host });\n+        builder.ensure(compile::Std::new(compiler, compiler.host));\n \n         // Also provide `rust_test_helpers` for the host.\n         builder.ensure(native::TestHelpers { target: compiler.host });\n@@ -1646,7 +1646,7 @@ impl BookTest {\n     fn run_ext_doc(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n \n-        builder.ensure(compile::Std { compiler, target: compiler.host });\n+        builder.ensure(compile::Std::new(compiler, compiler.host));\n \n         // mdbook just executes a binary named \"rustdoc\", so we need to update\n         // PATH so that it points to our rustdoc.\n@@ -1674,7 +1674,7 @@ impl BookTest {\n     fn run_local_doc(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n \n-        builder.ensure(compile::Std { compiler, target: compiler.host });\n+        builder.ensure(compile::Std::new(compiler, compiler.host));\n \n         // Do a breadth-first traversal of the `src/doc` directory and just run\n         // tests for all files that end in `*.md`\n@@ -1793,7 +1793,7 @@ impl Step for ErrorIndex {\n         builder.run_quiet(&mut tool);\n         // The tests themselves need to link to std, so make sure it is\n         // available.\n-        builder.ensure(compile::Std { compiler, target: compiler.host });\n+        builder.ensure(compile::Std::new(compiler, compiler.host));\n         markdown_test(builder, compiler, &output);\n     }\n }\n@@ -1870,7 +1870,7 @@ impl Step for CrateLibrustc {\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.krate(\"rustc-main\")\n+        run.crate_or_deps(\"rustc-main\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -1912,7 +1912,7 @@ impl Step for Crate {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.krate(\"test\")\n+        run.crate_or_deps(\"test\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -1943,7 +1943,7 @@ impl Step for Crate {\n         let mode = self.mode;\n         let test_kind = self.test_kind;\n \n-        builder.ensure(compile::Std { compiler, target });\n+        builder.ensure(compile::Std::new(compiler, target));\n         builder.ensure(RemoteCopyLibs { compiler, target });\n \n         // If we're not doing a full bootstrap but we're testing a stage2\n@@ -2065,7 +2065,7 @@ impl Step for CrateRustdoc {\n             // isn't really necessary.\n             builder.compiler_for(builder.top_stage, target, target)\n         };\n-        builder.ensure(compile::Rustc { compiler, target });\n+        builder.ensure(compile::Rustc::new(compiler, target));\n \n         let mut cargo = tool::prepare_tool_cargo(\n             builder,\n@@ -2180,7 +2180,7 @@ impl Step for CrateRustdocJsonTypes {\n         // `compiler`, then it would cause rustdoc to be built *again*, which\n         // isn't really necessary.\n         let compiler = builder.compiler_for(builder.top_stage, target, target);\n-        builder.ensure(compile::Rustc { compiler, target });\n+        builder.ensure(compile::Rustc::new(compiler, target));\n \n         let mut cargo = tool::prepare_tool_cargo(\n             builder,\n@@ -2248,7 +2248,7 @@ impl Step for RemoteCopyLibs {\n             return;\n         }\n \n-        builder.ensure(compile::Std { compiler, target });\n+        builder.ensure(compile::Std::new(compiler, target));\n \n         builder.info(&format!(\"REMOTE copy libs to emulator ({})\", target));\n \n@@ -2418,7 +2418,7 @@ impl Step for TierCheck {\n \n     /// Tests the Platform Support page in the rustc book.\n     fn run(self, builder: &Builder<'_>) {\n-        builder.ensure(compile::Std { compiler: self.compiler, target: self.compiler.host });\n+        builder.ensure(compile::Std::new(self.compiler, self.compiler.host));\n         let mut cargo = tool::prepare_tool_cargo(\n             builder,\n             self.compiler,"}, {"sha": "83e348ad9b75570b4c3ee9b9dcbe573271bef55d", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d0011b0c057d39dd9a6a1a671a22aad43b38535c/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0011b0c057d39dd9a6a1a671a22aad43b38535c/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=d0011b0c057d39dd9a6a1a671a22aad43b38535c", "patch": "@@ -51,10 +51,10 @@ impl Step for ToolBuild {\n \n         match self.mode {\n             Mode::ToolRustc => {\n-                builder.ensure(compile::Std { compiler, target: compiler.host });\n-                builder.ensure(compile::Rustc { compiler, target });\n+                builder.ensure(compile::Std::new(compiler, compiler.host));\n+                builder.ensure(compile::Rustc::new(compiler, target));\n             }\n-            Mode::ToolStd => builder.ensure(compile::Std { compiler, target }),\n+            Mode::ToolStd => builder.ensure(compile::Std::new(compiler, target)),\n             Mode::ToolBootstrap => {} // uses downloaded stage0 compiler libs\n             _ => panic!(\"unexpected Mode for tool build\"),\n         }\n@@ -512,8 +512,8 @@ impl Step for Rustdoc {\n         // When using `download-rustc` and a stage0 build_compiler, copying rustc doesn't actually\n         // build stage0 libstd (because the libstd in sysroot has the wrong ABI). Explicitly build\n         // it.\n-        builder.ensure(compile::Std { compiler: build_compiler, target: target_compiler.host });\n-        builder.ensure(compile::Rustc { compiler: build_compiler, target: target_compiler.host });\n+        builder.ensure(compile::Std::new(build_compiler, target_compiler.host));\n+        builder.ensure(compile::Rustc::new(build_compiler, target_compiler.host));\n         // NOTE: this implies that `download-rustc` is pretty useless when compiling with the stage0\n         // compiler, since you do just as much work.\n         if !builder.config.dry_run && builder.download_rustc() && build_compiler.stage == 0 {"}]}