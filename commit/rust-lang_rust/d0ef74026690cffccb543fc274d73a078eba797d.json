{"sha": "d0ef74026690cffccb543fc274d73a078eba797d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwZWY3NDAyNjY5MGNmZmNjYjU0M2ZjMjc0ZDczYTA3OGViYTc5N2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-04T18:48:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-04T18:48:41Z"}, "message": "Auto merge of #31360 - pitdicker:fs_tests_cleanup, r=alexcrichton\n\n- use `symlink_file` and `symlink_dir` instead of the old `soft_link`\n- create a junction instead of a directory symlink for testing recursive_rmdir (as it causes the\n  same troubles, but can be created by users without `SeCreateSymbolicLinkPrivilege`)\n- `remove_dir_all` was unable to remove directory symlinks and junctions\n- only run tests that create symlinks if we have the right permissions.\n- rename `Path2` to `Path`\n- remove the global `#[allow(deprecated)]` and outdated comments\n- After factoring out `create_junction()` from the test `directory_junctions_are_directories` and\n  removing needlessly complex code, what I was left with was:\n  ```\n  #[test]\n  #[cfg(windows)]\n  fn directory_junctions_are_directories() {\n      use sys::fs::create_junction;\n\n      let tmpdir = tmpdir();\n\n      let foo = tmpdir.join(\"foo\");\n      let bar = tmpdir.join(\"bar\");\n\n      fs::create_dir(&foo).unwrap();\n      check!(create_junction(&foo, &bar));\n      assert!(bar.metadata().unwrap().is_dir());\n  }\n  ```\n  It test whether a junction is a directory instead of a reparse point. But it actually test the\n  target of the junction (which is a directory if it exists) instead of the junction itself, which\n  should always be a symlink. So this test is invalid, and I expect it only exists because the\n  author was suprised by it. So I removed it.\n\nSome things that do not yet work right:\n- relative symlinks do not accept forward slashes\n- the conversion of paths for `create_junction` is hacky\n- `remove_dir_all` now messes with the internal data of `FileAttr` to be able to remove symlinks.\n  We should add some method like `is_symlink_dir()` to it, so code outside the standard library\n  can see the difference between file and directory symlinks too.", "tree": {"sha": "53b22502b696e336d3ee7ae6a722fbdbfda77053", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53b22502b696e336d3ee7ae6a722fbdbfda77053"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0ef74026690cffccb543fc274d73a078eba797d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0ef74026690cffccb543fc274d73a078eba797d", "html_url": "https://github.com/rust-lang/rust/commit/d0ef74026690cffccb543fc274d73a078eba797d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0ef74026690cffccb543fc274d73a078eba797d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f01b85b1034889888be65d2208640ac926a42d36", "url": "https://api.github.com/repos/rust-lang/rust/commits/f01b85b1034889888be65d2208640ac926a42d36", "html_url": "https://github.com/rust-lang/rust/commit/f01b85b1034889888be65d2208640ac926a42d36"}, {"sha": "fb172b676e5ab951e58b98cede795ab1a7557a58", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb172b676e5ab951e58b98cede795ab1a7557a58", "html_url": "https://github.com/rust-lang/rust/commit/fb172b676e5ab951e58b98cede795ab1a7557a58"}], "stats": {"total": 375, "additions": 192, "deletions": 183}, "files": [{"sha": "b5a682955c0c0cb4c3127f5db6e6e5b3c6f1d465", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 105, "deletions": 57, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/d0ef74026690cffccb543fc274d73a078eba797d/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ef74026690cffccb543fc274d73a078eba797d/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=d0ef74026690cffccb543fc274d73a078eba797d", "patch": "@@ -1265,20 +1265,7 @@ pub fn remove_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn remove_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n-    _remove_dir_all(path.as_ref())\n-}\n-\n-fn _remove_dir_all(path: &Path) -> io::Result<()> {\n-    for child in try!(read_dir(path)) {\n-        let child = try!(child).path();\n-        let stat = try!(symlink_metadata(&*child));\n-        if stat.is_dir() {\n-            try!(remove_dir_all(&*child));\n-        } else {\n-            try!(remove_file(&*child));\n-        }\n-    }\n-    remove_dir(path)\n+    fs_imp::remove_dir_all(path.as_ref())\n }\n \n /// Returns an iterator over the entries within a directory.\n@@ -1489,19 +1476,27 @@ impl AsInnerMut<fs_imp::DirBuilder> for DirBuilder {\n \n #[cfg(test)]\n mod tests {\n-    #![allow(deprecated)] //rand\n-\n     use prelude::v1::*;\n     use io::prelude::*;\n \n     use env;\n     use fs::{self, File, OpenOptions};\n     use io::{ErrorKind, SeekFrom};\n-    use path::PathBuf;\n-    use path::Path as Path2;\n+    use path::{Path, PathBuf};\n     use rand::{self, StdRng, Rng};\n     use str;\n \n+    #[cfg(windows)]\n+    use os::windows::fs::{symlink_dir, symlink_file};\n+    #[cfg(windows)]\n+    use sys::fs::symlink_junction;\n+    #[cfg(unix)]\n+    use os::unix::fs::symlink as symlink_dir;\n+    #[cfg(unix)]\n+    use os::unix::fs::symlink as symlink_file;\n+    #[cfg(unix)]\n+    use os::unix::fs::symlink as symlink_junction;\n+\n     macro_rules! check { ($e:expr) => (\n         match $e {\n             Ok(t) => t,\n@@ -1525,7 +1520,7 @@ mod tests {\n             p.join(path)\n         }\n \n-        fn path<'a>(&'a self) -> &'a Path2 {\n+        fn path<'a>(&'a self) -> &'a Path {\n             let TempDir(ref p) = *self;\n             p\n         }\n@@ -1548,6 +1543,27 @@ mod tests {\n         TempDir(ret)\n     }\n \n+    // Several test fail on windows if the user does not have permission to\n+    // create symlinks (the `SeCreateSymbolicLinkPrivilege`). Instead of\n+    // disabling these test on Windows, use this function to test whether we\n+    // have permission, and return otherwise. This way, we still don't run these\n+    // tests most of the time, but at least we do if the user has the right\n+    // permissions.\n+    pub fn got_symlink_permission(tmpdir: &TempDir) -> bool {\n+        if cfg!(unix) { return true }\n+        let link = tmpdir.join(\"some_hopefully_unique_link_name\");\n+\n+        match symlink_file(r\"nonexisting_target\", link) {\n+            Ok(_) => true,\n+            Err(ref err) =>\n+                if err.to_string().contains(\"A required privilege is not held by the client.\") {\n+                    false\n+                } else {\n+                    true\n+                }\n+        }\n+    }\n+\n     #[test]\n     fn file_test_io_smoke_test() {\n         let message = \"it's alright. have a good time\";\n@@ -1578,8 +1594,9 @@ mod tests {\n         if cfg!(unix) {\n             error!(result, \"o such file or directory\");\n         }\n-        // error!(result, \"couldn't open path as file\");\n-        // error!(result, format!(\"path={}; mode=open; access=read\", filename.display()));\n+        if cfg!(windows) {\n+            error!(result, \"The system cannot find the file specified\");\n+        }\n     }\n \n     #[test]\n@@ -1592,8 +1609,9 @@ mod tests {\n         if cfg!(unix) {\n             error!(result, \"o such file or directory\");\n         }\n-        // error!(result, \"couldn't unlink path\");\n-        // error!(result, format!(\"path={}\", filename.display()));\n+        if cfg!(windows) {\n+            error!(result, \"The system cannot find the file specified\");\n+        }\n     }\n \n     #[test]\n@@ -1799,6 +1817,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn file_test_walk_dir() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"walk_dir\");\n@@ -1855,19 +1874,13 @@ mod tests {\n         let result = fs::create_dir_all(&file);\n \n         assert!(result.is_err());\n-        // error!(result, \"couldn't recursively mkdir\");\n-        // error!(result, \"couldn't create directory\");\n-        // error!(result, \"mode=0700\");\n-        // error!(result, format!(\"path={}\", file.display()));\n     }\n \n     #[test]\n     fn recursive_mkdir_slash() {\n-        check!(fs::create_dir_all(&Path2::new(\"/\")));\n+        check!(fs::create_dir_all(&Path::new(\"/\")));\n     }\n \n-    // FIXME(#12795) depends on lstat to work on windows\n-    #[cfg(not(windows))]\n     #[test]\n     fn recursive_rmdir() {\n         let tmpdir = tmpdir();\n@@ -1879,7 +1892,7 @@ mod tests {\n         check!(fs::create_dir_all(&dtt));\n         check!(fs::create_dir_all(&d2));\n         check!(check!(File::create(&canary)).write(b\"foo\"));\n-        check!(fs::soft_link(&d2, &dt.join(\"d2\")));\n+        check!(symlink_junction(&d2, &dt.join(\"d2\")));\n         check!(fs::remove_dir_all(&d1));\n \n         assert!(!d1.is_dir());\n@@ -1888,8 +1901,8 @@ mod tests {\n \n     #[test]\n     fn unicode_path_is_dir() {\n-        assert!(Path2::new(\".\").is_dir());\n-        assert!(!Path2::new(\"test/stdtest/fs.rs\").is_dir());\n+        assert!(Path::new(\".\").is_dir());\n+        assert!(!Path::new(\"test/stdtest/fs.rs\").is_dir());\n \n         let tmpdir = tmpdir();\n \n@@ -1907,21 +1920,21 @@ mod tests {\n \n     #[test]\n     fn unicode_path_exists() {\n-        assert!(Path2::new(\".\").exists());\n-        assert!(!Path2::new(\"test/nonexistent-bogus-path\").exists());\n+        assert!(Path::new(\".\").exists());\n+        assert!(!Path::new(\"test/nonexistent-bogus-path\").exists());\n \n         let tmpdir = tmpdir();\n         let unicode = tmpdir.path();\n         let unicode = unicode.join(&format!(\"test-\uac01\u4e01\u30fc\u518d\u89c1\"));\n         check!(fs::create_dir(&unicode));\n         assert!(unicode.exists());\n-        assert!(!Path2::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());\n+        assert!(!Path::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());\n     }\n \n     #[test]\n     fn copy_file_does_not_exist() {\n-        let from = Path2::new(\"test/nonexistent-bogus-path\");\n-        let to = Path2::new(\"test/other-bogus-path\");\n+        let from = Path::new(\"test/nonexistent-bogus-path\");\n+        let to = Path::new(\"test/other-bogus-path\");\n \n         match fs::copy(&from, &to) {\n             Ok(..) => panic!(),\n@@ -1935,7 +1948,7 @@ mod tests {\n     #[test]\n     fn copy_src_does_not_exist() {\n         let tmpdir = tmpdir();\n-        let from = Path2::new(\"test/nonexistent-bogus-path\");\n+        let from = Path::new(\"test/nonexistent-bogus-path\");\n         let to = tmpdir.join(\"out.txt\");\n         check!(check!(File::create(&to)).write(b\"hello\"));\n         assert!(fs::copy(&from, &to).is_err());\n@@ -2026,34 +2039,35 @@ mod tests {\n         assert_eq!(v, b\"carrot\".to_vec());\n     }\n \n-    #[cfg(not(windows))] // FIXME(#10264) operation not permitted?\n     #[test]\n     fn symlinks_work() {\n         let tmpdir = tmpdir();\n+        if !got_symlink_permission(&tmpdir) { return };\n+\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n         check!(check!(File::create(&input)).write(\"foobar\".as_bytes()));\n-        check!(fs::soft_link(&input, &out));\n-        // if cfg!(not(windows)) {\n-        //     assert_eq!(check!(lstat(&out)).kind, FileType::Symlink);\n-        //     assert_eq!(check!(out.lstat()).kind, FileType::Symlink);\n-        // }\n+        check!(symlink_file(&input, &out));\n+        assert!(check!(out.symlink_metadata()).file_type().is_symlink());\n         assert_eq!(check!(fs::metadata(&out)).len(),\n                    check!(fs::metadata(&input)).len());\n         let mut v = Vec::new();\n         check!(check!(File::open(&out)).read_to_end(&mut v));\n         assert_eq!(v, b\"foobar\".to_vec());\n     }\n \n-    #[cfg(not(windows))] // apparently windows doesn't like symlinks\n     #[test]\n     fn symlink_noexist() {\n+        // Symlinks can point to things that don't exist\n         let tmpdir = tmpdir();\n-        // symlinks can point to things that don't exist\n-        check!(fs::soft_link(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\")));\n-        assert_eq!(check!(fs::read_link(&tmpdir.join(\"bar\"))),\n-                   tmpdir.join(\"foo\"));\n+        if !got_symlink_permission(&tmpdir) { return };\n+\n+        // Use a relative path for testing. Symlinks get normalized by Windows,\n+        // so we may not get the same path back for absolute paths\n+        check!(symlink_file(&\"foo\", &tmpdir.join(\"bar\")));\n+        assert_eq!(check!(fs::read_link(&tmpdir.join(\"bar\"))).to_str().unwrap(),\n+                   \"foo\");\n     }\n \n     #[test]\n@@ -2346,9 +2360,10 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg(not(windows))]\n     fn realpath_works() {\n         let tmpdir = tmpdir();\n+        if !got_symlink_permission(&tmpdir) { return };\n+\n         let tmpdir = fs::canonicalize(tmpdir.path()).unwrap();\n         let file = tmpdir.join(\"test\");\n         let dir = tmpdir.join(\"test2\");\n@@ -2357,8 +2372,8 @@ mod tests {\n \n         File::create(&file).unwrap();\n         fs::create_dir(&dir).unwrap();\n-        fs::soft_link(&file, &link).unwrap();\n-        fs::soft_link(&dir, &linkdir).unwrap();\n+        symlink_file(&file, &link).unwrap();\n+        symlink_dir(&dir, &linkdir).unwrap();\n \n         assert!(link.symlink_metadata().unwrap().file_type().is_symlink());\n \n@@ -2370,11 +2385,11 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg(not(windows))]\n     fn realpath_works_tricky() {\n         let tmpdir = tmpdir();\n-        let tmpdir = fs::canonicalize(tmpdir.path()).unwrap();\n+        if !got_symlink_permission(&tmpdir) { return };\n \n+        let tmpdir = fs::canonicalize(tmpdir.path()).unwrap();\n         let a = tmpdir.join(\"a\");\n         let b = a.join(\"b\");\n         let c = b.join(\"c\");\n@@ -2385,8 +2400,14 @@ mod tests {\n         fs::create_dir_all(&b).unwrap();\n         fs::create_dir_all(&d).unwrap();\n         File::create(&f).unwrap();\n-        fs::soft_link(\"../d/e\", &c).unwrap();\n-        fs::soft_link(\"../f\", &e).unwrap();\n+        if cfg!(not(windows)) {\n+            symlink_dir(\"../d/e\", &c).unwrap();\n+            symlink_file(\"../f\", &e).unwrap();\n+        }\n+        if cfg!(windows) {\n+            symlink_dir(r\"..\\d\\e\", &c).unwrap();\n+            symlink_file(r\"..\\f\", &e).unwrap();\n+        }\n \n         assert_eq!(fs::canonicalize(&c).unwrap(), f);\n         assert_eq!(fs::canonicalize(&e).unwrap(), f);\n@@ -2420,4 +2441,31 @@ mod tests {\n         let res = fs::read_dir(\"/path/that/does/not/exist\");\n         assert_eq!(res.err().unwrap().kind(), ErrorKind::NotFound);\n     }\n+\n+    #[test]\n+    fn create_dir_all_with_junctions() {\n+        let tmpdir = tmpdir();\n+        let target = tmpdir.join(\"target\");\n+\n+        let junction = tmpdir.join(\"junction\");\n+        let b = junction.join(\"a/b\");\n+\n+        let link = tmpdir.join(\"link\");\n+        let d = link.join(\"c/d\");\n+\n+        fs::create_dir(&target).unwrap();\n+\n+        check!(symlink_junction(&target, &junction));\n+        check!(fs::create_dir_all(&b));\n+        // the junction itself is not a directory, but `is_dir()` on a Path\n+        // follows links\n+        assert!(junction.is_dir());\n+        assert!(b.exists());\n+\n+        if !got_symlink_permission(&tmpdir) { return };\n+        check!(symlink_dir(&target, &link));\n+        check!(fs::create_dir_all(&d));\n+        assert!(link.is_dir());\n+        assert!(d.exists());\n+    }\n }"}, {"sha": "2527c6774ff6d27f93f2fc23d61d44f493bc6f13", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d0ef74026690cffccb543fc274d73a078eba797d/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ef74026690cffccb543fc274d73a078eba797d/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=d0ef74026690cffccb543fc274d73a078eba797d", "patch": "@@ -554,6 +554,18 @@ pub fn rmdir(p: &Path) -> io::Result<()> {\n     Ok(())\n }\n \n+pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n+    for child in try!(readdir(path)) {\n+        let child = try!(child);\n+        if try!(child.file_type()).is_dir() {\n+            try!(remove_dir_all(&child.path()));\n+        } else {\n+            try!(unlink(&child.path()));\n+        }\n+    }\n+    rmdir(path)\n+}\n+\n pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n     let c_path = try!(cstr(p));\n     let p = c_path.as_ptr();"}, {"sha": "8d921146653ee5e16fa275f9d6dd95452e55b612", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 75, "deletions": 126, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/d0ef74026690cffccb543fc274d73a078eba797d/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ef74026690cffccb543fc274d73a078eba797d/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=d0ef74026690cffccb543fc274d73a078eba797d", "patch": "@@ -35,7 +35,7 @@ pub struct FileAttr {\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub enum FileType {\n-    Dir, File, Symlink, ReparsePoint, MountPoint,\n+    Dir, File, SymlinkFile, SymlinkDir, ReparsePoint, MountPoint,\n }\n \n pub struct ReadDir {\n@@ -450,23 +450,30 @@ impl FilePermissions {\n \n impl FileType {\n     fn new(attrs: c::DWORD, reparse_tag: c::DWORD) -> FileType {\n-        if attrs & c::FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n-            match reparse_tag {\n-                c::IO_REPARSE_TAG_SYMLINK => FileType::Symlink,\n-                c::IO_REPARSE_TAG_MOUNT_POINT => FileType::MountPoint,\n-                _ => FileType::ReparsePoint,\n-            }\n-        } else if attrs & c::FILE_ATTRIBUTE_DIRECTORY != 0 {\n-            FileType::Dir\n-        } else {\n-            FileType::File\n+        match (attrs & c::FILE_ATTRIBUTE_DIRECTORY != 0,\n+               attrs & c::FILE_ATTRIBUTE_REPARSE_POINT != 0,\n+               reparse_tag) {\n+            (false, false, _) => FileType::File,\n+            (true, false, _) => FileType::Dir,\n+            (false, true, c::IO_REPARSE_TAG_SYMLINK) => FileType::SymlinkFile,\n+            (true, true, c::IO_REPARSE_TAG_SYMLINK) => FileType::SymlinkDir,\n+            (true, true, c::IO_REPARSE_TAG_MOUNT_POINT) => FileType::MountPoint,\n+            (_, true, _) => FileType::ReparsePoint,\n+            // Note: if a _file_ has a reparse tag of the type IO_REPARSE_TAG_MOUNT_POINT it is\n+            // invalid, as junctions always have to be dirs. We set the filetype to ReparsePoint\n+            // to indicate it is something symlink-like, but not something you can follow.\n         }\n     }\n \n     pub fn is_dir(&self) -> bool { *self == FileType::Dir }\n     pub fn is_file(&self) -> bool { *self == FileType::File }\n     pub fn is_symlink(&self) -> bool {\n-        *self == FileType::Symlink || *self == FileType::MountPoint\n+        *self == FileType::SymlinkFile ||\n+        *self == FileType::SymlinkDir ||\n+        *self == FileType::MountPoint\n+    }\n+    pub fn is_symlink_dir(&self) -> bool {\n+        *self == FileType::SymlinkDir || *self == FileType::MountPoint\n     }\n }\n \n@@ -523,6 +530,21 @@ pub fn rmdir(p: &Path) -> io::Result<()> {\n     Ok(())\n }\n \n+pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n+    for child in try!(readdir(path)) {\n+        let child = try!(child);\n+        let child_type = try!(child.file_type());\n+        if child_type.is_dir() {\n+            try!(remove_dir_all(&child.path()));\n+        } else if child_type.is_symlink_dir() {\n+            try!(rmdir(&child.path()));\n+        } else {\n+            try!(unlink(&child.path()));\n+        }\n+    }\n+    rmdir(path)\n+}\n+\n pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n     let file = try!(File::open_reparse_point(p, false));\n     file.readlink()\n@@ -641,124 +663,51 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     Ok(size as u64)\n }\n \n-#[test]\n-fn directory_junctions_are_directories() {\n-    use ffi::OsStr;\n-    use env;\n-    use rand::{self, Rng};\n-    use vec::Vec;\n-\n-    macro_rules! t {\n-        ($e:expr) => (match $e {\n-            Ok(e) => e,\n-            Err(e) => panic!(\"{} failed with: {}\", stringify!($e), e),\n-        })\n-    }\n+#[allow(dead_code)]\n+pub fn symlink_junction<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n+    symlink_junction_inner(src.as_ref(), dst.as_ref())\n+}\n \n+// Creating a directory junction on windows involves dealing with reparse\n+// points and the DeviceIoControl function, and this code is a skeleton of\n+// what can be found here:\n+//\n+// http://www.flexhex.com/docs/articles/hard-links.phtml\n+#[allow(dead_code)]\n+fn symlink_junction_inner(target: &Path, junction: &Path) -> io::Result<()> {\n     let d = DirBuilder::new();\n-    let p = env::temp_dir();\n-    let mut r = rand::thread_rng();\n-    let ret = p.join(&format!(\"rust-{}\", r.next_u32()));\n-    let foo = ret.join(\"foo\");\n-    let bar = ret.join(\"bar\");\n-    t!(d.mkdir(&ret));\n-    t!(d.mkdir(&foo));\n-    t!(d.mkdir(&bar));\n-\n-    t!(create_junction(&bar, &foo));\n-    let metadata = stat(&bar);\n-    t!(delete_junction(&bar));\n-\n-    t!(rmdir(&foo));\n-    t!(rmdir(&bar));\n-    t!(rmdir(&ret));\n-\n-    let metadata = t!(metadata);\n-    assert!(metadata.file_type().is_dir());\n-\n-    // Creating a directory junction on windows involves dealing with reparse\n-    // points and the DeviceIoControl function, and this code is a skeleton of\n-    // what can be found here:\n-    //\n-    // http://www.flexhex.com/docs/articles/hard-links.phtml\n-    fn create_junction(src: &Path, dst: &Path) -> io::Result<()> {\n-        let f = try!(opendir(src, true));\n-        let h = f.handle().raw();\n+    try!(d.mkdir(&junction));\n+    let f = try!(File::open_reparse_point(junction, true));\n+    let h = f.handle().raw();\n \n-        unsafe {\n-            let mut data = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n-            let mut db = data.as_mut_ptr()\n-                            as *mut c::REPARSE_MOUNTPOINT_DATA_BUFFER;\n-            let buf = &mut (*db).ReparseTarget as *mut _;\n-            let mut i = 0;\n-            let v = br\"\\??\\\";\n-            let v = v.iter().map(|x| *x as u16);\n-            for c in v.chain(dst.as_os_str().encode_wide()) {\n-                *buf.offset(i) = c;\n-                i += 1;\n-            }\n-            *buf.offset(i) = 0;\n+    unsafe {\n+        let mut data = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n+        let mut db = data.as_mut_ptr()\n+                        as *mut c::REPARSE_MOUNTPOINT_DATA_BUFFER;\n+        let buf = &mut (*db).ReparseTarget as *mut _;\n+        let mut i = 0;\n+        // FIXME: this conversion is very hacky\n+        let v = br\"\\??\\\";\n+        let v = v.iter().map(|x| *x as u16);\n+        for c in v.chain(target.as_os_str().encode_wide()) {\n+            *buf.offset(i) = c;\n             i += 1;\n-            (*db).ReparseTag = c::IO_REPARSE_TAG_MOUNT_POINT;\n-            (*db).ReparseTargetMaximumLength = (i * 2) as c::WORD;\n-            (*db).ReparseTargetLength = ((i - 1) * 2) as c::WORD;\n-            (*db).ReparseDataLength =\n-                    (*db).ReparseTargetLength as c::DWORD + 12;\n-\n-            let mut ret = 0;\n-            cvt(c::DeviceIoControl(h as *mut _,\n-                                   c::FSCTL_SET_REPARSE_POINT,\n-                                   data.as_ptr() as *mut _,\n-                                   (*db).ReparseDataLength + 8,\n-                                   ptr::null_mut(), 0,\n-                                   &mut ret,\n-                                   ptr::null_mut())).map(|_| ())\n-        }\n-    }\n-\n-    fn opendir(p: &Path, write: bool) -> io::Result<File> {\n-        unsafe {\n-            let mut token = ptr::null_mut();\n-            let mut tp: c::TOKEN_PRIVILEGES = mem::zeroed();\n-            try!(cvt(c::OpenProcessToken(c::GetCurrentProcess(),\n-                                         c::TOKEN_ADJUST_PRIVILEGES,\n-                                         &mut token)));\n-            let name: &OsStr = if write {\n-                \"SeRestorePrivilege\".as_ref()\n-            } else {\n-                \"SeBackupPrivilege\".as_ref()\n-            };\n-            let name = name.encode_wide().chain(Some(0)).collect::<Vec<_>>();\n-            try!(cvt(c::LookupPrivilegeValueW(ptr::null(),\n-                                              name.as_ptr(),\n-                                              &mut tp.Privileges[0].Luid)));\n-            tp.PrivilegeCount = 1;\n-            tp.Privileges[0].Attributes = c::SE_PRIVILEGE_ENABLED;\n-            let size = mem::size_of::<c::TOKEN_PRIVILEGES>() as c::DWORD;\n-            try!(cvt(c::AdjustTokenPrivileges(token, c::FALSE, &mut tp, size,\n-                                              ptr::null_mut(), ptr::null_mut())));\n-            try!(cvt(c::CloseHandle(token)));\n-\n-            File::open_reparse_point(p, write)\n-        }\n-    }\n-\n-    fn delete_junction(p: &Path) -> io::Result<()> {\n-        unsafe {\n-            let f = try!(opendir(p, true));\n-            let h = f.handle().raw();\n-            let mut data = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n-            let mut db = data.as_mut_ptr()\n-                            as *mut c::REPARSE_MOUNTPOINT_DATA_BUFFER;\n-            (*db).ReparseTag = c::IO_REPARSE_TAG_MOUNT_POINT;\n-            let mut bytes = 0;\n-            cvt(c::DeviceIoControl(h as *mut _,\n-                                   c::FSCTL_DELETE_REPARSE_POINT,\n-                                   data.as_ptr() as *mut _,\n-                                   (*db).ReparseDataLength + 8,\n-                                   ptr::null_mut(), 0,\n-                                   &mut bytes,\n-                                   ptr::null_mut())).map(|_| ())\n         }\n+        *buf.offset(i) = 0;\n+        i += 1;\n+        (*db).ReparseTag = c::IO_REPARSE_TAG_MOUNT_POINT;\n+        (*db).ReparseTargetMaximumLength = (i * 2) as c::WORD;\n+        (*db).ReparseTargetLength = ((i - 1) * 2) as c::WORD;\n+        (*db).ReparseDataLength =\n+                (*db).ReparseTargetLength as c::DWORD + 12;\n+\n+        let mut ret = 0;\n+        cvt(c::DeviceIoControl(h as *mut _,\n+                               c::FSCTL_SET_REPARSE_POINT,\n+                               data.as_ptr() as *mut _,\n+                               (*db).ReparseDataLength + 8,\n+                               ptr::null_mut(), 0,\n+                               &mut ret,\n+                               ptr::null_mut())).map(|_| ())\n     }\n }"}]}