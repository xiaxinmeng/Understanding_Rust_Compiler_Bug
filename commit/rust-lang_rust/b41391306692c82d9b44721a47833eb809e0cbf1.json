{"sha": "b41391306692c82d9b44721a47833eb809e0cbf1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0MTM5MTMwNjY5MmM4MmQ5YjQ0NzIxYTQ3ODMzZWI4MDllMGNiZjE=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-08-26T02:18:32Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-10-16T03:10:10Z"}, "message": "path2: Start reimplementing in terms of ~[u8] instead of ~str\n\nAs documented in #7225, we cannot rely on paths being representable in\nutf-8. Specifically, Linux allows anything (besides NUL) in a path.\nRedesign GenericPath in light of this.\n\nPosixPath hasn't been reimplemented yet for ~[u8].", "tree": {"sha": "9037866337af058ed5dc7e7a62be72ac898e623e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9037866337af058ed5dc7e7a62be72ac898e623e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b41391306692c82d9b44721a47833eb809e0cbf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b41391306692c82d9b44721a47833eb809e0cbf1", "html_url": "https://github.com/rust-lang/rust/commit/b41391306692c82d9b44721a47833eb809e0cbf1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b41391306692c82d9b44721a47833eb809e0cbf1/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e97d61672b3f31e4d54589bed20286aca02bf42b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e97d61672b3f31e4d54589bed20286aca02bf42b", "html_url": "https://github.com/rust-lang/rust/commit/e97d61672b3f31e4d54589bed20286aca02bf42b"}], "stats": {"total": 445, "additions": 357, "deletions": 88}, "files": [{"sha": "45ce6e94ae4aa670b024233aea77876e659d4ad9", "filename": "src/libstd/path2.rs", "status": "modified", "additions": 357, "deletions": 88, "changes": 445, "blob_url": "https://github.com/rust-lang/rust/blob/b41391306692c82d9b44721a47833eb809e0cbf1/src%2Flibstd%2Fpath2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b41391306692c82d9b44721a47833eb809e0cbf1/src%2Flibstd%2Fpath2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath2.rs?ref=b41391306692c82d9b44721a47833eb809e0cbf1", "patch": "@@ -19,8 +19,8 @@ use iterator::{AdditiveIterator, Extendable, Iterator};\n use option::{Option, None, Some};\n use str;\n use str::{OwnedStr, Str, StrSlice, StrVector};\n-use to_str::ToStr;\n use util;\n+use vec;\n use vec::{ImmutableVector, OwnedVector};\n \n /// Typedef for the platform-native path type\n@@ -40,10 +40,16 @@ pub type ComponentIter<'self> = PosixComponentIter<'self>;\n /// Iterator that yields successive components of a PosixPath\n type PosixComponentIter<'self> = str::CharSplitIterator<'self, char>;\n \n+// Condition that is raised when a NUL is found in a byte vector given to a Path function\n+condition! {\n+    // this should be a &[u8] but there's a lifetime issue\n+    null_byte: ~[u8] -> ~[u8];\n+}\n+\n /// Represents a POSIX file path\n #[deriving(Clone, DeepClone)]\n pub struct PosixPath {\n-    priv repr: ~str, // assumed to never be empty\n+    priv repr: ~[u8], // assumed to never be empty or contain NULs\n     priv sepidx: Option<uint> // index of the final separator in repr\n }\n \n@@ -55,185 +61,426 @@ impl Eq for PosixPath {\n \n impl FromStr for PosixPath {\n     fn from_str(s: &str) -> Option<PosixPath> {\n-        Some(PosixPath::new(s))\n+        let v = s.as_bytes();\n+        if contains_nul(v) {\n+            None\n+        } else {\n+            Some(unsafe { GenericPathUnsafe::from_vec_unchecked(v) })\n+        }\n     }\n }\n \n /// A trait that represents the generic operations available on paths\n-pub trait GenericPath: Clone {\n+pub trait GenericPath: Clone + GenericPathUnsafe {\n+    /// Creates a new Path from a byte vector.\n+    /// The resulting Path will always be normalized.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the path contains a NUL.\n+    #[inline]\n+    fn from_vec(path: &[u8]) -> Self {\n+        if contains_nul(path) {\n+            let path = self::null_byte::cond.raise(path.to_owned());\n+            assert!(!contains_nul(path));\n+            unsafe { GenericPathUnsafe::from_vec_unchecked(path) }\n+        } else {\n+            unsafe { GenericPathUnsafe::from_vec_unchecked(path) }\n+        }\n+    }\n+\n     /// Creates a new Path from a string.\n-    /// The resulting path will always be normalized.\n-    fn from_str(path: &str) -> Self;\n-\n-    /// Returns the path as a string\n-    fn as_str<'a>(&'a self) -> &'a str;\n-\n-    /// Returns the directory component of `self`, as a string (with no trailing separator).\n-    /// If `self` has no directory component, returns \".\".\n-    fn dirname<'a>(&'a self) -> &'a str;\n-    /// Returns the file component of `self`, as a string.\n-    /// If `self` represents the root of the file hierarchy, returns the empty string.\n-    /// If `self` is \".\", returns the empty string.\n-    fn filename<'a>(&'a self) -> &'a str;\n-    /// Returns the stem of the filename of `self`, as a string.\n+    /// The resulting Path will always be normalized.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the path contains a NUL.\n+    #[inline]\n+    fn from_str(path: &str) -> Self {\n+        GenericPath::from_vec(path.as_bytes())\n+    }\n+\n+    /// Creates a new Path from a CString.\n+    /// The resulting Path will always be normalized.\n+    #[inline]\n+    fn from_c_str(path: CString) -> Self {\n+        // CStrings can't contain NULs\n+        unsafe { GenericPathUnsafe::from_vec_unchecked(path.as_bytes()) }\n+    }\n+\n+    /// Returns the path as a string, if possible.\n+    /// If the path is not representable in utf-8, this returns None.\n+    #[inline]\n+    fn as_str<'a>(&'a self) -> Option<&'a str> {\n+        str::from_bytes_slice_opt(self.as_vec())\n+    }\n+\n+    /// Returns the path as a byte vector\n+    fn as_vec<'a>(&'a self) -> &'a [u8];\n+\n+    /// Returns the directory component of `self`, as a byte vector (with no trailing separator).\n+    /// If `self` has no directory component, returns ['.'].\n+    fn dirname<'a>(&'a self) -> &'a [u8];\n+    /// Returns the directory component of `self`, as a string, if possible.\n+    /// See `dirname` for details.\n+    #[inline]\n+    fn dirname_str<'a>(&'a self) -> Option<&'a str> {\n+        str::from_bytes_slice_opt(self.dirname())\n+    }\n+    /// Returns the file component of `self`, as a byte vector.\n+    /// If `self` represents the root of the file hierarchy, returns the empty vector.\n+    /// If `self` is \".\", returns the empty vector.\n+    fn filename<'a>(&'a self) -> &'a [u8];\n+    /// Returns the file component of `self`, as a string, if possible.\n+    /// See `filename` for details.\n+    #[inline]\n+    fn filename_str<'a>(&'a self) -> Option<&'a str> {\n+        str::from_bytes_slice_opt(self.filename())\n+    }\n+    /// Returns the stem of the filename of `self`, as a byte vector.\n     /// The stem is the portion of the filename just before the last '.'.\n     /// If there is no '.', the entire filename is returned.\n-    fn filestem<'a>(&'a self) -> &'a str {\n+    fn filestem<'a>(&'a self) -> &'a [u8] {\n         let name = self.filename();\n-        match name.rfind('.') {\n+        let dot = '.' as u8;\n+        match name.rposition_elem(&dot) {\n             None | Some(0) => name,\n-            Some(1) if name == \"..\" => name,\n+            Some(1) if name == bytes!(\"..\") => name,\n             Some(pos) => name.slice_to(pos)\n         }\n     }\n-    /// Returns the extension of the filename of `self`, as a string option.\n+    /// Returns the stem of the filename of `self`, as a string, if possible.\n+    /// See `filestem` for details.\n+    #[inline]\n+    fn filestem_str<'a>(&'a self) -> Option<&'a str> {\n+        str::from_bytes_slice_opt(self.filestem())\n+    }\n+    /// Returns the extension of the filename of `self`, as an optional byte vector.\n     /// The extension is the portion of the filename just after the last '.'.\n     /// If there is no extension, None is returned.\n-    /// If the filename ends in '.', the empty string is returned.\n-    fn extension<'a>(&'a self) -> Option<&'a str> {\n+    /// If the filename ends in '.', the empty vector is returned.\n+    fn extension<'a>(&'a self) -> Option<&'a [u8]> {\n         let name = self.filename();\n-        match name.rfind('.') {\n+        let dot = '.' as u8;\n+        match name.rposition_elem(&dot) {\n             None | Some(0) => None,\n-            Some(1) if name == \"..\" => None,\n+            Some(1) if name == bytes!(\"..\") => None,\n             Some(pos) => Some(name.slice_from(pos+1))\n         }\n     }\n+    /// Returns the extension of the filename of `self`, as a string, if possible.\n+    /// See `extension` for details.\n+    #[inline]\n+    fn extension_str<'a>(&'a self) -> Option<&'a str> {\n+        self.extension().chain(|v| str::from_bytes_slice_opt(v))\n+    }\n \n-    /// Replaces the directory portion of the path with the given string.\n+    /// Replaces the directory portion of the path with the given byte vector.\n     /// If `self` represents the root of the filesystem hierarchy, the last path component\n-    /// of the given string becomes the filename.\n-    fn set_dirname(&mut self, dirname: &str);\n+    /// of the given byte vector becomes the filename.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the dirname contains a NUL.\n+    #[inline]\n+    fn set_dirname(&mut self, dirname: &[u8]) {\n+        if contains_nul(dirname) {\n+            let dirname = self::null_byte::cond.raise(dirname.to_owned());\n+            assert!(!contains_nul(dirname));\n+            unsafe { self.set_dirname_unchecked(dirname) }\n+        } else {\n+            unsafe { self.set_dirname_unchecked(dirname) }\n+        }\n+    }\n+    /// Replaces the directory portion of the path with the given string.\n+    /// See `set_dirname` for details.\n+    #[inline]\n+    fn set_dirname_str(&mut self, dirname: &str) {\n+        self.set_dirname(dirname.as_bytes())\n+    }\n+    /// Replaces the filename portion of the path with the given byte vector.\n+    /// If the replacement name is [], this is equivalent to popping the path.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the filename contains a NUL.\n+    #[inline]\n+    fn set_filename(&mut self, filename: &[u8]) {\n+        if contains_nul(filename) {\n+            let filename = self::null_byte::cond.raise(filename.to_owned());\n+            assert!(!contains_nul(filename));\n+            unsafe { self.set_filename_unchecked(filename) }\n+        } else {\n+            unsafe { self.set_filename_unchecked(filename) }\n+        }\n+    }\n     /// Replaces the filename portion of the path with the given string.\n-    /// If the replacement name is \"\", this is equivalent to popping the path.\n-    fn set_filename(&mut self, filename: &str);\n-    /// Replaces the filestem with the given string.\n+    /// See `set_filename` for details.\n+    #[inline]\n+    fn set_filename_str(&mut self, filename: &str) {\n+        self.set_filename(filename.as_bytes())\n+    }\n+    /// Replaces the filestem with the given byte vector.\n     /// If there is no extension in `self` (or `self` has no filename), this is equivalent\n-    /// to `set_filename`. Otherwise, if the given string is \"\", the extension (including\n-    /// the preceding \".\") becomes the new filename.\n-    fn set_filestem(&mut self, filestem: &str) {\n+    /// to `set_filename`. Otherwise, if the given byte vector is [], the extension (including\n+    /// the preceding '.') becomes the new filename.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the filestem contains a NUL.\n+    fn set_filestem(&mut self, filestem: &[u8]) {\n         // borrowck is being a pain here\n         let val = {\n             let name = self.filename();\n             if !name.is_empty() {\n-                match name.rfind('.') {\n+                let dot = '.' as u8;\n+                match name.rposition_elem(&dot) {\n                     None | Some(0) => None,\n                     Some(idx) => {\n-                        let mut s = str::with_capacity(filestem.len() + name.len() - idx);\n-                        s.push_str(filestem);\n-                        s.push_str(name.slice_from(idx));\n-                        Some(s)\n+                        let mut v;\n+                        if contains_nul(filestem) {\n+                            let filestem = self::null_byte::cond.raise(filestem.to_owned());\n+                            assert!(!contains_nul(filestem));\n+                            v = vec::with_capacity(filestem.len() + name.len() - idx);\n+                            v.push_all(filestem);\n+                        } else {\n+                            v = vec::with_capacity(filestem.len() + name.len() - idx);\n+                            v.push_all(filestem);\n+                        }\n+                        v.push_all(name.slice_from(idx));\n+                        Some(v)\n                     }\n                 }\n             } else { None }\n         };\n         match val {\n             None => self.set_filename(filestem),\n-            Some(s) => self.set_filename(s)\n+            Some(v) => unsafe { self.set_filename_unchecked(v) }\n         }\n     }\n-    /// Replaces the extension with the given string.\n+    /// Replaces the filestem with the given string.\n+    /// See `set_filestem` for details.\n+    #[inline]\n+    fn set_filestem_str(&mut self, filestem: &str) {\n+        self.set_filestem(filestem.as_bytes())\n+    }\n+    /// Replaces the extension with the given byte vector.\n     /// If there is no extension in `self`, this adds one.\n-    /// If the given string is \"\", this removes the extension.\n+    /// If the given byte vector is [], this removes the extension.\n     /// If `self` has no filename, this is a no-op.\n-    fn set_extension(&mut self, extension: &str) {\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the extension contains a NUL.\n+    fn set_extension(&mut self, extension: &[u8]) {\n         // borrowck causes problems here too\n         let val = {\n             let name = self.filename();\n             if !name.is_empty() {\n-                match name.rfind('.') {\n+                let dot = '.' as u8;\n+                match name.rposition_elem(&dot) {\n                     None | Some(0) => {\n                         if extension.is_empty() {\n                             None\n                         } else {\n-                            let mut s = str::with_capacity(name.len() + extension.len() + 1);\n-                            s.push_str(name);\n-                            s.push_char('.');\n-                            s.push_str(extension);\n-                            Some(s)\n+                            let mut v;\n+                            if contains_nul(extension) {\n+                                let extension = self::null_byte::cond.raise(extension.to_owned());\n+                                assert!(!contains_nul(extension));\n+                                v = vec::with_capacity(name.len() + extension.len() + 1);\n+                                v.push_all(name);\n+                                v.push(dot);\n+                                v.push_all(extension);\n+                            } else {\n+                                v = vec::with_capacity(name.len() + extension.len() + 1);\n+                                v.push_all(name);\n+                                v.push(dot);\n+                                v.push_all(extension);\n+                            }\n+                            Some(v)\n                         }\n                     }\n                     Some(idx) => {\n                         if extension.is_empty() {\n                             Some(name.slice_to(idx).to_owned())\n                         } else {\n-                            let mut s = str::with_capacity(idx + extension.len() + 1);\n-                            s.push_str(name.slice_to(idx+1));\n-                            s.push_str(extension);\n-                            Some(s)\n+                            let mut v;\n+                            if contains_nul(extension) {\n+                                let extension = self::null_byte::cond.raise(extension.to_owned());\n+                                assert!(!contains_nul(extension));\n+                                v = vec::with_capacity(idx + extension.len() + 1);\n+                                v.push_all(name.slice_to(idx+1));\n+                                v.push_all(extension);\n+                            } else {\n+                                v = vec::with_capacity(idx + extension.len() + 1);\n+                                v.push_all(name.slice_to(idx+1));\n+                                v.push_all(extension);\n+                            }\n+                            Some(v)\n                         }\n                     }\n                 }\n             } else { None }\n         };\n         match val {\n             None => (),\n-            Some(s) => self.set_filename(s)\n+            Some(v) => unsafe { self.set_filename_unchecked(v) }\n         }\n     }\n+    /// Replaces the extension with the given string.\n+    /// See `set_extension` for details.\n+    #[inline]\n+    fn set_extension_str(&mut self, extension: &str) {\n+        self.set_extension(extension.as_bytes())\n+    }\n \n-    /// Returns a new Path constructed by replacing the dirname with the given string.\n+    /// Returns a new Path constructed by replacing the dirname with the given byte vector.\n     /// See `set_dirname` for details.\n-    fn with_dirname(&self, dirname: &str) -> Self {\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the dirname contains a NUL.\n+    #[inline]\n+    fn with_dirname(&self, dirname: &[u8]) -> Self {\n         let mut p = self.clone();\n         p.set_dirname(dirname);\n         p\n     }\n-    /// Returns a new Path constructed by replacing the filename with the given string.\n+    /// Returns a new Path constructed by replacing the dirname with the given string.\n+    /// See `set_dirname` for details.\n+    #[inline]\n+    fn with_dirname_str(&self, dirname: &str) -> Self {\n+        self.with_dirname(dirname.as_bytes())\n+    }\n+    /// Returns a new Path constructed by replacing the filename with the given byte vector.\n     /// See `set_filename` for details.\n-    fn with_filename(&self, filename: &str) -> Self {\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the filename contains a NUL.\n+    #[inline]\n+    fn with_filename(&self, filename: &[u8]) -> Self {\n         let mut p = self.clone();\n         p.set_filename(filename);\n         p\n     }\n-    /// Returns a new Path constructed by setting the filestem to the given string.\n+    /// Returns a new Path constructed by replacing the filename with the given string.\n+    /// See `set_filename` for details.\n+    #[inline]\n+    fn with_filename_str(&self, filename: &str) -> Self {\n+        self.with_filename(filename.as_bytes())\n+    }\n+    /// Returns a new Path constructed by setting the filestem to the given byte vector.\n     /// See `set_filestem` for details.\n-    fn with_filestem(&self, filestem: &str) -> Self {\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the filestem contains a NUL.\n+    #[inline]\n+    fn with_filestem(&self, filestem: &[u8]) -> Self {\n         let mut p = self.clone();\n         p.set_filestem(filestem);\n         p\n     }\n-    /// Returns a new Path constructed by setting the extension to the given string.\n+    /// Returns a new Path constructed by setting the filestem to the given string.\n+    /// See `set_filestem` for details.\n+    #[inline]\n+    fn with_filestem_str(&self, filestem: &str) -> Self {\n+        self.with_filestem(filestem.as_bytes())\n+    }\n+    /// Returns a new Path constructed by setting the extension to the given byte vector.\n     /// See `set_extension` for details.\n-    fn with_extension(&self, extension: &str) -> Self {\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the extension contains a NUL.\n+    #[inline]\n+    fn with_extension(&self, extension: &[u8]) -> Self {\n         let mut p = self.clone();\n         p.set_extension(extension);\n         p\n     }\n-\n+    /// Returns a new Path constructed by setting the extension to the given string.\n+    /// See `set_extension` for details.\n+    #[inline]\n+    fn with_extension_str(&self, extension: &str) -> Self {\n+        self.with_extension(extension.as_bytes())\n+    }\n \n     /// Returns the directory component of `self`, as a Path.\n     /// If `self` represents the root of the filesystem hierarchy, returns `self`.\n     fn dir_path(&self) -> Self {\n-        GenericPath::from_str(self.dirname())\n+        GenericPath::from_vec(self.dirname())\n     }\n     /// Returns the file component of `self`, as a relative Path.\n     /// If `self` represents the root of the filesystem hierarchy, returns None.\n     fn file_path(&self) -> Option<Self> {\n         match self.filename() {\n-            \"\" => None,\n-            s => Some(GenericPath::from_str(s))\n+            [] => None,\n+            v => Some(GenericPath::from_vec(v))\n         }\n     }\n \n-    /// Pushes a path (as a string) onto `self`.\n+    /// Pushes a path (as a byte vector) onto `self`.\n     /// If the argument represents an absolute path, it replaces `self`.\n-    fn push(&mut self, path: &str);\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the path contains a NUL.\n+    #[inline]\n+    fn push(&mut self, path: &[u8]) {\n+        if contains_nul(path) {\n+            let path = self::null_byte::cond.raise(path.to_owned());\n+            assert!(!contains_nul(path));\n+            unsafe { self.push_unchecked(path) }\n+        } else {\n+            unsafe { self.push_unchecked(path) }\n+        }\n+    }\n+    /// Pushes a path (as a string) onto `self.\n+    /// See `push` for details.\n+    #[inline]\n+    fn push_str(&mut self, path: &str) {\n+        self.push(path.as_bytes())\n+    }\n     /// Pushes a Path onto `self`.\n     /// If the argument represents an absolute path, it replaces `self`.\n-    fn push_path(&mut self, path: &Self);\n+    #[inline]\n+    fn push_path(&mut self, path: &Self) {\n+        self.push(path.as_vec())\n+    }\n     /// Pops the last path component off of `self` and returns it.\n     /// If `self` represents the root of the file hierarchy, None is returned.\n-    fn pop_opt(&mut self) -> Option<~str>;\n+    fn pop_opt(&mut self) -> Option<~[u8]>;\n+    /// Pops the last path component off of `self` and returns it as a string, if possible.\n+    /// `self` will still be modified even if None is returned.\n+    /// See `pop_opt` for details.\n+    #[inline]\n+    fn pop_opt_str(&mut self) -> Option<~str> {\n+        self.pop_opt().chain(|v| str::from_bytes_owned_opt(v))\n+    }\n \n-    /// Returns a new Path constructed by joining `self` with the given path (as a string).\n+    /// Returns a new Path constructed by joining `self` with the given path (as a byte vector).\n     /// If the given path is absolute, the new Path will represent just that.\n-    fn join(&self, path: &str) -> Self {\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the path contains a NUL.\n+    #[inline]\n+    fn join(&self, path: &[u8]) -> Self {\n         let mut p = self.clone();\n         p.push(path);\n         p\n     }\n+    /// Returns a new Path constructed by joining `self` with the given path (as a string).\n+    /// See `join` for details.\n+    #[inline]\n+    fn join_str(&self, path: &str) -> Self {\n+        self.join(path.as_bytes())\n+    }\n     /// Returns a new Path constructed by joining `self` with the given path.\n     /// If the given path is absolute, the new Path will represent just that.\n+    #[inline]\n     fn join_path(&self, path: &Self) -> Self {\n         let mut p = self.clone();\n         p.push_path(path);\n@@ -255,22 +502,42 @@ pub trait GenericPath: Clone {\n     fn path_relative_from(&self, base: &Self) -> Option<Self>;\n }\n \n-impl ToStr for PosixPath {\n-    #[inline]\n-    fn to_str(&self) -> ~str {\n-        self.as_str().to_owned()\n-    }\n+/// A trait that represents the unsafe operations on GenericPaths\n+pub trait GenericPathUnsafe {\n+    /// Creates a new Path from a byte vector without checking for null bytes.\n+    /// The resulting Path will always be normalized.\n+    unsafe fn from_vec_unchecked(path: &[u8]) -> Self;\n+\n+    /// Replaces the directory portion of the path with the given byte vector without\n+    /// checking for null bytes.\n+    /// See `set_dirname` for details.\n+    unsafe fn set_dirname_unchecked(&mut self, dirname: &[u8]);\n+\n+    /// Replaces the filename portion of the path with the given byte vector without\n+    /// checking for null bytes.\n+    /// See `set_filename` for details.\n+    unsafe fn set_filename_unchecked(&mut self, filename: &[u8]);\n+\n+    /// Pushes a path onto `self` without checking for null bytes.\n+    /// See `push` for details.\n+    unsafe fn push_unchecked(&mut self, path: &[u8]);\n+}\n+\n+#[inline(always)]\n+fn contains_nul(v: &[u8]) -> bool {\n+    v.iter().any(|&x| x == 0)\n }\n \n impl ToCStr for PosixPath {\n     #[inline]\n     fn to_c_str(&self) -> CString {\n-        self.as_str().to_c_str()\n+        // The Path impl guarantees no internal NUL\n+        unsafe { self.as_vec().to_c_str_unchecked() }\n     }\n \n     #[inline]\n     unsafe fn to_c_str_unchecked(&self) -> CString {\n-        self.as_str().to_c_str_unchecked()\n+        self.as_vec().to_c_str_unchecked()\n     }\n }\n \n@@ -583,24 +850,26 @@ fn normalize_helper<'a, Sep: str::CharEq>(s: &'a str, is_abs: bool, sep: Sep) ->\n /// Various POSIX helpers\n pub mod posix {\n     /// The standard path separator character\n-    pub static sep: char = '/';\n+    pub static sep: u8 = '/' as u8;\n \n-    /// Returns whether the given char is a path separator\n+    /// Returns whether the given byte is a path separator\n     #[inline]\n-    pub fn is_sep(u: char) -> bool {\n-        u == sep\n+    pub fn is_sep(u: &u8) -> bool {\n+        *u == sep\n     }\n }\n \n /// Various Windows helpers\n pub mod windows {\n     /// The standard path separator character\n-    pub static sep: char = '\\\\';\n+    pub static sep: u8 = '\\\\' as u8;\n+    /// The alternative path separator character\n+    pub static sep2: u8 = '/' as u8;\n \n-    /// Returns whether the given char is a path separator (both / and \\)\n+    /// Returns whether the given byte is a path separator\n     #[inline]\n-    pub fn is_sep(u: char) -> bool {\n-        u == sep || u == '/'\n+    pub fn is_sep(u: &u8) -> bool {\n+        *u == sep || *u == sep2\n     }\n }\n "}]}