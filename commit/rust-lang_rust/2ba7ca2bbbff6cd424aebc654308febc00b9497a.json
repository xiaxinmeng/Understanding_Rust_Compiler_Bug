{"sha": "2ba7ca2bbbff6cd424aebc654308febc00b9497a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiYTdjYTJiYmJmZjZjZDQyNGFlYmM2NTQzMDhmZWJjMDBiOTQ5N2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-16T12:51:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-16T12:51:42Z"}, "message": "Auto merge of #77117 - davidtwco:issue-34651-split-dwarf, r=nagisa\n\ncg_llvm: split dwarf support\n\ncc #34651\n\nThis PR adds initial support for Split DWARF to rustc, based on the implementation in Clang.\n\n##### Current Status\nThis PR currently has functioning split-dwarf, running rustc with `-Zsplit-dwarf=split` when compiling a binary will produce a `dwp` alongside the binary, which contains the linked dwarf objects.\n\n```shell-session\n$ rustc -Cdebuginfo=2 -Zsplit-dwarf=split -C save-temps ./foo.rs\n$ ls foo*\nfoo\nfoo.belfx9afw9cmv8.rcgu.dwo\nfoo.belfx9afw9cmv8.rcgu.o\nfoo.foo.7rcbfp3g-cgu.0.rcgu.dwo\nfoo.foo.7rcbfp3g-cgu.0.rcgu.o\nfoo.foo.7rcbfp3g-cgu.1.rcgu.dwo\nfoo.foo.7rcbfp3g-cgu.1.rcgu.o\nfoo.foo.7rcbfp3g-cgu.2.rcgu.dwo\nfoo.foo.7rcbfp3g-cgu.2.rcgu.o\nfoo.foo.7rcbfp3g-cgu.3.rcgu.dwo\nfoo.foo.7rcbfp3g-cgu.3.rcgu.o\nfoo.foo.7rcbfp3g-cgu.4.rcgu.dwo\nfoo.foo.7rcbfp3g-cgu.4.rcgu.o\nfoo.foo.7rcbfp3g-cgu.5.rcgu.dwo\nfoo.foo.7rcbfp3g-cgu.5.rcgu.o\nfoo.foo.7rcbfp3g-cgu.6.rcgu.dwo\nfoo.foo.7rcbfp3g-cgu.6.rcgu.o\nfoo.foo.7rcbfp3g-cgu.7.rcgu.dwo\nfoo.foo.7rcbfp3g-cgu.7.rcgu.o\nfoo.dwp\nfoo.rs\n$ readelf -wi foo.foo.7rcbfp3g-cgu.0.rcgu.o\n# ...\n  Compilation Unit @ offset 0x90:\n   Length:        0x2c (32-bit)\n   Version:       4\n   Abbrev Offset: 0x5b\n   Pointer Size:  8\n <0><9b>: Abbrev Number: 1 (DW_TAG_compile_unit)\n    <9c>   DW_AT_stmt_list   : 0xe8\n    <a0>   DW_AT_comp_dir    : (indirect string, offset: 0x13b): /home/david/Projects/rust/rust0\n    <a4>   DW_AT_GNU_dwo_name: (indirect string, offset: 0x15b): foo.foo.7rcbfp3g-cgu.0.rcgu.dwo\n    <a8>   DW_AT_GNU_dwo_id  : 0x357472a2b032d7b9\n    <b0>   DW_AT_low_pc      : 0x0\n    <b8>   DW_AT_ranges      : 0x40\n    <bc>   DW_AT_GNU_addr_base: 0x0\n# ...\n```\n\n##### To-Do\nI've opened this PR as a draft to get feedback and work out how we'd expect rustc to work when Split DWARF is requested. It might be easier to read the PR commit-by-commit.\n\n- [ ] Add error when Split DWARF is requested on platforms where it doesn't make sense.\n- [x] Determine whether or not there should be a single `dwo` output from rustc, or one per codegen-unit as exists currently.\n- [x] Add tests.\n- [x] Fix `single` mode - currently single mode doesn't change the invocation of `addPassesToEmitFile`, which is correct, but it also needs to change the split dwarf path provided to `createCompileUnit` and `createTargetMachine` so that it's just the final binary (currently it is still a non-existent `dwo` file).\n\nr? `@nagisa`\ncc `@michaelwoerister` `@eddyb` `@alexcrichton` `@rust-lang/wg-incr-comp`", "tree": {"sha": "231959b03519aadce7c2e68becd08d620cad790e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/231959b03519aadce7c2e68becd08d620cad790e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ba7ca2bbbff6cd424aebc654308febc00b9497a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ba7ca2bbbff6cd424aebc654308febc00b9497a", "html_url": "https://github.com/rust-lang/rust/commit/2ba7ca2bbbff6cd424aebc654308febc00b9497a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ba7ca2bbbff6cd424aebc654308febc00b9497a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "268cbfeb88b4c13425d47910d3424c85b4c96462", "url": "https://api.github.com/repos/rust-lang/rust/commits/268cbfeb88b4c13425d47910d3424c85b4c96462", "html_url": "https://github.com/rust-lang/rust/commit/268cbfeb88b4c13425d47910d3424c85b4c96462"}, {"sha": "ee073b5ec54a13b393071298acc54e1fd28cfcdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee073b5ec54a13b393071298acc54e1fd28cfcdf", "html_url": "https://github.com/rust-lang/rust/commit/ee073b5ec54a13b393071298acc54e1fd28cfcdf"}], "stats": {"total": 558, "additions": 431, "deletions": 127}, "files": [{"sha": "78d6ff0cb001c404f085d12c018f04cf5fcd3775", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=2ba7ca2bbbff6cd424aebc654308febc00b9497a", "patch": "@@ -75,6 +75,7 @@ fn emit_module(\n             name,\n             kind,\n             object: Some(tmp_file),\n+            dwarf_object: None,\n             bytecode: None,\n         },\n         work_product,\n@@ -111,6 +112,7 @@ fn reuse_workproduct_for_cgu(\n         name: cgu.name().to_string(),\n         kind: ModuleKind::Regular,\n         object,\n+        dwarf_object: None,\n         bytecode: None,\n     }\n }\n@@ -290,6 +292,7 @@ pub(super) fn run_aot(\n             name: metadata_cgu_name,\n             kind: ModuleKind::Metadata,\n             object: Some(tmp_file),\n+            dwarf_object: None,\n             bytecode: None,\n         })\n     } else {"}, {"sha": "29415973ed0739a7d1cc43d4e44e7b07255453f2", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=2ba7ca2bbbff6cd424aebc654308febc00b9497a", "patch": "@@ -6,7 +6,9 @@ use crate::llvm::{self, build_string, False, True};\n use crate::{LlvmCodegenBackend, ModuleLlvm};\n use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule, ThinShared};\n use rustc_codegen_ssa::back::symbol_export;\n-use rustc_codegen_ssa::back::write::{CodegenContext, FatLTOInput, ModuleConfig};\n+use rustc_codegen_ssa::back::write::{\n+    CodegenContext, FatLTOInput, ModuleConfig, TargetMachineFactoryConfig,\n+};\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::{looks_like_rust_object_file, ModuleCodegen, ModuleKind};\n use rustc_data_structures::fx::FxHashMap;\n@@ -728,20 +730,23 @@ pub unsafe fn optimize_thin_module(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n ) -> Result<ModuleCodegen<ModuleLlvm>, FatalError> {\n     let diag_handler = cgcx.create_diag_handler();\n-    let tm = (cgcx.tm_factory.0)().map_err(|e| write::llvm_err(&diag_handler, &e))?;\n+\n+    let module_name = &thin_module.shared.module_names[thin_module.idx];\n+    let split_dwarf_file = cgcx\n+        .output_filenames\n+        .split_dwarf_filename(cgcx.split_dwarf_kind, Some(module_name.to_str().unwrap()));\n+    let tm_factory_config = TargetMachineFactoryConfig { split_dwarf_file };\n+    let tm =\n+        (cgcx.tm_factory)(tm_factory_config).map_err(|e| write::llvm_err(&diag_handler, &e))?;\n \n     // Right now the implementation we've got only works over serialized\n     // modules, so we create a fresh new LLVM context and parse the module\n     // into that context. One day, however, we may do this for upstream\n     // crates but for locally codegened modules we may be able to reuse\n     // that LLVM Context and Module.\n     let llcx = llvm::LLVMRustContextCreate(cgcx.fewer_names);\n-    let llmod_raw = parse_module(\n-        llcx,\n-        &thin_module.shared.module_names[thin_module.idx],\n-        thin_module.data(),\n-        &diag_handler,\n-    )? as *const _;\n+    let llmod_raw =\n+        parse_module(llcx, &module_name, thin_module.data(), &diag_handler)? as *const _;\n     let module = ModuleCodegen {\n         module_llvm: ModuleLlvm { llmod_raw, llcx, tm },\n         name: thin_module.name().to_string(),"}, {"sha": "3fda1e26dae9e0d04ca7eab93ad2b8b77c1db82b", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 62, "deletions": 9, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=2ba7ca2bbbff6cd424aebc654308febc00b9497a", "patch": "@@ -11,7 +11,10 @@ use crate::llvm_util;\n use crate::type_::Type;\n use crate::LlvmCodegenBackend;\n use crate::ModuleLlvm;\n-use rustc_codegen_ssa::back::write::{BitcodeSection, CodegenContext, EmitObj, ModuleConfig};\n+use rustc_codegen_ssa::back::write::{\n+    BitcodeSection, CodegenContext, EmitObj, ModuleConfig, TargetMachineFactoryConfig,\n+    TargetMachineFactoryFn,\n+};\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::{CompiledModule, ModuleCodegen};\n use rustc_data_structures::small_c_str::SmallCStr;\n@@ -20,7 +23,9 @@ use rustc_fs_util::{link_or_copy, path_to_c_string};\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::bug;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::{self, Lto, OutputType, Passes, SanitizerSet, SwitchWithOptPath};\n+use rustc_session::config::{\n+    self, Lto, OutputType, Passes, SanitizerSet, SplitDwarfKind, SwitchWithOptPath,\n+};\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::InnerSpan;\n@@ -49,11 +54,31 @@ pub fn write_output_file(\n     pm: &llvm::PassManager<'ll>,\n     m: &'ll llvm::Module,\n     output: &Path,\n+    dwo_output: Option<&Path>,\n     file_type: llvm::FileType,\n ) -> Result<(), FatalError> {\n     unsafe {\n         let output_c = path_to_c_string(output);\n-        let result = llvm::LLVMRustWriteOutputFile(target, pm, m, output_c.as_ptr(), file_type);\n+        let result = if let Some(dwo_output) = dwo_output {\n+            let dwo_output_c = path_to_c_string(dwo_output);\n+            llvm::LLVMRustWriteOutputFile(\n+                target,\n+                pm,\n+                m,\n+                output_c.as_ptr(),\n+                dwo_output_c.as_ptr(),\n+                file_type,\n+            )\n+        } else {\n+            llvm::LLVMRustWriteOutputFile(\n+                target,\n+                pm,\n+                m,\n+                output_c.as_ptr(),\n+                std::ptr::null(),\n+                file_type,\n+            )\n+        };\n         result.into_result().map_err(|()| {\n             let msg = format!(\"could not write output to {}\", output.display());\n             llvm_err(handler, &msg)\n@@ -62,12 +87,17 @@ pub fn write_output_file(\n }\n \n pub fn create_informational_target_machine(sess: &Session) -> &'static mut llvm::TargetMachine {\n-    target_machine_factory(sess, config::OptLevel::No)()\n+    let config = TargetMachineFactoryConfig { split_dwarf_file: None };\n+    target_machine_factory(sess, config::OptLevel::No)(config)\n         .unwrap_or_else(|err| llvm_err(sess.diagnostic(), &err).raise())\n }\n \n-pub fn create_target_machine(tcx: TyCtxt<'_>) -> &'static mut llvm::TargetMachine {\n-    target_machine_factory(&tcx.sess, tcx.backend_optimization_level(LOCAL_CRATE))()\n+pub fn create_target_machine(tcx: TyCtxt<'_>, mod_name: &str) -> &'static mut llvm::TargetMachine {\n+    let split_dwarf_file = tcx\n+        .output_filenames(LOCAL_CRATE)\n+        .split_dwarf_filename(tcx.sess.opts.debugging_opts.split_dwarf, Some(mod_name));\n+    let config = TargetMachineFactoryConfig { split_dwarf_file };\n+    target_machine_factory(&tcx.sess, tcx.backend_optimization_level(LOCAL_CRATE))(config)\n         .unwrap_or_else(|err| llvm_err(tcx.sess.diagnostic(), &err).raise())\n }\n \n@@ -122,7 +152,7 @@ fn to_llvm_code_model(code_model: Option<CodeModel>) -> llvm::CodeModel {\n pub fn target_machine_factory(\n     sess: &Session,\n     optlvl: config::OptLevel,\n-) -> Arc<dyn Fn() -> Result<&'static mut llvm::TargetMachine, String> + Send + Sync> {\n+) -> TargetMachineFactoryFn<LlvmCodegenBackend> {\n     let reloc_model = to_llvm_relocation_model(sess.relocation_model());\n \n     let (opt_level, _) = to_llvm_opt_settings(optlvl);\n@@ -163,7 +193,10 @@ pub fn target_machine_factory(\n     let use_init_array =\n         !sess.opts.debugging_opts.use_ctors_section.unwrap_or(sess.target.use_ctors_section);\n \n-    Arc::new(move || {\n+    Arc::new(move |config: TargetMachineFactoryConfig| {\n+        let split_dwarf_file = config.split_dwarf_file.unwrap_or_default();\n+        let split_dwarf_file = CString::new(split_dwarf_file.to_str().unwrap()).unwrap();\n+\n         let tm = unsafe {\n             llvm::LLVMRustCreateTargetMachine(\n                 triple.as_ptr(),\n@@ -182,6 +215,7 @@ pub fn target_machine_factory(\n                 emit_stack_size_section,\n                 relax_elf_relocations,\n                 use_init_array,\n+                split_dwarf_file.as_ptr(),\n             )\n         };\n \n@@ -785,7 +819,15 @@ pub(crate) unsafe fn codegen(\n                 llmod\n             };\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                write_output_file(diag_handler, tm, cpm, llmod, &path, llvm::FileType::AssemblyFile)\n+                write_output_file(\n+                    diag_handler,\n+                    tm,\n+                    cpm,\n+                    llmod,\n+                    &path,\n+                    None,\n+                    llvm::FileType::AssemblyFile,\n+                )\n             })?;\n         }\n \n@@ -794,13 +836,23 @@ pub(crate) unsafe fn codegen(\n                 let _timer = cgcx\n                     .prof\n                     .generic_activity_with_arg(\"LLVM_module_codegen_emit_obj\", &module.name[..]);\n+\n+                let dwo_out = cgcx.output_filenames.temp_path_dwo(module_name);\n+                let dwo_out = match cgcx.split_dwarf_kind {\n+                    // Don't change how DWARF is emitted in single mode (or when disabled).\n+                    SplitDwarfKind::None | SplitDwarfKind::Single => None,\n+                    // Emit (a subset of the) DWARF into a separate file in split mode.\n+                    SplitDwarfKind::Split => Some(dwo_out.as_path()),\n+                };\n+\n                 with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                     write_output_file(\n                         diag_handler,\n                         tm,\n                         cpm,\n                         llmod,\n                         &obj_out,\n+                        dwo_out,\n                         llvm::FileType::ObjectFile,\n                     )\n                 })?;\n@@ -828,6 +880,7 @@ pub(crate) unsafe fn codegen(\n \n     Ok(module.into_compiled_module(\n         config.emit_obj != EmitObj::None,\n+        cgcx.split_dwarf_kind == SplitDwarfKind::Split,\n         config.emit_bc,\n         &cgcx.output_filenames,\n     ))"}, {"sha": "fa285f3488f8415f28e28be1bbc0b81f44c71720", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=2ba7ca2bbbff6cd424aebc654308febc00b9497a", "patch": "@@ -993,9 +993,15 @@ pub fn compile_unit_metadata(\n     let producer = format!(\"clang LLVM ({})\", rustc_producer);\n \n     let name_in_debuginfo = name_in_debuginfo.to_string_lossy();\n-    let work_dir = tcx.sess.working_dir.0.to_string_lossy();\n     let flags = \"\\0\";\n-    let split_name = \"\";\n+\n+    let out_dir = &tcx.output_filenames(LOCAL_CRATE).out_directory;\n+    let split_name = tcx\n+        .output_filenames(LOCAL_CRATE)\n+        .split_dwarf_filename(tcx.sess.opts.debugging_opts.split_dwarf, Some(codegen_unit_name))\n+        .unwrap_or_default();\n+    let out_dir = out_dir.to_str().unwrap();\n+    let split_name = split_name.to_str().unwrap();\n \n     // FIXME(#60020):\n     //\n@@ -1020,8 +1026,8 @@ pub fn compile_unit_metadata(\n             debug_context.builder,\n             name_in_debuginfo.as_ptr().cast(),\n             name_in_debuginfo.len(),\n-            work_dir.as_ptr().cast(),\n-            work_dir.len(),\n+            out_dir.as_ptr().cast(),\n+            out_dir.len(),\n             llvm::ChecksumKind::None,\n             ptr::null(),\n             0,\n@@ -1039,6 +1045,8 @@ pub fn compile_unit_metadata(\n             split_name.as_ptr().cast(),\n             split_name.len(),\n             kind,\n+            0,\n+            tcx.sess.opts.debugging_opts.split_dwarf_inlining,\n         );\n \n         if tcx.sess.opts.debugging_opts.profile {"}, {"sha": "a58c2fbd8ab2c2219af509bac12afcd9268a357a", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=2ba7ca2bbbff6cd424aebc654308febc00b9497a", "patch": "@@ -19,7 +19,9 @@ use back::write::{create_informational_target_machine, create_target_machine};\n pub use llvm_util::target_features;\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule};\n-use rustc_codegen_ssa::back::write::{CodegenContext, FatLTOInput, ModuleConfig};\n+use rustc_codegen_ssa::back::write::{\n+    CodegenContext, FatLTOInput, ModuleConfig, TargetMachineFactoryConfig, TargetMachineFactoryFn,\n+};\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::ModuleCodegen;\n use rustc_codegen_ssa::{CodegenResults, CompiledModule};\n@@ -34,7 +36,6 @@ use rustc_span::symbol::Symbol;\n \n use std::any::Any;\n use std::ffi::CStr;\n-use std::sync::Arc;\n \n mod back {\n     pub mod archive;\n@@ -109,7 +110,7 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n         &self,\n         sess: &Session,\n         optlvl: OptLevel,\n-    ) -> Arc<dyn Fn() -> Result<&'static mut llvm::TargetMachine, String> + Send + Sync> {\n+    ) -> TargetMachineFactoryFn<Self> {\n         back::write::target_machine_factory(sess, optlvl)\n     }\n     fn target_cpu<'b>(&self, sess: &'b Session) -> &'b str {\n@@ -331,7 +332,7 @@ impl ModuleLlvm {\n         unsafe {\n             let llcx = llvm::LLVMRustContextCreate(tcx.sess.fewer_names());\n             let llmod_raw = context::create_module(tcx, llcx, mod_name) as *const _;\n-            ModuleLlvm { llmod_raw, llcx, tm: create_target_machine(tcx) }\n+            ModuleLlvm { llmod_raw, llcx, tm: create_target_machine(tcx, mod_name) }\n         }\n     }\n \n@@ -352,7 +353,13 @@ impl ModuleLlvm {\n         unsafe {\n             let llcx = llvm::LLVMRustContextCreate(cgcx.fewer_names);\n             let llmod_raw = back::lto::parse_module(llcx, name, buffer, handler)?;\n-            let tm = match (cgcx.tm_factory.0)() {\n+\n+            let split_dwarf_file = cgcx\n+                .output_filenames\n+                .split_dwarf_filename(cgcx.split_dwarf_kind, Some(name.to_str().unwrap()));\n+            let tm_factory_config = TargetMachineFactoryConfig { split_dwarf_file };\n+\n+            let tm = match (cgcx.tm_factory)(tm_factory_config) {\n                 Ok(m) => m,\n                 Err(e) => {\n                     handler.struct_err(&e).emit();"}, {"sha": "707aaa2b53ffc8575925f48da94c200fc6d1cb80", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=2ba7ca2bbbff6cd424aebc654308febc00b9497a", "patch": "@@ -1830,6 +1830,8 @@ extern \"C\" {\n         SplitName: *const c_char,\n         SplitNameLen: size_t,\n         kind: DebugEmissionKind,\n+        DWOId: u64,\n+        SplitDebugInlining: bool,\n     ) -> &'a DIDescriptor;\n \n     pub fn LLVMRustDIBuilderCreateFile(\n@@ -2151,6 +2153,7 @@ extern \"C\" {\n         EmitStackSizeSection: bool,\n         RelaxELFRelocations: bool,\n         UseInitArray: bool,\n+        SplitDwarfFile: *const c_char,\n     ) -> Option<&'static mut TargetMachine>;\n     pub fn LLVMRustDisposeTargetMachine(T: &'static mut TargetMachine);\n     pub fn LLVMRustAddBuilderLibraryInfo(\n@@ -2179,6 +2182,7 @@ extern \"C\" {\n         PM: &PassManager<'a>,\n         M: &'a Module,\n         Output: *const c_char,\n+        DwoOutput: *const c_char,\n         FileType: FileType,\n     ) -> LLVMRustResult;\n     pub fn LLVMRustOptimizeWithNewPassManager("}, {"sha": "ccd4d103ddb7f3fc3d26a4969065edbc6e0302b2", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 144, "deletions": 68, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=2ba7ca2bbbff6cd424aebc654308febc00b9497a", "patch": "@@ -21,7 +21,9 @@ use super::archive::ArchiveBuilder;\n use super::command::Command;\n use super::linker::{self, Linker};\n use super::rpath::{self, RPathConfig};\n-use crate::{looks_like_rust_object_file, CodegenResults, CrateInfo, METADATA_FILENAME};\n+use crate::{\n+    looks_like_rust_object_file, CodegenResults, CompiledModule, CrateInfo, METADATA_FILENAME,\n+};\n \n use cc::windows_registry;\n use tempfile::Builder as TempFileBuilder;\n@@ -96,6 +98,9 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n                         path.as_ref(),\n                         target_cpu,\n                     );\n+                    if sess.opts.debugging_opts.split_dwarf == config::SplitDwarfKind::Split {\n+                        link_dwarf_object(sess, &out_filename);\n+                    }\n                 }\n             }\n             if sess.opts.json_artifact_notifications {\n@@ -107,22 +112,30 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n     // Remove the temporary object file and metadata if we aren't saving temps\n     sess.time(\"link_binary_remove_temps\", || {\n         if !sess.opts.cg.save_temps {\n+            let remove_temps_from_module = |module: &CompiledModule| {\n+                if let Some(ref obj) = module.object {\n+                    remove(sess, obj);\n+                }\n+\n+                if let Some(ref obj) = module.dwarf_object {\n+                    remove(sess, obj);\n+                }\n+            };\n+\n             if sess.opts.output_types.should_codegen()\n                 && !preserve_objects_for_their_debuginfo(sess)\n             {\n-                for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n-                    remove(sess, obj);\n+                for module in &codegen_results.modules {\n+                    remove_temps_from_module(module);\n                 }\n             }\n+\n             if let Some(ref metadata_module) = codegen_results.metadata_module {\n-                if let Some(ref obj) = metadata_module.object {\n-                    remove(sess, obj);\n-                }\n+                remove_temps_from_module(metadata_module);\n             }\n+\n             if let Some(ref allocator_module) = codegen_results.allocator_module {\n-                if let Some(ref obj) = allocator_module.object {\n-                    remove(sess, obj);\n-                }\n+                remove_temps_from_module(allocator_module);\n             }\n         }\n     });\n@@ -279,12 +292,12 @@ pub fn emit_metadata(sess: &Session, metadata: &EncodedMetadata, tmpdir: &MaybeT\n     out_filename\n }\n \n-// Create an 'rlib'\n-//\n-// An rlib in its current incarnation is essentially a renamed .a file. The\n-// rlib primarily contains the object file of the crate, but it also contains\n-// all of the object files from native libraries. This is done by unzipping\n-// native libraries and inserting all of the contents into this archive.\n+/// Create an 'rlib'.\n+///\n+/// An rlib in its current incarnation is essentially a renamed .a file. The rlib primarily contains\n+/// the object file of the crate, but it also contains all of the object files from native\n+/// libraries. This is done by unzipping native libraries and inserting all of the contents into\n+/// this archive.\n fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n     sess: &'a Session,\n     codegen_results: &CodegenResults,\n@@ -379,18 +392,17 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n     ab\n }\n \n-// Create a static archive\n-//\n-// This is essentially the same thing as an rlib, but it also involves adding\n-// all of the upstream crates' objects into the archive. This will slurp in\n-// all of the native libraries of upstream dependencies as well.\n-//\n-// Additionally, there's no way for us to link dynamic libraries, so we warn\n-// about all dynamic library dependencies that they're not linked in.\n-//\n-// There's no need to include metadata in a static archive, so ensure to not\n-// link in the metadata object file (and also don't prepare the archive with a\n-// metadata file).\n+/// Create a static archive.\n+///\n+/// This is essentially the same thing as an rlib, but it also involves adding all of the upstream\n+/// crates' objects into the archive. This will slurp in all of the native libraries of upstream\n+/// dependencies as well.\n+///\n+/// Additionally, there's no way for us to link dynamic libraries, so we warn about all dynamic\n+/// library dependencies that they're not linked in.\n+///\n+/// There's no need to include metadata in a static archive, so ensure to not link in the metadata\n+/// object file (and also don't prepare the archive with a metadata file).\n fn link_staticlib<'a, B: ArchiveBuilder<'a>>(\n     sess: &'a Session,\n     codegen_results: &CodegenResults,\n@@ -447,10 +459,73 @@ fn link_staticlib<'a, B: ArchiveBuilder<'a>>(\n     }\n }\n \n-// Create a dynamic library or executable\n-//\n-// This will invoke the system linker/cc to create the resulting file. This\n-// links to all upstream files as well.\n+fn escape_stdout_stderr_string(s: &[u8]) -> String {\n+    str::from_utf8(s).map(|s| s.to_owned()).unwrap_or_else(|_| {\n+        let mut x = \"Non-UTF-8 output: \".to_string();\n+        x.extend(s.iter().flat_map(|&b| ascii::escape_default(b)).map(char::from));\n+        x\n+    })\n+}\n+\n+const LLVM_DWP_EXECUTABLE: &'static str = \"rust-llvm-dwp\";\n+\n+/// Invoke `llvm-dwp` (shipped alongside rustc) to link `dwo` files from Split DWARF into a `dwp`\n+/// file.\n+fn link_dwarf_object<'a>(sess: &'a Session, executable_out_filename: &Path) {\n+    info!(\"preparing dwp to {}.dwp\", executable_out_filename.to_str().unwrap());\n+\n+    let dwp_out_filename = executable_out_filename.with_extension(\"dwp\");\n+    let mut cmd = Command::new(LLVM_DWP_EXECUTABLE);\n+    cmd.arg(\"-e\");\n+    cmd.arg(executable_out_filename);\n+    cmd.arg(\"-o\");\n+    cmd.arg(&dwp_out_filename);\n+\n+    let mut new_path = sess.host_filesearch(PathKind::All).get_tools_search_paths(false);\n+    if let Some(path) = env::var_os(\"PATH\") {\n+        new_path.extend(env::split_paths(&path));\n+    }\n+    let new_path = env::join_paths(new_path).unwrap();\n+    cmd.env(\"PATH\", new_path);\n+\n+    info!(\"{:?}\", &cmd);\n+    match sess.time(\"run_dwp\", || cmd.output()) {\n+        Ok(prog) if !prog.status.success() => {\n+            sess.struct_err(&format!(\n+                \"linking dwarf objects with `{}` failed: {}\",\n+                LLVM_DWP_EXECUTABLE, prog.status\n+            ))\n+            .note(&format!(\"{:?}\", &cmd))\n+            .note(&escape_stdout_stderr_string(&prog.stdout))\n+            .note(&escape_stdout_stderr_string(&prog.stderr))\n+            .emit();\n+            info!(\"linker stderr:\\n{}\", escape_stdout_stderr_string(&prog.stderr));\n+            info!(\"linker stdout:\\n{}\", escape_stdout_stderr_string(&prog.stdout));\n+        }\n+        Ok(_) => {}\n+        Err(e) => {\n+            let dwp_not_found = e.kind() == io::ErrorKind::NotFound;\n+            let mut err = if dwp_not_found {\n+                sess.struct_err(&format!(\"linker `{}` not found\", LLVM_DWP_EXECUTABLE))\n+            } else {\n+                sess.struct_err(&format!(\"could not exec the linker `{}`\", LLVM_DWP_EXECUTABLE))\n+            };\n+\n+            err.note(&e.to_string());\n+\n+            if !dwp_not_found {\n+                err.note(&format!(\"{:?}\", &cmd));\n+            }\n+\n+            err.emit();\n+        }\n+    }\n+}\n+\n+/// Create a dynamic library or executable.\n+///\n+/// This will invoke the system linker/cc to create the resulting file. This links to all upstream\n+/// files as well.\n fn link_natively<'a, B: ArchiveBuilder<'a>>(\n     sess: &'a Session,\n     crate_type: CrateType,\n@@ -662,7 +737,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n                     prog.status\n                 ))\n                 .note(&format!(\"{:?}\", &cmd))\n-                .note(&escape_string(&output))\n+                .note(&escape_stdout_stderr_string(&output))\n                 .emit();\n \n                 // If MSVC's `link.exe` was expected but the return code\n@@ -715,8 +790,8 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n \n                 sess.abort_if_errors();\n             }\n-            info!(\"linker stderr:\\n{}\", escape_string(&prog.stderr));\n-            info!(\"linker stdout:\\n{}\", escape_string(&prog.stdout));\n+            info!(\"linker stderr:\\n{}\", escape_stdout_stderr_string(&prog.stderr));\n+            info!(\"linker stdout:\\n{}\", escape_stdout_stderr_string(&prog.stdout));\n         }\n         Err(e) => {\n             let linker_not_found = e.kind() == io::ErrorKind::NotFound;\n@@ -962,6 +1037,13 @@ fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n         return false;\n     }\n \n+    // Single mode keeps debuginfo in the same object file, but in such a way that it it skipped\n+    // by the linker - so it's expected that when codegen units are linked together that this\n+    // debuginfo would be lost without keeping around the temps.\n+    if sess.opts.debugging_opts.split_dwarf == config::SplitDwarfKind::Single {\n+        return true;\n+    }\n+\n     // If we're on OSX then the equivalent of split dwarf is turned on by\n     // default. The final executable won't actually have any debug information\n     // except it'll have pointers to elsewhere. Historically we've always run\n@@ -1677,17 +1759,15 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     cmd.take_cmd()\n }\n \n-// # Native library linking\n-//\n-// User-supplied library search paths (-L on the command line). These are\n-// the same paths used to find Rust crates, so some of them may have been\n-// added already by the previous crate linking code. This only allows them\n-// to be found at compile time so it is still entirely up to outside\n-// forces to make sure that library can be found at runtime.\n-//\n-// Also note that the native libraries linked here are only the ones located\n-// in the current crate. Upstream crates with native library dependencies\n-// may have their native library pulled in above.\n+/// # Native library linking\n+///\n+/// User-supplied library search paths (-L on the command line). These are the same paths used to\n+/// find Rust crates, so some of them may have been added already by the previous crate linking\n+/// code. This only allows them to be found at compile time so it is still entirely up to outside\n+/// forces to make sure that library can be found at runtime.\n+///\n+/// Also note that the native libraries linked here are only the ones located in the current crate.\n+/// Upstream crates with native library dependencies may have their native library pulled in above.\n fn add_local_native_libraries(\n     cmd: &mut dyn Linker,\n     sess: &Session,\n@@ -1727,11 +1807,10 @@ fn add_local_native_libraries(\n     }\n }\n \n-// # Rust Crate linking\n-//\n-// Rust crates are not considered at all when creating an rlib output. All\n-// dependencies will be linked when producing the final output (instead of\n-// the intermediate rlib version)\n+/// # Rust Crate linking\n+///\n+/// Rust crates are not considered at all when creating an rlib output. All dependencies will be\n+/// linked when producing the final output (instead of the intermediate rlib version).\n fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n     cmd: &mut dyn Linker,\n     sess: &'a Session,\n@@ -1996,24 +2075,21 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n     }\n }\n \n-// Link in all of our upstream crates' native dependencies. Remember that\n-// all of these upstream native dependencies are all non-static\n-// dependencies. We've got two cases then:\n-//\n-// 1. The upstream crate is an rlib. In this case we *must* link in the\n-// native dependency because the rlib is just an archive.\n-//\n-// 2. The upstream crate is a dylib. In order to use the dylib, we have to\n-// have the dependency present on the system somewhere. Thus, we don't\n-// gain a whole lot from not linking in the dynamic dependency to this\n-// crate as well.\n-//\n-// The use case for this is a little subtle. In theory the native\n-// dependencies of a crate are purely an implementation detail of the crate\n-// itself, but the problem arises with generic and inlined functions. If a\n-// generic function calls a native function, then the generic function must\n-// be instantiated in the target crate, meaning that the native symbol must\n-// also be resolved in the target crate.\n+/// Link in all of our upstream crates' native dependencies. Remember that all of these upstream\n+/// native dependencies are all non-static dependencies. We've got two cases then:\n+///\n+/// 1. The upstream crate is an rlib. In this case we *must* link in the native dependency because\n+/// the rlib is just an archive.\n+///\n+/// 2. The upstream crate is a dylib. In order to use the dylib, we have to have the dependency\n+/// present on the system somewhere. Thus, we don't gain a whole lot from not linking in the\n+/// dynamic dependency to this crate as well.\n+///\n+/// The use case for this is a little subtle. In theory the native dependencies of a crate are\n+/// purely an implementation detail of the crate itself, but the problem arises with generic and\n+/// inlined functions. If a generic function calls a native function, then the generic function\n+/// must be instantiated in the target crate, meaning that the native symbol must also be resolved\n+/// in the target crate.\n fn add_upstream_native_libraries(\n     cmd: &mut dyn Linker,\n     sess: &Session,"}, {"sha": "c84b87964b845507b673af2c29247d24e7ddfc35", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=2ba7ca2bbbff6cd424aebc654308febc00b9497a", "patch": "@@ -274,17 +274,20 @@ impl ModuleConfig {\n     }\n }\n \n-// HACK(eddyb) work around `#[derive]` producing wrong bounds for `Clone`.\n-pub struct TargetMachineFactory<B: WriteBackendMethods>(\n-    pub Arc<dyn Fn() -> Result<B::TargetMachine, String> + Send + Sync>,\n-);\n-\n-impl<B: WriteBackendMethods> Clone for TargetMachineFactory<B> {\n-    fn clone(&self) -> Self {\n-        TargetMachineFactory(self.0.clone())\n-    }\n+/// Configuration passed to the function returned by the `target_machine_factory`.\n+pub struct TargetMachineFactoryConfig {\n+    /// Split DWARF is enabled in LLVM by checking that `TM.MCOptions.SplitDwarfFile` isn't empty,\n+    /// so the path to the dwarf object has to be provided when we create the target machine.\n+    /// This can be ignored by backends which do not need it for their Split DWARF support.\n+    pub split_dwarf_file: Option<PathBuf>,\n }\n \n+pub type TargetMachineFactoryFn<B> = Arc<\n+    dyn Fn(TargetMachineFactoryConfig) -> Result<<B as WriteBackendMethods>::TargetMachine, String>\n+        + Send\n+        + Sync,\n+>;\n+\n pub type ExportedSymbols = FxHashMap<CrateNum, Arc<Vec<(String, SymbolExportLevel)>>>;\n \n /// Additional resources used by optimize_and_codegen (not module specific)\n@@ -305,12 +308,13 @@ pub struct CodegenContext<B: WriteBackendMethods> {\n     pub regular_module_config: Arc<ModuleConfig>,\n     pub metadata_module_config: Arc<ModuleConfig>,\n     pub allocator_module_config: Arc<ModuleConfig>,\n-    pub tm_factory: TargetMachineFactory<B>,\n+    pub tm_factory: TargetMachineFactoryFn<B>,\n     pub msvc_imps_needed: bool,\n     pub is_pe_coff: bool,\n     pub target_pointer_width: u32,\n     pub target_arch: String,\n     pub debuginfo: config::DebugInfo,\n+    pub split_dwarf_kind: config::SplitDwarfKind,\n \n     // Number of cgus excluding the allocator/metadata modules\n     pub total_cgus: usize,\n@@ -627,6 +631,12 @@ fn produce_final_output_artifacts(\n                 }\n             }\n \n+            if let Some(ref path) = module.dwarf_object {\n+                if !keep_numbered_objects {\n+                    remove(sess, path);\n+                }\n+            }\n+\n             if let Some(ref path) = module.bytecode {\n                 if !keep_numbered_bitcode {\n                     remove(sess, path);\n@@ -849,6 +859,7 @@ fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n         name: module.name,\n         kind: ModuleKind::Regular,\n         object,\n+        dwarf_object: None,\n         bytecode: None,\n     }))\n }\n@@ -1020,13 +1031,14 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         regular_module_config: regular_config,\n         metadata_module_config: metadata_config,\n         allocator_module_config: allocator_config,\n-        tm_factory: TargetMachineFactory(backend.target_machine_factory(tcx.sess, ol)),\n+        tm_factory: backend.target_machine_factory(tcx.sess, ol),\n         total_cgus,\n         msvc_imps_needed: msvc_imps_needed(tcx),\n         is_pe_coff: tcx.sess.target.is_like_windows,\n         target_pointer_width: tcx.sess.target.pointer_width,\n         target_arch: tcx.sess.target.arch.clone(),\n         debuginfo: tcx.sess.opts.debuginfo,\n+        split_dwarf_kind: tcx.sess.opts.debugging_opts.split_dwarf,\n     };\n \n     // This is the \"main loop\" of parallel work happening for parallel codegen."}, {"sha": "ee889d552412e295d8df11790f1afb5ecac25b9e", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=2ba7ca2bbbff6cd424aebc654308febc00b9497a", "patch": "@@ -64,13 +64,15 @@ impl<M> ModuleCodegen<M> {\n     pub fn into_compiled_module(\n         self,\n         emit_obj: bool,\n+        emit_dwarf_obj: bool,\n         emit_bc: bool,\n         outputs: &OutputFilenames,\n     ) -> CompiledModule {\n         let object = emit_obj.then(|| outputs.temp_path(OutputType::Object, Some(&self.name)));\n+        let dwarf_object = emit_dwarf_obj.then(|| outputs.temp_path_dwo(Some(&self.name)));\n         let bytecode = emit_bc.then(|| outputs.temp_path(OutputType::Bitcode, Some(&self.name)));\n \n-        CompiledModule { name: self.name.clone(), kind: self.kind, object, bytecode }\n+        CompiledModule { name: self.name.clone(), kind: self.kind, object, dwarf_object, bytecode }\n     }\n }\n \n@@ -79,6 +81,7 @@ pub struct CompiledModule {\n     pub name: String,\n     pub kind: ModuleKind,\n     pub object: Option<PathBuf>,\n+    pub dwarf_object: Option<PathBuf>,\n     pub bytecode: Option<PathBuf>,\n }\n "}, {"sha": "f28db2fe84b6b00bf0adc35d436c9698b9fd7843", "filename": "compiler/rustc_codegen_ssa/src/traits/backend.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs?ref=2ba7ca2bbbff6cd424aebc654308febc00b9497a", "patch": "@@ -1,5 +1,6 @@\n use super::write::WriteBackendMethods;\n use super::CodegenObject;\n+use crate::back::write::TargetMachineFactoryFn;\n use crate::{CodegenResults, ModuleCodegen};\n \n use rustc_ast::expand::allocator::AllocatorKind;\n@@ -21,7 +22,6 @@ use rustc_target::spec::Target;\n pub use rustc_data_structures::sync::MetadataRef;\n \n use std::any::Any;\n-use std::sync::Arc;\n \n pub trait BackendTypes {\n     type Value: CodegenObject;\n@@ -123,7 +123,7 @@ pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Se\n         &self,\n         sess: &Session,\n         opt_level: config::OptLevel,\n-    ) -> Arc<dyn Fn() -> Result<Self::TargetMachine, String> + Send + Sync>;\n+    ) -> TargetMachineFactoryFn<Self>;\n     fn target_cpu<'b>(&self, sess: &'b Session) -> &'b str;\n     fn tune_cpu<'b>(&self, sess: &'b Session) -> Option<&'b str>;\n }"}, {"sha": "2264908995bb7f34ce335e3224b97e6f4c911a14", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=2ba7ca2bbbff6cd424aebc654308febc00b9497a", "patch": "@@ -450,7 +450,8 @@ extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n     bool AsmComments,\n     bool EmitStackSizeSection,\n     bool RelaxELFRelocations,\n-    bool UseInitArray) {\n+    bool UseInitArray,\n+    const char *SplitDwarfFile) {\n \n   auto OptLevel = fromRust(RustOptLevel);\n   auto RM = fromRust(RustReloc);\n@@ -476,6 +477,9 @@ extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n   Options.MCOptions.AsmVerbose = AsmComments;\n   Options.MCOptions.PreserveAsmComments = AsmComments;\n   Options.MCOptions.ABIName = ABIStr;\n+  if (SplitDwarfFile) {\n+      Options.MCOptions.SplitDwarfFile = SplitDwarfFile;\n+  }\n   Options.RelaxELFRelocations = RelaxELFRelocations;\n   Options.UseInitArray = UseInitArray;\n \n@@ -610,7 +614,7 @@ static TargetMachine::CodeGenFileType fromRust(LLVMRustFileType Type) {\n \n extern \"C\" LLVMRustResult\n LLVMRustWriteOutputFile(LLVMTargetMachineRef Target, LLVMPassManagerRef PMR,\n-                        LLVMModuleRef M, const char *Path,\n+                        LLVMModuleRef M, const char *Path, const char *DwoPath,\n                         LLVMRustFileType RustFileType) {\n   llvm::legacy::PassManager *PM = unwrap<llvm::legacy::PassManager>(PMR);\n   auto FileType = fromRust(RustFileType);\n@@ -626,8 +630,22 @@ LLVMRustWriteOutputFile(LLVMTargetMachineRef Target, LLVMPassManagerRef PMR,\n   }\n \n   buffer_ostream BOS(OS);\n-  unwrap(Target)->addPassesToEmitFile(*PM, BOS, nullptr, FileType, false);\n-  PM->run(*unwrap(M));\n+  if (DwoPath) {\n+    raw_fd_ostream DOS(DwoPath, EC, sys::fs::F_None);\n+    EC.clear();\n+    if (EC)\n+        ErrorInfo = EC.message();\n+    if (ErrorInfo != \"\") {\n+      LLVMRustSetLastError(ErrorInfo.c_str());\n+      return LLVMRustResult::Failure;\n+    }\n+    buffer_ostream DBOS(DOS);\n+    unwrap(Target)->addPassesToEmitFile(*PM, BOS, &DBOS, FileType, false);\n+    PM->run(*unwrap(M));\n+  } else {\n+    unwrap(Target)->addPassesToEmitFile(*PM, BOS, nullptr, FileType, false);\n+    PM->run(*unwrap(M));\n+  }\n \n   // Apparently `addPassesToEmitFile` adds a pointer to our on-the-stack output\n   // stream (OS), so the only real safe place to delete this is here? Don't we"}, {"sha": "c0ff62c17beb56db0c28d438d649256bc33d37c8", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=2ba7ca2bbbff6cd424aebc654308febc00b9497a", "patch": "@@ -690,13 +690,14 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateCompileUnit(\n     const char *Producer, size_t ProducerLen, bool isOptimized,\n     const char *Flags, unsigned RuntimeVer,\n     const char *SplitName, size_t SplitNameLen,\n-    LLVMRustDebugEmissionKind Kind) {\n+    LLVMRustDebugEmissionKind Kind,\n+    uint64_t DWOId, bool SplitDebugInlining) {\n   auto *File = unwrapDI<DIFile>(FileRef);\n \n   return wrap(Builder->createCompileUnit(Lang, File, StringRef(Producer, ProducerLen),\n                                          isOptimized, Flags, RuntimeVer,\n                                          StringRef(SplitName, SplitNameLen),\n-                                         fromRust(Kind)));\n+                                         fromRust(Kind), DWOId, SplitDebugInlining));\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateFile("}, {"sha": "c20b11656b22960b0147a7a2b6b3bd626b19dafe", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=2ba7ca2bbbff6cd424aebc654308febc00b9497a", "patch": "@@ -221,6 +221,23 @@ pub enum DebugInfo {\n     Full,\n }\n \n+/// Some debuginfo requires link-time relocation and some does not. LLVM can partition the debuginfo\n+/// into sections depending on whether or not it requires link-time relocation. Split DWARF\n+/// provides a mechanism which allows the linker to skip the sections which don't require link-time\n+/// relocation - either by putting those sections into DWARF object files, or keeping them in the\n+/// object file in such a way that the linker will skip them.\n+#[derive(Clone, Copy, Debug, PartialEq, Hash)]\n+pub enum SplitDwarfKind {\n+    /// Disabled.\n+    None,\n+    /// Sections which do not require relocation are written into the object file but ignored\n+    /// by the linker.\n+    Single,\n+    /// Sections which do not require relocation are written into a DWARF object (`.dwo`) file,\n+    /// which is skipped by the linker by virtue of being a different file.\n+    Split,\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]\n #[derive(Encodable, Decodable)]\n pub enum OutputType {\n@@ -533,6 +550,7 @@ impl_stable_hash_via_hash!(OutputFilenames);\n \n pub const RLINK_EXT: &str = \"rlink\";\n pub const RUST_CGU_EXT: &str = \"rcgu\";\n+pub const DWARF_OBJECT_EXT: &str = \"dwo\";\n \n impl OutputFilenames {\n     pub fn new(\n@@ -566,7 +584,12 @@ impl OutputFilenames {\n         self.temp_path_ext(extension, codegen_unit_name)\n     }\n \n-    /// Like temp_path, but also supports things where there is no corresponding\n+    /// Like `temp_path`, but specifically for dwarf objects.\n+    pub fn temp_path_dwo(&self, codegen_unit_name: Option<&str>) -> PathBuf {\n+        self.temp_path_ext(DWARF_OBJECT_EXT, codegen_unit_name)\n+    }\n+\n+    /// Like `temp_path`, but also supports things where there is no corresponding\n     /// OutputType, like noopt-bitcode or lto-bitcode.\n     pub fn temp_path_ext(&self, ext: &str, codegen_unit_name: Option<&str>) -> PathBuf {\n         let mut extension = String::new();\n@@ -593,6 +616,37 @@ impl OutputFilenames {\n         path.set_extension(extension);\n         path\n     }\n+\n+    /// Returns the name of the Split DWARF file - this can differ depending on which Split DWARF\n+    /// mode is being used, which is the logic that this function is intended to encapsulate.\n+    pub fn split_dwarf_filename(\n+        &self,\n+        split_dwarf_kind: SplitDwarfKind,\n+        cgu_name: Option<&str>,\n+    ) -> Option<PathBuf> {\n+        self.split_dwarf_path(split_dwarf_kind, cgu_name)\n+            .map(|path| path.strip_prefix(&self.out_directory).unwrap_or(&path).to_path_buf())\n+    }\n+\n+    /// Returns the path for the Split DWARF file - this can differ depending on which Split DWARF\n+    /// mode is being used, which is the logic that this function is intended to encapsulate.\n+    pub fn split_dwarf_path(\n+        &self,\n+        split_dwarf_kind: SplitDwarfKind,\n+        cgu_name: Option<&str>,\n+    ) -> Option<PathBuf> {\n+        let obj_out = self.temp_path(OutputType::Object, cgu_name);\n+        let dwo_out = self.temp_path_dwo(cgu_name);\n+        match split_dwarf_kind {\n+            SplitDwarfKind::None => None,\n+            // Single mode doesn't change how DWARF is emitted, but does add Split DWARF attributes\n+            // (pointing at the path which is being determined here). Use the path to the current\n+            // object file.\n+            SplitDwarfKind::Single => Some(obj_out),\n+            // Split mode emits the DWARF into a different file, use that path.\n+            SplitDwarfKind::Split => Some(dwo_out),\n+        }\n+    }\n }\n \n pub fn host_triple() -> &'static str {"}, {"sha": "81f79f4b0e0fbd51f98fbc137f6dfb6a1fd294f1", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba7ca2bbbff6cd424aebc654308febc00b9497a/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=2ba7ca2bbbff6cd424aebc654308febc00b9497a", "patch": "@@ -269,6 +269,7 @@ macro_rules! options {\n         pub const parse_switch_with_opt_path: &str =\n             \"an optional path to the profiling data output directory\";\n         pub const parse_merge_functions: &str = \"one of: `disabled`, `trampolines`, or `aliases`\";\n+        pub const parse_split_dwarf_kind: &str = \"one of: `none`, `single` or `split`\";\n         pub const parse_symbol_mangling_version: &str = \"either `legacy` or `v0` (RFC 2603)\";\n         pub const parse_src_file_hash: &str = \"either `md5` or `sha1`\";\n         pub const parse_relocation_model: &str =\n@@ -676,6 +677,19 @@ macro_rules! options {\n             true\n         }\n \n+        fn parse_split_dwarf_kind(\n+            slot: &mut SplitDwarfKind,\n+            v: Option<&str>,\n+        ) -> bool {\n+            *slot = match v {\n+                Some(\"none\") => SplitDwarfKind::None,\n+                Some(\"split\") => SplitDwarfKind::Split,\n+                Some(\"single\") => SplitDwarfKind::Single,\n+                _ => return false,\n+            };\n+            true\n+        }\n+\n         fn parse_symbol_mangling_version(\n             slot: &mut Option<SymbolManglingVersion>,\n             v: Option<&str>,\n@@ -1088,6 +1102,11 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"hash algorithm of source files in debug info (`md5`, `sha1`, or `sha256`)\"),\n     strip: Strip = (Strip::None, parse_strip, [UNTRACKED],\n         \"tell the linker which information to strip (`none` (default), `debuginfo` or `symbols`)\"),\n+    split_dwarf: SplitDwarfKind = (SplitDwarfKind::None, parse_split_dwarf_kind, [UNTRACKED],\n+        \"enable generation of split dwarf\"),\n+    split_dwarf_inlining: bool = (true, parse_bool, [UNTRACKED],\n+        \"provide minimal debug info in the object/executable to facilitate online \\\n+         symbolication/stack traces in the absence of .dwo/.dwp files when using Split DWARF\"),\n     symbol_mangling_version: Option<SymbolManglingVersion> = (None,\n         parse_symbol_mangling_version, [TRACKED],\n         \"which mangling version to use for symbol names ('legacy' (default) or 'v0')\"),"}, {"sha": "fbebb26c746206cc31e20d8240da5bd4895b2b4d", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2ba7ca2bbbff6cd424aebc654308febc00b9497a/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba7ca2bbbff6cd424aebc654308febc00b9497a/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=2ba7ca2bbbff6cd424aebc654308febc00b9497a", "patch": "@@ -969,15 +969,25 @@ impl Step for Assemble {\n \n         copy_codegen_backends_to_sysroot(builder, build_compiler, target_compiler);\n \n+        // We prepend this bin directory to the user PATH when linking Rust binaries. To\n+        // avoid shadowing the system LLD we rename the LLD we provide to `rust-lld`.\n         let libdir = builder.sysroot_libdir(target_compiler, target_compiler.host);\n+        let libdir_bin = libdir.parent().unwrap().join(\"bin\");\n+        t!(fs::create_dir_all(&libdir_bin));\n+\n         if let Some(lld_install) = lld_install {\n             let src_exe = exe(\"lld\", target_compiler.host);\n             let dst_exe = exe(\"rust-lld\", target_compiler.host);\n-            // we prepend this bin directory to the user PATH when linking Rust binaries. To\n-            // avoid shadowing the system LLD we rename the LLD we provide to `rust-lld`.\n-            let dst = libdir.parent().unwrap().join(\"bin\");\n-            t!(fs::create_dir_all(&dst));\n-            builder.copy(&lld_install.join(\"bin\").join(&src_exe), &dst.join(&dst_exe));\n+            builder.copy(&lld_install.join(\"bin\").join(&src_exe), &libdir_bin.join(&dst_exe));\n+        }\n+\n+        // Similarly, copy `llvm-dwp` into libdir for Split DWARF.\n+        {\n+            let src_exe = exe(\"llvm-dwp\", target_compiler.host);\n+            let dst_exe = exe(\"rust-llvm-dwp\", target_compiler.host);\n+            let llvm_config_bin = builder.ensure(native::Llvm { target: target_compiler.host });\n+            let llvm_bin_dir = llvm_config_bin.parent().unwrap();\n+            builder.copy(&llvm_bin_dir.join(&src_exe), &libdir_bin.join(&dst_exe));\n         }\n \n         // Ensure that `libLLVM.so` ends up in the newly build compiler directory,"}, {"sha": "25905895116fa85f83f8b558f80d812b1e8ce095", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2ba7ca2bbbff6cd424aebc654308febc00b9497a/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba7ca2bbbff6cd424aebc654308febc00b9497a/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=2ba7ca2bbbff6cd424aebc654308febc00b9497a", "patch": "@@ -523,17 +523,20 @@ impl Step for Rustc {\n             // component for now.\n             maybe_install_llvm_runtime(builder, host, image);\n \n+            let src_dir = builder.sysroot_libdir(compiler, host).parent().unwrap().join(\"bin\");\n+            let dst_dir = image.join(\"lib/rustlib\").join(&*host.triple).join(\"bin\");\n+            t!(fs::create_dir_all(&dst_dir));\n+\n             // Copy over lld if it's there\n             if builder.config.lld_enabled {\n                 let exe = exe(\"rust-lld\", compiler.host);\n-                let src =\n-                    builder.sysroot_libdir(compiler, host).parent().unwrap().join(\"bin\").join(&exe);\n-                // for the rationale about this rename check `compile::copy_lld_to_sysroot`\n-                let dst = image.join(\"lib/rustlib\").join(&*host.triple).join(\"bin\").join(&exe);\n-                t!(fs::create_dir_all(&dst.parent().unwrap()));\n-                builder.copy(&src, &dst);\n+                builder.copy(&src_dir.join(&exe), &dst_dir.join(&exe));\n             }\n \n+            // Copy over llvm-dwp if it's there\n+            let exe = exe(\"rust-llvm-dwp\", compiler.host);\n+            builder.copy(&src_dir.join(&exe), &dst_dir.join(&exe));\n+\n             // Man pages\n             t!(fs::create_dir_all(image.join(\"share/man/man1\")));\n             let man_src = builder.src.join(\"src/doc/man\");"}, {"sha": "b99692e8ba5b8264a166ba5e071f5cd6ff04c3de", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2ba7ca2bbbff6cd424aebc654308febc00b9497a/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba7ca2bbbff6cd424aebc654308febc00b9497a/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=2ba7ca2bbbff6cd424aebc654308febc00b9497a", "patch": "@@ -897,7 +897,12 @@ default_test!(Incremental {\n     suite: \"incremental\"\n });\n \n-default_test!(Debuginfo { path: \"src/test/debuginfo\", mode: \"debuginfo\", suite: \"debuginfo\" });\n+default_test_with_compare_mode!(Debuginfo {\n+    path: \"src/test/debuginfo\",\n+    mode: \"debuginfo\",\n+    suite: \"debuginfo\",\n+    compare_mode: \"split-dwarf\"\n+});\n \n host_test!(UiFullDeps { path: \"src/test/ui-fulldeps\", mode: \"ui\", suite: \"ui-fulldeps\" });\n "}, {"sha": "e1a78e2edfc44014b7e24dbd06c74402170c8615", "filename": "src/test/run-make-fulldeps/split-dwarf/Makefile", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ba7ca2bbbff6cd424aebc654308febc00b9497a/src%2Ftest%2Frun-make-fulldeps%2Fsplit-dwarf%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/2ba7ca2bbbff6cd424aebc654308febc00b9497a/src%2Ftest%2Frun-make-fulldeps%2Fsplit-dwarf%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsplit-dwarf%2FMakefile?ref=2ba7ca2bbbff6cd424aebc654308febc00b9497a", "patch": "@@ -0,0 +1,8 @@\n+-include ../tools.mk\n+\n+# only-linux\n+\n+all:\n+\t$(RUSTC) -Z split-dwarf=split foo.rs\n+\trm $(TMPDIR)/foo.dwp\n+\trm $(TMPDIR)/$(call BIN,foo)"}, {"sha": "f328e4d9d04c31d0d70d16d21a07d1613be9d577", "filename": "src/test/run-make-fulldeps/split-dwarf/foo.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ba7ca2bbbff6cd424aebc654308febc00b9497a/src%2Ftest%2Frun-make-fulldeps%2Fsplit-dwarf%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba7ca2bbbff6cd424aebc654308febc00b9497a/src%2Ftest%2Frun-make-fulldeps%2Fsplit-dwarf%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsplit-dwarf%2Ffoo.rs?ref=2ba7ca2bbbff6cd424aebc654308febc00b9497a", "patch": "@@ -0,0 +1 @@\n+fn main() {}"}, {"sha": "80fbb06b9469109fb3efd1a80603faa9e3d460f7", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ba7ca2bbbff6cd424aebc654308febc00b9497a/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba7ca2bbbff6cd424aebc654308febc00b9497a/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=2ba7ca2bbbff6cd424aebc654308febc00b9497a", "patch": "@@ -127,6 +127,8 @@ pub enum CompareMode {\n     Nll,\n     Polonius,\n     Chalk,\n+    SplitDwarf,\n+    SplitDwarfSingle,\n }\n \n impl CompareMode {\n@@ -135,6 +137,8 @@ impl CompareMode {\n             CompareMode::Nll => \"nll\",\n             CompareMode::Polonius => \"polonius\",\n             CompareMode::Chalk => \"chalk\",\n+            CompareMode::SplitDwarf => \"split-dwarf\",\n+            CompareMode::SplitDwarfSingle => \"split-dwarf-single\",\n         }\n     }\n \n@@ -143,6 +147,8 @@ impl CompareMode {\n             \"nll\" => CompareMode::Nll,\n             \"polonius\" => CompareMode::Polonius,\n             \"chalk\" => CompareMode::Chalk,\n+            \"split-dwarf\" => CompareMode::SplitDwarf,\n+            \"split-dwarf-single\" => CompareMode::SplitDwarfSingle,\n             x => panic!(\"unknown --compare-mode option: {}\", x),\n         }\n     }"}, {"sha": "a1be0a19f68546be500721d6a8586d13b4b803af", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ba7ca2bbbff6cd424aebc654308febc00b9497a/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba7ca2bbbff6cd424aebc654308febc00b9497a/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=2ba7ca2bbbff6cd424aebc654308febc00b9497a", "patch": "@@ -852,6 +852,8 @@ impl Config {\n                 Some(CompareMode::Nll) => name == \"compare-mode-nll\",\n                 Some(CompareMode::Polonius) => name == \"compare-mode-polonius\",\n                 Some(CompareMode::Chalk) => name == \"compare-mode-chalk\",\n+                Some(CompareMode::SplitDwarf) => name == \"compare-mode-split-dwarf\",\n+                Some(CompareMode::SplitDwarfSingle) => name == \"compare-mode-split-dwarf-single\",\n                 None => false,\n             } ||\n             (cfg!(debug_assertions) && name == \"debug\") ||"}, {"sha": "828c4e89f0b1fd20e6740a3cc66afd234c3ab928", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ba7ca2bbbff6cd424aebc654308febc00b9497a/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba7ca2bbbff6cd424aebc654308febc00b9497a/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=2ba7ca2bbbff6cd424aebc654308febc00b9497a", "patch": "@@ -2017,6 +2017,12 @@ impl<'test> TestCx<'test> {\n             Some(CompareMode::Chalk) => {\n                 rustc.args(&[\"-Zchalk\"]);\n             }\n+            Some(CompareMode::SplitDwarf) => {\n+                rustc.args(&[\"-Zsplit-dwarf=split\"]);\n+            }\n+            Some(CompareMode::SplitDwarfSingle) => {\n+                rustc.args(&[\"-Zsplit-dwarf=single\"]);\n+            }\n             None => {}\n         }\n "}]}