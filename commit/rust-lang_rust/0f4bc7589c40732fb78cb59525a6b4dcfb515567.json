{"sha": "0f4bc7589c40732fb78cb59525a6b4dcfb515567", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmNGJjNzU4OWM0MDczMmZiNzhjYjU5NTI1YTZiNGRjZmI1MTU1Njc=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-11T12:49:09Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-11T12:49:09Z"}, "message": "Merge #495\n\n495: Fix on type handlers r=matklad a=matklad\n\nLooks like our on type handlers didn't actually worked, this shoud fix that!\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "4ff25038c52dc1767579135bb5387b0fb184c83d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ff25038c52dc1767579135bb5387b0fb184c83d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f4bc7589c40732fb78cb59525a6b4dcfb515567", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f4bc7589c40732fb78cb59525a6b4dcfb515567", "html_url": "https://github.com/rust-lang/rust/commit/0f4bc7589c40732fb78cb59525a6b4dcfb515567", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f4bc7589c40732fb78cb59525a6b4dcfb515567/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "dd122145b57513cf57076ae3235d70215b226039", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd122145b57513cf57076ae3235d70215b226039", "html_url": "https://github.com/rust-lang/rust/commit/dd122145b57513cf57076ae3235d70215b226039"}, {"sha": "a1b661faec69e5c643924bf672ac61ff4ff12202", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1b661faec69e5c643924bf672ac61ff4ff12202", "html_url": "https://github.com/rust-lang/rust/commit/a1b661faec69e5c643924bf672ac61ff4ff12202"}], "stats": {"total": 352, "additions": 174, "deletions": 178}, "files": [{"sha": "3495ad967706d887d67a02c1e2683f3d606efaa9", "filename": "crates/ra_ide_api_light/src/assists.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f4bc7589c40732fb78cb59525a6b4dcfb515567/crates%2Fra_ide_api_light%2Fsrc%2Fassists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4bc7589c40732fb78cb59525a6b4dcfb515567/crates%2Fra_ide_api_light%2Fsrc%2Fassists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Fassists.rs?ref=0f4bc7589c40732fb78cb59525a6b4dcfb515567", "patch": "@@ -15,10 +15,11 @@ use ra_text_edit::{TextEdit, TextEditBuilder};\n use ra_syntax::{\n     Direction, SyntaxNode, TextUnit, TextRange, SourceFile, AstNode,\n     algo::{find_leaf_at_offset, find_node_at_offset, find_covering_node, LeafAtOffset},\n-    ast::{self, AstToken},\n };\n use itertools::Itertools;\n \n+use crate::formatting::leading_indent;\n+\n pub use self::{\n     flip_comma::flip_comma,\n     add_derive::add_derive,\n@@ -165,7 +166,7 @@ impl AssistBuilder {\n     }\n     fn replace_node_and_indent(&mut self, node: &SyntaxNode, replace_with: impl Into<String>) {\n         let mut replace_with = replace_with.into();\n-        if let Some(indent) = calc_indent(node) {\n+        if let Some(indent) = leading_indent(node) {\n             replace_with = reindent(&replace_with, indent)\n         }\n         self.replace(node.range(), replace_with)\n@@ -182,12 +183,6 @@ impl AssistBuilder {\n     }\n }\n \n-fn calc_indent(node: &SyntaxNode) -> Option<&str> {\n-    let prev = node.prev_sibling()?;\n-    let ws_text = ast::Whitespace::cast(prev)?.text();\n-    ws_text.rfind('\\n').map(|pos| &ws_text[pos + 1..])\n-}\n-\n fn reindent(text: &str, indent: &str) -> String {\n     let indent = format!(\"\\n{}\", indent);\n     text.lines().intersperse(&indent).collect()"}, {"sha": "4635fbd605a0897fcb48d481ba238e93c9698707", "filename": "crates/ra_ide_api_light/src/formatting.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f4bc7589c40732fb78cb59525a6b4dcfb515567/crates%2Fra_ide_api_light%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4bc7589c40732fb78cb59525a6b4dcfb515567/crates%2Fra_ide_api_light%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Fformatting.rs?ref=0f4bc7589c40732fb78cb59525a6b4dcfb515567", "patch": "@@ -1,8 +1,16 @@\n use ra_syntax::{\n-    ast, AstNode,\n+    AstNode,\n     SyntaxNode, SyntaxKind::*,\n+    ast::{self, AstToken},\n };\n \n+/// If the node is on the begining of the line, calculate indent.\n+pub(crate) fn leading_indent(node: &SyntaxNode) -> Option<&str> {\n+    let prev = node.prev_sibling()?;\n+    let ws_text = ast::Whitespace::cast(prev)?.text();\n+    ws_text.rfind('\\n').map(|pos| &ws_text[pos + 1..])\n+}\n+\n pub(crate) fn extract_trivial_expression(block: &ast::Block) -> Option<&ast::Expr> {\n     let expr = block.expr()?;\n     if expr.syntax().text().contains('\\n') {"}, {"sha": "c8f3dfe448e5aa4477cfa5f3068ba0caf2cc60ba", "filename": "crates/ra_ide_api_light/src/typing.rs", "status": "modified", "additions": 141, "deletions": 143, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/0f4bc7589c40732fb78cb59525a6b4dcfb515567/crates%2Fra_ide_api_light%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4bc7589c40732fb78cb59525a6b4dcfb515567/crates%2Fra_ide_api_light%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Ftyping.rs?ref=0f4bc7589c40732fb78cb59525a6b4dcfb515567", "patch": "@@ -1,11 +1,11 @@\n use ra_syntax::{\n+    AstNode, SourceFile, SyntaxKind::*,\n+    SyntaxNode, TextUnit, TextRange,\n     algo::{find_node_at_offset, find_leaf_at_offset, LeafAtOffset},\n-    ast,\n-    AstNode, Direction, SourceFile, SyntaxKind::*,\n-    SyntaxNode, TextUnit,\n+    ast::{self, AstToken},\n };\n \n-use crate::{LocalEdit, TextEditBuilder};\n+use crate::{LocalEdit, TextEditBuilder, formatting::leading_indent};\n \n pub fn on_enter(file: &SourceFile, offset: TextUnit) -> Option<LocalEdit> {\n     let comment = find_leaf_at_offset(file.syntax(), offset)\n@@ -53,20 +53,21 @@ fn node_indent<'a>(file: &'a SourceFile, node: &SyntaxNode) -> Option<&'a str> {\n     Some(&text[pos..])\n }\n \n-pub fn on_eq_typed(file: &SourceFile, offset: TextUnit) -> Option<LocalEdit> {\n-    let let_stmt: &ast::LetStmt = find_node_at_offset(file.syntax(), offset)?;\n+pub fn on_eq_typed(file: &SourceFile, eq_offset: TextUnit) -> Option<LocalEdit> {\n+    assert_eq!(file.syntax().text().char_at(eq_offset), Some('='));\n+    let let_stmt: &ast::LetStmt = find_node_at_offset(file.syntax(), eq_offset)?;\n     if let_stmt.has_semi() {\n         return None;\n     }\n     if let Some(expr) = let_stmt.initializer() {\n         let expr_range = expr.syntax().range();\n-        if expr_range.contains(offset) && offset != expr_range.start() {\n+        if expr_range.contains(eq_offset) && eq_offset != expr_range.start() {\n             return None;\n         }\n         if file\n             .syntax()\n             .text()\n-            .slice(offset..expr_range.start())\n+            .slice(eq_offset..expr_range.start())\n             .contains('\\n')\n         {\n             return None;\n@@ -84,54 +85,44 @@ pub fn on_eq_typed(file: &SourceFile, offset: TextUnit) -> Option<LocalEdit> {\n     })\n }\n \n-pub fn on_dot_typed(file: &SourceFile, offset: TextUnit) -> Option<LocalEdit> {\n-    let before_dot_offset = offset - TextUnit::of_char('.');\n+pub fn on_dot_typed(file: &SourceFile, dot_offset: TextUnit) -> Option<LocalEdit> {\n+    assert_eq!(file.syntax().text().char_at(dot_offset), Some('.'));\n \n-    let whitespace = find_leaf_at_offset(file.syntax(), before_dot_offset).left_biased()?;\n-\n-    // find whitespace just left of the dot\n-    ast::Whitespace::cast(whitespace)?;\n-\n-    // make sure there is a method call\n-    let method_call = whitespace\n-        .siblings(Direction::Prev)\n-        // first is whitespace\n-        .skip(1)\n-        .next()?;\n-\n-    ast::MethodCallExpr::cast(method_call)?;\n-\n-    // find how much the _method call is indented\n-    let method_chain_indent = method_call\n-        .parent()?\n-        .siblings(Direction::Prev)\n-        .skip(1)\n-        .next()?\n-        .leaf_text()\n-        .map(|x| last_line_indent_in_whitespace(x))?;\n-\n-    let current_indent = TextUnit::of_str(last_line_indent_in_whitespace(whitespace.leaf_text()?));\n-    // TODO: indent is always 4 spaces now. A better heuristic could look on the previous line(s)\n-\n-    let target_indent = TextUnit::of_str(method_chain_indent) + TextUnit::from_usize(4);\n-\n-    let diff = target_indent - current_indent;\n-\n-    let indent = \"\".repeat(diff.to_usize());\n+    let whitespace = find_leaf_at_offset(file.syntax(), dot_offset)\n+        .left_biased()\n+        .and_then(ast::Whitespace::cast)?;\n \n-    let cursor_position = offset + diff;\n+    let current_indent = {\n+        let text = whitespace.text();\n+        let newline = text.rfind('\\n')?;\n+        &text[newline + 1..]\n+    };\n+    let current_indent_len = TextUnit::of_str(current_indent);\n+\n+    // Make sure dot is a part of call chain\n+    let field_expr = whitespace\n+        .syntax()\n+        .parent()\n+        .and_then(ast::FieldExpr::cast)?;\n+    let prev_indent = leading_indent(field_expr.syntax())?;\n+    let target_indent = format!(\"    {}\", prev_indent);\n+    let target_indent_len = TextUnit::of_str(&target_indent);\n+    if current_indent_len == target_indent_len {\n+        return None;\n+    }\n     let mut edit = TextEditBuilder::default();\n-    edit.insert(before_dot_offset, indent);\n-    Some(LocalEdit {\n-        label: \"indent dot\".to_string(),\n+    edit.replace(\n+        TextRange::from_to(dot_offset - current_indent_len, dot_offset),\n+        target_indent.into(),\n+    );\n+    let res = LocalEdit {\n+        label: \"reindent dot\".to_string(),\n         edit: edit.finish(),\n-        cursor_position: Some(cursor_position),\n-    })\n-}\n-\n-/// Finds the last line in the whitespace\n-fn last_line_indent_in_whitespace(ws: &str) -> &str {\n-    ws.split('\\n').last().unwrap_or(\"\")\n+        cursor_position: Some(\n+            dot_offset + target_indent_len - current_indent_len + TextUnit::of_char('.'),\n+        ),\n+    };\n+    Some(res)\n }\n \n #[cfg(test)]\n@@ -142,12 +133,18 @@ mod tests {\n \n     #[test]\n     fn test_on_eq_typed() {\n-        fn do_check(before: &str, after: &str) {\n+        fn type_eq(before: &str, after: &str) {\n             let (offset, before) = extract_offset(before);\n+            let mut edit = TextEditBuilder::default();\n+            edit.insert(offset, \"=\".to_string());\n+            let before = edit.finish().apply(&before);\n             let file = SourceFile::parse(&before);\n-            let result = on_eq_typed(&file, offset).unwrap();\n-            let actual = result.edit.apply(&before);\n-            assert_eq_text!(after, &actual);\n+            if let Some(result) = on_eq_typed(&file, offset) {\n+                let actual = result.edit.apply(&before);\n+                assert_eq_text!(after, &actual);\n+            } else {\n+                assert_eq_text!(&before, after)\n+            };\n         }\n \n         //     do_check(r\"\n@@ -159,10 +156,10 @@ mod tests {\n         //     let foo =;\n         // }\n         // \");\n-        do_check(\n+        type_eq(\n             r\"\n fn foo() {\n-    let foo =<|> 1 + 1\n+    let foo <|> 1 + 1\n }\n \",\n             r\"\n@@ -184,112 +181,113 @@ fn foo() {\n         // \");\n     }\n \n+    fn type_dot(before: &str, after: &str) {\n+        let (offset, before) = extract_offset(before);\n+        let mut edit = TextEditBuilder::default();\n+        edit.insert(offset, \".\".to_string());\n+        let before = edit.finish().apply(&before);\n+        let file = SourceFile::parse(&before);\n+        if let Some(result) = on_dot_typed(&file, offset) {\n+            let actual = result.edit.apply(&before);\n+            assert_eq_text!(after, &actual);\n+        } else {\n+            assert_eq_text!(&before, after)\n+        };\n+    }\n+\n     #[test]\n-    fn test_on_dot_typed() {\n-        fn do_check(before: &str, after: &str) {\n-            let (offset, before) = extract_offset(before);\n-            let file = SourceFile::parse(&before);\n-            if let Some(result) = on_eq_typed(&file, offset) {\n-                let actual = result.edit.apply(&before);\n-                assert_eq_text!(after, &actual);\n-            };\n-        }\n-        // indent if continuing chain call\n-        do_check(\n+    fn indents_new_chain_call() {\n+        type_dot(\n             r\"\n-    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-        self.child_impl(db, name)\n-        .<|>\n-    }\n-\",\n+            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+                self.child_impl(db, name)\n+                <|>\n+            }\n+            \",\n             r\"\n-    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-        self.child_impl(db, name)\n-            .\n-    }\n-\",\n+            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+                self.child_impl(db, name)\n+                    .\n+            }\n+            \",\n         );\n-\n-        // do not indent if already indented\n-        do_check(\n+        type_dot(\n             r\"\n-    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-        self.child_impl(db, name)\n-            .<|>\n-    }\n-\",\n+            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+                self.child_impl(db, name)\n+                    <|>\n+            }\n+            \",\n             r\"\n-    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-        self.child_impl(db, name)\n-            .\n+            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+                self.child_impl(db, name)\n+                    .\n+            }\n+            \",\n+        )\n     }\n-\",\n-        );\n \n-        // indent if the previous line is already indented\n-        do_check(\n+    #[test]\n+    fn indents_continued_chain_call() {\n+        type_dot(\n             r\"\n-    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-        self.child_impl(db, name)\n-            .first()\n-        .<|>\n-    }\n-\",\n+            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+                self.child_impl(db, name)\n+                    .first()\n+                <|>\n+            }\n+            \",\n             r\"\n-    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-        self.child_impl(db, name)\n-            .first()\n-            .\n-    }\n-\",\n+            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+                self.child_impl(db, name)\n+                    .first()\n+                    .\n+            }\n+            \",\n         );\n-\n-        // don't indent if indent matches previous line\n-        do_check(\n+        type_dot(\n             r\"\n-    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-        self.child_impl(db, name)\n-            .first()\n-            .<|>\n-    }\n-\",\n+            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+                self.child_impl(db, name)\n+                    .first()\n+                    <|>\n+            }\n+            \",\n             r\"\n-    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-        self.child_impl(db, name)\n-            .first()\n-            .\n-    }\n-\",\n+            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+                self.child_impl(db, name)\n+                    .first()\n+                    .\n+            }\n+            \",\n         );\n+    }\n \n-        // don't indent if there is no method call on previous line\n-        do_check(\n+    #[test]\n+    fn dont_indent_freestanding_dot() {\n+        type_dot(\n             r\"\n-    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-        .<|>\n-    }\n-\",\n+            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+                <|>\n+            }\n+            \",\n             r\"\n-    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-        .\n-    }\n-\",\n+            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+                .\n+            }\n+            \",\n         );\n-\n-        // indent to match previous expr\n-        do_check(\n+        type_dot(\n             r\"\n-    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-        self.child_impl(db, name)\n-.<|>\n-    }\n-\",\n+            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n+            <|>\n+            }\n+            \",\n             r\"\n-    pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-        self.child_impl(db, name)\n+            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n             .\n-    }\n-\",\n+            }\n+            \",\n         );\n     }\n "}, {"sha": "5f4b2714960e891131c087ea4f867d83618e3fd5", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0f4bc7589c40732fb78cb59525a6b4dcfb515567/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4bc7589c40732fb78cb59525a6b4dcfb515567/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=0f4bc7589c40732fb78cb59525a6b4dcfb515567", "patch": "@@ -9,7 +9,7 @@ use languageserver_types::{\n     SignatureInformation, SymbolInformation, TextDocumentIdentifier, TextEdit, WorkspaceEdit,\n };\n use ra_ide_api::{\n-    FileId, FilePosition, FileRange, FoldKind, Query, RunnableKind, Severity, SourceChange,\n+    FileId, FilePosition, FileRange, FoldKind, Query, RunnableKind, Severity,\n };\n use ra_syntax::{TextUnit, AstNode};\n use rustc_hash::FxHashMap;\n@@ -92,35 +92,30 @@ pub fn handle_on_type_formatting(\n     world: ServerWorld,\n     params: req::DocumentOnTypeFormattingParams,\n ) -> Result<Option<Vec<TextEdit>>> {\n-    let analysis: Option<Box<Fn(FilePosition) -> Option<SourceChange>>> = match params.ch.as_str() {\n-        \"=\" => Some(Box::new(|pos| world.analysis().on_eq_typed(pos))),\n-        \".\" => Some(Box::new(|pos| world.analysis().on_dot_typed(pos))),\n-        _ => None,\n+    let file_id = params.text_document.try_conv_with(&world)?;\n+    let line_index = world.analysis().file_line_index(file_id);\n+    let position = FilePosition {\n+        file_id,\n+        /// in `ra_ide_api`, the `on_type` invariant is that\n+        /// `text.char_at(position) == typed_char`.\n+        offset: params.position.conv_with(&line_index) - TextUnit::of_char('.'),\n     };\n \n-    if let Some(ana) = analysis {\n-        let file_id = params.text_document.try_conv_with(&world)?;\n-        let line_index = world.analysis().file_line_index(file_id);\n-        let position = FilePosition {\n-            file_id,\n-            offset: params.position.conv_with(&line_index),\n-        };\n+    let edit = match params.ch.as_str() {\n+        \"=\" => world.analysis().on_eq_typed(position),\n+        \".\" => world.analysis().on_dot_typed(position),\n+        _ => return Ok(None),\n+    };\n+    let mut edit = match edit {\n+        Some(it) => it,\n+        None => return Ok(None),\n+    };\n \n-        if let Some(mut action) = ana(position) {\n-            let change: Vec<TextEdit> = action\n-                .source_file_edits\n-                .pop()\n-                .unwrap()\n-                .edit\n-                .as_atoms()\n-                .iter()\n-                .map_conv_with(&line_index)\n-                .collect();\n-            return Ok(Some(change));\n-        }\n-    }\n+    // This should be a single-file edit\n+    let edit = edit.source_file_edits.pop().unwrap();\n \n-    return Ok(None);\n+    let change: Vec<TextEdit> = edit.edit.conv_with(&line_index);\n+    return Ok(Some(change));\n }\n \n pub fn handle_document_symbol("}]}