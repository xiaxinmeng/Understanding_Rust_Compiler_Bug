{"sha": "ffdcf7486656119328c3c6c1efef408abba3139f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmZGNmNzQ4NjY1NjExOTMyOGMzYzZjMWVmZWY0MDhhYmJhMzEzOWY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-03-08T19:15:12Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-03-10T16:21:45Z"}, "message": "resolve: Use path segment spans in smart_resolve_path", "tree": {"sha": "7a4e50d67be642a9c1ccb9c4b59ed756dc9128c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a4e50d67be642a9c1ccb9c4b59ed756dc9128c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffdcf7486656119328c3c6c1efef408abba3139f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffdcf7486656119328c3c6c1efef408abba3139f", "html_url": "https://github.com/rust-lang/rust/commit/ffdcf7486656119328c3c6c1efef408abba3139f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffdcf7486656119328c3c6c1efef408abba3139f/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32575a0487a2086ca7b15a0ca2565efc60bdc0c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/32575a0487a2086ca7b15a0ca2565efc60bdc0c3", "html_url": "https://github.com/rust-lang/rust/commit/32575a0487a2086ca7b15a0ca2565efc60bdc0c3"}], "stats": {"total": 111, "additions": 64, "deletions": 47}, "files": [{"sha": "99061747832ec988b38cbcc0378f1e0b40b91b24", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ffdcf7486656119328c3c6c1efef408abba3139f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffdcf7486656119328c3c6c1efef408abba3139f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ffdcf7486656119328c3c6c1efef408abba3139f", "patch": "@@ -407,7 +407,7 @@ enum PathSource<'a> {\n     // Trait paths in bounds or impls.\n     Trait,\n     // Expression paths `path`, with optional parent context.\n-    Expr(Option<&'a ExprKind>),\n+    Expr(Option<&'a Expr>),\n     // Paths in path patterns `Path`.\n     Pat,\n     // Paths in struct expressions and patterns `Path { .. }`.\n@@ -464,7 +464,7 @@ impl<'a> PathSource<'a> {\n                 ValueNS => \"method or associated constant\",\n                 MacroNS => bug!(\"associated macro\"),\n             },\n-            PathSource::Expr(parent) => match parent {\n+            PathSource::Expr(parent) => match parent.map(|p| &p.node) {\n                 // \"function\" here means \"anything callable\" rather than `Def::Fn`,\n                 // this is not precise but usually more helpful than just \"value\".\n                 Some(&ExprKind::Call(..)) => \"function\",\n@@ -2194,14 +2194,16 @@ impl<'a> Resolver<'a> {\n                           source: PathSource)\n                           -> PathResolution {\n         let segments = &path.segments.iter().map(|seg| seg.identifier).collect::<Vec<_>>();\n-        self.smart_resolve_path_fragment(id, qself, segments, path.span, source)\n+        let ident_span = path.segments.last().map_or(path.span, |seg| seg.span);\n+        self.smart_resolve_path_fragment(id, qself, segments, path.span, ident_span, source)\n     }\n \n     fn smart_resolve_path_fragment(&mut self,\n                                    id: NodeId,\n                                    qself: Option<&QSelf>,\n                                    path: &[Ident],\n                                    span: Span,\n+                                   ident_span: Span,\n                                    source: PathSource)\n                                    -> PathResolution {\n         let ns = source.namespace();\n@@ -2213,9 +2215,9 @@ impl<'a> Resolver<'a> {\n             let expected = source.descr_expected();\n             let path_str = names_to_string(path);\n             let code = source.error_code(def.is_some());\n-            let (base_msg, fallback_label) = if let Some(def) = def {\n+            let (base_msg, fallback_label, base_span) = if let Some(def) = def {\n                 (format!(\"expected {}, found {} `{}`\", expected, def.kind_name(), path_str),\n-                 format!(\"not a {}\", expected))\n+                 format!(\"not a {}\", expected), span)\n             } else {\n                 let item_str = path[path.len() - 1];\n                 let (mod_prefix, mod_str) = if path.len() == 1 {\n@@ -2231,9 +2233,9 @@ impl<'a> Resolver<'a> {\n                     (mod_prefix, format!(\"`{}`\", names_to_string(mod_path)))\n                 };\n                 (format!(\"cannot find {} `{}` in {}{}\", expected, item_str, mod_prefix, mod_str),\n-                 format!(\"not found in {}\", mod_str))\n+                 format!(\"not found in {}\", mod_str), ident_span)\n             };\n-            let mut err = this.session.struct_span_err_with_code(span, &base_msg, code);\n+            let mut err = this.session.struct_span_err_with_code(base_span, &base_msg, code);\n \n             // Emit special messages for unresolved `Self` and `self`.\n             if is_self_type(path, ns) {\n@@ -2291,15 +2293,15 @@ impl<'a> Resolver<'a> {\n                         err.span_label(span, &format!(\"type aliases cannot be used for traits\"));\n                         return err;\n                     }\n-                    (Def::Mod(..), PathSource::Expr(Some(parent))) => match *parent {\n+                    (Def::Mod(..), PathSource::Expr(Some(parent))) => match parent.node {\n                         ExprKind::Field(_, ident) => {\n-                            err.span_label(span, &format!(\"did you mean `{}::{}`?\",\n-                                                           path_str, ident.node));\n+                            err.span_label(parent.span, &format!(\"did you mean `{}::{}`?\",\n+                                                                 path_str, ident.node));\n                             return err;\n                         }\n                         ExprKind::MethodCall(ident, ..) => {\n-                            err.span_label(span, &format!(\"did you mean `{}::{}(...)`?\",\n-                                                           path_str, ident.node));\n+                            err.span_label(parent.span, &format!(\"did you mean `{}::{}(...)`?\",\n+                                                                 path_str, ident.node));\n                             return err;\n                         }\n                         _ => {}\n@@ -2324,12 +2326,12 @@ impl<'a> Resolver<'a> {\n \n             // Try Levenshtein if nothing else worked.\n             if let Some(candidate) = this.lookup_typo_candidate(path, ns, is_expected) {\n-                err.span_label(span, &format!(\"did you mean `{}`?\", candidate));\n+                err.span_label(ident_span, &format!(\"did you mean `{}`?\", candidate));\n                 return err;\n             }\n \n             // Fallback label.\n-            err.span_label(span, &fallback_label);\n+            err.span_label(base_span, &fallback_label);\n             err\n         };\n         let report_errors = |this: &mut Self, def: Option<Def>| {\n@@ -2449,7 +2451,7 @@ impl<'a> Resolver<'a> {\n             // Make sure `A::B` in `<T as A>::B::C` is a trait item.\n             let ns = if qself.position + 1 == path.len() { ns } else { TypeNS };\n             let res = self.smart_resolve_path_fragment(id, None, &path[..qself.position + 1],\n-                                                       span, PathSource::TraitItem(ns));\n+                                                       span, span, PathSource::TraitItem(ns));\n             return Some(PathResolution::with_unresolved_segments(\n                 res.base_def(), res.unresolved_segments() + path.len() - qself.position - 1\n             ));\n@@ -2807,7 +2809,7 @@ impl<'a> Resolver<'a> {\n                                        path: &[Ident],\n                                        ns: Namespace,\n                                        filter_fn: FilterFn)\n-                                       -> Option<String>\n+                                       -> Option<Symbol>\n         where FilterFn: Fn(Def) -> bool\n     {\n         let add_module_candidates = |module: Module, names: &mut Vec<Name>| {\n@@ -2821,7 +2823,7 @@ impl<'a> Resolver<'a> {\n         };\n \n         let mut names = Vec::new();\n-        let prefix_str = if path.len() == 1 {\n+        if path.len() == 1 {\n             // Search in lexical scope.\n             // Walk backwards up the ribs in scope and collect candidates.\n             for rib in self.ribs[ns].iter().rev() {\n@@ -2855,21 +2857,19 @@ impl<'a> Resolver<'a> {\n                     names.push(*name);\n                 }\n             }\n-            String::new()\n         } else {\n             // Search in module.\n             let mod_path = &path[..path.len() - 1];\n             if let PathResult::Module(module) = self.resolve_path(mod_path, Some(TypeNS), None) {\n                 add_module_candidates(module, &mut names);\n             }\n-            names_to_string(mod_path) + \"::\"\n-        };\n+        }\n \n         let name = path[path.len() - 1].name;\n         // Make sure error reporting is deterministic.\n         names.sort_by_key(|name| name.as_str());\n         match find_best_match_for_name(names.iter(), &name.as_str(), None) {\n-            Some(found) if found != name => Some(format!(\"{}{}\", prefix_str, found)),\n+            Some(found) if found != name => Some(found),\n             _ => None,\n         }\n     }\n@@ -2892,7 +2892,7 @@ impl<'a> Resolver<'a> {\n         self.with_resolved_label(label, id, |this| this.visit_block(block));\n     }\n \n-    fn resolve_expr(&mut self, expr: &Expr, parent: Option<&ExprKind>) {\n+    fn resolve_expr(&mut self, expr: &Expr, parent: Option<&Expr>) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call.\n \n@@ -2973,11 +2973,11 @@ impl<'a> Resolver<'a> {\n \n             // Equivalent to `visit::walk_expr` + passing some context to children.\n             ExprKind::Field(ref subexpression, _) => {\n-                self.resolve_expr(subexpression, Some(&expr.node));\n+                self.resolve_expr(subexpression, Some(expr));\n             }\n             ExprKind::MethodCall(_, ref types, ref arguments) => {\n                 let mut arguments = arguments.iter();\n-                self.resolve_expr(arguments.next().unwrap(), Some(&expr.node));\n+                self.resolve_expr(arguments.next().unwrap(), Some(expr));\n                 for argument in arguments {\n                     self.resolve_expr(argument, None);\n                 }\n@@ -2993,7 +2993,7 @@ impl<'a> Resolver<'a> {\n                 });\n             }\n             ExprKind::Call(ref callee, ref arguments) => {\n-                self.resolve_expr(callee, Some(&expr.node));\n+                self.resolve_expr(callee, Some(expr));\n                 for argument in arguments {\n                     self.resolve_expr(argument, None);\n                 }"}, {"sha": "9d4779a06baf62b6c877451f4e7dfa4e7db92398", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ffdcf7486656119328c3c6c1efef408abba3139f/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffdcf7486656119328c3c6c1efef408abba3139f/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=ffdcf7486656119328c3c6c1efef408abba3139f", "patch": "@@ -502,7 +502,6 @@ impl<'a> Resolver<'a> {\n             };\n             let ident = Ident::from_str(name);\n             self.lookup_typo_candidate(&vec![ident], MacroNS, is_macro)\n-                .as_ref().map(|s| Symbol::intern(s))\n         });\n \n         if let Some(suggestion) = suggestion {"}, {"sha": "dd04c5ce356c626224f5eda92cbc93e69edc4d5c", "filename": "src/test/ui/resolve/enums-are-namespaced-xc.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ffdcf7486656119328c3c6c1efef408abba3139f/src%2Ftest%2Fui%2Fresolve%2Fenums-are-namespaced-xc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ffdcf7486656119328c3c6c1efef408abba3139f/src%2Ftest%2Fui%2Fresolve%2Fenums-are-namespaced-xc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fenums-are-namespaced-xc.stderr?ref=ffdcf7486656119328c3c6c1efef408abba3139f", "patch": "@@ -1,26 +1,26 @@\n error[E0425]: cannot find value `A` in module `namespaced_enums`\n-  --> $DIR/enums-are-namespaced-xc.rs:15:13\n+  --> $DIR/enums-are-namespaced-xc.rs:15:31\n    |\n 15 |     let _ = namespaced_enums::A;\n-   |             ^^^^^^^^^^^^^^^^^^^ not found in `namespaced_enums`\n+   |                               ^ not found in `namespaced_enums`\n    |\n    = help: possible candidate is found in another module, you can import it into scope:\n              `use namespaced_enums::Foo::A;`\n \n error[E0425]: cannot find function `B` in module `namespaced_enums`\n-  --> $DIR/enums-are-namespaced-xc.rs:18:13\n+  --> $DIR/enums-are-namespaced-xc.rs:18:31\n    |\n 18 |     let _ = namespaced_enums::B(10);\n-   |             ^^^^^^^^^^^^^^^^^^^ not found in `namespaced_enums`\n+   |                               ^ not found in `namespaced_enums`\n    |\n    = help: possible candidate is found in another module, you can import it into scope:\n              `use namespaced_enums::Foo::B;`\n \n error[E0422]: cannot find struct, variant or union type `C` in module `namespaced_enums`\n-  --> $DIR/enums-are-namespaced-xc.rs:21:13\n+  --> $DIR/enums-are-namespaced-xc.rs:21:31\n    |\n 21 |     let _ = namespaced_enums::C { a: 10 };\n-   |             ^^^^^^^^^^^^^^^^^^^ not found in `namespaced_enums`\n+   |                               ^ not found in `namespaced_enums`\n    |\n    = help: possible candidate is found in another module, you can import it into scope:\n              `use namespaced_enums::Foo::C;`"}, {"sha": "4dff2620319e4607dcee7cf5fe92c79bd922a8ab", "filename": "src/test/ui/resolve/levenshtein.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ffdcf7486656119328c3c6c1efef408abba3139f/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ffdcf7486656119328c3c6c1efef408abba3139f/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr?ref=ffdcf7486656119328c3c6c1efef408abba3139f", "patch": "@@ -14,7 +14,7 @@ error[E0412]: cannot find type `Opiton` in this scope\n   --> $DIR/levenshtein.rs:20:10\n    |\n 20 | type B = Opiton<u8>; // Misspelled type name from the prelude.\n-   |          ^^^^^^^^^^ did you mean `Option`?\n+   |          ^^^^^^ did you mean `Option`?\n \n error[E0412]: cannot find type `Baz` in this scope\n   --> $DIR/levenshtein.rs:23:14\n@@ -35,16 +35,16 @@ error[E0425]: cannot find function `foobar` in this scope\n    |     ^^^^^^ did you mean `foo_bar`?\n \n error[E0412]: cannot find type `first` in module `m`\n-  --> $DIR/levenshtein.rs:32:12\n+  --> $DIR/levenshtein.rs:32:15\n    |\n 32 |     let b: m::first = m::second; // Misspelled item in module.\n-   |            ^^^^^^^^ did you mean `m::First`?\n+   |               ^^^^^ did you mean `First`?\n \n error[E0425]: cannot find value `second` in module `m`\n-  --> $DIR/levenshtein.rs:32:23\n+  --> $DIR/levenshtein.rs:32:26\n    |\n 32 |     let b: m::first = m::second; // Misspelled item in module.\n-   |                       ^^^^^^^^^ did you mean `m::Second`?\n+   |                          ^^^^^^ did you mean `Second`?\n \n error: aborting due to 8 previous errors\n "}, {"sha": "85fb1777dea233abf7e71dd53e577a29a7ba84b5", "filename": "src/test/ui/resolve/suggest-path-instead-of-mod-dot-item.stderr", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ffdcf7486656119328c3c6c1efef408abba3139f/src%2Ftest%2Fui%2Fresolve%2Fsuggest-path-instead-of-mod-dot-item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ffdcf7486656119328c3c6c1efef408abba3139f/src%2Ftest%2Fui%2Fresolve%2Fsuggest-path-instead-of-mod-dot-item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fsuggest-path-instead-of-mod-dot-item.stderr?ref=ffdcf7486656119328c3c6c1efef408abba3139f", "patch": "@@ -2,55 +2,73 @@ error[E0423]: expected value, found module `a`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:27:5\n    |\n 27 |     a.I\n-   |     ^ did you mean `a::I`?\n+   |     ^--\n+   |     |\n+   |     did you mean `a::I`?\n \n error[E0423]: expected value, found module `a`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:33:5\n    |\n 33 |     a.g()\n-   |     ^ did you mean `a::g(...)`?\n+   |     ^----\n+   |     |\n+   |     did you mean `a::g(...)`?\n \n error[E0423]: expected value, found module `a`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:39:5\n    |\n 39 |     a.b.J\n-   |     ^ did you mean `a::b`?\n+   |     ^--\n+   |     |\n+   |     did you mean `a::b`?\n \n error[E0423]: expected value, found module `a::b`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:45:5\n    |\n 45 |     a::b.J\n-   |     ^^^^ did you mean `a::b::J`?\n+   |     ^^^^--\n+   |     |\n+   |     did you mean `a::b::J`?\n \n error[E0423]: expected value, found module `a`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:51:5\n    |\n 51 |     a.b.f();\n-   |     ^ did you mean `a::b`?\n+   |     ^--\n+   |     |\n+   |     did you mean `a::b`?\n \n error[E0423]: expected value, found module `a::b`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:55:12\n    |\n 55 |     v.push(a::b);\n-   |            ^^^^ did you mean `a::I`?\n+   |            ^^^-\n+   |               |\n+   |               did you mean `I`?\n \n error[E0423]: expected value, found module `a::b`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:61:5\n    |\n 61 |     a::b.f()\n-   |     ^^^^ did you mean `a::b::f(...)`?\n+   |     ^^^^----\n+   |     |\n+   |     did you mean `a::b::f(...)`?\n \n error[E0423]: expected value, found module `a::b`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:67:5\n    |\n 67 |     a::b\n-   |     ^^^^ did you mean `a::I`?\n+   |     ^^^-\n+   |        |\n+   |        did you mean `I`?\n \n error[E0423]: expected function, found module `a::b`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:73:5\n    |\n 73 |     a::b()\n-   |     ^^^^ did you mean `a::I`?\n+   |     ^^^-\n+   |        |\n+   |        did you mean `I`?\n \n error: main function not found\n "}, {"sha": "015dbfc3dc775fe509d4ac8e7bef1b8748332212", "filename": "src/test/ui/resolve/unboxed-closure-sugar-nonexistent-trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ffdcf7486656119328c3c6c1efef408abba3139f/src%2Ftest%2Fui%2Fresolve%2Funboxed-closure-sugar-nonexistent-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ffdcf7486656119328c3c6c1efef408abba3139f/src%2Ftest%2Fui%2Fresolve%2Funboxed-closure-sugar-nonexistent-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Funboxed-closure-sugar-nonexistent-trait.stderr?ref=ffdcf7486656119328c3c6c1efef408abba3139f", "patch": "@@ -2,7 +2,7 @@ error[E0405]: cannot find trait `Nonexist` in this scope\n   --> $DIR/unboxed-closure-sugar-nonexistent-trait.rs:11:8\n    |\n 11 | fn f<F:Nonexist(isize) -> isize>(x: F) {}\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n+   |        ^^^^^^^^ not found in this scope\n \n error[E0404]: expected trait, found type alias `Typedef`\n   --> $DIR/unboxed-closure-sugar-nonexistent-trait.rs:17:8"}]}