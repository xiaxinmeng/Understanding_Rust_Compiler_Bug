{"sha": "76572e67eabffa959c665f8450dbb12d71848aba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2NTcyZTY3ZWFiZmZhOTU5YzY2NWY4NDUwZGJiMTJkNzE4NDhhYmE=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-16T15:42:36Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-16T15:42:36Z"}, "message": "Merge #976\n\n976: Replace Display by a pretty printing trait for Ty r=matklad a=flodiebold\n\nThis allows removing the names from Adt and FnDef (and more later), as a first\r\nstep towards aligning more with chalk's Ty :)\r\n\r\nI may have gone a bit overboard with the definition of the PrettyPrint trait...\n\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>", "tree": {"sha": "c293e134706908ddc54400dee029271ec9859692", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c293e134706908ddc54400dee029271ec9859692"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76572e67eabffa959c665f8450dbb12d71848aba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76572e67eabffa959c665f8450dbb12d71848aba", "html_url": "https://github.com/rust-lang/rust/commit/76572e67eabffa959c665f8450dbb12d71848aba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76572e67eabffa959c665f8450dbb12d71848aba/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "b6ddf976f1b00703a35b91a5aa04debf19b7ca25", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6ddf976f1b00703a35b91a5aa04debf19b7ca25", "html_url": "https://github.com/rust-lang/rust/commit/b6ddf976f1b00703a35b91a5aa04debf19b7ca25"}, {"sha": "c5ee60e05b1fafe20f56b21cfab30e7b80cb9d42", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5ee60e05b1fafe20f56b21cfab30e7b80cb9d42", "html_url": "https://github.com/rust-lang/rust/commit/c5ee60e05b1fafe20f56b21cfab30e7b80cb9d42"}], "stats": {"total": 196, "additions": 136, "deletions": 60}, "files": [{"sha": "4508a873e10e3dd9e441e552a0c5ec0719bb679a", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76572e67eabffa959c665f8450dbb12d71848aba/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76572e67eabffa959c665f8450dbb12d71848aba/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=76572e67eabffa959c665f8450dbb12d71848aba", "patch": "@@ -56,7 +56,7 @@ pub use self::{\n     ids::{HirFileId, MacroCallId, MacroCallLoc, HirInterner},\n     macros::{MacroDef, MacroInput, MacroExpansion},\n     nameres::{ItemMap, PerNs, Namespace},\n-    ty::{Ty, Substs},\n+    ty::{Ty, Substs, display::HirDisplay},\n     impl_block::{ImplBlock, ImplItem},\n     docs::{Docs, Documentation},\n     adt::AdtDef,"}, {"sha": "f64877f3b0e6be503b533946558462bfed0122cb", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 60, "deletions": 34, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/76572e67eabffa959c665f8450dbb12d71848aba/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76572e67eabffa959c665f8450dbb12d71848aba/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=76572e67eabffa959c665f8450dbb12d71848aba", "patch": "@@ -9,16 +9,16 @@ pub(crate) mod method_resolution;\n mod op;\n mod lower;\n mod infer;\n+pub(crate) mod display;\n \n use std::sync::Arc;\n use std::{fmt, mem};\n \n-use join_to_string::join;\n-\n-use crate::{Name, AdtDef, type_ref::Mutability};\n+use crate::{Name, AdtDef, type_ref::Mutability, db::HirDatabase};\n \n pub(crate) use lower::{TypableDef, CallableDef, type_for_def, type_for_field};\n pub(crate) use infer::{infer, InferenceResult, InferTy};\n+use display::{HirDisplay, HirFormatter};\n \n /// A type. This is based on the `TyKind` enum in rustc (librustc/ty/sty.rs).\n ///\n@@ -42,8 +42,6 @@ pub enum Ty {\n     Adt {\n         /// The definition of the struct/enum.\n         def_id: AdtDef,\n-        /// The name, for displaying.\n-        name: Name,\n         /// Substitutions for the generic parameters of the type.\n         substs: Substs,\n     },\n@@ -79,8 +77,6 @@ pub enum Ty {\n     FnDef {\n         /// The definition of the function / constructor.\n         def: CallableDef,\n-        /// For display\n-        name: Name,\n         /// Parameters and return type\n         sig: Arc<FnSig>,\n         /// Substitutions for the generic parameters of the type\n@@ -265,8 +261,8 @@ impl Ty {\n     /// `Option<u32>` afterwards.)\n     pub fn apply_substs(self, substs: Substs) -> Ty {\n         match self {\n-            Ty::Adt { def_id, name, .. } => Ty::Adt { def_id, name, substs },\n-            Ty::FnDef { def, name, sig, .. } => Ty::FnDef { def, name, sig, substs },\n+            Ty::Adt { def_id, .. } => Ty::Adt { def_id, substs },\n+            Ty::FnDef { def, sig, .. } => Ty::FnDef { def, sig, substs },\n             _ => self,\n         }\n     }\n@@ -297,50 +293,80 @@ impl Ty {\n     }\n }\n \n-impl fmt::Display for Ty {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+impl HirDisplay for &Ty {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        HirDisplay::hir_fmt(*self, f)\n+    }\n+}\n+\n+impl HirDisplay for Ty {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n         match self {\n-            Ty::Bool => write!(f, \"bool\"),\n-            Ty::Char => write!(f, \"char\"),\n-            Ty::Int(t) => write!(f, \"{}\", t.ty_to_string()),\n-            Ty::Float(t) => write!(f, \"{}\", t.ty_to_string()),\n-            Ty::Str => write!(f, \"str\"),\n-            Ty::Slice(t) | Ty::Array(t) => write!(f, \"[{}]\", t),\n-            Ty::RawPtr(t, m) => write!(f, \"*{}{}\", m.as_keyword_for_ptr(), t),\n-            Ty::Ref(t, m) => write!(f, \"&{}{}\", m.as_keyword_for_ref(), t),\n-            Ty::Never => write!(f, \"!\"),\n+            Ty::Bool => write!(f, \"bool\")?,\n+            Ty::Char => write!(f, \"char\")?,\n+            Ty::Int(t) => write!(f, \"{}\", t.ty_to_string())?,\n+            Ty::Float(t) => write!(f, \"{}\", t.ty_to_string())?,\n+            Ty::Str => write!(f, \"str\")?,\n+            Ty::Slice(t) | Ty::Array(t) => {\n+                write!(f, \"[{}]\", t.display(f.db))?;\n+            }\n+            Ty::RawPtr(t, m) => {\n+                write!(f, \"*{}{}\", m.as_keyword_for_ptr(), t.display(f.db))?;\n+            }\n+            Ty::Ref(t, m) => {\n+                write!(f, \"&{}{}\", m.as_keyword_for_ref(), t.display(f.db))?;\n+            }\n+            Ty::Never => write!(f, \"!\")?,\n             Ty::Tuple(ts) => {\n                 if ts.len() == 1 {\n-                    write!(f, \"({},)\", ts[0])\n+                    write!(f, \"({},)\", ts[0].display(f.db))?;\n                 } else {\n-                    join(ts.iter()).surround_with(\"(\", \")\").separator(\", \").to_fmt(f)\n+                    write!(f, \"(\")?;\n+                    f.write_joined(&**ts, \", \")?;\n+                    write!(f, \")\")?;\n                 }\n             }\n             Ty::FnPtr(sig) => {\n-                join(sig.input.iter()).surround_with(\"fn(\", \")\").separator(\", \").to_fmt(f)?;\n-                write!(f, \" -> {}\", sig.output)\n+                write!(f, \"fn(\")?;\n+                f.write_joined(&sig.input, \", \")?;\n+                write!(f, \") -> {}\", sig.output.display(f.db))?;\n             }\n-            Ty::FnDef { def, name, substs, sig, .. } => {\n+            Ty::FnDef { def, substs, sig, .. } => {\n+                let name = match def {\n+                    CallableDef::Function(ff) => ff.name(f.db),\n+                    CallableDef::Struct(s) => s.name(f.db).unwrap_or_else(Name::missing),\n+                    CallableDef::EnumVariant(e) => e.name(f.db).unwrap_or_else(Name::missing),\n+                };\n                 match def {\n                     CallableDef::Function(_) => write!(f, \"fn {}\", name)?,\n                     CallableDef::Struct(_) | CallableDef::EnumVariant(_) => write!(f, \"{}\", name)?,\n                 }\n                 if substs.0.len() > 0 {\n-                    join(substs.0.iter()).surround_with(\"<\", \">\").separator(\", \").to_fmt(f)?;\n+                    write!(f, \"<\")?;\n+                    f.write_joined(&*substs.0, \", \")?;\n+                    write!(f, \">\")?;\n                 }\n-                join(sig.input.iter()).surround_with(\"(\", \")\").separator(\", \").to_fmt(f)?;\n-                write!(f, \" -> {}\", sig.output)\n+                write!(f, \"(\")?;\n+                f.write_joined(&sig.input, \", \")?;\n+                write!(f, \") -> {}\", sig.output.display(f.db))?;\n             }\n-            Ty::Adt { name, substs, .. } => {\n+            Ty::Adt { def_id, substs, .. } => {\n+                let name = match def_id {\n+                    AdtDef::Struct(s) => s.name(f.db),\n+                    AdtDef::Enum(e) => e.name(f.db),\n+                }\n+                .unwrap_or_else(Name::missing);\n                 write!(f, \"{}\", name)?;\n                 if substs.0.len() > 0 {\n-                    join(substs.0.iter()).surround_with(\"<\", \">\").separator(\", \").to_fmt(f)?;\n+                    write!(f, \"<\")?;\n+                    f.write_joined(&*substs.0, \", \")?;\n+                    write!(f, \">\")?;\n                 }\n-                Ok(())\n             }\n-            Ty::Param { name, .. } => write!(f, \"{}\", name),\n-            Ty::Unknown => write!(f, \"{{unknown}}\"),\n-            Ty::Infer(..) => write!(f, \"_\"),\n+            Ty::Param { name, .. } => write!(f, \"{}\", name)?,\n+            Ty::Unknown => write!(f, \"{{unknown}}\")?,\n+            Ty::Infer(..) => write!(f, \"_\")?,\n         }\n+        Ok(())\n     }\n }"}, {"sha": "63ec9d7e1d8b0a13bed3e0ec4a07705f86230415", "filename": "crates/ra_hir/src/ty/display.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/76572e67eabffa959c665f8450dbb12d71848aba/crates%2Fra_hir%2Fsrc%2Fty%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76572e67eabffa959c665f8450dbb12d71848aba/crates%2Fra_hir%2Fsrc%2Fty%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fdisplay.rs?ref=76572e67eabffa959c665f8450dbb12d71848aba", "patch": "@@ -0,0 +1,56 @@\n+use std::fmt;\n+\n+use crate::db::HirDatabase;\n+\n+pub struct HirFormatter<'a, 'b, DB> {\n+    pub db: &'a DB,\n+    fmt: &'a mut fmt::Formatter<'b>,\n+}\n+\n+pub trait HirDisplay {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result;\n+    fn display<'a, DB>(&'a self, db: &'a DB) -> HirDisplayWrapper<'a, DB, Self>\n+    where\n+        Self: Sized,\n+    {\n+        HirDisplayWrapper(db, self)\n+    }\n+}\n+\n+impl<'a, 'b, DB> HirFormatter<'a, 'b, DB>\n+where\n+    DB: HirDatabase,\n+{\n+    pub fn write_joined<T: HirDisplay>(\n+        &mut self,\n+        iter: impl IntoIterator<Item = T>,\n+        sep: &str,\n+    ) -> fmt::Result {\n+        let mut first = true;\n+        for e in iter {\n+            if !first {\n+                write!(self, \"{}\", sep)?;\n+            }\n+            first = false;\n+            e.hir_fmt(self)?;\n+        }\n+        Ok(())\n+    }\n+\n+    /// This allows using the `write!` macro directly with a `HirFormatter`.\n+    pub fn write_fmt(&mut self, args: fmt::Arguments) -> fmt::Result {\n+        fmt::write(self.fmt, args)\n+    }\n+}\n+\n+pub struct HirDisplayWrapper<'a, DB, T>(&'a DB, &'a T);\n+\n+impl<'a, DB, T> fmt::Display for HirDisplayWrapper<'a, DB, T>\n+where\n+    DB: HirDatabase,\n+    T: HirDisplay,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.1.hir_fmt(&mut HirFormatter { db: self.0, fmt: f })\n+    }\n+}"}, {"sha": "ee4508bb26286915b06b494a95a07d0dda3d9c50", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/76572e67eabffa959c665f8450dbb12d71848aba/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76572e67eabffa959c665f8450dbb12d71848aba/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=76572e67eabffa959c665f8450dbb12d71848aba", "patch": "@@ -9,7 +9,7 @@\n use std::sync::Arc;\n \n use crate::{\n-    Function, Struct, StructField, Enum, EnumVariant, Path, Name,\n+    Function, Struct, StructField, Enum, EnumVariant, Path,\n     ModuleDef, TypeAlias,\n     Const, Static,\n     HirDatabase,\n@@ -232,13 +232,12 @@ fn type_for_fn(db: &impl HirDatabase, def: Function) -> Ty {\n     let signature = def.signature(db);\n     let resolver = def.resolver(db);\n     let generics = def.generic_params(db);\n-    let name = def.name(db);\n     let input =\n         signature.params().iter().map(|tr| Ty::from_hir(db, &resolver, tr)).collect::<Vec<_>>();\n     let output = Ty::from_hir(db, &resolver, signature.ret_type());\n     let sig = Arc::new(FnSig { input, output });\n     let substs = make_substs(&generics);\n-    Ty::FnDef { def: def.into(), sig, name, substs }\n+    Ty::FnDef { def: def.into(), sig, substs }\n }\n \n /// Build the declared type of a const.\n@@ -266,15 +265,14 @@ fn type_for_struct_constructor(db: &impl HirDatabase, def: Struct) -> Ty {\n     };\n     let resolver = def.resolver(db);\n     let generics = def.generic_params(db);\n-    let name = def.name(db).unwrap_or_else(Name::missing);\n     let input = fields\n         .iter()\n         .map(|(_, field)| Ty::from_hir(db, &resolver, &field.type_ref))\n         .collect::<Vec<_>>();\n     let output = type_for_struct(db, def);\n     let sig = Arc::new(FnSig { input, output });\n     let substs = make_substs(&generics);\n-    Ty::FnDef { def: def.into(), sig, name, substs }\n+    Ty::FnDef { def: def.into(), sig, substs }\n }\n \n /// Build the type of a tuple enum variant constructor.\n@@ -286,15 +284,14 @@ fn type_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariant) ->\n     };\n     let resolver = def.parent_enum(db).resolver(db);\n     let generics = def.parent_enum(db).generic_params(db);\n-    let name = def.name(db).unwrap_or_else(Name::missing);\n     let input = fields\n         .iter()\n         .map(|(_, field)| Ty::from_hir(db, &resolver, &field.type_ref))\n         .collect::<Vec<_>>();\n     let substs = make_substs(&generics);\n     let output = type_for_enum(db, def.parent_enum(db)).subst(&substs);\n     let sig = Arc::new(FnSig { input, output });\n-    Ty::FnDef { def: def.into(), sig, name, substs }\n+    Ty::FnDef { def: def.into(), sig, substs }\n }\n \n fn make_substs(generics: &GenericParams) -> Substs {\n@@ -310,20 +307,12 @@ fn make_substs(generics: &GenericParams) -> Substs {\n \n fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Ty {\n     let generics = s.generic_params(db);\n-    Ty::Adt {\n-        def_id: s.into(),\n-        name: s.name(db).unwrap_or_else(Name::missing),\n-        substs: make_substs(&generics),\n-    }\n+    Ty::Adt { def_id: s.into(), substs: make_substs(&generics) }\n }\n \n fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Ty {\n     let generics = s.generic_params(db);\n-    Ty::Adt {\n-        def_id: s.into(),\n-        name: s.name(db).unwrap_or_else(Name::missing),\n-        substs: make_substs(&generics),\n-    }\n+    Ty::Adt { def_id: s.into(), substs: make_substs(&generics) }\n }\n \n fn type_for_type_alias(db: &impl HirDatabase, t: TypeAlias) -> Ty {"}, {"sha": "acae71c266d2e5d9260b9547fff19912caa2cac1", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/76572e67eabffa959c665f8450dbb12d71848aba/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76572e67eabffa959c665f8450dbb12d71848aba/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=76572e67eabffa959c665f8450dbb12d71848aba", "patch": "@@ -10,6 +10,7 @@ use test_utils::covers;\n use crate::{\n     source_binder,\n     mock::MockDatabase,\n+    ty::display::HirDisplay,\n };\n \n // These tests compare the inference results for all expressions in a file\n@@ -2142,7 +2143,7 @@ fn type_at_pos(db: &MockDatabase, pos: FilePosition) -> String {\n     let node = algo::find_node_at_offset::<ast::Expr>(syntax.syntax(), pos.offset).unwrap();\n     let expr = body_source_map.node_expr(node).unwrap();\n     let ty = &inference_result[expr];\n-    ty.to_string()\n+    ty.display(db).to_string()\n }\n \n fn infer(content: &str) -> String {\n@@ -2178,7 +2179,7 @@ fn infer(content: &str) -> String {\n                 \"{} '{}': {}\\n\",\n                 syntax_ptr.range(),\n                 ellipsize(node.text().to_string().replace(\"\\n\", \" \"), 15),\n-                ty\n+                ty.display(&db)\n             )\n             .unwrap();\n         }"}, {"sha": "28c8f83ab9f308d0fd781cad6ea9ff48832dd654", "filename": "crates/ra_ide_api/src/completion/presentation.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/76572e67eabffa959c665f8450dbb12d71848aba/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76572e67eabffa959c665f8450dbb12d71848aba/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=76572e67eabffa959c665f8450dbb12d71848aba", "patch": "@@ -1,7 +1,7 @@\n //! This modules takes care of rendering various defenitions as completion items.\n use join_to_string::join;\n use test_utils::tested_by;\n-use hir::{Docs, PerNs, Resolution};\n+use hir::{Docs, PerNs, Resolution, HirDisplay};\n use ra_syntax::ast::NameOwner;\n \n use crate::completion::{\n@@ -22,15 +22,15 @@ impl Completions {\n             field.name(ctx.db).to_string(),\n         )\n         .kind(CompletionItemKind::Field)\n-        .detail(field.ty(ctx.db).subst(substs).to_string())\n+        .detail(field.ty(ctx.db).subst(substs).display(ctx.db).to_string())\n         .set_documentation(field.docs(ctx.db))\n         .add_to(self);\n     }\n \n     pub(crate) fn add_pos_field(&mut self, ctx: &CompletionContext, field: usize, ty: &hir::Ty) {\n         CompletionItem::new(CompletionKind::Reference, ctx.source_range(), field.to_string())\n             .kind(CompletionItemKind::Field)\n-            .detail(ty.to_string())\n+            .detail(ty.display(ctx.db).to_string())\n             .add_to(self);\n     }\n \n@@ -154,7 +154,10 @@ impl Completions {\n             None => return,\n         };\n         let detail_types = variant.fields(ctx.db).into_iter().map(|field| field.ty(ctx.db));\n-        let detail = join(detail_types).separator(\", \").surround_with(\"(\", \")\").to_string();\n+        let detail = join(detail_types.map(|t| t.display(ctx.db).to_string()))\n+            .separator(\", \")\n+            .surround_with(\"(\", \")\")\n+            .to_string();\n \n         CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.to_string())\n             .kind(CompletionItemKind::EnumVariant)"}, {"sha": "f6a83dd93799944d44e731fc8ba0c1f588087bc6", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/76572e67eabffa959c665f8450dbb12d71848aba/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76572e67eabffa959c665f8450dbb12d71848aba/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=76572e67eabffa959c665f8450dbb12d71848aba", "patch": "@@ -3,6 +3,7 @@ use ra_syntax::{\n     AstNode, SyntaxNode, TreeArc, ast::{self, NameOwner, VisibilityOwner, TypeAscriptionOwner},\n     algo::{find_covering_node, find_node_at_offset, find_leaf_at_offset, visit::{visitor, Visitor}},\n };\n+use hir::HirDisplay;\n \n use crate::{db::RootDatabase, RangeInfo, FilePosition, FileRange, NavigationTarget};\n \n@@ -134,9 +135,9 @@ pub(crate) fn type_of(db: &RootDatabase, frange: FileRange) -> Option<String> {\n     let infer = function.infer(db);\n     let source_map = function.body_source_map(db);\n     if let Some(expr) = ast::Expr::cast(node).and_then(|e| source_map.node_expr(e)) {\n-        Some(infer[expr].to_string())\n+        Some(infer[expr].display(db).to_string())\n     } else if let Some(pat) = ast::Pat::cast(node).and_then(|p| source_map.node_pat(p)) {\n-        Some(infer[pat].to_string())\n+        Some(infer[pat].display(db).to_string())\n     } else {\n         None\n     }"}]}