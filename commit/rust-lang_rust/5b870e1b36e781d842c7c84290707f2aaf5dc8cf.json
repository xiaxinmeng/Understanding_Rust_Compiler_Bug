{"sha": "5b870e1b36e781d842c7c84290707f2aaf5dc8cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViODcwZTFiMzZlNzgxZDg0MmM3Yzg0MjkwNzA3ZjJhYWY1ZGM4Y2Y=", "commit": {"author": {"name": "nahuakang", "email": "kangnahua@gmail.com", "date": "2021-02-09T22:27:03Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-02T09:14:20Z"}, "message": "Move detect_manual_memcpy to its module; split up utils structs", "tree": {"sha": "6c87ed5e42c4307a4b32f91f391f36db440a3e7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c87ed5e42c4307a4b32f91f391f36db440a3e7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b870e1b36e781d842c7c84290707f2aaf5dc8cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b870e1b36e781d842c7c84290707f2aaf5dc8cf", "html_url": "https://github.com/rust-lang/rust/commit/5b870e1b36e781d842c7c84290707f2aaf5dc8cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b870e1b36e781d842c7c84290707f2aaf5dc8cf/comments", "author": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c1f676bfe831f488cbd8e07d46b7b9be727ca24", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c1f676bfe831f488cbd8e07d46b7b9be727ca24", "html_url": "https://github.com/rust-lang/rust/commit/2c1f676bfe831f488cbd8e07d46b7b9be727ca24"}], "stats": {"total": 1367, "additions": 694, "deletions": 673}, "files": [{"sha": "85b3dfaece7364ef658fb50cb20cbeb3992d494e", "filename": "clippy_lints/src/loops/manual_memcpy.rs", "status": "added", "additions": 381, "deletions": 0, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/5b870e1b36e781d842c7c84290707f2aaf5dc8cf/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b870e1b36e781d842c7c84290707f2aaf5dc8cf/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=5b870e1b36e781d842c7c84290707f2aaf5dc8cf", "patch": "@@ -0,0 +1,381 @@\n+use super::{get_span_of_entire_for_loop, IncrementVisitor, InitializeVisitor, MinifyingSugg};\n+use crate::utils::sugg::Sugg;\n+use crate::utils::{\n+    get_enclosing_block, higher, is_type_diagnostic_item, path_to_local, snippet, span_lint_and_sugg, sugg,\n+};\n+use if_chain::if_chain;\n+use rustc_ast::ast;\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::walk_block;\n+use rustc_hir::{BinOpKind, Block, Expr, ExprKind, HirId, Pat, PatKind, StmtKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::symbol::sym;\n+use std::iter::Iterator;\n+\n+/// Checks for for loops that sequentially copy items from one slice-like\n+/// object to another.\n+pub(super) fn detect_manual_memcpy<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    expr: &'tcx Expr<'_>,\n+) -> bool {\n+    if let Some(higher::Range {\n+        start: Some(start),\n+        end: Some(end),\n+        limits,\n+    }) = higher::range(arg)\n+    {\n+        // the var must be a single name\n+        if let PatKind::Binding(_, canonical_id, _, _) = pat.kind {\n+            let mut starts = vec![Start {\n+                id: canonical_id,\n+                kind: StartKind::Range,\n+            }];\n+\n+            // This is one of few ways to return different iterators\n+            // derived from: https://stackoverflow.com/questions/29760668/conditionally-iterate-over-one-of-several-possible-iterators/52064434#52064434\n+            let mut iter_a = None;\n+            let mut iter_b = None;\n+\n+            if let ExprKind::Block(block, _) = body.kind {\n+                if let Some(loop_counters) = get_loop_counters(cx, block, expr) {\n+                    starts.extend(loop_counters);\n+                }\n+                iter_a = Some(get_assignments(block, &starts));\n+            } else {\n+                iter_b = Some(get_assignment(body));\n+            }\n+\n+            let assignments = iter_a.into_iter().flatten().chain(iter_b.into_iter());\n+\n+            let big_sugg = assignments\n+                // The only statements in the for loops can be indexed assignments from\n+                // indexed retrievals (except increments of loop counters).\n+                .map(|o| {\n+                    o.and_then(|(lhs, rhs)| {\n+                        let rhs = fetch_cloned_expr(rhs);\n+                        if_chain! {\n+                            if let ExprKind::Index(base_left, idx_left) = lhs.kind;\n+                            if let ExprKind::Index(base_right, idx_right) = rhs.kind;\n+                            if is_slice_like(cx, cx.typeck_results().expr_ty(base_left))\n+                                && is_slice_like(cx, cx.typeck_results().expr_ty(base_right));\n+                            if let Some((start_left, offset_left)) = get_details_from_idx(cx, &idx_left, &starts);\n+                            if let Some((start_right, offset_right)) = get_details_from_idx(cx, &idx_right, &starts);\n+\n+                            // Source and destination must be different\n+                            if path_to_local(base_left) != path_to_local(base_right);\n+                            then {\n+                                Some((IndexExpr { base: base_left, idx: start_left, idx_offset: offset_left },\n+                                    IndexExpr { base: base_right, idx: start_right, idx_offset: offset_right }))\n+                            } else {\n+                                None\n+                            }\n+                        }\n+                    })\n+                })\n+                .map(|o| o.map(|(dst, src)| build_manual_memcpy_suggestion(cx, start, end, limits, &dst, &src)))\n+                .collect::<Option<Vec<_>>>()\n+                .filter(|v| !v.is_empty())\n+                .map(|v| v.join(\"\\n    \"));\n+\n+            if let Some(big_sugg) = big_sugg {\n+                span_lint_and_sugg(\n+                    cx,\n+                    super::MANUAL_MEMCPY,\n+                    get_span_of_entire_for_loop(expr),\n+                    \"it looks like you're manually copying between slices\",\n+                    \"try replacing the loop by\",\n+                    big_sugg,\n+                    Applicability::Unspecified,\n+                );\n+                return true;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+fn build_manual_memcpy_suggestion<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    start: &Expr<'_>,\n+    end: &Expr<'_>,\n+    limits: ast::RangeLimits,\n+    dst: &IndexExpr<'_>,\n+    src: &IndexExpr<'_>,\n+) -> String {\n+    fn print_offset(offset: MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n+        if offset.as_str() == \"0\" {\n+            sugg::EMPTY.into()\n+        } else {\n+            offset\n+        }\n+    }\n+\n+    let print_limit = |end: &Expr<'_>, end_str: &str, base: &Expr<'_>, sugg: MinifyingSugg<'static>| {\n+        if_chain! {\n+            if let ExprKind::MethodCall(method, _, len_args, _) = end.kind;\n+            if method.ident.name == sym!(len);\n+            if len_args.len() == 1;\n+            if let Some(arg) = len_args.get(0);\n+            if path_to_local(arg) == path_to_local(base);\n+            then {\n+                if sugg.as_str() == end_str {\n+                    sugg::EMPTY.into()\n+                } else {\n+                    sugg\n+                }\n+            } else {\n+                match limits {\n+                    ast::RangeLimits::Closed => {\n+                        sugg + &sugg::ONE.into()\n+                    },\n+                    ast::RangeLimits::HalfOpen => sugg,\n+                }\n+            }\n+        }\n+    };\n+\n+    let start_str = Sugg::hir(cx, start, \"\").into();\n+    let end_str: MinifyingSugg<'_> = Sugg::hir(cx, end, \"\").into();\n+\n+    let print_offset_and_limit = |idx_expr: &IndexExpr<'_>| match idx_expr.idx {\n+        StartKind::Range => (\n+            print_offset(apply_offset(&start_str, &idx_expr.idx_offset)).into_sugg(),\n+            print_limit(\n+                end,\n+                end_str.as_str(),\n+                idx_expr.base,\n+                apply_offset(&end_str, &idx_expr.idx_offset),\n+            )\n+            .into_sugg(),\n+        ),\n+        StartKind::Counter { initializer } => {\n+            let counter_start = Sugg::hir(cx, initializer, \"\").into();\n+            (\n+                print_offset(apply_offset(&counter_start, &idx_expr.idx_offset)).into_sugg(),\n+                print_limit(\n+                    end,\n+                    end_str.as_str(),\n+                    idx_expr.base,\n+                    apply_offset(&end_str, &idx_expr.idx_offset) + &counter_start - &start_str,\n+                )\n+                .into_sugg(),\n+            )\n+        },\n+    };\n+\n+    let (dst_offset, dst_limit) = print_offset_and_limit(&dst);\n+    let (src_offset, src_limit) = print_offset_and_limit(&src);\n+\n+    let dst_base_str = snippet(cx, dst.base.span, \"???\");\n+    let src_base_str = snippet(cx, src.base.span, \"???\");\n+\n+    let dst = if dst_offset == sugg::EMPTY && dst_limit == sugg::EMPTY {\n+        dst_base_str\n+    } else {\n+        format!(\n+            \"{}[{}..{}]\",\n+            dst_base_str,\n+            dst_offset.maybe_par(),\n+            dst_limit.maybe_par()\n+        )\n+        .into()\n+    };\n+\n+    format!(\n+        \"{}.clone_from_slice(&{}[{}..{}]);\",\n+        dst,\n+        src_base_str,\n+        src_offset.maybe_par(),\n+        src_limit.maybe_par()\n+    )\n+}\n+\n+/// a wrapper around `MinifyingSugg`, which carries a operator like currying\n+/// so that the suggested code become more efficient (e.g. `foo + -bar` `foo - bar`).\n+struct Offset {\n+    value: MinifyingSugg<'static>,\n+    sign: OffsetSign,\n+}\n+\n+#[derive(Clone, Copy)]\n+enum OffsetSign {\n+    Positive,\n+    Negative,\n+}\n+\n+impl Offset {\n+    fn negative(value: Sugg<'static>) -> Self {\n+        Self {\n+            value: value.into(),\n+            sign: OffsetSign::Negative,\n+        }\n+    }\n+\n+    fn positive(value: Sugg<'static>) -> Self {\n+        Self {\n+            value: value.into(),\n+            sign: OffsetSign::Positive,\n+        }\n+    }\n+\n+    fn empty() -> Self {\n+        Self::positive(sugg::ZERO)\n+    }\n+}\n+\n+fn apply_offset(lhs: &MinifyingSugg<'static>, rhs: &Offset) -> MinifyingSugg<'static> {\n+    match rhs.sign {\n+        OffsetSign::Positive => lhs + &rhs.value,\n+        OffsetSign::Negative => lhs - &rhs.value,\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+enum StartKind<'hir> {\n+    Range,\n+    Counter { initializer: &'hir Expr<'hir> },\n+}\n+\n+struct IndexExpr<'hir> {\n+    base: &'hir Expr<'hir>,\n+    idx: StartKind<'hir>,\n+    idx_offset: Offset,\n+}\n+\n+struct Start<'hir> {\n+    id: HirId,\n+    kind: StartKind<'hir>,\n+}\n+\n+fn is_slice_like<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'_>) -> bool {\n+    let is_slice = match ty.kind() {\n+        ty::Ref(_, subty, _) => is_slice_like(cx, subty),\n+        ty::Slice(..) | ty::Array(..) => true,\n+        _ => false,\n+    };\n+\n+    is_slice || is_type_diagnostic_item(cx, ty, sym::vec_type) || is_type_diagnostic_item(cx, ty, sym!(vecdeque_type))\n+}\n+\n+fn fetch_cloned_expr<'tcx>(expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n+    if_chain! {\n+        if let ExprKind::MethodCall(method, _, args, _) = expr.kind;\n+        if method.ident.name == sym::clone;\n+        if args.len() == 1;\n+        if let Some(arg) = args.get(0);\n+        then { arg } else { expr }\n+    }\n+}\n+\n+fn get_details_from_idx<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    idx: &Expr<'_>,\n+    starts: &[Start<'tcx>],\n+) -> Option<(StartKind<'tcx>, Offset)> {\n+    fn get_start<'tcx>(e: &Expr<'_>, starts: &[Start<'tcx>]) -> Option<StartKind<'tcx>> {\n+        let id = path_to_local(e)?;\n+        starts.iter().find(|start| start.id == id).map(|start| start.kind)\n+    }\n+\n+    fn get_offset<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>, starts: &[Start<'tcx>]) -> Option<Sugg<'static>> {\n+        match &e.kind {\n+            ExprKind::Lit(l) => match l.node {\n+                ast::LitKind::Int(x, _ty) => Some(Sugg::NonParen(x.to_string().into())),\n+                _ => None,\n+            },\n+            ExprKind::Path(..) if get_start(e, starts).is_none() => Some(Sugg::hir(cx, e, \"???\")),\n+            _ => None,\n+        }\n+    }\n+\n+    match idx.kind {\n+        ExprKind::Binary(op, lhs, rhs) => match op.node {\n+            BinOpKind::Add => {\n+                let offset_opt = get_start(lhs, starts)\n+                    .and_then(|s| get_offset(cx, rhs, starts).map(|o| (s, o)))\n+                    .or_else(|| get_start(rhs, starts).and_then(|s| get_offset(cx, lhs, starts).map(|o| (s, o))));\n+\n+                offset_opt.map(|(s, o)| (s, Offset::positive(o)))\n+            },\n+            BinOpKind::Sub => {\n+                get_start(lhs, starts).and_then(|s| get_offset(cx, rhs, starts).map(|o| (s, Offset::negative(o))))\n+            },\n+            _ => None,\n+        },\n+        ExprKind::Path(..) => get_start(idx, starts).map(|s| (s, Offset::empty())),\n+        _ => None,\n+    }\n+}\n+\n+fn get_assignment<'tcx>(e: &'tcx Expr<'tcx>) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n+    if let ExprKind::Assign(lhs, rhs, _) = e.kind {\n+        Some((lhs, rhs))\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Get assignments from the given block.\n+/// The returned iterator yields `None` if no assignment expressions are there,\n+/// filtering out the increments of the given whitelisted loop counters;\n+/// because its job is to make sure there's nothing other than assignments and the increments.\n+fn get_assignments<'a, 'tcx>(\n+    Block { stmts, expr, .. }: &'tcx Block<'tcx>,\n+    loop_counters: &'a [Start<'tcx>],\n+) -> impl Iterator<Item = Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)>> + 'a {\n+    // As the `filter` and `map` below do different things, I think putting together\n+    // just increases complexity. (cc #3188 and #4193)\n+    stmts\n+        .iter()\n+        .filter_map(move |stmt| match stmt.kind {\n+            StmtKind::Local(..) | StmtKind::Item(..) => None,\n+            StmtKind::Expr(e) | StmtKind::Semi(e) => Some(e),\n+        })\n+        .chain((*expr).into_iter())\n+        .filter(move |e| {\n+            if let ExprKind::AssignOp(_, place, _) = e.kind {\n+                path_to_local(place).map_or(false, |id| {\n+                    !loop_counters\n+                        .iter()\n+                        // skip the first item which should be `StartKind::Range`\n+                        // this makes it possible to use the slice with `StartKind::Range` in the same iterator loop.\n+                        .skip(1)\n+                        .any(|counter| counter.id == id)\n+                })\n+            } else {\n+                true\n+            }\n+        })\n+        .map(get_assignment)\n+}\n+\n+fn get_loop_counters<'a, 'tcx>(\n+    cx: &'a LateContext<'tcx>,\n+    body: &'tcx Block<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+) -> Option<impl Iterator<Item = Start<'tcx>> + 'a> {\n+    // Look for variables that are incremented once per loop iteration.\n+    let mut increment_visitor = IncrementVisitor::new(cx);\n+    walk_block(&mut increment_visitor, body);\n+\n+    // For each candidate, check the parent block to see if\n+    // it's initialized to zero at the start of the loop.\n+    get_enclosing_block(&cx, expr.hir_id).and_then(|block| {\n+        increment_visitor\n+            .into_results()\n+            .filter_map(move |var_id| {\n+                let mut initialize_visitor = InitializeVisitor::new(cx, expr, var_id);\n+                walk_block(&mut initialize_visitor, block);\n+\n+                initialize_visitor.get_result().map(|(_, initializer)| Start {\n+                    id: var_id,\n+                    kind: StartKind::Counter { initializer },\n+                })\n+            })\n+            .into()\n+    })\n+}"}, {"sha": "c6055e34eb2ef83eb2b77de9485298ed6c47992a", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 13, "deletions": 671, "changes": 684, "blob_url": "https://github.com/rust-lang/rust/blob/5b870e1b36e781d842c7c84290707f2aaf5dc8cf/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b870e1b36e781d842c7c84290707f2aaf5dc8cf/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=5b870e1b36e781d842c7c84290707f2aaf5dc8cf", "patch": "@@ -6,36 +6,34 @@ mod for_mut_range_bound;\n mod for_single_element_loop;\n mod infinite_loop;\n mod manual_flatten;\n+mod manual_memcpy;\n mod needless_collect;\n mod same_item_push;\n mod utils;\n \n use crate::utils::sugg::Sugg;\n use crate::utils::usage::mutated_variables;\n use crate::utils::{\n-    get_enclosing_block, get_parent_expr, get_trait_def_id, higher, implements_trait, is_in_panic_handler,\n-    is_integer_const, is_no_std_crate, is_refutable, is_type_diagnostic_item, last_path_segment, match_trait_method,\n-    path_to_local, path_to_local_id, paths, snippet, snippet_with_applicability, span_lint, span_lint_and_help,\n-    span_lint_and_sugg, sugg,\n+    get_enclosing_block, get_trait_def_id, higher, implements_trait, is_in_panic_handler, is_no_std_crate,\n+    is_refutable, last_path_segment, match_trait_method, path_to_local, path_to_local_id, paths,\n+    snippet_with_applicability, span_lint, span_lint_and_help, span_lint_and_sugg, sugg,\n };\n use if_chain::if_chain;\n-use rustc_ast::ast;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_block, walk_expr, walk_pat, walk_stmt, NestedVisitorMap, Visitor};\n+use rustc_hir::intravisit::{walk_block, walk_expr, NestedVisitorMap, Visitor};\n use rustc_hir::{\n-    BinOpKind, Block, BorrowKind, Expr, ExprKind, HirId, InlineAsmOperand, LoopSource, MatchSource, Mutability, Node,\n-    Pat, PatKind, Stmt, StmtKind,\n+    Block, Expr, ExprKind, HirId, InlineAsmOperand, LoopSource, MatchSource, Node, Pat, PatKind, Stmt, StmtKind,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::sym;\n use std::iter::{once, Iterator};\n-use utils::{get_span_of_entire_for_loop, make_iterator_snippet};\n+use utils::{\n+    get_span_of_entire_for_loop, make_iterator_snippet, IncrementVisitor, InitializeVisitor, LoopNestVisitor, Nesting,\n+};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for for-loops that manually copy items between\n@@ -857,7 +855,7 @@ fn check_for_loop<'tcx>(\n     expr: &'tcx Expr<'_>,\n     span: Span,\n ) {\n-    let is_manual_memcpy_triggered = detect_manual_memcpy(cx, pat, arg, body, expr);\n+    let is_manual_memcpy_triggered = manual_memcpy::detect_manual_memcpy(cx, pat, arg, body, expr);\n     if !is_manual_memcpy_triggered {\n         for_loop_range::check_for_loop_range(cx, pat, arg, body, expr);\n         for_loop_explicit_counter::check_for_loop_explicit_counter(cx, pat, arg, body, expr);\n@@ -940,373 +938,6 @@ impl std::ops::Sub<&MinifyingSugg<'static>> for MinifyingSugg<'static> {\n     }\n }\n \n-/// a wrapper around `MinifyingSugg`, which carries a operator like currying\n-/// so that the suggested code become more efficient (e.g. `foo + -bar` `foo - bar`).\n-struct Offset {\n-    value: MinifyingSugg<'static>,\n-    sign: OffsetSign,\n-}\n-\n-#[derive(Clone, Copy)]\n-enum OffsetSign {\n-    Positive,\n-    Negative,\n-}\n-\n-impl Offset {\n-    fn negative(value: Sugg<'static>) -> Self {\n-        Self {\n-            value: value.into(),\n-            sign: OffsetSign::Negative,\n-        }\n-    }\n-\n-    fn positive(value: Sugg<'static>) -> Self {\n-        Self {\n-            value: value.into(),\n-            sign: OffsetSign::Positive,\n-        }\n-    }\n-\n-    fn empty() -> Self {\n-        Self::positive(sugg::ZERO)\n-    }\n-}\n-\n-fn apply_offset(lhs: &MinifyingSugg<'static>, rhs: &Offset) -> MinifyingSugg<'static> {\n-    match rhs.sign {\n-        OffsetSign::Positive => lhs + &rhs.value,\n-        OffsetSign::Negative => lhs - &rhs.value,\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy)]\n-enum StartKind<'hir> {\n-    Range,\n-    Counter { initializer: &'hir Expr<'hir> },\n-}\n-\n-struct IndexExpr<'hir> {\n-    base: &'hir Expr<'hir>,\n-    idx: StartKind<'hir>,\n-    idx_offset: Offset,\n-}\n-\n-struct Start<'hir> {\n-    id: HirId,\n-    kind: StartKind<'hir>,\n-}\n-\n-fn is_slice_like<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'_>) -> bool {\n-    let is_slice = match ty.kind() {\n-        ty::Ref(_, subty, _) => is_slice_like(cx, subty),\n-        ty::Slice(..) | ty::Array(..) => true,\n-        _ => false,\n-    };\n-\n-    is_slice || is_type_diagnostic_item(cx, ty, sym::vec_type) || is_type_diagnostic_item(cx, ty, sym!(vecdeque_type))\n-}\n-\n-fn fetch_cloned_expr<'tcx>(expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n-    if_chain! {\n-        if let ExprKind::MethodCall(method, _, args, _) = expr.kind;\n-        if method.ident.name == sym::clone;\n-        if args.len() == 1;\n-        if let Some(arg) = args.get(0);\n-        then { arg } else { expr }\n-    }\n-}\n-\n-fn get_details_from_idx<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    idx: &Expr<'_>,\n-    starts: &[Start<'tcx>],\n-) -> Option<(StartKind<'tcx>, Offset)> {\n-    fn get_start<'tcx>(e: &Expr<'_>, starts: &[Start<'tcx>]) -> Option<StartKind<'tcx>> {\n-        let id = path_to_local(e)?;\n-        starts.iter().find(|start| start.id == id).map(|start| start.kind)\n-    }\n-\n-    fn get_offset<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>, starts: &[Start<'tcx>]) -> Option<Sugg<'static>> {\n-        match &e.kind {\n-            ExprKind::Lit(l) => match l.node {\n-                ast::LitKind::Int(x, _ty) => Some(Sugg::NonParen(x.to_string().into())),\n-                _ => None,\n-            },\n-            ExprKind::Path(..) if get_start(e, starts).is_none() => Some(Sugg::hir(cx, e, \"???\")),\n-            _ => None,\n-        }\n-    }\n-\n-    match idx.kind {\n-        ExprKind::Binary(op, lhs, rhs) => match op.node {\n-            BinOpKind::Add => {\n-                let offset_opt = get_start(lhs, starts)\n-                    .and_then(|s| get_offset(cx, rhs, starts).map(|o| (s, o)))\n-                    .or_else(|| get_start(rhs, starts).and_then(|s| get_offset(cx, lhs, starts).map(|o| (s, o))));\n-\n-                offset_opt.map(|(s, o)| (s, Offset::positive(o)))\n-            },\n-            BinOpKind::Sub => {\n-                get_start(lhs, starts).and_then(|s| get_offset(cx, rhs, starts).map(|o| (s, Offset::negative(o))))\n-            },\n-            _ => None,\n-        },\n-        ExprKind::Path(..) => get_start(idx, starts).map(|s| (s, Offset::empty())),\n-        _ => None,\n-    }\n-}\n-\n-fn get_assignment<'tcx>(e: &'tcx Expr<'tcx>) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n-    if let ExprKind::Assign(lhs, rhs, _) = e.kind {\n-        Some((lhs, rhs))\n-    } else {\n-        None\n-    }\n-}\n-\n-/// Get assignments from the given block.\n-/// The returned iterator yields `None` if no assignment expressions are there,\n-/// filtering out the increments of the given whitelisted loop counters;\n-/// because its job is to make sure there's nothing other than assignments and the increments.\n-fn get_assignments<'a, 'tcx>(\n-    Block { stmts, expr, .. }: &'tcx Block<'tcx>,\n-    loop_counters: &'a [Start<'tcx>],\n-) -> impl Iterator<Item = Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)>> + 'a {\n-    // As the `filter` and `map` below do different things, I think putting together\n-    // just increases complexity. (cc #3188 and #4193)\n-    stmts\n-        .iter()\n-        .filter_map(move |stmt| match stmt.kind {\n-            StmtKind::Local(..) | StmtKind::Item(..) => None,\n-            StmtKind::Expr(e) | StmtKind::Semi(e) => Some(e),\n-        })\n-        .chain((*expr).into_iter())\n-        .filter(move |e| {\n-            if let ExprKind::AssignOp(_, place, _) = e.kind {\n-                path_to_local(place).map_or(false, |id| {\n-                    !loop_counters\n-                        .iter()\n-                        // skip the first item which should be `StartKind::Range`\n-                        // this makes it possible to use the slice with `StartKind::Range` in the same iterator loop.\n-                        .skip(1)\n-                        .any(|counter| counter.id == id)\n-                })\n-            } else {\n-                true\n-            }\n-        })\n-        .map(get_assignment)\n-}\n-\n-fn get_loop_counters<'a, 'tcx>(\n-    cx: &'a LateContext<'tcx>,\n-    body: &'tcx Block<'tcx>,\n-    expr: &'tcx Expr<'_>,\n-) -> Option<impl Iterator<Item = Start<'tcx>> + 'a> {\n-    // Look for variables that are incremented once per loop iteration.\n-    let mut increment_visitor = IncrementVisitor::new(cx);\n-    walk_block(&mut increment_visitor, body);\n-\n-    // For each candidate, check the parent block to see if\n-    // it's initialized to zero at the start of the loop.\n-    get_enclosing_block(&cx, expr.hir_id).and_then(|block| {\n-        increment_visitor\n-            .into_results()\n-            .filter_map(move |var_id| {\n-                let mut initialize_visitor = InitializeVisitor::new(cx, expr, var_id);\n-                walk_block(&mut initialize_visitor, block);\n-\n-                initialize_visitor.get_result().map(|(_, initializer)| Start {\n-                    id: var_id,\n-                    kind: StartKind::Counter { initializer },\n-                })\n-            })\n-            .into()\n-    })\n-}\n-\n-fn build_manual_memcpy_suggestion<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    start: &Expr<'_>,\n-    end: &Expr<'_>,\n-    limits: ast::RangeLimits,\n-    dst: &IndexExpr<'_>,\n-    src: &IndexExpr<'_>,\n-) -> String {\n-    fn print_offset(offset: MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n-        if offset.as_str() == \"0\" {\n-            sugg::EMPTY.into()\n-        } else {\n-            offset\n-        }\n-    }\n-\n-    let print_limit = |end: &Expr<'_>, end_str: &str, base: &Expr<'_>, sugg: MinifyingSugg<'static>| {\n-        if_chain! {\n-            if let ExprKind::MethodCall(method, _, len_args, _) = end.kind;\n-            if method.ident.name == sym!(len);\n-            if len_args.len() == 1;\n-            if let Some(arg) = len_args.get(0);\n-            if path_to_local(arg) == path_to_local(base);\n-            then {\n-                if sugg.as_str() == end_str {\n-                    sugg::EMPTY.into()\n-                } else {\n-                    sugg\n-                }\n-            } else {\n-                match limits {\n-                    ast::RangeLimits::Closed => {\n-                        sugg + &sugg::ONE.into()\n-                    },\n-                    ast::RangeLimits::HalfOpen => sugg,\n-                }\n-            }\n-        }\n-    };\n-\n-    let start_str = Sugg::hir(cx, start, \"\").into();\n-    let end_str: MinifyingSugg<'_> = Sugg::hir(cx, end, \"\").into();\n-\n-    let print_offset_and_limit = |idx_expr: &IndexExpr<'_>| match idx_expr.idx {\n-        StartKind::Range => (\n-            print_offset(apply_offset(&start_str, &idx_expr.idx_offset)).into_sugg(),\n-            print_limit(\n-                end,\n-                end_str.as_str(),\n-                idx_expr.base,\n-                apply_offset(&end_str, &idx_expr.idx_offset),\n-            )\n-            .into_sugg(),\n-        ),\n-        StartKind::Counter { initializer } => {\n-            let counter_start = Sugg::hir(cx, initializer, \"\").into();\n-            (\n-                print_offset(apply_offset(&counter_start, &idx_expr.idx_offset)).into_sugg(),\n-                print_limit(\n-                    end,\n-                    end_str.as_str(),\n-                    idx_expr.base,\n-                    apply_offset(&end_str, &idx_expr.idx_offset) + &counter_start - &start_str,\n-                )\n-                .into_sugg(),\n-            )\n-        },\n-    };\n-\n-    let (dst_offset, dst_limit) = print_offset_and_limit(&dst);\n-    let (src_offset, src_limit) = print_offset_and_limit(&src);\n-\n-    let dst_base_str = snippet(cx, dst.base.span, \"???\");\n-    let src_base_str = snippet(cx, src.base.span, \"???\");\n-\n-    let dst = if dst_offset == sugg::EMPTY && dst_limit == sugg::EMPTY {\n-        dst_base_str\n-    } else {\n-        format!(\n-            \"{}[{}..{}]\",\n-            dst_base_str,\n-            dst_offset.maybe_par(),\n-            dst_limit.maybe_par()\n-        )\n-        .into()\n-    };\n-\n-    format!(\n-        \"{}.clone_from_slice(&{}[{}..{}]);\",\n-        dst,\n-        src_base_str,\n-        src_offset.maybe_par(),\n-        src_limit.maybe_par()\n-    )\n-}\n-\n-/// Checks for for loops that sequentially copy items from one slice-like\n-/// object to another.\n-fn detect_manual_memcpy<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    pat: &'tcx Pat<'_>,\n-    arg: &'tcx Expr<'_>,\n-    body: &'tcx Expr<'_>,\n-    expr: &'tcx Expr<'_>,\n-) -> bool {\n-    if let Some(higher::Range {\n-        start: Some(start),\n-        end: Some(end),\n-        limits,\n-    }) = higher::range(arg)\n-    {\n-        // the var must be a single name\n-        if let PatKind::Binding(_, canonical_id, _, _) = pat.kind {\n-            let mut starts = vec![Start {\n-                id: canonical_id,\n-                kind: StartKind::Range,\n-            }];\n-\n-            // This is one of few ways to return different iterators\n-            // derived from: https://stackoverflow.com/questions/29760668/conditionally-iterate-over-one-of-several-possible-iterators/52064434#52064434\n-            let mut iter_a = None;\n-            let mut iter_b = None;\n-\n-            if let ExprKind::Block(block, _) = body.kind {\n-                if let Some(loop_counters) = get_loop_counters(cx, block, expr) {\n-                    starts.extend(loop_counters);\n-                }\n-                iter_a = Some(get_assignments(block, &starts));\n-            } else {\n-                iter_b = Some(get_assignment(body));\n-            }\n-\n-            let assignments = iter_a.into_iter().flatten().chain(iter_b.into_iter());\n-\n-            let big_sugg = assignments\n-                // The only statements in the for loops can be indexed assignments from\n-                // indexed retrievals (except increments of loop counters).\n-                .map(|o| {\n-                    o.and_then(|(lhs, rhs)| {\n-                        let rhs = fetch_cloned_expr(rhs);\n-                        if_chain! {\n-                            if let ExprKind::Index(base_left, idx_left) = lhs.kind;\n-                            if let ExprKind::Index(base_right, idx_right) = rhs.kind;\n-                            if is_slice_like(cx, cx.typeck_results().expr_ty(base_left))\n-                                && is_slice_like(cx, cx.typeck_results().expr_ty(base_right));\n-                            if let Some((start_left, offset_left)) = get_details_from_idx(cx, &idx_left, &starts);\n-                            if let Some((start_right, offset_right)) = get_details_from_idx(cx, &idx_right, &starts);\n-\n-                            // Source and destination must be different\n-                            if path_to_local(base_left) != path_to_local(base_right);\n-                            then {\n-                                Some((IndexExpr { base: base_left, idx: start_left, idx_offset: offset_left },\n-                                    IndexExpr { base: base_right, idx: start_right, idx_offset: offset_right }))\n-                            } else {\n-                                None\n-                            }\n-                        }\n-                    })\n-                })\n-                .map(|o| o.map(|(dst, src)| build_manual_memcpy_suggestion(cx, start, end, limits, &dst, &src)))\n-                .collect::<Option<Vec<_>>>()\n-                .filter(|v| !v.is_empty())\n-                .map(|v| v.join(\"\\n    \"));\n-\n-            if let Some(big_sugg) = big_sugg {\n-                span_lint_and_sugg(\n-                    cx,\n-                    MANUAL_MEMCPY,\n-                    get_span_of_entire_for_loop(expr),\n-                    \"it looks like you're manually copying between slices\",\n-                    \"try replacing the loop by\",\n-                    big_sugg,\n-                    Applicability::Unspecified,\n-                );\n-                return true;\n-            }\n-        }\n-    }\n-    false\n-}\n-\n fn is_used_inside<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, container: &'tcx Expr<'_>) -> bool {\n     let def_id = match path_to_local(expr) {\n         Some(id) => id,\n@@ -1398,233 +1029,6 @@ fn is_simple_break_expr(expr: &Expr<'_>) -> bool {\n     }\n }\n \n-#[derive(Debug, PartialEq)]\n-enum IncrementVisitorVarState {\n-    Initial,  // Not examined yet\n-    IncrOnce, // Incremented exactly once, may be a loop counter\n-    DontWarn,\n-}\n-\n-/// Scan a for loop for variables that are incremented exactly once and not used after that.\n-struct IncrementVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,                          // context reference\n-    states: FxHashMap<HirId, IncrementVisitorVarState>, // incremented variables\n-    depth: u32,                                         // depth of conditional expressions\n-    done: bool,\n-}\n-\n-impl<'a, 'tcx> IncrementVisitor<'a, 'tcx> {\n-    fn new(cx: &'a LateContext<'tcx>) -> Self {\n-        Self {\n-            cx,\n-            states: FxHashMap::default(),\n-            depth: 0,\n-            done: false,\n-        }\n-    }\n-\n-    fn into_results(self) -> impl Iterator<Item = HirId> {\n-        self.states.into_iter().filter_map(|(id, state)| {\n-            if state == IncrementVisitorVarState::IncrOnce {\n-                Some(id)\n-            } else {\n-                None\n-            }\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if self.done {\n-            return;\n-        }\n-\n-        // If node is a variable\n-        if let Some(def_id) = path_to_local(expr) {\n-            if let Some(parent) = get_parent_expr(self.cx, expr) {\n-                let state = self.states.entry(def_id).or_insert(IncrementVisitorVarState::Initial);\n-                if *state == IncrementVisitorVarState::IncrOnce {\n-                    *state = IncrementVisitorVarState::DontWarn;\n-                    return;\n-                }\n-\n-                match parent.kind {\n-                    ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n-                        if lhs.hir_id == expr.hir_id {\n-                            *state = if op.node == BinOpKind::Add\n-                                && is_integer_const(self.cx, rhs, 1)\n-                                && *state == IncrementVisitorVarState::Initial\n-                                && self.depth == 0\n-                            {\n-                                IncrementVisitorVarState::IncrOnce\n-                            } else {\n-                                // Assigned some other value or assigned multiple times\n-                                IncrementVisitorVarState::DontWarn\n-                            };\n-                        }\n-                    },\n-                    ExprKind::Assign(ref lhs, _, _) if lhs.hir_id == expr.hir_id => {\n-                        *state = IncrementVisitorVarState::DontWarn\n-                    },\n-                    ExprKind::AddrOf(BorrowKind::Ref, mutability, _) if mutability == Mutability::Mut => {\n-                        *state = IncrementVisitorVarState::DontWarn\n-                    },\n-                    _ => (),\n-                }\n-            }\n-\n-            walk_expr(self, expr);\n-        } else if is_loop(expr) || is_conditional(expr) {\n-            self.depth += 1;\n-            walk_expr(self, expr);\n-            self.depth -= 1;\n-        } else if let ExprKind::Continue(_) = expr.kind {\n-            self.done = true;\n-        } else {\n-            walk_expr(self, expr);\n-        }\n-    }\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n-enum InitializeVisitorState<'hir> {\n-    Initial,          // Not examined yet\n-    Declared(Symbol), // Declared but not (yet) initialized\n-    Initialized {\n-        name: Symbol,\n-        initializer: &'hir Expr<'hir>,\n-    },\n-    DontWarn,\n-}\n-\n-/// Checks whether a variable is initialized at the start of a loop and not modified\n-/// and used after the loop.\n-struct InitializeVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,  // context reference\n-    end_expr: &'tcx Expr<'tcx>, // the for loop. Stop scanning here.\n-    var_id: HirId,\n-    state: InitializeVisitorState<'tcx>,\n-    depth: u32, // depth of conditional expressions\n-    past_loop: bool,\n-}\n-\n-impl<'a, 'tcx> InitializeVisitor<'a, 'tcx> {\n-    fn new(cx: &'a LateContext<'tcx>, end_expr: &'tcx Expr<'tcx>, var_id: HirId) -> Self {\n-        Self {\n-            cx,\n-            end_expr,\n-            var_id,\n-            state: InitializeVisitorState::Initial,\n-            depth: 0,\n-            past_loop: false,\n-        }\n-    }\n-\n-    fn get_result(&self) -> Option<(Symbol, &'tcx Expr<'tcx>)> {\n-        if let InitializeVisitorState::Initialized { name, initializer } = self.state {\n-            Some((name, initializer))\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n-        // Look for declarations of the variable\n-        if_chain! {\n-            if let StmtKind::Local(ref local) = stmt.kind;\n-            if local.pat.hir_id == self.var_id;\n-            if let PatKind::Binding(.., ident, _) = local.pat.kind;\n-            then {\n-                self.state = local.init.map_or(InitializeVisitorState::Declared(ident.name), |init| {\n-                    InitializeVisitorState::Initialized {\n-                        initializer: init,\n-                        name: ident.name,\n-                    }\n-                })\n-            }\n-        }\n-        walk_stmt(self, stmt);\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if matches!(self.state, InitializeVisitorState::DontWarn) {\n-            return;\n-        }\n-        if expr.hir_id == self.end_expr.hir_id {\n-            self.past_loop = true;\n-            return;\n-        }\n-        // No need to visit expressions before the variable is\n-        // declared\n-        if matches!(self.state, InitializeVisitorState::Initial) {\n-            return;\n-        }\n-\n-        // If node is the desired variable, see how it's used\n-        if path_to_local_id(expr, self.var_id) {\n-            if self.past_loop {\n-                self.state = InitializeVisitorState::DontWarn;\n-                return;\n-            }\n-\n-            if let Some(parent) = get_parent_expr(self.cx, expr) {\n-                match parent.kind {\n-                    ExprKind::AssignOp(_, ref lhs, _) if lhs.hir_id == expr.hir_id => {\n-                        self.state = InitializeVisitorState::DontWarn;\n-                    },\n-                    ExprKind::Assign(ref lhs, ref rhs, _) if lhs.hir_id == expr.hir_id => {\n-                        self.state = if_chain! {\n-                            if self.depth == 0;\n-                            if let InitializeVisitorState::Declared(name)\n-                                | InitializeVisitorState::Initialized { name, ..} = self.state;\n-                            then {\n-                                InitializeVisitorState::Initialized { initializer: rhs, name }\n-                            } else {\n-                                InitializeVisitorState::DontWarn\n-                            }\n-                        }\n-                    },\n-                    ExprKind::AddrOf(BorrowKind::Ref, mutability, _) if mutability == Mutability::Mut => {\n-                        self.state = InitializeVisitorState::DontWarn\n-                    },\n-                    _ => (),\n-                }\n-            }\n-\n-            walk_expr(self, expr);\n-        } else if !self.past_loop && is_loop(expr) {\n-            self.state = InitializeVisitorState::DontWarn;\n-        } else if is_conditional(expr) {\n-            self.depth += 1;\n-            walk_expr(self, expr);\n-            self.depth -= 1;\n-        } else {\n-            walk_expr(self, expr);\n-        }\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n-    }\n-}\n-\n-fn is_loop(expr: &Expr<'_>) -> bool {\n-    matches!(expr.kind, ExprKind::Loop(..))\n-}\n-\n-fn is_conditional(expr: &Expr<'_>) -> bool {\n-    matches!(expr.kind, ExprKind::If(..) | ExprKind::Match(..))\n-}\n-\n fn is_nested(cx: &LateContext<'_>, match_expr: &Expr<'_>, iter_expr: &Expr<'_>) -> bool {\n     if_chain! {\n         if let Some(loop_block) = get_enclosing_block(cx, match_expr.hir_id);\n@@ -1659,10 +1063,10 @@ fn is_loop_nested(cx: &LateContext<'_>, loop_expr: &Expr<'_>, iter_expr: &Expr<'\n                 let mut block_visitor = LoopNestVisitor {\n                     hir_id: id,\n                     iterator: iter_id,\n-                    nesting: Unknown,\n+                    nesting: Nesting::Unknown,\n                 };\n                 walk_block(&mut block_visitor, block);\n-                if block_visitor.nesting == RuledOut {\n+                if block_visitor.nesting == Nesting::RuledOut {\n                     return false;\n                 }\n             },\n@@ -1674,65 +1078,3 @@ fn is_loop_nested(cx: &LateContext<'_>, loop_expr: &Expr<'_>, iter_expr: &Expr<'\n         id = parent;\n     }\n }\n-\n-#[derive(PartialEq, Eq)]\n-enum Nesting {\n-    Unknown,     // no nesting detected yet\n-    RuledOut,    // the iterator is initialized or assigned within scope\n-    LookFurther, // no nesting detected, no further walk required\n-}\n-\n-use self::Nesting::{LookFurther, RuledOut, Unknown};\n-\n-struct LoopNestVisitor {\n-    hir_id: HirId,\n-    iterator: HirId,\n-    nesting: Nesting,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n-        if stmt.hir_id == self.hir_id {\n-            self.nesting = LookFurther;\n-        } else if self.nesting == Unknown {\n-            walk_stmt(self, stmt);\n-        }\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if self.nesting != Unknown {\n-            return;\n-        }\n-        if expr.hir_id == self.hir_id {\n-            self.nesting = LookFurther;\n-            return;\n-        }\n-        match expr.kind {\n-            ExprKind::Assign(ref path, _, _) | ExprKind::AssignOp(_, ref path, _) => {\n-                if path_to_local_id(path, self.iterator) {\n-                    self.nesting = RuledOut;\n-                }\n-            },\n-            _ => walk_expr(self, expr),\n-        }\n-    }\n-\n-    fn visit_pat(&mut self, pat: &'tcx Pat<'_>) {\n-        if self.nesting != Unknown {\n-            return;\n-        }\n-        if let PatKind::Binding(_, id, ..) = pat.kind {\n-            if id == self.iterator {\n-                self.nesting = RuledOut;\n-                return;\n-            }\n-        }\n-        walk_pat(self, pat)\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}"}, {"sha": "9e38e17719aad116846c252a97d1c9bd00bb89bc", "filename": "clippy_lints/src/loops/utils.rs", "status": "modified", "additions": 300, "deletions": 2, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/5b870e1b36e781d842c7c84290707f2aaf5dc8cf/clippy_lints%2Fsrc%2Floops%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b870e1b36e781d842c7c84290707f2aaf5dc8cf/clippy_lints%2Fsrc%2Floops%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Futils.rs?ref=5b870e1b36e781d842c7c84290707f2aaf5dc8cf", "patch": "@@ -1,8 +1,306 @@\n-use crate::utils::{get_trait_def_id, has_iter_method, implements_trait, paths, sugg};\n+use crate::utils::{\n+    get_parent_expr, get_trait_def_id, has_iter_method, implements_trait, is_integer_const, path_to_local,\n+    path_to_local_id, paths, sugg,\n+};\n+use if_chain::if_chain;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n-use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability};\n+use rustc_hir::intravisit::{walk_expr, walk_pat, walk_stmt, NestedVisitorMap, Visitor};\n+use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Stmt, StmtKind};\n use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n use rustc_span::source_map::Span;\n+use rustc_span::symbol::Symbol;\n+use std::iter::Iterator;\n+\n+#[derive(Debug, PartialEq)]\n+enum IncrementVisitorVarState {\n+    Initial,  // Not examined yet\n+    IncrOnce, // Incremented exactly once, may be a loop counter\n+    DontWarn,\n+}\n+\n+/// Scan a for loop for variables that are incremented exactly once and not used after that.\n+pub(super) struct IncrementVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,                          // context reference\n+    states: FxHashMap<HirId, IncrementVisitorVarState>, // incremented variables\n+    depth: u32,                                         // depth of conditional expressions\n+    done: bool,\n+}\n+\n+impl<'a, 'tcx> IncrementVisitor<'a, 'tcx> {\n+    pub(super) fn new(cx: &'a LateContext<'tcx>) -> Self {\n+        Self {\n+            cx,\n+            states: FxHashMap::default(),\n+            depth: 0,\n+            done: false,\n+        }\n+    }\n+\n+    pub(super) fn into_results(self) -> impl Iterator<Item = HirId> {\n+        self.states.into_iter().filter_map(|(id, state)| {\n+            if state == IncrementVisitorVarState::IncrOnce {\n+                Some(id)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if self.done {\n+            return;\n+        }\n+\n+        // If node is a variable\n+        if let Some(def_id) = path_to_local(expr) {\n+            if let Some(parent) = get_parent_expr(self.cx, expr) {\n+                let state = self.states.entry(def_id).or_insert(IncrementVisitorVarState::Initial);\n+                if *state == IncrementVisitorVarState::IncrOnce {\n+                    *state = IncrementVisitorVarState::DontWarn;\n+                    return;\n+                }\n+\n+                match parent.kind {\n+                    ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n+                        if lhs.hir_id == expr.hir_id {\n+                            *state = if op.node == BinOpKind::Add\n+                                && is_integer_const(self.cx, rhs, 1)\n+                                && *state == IncrementVisitorVarState::Initial\n+                                && self.depth == 0\n+                            {\n+                                IncrementVisitorVarState::IncrOnce\n+                            } else {\n+                                // Assigned some other value or assigned multiple times\n+                                IncrementVisitorVarState::DontWarn\n+                            };\n+                        }\n+                    },\n+                    ExprKind::Assign(ref lhs, _, _) if lhs.hir_id == expr.hir_id => {\n+                        *state = IncrementVisitorVarState::DontWarn\n+                    },\n+                    ExprKind::AddrOf(BorrowKind::Ref, mutability, _) if mutability == Mutability::Mut => {\n+                        *state = IncrementVisitorVarState::DontWarn\n+                    },\n+                    _ => (),\n+                }\n+            }\n+\n+            walk_expr(self, expr);\n+        } else if is_loop(expr) || is_conditional(expr) {\n+            self.depth += 1;\n+            walk_expr(self, expr);\n+            self.depth -= 1;\n+        } else if let ExprKind::Continue(_) = expr.kind {\n+            self.done = true;\n+        } else {\n+            walk_expr(self, expr);\n+        }\n+    }\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+enum InitializeVisitorState<'hir> {\n+    Initial,          // Not examined yet\n+    Declared(Symbol), // Declared but not (yet) initialized\n+    Initialized {\n+        name: Symbol,\n+        initializer: &'hir Expr<'hir>,\n+    },\n+    DontWarn,\n+}\n+\n+/// Checks whether a variable is initialized at the start of a loop and not modified\n+/// and used after the loop.\n+pub(super) struct InitializeVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,  // context reference\n+    end_expr: &'tcx Expr<'tcx>, // the for loop. Stop scanning here.\n+    var_id: HirId,\n+    state: InitializeVisitorState<'tcx>,\n+    depth: u32, // depth of conditional expressions\n+    past_loop: bool,\n+}\n+\n+impl<'a, 'tcx> InitializeVisitor<'a, 'tcx> {\n+    pub(super) fn new(cx: &'a LateContext<'tcx>, end_expr: &'tcx Expr<'tcx>, var_id: HirId) -> Self {\n+        Self {\n+            cx,\n+            end_expr,\n+            var_id,\n+            state: InitializeVisitorState::Initial,\n+            depth: 0,\n+            past_loop: false,\n+        }\n+    }\n+\n+    pub(super) fn get_result(&self) -> Option<(Symbol, &'tcx Expr<'tcx>)> {\n+        if let InitializeVisitorState::Initialized { name, initializer } = self.state {\n+            Some((name, initializer))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n+        // Look for declarations of the variable\n+        if_chain! {\n+            if let StmtKind::Local(ref local) = stmt.kind;\n+            if local.pat.hir_id == self.var_id;\n+            if let PatKind::Binding(.., ident, _) = local.pat.kind;\n+            then {\n+                self.state = local.init.map_or(InitializeVisitorState::Declared(ident.name), |init| {\n+                    InitializeVisitorState::Initialized {\n+                        initializer: init,\n+                        name: ident.name,\n+                    }\n+                })\n+            }\n+        }\n+        walk_stmt(self, stmt);\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if matches!(self.state, InitializeVisitorState::DontWarn) {\n+            return;\n+        }\n+        if expr.hir_id == self.end_expr.hir_id {\n+            self.past_loop = true;\n+            return;\n+        }\n+        // No need to visit expressions before the variable is\n+        // declared\n+        if matches!(self.state, InitializeVisitorState::Initial) {\n+            return;\n+        }\n+\n+        // If node is the desired variable, see how it's used\n+        if path_to_local_id(expr, self.var_id) {\n+            if self.past_loop {\n+                self.state = InitializeVisitorState::DontWarn;\n+                return;\n+            }\n+\n+            if let Some(parent) = get_parent_expr(self.cx, expr) {\n+                match parent.kind {\n+                    ExprKind::AssignOp(_, ref lhs, _) if lhs.hir_id == expr.hir_id => {\n+                        self.state = InitializeVisitorState::DontWarn;\n+                    },\n+                    ExprKind::Assign(ref lhs, ref rhs, _) if lhs.hir_id == expr.hir_id => {\n+                        self.state = if_chain! {\n+                            if self.depth == 0;\n+                            if let InitializeVisitorState::Declared(name)\n+                                | InitializeVisitorState::Initialized { name, ..} = self.state;\n+                            then {\n+                                InitializeVisitorState::Initialized { initializer: rhs, name }\n+                            } else {\n+                                InitializeVisitorState::DontWarn\n+                            }\n+                        }\n+                    },\n+                    ExprKind::AddrOf(BorrowKind::Ref, mutability, _) if mutability == Mutability::Mut => {\n+                        self.state = InitializeVisitorState::DontWarn\n+                    },\n+                    _ => (),\n+                }\n+            }\n+\n+            walk_expr(self, expr);\n+        } else if !self.past_loop && is_loop(expr) {\n+            self.state = InitializeVisitorState::DontWarn;\n+        } else if is_conditional(expr) {\n+            self.depth += 1;\n+            walk_expr(self, expr);\n+            self.depth -= 1;\n+        } else {\n+            walk_expr(self, expr);\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+    }\n+}\n+\n+fn is_loop(expr: &Expr<'_>) -> bool {\n+    matches!(expr.kind, ExprKind::Loop(..))\n+}\n+\n+fn is_conditional(expr: &Expr<'_>) -> bool {\n+    matches!(expr.kind, ExprKind::If(..) | ExprKind::Match(..))\n+}\n+\n+#[derive(PartialEq, Eq)]\n+pub(super) enum Nesting {\n+    Unknown,     // no nesting detected yet\n+    RuledOut,    // the iterator is initialized or assigned within scope\n+    LookFurther, // no nesting detected, no further walk required\n+}\n+\n+use self::Nesting::{LookFurther, RuledOut, Unknown};\n+\n+pub(super) struct LoopNestVisitor {\n+    pub(super) hir_id: HirId,\n+    pub(super) iterator: HirId,\n+    pub(super) nesting: Nesting,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n+        if stmt.hir_id == self.hir_id {\n+            self.nesting = LookFurther;\n+        } else if self.nesting == Unknown {\n+            walk_stmt(self, stmt);\n+        }\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if self.nesting != Unknown {\n+            return;\n+        }\n+        if expr.hir_id == self.hir_id {\n+            self.nesting = LookFurther;\n+            return;\n+        }\n+        match expr.kind {\n+            ExprKind::Assign(ref path, _, _) | ExprKind::AssignOp(_, ref path, _) => {\n+                if path_to_local_id(path, self.iterator) {\n+                    self.nesting = RuledOut;\n+                }\n+            },\n+            _ => walk_expr(self, expr),\n+        }\n+    }\n+\n+    fn visit_pat(&mut self, pat: &'tcx Pat<'_>) {\n+        if self.nesting != Unknown {\n+            return;\n+        }\n+        if let PatKind::Binding(_, id, ..) = pat.kind {\n+            if id == self.iterator {\n+                self.nesting = RuledOut;\n+                return;\n+            }\n+        }\n+        walk_pat(self, pat)\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n \n // this function assumes the given expression is a `for` loop.\n pub(super) fn get_span_of_entire_for_loop(expr: &Expr<'_>) -> Span {"}]}