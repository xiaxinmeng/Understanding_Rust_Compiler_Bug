{"sha": "dea973089c026a13859eecf06a5da9f2d11ab46e", "node_id": "C_kwDOAAsO6NoAKGRlYTk3MzA4OWMwMjZhMTM4NTllZWNmMDZhNWRhOWYyZDExYWI0NmU", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-10T16:33:35Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-10T17:26:18Z"}, "message": "Simplify", "tree": {"sha": "f3012a0fa34882ab134d3ccfd03049fe748293a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3012a0fa34882ab134d3ccfd03049fe748293a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dea973089c026a13859eecf06a5da9f2d11ab46e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dea973089c026a13859eecf06a5da9f2d11ab46e", "html_url": "https://github.com/rust-lang/rust/commit/dea973089c026a13859eecf06a5da9f2d11ab46e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dea973089c026a13859eecf06a5da9f2d11ab46e/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f724c84e7d50e8f4fe84e7842008c1e4d33ef717", "url": "https://api.github.com/repos/rust-lang/rust/commits/f724c84e7d50e8f4fe84e7842008c1e4d33ef717", "html_url": "https://github.com/rust-lang/rust/commit/f724c84e7d50e8f4fe84e7842008c1e4d33ef717"}], "stats": {"total": 59, "additions": 33, "deletions": 26}, "files": [{"sha": "c753369bfd98e5626b479b1ab8ef26d7fef8b7f4", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dea973089c026a13859eecf06a5da9f2d11ab46e/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dea973089c026a13859eecf06a5da9f2d11ab46e/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=dea973089c026a13859eecf06a5da9f2d11ab46e", "patch": "@@ -897,13 +897,13 @@ impl<'db> SemanticsImpl<'db> {\n     }\n \n     fn scope(&self, node: &SyntaxNode) -> SemanticsScope<'db> {\n-        let sa = self.analyze(node);\n-        SemanticsScope { db: self.db, file_id: sa.file_id, resolver: sa.resolver }\n+        let SourceAnalyzer { file_id, resolver, .. } = self.analyze(node);\n+        SemanticsScope { db: self.db, file_id, resolver }\n     }\n \n     fn scope_at_offset(&self, node: &SyntaxNode, offset: TextSize) -> SemanticsScope<'db> {\n-        let sa = self.analyze_with_offset(node, offset);\n-        SemanticsScope { db: self.db, file_id: sa.file_id, resolver: sa.resolver }\n+        let SourceAnalyzer { file_id, resolver, .. } = self.analyze_with_offset(node, offset);\n+        SemanticsScope { db: self.db, file_id, resolver }\n     }\n \n     fn scope_for_def(&self, def: Trait) -> SemanticsScope<'db> {\n@@ -924,9 +924,11 @@ impl<'db> SemanticsImpl<'db> {\n     fn analyze(&self, node: &SyntaxNode) -> SourceAnalyzer {\n         self.analyze_impl(node, None)\n     }\n+\n     fn analyze_with_offset(&self, node: &SyntaxNode, offset: TextSize) -> SourceAnalyzer {\n         self.analyze_impl(node, Some(offset))\n     }\n+\n     fn analyze_impl(&self, node: &SyntaxNode, offset: Option<TextSize>) -> SourceAnalyzer {\n         let _p = profile::span(\"Semantics::analyze_impl\");\n         let node = self.find_file(node.clone());"}, {"sha": "eabe3acdcd50f5b7e5e4b4a72d28b702de3ee584", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dea973089c026a13859eecf06a5da9f2d11ab46e/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dea973089c026a13859eecf06a5da9f2d11ab46e/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=dea973089c026a13859eecf06a5da9f2d11ab46e", "patch": "@@ -13,6 +13,7 @@ use hir_def::{\n };\n use hir_expand::name::Name;\n use rustc_hash::{FxHashMap, FxHashSet};\n+use stdx::never;\n \n use crate::{\n     autoderef,\n@@ -322,7 +323,7 @@ pub fn def_crates(\n             }};\n         }\n \n-    let mod_to_crate_ids = |module: ModuleId| Some(std::iter::once(module.krate()).collect());\n+    let mod_to_crate_ids = |module: ModuleId| Some(iter::once(module.krate()).collect());\n \n     let lang_item_targets = match ty.kind(&Interner) {\n         TyKind::Adt(AdtId(def_id), _) => {\n@@ -521,9 +522,16 @@ fn iterate_method_candidates_with_autoref(\n     name: Option<&Name>,\n     mut callback: &mut dyn FnMut(&Canonical<Ty>, AssocItemId) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n+    let (receiver_ty, rest) = match deref_chain.split_first() {\n+        Some((rec, rest)) => (rec.clone(), rest),\n+        None => {\n+            never!(\"received empty deref-chain\");\n+            return ControlFlow::Break(());\n+        }\n+    };\n     iterate_method_candidates_by_receiver(\n-        &deref_chain[0],\n-        &deref_chain[1..],\n+        &receiver_ty,\n+        &rest,\n         db,\n         env.clone(),\n         krate,\n@@ -534,8 +542,8 @@ fn iterate_method_candidates_with_autoref(\n     )?;\n \n     let refed = Canonical {\n-        binders: deref_chain[0].binders.clone(),\n-        value: TyKind::Ref(Mutability::Not, static_lifetime(), deref_chain[0].value.clone())\n+        binders: receiver_ty.binders.clone(),\n+        value: TyKind::Ref(Mutability::Not, static_lifetime(), receiver_ty.value.clone())\n             .intern(&Interner),\n     };\n \n@@ -552,9 +560,8 @@ fn iterate_method_candidates_with_autoref(\n     )?;\n \n     let ref_muted = Canonical {\n-        binders: deref_chain[0].binders.clone(),\n-        value: TyKind::Ref(Mutability::Mut, static_lifetime(), deref_chain[0].value.clone())\n-            .intern(&Interner),\n+        binders: receiver_ty.binders,\n+        value: TyKind::Ref(Mutability::Mut, static_lifetime(), receiver_ty.value).intern(&Interner),\n     };\n \n     iterate_method_candidates_by_receiver(\n@@ -584,7 +591,7 @@ fn iterate_method_candidates_by_receiver(\n     // We're looking for methods with *receiver* type receiver_ty. These could\n     // be found in any of the derefs of receiver_ty, so we have to go through\n     // that.\n-    for self_ty in std::iter::once(receiver_ty).chain(rest_of_deref_chain) {\n+    for self_ty in iter::once(receiver_ty).chain(rest_of_deref_chain) {\n         iterate_inherent_methods(\n             self_ty,\n             db,\n@@ -597,7 +604,7 @@ fn iterate_method_candidates_by_receiver(\n         )?\n     }\n \n-    for self_ty in std::iter::once(receiver_ty).chain(rest_of_deref_chain) {\n+    for self_ty in iter::once(receiver_ty).chain(rest_of_deref_chain) {\n         iterate_trait_method_candidates(\n             self_ty,\n             db,\n@@ -659,8 +666,7 @@ fn iterate_trait_method_candidates(\n         }\n         _ => Vec::new(),\n     };\n-    let traits =\n-        inherent_trait.chain(env_traits.into_iter()).chain(traits_in_scope.iter().copied());\n+    let traits = inherent_trait.chain(env_traits).chain(traits_in_scope.iter().copied());\n \n     'traits: for t in traits {\n         let data = db.trait_data(t);\n@@ -750,7 +756,7 @@ fn iterate_inherent_methods(\n         let impls_for_self_ty = filter_inherent_impls_for_self_ty(&impls, &self_ty.value);\n \n         for &impl_def in impls_for_self_ty {\n-            for &item in db.impl_data(impl_def).items.iter() {\n+            for &item in &db.impl_data(impl_def).items {\n                 if !is_valid_candidate(\n                     db,\n                     env.clone(),"}, {"sha": "05ae95769b002251330f864327d7d8f30e25ecf4", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dea973089c026a13859eecf06a5da9f2d11ab46e/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dea973089c026a13859eecf06a5da9f2d11ab46e/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=dea973089c026a13859eecf06a5da9f2d11ab46e", "patch": "@@ -350,29 +350,28 @@ impl<'a> CompletionContext<'a> {\n impl<'a> CompletionContext<'a> {\n     pub(super) fn new(\n         db: &'a RootDatabase,\n-        position: FilePosition,\n+        position @ FilePosition { file_id, offset }: FilePosition,\n         config: &'a CompletionConfig,\n     ) -> Option<CompletionContext<'a>> {\n         let _p = profile::span(\"CompletionContext::new\");\n         let sema = Semantics::new(db);\n \n-        let original_file = sema.parse(position.file_id);\n+        let original_file = sema.parse(file_id);\n \n         // Insert a fake ident to get a valid parse tree. We will use this file\n         // to determine context, though the original_file will be used for\n         // actual completion.\n         let file_with_fake_ident = {\n-            let parse = db.parse(position.file_id);\n-            let edit = Indel::insert(position.offset, \"intellijRulezz\".to_string());\n+            let parse = db.parse(file_id);\n+            let edit = Indel::insert(offset, \"intellijRulezz\".to_string());\n             parse.reparse(&edit).tree()\n         };\n         let fake_ident_token =\n-            file_with_fake_ident.syntax().token_at_offset(position.offset).right_biased().unwrap();\n+            file_with_fake_ident.syntax().token_at_offset(offset).right_biased().unwrap();\n \n-        let original_token =\n-            original_file.syntax().token_at_offset(position.offset).left_biased()?;\n+        let original_token = original_file.syntax().token_at_offset(offset).left_biased()?;\n         let token = sema.descend_into_macros_single(original_token.clone());\n-        let scope = sema.scope_at_offset(&token, position.offset);\n+        let scope = sema.scope_at_offset(&token, offset);\n         let krate = scope.krate();\n         let mut locals = vec![];\n         scope.process_all_names(&mut |name, scope| {\n@@ -408,7 +407,7 @@ impl<'a> CompletionContext<'a> {\n         ctx.expand_and_fill(\n             original_file.syntax().clone(),\n             file_with_fake_ident.syntax().clone(),\n-            position.offset,\n+            offset,\n             fake_ident_token,\n         );\n         Some(ctx)"}]}