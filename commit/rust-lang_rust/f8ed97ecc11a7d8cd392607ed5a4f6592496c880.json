{"sha": "f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "node_id": "C_kwDOAAsO6NoAKGY4ZWQ5N2VjYzExYTdkOGNkMzkyNjA3ZWQ1YTRmNjU5MjQ5NmM4ODA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-09T00:18:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-09T00:18:10Z"}, "message": "Auto merge of #110031 - compiler-errors:generic-elaboration, r=b-naber\n\nMake elaboration generic over input\n\nCombines all the `elaborate_*` family of functions into just one, which is an iterator over the same type that you pass in (e.g. elaborating `Predicate` gives `Predicate`s, elaborating `Obligation`s gives `Obligation`s, etc.)", "tree": {"sha": "e1e2e58d8e714509c14c35ef2928cbfb3b635585", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1e2e58d8e714509c14c35ef2928cbfb3b635585"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "html_url": "https://github.com/rust-lang/rust/commit/f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1be642ce3c24d1a0517c9bf91af926740618b01", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1be642ce3c24d1a0517c9bf91af926740618b01", "html_url": "https://github.com/rust-lang/rust/commit/d1be642ce3c24d1a0517c9bf91af926740618b01"}, {"sha": "2cd0729d635a47bc585c683b36cd72cf884eb258", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cd0729d635a47bc585c683b36cd72cf884eb258", "html_url": "https://github.com/rust-lang/rust/commit/2cd0729d635a47bc585c683b36cd72cf884eb258"}], "stats": {"total": 329, "additions": 164, "deletions": 165}, "files": [{"sha": "acca3fa26418712eac7f02829cf2ba7fb3f0b2d8", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "patch": "@@ -33,9 +33,9 @@ use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKin\n use rustc_middle::middle::stability::AllowUnstable;\n use rustc_middle::ty::fold::FnMutDelegate;\n use rustc_middle::ty::subst::{self, GenericArgKind, InternalSubsts, SubstsRef};\n-use rustc_middle::ty::DynKind;\n use rustc_middle::ty::GenericParamDefKind;\n use rustc_middle::ty::{self, Const, IsSuggestable, Ty, TyCtxt, TypeVisitableExt};\n+use rustc_middle::ty::{DynKind, ToPredicate};\n use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, BARE_TRAIT_OBJECTS};\n use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::edition::Edition;\n@@ -1526,8 +1526,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         for (base_trait_ref, span, constness) in regular_traits_refs_spans {\n             assert_eq!(constness, ty::BoundConstness::NotConst);\n-\n-            for pred in traits::elaborate_trait_ref(tcx, base_trait_ref) {\n+            let base_pred: ty::Predicate<'tcx> = base_trait_ref.to_predicate(tcx);\n+            for pred in traits::elaborate(tcx, [base_pred]) {\n                 debug!(\"conv_object_ty_poly_trait_ref: observing object predicate `{:?}`\", pred);\n \n                 let bound_predicate = pred.kind();"}, {"sha": "f6c2004c4a672073000482401c0745c3a613ad64", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "patch": "@@ -2034,7 +2034,7 @@ pub(super) fn check_type_bounds<'tcx>(\n         ObligationCause::new(impl_ty_span, impl_ty_def_id, code)\n     };\n \n-    let obligations = tcx\n+    let obligations: Vec<_> = tcx\n         .bound_explicit_item_bounds(trait_ty.def_id)\n         .subst_iter_copied(tcx, rebased_substs)\n         .map(|(concrete_ty_bound, span)| {\n@@ -2044,7 +2044,7 @@ pub(super) fn check_type_bounds<'tcx>(\n         .collect();\n     debug!(\"check_type_bounds: item_bounds={:?}\", obligations);\n \n-    for mut obligation in util::elaborate_obligations(tcx, obligations) {\n+    for mut obligation in util::elaborate(tcx, obligations) {\n         let normalized_predicate =\n             ocx.normalize(&normalize_cause, normalize_param_env, obligation.predicate);\n         debug!(\"compare_projection_bounds: normalized predicate = {:?}\", normalized_predicate);"}, {"sha": "c03621fcfb224d0447c3c37c1c71c2b402f5ba8e", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "patch": "@@ -1908,7 +1908,7 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n \n         let predicates_with_span = tcx.predicates_of(self.body_def_id).predicates.iter().copied();\n         // Check elaborated bounds.\n-        let implied_obligations = traits::elaborate_predicates_with_span(tcx, predicates_with_span);\n+        let implied_obligations = traits::elaborate(tcx, predicates_with_span);\n \n         for (pred, obligation_span) in implied_obligations {\n             // We lower empty bounds like `Vec<dyn Copy>:` as"}, {"sha": "2e56d24638cdb101920d748bc2a849fe66492b5c", "filename": "compiler/rustc_hir_analysis/src/collect/item_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "patch": "@@ -130,7 +130,7 @@ pub(super) fn item_bounds(\n     tcx: TyCtxt<'_>,\n     def_id: DefId,\n ) -> ty::EarlyBinder<&'_ ty::List<ty::Predicate<'_>>> {\n-    let bounds = tcx.mk_predicates_from_iter(util::elaborate_predicates(\n+    let bounds = tcx.mk_predicates_from_iter(util::elaborate(\n         tcx,\n         tcx.explicit_item_bounds(def_id).iter().map(|&(bound, _span)| bound),\n     ));"}, {"sha": "35785e81ff497516004281970f1c4b127d6611c0", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "patch": "@@ -318,15 +318,14 @@ fn check_predicates<'tcx>(\n     span: Span,\n ) {\n     let instantiated = tcx.predicates_of(impl1_def_id).instantiate(tcx, impl1_substs);\n-    let impl1_predicates: Vec<_> =\n-        traits::elaborate_predicates_with_span(tcx, instantiated.into_iter()).collect();\n+    let impl1_predicates: Vec<_> = traits::elaborate(tcx, instantiated.into_iter()).collect();\n \n     let mut impl2_predicates = if impl2_node.is_from_trait() {\n         // Always applicable traits have to be always applicable without any\n         // assumptions.\n         Vec::new()\n     } else {\n-        traits::elaborate_predicates(\n+        traits::elaborate(\n             tcx,\n             tcx.predicates_of(impl2_node.def_id())\n                 .instantiate(tcx, impl2_substs)\n@@ -371,11 +370,10 @@ fn check_predicates<'tcx>(\n                 .unwrap();\n \n         assert!(!obligations.needs_infer());\n-        impl2_predicates.extend(\n-            traits::elaborate_obligations(tcx, obligations).map(|obligation| obligation.predicate),\n-        )\n+        impl2_predicates\n+            .extend(traits::elaborate(tcx, obligations).map(|obligation| obligation.predicate))\n     }\n-    impl2_predicates.extend(traits::elaborate_predicates(tcx, always_applicable_traits));\n+    impl2_predicates.extend(traits::elaborate(tcx, always_applicable_traits));\n \n     for (predicate, span) in impl1_predicates {\n         if !impl2_predicates.iter().any(|pred2| trait_predicates_eq(tcx, predicate, *pred2, span)) {"}, {"sha": "15eec42d78641c7810f53da5c6b97fe2af3120e1", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "patch": "@@ -204,7 +204,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut expected_sig = None;\n         let mut expected_kind = None;\n \n-        for (pred, span) in traits::elaborate_predicates_with_span(\n+        for (pred, span) in traits::elaborate(\n             self.tcx,\n             // Reverse the obligations here, since `elaborate_*` uses a stack,\n             // and we want to keep inference generally in the same order of"}, {"sha": "9155a3d8daa19ac796521454b34d47853d854173", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "patch": "@@ -574,7 +574,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n     ) -> Option<Span> {\n         let sized_def_id = self.tcx.lang_items().sized_trait()?;\n \n-        traits::elaborate_predicates(self.tcx, predicates.predicates.iter().copied())\n+        traits::elaborate(self.tcx, predicates.predicates.iter().copied())\n             // We don't care about regions here.\n             .filter_map(|pred| match pred.kind().skip_binder() {\n                 ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred))"}, {"sha": "0092bd2c6e641201faee1d0a8e66eb2b91de4212", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "patch": "@@ -1555,8 +1555,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         if !self.predicate_may_hold(&o) {\n                             result = ProbeResult::NoMatch;\n                             let parent_o = o.clone();\n-                            let implied_obligations =\n-                                traits::elaborate_obligations(self.tcx, vec![o]);\n+                            let implied_obligations = traits::elaborate(self.tcx, vec![o]);\n                             for o in implied_obligations {\n                                 let parent = if o == parent_o {\n                                     None"}, {"sha": "c7f7ed149407acaa297f9027f91b9e41c01b99fe", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 112, "deletions": 97, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "patch": "@@ -1,7 +1,7 @@\n use smallvec::smallvec;\n \n use crate::infer::outlives::components::{push_outlives_components, Component};\n-use crate::traits::{self, Obligation, ObligationCause, PredicateObligation};\n+use crate::traits::{self, Obligation, PredicateObligation};\n use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_middle::ty::{self, ToPredicate, TyCtxt};\n use rustc_span::symbol::Ident;\n@@ -66,99 +66,129 @@ impl<'tcx> Extend<ty::Predicate<'tcx>> for PredicateSet<'tcx> {\n /// if we know that `T: Ord`, the elaborator would deduce that `T: PartialOrd`\n /// holds as well. Similarly, if we have `trait Foo: 'static`, and we know that\n /// `T: Foo`, then we know that `T: 'static`.\n-pub struct Elaborator<'tcx> {\n-    stack: Vec<PredicateObligation<'tcx>>,\n+pub struct Elaborator<'tcx, O> {\n+    stack: Vec<O>,\n     visited: PredicateSet<'tcx>,\n }\n \n-pub fn elaborate_trait_ref<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> impl Iterator<Item = ty::Predicate<'tcx>> {\n-    elaborate_predicates(tcx, std::iter::once(trait_ref.without_const().to_predicate(tcx)))\n+/// Describes how to elaborate an obligation into a sub-obligation.\n+///\n+/// For [`Obligation`], a sub-obligation is combined with the current obligation's\n+/// param-env and cause code. For [`ty::Predicate`], none of this is needed, since\n+/// there is no param-env or cause code to copy over.\n+pub trait Elaboratable<'tcx> {\n+    fn predicate(&self) -> ty::Predicate<'tcx>;\n+\n+    // Makes a new `Self` but with a different predicate.\n+    fn child(&self, predicate: ty::Predicate<'tcx>) -> Self;\n+\n+    // Makes a new `Self` but with a different predicate and a different cause\n+    // code (if `Self` has one).\n+    fn child_with_derived_cause(\n+        &self,\n+        predicate: ty::Predicate<'tcx>,\n+        span: Span,\n+        parent_trait_pred: ty::PolyTraitPredicate<'tcx>,\n+        index: usize,\n+    ) -> Self;\n }\n \n-pub fn elaborate_trait_refs<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n-) -> impl Iterator<Item = ty::Predicate<'tcx>> {\n-    let predicates = trait_refs.map(move |trait_ref| trait_ref.without_const().to_predicate(tcx));\n-    elaborate_predicates(tcx, predicates)\n+impl<'tcx> Elaboratable<'tcx> for PredicateObligation<'tcx> {\n+    fn predicate(&self) -> ty::Predicate<'tcx> {\n+        self.predicate\n+    }\n+\n+    fn child(&self, predicate: ty::Predicate<'tcx>) -> Self {\n+        Obligation {\n+            cause: self.cause.clone(),\n+            param_env: self.param_env,\n+            recursion_depth: 0,\n+            predicate,\n+        }\n+    }\n+\n+    fn child_with_derived_cause(\n+        &self,\n+        predicate: ty::Predicate<'tcx>,\n+        span: Span,\n+        parent_trait_pred: ty::PolyTraitPredicate<'tcx>,\n+        index: usize,\n+    ) -> Self {\n+        let cause = self.cause.clone().derived_cause(parent_trait_pred, |derived| {\n+            traits::ImplDerivedObligation(Box::new(traits::ImplDerivedObligationCause {\n+                derived,\n+                impl_or_alias_def_id: parent_trait_pred.def_id(),\n+                impl_def_predicate_index: Some(index),\n+                span,\n+            }))\n+        });\n+        Obligation { cause, param_env: self.param_env, recursion_depth: 0, predicate }\n+    }\n }\n \n-pub fn elaborate_predicates<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n-) -> impl Iterator<Item = ty::Predicate<'tcx>> {\n-    elaborate_obligations(\n-        tcx,\n-        predicates\n-            .map(|predicate| {\n-                Obligation::new(\n-                    tcx,\n-                    // We'll dump the cause/param-env later\n-                    ObligationCause::dummy(),\n-                    ty::ParamEnv::empty(),\n-                    predicate,\n-                )\n-            })\n-            .collect(),\n-    )\n-    .map(|obl| obl.predicate)\n+impl<'tcx> Elaboratable<'tcx> for ty::Predicate<'tcx> {\n+    fn predicate(&self) -> ty::Predicate<'tcx> {\n+        *self\n+    }\n+\n+    fn child(&self, predicate: ty::Predicate<'tcx>) -> Self {\n+        predicate\n+    }\n+\n+    fn child_with_derived_cause(\n+        &self,\n+        predicate: ty::Predicate<'tcx>,\n+        _span: Span,\n+        _parent_trait_pred: ty::PolyTraitPredicate<'tcx>,\n+        _index: usize,\n+    ) -> Self {\n+        predicate\n+    }\n }\n \n-pub fn elaborate_predicates_with_span<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    predicates: impl Iterator<Item = (ty::Predicate<'tcx>, Span)>,\n-) -> impl Iterator<Item = (ty::Predicate<'tcx>, Span)> {\n-    elaborate_obligations(\n-        tcx,\n-        predicates\n-            .map(|(predicate, span)| {\n-                Obligation::new(\n-                    tcx,\n-                    // We'll dump the cause/param-env later\n-                    ObligationCause::dummy_with_span(span),\n-                    ty::ParamEnv::empty(),\n-                    predicate,\n-                )\n-            })\n-            .collect(),\n-    )\n-    .map(|obl| (obl.predicate, obl.cause.span))\n+impl<'tcx> Elaboratable<'tcx> for (ty::Predicate<'tcx>, Span) {\n+    fn predicate(&self) -> ty::Predicate<'tcx> {\n+        self.0\n+    }\n+\n+    fn child(&self, predicate: ty::Predicate<'tcx>) -> Self {\n+        (predicate, self.1)\n+    }\n+\n+    fn child_with_derived_cause(\n+        &self,\n+        predicate: ty::Predicate<'tcx>,\n+        _span: Span,\n+        _parent_trait_pred: ty::PolyTraitPredicate<'tcx>,\n+        _index: usize,\n+    ) -> Self {\n+        (predicate, self.1)\n+    }\n }\n \n-pub fn elaborate_obligations<'tcx>(\n+pub fn elaborate<'tcx, O: Elaboratable<'tcx>>(\n     tcx: TyCtxt<'tcx>,\n-    obligations: Vec<PredicateObligation<'tcx>>,\n-) -> Elaborator<'tcx> {\n+    obligations: impl IntoIterator<Item = O>,\n+) -> Elaborator<'tcx, O> {\n     let mut elaborator = Elaborator { stack: Vec::new(), visited: PredicateSet::new(tcx) };\n     elaborator.extend_deduped(obligations);\n     elaborator\n }\n \n-fn predicate_obligation<'tcx>(\n-    predicate: ty::Predicate<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-) -> PredicateObligation<'tcx> {\n-    Obligation { cause, param_env, recursion_depth: 0, predicate }\n-}\n-\n-impl<'tcx> Elaborator<'tcx> {\n-    fn extend_deduped(&mut self, obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>) {\n+impl<'tcx, O: Elaboratable<'tcx>> Elaborator<'tcx, O> {\n+    fn extend_deduped(&mut self, obligations: impl IntoIterator<Item = O>) {\n         // Only keep those bounds that we haven't already seen.\n         // This is necessary to prevent infinite recursion in some\n         // cases. One common case is when people define\n         // `trait Sized: Sized { }` rather than `trait Sized { }`.\n         // let visited = &mut self.visited;\n-        self.stack.extend(obligations.into_iter().filter(|o| self.visited.insert(o.predicate)));\n+        self.stack.extend(obligations.into_iter().filter(|o| self.visited.insert(o.predicate())));\n     }\n \n-    fn elaborate(&mut self, obligation: &PredicateObligation<'tcx>) {\n+    fn elaborate(&mut self, elaboratable: &O) {\n         let tcx = self.visited.tcx;\n \n-        let bound_predicate = obligation.predicate.kind();\n+        let bound_predicate = elaboratable.predicate().kind();\n         match bound_predicate.skip_binder() {\n             ty::PredicateKind::Clause(ty::Clause::Trait(data)) => {\n                 // Get predicates declared on the trait.\n@@ -170,24 +200,11 @@ impl<'tcx> Elaborator<'tcx> {\n                         if data.constness == ty::BoundConstness::NotConst {\n                             pred = pred.without_const(tcx);\n                         }\n-\n-                        let cause = obligation.cause.clone().derived_cause(\n-                            bound_predicate.rebind(data),\n-                            |derived| {\n-                                traits::ImplDerivedObligation(Box::new(\n-                                    traits::ImplDerivedObligationCause {\n-                                        derived,\n-                                        impl_or_alias_def_id: data.def_id(),\n-                                        impl_def_predicate_index: Some(index),\n-                                        span,\n-                                    },\n-                                ))\n-                            },\n-                        );\n-                        predicate_obligation(\n+                        elaboratable.child_with_derived_cause(\n                             pred.subst_supertrait(tcx, &bound_predicate.rebind(data.trait_ref)),\n-                            obligation.param_env,\n-                            cause,\n+                            span,\n+                            bound_predicate.rebind(data),\n+                            index,\n                         )\n                     });\n                 debug!(?data, ?obligations, \"super_predicates\");\n@@ -290,13 +307,7 @@ impl<'tcx> Elaborator<'tcx> {\n                         .map(|predicate_kind| {\n                             bound_predicate.rebind(predicate_kind).to_predicate(tcx)\n                         })\n-                        .map(|predicate| {\n-                            predicate_obligation(\n-                                predicate,\n-                                obligation.param_env,\n-                                obligation.cause.clone(),\n-                            )\n-                        }),\n+                        .map(|predicate| elaboratable.child(predicate)),\n                 );\n             }\n             ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n@@ -313,8 +324,8 @@ impl<'tcx> Elaborator<'tcx> {\n     }\n }\n \n-impl<'tcx> Iterator for Elaborator<'tcx> {\n-    type Item = PredicateObligation<'tcx>;\n+impl<'tcx, O: Elaboratable<'tcx>> Iterator for Elaborator<'tcx, O> {\n+    type Item = O;\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.stack.len(), None)\n@@ -339,17 +350,21 @@ pub fn supertraits<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>,\n ) -> impl Iterator<Item = ty::PolyTraitRef<'tcx>> {\n-    FilterToTraits::new(elaborate_trait_ref(tcx, trait_ref))\n+    let pred: ty::Predicate<'tcx> = trait_ref.to_predicate(tcx);\n+    FilterToTraits::new(elaborate(tcx, [pred]))\n }\n \n pub fn transitive_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n ) -> impl Iterator<Item = ty::PolyTraitRef<'tcx>> {\n-    FilterToTraits::new(elaborate_trait_refs(tcx, trait_refs))\n+    FilterToTraits::new(elaborate(\n+        tcx,\n+        trait_refs.map(|trait_ref| -> ty::Predicate<'tcx> { trait_ref.to_predicate(tcx) }),\n+    ))\n }\n \n-/// A specialized variant of `elaborate_trait_refs` that only elaborates trait references that may\n+/// A specialized variant of `elaborate` that only elaborates trait references that may\n /// define the given associated type `assoc_name`. It uses the\n /// `super_predicates_that_define_assoc_type` query to avoid enumerating super-predicates that\n /// aren't related to `assoc_item`. This is used when resolving types like `Self::Item` or"}, {"sha": "35c461f5acee81f78e8fb1f2026aa7620e315874", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "patch": "@@ -12,7 +12,7 @@ use rustc_errors::{pluralize, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_infer::traits::util::elaborate_predicates_with_span;\n+use rustc_infer::traits::util::elaborate;\n use rustc_middle::ty::adjustment;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::Symbol;\n@@ -254,24 +254,21 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                 }\n                 ty::Adt(def, _) => is_def_must_use(cx, def.did(), span),\n                 ty::Alias(ty::Opaque, ty::AliasTy { def_id: def, .. }) => {\n-                    elaborate_predicates_with_span(\n-                        cx.tcx,\n-                        cx.tcx.explicit_item_bounds(def).iter().cloned(),\n-                    )\n-                    .find_map(|(pred, _span)| {\n-                        // We only look at the `DefId`, so it is safe to skip the binder here.\n-                        if let ty::PredicateKind::Clause(ty::Clause::Trait(\n-                            ref poly_trait_predicate,\n-                        )) = pred.kind().skip_binder()\n-                        {\n-                            let def_id = poly_trait_predicate.trait_ref.def_id;\n-\n-                            is_def_must_use(cx, def_id, span)\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                    .map(|inner| MustUsePath::Opaque(Box::new(inner)))\n+                    elaborate(cx.tcx, cx.tcx.explicit_item_bounds(def).iter().cloned())\n+                        .find_map(|(pred, _span)| {\n+                            // We only look at the `DefId`, so it is safe to skip the binder here.\n+                            if let ty::PredicateKind::Clause(ty::Clause::Trait(\n+                                ref poly_trait_predicate,\n+                            )) = pred.kind().skip_binder()\n+                            {\n+                                let def_id = poly_trait_predicate.trait_ref.def_id;\n+\n+                                is_def_must_use(cx, def_id, span)\n+                            } else {\n+                                None\n+                            }\n+                        })\n+                        .map(|inner| MustUsePath::Opaque(Box::new(inner)))\n                 }\n                 ty::Dynamic(binders, _, _) => binders.iter().find_map(|predicate| {\n                     if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate.skip_binder()"}, {"sha": "79a9ac7d20c182d85b1b9727234712a9200ee300", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "patch": "@@ -115,10 +115,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n             .predicates\n             .iter()\n             .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n-        if traits::impossible_predicates(\n-            tcx,\n-            traits::elaborate_predicates(tcx, predicates).collect(),\n-        ) {\n+        if traits::impossible_predicates(tcx, traits::elaborate(tcx, predicates).collect()) {\n             trace!(\"ConstProp skipped for {:?}: found unsatisfiable predicates\", def_id);\n             return;\n         }"}, {"sha": "699fe44892b2c3814c078eb8bff0738f7e7de153", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "patch": "@@ -91,10 +91,7 @@ impl<'tcx> MirLint<'tcx> for ConstProp {\n             .predicates\n             .iter()\n             .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n-        if traits::impossible_predicates(\n-            tcx,\n-            traits::elaborate_predicates(tcx, predicates).collect(),\n-        ) {\n+        if traits::impossible_predicates(tcx, traits::elaborate(tcx, predicates).collect()) {\n             trace!(\"ConstProp skipped for {:?}: found unsatisfiable predicates\", def_id);\n             return;\n         }"}, {"sha": "6476da7ba489c99a72d90cff83cc4756504e1e87", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "patch": "@@ -9,7 +9,7 @@ use itertools::Itertools;\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n-use rustc_infer::traits::util::elaborate_predicates;\n+use rustc_infer::traits::util::elaborate;\n use rustc_middle::traits::solve::{CanonicalResponse, Certainty, Goal, MaybeCause, QueryResult};\n use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::TypeFoldable;\n@@ -498,7 +498,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         let tcx = self.tcx();\n         let own_bounds: FxIndexSet<_> =\n             bounds.iter().map(|bound| bound.with_self_ty(tcx, self_ty)).collect();\n-        for assumption in elaborate_predicates(tcx, own_bounds.iter().copied()) {\n+        for assumption in elaborate(tcx, own_bounds.iter().copied()) {\n             // FIXME: Predicates are fully elaborated in the object type's existential bounds\n             // list. We want to only consider these pre-elaborated projections, and not other\n             // projection predicates that we reach by elaborating the principal trait ref,"}, {"sha": "a53d414be9e7a811613fbd461ba7c8c76fdf56b8", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "patch": "@@ -234,7 +234,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n     /// constructed once for a given type. As part of the construction process, the `ParamEnv` will\n     /// have any supertrait bounds normalized -- e.g., if we have a type `struct Foo<T: Copy>`, the\n     /// `ParamEnv` will contain `T: Copy` and `T: Clone`, since `Copy: Clone`. When we construct our\n-    /// own `ParamEnv`, we need to do this ourselves, through `traits::elaborate_predicates`, or\n+    /// own `ParamEnv`, we need to do this ourselves, through `traits::elaborate`, or\n     /// else `SelectionContext` will choke on the missing predicates. However, this should never\n     /// show up in the final synthesized generics: we don't want our generated docs page to contain\n     /// something like `T: Copy + Clone`, as that's redundant. Therefore, we keep track of a\n@@ -346,10 +346,8 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                 _ => panic!(\"Unexpected error for '{:?}': {:?}\", ty, result),\n             };\n \n-            let normalized_preds = elaborate_predicates(\n-                tcx,\n-                computed_preds.clone().chain(user_computed_preds.iter().cloned()),\n-            );\n+            let normalized_preds =\n+                elaborate(tcx, computed_preds.clone().chain(user_computed_preds.iter().cloned()));\n             new_env = ty::ParamEnv::new(\n                 tcx.mk_predicates_from_iter(normalized_preds),\n                 param_env.reveal(),"}, {"sha": "53d4f95e9e30fec17058656ceb43688302771574", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "patch": "@@ -368,7 +368,7 @@ fn negative_impl_exists<'tcx>(\n     }\n \n     // Try to prove a negative obligation exists for super predicates\n-    for pred in util::elaborate_predicates(infcx.tcx, iter::once(o.predicate)) {\n+    for pred in util::elaborate(infcx.tcx, iter::once(o.predicate)) {\n         if resolve_negative_obligation(infcx.fork(), &o.with(infcx.tcx, pred), body_def_id) {\n             return true;\n         }"}, {"sha": "0475f24d87c7f77d91bc70dbdf6d711dacd6dce8", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/ambiguity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs?ref=f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "patch": "@@ -1,6 +1,6 @@\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::{InferCtxt, LateBoundRegionConversionTime};\n-use rustc_infer::traits::util::elaborate_predicates_with_span;\n+use rustc_infer::traits::util::elaborate;\n use rustc_infer::traits::{Obligation, ObligationCause, TraitObligation};\n use rustc_middle::ty;\n use rustc_span::{Span, DUMMY_SP};\n@@ -82,7 +82,7 @@ pub fn recompute_applicable_impls<'tcx>(\n \n     let predicates =\n         tcx.predicates_of(obligation.cause.body_id.to_def_id()).instantiate_identity(tcx);\n-    for (pred, span) in elaborate_predicates_with_span(tcx, predicates.into_iter()) {\n+    for (pred, span) in elaborate(tcx, predicates.into_iter()) {\n         let kind = pred.kind();\n         if let ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) = kind.skip_binder()\n             && param_env_candidate_may_apply(kind.rebind(trait_pred))"}, {"sha": "6ebf056f0e837d1f2c1f65f7cd0c45ae007d3700", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "patch": "@@ -1624,7 +1624,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             }\n         };\n \n-        for pred in super::elaborate_predicates(self.tcx, std::iter::once(cond)) {\n+        for pred in super::elaborate(self.tcx, std::iter::once(cond)) {\n             let bound_predicate = pred.kind();\n             if let ty::PredicateKind::Clause(ty::Clause::Trait(implication)) =\n                 bound_predicate.skip_binder()"}, {"sha": "8a203dec86bab6fe2cf18c3b03836a495ee7c3b0", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "patch": "@@ -58,10 +58,7 @@ pub use self::specialize::{specialization_graph, translate_substs, OverlapError}\n pub use self::structural_match::{\n     search_for_adt_const_param_violation, search_for_structural_match_violation,\n };\n-pub use self::util::{\n-    elaborate_obligations, elaborate_predicates, elaborate_predicates_with_span,\n-    elaborate_trait_ref, elaborate_trait_refs,\n-};\n+pub use self::util::elaborate;\n pub use self::util::{expand_trait_aliases, TraitAliasExpander};\n pub use self::util::{get_vtable_index_of_object_method, impl_item_is_final, upcast_choices};\n pub use self::util::{\n@@ -267,7 +264,7 @@ pub fn normalize_param_env_or_error<'tcx>(\n     // and errors will get reported then; so outside of type inference we\n     // can be sure that no errors should occur.\n     let mut predicates: Vec<_> =\n-        util::elaborate_predicates(tcx, unnormalized_env.caller_bounds().into_iter()).collect();\n+        util::elaborate(tcx, unnormalized_env.caller_bounds().into_iter()).collect();\n \n     debug!(\"normalize_param_env_or_error: elaborated-predicates={:?}\", predicates);\n "}, {"sha": "b8ad1925e4eaa706d54442a5d88b47ea5a3bd26d", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "patch": "@@ -8,7 +8,7 @@\n //!   - not reference the erased type `Self` except for in this receiver;\n //!   - not have generic type parameters.\n \n-use super::{elaborate_predicates, elaborate_trait_ref};\n+use super::elaborate;\n \n use crate::infer::TyCtxtInferExt;\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n@@ -379,7 +379,7 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     // Search for a predicate like `Self : Sized` amongst the trait bounds.\n     let predicates = tcx.predicates_of(def_id);\n     let predicates = predicates.instantiate_identity(tcx).predicates;\n-    elaborate_predicates(tcx, predicates.into_iter()).any(|pred| match pred.kind().skip_binder() {\n+    elaborate(tcx, predicates.into_iter()).any(|pred| match pred.kind().skip_binder() {\n         ty::PredicateKind::Clause(ty::Clause::Trait(ref trait_pred)) => {\n             trait_pred.def_id() == sized_def_id && trait_pred.self_ty().is_param(0)\n         }\n@@ -666,7 +666,8 @@ fn object_ty_for_trait<'tcx>(\n     });\n     debug!(?trait_predicate);\n \n-    let mut elaborated_predicates: Vec<_> = elaborate_trait_ref(tcx, trait_ref)\n+    let pred: ty::Predicate<'tcx> = trait_ref.to_predicate(tcx);\n+    let mut elaborated_predicates: Vec<_> = elaborate(tcx, [pred])\n         .filter_map(|pred| {\n             debug!(?pred);\n             let pred = pred.to_opt_poly_projection_pred()?;"}, {"sha": "3d026506a5a8d9fab7a3e8ff18be3fed2c94aa74", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "patch": "@@ -364,7 +364,7 @@ impl<'tcx> WfPredicates<'tcx> {\n         };\n \n         if let Elaborate::All = elaborate {\n-            let implied_obligations = traits::util::elaborate_obligations(tcx, obligations);\n+            let implied_obligations = traits::util::elaborate(tcx, obligations);\n             let implied_obligations = implied_obligations.map(extend);\n             self.out.extend(implied_obligations);\n         } else {\n@@ -920,7 +920,7 @@ pub(crate) fn required_region_bounds<'tcx>(\n ) -> Vec<ty::Region<'tcx>> {\n     assert!(!erased_self_ty.has_escaping_bound_vars());\n \n-    traits::elaborate_predicates(tcx, predicates)\n+    traits::elaborate(tcx, predicates)\n         .filter_map(|pred| {\n             debug!(?pred);\n             match pred.kind().skip_binder() {"}, {"sha": "0bb1775aae9cfb23c2c700c1cfb73109c927de67", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "patch": "@@ -122,7 +122,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n \n         let sized_trait = need!(cx.tcx.lang_items().sized_trait());\n \n-        let preds = traits::elaborate_predicates(cx.tcx, cx.param_env.caller_bounds().iter())\n+        let preds = traits::elaborate(cx.tcx, cx.param_env.caller_bounds().iter())\n             .filter(|p| !p.is_global())\n             .filter_map(|pred| {\n                 // Note that we do not want to deal with qualified predicates here."}, {"sha": "9051cf51658df061b6b94bf213db999f6cb2334e", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8ed97ecc11a7d8cd392607ed5a4f6592496c880/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=f8ed97ecc11a7d8cd392607ed5a4f6592496c880", "patch": "@@ -2104,7 +2104,7 @@ pub fn fn_has_unsatisfiable_preds(cx: &LateContext<'_>, did: DefId) -> bool {\n         .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n     traits::impossible_predicates(\n         cx.tcx,\n-        traits::elaborate_predicates(cx.tcx, predicates)\n+        traits::elaborate(cx.tcx, predicates)\n             .collect::<Vec<_>>(),\n     )\n }"}]}