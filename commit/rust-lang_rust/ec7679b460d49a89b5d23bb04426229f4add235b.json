{"sha": "ec7679b460d49a89b5d23bb04426229f4add235b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNzY3OWI0NjBkNDlhODliNWQyM2JiMDQ0MjYyMjlmNGFkZDIzNWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-27T06:30:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-27T06:30:19Z"}, "message": "Auto merge of #36764 - jonathandturner:rollup, r=jonathandturner\n\nRollup of 14 pull requests\n\n- Successful merges: #36563, #36574, #36586, #36662, #36663, #36669, #36676, #36721, #36723, #36727, #36729, #36742, #36754, #36756\n- Failed merges:", "tree": {"sha": "956c9fd346bfd0264dd01c768b7f885d835675b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/956c9fd346bfd0264dd01c768b7f885d835675b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec7679b460d49a89b5d23bb04426229f4add235b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec7679b460d49a89b5d23bb04426229f4add235b", "html_url": "https://github.com/rust-lang/rust/commit/ec7679b460d49a89b5d23bb04426229f4add235b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec7679b460d49a89b5d23bb04426229f4add235b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0623cf7bda44849ab5df78a06b22f9108cf821a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0623cf7bda44849ab5df78a06b22f9108cf821a", "html_url": "https://github.com/rust-lang/rust/commit/d0623cf7bda44849ab5df78a06b22f9108cf821a"}, {"sha": "e832762ba6456801967a9306f9848514c0772fa7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e832762ba6456801967a9306f9848514c0772fa7", "html_url": "https://github.com/rust-lang/rust/commit/e832762ba6456801967a9306f9848514c0772fa7"}], "stats": {"total": 2771, "additions": 1710, "deletions": 1061}, "files": [{"sha": "fd0397e5f87c51f36cffb25f90b2b7a0ba8a2ef5", "filename": "configure", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/configure", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -437,6 +437,10 @@ case $CFG_OSTYPE in\n         CFG_CPUTYPE=$(isainfo -n)\n         ;;\n \n+    Haiku)\n+        CFG_OSTYPE=unknown-haiku\n+        ;;\n+\n     MINGW*)\n         # msys' `uname` does not print gcc configuration, but prints msys\n         # configuration. so we cannot believe `uname -m`:\n@@ -532,6 +536,10 @@ case $CFG_CPUTYPE in\n         CFG_CPUTYPE=x86_64\n         ;;\n \n+    BePC)\n+        CFG_CPUTYPE=i686\n+        ;;\n+\n     *)\n         err \"unknown CPU type: $CFG_CPUTYPE\"\n esac"}, {"sha": "cbacbff070e881c38fa1eb95fd365097bd3c06a3", "filename": "mk/cfg/i686-unknown-haiku.mk", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/mk%2Fcfg%2Fi686-unknown-haiku.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/mk%2Fcfg%2Fi686-unknown-haiku.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi686-unknown-haiku.mk?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -0,0 +1,27 @@\n+# i686-unknown-haiku configuration\n+CROSS_PREFIX_i686-unknown-haiku=i586-pc-haiku-\n+CC_i686-unknown-haiku=$(CC)\n+CXX_i686-unknown-haiku=$(CXX)\n+CPP_i686-unknown-haiku=$(CPP)\n+AR_i686-unknown-haiku=$(AR)\n+CFG_LIB_NAME_i686-unknown-haiku=lib$(1).so\n+CFG_STATIC_LIB_NAME_i686-unknown-haiku=lib$(1).a\n+CFG_LIB_GLOB_i686-unknown-haiku=lib$(1)-*.so\n+CFG_LIB_DSYM_GLOB_i686-unknown-haiku=lib$(1)-*.dylib.dSYM\n+CFG_CFLAGS_i686-unknown-haiku := -m32 $(CFLAGS)\n+CFG_GCCISH_CFLAGS_i686-unknown-haiku := -Wall -Werror -g -fPIC -m32 $(CFLAGS)\n+CFG_GCCISH_CXXFLAGS_i686-unknown-haiku := -fno-rtti $(CXXFLAGS)\n+CFG_GCCISH_LINK_FLAGS_i686-unknown-haiku := -shared -fPIC -ldl -pthread  -lrt -g -m32\n+CFG_GCCISH_PRE_LIB_FLAGS_i686-unknown-haiku := -Wl,-whole-archive\n+CFG_GCCISH_POST_LIB_FLAGS_i686-unknown-haiku := -Wl,-no-whole-archive\n+CFG_DEF_SUFFIX_i686-unknown-haiku := .linux.def\n+CFG_LLC_FLAGS_i686-unknown-haiku :=\n+CFG_INSTALL_NAME_i686-unknown-haiku =\n+CFG_EXE_SUFFIX_i686-unknown-haiku =\n+CFG_WINDOWSY_i686-unknown-haiku :=\n+CFG_UNIXY_i686-unknown-haiku := 1\n+CFG_PATH_MUNGE_i686-unknown-haiku := true\n+CFG_LDPATH_i686-unknown-haiku :=\n+CFG_RUN_i686-unknown-haiku=$(2)\n+CFG_RUN_TARG_i686-unknown-haiku=$(call CFG_RUN_i686-unknown-haiku,,$(2))\n+CFG_GNU_TRIPLE_i686-unknown-haiku := i686-unknown-haiku"}, {"sha": "4c2d888be06fbb6a52eacad88eae1572c678a6e4", "filename": "mk/cfg/x86_64-unknown-haiku.mk", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/mk%2Fcfg%2Fx86_64-unknown-haiku.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/mk%2Fcfg%2Fx86_64-unknown-haiku.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-haiku.mk?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -0,0 +1,27 @@\n+# x86_64-unknown-haiku configuration\n+CROSS_PREFIX_x86_64-unknown-haiku=x86_64-unknown-haiku-\n+CC_x86_64-unknown-haiku=$(CC)\n+CXX_x86_64-unknown-haiku=$(CXX)\n+CPP_x86_64-unknown-haiku=$(CPP)\n+AR_x86_64-unknown-haiku=$(AR)\n+CFG_LIB_NAME_x86_64-unknown-haiku=lib$(1).so\n+CFG_STATIC_LIB_NAME_x86_64-unknown-haiku=lib$(1).a\n+CFG_LIB_GLOB_x86_64-unknown-haiku=lib$(1)-*.so\n+CFG_LIB_DSYM_GLOB_x86_64-unknown-haiku=lib$(1)-*.dylib.dSYM\n+CFG_CFLAGS_x86_64-unknown-haiku := -m64 $(CFLAGS)\n+CFG_GCCISH_CFLAGS_x86_64-unknown-haiku := -Wall -Werror -g -fPIC -m64 $(CFLAGS)\n+CFG_GCCISH_CXXFLAGS_x86_64-unknown-haiku := -fno-rtti $(CXXFLAGS)\n+CFG_GCCISH_LINK_FLAGS_x86_64-unknown-haiku := -shared -fPIC -ldl -pthread -lrt -g -m64\n+CFG_GCCISH_PRE_LIB_FLAGS_x86_64-unknown-haiku := -Wl,-whole-archive\n+CFG_GCCISH_POST_LIB_FLAGS_x86_64-unknown-haiku := -Wl,-no-whole-archive\n+CFG_DEF_SUFFIX_x86_64-unknown-haiku := .linux.def\n+CFG_LLC_FLAGS_x86_64-unknown-haiku :=\n+CFG_INSTALL_NAME_x86_64-unknown-haiku =\n+CFG_EXE_SUFFIX_x86_64-unknown-haiku =\n+CFG_WINDOWSY_x86_64-unknown-haiku :=\n+CFG_UNIXY_x86_64-unknown-haiku := 1\n+CFG_PATH_MUNGE_x86_64-unknown-haiku := true\n+CFG_LDPATH_x86_64-unknown-haiku :=\n+CFG_RUN_x86_64-unknown-haiku=$(2)\n+CFG_RUN_TARG_x86_64-unknown-haiku=$(call CFG_RUN_x86_64-unknown-haiku,,$(2))\n+CFG_GNU_TRIPLE_x86_64-unknown-haiku := x86_64-unknown-haiku"}, {"sha": "f06f6baa79d0a80c6cf78afe240eefb377466760", "filename": "mk/main.mk", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -512,10 +512,14 @@ ifeq ($$(OSTYPE_$(3)),apple-darwin)\n else\n ifeq ($$(CFG_WINDOWSY_$(3)),1)\n   LD_LIBRARY_PATH_ENV_NAME$(1)_T_$(2)_H_$(3) := PATH\n+else\n+ifeq ($$(OSTYPE_$(3)),unknown-haiku)\n+  LD_LIBRARY_PATH_ENV_NAME$(1)_T_$(2)_H_$(3) := LIBRARY_PATH\n else\n   LD_LIBRARY_PATH_ENV_NAME$(1)_T_$(2)_H_$(3) := LD_LIBRARY_PATH\n endif\n endif\n+endif\n \n LD_LIBRARY_PATH_ENV_HOSTDIR$(1)_T_$(2)_H_$(3) := \\\n     $$(CURDIR)/$$(HLIB$(1)_H_$(3)):$$(CFG_LLVM_INST_DIR_$(3))/lib"}, {"sha": "bcc53129f8d8e00666fe20cedc2561c2b5876129", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -243,7 +243,14 @@ impl Build {\n         // Almost all of these are simple one-liners that shell out to the\n         // corresponding functionality in the extra modules, where more\n         // documentation can be found.\n-        for target in step::all(self) {\n+        let steps = step::all(self);\n+\n+        self.verbose(\"bootstrap build plan:\");\n+        for step in &steps {\n+            self.verbose(&format!(\"{:?}\", step));\n+        }\n+\n+        for target in steps {\n             let doc_out = self.out.join(&target.target).join(\"doc\");\n             match target.src {\n                 Llvm { _dummy } => {"}, {"sha": "4b5a26d205af7457f7093871145457a996e86af9", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -171,6 +171,8 @@ targets!(define_source);\n /// into a topologically sorted list which when executed left-to-right will\n /// correctly sequence the entire build.\n pub fn all(build: &Build) -> Vec<Step> {\n+    build.verbose(\"inferred build steps:\");\n+\n     let mut ret = Vec::new();\n     let mut all = HashSet::new();\n     for target in top_level(build) {\n@@ -184,6 +186,7 @@ pub fn all(build: &Build) -> Vec<Step> {\n                 set: &mut HashSet<Step<'a>>) {\n         if set.insert(target.clone()) {\n             for dep in target.deps(build) {\n+                build.verbose(&format!(\"{:?}\\n  -> {:?}\", target, dep));\n                 fill(build, &dep, ret, set);\n             }\n             ret.push(target.clone());"}, {"sha": "bff448aadd5dc2df6c25c0b302acd1613fe9b405", "filename": "src/doc/book/getting-started.md", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Fdoc%2Fbook%2Fgetting-started.md", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Fdoc%2Fbook%2Fgetting-started.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fgetting-started.md?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -230,12 +230,13 @@ $ cd hello_world\n \n ## Writing and Running a Rust Program\n \n-Next, make a new source file and call it *main.rs*. Rust files always end\n-in a *.rs* extension. If you\u2019re using more than one word in your filename, use\n-an underscore to separate them; for example, you'd use *hello_world.rs* rather\n-than *helloworld.rs*.\n+We need to create a source file for our Rust program. Rust files always end\n+in a *.rs* extension. If you are using more than one word in your filename,\n+use an underscore to separate them; for example, you would use\n+*my_program.rs* rather than *myprogram.rs*.\n \n-Now open the *main.rs* file you just created, and type the following code:\n+Now, make a new file and call it *main.rs*. Open the file and type\n+the following code:\n \n ```rust\n fn main() {"}, {"sha": "645a80ab8b5813c438d60042ae1b2b674a072ceb", "filename": "src/etc/local_stage0.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Fetc%2Flocal_stage0.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Fetc%2Flocal_stage0.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flocal_stage0.sh?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -18,7 +18,7 @@ LIB_PREFIX=lib\n \n OS=`uname -s`\n case $OS in\n-    (\"Linux\"|\"FreeBSD\"|\"DragonFly\"|\"Bitrig\"|\"OpenBSD\"|\"SunOS\")\n+    (\"Linux\"|\"FreeBSD\"|\"DragonFly\"|\"Bitrig\"|\"OpenBSD\"|\"SunOS\"|\"Haiku\")\n     BIN_SUF=\n     LIB_SUF=.so\n     ;;"}, {"sha": "eb708c020826a8d792a5a5275be147aabe47fe24", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -1 +1 @@\n-Subproject commit d4f6a19c55a03e3f9f6fb7377911b37ed807eb6c\n+Subproject commit eb708c020826a8d792a5a5275be147aabe47fe24"}, {"sha": "1acd0fb0f79c05d4c0c29fb3d0abd7e2e1f50dd1", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -103,11 +103,16 @@ impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        span_err!(self.infcx.tcx.sess, span, E0512,\n+        struct_span_err!(self.infcx.tcx.sess, span, E0512,\n                   \"transmute called with differently sized types: \\\n                    {} ({}) to {} ({})\",\n                   from, skeleton_string(from, sk_from),\n-                  to, skeleton_string(to, sk_to));\n+                  to, skeleton_string(to, sk_to))\n+            .span_label(span,\n+                &format!(\"transmuting between {} and {}\",\n+                    skeleton_string(from, sk_from),\n+                    skeleton_string(to, sk_to)))\n+            .emit();\n     }\n }\n "}, {"sha": "e906c24df0ff1154d9d5571db2d414a0ff654731", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -605,6 +605,7 @@ macro_rules! options {\n         pub const parse_opt_bool: Option<&'static str> =\n             Some(\"one of: `y`, `yes`, `on`, `n`, `no`, or `off`\");\n         pub const parse_string: Option<&'static str> = Some(\"a string\");\n+        pub const parse_string_push: Option<&'static str> = Some(\"a string\");\n         pub const parse_opt_string: Option<&'static str> = Some(\"a string\");\n         pub const parse_list: Option<&'static str> = Some(\"a space-separated list of strings\");\n         pub const parse_opt_list: Option<&'static str> = Some(\"a space-separated list of strings\");\n@@ -667,6 +668,13 @@ macro_rules! options {\n             }\n         }\n \n+        fn parse_string_push(slot: &mut Vec<String>, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => { slot.push(s.to_string()); true },\n+                None => false,\n+            }\n+        }\n+\n         fn parse_list(slot: &mut Vec<String>, v: Option<&str>)\n                       -> bool {\n             match v {\n@@ -742,6 +750,8 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n         \"tool to assemble archives with\"),\n     linker: Option<String> = (None, parse_opt_string, [UNTRACKED],\n         \"system linker to link outputs with\"),\n+    link_arg: Vec<String> = (vec![], parse_string_push, [UNTRACKED],\n+        \"a single extra argument to pass to the linker (can be used several times)\"),\n     link_args: Option<Vec<String>> = (None, parse_opt_list, [UNTRACKED],\n         \"extra arguments to pass to the linker (space separated)\"),\n     link_dead_code: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "5e319ba1838a0a9558e4d31fe65092da0b5dd7b5", "filename": "src/librustc_back/target/haiku_base.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustc_back%2Ftarget%2Fhaiku_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustc_back%2Ftarget%2Fhaiku_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fhaiku_base.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::TargetOptions;\n+use std::default::Default;\n+\n+pub fn opts() -> TargetOptions {\n+    TargetOptions {\n+        linker: \"cc\".to_string(),\n+        dynamic_linking: true,\n+        executables: true,\n+        has_rpath: true,\n+        linker_is_gnu: true,\n+        .. Default::default()\n+    }\n+}"}, {"sha": "862016704f47cde38e68d5846f97de69ede07315", "filename": "src/librustc_back/target/i686_unknown_haiku.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_haiku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_haiku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_haiku.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::{Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::haiku_base::opts();\n+    base.cpu = \"pentium4\".to_string();\n+    base.max_atomic_width = 64;\n+    base.pre_link_args.push(\"-m32\".to_string());\n+\n+    Ok(Target {\n+        llvm_target: \"i686-unknown-haiku\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-f64:32:64-f80:32-n8:16:32-S128\".to_string(),\n+        arch: \"x86\".to_string(),\n+        target_os: \"haiku\".to_string(),\n+        target_env: \"\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        options: base,\n+    })\n+}"}, {"sha": "087078021a1883ec98ed0e92f5ea7f62f3c0d357", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -56,6 +56,7 @@ mod apple_ios_base;\n mod bitrig_base;\n mod dragonfly_base;\n mod freebsd_base;\n+mod haiku_base;\n mod linux_base;\n mod linux_musl_base;\n mod openbsd_base;\n@@ -165,6 +166,9 @@ supported_targets! {\n     (\"x86_64-unknown-netbsd\", x86_64_unknown_netbsd),\n     (\"x86_64-rumprun-netbsd\", x86_64_rumprun_netbsd),\n \n+    (\"i686_unknown_haiku\", i686_unknown_haiku),\n+    (\"x86_64_unknown_haiku\", x86_64_unknown_haiku),\n+\n     (\"x86_64-apple-darwin\", x86_64_apple_darwin),\n     (\"i686-apple-darwin\", i686_apple_darwin),\n "}, {"sha": "171e88cee50c4fb6165cd9b2ccaff07a62e742b9", "filename": "src/librustc_back/target/x86_64_unknown_haiku.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_haiku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_haiku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_haiku.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::{Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::haiku_base::opts();\n+    base.cpu = \"x86-64\".to_string();\n+    base.max_atomic_width = 64;\n+    base.pre_link_args.push(\"-m64\".to_string());\n+\n+    Ok(Target {\n+        llvm_target: \"x86_64-unknown-haiku\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        data_layout: \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n+        arch: \"x86_64\".to_string(),\n+        target_os: \"haiku\".to_string(),\n+        target_env: \"\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        options: base,\n+    })\n+}"}, {"sha": "510c9ceef0960a8c8b6a20e3625ee6c2e10b4052", "filename": "src/librustc_data_structures/flock.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustc_data_structures%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustc_data_structures%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fflock.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -94,6 +94,27 @@ mod imp {\n         pub const F_SETLKW: libc::c_int = 9;\n     }\n \n+    #[cfg(target_os = \"haiku\")]\n+    mod os {\n+        use libc;\n+\n+        pub struct flock {\n+            pub l_type: libc::c_short,\n+            pub l_whence: libc::c_short,\n+            pub l_start: libc::off_t,\n+            pub l_len: libc::off_t,\n+            pub l_pid: libc::pid_t,\n+\n+            // not actually here, but brings in line with freebsd\n+            pub l_sysid: libc::c_int,\n+        }\n+\n+        pub const F_UNLCK: libc::c_short = 0x0200;\n+        pub const F_WRLCK: libc::c_short = 0x0400;\n+        pub const F_SETLK: libc::c_int = 0x0080;\n+        pub const F_SETLKW: libc::c_int = 0x0100;\n+    }\n+\n     #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n     mod os {\n         use libc;"}, {"sha": "5dab82dbc7ac4f786fc1c387469a14be2ba83310", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -754,7 +754,8 @@ fn link_args(cmd: &mut Linker,\n         let empty_vec = Vec::new();\n         let empty_str = String::new();\n         let args = sess.opts.cg.link_args.as_ref().unwrap_or(&empty_vec);\n-        let mut args = args.iter().chain(used_link_args.iter());\n+        let more_args = &sess.opts.cg.link_arg;\n+        let mut args = args.iter().chain(more_args.iter()).chain(used_link_args.iter());\n         let relocation_model = sess.opts.cg.relocation_model.as_ref()\n                                    .unwrap_or(&empty_str);\n         if (t.options.relocation_model == \"pic\" || *relocation_model == \"pic\")\n@@ -844,6 +845,7 @@ fn link_args(cmd: &mut Linker,\n     if let Some(ref args) = sess.opts.cg.link_args {\n         cmd.args(args);\n     }\n+    cmd.args(&sess.opts.cg.link_arg);\n     cmd.args(&used_link_args);\n }\n "}, {"sha": "ee00cb2f5a3e4797b8fdb4f8022880dcd59d321d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -1525,9 +1525,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match self.locals.borrow().get(&nid) {\n             Some(&t) => t,\n             None => {\n-                span_err!(self.tcx.sess, span, E0513,\n-                          \"no type for local variable {}\",\n-                          nid);\n+                struct_span_err!(self.tcx.sess, span, E0513,\n+                                 \"no type for local variable {}\",\n+                                 self.tcx.map.node_to_string(nid))\n+                    .span_label(span, &\"no type for variable\")\n+                    .emit();\n                 self.tcx.types.err\n             }\n         }"}, {"sha": "0d6b43b59c6ad7b17371a7fefef4dcf92795dd4f", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -3766,6 +3766,45 @@ extern \"platform-intrinsic\" {\n ```\n \"##,\n \n+E0513: r##\"\n+The type of the variable couldn't be found out.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0513\n+use std::mem;\n+\n+unsafe {\n+    let size = mem::size_of::<u32>();\n+    mem::transmute_copy::<u32, [u8; size]>(&8_8);\n+    // error: no type for local variable\n+}\n+```\n+\n+To fix this error, please use a constant size instead of `size`. To make\n+this error more obvious, you could run:\n+\n+```compile_fail,E0080\n+use std::mem;\n+\n+unsafe {\n+    mem::transmute_copy::<u32, [u8; mem::size_of::<u32>()]>(&8_8);\n+    // error: constant evaluation error\n+}\n+```\n+\n+So now, you can fix your code by setting the size directly:\n+\n+```\n+use std::mem;\n+\n+unsafe {\n+    mem::transmute_copy::<u32, [u8; 4]>(&8_8);\n+    // `u32` is 4 bytes so we replace the `mem::size_of` call with its size\n+}\n+```\n+\"##,\n+\n E0516: r##\"\n The `typeof` keyword is currently reserved but unimplemented.\n Erroneous code example:\n@@ -4064,7 +4103,6 @@ register_diagnostics! {\n     E0399, // trait items need to be implemented because the associated\n            // type `{}` was overridden\n     E0436, // functional record update requires a struct\n-    E0513, // no type for local variable ..\n     E0521, // redundant default implementations of trait\n     E0533, // `{}` does not name a unit variant, unit struct or a constant\n     E0562, // `impl Trait` not allowed outside of function"}, {"sha": "49e467e5cbe3bba50bfc813ac45cce9c3354781a", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -32,6 +32,7 @@ use errors::emitter::ColorConfig;\n use std::cell::{RefCell, Cell};\n use std::mem;\n use std::rc::Rc;\n+use std::path::PathBuf;\n \n use visit_ast::RustdocVisitor;\n use clean;\n@@ -127,7 +128,8 @@ pub fn run_core(search_paths: SearchPaths,\n                 cfgs: Vec<String>,\n                 externs: config::Externs,\n                 input: Input,\n-                triple: Option<String>) -> (clean::Crate, RenderInfo)\n+                triple: Option<String>,\n+                maybe_sysroot: Option<PathBuf>) -> (clean::Crate, RenderInfo)\n {\n     // Parse, resolve, and typecheck the given crate.\n \n@@ -139,7 +141,7 @@ pub fn run_core(search_paths: SearchPaths,\n     let warning_lint = lint::builtin::WARNINGS.name_lower();\n \n     let sessopts = config::Options {\n-        maybe_sysroot: None,\n+        maybe_sysroot: maybe_sysroot,\n         search_paths: search_paths,\n         crate_types: vec!(config::CrateTypeRlib),\n         lint_opts: vec!((warning_lint, lint::Allow)),"}, {"sha": "cad5fae690fb817d3baf3b313945c29e10dc3b96", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -378,6 +378,11 @@ h4 > code, h3 > code, .invisible > code {\n     font-size: 90%;\n }\n \n+/* Shift where in trait listing down a line */\n+pre.trait .where::before {\n+    content: '\\a         ';\n+}\n+\n nav {\n     border-bottom: 1px solid;\n     padding-bottom: 10px;"}, {"sha": "1ff84b95da6a4c54414f9418b5a0d84d1dfd2e0c", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 14, "deletions": 36, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -91,39 +91,14 @@ pub mod test;\n \n use clean::Attributes;\n \n-type Pass = (&'static str,                                      // name\n-             fn(clean::Crate) -> plugins::PluginResult,         // fn\n-             &'static str);                                     // description\n-\n-const PASSES: &'static [Pass] = &[\n-    (\"strip-hidden\", passes::strip_hidden,\n-     \"strips all doc(hidden) items from the output\"),\n-    (\"unindent-comments\", passes::unindent_comments,\n-     \"removes excess indentation on comments in order for markdown to like it\"),\n-    (\"collapse-docs\", passes::collapse_docs,\n-     \"concatenates all document attributes into one document attribute\"),\n-    (\"strip-private\", passes::strip_private,\n-     \"strips all private items from a crate which cannot be seen externally, \\\n-      implies strip-priv-imports\"),\n-    (\"strip-priv-imports\", passes::strip_priv_imports,\n-     \"strips all private import statements (`use`, `extern crate`) from a crate\"),\n-];\n-\n-const DEFAULT_PASSES: &'static [&'static str] = &[\n-    \"strip-hidden\",\n-    \"strip-private\",\n-    \"collapse-docs\",\n-    \"unindent-comments\",\n-];\n-\n struct Output {\n     krate: clean::Crate,\n     renderinfo: html::render::RenderInfo,\n     passes: Vec<String>,\n }\n \n pub fn main() {\n-    const STACK_SIZE: usize = 32000000; // 32MB\n+    const STACK_SIZE: usize = 32_000_000; // 32MB\n     let res = std::thread::Builder::new().stack_size(STACK_SIZE).spawn(move || {\n         let s = env::args().collect::<Vec<_>>();\n         main_args(&s)\n@@ -186,6 +161,7 @@ pub fn opts() -> Vec<RustcOptGroup> {\n                          own theme\", \"PATH\")),\n         unstable(optmulti(\"Z\", \"\",\n                           \"internal and debugging options (only on nightly build)\", \"FLAG\")),\n+        stable(optopt(\"\", \"sysroot\", \"Override the system root\", \"PATH\")),\n     )\n }\n \n@@ -222,11 +198,11 @@ pub fn main_args(args: &[String]) -> isize {\n \n     if matches.opt_strs(\"passes\") == [\"list\"] {\n         println!(\"Available passes for running rustdoc:\");\n-        for &(name, _, description) in PASSES {\n+        for &(name, _, description) in passes::PASSES {\n             println!(\"{:>20} - {}\", name, description);\n         }\n         println!(\"\\nDefault passes for rustdoc:\");\n-        for &name in DEFAULT_PASSES {\n+        for &name in passes::DEFAULT_PASSES {\n             println!(\"{:>20}\", name);\n         }\n         return 0;\n@@ -235,7 +211,8 @@ pub fn main_args(args: &[String]) -> isize {\n     if matches.free.is_empty() {\n         println!(\"expected an input file to act on\");\n         return 1;\n-    } if matches.free.len() > 1 {\n+    }\n+    if matches.free.len() > 1 {\n         println!(\"only one input file may be specified\");\n         return 1;\n     }\n@@ -370,6 +347,7 @@ fn rust_input(cratefile: &str, externs: Externs, matches: &getopts::Matches) ->\n     }\n     let cfgs = matches.opt_strs(\"cfg\");\n     let triple = matches.opt_str(\"target\");\n+    let maybe_sysroot = matches.opt_str(\"sysroot\").map(PathBuf::from);\n \n     let cr = PathBuf::from(cratefile);\n     info!(\"starting to run rustc\");\n@@ -379,7 +357,7 @@ fn rust_input(cratefile: &str, externs: Externs, matches: &getopts::Matches) ->\n         use rustc::session::config::Input;\n \n         tx.send(core::run_core(paths, cfgs, externs, Input::File(cr),\n-                               triple)).unwrap();\n+                               triple, maybe_sysroot)).unwrap();\n     });\n     let (mut krate, renderinfo) = rx.recv().unwrap();\n     info!(\"finished with rustc\");\n@@ -410,7 +388,7 @@ fn rust_input(cratefile: &str, externs: Externs, matches: &getopts::Matches) ->\n     }\n \n     if default_passes {\n-        for name in DEFAULT_PASSES.iter().rev() {\n+        for name in passes::DEFAULT_PASSES.iter().rev() {\n             passes.insert(0, name.to_string());\n         }\n     }\n@@ -420,11 +398,11 @@ fn rust_input(cratefile: &str, externs: Externs, matches: &getopts::Matches) ->\n                       .unwrap_or(\"/tmp/rustdoc/plugins\".to_string());\n     let mut pm = plugins::PluginManager::new(PathBuf::from(path));\n     for pass in &passes {\n-        let plugin = match PASSES.iter()\n-                                 .position(|&(p, ..)| {\n-                                     p == *pass\n-                                 }) {\n-            Some(i) => PASSES[i].1,\n+        let plugin = match passes::PASSES.iter()\n+                                         .position(|&(p, ..)| {\n+                                             p == *pass\n+                                         }) {\n+            Some(i) => passes::PASSES[i].1,\n             None => {\n                 error!(\"unknown pass {}, skipping\", *pass);\n                 continue"}, {"sha": "c60e22824965f97248cee5444111f0b20758c88d", "filename": "src/librustdoc/passes.rs", "status": "removed", "additions": 0, "deletions": 416, "changes": 416, "blob_url": "https://github.com/rust-lang/rust/blob/d0623cf7bda44849ab5df78a06b22f9108cf821a/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0623cf7bda44849ab5df78a06b22f9108cf821a/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=d0623cf7bda44849ab5df78a06b22f9108cf821a", "patch": "@@ -1,416 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::hir::def_id::DefId;\n-use rustc::middle::privacy::AccessLevels;\n-use rustc::util::nodemap::DefIdSet;\n-use std::cmp;\n-use std::mem;\n-use std::string::String;\n-use std::usize;\n-\n-use clean::{self, Attributes, GetDefId};\n-use clean::Item;\n-use plugins;\n-use fold;\n-use fold::DocFolder;\n-use fold::FoldItem::Strip;\n-\n-/// Strip items marked `#[doc(hidden)]`\n-pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n-    let mut retained = DefIdSet();\n-\n-    // strip all #[doc(hidden)] items\n-    let krate = {\n-        struct Stripper<'a> {\n-            retained: &'a mut DefIdSet,\n-            update_retained: bool,\n-        }\n-        impl<'a> fold::DocFolder for Stripper<'a> {\n-            fn fold_item(&mut self, i: Item) -> Option<Item> {\n-                if i.attrs.list(\"doc\").has_word(\"hidden\") {\n-                    debug!(\"found one in strip_hidden; removing\");\n-                    // use a dedicated hidden item for given item type if any\n-                    match i.inner {\n-                        clean::StructFieldItem(..) | clean::ModuleItem(..) => {\n-                            // We need to recurse into stripped modules to\n-                            // strip things like impl methods but when doing so\n-                            // we must not add any items to the `retained` set.\n-                            let old = mem::replace(&mut self.update_retained, false);\n-                            let ret = Strip(self.fold_item_recur(i).unwrap()).fold();\n-                            self.update_retained = old;\n-                            return ret;\n-                        }\n-                        _ => return None,\n-                    }\n-                } else {\n-                    if self.update_retained {\n-                        self.retained.insert(i.def_id);\n-                    }\n-                }\n-                self.fold_item_recur(i)\n-            }\n-        }\n-        let mut stripper = Stripper{ retained: &mut retained, update_retained: true };\n-        stripper.fold_crate(krate)\n-    };\n-\n-    // strip all impls referencing stripped items\n-    let mut stripper = ImplStripper { retained: &retained };\n-    stripper.fold_crate(krate)\n-}\n-\n-/// Strip private items from the point of view of a crate or externally from a\n-/// crate, specified by the `xcrate` flag.\n-pub fn strip_private(mut krate: clean::Crate) -> plugins::PluginResult {\n-    // This stripper collects all *retained* nodes.\n-    let mut retained = DefIdSet();\n-    let access_levels = krate.access_levels.clone();\n-\n-    // strip all private items\n-    {\n-        let mut stripper = Stripper {\n-            retained: &mut retained,\n-            access_levels: &access_levels,\n-            update_retained: true,\n-        };\n-        krate = ImportStripper.fold_crate(stripper.fold_crate(krate));\n-    }\n-\n-    // strip all impls referencing private items\n-    let mut stripper = ImplStripper { retained: &retained };\n-    stripper.fold_crate(krate)\n-}\n-\n-struct Stripper<'a> {\n-    retained: &'a mut DefIdSet,\n-    access_levels: &'a AccessLevels<DefId>,\n-    update_retained: bool,\n-}\n-\n-impl<'a> fold::DocFolder for Stripper<'a> {\n-    fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        match i.inner {\n-            clean::StrippedItem(..) => {\n-                // We need to recurse into stripped modules to strip things\n-                // like impl methods but when doing so we must not add any\n-                // items to the `retained` set.\n-                let old = mem::replace(&mut self.update_retained, false);\n-                let ret = self.fold_item_recur(i);\n-                self.update_retained = old;\n-                return ret;\n-            }\n-            // These items can all get re-exported\n-            clean::TypedefItem(..) | clean::StaticItem(..) |\n-            clean::StructItem(..) | clean::EnumItem(..) |\n-            clean::TraitItem(..) | clean::FunctionItem(..) |\n-            clean::VariantItem(..) | clean::MethodItem(..) |\n-            clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) |\n-            clean::ConstantItem(..) | clean::UnionItem(..) => {\n-                if i.def_id.is_local() {\n-                    if !self.access_levels.is_exported(i.def_id) {\n-                        return None;\n-                    }\n-                }\n-            }\n-\n-            clean::StructFieldItem(..) => {\n-                if i.visibility != Some(clean::Public) {\n-                    return Strip(i).fold();\n-                }\n-            }\n-\n-            clean::ModuleItem(..) => {\n-                if i.def_id.is_local() && i.visibility != Some(clean::Public) {\n-                    let old = mem::replace(&mut self.update_retained, false);\n-                    let ret = Strip(self.fold_item_recur(i).unwrap()).fold();\n-                    self.update_retained = old;\n-                    return ret;\n-                }\n-            }\n-\n-            // handled in the `strip-priv-imports` pass\n-            clean::ExternCrateItem(..) | clean::ImportItem(..) => {}\n-\n-            clean::DefaultImplItem(..) | clean::ImplItem(..) => {}\n-\n-            // tymethods/macros have no control over privacy\n-            clean::MacroItem(..) | clean::TyMethodItem(..) => {}\n-\n-            // Primitives are never stripped\n-            clean::PrimitiveItem(..) => {}\n-\n-            // Associated consts and types are never stripped\n-            clean::AssociatedConstItem(..) |\n-            clean::AssociatedTypeItem(..) => {}\n-        }\n-\n-        let fastreturn = match i.inner {\n-            // nothing left to do for traits (don't want to filter their\n-            // methods out, visibility controlled by the trait)\n-            clean::TraitItem(..) => true,\n-\n-            // implementations of traits are always public.\n-            clean::ImplItem(ref imp) if imp.trait_.is_some() => true,\n-            // Struct variant fields have inherited visibility\n-            clean::VariantItem(clean::Variant {\n-                kind: clean::StructVariant(..)\n-            }) => true,\n-            _ => false,\n-        };\n-\n-        let i = if fastreturn {\n-            if self.update_retained {\n-                self.retained.insert(i.def_id);\n-            }\n-            return Some(i);\n-        } else {\n-            self.fold_item_recur(i)\n-        };\n-\n-        i.and_then(|i| {\n-            match i.inner {\n-                // emptied modules have no need to exist\n-                clean::ModuleItem(ref m)\n-                    if m.items.is_empty() &&\n-                       i.doc_value().is_none() => None,\n-                _ => {\n-                    if self.update_retained {\n-                        self.retained.insert(i.def_id);\n-                    }\n-                    Some(i)\n-                }\n-            }\n-        })\n-    }\n-}\n-\n-// This stripper discards all impls which reference stripped items\n-struct ImplStripper<'a> {\n-    retained: &'a DefIdSet\n-}\n-\n-impl<'a> fold::DocFolder for ImplStripper<'a> {\n-    fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        if let clean::ImplItem(ref imp) = i.inner {\n-            // emptied none trait impls can be stripped\n-            if imp.trait_.is_none() && imp.items.is_empty() {\n-                return None;\n-            }\n-            if let Some(did) = imp.for_.def_id() {\n-                if did.is_local() && !imp.for_.is_generic() &&\n-                    !self.retained.contains(&did)\n-                {\n-                    return None;\n-                }\n-            }\n-            if let Some(did) = imp.trait_.def_id() {\n-                if did.is_local() && !self.retained.contains(&did) {\n-                    return None;\n-                }\n-            }\n-        }\n-        self.fold_item_recur(i)\n-    }\n-}\n-\n-// This stripper discards all private import statements (`use`, `extern crate`)\n-struct ImportStripper;\n-impl fold::DocFolder for ImportStripper {\n-    fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        match i.inner {\n-            clean::ExternCrateItem(..) |\n-            clean::ImportItem(..) if i.visibility != Some(clean::Public) => None,\n-            _ => self.fold_item_recur(i)\n-        }\n-    }\n-}\n-\n-pub fn strip_priv_imports(krate: clean::Crate)  -> plugins::PluginResult {\n-    ImportStripper.fold_crate(krate)\n-}\n-\n-pub fn unindent_comments(krate: clean::Crate) -> plugins::PluginResult {\n-    struct CommentCleaner;\n-    impl fold::DocFolder for CommentCleaner {\n-        fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n-            let mut avec: Vec<clean::Attribute> = Vec::new();\n-            for attr in &i.attrs {\n-                match attr {\n-                    &clean::NameValue(ref x, ref s)\n-                            if \"doc\" == *x => {\n-                        avec.push(clean::NameValue(\"doc\".to_string(),\n-                                                   unindent(s)))\n-                    }\n-                    x => avec.push(x.clone())\n-                }\n-            }\n-            i.attrs = avec;\n-            self.fold_item_recur(i)\n-        }\n-    }\n-    let mut cleaner = CommentCleaner;\n-    let krate = cleaner.fold_crate(krate);\n-    krate\n-}\n-\n-pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n-    struct Collapser;\n-    impl fold::DocFolder for Collapser {\n-        fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n-            let mut docstr = String::new();\n-            for attr in &i.attrs {\n-                if let clean::NameValue(ref x, ref s) = *attr {\n-                    if \"doc\" == *x {\n-                        docstr.push_str(s);\n-                        docstr.push('\\n');\n-                    }\n-                }\n-            }\n-            let mut a: Vec<clean::Attribute> = i.attrs.iter().filter(|&a| match a {\n-                &clean::NameValue(ref x, _) if \"doc\" == *x => false,\n-                _ => true\n-            }).cloned().collect();\n-            if !docstr.is_empty() {\n-                a.push(clean::NameValue(\"doc\".to_string(), docstr));\n-            }\n-            i.attrs = a;\n-            self.fold_item_recur(i)\n-        }\n-    }\n-    let mut collapser = Collapser;\n-    let krate = collapser.fold_crate(krate);\n-    krate\n-}\n-\n-pub fn unindent(s: &str) -> String {\n-    let lines = s.lines().collect::<Vec<&str> >();\n-    let mut saw_first_line = false;\n-    let mut saw_second_line = false;\n-    let min_indent = lines.iter().fold(usize::MAX, |min_indent, line| {\n-\n-        // After we see the first non-whitespace line, look at\n-        // the line we have. If it is not whitespace, and therefore\n-        // part of the first paragraph, then ignore the indentation\n-        // level of the first line\n-        let ignore_previous_indents =\n-            saw_first_line &&\n-            !saw_second_line &&\n-            !line.chars().all(|c| c.is_whitespace());\n-\n-        let min_indent = if ignore_previous_indents {\n-            usize::MAX\n-        } else {\n-            min_indent\n-        };\n-\n-        if saw_first_line {\n-            saw_second_line = true;\n-        }\n-\n-        if line.chars().all(|c| c.is_whitespace()) {\n-            min_indent\n-        } else {\n-            saw_first_line = true;\n-            let mut whitespace = 0;\n-            line.chars().all(|char| {\n-                // Compare against either space or tab, ignoring whether they\n-                // are mixed or not\n-                if char == ' ' || char == '\\t' {\n-                    whitespace += 1;\n-                    true\n-                } else {\n-                    false\n-                }\n-            });\n-            cmp::min(min_indent, whitespace)\n-        }\n-    });\n-\n-    if !lines.is_empty() {\n-        let mut unindented = vec![ lines[0].trim().to_string() ];\n-        unindented.extend_from_slice(&lines[1..].iter().map(|&line| {\n-            if line.chars().all(|c| c.is_whitespace()) {\n-                line.to_string()\n-            } else {\n-                assert!(line.len() >= min_indent);\n-                line[min_indent..].to_string()\n-            }\n-        }).collect::<Vec<_>>());\n-        unindented.join(\"\\n\")\n-    } else {\n-        s.to_string()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod unindent_tests {\n-    use super::unindent;\n-\n-    #[test]\n-    fn should_unindent() {\n-        let s = \"    line1\\n    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\nline2\");\n-    }\n-\n-    #[test]\n-    fn should_unindent_multiple_paragraphs() {\n-        let s = \"    line1\\n\\n    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\n\\nline2\");\n-    }\n-\n-    #[test]\n-    fn should_leave_multiple_indent_levels() {\n-        // Line 2 is indented another level beyond the\n-        // base indentation and should be preserved\n-        let s = \"    line1\\n\\n        line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\n\\n    line2\");\n-    }\n-\n-    #[test]\n-    fn should_ignore_first_line_indent() {\n-        // The first line of the first paragraph may not be indented as\n-        // far due to the way the doc string was written:\n-        //\n-        // #[doc = \"Start way over here\n-        //          and continue here\"]\n-        let s = \"line1\\n    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\nline2\");\n-    }\n-\n-    #[test]\n-    fn should_not_ignore_first_line_indent_in_a_single_line_para() {\n-        let s = \"line1\\n\\n    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\n\\n    line2\");\n-    }\n-\n-    #[test]\n-    fn should_unindent_tabs() {\n-        let s = \"\\tline1\\n\\tline2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\nline2\");\n-    }\n-\n-    #[test]\n-    fn should_trim_mixed_indentation() {\n-        let s = \"\\t    line1\\n\\t    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\nline2\");\n-\n-        let s = \"    \\tline1\\n    \\tline2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\nline2\");\n-    }\n-}"}, {"sha": "c034ef9326846c349b7761606918c72bd1fad35d", "filename": "src/librustdoc/passes/collapse_docs.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::string::String;\n+\n+use clean::{self, Item};\n+use plugins;\n+use fold;\n+use fold::DocFolder;\n+\n+pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n+    let mut collapser = Collapser;\n+    let krate = collapser.fold_crate(krate);\n+    krate\n+}\n+\n+struct Collapser;\n+\n+impl fold::DocFolder for Collapser {\n+    fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n+        let mut docstr = String::new();\n+        for attr in &i.attrs {\n+            if let clean::NameValue(ref x, ref s) = *attr {\n+                if \"doc\" == *x {\n+                    docstr.push_str(s);\n+                    docstr.push('\\n');\n+                }\n+            }\n+        }\n+        let mut a: Vec<clean::Attribute> = i.attrs.iter().filter(|&a| match a {\n+            &clean::NameValue(ref x, _) if \"doc\" == *x => false,\n+            _ => true\n+        }).cloned().collect();\n+        if !docstr.is_empty() {\n+            a.push(clean::NameValue(\"doc\".to_string(), docstr));\n+        }\n+        i.attrs = a;\n+        self.fold_item_recur(i)\n+    }\n+}"}, {"sha": "a1b330e9b842349e72f68f3d37b7846a2723e5e0", "filename": "src/librustdoc/passes/mod.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -0,0 +1,204 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir::def_id::DefId;\n+use rustc::middle::privacy::AccessLevels;\n+use rustc::util::nodemap::DefIdSet;\n+use std::mem;\n+\n+use clean::{self, GetDefId, Item};\n+use fold;\n+use fold::FoldItem::Strip;\n+use plugins;\n+\n+mod collapse_docs;\n+pub use self::collapse_docs::collapse_docs;\n+\n+mod strip_hidden;\n+pub use self::strip_hidden::strip_hidden;\n+\n+mod strip_private;\n+pub use self::strip_private::strip_private;\n+\n+mod strip_priv_imports;\n+pub use self::strip_priv_imports::strip_priv_imports;\n+\n+mod unindent_comments;\n+pub use self::unindent_comments::unindent_comments;\n+\n+type Pass = (&'static str,                                      // name\n+             fn(clean::Crate) -> plugins::PluginResult,         // fn\n+             &'static str);                                     // description\n+\n+pub const PASSES: &'static [Pass] = &[\n+    (\"strip-hidden\", strip_hidden,\n+     \"strips all doc(hidden) items from the output\"),\n+    (\"unindent-comments\", unindent_comments,\n+     \"removes excess indentation on comments in order for markdown to like it\"),\n+    (\"collapse-docs\", collapse_docs,\n+     \"concatenates all document attributes into one document attribute\"),\n+    (\"strip-private\", strip_private,\n+     \"strips all private items from a crate which cannot be seen externally, \\\n+      implies strip-priv-imports\"),\n+    (\"strip-priv-imports\", strip_priv_imports,\n+     \"strips all private import statements (`use`, `extern crate`) from a crate\"),\n+];\n+\n+pub const DEFAULT_PASSES: &'static [&'static str] = &[\n+    \"strip-hidden\",\n+    \"strip-private\",\n+    \"collapse-docs\",\n+    \"unindent-comments\",\n+];\n+\n+\n+struct Stripper<'a> {\n+    retained: &'a mut DefIdSet,\n+    access_levels: &'a AccessLevels<DefId>,\n+    update_retained: bool,\n+}\n+\n+impl<'a> fold::DocFolder for Stripper<'a> {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        match i.inner {\n+            clean::StrippedItem(..) => {\n+                // We need to recurse into stripped modules to strip things\n+                // like impl methods but when doing so we must not add any\n+                // items to the `retained` set.\n+                let old = mem::replace(&mut self.update_retained, false);\n+                let ret = self.fold_item_recur(i);\n+                self.update_retained = old;\n+                return ret;\n+            }\n+            // These items can all get re-exported\n+            clean::TypedefItem(..) | clean::StaticItem(..) |\n+            clean::StructItem(..) | clean::EnumItem(..) |\n+            clean::TraitItem(..) | clean::FunctionItem(..) |\n+            clean::VariantItem(..) | clean::MethodItem(..) |\n+            clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) |\n+            clean::ConstantItem(..) | clean::UnionItem(..) => {\n+                if i.def_id.is_local() {\n+                    if !self.access_levels.is_exported(i.def_id) {\n+                        return None;\n+                    }\n+                }\n+            }\n+\n+            clean::StructFieldItem(..) => {\n+                if i.visibility != Some(clean::Public) {\n+                    return Strip(i).fold();\n+                }\n+            }\n+\n+            clean::ModuleItem(..) => {\n+                if i.def_id.is_local() && i.visibility != Some(clean::Public) {\n+                    let old = mem::replace(&mut self.update_retained, false);\n+                    let ret = Strip(self.fold_item_recur(i).unwrap()).fold();\n+                    self.update_retained = old;\n+                    return ret;\n+                }\n+            }\n+\n+            // handled in the `strip-priv-imports` pass\n+            clean::ExternCrateItem(..) | clean::ImportItem(..) => {}\n+\n+            clean::DefaultImplItem(..) | clean::ImplItem(..) => {}\n+\n+            // tymethods/macros have no control over privacy\n+            clean::MacroItem(..) | clean::TyMethodItem(..) => {}\n+\n+            // Primitives are never stripped\n+            clean::PrimitiveItem(..) => {}\n+\n+            // Associated consts and types are never stripped\n+            clean::AssociatedConstItem(..) |\n+            clean::AssociatedTypeItem(..) => {}\n+        }\n+\n+        let fastreturn = match i.inner {\n+            // nothing left to do for traits (don't want to filter their\n+            // methods out, visibility controlled by the trait)\n+            clean::TraitItem(..) => true,\n+\n+            // implementations of traits are always public.\n+            clean::ImplItem(ref imp) if imp.trait_.is_some() => true,\n+            // Struct variant fields have inherited visibility\n+            clean::VariantItem(clean::Variant {\n+                kind: clean::StructVariant(..)\n+            }) => true,\n+            _ => false,\n+        };\n+\n+        let i = if fastreturn {\n+            if self.update_retained {\n+                self.retained.insert(i.def_id);\n+            }\n+            return Some(i);\n+        } else {\n+            self.fold_item_recur(i)\n+        };\n+\n+        i.and_then(|i| {\n+            match i.inner {\n+                // emptied modules have no need to exist\n+                clean::ModuleItem(ref m)\n+                    if m.items.is_empty() &&\n+                       i.doc_value().is_none() => None,\n+                _ => {\n+                    if self.update_retained {\n+                        self.retained.insert(i.def_id);\n+                    }\n+                    Some(i)\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+// This stripper discards all impls which reference stripped items\n+struct ImplStripper<'a> {\n+    retained: &'a DefIdSet\n+}\n+\n+impl<'a> fold::DocFolder for ImplStripper<'a> {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        if let clean::ImplItem(ref imp) = i.inner {\n+            // emptied none trait impls can be stripped\n+            if imp.trait_.is_none() && imp.items.is_empty() {\n+                return None;\n+            }\n+            if let Some(did) = imp.for_.def_id() {\n+                if did.is_local() && !imp.for_.is_generic() &&\n+                    !self.retained.contains(&did)\n+                {\n+                    return None;\n+                }\n+            }\n+            if let Some(did) = imp.trait_.def_id() {\n+                if did.is_local() && !self.retained.contains(&did) {\n+                    return None;\n+                }\n+            }\n+        }\n+        self.fold_item_recur(i)\n+    }\n+}\n+\n+// This stripper discards all private import statements (`use`, `extern crate`)\n+struct ImportStripper;\n+impl fold::DocFolder for ImportStripper {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        match i.inner {\n+            clean::ExternCrateItem(..) |\n+            clean::ImportItem(..) if i.visibility != Some(clean::Public) => None,\n+            _ => self.fold_item_recur(i)\n+        }\n+    }\n+}"}, {"sha": "927ccf917199978221c2488262aa97e838869e03", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::util::nodemap::DefIdSet;\n+use std::mem;\n+\n+use clean::{self, Attributes};\n+use clean::Item;\n+use plugins;\n+use fold;\n+use fold::DocFolder;\n+use fold::FoldItem::Strip;\n+use passes::ImplStripper;\n+\n+/// Strip items marked `#[doc(hidden)]`\n+pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n+    let mut retained = DefIdSet();\n+\n+    // strip all #[doc(hidden)] items\n+    let krate = {\n+        let mut stripper = Stripper{ retained: &mut retained, update_retained: true };\n+        stripper.fold_crate(krate)\n+    };\n+\n+    // strip all impls referencing stripped items\n+    let mut stripper = ImplStripper { retained: &retained };\n+    stripper.fold_crate(krate)\n+}\n+\n+struct Stripper<'a> {\n+    retained: &'a mut DefIdSet,\n+    update_retained: bool,\n+}\n+\n+impl<'a> fold::DocFolder for Stripper<'a> {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        if i.attrs.list(\"doc\").has_word(\"hidden\") {\n+            debug!(\"found one in strip_hidden; removing\");\n+            // use a dedicated hidden item for given item type if any\n+            match i.inner {\n+                clean::StructFieldItem(..) | clean::ModuleItem(..) => {\n+                    // We need to recurse into stripped modules to\n+                    // strip things like impl methods but when doing so\n+                    // we must not add any items to the `retained` set.\n+                    let old = mem::replace(&mut self.update_retained, false);\n+                    let ret = Strip(self.fold_item_recur(i).unwrap()).fold();\n+                    self.update_retained = old;\n+                    return ret;\n+                }\n+                _ => return None,\n+            }\n+        } else {\n+            if self.update_retained {\n+                self.retained.insert(i.def_id);\n+            }\n+        }\n+        self.fold_item_recur(i)\n+    }\n+}"}, {"sha": "91f8be43c281a629de133d6de245e973fc35191c", "filename": "src/librustdoc/passes/strip_priv_imports.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use clean;\n+use fold::DocFolder;\n+use plugins;\n+use passes::ImportStripper;\n+\n+pub fn strip_priv_imports(krate: clean::Crate)  -> plugins::PluginResult {\n+    ImportStripper.fold_crate(krate)\n+}"}, {"sha": "acd735739e4887520b3c36a605f487239d6a7de8", "filename": "src/librustdoc/passes/strip_private.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::util::nodemap::DefIdSet;\n+\n+use clean;\n+use plugins;\n+use fold::DocFolder;\n+use passes::{ImplStripper, ImportStripper, Stripper};\n+\n+/// Strip private items from the point of view of a crate or externally from a\n+/// crate, specified by the `xcrate` flag.\n+pub fn strip_private(mut krate: clean::Crate) -> plugins::PluginResult {\n+    // This stripper collects all *retained* nodes.\n+    let mut retained = DefIdSet();\n+    let access_levels = krate.access_levels.clone();\n+\n+    // strip all private items\n+    {\n+        let mut stripper = Stripper {\n+            retained: &mut retained,\n+            access_levels: &access_levels,\n+            update_retained: true,\n+        };\n+        krate = ImportStripper.fold_crate(stripper.fold_crate(krate));\n+    }\n+\n+    // strip all impls referencing private items\n+    let mut stripper = ImplStripper { retained: &retained };\n+    stripper.fold_crate(krate)\n+}"}, {"sha": "20640f3f88518f98d2c8f7269a9377a9f698559e", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -0,0 +1,168 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cmp;\n+use std::string::String;\n+use std::usize;\n+\n+use clean::{self, Item};\n+use plugins;\n+use fold::{self, DocFolder};\n+\n+pub fn unindent_comments(krate: clean::Crate) -> plugins::PluginResult {\n+    let mut cleaner = CommentCleaner;\n+    let krate = cleaner.fold_crate(krate);\n+    krate\n+}\n+\n+struct CommentCleaner;\n+\n+impl fold::DocFolder for CommentCleaner {\n+    fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n+        let mut avec: Vec<clean::Attribute> = Vec::new();\n+        for attr in &i.attrs {\n+            match attr {\n+                &clean::NameValue(ref x, ref s)\n+                        if \"doc\" == *x => {\n+                    avec.push(clean::NameValue(\"doc\".to_string(),\n+                                               unindent(s)))\n+                }\n+                x => avec.push(x.clone())\n+            }\n+        }\n+        i.attrs = avec;\n+        self.fold_item_recur(i)\n+    }\n+}\n+\n+fn unindent(s: &str) -> String {\n+    let lines = s.lines().collect::<Vec<&str> >();\n+    let mut saw_first_line = false;\n+    let mut saw_second_line = false;\n+    let min_indent = lines.iter().fold(usize::MAX, |min_indent, line| {\n+\n+        // After we see the first non-whitespace line, look at\n+        // the line we have. If it is not whitespace, and therefore\n+        // part of the first paragraph, then ignore the indentation\n+        // level of the first line\n+        let ignore_previous_indents =\n+            saw_first_line &&\n+            !saw_second_line &&\n+            !line.chars().all(|c| c.is_whitespace());\n+\n+        let min_indent = if ignore_previous_indents {\n+            usize::MAX\n+        } else {\n+            min_indent\n+        };\n+\n+        if saw_first_line {\n+            saw_second_line = true;\n+        }\n+\n+        if line.chars().all(|c| c.is_whitespace()) {\n+            min_indent\n+        } else {\n+            saw_first_line = true;\n+            let mut whitespace = 0;\n+            line.chars().all(|char| {\n+                // Compare against either space or tab, ignoring whether they\n+                // are mixed or not\n+                if char == ' ' || char == '\\t' {\n+                    whitespace += 1;\n+                    true\n+                } else {\n+                    false\n+                }\n+            });\n+            cmp::min(min_indent, whitespace)\n+        }\n+    });\n+\n+    if !lines.is_empty() {\n+        let mut unindented = vec![ lines[0].trim().to_string() ];\n+        unindented.extend_from_slice(&lines[1..].iter().map(|&line| {\n+            if line.chars().all(|c| c.is_whitespace()) {\n+                line.to_string()\n+            } else {\n+                assert!(line.len() >= min_indent);\n+                line[min_indent..].to_string()\n+            }\n+        }).collect::<Vec<_>>());\n+        unindented.join(\"\\n\")\n+    } else {\n+        s.to_string()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod unindent_tests {\n+    use super::unindent;\n+\n+    #[test]\n+    fn should_unindent() {\n+        let s = \"    line1\\n    line2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1\\nline2\");\n+    }\n+\n+    #[test]\n+    fn should_unindent_multiple_paragraphs() {\n+        let s = \"    line1\\n\\n    line2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1\\n\\nline2\");\n+    }\n+\n+    #[test]\n+    fn should_leave_multiple_indent_levels() {\n+        // Line 2 is indented another level beyond the\n+        // base indentation and should be preserved\n+        let s = \"    line1\\n\\n        line2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1\\n\\n    line2\");\n+    }\n+\n+    #[test]\n+    fn should_ignore_first_line_indent() {\n+        // The first line of the first paragraph may not be indented as\n+        // far due to the way the doc string was written:\n+        //\n+        // #[doc = \"Start way over here\n+        //          and continue here\"]\n+        let s = \"line1\\n    line2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1\\nline2\");\n+    }\n+\n+    #[test]\n+    fn should_not_ignore_first_line_indent_in_a_single_line_para() {\n+        let s = \"line1\\n\\n    line2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1\\n\\n    line2\");\n+    }\n+\n+    #[test]\n+    fn should_unindent_tabs() {\n+        let s = \"\\tline1\\n\\tline2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1\\nline2\");\n+    }\n+\n+    #[test]\n+    fn should_trim_mixed_indentation() {\n+        let s = \"\\t    line1\\n\\t    line2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1\\nline2\");\n+\n+        let s = \"    \\tline1\\n    \\tline2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1\\nline2\");\n+    }\n+}"}, {"sha": "5171fbdf03e80702f3b44fda48151af5ba5dba1d", "filename": "src/libstd/env.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -903,6 +903,17 @@ mod os {\n     pub const EXE_EXTENSION: &'static str = \"js\";\n }\n \n+#[cfg(target_os = \"haiku\")]\n+mod os {\n+    pub const FAMILY: &'static str = \"unix\";\n+    pub const OS: &'static str = \"haiku\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n #[cfg(target_arch = \"x86\")]\n mod arch {\n     pub const ARCH: &'static str = \"x86\";"}, {"sha": "54f8ea1b71b3effa9556cb0cc6672b95579831d0", "filename": "src/libstd/os/haiku/fs.rs", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fos%2Fhaiku%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fos%2Fhaiku%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fhaiku%2Ffs.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -0,0 +1,138 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+\n+use libc;\n+\n+use fs::Metadata;\n+use sys_common::AsInner;\n+\n+#[allow(deprecated)]\n+use os::haiku::raw;\n+\n+/// OS-specific extension methods for `fs::Metadata`\n+#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+pub trait MetadataExt {\n+    /// Gain a reference to the underlying `stat` structure which contains\n+    /// the raw information returned by the OS.\n+    ///\n+    /// The contents of the returned `stat` are **not** consistent across\n+    /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n+    /// cross-Unix abstractions contained within the raw stat.\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    #[rustc_deprecated(since = \"1.8.0\",\n+                       reason = \"deprecated in favor of the accessor \\\n+                                 methods of this trait\")]\n+    #[allow(deprecated)]\n+    fn as_raw_stat(&self) -> &raw::stat;\n+\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_dev(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ino(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mode(&self) -> u32;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_nlink(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_uid(&self) -> u32;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_gid(&self) -> u32;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_rdev(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_size(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_atime(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_atime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mtime(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mtime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ctime(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ctime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_crtime(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_crtime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_blksize(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_blocks(&self) -> u64;\n+}\n+\n+#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+impl MetadataExt for Metadata {\n+    #[allow(deprecated)]\n+    fn as_raw_stat(&self) -> &raw::stat {\n+        unsafe {\n+            &*(self.as_inner().as_inner() as *const libc::stat\n+                                          as *const raw::stat)\n+        }\n+    }\n+    fn st_dev(&self) -> u64 {\n+        self.as_inner().as_inner().st_dev as u64\n+    }\n+    fn st_ino(&self) -> u64 {\n+        self.as_inner().as_inner().st_ino as u64\n+    }\n+    fn st_mode(&self) -> u32 {\n+        self.as_inner().as_inner().st_mode as u32\n+    }\n+    fn st_nlink(&self) -> u64 {\n+        self.as_inner().as_inner().st_nlink as u64\n+    }\n+    fn st_uid(&self) -> u32 {\n+        self.as_inner().as_inner().st_uid as u32\n+    }\n+    fn st_gid(&self) -> u32 {\n+        self.as_inner().as_inner().st_gid as u32\n+    }\n+    fn st_rdev(&self) -> u64 {\n+        self.as_inner().as_inner().st_rdev as u64\n+    }\n+    fn st_size(&self) -> u64 {\n+        self.as_inner().as_inner().st_size as u64\n+    }\n+    fn st_atime(&self) -> i64 {\n+        self.as_inner().as_inner().st_atime as i64\n+    }\n+    fn st_atime_nsec(&self) -> i64 {\n+        self.as_inner().as_inner().st_atime_nsec as i64\n+    }\n+    fn st_mtime(&self) -> i64 {\n+        self.as_inner().as_inner().st_mtime as i64\n+    }\n+    fn st_mtime_nsec(&self) -> i64 {\n+        self.as_inner().as_inner().st_mtime_nsec as i64\n+    }\n+    fn st_ctime(&self) -> i64 {\n+        self.as_inner().as_inner().st_ctime as i64\n+    }\n+    fn st_ctime_nsec(&self) -> i64 {\n+        self.as_inner().as_inner().st_ctime_nsec as i64\n+    }\n+    fn st_crtime(&self) -> i64 {\n+        self.as_inner().as_inner().st_crtime as i64\n+    }\n+    fn st_crtime_nsec(&self) -> i64 {\n+        self.as_inner().as_inner().st_crtime_nsec as i64\n+    }\n+    fn st_blksize(&self) -> u64 {\n+        self.as_inner().as_inner().st_blksize as u64\n+    }\n+    fn st_blocks(&self) -> u64 {\n+        self.as_inner().as_inner().st_blocks as u64\n+    }\n+}"}, {"sha": "dd1675cc9b51f2ecf54ed08c951d2eaa1356c4ea", "filename": "src/libstd/os/haiku/mod.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fos%2Fhaiku%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fos%2Fhaiku%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fhaiku%2Fmod.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Haiku-specific definitions\n+\n+#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+\n+pub mod raw;\n+pub mod fs;"}, {"sha": "95353d999f9520067a77117f75f224fb9ba4c326", "filename": "src/libstd/os/haiku/raw.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fos%2Fhaiku%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fos%2Fhaiku%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fhaiku%2Fraw.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Haiku-specific raw type definitions\n+\n+#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+\n+#![allow(deprecated)]\n+\n+use os::raw::{c_long};\n+use os::unix::raw::{uid_t, gid_t};\n+\n+// Use the direct definition of usize, instead of uintptr_t like in libc\n+#[stable(feature = \"pthread_t\", since = \"1.8.0\")] pub type pthread_t = usize;\n+\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blkcnt_t = i64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blksize_t = i32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type dev_t = i32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type ino_t = i64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type mode_t = u32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type nlink_t = i32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type off_t = i64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type time_t = i32;\n+\n+#[repr(C)]\n+#[derive(Clone)]\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub struct stat {\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_dev: dev_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_ino: ino_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_mode: mode_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_nlink: nlink_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_uid: uid_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_gid: gid_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_size: off_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_rdev: dev_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_blksize: blksize_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_atime: time_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_atime_nsec: c_long,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_mtime: time_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_mtime_nsec: c_long,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_ctime: time_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_ctime_nsec: c_long,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_crtime: time_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_crtime_nsec: c_long,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_type: u32,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_blocks: blkcnt_t,\n+}"}, {"sha": "7622ef886935c3e601328a6dafe01d9a1f3e560e", "filename": "src/libstd/os/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmod.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -24,6 +24,7 @@ pub use sys::ext as windows;\n #[cfg(target_os = \"bitrig\")]    pub mod bitrig;\n #[cfg(target_os = \"dragonfly\")] pub mod dragonfly;\n #[cfg(target_os = \"freebsd\")]   pub mod freebsd;\n+#[cfg(target_os = \"haiku\")]     pub mod haiku;\n #[cfg(target_os = \"ios\")]       pub mod ios;\n #[cfg(target_os = \"linux\")]     pub mod linux;\n #[cfg(target_os = \"macos\")]     pub mod macos;"}, {"sha": "5dc6ee2bc8c660921d7f1cac3062ce41525d0e47", "filename": "src/libstd/rtdeps.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Frtdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Frtdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frtdeps.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -62,3 +62,7 @@ extern {}\n #[cfg(target_os = \"ios\")]\n #[link(name = \"System\")]\n extern {}\n+\n+#[cfg(target_os = \"haiku\")]\n+#[link(name = \"network\")]\n+extern {}"}, {"sha": "b5330463e30c475cdfc45ed19b99dcf8854d6d9c", "filename": "src/libstd/sys/common/args.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fsys%2Fcommon%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fsys%2Fcommon%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fargs.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -38,7 +38,8 @@ pub fn clone() -> Option<Vec<Vec<u8>>> { imp::clone() }\n           target_os = \"netbsd\",\n           target_os = \"openbsd\",\n           target_os = \"solaris\",\n-          target_os = \"emscripten\"))]\n+          target_os = \"emscripten\",\n+          target_os = \"haiku\"))]\n mod imp {\n     use libc::c_char;\n     use mem;"}, {"sha": "18280e497db1d949092cb1f6697909f1762e978f", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -24,22 +24,22 @@ use time::Duration;\n #[cfg(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n           target_os = \"ios\", target_os = \"macos\",\n           target_os = \"openbsd\", target_os = \"netbsd\",\n-          target_os = \"solaris\"))]\n+          target_os = \"solaris\", target_os = \"haiku\"))]\n use sys::net::netc::IPV6_JOIN_GROUP as IPV6_ADD_MEMBERSHIP;\n #[cfg(not(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n               target_os = \"ios\", target_os = \"macos\",\n               target_os = \"openbsd\", target_os = \"netbsd\",\n-              target_os = \"solaris\")))]\n+              target_os = \"solaris\", taget_os = \"haiku\")))]\n use sys::net::netc::IPV6_ADD_MEMBERSHIP;\n #[cfg(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n           target_os = \"ios\", target_os = \"macos\",\n           target_os = \"openbsd\", target_os = \"netbsd\",\n-          target_os = \"solaris\"))]\n+          target_os = \"solaris\", target_os = \"haiku\"))]\n use sys::net::netc::IPV6_LEAVE_GROUP as IPV6_DROP_MEMBERSHIP;\n #[cfg(not(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n               target_os = \"ios\", target_os = \"macos\",\n               target_os = \"openbsd\", target_os = \"netbsd\",\n-              target_os = \"solaris\")))]\n+              target_os = \"solaris\", target_os = \"haiku\")))]\n use sys::net::netc::IPV6_DROP_MEMBERSHIP;\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "60c1750b4693c965b9a16c50f2af30e2a0ce561d", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -59,14 +59,20 @@ impl FileDesc {\n         Ok(ret as usize)\n     }\n \n-    #[cfg(not(any(target_env = \"newlib\", target_os = \"solaris\", target_os = \"emscripten\")))]\n+    #[cfg(not(any(target_env = \"newlib\",\n+                  target_os = \"solaris\",\n+                  target_os = \"emscripten\",\n+                  target_os = \"haiku\")))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {\n             cvt(libc::ioctl(self.fd, libc::FIOCLEX))?;\n             Ok(())\n         }\n     }\n-    #[cfg(any(target_env = \"newlib\", target_os = \"solaris\", target_os = \"emscripten\"))]\n+    #[cfg(any(target_env = \"newlib\",\n+              target_os = \"solaris\",\n+              target_os = \"emscripten\",\n+              target_os = \"haiku\"))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {\n             let previous = cvt(libc::fcntl(self.fd, libc::F_GETFD))?;\n@@ -104,9 +110,9 @@ impl FileDesc {\n         // resolve so we at least compile this.\n         //\n         // [1]: http://comments.gmane.org/gmane.linux.lib.musl.general/2963\n-        #[cfg(target_os = \"android\")]\n+        #[cfg(any(target_os = \"android\", target_os = \"haiku\"))]\n         use libc::F_DUPFD as F_DUPFD_CLOEXEC;\n-        #[cfg(not(target_os = \"android\"))]\n+        #[cfg(not(any(target_os = \"android\", target_os=\"haiku\")))]\n         use libc::F_DUPFD_CLOEXEC;\n \n         let make_filedesc = |fd| {"}, {"sha": "d015aeee338dba7a3699bdf7509ef9ddd8e73c6c", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -279,7 +279,12 @@ impl DirEntry {\n         stat(&self.path()).map(|m| m.file_type())\n     }\n \n-    #[cfg(not(target_os = \"solaris\"))]\n+    #[cfg(target_os = \"haiku\")]\n+    pub fn file_type(&self) -> io::Result<FileType> {\n+        lstat(&self.path()).map(|m| m.file_type())\n+    }\n+\n+    #[cfg(not(any(target_os = \"solaris\", target_os = \"haiku\")))]\n     pub fn file_type(&self) -> io::Result<FileType> {\n         match self.entry.d_type {\n             libc::DT_CHR => Ok(FileType { mode: libc::S_IFCHR }),\n@@ -298,7 +303,8 @@ impl DirEntry {\n               target_os = \"linux\",\n               target_os = \"emscripten\",\n               target_os = \"android\",\n-              target_os = \"solaris\"))]\n+              target_os = \"solaris\",\n+              target_os = \"haiku\"))]\n     pub fn ino(&self) -> u64 {\n         self.entry.d_ino as u64\n     }\n@@ -327,7 +333,8 @@ impl DirEntry {\n     }\n     #[cfg(any(target_os = \"android\",\n               target_os = \"linux\",\n-              target_os = \"emscripten\"))]\n+              target_os = \"emscripten\",\n+              target_os = \"haiku\"))]\n     fn name_bytes(&self) -> &[u8] {\n         unsafe {\n             CStr::from_ptr(self.entry.d_name.as_ptr()).to_bytes()"}, {"sha": "3fbeda58e821d2b2614a944629f33d79f473e608", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -17,6 +17,7 @@ use libc;\n #[cfg(target_os = \"bitrig\")]    pub use os::bitrig as platform;\n #[cfg(target_os = \"dragonfly\")] pub use os::dragonfly as platform;\n #[cfg(target_os = \"freebsd\")]   pub use os::freebsd as platform;\n+#[cfg(target_os = \"haiku\")]     pub use os::haiku as platform;\n #[cfg(target_os = \"ios\")]       pub use os::ios as platform;\n #[cfg(target_os = \"linux\")]     pub use os::linux as platform;\n #[cfg(target_os = \"macos\")]     pub use os::macos as platform;"}, {"sha": "ec7ccdf5894fd01b17568bc7e314f4179ad79453", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -10,7 +10,7 @@\n \n use ffi::CStr;\n use io;\n-use libc::{self, c_int, size_t, sockaddr, socklen_t};\n+use libc::{self, c_int, size_t, sockaddr, socklen_t, EAI_SYSTEM};\n use net::{SocketAddr, Shutdown};\n use str;\n use sys::fd::FileDesc;\n@@ -38,7 +38,12 @@ pub struct Socket(FileDesc);\n pub fn init() {}\n \n pub fn cvt_gai(err: c_int) -> io::Result<()> {\n-    if err == 0 { return Ok(()) }\n+    if err == 0 {\n+        return Ok(())\n+    }\n+    if err == EAI_SYSTEM {\n+        return Err(io::Error::last_os_error())\n+    }\n \n     let detail = unsafe {\n         str::from_utf8(CStr::from_ptr(libc::gai_strerror(err)).to_bytes()).unwrap()"}, {"sha": "850c3d52715365aa5ba290565d226526d48a6166", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -51,6 +51,7 @@ extern {\n                    target_os = \"ios\",\n                    target_os = \"freebsd\"),\n                link_name = \"__error\")]\n+    #[cfg_attr(target_os = \"haiku\", link_name = \"_errnop\")]\n     fn errno_location() -> *mut c_int;\n }\n \n@@ -303,6 +304,49 @@ pub fn current_exe() -> io::Result<PathBuf> {\n     }\n }\n \n+#[cfg(target_os = \"haiku\")]\n+pub fn current_exe() -> io::Result<PathBuf> {\n+    // Use Haiku's image info functions\n+    #[repr(C)]\n+    struct image_info {\n+        id: i32,\n+        type_: i32,\n+        sequence: i32,\n+        init_order: i32,\n+        init_routine: *mut libc::c_void,    // function pointer\n+        term_routine: *mut libc::c_void,    // function pointer\n+        device: libc::dev_t,\n+        node: libc::ino_t,\n+        name: [libc::c_char; 1024],         // MAXPATHLEN\n+        text: *mut libc::c_void,\n+        data: *mut libc::c_void,\n+        text_size: i32,\n+        data_size: i32,\n+        api_version: i32,\n+        abi: i32,\n+    }\n+\n+    unsafe {\n+        extern {\n+            fn _get_next_image_info(team_id: i32, cookie: *mut i32,\n+                info: *mut image_info, size: i32) -> i32;\n+        }\n+\n+        let mut info: image_info = mem::zeroed();\n+        let mut cookie: i32 = 0;\n+        // the executable can be found at team id 0\n+        let result = _get_next_image_info(0, &mut cookie, &mut info,\n+            mem::size_of::<image_info>() as i32);\n+        if result != 0 {\n+            use io::ErrorKind;\n+            Err(io::Error::new(ErrorKind::Other, \"Error getting executable path\"))\n+        } else {\n+            let name = CStr::from_ptr(info.name.as_ptr()).to_bytes();\n+            Ok(PathBuf::from(OsStr::from_bytes(name)))\n+        }\n+    }\n+}\n+\n pub struct Args {\n     iter: vec::IntoIter<OsString>,\n     _dont_send_or_sync_me: PhantomData<*mut ()>,\n@@ -412,7 +456,8 @@ pub fn args() -> Args {\n           target_os = \"openbsd\",\n           target_os = \"solaris\",\n           target_os = \"nacl\",\n-          target_os = \"emscripten\"))]\n+          target_os = \"emscripten\",\n+          target_os = \"haiku\"))]\n pub fn args() -> Args {\n     use sys_common;\n     let bytes = sys_common::args::clone().unwrap_or(Vec::new());"}, {"sha": "980ef01f549c36b9d10f0a1a49d738f8035c8a7d", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -115,9 +115,12 @@ impl Thread {\n                                      name.as_ptr() as *mut libc::c_void);\n         }\n     }\n-    #[cfg(any(target_env = \"newlib\", target_os = \"solaris\", target_os = \"emscripten\"))]\n+    #[cfg(any(target_env = \"newlib\",\n+              target_os = \"solaris\",\n+              target_os = \"haiku\",\n+              target_os = \"emscripten\"))]\n     pub fn set_name(_name: &CStr) {\n-        // Newlib, Illumos and Emscripten have no way to set a thread name.\n+        // Newlib, Illumos, Haiku, and Emscripten have no way to set a thread name.\n     }\n \n     pub fn sleep(dur: Duration) {"}, {"sha": "1f2dc228ded3468250cbc08ca6b49cc7a33cdd0f", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -24,6 +24,7 @@ pub enum Os {\n     Netbsd,\n     Openbsd,\n     NaCl,\n+    Haiku,\n     Solaris,\n }\n \n@@ -146,6 +147,7 @@ impl fmt::Display for Os {\n             Os::Netbsd => \"netbsd\".fmt(f),\n             Os::Openbsd => \"openbsd\".fmt(f),\n             Os::NaCl => \"nacl\".fmt(f),\n+            Os::Haiku => \"haiku\".fmt(f),\n             Os::Solaris => \"solaris\".fmt(f),\n         }\n     }"}, {"sha": "495ad176542c10f73c905fc9500d8d54ee3c5a02", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 142, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -18,8 +18,7 @@ use errors::DiagnosticBuilder;\n use ext::expand::{self, Invocation, Expansion};\n use ext::hygiene::Mark;\n use fold::{self, Folder};\n-use parse;\n-use parse::parser::{self, Parser};\n+use parse::{self, parser};\n use parse::token;\n use parse::token::{InternedString, str_to_ident};\n use ptr::P;\n@@ -188,146 +187,6 @@ impl<F> AttrProcMacro for F\n     }\n }\n \n-pub struct TokResult<'a> {\n-    pub parser: Parser<'a>,\n-    pub span: Span,\n-}\n-\n-impl<'a> TokResult<'a> {\n-    // There is quite a lot of overlap here with ParserAnyMacro in ext/tt/macro_rules.rs\n-    // We could probably share more code.\n-    // FIXME(#36641) Unify TokResult and ParserAnyMacro.\n-    fn ensure_complete_parse(&mut self, allow_semi: bool) {\n-        let macro_span = &self.span;\n-        self.parser.ensure_complete_parse(allow_semi, |parser| {\n-            let token_str = parser.this_token_to_string();\n-            let msg = format!(\"macro expansion ignores token `{}` and any following\", token_str);\n-            let span = parser.span;\n-            parser.diagnostic()\n-                  .struct_span_err(span, &msg)\n-                  .span_note(*macro_span, \"caused by the macro expansion here\")\n-                  .emit();\n-        });\n-    }\n-}\n-\n-impl<'a> MacResult for TokResult<'a> {\n-    fn make_items(mut self: Box<Self>) -> Option<SmallVector<P<ast::Item>>> {\n-        if self.parser.sess.span_diagnostic.has_errors() {\n-            return Some(SmallVector::zero());\n-        }\n-\n-        let mut items = SmallVector::zero();\n-        loop {\n-            match self.parser.parse_item() {\n-                Ok(Some(item)) => items.push(item),\n-                Ok(None) => {\n-                    self.ensure_complete_parse(false);\n-                    return Some(items);\n-                }\n-                Err(mut e) => {\n-                    e.emit();\n-                    return Some(SmallVector::zero());\n-                }\n-            }\n-        }\n-    }\n-\n-    fn make_impl_items(mut self: Box<Self>) -> Option<SmallVector<ast::ImplItem>> {\n-        let mut items = SmallVector::zero();\n-        loop {\n-            if self.parser.token == token::Eof {\n-                break;\n-            }\n-            match self.parser.parse_impl_item() {\n-                Ok(item) => items.push(item),\n-                Err(mut e) => {\n-                    e.emit();\n-                    return Some(SmallVector::zero());\n-                }\n-            }\n-        }\n-        self.ensure_complete_parse(false);\n-        Some(items)\n-    }\n-\n-    fn make_trait_items(mut self: Box<Self>) -> Option<SmallVector<ast::TraitItem>> {\n-        let mut items = SmallVector::zero();\n-        loop {\n-            if self.parser.token == token::Eof {\n-                break;\n-            }\n-            match self.parser.parse_trait_item() {\n-                Ok(item) => items.push(item),\n-                Err(mut e) => {\n-                    e.emit();\n-                    return Some(SmallVector::zero());\n-                }\n-            }\n-        }\n-        self.ensure_complete_parse(false);\n-        Some(items)\n-    }\n-\n-    fn make_expr(mut self: Box<Self>) -> Option<P<ast::Expr>> {\n-        match self.parser.parse_expr() {\n-            Ok(e) => {\n-                self.ensure_complete_parse(true);\n-                Some(e)\n-            }\n-            Err(mut e) => {\n-                e.emit();\n-                Some(DummyResult::raw_expr(self.span))\n-            }\n-        }\n-    }\n-\n-    fn make_pat(mut self: Box<Self>) -> Option<P<ast::Pat>> {\n-        match self.parser.parse_pat() {\n-            Ok(e) => {\n-                self.ensure_complete_parse(false);\n-                Some(e)\n-            }\n-            Err(mut e) => {\n-                e.emit();\n-                Some(P(DummyResult::raw_pat(self.span)))\n-            }\n-        }\n-    }\n-\n-    fn make_stmts(mut self: Box<Self>) -> Option<SmallVector<ast::Stmt>> {\n-        let mut stmts = SmallVector::zero();\n-        loop {\n-            if self.parser.token == token::Eof {\n-                break;\n-            }\n-            match self.parser.parse_full_stmt(false) {\n-                Ok(Some(stmt)) => stmts.push(stmt),\n-                Ok(None) => { /* continue */ }\n-                Err(mut e) => {\n-                    e.emit();\n-                    return Some(SmallVector::zero());\n-                }\n-            }\n-        }\n-        self.ensure_complete_parse(false);\n-        Some(stmts)\n-    }\n-\n-    fn make_ty(mut self: Box<Self>) -> Option<P<ast::Ty>> {\n-        match self.parser.parse_ty() {\n-            Ok(e) => {\n-                self.ensure_complete_parse(false);\n-                Some(e)\n-            }\n-            Err(mut e) => {\n-                e.emit();\n-                Some(DummyResult::raw_ty(self.span))\n-            }\n-        }\n-    }\n-}\n-\n /// Represents a thing that maps token trees to Macro Results\n pub trait TTMacroExpander {\n     fn expand<'cx>(&self,"}, {"sha": "8436835da3e1d3dfe4199526c7b6e318d2273b79", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 86, "deletions": 22, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast::{Block, Crate, Ident, Mac_, PatKind};\n-use ast::{MacStmtStyle, StmtKind, ItemKind};\n+use ast::{Name, MacStmtStyle, StmtKind, ItemKind};\n use ast;\n use ext::hygiene::Mark;\n use ext::placeholders::{placeholder, PlaceholderExpander};\n@@ -21,9 +21,9 @@ use ext::base::*;\n use feature_gate::{self, Features};\n use fold;\n use fold::*;\n-use parse::{ParseSess, lexer};\n+use parse::{ParseSess, PResult, lexer};\n use parse::parser::Parser;\n-use parse::token::{intern, keywords};\n+use parse::token::{self, intern, keywords};\n use print::pprust;\n use ptr::P;\n use tokenstream::{TokenTree, TokenStream};\n@@ -38,12 +38,12 @@ macro_rules! expansions {\n     ($($kind:ident: $ty:ty [$($vec:ident, $ty_elt:ty)*], $kind_name:expr, .$make:ident,\n             $(.$fold:ident)*  $(lift .$fold_elt:ident)*,\n             $(.$visit:ident)*  $(lift .$visit_elt:ident)*;)*) => {\n-        #[derive(Copy, Clone)]\n+        #[derive(Copy, Clone, PartialEq, Eq)]\n         pub enum ExpansionKind { OptExpr, $( $kind, )*  }\n         pub enum Expansion { OptExpr(Option<P<ast::Expr>>), $( $kind($ty), )* }\n \n         impl ExpansionKind {\n-            fn name(self) -> &'static str {\n+            pub fn name(self) -> &'static str {\n                 match self {\n                     ExpansionKind::OptExpr => \"expression\",\n                     $( ExpansionKind::$kind => $kind_name, )*\n@@ -106,6 +106,12 @@ macro_rules! expansions {\n                 self.expand(Expansion::$kind(SmallVector::one(node))).$make()\n             })*)*\n         }\n+\n+        impl<'a> MacResult for ::ext::tt::macro_rules::ParserAnyMacro<'a> {\n+            $(fn $make(self: Box<::ext::tt::macro_rules::ParserAnyMacro<'a>>) -> Option<$ty> {\n+                Some(self.make(ExpansionKind::$kind).$make())\n+            })*\n+        }\n     }\n }\n \n@@ -293,10 +299,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         };\n \n         attr::mark_used(&attr);\n+        let name = intern(&attr.name());\n         self.cx.bt_push(ExpnInfo {\n             call_site: attr.span,\n             callee: NameAndSpan {\n-                format: MacroAttribute(intern(&attr.name())),\n+                format: MacroAttribute(name),\n                 span: Some(attr.span),\n                 allow_internal_unstable: false,\n             }\n@@ -319,14 +326,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 let item_toks = TokenStream::from_tts(tts_for_item(&item, &self.cx.parse_sess));\n \n                 let tok_result = mac.expand(self.cx, attr.span, attr_toks, item_toks);\n-                let parser = self.cx.new_parser_from_tts(&tok_result.to_tts());\n-                let result = Box::new(TokResult { parser: parser, span: attr.span });\n-\n-                kind.make_from(result).unwrap_or_else(|| {\n-                    let msg = format!(\"macro could not be expanded into {} position\", kind.name());\n-                    self.cx.span_err(attr.span, &msg);\n-                    kind.dummy(attr.span)\n-                })\n+                self.parse_expansion(tok_result, kind, name, attr.span)\n             }\n             _ => unreachable!(),\n         }\n@@ -423,14 +423,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     },\n                 });\n \n-\n-                let tok_result = expandfun.expand(self.cx,\n-                                                  span,\n-                                                  TokenStream::from_tts(marked_tts));\n-                let parser = self.cx.new_parser_from_tts(&tok_result.to_tts());\n-                let result = Box::new(TokResult { parser: parser, span: span });\n-                // FIXME better span info.\n-                kind.make_from(result).map(|i| i.fold_with(&mut ChangeSpan { span: span }))\n+                let toks = TokenStream::from_tts(marked_tts);\n+                let tok_result = expandfun.expand(self.cx, span, toks);\n+                Some(self.parse_expansion(tok_result, kind, extname, span))\n             }\n         };\n \n@@ -448,6 +443,75 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             expn_id: Some(self.cx.backtrace()),\n         })\n     }\n+\n+    fn parse_expansion(&mut self, toks: TokenStream, kind: ExpansionKind, name: Name, span: Span)\n+                       -> Expansion {\n+        let mut parser = self.cx.new_parser_from_tts(&toks.to_tts());\n+        let expansion = match parser.parse_expansion(kind, false) {\n+            Ok(expansion) => expansion,\n+            Err(mut err) => {\n+                err.emit();\n+                return kind.dummy(span);\n+            }\n+        };\n+        parser.ensure_complete_parse(name, kind.name(), span);\n+        // FIXME better span info\n+        expansion.fold_with(&mut ChangeSpan { span: span })\n+    }\n+}\n+\n+impl<'a> Parser<'a> {\n+    pub fn parse_expansion(&mut self, kind: ExpansionKind, macro_legacy_warnings: bool)\n+                           -> PResult<'a, Expansion> {\n+        Ok(match kind {\n+            ExpansionKind::Items => {\n+                let mut items = SmallVector::zero();\n+                while let Some(item) = self.parse_item()? {\n+                    items.push(item);\n+                }\n+                Expansion::Items(items)\n+            }\n+            ExpansionKind::TraitItems => {\n+                let mut items = SmallVector::zero();\n+                while self.token != token::Eof {\n+                    items.push(self.parse_trait_item()?);\n+                }\n+                Expansion::TraitItems(items)\n+            }\n+            ExpansionKind::ImplItems => {\n+                let mut items = SmallVector::zero();\n+                while self.token != token::Eof {\n+                    items.push(self.parse_impl_item()?);\n+                }\n+                Expansion::ImplItems(items)\n+            }\n+            ExpansionKind::Stmts => {\n+                let mut stmts = SmallVector::zero();\n+                while self.token != token::Eof {\n+                    if let Some(stmt) = self.parse_full_stmt(macro_legacy_warnings)? {\n+                        stmts.push(stmt);\n+                    }\n+                }\n+                Expansion::Stmts(stmts)\n+            }\n+            ExpansionKind::Expr => Expansion::Expr(self.parse_expr()?),\n+            ExpansionKind::OptExpr => Expansion::OptExpr(Some(self.parse_expr()?)),\n+            ExpansionKind::Ty => Expansion::Ty(self.parse_ty()?),\n+            ExpansionKind::Pat => Expansion::Pat(self.parse_pat()?),\n+        })\n+    }\n+\n+    pub fn ensure_complete_parse(&mut self, macro_name: ast::Name, kind_name: &str, span: Span) {\n+        if self.token != token::Eof {\n+            let msg = format!(\"macro expansion ignores token `{}` and any following\",\n+                              self.this_token_to_string());\n+            let mut err = self.diagnostic().struct_span_err(self.span, &msg);\n+            let msg = format!(\"caused by the macro expansion here; the usage \\\n+                               of `{}!` is likely invalid in {} context\",\n+                               macro_name, kind_name);\n+            err.span_note(span, &msg).emit();\n+        }\n+    }\n }\n \n struct InvocationCollector<'a, 'b: 'a> {"}, {"sha": "9f4c0b5eb808f6203b1162c5d10ac0a359427a63", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 54, "deletions": 106, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -12,6 +12,7 @@ use {ast, attr};\n use syntax_pos::{Span, DUMMY_SP};\n use ext::base::{DummyResult, ExtCtxt, MacEager, MacResult, SyntaxExtension};\n use ext::base::{IdentMacroExpander, NormalTT, TTMacroExpander};\n+use ext::expand::{Expansion, ExpansionKind};\n use ext::placeholders;\n use ext::tt::macro_parser::{Success, Error, Failure};\n use ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n@@ -22,18 +23,14 @@ use parse::parser::{Parser, Restrictions};\n use parse::token::{self, gensym_ident, NtTT, Token};\n use parse::token::Token::*;\n use print;\n-use ptr::P;\n use tokenstream::{self, TokenTree};\n \n-use util::small_vector::SmallVector;\n-\n-use std::cell::RefCell;\n use std::collections::{HashMap};\n use std::collections::hash_map::{Entry};\n use std::rc::Rc;\n \n-struct ParserAnyMacro<'a> {\n-    parser: RefCell<Parser<'a>>,\n+pub struct ParserAnyMacro<'a> {\n+    parser: Parser<'a>,\n \n     /// Span of the expansion site of the macro this parser is for\n     site_span: Span,\n@@ -42,106 +39,20 @@ struct ParserAnyMacro<'a> {\n }\n \n impl<'a> ParserAnyMacro<'a> {\n-    /// Make sure we don't have any tokens left to parse, so we don't\n-    /// silently drop anything. `allow_semi` is so that \"optional\"\n-    /// semicolons at the end of normal expressions aren't complained\n-    /// about e.g. the semicolon in `macro_rules! kapow { () => {\n-    /// panic!(); } }` doesn't get picked up by .parse_expr(), but it's\n-    /// allowed to be there.\n-    fn ensure_complete_parse(&self, allow_semi: bool, context: &str) {\n-        let mut parser = self.parser.borrow_mut();\n-        parser.ensure_complete_parse(allow_semi, |parser| {\n-            let token_str = parser.this_token_to_string();\n-            let msg = format!(\"macro expansion ignores token `{}` and any \\\n-                               following\",\n-                              token_str);\n-            let span = parser.span;\n-            let mut err = parser.diagnostic().struct_span_err(span, &msg);\n-            let msg = format!(\"caused by the macro expansion here; the usage \\\n-                               of `{}!` is likely invalid in {} context\",\n-                               self.macro_ident, context);\n-            err.span_note(self.site_span, &msg)\n-               .emit();\n-        });\n-    }\n-}\n-\n-impl<'a> MacResult for ParserAnyMacro<'a> {\n-    fn make_expr(self: Box<ParserAnyMacro<'a>>) -> Option<P<ast::Expr>> {\n-        let ret = panictry!(self.parser.borrow_mut().parse_expr());\n-        self.ensure_complete_parse(true, \"expression\");\n-        Some(ret)\n-    }\n-    fn make_pat(self: Box<ParserAnyMacro<'a>>) -> Option<P<ast::Pat>> {\n-        let ret = panictry!(self.parser.borrow_mut().parse_pat());\n-        self.ensure_complete_parse(false, \"pattern\");\n-        Some(ret)\n-    }\n-    fn make_items(self: Box<ParserAnyMacro<'a>>) -> Option<SmallVector<P<ast::Item>>> {\n-        let mut ret = SmallVector::zero();\n-        while let Some(item) = panictry!(self.parser.borrow_mut().parse_item()) {\n-            ret.push(item);\n-        }\n-        self.ensure_complete_parse(false, \"item\");\n-        Some(ret)\n-    }\n-\n-    fn make_impl_items(self: Box<ParserAnyMacro<'a>>)\n-                       -> Option<SmallVector<ast::ImplItem>> {\n-        let mut ret = SmallVector::zero();\n-        loop {\n-            let mut parser = self.parser.borrow_mut();\n-            match parser.token {\n-                token::Eof => break,\n-                _ => ret.push(panictry!(parser.parse_impl_item()))\n-            }\n-        }\n-        self.ensure_complete_parse(false, \"item\");\n-        Some(ret)\n-    }\n-\n-    fn make_trait_items(self: Box<ParserAnyMacro<'a>>)\n-                       -> Option<SmallVector<ast::TraitItem>> {\n-        let mut ret = SmallVector::zero();\n-        loop {\n-            let mut parser = self.parser.borrow_mut();\n-            match parser.token {\n-                token::Eof => break,\n-                _ => ret.push(panictry!(parser.parse_trait_item()))\n-            }\n-        }\n-        self.ensure_complete_parse(false, \"item\");\n-        Some(ret)\n-    }\n-\n-\n-    fn make_stmts(self: Box<ParserAnyMacro<'a>>)\n-                 -> Option<SmallVector<ast::Stmt>> {\n-        let mut ret = SmallVector::zero();\n-        loop {\n-            let mut parser = self.parser.borrow_mut();\n-            match parser.token {\n-                token::Eof => break,\n-                _ => match parser.parse_full_stmt(true) {\n-                    Ok(maybe_stmt) => match maybe_stmt {\n-                        Some(stmt) => ret.push(stmt),\n-                        None => (),\n-                    },\n-                    Err(mut e) => {\n-                        e.emit();\n-                        break;\n-                    }\n-                }\n-            }\n+    pub fn make(mut self: Box<ParserAnyMacro<'a>>, kind: ExpansionKind) -> Expansion {\n+        let ParserAnyMacro { site_span, macro_ident, ref mut parser } = *self;\n+        let expansion = panictry!(parser.parse_expansion(kind, true));\n+\n+        // We allow semicolons at the end of expressions -- e.g. the semicolon in\n+        // `macro_rules! m { () => { panic!(); } }` isn't parsed by `.parse_expr()`,\n+        // but `m!()` is allowed in expression positions (c.f. issue #34706).\n+        if kind == ExpansionKind::Expr && parser.token == token::Semi {\n+            parser.bump();\n         }\n-        self.ensure_complete_parse(false, \"statement\");\n-        Some(ret)\n-    }\n \n-    fn make_ty(self: Box<ParserAnyMacro<'a>>) -> Option<P<ast::Ty>> {\n-        let ret = panictry!(self.parser.borrow_mut().parse_ty());\n-        self.ensure_complete_parse(false, \"type\");\n-        Some(ret)\n+        // Make sure we don't have any tokens left to parse so we don't silently drop anything.\n+        parser.ensure_complete_parse(macro_ident.name, kind.name(), site_span);\n+        expansion\n     }\n }\n \n@@ -219,7 +130,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                 // Let the context choose how to interpret the result.\n                 // Weird, but useful for X-macros.\n                 return Box::new(ParserAnyMacro {\n-                    parser: RefCell::new(p),\n+                    parser: p,\n \n                     // Pass along the original expansion site and the name of the macro\n                     // so we can print a useful error message if the parse of the expanded\n@@ -332,7 +243,7 @@ pub fn compile(sess: &ParseSess, def: &ast::MacroDef) -> SyntaxExtension {\n                     (**tt).clone()\n                 }\n                 _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n-            }).collect()\n+            }).collect::<Vec<TokenTree>>()\n         }\n         _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n     };\n@@ -351,6 +262,11 @@ pub fn compile(sess: &ParseSess, def: &ast::MacroDef) -> SyntaxExtension {\n         valid &= check_rhs(sess, rhs);\n     }\n \n+    // don't abort iteration early, so that errors for multiple lhses can be reported\n+    for lhs in &lhses {\n+        valid &= check_lhs_no_empty_seq(sess, &[lhs.clone()])\n+    }\n+\n     let exp: Box<_> = Box::new(MacroRulesMacroExpander {\n         name: def.ident,\n         imported_from: def.imported_from,\n@@ -377,6 +293,38 @@ fn check_lhs_nt_follows(sess: &ParseSess, lhs: &TokenTree) -> bool {\n     // after parsing/expansion. we can report every error in every macro this way.\n }\n \n+/// Check that the lhs contains no repetition which could match an empty token\n+/// tree, because then the matcher would hang indefinitely.\n+fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[TokenTree]) -> bool {\n+    for tt in tts {\n+        match *tt {\n+            TokenTree::Token(_, _) => (),\n+            TokenTree::Delimited(_, ref del) => if !check_lhs_no_empty_seq(sess, &del.tts) {\n+                return false;\n+            },\n+            TokenTree::Sequence(span, ref seq) => {\n+                if seq.separator.is_none() {\n+                    if seq.tts.iter().all(|seq_tt| {\n+                        match *seq_tt {\n+                            TokenTree::Sequence(_, ref sub_seq) =>\n+                                sub_seq.op == tokenstream::KleeneOp::ZeroOrMore,\n+                            _ => false,\n+                        }\n+                    }) {\n+                        sess.span_diagnostic.span_err(span, \"repetition matches empty token tree\");\n+                        return false;\n+                    }\n+                }\n+                if !check_lhs_no_empty_seq(sess, &seq.tts) {\n+                    return false;\n+                }\n+            }\n+        }\n+    }\n+\n+    true\n+}\n+\n fn check_rhs(sess: &ParseSess, rhs: &TokenTree) -> bool {\n     match *rhs {\n         TokenTree::Delimited(..) => return true,"}, {"sha": "d5ed1d157e47abbd0e1a1e19970c8d9022054e00", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 222, "deletions": 263, "changes": 485, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -542,11 +542,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_ident_into_path(&mut self) -> PResult<'a, ast::Path> {\n-        let ident = self.parse_ident()?;\n-        Ok(ast::Path::from_ident(self.last_span, ident))\n-    }\n-\n     /// Check if the next token is `tok`, and return `true` if so.\n     ///\n     /// This method will automatically add `tok` to `expected_tokens` if `tok` is not\n@@ -1202,94 +1197,87 @@ impl<'a> Parser<'a> {\n                 None\n             };\n             (ident, TraitItemKind::Const(ty, default))\n-        } else if !self.token.is_any_keyword()\n-            && self.look_ahead(1, |t| *t == token::Not)\n-            && (self.look_ahead(2, |t| *t == token::OpenDelim(token::Paren))\n-                || self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))) {\n-                // trait item macro.\n-                // code copied from parse_macro_use_or_failure... abstraction!\n-                let lo = self.span.lo;\n-                let pth = self.parse_ident_into_path()?;\n-                self.expect(&token::Not)?;\n+        } else if self.token.is_path_start() {\n+            // trait item macro.\n+            // code copied from parse_macro_use_or_failure... abstraction!\n+            let lo = self.span.lo;\n+            let pth = self.parse_path(PathStyle::Mod)?;\n+            self.expect(&token::Not)?;\n \n-                // eat a matched-delimiter token tree:\n-                let delim = self.expect_open_delim()?;\n-                let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n-                                             SeqSep::none(),\n-                                             |pp| pp.parse_token_tree())?;\n-                let m_ = Mac_ { path: pth, tts: tts };\n-                let m: ast::Mac = codemap::Spanned { node: m_,\n-                                                     span: mk_sp(lo,\n-                                                                 self.last_span.hi) };\n-                if delim != token::Brace {\n-                    self.expect(&token::Semi)?\n-                }\n-                (keywords::Invalid.ident(), ast::TraitItemKind::Macro(m))\n-            } else {\n-                let (constness, unsafety, abi) = match self.parse_fn_front_matter() {\n-                    Ok(cua) => cua,\n-                    Err(e) => {\n-                        loop {\n-                            match self.token {\n-                                token::Eof => break,\n-                                token::CloseDelim(token::Brace) |\n-                                token::Semi => {\n-                                    self.bump();\n-                                    break;\n-                                }\n-                                token::OpenDelim(token::Brace) => {\n-                                    self.parse_token_tree()?;\n-                                    break;\n-                                }\n-                                _ => self.bump()\n+            // eat a matched-delimiter token tree:\n+            let delim = self.expect_open_delim()?;\n+            let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n+                                            SeqSep::none(),\n+                                            |pp| pp.parse_token_tree())?;\n+            if delim != token::Brace {\n+                self.expect(&token::Semi)?\n+            }\n+\n+            let mac = spanned(lo, self.last_span.hi, Mac_ { path: pth, tts: tts });\n+            (keywords::Invalid.ident(), ast::TraitItemKind::Macro(mac))\n+        } else {\n+            let (constness, unsafety, abi) = match self.parse_fn_front_matter() {\n+                Ok(cua) => cua,\n+                Err(e) => {\n+                    loop {\n+                        match self.token {\n+                            token::Eof => break,\n+                            token::CloseDelim(token::Brace) |\n+                            token::Semi => {\n+                                self.bump();\n+                                break;\n+                            }\n+                            token::OpenDelim(token::Brace) => {\n+                                self.parse_token_tree()?;\n+                                break;\n                             }\n+                            _ => self.bump(),\n                         }\n-\n-                        return Err(e);\n                     }\n-                };\n \n-                let ident = self.parse_ident()?;\n-                let mut generics = self.parse_generics()?;\n+                    return Err(e);\n+                }\n+            };\n \n-                let d = self.parse_fn_decl_with_self(|p: &mut Parser<'a>|{\n-                    // This is somewhat dubious; We don't want to allow\n-                    // argument names to be left off if there is a\n-                    // definition...\n-                    p.parse_arg_general(false)\n-                })?;\n+            let ident = self.parse_ident()?;\n+            let mut generics = self.parse_generics()?;\n \n-                generics.where_clause = self.parse_where_clause()?;\n-                let sig = ast::MethodSig {\n-                    unsafety: unsafety,\n-                    constness: constness,\n-                    decl: d,\n-                    generics: generics,\n-                    abi: abi,\n-                };\n+            let d = self.parse_fn_decl_with_self(|p: &mut Parser<'a>|{\n+                // This is somewhat dubious; We don't want to allow\n+                // argument names to be left off if there is a\n+                // definition...\n+                p.parse_arg_general(false)\n+            })?;\n \n-                let body = match self.token {\n-                    token::Semi => {\n-                        self.bump();\n-                        debug!(\"parse_trait_methods(): parsing required method\");\n-                        None\n-                    }\n-                    token::OpenDelim(token::Brace) => {\n-                        debug!(\"parse_trait_methods(): parsing provided method\");\n-                        let (inner_attrs, body) =\n-                            self.parse_inner_attrs_and_block()?;\n-                        attrs.extend(inner_attrs.iter().cloned());\n-                        Some(body)\n-                    }\n+            generics.where_clause = self.parse_where_clause()?;\n+            let sig = ast::MethodSig {\n+                unsafety: unsafety,\n+                constness: constness,\n+                decl: d,\n+                generics: generics,\n+                abi: abi,\n+            };\n \n-                    _ => {\n-                        let token_str = self.this_token_to_string();\n-                        return Err(self.fatal(&format!(\"expected `;` or `{{`, found `{}`\",\n-                                                    token_str)[..]))\n-                    }\n-                };\n-                (ident, ast::TraitItemKind::Method(sig, body))\n+            let body = match self.token {\n+                token::Semi => {\n+                    self.bump();\n+                    debug!(\"parse_trait_methods(): parsing required method\");\n+                    None\n+                }\n+                token::OpenDelim(token::Brace) => {\n+                    debug!(\"parse_trait_methods(): parsing provided method\");\n+                    let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+                    attrs.extend(inner_attrs.iter().cloned());\n+                    Some(body)\n+                }\n+                _ => {\n+                    let token_str = self.this_token_to_string();\n+                    return Err(self.fatal(&format!(\"expected `;` or `{{`, found `{}`\", token_str)));\n+                }\n             };\n+            (ident, ast::TraitItemKind::Method(sig, body))\n+        };\n+\n         Ok(TraitItem {\n             id: ast::DUMMY_NODE_ID,\n             ident: name,\n@@ -1430,9 +1418,8 @@ impl<'a> Parser<'a> {\n             TyKind::Path(Some(qself), path)\n         } else if self.token.is_path_start() {\n             let path = self.parse_path(PathStyle::Type)?;\n-            if self.check(&token::Not) {\n+            if self.eat(&token::Not) {\n                 // MACRO INVOCATION\n-                self.bump();\n                 let delim = self.expect_open_delim()?;\n                 let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n                                                 SeqSep::none(),\n@@ -2310,21 +2297,14 @@ impl<'a> Parser<'a> {\n                     let pth = self.parse_path(PathStyle::Expr)?;\n \n                     // `!`, as an operator, is prefix, so we know this isn't that\n-                    if self.check(&token::Not) {\n+                    if self.eat(&token::Not) {\n                         // MACRO INVOCATION expression\n-                        self.bump();\n-\n                         let delim = self.expect_open_delim()?;\n-                        let tts = self.parse_seq_to_end(\n-                            &token::CloseDelim(delim),\n-                            SeqSep::none(),\n-                            |p| p.parse_token_tree())?;\n+                        let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n+                                                        SeqSep::none(),\n+                                                        |p| p.parse_token_tree())?;\n                         let hi = self.last_span.hi;\n-\n-                        return Ok(self.mk_mac_expr(lo,\n-                                                   hi,\n-                                                   Mac_ { path: pth, tts: tts },\n-                                                   attrs));\n+                        return Ok(self.mk_mac_expr(lo, hi, Mac_ { path: pth, tts: tts }, attrs));\n                     }\n                     if self.check(&token::OpenDelim(token::Brace)) {\n                         // This is a struct literal, unless we're prohibited\n@@ -2333,51 +2313,7 @@ impl<'a> Parser<'a> {\n                             Restrictions::RESTRICTION_NO_STRUCT_LITERAL\n                         );\n                         if !prohibited {\n-                            // It's a struct literal.\n-                            self.bump();\n-                            let mut fields = Vec::new();\n-                            let mut base = None;\n-\n-                            attrs.extend(self.parse_inner_attributes()?);\n-\n-                            while self.token != token::CloseDelim(token::Brace) {\n-                                if self.eat(&token::DotDot) {\n-                                    match self.parse_expr() {\n-                                        Ok(e) => {\n-                                            base = Some(e);\n-                                        }\n-                                        Err(mut e) => {\n-                                            e.emit();\n-                                            self.recover_stmt();\n-                                        }\n-                                    }\n-                                    break;\n-                                }\n-\n-                                match self.parse_field() {\n-                                    Ok(f) => fields.push(f),\n-                                    Err(mut e) => {\n-                                        e.emit();\n-                                        self.recover_stmt();\n-                                        break;\n-                                    }\n-                                }\n-\n-                                match self.expect_one_of(&[token::Comma],\n-                                                         &[token::CloseDelim(token::Brace)]) {\n-                                    Ok(()) => {}\n-                                    Err(mut e) => {\n-                                        e.emit();\n-                                        self.recover_stmt();\n-                                        break;\n-                                    }\n-                                }\n-                            }\n-\n-                            hi = self.span.hi;\n-                            self.expect(&token::CloseDelim(token::Brace))?;\n-                            ex = ExprKind::Struct(pth, fields, base);\n-                            return Ok(self.mk_expr(lo, hi, ex, attrs));\n+                            return self.parse_struct_expr(lo, pth, attrs);\n                         }\n                     }\n \n@@ -2403,6 +2339,53 @@ impl<'a> Parser<'a> {\n         return Ok(self.mk_expr(lo, hi, ex, attrs));\n     }\n \n+    fn parse_struct_expr(&mut self, lo: BytePos, pth: ast::Path, mut attrs: ThinVec<Attribute>)\n+                         -> PResult<'a, P<Expr>> {\n+        self.bump();\n+        let mut fields = Vec::new();\n+        let mut base = None;\n+\n+        attrs.extend(self.parse_inner_attributes()?);\n+\n+        while self.token != token::CloseDelim(token::Brace) {\n+            if self.eat(&token::DotDot) {\n+                match self.parse_expr() {\n+                    Ok(e) => {\n+                        base = Some(e);\n+                    }\n+                    Err(mut e) => {\n+                        e.emit();\n+                        self.recover_stmt();\n+                    }\n+                }\n+                break;\n+            }\n+\n+            match self.parse_field() {\n+                Ok(f) => fields.push(f),\n+                Err(mut e) => {\n+                    e.emit();\n+                    self.recover_stmt();\n+                    break;\n+                }\n+            }\n+\n+            match self.expect_one_of(&[token::Comma],\n+                                     &[token::CloseDelim(token::Brace)]) {\n+                Ok(()) => {}\n+                Err(mut e) => {\n+                    e.emit();\n+                    self.recover_stmt();\n+                    break;\n+                }\n+            }\n+        }\n+\n+        let hi = self.span.hi;\n+        self.expect(&token::CloseDelim(token::Brace))?;\n+        return Ok(self.mk_expr(lo, hi, ExprKind::Struct(pth, fields, base), attrs));\n+    }\n+\n     fn parse_or_use_outer_attributes(&mut self,\n                                      already_parsed_attrs: Option<ThinVec<Attribute>>)\n                                      -> PResult<'a, ThinVec<Attribute>> {\n@@ -3577,39 +3560,37 @@ impl<'a> Parser<'a> {\n         let lo = self.span.lo;\n         let pat;\n         match self.token {\n-          token::Underscore => {\n-            // Parse _\n-            self.bump();\n-            pat = PatKind::Wild;\n-          }\n-          token::BinOp(token::And) | token::AndAnd => {\n-            // Parse &pat / &mut pat\n-            self.expect_and()?;\n-            let mutbl = self.parse_mutability()?;\n-            if let token::Lifetime(ident) = self.token {\n-                return Err(self.fatal(&format!(\"unexpected lifetime `{}` in pattern\", ident)));\n+            token::Underscore => {\n+                // Parse _\n+                self.bump();\n+                pat = PatKind::Wild;\n+            }\n+            token::BinOp(token::And) | token::AndAnd => {\n+                // Parse &pat / &mut pat\n+                self.expect_and()?;\n+                let mutbl = self.parse_mutability()?;\n+                if let token::Lifetime(ident) = self.token {\n+                    return Err(self.fatal(&format!(\"unexpected lifetime `{}` in pattern\", ident)));\n+                }\n+                let subpat = self.parse_pat()?;\n+                pat = PatKind::Ref(subpat, mutbl);\n+            }\n+            token::OpenDelim(token::Paren) => {\n+                // Parse (pat,pat,pat,...) as tuple pattern\n+                self.bump();\n+                let (fields, ddpos) = self.parse_pat_tuple_elements(true)?;\n+                self.expect(&token::CloseDelim(token::Paren))?;\n+                pat = PatKind::Tuple(fields, ddpos);\n+            }\n+            token::OpenDelim(token::Bracket) => {\n+                // Parse [pat,pat,...] as slice pattern\n+                self.bump();\n+                let (before, slice, after) = self.parse_pat_vec_elements()?;\n+                self.expect(&token::CloseDelim(token::Bracket))?;\n+                pat = PatKind::Vec(before, slice, after);\n             }\n-\n-            let subpat = self.parse_pat()?;\n-            pat = PatKind::Ref(subpat, mutbl);\n-          }\n-          token::OpenDelim(token::Paren) => {\n-            // Parse (pat,pat,pat,...) as tuple pattern\n-            self.bump();\n-            let (fields, ddpos) = self.parse_pat_tuple_elements(true)?;\n-            self.expect(&token::CloseDelim(token::Paren))?;\n-            pat = PatKind::Tuple(fields, ddpos);\n-          }\n-          token::OpenDelim(token::Bracket) => {\n-            // Parse [pat,pat,...] as slice pattern\n-            self.bump();\n-            let (before, slice, after) = self.parse_pat_vec_elements()?;\n-            self.expect(&token::CloseDelim(token::Bracket))?;\n-            pat = PatKind::Vec(before, slice, after);\n-          }\n-          _ => {\n             // At this point, token != _, &, &&, (, [\n-            if self.eat_keyword(keywords::Mut) {\n+            _ => if self.eat_keyword(keywords::Mut) {\n                 // Parse mut ident @ pat\n                 pat = self.parse_pat_ident(BindingMode::ByValue(Mutability::Mutable))?;\n             } else if self.eat_keyword(keywords::Ref) {\n@@ -3620,53 +3601,49 @@ impl<'a> Parser<'a> {\n                 // Parse box pat\n                 let subpat = self.parse_pat()?;\n                 pat = PatKind::Box(subpat);\n+            } else if self.token.is_ident() && self.token.is_path_start() &&\n+                      self.look_ahead(1, |t| match *t {\n+                          token::OpenDelim(token::Paren) | token::OpenDelim(token::Brace) |\n+                          token::DotDotDot | token::ModSep | token::Not => false,\n+                          _ => true,\n+                      }) {\n+                // Parse ident @ pat\n+                // This can give false positives and parse nullary enums,\n+                // they are dealt with later in resolve\n+                let binding_mode = BindingMode::ByValue(Mutability::Immutable);\n+                pat = self.parse_pat_ident(binding_mode)?;\n             } else if self.token.is_path_start() {\n                 // Parse pattern starting with a path\n-                if self.token.is_ident() && self.look_ahead(1, |t| *t != token::DotDotDot &&\n-                        *t != token::OpenDelim(token::Brace) &&\n-                        *t != token::OpenDelim(token::Paren) &&\n-                        *t != token::ModSep) {\n-                    // Plain idents have some extra abilities here compared to general paths\n-                    if self.look_ahead(1, |t| *t == token::Not) {\n+                let (qself, path) = if self.eat_lt() {\n+                    // Parse a qualified path\n+                    let (qself, path) = self.parse_qualified_path(PathStyle::Expr)?;\n+                    (Some(qself), path)\n+                } else {\n+                    // Parse an unqualified path\n+                    (None, self.parse_path(PathStyle::Expr)?)\n+                };\n+                match self.token {\n+                    token::Not if qself.is_none() => {\n                         // Parse macro invocation\n-                        let path = self.parse_ident_into_path()?;\n                         self.bump();\n                         let delim = self.expect_open_delim()?;\n-                        let tts = self.parse_seq_to_end(\n-                            &token::CloseDelim(delim),\n-                            SeqSep::none(), |p| p.parse_token_tree())?;\n-                        let mac = Mac_ { path: path, tts: tts };\n-                        pat = PatKind::Mac(codemap::Spanned {node: mac,\n-                                                               span: mk_sp(lo, self.last_span.hi)});\n-                    } else {\n-                        // Parse ident @ pat\n-                        // This can give false positives and parse nullary enums,\n-                        // they are dealt with later in resolve\n-                        let binding_mode = BindingMode::ByValue(Mutability::Immutable);\n-                        pat = self.parse_pat_ident(binding_mode)?;\n+                        let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n+                                                        SeqSep::none(),\n+                                                        |p| p.parse_token_tree())?;\n+                        let mac = spanned(lo, self.last_span.hi, Mac_ { path: path, tts: tts });\n+                        pat = PatKind::Mac(mac);\n                     }\n-                } else {\n-                    let (qself, path) = if self.eat_lt() {\n-                        // Parse a qualified path\n-                        let (qself, path) =\n-                            self.parse_qualified_path(PathStyle::Expr)?;\n-                        (Some(qself), path)\n-                    } else {\n-                        // Parse an unqualified path\n-                        (None, self.parse_path(PathStyle::Expr)?)\n-                    };\n-                    match self.token {\n-                      token::DotDotDot => {\n+                    token::DotDotDot => {\n                         // Parse range\n                         let hi = self.last_span.hi;\n                         let begin =\n                               self.mk_expr(lo, hi, ExprKind::Path(qself, path), ThinVec::new());\n                         self.bump();\n                         let end = self.parse_pat_range_end()?;\n                         pat = PatKind::Range(begin, end);\n-                      }\n-                      token::OpenDelim(token::Brace) => {\n-                         if qself.is_some() {\n+                    }\n+                    token::OpenDelim(token::Brace) => {\n+                        if qself.is_some() {\n                             return Err(self.fatal(\"unexpected `{` after qualified path\"));\n                         }\n                         // Parse struct pattern\n@@ -3678,8 +3655,8 @@ impl<'a> Parser<'a> {\n                         });\n                         self.bump();\n                         pat = PatKind::Struct(path, fields, etc);\n-                      }\n-                      token::OpenDelim(token::Paren) => {\n+                    }\n+                    token::OpenDelim(token::Paren) => {\n                         if qself.is_some() {\n                             return Err(self.fatal(\"unexpected `(` after qualified path\"));\n                         }\n@@ -3688,11 +3665,8 @@ impl<'a> Parser<'a> {\n                         let (fields, ddpos) = self.parse_pat_tuple_elements(false)?;\n                         self.expect(&token::CloseDelim(token::Paren))?;\n                         pat = PatKind::TupleStruct(path, fields, ddpos)\n-                      }\n-                      _ => {\n-                        pat = PatKind::Path(qself, path);\n-                      }\n                     }\n+                    _ => pat = PatKind::Path(qself, path),\n                 }\n             } else {\n                 // Try to parse everything else as literal with optional minus\n@@ -3712,7 +3686,6 @@ impl<'a> Parser<'a> {\n                     }\n                 }\n             }\n-          }\n         }\n \n         let hi = self.last_span.hi;\n@@ -3894,16 +3867,33 @@ impl<'a> Parser<'a> {\n                 node: StmtKind::Local(self.parse_local(attrs.into())?),\n                 span: mk_sp(lo, self.last_span.hi),\n             }\n-        } else if self.token.is_ident()\n-            && !self.token.is_any_keyword()\n-            && self.look_ahead(1, |t| *t == token::Not) {\n-            // it's a macro invocation:\n+        } else if self.token.is_path_start() && self.token != token::Lt && {\n+            !self.check_keyword(keywords::Union) ||\n+            self.look_ahead(1, |t| *t == token::Not || *t == token::ModSep)\n+        } {\n+            let pth = self.parse_path(PathStyle::Expr)?;\n \n-            // Potential trouble: if we allow macros with paths instead of\n-            // idents, we'd need to look ahead past the whole path here...\n-            let pth = self.parse_ident_into_path()?;\n-            self.bump();\n+            if !self.eat(&token::Not) {\n+                let expr = if self.check(&token::OpenDelim(token::Brace)) {\n+                    self.parse_struct_expr(lo, pth, ThinVec::new())?\n+                } else {\n+                    let hi = self.last_span.hi;\n+                    self.mk_expr(lo, hi, ExprKind::Path(None, pth), ThinVec::new())\n+                };\n+\n+                let expr = self.with_res(Restrictions::RESTRICTION_STMT_EXPR, |this| {\n+                    let expr = this.parse_dot_or_call_expr_with(expr, lo, attrs.into())?;\n+                    this.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(expr))\n+                })?;\n \n+                return Ok(Some(Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    node: StmtKind::Expr(expr),\n+                    span: mk_sp(lo, self.last_span.hi),\n+                }));\n+            }\n+\n+            // it's a macro invocation\n             let id = match self.token {\n                 token::OpenDelim(_) => keywords::Invalid.ident(), // no special identifier\n                 _ => self.parse_ident()?,\n@@ -4857,32 +4847,27 @@ impl<'a> Parser<'a> {\n     fn parse_impl_method(&mut self, vis: &Visibility)\n                          -> PResult<'a, (Ident, Vec<ast::Attribute>, ast::ImplItemKind)> {\n         // code copied from parse_macro_use_or_failure... abstraction!\n-        if !self.token.is_any_keyword()\n-            && self.look_ahead(1, |t| *t == token::Not)\n-            && (self.look_ahead(2, |t| *t == token::OpenDelim(token::Paren))\n-                || self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))) {\n+        if self.token.is_path_start() {\n             // method macro.\n \n             let last_span = self.last_span;\n             self.complain_if_pub_macro(&vis, last_span);\n \n             let lo = self.span.lo;\n-            let pth = self.parse_ident_into_path()?;\n+            let pth = self.parse_path(PathStyle::Mod)?;\n             self.expect(&token::Not)?;\n \n             // eat a matched-delimiter token tree:\n             let delim = self.expect_open_delim()?;\n             let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n                                             SeqSep::none(),\n                                             |p| p.parse_token_tree())?;\n-            let m_ = Mac_ { path: pth, tts: tts };\n-            let m: ast::Mac = codemap::Spanned { node: m_,\n-                                                    span: mk_sp(lo,\n-                                                                self.last_span.hi) };\n             if delim != token::Brace {\n                 self.expect(&token::Semi)?\n             }\n-            Ok((keywords::Invalid.ident(), vec![], ast::ImplItemKind::Macro(m)))\n+\n+            let mac = spanned(lo, self.last_span.hi, Mac_ { path: pth, tts: tts });\n+            Ok((keywords::Invalid.ident(), vec![], ast::ImplItemKind::Macro(mac)))\n         } else {\n             let (constness, unsafety, abi) = self.parse_fn_front_matter()?;\n             let ident = self.parse_ident()?;\n@@ -5979,11 +5964,7 @@ impl<'a> Parser<'a> {\n         lo: BytePos,\n         visibility: Visibility\n     ) -> PResult<'a, Option<P<Item>>> {\n-        if macros_allowed && !self.token.is_any_keyword()\n-                && self.look_ahead(1, |t| *t == token::Not)\n-                && (self.look_ahead(2, |t| t.is_ident())\n-                    || self.look_ahead(2, |t| *t == token::OpenDelim(token::Paren))\n-                    || self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))) {\n+        if macros_allowed && self.token.is_path_start() {\n             // MACRO INVOCATION ITEM\n \n             let last_span = self.last_span;\n@@ -5992,7 +5973,7 @@ impl<'a> Parser<'a> {\n             let mac_lo = self.span.lo;\n \n             // item macro.\n-            let pth = self.parse_ident_into_path()?;\n+            let pth = self.parse_path(PathStyle::Mod)?;\n             self.expect(&token::Not)?;\n \n             // a 'special' identifier (like what `macro_rules!` uses)\n@@ -6008,12 +5989,6 @@ impl<'a> Parser<'a> {\n             let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n                                             SeqSep::none(),\n                                             |p| p.parse_token_tree())?;\n-            // single-variant-enum... :\n-            let m = Mac_ { path: pth, tts: tts };\n-            let m: ast::Mac = codemap::Spanned { node: m,\n-                                                 span: mk_sp(mac_lo,\n-                                                             self.last_span.hi) };\n-\n             if delim != token::Brace {\n                 if !self.eat(&token::Semi) {\n                     let last_span = self.last_span;\n@@ -6024,14 +5999,9 @@ impl<'a> Parser<'a> {\n                 }\n             }\n \n-            let item_ = ItemKind::Mac(m);\n-            let last_span = self.last_span;\n-            let item = self.mk_item(lo,\n-                                    last_span.hi,\n-                                    id,\n-                                    item_,\n-                                    visibility,\n-                                    attrs);\n+            let hi = self.last_span.hi;\n+            let mac = spanned(mac_lo, hi, Mac_ { path: pth, tts: tts });\n+            let item = self.mk_item(lo, hi, id, ItemKind::Mac(mac), visibility, attrs);\n             return Ok(Some(item));\n         }\n \n@@ -6171,15 +6141,4 @@ impl<'a> Parser<'a> {\n             _ =>  Err(self.fatal(\"expected string literal\"))\n         }\n     }\n-\n-    pub fn ensure_complete_parse<F>(&mut self, allow_semi: bool, on_err: F)\n-        where F: FnOnce(&Parser)\n-    {\n-        if allow_semi && self.token == token::Semi {\n-            self.bump();\n-        }\n-        if self.token != token::Eof {\n-            on_err(self);\n-        }\n-    }\n }"}, {"sha": "4b1df7d170dbc273ff4f38b1e72ed1f349321673", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -48,10 +48,12 @@ pub fn get_dbpath_for_term(term: &str) -> Option<PathBuf> {\n                 // According to  /etc/terminfo/README, after looking at\n                 // ~/.terminfo, ncurses will search /etc/terminfo, then\n                 // /lib/terminfo, and eventually /usr/share/terminfo.\n+                // On Haiku the database can be found at /boot/system/data/terminfo\n                 Err(..) => {\n                     dirs_to_search.push(PathBuf::from(\"/etc/terminfo\"));\n                     dirs_to_search.push(PathBuf::from(\"/lib/terminfo\"));\n                     dirs_to_search.push(PathBuf::from(\"/usr/share/terminfo\"));\n+                    dirs_to_search.push(PathBuf::from(\"/boot/system/data/terminfo\"));\n                 }\n             }\n         }"}, {"sha": "13d57f784e7954b0f8b2a4286d0739a2b30f08b4", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -1080,6 +1080,12 @@ fn get_concurrency() -> usize {\n         }\n         cpus as usize\n     }\n+\n+    #[cfg(target_os = \"haiku\")]\n+    fn num_cpus() -> usize {\n+        // FIXME: implement\n+        1\n+    }\n }\n \n pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescAndFn> {"}, {"sha": "30de859f1501aeee01176cba6daca382bbca09d5", "filename": "src/libunwind/libunwind.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibunwind%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Flibunwind%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flibunwind.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -241,6 +241,7 @@ if #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))] {\n #[cfg_attr(any(all(target_os = \"linux\", not(target_env = \"musl\")),\n                target_os = \"freebsd\",\n                target_os = \"solaris\",\n+               target_os = \"haiku\",\n                all(target_os = \"linux\",\n                    target_env = \"musl\",\n                    not(target_arch = \"x86\"),"}, {"sha": "12cd81ec700444b7b07f8db14bd76e3a0065c96d", "filename": "src/rustllvm/ArchiveWrapper.cpp", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Frustllvm%2FArchiveWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Frustllvm%2FArchiveWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FArchiveWrapper.cpp?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -22,7 +22,7 @@ struct RustArchiveMember {\n   Archive::Child child;\n \n   RustArchiveMember(): filename(NULL), name(NULL),\n-#if LLVM_VERSION_MINOR >= 8\n+#if LLVM_VERSION_GE(3, 8)\n     child(NULL, NULL, NULL)\n #else\n     child(NULL, NULL)\n@@ -35,7 +35,7 @@ struct RustArchiveMember {\n struct RustArchiveIterator {\n     Archive::child_iterator cur;\n     Archive::child_iterator end;\n-#if LLVM_VERSION_MINOR >= 9\n+#if LLVM_VERSION_GE(3, 9)\n     Error err;\n #endif\n };\n@@ -81,15 +81,15 @@ LLVMRustOpenArchive(char *path) {\n         return nullptr;\n     }\n \n-#if LLVM_VERSION_MINOR <= 8\n+#if LLVM_VERSION_LE(3, 8)\n     ErrorOr<std::unique_ptr<Archive>> archive_or =\n #else\n     Expected<std::unique_ptr<Archive>> archive_or =\n #endif\n         Archive::create(buf_or.get()->getMemBufferRef());\n \n     if (!archive_or) {\n-#if LLVM_VERSION_MINOR <= 8\n+#if LLVM_VERSION_LE(3, 8)\n         LLVMRustSetLastError(archive_or.getError().message().c_str());\n #else\n         LLVMRustSetLastError(toString(archive_or.takeError()).c_str());\n@@ -112,7 +112,7 @@ extern \"C\" LLVMRustArchiveIteratorRef\n LLVMRustArchiveIteratorNew(LLVMRustArchiveRef ra) {\n     Archive *ar = ra->getBinary();\n     RustArchiveIterator *rai = new RustArchiveIterator();\n-#if LLVM_VERSION_MINOR <= 8\n+#if LLVM_VERSION_LE(3, 8)\n     rai->cur = ar->child_begin();\n #else\n     rai->cur = ar->child_begin(rai->err);\n@@ -127,15 +127,15 @@ LLVMRustArchiveIteratorNew(LLVMRustArchiveRef ra) {\n \n extern \"C\" LLVMRustArchiveChildConstRef\n LLVMRustArchiveIteratorNext(LLVMRustArchiveIteratorRef rai) {\n-#if LLVM_VERSION_MINOR >= 9\n+#if LLVM_VERSION_GE(3, 9)\n     if (rai->err) {\n         LLVMRustSetLastError(toString(std::move(rai->err)).c_str());\n         return NULL;\n     }\n #endif\n     if (rai->cur == rai->end)\n         return NULL;\n-#if LLVM_VERSION_MINOR == 8\n+#if LLVM_VERSION_EQ(3, 8)\n     const ErrorOr<Archive::Child>* cur = rai->cur.operator->();\n     if (!*cur) {\n         LLVMRustSetLastError(cur->getError().message().c_str());\n@@ -207,7 +207,7 @@ LLVMRustWriteArchive(char *Dst,\n                      bool WriteSymbtab,\n                      LLVMRustArchiveKind rust_kind) {\n \n-#if LLVM_VERSION_MINOR <= 8\n+#if LLVM_VERSION_LE(3, 8)\n   std::vector<NewArchiveIterator> Members;\n #else\n   std::vector<NewArchiveMember> Members;\n@@ -218,20 +218,20 @@ LLVMRustWriteArchive(char *Dst,\n     auto Member = NewMembers[i];\n     assert(Member->name);\n     if (Member->filename) {\n-#if LLVM_VERSION_MINOR >= 9\n+#if LLVM_VERSION_GE(3, 9)\n       Expected<NewArchiveMember> MOrErr = NewArchiveMember::getFile(Member->filename, true);\n       if (!MOrErr) {\n         LLVMRustSetLastError(toString(MOrErr.takeError()).c_str());\n         return LLVMRustResult::Failure;\n       }\n       Members.push_back(std::move(*MOrErr));\n-#elif LLVM_VERSION_MINOR == 8\n+#elif LLVM_VERSION_EQ(3, 8)\n       Members.push_back(NewArchiveIterator(Member->filename));\n #else\n       Members.push_back(NewArchiveIterator(Member->filename, Member->name));\n #endif\n     } else {\n-#if LLVM_VERSION_MINOR <= 8\n+#if LLVM_VERSION_LE(3, 8)\n       Members.push_back(NewArchiveIterator(Member->child, Member->name));\n #else\n       Expected<NewArchiveMember> MOrErr = NewArchiveMember::getOldMember(Member->child, true);\n@@ -243,7 +243,7 @@ LLVMRustWriteArchive(char *Dst,\n #endif\n     }\n   }\n-#if LLVM_VERSION_MINOR >= 8\n+#if LLVM_VERSION_GE(3, 8)\n   auto pair = writeArchive(Dst, Members, WriteSymbtab, Kind, true, false);\n #else\n   auto pair = writeArchive(Dst, Members, WriteSymbtab, Kind, true);"}, {"sha": "60093e9bd37a812afdd97d87ed125658fd0f6a1b", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -46,7 +46,7 @@ LLVMInitializePasses() {\n   initializeVectorization(Registry);\n   initializeIPO(Registry);\n   initializeAnalysis(Registry);\n-#if LLVM_VERSION_MINOR == 7\n+#if LLVM_VERSION_EQ(3, 7)\n   initializeIPA(Registry);\n #endif\n   initializeTransformUtils(Registry);\n@@ -297,7 +297,7 @@ LLVMRustCreateTargetMachine(const char *triple,\n                             bool FunctionSections,\n                             bool DataSections) {\n \n-#if LLVM_VERSION_MINOR <= 8\n+#if LLVM_VERSION_LE(3, 8)\n     Reloc::Model RM;\n #else\n     Optional<Reloc::Model> RM;\n@@ -316,7 +316,7 @@ LLVMRustCreateTargetMachine(const char *triple,\n             RM = Reloc::DynamicNoPIC;\n             break;\n         default:\n-#if LLVM_VERSION_MINOR <= 8\n+#if LLVM_VERSION_LE(3, 8)\n             RM = Reloc::Default;\n #endif\n             break;\n@@ -337,7 +337,7 @@ LLVMRustCreateTargetMachine(const char *triple,\n     }\n \n     TargetOptions Options;\n-#if LLVM_VERSION_MINOR <= 8\n+#if LLVM_VERSION_LE(3, 8)\n     Options.PositionIndependentExecutable = PositionIndependentExecutable;\n #endif\n \n@@ -539,7 +539,7 @@ extern \"C\" void\n LLVMRustRunRestrictionPass(LLVMModuleRef M, char **symbols, size_t len) {\n     llvm::legacy::PassManager passes;\n \n-#if LLVM_VERSION_MINOR <= 8\n+#if LLVM_VERSION_LE(3, 8)\n     ArrayRef<const char*> ref(symbols, len);\n     passes.add(llvm::createInternalizePass(ref));\n #else\n@@ -593,7 +593,7 @@ LLVMRustGetModuleDataLayout(LLVMModuleRef M) {\n \n extern \"C\" void\n LLVMRustSetModulePIELevel(LLVMModuleRef M) {\n-#if LLVM_VERSION_MINOR >= 9\n+#if LLVM_VERSION_GE(3, 9)\n     unwrap(M)->setPIELevel(PIELevel::Level::Large);\n #endif\n }"}, {"sha": "672ab117f15f3c801006079ce22db0be62c7a989", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -394,7 +394,7 @@ extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateSubroutineType(\n     LLVMRustMetadataRef File,\n     LLVMRustMetadataRef ParameterTypes) {\n     return wrap(Builder->createSubroutineType(\n-#if LLVM_VERSION_MINOR == 7\n+#if LLVM_VERSION_EQ(3, 7)\n         unwrapDI<DIFile>(File),\n #endif\n         DITypeRefArray(unwrap<MDTuple>(ParameterTypes))));\n@@ -416,7 +416,7 @@ extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateFunction(\n     LLVMValueRef Fn,\n     LLVMRustMetadataRef TParam,\n     LLVMRustMetadataRef Decl) {\n-#if LLVM_VERSION_MINOR >= 8\n+#if LLVM_VERSION_GE(3, 8)\n     DITemplateParameterArray TParams =\n         DITemplateParameterArray(unwrap<MDTuple>(TParam));\n     DISubprogram *Sub = Builder->createFunction(\n@@ -565,7 +565,7 @@ extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateVariable(\n     int64_t* AddrOps,\n     unsigned AddrOpsCount,\n     unsigned ArgNo) {\n-#if LLVM_VERSION_MINOR >= 8\n+#if LLVM_VERSION_GE(3, 8)\n     if (Tag == 0x100) { // DW_TAG_auto_variable\n         return wrap(Builder->createAutoVariable(\n             unwrapDI<DIDescriptor>(Scope), Name,\n@@ -814,7 +814,7 @@ LLVMRustLinkInExternalBitcode(LLVMModuleRef dst, char *bc, size_t len) {\n \n     raw_string_ostream Stream(Err);\n     DiagnosticPrinterRawOStream DP(Stream);\n-#if LLVM_VERSION_MINOR >= 8\n+#if LLVM_VERSION_GE(3, 8)\n     if (Linker::linkModules(*Dst, std::move(Src.get()))) {\n #else\n     if (Linker::LinkModules(Dst, Src->get(), [&](const DiagnosticInfo &DI) { DI.print(DP); })) {\n@@ -937,14 +937,14 @@ to_rust(DiagnosticKind kind)\n         return LLVMRustDiagnosticKind::OptimizationRemarkMissed;\n     case DK_OptimizationRemarkAnalysis:\n         return LLVMRustDiagnosticKind::OptimizationRemarkAnalysis;\n-#if LLVM_VERSION_MINOR >= 8\n+#if LLVM_VERSION_GE(3, 8)\n     case DK_OptimizationRemarkAnalysisFPCommute:\n         return LLVMRustDiagnosticKind::OptimizationRemarkAnalysisFPCommute;\n     case DK_OptimizationRemarkAnalysisAliasing:\n         return LLVMRustDiagnosticKind::OptimizationRemarkAnalysisAliasing;\n #endif\n     default:\n-#if LLVM_VERSION_MINOR >= 9\n+#if LLVM_VERSION_GE(3, 9)\n         return (kind >= DK_FirstRemark && kind <= DK_LastRemark) ?\n             LLVMRustDiagnosticKind::OptimizationRemarkOther :\n             LLVMRustDiagnosticKind::Other;\n@@ -994,7 +994,7 @@ extern \"C\" LLVMTypeKind LLVMRustGetTypeKind(LLVMTypeRef Ty) {\n     return LLVMVectorTypeKind;\n   case Type::X86_MMXTyID:\n     return LLVMX86_MMXTypeKind;\n-#if LLVM_VERSION_MINOR >= 8\n+#if LLVM_VERSION_GE(3, 8)\n   case Type::TokenTyID:\n     return LLVMTokenTypeKind;\n #endif\n@@ -1043,7 +1043,7 @@ LLVMRustBuildCleanupPad(LLVMBuilderRef Builder,\n                         unsigned ArgCnt,\n                         LLVMValueRef *LLArgs,\n                         const char *Name) {\n-#if LLVM_VERSION_MINOR >= 8\n+#if LLVM_VERSION_GE(3, 8)\n     Value **Args = unwrap(LLArgs);\n     if (ParentPad == NULL) {\n         Type *Ty = Type::getTokenTy(unwrap(Builder)->getContext());\n@@ -1061,7 +1061,7 @@ extern \"C\" LLVMValueRef\n LLVMRustBuildCleanupRet(LLVMBuilderRef Builder,\n                         LLVMValueRef CleanupPad,\n                         LLVMBasicBlockRef UnwindBB) {\n-#if LLVM_VERSION_MINOR >= 8\n+#if LLVM_VERSION_GE(3, 8)\n     CleanupPadInst *Inst = cast<CleanupPadInst>(unwrap(CleanupPad));\n     return wrap(unwrap(Builder)->CreateCleanupRet(Inst, unwrap(UnwindBB)));\n #else\n@@ -1075,7 +1075,7 @@ LLVMRustBuildCatchPad(LLVMBuilderRef Builder,\n                       unsigned ArgCnt,\n                       LLVMValueRef *LLArgs,\n                       const char *Name) {\n-#if LLVM_VERSION_MINOR >= 8\n+#if LLVM_VERSION_GE(3, 8)\n     Value **Args = unwrap(LLArgs);\n     return wrap(unwrap(Builder)->CreateCatchPad(unwrap(ParentPad),\n                                                 ArrayRef<Value*>(Args, ArgCnt),\n@@ -1089,7 +1089,7 @@ extern \"C\" LLVMValueRef\n LLVMRustBuildCatchRet(LLVMBuilderRef Builder,\n                       LLVMValueRef Pad,\n                       LLVMBasicBlockRef BB) {\n-#if LLVM_VERSION_MINOR >= 8\n+#if LLVM_VERSION_GE(3, 8)\n     return wrap(unwrap(Builder)->CreateCatchRet(cast<CatchPadInst>(unwrap(Pad)),\n                                                 unwrap(BB)));\n #else\n@@ -1103,7 +1103,7 @@ LLVMRustBuildCatchSwitch(LLVMBuilderRef Builder,\n                          LLVMBasicBlockRef BB,\n                          unsigned NumHandlers,\n                          const char *Name) {\n-#if LLVM_VERSION_MINOR >= 8\n+#if LLVM_VERSION_GE(3, 8)\n     if (ParentPad == NULL) {\n         Type *Ty = Type::getTokenTy(unwrap(Builder)->getContext());\n         ParentPad = wrap(Constant::getNullValue(Ty));\n@@ -1120,7 +1120,7 @@ LLVMRustBuildCatchSwitch(LLVMBuilderRef Builder,\n extern \"C\" void\n LLVMRustAddHandler(LLVMValueRef CatchSwitchRef,\n                    LLVMBasicBlockRef Handler) {\n-#if LLVM_VERSION_MINOR >= 8\n+#if LLVM_VERSION_GE(3, 8)\n     Value *CatchSwitch = unwrap(CatchSwitchRef);\n     cast<CatchSwitchInst>(CatchSwitch)->addHandler(unwrap(Handler));\n #endif\n@@ -1129,14 +1129,14 @@ LLVMRustAddHandler(LLVMValueRef CatchSwitchRef,\n extern \"C\" void\n LLVMRustSetPersonalityFn(LLVMBuilderRef B,\n                          LLVMValueRef Personality) {\n-#if LLVM_VERSION_MINOR >= 8\n+#if LLVM_VERSION_GE(3, 8)\n     unwrap(B)->GetInsertBlock()\n              ->getParent()\n              ->setPersonalityFn(cast<Function>(unwrap(Personality)));\n #endif\n }\n \n-#if LLVM_VERSION_MINOR >= 8\n+#if LLVM_VERSION_GE(3, 8)\n extern \"C\" OperandBundleDef*\n LLVMRustBuildOperandBundleDef(const char *Name,\n                               LLVMValueRef *Inputs,"}, {"sha": "ffe94d1e22f20b117bd607cb3ab129f10ef75100", "filename": "src/rustllvm/rustllvm.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Frustllvm%2Frustllvm.h", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Frustllvm%2Frustllvm.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.h?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -45,7 +45,16 @@\n #include \"llvm-c/ExecutionEngine.h\"\n #include \"llvm-c/Object.h\"\n \n-#if LLVM_VERSION_MINOR >= 7\n+#define LLVM_VERSION_GE(major, minor) \\\n+  (LLVM_VERSION_MAJOR > (major) || LLVM_VERSION_MAJOR == (major) && LLVM_VERSION_MINOR >= (minor))\n+\n+#define LLVM_VERSION_EQ(major, minor) \\\n+  (LLVM_VERSION_MAJOR == (major) && LLVM_VERSION_MINOR == (minor))\n+\n+#define LLVM_VERSION_LE(major, minor) \\\n+  (LLVM_VERSION_MAJOR < (major) || LLVM_VERSION_MAJOR == (major) && LLVM_VERSION_MINOR <= (minor))\n+\n+#if LLVM_VERSION_GE(3, 7)\n #include \"llvm/IR/LegacyPassManager.h\"\n #else\n #include \"llvm/PassManager.h\""}, {"sha": "2b89873ee45ff9838a8c6e42f8dfcbb8b328c248", "filename": "src/test/compile-fail/E0512.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftest%2Fcompile-fail%2FE0512.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftest%2Fcompile-fail%2FE0512.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0512.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -12,4 +12,5 @@ fn takes_u8(_: u8) {}\n \n fn main() {\n     unsafe { takes_u8(::std::mem::transmute(0u16)); } //~ ERROR E0512\n+                                                      //~| transmuting between 16 bits and 8 bits\n }"}, {"sha": "726e23265241dac4f6ac35e5c78113466dafffbb", "filename": "src/test/compile-fail/E0513.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftest%2Fcompile-fail%2FE0513.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftest%2Fcompile-fail%2FE0513.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0513.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mem;\n+\n+fn main() {\n+    unsafe {\n+        let size = mem::size_of::<u32>();\n+        mem::transmute_copy::<u32, [u8; size]>(&8_8); //~ ERROR E0513\n+                                                      //~| NOTE no type for variable\n+    }\n+}"}, {"sha": "457d40e62b0371ebc3ea09ba0d601413d74cf17d", "filename": "src/test/compile-fail/issue-21146.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftest%2Fcompile-fail%2Fissue-21146.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftest%2Fcompile-fail%2Fissue-21146.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21146.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: expected item, found `parse_error`\n+// error-pattern: expected one of `!` or `::`, found `<eof>`\n include!(\"auxiliary/issue-21146-inc.rs\");\n fn main() {}"}, {"sha": "b7b5553dc74e469c5f16ee287489156bb7c6de81", "filename": "src/test/compile-fail/issue-5067.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftest%2Fcompile-fail%2Fissue-5067.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftest%2Fcompile-fail%2Fissue-5067.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5067.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! foo {\n+    ( $()* ) => {};\n+    //~^ ERROR repetition matches empty token tree\n+    ( $()+ ) => {};\n+    //~^ ERROR repetition matches empty token tree\n+\n+    ( $(),* ) => {}; // PASS\n+    ( $(),+ ) => {}; // PASS\n+\n+    ( [$()*] ) => {};\n+    //~^ ERROR repetition matches empty token tree\n+    ( [$()+] ) => {};\n+    //~^ ERROR repetition matches empty token tree\n+\n+    ( [$(),*] ) => {}; // PASS\n+    ( [$(),+] ) => {}; // PASS\n+\n+    ( $($()* $(),* $(a)* $(a),* )* ) => {};\n+    //~^ ERROR repetition matches empty token tree\n+    ( $($()* $(),* $(a)* $(a),* )+ ) => {};\n+    //~^ ERROR repetition matches empty token tree\n+\n+    ( $(a     $(),* $(a)* $(a),* )* ) => {}; // PASS\n+    ( $($(a)+ $(),* $(a)* $(a),* )+ ) => {}; // PASS\n+\n+    ( $(a $()+)* ) => {};\n+    //~^ ERROR repetition matches empty token tree\n+    ( $(a $()*)+ ) => {};\n+    //~^ ERROR repetition matches empty token tree\n+}\n+\n+\n+// --- Original Issue --- //\n+\n+macro_rules! make_vec {\n+    (a $e1:expr $($(, a $e2:expr)*)*) => ([$e1 $($(, $e2)*)*]);\n+    //~^ ERROR repetition matches empty token tree\n+}\n+\n+fn main() {\n+    let _ = make_vec!(a 1, a 2, a 3);\n+}\n+\n+\n+// --- Minified Issue --- //\n+\n+macro_rules! m {\n+    ( $()* ) => {}\n+    //~^ ERROR repetition matches empty token tree\n+}\n+\n+m!();"}, {"sha": "80802e19f8401de8c6344d2aee2dde3fc4b9050f", "filename": "src/test/compile-fail/macro-context.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftest%2Fcompile-fail%2Fmacro-context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftest%2Fcompile-fail%2Fmacro-context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-context.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -14,11 +14,8 @@ macro_rules! m {\n                             //~| ERROR macro expansion ignores token `typeof`\n                             //~| ERROR macro expansion ignores token `;`\n                             //~| ERROR macro expansion ignores token `;`\n-                            //~| ERROR macro expansion ignores token `i`\n }\n \n-m!();               //~ NOTE the usage of `m!` is likely invalid in item context\n-\n fn main() {\n     let a: m!();    //~ NOTE the usage of `m!` is likely invalid in type context\n     let i = m!();   //~ NOTE the usage of `m!` is likely invalid in expression context"}, {"sha": "c69b7e526cc3b1a53b2495ec735b9928fa8ae543", "filename": "src/test/compile-fail/paths-in-macro-invocations.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftest%2Fcompile-fail%2Fpaths-in-macro-invocations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftest%2Fcompile-fail%2Fpaths-in-macro-invocations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpaths-in-macro-invocations.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+::foo::bar!(); //~ ERROR expected macro name without module separators\n+foo::bar!(); //~ ERROR expected macro name without module separators\n+\n+trait T {\n+    foo::bar!(); //~ ERROR expected macro name without module separators\n+    ::foo::bar!(); //~ ERROR expected macro name without module separators\n+}\n+\n+struct S {\n+    x: foo::bar!(), //~ ERROR expected macro name without module separators\n+    y: ::foo::bar!(), //~ ERROR expected macro name without module separators\n+}\n+\n+impl S {\n+    foo::bar!(); //~ ERROR expected macro name without module separators\n+    ::foo::bar!(); //~ ERROR expected macro name without module separators\n+}\n+\n+fn main() {\n+    foo::bar!(); //~ ERROR expected macro name without module separators\n+    ::foo::bar!(); //~ ERROR expected macro name without module separators\n+\n+    let _ = foo::bar!(); //~ ERROR expected macro name without module separators\n+    let _ = ::foo::bar!(); //~ ERROR expected macro name without module separators\n+\n+    let foo::bar!() = 0; //~ ERROR expected macro name without module separators\n+    let ::foo::bar!() = 0; //~ ERROR expected macro name without module separators\n+}"}, {"sha": "911606ef01213e17c518d8b9f6be9ef5fc57c8c8", "filename": "src/test/compile-fail/self_type_keyword.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -30,8 +30,7 @@ pub fn main() {\n         ref mut Self => (),\n         //~^ ERROR expected identifier, found keyword `Self`\n         Self!() => (),\n-        //~^ ERROR expected identifier, found keyword `Self`\n-        //~^^ ERROR macro undefined: 'Self!'\n+        //~^ ERROR macro undefined: 'Self!'\n         Foo { x: Self } => (),\n         //~^ ERROR expected identifier, found keyword `Self`\n         Foo { Self } => (),"}, {"sha": "ff3fefde40ece69c6005601d7fd513b09afba3f8", "filename": "src/test/parse-fail/extern-no-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftest%2Fparse-fail%2Fextern-no-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftest%2Fparse-fail%2Fextern-no-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fextern-no-fn.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -11,7 +11,7 @@\n // compile-flags: -Z parse-only\n \n extern {\n-    f(); //~ ERROR expected one of `fn`, `pub`, `static`, or `}`, found `f`\n+    f(); //~ ERROR expected one of `!` or `::`, found `(`\n }\n \n fn main() {"}, {"sha": "c03e0ef73217c5acee45a4012275acbff2f997bb", "filename": "src/test/parse-fail/issue-21153.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftest%2Fparse-fail%2Fissue-21153.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftest%2Fparse-fail%2Fissue-21153.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-21153.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -11,5 +11,6 @@\n // compile-flags: -Z parse-only\n \n trait MyTrait<T>: Iterator {\n-    Item = T; //~ ERROR expected one of `const`, `extern`, `fn`, `type`, or `unsafe`, found `Item`\n+    Item = T; //~ ERROR expected one of `!` or `::`, found `=`\n+              //~| ERROR expected item, found `=`\n }"}, {"sha": "0ee239af0fa6c796182f3f86682cebe1393bf9bb", "filename": "src/test/run-make/link-arg/Makefile", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftest%2Frun-make%2Flink-arg%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftest%2Frun-make%2Flink-arg%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flink-arg%2FMakefile?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -0,0 +1,5 @@\n+-include ../tools.mk\n+RUSTC_FLAGS = -C link-arg=\"-lfoo\" -C link-arg=\"-lbar\" -Z print-link-args\n+\n+all:\n+\t$(RUSTC) $(RUSTC_FLAGS) empty.rs | grep lfoo | grep lbar"}, {"sha": "2b76fb24e5f1eb994ba0d792dc451a5bf8faac71", "filename": "src/test/run-make/link-arg/empty.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftest%2Frun-make%2Flink-arg%2Fempty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftest%2Frun-make%2Flink-arg%2Fempty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flink-arg%2Fempty.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() { }"}, {"sha": "0abe44d82591d702a89c93c44986c54b0ceeed7b", "filename": "src/test/run-pass/fds-are-cloexec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftest%2Frun-pass%2Ffds-are-cloexec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftest%2Frun-pass%2Ffds-are-cloexec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffds-are-cloexec.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -11,6 +11,7 @@\n // ignore-windows\n // ignore-android\n // ignore-emscripten\n+// ignore-haiku\n \n #![feature(libc)]\n "}, {"sha": "428bbcfe5761d6d00acadc632fea0f7c0c5685ef", "filename": "src/tools/compiletest/src/util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7679b460d49a89b5d23bb04426229f4add235b/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs?ref=ec7679b460d49a89b5d23bb04426229f4add235b", "patch": "@@ -17,6 +17,7 @@ const OS_TABLE: &'static [(&'static str, &'static str)] = &[(\"android\", \"android\n                                                             (\"darwin\", \"macos\"),\n                                                             (\"dragonfly\", \"dragonfly\"),\n                                                             (\"freebsd\", \"freebsd\"),\n+                                                            (\"haiku\", \"haiku\"),\n                                                             (\"ios\", \"ios\"),\n                                                             (\"linux\", \"linux\"),\n                                                             (\"mingw32\", \"windows\"),"}]}