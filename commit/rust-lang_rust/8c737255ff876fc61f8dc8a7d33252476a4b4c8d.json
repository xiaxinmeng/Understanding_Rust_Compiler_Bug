{"sha": "8c737255ff876fc61f8dc8a7d33252476a4b4c8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjNzM3MjU1ZmY4NzZmYzYxZjhkYzhhN2QzMzI1MjQ3NmE0YjRjOGQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-13T19:58:36Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-15T21:00:05Z"}, "message": "use salsa for new module map", "tree": {"sha": "1adc74bb54f59c6d868a337cc440ed227e43a44b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1adc74bb54f59c6d868a337cc440ed227e43a44b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c737255ff876fc61f8dc8a7d33252476a4b4c8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c737255ff876fc61f8dc8a7d33252476a4b4c8d", "html_url": "https://github.com/rust-lang/rust/commit/8c737255ff876fc61f8dc8a7d33252476a4b4c8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c737255ff876fc61f8dc8a7d33252476a4b4c8d/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60fdfec32759d5e006eae9fe09a87b1a28b19983", "url": "https://api.github.com/repos/rust-lang/rust/commits/60fdfec32759d5e006eae9fe09a87b1a28b19983", "html_url": "https://github.com/rust-lang/rust/commit/60fdfec32759d5e006eae9fe09a87b1a28b19983"}], "stats": {"total": 713, "additions": 318, "deletions": 395}, "files": [{"sha": "88f29d7c869a0dfca36891dda7d2e7fe621e1b9b", "filename": "crates/libanalysis/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c737255ff876fc61f8dc8a7d33252476a4b4c8d/crates%2Flibanalysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8c737255ff876fc61f8dc8a7d33252476a4b4c8d/crates%2Flibanalysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2FCargo.toml?ref=8c737255ff876fc61f8dc8a7d33252476a4b4c8d", "patch": "@@ -14,6 +14,7 @@ fst = \"0.3.1\"\n im = \"12.0.0\"\n libsyntax2 = { path = \"../libsyntax2\" }\n libeditor = { path = \"../libeditor\" }\n+salsa = { path = \"../salsa\" }\n \n [dev-dependencies]\n test_utils = { path = \"../test_utils\" }"}, {"sha": "d30e75fe2b6b95b4a677d21831629c9a3637f9ed", "filename": "crates/libanalysis/src/db.rs", "status": "removed", "additions": 0, "deletions": 306, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/60fdfec32759d5e006eae9fe09a87b1a28b19983/crates%2Flibanalysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60fdfec32759d5e006eae9fe09a87b1a28b19983/crates%2Flibanalysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fdb.rs?ref=60fdfec32759d5e006eae9fe09a87b1a28b19983", "patch": "@@ -1,306 +0,0 @@\n-use std::{\n-    hash::{Hash, Hasher},\n-    sync::Arc,\n-    cell::RefCell,\n-    fmt::Debug,\n-    any::Any,\n-};\n-use parking_lot::Mutex;\n-use libsyntax2::{File};\n-use im;\n-use {\n-    FileId,\n-    imp::{FileResolverImp},\n-};\n-\n-#[derive(Debug)]\n-pub(crate) struct DbHost {\n-    db: Arc<Db>,\n-}\n-\n-impl DbHost {\n-    pub(crate) fn new() -> DbHost {\n-        let db = Db {\n-            file_resolver: FileResolverImp::default(),\n-            files: im::HashMap::new(),\n-            cache: Mutex::new(Cache::new())\n-        };\n-        DbHost { db: Arc::new(db) }\n-    }\n-    pub(crate) fn change_file(&mut self, file_id: FileId, text: Option<String>) {\n-        let db = self.db_mut();\n-        match text {\n-            None => {\n-                db.files.remove(&file_id);\n-            }\n-            Some(text) => {\n-                db.files.insert(file_id, Arc::new(text));\n-            }\n-        }\n-    }\n-    pub(crate) fn set_file_resolver(&mut self, file_resolver: FileResolverImp) {\n-        let db = self.db_mut();\n-        db.file_resolver = file_resolver\n-    }\n-    pub(crate) fn query_ctx(&self) -> QueryCtx {\n-        QueryCtx {\n-            db: Arc::clone(&self.db),\n-            stack: RefCell::new(Vec::new()),\n-            trace: RefCell::new(Vec::new()),\n-        }\n-    }\n-    fn db_mut(&mut self) -> &mut Db {\n-        // NB: this \"forks\" the database\n-        let db = Arc::make_mut(&mut self.db);\n-        db.cache.get_mut().gen += 1;\n-        db\n-    }\n-}\n-\n-type QueryInvocationId = (u32, u64);\n-type Gen = u64;\n-type OutputHash = u64;\n-\n-fn id<Q: Query>(params: &Q::Params) -> QueryInvocationId {\n-    use std::collections::hash_map::DefaultHasher;\n-    let mut hasher = DefaultHasher::new();\n-    params.hash(&mut hasher);\n-    (Q::ID, hasher.finish())\n-}\n-fn output_hash<Q: Query>(output: &Q::Output) -> OutputHash {\n-    use std::collections::hash_map::DefaultHasher;\n-    let mut hasher = DefaultHasher::new();\n-    output.hash(&mut hasher);\n-    hasher.finish()\n-}\n-\n-#[derive(Debug)]\n-pub(crate) struct Db {\n-    file_resolver: FileResolverImp,\n-    files: im::HashMap<FileId, Arc<String>>,\n-    cache: Mutex<Cache>,\n-}\n-\n-impl Clone for Db {\n-    fn clone(&self) -> Db {\n-        Db {\n-            file_resolver: self.file_resolver.clone(),\n-            files: self.files.clone(),\n-            cache: Mutex::new(Cache::new()),\n-        }\n-    }\n-}\n-\n-type QueryDeps = Vec<(QueryInvocationId, Arc<Any>, OutputHash)>;\n-\n-#[derive(Default, Debug)]\n-pub(crate) struct Cache {\n-    gen: Gen,\n-    green: im::HashMap<QueryInvocationId, (Gen, OutputHash)>,\n-    deps: im::HashMap<QueryInvocationId, QueryDeps>,\n-    results: im::HashMap<QueryInvocationId, Arc<Any>>,\n-}\n-\n-\n-#[allow(type_alias_bounds)]\n-pub(crate) type QueryCache<Q: Query> = im::HashMap<\n-    <Q as Query>::Params,\n-    <Q as Query>::Output\n->;\n-\n-impl Cache {\n-    fn new() -> Cache {\n-        Default::default()\n-    }\n-\n-    fn get_result<Q: Query>(&self, id: QueryInvocationId) -> Q::Output\n-    where\n-        Q::Output: Clone\n-    {\n-        let res = &self.results[&id];\n-        let res = res.downcast_ref::<Q::Output>().unwrap();\n-        res.clone()\n-    }\n-}\n-\n-pub(crate) struct QueryCtx {\n-    db: Arc<Db>,\n-    stack: RefCell<Vec<(QueryInvocationId, QueryDeps)>>,\n-    pub(crate) trace: RefCell<Vec<TraceEvent>>,\n-}\n-\n-#[derive(Clone, Copy, Debug)]\n-pub(crate) struct TraceEvent {\n-    pub(crate) query_id: u32,\n-    pub(crate) kind: TraceEventKind\n-}\n-\n-#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n-pub(crate) enum TraceEventKind {\n-    Start, Evaluating, Finish\n-}\n-\n-impl QueryCtx {\n-    pub(crate) fn get<Q: Get>(&self, params: &Q::Params) -> Q::Output {\n-        let me = id::<Q>(params);\n-        self.trace(TraceEvent { query_id: Q::ID, kind: TraceEventKind::Start });\n-        let res = Q::get(self, params);\n-        self.trace(TraceEvent { query_id: Q::ID, kind: TraceEventKind::Finish });\n-        {\n-            let mut stack = self.stack.borrow_mut();\n-            if let Some((_, ref mut deps)) = stack.last_mut() {\n-                let params = Arc::new(params.clone());\n-                deps.push((me, params, output_hash::<Q>(&res)));\n-            }\n-        }\n-\n-        res\n-    }\n-    fn trace(&self, event: TraceEvent) {\n-        self.trace.borrow_mut().push(event)\n-    }\n-}\n-\n-pub(crate) trait Query {\n-    const ID: u32;\n-    type Params: Hash + Eq + Debug + Clone + Any + 'static;\n-    type Output: Hash + Debug + Any + 'static;\n-}\n-\n-pub(crate) trait Get: Query {\n-    fn get(ctx: &QueryCtx, params: &Self::Params) -> Self::Output;\n-}\n-\n-impl<Q: Eval> Get for Q\n-where\n-    Q::Params: Clone,\n-    Q::Output: Clone,\n-{\n-    fn get(ctx: &QueryCtx, params: &Self::Params) -> Self::Output {\n-        if let Some(res) = try_reuse::<Q>(ctx, params) {\n-            return res;\n-        }\n-\n-        let me = id::<Q>(params);\n-        ctx.trace(TraceEvent { query_id: Q::ID, kind: TraceEventKind::Evaluating });\n-        ctx.stack.borrow_mut().push((me, Vec::new()));\n-        let res = Self::eval(ctx, params);\n-        let (also_me, deps) = ctx.stack.borrow_mut().pop().unwrap();\n-        assert_eq!(also_me, me);\n-        let mut cache = ctx.db.cache.lock();\n-        cache.deps.insert(me, deps);\n-        let gen = cache.gen;\n-        let output_hash = output_hash::<Q>(&res);\n-        let id = id::<Q>(params);\n-        cache.green.insert(id, (gen, output_hash));\n-        cache.results.insert(me, Arc::new(res.clone()));\n-        res\n-    }\n-}\n-\n-fn try_reuse<Q: Eval>(ctx: &QueryCtx, params: &Q::Params) -> Option<Q::Output>\n-where\n-    Q::Params: Clone,\n-    Q::Output: Clone,\n-{\n-    let id = id::<Q>(params);\n-    let mut cache = ctx.db.cache.lock();\n-    let curr_gen = cache.gen;\n-    let old_hash = match *cache.green.get(&id)? {\n-        (gen, _) if gen == curr_gen => {\n-            return Some(cache.get_result::<Q>(id));\n-        }\n-        (_, hash) => hash,\n-    };\n-    let deps_are_fresh = cache.deps[&id]\n-        .iter()\n-        .all(|&(dep_id, _, dep_hash)| {\n-            match cache.green.get(&dep_id) {\n-                //TODO: store the value of parameters, and re-execute the query\n-                Some((gen, hash)) if gen == &curr_gen && hash == &dep_hash => true,\n-                _ => false,\n-            }\n-        });\n-    if !deps_are_fresh {\n-        return None;\n-    }\n-    cache.green.insert(id, (curr_gen, old_hash));\n-    Some(cache.get_result::<Q>(id))\n-}\n-\n-pub(crate) trait Eval: Query\n-where\n-    Self::Params: Clone,\n-    Self::Output: Clone,\n-{\n-    fn eval(ctx: &QueryCtx, params: &Self::Params) -> Self::Output;\n-}\n-\n-#[derive(Debug)]\n-pub(crate) struct DbFiles {\n-    db: Arc<Db>,\n-}\n-\n-impl Hash for DbFiles {\n-    fn hash<H: Hasher>(&self, hasher: &mut H) {\n-        self.db.cache.lock().gen.hash(hasher)\n-    }\n-}\n-\n-impl DbFiles {\n-    pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item=FileId> + 'a {\n-        self.db.files.keys().cloned()\n-    }\n-    pub(crate) fn file_resolver(&self) -> FileResolverImp {\n-        self.db.file_resolver.clone()\n-    }\n-}\n-\n-pub(crate) enum Files {}\n-impl Query for Files {\n-    const ID: u32 = 1;\n-    type Params = ();\n-    type Output = DbFiles;\n-}\n-impl Get for Files {\n-    fn get(ctx: &QueryCtx, params: &()) -> DbFiles {\n-        let res = DbFiles { db: Arc::clone(&ctx.db) };\n-        let id = id::<Self>(params);\n-        let hash = output_hash::<Self>(&res);\n-        let mut cache = ctx.db.cache.lock();\n-        let gen = cache.gen;\n-        cache.green.insert(id, (gen, hash));\n-        res\n-    }\n-}\n-\n-enum FileText {}\n-impl Query for FileText {\n-    const ID: u32 = 10;\n-    type Params = FileId;\n-    type Output = Arc<String>;\n-}\n-impl Get for FileText {\n-    fn get(ctx: &QueryCtx, file_id: &FileId) -> Arc<String> {\n-        let res = ctx.db.files[file_id].clone();\n-        let id = id::<Self>(file_id);\n-        let hash = output_hash::<Self>(&res);\n-        let mut cache = ctx.db.cache.lock();\n-        let gen = cache.gen;\n-        cache.green.insert(id, (gen, hash));\n-        res\n-    }\n-}\n-\n-pub(crate) enum FileSyntax {}\n-impl Query for FileSyntax {\n-    const ID: u32 = 20;\n-    type Params = FileId;\n-    type Output = File;\n-}\n-impl Eval for FileSyntax {\n-    fn eval(ctx: &QueryCtx, file_id: &FileId) -> File {\n-        let text = ctx.get::<FileText>(file_id);\n-        File::parse(&text)\n-    }\n-}"}, {"sha": "f68aab61c0f1b0a6875e3124308567511b68bd74", "filename": "crates/libanalysis/src/db/mod.rs", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/8c737255ff876fc61f8dc8a7d33252476a4b4c8d/crates%2Flibanalysis%2Fsrc%2Fdb%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c737255ff876fc61f8dc8a7d33252476a4b4c8d/crates%2Flibanalysis%2Fsrc%2Fdb%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fdb%2Fmod.rs?ref=8c737255ff876fc61f8dc8a7d33252476a4b4c8d", "patch": "@@ -0,0 +1,196 @@\n+mod queries;\n+\n+use std::{\n+    hash::{Hash},\n+    sync::Arc,\n+    fmt::Debug,\n+    any::Any,\n+    iter,\n+};\n+use im;\n+use salsa;\n+use {\n+    FileId,\n+    imp::{FileResolverImp},\n+};\n+\n+\n+#[derive(Clone, Default)]\n+pub(crate) struct State {\n+    pub(crate) resolver: FileResolverImp,\n+    pub(crate) file_map: im::HashMap<FileId, Arc<str>>,\n+}\n+\n+type Data = Arc<Any + Send + Sync + 'static>;\n+\n+pub(crate) struct QueryCtx<'a> {\n+    inner: &'a salsa::QueryCtx<State, Data>\n+}\n+\n+pub(crate) struct Db {\n+    inner: salsa::Db<State, Data>\n+}\n+\n+struct GroundQuery<T, R> {\n+    id: u16,\n+    f: fn(&State, &T) -> R,\n+    h: fn(&R) -> u64,\n+}\n+\n+pub(crate) struct Query<T, R> {\n+    pub(crate) id: u16,\n+    pub(crate) f: fn(QueryCtx, &T) -> R,\n+}\n+\n+impl Db {\n+    pub(crate) fn new(state: State) -> Db {\n+        Db { inner: salsa::Db::new(query_config(), state) }\n+    }\n+    pub(crate) fn state(&self) -> &State {\n+        self.inner.ground_data()\n+    }\n+    pub(crate) fn with_state(\n+        &self,\n+        new_state: State,\n+        updated_files: &[FileId],\n+        file_set_changed: bool,\n+    ) -> Db {\n+        let mut inv = salsa::Invalidations::new();\n+        if file_set_changed {\n+            inv.invalidate(\n+                salsa::QueryTypeId(queries::FILE_SET.id),\n+                iter::once(salsa::InputFingerprint(hash(&()))),\n+            );\n+        } else {\n+            inv.invalidate(\n+                salsa::QueryTypeId(queries::FILE_SET.id),\n+                iter::empty(),\n+            );\n+        }\n+        inv.invalidate(\n+            salsa::QueryTypeId(queries::FILE_TEXT.id),\n+            updated_files.iter().map(hash).map(salsa::InputFingerprint),\n+        );\n+        Db { inner: self.inner.with_ground_data(new_state, inv) }\n+    }\n+    pub(crate) fn get<T, R>(&self, q: Query<T, R>, params: T) -> (Arc<R>, Vec<u16>)\n+    where\n+        T: Hash + Send + Sync + 'static,\n+        R: Send + Sync + 'static,\n+    {\n+        let query_id = salsa::QueryId(\n+            salsa::QueryTypeId(q.id),\n+            salsa::InputFingerprint(hash(&params)),\n+        );\n+        let params = Arc::new(params);\n+        let (res, events) = self.inner.get(query_id, params);\n+        let res = res.downcast().unwrap();\n+        let events = events.into_iter().map(|it| it.0).collect();\n+        (res, events)\n+    }\n+\n+}\n+\n+impl<'a> QueryCtx<'a> {\n+    fn get_g<T, R>(&self, q: GroundQuery<T, R>, params: T) -> Arc<R>\n+    where\n+        T: Hash + Send + Sync + 'static,\n+        R: Send + Sync + 'static,\n+     {\n+        let query_id = salsa::QueryId(\n+            salsa::QueryTypeId(q.id),\n+            salsa::InputFingerprint(hash(&params)),\n+        );\n+        let res = self.inner.get(query_id, Arc::new(params));\n+        res.downcast().unwrap()\n+    }\n+    pub(crate) fn get<T, R>(&self, q: Query<T, R>, params: T) -> Arc<R>\n+    where\n+        T: Hash + Send + Sync + 'static,\n+        R: Send + Sync + 'static,\n+     {\n+        let query_id = salsa::QueryId(\n+            salsa::QueryTypeId(q.id),\n+            salsa::InputFingerprint(hash(&params)),\n+        );\n+        let res = self.inner.get(query_id, Arc::new(params));\n+        res.downcast().unwrap()\n+    }\n+}\n+\n+fn query_config() -> salsa::QueryConfig<State, Data> {\n+    let mut res = salsa::QueryConfig::new();\n+    let queries: Vec<SalsaGroundQuery> = vec![\n+        queries::FILE_TEXT.into(),\n+        queries::FILE_SET.into(),\n+    ];\n+    for q in queries {\n+        res = res.with_ground_query(q.query_type, q.f)\n+    }\n+    let queries: Vec<SalsaQuery> = vec![\n+        queries::FILE_SYNTAX.into(),\n+        ::module_map_db::MODULE_DESCR.into(),\n+        ::module_map_db::RESOLVE_SUBMODULE.into(),\n+        ::module_map_db::PARENT_MODULE.into(),\n+    ];\n+    for q in queries {\n+        res = res.with_query(q.query_type, q.f);\n+    }\n+    res\n+}\n+\n+struct SalsaGroundQuery {\n+    query_type: salsa::QueryTypeId,\n+    f: Box<Fn(&State, &Data) -> (Data, salsa::OutputFingerprint) + Send + Sync + 'static>,\n+}\n+\n+impl<T, R> From<GroundQuery<T, R>> for SalsaGroundQuery\n+where\n+    T: Send + Sync + 'static,\n+    R: Send + Sync + 'static,\n+{\n+    fn from(q: GroundQuery<T, R>) -> SalsaGroundQuery\n+    {\n+        SalsaGroundQuery {\n+            query_type: salsa::QueryTypeId(q.id),\n+            f: Box::new(move |state, data| {\n+                let data: &T = data.downcast_ref().unwrap();\n+                let res = (q.f)(state, data);\n+                let h = (q.h)(&res);\n+                (Arc::new(res), salsa::OutputFingerprint(h))\n+            })\n+        }\n+    }\n+}\n+\n+struct SalsaQuery {\n+    query_type: salsa::QueryTypeId,\n+    f: Box<Fn(&salsa::QueryCtx<State, Data>, &Data) -> (Data, salsa::OutputFingerprint) + Send + Sync + 'static>,\n+}\n+\n+impl<T, R> From<Query<T, R>> for SalsaQuery\n+where\n+    T: Hash + Send + Sync + 'static,\n+    R: Hash + Send + Sync + 'static,\n+{\n+    fn from(q: Query<T, R>) -> SalsaQuery\n+    {\n+        SalsaQuery {\n+            query_type: salsa::QueryTypeId(q.id),\n+            f: Box::new(move |ctx, data| {\n+                let ctx = QueryCtx { inner: ctx };\n+                let data: &T = data.downcast_ref().unwrap();\n+                let res = (q.f)(ctx, data);\n+                let h = hash(&res);\n+                (Arc::new(res), salsa::OutputFingerprint(h))\n+            })\n+        }\n+    }\n+}\n+\n+fn hash<T: ::std::hash::Hash>(x: &T) -> u64 {\n+    use std::hash::Hasher;\n+    let mut hasher = ::std::collections::hash_map::DefaultHasher::new();\n+    ::std::hash::Hash::hash(x, &mut hasher);\n+    hasher.finish()\n+}"}, {"sha": "2d4aac6e93e2222d74d14119a33e3df8ad564d0d", "filename": "crates/libanalysis/src/db/queries.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8c737255ff876fc61f8dc8a7d33252476a4b4c8d/crates%2Flibanalysis%2Fsrc%2Fdb%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c737255ff876fc61f8dc8a7d33252476a4b4c8d/crates%2Flibanalysis%2Fsrc%2Fdb%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fdb%2Fqueries.rs?ref=8c737255ff876fc61f8dc8a7d33252476a4b4c8d", "patch": "@@ -0,0 +1,43 @@\n+use std::sync::Arc;\n+use libsyntax2::{File};\n+use {\n+    FileId, FileResolverImp,\n+    db::{Query, GroundQuery, QueryCtx, hash},\n+};\n+\n+\n+impl<'a> QueryCtx<'a> {\n+    pub(crate) fn file_set(&self) -> Arc<(Vec<FileId>, FileResolverImp)> {\n+        self.get_g(FILE_SET, ())\n+    }\n+    pub(crate) fn file_text(&self, file_id: FileId) -> Arc<str> {\n+        Arc::clone(&*self.get_g(FILE_TEXT, file_id))\n+    }\n+    pub(crate) fn file_syntax(&self, file_id: FileId) -> File {\n+        (&*self.get(FILE_SYNTAX, file_id)).clone()\n+    }\n+}\n+\n+pub(super) const FILE_TEXT: GroundQuery<FileId, Arc<str>> = GroundQuery {\n+    id: 10,\n+    f: |state, id| state.file_map[&id].clone(),\n+    h: hash,\n+};\n+\n+pub(super) const FILE_SET: GroundQuery<(), (Vec<FileId>, FileResolverImp)> = GroundQuery {\n+    id: 11,\n+    f: |state, &()| {\n+        let files = state.file_map.keys().cloned().collect();\n+        let resolver = state.resolver.clone();\n+        (files, resolver)\n+    },\n+    h: |(files, _)| hash(files),\n+};\n+\n+pub(super) const FILE_SYNTAX: Query<FileId, File> = Query {\n+    id: 20,\n+    f: |ctx, file_id: &FileId| {\n+        let text = ctx.file_text(*file_id);\n+        File::parse(&*text)\n+    }\n+};"}, {"sha": "bca5d4c1d6789cd7a0186d2140b8ff78287b9da6", "filename": "crates/libanalysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c737255ff876fc61f8dc8a7d33252476a4b4c8d/crates%2Flibanalysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c737255ff876fc61f8dc8a7d33252476a4b4c8d/crates%2Flibanalysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Flib.rs?ref=8c737255ff876fc61f8dc8a7d33252476a4b4c8d", "patch": "@@ -10,6 +10,7 @@ extern crate relative_path;\n #[macro_use]\n extern crate crossbeam_channel;\n extern crate im;\n+extern crate salsa;\n \n mod symbol_index;\n mod module_map;"}, {"sha": "ff69cc0d2085b41df47b04bf7cbd5e4caf422e05", "filename": "crates/libanalysis/src/module_map_db.rs", "status": "modified", "additions": 61, "deletions": 69, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/8c737255ff876fc61f8dc8a7d33252476a4b4c8d/crates%2Flibanalysis%2Fsrc%2Fmodule_map_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c737255ff876fc61f8dc8a7d33252476a4b4c8d/crates%2Flibanalysis%2Fsrc%2Fmodule_map_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fmodule_map_db.rs?ref=8c737255ff876fc61f8dc8a7d33252476a4b4c8d", "patch": "@@ -2,66 +2,55 @@ use std::sync::Arc;\n use {\n     FileId,\n     db::{\n-        Query, Eval, QueryCtx, FileSyntax, Files,\n-        Cache, QueryCache,\n+        Query, QueryCtx\n     },\n     module_map::resolve_submodule,\n };\n \n-pub(crate) enum ModuleDescr {}\n-impl Query for ModuleDescr {\n-    const ID: u32 = 30;\n-    type Params = FileId;\n-    type Output = Arc<descr::ModuleDescr>;\n-}\n-\n-enum ResolveSubmodule {}\n-impl Query for ResolveSubmodule {\n-    const ID: u32 = 31;\n-    type Params = (FileId, descr::Submodule);\n-    type Output = Arc<Vec<FileId>>;\n-}\n-\n-enum ParentModule {}\n-impl Query for ParentModule {\n-    const ID: u32 = 40;\n-    type Params = FileId;\n-    type Output = Arc<Vec<FileId>>;\n+impl<'a> QueryCtx<'a> {\n+    fn module_descr(&self, file_id: FileId) -> Arc<descr::ModuleDescr> {\n+        self.get(MODULE_DESCR, file_id)\n+    }\n+    fn resolve_submodule(&self, file_id: FileId, submod: descr::Submodule) -> Arc<Vec<FileId>> {\n+        self.get(RESOLVE_SUBMODULE, (file_id, submod))\n+    }\n }\n \n-impl Eval for ModuleDescr {\n-    fn eval(ctx: &QueryCtx, file_id: &FileId) -> Arc<descr::ModuleDescr> {\n-        let file = ctx.get::<FileSyntax>(file_id);\n-        Arc::new(descr::ModuleDescr::new(file.ast()))\n+pub(crate) const MODULE_DESCR: Query<FileId, descr::ModuleDescr> = Query {\n+    id: 30,\n+    f: |ctx, &file_id| {\n+        let file = ctx.file_syntax(file_id);\n+        descr::ModuleDescr::new(file.ast())\n     }\n-}\n+};\n \n-impl Eval for ResolveSubmodule {\n-    fn eval(ctx: &QueryCtx, &(file_id, ref submodule): &(FileId, descr::Submodule)) -> Arc<Vec<FileId>> {\n-        let files = ctx.get::<Files>(&());\n-        let res = resolve_submodule(file_id, &submodule.name, &files.file_resolver()).0;\n-        Arc::new(res)\n+pub(crate) const RESOLVE_SUBMODULE: Query<(FileId, descr::Submodule), Vec<FileId>> = Query {\n+    id: 31,\n+    f: |ctx, params| {\n+        let files = ctx.file_set();\n+        resolve_submodule(params.0, &params.1.name, &files.1).0\n     }\n-}\n+};\n \n-impl Eval for ParentModule {\n-    fn eval(ctx: &QueryCtx, file_id: &FileId) -> Arc<Vec<FileId>> {\n-        let files = ctx.get::<Files>(&());\n-        let res = files.iter()\n-            .map(|parent_id| (parent_id, ctx.get::<ModuleDescr>(&parent_id)))\n+pub(crate) const PARENT_MODULE: Query<FileId, Vec<FileId>> = Query {\n+    id: 40,\n+    f: |ctx, file_id| {\n+        let files = ctx.file_set();\n+        let res = files.0.iter()\n+            .map(|&parent_id| (parent_id, ctx.module_descr(parent_id)))\n             .filter(|(parent_id, descr)| {\n                 descr.submodules.iter()\n                     .any(|subm| {\n-                        ctx.get::<ResolveSubmodule>(&(*parent_id, subm.clone()))\n+                        ctx.resolve_submodule(*parent_id, subm.clone())\n                             .iter()\n                             .any(|it| it == file_id)\n                     })\n             })\n             .map(|(id, _)| id)\n             .collect();\n-        Arc::new(res)\n+        res\n     }\n-}\n+};\n \n mod descr {\n     use libsyntax2::{\n@@ -102,7 +91,7 @@ mod tests {\n     use im;\n     use relative_path::{RelativePath, RelativePathBuf};\n     use {\n-        db::{Query, DbHost, TraceEventKind},\n+        db::{Query, Db, State},\n         imp::FileResolverImp,\n         FileId, FileResolver,\n     };\n@@ -126,52 +115,55 @@ mod tests {\n     struct Fixture {\n         next_file_id: u32,\n         fm: im::HashMap<FileId, RelativePathBuf>,\n-        db: DbHost,\n+        db: Db,\n     }\n \n     impl Fixture {\n         fn new() -> Fixture {\n             Fixture {\n                 next_file_id: 1,\n                 fm: im::HashMap::new(),\n-                db: DbHost::new(),\n+                db: Db::new(State::default()),\n             }\n         }\n         fn add_file(&mut self, path: &str, text: &str) -> FileId {\n             assert!(path.starts_with(\"/\"));\n             let file_id = FileId(self.next_file_id);\n             self.next_file_id += 1;\n             self.fm.insert(file_id, RelativePathBuf::from(&path[1..]));\n-            self.db.change_file(file_id, Some(text.to_string()));\n-            self.db.set_file_resolver(FileResolverImp::new(\n+            let mut new_state = self.db.state().clone();\n+            new_state.file_map.insert(file_id, text.to_string().into_boxed_str().into());\n+            new_state.resolver = FileResolverImp::new(\n                 Arc::new(FileMap(self.fm.clone()))\n-            ));\n-\n+            );\n+            self.db = self.db.with_state(new_state, &[file_id], true);\n             file_id\n         }\n         fn remove_file(&mut self, file_id: FileId) {\n             self.fm.remove(&file_id);\n-            self.db.change_file(file_id, None);\n-            self.db.set_file_resolver(FileResolverImp::new(\n+            let mut new_state = self.db.state().clone();\n+            new_state.file_map.remove(&file_id);\n+            new_state.resolver = FileResolverImp::new(\n                 Arc::new(FileMap(self.fm.clone()))\n-            ))\n+            );\n+            self.db = self.db.with_state(new_state, &[file_id], true);\n         }\n         fn change_file(&mut self, file_id: FileId, new_text: &str) {\n-            self.db.change_file(file_id, Some(new_text.to_string()));\n+            let mut new_state = self.db.state().clone();\n+            new_state.file_map.insert(file_id, new_text.to_string().into_boxed_str().into());\n+            self.db = self.db.with_state(new_state, &[file_id], false);\n         }\n         fn check_parent_modules(\n             &self,\n             file_id: FileId,\n             expected: &[FileId],\n-            queries: &[(u32, u64)]\n+            queries: &[(u16, u64)]\n         ) {\n-            let ctx = self.db.query_ctx();\n-            let actual = ctx.get::<ParentModule>(&file_id);\n+            let (actual, events) = self.db.get(PARENT_MODULE, file_id);\n             assert_eq!(actual.as_slice(), expected);\n             let mut counts = HashMap::new();\n-            ctx.trace.borrow().iter()\n-               .filter(|event| event.kind == TraceEventKind::Evaluating)\n-               .for_each(|event| *counts.entry(event.query_id).or_insert(0) += 1);\n+            events.into_iter()\n+               .for_each(|event| *counts.entry(event).or_insert(0) += 1);\n             for &(query_id, expected_count) in queries.iter() {\n                 let actual_count = *counts.get(&query_id).unwrap_or(&0);\n                 assert_eq!(\n@@ -189,25 +181,25 @@ mod tests {\n     fn test_parent_module() {\n         let mut f = Fixture::new();\n         let foo = f.add_file(\"/foo.rs\", \"\");\n-        // f.check_parent_modules(foo, &[], &[(ModuleDescr::ID, 1)]);\n+        f.check_parent_modules(foo, &[], &[(MODULE_DESCR.id, 1)]);\n \n         let lib = f.add_file(\"/lib.rs\", \"mod foo;\");\n-        f.check_parent_modules(foo, &[lib], &[(ModuleDescr::ID, 2)]);\n-        f.check_parent_modules(foo, &[lib], &[(ModuleDescr::ID, 0)]);\n+        f.check_parent_modules(foo, &[lib], &[(MODULE_DESCR.id, 1)]);\n+        f.check_parent_modules(foo, &[lib], &[(MODULE_DESCR.id, 0)]);\n \n         f.change_file(lib, \"\");\n-        f.check_parent_modules(foo, &[], &[(ModuleDescr::ID, 2)]);\n+        f.check_parent_modules(foo, &[], &[(MODULE_DESCR.id, 1)]);\n \n-        // f.change_file(lib, \"mod foo;\");\n-        // f.check_parent_modules(foo, &[lib], &[(ModuleDescr::ID, 2)]);\n+        f.change_file(lib, \"mod foo;\");\n+        f.check_parent_modules(foo, &[lib], &[(MODULE_DESCR.id, 1)]);\n \n-        // f.change_file(lib, \"mod bar;\");\n-        // f.check_parent_modules(foo, &[], &[(ModuleDescr::ID, 2)]);\n+        f.change_file(lib, \"mod bar;\");\n+        f.check_parent_modules(foo, &[], &[(MODULE_DESCR.id, 1)]);\n \n-        // f.change_file(lib, \"mod foo;\");\n-        // f.check_parent_modules(foo, &[lib], &[(ModuleDescr::ID, 2)]);\n+        f.change_file(lib, \"mod foo;\");\n+        f.check_parent_modules(foo, &[lib], &[(MODULE_DESCR.id, 1)]);\n \n-        // f.remove_file(lib);\n-        // f.check_parent_modules(foo, &[], &[(ModuleDescr::ID, 1)]);\n+        f.remove_file(lib);\n+        f.check_parent_modules(foo, &[], &[(MODULE_DESCR.id, 0)]);\n     }\n }"}, {"sha": "75815e8bd2d461cfdde8099f914b13efbc91db42", "filename": "crates/salsa/src/lib.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c737255ff876fc61f8dc8a7d33252476a4b4c8d/crates%2Fsalsa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c737255ff876fc61f8dc8a7d33252476a4b4c8d/crates%2Fsalsa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsalsa%2Fsrc%2Flib.rs?ref=8c737255ff876fc61f8dc8a7d33252476a4b4c8d", "patch": "@@ -8,8 +8,8 @@ use std::{\n };\n use parking_lot::Mutex;\n \n-type GroundQueryFn<T, D> = fn(&T, &D) -> (D, OutputFingerprint);\n-type QueryFn<T, D> = fn(&QueryCtx<T, D>, &D) -> (D, OutputFingerprint);\n+type GroundQueryFn<T, D> = Box<Fn(&T, &D) -> (D, OutputFingerprint) + Send + Sync + 'static>;\n+type QueryFn<T, D> = Box<Fn(&QueryCtx<T, D>, &D) -> (D, OutputFingerprint) + Send + Sync + 'static>;\n \n #[derive(Debug)]\n pub struct Db<T, D> {\n@@ -119,7 +119,7 @@ where\n         res\n     }\n \n-    pub fn get_inner(\n+    fn get_inner(\n         &self,\n         query_id: QueryId,\n         params: D,\n@@ -176,9 +176,9 @@ where\n         self.executed.borrow_mut().push(query_id.0);\n         self.stack.borrow_mut().push(Vec::new());\n \n-        let (res, output_fingerprint) = if let Some(f) = self.ground_query_fn_by_type(query_id.0) {\n+        let (res, output_fingerprint) = if let Some(f) = self.query_config.ground_fn.get(&query_id.0) {\n             f(&self.db.ground_data, &params)\n-        } else if let Some(f) = self.query_fn_by_type(query_id.0) {\n+        } else if let Some(f) = self.query_config.query_fn.get(&query_id.0) {\n             f(self, &params)\n         } else {\n             panic!(\"unknown query type: {:?}\", query_id.0);\n@@ -190,12 +190,6 @@ where\n         self.db.record(query_id, params, res.clone(), output_fingerprint, deps);\n         (res, output_fingerprint)\n     }\n-    fn ground_query_fn_by_type(&self, query_type: QueryTypeId) -> Option<GroundQueryFn<T, D>> {\n-        self.query_config.ground_fn.get(&query_type).map(|&it| it)\n-    }\n-    fn query_fn_by_type(&self, query_type: QueryTypeId) -> Option<QueryFn<T, D>> {\n-        self.query_config.query_fn.get(&query_type).map(|&it| it)\n-    }\n     fn record_dep(\n         &self,\n         query_id: QueryId,\n@@ -239,7 +233,9 @@ where\n             query_config: Arc::new(query_config),\n         }\n     }\n-\n+    pub fn ground_data(&self) -> &T {\n+        &self.db.ground_data\n+    }\n     pub fn with_ground_data(\n         &self,\n         ground_data: T,"}, {"sha": "aed9219bee1fb5da5c0af202aff86240f3f11547", "filename": "crates/salsa/tests/integration.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c737255ff876fc61f8dc8a7d33252476a4b4c8d/crates%2Fsalsa%2Ftests%2Fintegration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c737255ff876fc61f8dc8a7d33252476a4b4c8d/crates%2Fsalsa%2Ftests%2Fintegration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsalsa%2Ftests%2Fintegration.rs?ref=8c737255ff876fc61f8dc8a7d33252476a4b4c8d", "patch": "@@ -79,27 +79,27 @@ where\n \n fn mk_queries() -> salsa::QueryConfig<State, Data> {\n     salsa::QueryConfig::<State, Data>::new()\n-        .with_ground_query(GET_TEXT, |state, id| {\n+        .with_ground_query(GET_TEXT, Box::new(|state, id| {\n             mk_ground_query::<u32, String>(state, id, |state, id| state[id].clone())\n-        })\n-        .with_ground_query(GET_FILES, |state, id| {\n+        }))\n+        .with_ground_query(GET_FILES, Box::new(|state, id| {\n             mk_ground_query::<(), Vec<u32>>(state, id, |state, &()| state.keys().cloned().collect())\n-        })\n-        .with_query(FILE_NEWLINES, |query_ctx, id| {\n+        }))\n+        .with_query(FILE_NEWLINES, Box::new(|query_ctx, id| {\n             mk_query(query_ctx, id, |query_ctx, &id| {\n                 let text = query_ctx.get_text(id);\n                 text.lines().count()\n             })\n-        })\n-        .with_query(TOTAL_NEWLINES, |query_ctx, id| {\n+        }))\n+        .with_query(TOTAL_NEWLINES, Box::new(|query_ctx, id| {\n             mk_query(query_ctx, id, |query_ctx, &()| {\n                 let mut total = 0;\n                 for &id in query_ctx.get_files().iter() {\n                     total += query_ctx.get_n_lines(id)\n                 }\n                 total\n             })\n-        })\n+        }))\n }\n \n #[test]"}]}