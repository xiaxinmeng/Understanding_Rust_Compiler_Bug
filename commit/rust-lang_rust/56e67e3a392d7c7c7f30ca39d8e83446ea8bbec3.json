{"sha": "56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2ZTY3ZTNhMzkyZDdjN2M3ZjMwY2EzOWQ4ZTgzNDQ2ZWE4YmJlYzM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-10-15T15:27:50Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-10-15T15:38:17Z"}, "message": "More idiomatic classification API", "tree": {"sha": "4fe5fa460ddaf0bc19347d42bb91215614b5e840", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fe5fa460ddaf0bc19347d42bb91215614b5e840"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3", "html_url": "https://github.com/rust-lang/rust/commit/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9c1336873d65805ad34129939d800dbf59daf61", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9c1336873d65805ad34129939d800dbf59daf61", "html_url": "https://github.com/rust-lang/rust/commit/f9c1336873d65805ad34129939d800dbf59daf61"}], "stats": {"total": 392, "additions": 196, "deletions": 196}, "files": [{"sha": "e3d84d6986afcaced592137f95c8edd17477352f", "filename": "crates/assists/src/handlers/add_turbo_fish.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs?ref=56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3", "patch": "@@ -1,4 +1,4 @@\n-use ide_db::defs::{classify_name_ref, Definition, NameRefClass};\n+use ide_db::defs::{Definition, NameRefClass};\n use syntax::{ast, AstNode, SyntaxKind, T};\n use test_utils::mark;\n \n@@ -39,7 +39,7 @@ pub(crate) fn add_turbo_fish(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n         return None;\n     }\n     let name_ref = ast::NameRef::cast(ident.parent())?;\n-    let def = match classify_name_ref(&ctx.sema, &name_ref)? {\n+    let def = match NameRefClass::classify(&ctx.sema, &name_ref)? {\n         NameRefClass::Definition(def) => def,\n         NameRefClass::ExternCrate(_) | NameRefClass::FieldShorthand { .. } => return None,\n     };"}, {"sha": "316a58d883adf37b4216edbb3c36001493b581d4", "filename": "crates/assists/src/handlers/expand_glob_import.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3/crates%2Fassists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3/crates%2Fassists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs?ref=56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3", "patch": "@@ -1,7 +1,7 @@\n use either::Either;\n use hir::{AssocItem, MacroDef, Module, ModuleDef, Name, PathResolution, ScopeDef};\n use ide_db::{\n-    defs::{classify_name_ref, Definition, NameRefClass},\n+    defs::{Definition, NameRefClass},\n     search::SearchScope,\n };\n use syntax::{\n@@ -217,7 +217,7 @@ fn find_imported_defs(ctx: &AssistContext, star: SyntaxToken) -> Option<Vec<Def>\n             .flatten()\n             .filter_map(|n| Some(n.descendants().filter_map(ast::NameRef::cast)))\n             .flatten()\n-            .filter_map(|r| match classify_name_ref(&ctx.sema, &r)? {\n+            .filter_map(|r| match NameRefClass::classify(&ctx.sema, &r)? {\n                 NameRefClass::Definition(Definition::ModuleDef(def)) => Some(Def::ModuleDef(def)),\n                 NameRefClass::Definition(Definition::Macro(def)) => Some(Def::MacroDef(def)),\n                 _ => None,"}, {"sha": "592a8e3addc2fd4ae4a006095a190d56436b1633", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3", "patch": "@@ -14,7 +14,7 @@ use hir::{\n     ModuleDef,\n };\n use ide_db::{\n-    defs::{classify_name, classify_name_ref, Definition},\n+    defs::{Definition, NameClass, NameRefClass},\n     RootDatabase,\n };\n use syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset, T};\n@@ -232,8 +232,8 @@ pub(crate) fn external_docs(\n     let node = token.parent();\n     let definition = match_ast! {\n         match node {\n-            ast::NameRef(name_ref) => classify_name_ref(&sema, &name_ref).map(|d| d.definition(sema.db)),\n-            ast::Name(name) => classify_name(&sema, &name).map(|d| d.reference_or_definition(sema.db)),\n+            ast::NameRef(name_ref) => NameRefClass::classify(&sema, &name_ref).map(|d| d.definition(sema.db)),\n+            ast::Name(name) => NameClass::classify(&sema, &name).map(|d| d.reference_or_definition(sema.db)),\n             _ => None,\n         }\n     };"}, {"sha": "db6ad689eddd82368a3a92ce5a45a85bfa03fd24", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3", "patch": "@@ -1,6 +1,6 @@\n use hir::Semantics;\n use ide_db::{\n-    defs::{classify_name, classify_name_ref},\n+    defs::{NameClass, NameRefClass},\n     symbol_index, RootDatabase,\n };\n use syntax::{\n@@ -40,7 +40,7 @@ pub(crate) fn goto_definition(\n                 reference_definition(&sema, &name_ref).to_vec()\n             },\n             ast::Name(name) => {\n-                let def = classify_name(&sema, &name)?.reference_or_definition(sema.db);\n+                let def = NameClass::classify(&sema, &name)?.reference_or_definition(sema.db);\n                 let nav = def.try_to_nav(sema.db)?;\n                 vec![nav]\n             },\n@@ -81,7 +81,7 @@ pub(crate) fn reference_definition(\n     sema: &Semantics<RootDatabase>,\n     name_ref: &ast::NameRef,\n ) -> ReferenceResult {\n-    let name_kind = classify_name_ref(sema, name_ref);\n+    let name_kind = NameRefClass::classify(sema, name_ref);\n     if let Some(def) = name_kind {\n         let def = def.definition(sema.db);\n         return match def.try_to_nav(sema.db) {"}, {"sha": "e915a753e1efa1cccba5457f93b720cdf00dc32c", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3", "patch": "@@ -4,7 +4,7 @@ use hir::{\n     Module, ModuleDef, ModuleSource, Semantics,\n };\n use ide_db::{\n-    defs::{classify_name, classify_name_ref, Definition},\n+    defs::{Definition, NameClass, NameRefClass},\n     RootDatabase,\n };\n use itertools::Itertools;\n@@ -107,8 +107,8 @@ pub(crate) fn hover(\n     let node = token.parent();\n     let definition = match_ast! {\n         match node {\n-            ast::NameRef(name_ref) => classify_name_ref(&sema, &name_ref).map(|d| d.definition(sema.db)),\n-            ast::Name(name) => classify_name(&sema, &name).and_then(|d| d.definition(sema.db)),\n+            ast::Name(name) => NameClass::classify(&sema, &name).and_then(|d| d.definition(sema.db)),\n+            ast::NameRef(name_ref) => NameRefClass::classify(&sema, &name_ref).map(|d| d.definition(sema.db)),\n             _ => None,\n         }\n     };"}, {"sha": "fc537b9c0e454def50ad30b211e1c6a36ea8ad61", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3", "patch": "@@ -13,7 +13,7 @@ pub(crate) mod rename;\n \n use hir::Semantics;\n use ide_db::{\n-    defs::{classify_name, classify_name_ref, Definition},\n+    defs::{Definition, NameClass, NameRefClass},\n     search::SearchScope,\n     RootDatabase,\n };\n@@ -132,13 +132,13 @@ fn find_name(\n     opt_name: Option<ast::Name>,\n ) -> Option<RangeInfo<Definition>> {\n     if let Some(name) = opt_name {\n-        let def = classify_name(sema, &name)?.reference_or_definition(sema.db);\n+        let def = NameClass::classify(sema, &name)?.reference_or_definition(sema.db);\n         let range = name.syntax().text_range();\n         return Some(RangeInfo::new(range, def));\n     }\n     let name_ref =\n         sema.find_node_at_offset_with_descend::<ast::NameRef>(&syntax, position.offset)?;\n-    let def = classify_name_ref(sema, &name_ref)?.definition(sema.db);\n+    let def = NameRefClass::classify(sema, &name_ref)?.definition(sema.db);\n     let range = name_ref.syntax().text_range();\n     Some(RangeInfo::new(range, def))\n }"}, {"sha": "35aafc49d740231c349d866e4fd466a964396eb5", "filename": "crates/ide/src/references/rename.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3", "patch": "@@ -3,7 +3,7 @@\n use base_db::SourceDatabaseExt;\n use hir::{Module, ModuleDef, ModuleSource, Semantics};\n use ide_db::{\n-    defs::{classify_name, classify_name_ref, Definition, NameClass, NameRefClass},\n+    defs::{Definition, NameClass, NameRefClass},\n     RootDatabase,\n };\n \n@@ -88,13 +88,13 @@ fn find_module_at_offset(\n     let module = match_ast! {\n         match (ident.parent()) {\n             ast::NameRef(name_ref) => {\n-                match classify_name_ref(sema, &name_ref)? {\n+                match NameRefClass::classify(sema, &name_ref)? {\n                     NameRefClass::Definition(Definition::ModuleDef(ModuleDef::Module(module))) => module,\n                     _ => return None,\n                 }\n             },\n             ast::Name(name) => {\n-                match classify_name(&sema, &name)? {\n+                match NameClass::classify(&sema, &name)? {\n                     NameClass::Definition(Definition::ModuleDef(ModuleDef::Module(module))) => module,\n                     _ => return None,\n                 }"}, {"sha": "b35c031627fadc590c3961f6891be4bd56993587", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3", "patch": "@@ -8,7 +8,7 @@ mod tests;\n \n use hir::{Local, Name, Semantics, VariantDef};\n use ide_db::{\n-    defs::{classify_name, classify_name_ref, Definition, NameClass, NameRefClass},\n+    defs::{Definition, NameClass, NameRefClass},\n     RootDatabase,\n };\n use rustc_hash::FxHashMap;\n@@ -443,7 +443,7 @@ fn highlight_element(\n         // Highlight definitions depending on the \"type\" of the definition.\n         NAME => {\n             let name = element.into_node().and_then(ast::Name::cast).unwrap();\n-            let name_kind = classify_name(sema, &name);\n+            let name_kind = NameClass::classify(sema, &name);\n \n             if let Some(NameClass::Definition(Definition::Local(local))) = &name_kind {\n                 if let Some(name) = local.name(db) {\n@@ -480,7 +480,7 @@ fn highlight_element(\n         NAME_REF => {\n             let name_ref = element.into_node().and_then(ast::NameRef::cast).unwrap();\n             highlight_func_by_name_ref(sema, &name_ref).unwrap_or_else(|| {\n-                match classify_name_ref(sema, &name_ref) {\n+                match NameRefClass::classify(sema, &name_ref) {\n                     Some(name_kind) => match name_kind {\n                         NameRefClass::ExternCrate(_) => HighlightTag::Module.into(),\n                         NameRefClass::Definition(def) => {"}, {"sha": "3cef0baf7a1ff0e22c7f6537fbcc14c0df557833", "filename": "crates/ide_db/src/defs.rs", "status": "modified", "additions": 169, "deletions": 169, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3/crates%2Fide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3/crates%2Fide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fdefs.rs?ref=56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3", "patch": "@@ -110,121 +110,121 @@ impl NameClass {\n             NameClass::PatFieldShorthand { local_def: _, field_ref } => field_ref,\n         }\n     }\n-}\n \n-pub fn classify_name(sema: &Semantics<RootDatabase>, name: &ast::Name) -> Option<NameClass> {\n-    let _p = profile::span(\"classify_name\");\n+    pub fn classify(sema: &Semantics<RootDatabase>, name: &ast::Name) -> Option<NameClass> {\n+        let _p = profile::span(\"classify_name\");\n \n-    let parent = name.syntax().parent()?;\n+        let parent = name.syntax().parent()?;\n \n-    if let Some(bind_pat) = ast::IdentPat::cast(parent.clone()) {\n-        if let Some(def) = sema.resolve_bind_pat_to_const(&bind_pat) {\n-            return Some(NameClass::ConstReference(Definition::ModuleDef(def)));\n+        if let Some(bind_pat) = ast::IdentPat::cast(parent.clone()) {\n+            if let Some(def) = sema.resolve_bind_pat_to_const(&bind_pat) {\n+                return Some(NameClass::ConstReference(Definition::ModuleDef(def)));\n+            }\n         }\n-    }\n \n-    match_ast! {\n-        match parent {\n-            ast::Rename(it) => {\n-                if let Some(use_tree) = it.syntax().parent().and_then(ast::UseTree::cast) {\n-                    let path = use_tree.path()?;\n-                    let path_segment = path.segment()?;\n-                    let name_ref_class = path_segment\n-                        .name_ref()\n-                        // The rename might be from a `self` token, so fallback to the name higher\n-                        // in the use tree.\n-                        .or_else(||{\n-                            if path_segment.self_token().is_none() {\n-                                return None;\n-                            }\n+        match_ast! {\n+            match parent {\n+                ast::Rename(it) => {\n+                    if let Some(use_tree) = it.syntax().parent().and_then(ast::UseTree::cast) {\n+                        let path = use_tree.path()?;\n+                        let path_segment = path.segment()?;\n+                        let name_ref_class = path_segment\n+                            .name_ref()\n+                            // The rename might be from a `self` token, so fallback to the name higher\n+                            // in the use tree.\n+                            .or_else(||{\n+                                if path_segment.self_token().is_none() {\n+                                    return None;\n+                                }\n \n-                            let use_tree = use_tree\n-                                .syntax()\n-                                .parent()\n-                                .as_ref()\n-                                // Skip over UseTreeList\n-                                .and_then(SyntaxNode::parent)\n-                                .and_then(ast::UseTree::cast)?;\n-                            let path = use_tree.path()?;\n-                            let path_segment = path.segment()?;\n-                            path_segment.name_ref()\n-                        })\n-                        .and_then(|name_ref| classify_name_ref(sema, &name_ref))?;\n+                                let use_tree = use_tree\n+                                    .syntax()\n+                                    .parent()\n+                                    .as_ref()\n+                                    // Skip over UseTreeList\n+                                    .and_then(SyntaxNode::parent)\n+                                    .and_then(ast::UseTree::cast)?;\n+                                let path = use_tree.path()?;\n+                                let path_segment = path.segment()?;\n+                                path_segment.name_ref()\n+                            })\n+                            .and_then(|name_ref| NameRefClass::classify(sema, &name_ref))?;\n \n-                    Some(NameClass::Definition(name_ref_class.definition(sema.db)))\n-                } else {\n-                    let extern_crate = it.syntax().parent().and_then(ast::ExternCrate::cast)?;\n-                    let resolved = sema.resolve_extern_crate(&extern_crate)?;\n-                    Some(NameClass::ExternCrate(resolved))\n-                }\n-            },\n-            ast::IdentPat(it) => {\n-                let local = sema.to_def(&it)?;\n+                        Some(NameClass::Definition(name_ref_class.definition(sema.db)))\n+                    } else {\n+                        let extern_crate = it.syntax().parent().and_then(ast::ExternCrate::cast)?;\n+                        let resolved = sema.resolve_extern_crate(&extern_crate)?;\n+                        Some(NameClass::ExternCrate(resolved))\n+                    }\n+                },\n+                ast::IdentPat(it) => {\n+                    let local = sema.to_def(&it)?;\n \n-                if let Some(record_pat_field) = it.syntax().parent().and_then(ast::RecordPatField::cast) {\n-                    if record_pat_field.name_ref().is_none() {\n-                        if let Some(field) = sema.resolve_record_pat_field(&record_pat_field) {\n-                            let field = Definition::Field(field);\n-                            return Some(NameClass::PatFieldShorthand { local_def: local, field_ref: field });\n+                    if let Some(record_pat_field) = it.syntax().parent().and_then(ast::RecordPatField::cast) {\n+                        if record_pat_field.name_ref().is_none() {\n+                            if let Some(field) = sema.resolve_record_pat_field(&record_pat_field) {\n+                                let field = Definition::Field(field);\n+                                return Some(NameClass::PatFieldShorthand { local_def: local, field_ref: field });\n+                            }\n                         }\n                     }\n-                }\n \n-                Some(NameClass::Definition(Definition::Local(local)))\n-            },\n-            ast::RecordField(it) => {\n-                let field: hir::Field = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::Field(field)))\n-            },\n-            ast::Module(it) => {\n-                let def = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n-            },\n-            ast::Struct(it) => {\n-                let def: hir::Struct = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n-            },\n-            ast::Union(it) => {\n-                let def: hir::Union = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n-            },\n-            ast::Enum(it) => {\n-                let def: hir::Enum = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n-            },\n-            ast::Trait(it) => {\n-                let def: hir::Trait = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n-            },\n-            ast::Static(it) => {\n-                let def: hir::Static = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n-            },\n-            ast::Variant(it) => {\n-                let def: hir::EnumVariant = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n-            },\n-            ast::Fn(it) => {\n-                let def: hir::Function = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n-            },\n-            ast::Const(it) => {\n-                let def: hir::Const = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n-            },\n-            ast::TypeAlias(it) => {\n-                let def: hir::TypeAlias = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n-            },\n-            ast::MacroCall(it) => {\n-                let def = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::Macro(def)))\n-            },\n-            ast::TypeParam(it) => {\n-                let def = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::TypeParam(def)))\n-            },\n-            _ => None,\n+                    Some(NameClass::Definition(Definition::Local(local)))\n+                },\n+                ast::RecordField(it) => {\n+                    let field: hir::Field = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::Field(field)))\n+                },\n+                ast::Module(it) => {\n+                    let def = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                },\n+                ast::Struct(it) => {\n+                    let def: hir::Struct = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                },\n+                ast::Union(it) => {\n+                    let def: hir::Union = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                },\n+                ast::Enum(it) => {\n+                    let def: hir::Enum = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                },\n+                ast::Trait(it) => {\n+                    let def: hir::Trait = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                },\n+                ast::Static(it) => {\n+                    let def: hir::Static = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                },\n+                ast::Variant(it) => {\n+                    let def: hir::EnumVariant = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                },\n+                ast::Fn(it) => {\n+                    let def: hir::Function = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                },\n+                ast::Const(it) => {\n+                    let def: hir::Const = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                },\n+                ast::TypeAlias(it) => {\n+                    let def: hir::TypeAlias = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                },\n+                ast::MacroCall(it) => {\n+                    let def = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::Macro(def)))\n+                },\n+                ast::TypeParam(it) => {\n+                    let def = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::TypeParam(def)))\n+                },\n+                _ => None,\n+            }\n         }\n     }\n }\n@@ -244,91 +244,91 @@ impl NameRefClass {\n             NameRefClass::FieldShorthand { local, field: _ } => Definition::Local(local),\n         }\n     }\n-}\n \n-// Note: we don't have unit-tests for this rather important function.\n-// It is primarily exercised via goto definition tests in `ide`.\n-pub fn classify_name_ref(\n-    sema: &Semantics<RootDatabase>,\n-    name_ref: &ast::NameRef,\n-) -> Option<NameRefClass> {\n-    let _p = profile::span(\"classify_name_ref\");\n+    // Note: we don't have unit-tests for this rather important function.\n+    // It is primarily exercised via goto definition tests in `ide`.\n+    pub fn classify(\n+        sema: &Semantics<RootDatabase>,\n+        name_ref: &ast::NameRef,\n+    ) -> Option<NameRefClass> {\n+        let _p = profile::span(\"classify_name_ref\");\n \n-    let parent = name_ref.syntax().parent()?;\n+        let parent = name_ref.syntax().parent()?;\n \n-    if let Some(method_call) = ast::MethodCallExpr::cast(parent.clone()) {\n-        if let Some(func) = sema.resolve_method_call(&method_call) {\n-            return Some(NameRefClass::Definition(Definition::ModuleDef(func.into())));\n+        if let Some(method_call) = ast::MethodCallExpr::cast(parent.clone()) {\n+            if let Some(func) = sema.resolve_method_call(&method_call) {\n+                return Some(NameRefClass::Definition(Definition::ModuleDef(func.into())));\n+            }\n         }\n-    }\n \n-    if let Some(field_expr) = ast::FieldExpr::cast(parent.clone()) {\n-        if let Some(field) = sema.resolve_field(&field_expr) {\n-            return Some(NameRefClass::Definition(Definition::Field(field)));\n+        if let Some(field_expr) = ast::FieldExpr::cast(parent.clone()) {\n+            if let Some(field) = sema.resolve_field(&field_expr) {\n+                return Some(NameRefClass::Definition(Definition::Field(field)));\n+            }\n         }\n-    }\n \n-    if let Some(record_field) = ast::RecordExprField::for_field_name(name_ref) {\n-        if let Some((field, local)) = sema.resolve_record_field(&record_field) {\n-            let field = Definition::Field(field);\n-            let res = match local {\n-                None => NameRefClass::Definition(field),\n-                Some(local) => NameRefClass::FieldShorthand { field, local },\n-            };\n-            return Some(res);\n+        if let Some(record_field) = ast::RecordExprField::for_field_name(name_ref) {\n+            if let Some((field, local)) = sema.resolve_record_field(&record_field) {\n+                let field = Definition::Field(field);\n+                let res = match local {\n+                    None => NameRefClass::Definition(field),\n+                    Some(local) => NameRefClass::FieldShorthand { field, local },\n+                };\n+                return Some(res);\n+            }\n         }\n-    }\n \n-    if let Some(record_pat_field) = ast::RecordPatField::cast(parent.clone()) {\n-        if let Some(field) = sema.resolve_record_pat_field(&record_pat_field) {\n-            let field = Definition::Field(field);\n-            return Some(NameRefClass::Definition(field));\n+        if let Some(record_pat_field) = ast::RecordPatField::cast(parent.clone()) {\n+            if let Some(field) = sema.resolve_record_pat_field(&record_pat_field) {\n+                let field = Definition::Field(field);\n+                return Some(NameRefClass::Definition(field));\n+            }\n         }\n-    }\n \n-    if ast::AssocTypeArg::cast(parent.clone()).is_some() {\n-        // `Trait<Assoc = Ty>`\n-        //        ^^^^^\n-        let path = name_ref.syntax().ancestors().find_map(ast::Path::cast)?;\n-        let resolved = sema.resolve_path(&path)?;\n-        if let PathResolution::Def(ModuleDef::Trait(tr)) = resolved {\n-            if let Some(ty) = tr\n-                .items(sema.db)\n-                .iter()\n-                .filter_map(|assoc| match assoc {\n-                    hir::AssocItem::TypeAlias(it) => Some(*it),\n-                    _ => None,\n-                })\n-                .find(|alias| alias.name(sema.db).to_string() == **name_ref.text())\n-            {\n-                return Some(NameRefClass::Definition(Definition::ModuleDef(\n-                    ModuleDef::TypeAlias(ty),\n-                )));\n+        if ast::AssocTypeArg::cast(parent.clone()).is_some() {\n+            // `Trait<Assoc = Ty>`\n+            //        ^^^^^\n+            let path = name_ref.syntax().ancestors().find_map(ast::Path::cast)?;\n+            let resolved = sema.resolve_path(&path)?;\n+            if let PathResolution::Def(ModuleDef::Trait(tr)) = resolved {\n+                if let Some(ty) = tr\n+                    .items(sema.db)\n+                    .iter()\n+                    .filter_map(|assoc| match assoc {\n+                        hir::AssocItem::TypeAlias(it) => Some(*it),\n+                        _ => None,\n+                    })\n+                    .find(|alias| alias.name(sema.db).to_string() == **name_ref.text())\n+                {\n+                    return Some(NameRefClass::Definition(Definition::ModuleDef(\n+                        ModuleDef::TypeAlias(ty),\n+                    )));\n+                }\n             }\n         }\n-    }\n \n-    if let Some(macro_call) = parent.ancestors().find_map(ast::MacroCall::cast) {\n-        if let Some(path) = macro_call.path() {\n-            if path.qualifier().is_none() {\n-                // Only use this to resolve single-segment macro calls like `foo!()`. Multi-segment\n-                // paths are handled below (allowing `log<|>::info!` to resolve to the log crate).\n-                if let Some(macro_def) = sema.resolve_macro_call(&macro_call) {\n-                    return Some(NameRefClass::Definition(Definition::Macro(macro_def)));\n+        if let Some(macro_call) = parent.ancestors().find_map(ast::MacroCall::cast) {\n+            if let Some(path) = macro_call.path() {\n+                if path.qualifier().is_none() {\n+                    // Only use this to resolve single-segment macro calls like `foo!()`. Multi-segment\n+                    // paths are handled below (allowing `log<|>::info!` to resolve to the log crate).\n+                    if let Some(macro_def) = sema.resolve_macro_call(&macro_call) {\n+                        return Some(NameRefClass::Definition(Definition::Macro(macro_def)));\n+                    }\n                 }\n             }\n         }\n-    }\n \n-    if let Some(path) = name_ref.syntax().ancestors().find_map(ast::Path::cast) {\n-        if let Some(resolved) = sema.resolve_path(&path) {\n-            return Some(NameRefClass::Definition(resolved.into()));\n+        if let Some(path) = name_ref.syntax().ancestors().find_map(ast::Path::cast) {\n+            if let Some(resolved) = sema.resolve_path(&path) {\n+                return Some(NameRefClass::Definition(resolved.into()));\n+            }\n         }\n-    }\n \n-    let extern_crate = ast::ExternCrate::cast(parent)?;\n-    let resolved = sema.resolve_extern_crate(&extern_crate)?;\n-    Some(NameRefClass::ExternCrate(resolved))\n+        let extern_crate = ast::ExternCrate::cast(parent)?;\n+        let resolved = sema.resolve_extern_crate(&extern_crate)?;\n+        Some(NameRefClass::ExternCrate(resolved))\n+    }\n }\n \n impl From<PathResolution> for Definition {"}, {"sha": "8c925fbdc860166178f0aba370c75a175de99797", "filename": "crates/ide_db/src/imports_locator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fimports_locator.rs?ref=56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3", "patch": "@@ -5,7 +5,7 @@ use hir::{Crate, MacroDef, ModuleDef, Semantics};\n use syntax::{ast, AstNode, SyntaxKind::NAME};\n \n use crate::{\n-    defs::{classify_name, Definition},\n+    defs::{Definition, NameClass},\n     symbol_index::{self, FileSymbol, Query},\n     RootDatabase,\n };\n@@ -60,5 +60,5 @@ fn get_name_definition<'a>(\n         candidate_node\n     };\n     let name = ast::Name::cast(candidate_name_node)?;\n-    classify_name(sema, &name)?.definition(sema.db)\n+    NameClass::classify(sema, &name)?.definition(sema.db)\n }"}, {"sha": "3af52ec5e4cb4f4faffdb128d23b59378d9a6176", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=56e67e3a392d7c7c7f30ca39d8e83446ea8bbec3", "patch": "@@ -14,7 +14,7 @@ use syntax::{ast, match_ast, AstNode, TextRange, TextSize};\n \n use crate::defs::NameClass;\n use crate::{\n-    defs::{classify_name, classify_name_ref, Definition, NameRefClass},\n+    defs::{Definition, NameRefClass},\n     RootDatabase,\n };\n \n@@ -276,7 +276,7 @@ impl<'a> FindUsages<'a> {\n         name_ref: &ast::NameRef,\n         sink: &mut dyn FnMut(Reference) -> bool,\n     ) -> bool {\n-        match classify_name_ref(self.sema, &name_ref) {\n+        match NameRefClass::classify(self.sema, &name_ref) {\n             Some(NameRefClass::Definition(def)) if &def == self.def => {\n                 let kind = if is_record_lit_name_ref(&name_ref) || is_call_expr_name_ref(&name_ref)\n                 {\n@@ -313,7 +313,7 @@ impl<'a> FindUsages<'a> {\n     }\n \n     fn found_name(&self, name: &ast::Name, sink: &mut dyn FnMut(Reference) -> bool) -> bool {\n-        match classify_name(self.sema, name) {\n+        match NameClass::classify(self.sema, name) {\n             Some(NameClass::PatFieldShorthand { local_def: _, field_ref }) => {\n                 let reference = match self.def {\n                     Definition::Field(_) if &field_ref == self.def => Reference {"}]}