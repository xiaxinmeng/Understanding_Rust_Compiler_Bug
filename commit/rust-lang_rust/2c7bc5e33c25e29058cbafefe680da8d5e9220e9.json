{"sha": "2c7bc5e33c25e29058cbafefe680da8d5e9220e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjN2JjNWUzM2MyNWUyOTA1OGNiYWZlZmU2ODBkYThkNWU5MjIwZTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-15T12:34:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-15T12:34:31Z"}, "message": "Auto merge of #87867 - bjorn3:unique_type_id_interner, r=wesleywiser\n\nUse a separate interner type for UniqueTypeId\n\nUsing symbol::Interner makes it very easy to mixup UniqueTypeId symbols\nwith the global interner. In fact the Debug implementation of\nUniqueTypeId did exactly this.\n\nUsing a separate interner type also avoids prefilling the interner with\nunused symbols and allow for optimizing the symbol interner for parallel\naccess without negatively affecting the single threaded module codegen.", "tree": {"sha": "aac5c14d47fc781a748b72a525b80f26d557c978", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aac5c14d47fc781a748b72a525b80f26d557c978"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c7bc5e33c25e29058cbafefe680da8d5e9220e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c7bc5e33c25e29058cbafefe680da8d5e9220e9", "html_url": "https://github.com/rust-lang/rust/commit/2c7bc5e33c25e29058cbafefe680da8d5e9220e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c7bc5e33c25e29058cbafefe680da8d5e9220e9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e846f9c44f1e17cac66d7b75e2ca099c87a2dfcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/e846f9c44f1e17cac66d7b75e2ca099c87a2dfcb", "html_url": "https://github.com/rust-lang/rust/commit/e846f9c44f1e17cac66d7b75e2ca099c87a2dfcb"}, {"sha": "8c7840e8cb700870854efa02cca817c7dd610698", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c7840e8cb700870854efa02cca817c7dd610698", "html_url": "https://github.com/rust-lang/rust/commit/8c7840e8cb700870854efa02cca817c7dd610698"}], "stats": {"total": 72, "additions": 61, "deletions": 11}, "files": [{"sha": "f119f2050e9aac6b4cae64dc5d808f8026e969c7", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2c7bc5e33c25e29058cbafefe680da8d5e9220e9/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2c7bc5e33c25e29058cbafefe680da8d5e9220e9/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2c7bc5e33c25e29058cbafefe680da8d5e9220e9", "patch": "@@ -3654,6 +3654,7 @@ dependencies = [\n  \"libc\",\n  \"measureme\",\n  \"rustc-demangle\",\n+ \"rustc_arena\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_codegen_ssa\","}, {"sha": "3c99febbd57cc952faafcf62a69101e9dbb8d231", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2c7bc5e33c25e29058cbafefe680da8d5e9220e9/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2c7bc5e33c25e29058cbafefe680da8d5e9220e9/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=2c7bc5e33c25e29058cbafefe680da8d5e9220e9", "patch": "@@ -16,6 +16,7 @@ snap = \"1\"\n tracing = \"0.1\"\n rustc_middle = { path = \"../rustc_middle\" }\n rustc-demangle = \"0.1.21\"\n+rustc_arena = { path = \"../rustc_arena\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_codegen_ssa = { path = \"../rustc_codegen_ssa\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }"}, {"sha": "9272435a330a5f00dca8d749988a64faaaf90496", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 54, "deletions": 9, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2c7bc5e33c25e29058cbafefe680da8d5e9220e9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c7bc5e33c25e29058cbafefe680da8d5e9220e9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=2c7bc5e33c25e29058cbafefe680da8d5e9220e9", "patch": "@@ -34,7 +34,7 @@ use rustc_middle::ty::Instance;\n use rustc_middle::ty::{self, AdtKind, GeneratorSubsts, ParamEnv, Ty, TyCtxt};\n use rustc_middle::{bug, span_bug};\n use rustc_session::config::{self, DebugInfo};\n-use rustc_span::symbol::{Interner, Symbol};\n+use rustc_span::symbol::Symbol;\n use rustc_span::FileNameDisplayPreference;\n use rustc_span::{self, SourceFile, SourceFileHash, Span};\n use rustc_target::abi::{Abi, Align, HasDataLayout, Integer, TagEncoding};\n@@ -89,8 +89,54 @@ pub const UNKNOWN_COLUMN_NUMBER: c_uint = 0;\n \n pub const NO_SCOPE_METADATA: Option<&DIScope> = None;\n \n-#[derive(Copy, Debug, Hash, Eq, PartialEq, Clone)]\n-pub struct UniqueTypeId(Symbol);\n+mod unique_type_id {\n+    use super::*;\n+    use rustc_arena::DroplessArena;\n+\n+    #[derive(Copy, Hash, Eq, PartialEq, Clone)]\n+    pub(super) struct UniqueTypeId(u32);\n+\n+    // The `&'static str`s in this type actually point into the arena.\n+    //\n+    // The `FxHashMap`+`Vec` pair could be replaced by `FxIndexSet`, but #75278\n+    // found that to regress performance up to 2% in some cases. This might be\n+    // revisited after further improvements to `indexmap`.\n+    #[derive(Default)]\n+    pub(super) struct TypeIdInterner {\n+        arena: DroplessArena,\n+        names: FxHashMap<&'static str, UniqueTypeId>,\n+        strings: Vec<&'static str>,\n+    }\n+\n+    impl TypeIdInterner {\n+        #[inline]\n+        pub(super) fn intern(&mut self, string: &str) -> UniqueTypeId {\n+            if let Some(&name) = self.names.get(string) {\n+                return name;\n+            }\n+\n+            let name = UniqueTypeId(self.strings.len() as u32);\n+\n+            // `from_utf8_unchecked` is safe since we just allocated a `&str` which is known to be\n+            // UTF-8.\n+            let string: &str =\n+                unsafe { std::str::from_utf8_unchecked(self.arena.alloc_slice(string.as_bytes())) };\n+            // It is safe to extend the arena allocation to `'static` because we only access\n+            // these while the arena is still alive.\n+            let string: &'static str = unsafe { &*(string as *const str) };\n+            self.strings.push(string);\n+            self.names.insert(string, name);\n+            name\n+        }\n+\n+        // Get the symbol as a string. `Symbol::as_str()` should be used in\n+        // preference to this function.\n+        pub(super) fn get(&self, symbol: UniqueTypeId) -> &str {\n+            self.strings[symbol.0 as usize]\n+        }\n+    }\n+}\n+use unique_type_id::*;\n \n /// The `TypeMap` is where the `CrateDebugContext` holds the type metadata nodes\n /// created so far. The metadata nodes are indexed by `UniqueTypeId`, and, for\n@@ -99,7 +145,7 @@ pub struct UniqueTypeId(Symbol);\n #[derive(Default)]\n pub struct TypeMap<'ll, 'tcx> {\n     /// The `UniqueTypeId`s created so far.\n-    unique_id_interner: Interner,\n+    unique_id_interner: TypeIdInterner,\n     /// A map from `UniqueTypeId` to debuginfo metadata for that type. This is a 1:1 mapping.\n     unique_id_to_metadata: FxHashMap<UniqueTypeId, &'ll DIType>,\n     /// A map from types to debuginfo metadata. This is an N:1 mapping.\n@@ -166,8 +212,7 @@ impl TypeMap<'ll, 'tcx> {\n     /// Gets the string representation of a `UniqueTypeId`. This method will fail if\n     /// the ID is unknown.\n     fn get_unique_type_id_as_string(&self, unique_type_id: UniqueTypeId) -> &str {\n-        let UniqueTypeId(interner_key) = unique_type_id;\n-        self.unique_id_interner.get(interner_key)\n+        self.unique_id_interner.get(unique_type_id)\n     }\n \n     /// Gets the `UniqueTypeId` for the given type. If the `UniqueTypeId` for the given\n@@ -197,9 +242,9 @@ impl TypeMap<'ll, 'tcx> {\n         let unique_type_id = hasher.finish::<Fingerprint>().to_hex();\n \n         let key = self.unique_id_interner.intern(&unique_type_id);\n-        self.type_to_unique_id.insert(type_, UniqueTypeId(key));\n+        self.type_to_unique_id.insert(type_, key);\n \n-        UniqueTypeId(key)\n+        key\n     }\n \n     /// Gets the `UniqueTypeId` for an enum variant. Enum variants are not really\n@@ -215,7 +260,7 @@ impl TypeMap<'ll, 'tcx> {\n         let enum_variant_type_id =\n             format!(\"{}::{}\", self.get_unique_type_id_as_string(enum_type_id), variant_name);\n         let interner_key = self.unique_id_interner.intern(&enum_variant_type_id);\n-        UniqueTypeId(interner_key)\n+        interner_key\n     }\n \n     /// Gets the unique type ID string for an enum variant part."}, {"sha": "1b245f2a7506080f1d5de9aa83cde69cd67ddb33", "filename": "compiler/rustc_macros/src/symbols.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c7bc5e33c25e29058cbafefe680da8d5e9220e9/compiler%2Frustc_macros%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c7bc5e33c25e29058cbafefe680da8d5e9220e9/compiler%2Frustc_macros%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsymbols.rs?ref=2c7bc5e33c25e29058cbafefe680da8d5e9220e9", "patch": "@@ -215,7 +215,7 @@ fn symbols_with_errors(input: TokenStream) -> (TokenStream, Vec<syn::Error>) {\n         }\n \n         impl Interner {\n-            pub fn fresh() -> Self {\n+            pub(crate) fn fresh() -> Self {\n                 Interner::prefill(&[\n                     #prefill_stream\n                 ])"}, {"sha": "1df5b8cd2cc8dd1f78908d326fcd611ce7ca7edb", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2c7bc5e33c25e29058cbafefe680da8d5e9220e9/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c7bc5e33c25e29058cbafefe680da8d5e9220e9/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=2c7bc5e33c25e29058cbafefe680da8d5e9220e9", "patch": "@@ -1701,8 +1701,11 @@ impl<CTX> ToStableHashKey<CTX> for Symbol {\n // The `FxHashMap`+`Vec` pair could be replaced by `FxIndexSet`, but #75278\n // found that to regress performance up to 2% in some cases. This might be\n // revisited after further improvements to `indexmap`.\n+//\n+// This type is private to prevent accidentally constructing more than one `Interner` on the same\n+// thread, which makes it easy to mixup `Symbol`s between `Interner`s.\n #[derive(Default)]\n-pub struct Interner {\n+pub(crate) struct Interner {\n     arena: DroplessArena,\n     names: FxHashMap<&'static str, Symbol>,\n     strings: Vec<&'static str>,"}]}