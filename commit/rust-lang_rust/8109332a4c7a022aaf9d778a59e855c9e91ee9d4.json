{"sha": "8109332a4c7a022aaf9d778a59e855c9e91ee9d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxMDkzMzJhNGM3YTAyMmFhZjlkNzc4YTU5ZTg1NWM5ZTkxZWU5ZDQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-29T18:34:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-29T18:34:15Z"}, "message": "Rollup merge of #64825 - estebank:match-unit, r=Centril\n\nPoint at enclosing match when expecting `()` in arm\n\nWhen encountering code like the following:\n\n```rust\nfn main() {\n    match 3 {\n        4 => 1,\n        3 => {\n            println!(\"Yep it maches.\");\n            2\n        }\n        _ => 2\n    }\n    println!(\"Bye!\")\n}\n```\n\npoint at the enclosing `match` expression and suggest ignoring the\nreturned value:\n\n```\nerror[E0308]: mismatched types\n  --> $DIR/match-needing-semi.rs:8:13\n   |\nLL | /     match 3 {\nLL | |         4 => 1,\nLL | |         3 => {\nLL | |             2\n   | |             ^ expected (), found integer\nLL | |         }\nLL | |         _ => 2\nLL | |     }\n   | |     -- help: consider using a semicolon here\n   | |_____|\n   |       expected this to be `()`\n   |\n   = note: expected type `()`\n              found type `{integer}\n```\n\nFix #40799.", "tree": {"sha": "57cdd16913e74f63e1b998b4b9a582be62fe256d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57cdd16913e74f63e1b998b4b9a582be62fe256d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8109332a4c7a022aaf9d778a59e855c9e91ee9d4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdkPknCRBK7hj4Ov3rIwAAdHIIABo56dPF0DWLf9SqSU5c3Vzl\noK0OPidyzGMm7BdVp4L1Vq75tJ5Ju4mZ/4/Yw6dZn8D2ucvdOUhbOvdZvkJSguJe\n78Ab+hdCEsBLpyEijOIM9xFa9eI8j7YElSSx1/KejITAMCrYNJlhRouI/gsvYgNg\ntbh94J5yZ+jKZhDnEaGMtHNzpp+C2vFi5sCoMmNlFPGF7p5S8jshkbJ5gOKcKrln\n6PMUqhTZn5L/cdVRlpEFqXuZlMf5rM81pO487dlJX7zx0ZJypRK0sTx3bW9cu+ON\nZCPeXVvg8YSRyTPENH2kdr9agU4+gVf11/CPVleukj8LgAf81iyiuSQ9rT+waic=\n=R3/f\n-----END PGP SIGNATURE-----\n", "payload": "tree 57cdd16913e74f63e1b998b4b9a582be62fe256d\nparent f34e2b1e7cbbc77d1fadcdb613c3db9c79841e5f\nparent c861e24e7251fcbf0cbb8b85c676afe6b901f8af\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1569782055 +0200\ncommitter GitHub <noreply@github.com> 1569782055 +0200\n\nRollup merge of #64825 - estebank:match-unit, r=Centril\n\nPoint at enclosing match when expecting `()` in arm\n\nWhen encountering code like the following:\n\n```rust\nfn main() {\n    match 3 {\n        4 => 1,\n        3 => {\n            println!(\"Yep it maches.\");\n            2\n        }\n        _ => 2\n    }\n    println!(\"Bye!\")\n}\n```\n\npoint at the enclosing `match` expression and suggest ignoring the\nreturned value:\n\n```\nerror[E0308]: mismatched types\n  --> $DIR/match-needing-semi.rs:8:13\n   |\nLL | /     match 3 {\nLL | |         4 => 1,\nLL | |         3 => {\nLL | |             2\n   | |             ^ expected (), found integer\nLL | |         }\nLL | |         _ => 2\nLL | |     }\n   | |     -- help: consider using a semicolon here\n   | |_____|\n   |       expected this to be `()`\n   |\n   = note: expected type `()`\n              found type `{integer}\n```\n\nFix #40799.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8109332a4c7a022aaf9d778a59e855c9e91ee9d4", "html_url": "https://github.com/rust-lang/rust/commit/8109332a4c7a022aaf9d778a59e855c9e91ee9d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8109332a4c7a022aaf9d778a59e855c9e91ee9d4/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f34e2b1e7cbbc77d1fadcdb613c3db9c79841e5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f34e2b1e7cbbc77d1fadcdb613c3db9c79841e5f", "html_url": "https://github.com/rust-lang/rust/commit/f34e2b1e7cbbc77d1fadcdb613c3db9c79841e5f"}, {"sha": "c861e24e7251fcbf0cbb8b85c676afe6b901f8af", "url": "https://api.github.com/repos/rust-lang/rust/commits/c861e24e7251fcbf0cbb8b85c676afe6b901f8af", "html_url": "https://github.com/rust-lang/rust/commit/c861e24e7251fcbf0cbb8b85c676afe6b901f8af"}], "stats": {"total": 230, "additions": 180, "deletions": 50}, "files": [{"sha": "9dcecedd97caef4a0e102d31e90a994a99e6a2e2", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8109332a4c7a022aaf9d778a59e855c9e91ee9d4/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8109332a4c7a022aaf9d778a59e855c9e91ee9d4/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=8109332a4c7a022aaf9d778a59e855c9e91ee9d4", "patch": "@@ -1037,10 +1037,9 @@ impl LoweringContext<'_> {\n     ) -> hir::Expr {\n         // expand <head>\n         let mut head = self.lower_expr(head);\n-        let head_sp = head.span;\n         let desugared_span = self.mark_span_with_reason(\n             DesugaringKind::ForLoop,\n-            head_sp,\n+            head.span,\n             None,\n         );\n         head.span = desugared_span;\n@@ -1086,21 +1085,21 @@ impl LoweringContext<'_> {\n \n         // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n         let match_expr = {\n-            let iter = P(self.expr_ident(head_sp, iter, iter_pat_nid));\n-            let ref_mut_iter = self.expr_mut_addr_of(head_sp, iter);\n+            let iter = P(self.expr_ident(desugared_span, iter, iter_pat_nid));\n+            let ref_mut_iter = self.expr_mut_addr_of(desugared_span, iter);\n             let next_path = &[sym::iter, sym::Iterator, sym::next];\n             let next_expr = P(self.expr_call_std_path(\n-                head_sp,\n+                desugared_span,\n                 next_path,\n                 hir_vec![ref_mut_iter],\n             ));\n             let arms = hir_vec![pat_arm, break_arm];\n \n-            self.expr_match(head_sp, next_expr, arms, hir::MatchSource::ForLoopDesugar)\n+            self.expr_match(desugared_span, next_expr, arms, hir::MatchSource::ForLoopDesugar)\n         };\n-        let match_stmt = self.stmt_expr(head_sp, match_expr);\n+        let match_stmt = self.stmt_expr(desugared_span, match_expr);\n \n-        let next_expr = P(self.expr_ident(head_sp, next_ident, next_pat_hid));\n+        let next_expr = P(self.expr_ident(desugared_span, next_ident, next_pat_hid));\n \n         // `let mut __next`\n         let next_let = self.stmt_let_pat(\n@@ -1115,7 +1114,7 @@ impl LoweringContext<'_> {\n         let pat = self.lower_pat(pat);\n         let pat_let = self.stmt_let_pat(\n             ThinVec::new(),\n-            head_sp,\n+            desugared_span,\n             Some(next_expr),\n             pat,\n             hir::LocalSource::ForLoopDesugar,\n@@ -1152,14 +1151,14 @@ impl LoweringContext<'_> {\n             let into_iter_path =\n                 &[sym::iter, sym::IntoIterator, sym::into_iter];\n             P(self.expr_call_std_path(\n-                head_sp,\n+                desugared_span,\n                 into_iter_path,\n                 hir_vec![head],\n             ))\n         };\n \n         let match_expr = P(self.expr_match(\n-            head_sp,\n+            desugared_span,\n             into_iter_expr,\n             hir_vec![iter_arm],\n             hir::MatchSource::ForLoopDesugar,\n@@ -1171,7 +1170,7 @@ impl LoweringContext<'_> {\n         // surrounding scope of the `match` since the `match` is not a terminating scope.\n         //\n         // Also, add the attributes to the outer returned expr node.\n-        self.expr_drop_temps(head_sp, match_expr, e.attrs.clone())\n+        self.expr_drop_temps(desugared_span, match_expr, e.attrs.clone())\n     }\n \n     /// Desugar `ExprKind::Try` from: `<expr>?` into:"}, {"sha": "a1011697ef1606ca6d69a42de6d23f336429601d", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8109332a4c7a022aaf9d778a59e855c9e91ee9d4/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8109332a4c7a022aaf9d778a59e855c9e91ee9d4/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=8109332a4c7a022aaf9d778a59e855c9e91ee9d4", "patch": "@@ -818,6 +818,32 @@ impl<'hir> Map<'hir> {\n         CRATE_HIR_ID\n     }\n \n+    /// When on a match arm tail expression or on a match arm, give back the enclosing `match`\n+    /// expression.\n+    ///\n+    /// Used by error reporting when there's a type error in a match arm caused by the `match`\n+    /// expression needing to be unit.\n+    pub fn get_match_if_cause(&self, hir_id: HirId) -> Option<&Expr> {\n+        for (_, node) in ParentHirIterator::new(hir_id, &self) {\n+            match node {\n+                Node::Item(_) |\n+                Node::ForeignItem(_) |\n+                Node::TraitItem(_) |\n+                Node::ImplItem(_) => break,\n+                Node::Expr(expr) => match expr.kind {\n+                    ExprKind::Match(_, _, _) => return Some(expr),\n+                    _ => {}\n+                },\n+                Node::Stmt(stmt) => match stmt.kind {\n+                    StmtKind::Local(_) => break,\n+                    _ => {}\n+                }\n+                _ => {}\n+            }\n+        }\n+        None\n+    }\n+\n     /// Returns the nearest enclosing scope. A scope is roughly an item or block.\n     pub fn get_enclosing_scope(&self, hir_id: HirId) -> Option<HirId> {\n         for (hir_id, node) in ParentHirIterator::new(hir_id, &self) {"}, {"sha": "a1daed005f3024ae79a1bd20dedd406cf5288896", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8109332a4c7a022aaf9d778a59e855c9e91ee9d4/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8109332a4c7a022aaf9d778a59e855c9e91ee9d4/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=8109332a4c7a022aaf9d778a59e855c9e91ee9d4", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // 2. By expecting `bool` for `expr` we get nice diagnostics for e.g. `if x = y { .. }`.\n             //\n             // FIXME(60707): Consider removing hack with principled solution.\n-            self.check_expr_has_type_or_error(discrim, self.tcx.types.bool)\n+            self.check_expr_has_type_or_error(discrim, self.tcx.types.bool, |_| {})\n         } else {\n             self.demand_discriminant_type(arms, discrim)\n         };\n@@ -106,7 +106,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if let Some(g) = &arm.guard {\n                 self.diverges.set(pats_diverge);\n                 match g {\n-                    hir::Guard::If(e) => self.check_expr_has_type_or_error(e, tcx.types.bool),\n+                    hir::Guard::If(e) => {\n+                        self.check_expr_has_type_or_error(e, tcx.types.bool, |_| {})\n+                    }\n                 };\n             }\n \n@@ -442,7 +444,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 kind: TypeVariableOriginKind::TypeInference,\n                 span: discrim.span,\n             });\n-            self.check_expr_has_type_or_error(discrim, discrim_ty);\n+            self.check_expr_has_type_or_error(discrim, discrim_ty, |_| {});\n             discrim_ty\n         }\n     }"}, {"sha": "56962d53a645064b4ff9ea9d735a86eaa9f23e58", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 43, "deletions": 30, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/8109332a4c7a022aaf9d778a59e855c9e91ee9d4/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8109332a4c7a022aaf9d778a59e855c9e91ee9d4/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=8109332a4c7a022aaf9d778a59e855c9e91ee9d4", "patch": "@@ -1163,18 +1163,20 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 fcx.try_coerce(expression, expression_ty, self.expected_ty, AllowTwoPhase::No)\n             } else {\n                 match self.expressions {\n-                    Expressions::Dynamic(ref exprs) =>\n-                        fcx.try_find_coercion_lub(cause,\n-                                                  exprs,\n-                                                  self.merged_ty(),\n-                                                  expression,\n-                                                  expression_ty),\n-                    Expressions::UpFront(ref coercion_sites) =>\n-                        fcx.try_find_coercion_lub(cause,\n-                                                  &coercion_sites[0..self.pushed],\n-                                                  self.merged_ty(),\n-                                                  expression,\n-                                                  expression_ty),\n+                    Expressions::Dynamic(ref exprs) => fcx.try_find_coercion_lub(\n+                        cause,\n+                        exprs,\n+                        self.merged_ty(),\n+                        expression,\n+                        expression_ty,\n+                    ),\n+                    Expressions::UpFront(ref coercion_sites) => fcx.try_find_coercion_lub(\n+                        cause,\n+                        &coercion_sites[0..self.pushed],\n+                        self.merged_ty(),\n+                        expression,\n+                        expression_ty,\n+                    ),\n                 }\n             }\n         } else {\n@@ -1216,7 +1218,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                     self.pushed += 1;\n                 }\n             }\n-            Err(err) => {\n+            Err(coercion_error) => {\n                 let (expected, found) = if label_expression_as_expected {\n                     // In the case where this is a \"forced unit\", like\n                     // `break`, we want to call the `()` \"expected\"\n@@ -1232,41 +1234,42 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                     (self.final_ty.unwrap_or(self.expected_ty), expression_ty)\n                 };\n \n-                let mut db;\n+                let mut err;\n                 match cause.code {\n                     ObligationCauseCode::ReturnNoExpression => {\n-                        db = struct_span_err!(\n+                        err = struct_span_err!(\n                             fcx.tcx.sess, cause.span, E0069,\n                             \"`return;` in a function whose return type is not `()`\");\n-                        db.span_label(cause.span, \"return type is not `()`\");\n+                        err.span_label(cause.span, \"return type is not `()`\");\n                     }\n                     ObligationCauseCode::BlockTailExpression(blk_id) => {\n                         let parent_id = fcx.tcx.hir().get_parent_node(blk_id);\n-                        db = self.report_return_mismatched_types(\n+                        err = self.report_return_mismatched_types(\n                             cause,\n                             expected,\n                             found,\n-                            err,\n+                            coercion_error,\n                             fcx,\n                             parent_id,\n                             expression.map(|expr| (expr, blk_id)),\n                         );\n                     }\n                     ObligationCauseCode::ReturnValue(id) => {\n-                        db = self.report_return_mismatched_types(\n-                            cause, expected, found, err, fcx, id, None);\n+                        err = self.report_return_mismatched_types(\n+                            cause, expected, found, coercion_error, fcx, id, None);\n                     }\n                     _ => {\n-                        db = fcx.report_mismatched_types(cause, expected, found, err);\n+                        err = fcx.report_mismatched_types(cause, expected, found, coercion_error);\n                     }\n                 }\n \n                 if let Some(augment_error) = augment_error {\n-                    augment_error(&mut db);\n+                    augment_error(&mut err);\n                 }\n \n                 // Error possibly reported in `check_assign` so avoid emitting error again.\n-                db.emit_unless(expression.filter(|e| fcx.is_assign_to_bool(e, expected)).is_some());\n+                err.emit_unless(expression.filter(|e| fcx.is_assign_to_bool(e, expected))\n+                    .is_some());\n \n                 self.final_ty = Some(fcx.tcx.types.err);\n             }\n@@ -1278,12 +1281,12 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         cause: &ObligationCause<'tcx>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n-        err: TypeError<'tcx>,\n+        ty_err: TypeError<'tcx>,\n         fcx: &FnCtxt<'a, 'tcx>,\n         id: hir::HirId,\n         expression: Option<(&'tcx hir::Expr, hir::HirId)>,\n     ) -> DiagnosticBuilder<'a> {\n-        let mut db = fcx.report_mismatched_types(cause, expected, found, err);\n+        let mut err = fcx.report_mismatched_types(cause, expected, found, ty_err);\n \n         let mut pointing_at_return_type = false;\n         let mut return_sp = None;\n@@ -1294,14 +1297,24 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         let parent_id = fcx.tcx.hir().get_parent_node(id);\n         let fn_decl = if let Some((expr, blk_id)) = expression {\n             pointing_at_return_type = fcx.suggest_mismatched_types_on_tail(\n-                &mut db,\n+                &mut err,\n                 expr,\n                 expected,\n                 found,\n                 cause.span,\n                 blk_id,\n             );\n             let parent = fcx.tcx.hir().get(parent_id);\n+            if let (Some(match_expr), true, false) = (\n+                fcx.tcx.hir().get_match_if_cause(expr.hir_id),\n+                expected.is_unit(),\n+                pointing_at_return_type,\n+            ) {\n+                if match_expr.span.desugaring_kind().is_none() {\n+                    err.span_label(match_expr.span, \"expected this to be `()`\");\n+                    fcx.suggest_semicolon_at_end(match_expr.span, &mut err);\n+                }\n+            }\n             fcx.get_node_fn_decl(parent).map(|(fn_decl, _, is_main)| (fn_decl, is_main))\n         } else {\n             fcx.get_fn_decl(parent_id)\n@@ -1310,20 +1323,20 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         if let (Some((fn_decl, can_suggest)), _) = (fn_decl, pointing_at_return_type) {\n             if expression.is_none() {\n                 pointing_at_return_type |= fcx.suggest_missing_return_type(\n-                    &mut db, &fn_decl, expected, found, can_suggest);\n+                    &mut err, &fn_decl, expected, found, can_suggest);\n             }\n             if !pointing_at_return_type {\n                 return_sp = Some(fn_decl.output.span()); // `impl Trait` return type\n             }\n         }\n         if let (Some(sp), Some(return_sp)) = (fcx.ret_coercion_span.borrow().as_ref(), return_sp) {\n-            db.span_label(return_sp, \"expected because this return type...\");\n-            db.span_label( *sp, format!(\n+            err.span_label(return_sp, \"expected because this return type...\");\n+            err.span_label( *sp, format!(\n                 \"...is found to be `{}` here\",\n                 fcx.resolve_type_vars_with_obligations(expected),\n             ));\n         }\n-        db\n+        err\n     }\n \n     pub fn complete<'a>(self, fcx: &FnCtxt<'a, 'tcx>) -> Ty<'tcx> {"}, {"sha": "04c8536de8dfef423b0430a8cfc8c0f1066f83ad", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8109332a4c7a022aaf9d778a59e855c9e91ee9d4/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8109332a4c7a022aaf9d778a59e855c9e91ee9d4/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=8109332a4c7a022aaf9d778a59e855c9e91ee9d4", "patch": "@@ -53,14 +53,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &'tcx hir::Expr,\n         expected: Ty<'tcx>,\n+        extend_err: impl Fn(&mut DiagnosticBuilder<'_>),\n     ) -> Ty<'tcx> {\n-        self.check_expr_meets_expectation_or_error(expr, ExpectHasType(expected))\n+        self.check_expr_meets_expectation_or_error(expr, ExpectHasType(expected), extend_err)\n     }\n \n     fn check_expr_meets_expectation_or_error(\n         &self,\n         expr: &'tcx hir::Expr,\n         expected: Expectation<'tcx>,\n+        extend_err: impl Fn(&mut DiagnosticBuilder<'_>),\n     ) -> Ty<'tcx> {\n         let expected_ty = expected.to_option(&self).unwrap_or(self.tcx.types.bool);\n         let mut ty = self.check_expr_with_expectation(expr, expected);\n@@ -88,6 +90,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 ExprKind::DropTemps(expr) => expr,\n                 _ => expr,\n             };\n+            extend_err(&mut err);\n             // Error possibly reported in `check_assign` so avoid emitting error again.\n             err.emit_unless(self.is_assign_to_bool(expr, expected_ty));\n         }\n@@ -971,7 +974,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     kind: TypeVariableOriginKind::MiscVariable,\n                     span: element.span,\n                 });\n-                let element_ty = self.check_expr_has_type_or_error(&element, ty);\n+                let element_ty = self.check_expr_has_type_or_error(&element, ty, |_| {});\n                 (element_ty, ty)\n             }\n         };\n@@ -1058,7 +1061,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // the fields with the base_expr. This could cause us to hit errors later\n             // when certain fields are assumed to exist that in fact do not.\n             if !error_happened {\n-                self.check_expr_has_type_or_error(base_expr, adt_ty);\n+                self.check_expr_has_type_or_error(base_expr, adt_ty, |_| {});\n                 match adt_ty.kind {\n                     ty::Adt(adt, substs) if adt.is_struct() => {\n                         let fru_field_types = adt.non_enum_variant().fields.iter().map(|f| {"}, {"sha": "092ab0936c0f430588ce366b22fa0d4904f3f8a7", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8109332a4c7a022aaf9d778a59e855c9e91ee9d4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8109332a4c7a022aaf9d778a59e855c9e91ee9d4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8109332a4c7a022aaf9d778a59e855c9e91ee9d4", "patch": "@@ -3879,6 +3879,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn suggest_semicolon_at_end(&self, span: Span, err: &mut DiagnosticBuilder<'_>) {\n+        err.span_suggestion_short(\n+            span.shrink_to_hi(),\n+            \"consider using a semicolon here\",\n+            \";\".to_string(),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+\n     pub fn check_stmt(&self, stmt: &'tcx hir::Stmt) {\n         // Don't do all the complex logic below for `DeclItem`.\n         match stmt.kind {\n@@ -3902,7 +3911,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             hir::StmtKind::Item(_) => {}\n             hir::StmtKind::Expr(ref expr) => {\n                 // Check with expected type of `()`.\n-                self.check_expr_has_type_or_error(&expr, self.tcx.mk_unit());\n+\n+                self.check_expr_has_type_or_error(&expr, self.tcx.mk_unit(), |err| {\n+                    self.suggest_semicolon_at_end(expr.span, err);\n+                });\n             }\n             hir::StmtKind::Semi(ref expr) => {\n                 self.check_expr(&expr);"}, {"sha": "a52ec6dc539386a0fd67c47105196a496bfff1f3", "filename": "src/test/ui/struct-literal-variant-in-if.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8109332a4c7a022aaf9d778a59e855c9e91ee9d4/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8109332a4c7a022aaf9d778a59e855c9e91ee9d4/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr?ref=8109332a4c7a022aaf9d778a59e855c9e91ee9d4", "patch": "@@ -50,7 +50,10 @@ error[E0308]: mismatched types\n   --> $DIR/struct-literal-variant-in-if.rs:10:20\n    |\n LL |     if x == E::V { field } {}\n-   |                    ^^^^^ expected (), found bool\n+   |     ---------------^^^^^--- help: consider using a semicolon here\n+   |     |              |\n+   |     |              expected (), found bool\n+   |     expected this to be `()`\n    |\n    = note: expected type `()`\n               found type `bool`"}, {"sha": "03cbed1376ea3ed21c8513d2d7a35d5ef419c539", "filename": "src/test/ui/suggestions/match-needing-semi.fixed", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8109332a4c7a022aaf9d778a59e855c9e91ee9d4/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-needing-semi.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8109332a4c7a022aaf9d778a59e855c9e91ee9d4/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-needing-semi.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-needing-semi.fixed?ref=8109332a4c7a022aaf9d778a59e855c9e91ee9d4", "patch": "@@ -0,0 +1,18 @@\n+// check-only\n+// run-rustfix\n+\n+fn main() {\n+    match 3 {\n+        4 => 1,\n+        3 => {\n+            2 //~ ERROR mismatched types\n+        }\n+        _ => 2\n+    };\n+    match 3 { //~ ERROR mismatched types\n+        4 => 1,\n+        3 => 2,\n+        _ => 2\n+    };\n+    let _ = ();\n+}"}, {"sha": "f34071ac758868b9fb4c10b5244288dcebb8ebc7", "filename": "src/test/ui/suggestions/match-needing-semi.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8109332a4c7a022aaf9d778a59e855c9e91ee9d4/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-needing-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8109332a4c7a022aaf9d778a59e855c9e91ee9d4/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-needing-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-needing-semi.rs?ref=8109332a4c7a022aaf9d778a59e855c9e91ee9d4", "patch": "@@ -0,0 +1,18 @@\n+// check-only\n+// run-rustfix\n+\n+fn main() {\n+    match 3 {\n+        4 => 1,\n+        3 => {\n+            2 //~ ERROR mismatched types\n+        }\n+        _ => 2\n+    }\n+    match 3 { //~ ERROR mismatched types\n+        4 => 1,\n+        3 => 2,\n+        _ => 2\n+    }\n+    let _ = ();\n+}"}, {"sha": "988945817c2eeb88a86ac84bae93a86da87d0f93", "filename": "src/test/ui/suggestions/match-needing-semi.stderr", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8109332a4c7a022aaf9d778a59e855c9e91ee9d4/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-needing-semi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8109332a4c7a022aaf9d778a59e855c9e91ee9d4/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-needing-semi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-needing-semi.stderr?ref=8109332a4c7a022aaf9d778a59e855c9e91ee9d4", "patch": "@@ -0,0 +1,36 @@\n+error[E0308]: mismatched types\n+  --> $DIR/match-needing-semi.rs:8:13\n+   |\n+LL | /     match 3 {\n+LL | |         4 => 1,\n+LL | |         3 => {\n+LL | |             2\n+   | |             ^ expected (), found integer\n+LL | |         }\n+LL | |         _ => 2\n+LL | |     }\n+   | |     -- help: consider using a semicolon here\n+   | |_____|\n+   |       expected this to be `()`\n+   |\n+   = note: expected type `()`\n+              found type `{integer}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/match-needing-semi.rs:12:5\n+   |\n+LL | /     match 3 {\n+LL | |         4 => 1,\n+LL | |         3 => 2,\n+LL | |         _ => 2\n+LL | |     }\n+   | |     ^- help: consider using a semicolon here\n+   | |_____|\n+   |       expected (), found integer\n+   |\n+   = note: expected type `()`\n+              found type `{integer}`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}