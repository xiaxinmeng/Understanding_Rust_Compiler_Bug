{"sha": "f8a59adf5e9633aa5d10efcdbf70b408d280ef01", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4YTU5YWRmNWU5NjMzYWE1ZDEwZWZjZGJmNzBiNDA4ZDI4MGVmMDE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-26T16:56:41Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-26T18:24:00Z"}, "message": "Tease apart orthogonal concerns in markdown link rewriting\n\n`hir` should know nothing about URLs, markdown and html. It should\nonly be able to:\n\n* resolve stringy path from documentation\n* generate canonical stringy path for a def\n\nIn contrast, link rewriting should not care about semantics of paths\nand names resolution, and should be concern only with text mangling\nbits.", "tree": {"sha": "d088d683f75bbd2bed837f1ca0aca61fdba5c11b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d088d683f75bbd2bed837f1ca0aca61fdba5c11b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8a59adf5e9633aa5d10efcdbf70b408d280ef01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8a59adf5e9633aa5d10efcdbf70b408d280ef01", "html_url": "https://github.com/rust-lang/rust/commit/f8a59adf5e9633aa5d10efcdbf70b408d280ef01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8a59adf5e9633aa5d10efcdbf70b408d280ef01/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d6c4c143b4b4c74810318eca1b5493e43535fff", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d6c4c143b4b4c74810318eca1b5493e43535fff", "html_url": "https://github.com/rust-lang/rust/commit/3d6c4c143b4b4c74810318eca1b5493e43535fff"}], "stats": {"total": 634, "additions": 297, "deletions": 337}, "files": [{"sha": "f1a17fa90e3a5d54f4fa52b388124c52b16b5fcb", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8a59adf5e9633aa5d10efcdbf70b408d280ef01/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f8a59adf5e9633aa5d10efcdbf70b408d280ef01/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f8a59adf5e9633aa5d10efcdbf70b408d280ef01", "patch": "@@ -498,7 +498,6 @@ dependencies = [\n  \"stdx\",\n  \"syntax\",\n  \"tt\",\n- \"url\",\n ]\n \n [[package]]\n@@ -606,6 +605,7 @@ dependencies = [\n  \"syntax\",\n  \"test_utils\",\n  \"text_edit\",\n+ \"url\",\n ]\n \n [[package]]"}, {"sha": "6dc5ad63ba0d2749dddf09bbc1c381cb59040fd6", "filename": "crates/hir/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f8a59adf5e9633aa5d10efcdbf70b408d280ef01/crates%2Fhir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f8a59adf5e9633aa5d10efcdbf70b408d280ef01/crates%2Fhir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2FCargo.toml?ref=f8a59adf5e9633aa5d10efcdbf70b408d280ef01", "patch": "@@ -15,7 +15,6 @@ rustc-hash = \"1.1.0\"\n either = \"1.5.3\"\n arrayvec = \"0.5.1\"\n itertools = \"0.9.0\"\n-url = \"2.1.1\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n syntax = { path = \"../syntax\", version = \"0.0.0\" }"}, {"sha": "c3e820d89b6ed40635977ca5cefd40da38dc80ea", "filename": "crates/hir/src/attrs.rs", "status": "modified", "additions": 54, "deletions": 79, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/f8a59adf5e9633aa5d10efcdbf70b408d280ef01/crates%2Fhir%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8a59adf5e9633aa5d10efcdbf70b408d280ef01/crates%2Fhir%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fattrs.rs?ref=f8a59adf5e9633aa5d10efcdbf70b408d280ef01", "patch": "@@ -1,20 +1,32 @@\n //! Attributes & documentation for hir types.\n use hir_def::{\n-    attr::Attrs,\n-    docs::Documentation,\n-    resolver::{HasResolver, Resolver},\n-    AdtId, AttrDefId, FunctionId, GenericDefId, ModuleId, StaticId, TraitId, VariantId,\n+    attr::Attrs, docs::Documentation, path::ModPath, resolver::HasResolver, AttrDefId, ModuleDefId,\n };\n+use hir_expand::hygiene::Hygiene;\n use hir_ty::db::HirDatabase;\n+use syntax::ast;\n \n use crate::{\n-    doc_links::Resolvable, Adt, Const, Enum, EnumVariant, Field, Function, GenericDef, ImplDef,\n-    Local, MacroDef, Module, ModuleDef, Static, Struct, Trait, TypeAlias, TypeParam, Union,\n+    Adt, Const, Enum, EnumVariant, Field, Function, MacroDef, Module, ModuleDef, Static, Struct,\n+    Trait, TypeAlias, Union,\n };\n \n pub trait HasAttrs {\n     fn attrs(self, db: &dyn HirDatabase) -> Attrs;\n     fn docs(self, db: &dyn HirDatabase) -> Option<Documentation>;\n+    fn resolve_doc_path(\n+        self,\n+        db: &dyn HirDatabase,\n+        link: &str,\n+        ns: Option<Namespace>,\n+    ) -> Option<ModuleDef>;\n+}\n+\n+#[derive(PartialEq, Eq, Hash, Copy, Clone, Debug)]\n+pub enum Namespace {\n+    Types,\n+    Values,\n+    Macros,\n }\n \n macro_rules! impl_has_attrs {\n@@ -28,6 +40,10 @@ macro_rules! impl_has_attrs {\n                 let def = AttrDefId::$def_id(self.into());\n                 db.documentation(def)\n             }\n+            fn resolve_doc_path(self, db: &dyn HirDatabase, link: &str, ns: Option<Namespace>) -> Option<ModuleDef> {\n+                let def = AttrDefId::$def_id(self.into());\n+                resolve_doc_path(db, def, link, ns).map(ModuleDef::from)\n+            }\n         }\n     )*};\n }\n@@ -54,83 +70,42 @@ macro_rules! impl_has_attrs_adt {\n             fn docs(self, db: &dyn HirDatabase) -> Option<Documentation> {\n                 Adt::$adt(self).docs(db)\n             }\n+            fn resolve_doc_path(self, db: &dyn HirDatabase, link: &str, ns: Option<Namespace>) -> Option<ModuleDef> {\n+                Adt::$adt(self).resolve_doc_path(db, link, ns)\n+            }\n         }\n     )*};\n }\n \n impl_has_attrs_adt![Struct, Union, Enum];\n \n-impl Resolvable for ModuleDef {\n-    fn resolver(&self, db: &dyn HirDatabase) -> Option<Resolver> {\n-        Some(match self {\n-            ModuleDef::Module(m) => ModuleId::from(m.clone()).resolver(db.upcast()),\n-            ModuleDef::Function(f) => FunctionId::from(f.clone()).resolver(db.upcast()),\n-            ModuleDef::Adt(adt) => AdtId::from(adt.clone()).resolver(db.upcast()),\n-            ModuleDef::EnumVariant(ev) => {\n-                GenericDefId::from(GenericDef::from(ev.clone())).resolver(db.upcast())\n-            }\n-            ModuleDef::Const(c) => {\n-                GenericDefId::from(GenericDef::from(c.clone())).resolver(db.upcast())\n-            }\n-            ModuleDef::Static(s) => StaticId::from(s.clone()).resolver(db.upcast()),\n-            ModuleDef::Trait(t) => TraitId::from(t.clone()).resolver(db.upcast()),\n-            ModuleDef::TypeAlias(t) => ModuleId::from(t.module(db)).resolver(db.upcast()),\n-            // FIXME: This should be a resolver relative to `std/core`\n-            ModuleDef::BuiltinType(_t) => None?,\n-        })\n-    }\n-\n-    fn try_into_module_def(self) -> Option<ModuleDef> {\n-        Some(self)\n-    }\n-}\n-\n-impl Resolvable for TypeParam {\n-    fn resolver(&self, db: &dyn HirDatabase) -> Option<Resolver> {\n-        Some(ModuleId::from(self.module(db)).resolver(db.upcast()))\n-    }\n-\n-    fn try_into_module_def(self) -> Option<ModuleDef> {\n-        None\n-    }\n-}\n-\n-impl Resolvable for MacroDef {\n-    fn resolver(&self, db: &dyn HirDatabase) -> Option<Resolver> {\n-        Some(ModuleId::from(self.module(db)?).resolver(db.upcast()))\n-    }\n-\n-    fn try_into_module_def(self) -> Option<ModuleDef> {\n-        None\n-    }\n-}\n-\n-impl Resolvable for Field {\n-    fn resolver(&self, db: &dyn HirDatabase) -> Option<Resolver> {\n-        Some(VariantId::from(self.parent_def(db)).resolver(db.upcast()))\n-    }\n-\n-    fn try_into_module_def(self) -> Option<ModuleDef> {\n-        None\n-    }\n-}\n-\n-impl Resolvable for ImplDef {\n-    fn resolver(&self, db: &dyn HirDatabase) -> Option<Resolver> {\n-        Some(ModuleId::from(self.module(db)).resolver(db.upcast()))\n-    }\n-\n-    fn try_into_module_def(self) -> Option<ModuleDef> {\n-        None\n-    }\n-}\n-\n-impl Resolvable for Local {\n-    fn resolver(&self, db: &dyn HirDatabase) -> Option<Resolver> {\n-        Some(ModuleId::from(self.module(db)).resolver(db.upcast()))\n-    }\n-\n-    fn try_into_module_def(self) -> Option<ModuleDef> {\n-        None\n-    }\n+fn resolve_doc_path(\n+    db: &dyn HirDatabase,\n+    def: AttrDefId,\n+    link: &str,\n+    ns: Option<Namespace>,\n+) -> Option<ModuleDefId> {\n+    let resolver = match def {\n+        AttrDefId::ModuleId(it) => it.resolver(db.upcast()),\n+        AttrDefId::FieldId(it) => it.parent.resolver(db.upcast()),\n+        AttrDefId::AdtId(it) => it.resolver(db.upcast()),\n+        AttrDefId::FunctionId(it) => it.resolver(db.upcast()),\n+        AttrDefId::EnumVariantId(it) => it.parent.resolver(db.upcast()),\n+        AttrDefId::StaticId(it) => it.resolver(db.upcast()),\n+        AttrDefId::ConstId(it) => it.resolver(db.upcast()),\n+        AttrDefId::TraitId(it) => it.resolver(db.upcast()),\n+        AttrDefId::TypeAliasId(it) => it.resolver(db.upcast()),\n+        AttrDefId::ImplId(it) => it.resolver(db.upcast()),\n+        AttrDefId::MacroDefId(_) => return None,\n+    };\n+    let path = ast::Path::parse(link).ok()?;\n+    let modpath = ModPath::from_src(path, &Hygiene::new_unhygienic()).unwrap();\n+    let resolved = resolver.resolve_module_path_in_items(db.upcast(), &modpath);\n+    let def = match ns {\n+        Some(Namespace::Types) => resolved.take_types()?,\n+        Some(Namespace::Values) => resolved.take_values()?,\n+        Some(Namespace::Macros) => return None,\n+        None => resolved.iter_items().find_map(|it| it.as_module_def_id())?,\n+    };\n+    Some(def.into())\n }"}, {"sha": "c2fc819e764aa8669001a8ca9745a67e58af05db", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f8a59adf5e9633aa5d10efcdbf70b408d280ef01/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8a59adf5e9633aa5d10efcdbf70b408d280ef01/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=f8a59adf5e9633aa5d10efcdbf70b408d280ef01", "patch": "@@ -196,6 +196,16 @@ impl ModuleDef {\n         }\n     }\n \n+    pub fn canonical_path(&self, db: &dyn HirDatabase) -> Option<String> {\n+        let mut segments = Vec::new();\n+        segments.push(self.name(db)?.to_string());\n+        for m in self.module(db)?.path_to_root(db) {\n+            segments.extend(m.name(db).map(|it| it.to_string()))\n+        }\n+        segments.reverse();\n+        Some(segments.join(\"::\"))\n+    }\n+\n     pub fn definition_visibility(&self, db: &dyn HirDatabase) -> Option<Visibility> {\n         let module = match self {\n             ModuleDef::Module(it) => it.parent(db)?,"}, {"sha": "ddaffbec25547229aedbacf3451cfc98fb41e787", "filename": "crates/hir/src/doc_links.rs", "status": "removed", "additions": 0, "deletions": 238, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/3d6c4c143b4b4c74810318eca1b5493e43535fff/crates%2Fhir%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d6c4c143b4b4c74810318eca1b5493e43535fff/crates%2Fhir%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdoc_links.rs?ref=3d6c4c143b4b4c74810318eca1b5493e43535fff", "patch": "@@ -1,238 +0,0 @@\n-//! Resolves links in markdown documentation.\n-\n-use std::iter::once;\n-\n-use hir_def::resolver::Resolver;\n-use itertools::Itertools;\n-use syntax::ast::Path;\n-use url::Url;\n-\n-use crate::{db::HirDatabase, Adt, AsName, Crate, Hygiene, ItemInNs, ModPath, ModuleDef};\n-\n-pub fn resolve_doc_link<T: Resolvable + Clone>(\n-    db: &dyn HirDatabase,\n-    definition: &T,\n-    link_text: &str,\n-    link_target: &str,\n-) -> Option<(String, String)> {\n-    let resolver = definition.resolver(db)?;\n-    let module_def = definition.clone().try_into_module_def();\n-    resolve_doc_link_impl(db, &resolver, module_def, link_text, link_target)\n-}\n-\n-fn resolve_doc_link_impl(\n-    db: &dyn HirDatabase,\n-    resolver: &Resolver,\n-    module_def: Option<ModuleDef>,\n-    link_text: &str,\n-    link_target: &str,\n-) -> Option<(String, String)> {\n-    try_resolve_intra(db, &resolver, link_text, &link_target).or_else(|| {\n-        try_resolve_path(db, &module_def?, &link_target)\n-            .map(|target| (target, link_text.to_string()))\n-    })\n-}\n-\n-/// Try to resolve path to local documentation via intra-doc-links (i.e. `super::gateway::Shard`).\n-///\n-/// See [RFC1946](https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md).\n-fn try_resolve_intra(\n-    db: &dyn HirDatabase,\n-    resolver: &Resolver,\n-    link_text: &str,\n-    link_target: &str,\n-) -> Option<(String, String)> {\n-    // Set link_target for implied shortlinks\n-    let link_target =\n-        if link_target.is_empty() { link_text.trim_matches('`') } else { link_target };\n-\n-    let doclink = IntraDocLink::from(link_target);\n-\n-    // Parse link as a module path\n-    let path = Path::parse(doclink.path).ok()?;\n-    let modpath = ModPath::from_src(path, &Hygiene::new_unhygienic()).unwrap();\n-\n-    let resolved = resolver.resolve_module_path_in_items(db.upcast(), &modpath);\n-    let (defid, namespace) = match doclink.namespace {\n-        // FIXME: .or(resolved.macros)\n-        None => resolved\n-            .types\n-            .map(|t| (t.0, Namespace::Types))\n-            .or(resolved.values.map(|t| (t.0, Namespace::Values)))?,\n-        Some(ns @ Namespace::Types) => (resolved.types?.0, ns),\n-        Some(ns @ Namespace::Values) => (resolved.values?.0, ns),\n-        // FIXME:\n-        Some(Namespace::Macros) => return None,\n-    };\n-\n-    // Get the filepath of the final symbol\n-    let def: ModuleDef = defid.into();\n-    let module = def.module(db)?;\n-    let krate = module.krate();\n-    let ns = match namespace {\n-        Namespace::Types => ItemInNs::Types(defid),\n-        Namespace::Values => ItemInNs::Values(defid),\n-        // FIXME:\n-        Namespace::Macros => None?,\n-    };\n-    let import_map = db.import_map(krate.into());\n-    let path = import_map.path_of(ns)?;\n-\n-    Some((\n-        get_doc_url(db, &krate)?\n-            .join(&format!(\"{}/\", krate.display_name(db)?))\n-            .ok()?\n-            .join(&path.segments.iter().map(|name| name.to_string()).join(\"/\"))\n-            .ok()?\n-            .join(&get_symbol_filename(db, &def)?)\n-            .ok()?\n-            .into_string(),\n-        strip_prefixes_suffixes(link_text).to_string(),\n-    ))\n-}\n-\n-/// Try to resolve path to local documentation via path-based links (i.e. `../gateway/struct.Shard.html`).\n-fn try_resolve_path(db: &dyn HirDatabase, moddef: &ModuleDef, link_target: &str) -> Option<String> {\n-    if !link_target.contains(\"#\") && !link_target.contains(\".html\") {\n-        return None;\n-    }\n-    let ns = ItemInNs::Types(moddef.clone().into());\n-\n-    let module = moddef.module(db)?;\n-    let krate = module.krate();\n-    let import_map = db.import_map(krate.into());\n-    let base = once(format!(\"{}\", krate.display_name(db)?))\n-        .chain(import_map.path_of(ns)?.segments.iter().map(|name| format!(\"{}\", name)))\n-        .join(\"/\");\n-\n-    get_doc_url(db, &krate)\n-        .and_then(|url| url.join(&base).ok())\n-        .and_then(|url| {\n-            get_symbol_filename(db, moddef).as_deref().map(|f| url.join(f).ok()).flatten()\n-        })\n-        .and_then(|url| url.join(link_target).ok())\n-        .map(|url| url.into_string())\n-}\n-\n-/// Strip prefixes, suffixes, and inline code marks from the given string.\n-fn strip_prefixes_suffixes(mut s: &str) -> &str {\n-    s = s.trim_matches('`');\n-\n-    [\n-        (TYPES.0.iter(), TYPES.1.iter()),\n-        (VALUES.0.iter(), VALUES.1.iter()),\n-        (MACROS.0.iter(), MACROS.1.iter()),\n-    ]\n-    .iter()\n-    .for_each(|(prefixes, suffixes)| {\n-        prefixes.clone().for_each(|prefix| s = s.trim_start_matches(*prefix));\n-        suffixes.clone().for_each(|suffix| s = s.trim_end_matches(*suffix));\n-    });\n-    let s = s.trim_start_matches(\"@\").trim();\n-    s\n-}\n-\n-fn get_doc_url(db: &dyn HirDatabase, krate: &Crate) -> Option<Url> {\n-    krate\n-        .get_html_root_url(db)\n-        .or_else(||\n-        // Fallback to docs.rs\n-        // FIXME: Specify an exact version here. This may be difficult, as multiple versions of the same crate could exist.\n-        Some(format!(\"https://docs.rs/{}/*/\", krate.display_name(db)?)))\n-        .and_then(|s| Url::parse(&s).ok())\n-}\n-\n-/// Get the filename and extension generated for a symbol by rustdoc.\n-///\n-/// Example: `struct.Shard.html`\n-fn get_symbol_filename(db: &dyn HirDatabase, definition: &ModuleDef) -> Option<String> {\n-    Some(match definition {\n-        ModuleDef::Adt(adt) => match adt {\n-            Adt::Struct(s) => format!(\"struct.{}.html\", s.name(db)),\n-            Adt::Enum(e) => format!(\"enum.{}.html\", e.name(db)),\n-            Adt::Union(u) => format!(\"union.{}.html\", u.name(db)),\n-        },\n-        ModuleDef::Module(_) => \"index.html\".to_string(),\n-        ModuleDef::Trait(t) => format!(\"trait.{}.html\", t.name(db)),\n-        ModuleDef::TypeAlias(t) => format!(\"type.{}.html\", t.name(db)),\n-        ModuleDef::BuiltinType(t) => format!(\"primitive.{}.html\", t.as_name()),\n-        ModuleDef::Function(f) => format!(\"fn.{}.html\", f.name(db)),\n-        ModuleDef::EnumVariant(ev) => {\n-            format!(\"enum.{}.html#variant.{}\", ev.parent_enum(db).name(db), ev.name(db))\n-        }\n-        ModuleDef::Const(c) => format!(\"const.{}.html\", c.name(db)?),\n-        ModuleDef::Static(s) => format!(\"static.{}.html\", s.name(db)?),\n-    })\n-}\n-\n-struct IntraDocLink<'s> {\n-    path: &'s str,\n-    namespace: Option<Namespace>,\n-}\n-\n-impl<'s> From<&'s str> for IntraDocLink<'s> {\n-    fn from(s: &'s str) -> Self {\n-        Self { path: strip_prefixes_suffixes(s), namespace: Namespace::from_intra_spec(s) }\n-    }\n-}\n-\n-#[derive(PartialEq, Eq, Hash, Copy, Clone, Debug)]\n-enum Namespace {\n-    Types,\n-    Values,\n-    Macros,\n-}\n-\n-static TYPES: ([&str; 7], [&str; 0]) =\n-    ([\"type\", \"struct\", \"enum\", \"mod\", \"trait\", \"union\", \"module\"], []);\n-static VALUES: ([&str; 8], [&str; 1]) =\n-    ([\"value\", \"function\", \"fn\", \"method\", \"const\", \"static\", \"mod\", \"module\"], [\"()\"]);\n-static MACROS: ([&str; 1], [&str; 1]) = ([\"macro\"], [\"!\"]);\n-\n-impl Namespace {\n-    /// Extract the specified namespace from an intra-doc-link if one exists.\n-    ///\n-    /// # Examples\n-    ///\n-    /// * `struct MyStruct` -> `Namespace::Types`\n-    /// * `panic!` -> `Namespace::Macros`\n-    /// * `fn@from_intra_spec` -> `Namespace::Values`\n-    fn from_intra_spec(s: &str) -> Option<Self> {\n-        [\n-            (Namespace::Types, (TYPES.0.iter(), TYPES.1.iter())),\n-            (Namespace::Values, (VALUES.0.iter(), VALUES.1.iter())),\n-            (Namespace::Macros, (MACROS.0.iter(), MACROS.1.iter())),\n-        ]\n-        .iter()\n-        .filter(|(_ns, (prefixes, suffixes))| {\n-            prefixes\n-                .clone()\n-                .map(|prefix| {\n-                    s.starts_with(*prefix)\n-                        && s.chars()\n-                            .nth(prefix.len() + 1)\n-                            .map(|c| c == '@' || c == ' ')\n-                            .unwrap_or(false)\n-                })\n-                .any(|cond| cond)\n-                || suffixes\n-                    .clone()\n-                    .map(|suffix| {\n-                        s.starts_with(*suffix)\n-                            && s.chars()\n-                                .nth(suffix.len() + 1)\n-                                .map(|c| c == '@' || c == ' ')\n-                                .unwrap_or(false)\n-                    })\n-                    .any(|cond| cond)\n-        })\n-        .map(|(ns, (_, _))| *ns)\n-        .next()\n-    }\n-}\n-\n-/// Sealed trait used solely for the generic bound on [`resolve_doc_link`].\n-pub trait Resolvable {\n-    fn resolver(&self, db: &dyn HirDatabase) -> Option<Resolver>;\n-    fn try_into_module_def(self) -> Option<ModuleDef>;\n-}"}, {"sha": "b9d9c7e2513c55e71ca75a1a9f3b462eeb650a5c", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8a59adf5e9633aa5d10efcdbf70b408d280ef01/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8a59adf5e9633aa5d10efcdbf70b408d280ef01/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=f8a59adf5e9633aa5d10efcdbf70b408d280ef01", "patch": "@@ -27,19 +27,17 @@ pub mod diagnostics;\n \n mod from_id;\n mod code_model;\n-mod doc_links;\n mod attrs;\n mod has_source;\n \n pub use crate::{\n-    attrs::HasAttrs,\n+    attrs::{HasAttrs, Namespace},\n     code_model::{\n         Access, Adt, AsAssocItem, AssocItem, AssocItemContainer, Callable, CallableKind, Const,\n         Crate, CrateDependency, DefWithBody, Enum, EnumVariant, Field, FieldSource, Function,\n         GenericDef, HasVisibility, ImplDef, Local, MacroDef, Module, ModuleDef, ScopeDef, Static,\n         Struct, Trait, Type, TypeAlias, TypeParam, Union, VariantDef, Visibility,\n     },\n-    doc_links::resolve_doc_link,\n     has_source::HasSource,\n     semantics::{original_range, PathResolution, Semantics, SemanticsScope},\n };"}, {"sha": "a15f704ca482a137e80049e48525d53e7105d99d", "filename": "crates/ide/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f8a59adf5e9633aa5d10efcdbf70b408d280ef01/crates%2Fide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f8a59adf5e9633aa5d10efcdbf70b408d280ef01/crates%2Fide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2FCargo.toml?ref=f8a59adf5e9633aa5d10efcdbf70b408d280ef01", "patch": "@@ -18,6 +18,7 @@ rustc-hash = \"1.1.0\"\n oorandom = \"11.1.2\"\n pulldown-cmark-to-cmark = \"5.0.0\"\n pulldown-cmark = {version = \"0.7.2\", default-features = false}\n+url = \"2.1.1\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n syntax = { path = \"../syntax\", version = \"0.0.0\" }"}, {"sha": "efec0184e2703ed3adfd1245e75220a14c1eafea", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f8a59adf5e9633aa5d10efcdbf70b408d280ef01/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8a59adf5e9633aa5d10efcdbf70b408d280ef01/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=f8a59adf5e9633aa5d10efcdbf70b408d280ef01", "patch": "@@ -1755,6 +1755,60 @@ pub struct B<|>ar\n         );\n     }\n \n+    #[test]\n+    fn test_doc_links_enum_variant() {\n+        check(\n+            r#\"\n+enum E {\n+    /// [E]\n+    V<|> { field: i32 }\n+}\n+\"#,\n+            expect![[r#\"\n+                *V*\n+\n+                ```rust\n+                test::E\n+                ```\n+\n+                ```rust\n+                V\n+                ```\n+\n+                ---\n+\n+                [E](https://docs.rs/test/*/test/enum.E.html)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_doc_links_field() {\n+        check(\n+            r#\"\n+struct S {\n+    /// [`S`]\n+    field<|>: i32\n+}\n+\"#,\n+            expect![[r#\"\n+                *field*\n+\n+                ```rust\n+                test::S\n+                ```\n+\n+                ```rust\n+                field: i32\n+                ```\n+\n+                ---\n+\n+                [`S`](https://docs.rs/test/*/test/struct.S.html)\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn test_hover_macro_generated_struct_fn_doc_comment() {\n         mark::check!(hover_macro_generated_struct_fn_doc_comment);"}, {"sha": "acedea71bd5eef8f92953ea895efdbf80e6ca64a", "filename": "crates/ide/src/link_rewrite.rs", "status": "modified", "additions": 176, "deletions": 15, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/f8a59adf5e9633aa5d10efcdbf70b408d280ef01/crates%2Fide%2Fsrc%2Flink_rewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8a59adf5e9633aa5d10efcdbf70b408d280ef01/crates%2Fide%2Fsrc%2Flink_rewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flink_rewrite.rs?ref=f8a59adf5e9633aa5d10efcdbf70b408d280ef01", "patch": "@@ -2,11 +2,11 @@\n //!\n //! Most of the implementation can be found in [`hir::doc_links`].\n \n+use hir::{Adt, Crate, HasAttrs, ModuleDef};\n+use ide_db::{defs::Definition, RootDatabase};\n use pulldown_cmark::{CowStr, Event, Options, Parser, Tag};\n use pulldown_cmark_to_cmark::{cmark_with_options, Options as CmarkOptions};\n-\n-use hir::resolve_doc_link;\n-use ide_db::{defs::Definition, RootDatabase};\n+use url::Url;\n \n /// Rewrite documentation links in markdown to point to an online host (e.g. docs.rs)\n pub fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Definition) -> String {\n@@ -26,19 +26,16 @@ pub fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Definition)\n             // Two posibilities:\n             // * path-based links: `../../module/struct.MyStruct.html`\n             // * module-based links (AKA intra-doc links): `super::super::module::MyStruct`\n-            let resolved = match definition {\n-                Definition::ModuleDef(t) => resolve_doc_link(db, t, title, target),\n-                Definition::Macro(t) => resolve_doc_link(db, t, title, target),\n-                Definition::Field(t) => resolve_doc_link(db, t, title, target),\n-                Definition::SelfType(t) => resolve_doc_link(db, t, title, target),\n-                Definition::Local(t) => resolve_doc_link(db, t, title, target),\n-                Definition::TypeParam(t) => resolve_doc_link(db, t, title, target),\n-            };\n-\n-            match resolved {\n-                Some((target, title)) => (target, title),\n-                None => (target.to_string(), title.to_string()),\n+            if let Some(rewritten) = rewrite_intra_doc_link(db, *definition, target, title) {\n+                return rewritten;\n+            }\n+            if let Definition::ModuleDef(def) = *definition {\n+                if let Some(target) = rewrite_url_link(db, def, target) {\n+                    return (target, title.to_string());\n+                }\n             }\n+\n+            (target.to_string(), title.to_string())\n         }\n     });\n     let mut out = String::new();\n@@ -48,6 +45,64 @@ pub fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Definition)\n     out\n }\n \n+fn rewrite_intra_doc_link(\n+    db: &RootDatabase,\n+    def: Definition,\n+    target: &str,\n+    title: &str,\n+) -> Option<(String, String)> {\n+    let link = if target.is_empty() { title } else { target };\n+    let (link, ns) = parse_link(link);\n+    let resolved = match def {\n+        Definition::ModuleDef(def) => match def {\n+            ModuleDef::Module(it) => it.resolve_doc_path(db, link, ns),\n+            ModuleDef::Function(it) => it.resolve_doc_path(db, link, ns),\n+            ModuleDef::Adt(it) => it.resolve_doc_path(db, link, ns),\n+            ModuleDef::EnumVariant(it) => it.resolve_doc_path(db, link, ns),\n+            ModuleDef::Const(it) => it.resolve_doc_path(db, link, ns),\n+            ModuleDef::Static(it) => it.resolve_doc_path(db, link, ns),\n+            ModuleDef::Trait(it) => it.resolve_doc_path(db, link, ns),\n+            ModuleDef::TypeAlias(it) => it.resolve_doc_path(db, link, ns),\n+            ModuleDef::BuiltinType(_) => return None,\n+        },\n+        Definition::Macro(it) => it.resolve_doc_path(db, link, ns),\n+        Definition::Field(it) => it.resolve_doc_path(db, link, ns),\n+        Definition::SelfType(_) | Definition::Local(_) | Definition::TypeParam(_) => return None,\n+    }?;\n+    let krate = resolved.module(db)?.krate();\n+    let canonical_path = resolved.canonical_path(db)?;\n+    let new_target = get_doc_url(db, &krate)?\n+        .join(&format!(\"{}/\", krate.display_name(db)?))\n+        .ok()?\n+        .join(&canonical_path.replace(\"::\", \"/\"))\n+        .ok()?\n+        .join(&get_symbol_filename(db, &resolved)?)\n+        .ok()?\n+        .into_string();\n+    let new_title = strip_prefixes_suffixes(title);\n+    Some((new_target, new_title.to_string()))\n+}\n+\n+/// Try to resolve path to local documentation via path-based links (i.e. `../gateway/struct.Shard.html`).\n+fn rewrite_url_link(db: &RootDatabase, def: ModuleDef, target: &str) -> Option<String> {\n+    if !(target.contains(\"#\") || target.contains(\".html\")) {\n+        return None;\n+    }\n+\n+    let module = def.module(db)?;\n+    let krate = module.krate();\n+    let canonical_path = def.canonical_path(db)?;\n+    let base = format!(\"{}/{}\", krate.display_name(db)?, canonical_path.replace(\"::\", \"/\"));\n+\n+    get_doc_url(db, &krate)\n+        .and_then(|url| url.join(&base).ok())\n+        .and_then(|url| {\n+            get_symbol_filename(db, &def).as_deref().map(|f| url.join(f).ok()).flatten()\n+        })\n+        .and_then(|url| url.join(target).ok())\n+        .map(|url| url.into_string())\n+}\n+\n // Rewrites a markdown document, resolving links using `callback` and additionally striping prefixes/suffixes on link titles.\n fn map_links<'e>(\n     events: impl Iterator<Item = Event<'e>>,\n@@ -79,3 +134,109 @@ fn map_links<'e>(\n         _ => evt,\n     })\n }\n+\n+fn parse_link(s: &str) -> (&str, Option<hir::Namespace>) {\n+    let path = strip_prefixes_suffixes(s);\n+    let ns = ns_from_intra_spec(s);\n+    (path, ns)\n+}\n+\n+/// Strip prefixes, suffixes, and inline code marks from the given string.\n+fn strip_prefixes_suffixes(mut s: &str) -> &str {\n+    s = s.trim_matches('`');\n+\n+    [\n+        (TYPES.0.iter(), TYPES.1.iter()),\n+        (VALUES.0.iter(), VALUES.1.iter()),\n+        (MACROS.0.iter(), MACROS.1.iter()),\n+    ]\n+    .iter()\n+    .for_each(|(prefixes, suffixes)| {\n+        prefixes.clone().for_each(|prefix| s = s.trim_start_matches(*prefix));\n+        suffixes.clone().for_each(|suffix| s = s.trim_end_matches(*suffix));\n+    });\n+    s.trim_start_matches(\"@\").trim()\n+}\n+\n+static TYPES: ([&str; 7], [&str; 0]) =\n+    ([\"type\", \"struct\", \"enum\", \"mod\", \"trait\", \"union\", \"module\"], []);\n+static VALUES: ([&str; 8], [&str; 1]) =\n+    ([\"value\", \"function\", \"fn\", \"method\", \"const\", \"static\", \"mod\", \"module\"], [\"()\"]);\n+static MACROS: ([&str; 1], [&str; 1]) = ([\"macro\"], [\"!\"]);\n+\n+/// Extract the specified namespace from an intra-doc-link if one exists.\n+///\n+/// # Examples\n+///\n+/// * `struct MyStruct` -> `Namespace::Types`\n+/// * `panic!` -> `Namespace::Macros`\n+/// * `fn@from_intra_spec` -> `Namespace::Values`\n+fn ns_from_intra_spec(s: &str) -> Option<hir::Namespace> {\n+    [\n+        (hir::Namespace::Types, (TYPES.0.iter(), TYPES.1.iter())),\n+        (hir::Namespace::Values, (VALUES.0.iter(), VALUES.1.iter())),\n+        (hir::Namespace::Macros, (MACROS.0.iter(), MACROS.1.iter())),\n+    ]\n+    .iter()\n+    .filter(|(_ns, (prefixes, suffixes))| {\n+        prefixes\n+            .clone()\n+            .map(|prefix| {\n+                s.starts_with(*prefix)\n+                    && s.chars()\n+                        .nth(prefix.len() + 1)\n+                        .map(|c| c == '@' || c == ' ')\n+                        .unwrap_or(false)\n+            })\n+            .any(|cond| cond)\n+            || suffixes\n+                .clone()\n+                .map(|suffix| {\n+                    s.starts_with(*suffix)\n+                        && s.chars()\n+                            .nth(suffix.len() + 1)\n+                            .map(|c| c == '@' || c == ' ')\n+                            .unwrap_or(false)\n+                })\n+                .any(|cond| cond)\n+    })\n+    .map(|(ns, (_, _))| *ns)\n+    .next()\n+}\n+\n+fn get_doc_url(db: &RootDatabase, krate: &Crate) -> Option<Url> {\n+    krate\n+        .get_html_root_url(db)\n+        .or_else(|| {\n+            // Fallback to docs.rs. This uses `display_name` and can never be\n+            // correct, but that's what fallbacks are about.\n+            //\n+            // FIXME: clicking on the link should just open the file in the editor,\n+            // instead of falling back to external urls.\n+            Some(format!(\"https://docs.rs/{}/*/\", krate.display_name(db)?))\n+        })\n+        .and_then(|s| Url::parse(&s).ok())\n+}\n+\n+/// Get the filename and extension generated for a symbol by rustdoc.\n+///\n+/// Example: `struct.Shard.html`\n+fn get_symbol_filename(db: &RootDatabase, definition: &ModuleDef) -> Option<String> {\n+    Some(match definition {\n+        ModuleDef::Adt(adt) => match adt {\n+            Adt::Struct(s) => format!(\"struct.{}.html\", s.name(db)),\n+            Adt::Enum(e) => format!(\"enum.{}.html\", e.name(db)),\n+            Adt::Union(u) => format!(\"union.{}.html\", u.name(db)),\n+        },\n+        ModuleDef::Module(_) => \"index.html\".to_string(),\n+        ModuleDef::Trait(t) => format!(\"trait.{}.html\", t.name(db)),\n+        ModuleDef::TypeAlias(t) => format!(\"type.{}.html\", t.name(db)),\n+        ModuleDef::BuiltinType(t) => format!(\"primitive.{}.html\", t),\n+        ModuleDef::Function(f) => format!(\"fn.{}.html\", f.name(db)),\n+        ModuleDef::EnumVariant(ev) => {\n+            format!(\"enum.{}.html#variant.{}\", ev.parent_enum(db).name(db), ev.name(db))\n+        }\n+        ModuleDef::Const(c) => format!(\"const.{}.html\", c.name(db)?),\n+        ModuleDef::Static(s) => format!(\"static.{}.html\", s.name(db)?),\n+    })\n+}"}]}