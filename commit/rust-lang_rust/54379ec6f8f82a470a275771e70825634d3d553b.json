{"sha": "54379ec6f8f82a470a275771e70825634d3d553b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0Mzc5ZWM2ZjhmODJhNDcwYTI3NTc3MWU3MDgyNTYzNGQzZDU1M2I=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-09-17T21:16:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-17T21:16:28Z"}, "message": "Merge #1862\n\n1862: Assoc item resolution refactoring (again) r=flodiebold a=flodiebold\n\nThis is #1849, with the associated type selection code removed for now. Handling cycles there will need some more thought.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "498719aafe633f9eb9cb65ba65932076981e4632", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/498719aafe633f9eb9cb65ba65932076981e4632"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54379ec6f8f82a470a275771e70825634d3d553b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdgU0sCRBK7hj4Ov3rIwAAdHIIADlfxzvJoa428p9eXSVh2x5X\nGYQjK1RWNI9QbDQdzyCFLGJHuTz2c7uubdb5O28pKPOQgEu5kxIf32kHP19ZnVBj\nk6AP5dmn5jmnB3HpqZQbDzjLvdYXwNJaRSjse/XEJciqcjZQN9DUp8TgXX234wEk\nmZSUF7JA4skoCt5NFepI47GQ01EZ7FWMpkfXi/1R0/AYCLu5wi2x/0lluA7dWhBW\n6hKZQsiYOzf423okc8uPzRl9YwrnYQWW1aDxyUCSaR2qmbdyv275VjGyS+1lKJr7\nM9eXRdgKEfWyKs/rgU9ZyllzihhWMXpJonsyt4zC7R1rqgMQeBduGNJASJbw0J8=\n=THdw\n-----END PGP SIGNATURE-----\n", "payload": "tree 498719aafe633f9eb9cb65ba65932076981e4632\nparent d505ee968b2a99eed65dfe7be27940ad9b2647c1\nparent c2f9558e1af8dbf73ff86eeffcb9ea6940947dd6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1568754988 +0000\ncommitter GitHub <noreply@github.com> 1568754988 +0000\n\nMerge #1862\n\n1862: Assoc item resolution refactoring (again) r=flodiebold a=flodiebold\n\nThis is #1849, with the associated type selection code removed for now. Handling cycles there will need some more thought.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54379ec6f8f82a470a275771e70825634d3d553b", "html_url": "https://github.com/rust-lang/rust/commit/54379ec6f8f82a470a275771e70825634d3d553b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54379ec6f8f82a470a275771e70825634d3d553b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d505ee968b2a99eed65dfe7be27940ad9b2647c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/d505ee968b2a99eed65dfe7be27940ad9b2647c1", "html_url": "https://github.com/rust-lang/rust/commit/d505ee968b2a99eed65dfe7be27940ad9b2647c1"}, {"sha": "c2f9558e1af8dbf73ff86eeffcb9ea6940947dd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2f9558e1af8dbf73ff86eeffcb9ea6940947dd6", "html_url": "https://github.com/rust-lang/rust/commit/c2f9558e1af8dbf73ff86eeffcb9ea6940947dd6"}], "stats": {"total": 619, "additions": 358, "deletions": 261}, "files": [{"sha": "6b1e44a2c5f5edda4f2ecb9a6f183f18162cdf38", "filename": "crates/ra_cli/src/analysis_stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs?ref=54379ec6f8f82a470a275771e70825634d3d553b", "patch": "@@ -1,7 +1,7 @@\n use std::{collections::HashSet, fmt::Write, path::Path, time::Instant};\n \n use ra_db::SourceDatabase;\n-use ra_hir::{Crate, HasBodySource, HasSource, HirDisplay, ImplItem, ModuleDef, Ty, TypeWalk};\n+use ra_hir::{AssocItem, Crate, HasBodySource, HasSource, HirDisplay, ModuleDef, Ty, TypeWalk};\n use ra_syntax::AstNode;\n \n use crate::{Result, Verbosity};\n@@ -47,7 +47,7 @@ pub fn run(\n             for impl_block in module.impl_blocks(db) {\n                 for item in impl_block.items(db) {\n                     num_decls += 1;\n-                    if let ImplItem::Method(f) = item {\n+                    if let AssocItem::Function(f) = item {\n                         funcs.push(f);\n                     }\n                 }"}, {"sha": "706d24c32501753e35e8583e7701b5306af93646", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=54379ec6f8f82a470a275771e70825634d3d553b", "patch": "@@ -23,7 +23,7 @@ use crate::{\n     },\n     nameres::{CrateModuleId, ImportId, ModuleScope, Namespace},\n     resolve::{Resolver, TypeNs},\n-    traits::{TraitData, TraitItem},\n+    traits::TraitData,\n     ty::{\n         primitive::{FloatBitness, FloatTy, IntBitness, IntTy, Signedness},\n         InferenceResult, TraitRef,\n@@ -269,7 +269,7 @@ impl Module {\n \n         for impl_block in self.impl_blocks(db) {\n             for item in impl_block.items(db) {\n-                if let crate::ImplItem::Method(f) = item {\n+                if let AssocItem::Function(f) = item {\n                     f.diagnostics(db, sink);\n                 }\n             }\n@@ -749,6 +749,10 @@ impl Const {\n         db.const_data(self)\n     }\n \n+    pub fn name(&self, db: &impl HirDatabase) -> Option<Name> {\n+        self.data(db).name().cloned()\n+    }\n+\n     pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n         db.infer(self.into())\n     }\n@@ -849,7 +853,7 @@ impl Trait {\n         self.trait_data(db).name().clone()\n     }\n \n-    pub fn items(self, db: &impl DefDatabase) -> Vec<TraitItem> {\n+    pub fn items(self, db: &impl DefDatabase) -> Vec<AssocItem> {\n         self.trait_data(db).items().to_vec()\n     }\n \n@@ -902,7 +906,7 @@ impl Trait {\n             .items()\n             .iter()\n             .filter_map(|item| match item {\n-                TraitItem::TypeAlias(t) => Some(*t),\n+                AssocItem::TypeAlias(t) => Some(*t),\n                 _ => None,\n             })\n             .find(|t| &t.name(db) == name)\n@@ -1019,3 +1023,15 @@ impl Container {\n         }\n     }\n }\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub enum AssocItem {\n+    Function(Function),\n+    Const(Const),\n+    TypeAlias(TypeAlias),\n+}\n+// FIXME: not every function, ... is actually an assoc item. maybe we should make\n+// sure that you can only turn actual assoc items into AssocItems. This would\n+// require not implementing From, and instead having some checked way of\n+// casting them, and somehow making the constructors private, which would be annoying.\n+impl_froms!(AssocItem: Function, Const, TypeAlias);"}, {"sha": "c463d351cf16ff02e8d6e1349966a37197f011f5", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=54379ec6f8f82a470a275771e70825634d3d553b", "patch": "@@ -15,7 +15,7 @@ use crate::{\n     resolve::Resolver,\n     ty::Ty,\n     type_ref::TypeRef,\n-    Const, Function, HasSource, HirFileId, Source, TraitRef, TypeAlias,\n+    AssocItem, Const, Function, HasSource, HirFileId, Source, TraitRef, TypeAlias,\n };\n \n #[derive(Debug, Default, PartialEq, Eq)]\n@@ -56,7 +56,7 @@ impl HasSource for ImplBlock {\n impl ImplBlock {\n     pub(crate) fn containing(\n         module_impl_blocks: Arc<ModuleImplBlocks>,\n-        item: ImplItem,\n+        item: AssocItem,\n     ) -> Option<ImplBlock> {\n         let impl_id = *module_impl_blocks.impls_by_def.get(&item)?;\n         Some(ImplBlock { module: module_impl_blocks.module, impl_id })\n@@ -91,7 +91,7 @@ impl ImplBlock {\n         TraitRef::from_hir(db, &self.resolver(db), &self.target_trait(db)?, Some(target_ty))\n     }\n \n-    pub fn items(&self, db: &impl DefDatabase) -> Vec<ImplItem> {\n+    pub fn items(&self, db: &impl DefDatabase) -> Vec<AssocItem> {\n         db.impls_in_module(self.module).impls[self.impl_id].items().to_vec()\n     }\n \n@@ -113,7 +113,7 @@ impl ImplBlock {\n pub struct ImplData {\n     target_trait: Option<TypeRef>,\n     target_type: TypeRef,\n-    items: Vec<ImplItem>,\n+    items: Vec<AssocItem>,\n     negative: bool,\n }\n \n@@ -151,27 +151,11 @@ impl ImplData {\n         &self.target_type\n     }\n \n-    pub fn items(&self) -> &[ImplItem] {\n+    pub fn items(&self) -> &[AssocItem] {\n         &self.items\n     }\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-//FIXME: rename to ImplDef?\n-pub enum ImplItem {\n-    Method(Function),\n-    Const(Const),\n-    TypeAlias(TypeAlias),\n-    // Existential\n-}\n-impl_froms!(ImplItem: Const, TypeAlias);\n-\n-impl From<Function> for ImplItem {\n-    fn from(func: Function) -> ImplItem {\n-        ImplItem::Method(func)\n-    }\n-}\n-\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct ImplId(pub RawId);\n impl_arena_id!(ImplId);\n@@ -185,7 +169,7 @@ impl_arena_id!(ImplId);\n pub struct ModuleImplBlocks {\n     pub(crate) module: Module,\n     pub(crate) impls: Arena<ImplId, ImplData>,\n-    impls_by_def: FxHashMap<ImplItem, ImplId>,\n+    impls_by_def: FxHashMap<AssocItem, ImplId>,\n }\n \n impl ModuleImplBlocks {"}, {"sha": "e7a576aa0a7d111afd9b8971f3e36452a6f08829", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=54379ec6f8f82a470a275771e70825634d3d553b", "patch": "@@ -69,7 +69,7 @@ pub use self::{\n     expr::ExprScopes,\n     generics::{GenericParam, GenericParams, HasGenericParams},\n     ids::{HirFileId, MacroCallId, MacroCallLoc, MacroDefId, MacroFile},\n-    impl_block::{ImplBlock, ImplItem},\n+    impl_block::ImplBlock,\n     name::Name,\n     nameres::{ImportId, Namespace, PerNs},\n     path::{Path, PathKind},\n@@ -85,7 +85,7 @@ pub use self::{\n pub use self::code_model::{\n     docs::{DocDef, Docs, Documentation},\n     src::{HasBodySource, HasSource, Source},\n-    Adt, BuiltinType, Const, ConstData, Container, Crate, CrateDependency, DefWithBody, Enum,\n-    EnumVariant, FieldSource, FnData, Function, HasBody, MacroDef, Module, ModuleDef, ModuleSource,\n-    Static, Struct, StructField, Trait, TypeAlias, Union,\n+    Adt, AssocItem, BuiltinType, Const, ConstData, Container, Crate, CrateDependency, DefWithBody,\n+    Enum, EnumVariant, FieldSource, FnData, Function, HasBody, MacroDef, Module, ModuleDef,\n+    ModuleSource, Static, Struct, StructField, Trait, TypeAlias, Union,\n };"}, {"sha": "39d1b7e46f3b976fa83cf206824da2342ded6f6d", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=54379ec6f8f82a470a275771e70825634d3d553b", "patch": "@@ -190,6 +190,13 @@ impl Path {\n     pub fn expand_macro_expr(&self) -> Option<Name> {\n         self.as_ident().and_then(|name| Some(name.clone()))\n     }\n+\n+    pub fn is_type_relative(&self) -> bool {\n+        match self.kind {\n+            PathKind::Type(_) => true,\n+            _ => false,\n+        }\n+    }\n }\n \n impl GenericArgs {"}, {"sha": "a23c8792ad84c89b10718cb03511ed1e5eaac49e", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=54379ec6f8f82a470a275771e70825634d3d553b", "patch": "@@ -15,7 +15,6 @@ use crate::{\n     name::{Name, SELF_PARAM, SELF_TYPE},\n     nameres::{CrateDefMap, CrateModuleId, PerNs},\n     path::{Path, PathKind},\n-    type_ref::TypeRef,\n     Adt, BuiltinType, Const, Enum, EnumVariant, Function, MacroDef, ModuleDef, Static, Struct,\n     Trait, TypeAlias,\n };\n@@ -50,7 +49,7 @@ pub(crate) enum Scope {\n     ExprScope(ExprScope),\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum TypeNs {\n     SelfType(ImplBlock),\n     GenericParam(u32),\n@@ -59,19 +58,18 @@ pub enum TypeNs {\n     TypeAlias(TypeAlias),\n     BuiltinType(BuiltinType),\n     Trait(Trait),\n-    // Module belong to type ns, but the resovler is used when all module paths\n+    // Module belong to type ns, but the resolver is used when all module paths\n     // are fully resolved.\n     // Module(Module)\n }\n \n-#[derive(Debug)]\n-pub enum ResolveValueResult<'a> {\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum ResolveValueResult {\n     ValueNs(ValueNs),\n     Partial(TypeNs, usize),\n-    TypeRef(&'a TypeRef),\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum ValueNs {\n     LocalBinding(PatId),\n     Function(Function),\n@@ -131,6 +129,9 @@ impl Resolver {\n         db: &impl HirDatabase,\n         path: &Path,\n     ) -> Option<(TypeNs, Option<usize>)> {\n+        if path.is_type_relative() {\n+            return None;\n+        }\n         let first_name = &path.segments.first()?.name;\n         let skip_to_mod = path.kind != PathKind::Plain;\n         for scope in self.scopes.iter().rev() {\n@@ -189,11 +190,10 @@ impl Resolver {\n         &self,\n         db: &impl HirDatabase,\n         path: &'p Path,\n-    ) -> Option<ResolveValueResult<'p>> {\n-        if let PathKind::Type(type_ref) = &path.kind {\n-            return Some(ResolveValueResult::TypeRef(type_ref));\n+    ) -> Option<ResolveValueResult> {\n+        if path.is_type_relative() {\n+            return None;\n         }\n-\n         let n_segments = path.segments.len();\n         let tmp = SELF_PARAM;\n         let first_name = if path.is_self() { &tmp } else { &path.segments.first()?.name };\n@@ -284,7 +284,7 @@ impl Resolver {\n     ) -> Option<ValueNs> {\n         match self.resolve_path_in_value_ns(db, path)? {\n             ResolveValueResult::ValueNs(it) => Some(it),\n-            ResolveValueResult::Partial(..) | ResolveValueResult::TypeRef(_) => None,\n+            ResolveValueResult::Partial(..) => None,\n         }\n     }\n "}, {"sha": "4d895f0a1964bba9cf1054d5b91b4023710a62da", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=54379ec6f8f82a470a275771e70825634d3d553b", "patch": "@@ -190,7 +190,7 @@ pub enum PathResolution {\n     GenericParam(u32),\n     SelfType(crate::ImplBlock),\n     Macro(MacroDef),\n-    AssocItem(crate::ImplItem),\n+    AssocItem(crate::AssocItem),\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]"}, {"sha": "e39511518d10031a4db48c20ed7a2ab38f910fc5", "filename": "crates/ra_hir/src/traits.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftraits.rs?ref=54379ec6f8f82a470a275771e70825634d3d553b", "patch": "@@ -9,13 +9,13 @@ use crate::{\n     db::{AstDatabase, DefDatabase},\n     ids::LocationCtx,\n     name::AsName,\n-    Const, Function, HasSource, Module, Name, Trait, TypeAlias,\n+    AssocItem, Const, Function, HasSource, Module, Name, Trait, TypeAlias,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct TraitData {\n     name: Option<Name>,\n-    items: Vec<TraitItem>,\n+    items: Vec<AssocItem>,\n     auto: bool,\n }\n \n@@ -48,7 +48,7 @@ impl TraitData {\n         &self.name\n     }\n \n-    pub(crate) fn items(&self) -> &[TraitItem] {\n+    pub(crate) fn items(&self) -> &[AssocItem] {\n         &self.items\n     }\n \n@@ -57,22 +57,9 @@ impl TraitData {\n     }\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub enum TraitItem {\n-    Function(Function),\n-    Const(Const),\n-    TypeAlias(TypeAlias),\n-    // Existential\n-}\n-// FIXME: not every function, ... is actually a trait item. maybe we should make\n-// sure that you can only turn actual trait items into TraitItems. This would\n-// require not implementing From, and instead having some checked way of\n-// casting them.\n-impl_froms!(TraitItem: Function, Const, TypeAlias);\n-\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct TraitItemsIndex {\n-    traits_by_def: FxHashMap<TraitItem, Trait>,\n+    traits_by_def: FxHashMap<AssocItem, Trait>,\n }\n \n impl TraitItemsIndex {\n@@ -88,7 +75,7 @@ impl TraitItemsIndex {\n         index\n     }\n \n-    pub(crate) fn get_parent_trait(&self, item: TraitItem) -> Option<Trait> {\n+    pub(crate) fn get_parent_trait(&self, item: AssocItem) -> Option<Trait> {\n         self.traits_by_def.get(&item).cloned()\n     }\n }"}, {"sha": "70da7f3113adf4f43833cc740bc00b184aca5257", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 94, "deletions": 94, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=54379ec6f8f82a470a275771e70825634d3d553b", "patch": "@@ -48,8 +48,7 @@ use crate::{\n     resolve::{ResolveValueResult, Resolver, TypeNs, ValueNs},\n     ty::infer::diagnostics::InferenceDiagnostic,\n     type_ref::{Mutability, TypeRef},\n-    Adt, ConstData, DefWithBody, Either, FnData, Function, HasBody, ImplItem, Name, Path,\n-    StructField,\n+    Adt, AssocItem, ConstData, DefWithBody, FnData, Function, HasBody, Name, Path, StructField,\n };\n \n mod unify;\n@@ -121,7 +120,7 @@ pub struct InferenceResult {\n     /// For each struct literal, records the variant it resolves to.\n     variant_resolutions: FxHashMap<ExprOrPatId, VariantDef>,\n     /// For each associated item record what it resolves to\n-    assoc_resolutions: FxHashMap<ExprOrPatId, ImplItem>,\n+    assoc_resolutions: FxHashMap<ExprOrPatId, AssocItem>,\n     diagnostics: Vec<InferenceDiagnostic>,\n     pub(super) type_of_expr: ArenaMap<ExprId, Ty>,\n     pub(super) type_of_pat: ArenaMap<PatId, Ty>,\n@@ -141,10 +140,10 @@ impl InferenceResult {\n     pub fn variant_resolution_for_pat(&self, id: PatId) -> Option<VariantDef> {\n         self.variant_resolutions.get(&id.into()).copied()\n     }\n-    pub fn assoc_resolutions_for_expr(&self, id: ExprId) -> Option<ImplItem> {\n+    pub fn assoc_resolutions_for_expr(&self, id: ExprId) -> Option<AssocItem> {\n         self.assoc_resolutions.get(&id.into()).copied()\n     }\n-    pub fn assoc_resolutions_for_pat(&self, id: PatId) -> Option<ImplItem> {\n+    pub fn assoc_resolutions_for_pat(&self, id: PatId) -> Option<AssocItem> {\n         self.assoc_resolutions.get(&id.into()).copied()\n     }\n     pub fn type_mismatch_for_expr(&self, expr: ExprId) -> Option<&TypeMismatch> {\n@@ -235,7 +234,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.result.variant_resolutions.insert(id, variant);\n     }\n \n-    fn write_assoc_resolution(&mut self, id: ExprOrPatId, item: ImplItem) {\n+    fn write_assoc_resolution(&mut self, id: ExprOrPatId, item: AssocItem) {\n         self.result.assoc_resolutions.insert(id, item);\n     }\n \n@@ -468,16 +467,27 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n \n     fn infer_path_expr(&mut self, resolver: &Resolver, path: &Path, id: ExprOrPatId) -> Option<Ty> {\n-        let value_or_partial = resolver.resolve_path_in_value_ns(self.db, &path)?;\n-\n-        let (value, self_subst) = match value_or_partial {\n-            ResolveValueResult::ValueNs(it) => (it, None),\n-            ResolveValueResult::Partial(def, remaining_index) => {\n-                self.resolve_assoc_item(Either::A(def), path, remaining_index, id)?\n+        let (value, self_subst) = if let crate::PathKind::Type(type_ref) = &path.kind {\n+            if path.segments.is_empty() {\n+                // This can't actually happen syntax-wise\n+                return None;\n             }\n-            ResolveValueResult::TypeRef(type_ref) => {\n-                let ty = self.make_ty(type_ref);\n-                self.resolve_assoc_item(Either::B(ty), path, 0, id)?\n+            let ty = self.make_ty(type_ref);\n+            let remaining_segments_for_ty = &path.segments[..path.segments.len() - 1];\n+            let ty = Ty::from_type_relative_path(self.db, resolver, ty, remaining_segments_for_ty);\n+            self.resolve_ty_assoc_item(\n+                ty,\n+                path.segments.last().expect(\"path had at least one segment\"),\n+                id,\n+            )?\n+        } else {\n+            let value_or_partial = resolver.resolve_path_in_value_ns(self.db, &path)?;\n+\n+            match value_or_partial {\n+                ResolveValueResult::ValueNs(it) => (it, None),\n+                ResolveValueResult::Partial(def, remaining_index) => {\n+                    self.resolve_assoc_item(def, path, remaining_index, id)?\n+                }\n             }\n         };\n \n@@ -508,101 +518,91 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n     fn resolve_assoc_item(\n         &mut self,\n-        mut def_or_ty: Either<TypeNs, Ty>,\n+        def: TypeNs,\n         path: &Path,\n         remaining_index: usize,\n         id: ExprOrPatId,\n     ) -> Option<(ValueNs, Option<Substs>)> {\n         assert!(remaining_index < path.segments.len());\n-        let krate = self.resolver.krate()?;\n-\n-        let mut ty = Ty::Unknown;\n-\n-        // resolve intermediate segments\n-        for (i, segment) in path.segments[remaining_index..].iter().enumerate() {\n-            let is_last_segment = i == path.segments[remaining_index..].len() - 1;\n-            ty = match def_or_ty {\n-                Either::A(def) => {\n-                    let typable: TypableDef = match def {\n-                        TypeNs::Adt(it) => it.into(),\n-                        TypeNs::TypeAlias(it) => it.into(),\n-                        TypeNs::BuiltinType(it) => it.into(),\n-                        // FIXME associated item of traits, generics, and Self\n-                        TypeNs::Trait(_) | TypeNs::GenericParam(_) | TypeNs::SelfType(_) => {\n-                            return None;\n-                        }\n-                        // FIXME: report error here\n-                        TypeNs::EnumVariant(_) => return None,\n-                    };\n-\n-                    let ty = self.db.type_for_def(typable, Namespace::Types);\n-\n-                    // For example, this substs will take `Gen::*<u32>*::make`\n-                    assert!(remaining_index > 0);\n-                    let substs = Ty::substs_from_path_segment(\n-                        self.db,\n-                        &self.resolver,\n-                        &path.segments[remaining_index + i - 1],\n-                        typable,\n-                    );\n-                    ty.subst(&substs)\n-                }\n-                Either::B(ty) => ty,\n-            };\n-            if is_last_segment {\n-                break;\n+        // there may be more intermediate segments between the resolved one and\n+        // the end. Only the last segment needs to be resolved to a value; from\n+        // the segments before that, we need to get either a type or a trait ref.\n+\n+        let resolved_segment = &path.segments[remaining_index - 1];\n+        let remaining_segments = &path.segments[remaining_index..];\n+        let is_before_last = remaining_segments.len() == 1;\n+\n+        match (def, is_before_last) {\n+            (TypeNs::Trait(_trait), true) => {\n+                // FIXME Associated item of trait, e.g. `Default::default`\n+                None\n             }\n+            (def, _) => {\n+                // Either we already have a type (e.g. `Vec::new`), or we have a\n+                // trait but it's not the last segment, so the next segment\n+                // should resolve to an associated type of that trait (e.g. `<T\n+                // as Iterator>::Item::default`)\n+                let remaining_segments_for_ty = &remaining_segments[..remaining_segments.len() - 1];\n+                let ty = Ty::from_partly_resolved_hir_path(\n+                    self.db,\n+                    &self.resolver,\n+                    def,\n+                    resolved_segment,\n+                    remaining_segments_for_ty,\n+                );\n+                if let Ty::Unknown = ty {\n+                    return None;\n+                }\n \n-            // Attempt to find an impl_item for the type which has a name matching\n-            // the current segment\n-            log::debug!(\"looking for path segment: {:?}\", segment);\n+                let segment =\n+                    remaining_segments.last().expect(\"there should be at least one segment here\");\n \n-            let ty = mem::replace(&mut ty, Ty::Unknown);\n-            def_or_ty = ty.iterate_impl_items(self.db, krate, |item| {\n-                match item {\n-                    crate::ImplItem::Method(_) => None,\n-                    crate::ImplItem::Const(_) => None,\n+                self.resolve_ty_assoc_item(ty, segment, id)\n+            }\n+        }\n+    }\n \n-                    // FIXME: Resolve associated types\n-                    crate::ImplItem::TypeAlias(_) => {\n-                        // Some(Either::A(TypeNs::TypeAlias(..)))\n-                        None\n-                    }\n-                }\n-            })?;\n+    fn resolve_ty_assoc_item(\n+        &mut self,\n+        ty: Ty,\n+        segment: &crate::path::PathSegment,\n+        id: ExprOrPatId,\n+    ) -> Option<(ValueNs, Option<Substs>)> {\n+        if let Ty::Unknown = ty {\n+            return None;\n         }\n \n-        let segment = path.segments.last().unwrap();\n-        let def = ty.clone().iterate_impl_items(self.db, krate, |item| {\n-            let matching_def: Option<ValueNs> = match item {\n-                crate::ImplItem::Method(func) => {\n-                    if segment.name == func.name(self.db) {\n-                        Some(ValueNs::Function(func))\n-                    } else {\n-                        None\n-                    }\n-                }\n+        let krate = self.resolver.krate()?;\n \n-                crate::ImplItem::Const(konst) => {\n-                    let data = konst.data(self.db);\n-                    if Some(&segment.name) == data.name() {\n-                        Some(ValueNs::Const(konst))\n-                    } else {\n-                        None\n-                    }\n+        // Find impl\n+        // FIXME: consider trait candidates\n+        let item = ty.clone().iterate_impl_items(self.db, krate, |item| match item {\n+            AssocItem::Function(func) => {\n+                if segment.name == func.name(self.db) {\n+                    Some(AssocItem::Function(func))\n+                } else {\n+                    None\n                 }\n-                crate::ImplItem::TypeAlias(_) => None,\n-            };\n-            match matching_def {\n-                Some(_) => {\n-                    self.write_assoc_resolution(id, item);\n-                    matching_def\n+            }\n+\n+            AssocItem::Const(konst) => {\n+                if konst.name(self.db).map_or(false, |n| n == segment.name) {\n+                    Some(AssocItem::Const(konst))\n+                } else {\n+                    None\n                 }\n-                None => None,\n             }\n+            AssocItem::TypeAlias(_) => None,\n         })?;\n-        let self_types = self.find_self_types(&def, ty);\n-        Some((def, self_types))\n+        let def = match item {\n+            AssocItem::Function(f) => ValueNs::Function(f),\n+            AssocItem::Const(c) => ValueNs::Const(c),\n+            AssocItem::TypeAlias(_) => unreachable!(),\n+        };\n+        let substs = self.find_self_types(&def, ty);\n+\n+        self.write_assoc_resolution(id, item);\n+        Some((def, substs))\n     }\n \n     fn find_self_types(&self, def: &ValueNs, actual_def_ty: Ty) -> Option<Substs> {"}, {"sha": "a83842b0f3ae0e56ac4bae068f54d769dd42ee12", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 103, "deletions": 56, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=54379ec6f8f82a470a275771e70825634d3d553b", "patch": "@@ -86,78 +86,125 @@ impl Ty {\n         }\n     }\n \n-    pub(crate) fn from_hir_path(db: &impl HirDatabase, resolver: &Resolver, path: &Path) -> Ty {\n-        // Resolve the path (in type namespace)\n-        let (resolution, remaining_index) = match resolver.resolve_path_in_type_ns(db, path) {\n-            Some(it) => it,\n-            None => return Ty::Unknown,\n-        };\n+    pub(crate) fn from_type_relative_path(\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        ty: Ty,\n+        remaining_segments: &[PathSegment],\n+    ) -> Ty {\n+        if remaining_segments.len() == 1 {\n+            // resolve unselected assoc types\n+            let segment = &remaining_segments[0];\n+            Ty::select_associated_type(db, resolver, ty, segment)\n+        } else if remaining_segments.len() > 1 {\n+            // FIXME report error (ambiguous associated type)\n+            Ty::Unknown\n+        } else {\n+            ty\n+        }\n+    }\n \n-        let typable: TypableDef = match resolution {\n+    pub(crate) fn from_partly_resolved_hir_path(\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        resolution: TypeNs,\n+        resolved_segment: &PathSegment,\n+        remaining_segments: &[PathSegment],\n+    ) -> Ty {\n+        let ty = match resolution {\n             TypeNs::Trait(trait_) => {\n-                let segment = match remaining_index {\n-                    None => path.segments.last().expect(\"resolved path has at least one element\"),\n-                    Some(i) => &path.segments[i - 1],\n-                };\n-                let trait_ref = TraitRef::from_resolved_path(db, resolver, trait_, segment, None);\n-                return if let Some(remaining_index) = remaining_index {\n-                    if remaining_index == path.segments.len() - 1 {\n-                        let segment = &path.segments[remaining_index];\n-                        match trait_ref\n-                            .trait_\n-                            .associated_type_by_name_including_super_traits(db, &segment.name)\n-                        {\n-                            Some(associated_ty) => {\n-                                // FIXME handle type parameters on the segment\n-                                Ty::Projection(ProjectionTy {\n-                                    associated_ty,\n-                                    parameters: trait_ref.substs,\n-                                })\n-                            }\n-                            None => {\n-                                // associated type not found\n-                                Ty::Unknown\n-                            }\n+                let trait_ref =\n+                    TraitRef::from_resolved_path(db, resolver, trait_, resolved_segment, None);\n+                return if remaining_segments.len() == 1 {\n+                    let segment = &remaining_segments[0];\n+                    match trait_ref\n+                        .trait_\n+                        .associated_type_by_name_including_super_traits(db, &segment.name)\n+                    {\n+                        Some(associated_ty) => {\n+                            // FIXME handle type parameters on the segment\n+                            Ty::Projection(ProjectionTy {\n+                                associated_ty,\n+                                parameters: trait_ref.substs,\n+                            })\n+                        }\n+                        None => {\n+                            // FIXME: report error (associated type not found)\n+                            Ty::Unknown\n                         }\n-                    } else {\n-                        // FIXME more than one segment remaining, is this possible?\n-                        Ty::Unknown\n                     }\n+                } else if remaining_segments.len() > 1 {\n+                    // FIXME report error (ambiguous associated type)\n+                    Ty::Unknown\n                 } else {\n                     Ty::Dyn(Arc::new([GenericPredicate::Implemented(trait_ref)]))\n                 };\n             }\n             TypeNs::GenericParam(idx) => {\n-                if remaining_index.is_some() {\n-                    // e.g. T::Item\n-                    return Ty::Unknown;\n-                }\n-                return Ty::Param {\n-                    idx,\n-                    // FIXME: maybe return name in resolution?\n-                    name: path\n-                        .as_ident()\n-                        .expect(\"generic param should be single-segment path\")\n-                        .clone(),\n-                };\n-            }\n-            TypeNs::SelfType(impl_block) => {\n-                if remaining_index.is_some() {\n-                    // e.g. Self::Item\n-                    return Ty::Unknown;\n-                }\n-                return impl_block.target_ty(db);\n+                // FIXME: maybe return name in resolution?\n+                let name = resolved_segment.name.clone();\n+                Ty::Param { idx, name }\n             }\n+            TypeNs::SelfType(impl_block) => impl_block.target_ty(db),\n \n-            TypeNs::Adt(it) => it.into(),\n-            TypeNs::BuiltinType(it) => it.into(),\n-            TypeNs::TypeAlias(it) => it.into(),\n+            TypeNs::Adt(it) => Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into()),\n+            TypeNs::BuiltinType(it) => {\n+                Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into())\n+            }\n+            TypeNs::TypeAlias(it) => {\n+                Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into())\n+            }\n             // FIXME: report error\n             TypeNs::EnumVariant(_) => return Ty::Unknown,\n         };\n \n+        Ty::from_type_relative_path(db, resolver, ty, remaining_segments)\n+    }\n+\n+    pub(crate) fn from_hir_path(db: &impl HirDatabase, resolver: &Resolver, path: &Path) -> Ty {\n+        // Resolve the path (in type namespace)\n+        if let crate::PathKind::Type(type_ref) = &path.kind {\n+            let ty = Ty::from_hir(db, resolver, &type_ref);\n+            let remaining_segments = &path.segments[..];\n+            return Ty::from_type_relative_path(db, resolver, ty, remaining_segments);\n+        }\n+        let (resolution, remaining_index) = match resolver.resolve_path_in_type_ns(db, path) {\n+            Some(it) => it,\n+            None => return Ty::Unknown,\n+        };\n+        let (resolved_segment, remaining_segments) = match remaining_index {\n+            None => (\n+                path.segments.last().expect(\"resolved path has at least one element\"),\n+                &[] as &[PathSegment],\n+            ),\n+            Some(i) => (&path.segments[i - 1], &path.segments[i..]),\n+        };\n+        Ty::from_partly_resolved_hir_path(\n+            db,\n+            resolver,\n+            resolution,\n+            resolved_segment,\n+            remaining_segments,\n+        )\n+    }\n+\n+    fn select_associated_type(\n+        _db: &impl HirDatabase,\n+        _resolver: &Resolver,\n+        _self_ty: Ty,\n+        _segment: &PathSegment,\n+    ) -> Ty {\n+        Ty::Unknown\n+    }\n+\n+    fn from_hir_path_inner(\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        segment: &PathSegment,\n+        typable: TypableDef,\n+    ) -> Ty {\n         let ty = db.type_for_def(typable, Namespace::Types);\n-        let substs = Ty::substs_from_path(db, resolver, path, typable);\n+        let substs = Ty::substs_from_path_segment(db, resolver, segment, typable);\n         ty.subst(&substs)\n     }\n "}, {"sha": "8b46b11a9c4d4ee0c28b732e1de319eaf63c1f18", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=54379ec6f8f82a470a275771e70825634d3d553b", "patch": "@@ -11,13 +11,12 @@ use super::{autoderef, lower, Canonical, InEnvironment, TraitEnvironment, TraitR\n use crate::{\n     db::HirDatabase,\n     generics::HasGenericParams,\n-    impl_block::{ImplBlock, ImplId, ImplItem},\n+    impl_block::{ImplBlock, ImplId},\n     nameres::CrateModuleId,\n     resolve::Resolver,\n-    traits::TraitItem,\n     ty::primitive::{FloatBitness, UncertainFloatTy, UncertainIntTy},\n     ty::{Ty, TypeCtor},\n-    Crate, Function, Module, Name, Trait,\n+    AssocItem, Crate, Function, Module, Name, Trait,\n };\n \n /// This is used as a key for indexing impls.\n@@ -232,7 +231,7 @@ fn iterate_trait_method_candidates<T>(\n         // iteration\n         let mut known_implemented = inherently_implemented;\n         for item in data.items() {\n-            if let TraitItem::Function(m) = *item {\n+            if let AssocItem::Function(m) = *item {\n                 let data = m.data(db);\n                 if name.map_or(true, |name| data.name() == name) && data.has_self_param() {\n                     if !known_implemented {\n@@ -264,7 +263,7 @@ fn iterate_inherent_methods<T>(\n \n         for impl_block in impls.lookup_impl_blocks(&ty.value) {\n             for item in impl_block.items(db) {\n-                if let ImplItem::Method(f) = item {\n+                if let AssocItem::Function(f) = item {\n                     let data = f.data(db);\n                     if name.map_or(true, |name| data.name() == name) && data.has_self_param() {\n                         if let Some(result) = callback(&ty.value, f) {\n@@ -304,7 +303,7 @@ impl Ty {\n         self,\n         db: &impl HirDatabase,\n         krate: Crate,\n-        mut callback: impl FnMut(ImplItem) -> Option<T>,\n+        mut callback: impl FnMut(AssocItem) -> Option<T>,\n     ) -> Option<T> {\n         for krate in def_crates(db, krate, &self)? {\n             let impls = db.impls_in_crate(krate);"}, {"sha": "09c17fdf4d2966e6d9bee3f3480c1180f91ed645", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 76, "deletions": 22, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=54379ec6f8f82a470a275771e70825634d3d553b", "patch": "@@ -2613,18 +2613,18 @@ fn infer_call_trait_method_on_generic_param_1() {\n     assert_snapshot!(\n         infer(r#\"\n trait Trait {\n-    fn method() -> u32;\n+    fn method(&self) -> u32;\n }\n fn test<T: Trait>(t: T) {\n     t.method();\n }\n \"#),\n         @r###\"\n-\n-    [59; 60) 't': T\n-    [65; 84) '{     ...d(); }': ()\n-    [71; 72) 't': T\n-    [71; 81) 't.method()': {unknown}\n+    [30; 34) 'self': &Self\n+    [64; 65) 't': T\n+    [70; 89) '{     ...d(); }': ()\n+    [76; 77) 't': T\n+    [76; 86) 't.method()': u32\n     \"###\n     );\n }\n@@ -2634,18 +2634,18 @@ fn infer_call_trait_method_on_generic_param_2() {\n     assert_snapshot!(\n         infer(r#\"\n trait Trait<T> {\n-    fn method() -> T;\n+    fn method(&self) -> T;\n }\n fn test<U, T: Trait<U>>(t: T) {\n     t.method();\n }\n \"#),\n         @r###\"\n-\n-    [66; 67) 't': T\n-    [72; 91) '{     ...d(); }': ()\n-    [78; 79) 't': T\n-    [78; 88) 't.method()': {unknown}\n+    [33; 37) 'self': &Self\n+    [71; 72) 't': T\n+    [77; 96) '{     ...d(); }': ()\n+    [83; 84) 't': T\n+    [83; 93) 't.method()': [missing name]\n     \"###\n     );\n }\n@@ -2685,6 +2685,7 @@ fn test() {\n \n #[test]\n fn infer_project_associated_type() {\n+    // y, z, a don't yet work because of https://github.com/rust-lang/chalk/issues/234\n     assert_snapshot!(\n         infer(r#\"\n trait Iterable {\n@@ -2696,16 +2697,19 @@ fn test<T: Iterable>() {\n     let x: <S as Iterable>::Item = 1;\n     let y: <T as Iterable>::Item = no_matter;\n     let z: T::Item = no_matter;\n+    let a: <T>::Item = no_matter;\n }\n \"#),\n         @r###\"\n-    [108; 227) '{     ...ter; }': ()\n+    [108; 261) '{     ...ter; }': ()\n     [118; 119) 'x': u32\n     [145; 146) '1': u32\n     [156; 157) 'y': {unknown}\n     [183; 192) 'no_matter': {unknown}\n     [202; 203) 'z': {unknown}\n     [215; 224) 'no_matter': {unknown}\n+    [234; 235) 'a': {unknown}\n+    [249; 258) 'no_matter': {unknown}\n     \"###\n     );\n }\n@@ -2721,25 +2725,33 @@ struct S;\n impl Iterable for S { type Item = u32; }\n fn foo1<T: Iterable>(t: T) -> T::Item {}\n fn foo2<T: Iterable>(t: T) -> <T as Iterable>::Item {}\n+fn foo3<T: Iterable>(t: T) -> <T>::Item {}\n fn test() {\n     let x = foo1(S);\n     let y = foo2(S);\n+    let z = foo3(S);\n }\n \"#),\n         @r###\"\n     [106; 107) 't': T\n     [123; 125) '{}': ()\n     [147; 148) 't': T\n     [178; 180) '{}': ()\n-    [191; 236) '{     ...(S); }': ()\n-    [201; 202) 'x': {unknown}\n-    [205; 209) 'foo1': fn foo1<S>(T) -> {unknown}\n-    [205; 212) 'foo1(S)': {unknown}\n-    [210; 211) 'S': S\n-    [222; 223) 'y': u32\n-    [226; 230) 'foo2': fn foo2<S>(T) -> <T as Iterable>::Item\n-    [226; 233) 'foo2(S)': u32\n-    [231; 232) 'S': S\n+    [202; 203) 't': T\n+    [221; 223) '{}': ()\n+    [234; 300) '{     ...(S); }': ()\n+    [244; 245) 'x': {unknown}\n+    [248; 252) 'foo1': fn foo1<S>(T) -> {unknown}\n+    [248; 255) 'foo1(S)': {unknown}\n+    [253; 254) 'S': S\n+    [265; 266) 'y': u32\n+    [269; 273) 'foo2': fn foo2<S>(T) -> <T as Iterable>::Item\n+    [269; 276) 'foo2(S)': u32\n+    [274; 275) 'S': S\n+    [286; 287) 'z': {unknown}\n+    [290; 294) 'foo3': fn foo3<S>(T) -> {unknown}\n+    [290; 297) 'foo3(S)': {unknown}\n+    [295; 296) 'S': S\n     \"###\n     );\n }\n@@ -4050,6 +4062,48 @@ fn test<F: FnOnce(u32) -> u64>(f: F) {\n     );\n }\n \n+#[test]\n+fn unselected_projection_in_trait_env() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait {\n+    type Item;\n+}\n+\n+trait Trait2 {\n+    fn foo(&self) -> u32;\n+}\n+\n+fn test<T: Trait>() where T::Item: Trait2 {\n+    let x: T::Item = no_matter;\n+    x.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"u32\");\n+}\n+\n+#[test]\n+fn unselected_projection_in_trait_env_cycle() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait {\n+    type Item;\n+}\n+\n+trait Trait2<T> {}\n+\n+fn test<T: Trait>() where T: Trait2<T::Item> {\n+    let x: T::Item = no_matter<|>;\n+}\n+\"#,\n+    );\n+    // this is a legitimate cycle\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n fn type_at_pos(db: &MockDatabase, pos: FilePosition) -> String {\n     let file = db.parse(pos.file_id).ok().unwrap();\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();"}, {"sha": "693d9b28fd661789a599439a0de4929e5b57e151", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=54379ec6f8f82a470a275771e70825634d3d553b", "patch": "@@ -21,7 +21,7 @@ use crate::{\n         ApplicationTy, CallableDef, GenericPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n         TypeWalk,\n     },\n-    Crate, HasGenericParams, ImplBlock, ImplItem, Trait, TypeAlias,\n+    AssocItem, Crate, HasGenericParams, ImplBlock, Trait, TypeAlias,\n };\n \n /// This represents a trait whose name we could not resolve.\n@@ -496,7 +496,7 @@ pub(crate) fn trait_datum_query(\n         .items(db)\n         .into_iter()\n         .filter_map(|trait_item| match trait_item {\n-            crate::traits::TraitItem::TypeAlias(type_alias) => Some(type_alias),\n+            crate::AssocItem::TypeAlias(type_alias) => Some(type_alias),\n             _ => None,\n         })\n         .map(|type_alias| type_alias.to_chalk(db))\n@@ -616,7 +616,7 @@ pub(crate) fn impl_datum_query(\n         .items(db)\n         .into_iter()\n         .filter_map(|item| match item {\n-            ImplItem::TypeAlias(t) => Some(t),\n+            AssocItem::TypeAlias(t) => Some(t),\n             _ => None,\n         })\n         .filter_map(|t| {"}, {"sha": "e9fec54d8688a364d96a1cc61cd4941ab00398c4", "filename": "crates/ra_ide_api/src/completion/complete_path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=54379ec6f8f82a470a275771e70825634d3d553b", "patch": "@@ -52,14 +52,14 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n             if let Some(krate) = krate {\n                 ty.iterate_impl_items(ctx.db, krate, |item| {\n                     match item {\n-                        hir::ImplItem::Method(func) => {\n+                        hir::AssocItem::Function(func) => {\n                             let data = func.data(ctx.db);\n                             if !data.has_self_param() {\n                                 acc.add_function(ctx, func);\n                             }\n                         }\n-                        hir::ImplItem::Const(ct) => acc.add_const(ctx, ct),\n-                        hir::ImplItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),\n+                        hir::AssocItem::Const(ct) => acc.add_const(ctx, ct),\n+                        hir::AssocItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),\n                     }\n                     None::<()>\n                 });"}, {"sha": "11f73ccfd02e1128137a2edb9d7249301a46b8d1", "filename": "crates/ra_ide_api/src/display/navigation_target.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=54379ec6f8f82a470a275771e70825634d3d553b", "patch": "@@ -1,4 +1,4 @@\n-use hir::{FieldSource, HasSource, ImplItem, ModuleSource};\n+use hir::{AssocItem, FieldSource, HasSource, ModuleSource};\n use ra_db::{FileId, SourceDatabase};\n use ra_syntax::{\n     algo::visit::{visitor, Visitor},\n@@ -221,11 +221,14 @@ impl NavigationTarget {\n         )\n     }\n \n-    pub(crate) fn from_impl_item(db: &RootDatabase, impl_item: hir::ImplItem) -> NavigationTarget {\n-        match impl_item {\n-            ImplItem::Method(it) => NavigationTarget::from_def_source(db, it),\n-            ImplItem::Const(it) => NavigationTarget::from_def_source(db, it),\n-            ImplItem::TypeAlias(it) => NavigationTarget::from_def_source(db, it),\n+    pub(crate) fn from_assoc_item(\n+        db: &RootDatabase,\n+        assoc_item: hir::AssocItem,\n+    ) -> NavigationTarget {\n+        match assoc_item {\n+            AssocItem::Function(it) => NavigationTarget::from_def_source(db, it),\n+            AssocItem::Const(it) => NavigationTarget::from_def_source(db, it),\n+            AssocItem::TypeAlias(it) => NavigationTarget::from_def_source(db, it),\n         }\n     }\n "}, {"sha": "503dcacff4f2ef8007d1e0a50c90c904abc12f3c", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=54379ec6f8f82a470a275771e70825634d3d553b", "patch": "@@ -60,7 +60,7 @@ pub(crate) fn reference_definition(\n     match classify_name_ref(db, &analyzer, name_ref) {\n         Some(Macro(mac)) => return Exact(NavigationTarget::from_macro_def(db, mac)),\n         Some(FieldAccess(field)) => return Exact(NavigationTarget::from_field(db, field)),\n-        Some(AssocItem(assoc)) => return Exact(NavigationTarget::from_impl_item(db, assoc)),\n+        Some(AssocItem(assoc)) => return Exact(NavigationTarget::from_assoc_item(db, assoc)),\n         Some(Method(func)) => return Exact(NavigationTarget::from_def_source(db, func)),\n         Some(Def(def)) => match NavigationTarget::from_def(db, def) {\n             Some(nav) => return Exact(nav),"}, {"sha": "655bcdb16d9f3ea789c95b627a10ff785e40ffd9", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=54379ec6f8f82a470a275771e70825634d3d553b", "patch": "@@ -117,9 +117,9 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n                 }\n             }\n             Some(AssocItem(it)) => res.extend(match it {\n-                hir::ImplItem::Method(it) => from_def_source(db, it),\n-                hir::ImplItem::Const(it) => from_def_source(db, it),\n-                hir::ImplItem::TypeAlias(it) => from_def_source(db, it),\n+                hir::AssocItem::Function(it) => from_def_source(db, it),\n+                hir::AssocItem::Const(it) => from_def_source(db, it),\n+                hir::AssocItem::TypeAlias(it) => from_def_source(db, it),\n             }),\n             Some(Def(it)) => {\n                 match it {"}, {"sha": "aff03464ae7b4377173081165e80a00557a4e554", "filename": "crates/ra_ide_api/src/name_ref_kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_ide_api%2Fsrc%2Fname_ref_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_ide_api%2Fsrc%2Fname_ref_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fname_ref_kind.rs?ref=54379ec6f8f82a470a275771e70825634d3d553b", "patch": "@@ -8,7 +8,7 @@ pub enum NameRefKind {\n     Method(hir::Function),\n     Macro(hir::MacroDef),\n     FieldAccess(hir::StructField),\n-    AssocItem(hir::ImplItem),\n+    AssocItem(hir::AssocItem),\n     Def(hir::ModuleDef),\n     SelfType(hir::Ty),\n     Pat(AstPtr<ast::BindPat>),"}, {"sha": "3d7f91c1deeb10c78bb1b7250be565384bb2659a", "filename": "crates/ra_ide_api/src/syntax_highlighting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54379ec6f8f82a470a275771e70825634d3d553b/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs?ref=54379ec6f8f82a470a275771e70825634d3d553b", "patch": "@@ -102,9 +102,9 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n                         Some(Method(_)) => \"function\",\n                         Some(Macro(_)) => \"macro\",\n                         Some(FieldAccess(_)) => \"field\",\n-                        Some(AssocItem(hir::ImplItem::Method(_))) => \"function\",\n-                        Some(AssocItem(hir::ImplItem::Const(_))) => \"constant\",\n-                        Some(AssocItem(hir::ImplItem::TypeAlias(_))) => \"type\",\n+                        Some(AssocItem(hir::AssocItem::Function(_))) => \"function\",\n+                        Some(AssocItem(hir::AssocItem::Const(_))) => \"constant\",\n+                        Some(AssocItem(hir::AssocItem::TypeAlias(_))) => \"type\",\n                         Some(Def(hir::ModuleDef::Module(_))) => \"module\",\n                         Some(Def(hir::ModuleDef::Function(_))) => \"function\",\n                         Some(Def(hir::ModuleDef::Adt(_))) => \"type\","}]}