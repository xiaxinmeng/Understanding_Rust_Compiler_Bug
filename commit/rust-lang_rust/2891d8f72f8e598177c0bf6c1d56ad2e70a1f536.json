{"sha": "2891d8f72f8e598177c0bf6c1d56ad2e70a1f536", "node_id": "C_kwDOAAsO6NoAKDI4OTFkOGY3MmY4ZTU5ODE3N2MwYmY2YzFkNTZhZDJlNzBhMWY1MzY", "commit": {"author": {"name": "Samuel \"Sam\" Tardieu", "email": "sam@rfc1149.net", "date": "2023-03-26T15:11:34Z"}, "committer": {"name": "Samuel \"Sam\" Tardieu", "email": "sam@rfc1149.net", "date": "2023-04-05T08:06:01Z"}, "message": "Make redundant_async_block a more complete late pass\n\nThis lets us detect more complex situations: `async { x.await }` is\nsimplified into `x` if:\n\n- `x` is an expression without side-effect\n- or `x` is an async block itself\n\nIn both cases, no part of the `async` expression can be part of a macro\nexpansion.", "tree": {"sha": "1971e9c051adab66439c66da47d88d1493d4c6ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1971e9c051adab66439c66da47d88d1493d4c6ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2891d8f72f8e598177c0bf6c1d56ad2e70a1f536", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2891d8f72f8e598177c0bf6c1d56ad2e70a1f536", "html_url": "https://github.com/rust-lang/rust/commit/2891d8f72f8e598177c0bf6c1d56ad2e70a1f536", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2891d8f72f8e598177c0bf6c1d56ad2e70a1f536/comments", "author": {"login": "samueltardieu", "id": 44656, "node_id": "MDQ6VXNlcjQ0NjU2", "avatar_url": "https://avatars.githubusercontent.com/u/44656?v=4", "gravatar_id": "", "url": "https://api.github.com/users/samueltardieu", "html_url": "https://github.com/samueltardieu", "followers_url": "https://api.github.com/users/samueltardieu/followers", "following_url": "https://api.github.com/users/samueltardieu/following{/other_user}", "gists_url": "https://api.github.com/users/samueltardieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/samueltardieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/samueltardieu/subscriptions", "organizations_url": "https://api.github.com/users/samueltardieu/orgs", "repos_url": "https://api.github.com/users/samueltardieu/repos", "events_url": "https://api.github.com/users/samueltardieu/events{/privacy}", "received_events_url": "https://api.github.com/users/samueltardieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "samueltardieu", "id": 44656, "node_id": "MDQ6VXNlcjQ0NjU2", "avatar_url": "https://avatars.githubusercontent.com/u/44656?v=4", "gravatar_id": "", "url": "https://api.github.com/users/samueltardieu", "html_url": "https://github.com/samueltardieu", "followers_url": "https://api.github.com/users/samueltardieu/followers", "following_url": "https://api.github.com/users/samueltardieu/following{/other_user}", "gists_url": "https://api.github.com/users/samueltardieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/samueltardieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/samueltardieu/subscriptions", "organizations_url": "https://api.github.com/users/samueltardieu/orgs", "repos_url": "https://api.github.com/users/samueltardieu/repos", "events_url": "https://api.github.com/users/samueltardieu/events{/privacy}", "received_events_url": "https://api.github.com/users/samueltardieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ed64d4c612508ece912f170005abd7988865d10", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ed64d4c612508ece912f170005abd7988865d10", "html_url": "https://github.com/rust-lang/rust/commit/5ed64d4c612508ece912f170005abd7988865d10"}], "stats": {"total": 489, "additions": 338, "deletions": 151}, "files": [{"sha": "4638af8da9f35e93fe5e57e2d32ae5be114ca3f0", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2891d8f72f8e598177c0bf6c1d56ad2e70a1f536/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2891d8f72f8e598177c0bf6c1d56ad2e70a1f536/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=2891d8f72f8e598177c0bf6c1d56ad2e70a1f536", "patch": "@@ -935,7 +935,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|_| Box::new(no_mangle_with_rust_abi::NoMangleWithRustAbi));\n     store.register_late_pass(|_| Box::new(collection_is_never_read::CollectionIsNeverRead));\n     store.register_late_pass(|_| Box::new(missing_assert_message::MissingAssertMessage));\n-    store.register_early_pass(|| Box::new(redundant_async_block::RedundantAsyncBlock));\n+    store.register_late_pass(|_| Box::new(redundant_async_block::RedundantAsyncBlock));\n     store.register_late_pass(|_| Box::new(let_with_type_underscore::UnderscoreTyped));\n     store.register_late_pass(|_| Box::new(allow_attributes::AllowAttribute));\n     store.register_late_pass(move |_| Box::new(manual_main_separator_str::ManualMainSeparatorStr::new(msrv())));"}, {"sha": "a0f831764d071ddb1247e093bce93caa5c6f3745", "filename": "clippy_lints/src/redundant_async_block.rs", "status": "modified", "additions": 67, "deletions": 78, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/2891d8f72f8e598177c0bf6c1d56ad2e70a1f536/clippy_lints%2Fsrc%2Fredundant_async_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2891d8f72f8e598177c0bf6c1d56ad2e70a1f536/clippy_lints%2Fsrc%2Fredundant_async_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_async_block.rs?ref=2891d8f72f8e598177c0bf6c1d56ad2e70a1f536", "patch": "@@ -1,8 +1,15 @@\n-use clippy_utils::{diagnostics::span_lint_and_sugg, source::snippet};\n-use rustc_ast::ast::{Expr, ExprKind, Stmt, StmtKind};\n-use rustc_ast::visit::Visitor as AstVisitor;\n+use std::ops::ControlFlow;\n+\n+use clippy_utils::{\n+    diagnostics::span_lint_and_sugg,\n+    peel_blocks,\n+    source::{snippet, walk_span_to_context},\n+    visitors::for_each_expr,\n+};\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_hir::{AsyncGeneratorKind, Closure, Expr, ExprKind, GeneratorKind, MatchSource};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::{lint::in_external_macro, ty::UpvarCapture};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -14,106 +21,88 @@ declare_clippy_lint! {\n     ///\n     /// ### Example\n     /// ```rust\n-    /// async fn f() -> i32 {\n-    ///     1 + 2\n-    /// }\n-    ///\n+    /// let f = async {\n+    ///    1 + 2\n+    /// };\n     /// let fut = async {\n-    ///     f().await\n+    ///     f.await\n     /// };\n     /// ```\n     /// Use instead:\n     /// ```rust\n-    /// async fn f() -> i32 {\n-    ///     1 + 2\n-    /// }\n-    ///\n-    /// let fut = f();\n+    /// let f = async {\n+    ///    1 + 2\n+    /// };\n+    /// let fut = f;\n     /// ```\n     #[clippy::version = \"1.69.0\"]\n     pub REDUNDANT_ASYNC_BLOCK,\n-    nursery,\n+    complexity,\n     \"`async { future.await }` can be replaced by `future`\"\n }\n declare_lint_pass!(RedundantAsyncBlock => [REDUNDANT_ASYNC_BLOCK]);\n \n-impl EarlyLintPass for RedundantAsyncBlock {\n-    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n-        if expr.span.from_expansion() {\n-            return;\n-        }\n-        if let ExprKind::Async(_, _, block) = &expr.kind && block.stmts.len() == 1 &&\n-            let Some(Stmt { kind: StmtKind::Expr(last), .. }) = block.stmts.last() &&\n-            let ExprKind::Await(future) = &last.kind &&\n-            !future.span.from_expansion() &&\n-            !await_in_expr(future)\n+impl<'tcx> LateLintPass<'tcx> for RedundantAsyncBlock {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        let span = expr.span;\n+        if !in_external_macro(cx.tcx.sess, span) &&\n+            let Some(body_expr) = desugar_async_block(cx, expr) &&\n+            let Some(expr) = desugar_await(peel_blocks(body_expr)) &&\n+            // The await prefix must not come from a macro as its content could change in the future.\n+            expr.span.ctxt() == body_expr.span.ctxt() &&\n+            // An async block does not have immediate side-effects from a `.await` point-of-view.\n+            (!expr.can_have_side_effects() || desugar_async_block(cx, expr).is_some()) &&\n+            let Some(shortened_span) = walk_span_to_context(expr.span, span.ctxt())\n         {\n-            if captures_value(last) {\n-                // If the async block captures variables then there is no equivalence.\n-                return;\n-            }\n-\n             span_lint_and_sugg(\n                 cx,\n                 REDUNDANT_ASYNC_BLOCK,\n-                expr.span,\n+                span,\n                 \"this async expression only awaits a single future\",\n                 \"you can reduce it to\",\n-                snippet(cx, future.span, \"..\").into_owned(),\n+                snippet(cx, shortened_span, \"..\").into_owned(),\n                 Applicability::MachineApplicable,\n             );\n         }\n     }\n }\n \n-/// Check whether an expression contains `.await`\n-fn await_in_expr(expr: &Expr) -> bool {\n-    let mut detector = AwaitDetector::default();\n-    detector.visit_expr(expr);\n-    detector.await_found\n-}\n-\n-#[derive(Default)]\n-struct AwaitDetector {\n-    await_found: bool,\n-}\n-\n-impl<'ast> AstVisitor<'ast> for AwaitDetector {\n-    fn visit_expr(&mut self, ex: &'ast Expr) {\n-        match (&ex.kind, self.await_found) {\n-            (ExprKind::Await(_), _) => self.await_found = true,\n-            (_, false) => rustc_ast::visit::walk_expr(self, ex),\n-            _ => (),\n-        }\n+/// If `expr` is a desugared `async` block, return the original expression if it does not capture\n+/// any variable by ref.\n+fn desugar_async_block<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    if let ExprKind::Closure(Closure { body, def_id, .. }) = expr.kind &&\n+        let body = cx.tcx.hir().body(*body) &&\n+        matches!(body.generator_kind, Some(GeneratorKind::Async(AsyncGeneratorKind::Block)))\n+    {\n+        cx\n+            .typeck_results()\n+            .closure_min_captures\n+            .get(def_id)\n+            .map_or(true, |m| {\n+                m.values().all(|places| {\n+                    places\n+                        .iter()\n+                        .all(|place| matches!(place.info.capture_kind, UpvarCapture::ByValue))\n+                })\n+            })\n+            .then_some(body.value)\n+    } else {\n+        None\n     }\n }\n \n-/// Check whether an expression may have captured a local variable.\n-/// This is done by looking for paths with only one segment, except as\n-/// a prefix of `.await` since this would be captured by value.\n-///\n-/// This function will sometimes return `true` even tough there are no\n-/// captures happening: at the AST level, it is impossible to\n-/// dinstinguish a function call from a call to a closure which comes\n-/// from the local environment.\n-fn captures_value(expr: &Expr) -> bool {\n-    let mut detector = CaptureDetector::default();\n-    detector.visit_expr(expr);\n-    detector.capture_found\n-}\n-\n-#[derive(Default)]\n-struct CaptureDetector {\n-    capture_found: bool,\n-}\n-\n-impl<'ast> AstVisitor<'ast> for CaptureDetector {\n-    fn visit_expr(&mut self, ex: &'ast Expr) {\n-        match (&ex.kind, self.capture_found) {\n-            (ExprKind::Await(fut), _) if matches!(fut.kind, ExprKind::Path(..)) => (),\n-            (ExprKind::Path(_, path), _) if path.segments.len() == 1 => self.capture_found = true,\n-            (_, false) => rustc_ast::visit::walk_expr(self, ex),\n-            _ => (),\n-        }\n+/// If `expr` is a desugared `.await`, return the original expression if it does not come from a\n+/// macro expansion.\n+fn desugar_await<'tcx>(expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    if let ExprKind::Match(match_value, _, MatchSource::AwaitDesugar) = expr.kind &&\n+        let ExprKind::Call(_, [into_future_arg]) = match_value.kind &&\n+        let ctxt = expr.span.ctxt() &&\n+        for_each_expr(into_future_arg, |e|\n+            walk_span_to_context(e.span, ctxt)\n+                .map_or(ControlFlow::Break(()), |_| ControlFlow::Continue(()))).is_none()\n+    {\n+        Some(into_future_arg)\n+    } else {\n+        None\n     }\n }"}, {"sha": "ad96993c4a78c470968025745e6ea90b66aa06a5", "filename": "tests/ui/redundant_async_block.fixed", "status": "modified", "additions": 115, "deletions": 33, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/2891d8f72f8e598177c0bf6c1d56ad2e70a1f536/tests%2Fui%2Fredundant_async_block.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2891d8f72f8e598177c0bf6c1d56ad2e70a1f536/tests%2Fui%2Fredundant_async_block.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_async_block.fixed?ref=2891d8f72f8e598177c0bf6c1d56ad2e70a1f536", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(unused)]\n+#![allow(unused, clippy::manual_async_fn)]\n #![warn(clippy::redundant_async_block)]\n \n use std::future::Future;\n@@ -16,40 +16,16 @@ async fn func2() -> String {\n     x.await\n }\n \n-macro_rules! await_in_macro {\n-    ($e:expr) => {\n-        std::convert::identity($e).await\n-    };\n-}\n-\n-async fn func3(n: usize) -> usize {\n-    // Do not lint (suggestion would be `std::convert::identity(func1(n))`\n-    // which copies code from inside the macro)\n-    async move { await_in_macro!(func1(n)) }.await\n-}\n-\n-// This macro should never be linted as `$e` might contain `.await`\n-macro_rules! async_await_parameter_in_macro {\n-    ($e:expr) => {\n-        async { $e.await }\n-    };\n-}\n-\n-// MISSED OPPORTUNITY: this macro could be linted as the `async` block does not\n-// contain code coming from the parameters\n-macro_rules! async_await_in_macro {\n-    ($f:expr) => {\n-        ($f)(async { func2().await })\n-    };\n-}\n-\n fn main() {\n     let fut1 = async { 17 };\n+    // Lint\n     let fut2 = fut1;\n \n     let fut1 = async { 25 };\n+    // Lint\n     let fut2 = fut1;\n \n+    // Lint\n     let fut = async { 42 };\n \n     // Do not lint: not a single expression\n@@ -60,15 +36,12 @@ fn main() {\n \n     // Do not lint: expression contains `.await`\n     let fut = async { func1(func2().await.len()).await };\n-\n-    let fut = async_await_parameter_in_macro!(func2());\n-    let fut = async_await_in_macro!(std::convert::identity);\n }\n \n #[allow(clippy::let_and_return)]\n fn capture_local() -> impl Future<Output = i32> {\n-    // Lint\n     let fut = async { 17 };\n+    // Lint\n     fut\n }\n \n@@ -80,11 +53,39 @@ fn capture_local_closure(s: &str) -> impl Future<Output = &str> {\n \n #[allow(clippy::let_and_return)]\n fn capture_arg(s: &str) -> impl Future<Output = &str> {\n-    // Lint\n     let fut = async move { s };\n+    // Lint\n     fut\n }\n \n+fn capture_future_arg<T>(f: impl Future<Output = T>) -> impl Future<Output = T> {\n+    // Lint\n+    f\n+}\n+\n+fn capture_func_result<FN, F, T>(f: FN) -> impl Future<Output = T>\n+where\n+    F: Future<Output = T>,\n+    FN: FnOnce() -> F,\n+{\n+    // Do not lint, as f() would be evaluated prematurely\n+    async { f().await }\n+}\n+\n+fn double_future(f: impl Future<Output = impl Future<Output = u32>>) -> impl Future<Output = u32> {\n+    // Do not lint, we will get a `.await` outside a `.async`\n+    async { f.await.await }\n+}\n+\n+fn await_in_async<F, R>(f: F) -> impl Future<Output = u32>\n+where\n+    F: FnOnce() -> R,\n+    R: Future<Output = u32>,\n+{\n+    // Lint\n+    async { f().await + 1 }\n+}\n+\n #[derive(Debug, Clone)]\n struct F {}\n \n@@ -109,3 +110,84 @@ fn capture() {\n     // Do not lint: `val` would not live long enough\n     spawn(async { work(&{ val }).await });\n }\n+\n+fn await_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e:expr) => {\n+            $e.await\n+        };\n+    }\n+    // Do not lint: the macro may change in the future\n+    // or return different things depending on its argument\n+    async { mac!(async { 42 }) }\n+}\n+\n+fn async_expr_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        () => {\n+            async { 42 }\n+        };\n+    }\n+    // Do not lint: the macro may change in the future\n+    async { mac!().await }\n+}\n+\n+fn async_expr_from_macro_deep() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        () => {\n+            async { 42 }\n+        };\n+    }\n+    // Do not lint: the macro may change in the future\n+    async { ({ mac!() }).await }\n+}\n+\n+fn all_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        () => {\n+            // Lint\n+            async { 42 }\n+        };\n+    }\n+    mac!()\n+}\n+\n+fn parts_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e: expr) => {\n+            // Do not lint: `$e` might not always be side-effect free\n+            async { $e.await }\n+        };\n+    }\n+    mac!(async { 42 })\n+}\n+\n+fn safe_parts_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e: expr) => {\n+            // Lint\n+            async { $e }\n+        };\n+    }\n+    mac!(42)\n+}\n+\n+fn parts_from_macro_deep() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e: expr) => {\n+            // Do not lint: `$e` might not always be side-effect free\n+            async { ($e,).0.await }\n+        };\n+    }\n+    let f = std::future::ready(42);\n+    mac!(f)\n+}\n+\n+fn await_from_macro_deep() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e:expr) => {{ $e }.await};\n+    }\n+    // Do not lint: the macro may change in the future\n+    // or return different things depending on its argument\n+    async { mac!(async { 42 }) }\n+}"}, {"sha": "7ae235583694dd2e66371440b9fc1a5920e0b7cd", "filename": "tests/ui/redundant_async_block.rs", "status": "modified", "additions": 115, "deletions": 33, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/2891d8f72f8e598177c0bf6c1d56ad2e70a1f536/tests%2Fui%2Fredundant_async_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2891d8f72f8e598177c0bf6c1d56ad2e70a1f536/tests%2Fui%2Fredundant_async_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_async_block.rs?ref=2891d8f72f8e598177c0bf6c1d56ad2e70a1f536", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(unused)]\n+#![allow(unused, clippy::manual_async_fn)]\n #![warn(clippy::redundant_async_block)]\n \n use std::future::Future;\n@@ -16,40 +16,16 @@ async fn func2() -> String {\n     x.await\n }\n \n-macro_rules! await_in_macro {\n-    ($e:expr) => {\n-        std::convert::identity($e).await\n-    };\n-}\n-\n-async fn func3(n: usize) -> usize {\n-    // Do not lint (suggestion would be `std::convert::identity(func1(n))`\n-    // which copies code from inside the macro)\n-    async move { await_in_macro!(func1(n)) }.await\n-}\n-\n-// This macro should never be linted as `$e` might contain `.await`\n-macro_rules! async_await_parameter_in_macro {\n-    ($e:expr) => {\n-        async { $e.await }\n-    };\n-}\n-\n-// MISSED OPPORTUNITY: this macro could be linted as the `async` block does not\n-// contain code coming from the parameters\n-macro_rules! async_await_in_macro {\n-    ($f:expr) => {\n-        ($f)(async { func2().await })\n-    };\n-}\n-\n fn main() {\n     let fut1 = async { 17 };\n+    // Lint\n     let fut2 = async { fut1.await };\n \n     let fut1 = async { 25 };\n+    // Lint\n     let fut2 = async move { fut1.await };\n \n+    // Lint\n     let fut = async { async { 42 }.await };\n \n     // Do not lint: not a single expression\n@@ -60,15 +36,12 @@ fn main() {\n \n     // Do not lint: expression contains `.await`\n     let fut = async { func1(func2().await.len()).await };\n-\n-    let fut = async_await_parameter_in_macro!(func2());\n-    let fut = async_await_in_macro!(std::convert::identity);\n }\n \n #[allow(clippy::let_and_return)]\n fn capture_local() -> impl Future<Output = i32> {\n-    // Lint\n     let fut = async { 17 };\n+    // Lint\n     async move { fut.await }\n }\n \n@@ -80,11 +53,39 @@ fn capture_local_closure(s: &str) -> impl Future<Output = &str> {\n \n #[allow(clippy::let_and_return)]\n fn capture_arg(s: &str) -> impl Future<Output = &str> {\n-    // Lint\n     let fut = async move { s };\n+    // Lint\n     async move { fut.await }\n }\n \n+fn capture_future_arg<T>(f: impl Future<Output = T>) -> impl Future<Output = T> {\n+    // Lint\n+    async { f.await }\n+}\n+\n+fn capture_func_result<FN, F, T>(f: FN) -> impl Future<Output = T>\n+where\n+    F: Future<Output = T>,\n+    FN: FnOnce() -> F,\n+{\n+    // Do not lint, as f() would be evaluated prematurely\n+    async { f().await }\n+}\n+\n+fn double_future(f: impl Future<Output = impl Future<Output = u32>>) -> impl Future<Output = u32> {\n+    // Do not lint, we will get a `.await` outside a `.async`\n+    async { f.await.await }\n+}\n+\n+fn await_in_async<F, R>(f: F) -> impl Future<Output = u32>\n+where\n+    F: FnOnce() -> R,\n+    R: Future<Output = u32>,\n+{\n+    // Lint\n+    async { async { f().await + 1 }.await }\n+}\n+\n #[derive(Debug, Clone)]\n struct F {}\n \n@@ -109,3 +110,84 @@ fn capture() {\n     // Do not lint: `val` would not live long enough\n     spawn(async { work(&{ val }).await });\n }\n+\n+fn await_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e:expr) => {\n+            $e.await\n+        };\n+    }\n+    // Do not lint: the macro may change in the future\n+    // or return different things depending on its argument\n+    async { mac!(async { 42 }) }\n+}\n+\n+fn async_expr_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        () => {\n+            async { 42 }\n+        };\n+    }\n+    // Do not lint: the macro may change in the future\n+    async { mac!().await }\n+}\n+\n+fn async_expr_from_macro_deep() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        () => {\n+            async { 42 }\n+        };\n+    }\n+    // Do not lint: the macro may change in the future\n+    async { ({ mac!() }).await }\n+}\n+\n+fn all_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        () => {\n+            // Lint\n+            async { async { 42 }.await }\n+        };\n+    }\n+    mac!()\n+}\n+\n+fn parts_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e: expr) => {\n+            // Do not lint: `$e` might not always be side-effect free\n+            async { $e.await }\n+        };\n+    }\n+    mac!(async { 42 })\n+}\n+\n+fn safe_parts_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e: expr) => {\n+            // Lint\n+            async { async { $e }.await }\n+        };\n+    }\n+    mac!(42)\n+}\n+\n+fn parts_from_macro_deep() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e: expr) => {\n+            // Do not lint: `$e` might not always be side-effect free\n+            async { ($e,).0.await }\n+        };\n+    }\n+    let f = std::future::ready(42);\n+    mac!(f)\n+}\n+\n+fn await_from_macro_deep() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e:expr) => {{ $e }.await};\n+    }\n+    // Do not lint: the macro may change in the future\n+    // or return different things depending on its argument\n+    async { mac!(async { 42 }) }\n+}"}, {"sha": "f3dcb09b4440ade2e5211149a8e09134d040af9e", "filename": "tests/ui/redundant_async_block.stderr", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2891d8f72f8e598177c0bf6c1d56ad2e70a1f536/tests%2Fui%2Fredundant_async_block.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2891d8f72f8e598177c0bf6c1d56ad2e70a1f536/tests%2Fui%2Fredundant_async_block.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_async_block.stderr?ref=2891d8f72f8e598177c0bf6c1d56ad2e70a1f536", "patch": "@@ -7,34 +7,68 @@ LL |     let x = async { f.await };\n    = note: `-D clippy::redundant-async-block` implied by `-D warnings`\n \n error: this async expression only awaits a single future\n-  --> $DIR/redundant_async_block.rs:48:16\n+  --> $DIR/redundant_async_block.rs:22:16\n    |\n LL |     let fut2 = async { fut1.await };\n    |                ^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `fut1`\n \n error: this async expression only awaits a single future\n-  --> $DIR/redundant_async_block.rs:51:16\n+  --> $DIR/redundant_async_block.rs:26:16\n    |\n LL |     let fut2 = async move { fut1.await };\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `fut1`\n \n error: this async expression only awaits a single future\n-  --> $DIR/redundant_async_block.rs:53:15\n+  --> $DIR/redundant_async_block.rs:29:15\n    |\n LL |     let fut = async { async { 42 }.await };\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `async { 42 }`\n \n error: this async expression only awaits a single future\n-  --> $DIR/redundant_async_block.rs:72:5\n+  --> $DIR/redundant_async_block.rs:45:5\n    |\n LL |     async move { fut.await }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `fut`\n \n error: this async expression only awaits a single future\n-  --> $DIR/redundant_async_block.rs:85:5\n+  --> $DIR/redundant_async_block.rs:58:5\n    |\n LL |     async move { fut.await }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `fut`\n \n-error: aborting due to 6 previous errors\n+error: this async expression only awaits a single future\n+  --> $DIR/redundant_async_block.rs:63:5\n+   |\n+LL |     async { f.await }\n+   |     ^^^^^^^^^^^^^^^^^ help: you can reduce it to: `f`\n+\n+error: this async expression only awaits a single future\n+  --> $DIR/redundant_async_block.rs:86:5\n+   |\n+LL |     async { async { f().await + 1 }.await }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `async { f().await + 1 }`\n+\n+error: this async expression only awaits a single future\n+  --> $DIR/redundant_async_block.rs:149:13\n+   |\n+LL |             async { async { 42 }.await }\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `async { 42 }`\n+...\n+LL |     mac!()\n+   |     ------ in this macro invocation\n+   |\n+   = note: this error originates in the macro `mac` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: this async expression only awaits a single future\n+  --> $DIR/redundant_async_block.rs:169:13\n+   |\n+LL |             async { async { $e }.await }\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `async { $e }`\n+...\n+LL |     mac!(42)\n+   |     -------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `mac` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 10 previous errors\n "}]}