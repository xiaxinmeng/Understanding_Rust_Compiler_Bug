{"sha": "73422130ee96c09e7214c876a3600ac1f32aa8c8", "node_id": "C_kwDOAAsO6NoAKDczNDIyMTMwZWU5NmMwOWU3MjE0Yzg3NmEzNjAwYWMxZjMyYWE4Yzg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-24T18:12:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-24T18:12:33Z"}, "message": "Auto merge of #88872 - petrochenkov:getmod2, r=cjgillot\n\nresolve: Some module-related refactorings\n\nSee the individual commits.", "tree": {"sha": "c60efb257e8fa0e0f103b61602bfbaff9675a776", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c60efb257e8fa0e0f103b61602bfbaff9675a776"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73422130ee96c09e7214c876a3600ac1f32aa8c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73422130ee96c09e7214c876a3600ac1f32aa8c8", "html_url": "https://github.com/rust-lang/rust/commit/73422130ee96c09e7214c876a3600ac1f32aa8c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73422130ee96c09e7214c876a3600ac1f32aa8c8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f06f9bbd3a2b0a2781decd6163b14f71dd59bf7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f06f9bbd3a2b0a2781decd6163b14f71dd59bf7f", "html_url": "https://github.com/rust-lang/rust/commit/f06f9bbd3a2b0a2781decd6163b14f71dd59bf7f"}, {"sha": "8f035b87e0a839fbca853514287028569808d50f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f035b87e0a839fbca853514287028569808d50f", "html_url": "https://github.com/rust-lang/rust/commit/8f035b87e0a839fbca853514287028569808d50f"}], "stats": {"total": 371, "additions": 178, "deletions": 193}, "files": [{"sha": "0cf9d7af58933e3f112c3f2512fe78240f8d3e19", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 102, "deletions": 117, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/73422130ee96c09e7214c876a3600ac1f32aa8c8/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73422130ee96c09e7214c876a3600ac1f32aa8c8/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=73422130ee96c09e7214c876a3600ac1f32aa8c8", "patch": "@@ -9,11 +9,9 @@ use crate::def_collector::collect_definitions;\n use crate::imports::{Import, ImportKind};\n use crate::macros::{MacroRulesBinding, MacroRulesScope, MacroRulesScopeRef};\n use crate::Namespace::{self, MacroNS, TypeNS, ValueNS};\n-use crate::{CrateLint, Determinacy, PathResult, ResolutionError, VisResolutionError};\n-use crate::{\n-    ExternPreludeEntry, ModuleOrUniformRoot, ParentScope, PerNS, Resolver, ResolverArenas,\n-};\n-use crate::{Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, Segment, ToNameBinding};\n+use crate::{CrateLint, Determinacy, ExternPreludeEntry, Module, ModuleKind, ModuleOrUniformRoot};\n+use crate::{NameBinding, NameBindingKind, ParentScope, PathResult, PerNS, ResolutionError};\n+use crate::{Resolver, ResolverArenas, Segment, ToNameBinding, VisResolutionError};\n \n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n use rustc_ast::{self as ast, AssocItem, AssocItemKind, MetaItemKind, StmtKind};\n@@ -95,100 +93,93 @@ impl<'a> Resolver<'a> {\n     }\n \n     /// Walks up the tree of definitions starting at `def_id`,\n-    /// stopping at the first `DefKind::Mod` encountered\n-    fn nearest_parent_mod(&mut self, def_id: DefId) -> Module<'a> {\n-        let def_key = self.cstore().def_key(def_id);\n-\n-        let mut parent_id = DefId {\n-            krate: def_id.krate,\n-            index: def_key.parent.expect(\"failed to get parent for module\"),\n-        };\n-        // The immediate parent may not be a module\n-        // (e.g. `const _: () =  { #[path = \"foo.rs\"] mod foo; };`)\n-        // Walk up the tree until we hit a module or the crate root.\n-        while parent_id.index != CRATE_DEF_INDEX\n-            && self.cstore().def_kind(parent_id) != DefKind::Mod\n-        {\n-            let parent_def_key = self.cstore().def_key(parent_id);\n-            parent_id.index = parent_def_key.parent.expect(\"failed to get parent for module\");\n+    /// stopping at the first encountered module.\n+    /// Parent block modules for arbitrary def-ids are not recorded for the local crate,\n+    /// and are not preserved in metadata for foreign crates, so block modules are never\n+    /// returned by this function.\n+    ///\n+    /// For the local crate ignoring block modules may be incorrect, so use this method with care.\n+    ///\n+    /// For foreign crates block modules can be ignored without introducing observable differences,\n+    /// moreover they has to be ignored right now because they are not kept in metadata.\n+    /// Foreign parent modules are used for resolving names used by foreign macros with def-site\n+    /// hygiene, therefore block module ignorability relies on macros with def-site hygiene and\n+    /// block module parents being unreachable from other crates.\n+    /// Reachable macros with block module parents exist due to `#[macro_export] macro_rules!`,\n+    /// but they cannot use def-site hygiene, so the assumption holds\n+    /// (<https://github.com/rust-lang/rust/pull/77984#issuecomment-712445508>).\n+    fn get_nearest_non_block_module(&mut self, mut def_id: DefId) -> Module<'a> {\n+        loop {\n+            match self.get_module(def_id) {\n+                Some(module) => return module,\n+                None => {\n+                    def_id.index =\n+                        self.def_key(def_id).parent.expect(\"non-root `DefId` without parent\")\n+                }\n+            }\n         }\n-        self.get_module(parent_id)\n     }\n \n-    pub fn get_module(&mut self, def_id: DefId) -> Module<'a> {\n-        // If this is a local module, it will be in `module_map`, no need to recalculate it.\n-        if let Some(def_id) = def_id.as_local() {\n-            return self.module_map[&def_id];\n-        }\n+    pub fn expect_module(&mut self, def_id: DefId) -> Module<'a> {\n+        self.get_module(def_id).expect(\"argument `DefId` is not a module\")\n+    }\n \n-        // Cache module resolution\n-        if let Some(&module) = self.extern_module_map.get(&def_id) {\n-            return module;\n+    /// If `def_id` refers to a module (in resolver's sense, i.e. a module item, crate root, enum,\n+    /// or trait), then this function returns that module's resolver representation, otherwise it\n+    /// returns `None`.\n+    /// FIXME: `Module`s for local enums and traits are not currently found.\n+    crate fn get_module(&mut self, def_id: DefId) -> Option<Module<'a>> {\n+        if let module @ Some(..) = self.module_map.get(&def_id) {\n+            return module.copied();\n         }\n \n-        let (name, parent) = if def_id.index == CRATE_DEF_INDEX {\n-            // This is the crate root\n-            (self.cstore().crate_name(def_id.krate), None)\n-        } else {\n-            let def_key = self.cstore().def_key(def_id);\n-            let name = def_key\n-                .disambiguated_data\n-                .data\n-                .get_opt_name()\n-                .expect(\"given a DefId that wasn't a module\");\n-\n-            let parent = Some(self.nearest_parent_mod(def_id));\n-            (name, parent)\n-        };\n+        if !def_id.is_local() {\n+            let def_kind = self.cstore().def_kind(def_id);\n+            match def_kind {\n+                DefKind::Mod | DefKind::Enum | DefKind::Trait => {\n+                    let def_key = self.cstore().def_key(def_id);\n+                    let parent = def_key.parent.map(|index| {\n+                        self.get_nearest_non_block_module(DefId { index, krate: def_id.krate })\n+                    });\n+                    let name = if def_id.index == CRATE_DEF_INDEX {\n+                        self.cstore().crate_name(def_id.krate)\n+                    } else {\n+                        def_key.disambiguated_data.data.get_opt_name().expect(\"module without name\")\n+                    };\n \n-        // Allocate and return a new module with the information we found\n-        let kind = ModuleKind::Def(DefKind::Mod, def_id, name);\n-        let module = self.arenas.alloc_module(ModuleData::new(\n-            parent,\n-            kind,\n-            def_id,\n-            self.cstore().module_expansion_untracked(def_id, &self.session),\n-            self.cstore().get_span_untracked(def_id, &self.session),\n-        ));\n-        self.extern_module_map.insert(def_id, module);\n-        module\n+                    let module = self.arenas.new_module(\n+                        parent,\n+                        ModuleKind::Def(def_kind, def_id, name),\n+                        self.cstore().module_expansion_untracked(def_id, &self.session),\n+                        self.cstore().get_span_untracked(def_id, &self.session),\n+                        // FIXME: Account for `#[no_implicit_prelude]` attributes.\n+                        parent.map_or(false, |module| module.no_implicit_prelude),\n+                    );\n+                    self.module_map.insert(def_id, module);\n+                    Some(module)\n+                }\n+                _ => None,\n+            }\n+        } else {\n+            None\n+        }\n     }\n \n-    crate fn macro_def_scope(&mut self, expn_id: ExpnId) -> Module<'a> {\n-        let def_id = match expn_id.expn_data().macro_def_id {\n-            Some(def_id) => def_id,\n-            None => {\n-                return expn_id\n-                    .as_local()\n-                    .and_then(|expn_id| self.ast_transform_scopes.get(&expn_id))\n-                    .unwrap_or(&self.graph_root);\n-            }\n-        };\n-        self.macro_def_scope_from_def_id(def_id)\n+    crate fn expn_def_scope(&mut self, expn_id: ExpnId) -> Module<'a> {\n+        match expn_id.expn_data().macro_def_id {\n+            Some(def_id) => self.macro_def_scope(def_id),\n+            None => expn_id\n+                .as_local()\n+                .and_then(|expn_id| self.ast_transform_scopes.get(&expn_id))\n+                .unwrap_or(&self.graph_root),\n+        }\n     }\n \n-    crate fn macro_def_scope_from_def_id(&mut self, def_id: DefId) -> Module<'a> {\n+    crate fn macro_def_scope(&mut self, def_id: DefId) -> Module<'a> {\n         if let Some(id) = def_id.as_local() {\n             self.local_macro_def_scopes[&id]\n         } else {\n-            // This is not entirely correct - a `macro_rules!` macro may occur\n-            // inside a 'block' module:\n-            //\n-            // ```rust\n-            // const _: () = {\n-            // #[macro_export]\n-            // macro_rules! my_macro {\n-            //     () => {};\n-            // }\n-            // `\n-            // We don't record this information for external crates, so\n-            // the module we compute here will be the closest 'mod' item\n-            // (not necesssarily the actual parent of the `macro_rules!`\n-            // macro). `macro_rules!` macros can't use def-site hygiene,\n-            // so this hopefully won't be a problem.\n-            //\n-            // See https://github.com/rust-lang/rust/pull/77984#issuecomment-712445508\n-            self.nearest_parent_mod(def_id)\n+            self.get_nearest_non_block_module(def_id)\n         }\n     }\n \n@@ -274,7 +265,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                         self.r.visibilities[&def_id.expect_local()]\n                     }\n                     // Otherwise, the visibility is restricted to the nearest parent `mod` item.\n-                    _ => ty::Visibility::Restricted(self.parent_scope.module.nearest_parent_mod),\n+                    _ => ty::Visibility::Restricted(self.parent_scope.module.nearest_parent_mod()),\n                 })\n             }\n             ast::VisibilityKind::Restricted { ref path, id, .. } => {\n@@ -717,7 +708,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                         local_def_id,\n                     );\n                     self.r.extern_crate_map.insert(local_def_id, crate_id);\n-                    self.r.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX })\n+                    self.r.expect_module(crate_id.as_def_id())\n                 };\n \n                 let used = self.process_macro_use_imports(item, module);\n@@ -768,21 +759,16 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n \n             ItemKind::Mod(..) => {\n-                let module_kind = ModuleKind::Def(DefKind::Mod, def_id, ident.name);\n-                let module = self.r.arenas.alloc_module(ModuleData {\n-                    no_implicit_prelude: parent.no_implicit_prelude || {\n-                        self.r.session.contains_name(&item.attrs, sym::no_implicit_prelude)\n-                    },\n-                    ..ModuleData::new(\n-                        Some(parent),\n-                        module_kind,\n-                        def_id,\n-                        expansion.to_expn_id(),\n-                        item.span,\n-                    )\n-                });\n+                let module = self.r.arenas.new_module(\n+                    Some(parent),\n+                    ModuleKind::Def(DefKind::Mod, def_id, ident.name),\n+                    expansion.to_expn_id(),\n+                    item.span,\n+                    parent.no_implicit_prelude\n+                        || self.r.session.contains_name(&item.attrs, sym::no_implicit_prelude),\n+                );\n                 self.r.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n-                self.r.module_map.insert(local_def_id, module);\n+                self.r.module_map.insert(def_id, module);\n \n                 // Descend into the module.\n                 self.parent_scope.module = module;\n@@ -813,13 +799,12 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n \n             ItemKind::Enum(_, _) => {\n-                let module_kind = ModuleKind::Def(DefKind::Enum, def_id, ident.name);\n-                let module = self.r.new_module(\n-                    parent,\n-                    module_kind,\n-                    parent.nearest_parent_mod,\n+                let module = self.r.arenas.new_module(\n+                    Some(parent),\n+                    ModuleKind::Def(DefKind::Enum, def_id, ident.name),\n                     expansion.to_expn_id(),\n                     item.span,\n+                    parent.no_implicit_prelude,\n                 );\n                 self.r.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n                 self.parent_scope.module = module;\n@@ -888,13 +873,12 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n             ItemKind::Trait(..) => {\n                 // Add all the items within to a new module.\n-                let module_kind = ModuleKind::Def(DefKind::Trait, def_id, ident.name);\n-                let module = self.r.new_module(\n-                    parent,\n-                    module_kind,\n-                    parent.nearest_parent_mod,\n+                let module = self.r.arenas.new_module(\n+                    Some(parent),\n+                    ModuleKind::Def(DefKind::Trait, def_id, ident.name),\n                     expansion.to_expn_id(),\n                     item.span,\n+                    parent.no_implicit_prelude,\n                 );\n                 self.r.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n                 self.parent_scope.module = module;\n@@ -932,12 +916,12 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         let parent = self.parent_scope.module;\n         let expansion = self.parent_scope.expansion;\n         if self.block_needs_anonymous_module(block) {\n-            let module = self.r.new_module(\n-                parent,\n+            let module = self.r.arenas.new_module(\n+                Some(parent),\n                 ModuleKind::Block(block.id),\n-                parent.nearest_parent_mod,\n                 expansion.to_expn_id(),\n                 block.span,\n+                parent.no_implicit_prelude,\n             );\n             self.r.block_map.insert(block.id, module);\n             self.parent_scope.module = module; // Descend into the block.\n@@ -953,12 +937,13 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         // Record primary definitions.\n         match res {\n             Res::Def(kind @ (DefKind::Mod | DefKind::Enum | DefKind::Trait), def_id) => {\n-                let module = self.r.new_module(\n-                    parent,\n+                let module = self.r.arenas.new_module(\n+                    Some(parent),\n                     ModuleKind::Def(kind, def_id, ident.name),\n-                    def_id,\n                     expansion.to_expn_id(),\n                     span,\n+                    // FIXME: Account for `#[no_implicit_prelude]` attributes.\n+                    parent.no_implicit_prelude,\n                 );\n                 self.r.define(parent, ident, TypeNS, (module, vis, span, expansion));\n             }"}, {"sha": "435c79d2daf45d19a76f95be8f2e5ec7889ed666", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/73422130ee96c09e7214c876a3600ac1f32aa8c8/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73422130ee96c09e7214c876a3600ac1f32aa8c8/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=73422130ee96c09e7214c876a3600ac1f32aa8c8", "patch": "@@ -915,8 +915,7 @@ impl<'a> Resolver<'a> {\n                     continue;\n                 }\n                 if let Some(crate_id) = self.crate_loader.maybe_process_path_extern(ident.name) {\n-                    let crate_root =\n-                        self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n+                    let crate_root = self.expect_module(crate_id.as_def_id());\n                     suggestions.extend(self.lookup_import_candidates_from_module(\n                         lookup_ident,\n                         namespace,"}, {"sha": "7556f69c39116f7993abeb3d7b87fc6d2dce04eb", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/73422130ee96c09e7214c876a3600ac1f32aa8c8/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73422130ee96c09e7214c876a3600ac1f32aa8c8/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=73422130ee96c09e7214c876a3600ac1f32aa8c8", "patch": "@@ -427,7 +427,7 @@ impl<'a> Resolver<'a> {\n             match ident.span.glob_adjust(module.expansion, glob_import.span) {\n                 Some(Some(def)) => {\n                     tmp_parent_scope =\n-                        ParentScope { module: self.macro_def_scope(def), ..*parent_scope };\n+                        ParentScope { module: self.expn_def_scope(def), ..*parent_scope };\n                     adjusted_parent_scope = &tmp_parent_scope;\n                 }\n                 Some(None) => {}\n@@ -585,7 +585,7 @@ impl<'a> Resolver<'a> {\n         for import in module.glob_importers.borrow_mut().iter() {\n             let mut ident = key.ident;\n             let scope = match ident.span.reverse_glob_adjust(module.expansion, import.span) {\n-                Some(Some(def)) => self.macro_def_scope(def),\n+                Some(Some(def)) => self.expn_def_scope(def),\n                 Some(None) => import.parent_scope.module,\n                 None => continue,\n             };\n@@ -1364,7 +1364,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             .collect::<Vec<_>>();\n         for (mut key, binding) in bindings {\n             let scope = match key.ident.span.reverse_glob_adjust(module.expansion, import.span) {\n-                Some(Some(def)) => self.r.macro_def_scope(def),\n+                Some(Some(def)) => self.r.expn_def_scope(def),\n                 Some(None) => import.parent_scope.module,\n                 None => continue,\n             };"}, {"sha": "3c48a76224fd964f8d750978ee035f80223d4452", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/73422130ee96c09e7214c876a3600ac1f32aa8c8/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73422130ee96c09e7214c876a3600ac1f32aa8c8/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=73422130ee96c09e7214c876a3600ac1f32aa8c8", "patch": "@@ -799,9 +799,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     }\n \n     fn with_scope<T>(&mut self, id: NodeId, f: impl FnOnce(&mut Self) -> T) -> T {\n-        let id = self.r.local_def_id(id);\n-        let module = self.r.module_map.get(&id).cloned(); // clones a reference\n-        if let Some(module) = module {\n+        if let Some(module) = self.r.get_module(self.r.local_def_id(id).to_def_id()) {\n             // Move down in the graph.\n             let orig_module = replace(&mut self.parent_scope.module, module);\n             self.with_rib(ValueNS, ModuleRibKind(module), |this| {\n@@ -1872,7 +1870,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             if this.should_report_errs() {\n                 let (err, candidates) = this.smart_resolve_report_errors(path, span, source, res);\n \n-                let def_id = this.parent_scope.module.nearest_parent_mod;\n+                let def_id = this.parent_scope.module.nearest_parent_mod();\n                 let instead = res.is_some();\n                 let suggestion =\n                     if res.is_none() { this.report_missing_type_error(path) } else { None };\n@@ -1940,7 +1938,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n             drop(parent_err);\n \n-            let def_id = this.parent_scope.module.nearest_parent_mod;\n+            let def_id = this.parent_scope.module.nearest_parent_mod();\n \n             if this.should_report_errs() {\n                 this.r.use_injections.push(UseError {"}, {"sha": "68db06370ffea1aa462345d2027e05ee58653efe", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 58, "deletions": 57, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/73422130ee96c09e7214c876a3600ac1f32aa8c8/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73422130ee96c09e7214c876a3600ac1f32aa8c8/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=73422130ee96c09e7214c876a3600ac1f32aa8c8", "patch": "@@ -40,7 +40,8 @@ use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_expand::base::{DeriveResolutions, SyntaxExtension, SyntaxExtensionKind};\n use rustc_hir::def::Namespace::*;\n use rustc_hir::def::{self, CtorOf, DefKind, NonMacroAttrKind, PartialRes};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefPathHash, LocalDefId, CRATE_DEF_INDEX};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefPathHash, LocalDefId};\n+use rustc_hir::def_id::{CRATE_DEF_ID, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPathData, Definitions};\n use rustc_hir::TraitCandidate;\n use rustc_index::vec::IndexVec;\n@@ -505,10 +506,6 @@ pub struct ModuleData<'a> {\n     /// What kind of module this is, because this may not be a `mod`.\n     kind: ModuleKind,\n \n-    /// The [`DefId`] of the nearest `mod` item ancestor (which may be this module).\n-    /// This may be the crate root.\n-    nearest_parent_mod: DefId,\n-\n     /// Mapping between names and their (possibly in-progress) resolutions in this module.\n     /// Resolutions in modules from other crates are not populated until accessed.\n     lazy_resolutions: Resolutions<'a>,\n@@ -539,18 +536,21 @@ impl<'a> ModuleData<'a> {\n     fn new(\n         parent: Option<Module<'a>>,\n         kind: ModuleKind,\n-        nearest_parent_mod: DefId,\n         expansion: ExpnId,\n         span: Span,\n+        no_implicit_prelude: bool,\n     ) -> Self {\n+        let is_foreign = match kind {\n+            ModuleKind::Def(_, def_id, _) => !def_id.is_local(),\n+            ModuleKind::Block(_) => false,\n+        };\n         ModuleData {\n             parent,\n             kind,\n-            nearest_parent_mod,\n             lazy_resolutions: Default::default(),\n-            populate_on_access: Cell::new(!nearest_parent_mod.is_local()),\n+            populate_on_access: Cell::new(is_foreign),\n             unexpanded_invocations: Default::default(),\n-            no_implicit_prelude: false,\n+            no_implicit_prelude,\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new(Vec::new()),\n             traits: RefCell::new(None),\n@@ -623,6 +623,15 @@ impl<'a> ModuleData<'a> {\n         }\n     }\n \n+    /// The [`DefId`] of the nearest `mod` item ancestor (which may be this module).\n+    /// This may be the crate root.\n+    fn nearest_parent_mod(&self) -> DefId {\n+        match self.kind {\n+            ModuleKind::Def(DefKind::Mod, def_id, _) => def_id,\n+            _ => self.parent.expect(\"non-root module without parent\").nearest_parent_mod(),\n+        }\n+    }\n+\n     fn is_ancestor_of(&self, mut other: &Self) -> bool {\n         while !ptr::eq(self, other) {\n             if let Some(parent) = other.parent {\n@@ -934,8 +943,7 @@ pub struct Resolver<'a> {\n     /// some AST passes can generate identifiers that only resolve to local or\n     /// language items.\n     empty_module: Module<'a>,\n-    module_map: FxHashMap<LocalDefId, Module<'a>>,\n-    extern_module_map: FxHashMap<DefId, Module<'a>>,\n+    module_map: FxHashMap<DefId, Module<'a>>,\n     binding_parent_modules: FxHashMap<PtrKey<'a, NameBinding<'a>>, Module<'a>>,\n     underscore_disambiguator: u32,\n \n@@ -1052,8 +1060,16 @@ pub struct ResolverArenas<'a> {\n }\n \n impl<'a> ResolverArenas<'a> {\n-    fn alloc_module(&'a self, module: ModuleData<'a>) -> Module<'a> {\n-        let module = self.modules.alloc(module);\n+    fn new_module(\n+        &'a self,\n+        parent: Option<Module<'a>>,\n+        kind: ModuleKind,\n+        expn_id: ExpnId,\n+        span: Span,\n+        no_implicit_prelude: bool,\n+    ) -> Module<'a> {\n+        let module =\n+            self.modules.alloc(ModuleData::new(parent, kind, expn_id, span, no_implicit_prelude));\n         if module.def_id().map_or(true, |def_id| def_id.is_local()) {\n             self.local_modules.borrow_mut().push(module);\n         }\n@@ -1255,32 +1271,29 @@ impl<'a> Resolver<'a> {\n         metadata_loader: Box<MetadataLoaderDyn>,\n         arenas: &'a ResolverArenas<'a>,\n     ) -> Resolver<'a> {\n-        let root_local_def_id = LocalDefId { local_def_index: CRATE_DEF_INDEX };\n-        let root_def_id = root_local_def_id.to_def_id();\n-        let root_module_kind = ModuleKind::Def(DefKind::Mod, root_def_id, kw::Empty);\n-        let graph_root = arenas.alloc_module(ModuleData {\n-            no_implicit_prelude: session.contains_name(&krate.attrs, sym::no_implicit_prelude),\n-            ..ModuleData::new(None, root_module_kind, root_def_id, ExpnId::root(), krate.span)\n-        });\n-        let empty_module_kind = ModuleKind::Def(DefKind::Mod, root_def_id, kw::Empty);\n-        let empty_module = arenas.alloc_module(ModuleData {\n-            no_implicit_prelude: true,\n-            ..ModuleData::new(\n-                Some(graph_root),\n-                empty_module_kind,\n-                root_def_id,\n-                ExpnId::root(),\n-                DUMMY_SP,\n-            )\n-        });\n+        let root_def_id = CRATE_DEF_ID.to_def_id();\n+        let graph_root = arenas.new_module(\n+            None,\n+            ModuleKind::Def(DefKind::Mod, root_def_id, kw::Empty),\n+            ExpnId::root(),\n+            krate.span,\n+            session.contains_name(&krate.attrs, sym::no_implicit_prelude),\n+        );\n+        let empty_module = arenas.new_module(\n+            None,\n+            ModuleKind::Def(DefKind::Mod, root_def_id, kw::Empty),\n+            ExpnId::root(),\n+            DUMMY_SP,\n+            true,\n+        );\n         let mut module_map = FxHashMap::default();\n-        module_map.insert(root_local_def_id, graph_root);\n+        module_map.insert(root_def_id, graph_root);\n \n         let definitions = Definitions::new(session.local_stable_crate_id(), krate.span);\n         let root = definitions.get_root_def();\n \n         let mut visibilities = FxHashMap::default();\n-        visibilities.insert(root_local_def_id, ty::Visibility::Public);\n+        visibilities.insert(CRATE_DEF_ID, ty::Visibility::Public);\n \n         let mut def_id_to_node_id = IndexVec::default();\n         assert_eq!(def_id_to_node_id.push(CRATE_NODE_ID), root);\n@@ -1341,7 +1354,6 @@ impl<'a> Resolver<'a> {\n             empty_module,\n             module_map,\n             block_map: Default::default(),\n-            extern_module_map: FxHashMap::default(),\n             binding_parent_modules: FxHashMap::default(),\n             ast_transform_scopes: FxHashMap::default(),\n \n@@ -1632,18 +1644,6 @@ impl<'a> Resolver<'a> {\n         import_ids\n     }\n \n-    fn new_module(\n-        &self,\n-        parent: Module<'a>,\n-        kind: ModuleKind,\n-        nearest_parent_mod: DefId,\n-        expn_id: ExpnId,\n-        span: Span,\n-    ) -> Module<'a> {\n-        let module = ModuleData::new(Some(parent), kind, nearest_parent_mod, expn_id, span);\n-        self.arenas.alloc_module(module)\n-    }\n-\n     fn new_key(&mut self, ident: Ident, ns: Namespace) -> BindingKey {\n         let ident = ident.normalize_to_macros_2_0();\n         let disambiguator = if ident.name == kw::Underscore {\n@@ -2016,7 +2016,7 @@ impl<'a> Resolver<'a> {\n         derive_fallback_lint_id: Option<NodeId>,\n     ) -> Option<(Module<'a>, Option<NodeId>)> {\n         if !module.expansion.outer_expn_is_descendant_of(*ctxt) {\n-            return Some((self.macro_def_scope(ctxt.remove_mark()), None));\n+            return Some((self.expn_def_scope(ctxt.remove_mark()), None));\n         }\n \n         if let ModuleKind::Block(..) = module.kind {\n@@ -2085,7 +2085,7 @@ impl<'a> Resolver<'a> {\n             ModuleOrUniformRoot::Module(m) => {\n                 if let Some(def) = ident.span.normalize_to_macros_2_0_and_adjust(m.expansion) {\n                     tmp_parent_scope =\n-                        ParentScope { module: self.macro_def_scope(def), ..*parent_scope };\n+                        ParentScope { module: self.expn_def_scope(def), ..*parent_scope };\n                     adjusted_parent_scope = &tmp_parent_scope;\n                 }\n             }\n@@ -2158,7 +2158,7 @@ impl<'a> Resolver<'a> {\n             ctxt.adjust(ExpnId::root())\n         };\n         let module = match mark {\n-            Some(def) => self.macro_def_scope(def),\n+            Some(def) => self.expn_def_scope(def),\n             None => {\n                 debug!(\n                     \"resolve_crate_root({:?}): found no mark (ident.span = {:?})\",\n@@ -2167,7 +2167,8 @@ impl<'a> Resolver<'a> {\n                 return self.graph_root;\n             }\n         };\n-        let module = self.get_module(DefId { index: CRATE_DEF_INDEX, ..module.nearest_parent_mod });\n+        let module = self\n+            .expect_module(module.def_id().map_or(LOCAL_CRATE, |def_id| def_id.krate).as_def_id());\n         debug!(\n             \"resolve_crate_root({:?}): got module {:?} ({:?}) (ident.span = {:?})\",\n             ident,\n@@ -2179,10 +2180,10 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_self(&mut self, ctxt: &mut SyntaxContext, module: Module<'a>) -> Module<'a> {\n-        let mut module = self.get_module(module.nearest_parent_mod);\n+        let mut module = self.expect_module(module.nearest_parent_mod());\n         while module.span.ctxt().normalize_to_macros_2_0() != *ctxt {\n-            let parent = module.parent.unwrap_or_else(|| self.macro_def_scope(ctxt.remove_mark()));\n-            module = self.get_module(parent.nearest_parent_mod);\n+            let parent = module.parent.unwrap_or_else(|| self.expn_def_scope(ctxt.remove_mark()));\n+            module = self.expect_module(parent.nearest_parent_mod());\n         }\n         module\n     }\n@@ -2896,7 +2897,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn is_accessible_from(&self, vis: ty::Visibility, module: Module<'a>) -> bool {\n-        vis.is_accessible_from(module.nearest_parent_mod, self)\n+        vis.is_accessible_from(module.nearest_parent_mod(), self)\n     }\n \n     fn set_binding_parent_module(&mut self, binding: &'a NameBinding<'a>, module: Module<'a>) {\n@@ -2920,7 +2921,7 @@ impl<'a> Resolver<'a> {\n             self.binding_parent_modules.get(&PtrKey(modularized)),\n         ) {\n             (Some(macro_rules), Some(modularized)) => {\n-                macro_rules.nearest_parent_mod == modularized.nearest_parent_mod\n+                macro_rules.nearest_parent_mod() == modularized.nearest_parent_mod()\n                     && modularized.is_ancestor_of(macro_rules)\n             }\n             _ => false,\n@@ -3265,7 +3266,7 @@ impl<'a> Resolver<'a> {\n                 } else {\n                     self.crate_loader.maybe_process_path_extern(ident.name)?\n                 };\n-                let crate_root = self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n+                let crate_root = self.expect_module(crate_id.as_def_id());\n                 Some(\n                     (crate_root, ty::Visibility::Public, DUMMY_SP, LocalExpnId::ROOT)\n                         .to_name_binding(self.arenas),\n@@ -3306,7 +3307,7 @@ impl<'a> Resolver<'a> {\n                 tokens: None,\n             }\n         };\n-        let module = self.get_module(module_id);\n+        let module = self.expect_module(module_id);\n         let parent_scope = &ParentScope::module(module, self);\n         let res = self.resolve_ast_path(&path, ns, parent_scope).map_err(|_| ())?;\n         Ok((path, res))"}, {"sha": "39605ec1840f3d398572f1ba2aef5259037a9806", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/73422130ee96c09e7214c876a3600ac1f32aa8c8/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73422130ee96c09e7214c876a3600ac1f32aa8c8/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=73422130ee96c09e7214c876a3600ac1f32aa8c8", "patch": "@@ -225,21 +225,22 @@ impl<'a> ResolverExpand for Resolver<'a> {\n         features: &[Symbol],\n         parent_module_id: Option<NodeId>,\n     ) -> LocalExpnId {\n-        let parent_module = parent_module_id.map(|module_id| self.local_def_id(module_id));\n+        let parent_module =\n+            parent_module_id.map(|module_id| self.local_def_id(module_id).to_def_id());\n         let expn_id = LocalExpnId::fresh(\n             ExpnData::allow_unstable(\n                 ExpnKind::AstPass(pass),\n                 call_site,\n                 self.session.edition(),\n                 features.into(),\n                 None,\n-                parent_module.map(LocalDefId::to_def_id),\n+                parent_module,\n             ),\n             self.create_stable_hashing_context(),\n         );\n \n-        let parent_scope = parent_module\n-            .map_or(self.empty_module, |parent_def_id| self.module_map[&parent_def_id]);\n+        let parent_scope =\n+            parent_module.map_or(self.empty_module, |def_id| self.expect_module(def_id));\n         self.ast_transform_scopes.insert(expn_id, parent_scope);\n \n         expn_id\n@@ -298,15 +299,14 @@ impl<'a> ResolverExpand for Resolver<'a> {\n         )?;\n \n         let span = invoc.span();\n+        let def_id = res.opt_def_id();\n         invoc_id.set_expn_data(\n             ext.expn_data(\n                 parent_scope.expansion,\n                 span,\n                 fast_print_path(path),\n-                res.opt_def_id(),\n-                res.opt_def_id().map(|macro_def_id| {\n-                    self.macro_def_scope_from_def_id(macro_def_id).nearest_parent_mod\n-                }),\n+                def_id,\n+                def_id.map(|def_id| self.macro_def_scope(def_id).nearest_parent_mod()),\n             ),\n             self.create_stable_hashing_context(),\n         );"}, {"sha": "318c897bcbdf6f1c395effdc447d09cd689f1a16", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73422130ee96c09e7214c876a3600ac1f32aa8c8/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73422130ee96c09e7214c876a3600ac1f32aa8c8/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=73422130ee96c09e7214c876a3600ac1f32aa8c8", "patch": "@@ -759,7 +759,7 @@ fn traits_implemented_by(cx: &mut DocContext<'_>, type_: DefId, module: DefId) -\n     let mut resolver = cx.resolver.borrow_mut();\n     let in_scope_traits = cx.module_trait_cache.entry(module).or_insert_with(|| {\n         resolver.access(|resolver| {\n-            let parent_scope = &ParentScope::module(resolver.get_module(module), resolver);\n+            let parent_scope = &ParentScope::module(resolver.expect_module(module), resolver);\n             resolver\n                 .traits_in_scope(None, parent_scope, SyntaxContext::root(), None)\n                 .into_iter()"}, {"sha": "7576c1326b8e494c8902d21888a85976639d9d82", "filename": "src/test/rustdoc/macro-document-private-duplicate.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73422130ee96c09e7214c876a3600ac1f32aa8c8/src%2Ftest%2Frustdoc%2Fmacro-document-private-duplicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73422130ee96c09e7214c876a3600ac1f32aa8c8/src%2Ftest%2Frustdoc%2Fmacro-document-private-duplicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmacro-document-private-duplicate.rs?ref=73422130ee96c09e7214c876a3600ac1f32aa8c8", "patch": "@@ -1,3 +1,5 @@\n+// ignore-test (fails spuriously, see issue #89228)\n+\n // FIXME: If two macros in the same module have the same name\n // (yes, that's a thing), rustdoc lists both of them on the index page,\n // but only documents the first one on the page for the macro."}]}