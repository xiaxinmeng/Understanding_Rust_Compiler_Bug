{"sha": "8b731a5cac22f37d3709c889e4de342ca851e3ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiNzMxYTVjYWMyMmYzN2QzNzA5Yzg4OWU0ZGUzNDJjYTg1MWUzZmY=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2015-07-12T22:31:09Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2015-07-12T22:31:09Z"}, "message": "Add error codes", "tree": {"sha": "9a23e5916d953bde7bf13ed13d886c9ef17d5ca2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a23e5916d953bde7bf13ed13d886c9ef17d5ca2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b731a5cac22f37d3709c889e4de342ca851e3ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b731a5cac22f37d3709c889e4de342ca851e3ff", "html_url": "https://github.com/rust-lang/rust/commit/8b731a5cac22f37d3709c889e4de342ca851e3ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b731a5cac22f37d3709c889e4de342ca851e3ff/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e00b3177001dd8281038930f4a5d0f214420bc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e00b3177001dd8281038930f4a5d0f214420bc4", "html_url": "https://github.com/rust-lang/rust/commit/2e00b3177001dd8281038930f4a5d0f214420bc4"}], "stats": {"total": 329, "additions": 113, "deletions": 216}, "files": [{"sha": "00745136eef223d994bdd1640d8b7f319d028c5d", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8b731a5cac22f37d3709c889e4de342ca851e3ff/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b731a5cac22f37d3709c889e4de342ca851e3ff/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=8b731a5cac22f37d3709c889e4de342ca851e3ff", "patch": "@@ -208,10 +208,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     // Return an error here by looking up the namespace that\n                     // had the duplicate.\n                     let ns = ns.unwrap();\n-                    self.resolve_error(sp,\n-                        &format!(\"duplicate definition of {} `{}`\",\n-                             namespace_error_to_string(duplicate_type),\n-                             token::get_name(name)));\n+                    resolve_err!(self, sp, E0428,\n+                                 \"duplicate definition of {} `{}`\",\n+                                 namespace_error_to_string(duplicate_type),\n+                                 token::get_name(name));\n                     {\n                         let r = child.span_for_namespace(ns);\n                         if let Some(sp) = r {\n@@ -304,8 +304,9 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                             full_path.segments.last().unwrap().identifier.name;\n                         if &token::get_name(source_name)[..] == \"mod\" ||\n                            &token::get_name(source_name)[..] == \"self\" {\n-                            self.resolve_error(view_path.span,\n-                                \"`self` imports are only allowed within a { } list\");\n+                            resolve_err!(self, view_path.span, E0429,\n+                                         \"{}\",\n+                                         \"`self` imports are only allowed within a { } list\");\n                         }\n \n                         let subclass = SingleImport(binding.name,\n@@ -325,8 +326,9 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                             _ => None\n                         }).collect::<Vec<Span>>();\n                         if mod_spans.len() > 1 {\n-                            self.resolve_error(mod_spans[0],\n-                                \"`self` import can only appear once in the list\");\n+                            resolve_err!(self, mod_spans[0], E0430,\n+                                         \"{}\",\n+                                         \"`self` import can only appear once in the list\");\n                             for other_span in mod_spans.iter().skip(1) {\n                                 self.session.span_note(*other_span,\n                                     \"another `self` import appears here\");\n@@ -341,7 +343,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                     let name = match module_path.last() {\n                                         Some(name) => *name,\n                                         None => {\n-                                            self.resolve_error(source_item.span,\n+                                            resolve_err!(self, source_item.span, E0431,\n+                                                \"{}\",\n                                                 \"`self` import can only appear in an import list \\\n                                                  with a non-empty prefix\");\n                                             continue;"}, {"sha": "34cd6ef002ec8a32a37119ecf5d86f37214ec0b2", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8b731a5cac22f37d3709c889e4de342ca851e3ff/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b731a5cac22f37d3709c889e4de342ca851e3ff/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=8b731a5cac22f37d3709c889e4de342ca851e3ff", "patch": "@@ -209,5 +209,45 @@ register_diagnostics! {\n     E0257,\n     E0258,\n     E0364, // item is private\n-    E0365  // item is private\n+    E0365, // item is private\n+    E0397, // failed to resolve\n+    E0398, // unresolved import\n+    E0399, // can't capture dynamic environment in a fn item\n+    E0400, // attempt to use a non-constant value in a constant\n+    E0401, // can't use type parameters from outer function\n+    E0402, // cannot use an outer type parameter in this context\n+    E0403, // the name `{}` is already used\n+    E0404, // is not a trait\n+    E0405, // use of undeclared trait name\n+    E0406, // undeclared associated type\n+    E0407, // method is not a member of trait\n+    E0408, // variable from pattern #1 is not bound in pattern #\n+    E0409, // variable is bound with different mode in pattern # than in\n+           // pattern #1\n+    E0410, // variable from pattern is not bound in pattern 1\n+    E0411, // use of `Self` outside of an impl or trait\n+    E0412, // use of undeclared\n+    E0413, // declaration of shadows an enum variant or unit-like struct in\n+           // scope\n+    E0414, // only irrefutable patterns allowed here\n+    E0415, // identifier is bound more than once in this parameter list\n+    E0416, // identifier is bound more than once in the same pattern\n+    E0417, // static variables cannot be referenced in a pattern, use a\n+           // `const` instead\n+    E0418, // is not an enum variant, struct or const\n+    E0419, // unresolved enum variant, struct or const\n+    E0420, // is not an associated const\n+    E0421, // unresolved associated const\n+    E0422, // does not name a structure\n+    E0423, // is a struct variant name, but this expression uses it like a\n+           // function name\n+    E0424, // `self` is not available in a static method.\n+    E0425, // unresolved name\n+    E0426, // use of undeclared label\n+    E0427, // cannot use `ref` binding mode with ...\n+    E0428, // duplicate definition of ...\n+    E0429, // `self` imports are only allowed within a { } list\n+    E0430, // `self` import can only appear once in the list\n+    E0431  // `self` import can only appear in an import list with a non-empty\n+           // prefix\n }"}, {"sha": "c0e42f269ee2f5b891add36e8bc8e54805974d07", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 56, "deletions": 202, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/8b731a5cac22f37d3709c889e4de342ca851e3ff/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b731a5cac22f37d3709c889e4de342ca851e3ff/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8b731a5cac22f37d3709c889e4de342ca851e3ff", "patch": "@@ -26,6 +26,16 @@\n #![feature(slice_extras)]\n #![feature(staged_api)]\n \n+#![macro_use]\n+\n+macro_rules! resolve_err {\n+    ($this:expr, $span:expr, $code:ident, $($rest:tt)*) => {\n+        if $this.emit_errors {\n+            span_err!($this.session, $span, $code, $($rest)*);\n+        }\n+    }\n+}\n+\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n #[macro_use] #[no_link] extern crate rustc_bitflags;\n@@ -109,21 +119,6 @@ mod record_exports;\n mod build_reduced_graph;\n mod resolve_imports;\n \n-macro_rules! span_err {\n-    ($session:expr, $span:expr, $code:ident, $($message:tt)*) => ({\n-        __diagnostic_used!($code);\n-        $session.span_err_with_code($span, &format!($($message)*), stringify!($code))\n-    })\n-}\n-\n-macro_rules! resolve_err {\n-    ($this:expr, $span:expr, $code:ident, $($rest:tt)*) => {\n-        if $this.emit_errors {\n-            span_err!($this.session, $span, $code, $($rest)*);\n-        }\n-    }\n-}\n-\n #[derive(Copy, Clone)]\n struct BindingInfo {\n     span: Span,\n@@ -1318,10 +1313,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                               PathSearch,\n                                               true) {\n                 Failed(Some((span, msg))) => {\n-                    /*self.resolve_error(span,\n-                                       &format!(\"failed to resolve. {}\",\n-                                                msg));*/\n-                    resolve_err!(self, span, E0253, \"failed to resolve. {}\", msg);\n+                    resolve_err!(self, span, E0397, \"failed to resolve. {}\", msg);\n                 },\n                 Failed(None) => (), // Continue up the search chain.\n                 Indeterminate => {\n@@ -1579,15 +1571,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                          .span_to_snippet((*imports)[index].span)\n                          .unwrap();\n             if sn.contains(\"::\") {\n-                /*self.resolve_error((*imports)[index].span,\n-                                   \"unresolved import\");*/\n-                resolve_err!(self, (*imports)[index].span, E0253,\n+                resolve_err!(self, (*imports)[index].span, E0398,\n                              \"{}\", \"unresolved import\");\n             } else {\n-                /*let err = format!(\"unresolved import (maybe you meant `{}::*`?)\",\n-                                  sn);\n-                self.resolve_error((*imports)[index].span, &err[..]);*/\n-                resolve_err!(self, (*imports)[index].span, E0253,\n+                resolve_err!(self, (*imports)[index].span, E0398,\n                              \"unresolved import (maybe you meant `{}::*`?)\", sn);\n             }\n         }\n@@ -1714,21 +1701,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             // This was an attempt to access an upvar inside a\n                             // named function item. This is not allowed, so we\n                             // report an error.\n-\n-                            /*self.resolve_error(span,\n-                                \"can't capture dynamic environment in a fn item; \\\n-                                 use the || { ... } closure form instead\");*/\n-                            resolve_err!(self, span, E0253, \"{}\",\n+                            resolve_err!(self, span, E0399, \"{}\",\n                                          \"can't capture dynamic environment in a fn item; \\\n                                           use the || { ... } closure form instead\");\n                             return None;\n                         }\n                         ConstantItemRibKind => {\n                             // Still doesn't deal with upvars\n-                            /*self.resolve_error(span,\n-                                               \"attempt to use a non-constant \\\n-                                                value in a constant\");*/\n-                            resolve_err!(self, span, E0253, \"{}\",\n+                            resolve_err!(self, span, E0400, \"{}\",\n                                          \"attempt to use a non-constant \\\n                                           value in a constant\");\n                             return None;\n@@ -1746,22 +1726,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             // This was an attempt to use a type parameter outside\n                             // its scope.\n \n-                            /*self.resolve_error(span,\n-                                               \"can't use type parameters from \\\n-                                                outer function; try using a local \\\n-                                                type parameter instead\");*/\n-                            resolve_err!(self, span, E0253, \"{}\",\n+                            resolve_err!(self, span, E0401, \"{}\",\n                                          \"can't use type parameters from \\\n                                           outer function; try using a local \\\n                                           type parameter instead\");\n                             return None;\n                         }\n                         ConstantItemRibKind => {\n                             // see #9186\n-                            /*self.resolve_error(span,\n-                                               \"cannot use an outer type \\\n-                                                parameter in this context\");*/\n-                            resolve_err!(self, span, E0253, \"{}\",\n+                            resolve_err!(self, span, E0402, \"{}\",\n                                          \"cannot use an outer type \\\n                                           parameter in this context\");\n                             return None;\n@@ -1961,13 +1934,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     debug!(\"with_type_parameter_rib: {}\", type_parameter.id);\n \n                     if seen_bindings.contains(&name) {\n-                        /*self.resolve_error(type_parameter.span,\n-                                           &format!(\"the name `{}` is already \\\n-                                                     used for a type \\\n-                                                     parameter in this type \\\n-                                                     parameter list\",\n-                                                    name))*/\n-                        resolve_err!(self, type_parameter.span, E0253,\n+                        resolve_err!(self, type_parameter.span, E0403,\n                                      \"the name `{}` is already \\\n                                       used for a type \\\n                                       parameter in this type \\\n@@ -2059,10 +2026,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 debug!(\"(resolving trait) found trait def: {:?}\", path_res);\n                 Ok(path_res)\n             } else {\n-                /*self.resolve_error(trait_path.span,\n-                    &format!(\"`{}` is not a trait\",\n-                             path_names_to_string(trait_path, path_depth)));*/\n-                resolve_err!(self, trait_path.span, E0253,\n+                resolve_err!(self, trait_path.span, E0404,\n                              \"`{}` is not a trait\",\n                              path_names_to_string(trait_path, path_depth));\n \n@@ -2074,10 +2038,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 Err(())\n             }\n         } else {\n-            /*let msg = format!(\"use of undeclared trait name `{}`\",\n-                              path_names_to_string(trait_path, path_depth));\n-            self.resolve_error(trait_path.span, &msg);*/\n-            resolve_err!(self, trait_path.span, E0253,\n+            resolve_err!(self, trait_path.span, E0405,\n                          \"use of undeclared trait name `{}`\",\n                          path_names_to_string(trait_path, path_depth));\n             Err(())\n@@ -2097,8 +2058,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     if let Some(PathResolution { base_def: DefTyParam(..), .. }) = path_res {\n                         self.record_def(eq_pred.id, path_res.unwrap());\n                     } else {\n-                        //self.resolve_error(eq_pred.path.span, \"undeclared associated type\");\n-                        resolve_err!(self, eq_pred.span, E0253, \"{}\",\n+                        resolve_err!(self, eq_pred.span, E0406, \"{}\",\n                                      \"undeclared associated type\");\n                     }\n                 }\n@@ -2224,11 +2184,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if let Some((did, ref trait_ref)) = self.current_trait_ref {\n             if !self.trait_item_map.contains_key(&(name, did)) {\n                 let path_str = path_names_to_string(&trait_ref.path, 0);\n-                /*self.resolve_error(span,\n-                                    &format!(\"method `{}` is not a member of trait `{}`\",\n-                                            name,\n-                                            path_str));*/\n-                resolve_err!(self, span, E0253, \"method `{}` is not a member of trait `{}`\",\n+                resolve_err!(self, span, E0407, \"method `{}` is not a member of trait `{}`\",\n                              name, path_str);\n             }\n         }\n@@ -2276,27 +2232,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             for (&key, &binding_0) in &map_0 {\n                 match map_i.get(&key) {\n                   None => {\n-                    /*self.resolve_error(\n-                        p.span,\n-                        &format!(\"variable `{}` from pattern #1 is \\\n-                                  not bound in pattern #{}\",\n-                                key,\n-                                i + 1));*/\n-                    resolve_err!(self, p.span, E0253,\n+                    resolve_err!(self, p.span, E0408,\n                                  \"variable `{}` from pattern #1 is \\\n                                   not bound in pattern #{}\",\n                                  key,\n                                  i + 1);\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n-                        /*self.resolve_error(\n-                            binding_i.span,\n-                            &format!(\"variable `{}` is bound with different \\\n-                                      mode in pattern #{} than in pattern #1\",\n-                                    key,\n-                                    i + 1));*/\n-                        resolve_err!(self, binding_i.span, E0253,\n+                        resolve_err!(self, binding_i.span, E0409,\n                                      \"variable `{}` is bound with different \\\n                                       mode in pattern #{} than in pattern #1\",\n                                      key,\n@@ -2308,13 +2252,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             for (&key, &binding) in &map_i {\n                 if !map_0.contains_key(&key) {\n-                    /*self.resolve_error(\n-                        binding.span,\n-                        &format!(\"variable `{}` from pattern {}{} is \\\n-                                  not bound in pattern {}1\",\n-                                key,\n-                                \"#\", i + 1, \"#\"));*/\n-                    resolve_err!(self, binding.span, E0253,\n+                    resolve_err!(self, binding.span, E0410,\n                                  \"variable `{}` from pattern {}{} is \\\n                                   not bound in pattern {}1\",\n                                  key,\n@@ -2431,16 +2369,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             path.segments.len() > 0 &&\n                             maybe_qself.is_none() &&\n                             path.segments[0].identifier.name == self_type_name;\n-                        let msg = if is_invalid_self_type_name {\n-                            \"use of `Self` outside of an impl or trait\".to_string()\n+                        if is_invalid_self_type_name {\n+                            resolve_err!(self, ty.span, E0411,\n+                                         \"{}\",\n+                                         \"use of `Self` outside of an impl or trait\");\n                         } else {\n-                            format!(\"use of undeclared {} `{}`\",\n-                                kind, path_names_to_string(path, 0))\n-                        };\n-\n-                        //self.resolve_error(ty.span, &msg[..]);\n-                        resolve_err!(self, ty.span, E0253,\n-                                     \"{}\", msg);\n+                            resolve_err!(self, ty.span, E0412,\n+                                         \"use of undeclared {} `{}`\",\n+                                         kind,\n+                                         path_names_to_string(path, 0));\n+                        }\n                     }\n                 }\n             }\n@@ -2491,13 +2429,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             });\n                         }\n                         FoundStructOrEnumVariant(..) => {\n-                            /*self.resolve_error(\n-                                pattern.span,\n-                                &format!(\"declaration of `{}` shadows an enum \\\n-                                         variant or unit-like struct in \\\n-                                         scope\",\n-                                        renamed));*/\n-                            resolve_err!(self, pattern.span, E0253,\n+                            resolve_err!(self, pattern.span, E0413,\n                                          \"declaration of `{}` shadows an enum \\\n                                          variant or unit-like struct in \\\n                                          scope\",\n@@ -2519,10 +2451,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             });\n                         }\n                         FoundConst(..) => {\n-                            /*self.resolve_error(pattern.span,\n-                                                  \"only irrefutable patterns \\\n-                                                   allowed here\");*/\n-                            resolve_err!(self, pattern.span, E0253,\n+                            resolve_err!(self, pattern.span, E0414,\n                                          \"{}\",\n                                          \"only irrefutable patterns \\\n                                           allowed here\");\n@@ -2557,16 +2486,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     bindings_list.contains_key(&renamed) {\n                                 // Forbid duplicate bindings in the same\n                                 // parameter list.\n-                                /*self.resolve_error(pattern.span,\n-                                                   &format!(\"identifier `{}` \\\n-                                                            is bound more \\\n-                                                            than once in \\\n-                                                            this parameter \\\n-                                                            list\",\n-                                                           token::get_ident(\n-                                                               ident))\n-                                                   )*/\n-                                resolve_err!(self, pattern.span, E0253,\n+                                resolve_err!(self, pattern.span, E0415,\n                                              \"identifier `{}` \\\n                                               is bound more \\\n                                               than once in \\\n@@ -2577,12 +2497,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     Some(&pat_id) {\n                                 // Then this is a duplicate variable in the\n                                 // same disjunction, which is an error.\n-                                /*self.resolve_error(pattern.span,\n-                                    &format!(\"identifier `{}` is bound \\\n-                                             more than once in the same \\\n-                                             pattern\",\n-                                            token::get_ident(ident)));*/\n-                                resolve_err!(self, pattern.span, E0253,\n+                                resolve_err!(self, pattern.span, E0416,\n                                              \"identifier `{}` is bound \\\n                                               more than once in the same \\\n                                               pattern\",\n@@ -2617,11 +2532,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 self.record_def(pattern.id, path_res);\n                             }\n                             DefStatic(..) => {\n-                                /*self.resolve_error(path.span,\n-                                                   \"static variables cannot be \\\n-                                                    referenced in a pattern, \\\n-                                                    use a `const` instead\");*/\n-                                resolve_err!(self, path.span, E0253, \"{}\",\n+                                resolve_err!(self, path.span, E0417, \"{}\",\n                                              \"static variables cannot be \\\n                                               referenced in a pattern, \\\n                                               use a `const` instead\");\n@@ -2632,12 +2543,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 // partially resolved, that's OK, because it may\n                                 // be a `T::CONST` that typeck will resolve.\n                                 if path_res.depth == 0 {\n-                                    /*self.resolve_error(\n-                                        path.span,\n-                                        &format!(\"`{}` is not an enum variant, struct or const\",\n-                                                 token::get_ident(\n-                                                     path.segments.last().unwrap().identifier)));*/\n-                                    resolve_err!(self, path.span, E0253,\n+                                    resolve_err!(self, path.span, E0418,\n                                                  \"`{}` is not an enum variant, struct or const\",\n                                                  token::get_ident(\n                                                      path.segments.last().unwrap().identifier));\n@@ -2651,10 +2557,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             }\n                         }\n                     } else {\n-                        /*self.resolve_error(path.span,\n-                            &format!(\"unresolved enum variant, struct or const `{}`\",\n-                                token::get_ident(path.segments.last().unwrap().identifier)));*/\n-                        resolve_err!(self, path.span, E0253,\n+                        resolve_err!(self, path.span, E0419,\n                                      \"unresolved enum variant, struct or const `{}`\",\n                                      token::get_ident(path.segments.last().unwrap().identifier));\n                     }\n@@ -2688,21 +2591,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 self.record_def(pattern.id, path_res);\n                             }\n                             _ => {\n-                                /*self.resolve_error(path.span,\n-                                    &format!(\"`{}` is not an associated const\",\n-                                        token::get_ident(\n-                                            path.segments.last().unwrap().identifier)));*/\n-                                resolve_err!(self, path.span, E0253,\n+                                resolve_err!(self, path.span, E0420,\n                                              \"`{}` is not an associated const\",\n                                              token::get_ident(\n                                                  path.segments.last().unwrap().identifier));\n                             }\n                         }\n                     } else {\n-                        /*self.resolve_error(path.span,\n-                            &format!(\"unresolved associated const `{}`\",\n-                                token::get_ident(path.segments.last().unwrap().identifier)));*/\n-                        resolve_err!(self, path.span, E0253,\n+                        resolve_err!(self, path.span, E0421,\n                                      \"unresolved associated const `{}`\",\n                                      token::get_ident(path.segments.last().unwrap().identifier));\n                     }\n@@ -2717,10 +2613,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         result => {\n                             debug!(\"(resolving pattern) didn't find struct \\\n                                     def: {:?}\", result);\n-                            /*let msg = format!(\"`{}` does not name a structure\",\n-                                              path_names_to_string(path, 0));\n-                            self.resolve_error(path.span, &msg[..]);*/\n-                            resolve_err!(self, path.span, E0253,\n+                            resolve_err!(self, path.span, E0422,\n                                          \"`{}` does not name a structure\",\n                                          path_names_to_string(path, 0));\n                         }\n@@ -2768,11 +2661,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 return FoundConst(def, LastMod(AllPublic));\n                             }\n                             DefStatic(..) => {\n-                                /*self.resolve_error(span,\n-                                                   \"static variables cannot be \\\n-                                                    referenced in a pattern, \\\n-                                                    use a `const` instead\");*/\n-                                resolve_err!(self, span, E0253,\n+                                resolve_err!(self, span, E0417,\n                                              \"{}\",\n                                              \"static variables cannot be \\\n                                               referenced in a pattern, \\\n@@ -2793,9 +2682,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Failed(err) => {\n                 match err {\n                     Some((span, msg)) => {\n-                        /*self.resolve_error(span, &format!(\"failed to resolve: {}\",\n-                                                         msg));*/\n-                        resolve_err!(self, span, E0253,\n+                        resolve_err!(self, span, E0397,\n                                      \"failed to resolve: {}\",\n                                      msg);\n                     }\n@@ -3026,9 +2913,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 };\n \n-                /*self.resolve_error(span, &format!(\"failed to resolve. {}\",\n-                                                 msg));*/\n-                resolve_err!(self, span, E0253,\n+                resolve_err!(self, span, E0397,\n                              \"failed to resolve: {}\",\n                              msg);\n                 return None;\n@@ -3091,7 +2976,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 /*self.resolve_error(span, &format!(\"failed to resolve. {}\",\n                                                  msg));*/\n-                resolve_err!(self, span, E0253,\n+                resolve_err!(self, span, E0397,\n                              \"failed to resolve: {}\",\n                              msg);\n                 return None;\n@@ -3189,8 +3074,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                          failed to resolve {}\", name);\n \n                 if let Some((span, msg)) = err {\n-                    //self.resolve_error(span, &format!(\"failed to resolve. {}\", msg))\n-                    resolve_err!(self, span, E0253,\n+                    resolve_err!(self, span, E0397,\n                                  \"failed to resolve: {}\",\n                                  msg)\n                 }\n@@ -3400,12 +3284,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // Check if struct variant\n                     if let DefVariant(_, _, true) = path_res.base_def {\n                         let path_name = path_names_to_string(path, 0);\n-                        /*self.resolve_error(expr.span,\n-                                &format!(\"`{}` is a struct variant name, but \\\n-                                          this expression \\\n-                                          uses it like a function name\",\n-                                         path_name));*/\n-                        resolve_err!(self, expr.span, E0253,\n+                        resolve_err!(self, expr.span, E0423,\n                                      \"`{}` is a struct variant name, but \\\n                                       this expression \\\n                                       uses it like a function name\",\n@@ -3446,12 +3325,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     match type_res.map(|r| r.base_def) {\n                         Some(DefTy(struct_id, _))\n                             if self.structs.contains_key(&struct_id) => {\n-                                /*self.resolve_error(expr.span,\n-                                    &format!(\"`{}` is a structure name, but \\\n-                                                this expression \\\n-                                                uses it like a function name\",\n-                                                path_name));*/\n-                                resolve_err!(self, expr.span, E0253,\n+                                resolve_err!(self, expr.span, E0423,\n                                              \"{}` is a structure name, but \\\n                                               this expression \\\n                                               uses it like a function name\",\n@@ -3482,12 +3356,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                             if method_scope &&\n                                &token::get_name(special_names::self_)[..] == path_name {\n-                                    /*self.resolve_error(\n-                                        expr.span,\n-                                        \"`self` is not available \\\n-                                         in a static method. Maybe a \\\n-                                         `self` argument is missing?\");*/\n-                                    resolve_err!(self, expr.span, E0253,\n+                                    resolve_err!(self, expr.span, E0424,\n                                                  \"{}\",\n                                                  \"`self` is not available \\\n                                                   in a static method. Maybe a \\\n@@ -3515,11 +3384,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     msg = format!(\". Did you mean {}?\", msg)\n                                 }\n \n-                                /*self.resolve_error(\n-                                    expr.span,\n-                                    &format!(\"unresolved name `{}`{}\",\n-                                             path_name, msg));*/\n-                                resolve_err!(self, expr.span, E0253,\n+                                resolve_err!(self, expr.span, E0425,\n                                              \"unresolved name `{}`{}\",\n                                              path_name,\n                                              msg);\n@@ -3539,10 +3404,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     Some(definition) => self.record_def(expr.id, definition),\n                     None => {\n                         debug!(\"(resolving expression) didn't find struct def\",);\n-                        /*let msg = format!(\"`{}` does not name a structure\",\n-                                          path_names_to_string(path, 0));\n-                        self.resolve_error(path.span, &msg[..]);*/\n-                        resolve_err!(self, path.span, E0253,\n+                        resolve_err!(self, path.span, E0422,\n                                      \"`{}` does not name a structure\",\n                                      path_names_to_string(path, 0));\n                     }\n@@ -3569,11 +3431,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 let renamed = mtwt::resolve(label);\n                 match self.search_label(renamed) {\n                     None => {\n-                        /*self.resolve_error(\n-                            expr.span,\n-                            &format!(\"use of undeclared label `{}`\",\n-                                    token::get_ident(label)))*/\n-                        resolve_err!(self, expr.span, E0253,\n+                        resolve_err!(self, expr.span, E0426,\n                                      \"use of undeclared label `{}`\",\n                                      token::get_ident(label))\n                     }\n@@ -3721,11 +3579,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match pat_binding_mode {\n             BindByValue(_) => {}\n             BindByRef(..) => {\n-                /*self.resolve_error(pat.span,\n-                                   &format!(\"cannot use `ref` binding mode \\\n-                                            with {}\",\n-                                           descr));*/\n-                resolve_err!(self, pat.span, E0253,\n+                resolve_err!(self, pat.span, E0427,\n                              \"cannot use `ref` binding mode with {}\",\n                              descr);\n             }"}, {"sha": "cbaa96c4334e3ae604648ba3b5319254db9029b5", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b731a5cac22f37d3709c889e4de342ca851e3ff/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b731a5cac22f37d3709c889e4de342ca851e3ff/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=8b731a5cac22f37d3709c889e4de342ca851e3ff", "patch": "@@ -272,12 +272,12 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                         Some((span, msg)) => (span, format!(\". {}\", msg)),\n                         None => (import_directive.span, String::new())\n                     };\n-                    let msg = format!(\"unresolved import `{}`{}\",\n-                                      import_path_to_string(\n+                    resolve_err!(self.resolver, span, E0398,\n+                                 \"unresolved import `{}`{}\",\n+                                 import_path_to_string(\n                                           &import_directive.module_path,\n                                           import_directive.subclass),\n-                                      help);\n-                    self.resolver.resolve_error(span, &msg[..]);\n+                                 help);\n                 }\n                 ResolveResult::Indeterminate => break, // Bail out. We'll come around next time.\n                 ResolveResult::Success(()) => () // Good. Continue."}]}