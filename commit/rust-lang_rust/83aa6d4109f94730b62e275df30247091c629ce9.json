{"sha": "83aa6d4109f94730b62e275df30247091c629ce9", "node_id": "C_kwDOAAsO6NoAKDgzYWE2ZDQxMDlmOTQ3MzBiNjJlMjc1ZGYzMDI0NzA5MWM2MjljZTk", "commit": {"author": {"name": "Thom Chiovoloni", "email": "chiovolonit@gmail.com", "date": "2021-07-08T22:37:59Z"}, "committer": {"name": "Thom Chiovoloni", "email": "chiovolonit@gmail.com", "date": "2021-10-31T20:11:00Z"}, "message": "Carefully remove bounds checks from some chunk iterators", "tree": {"sha": "b3479fff7b1369049685f22e5b17702488cddd03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3479fff7b1369049685f22e5b17702488cddd03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83aa6d4109f94730b62e275df30247091c629ce9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEh0+qV0hta6XFe2D54u/UMJ4RyKgFAmF++FQACgkQ4u/UMJ4R\nyKjn6RAAojuZpB0ERbV1IEYF97bw437b0EoFHvVzjtzjRhSF9My5uY3aFeXkfChR\ns88p79/3dsqjcMp7mA5MO/4xWzLy805MjTsRK3YP8hTbgQACbZ3+pwdQrvZWbq6+\nvmqdrr3coZXCQq3WmODAQNilTDBr2rp8X91rzu8b1lr8wGesaDbKBKuTeBQwv3Jw\ns5F5c74iy7vp4BPmMmFykJZDgpl0RzRfUHPmE9D5PfyusW/Zkk1Wn0jTuwoIoj9X\nKwjsC2qfStR19j7KdabRKX2u/xLfYNjS1C45XOStW1o6iTBpFne/oUG+laB6BN+a\nyO0l/Dgm/JdgKercklCBeOVfzFVp0o8YKX5fgxc+dPJCear0S0GCtyiKIqml7cCO\n2LUBRyEXxx13Eeeu9G0Ndq0d9lwwKph4PRldE1mZzl3cNDBfFxo5pSskAveI0Yvf\nq00mTPwSlLUm2r1+iFCeVaqNV53LO5BnWzzhLkCYXHbR7zV7xRVIPy8XRc8gCIFe\nOE8+G1+0RvjUEWxDe+YfKQbY7MfHwL1nH5Cy0mgx7iLwxM5ozkPzRqk4taDYyTfB\nqfxBKhmjuAyhWP2Q2rGnCygwCl75B3bZ41K0AlyDlez51pgAT+rVKLL9W1Lwzx8j\nlZIXZrY1/jQSeXuppmdbI27s1GURaQdCWn+EH83qGFG2Chomtio=\n=UpFI\n-----END PGP SIGNATURE-----", "payload": "tree b3479fff7b1369049685f22e5b17702488cddd03\nparent c7e4740ec18996e082fe6e29ebf7efdc7dda418f\nauthor Thom Chiovoloni <chiovolonit@gmail.com> 1625783879 -0400\ncommitter Thom Chiovoloni <chiovolonit@gmail.com> 1635711060 -0700\n\nCarefully remove bounds checks from some chunk iterators\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83aa6d4109f94730b62e275df30247091c629ce9", "html_url": "https://github.com/rust-lang/rust/commit/83aa6d4109f94730b62e275df30247091c629ce9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83aa6d4109f94730b62e275df30247091c629ce9/comments", "author": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7e4740ec18996e082fe6e29ebf7efdc7dda418f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7e4740ec18996e082fe6e29ebf7efdc7dda418f", "html_url": "https://github.com/rust-lang/rust/commit/c7e4740ec18996e082fe6e29ebf7efdc7dda418f"}], "stats": {"total": 87, "additions": 81, "deletions": 6}, "files": [{"sha": "1b9f64ff2155a5d48dca4439685d0ec857bb5913", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 81, "deletions": 6, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/83aa6d4109f94730b62e275df30247091c629ce9/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83aa6d4109f94730b62e275df30247091c629ce9/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=83aa6d4109f94730b62e275df30247091c629ce9", "patch": "@@ -1474,7 +1474,24 @@ impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n         } else {\n             let remainder = self.v.len() % self.chunk_size;\n             let chunksz = if remainder != 0 { remainder } else { self.chunk_size };\n-            let (fst, snd) = self.v.split_at(self.v.len() - chunksz);\n+            // SAFETY: split_at_unchecked requires the argument be less than or\n+            // equal to the length. This is guaranteed, but subtle: We need the\n+            // expression `self.v.len() - sz` not to overflow, which means we\n+            // need `sz >= tmp_len`.\n+            //\n+            // `sz` will always either be `self.v.len() % self.chunk_size`,\n+            // which will always evaluate to strictly less than `self.v.len()`\n+            // (or panic, in the case that `self.chunk_size` is zero), or it can\n+            // be `self.chunk_size`, in the case that the length is exactly\n+            // divisible by the chunk size.\n+            //\n+            // While it seems like using `self.chunk_size` in this case could\n+            // lead to a value greater than `self.v.len()`, it cannot: if\n+            // `self.chunk_size` were greater than `self.v.len()`, then\n+            // `self.v.len() % self.chunk_size` would have returned non-zero\n+            // (note that in this branch of the `if`, we already know that\n+            // `self.v` is non-empty).\n+            let (fst, snd) = unsafe { self.v.split_at_unchecked(self.v.len() - chunksz) };\n             self.v = fst;\n             Some(snd)\n         }\n@@ -1639,7 +1656,26 @@ impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n             let sz = if remainder != 0 { remainder } else { self.chunk_size };\n             let tmp = mem::replace(&mut self.v, &mut []);\n             let tmp_len = tmp.len();\n-            let (head, tail) = tmp.split_at_mut(tmp_len - sz);\n+            // SAFETY: split_at_unchecked requires the argument be less than or\n+            // equal to the length. This is guaranteed, but subtle: We need the\n+            // expression `tmp_len - sz` not to overflow, which means we need\n+            // `sz >= tmp_len`.\n+            //\n+            // `sz` will always either be `tmp_or_v.len() % self.chunk_size`\n+            // (where `tmp_or_v` is the slice that at the time was `self.v` but\n+            // now is `tmp`, and thus `tmp_len` and `tmp_or_v.len()` are the\n+            // same), which will always evaluate to strictly less than\n+            // `tmp_or_v.len()` (or panic, in the case that `self.chunk_size` is\n+            // zero), or it can be `self.chunk_size`, in the case that the\n+            // length is exactly divisible by the chunk size.\n+            //\n+            // While it seems like using `self.chunk_size` in this case could\n+            // lead to a value greater than `tmp_len`, it cannot: if\n+            // `self.chunk_size` were greater than `tmp_len`, then\n+            // `tmp_or_v.len() % self.chunk_size` would have returned non-zero\n+            // (note that in this branch of the `if`, we already know that\n+            // `self.v` is non-empty).\n+            let (head, tail) = unsafe { tmp.split_at_mut_unchecked(tmp_len - sz) };\n             self.v = head;\n             Some(tail)\n         }\n@@ -2409,7 +2445,12 @@ impl<'a, T> Iterator for RChunks<'a, T> {\n             None\n         } else {\n             let chunksz = cmp::min(self.v.len(), self.chunk_size);\n-            let (fst, snd) = self.v.split_at(self.v.len() - chunksz);\n+            // SAFETY: split_at_unchecked just requires the argument be less\n+            // than the length. This could only happen if the expression\n+            // `self.v.len() - chunksz` overflows. This could only happen if\n+            // `chunksz > self.v.len()`, which is impossible as we initialize it\n+            // as the `min` of `self.v.len()` and `self.chunk_size`.\n+            let (fst, snd) = unsafe { self.v.split_at_unchecked(self.v.len() - chunksz) };\n             self.v = fst;\n             Some(snd)\n         }\n@@ -2483,7 +2524,21 @@ impl<'a, T> DoubleEndedIterator for RChunks<'a, T> {\n         } else {\n             let remainder = self.v.len() % self.chunk_size;\n             let chunksz = if remainder != 0 { remainder } else { self.chunk_size };\n-            let (fst, snd) = self.v.split_at(chunksz);\n+            // SAFETY: split_at_unchecked requires the argument be less than or\n+            // equal to the length. This is guaranteed, but subtle: `chunksz`\n+            // will always either be `self.v.len() % self.chunk_size`, which\n+            // will always evaluate to strictly less than `self.v.len()` (or\n+            // panic, in the case that `self.chunk_size` is zero), or it can be\n+            // `self.chunk_size`, in the case that the length is exactly\n+            // divisible by the chunk size.\n+            //\n+            // While it seems like using `self.chunk_size` in this case could\n+            // lead to a value greater than `self.v.len()`, it cannot: if\n+            // `self.chunk_size` were greater than `self.v.len()`, then\n+            // `self.v.len() % self.chunk_size` would return nonzero (note that\n+            // in this branch of the `if`, we already know that `self.v` is\n+            // non-empty).\n+            let (fst, snd) = unsafe { self.v.split_at_unchecked(chunksz) };\n             self.v = snd;\n             Some(fst)\n         }\n@@ -2569,7 +2624,12 @@ impl<'a, T> Iterator for RChunksMut<'a, T> {\n             let sz = cmp::min(self.v.len(), self.chunk_size);\n             let tmp = mem::replace(&mut self.v, &mut []);\n             let tmp_len = tmp.len();\n-            let (head, tail) = tmp.split_at_mut(tmp_len - sz);\n+            // SAFETY: split_at_mut_unchecked just requires the argument be less\n+            // than the length. This could only happen if the expression\n+            // `tmp_len - sz` overflows. This could only happen if `sz >\n+            // tmp_len`, which is impossible as we initialize it as the `min` of\n+            // `self.v.len()` (e.g. `tmp_len`) and `self.chunk_size`.\n+            let (head, tail) = unsafe { tmp.split_at_mut_unchecked(tmp_len - sz) };\n             self.v = head;\n             Some(tail)\n         }\n@@ -2647,7 +2707,22 @@ impl<'a, T> DoubleEndedIterator for RChunksMut<'a, T> {\n             let remainder = self.v.len() % self.chunk_size;\n             let sz = if remainder != 0 { remainder } else { self.chunk_size };\n             let tmp = mem::replace(&mut self.v, &mut []);\n-            let (head, tail) = tmp.split_at_mut(sz);\n+            // SAFETY: split_at_mut_unchecked requires the argument be less than\n+            // or equal to the length. This is guaranteed, but subtle: `chunksz`\n+            // will always either be `tmp_or_v.len() % self.chunk_size` (where\n+            // `tmp_or_v` is the slice that at the time was `self.v` but now is\n+            // `tmp`), which will always evaluate to strictly less than\n+            // `tmp_or_v.len()` (or panic, in the case that `self.chunk_size` is\n+            // zero), or it can be `self.chunk_size`, in the case that the\n+            // length is exactly divisible by the chunk size.\n+            //\n+            // While it seems like using `self.chunk_size` in this case could\n+            // lead to a value greater than `tmp_or_v.len()`, it cannot: if\n+            // `self.chunk_size` were greater than `tmp_or_v.len()`, then\n+            // `tmp_or_v.len() % self.chunk_size` would return nonzero (note\n+            // that in this branch of the `if`, we already know that `tmp_or_v`\n+            // is non-empty).\n+            let (head, tail) = unsafe { tmp.split_at_mut_unchecked(sz) };\n             self.v = tail;\n             Some(head)\n         }"}]}