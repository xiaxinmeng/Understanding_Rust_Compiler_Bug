{"sha": "68196ccc10c60de52bb771d295879456f73ede95", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4MTk2Y2NjMTBjNjBkZTUyYmI3NzFkMjk1ODc5NDU2ZjczZWRlOTU=", "commit": {"author": {"name": "Luca Barbieri", "email": "luca@luca-barbieri.com", "date": "2020-04-03T19:12:08Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-08T15:15:12Z"}, "message": "Add AstElement trait, generate tokens, support tokens in enums\n\n- Adds a new AstElement trait that is implemented by all generated\n  node, token and enum structs\n\n- Overhauls the code generators to code-generate all tokens, and\n  also enhances enums to support including tokens, node, and nested\n  enums", "tree": {"sha": "cec60917f9c4475c49d4842c05469f19ad2bff86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cec60917f9c4475c49d4842c05469f19ad2bff86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68196ccc10c60de52bb771d295879456f73ede95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68196ccc10c60de52bb771d295879456f73ede95", "html_url": "https://github.com/rust-lang/rust/commit/68196ccc10c60de52bb771d295879456f73ede95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68196ccc10c60de52bb771d295879456f73ede95/comments", "author": {"login": "luca-barbieri", "id": 298418, "node_id": "MDQ6VXNlcjI5ODQxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/298418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luca-barbieri", "html_url": "https://github.com/luca-barbieri", "followers_url": "https://api.github.com/users/luca-barbieri/followers", "following_url": "https://api.github.com/users/luca-barbieri/following{/other_user}", "gists_url": "https://api.github.com/users/luca-barbieri/gists{/gist_id}", "starred_url": "https://api.github.com/users/luca-barbieri/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luca-barbieri/subscriptions", "organizations_url": "https://api.github.com/users/luca-barbieri/orgs", "repos_url": "https://api.github.com/users/luca-barbieri/repos", "events_url": "https://api.github.com/users/luca-barbieri/events{/privacy}", "received_events_url": "https://api.github.com/users/luca-barbieri/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4762c6d9c66dc1b6be9b9010dbe787ef8d69530a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4762c6d9c66dc1b6be9b9010dbe787ef8d69530a", "html_url": "https://github.com/rust-lang/rust/commit/4762c6d9c66dc1b6be9b9010dbe787ef8d69530a"}], "stats": {"total": 474, "additions": 380, "deletions": 94}, "files": [{"sha": "1ac0201b8135b63f634e7b265324a2b30ab80f31", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 109, "deletions": 5, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/68196ccc10c60de52bb771d295879456f73ede95/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68196ccc10c60de52bb771d295879456f73ede95/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=68196ccc10c60de52bb771d295879456f73ede95", "patch": "@@ -11,7 +11,10 @@ pub mod make;\n use std::marker::PhantomData;\n \n use crate::{\n-    syntax_node::{SyntaxNode, SyntaxNodeChildren, SyntaxToken},\n+    syntax_node::{\n+        NodeOrToken, SyntaxElement, SyntaxElementChildren, SyntaxNode, SyntaxNodeChildren,\n+        SyntaxToken,\n+    },\n     SmolStr, SyntaxKind,\n };\n \n@@ -30,16 +33,24 @@ pub use self::{\n /// conversion itself has zero runtime cost: ast and syntax nodes have exactly\n /// the same representation: a pointer to the tree root and a pointer to the\n /// node itself.\n-pub trait AstNode: std::fmt::Display {\n+pub trait AstNode: AstElement {\n     fn can_cast(kind: SyntaxKind) -> bool\n     where\n         Self: Sized;\n \n-    fn cast(syntax: SyntaxNode) -> Option<Self>\n+    fn cast_or_return(syntax: SyntaxNode) -> Result<Self, SyntaxNode>\n     where\n         Self: Sized;\n \n+    fn cast(syntax: SyntaxNode) -> Option<Self>\n+    where\n+        Self: Sized,\n+    {\n+        <Self as AstNode>::cast_or_return(syntax).ok()\n+    }\n+\n     fn syntax(&self) -> &SyntaxNode;\n+    fn into_syntax(self) -> SyntaxNode;\n }\n \n #[test]\n@@ -48,16 +59,51 @@ fn assert_ast_is_object_safe() {\n }\n \n /// Like `AstNode`, but wraps tokens rather than interior nodes.\n-pub trait AstToken {\n-    fn cast(token: SyntaxToken) -> Option<Self>\n+pub trait AstToken: AstElement {\n+    fn can_cast(token: SyntaxKind) -> bool\n     where\n         Self: Sized;\n+\n+    fn cast_or_return(syntax: SyntaxToken) -> Result<Self, SyntaxToken>\n+    where\n+        Self: Sized;\n+\n+    fn cast(syntax: SyntaxToken) -> Option<Self>\n+    where\n+        Self: Sized,\n+    {\n+        <Self as AstToken>::cast_or_return(syntax).ok()\n+    }\n+\n     fn syntax(&self) -> &SyntaxToken;\n+    fn into_syntax(self) -> SyntaxToken;\n+\n     fn text(&self) -> &SmolStr {\n         self.syntax().text()\n     }\n }\n \n+/// Like `AstNode`, but wraps either nodes or tokens rather than interior nodes.\n+pub trait AstElement: std::fmt::Display {\n+    fn can_cast_element(kind: SyntaxKind) -> bool\n+    where\n+        Self: Sized;\n+\n+    fn cast_or_return_element(syntax: SyntaxElement) -> Result<Self, SyntaxElement>\n+    where\n+        Self: Sized;\n+\n+    fn cast_element(syntax: SyntaxElement) -> Option<Self>\n+    where\n+        Self: Sized,\n+    {\n+        <Self as AstElement>::cast_or_return_element(syntax).ok()\n+    }\n+\n+    fn syntax_element(&self) -> NodeOrToken<&SyntaxNode, &SyntaxToken>;\n+    fn into_syntax_element(self) -> SyntaxElement;\n+}\n+\n /// An iterator over `SyntaxNode` children of a particular AST type.\n #[derive(Debug, Clone)]\n pub struct AstChildren<N> {\n@@ -86,6 +132,64 @@ fn children<P: AstNode + ?Sized, C: AstNode>(parent: &P) -> AstChildren<C> {\n     AstChildren::new(parent.syntax())\n }\n \n+/// An iterator over `SyntaxToken` children of a particular AST type.\n+#[derive(Debug, Clone)]\n+pub struct AstChildTokens<N> {\n+    inner: SyntaxElementChildren,\n+    ph: PhantomData<N>,\n+}\n+\n+impl<N> AstChildTokens<N> {\n+    fn new(parent: &SyntaxNode) -> Self {\n+        AstChildTokens { inner: parent.children_with_tokens(), ph: PhantomData }\n+    }\n+}\n+\n+impl<N: AstToken> Iterator for AstChildTokens<N> {\n+    type Item = N;\n+    fn next(&mut self) -> Option<N> {\n+        self.inner.by_ref().filter_map(|x| x.into_token()).find_map(N::cast)\n+    }\n+}\n+\n+fn child_token_opt<P: AstNode + ?Sized, C: AstToken>(parent: &P) -> Option<C> {\n+    child_tokens(parent).next()\n+}\n+\n+fn child_tokens<P: AstNode + ?Sized, C: AstToken>(parent: &P) -> AstChildTokens<C> {\n+    AstChildTokens::new(parent.syntax())\n+}\n+\n+/// An iterator over `SyntaxNode` children of a particular AST type.\n+#[derive(Debug, Clone)]\n+pub struct AstChildElements<N> {\n+    inner: SyntaxElementChildren,\n+    ph: PhantomData<N>,\n+}\n+\n+impl<N> AstChildElements<N> {\n+    fn new(parent: &SyntaxNode) -> Self {\n+        AstChildElements { inner: parent.children_with_tokens(), ph: PhantomData }\n+    }\n+}\n+\n+impl<N: AstElement> Iterator for AstChildElements<N> {\n+    type Item = N;\n+    fn next(&mut self) -> Option<N> {\n+        self.inner.by_ref().find_map(N::cast_element)\n+    }\n+}\n+\n+#[allow(dead_code)]\n+fn child_element_opt<P: AstNode + ?Sized, C: AstElement>(parent: &P) -> Option<C> {\n+    child_elements(parent).next()\n+}\n+\n+#[allow(dead_code)]\n+fn child_elements<P: AstNode + ?Sized, C: AstElement>(parent: &P) -> AstChildElements<C> {\n+    AstChildElements::new(parent.syntax())\n+}\n+\n #[test]\n fn test_doc_comment_none() {\n     let file = SourceFile::parse("}, {"sha": "e8320b57ed45376733334806a2ff42eba764937a", "filename": "crates/ra_syntax/src/ast/tokens.rs", "status": "modified", "additions": 2, "deletions": 60, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/68196ccc10c60de52bb771d295879456f73ede95/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68196ccc10c60de52bb771d295879456f73ede95/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs?ref=68196ccc10c60de52bb771d295879456f73ede95", "patch": "@@ -1,26 +1,10 @@\n //! There are many AstNodes, but only a few tokens, so we hand-write them here.\n \n use crate::{\n-    ast::AstToken,\n-    SyntaxKind::{COMMENT, RAW_STRING, STRING, WHITESPACE},\n-    SyntaxToken, TextRange, TextUnit,\n+    ast::{AstToken, Comment, RawString, String, Whitespace},\n+    TextRange, TextUnit,\n };\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Comment(SyntaxToken);\n-\n-impl AstToken for Comment {\n-    fn cast(token: SyntaxToken) -> Option<Self> {\n-        match token.kind() {\n-            COMMENT => Some(Comment(token)),\n-            _ => None,\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken {\n-        &self.0\n-    }\n-}\n-\n impl Comment {\n     pub fn kind(&self) -> CommentKind {\n         kind_by_prefix(self.text())\n@@ -89,20 +73,6 @@ fn prefix_by_kind(kind: CommentKind) -> &'static str {\n     unreachable!()\n }\n \n-pub struct Whitespace(SyntaxToken);\n-\n-impl AstToken for Whitespace {\n-    fn cast(token: SyntaxToken) -> Option<Self> {\n-        match token.kind() {\n-            WHITESPACE => Some(Whitespace(token)),\n-            _ => None,\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken {\n-        &self.0\n-    }\n-}\n-\n impl Whitespace {\n     pub fn spans_multiple_lines(&self) -> bool {\n         let text = self.text();\n@@ -168,20 +138,6 @@ pub trait HasStringValue: HasQuotes {\n     fn value(&self) -> Option<std::string::String>;\n }\n \n-pub struct String(SyntaxToken);\n-\n-impl AstToken for String {\n-    fn cast(token: SyntaxToken) -> Option<Self> {\n-        match token.kind() {\n-            STRING => Some(String(token)),\n-            _ => None,\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken {\n-        &self.0\n-    }\n-}\n-\n impl HasStringValue for String {\n     fn value(&self) -> Option<std::string::String> {\n         let text = self.text().as_str();\n@@ -201,20 +157,6 @@ impl HasStringValue for String {\n     }\n }\n \n-pub struct RawString(SyntaxToken);\n-\n-impl AstToken for RawString {\n-    fn cast(token: SyntaxToken) -> Option<Self> {\n-        match token.kind() {\n-            RAW_STRING => Some(RawString(token)),\n-            _ => None,\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken {\n-        &self.0\n-    }\n-}\n-\n impl HasStringValue for RawString {\n     fn value(&self) -> Option<std::string::String> {\n         let text = self.text().as_str();"}, {"sha": "c730c75eed0343927c62708cdf5c57a4b187c644", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 269, "deletions": 29, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/68196ccc10c60de52bb771d295879456f73ede95/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68196ccc10c60de52bb771d295879456f73ede95/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=68196ccc10c60de52bb771d295879456f73ede95", "patch": "@@ -5,6 +5,8 @@\n \n use proc_macro2::{Punct, Spacing};\n use quote::{format_ident, quote};\n+use std::borrow::Cow;\n+use std::collections::{BTreeSet, HashMap, HashSet};\n \n use crate::{\n     ast_src::{AstSrc, FieldSrc, KindsSrc, AST_SRC, KINDS_SRC},\n@@ -18,13 +20,125 @@ pub fn generate_syntax(mode: Mode) -> Result<()> {\n     update(syntax_kinds_file.as_path(), &syntax_kinds, mode)?;\n \n     let ast_file = project_root().join(codegen::AST);\n-    let ast = generate_ast(AST_SRC)?;\n+    let ast = generate_ast(KINDS_SRC, AST_SRC)?;\n     update(ast_file.as_path(), &ast, mode)?;\n \n     Ok(())\n }\n \n-fn generate_ast(grammar: AstSrc<'_>) -> Result<String> {\n+#[derive(Debug, Default, Clone)]\n+struct ElementKinds {\n+    kinds: BTreeSet<proc_macro2::Ident>,\n+    has_nodes: bool,\n+    has_tokens: bool,\n+}\n+\n+fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n+    let all_token_kinds: Vec<_> = kinds\n+        .punct\n+        .into_iter()\n+        .map(|(_, kind)| kind)\n+        .copied()\n+        .map(|x| x.into())\n+        .chain(\n+            kinds\n+                .keywords\n+                .into_iter()\n+                .chain(kinds.contextual_keywords.into_iter())\n+                .map(|name| Cow::Owned(format!(\"{}_KW\", to_upper_snake_case(&name)))),\n+        )\n+        .chain(kinds.literals.into_iter().copied().map(|x| x.into()))\n+        .chain(kinds.tokens.into_iter().copied().map(|x| x.into()))\n+        .collect();\n+\n+    let mut element_kinds_map = HashMap::new();\n+    for kind in &all_token_kinds {\n+        let kind = &**kind;\n+        let name = to_pascal_case(kind);\n+        element_kinds_map.insert(\n+            name,\n+            ElementKinds {\n+                kinds: Some(format_ident!(\"{}\", kind)).into_iter().collect(),\n+                has_nodes: false,\n+                has_tokens: true,\n+            },\n+        );\n+    }\n+\n+    for kind in kinds.nodes {\n+        let name = to_pascal_case(kind);\n+        element_kinds_map.insert(\n+            name,\n+            ElementKinds {\n+                kinds: Some(format_ident!(\"{}\", *kind)).into_iter().collect(),\n+                has_nodes: true,\n+                has_tokens: false,\n+            },\n+        );\n+    }\n+\n+    for en in grammar.enums {\n+        let mut element_kinds: ElementKinds = Default::default();\n+        for variant in en.variants {\n+            if let Some(variant_element_kinds) = element_kinds_map.get(*variant) {\n+                element_kinds.kinds.extend(variant_element_kinds.kinds.iter().cloned());\n+                element_kinds.has_tokens |= variant_element_kinds.has_tokens;\n+                element_kinds.has_nodes |= variant_element_kinds.has_nodes;\n+            } else {\n+                panic!(\"Enum variant has type that does not exist or was not declared before the enum: {}\", *variant);\n+            }\n+        }\n+        element_kinds_map.insert(en.name.to_string(), element_kinds);\n+    }\n+\n+    let tokens = all_token_kinds.iter().map(|kind_str| {\n+        let kind_str = &**kind_str;\n+        let kind = format_ident!(\"{}\", kind_str);\n+        let name = format_ident!(\"{}\", to_pascal_case(kind_str));\n+        quote! {\n+            #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+            pub struct #name(SyntaxToken);\n+\n+            impl std::fmt::Display for #name {\n+                fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+                    std::fmt::Display::fmt(self.syntax(), f)\n+                }\n+            }\n+\n+            impl AstToken for #name {\n+                fn can_cast(kind: SyntaxKind) -> bool {\n+                    match kind {\n+                        #kind => true,\n+                        _ => false,\n+                    }\n+                }\n+                fn cast_or_return(syntax: SyntaxToken) -> Result<Self, SyntaxToken> {\n+                    if Self::can_cast(syntax.kind()) { Ok(Self(syntax)) } else { Err(syntax) }\n+                }\n+                fn syntax(&self) -> &SyntaxToken { &self.0 }\n+                fn into_syntax(self) -> SyntaxToken { self.0 }\n+            }\n+\n+            impl AstElement for #name {\n+                fn can_cast_element(kind: SyntaxKind) -> bool {\n+                    match kind {\n+                        #kind => true,\n+                        _ => false,\n+                    }\n+                }\n+                fn cast_or_return_element(syntax: SyntaxElement) -> Result<Self, SyntaxElement> {\n+                    if Self::can_cast_element(syntax.kind()) { Ok(Self(syntax.into_token().unwrap())) } else { Err(syntax) }\n+                }\n+                fn syntax_element(&self) -> NodeOrToken<&SyntaxNode, &SyntaxToken> {\n+                    NodeOrToken::Token(&self.0)\n+                }\n+                fn into_syntax_element(self) -> SyntaxElement {\n+                    NodeOrToken::Token(self.0)\n+                }\n+            }\n+        }\n+    });\n+\n     let nodes = grammar.nodes.iter().map(|node| {\n         let name = format_ident!(\"{}\", node.name);\n         let kind = format_ident!(\"{}\", to_upper_snake_case(&name.to_string()));\n@@ -42,20 +156,28 @@ fn generate_ast(grammar: AstSrc<'_>) -> Result<String> {\n                 FieldSrc::Optional(ty) | FieldSrc::Many(ty) => ty,\n                 FieldSrc::Shorthand => name,\n             };\n+            let element_kinds = &element_kinds_map.get(*ty).unwrap_or_else(|| panic!(\"type not found: {}\", *ty));\n+            let iter = if !element_kinds.has_tokens {\n+                format_ident!(\"AstChildren\")\n+            } else if !element_kinds.has_nodes {\n+                format_ident!(\"AstChildTokens\")\n+            } else {\n+                format_ident!(\"AstChildElements\")\n+            };\n             let ty = format_ident!(\"{}\", ty);\n \n             match field {\n                 FieldSrc::Many(_) => {\n                     quote! {\n-                        pub fn #method_name(&self) -> AstChildren<#ty> {\n-                            AstChildren::new(&self.syntax)\n+                        pub fn #method_name(&self) -> #iter<#ty> {\n+                            #iter::new(&self.syntax)\n                         }\n                     }\n                 }\n                 FieldSrc::Optional(_) | FieldSrc::Shorthand => {\n                     quote! {\n                         pub fn #method_name(&self) -> Option<#ty> {\n-                            AstChildren::new(&self.syntax).next()\n+                            #iter::new(&self.syntax).next()\n                         }\n                     }\n                 }\n@@ -81,11 +203,31 @@ fn generate_ast(grammar: AstSrc<'_>) -> Result<String> {\n                         _ => false,\n                     }\n                 }\n-                fn cast(syntax: SyntaxNode) -> Option<Self> {\n-                    if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }\n+                fn cast_or_return(syntax: SyntaxNode) -> Result<Self, SyntaxNode> {\n+                    if Self::can_cast(syntax.kind()) { Ok(Self { syntax }) } else { Err(syntax) }\n                 }\n                 fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+                fn into_syntax(self) -> SyntaxNode { self.syntax }\n             }\n+\n+            impl AstElement for #name {\n+                fn can_cast_element(kind: SyntaxKind) -> bool {\n+                    match kind {\n+                        #kind => true,\n+                        _ => false,\n+                    }\n+                }\n+                fn cast_or_return_element(syntax: SyntaxElement) -> Result<Self, SyntaxElement> {\n+                    if Self::can_cast_element(syntax.kind()) { Ok(Self { syntax: syntax.into_node().unwrap() }) } else { Err(syntax) }\n+                }\n+                fn syntax_element(&self) -> NodeOrToken<&SyntaxNode, &SyntaxToken> {\n+                    NodeOrToken::Node(&self.syntax)\n+                }\n+                fn into_syntax_element(self) -> SyntaxElement {\n+                    NodeOrToken::Node(self.syntax)\n+                }\n+            }\n+\n             #(#traits)*\n \n             impl #name {\n@@ -96,16 +238,71 @@ fn generate_ast(grammar: AstSrc<'_>) -> Result<String> {\n \n     let enums = grammar.enums.iter().map(|en| {\n         let variants = en.variants.iter().map(|var| format_ident!(\"{}\", var)).collect::<Vec<_>>();\n+        let element_kinds = &element_kinds_map[&en.name.to_string()];\n         let name = format_ident!(\"{}\", en.name);\n-        let kinds = variants\n+        let kinds = en.variants\n             .iter()\n-            .map(|name| format_ident!(\"{}\", to_upper_snake_case(&name.to_string())))\n+            .map(|name| {\n+                element_kinds_map[*name].kinds.iter().collect::<Vec<_>>()\n+            })\n             .collect::<Vec<_>>();\n         let traits = en.traits.iter().map(|trait_name| {\n             let trait_name = format_ident!(\"{}\", trait_name);\n             quote!(impl ast::#trait_name for #name {})\n         });\n \n+        let all_kinds = &element_kinds.kinds;\n+\n+        let specific_ast_trait = if element_kinds.has_nodes != element_kinds.has_tokens {\n+            let (ast_trait, syntax_type) = if element_kinds.has_tokens {\n+                (\n+                    quote!(AstToken),\n+                    quote!(SyntaxToken),\n+                )\n+            } else {\n+                (\n+                    quote!(AstNode),\n+                    quote!(SyntaxNode),\n+                )\n+            };\n+\n+            quote! {\n+                impl #ast_trait for #name {\n+                    fn can_cast(kind: SyntaxKind) -> bool {\n+                        match kind {\n+                            #(#all_kinds)|* => true,\n+                            _ => false,\n+                        }\n+                    }\n+                    #[allow(unreachable_patterns)]\n+                    fn cast_or_return(syntax: #syntax_type) -> Result<Self, #syntax_type> {\n+                        match syntax.kind() {\n+                            #(\n+                            #(#kinds)|* => #variants::cast_or_return(syntax).map(|x| #name::#variants(x)),\n+                            )*\n+                            _ => Err(syntax),\n+                        }\n+                    }\n+                    fn syntax(&self) -> &#syntax_type {\n+                        match self {\n+                            #(\n+                            #name::#variants(it) => it.syntax(),\n+                            )*\n+                        }\n+                    }\n+                    fn into_syntax(self) -> #syntax_type {\n+                        match self {\n+                            #(\n+                            #name::#variants(it) => it.into_syntax(),\n+                            )*\n+                        }\n+                    }\n+                }\n+            }\n+        } else {\n+            Default::default()\n+        };\n+\n         quote! {\n             #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n             pub enum #name {\n@@ -122,44 +319,71 @@ fn generate_ast(grammar: AstSrc<'_>) -> Result<String> {\n \n             impl std::fmt::Display for #name {\n                 fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-                    std::fmt::Display::fmt(self.syntax(), f)\n+                    match self {\n+                        #(\n+                        #name::#variants(it) => std::fmt::Display::fmt(it, f),\n+                        )*\n+                    }\n                 }\n             }\n \n-            impl AstNode for #name {\n-                fn can_cast(kind: SyntaxKind) -> bool {\n+            #specific_ast_trait\n+\n+            impl AstElement for #name {\n+                fn can_cast_element(kind: SyntaxKind) -> bool {\n                     match kind {\n-                        #(#kinds)|* => true,\n+                        #(#all_kinds)|* => true,\n                         _ => false,\n                     }\n                 }\n-                fn cast(syntax: SyntaxNode) -> Option<Self> {\n-                    let res = match syntax.kind() {\n+                #[allow(unreachable_patterns)]\n+                fn cast_or_return_element(syntax: SyntaxElement) -> Result<Self, SyntaxElement> {\n+                    match syntax.kind() {\n+                        #(\n+                        #(#kinds)|* => #variants::cast_or_return_element(syntax).map(|x| #name::#variants(x)),\n+                        )*\n+                        _ => Err(syntax),\n+                    }\n+                }\n+                fn syntax_element(&self) -> NodeOrToken<&SyntaxNode, &SyntaxToken> {\n+                    match self {\n                         #(\n-                        #kinds => #name::#variants(#variants { syntax }),\n+                        #name::#variants(it) => it.syntax_element(),\n                         )*\n-                        _ => return None,\n-                    };\n-                    Some(res)\n+                    }\n                 }\n-                fn syntax(&self) -> &SyntaxNode {\n+                fn into_syntax_element(self) -> SyntaxElement {\n                     match self {\n                         #(\n-                        #name::#variants(it) => &it.syntax,\n+                        #name::#variants(it) => it.into_syntax_element(),\n                         )*\n                     }\n                 }\n             }\n+\n             #(#traits)*\n         }\n     });\n \n+    let defined_nodes: HashSet<_> = grammar.nodes.iter().map(|node| node.name).collect();\n+\n+    for node in kinds\n+        .nodes\n+        .iter()\n+        .map(|kind| to_pascal_case(*kind))\n+        .filter(|name| !defined_nodes.contains(&**name))\n+    {\n+        eprintln!(\"Warning: node {} not defined in ast source\", node);\n+    }\n+\n     let ast = quote! {\n+        #[allow(unused_imports)]\n         use crate::{\n-            SyntaxNode, SyntaxKind::{self, *},\n-            ast::{self, AstNode, AstChildren},\n+            SyntaxNode, SyntaxToken, SyntaxElement, NodeOrToken, SyntaxKind::{self, *},\n+            ast::{self, AstNode, AstToken, AstElement, AstChildren, AstChildTokens, AstChildElements},\n         };\n \n+        #(#tokens)*\n         #(#nodes)*\n         #(#enums)*\n     };\n@@ -282,12 +506,12 @@ fn generate_syntax_kinds(grammar: KindsSrc<'_>) -> Result<String> {\n \n fn to_upper_snake_case(s: &str) -> String {\n     let mut buf = String::with_capacity(s.len());\n-    let mut prev_is_upper = None;\n+    let mut prev = false;\n     for c in s.chars() {\n-        if c.is_ascii_uppercase() && prev_is_upper == Some(false) {\n+        if c.is_ascii_uppercase() && prev {\n             buf.push('_')\n         }\n-        prev_is_upper = Some(c.is_ascii_uppercase());\n+        prev = true;\n \n         buf.push(c.to_ascii_uppercase());\n     }\n@@ -296,14 +520,30 @@ fn to_upper_snake_case(s: &str) -> String {\n \n fn to_lower_snake_case(s: &str) -> String {\n     let mut buf = String::with_capacity(s.len());\n-    let mut prev_is_upper = None;\n+    let mut prev = false;\n     for c in s.chars() {\n-        if c.is_ascii_uppercase() && prev_is_upper == Some(false) {\n+        if c.is_ascii_uppercase() && prev {\n             buf.push('_')\n         }\n-        prev_is_upper = Some(c.is_ascii_uppercase());\n+        prev = true;\n \n         buf.push(c.to_ascii_lowercase());\n     }\n     buf\n }\n+\n+fn to_pascal_case(s: &str) -> String {\n+    let mut buf = String::with_capacity(s.len());\n+    let mut prev_is_underscore = true;\n+    for c in s.chars() {\n+        if c == '_' {\n+            prev_is_underscore = true;\n+        } else if prev_is_underscore {\n+            buf.push(c.to_ascii_uppercase());\n+            prev_is_underscore = false;\n+        } else {\n+            buf.push(c.to_ascii_lowercase());\n+        }\n+    }\n+    buf\n+}"}]}