{"sha": "6d64f7f695943541fe12bb960971403f440d7225", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkNjRmN2Y2OTU5NDM1NDFmZTEyYmI5NjA5NzE0MDNmNDQwZDcyMjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-19T20:31:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-19T20:31:05Z"}, "message": "Auto merge of #88165 - GuillaumeGomez:rollup-4o0v2ps, r=GuillaumeGomez\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #86123 (Preserve more spans in internal `rustc_queries!` macro)\n - #87874 (Add TcpStream type to TcpListener::incoming docs)\n - #88034 (rustc_privacy: Replace `HirId`s and `DefId`s with `LocalDefId`s where possible)\n - #88050 (Remove `HashStable` impls for `FileName` and `RealFileName`)\n - #88093 ([rustdoc] Wrap code blocks in `<code>` tag)\n - #88146 (Add tests for some `feature(const_evaluatable_checked)` incr comp issues)\n - #88153 (Update .mailmap)\n - #88159 (Use a trait instead of the now disallowed missing trait there)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "e13fba589fabe127b60c3c2756d3cd969fd2a9f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e13fba589fabe127b60c3c2756d3cd969fd2a9f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d64f7f695943541fe12bb960971403f440d7225", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d64f7f695943541fe12bb960971403f440d7225", "html_url": "https://github.com/rust-lang/rust/commit/6d64f7f695943541fe12bb960971403f440d7225", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d64f7f695943541fe12bb960971403f440d7225/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7960030d6915a771f5ab72c3897a7ed50c3ed4bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/7960030d6915a771f5ab72c3897a7ed50c3ed4bd", "html_url": "https://github.com/rust-lang/rust/commit/7960030d6915a771f5ab72c3897a7ed50c3ed4bd"}, {"sha": "1095bb1eb25b38a221e35588530269c6219a95a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1095bb1eb25b38a221e35588530269c6219a95a1", "html_url": "https://github.com/rust-lang/rust/commit/1095bb1eb25b38a221e35588530269c6219a95a1"}], "stats": {"total": 1043, "additions": 638, "deletions": 405}, "files": [{"sha": "d1f5ca9371f62367962f4dd811308d2c605399ed", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d64f7f695943541fe12bb960971403f440d7225/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/6d64f7f695943541fe12bb960971403f440d7225/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=6d64f7f695943541fe12bb960971403f440d7225", "patch": "@@ -113,6 +113,7 @@ Hanna Kruppe <hanna.kruppe@gmail.com> <robin.kruppe@gmail.com>\n Heather <heather@cynede.net> <Cynede@Gentoo.org>\n Heather <heather@cynede.net> <Heather@cynede.net>\n Herman J. Radtke III <herman@hermanradtke.com> Herman J. Radtke III <hermanradtke@gmail.com>\n+Hirochika Matsumoto <git@hkmatsumoto.com> <matsujika@gmail.com>\n Ian Jackson <ijackson@chiark.greenend.org.uk> <ian.jackson@citrix.com>\n Ian Jackson <ijackson@chiark.greenend.org.uk> <ijackson+github@slimy.greenend.org.uk>\n Ian Jackson <ijackson@chiark.greenend.org.uk> <iwj@xenproject.org>"}, {"sha": "7ad36973f46c7d37493b783869650bb804533e2f", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 56, "deletions": 48, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/6d64f7f695943541fe12bb960971403f440d7225/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d64f7f695943541fe12bb960971403f440d7225/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=6d64f7f695943541fe12bb960971403f440d7225", "patch": "@@ -1,6 +1,6 @@\n use proc_macro::TokenStream;\n use proc_macro2::{Delimiter, TokenTree};\n-use quote::quote;\n+use quote::{quote, quote_spanned};\n use syn::parse::{Parse, ParseStream, Result};\n use syn::punctuated::Punctuated;\n use syn::spanned::Spanned;\n@@ -42,19 +42,19 @@ enum QueryModifier {\n     LoadCached(Ident, Ident, Block),\n \n     /// A cycle error for this query aborting the compilation with a fatal error.\n-    FatalCycle,\n+    FatalCycle(Ident),\n \n     /// A cycle error results in a delay_bug call\n-    CycleDelayBug,\n+    CycleDelayBug(Ident),\n \n     /// Don't hash the result, instead just mark a query red if it runs\n-    NoHash,\n+    NoHash(Ident),\n \n     /// Generate a dep node based on the dependencies of the query\n-    Anon,\n+    Anon(Ident),\n \n     /// Always evaluate the query, ignoring its dependencies\n-    EvalAlways,\n+    EvalAlways(Ident),\n }\n \n impl Parse for QueryModifier {\n@@ -111,15 +111,15 @@ impl Parse for QueryModifier {\n             let ty = args.parse()?;\n             Ok(QueryModifier::Storage(ty))\n         } else if modifier == \"fatal_cycle\" {\n-            Ok(QueryModifier::FatalCycle)\n+            Ok(QueryModifier::FatalCycle(modifier))\n         } else if modifier == \"cycle_delay_bug\" {\n-            Ok(QueryModifier::CycleDelayBug)\n+            Ok(QueryModifier::CycleDelayBug(modifier))\n         } else if modifier == \"no_hash\" {\n-            Ok(QueryModifier::NoHash)\n+            Ok(QueryModifier::NoHash(modifier))\n         } else if modifier == \"anon\" {\n-            Ok(QueryModifier::Anon)\n+            Ok(QueryModifier::Anon(modifier))\n         } else if modifier == \"eval_always\" {\n-            Ok(QueryModifier::EvalAlways)\n+            Ok(QueryModifier::EvalAlways(modifier))\n         } else {\n             Err(Error::new(modifier.span(), \"unknown query modifier\"))\n         }\n@@ -203,19 +203,19 @@ struct QueryModifiers {\n     load_cached: Option<(Ident, Ident, Block)>,\n \n     /// A cycle error for this query aborting the compilation with a fatal error.\n-    fatal_cycle: bool,\n+    fatal_cycle: Option<Ident>,\n \n     /// A cycle error results in a delay_bug call\n-    cycle_delay_bug: bool,\n+    cycle_delay_bug: Option<Ident>,\n \n     /// Don't hash the result, instead just mark a query red if it runs\n-    no_hash: bool,\n+    no_hash: Option<Ident>,\n \n     /// Generate a dep node based on the dependencies of the query\n-    anon: bool,\n+    anon: Option<Ident>,\n \n     // Always evaluate the query, ignoring its dependencies\n-    eval_always: bool,\n+    eval_always: Option<Ident>,\n }\n \n /// Process query modifiers into a struct, erroring on duplicates\n@@ -224,11 +224,11 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n     let mut storage = None;\n     let mut cache = None;\n     let mut desc = None;\n-    let mut fatal_cycle = false;\n-    let mut cycle_delay_bug = false;\n-    let mut no_hash = false;\n-    let mut anon = false;\n-    let mut eval_always = false;\n+    let mut fatal_cycle = None;\n+    let mut cycle_delay_bug = None;\n+    let mut no_hash = None;\n+    let mut anon = None;\n+    let mut eval_always = None;\n     for modifier in query.modifiers.0.drain(..) {\n         match modifier {\n             QueryModifier::LoadCached(tcx, id, block) => {\n@@ -289,35 +289,35 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n                 }\n                 desc = Some((tcx, list));\n             }\n-            QueryModifier::FatalCycle => {\n-                if fatal_cycle {\n+            QueryModifier::FatalCycle(ident) => {\n+                if fatal_cycle.is_some() {\n                     panic!(\"duplicate modifier `fatal_cycle` for query `{}`\", query.name);\n                 }\n-                fatal_cycle = true;\n+                fatal_cycle = Some(ident);\n             }\n-            QueryModifier::CycleDelayBug => {\n-                if cycle_delay_bug {\n+            QueryModifier::CycleDelayBug(ident) => {\n+                if cycle_delay_bug.is_some() {\n                     panic!(\"duplicate modifier `cycle_delay_bug` for query `{}`\", query.name);\n                 }\n-                cycle_delay_bug = true;\n+                cycle_delay_bug = Some(ident);\n             }\n-            QueryModifier::NoHash => {\n-                if no_hash {\n+            QueryModifier::NoHash(ident) => {\n+                if no_hash.is_some() {\n                     panic!(\"duplicate modifier `no_hash` for query `{}`\", query.name);\n                 }\n-                no_hash = true;\n+                no_hash = Some(ident);\n             }\n-            QueryModifier::Anon => {\n-                if anon {\n+            QueryModifier::Anon(ident) => {\n+                if anon.is_some() {\n                     panic!(\"duplicate modifier `anon` for query `{}`\", query.name);\n                 }\n-                anon = true;\n+                anon = Some(ident);\n             }\n-            QueryModifier::EvalAlways => {\n-                if eval_always {\n+            QueryModifier::EvalAlways(ident) => {\n+                if eval_always.is_some() {\n                     panic!(\"duplicate modifier `eval_always` for query `{}`\", query.name);\n                 }\n-                eval_always = true;\n+                eval_always = Some(ident);\n             }\n         }\n     }\n@@ -454,31 +454,39 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n         let mut attributes = Vec::new();\n \n         // Pass on the fatal_cycle modifier\n-        if modifiers.fatal_cycle {\n-            attributes.push(quote! { fatal_cycle });\n+        if let Some(fatal_cycle) = &modifiers.fatal_cycle {\n+            attributes.push(quote! { #fatal_cycle });\n         };\n         // Pass on the storage modifier\n         if let Some(ref ty) = modifiers.storage {\n-            attributes.push(quote! { storage(#ty) });\n+            let span = ty.span();\n+            attributes.push(quote_spanned! {span=> storage(#ty) });\n         };\n         // Pass on the cycle_delay_bug modifier\n-        if modifiers.cycle_delay_bug {\n-            attributes.push(quote! { cycle_delay_bug });\n+        if let Some(cycle_delay_bug) = &modifiers.cycle_delay_bug {\n+            attributes.push(quote! { #cycle_delay_bug });\n         };\n         // Pass on the no_hash modifier\n-        if modifiers.no_hash {\n-            attributes.push(quote! { no_hash });\n+        if let Some(no_hash) = &modifiers.no_hash {\n+            attributes.push(quote! { #no_hash });\n         };\n         // Pass on the anon modifier\n-        if modifiers.anon {\n-            attributes.push(quote! { anon });\n+        if let Some(anon) = &modifiers.anon {\n+            attributes.push(quote! { #anon });\n         };\n         // Pass on the eval_always modifier\n-        if modifiers.eval_always {\n-            attributes.push(quote! { eval_always });\n+        if let Some(eval_always) = &modifiers.eval_always {\n+            attributes.push(quote! { #eval_always });\n         };\n \n-        let attribute_stream = quote! {#(#attributes),*};\n+        // This uses the span of the query definition for the commas,\n+        // which can be important if we later encounter any ambiguity\n+        // errors with any of the numerous macro_rules! macros that\n+        // we use. Using the call-site span would result in a span pointing\n+        // at the entire `rustc_queries!` invocation, which wouldn't\n+        // be very useful.\n+        let span = name.span();\n+        let attribute_stream = quote_spanned! {span=> #(#attributes),*};\n         let doc_comments = query.doc_comments.iter();\n         // Add the query to the group\n         query_stream.extend(quote! {"}, {"sha": "a683cb05e16b69c448dbe6af7a9ba823fad4d3a6", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 76, "deletions": 63, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/6d64f7f695943541fe12bb960971403f440d7225/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d64f7f695943541fe12bb960971403f440d7225/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=6d64f7f695943541fe12bb960971403f440d7225", "patch": "@@ -11,7 +11,8 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId, LocalDefIdSet};\n+use rustc_hir::def_id::{CRATE_DEF_ID, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, DeepVisitor, NestedVisitorMap, Visitor};\n use rustc_hir::{AssocItemKind, HirIdSet, Node, PatKind};\n use rustc_middle::bug;\n@@ -354,9 +355,8 @@ trait VisibilityLike: Sized {\n \n     // Returns an over-approximation (`skip_assoc_tys` = true) of visibility due to\n     // associated types for which we can't determine visibility precisely.\n-    fn of_impl(hir_id: hir::HirId, tcx: TyCtxt<'_>, access_levels: &AccessLevels) -> Self {\n+    fn of_impl(def_id: LocalDefId, tcx: TyCtxt<'_>, access_levels: &AccessLevels) -> Self {\n         let mut find = FindMin { tcx, access_levels, min: Self::MAX };\n-        let def_id = tcx.hir().local_def_id(hir_id);\n         find.visit(tcx.type_of(def_id));\n         if let Some(trait_ref) = tcx.impl_trait_ref(def_id) {\n             find.visit_trait(trait_ref);\n@@ -424,7 +424,7 @@ struct EmbargoVisitor<'tcx> {\n \n struct ReachEverythingInTheInterfaceVisitor<'a, 'tcx> {\n     access_level: Option<AccessLevel>,\n-    item_def_id: DefId,\n+    item_def_id: LocalDefId,\n     ev: &'a mut EmbargoVisitor<'tcx>,\n }\n \n@@ -448,12 +448,12 @@ impl EmbargoVisitor<'tcx> {\n \n     fn reach(\n         &mut self,\n-        item_id: hir::HirId,\n+        def_id: LocalDefId,\n         access_level: Option<AccessLevel>,\n     ) -> ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n             access_level: cmp::min(access_level, Some(AccessLevel::Reachable)),\n-            item_def_id: self.tcx.hir().local_def_id(item_id).to_def_id(),\n+            item_def_id: def_id,\n             ev: self,\n         }\n     }\n@@ -536,10 +536,10 @@ impl EmbargoVisitor<'tcx> {\n                     | hir::ItemKind::Union(ref struct_def, _) = item.kind\n                     {\n                         for field in struct_def.fields() {\n-                            let field_vis =\n-                                self.tcx.visibility(self.tcx.hir().local_def_id(field.hir_id));\n+                            let def_id = self.tcx.hir().local_def_id(field.hir_id);\n+                            let field_vis = self.tcx.visibility(def_id);\n                             if field_vis.is_accessible_from(module.to_def_id(), self.tcx) {\n-                                self.reach(field.hir_id, level).ty();\n+                                self.reach(def_id, level).ty();\n                             }\n                         }\n                     } else {\n@@ -638,7 +638,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let inherited_item_level = match item.kind {\n             hir::ItemKind::Impl { .. } => {\n-                Option::<AccessLevel>::of_impl(item.hir_id(), self.tcx, &self.access_levels)\n+                Option::<AccessLevel>::of_impl(item.def_id, self.tcx, &self.access_levels)\n             }\n             // Foreign modules inherit level from parents.\n             hir::ItemKind::ForeignMod { .. } => self.prev_level,\n@@ -750,7 +750,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     // reachable if they are returned via `impl Trait`, even from private functions.\n                     let exist_level =\n                         cmp::max(item_level, Some(AccessLevel::ReachableFromImplTrait));\n-                    self.reach(item.hir_id(), exist_level).generics().predicates().ty();\n+                    self.reach(item.def_id, exist_level).generics().predicates().ty();\n                 }\n             }\n             // Visit everything.\n@@ -759,15 +759,15 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             | hir::ItemKind::Fn(..)\n             | hir::ItemKind::TyAlias(..) => {\n                 if item_level.is_some() {\n-                    self.reach(item.hir_id(), item_level).generics().predicates().ty();\n+                    self.reach(item.def_id, item_level).generics().predicates().ty();\n                 }\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n                 if item_level.is_some() {\n-                    self.reach(item.hir_id(), item_level).generics().predicates();\n+                    self.reach(item.def_id, item_level).generics().predicates();\n \n                     for trait_item_ref in trait_item_refs {\n-                        let mut reach = self.reach(trait_item_ref.id.hir_id(), item_level);\n+                        let mut reach = self.reach(trait_item_ref.id.def_id, item_level);\n                         reach.generics().predicates();\n \n                         if trait_item_ref.kind == AssocItemKind::Type\n@@ -782,18 +782,18 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             }\n             hir::ItemKind::TraitAlias(..) => {\n                 if item_level.is_some() {\n-                    self.reach(item.hir_id(), item_level).generics().predicates();\n+                    self.reach(item.def_id, item_level).generics().predicates();\n                 }\n             }\n             // Visit everything except for private impl items.\n             hir::ItemKind::Impl(ref impl_) => {\n                 if item_level.is_some() {\n-                    self.reach(item.hir_id(), item_level).generics().predicates().ty().trait_ref();\n+                    self.reach(item.def_id, item_level).generics().predicates().ty().trait_ref();\n \n                     for impl_item_ref in impl_.items {\n                         let impl_item_level = self.get(impl_item_ref.id.def_id);\n                         if impl_item_level.is_some() {\n-                            self.reach(impl_item_ref.id.hir_id(), impl_item_level)\n+                            self.reach(impl_item_ref.id.def_id, impl_item_level)\n                                 .generics()\n                                 .predicates()\n                                 .ty();\n@@ -805,13 +805,14 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             // Visit everything, but enum variants have their own levels.\n             hir::ItemKind::Enum(ref def, _) => {\n                 if item_level.is_some() {\n-                    self.reach(item.hir_id(), item_level).generics().predicates();\n+                    self.reach(item.def_id, item_level).generics().predicates();\n                 }\n                 for variant in def.variants {\n                     let variant_level = self.get(self.tcx.hir().local_def_id(variant.id));\n                     if variant_level.is_some() {\n                         for field in variant.data.fields() {\n-                            self.reach(field.hir_id, variant_level).ty();\n+                            self.reach(self.tcx.hir().local_def_id(field.hir_id), variant_level)\n+                                .ty();\n                         }\n                         // Corner case: if the variant is reachable, but its\n                         // enum is not, make the enum reachable as well.\n@@ -824,7 +825,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                 for foreign_item in items {\n                     let foreign_item_level = self.get(foreign_item.id.def_id);\n                     if foreign_item_level.is_some() {\n-                        self.reach(foreign_item.id.hir_id(), foreign_item_level)\n+                        self.reach(foreign_item.id.def_id, foreign_item_level)\n                             .generics()\n                             .predicates()\n                             .ty();\n@@ -834,11 +835,12 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             // Visit everything except for private fields.\n             hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n                 if item_level.is_some() {\n-                    self.reach(item.hir_id(), item_level).generics().predicates();\n+                    self.reach(item.def_id, item_level).generics().predicates();\n                     for field in struct_def.fields() {\n-                        let field_level = self.get(self.tcx.hir().local_def_id(field.hir_id));\n+                        let def_id = self.tcx.hir().local_def_id(field.hir_id);\n+                        let field_level = self.get(def_id);\n                         if field_level.is_some() {\n-                            self.reach(field.hir_id, field_level).ty();\n+                            self.reach(def_id, field_level).ty();\n                         }\n                     }\n                 }\n@@ -992,7 +994,7 @@ impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n struct NamePrivacyVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     maybe_typeck_results: Option<&'tcx ty::TypeckResults<'tcx>>,\n-    current_item: Option<hir::HirId>,\n+    current_item: LocalDefId,\n }\n \n impl<'tcx> NamePrivacyVisitor<'tcx> {\n@@ -1014,11 +1016,15 @@ impl<'tcx> NamePrivacyVisitor<'tcx> {\n         field: &'tcx ty::FieldDef,\n         in_update_syntax: bool,\n     ) {\n+        if def.is_enum() {\n+            return;\n+        }\n+\n         // definition of the field\n         let ident = Ident::new(kw::Empty, use_ctxt);\n-        let current_hir = self.current_item.unwrap();\n-        let def_id = self.tcx.adjust_ident_and_get_scope(ident, def.did, current_hir).1;\n-        if !def.is_enum() && !field.vis.is_accessible_from(def_id, self.tcx) {\n+        let hir_id = self.tcx.hir().local_def_id_to_hir_id(self.current_item);\n+        let def_id = self.tcx.adjust_ident_and_get_scope(ident, def.did, hir_id).1;\n+        if !field.vis.is_accessible_from(def_id, self.tcx) {\n             let label = if in_update_syntax {\n                 format!(\"field `{}` is private\", field.ident)\n             } else {\n@@ -1063,7 +1069,7 @@ impl<'tcx> Visitor<'tcx> for NamePrivacyVisitor<'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let orig_current_item = self.current_item.replace(item.hir_id());\n+        let orig_current_item = mem::replace(&mut self.current_item, item.def_id);\n         intravisit::walk_item(self, item);\n         self.current_item = orig_current_item;\n     }\n@@ -1763,9 +1769,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n \n struct SearchInterfaceForPrivateItemsVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    item_id: hir::HirId,\n-    item_def_id: DefId,\n-    span: Span,\n+    item_def_id: LocalDefId,\n     /// The visitor checks that each component type is at least this visible.\n     required_visibility: ty::Visibility,\n     has_pub_restricted: bool,\n@@ -1820,8 +1824,8 @@ impl SearchInterfaceForPrivateItemsVisitor<'tcx> {\n         if self.leaks_private_dep(def_id) {\n             self.tcx.struct_span_lint_hir(\n                 lint::builtin::EXPORTED_PRIVATE_DEPENDENCIES,\n-                self.item_id,\n-                self.span,\n+                self.tcx.hir().local_def_id_to_hir_id(self.item_def_id),\n+                self.tcx.def_span(self.item_def_id.to_def_id()),\n                 |lint| {\n                     lint.build(&format!(\n                         \"{} `{}` from private dependency '{}' in public \\\n@@ -1856,23 +1860,24 @@ impl SearchInterfaceForPrivateItemsVisitor<'tcx> {\n                 }\n             };\n             let make_msg = || format!(\"{} {} `{}` in public interface\", vis_descr, kind, descr);\n+            let span = self.tcx.def_span(self.item_def_id.to_def_id());\n             if self.has_pub_restricted || self.has_old_errors || self.in_assoc_ty {\n                 let mut err = if kind == \"trait\" {\n-                    struct_span_err!(self.tcx.sess, self.span, E0445, \"{}\", make_msg())\n+                    struct_span_err!(self.tcx.sess, span, E0445, \"{}\", make_msg())\n                 } else {\n-                    struct_span_err!(self.tcx.sess, self.span, E0446, \"{}\", make_msg())\n+                    struct_span_err!(self.tcx.sess, span, E0446, \"{}\", make_msg())\n                 };\n                 let vis_span =\n                     self.tcx.sess.source_map().guess_head_span(self.tcx.def_span(def_id));\n-                err.span_label(self.span, format!(\"can't leak {} {}\", vis_descr, kind));\n+                err.span_label(span, format!(\"can't leak {} {}\", vis_descr, kind));\n                 err.span_label(vis_span, format!(\"`{}` declared as {}\", descr, vis_descr));\n                 err.emit();\n             } else {\n                 let err_code = if kind == \"trait\" { \"E0445\" } else { \"E0446\" };\n                 self.tcx.struct_span_lint_hir(\n                     lint::builtin::PRIVATE_IN_PUBLIC,\n                     hir_id,\n-                    self.span,\n+                    span,\n                     |lint| lint.build(&format!(\"{} (error {})\", make_msg(), err_code)).emit(),\n                 );\n             }\n@@ -1915,35 +1920,33 @@ impl DefIdVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'tcx> {\n struct PrivateItemsInPublicInterfacesVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     has_pub_restricted: bool,\n-    old_error_set_ancestry: HirIdSet,\n+    old_error_set_ancestry: LocalDefIdSet,\n }\n \n impl<'tcx> PrivateItemsInPublicInterfacesVisitor<'tcx> {\n     fn check(\n         &self,\n-        item_id: hir::HirId,\n+        def_id: LocalDefId,\n         required_visibility: ty::Visibility,\n     ) -> SearchInterfaceForPrivateItemsVisitor<'tcx> {\n         SearchInterfaceForPrivateItemsVisitor {\n             tcx: self.tcx,\n-            item_id,\n-            item_def_id: self.tcx.hir().local_def_id(item_id).to_def_id(),\n-            span: self.tcx.hir().span(item_id),\n+            item_def_id: def_id,\n             required_visibility,\n             has_pub_restricted: self.has_pub_restricted,\n-            has_old_errors: self.old_error_set_ancestry.contains(&item_id),\n+            has_old_errors: self.old_error_set_ancestry.contains(&def_id),\n             in_assoc_ty: false,\n         }\n     }\n \n     fn check_assoc_item(\n         &self,\n-        hir_id: hir::HirId,\n+        def_id: LocalDefId,\n         assoc_item_kind: AssocItemKind,\n         defaultness: hir::Defaultness,\n         vis: ty::Visibility,\n     ) {\n-        let mut check = self.check(hir_id, vis);\n+        let mut check = self.check(def_id, vis);\n \n         let (check_ty, is_assoc_ty) = match assoc_item_kind {\n             AssocItemKind::Const | AssocItemKind::Fn { .. } => (true, false),\n@@ -1982,72 +1985,73 @@ impl<'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'tcx> {\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Fn(..)\n             | hir::ItemKind::TyAlias(..) => {\n-                self.check(item.hir_id(), item_visibility).generics().predicates().ty();\n+                self.check(item.def_id, item_visibility).generics().predicates().ty();\n             }\n             hir::ItemKind::OpaqueTy(..) => {\n                 // `ty()` for opaque types is the underlying type,\n                 // it's not a part of interface, so we skip it.\n-                self.check(item.hir_id(), item_visibility).generics().bounds();\n+                self.check(item.def_id, item_visibility).generics().bounds();\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n-                self.check(item.hir_id(), item_visibility).generics().predicates();\n+                self.check(item.def_id, item_visibility).generics().predicates();\n \n                 for trait_item_ref in trait_item_refs {\n                     self.check_assoc_item(\n-                        trait_item_ref.id.hir_id(),\n+                        trait_item_ref.id.def_id,\n                         trait_item_ref.kind,\n                         trait_item_ref.defaultness,\n                         item_visibility,\n                     );\n \n                     if let AssocItemKind::Type = trait_item_ref.kind {\n-                        self.check(trait_item_ref.id.hir_id(), item_visibility).bounds();\n+                        self.check(trait_item_ref.id.def_id, item_visibility).bounds();\n                     }\n                 }\n             }\n             hir::ItemKind::TraitAlias(..) => {\n-                self.check(item.hir_id(), item_visibility).generics().predicates();\n+                self.check(item.def_id, item_visibility).generics().predicates();\n             }\n             hir::ItemKind::Enum(ref def, _) => {\n-                self.check(item.hir_id(), item_visibility).generics().predicates();\n+                self.check(item.def_id, item_visibility).generics().predicates();\n \n                 for variant in def.variants {\n                     for field in variant.data.fields() {\n-                        self.check(field.hir_id, item_visibility).ty();\n+                        self.check(self.tcx.hir().local_def_id(field.hir_id), item_visibility).ty();\n                     }\n                 }\n             }\n             // Subitems of foreign modules have their own publicity.\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n                     let vis = tcx.visibility(foreign_item.id.def_id);\n-                    self.check(foreign_item.id.hir_id(), vis).generics().predicates().ty();\n+                    self.check(foreign_item.id.def_id, vis).generics().predicates().ty();\n                 }\n             }\n             // Subitems of structs and unions have their own publicity.\n             hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n-                self.check(item.hir_id(), item_visibility).generics().predicates();\n+                self.check(item.def_id, item_visibility).generics().predicates();\n \n                 for field in struct_def.fields() {\n-                    let field_visibility = tcx.visibility(tcx.hir().local_def_id(field.hir_id));\n-                    self.check(field.hir_id, min(item_visibility, field_visibility, tcx)).ty();\n+                    let def_id = tcx.hir().local_def_id(field.hir_id);\n+                    let field_visibility = tcx.visibility(def_id);\n+                    self.check(def_id, min(item_visibility, field_visibility, tcx)).ty();\n                 }\n             }\n             // An inherent impl is public when its type is public\n             // Subitems of inherent impls have their own publicity.\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity.\n             hir::ItemKind::Impl(ref impl_) => {\n-                let impl_vis = ty::Visibility::of_impl(item.hir_id(), tcx, &Default::default());\n-                self.check(item.hir_id(), impl_vis).generics().predicates();\n+                let impl_vis = ty::Visibility::of_impl(item.def_id, tcx, &Default::default());\n+                self.check(item.def_id, impl_vis).generics().predicates();\n                 for impl_item_ref in impl_.items {\n                     let impl_item_vis = if impl_.of_trait.is_none() {\n                         min(tcx.visibility(impl_item_ref.id.def_id), impl_vis, tcx)\n                     } else {\n                         impl_vis\n                     };\n                     self.check_assoc_item(\n-                        impl_item_ref.id.hir_id(),\n+                        impl_item_ref.id.def_id,\n                         impl_item_ref.kind,\n                         impl_item_ref.defaultness,\n                         impl_item_vis,\n@@ -2119,7 +2123,8 @@ fn visibility(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Visibility {\n \n fn check_mod_privacy(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     // Check privacy of names not checked in previous compilation stages.\n-    let mut visitor = NamePrivacyVisitor { tcx, maybe_typeck_results: None, current_item: None };\n+    let mut visitor =\n+        NamePrivacyVisitor { tcx, maybe_typeck_results: None, current_item: module_def_id };\n     let (module, span, hir_id) = tcx.hir().get_module(module_def_id);\n \n     intravisit::walk_mod(&mut visitor, module, hir_id);\n@@ -2188,7 +2193,15 @@ fn check_private_in_public(tcx: TyCtxt<'_>, (): ()) {\n     }\n \n     // Check for private types and traits in public interfaces.\n-    let mut visitor =\n-        PrivateItemsInPublicInterfacesVisitor { tcx, has_pub_restricted, old_error_set_ancestry };\n+    let mut visitor = PrivateItemsInPublicInterfacesVisitor {\n+        tcx,\n+        has_pub_restricted,\n+        // Only definition IDs are ever searched in `old_error_set_ancestry`,\n+        // so we can filter away all non-definition IDs at this point.\n+        old_error_set_ancestry: old_error_set_ancestry\n+            .into_iter()\n+            .filter_map(|hir_id| tcx.hir().opt_local_def_id(hir_id))\n+            .collect(),\n+    };\n     krate.visit_all_item_likes(&mut DeepVisitor::new(&mut visitor));\n }"}, {"sha": "9e127577b61a664c8d75b1b561603c650923de73", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d64f7f695943541fe12bb960971403f440d7225/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d64f7f695943541fe12bb960971403f440d7225/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=6d64f7f695943541fe12bb960971403f440d7225", "patch": "@@ -157,7 +157,7 @@ scoped_tls::scoped_thread_local!(static SESSION_GLOBALS: SessionGlobals);\n // FIXME: We should use this enum or something like it to get rid of the\n // use of magic `/rust/1.x/...` paths across the board.\n #[derive(Debug, Eq, PartialEq, Clone, Ord, PartialOrd)]\n-#[derive(HashStable_Generic, Decodable)]\n+#[derive(Decodable)]\n pub enum RealFileName {\n     LocalPath(PathBuf),\n     /// For remapped paths (namely paths into libstd that have been mapped\n@@ -269,7 +269,7 @@ impl RealFileName {\n \n /// Differentiates between real files and common virtual files.\n #[derive(Debug, Eq, PartialEq, Clone, Ord, PartialOrd, Hash)]\n-#[derive(HashStable_Generic, Decodable, Encodable)]\n+#[derive(Decodable, Encodable)]\n pub enum FileName {\n     Real(RealFileName),\n     /// Call to `quote!`."}, {"sha": "c8eb4811f7e9856a06ea3796b04f8b6c55ca381b", "filename": "library/std/src/net/tcp.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6d64f7f695943541fe12bb960971403f440d7225/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d64f7f695943541fe12bb960971403f440d7225/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs?ref=6d64f7f695943541fe12bb960971403f440d7225", "patch": "@@ -767,17 +767,24 @@ impl TcpListener {\n     /// # Examples\n     ///\n     /// ```no_run\n-    /// use std::net::TcpListener;\n+    /// use std::net::{TcpListener, TcpStream};\n     ///\n-    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n+    /// fn handle_connection(stream: TcpStream) {\n+    ///    //...\n+    /// }\n     ///\n-    /// for stream in listener.incoming() {\n-    ///     match stream {\n-    ///         Ok(stream) => {\n-    ///             println!(\"new client!\");\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n+    ///\n+    ///     for stream in listener.incoming() {\n+    ///         match stream {\n+    ///             Ok(stream) => {\n+    ///                 handle_connection(stream);\n+    ///             }\n+    ///             Err(e) => { /* connection failed */ }\n     ///         }\n-    ///         Err(e) => { /* connection failed */ }\n     ///     }\n+    ///     Ok(())\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "f8fc9243e14b95891549e9dd1b835f2e42cded95", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6d64f7f695943541fe12bb960971403f440d7225/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d64f7f695943541fe12bb960971403f440d7225/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=6d64f7f695943541fe12bb960971403f440d7225", "patch": "@@ -65,10 +65,11 @@ fn write_header(out: &mut Buffer, class: Option<&str>, extra_content: Option<Buf\n         out.push_buffer(extra);\n     }\n     if let Some(class) = class {\n-        writeln!(out, \"<pre class=\\\"rust {}\\\">\", class);\n+        write!(out, \"<pre class=\\\"rust {}\\\">\", class);\n     } else {\n-        writeln!(out, \"<pre class=\\\"rust\\\">\");\n+        write!(out, \"<pre class=\\\"rust\\\">\");\n     }\n+    write!(out, \"<code>\");\n }\n \n /// Convert the given `src` source code into HTML by adding classes for highlighting.\n@@ -101,7 +102,7 @@ fn write_code(\n }\n \n fn write_footer(out: &mut Buffer, playground_button: Option<&str>) {\n-    writeln!(out, \"</pre>{}</div>\", playground_button.unwrap_or_default());\n+    writeln!(out, \"</code></pre>{}</div>\", playground_button.unwrap_or_default());\n }\n \n /// How a span of text is classified. Mostly corresponds to token kinds."}, {"sha": "7c6d7dff816d539ed77a69521fca2df775dbfa36", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d64f7f695943541fe12bb960971403f440d7225/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d64f7f695943541fe12bb960971403f440d7225/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=6d64f7f695943541fe12bb960971403f440d7225", "patch": "@@ -234,7 +234,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n                     return Some(Event::Html(\n                         format!(\n                             \"<div class=\\\"example-wrap\\\">\\\n-                                 <pre class=\\\"language-{}\\\">{}</pre>\\\n+                                 <pre class=\\\"language-{}\\\"><code>{}</code></pre>\\\n                              </div>\",\n                             lang,\n                             Escape(&text),"}, {"sha": "96cc67ce97c756a44c8757f0dbdce9a3297471e0", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 289, "deletions": 261, "changes": 550, "blob_url": "https://github.com/rust-lang/rust/blob/6d64f7f695943541fe12bb960971403f440d7225/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d64f7f695943541fe12bb960971403f440d7225/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=6d64f7f695943541fe12bb960971403f440d7225", "patch": "@@ -454,24 +454,25 @@ fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::\n         + name.as_str().len()\n         + generics_len;\n \n-    w.write_str(\"<pre class=\\\"rust fn\\\">\");\n-    render_attributes_in_pre(w, it, \"\");\n-    w.reserve(header_len);\n-    write!(\n-        w,\n-        \"{vis}{constness}{asyncness}{unsafety}{abi}fn \\\n-         {name}{generics}{decl}{notable_traits}{where_clause}</pre>\",\n-        vis = vis,\n-        constness = constness,\n-        asyncness = asyncness,\n-        unsafety = unsafety,\n-        abi = abi,\n-        name = name,\n-        generics = f.generics.print(cx),\n-        where_clause = print_where_clause(&f.generics, cx, 0, true),\n-        decl = f.decl.full_print(header_len, 0, f.header.asyncness, cx),\n-        notable_traits = notable_traits_decl(&f.decl, cx),\n-    );\n+    wrap_item(w, \"fn\", |w| {\n+        render_attributes_in_pre(w, it, \"\");\n+        w.reserve(header_len);\n+        write!(\n+            w,\n+            \"{vis}{constness}{asyncness}{unsafety}{abi}fn \\\n+             {name}{generics}{decl}{notable_traits}{where_clause}\",\n+            vis = vis,\n+            constness = constness,\n+            asyncness = asyncness,\n+            unsafety = unsafety,\n+            abi = abi,\n+            name = name,\n+            generics = f.generics.print(cx),\n+            where_clause = print_where_clause(&f.generics, cx, 0, true),\n+            decl = f.decl.full_print(header_len, 0, f.header.asyncness, cx),\n+            notable_traits = notable_traits_decl(&f.decl, cx),\n+        );\n+    });\n     document(w, cx, it, None)\n }\n \n@@ -487,108 +488,111 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n \n     // Output the trait definition\n     wrap_into_docblock(w, |w| {\n-        w.write_str(\"<pre class=\\\"rust trait\\\">\");\n-        render_attributes_in_pre(w, it, \"\");\n-        write!(\n-            w,\n-            \"{}{}{}trait {}{}{}\",\n-            it.visibility.print_with_space(it.def_id, cx),\n-            t.unsafety.print_with_space(),\n-            if t.is_auto { \"auto \" } else { \"\" },\n-            it.name.as_ref().unwrap(),\n-            t.generics.print(cx),\n-            bounds\n-        );\n-\n-        if !t.generics.where_predicates.is_empty() {\n-            write!(w, \"{}\", print_where_clause(&t.generics, cx, 0, true));\n-        } else {\n-            w.write_str(\" \");\n-        }\n+        wrap_item(w, \"trait\", |w| {\n+            render_attributes_in_pre(w, it, \"\");\n+            write!(\n+                w,\n+                \"{}{}{}trait {}{}{}\",\n+                it.visibility.print_with_space(it.def_id, cx),\n+                t.unsafety.print_with_space(),\n+                if t.is_auto { \"auto \" } else { \"\" },\n+                it.name.as_ref().unwrap(),\n+                t.generics.print(cx),\n+                bounds\n+            );\n \n-        if t.items.is_empty() {\n-            w.write_str(\"{ }\");\n-        } else {\n-            // FIXME: we should be using a derived_id for the Anchors here\n-            w.write_str(\"{\\n\");\n-            let mut toggle = false;\n-\n-            // If there are too many associated types, hide _everything_\n-            if should_hide_fields(count_types) {\n-                toggle = true;\n-                toggle_open(\n-                    w,\n-                    format_args!(\"{} associated items\", count_types + count_consts + count_methods),\n-                );\n-            }\n-            for t in &types {\n-                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n-                w.write_str(\";\\n\");\n-            }\n-            // If there are too many associated constants, hide everything after them\n-            // We also do this if the types + consts is large because otherwise we could\n-            // render a bunch of types and _then_ a bunch of consts just because both were\n-            // _just_ under the limit\n-            if !toggle && should_hide_fields(count_types + count_consts) {\n-                toggle = true;\n-                toggle_open(\n-                    w,\n-                    format_args!(\n-                        \"{} associated constant{} and {} method{}\",\n-                        count_consts,\n-                        pluralize(count_consts),\n-                        count_methods,\n-                        pluralize(count_methods),\n-                    ),\n-                );\n-            }\n-            if !types.is_empty() && !consts.is_empty() {\n-                w.write_str(\"\\n\");\n-            }\n-            for t in &consts {\n-                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n-                w.write_str(\";\\n\");\n-            }\n-            if !toggle && should_hide_fields(count_methods) {\n-                toggle = true;\n-                toggle_open(w, format_args!(\"{} methods\", count_methods));\n-            }\n-            if !consts.is_empty() && !required.is_empty() {\n-                w.write_str(\"\\n\");\n+            if !t.generics.where_predicates.is_empty() {\n+                write!(w, \"{}\", print_where_clause(&t.generics, cx, 0, true));\n+            } else {\n+                w.write_str(\" \");\n             }\n-            for (pos, m) in required.iter().enumerate() {\n-                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n-                w.write_str(\";\\n\");\n \n-                if pos < required.len() - 1 {\n-                    w.write_str(\"<div class=\\\"item-spacer\\\"></div>\");\n+            if t.items.is_empty() {\n+                w.write_str(\"{ }\");\n+            } else {\n+                // FIXME: we should be using a derived_id for the Anchors here\n+                w.write_str(\"{\\n\");\n+                let mut toggle = false;\n+\n+                // If there are too many associated types, hide _everything_\n+                if should_hide_fields(count_types) {\n+                    toggle = true;\n+                    toggle_open(\n+                        w,\n+                        format_args!(\n+                            \"{} associated items\",\n+                            count_types + count_consts + count_methods\n+                        ),\n+                    );\n                 }\n-            }\n-            if !required.is_empty() && !provided.is_empty() {\n-                w.write_str(\"\\n\");\n-            }\n-            for (pos, m) in provided.iter().enumerate() {\n-                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n-                match *m.kind {\n-                    clean::MethodItem(ref inner, _)\n-                        if !inner.generics.where_predicates.is_empty() =>\n-                    {\n-                        w.write_str(\",\\n    { ... }\\n\");\n+                for t in &types {\n+                    render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n+                    w.write_str(\";\\n\");\n+                }\n+                // If there are too many associated constants, hide everything after them\n+                // We also do this if the types + consts is large because otherwise we could\n+                // render a bunch of types and _then_ a bunch of consts just because both were\n+                // _just_ under the limit\n+                if !toggle && should_hide_fields(count_types + count_consts) {\n+                    toggle = true;\n+                    toggle_open(\n+                        w,\n+                        format_args!(\n+                            \"{} associated constant{} and {} method{}\",\n+                            count_consts,\n+                            pluralize(count_consts),\n+                            count_methods,\n+                            pluralize(count_methods),\n+                        ),\n+                    );\n+                }\n+                if !types.is_empty() && !consts.is_empty() {\n+                    w.write_str(\"\\n\");\n+                }\n+                for t in &consts {\n+                    render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n+                    w.write_str(\";\\n\");\n+                }\n+                if !toggle && should_hide_fields(count_methods) {\n+                    toggle = true;\n+                    toggle_open(w, format_args!(\"{} methods\", count_methods));\n+                }\n+                if !consts.is_empty() && !required.is_empty() {\n+                    w.write_str(\"\\n\");\n+                }\n+                for (pos, m) in required.iter().enumerate() {\n+                    render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n+                    w.write_str(\";\\n\");\n+\n+                    if pos < required.len() - 1 {\n+                        w.write_str(\"<div class=\\\"item-spacer\\\"></div>\");\n                     }\n-                    _ => {\n-                        w.write_str(\" { ... }\\n\");\n+                }\n+                if !required.is_empty() && !provided.is_empty() {\n+                    w.write_str(\"\\n\");\n+                }\n+                for (pos, m) in provided.iter().enumerate() {\n+                    render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n+                    match *m.kind {\n+                        clean::MethodItem(ref inner, _)\n+                            if !inner.generics.where_predicates.is_empty() =>\n+                        {\n+                            w.write_str(\",\\n    { ... }\\n\");\n+                        }\n+                        _ => {\n+                            w.write_str(\" { ... }\\n\");\n+                        }\n+                    }\n+                    if pos < provided.len() - 1 {\n+                        w.write_str(\"<div class=\\\"item-spacer\\\"></div>\");\n                     }\n                 }\n-                if pos < provided.len() - 1 {\n-                    w.write_str(\"<div class=\\\"item-spacer\\\"></div>\");\n+                if toggle {\n+                    toggle_close(w);\n                 }\n+                w.write_str(\"}\");\n             }\n-            if toggle {\n-                toggle_close(w);\n-            }\n-            w.write_str(\"}\");\n-        }\n-        w.write_str(\"</pre>\")\n+        });\n     });\n \n     // Trait documentation\n@@ -811,16 +815,17 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n }\n \n fn item_trait_alias(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::TraitAlias) {\n-    w.write_str(\"<pre class=\\\"rust trait-alias\\\">\");\n-    render_attributes_in_pre(w, it, \"\");\n-    write!(\n-        w,\n-        \"trait {}{}{} = {};</pre>\",\n-        it.name.as_ref().unwrap(),\n-        t.generics.print(cx),\n-        print_where_clause(&t.generics, cx, 0, true),\n-        bounds(&t.bounds, true, cx)\n-    );\n+    wrap_item(w, \"trait-alias\", |w| {\n+        render_attributes_in_pre(w, it, \"\");\n+        write!(\n+            w,\n+            \"trait {}{}{} = {};\",\n+            it.name.as_ref().unwrap(),\n+            t.generics.print(cx),\n+            print_where_clause(&t.generics, cx, 0, true),\n+            bounds(&t.bounds, true, cx)\n+        );\n+    });\n \n     document(w, cx, it, None);\n \n@@ -832,16 +837,17 @@ fn item_trait_alias(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clea\n }\n \n fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::OpaqueTy) {\n-    w.write_str(\"<pre class=\\\"rust opaque\\\">\");\n-    render_attributes_in_pre(w, it, \"\");\n-    write!(\n-        w,\n-        \"type {}{}{where_clause} = impl {bounds};</pre>\",\n-        it.name.as_ref().unwrap(),\n-        t.generics.print(cx),\n-        where_clause = print_where_clause(&t.generics, cx, 0, true),\n-        bounds = bounds(&t.bounds, false, cx),\n-    );\n+    wrap_item(w, \"opaque\", |w| {\n+        render_attributes_in_pre(w, it, \"\");\n+        write!(\n+            w,\n+            \"type {}{}{where_clause} = impl {bounds};\",\n+            it.name.as_ref().unwrap(),\n+            t.generics.print(cx),\n+            where_clause = print_where_clause(&t.generics, cx, 0, true),\n+            bounds = bounds(&t.bounds, false, cx),\n+        );\n+    });\n \n     document(w, cx, it, None);\n \n@@ -859,19 +865,20 @@ fn item_typedef(\n     t: &clean::Typedef,\n     is_associated: bool,\n ) {\n-    w.write_str(\"<pre class=\\\"rust typedef\\\">\");\n-    render_attributes_in_pre(w, it, \"\");\n-    if !is_associated {\n-        write!(w, \"{}\", it.visibility.print_with_space(it.def_id, cx));\n-    }\n-    write!(\n-        w,\n-        \"type {}{}{where_clause} = {type_};</pre>\",\n-        it.name.as_ref().unwrap(),\n-        t.generics.print(cx),\n-        where_clause = print_where_clause(&t.generics, cx, 0, true),\n-        type_ = t.type_.print(cx),\n-    );\n+    wrap_item(w, \"typedef\", |w| {\n+        render_attributes_in_pre(w, it, \"\");\n+        if !is_associated {\n+            write!(w, \"{}\", it.visibility.print_with_space(it.def_id, cx));\n+        }\n+        write!(\n+            w,\n+            \"type {}{}{where_clause} = {type_};\",\n+            it.name.as_ref().unwrap(),\n+            t.generics.print(cx),\n+            where_clause = print_where_clause(&t.generics, cx, 0, true),\n+            type_ = t.type_.print(cx),\n+        );\n+    });\n \n     document(w, cx, it, None);\n \n@@ -885,10 +892,10 @@ fn item_typedef(\n \n fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Union) {\n     wrap_into_docblock(w, |w| {\n-        w.write_str(\"<pre class=\\\"rust union\\\">\");\n-        render_attributes_in_pre(w, it, \"\");\n-        render_union(w, it, Some(&s.generics), &s.fields, \"\", cx);\n-        w.write_str(\"</pre>\")\n+        wrap_item(w, \"union\", |w| {\n+            render_attributes_in_pre(w, it, \"\");\n+            render_union(w, it, Some(&s.generics), &s.fields, \"\", cx);\n+        });\n     });\n \n     document(w, cx, it, None);\n@@ -934,59 +941,68 @@ fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Uni\n \n fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum) {\n     wrap_into_docblock(w, |w| {\n-        w.write_str(\"<pre class=\\\"rust enum\\\">\");\n-        render_attributes_in_pre(w, it, \"\");\n-        write!(\n-            w,\n-            \"{}enum {}{}{}\",\n-            it.visibility.print_with_space(it.def_id, cx),\n-            it.name.as_ref().unwrap(),\n-            e.generics.print(cx),\n-            print_where_clause(&e.generics, cx, 0, true),\n-        );\n-        if e.variants.is_empty() && !e.variants_stripped {\n-            w.write_str(\" {}\");\n-        } else {\n-            w.write_str(\" {\\n\");\n-            let count_variants = e.variants.len();\n-            let toggle = should_hide_fields(count_variants);\n-            if toggle {\n-                toggle_open(w, format_args!(\"{} variants\", count_variants));\n-            }\n-            for v in &e.variants {\n-                w.write_str(\"    \");\n-                let name = v.name.as_ref().unwrap();\n-                match *v.kind {\n-                    clean::VariantItem(ref var) => match var {\n-                        clean::Variant::CLike => write!(w, \"{}\", name),\n-                        clean::Variant::Tuple(ref tys) => {\n-                            write!(w, \"{}(\", name);\n-                            for (i, ty) in tys.iter().enumerate() {\n-                                if i > 0 {\n-                                    w.write_str(\",&nbsp;\")\n+        wrap_item(w, \"enum\", |w| {\n+            render_attributes_in_pre(w, it, \"\");\n+            write!(\n+                w,\n+                \"{}enum {}{}{}\",\n+                it.visibility.print_with_space(it.def_id, cx),\n+                it.name.as_ref().unwrap(),\n+                e.generics.print(cx),\n+                print_where_clause(&e.generics, cx, 0, true),\n+            );\n+            if e.variants.is_empty() && !e.variants_stripped {\n+                w.write_str(\" {}\");\n+            } else {\n+                w.write_str(\" {\\n\");\n+                let count_variants = e.variants.len();\n+                let toggle = should_hide_fields(count_variants);\n+                if toggle {\n+                    toggle_open(w, format_args!(\"{} variants\", count_variants));\n+                }\n+                for v in &e.variants {\n+                    w.write_str(\"    \");\n+                    let name = v.name.as_ref().unwrap();\n+                    match *v.kind {\n+                        clean::VariantItem(ref var) => match var {\n+                            clean::Variant::CLike => write!(w, \"{}\", name),\n+                            clean::Variant::Tuple(ref tys) => {\n+                                write!(w, \"{}(\", name);\n+                                for (i, ty) in tys.iter().enumerate() {\n+                                    if i > 0 {\n+                                        w.write_str(\",&nbsp;\")\n+                                    }\n+                                    write!(w, \"{}\", ty.print(cx));\n                                 }\n-                                write!(w, \"{}\", ty.print(cx));\n+                                w.write_str(\")\");\n                             }\n-                            w.write_str(\")\");\n-                        }\n-                        clean::Variant::Struct(ref s) => {\n-                            render_struct(w, v, None, s.struct_type, &s.fields, \"    \", false, cx);\n-                        }\n-                    },\n-                    _ => unreachable!(),\n+                            clean::Variant::Struct(ref s) => {\n+                                render_struct(\n+                                    w,\n+                                    v,\n+                                    None,\n+                                    s.struct_type,\n+                                    &s.fields,\n+                                    \"    \",\n+                                    false,\n+                                    cx,\n+                                );\n+                            }\n+                        },\n+                        _ => unreachable!(),\n+                    }\n+                    w.write_str(\",\\n\");\n                 }\n-                w.write_str(\",\\n\");\n-            }\n \n-            if e.variants_stripped {\n-                w.write_str(\"    // some variants omitted\\n\");\n-            }\n-            if toggle {\n-                toggle_close(w);\n+                if e.variants_stripped {\n+                    w.write_str(\"    // some variants omitted\\n\");\n+                }\n+                if toggle {\n+                    toggle_close(w);\n+                }\n+                w.write_str(\"}\");\n             }\n-            w.write_str(\"}\");\n-        }\n-        w.write_str(\"</pre>\")\n+        });\n     });\n \n     document(w, cx, it, None);\n@@ -1090,27 +1106,27 @@ fn item_proc_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, m: &clean\n     let name = it.name.as_ref().expect(\"proc-macros always have names\");\n     match m.kind {\n         MacroKind::Bang => {\n-            w.push_str(\"<pre class=\\\"rust macro\\\">\");\n-            write!(w, \"{}!() {{ /* proc-macro */ }}\", name);\n-            w.push_str(\"</pre>\");\n+            wrap_item(w, \"macro\", |w| {\n+                write!(w, \"{}!() {{ /* proc-macro */ }}\", name);\n+            });\n         }\n         MacroKind::Attr => {\n-            w.push_str(\"<pre class=\\\"rust attr\\\">\");\n-            write!(w, \"#[{}]\", name);\n-            w.push_str(\"</pre>\");\n+            wrap_item(w, \"attr\", |w| {\n+                write!(w, \"#[{}]\", name);\n+            });\n         }\n         MacroKind::Derive => {\n-            w.push_str(\"<pre class=\\\"rust derive\\\">\");\n-            write!(w, \"#[derive({})]\", name);\n-            if !m.helpers.is_empty() {\n-                w.push_str(\"\\n{\\n\");\n-                w.push_str(\"    // Attributes available to this derive:\\n\");\n-                for attr in &m.helpers {\n-                    writeln!(w, \"    #[{}]\", attr);\n+            wrap_item(w, \"derive\", |w| {\n+                write!(w, \"#[derive({})]\", name);\n+                if !m.helpers.is_empty() {\n+                    w.push_str(\"\\n{\\n\");\n+                    w.push_str(\"    // Attributes available to this derive:\\n\");\n+                    for attr in &m.helpers {\n+                        writeln!(w, \"    #[{}]\", attr);\n+                    }\n+                    w.push_str(\"}\\n\");\n                 }\n-                w.push_str(\"}\\n\");\n-            }\n-            w.push_str(\"</pre>\");\n+            });\n         }\n     }\n     document(w, cx, it, None)\n@@ -1122,49 +1138,49 @@ fn item_primitive(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n }\n \n fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::Constant) {\n-    w.write_str(\"<pre class=\\\"rust const\\\">\");\n-    render_attributes_in_code(w, it);\n+    wrap_item(w, \"const\", |w| {\n+        render_attributes_in_code(w, it);\n \n-    write!(\n-        w,\n-        \"{vis}const {name}: {typ}\",\n-        vis = it.visibility.print_with_space(it.def_id, cx),\n-        name = it.name.as_ref().unwrap(),\n-        typ = c.type_.print(cx),\n-    );\n+        write!(\n+            w,\n+            \"{vis}const {name}: {typ}\",\n+            vis = it.visibility.print_with_space(it.def_id, cx),\n+            name = it.name.as_ref().unwrap(),\n+            typ = c.type_.print(cx),\n+        );\n \n-    let value = c.value(cx.tcx());\n-    let is_literal = c.is_literal(cx.tcx());\n-    let expr = c.expr(cx.tcx());\n-    if value.is_some() || is_literal {\n-        write!(w, \" = {expr};\", expr = Escape(&expr));\n-    } else {\n-        w.write_str(\";\");\n-    }\n+        let value = c.value(cx.tcx());\n+        let is_literal = c.is_literal(cx.tcx());\n+        let expr = c.expr(cx.tcx());\n+        if value.is_some() || is_literal {\n+            write!(w, \" = {expr};\", expr = Escape(&expr));\n+        } else {\n+            w.write_str(\";\");\n+        }\n \n-    if !is_literal {\n-        if let Some(value) = &value {\n-            let value_lowercase = value.to_lowercase();\n-            let expr_lowercase = expr.to_lowercase();\n+        if !is_literal {\n+            if let Some(value) = &value {\n+                let value_lowercase = value.to_lowercase();\n+                let expr_lowercase = expr.to_lowercase();\n \n-            if value_lowercase != expr_lowercase\n-                && value_lowercase.trim_end_matches(\"i32\") != expr_lowercase\n-            {\n-                write!(w, \" // {value}\", value = Escape(value));\n+                if value_lowercase != expr_lowercase\n+                    && value_lowercase.trim_end_matches(\"i32\") != expr_lowercase\n+                {\n+                    write!(w, \" // {value}\", value = Escape(value));\n+                }\n             }\n         }\n-    }\n+    });\n \n-    w.write_str(\"</pre>\");\n     document(w, cx, it, None)\n }\n \n fn item_struct(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Struct) {\n     wrap_into_docblock(w, |w| {\n-        w.write_str(\"<pre class=\\\"rust struct\\\">\");\n-        render_attributes_in_code(w, it);\n-        render_struct(w, it, Some(&s.generics), s.struct_type, &s.fields, \"\", true, cx);\n-        w.write_str(\"</pre>\")\n+        wrap_item(w, \"struct\", |w| {\n+            render_attributes_in_code(w, it);\n+            render_struct(w, it, Some(&s.generics), s.struct_type, &s.fields, \"\", true, cx);\n+        });\n     });\n \n     document(w, cx, it, None);\n@@ -1213,28 +1229,31 @@ fn item_struct(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n }\n \n fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Static) {\n-    w.write_str(\"<pre class=\\\"rust static\\\">\");\n-    render_attributes_in_code(w, it);\n-    write!(\n-        w,\n-        \"{vis}static {mutability}{name}: {typ}</pre>\",\n-        vis = it.visibility.print_with_space(it.def_id, cx),\n-        mutability = s.mutability.print_with_space(),\n-        name = it.name.as_ref().unwrap(),\n-        typ = s.type_.print(cx)\n-    );\n+    wrap_item(w, \"static\", |w| {\n+        render_attributes_in_code(w, it);\n+        write!(\n+            w,\n+            \"{vis}static {mutability}{name}: {typ}\",\n+            vis = it.visibility.print_with_space(it.def_id, cx),\n+            mutability = s.mutability.print_with_space(),\n+            name = it.name.as_ref().unwrap(),\n+            typ = s.type_.print(cx)\n+        );\n+    });\n     document(w, cx, it, None)\n }\n \n fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n-    w.write_str(\"<pre class=\\\"rust foreigntype\\\">extern {\\n\");\n-    render_attributes_in_code(w, it);\n-    write!(\n-        w,\n-        \"    {}type {};\\n}}</pre>\",\n-        it.visibility.print_with_space(it.def_id, cx),\n-        it.name.as_ref().unwrap(),\n-    );\n+    wrap_item(w, \"foreigntype\", |w| {\n+        w.write_str(\"extern {\\n\");\n+        render_attributes_in_code(w, it);\n+        write!(\n+            w,\n+            \"    {}type {};\\n}}\",\n+            it.visibility.print_with_space(it.def_id, cx),\n+            it.name.as_ref().unwrap(),\n+        );\n+    });\n \n     document(w, cx, it, None);\n \n@@ -1321,6 +1340,15 @@ where\n     w.write_str(\"</div>\")\n }\n \n+fn wrap_item<F>(w: &mut Buffer, item_name: &str, f: F)\n+where\n+    F: FnOnce(&mut Buffer),\n+{\n+    w.write_fmt(format_args!(\"<pre class=\\\"rust {}\\\"><code>\", item_name));\n+    f(w);\n+    w.write_str(\"</code></pre>\");\n+}\n+\n fn render_stability_since(\n     w: &mut Buffer,\n     item: &clean::Item,"}, {"sha": "23ca6eeaf3bb969be1af9f6ab6526bdfa12a0171", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d64f7f695943541fe12bb960971403f440d7225/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/6d64f7f695943541fe12bb960971403f440d7225/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=6d64f7f695943541fe12bb960971403f440d7225", "patch": "@@ -249,7 +249,6 @@ code, pre, a.test-arrow, .code-header {\n }\n .docblock pre code, .docblock-short pre code {\n \tpadding: 0;\n-\tpadding-right: 1ex;\n }\n pre {\n \tpadding: 14px;"}, {"sha": "f98ae59ddfe3c8b60901e7571f456ac384e9c90a", "filename": "src/test/incremental/const-generics/hash-tyvid-regression-1.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6d64f7f695943541fe12bb960971403f440d7225/src%2Ftest%2Fincremental%2Fconst-generics%2Fhash-tyvid-regression-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d64f7f695943541fe12bb960971403f440d7225/src%2Ftest%2Fincremental%2Fconst-generics%2Fhash-tyvid-regression-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fconst-generics%2Fhash-tyvid-regression-1.rs?ref=6d64f7f695943541fe12bb960971403f440d7225", "patch": "@@ -0,0 +1,15 @@\n+// revisions: cfail\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+// regression test for #77650\n+fn c<T, const N: std::num::NonZeroUsize>()\n+where\n+    [T; N.get()]: Sized,\n+{\n+    use std::convert::TryFrom;\n+    <[T; N.get()]>::try_from(())\n+    //~^ error: the trait bound\n+    //~^^ error: mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "cb8ca3abd7f9483793cec7381c14abbf54f1d1d2", "filename": "src/test/incremental/const-generics/hash-tyvid-regression-1.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6d64f7f695943541fe12bb960971403f440d7225/src%2Ftest%2Fincremental%2Fconst-generics%2Fhash-tyvid-regression-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d64f7f695943541fe12bb960971403f440d7225/src%2Ftest%2Fincremental%2Fconst-generics%2Fhash-tyvid-regression-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fconst-generics%2Fhash-tyvid-regression-1.stderr?ref=6d64f7f695943541fe12bb960971403f440d7225", "patch": "@@ -0,0 +1,35 @@\n+error[E0277]: the trait bound `[T; _]: From<()>` is not satisfied\n+  --> $DIR/hash-tyvid-regression-1.rs:9:5\n+   |\n+LL |     <[T; N.get()]>::try_from(())\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `From<()>` is not implemented for `[T; _]`\n+   |\n+   = note: required because of the requirements on the impl of `Into<[T; _]>` for `()`\n+   = note: required because of the requirements on the impl of `TryFrom<()>` for `[T; _]`\n+note: required by `try_from`\n+  --> $SRC_DIR/core/src/convert/mod.rs:LL:COL\n+   |\n+LL |     fn try_from(value: T) -> Result<Self, Self::Error>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/hash-tyvid-regression-1.rs:9:5\n+   |\n+LL |     <[T; N.get()]>::try_from(())\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found enum `Result`\n+   |\n+   = note: expected unit type `()`\n+                   found enum `Result<[T; _], Infallible>`\n+help: consider using a semicolon here\n+   |\n+LL |     <[T; N.get()]>::try_from(());\n+   |                                 +\n+help: try adding a return type\n+   |\n+LL | -> Result<[T; _], Infallible> where\n+   | +++++++++++++++++++++++++++++\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0277, E0308.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "22536ff56d7ce91b8e4ad9a4dcf4c8335a8af310", "filename": "src/test/incremental/const-generics/hash-tyvid-regression-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6d64f7f695943541fe12bb960971403f440d7225/src%2Ftest%2Fincremental%2Fconst-generics%2Fhash-tyvid-regression-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d64f7f695943541fe12bb960971403f440d7225/src%2Ftest%2Fincremental%2Fconst-generics%2Fhash-tyvid-regression-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fconst-generics%2Fhash-tyvid-regression-2.rs?ref=6d64f7f695943541fe12bb960971403f440d7225", "patch": "@@ -0,0 +1,18 @@\n+// revisions: cfail\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+// regression test for #77650\n+struct C<T, const N: core::num::NonZeroUsize>([T; N.get()])\n+where\n+    [T; N.get()]: Sized;\n+impl<'a, const N: core::num::NonZeroUsize, A, B: PartialEq<A>> PartialEq<&'a [A]> for C<B, N>\n+where\n+    [B; N.get()]: Sized,\n+{\n+    fn eq(&self, other: &&'a [A]) -> bool {\n+        self.0 == other\n+        //~^ error: can't compare\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "0e6040ef02e7ae23b943f2a9984b8c842a41da02", "filename": "src/test/incremental/const-generics/hash-tyvid-regression-2.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6d64f7f695943541fe12bb960971403f440d7225/src%2Ftest%2Fincremental%2Fconst-generics%2Fhash-tyvid-regression-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d64f7f695943541fe12bb960971403f440d7225/src%2Ftest%2Fincremental%2Fconst-generics%2Fhash-tyvid-regression-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fconst-generics%2Fhash-tyvid-regression-2.stderr?ref=6d64f7f695943541fe12bb960971403f440d7225", "patch": "@@ -0,0 +1,11 @@\n+error[E0277]: can't compare `[B; _]` with `&&[A]`\n+  --> $DIR/hash-tyvid-regression-2.rs:12:16\n+   |\n+LL |         self.0 == other\n+   |                ^^ no implementation for `[B; _] == &&[A]`\n+   |\n+   = help: the trait `PartialEq<&&[A]>` is not implemented for `[B; _]`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "76b1ae11c7d039c9bf0d2b34fcf904b993db0192", "filename": "src/test/incremental/const-generics/hash-tyvid-regression-3.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6d64f7f695943541fe12bb960971403f440d7225/src%2Ftest%2Fincremental%2Fconst-generics%2Fhash-tyvid-regression-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d64f7f695943541fe12bb960971403f440d7225/src%2Ftest%2Fincremental%2Fconst-generics%2Fhash-tyvid-regression-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fconst-generics%2Fhash-tyvid-regression-3.rs?ref=6d64f7f695943541fe12bb960971403f440d7225", "patch": "@@ -0,0 +1,26 @@\n+// revisions: cfail\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+// regression test for #79251\n+struct Node<const D: usize>\n+where\n+    SmallVec<{ D * 2 }>: ,\n+{\n+    keys: SmallVec<{ D * 2 }>,\n+}\n+\n+impl<const D: usize> Node<D>\n+where\n+    SmallVec<{ D * 2 }>: ,\n+{\n+    fn new() -> Self {\n+        let mut node = Node::new();\n+        node.keys.some_function();\n+        //~^ error: no method named\n+        node\n+    }\n+}\n+\n+struct SmallVec<const D: usize> {}\n+\n+fn main() {}"}, {"sha": "555d46756dcb926e8be475a6789009e586fcf97c", "filename": "src/test/incremental/const-generics/hash-tyvid-regression-3.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6d64f7f695943541fe12bb960971403f440d7225/src%2Ftest%2Fincremental%2Fconst-generics%2Fhash-tyvid-regression-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d64f7f695943541fe12bb960971403f440d7225/src%2Ftest%2Fincremental%2Fconst-generics%2Fhash-tyvid-regression-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fconst-generics%2Fhash-tyvid-regression-3.stderr?ref=6d64f7f695943541fe12bb960971403f440d7225", "patch": "@@ -0,0 +1,12 @@\n+error[E0599]: no method named `some_function` found for struct `SmallVec` in the current scope\n+  --> $DIR/hash-tyvid-regression-3.rs:17:19\n+   |\n+LL |         node.keys.some_function();\n+   |                   ^^^^^^^^^^^^^ method not found in `SmallVec<{ D * 2 }>`\n+...\n+LL | struct SmallVec<const D: usize> {}\n+   | ------------------------------- method `some_function` not found for this\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "35a675a2ab4d26ce7a7a3cf77147ef176d8f5444", "filename": "src/test/incremental/const-generics/hash-tyvid-regression-4.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6d64f7f695943541fe12bb960971403f440d7225/src%2Ftest%2Fincremental%2Fconst-generics%2Fhash-tyvid-regression-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d64f7f695943541fe12bb960971403f440d7225/src%2Ftest%2Fincremental%2Fconst-generics%2Fhash-tyvid-regression-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fconst-generics%2Fhash-tyvid-regression-4.rs?ref=6d64f7f695943541fe12bb960971403f440d7225", "patch": "@@ -0,0 +1,40 @@\n+// revisions: cfail\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+// regression test for #79251\n+#[derive(Debug)]\n+struct Node<K, const D: usize>\n+where\n+    SmallVec<K, { D * 2 }>: ,\n+{\n+    keys: SmallVec<K, { D * 2 }>,\n+}\n+\n+impl<K, const D: usize> Node<K, D>\n+where\n+    SmallVec<K, { D * 2 }>: ,\n+{\n+    fn new() -> Self {\n+        panic!()\n+    }\n+\n+    #[inline(never)]\n+    fn split(&mut self, i: usize, k: K, right: bool) -> Node<K, D> {\n+        let mut node = Node::new();\n+        node.keys.push(k);\n+        //~^ error: no method named\n+        node\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct SmallVec<T, const D: usize> {\n+    data: [T; D],\n+}\n+impl<T, const D: usize> SmallVec<T, D> {\n+    fn new() -> Self {\n+        panic!()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "c9a6715e571c9f76b88af4a82b84678691757c78", "filename": "src/test/incremental/const-generics/hash-tyvid-regression-4.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6d64f7f695943541fe12bb960971403f440d7225/src%2Ftest%2Fincremental%2Fconst-generics%2Fhash-tyvid-regression-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d64f7f695943541fe12bb960971403f440d7225/src%2Ftest%2Fincremental%2Fconst-generics%2Fhash-tyvid-regression-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fconst-generics%2Fhash-tyvid-regression-4.stderr?ref=6d64f7f695943541fe12bb960971403f440d7225", "patch": "@@ -0,0 +1,12 @@\n+error[E0599]: no method named `push` found for struct `SmallVec` in the current scope\n+  --> $DIR/hash-tyvid-regression-4.rs:23:19\n+   |\n+LL |         node.keys.push(k);\n+   |                   ^^^^ method not found in `SmallVec<_, { D * 2 }>`\n+...\n+LL | struct SmallVec<T, const D: usize> {\n+   | ---------------------------------- method `push` not found for this\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "200569a28d4a43e2ad466cb0399104d134cf9e76", "filename": "src/test/rustdoc-gui/code-tags.goml", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6d64f7f695943541fe12bb960971403f440d7225/src%2Ftest%2Frustdoc-gui%2Fcode-tags.goml", "raw_url": "https://github.com/rust-lang/rust/raw/6d64f7f695943541fe12bb960971403f440d7225/src%2Ftest%2Frustdoc-gui%2Fcode-tags.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fcode-tags.goml?ref=6d64f7f695943541fe12bb960971403f440d7225", "patch": "@@ -0,0 +1,20 @@\n+// This test ensures that items and documentation code blocks are wrapped in <pre><code>\n+goto: file://|DOC_PATH|/test_docs/fn.foo.html\n+size: (1080, 600)\n+// There should be three doc codeblocks\n+// Check that their content is inside <pre><code>\n+assert-count: (\".example-wrap pre > code\", 3)\n+// Check that function signature is inside <pre><code>\n+assert: \"pre.rust.fn > code\"\n+\n+goto: file://|DOC_PATH|/test_docs/struct.Foo.html\n+assert: \"pre.rust.struct > code\"\n+\n+goto: file://|DOC_PATH|/test_docs/enum.AnEnum.html\n+assert: \"pre.rust.enum > code\"\n+\n+goto: file://|DOC_PATH|/test_docs/trait.AnotherOne.html\n+assert: \"pre.rust.trait > code\"\n+\n+goto: file://|DOC_PATH|/test_docs/type.SomeType.html\n+assert: \"pre.rust.typedef > code\""}, {"sha": "5a49807e180b27d06fe1b15b157fb8dd14cff7b9", "filename": "src/test/rustdoc-gui/source-code-page.goml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d64f7f695943541fe12bb960971403f440d7225/src%2Ftest%2Frustdoc-gui%2Fsource-code-page.goml", "raw_url": "https://github.com/rust-lang/rust/raw/6d64f7f695943541fe12bb960971403f440d7225/src%2Ftest%2Frustdoc-gui%2Fsource-code-page.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsource-code-page.goml?ref=6d64f7f695943541fe12bb960971403f440d7225", "patch": "@@ -12,4 +12,4 @@ assert-attribute: (\".line-numbers > span:nth-child(5)\", {\"class\": \"line-highligh\n assert-attribute: (\".line-numbers > span:nth-child(6)\", {\"class\": \"line-highlighted\"})\n assert-attribute-false: (\".line-numbers > span:nth-child(7)\", {\"class\": \"line-highlighted\"})\n // This is to ensure that the content is correctly align with the line numbers.\n-compare-elements-position: (\"//*[@id='1']\", \".rust > span\", (\"y\"))\n+compare-elements-position: (\"//*[@id='1']\", \".rust > code > span\", (\"y\"))"}, {"sha": "ad5e4918ccac5b222aefcb8e3c4019ecdc61bc72", "filename": "src/test/ui/type-alias-impl-trait/unused_generic_param.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6d64f7f695943541fe12bb960971403f440d7225/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Funused_generic_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d64f7f695943541fe12bb960971403f440d7225/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Funused_generic_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Funused_generic_param.rs?ref=6d64f7f695943541fe12bb960971403f440d7225", "patch": "@@ -1,16 +1,17 @@\n+// check-pass\n+\n #![feature(type_alias_impl_trait)]\n+#![allow(dead_code)]\n \n fn main() {}\n \n-type PartiallyDefined<T> = impl 'static;\n-//~^ ERROR: at least one trait must be specified\n+type PartiallyDefined<T> = impl Sized;\n \n fn partially_defined<T: std::fmt::Debug>(_: T) -> PartiallyDefined<T> {\n     4u32\n }\n \n-type PartiallyDefined2<T> = impl 'static;\n-//~^ ERROR: at least one trait must be specified\n+type PartiallyDefined2<T> = impl Sized;\n \n fn partially_defined2<T: std::fmt::Debug>(_: T) -> PartiallyDefined2<T> {\n     4u32"}, {"sha": "4e11854b071894de30927861c2b9c5a19747b802", "filename": "src/test/ui/type-alias-impl-trait/unused_generic_param.stderr", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7960030d6915a771f5ab72c3897a7ed50c3ed4bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Funused_generic_param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7960030d6915a771f5ab72c3897a7ed50c3ed4bd/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Funused_generic_param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Funused_generic_param.stderr?ref=7960030d6915a771f5ab72c3897a7ed50c3ed4bd", "patch": "@@ -1,14 +0,0 @@\n-error: at least one trait must be specified\n-  --> $DIR/unused_generic_param.rs:5:28\n-   |\n-LL | type PartiallyDefined<T> = impl 'static;\n-   |                            ^^^^^^^^^^^^\n-\n-error: at least one trait must be specified\n-  --> $DIR/unused_generic_param.rs:12:29\n-   |\n-LL | type PartiallyDefined2<T> = impl 'static;\n-   |                             ^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n-"}]}