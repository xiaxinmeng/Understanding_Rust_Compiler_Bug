{"sha": "eaf9e05611e966344c250353b8e220469885c93c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhZjllMDU2MTFlOTY2MzQ0YzI1MDM1M2I4ZTIyMDQ2OTg4NWM5M2M=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-02T10:42:31Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-02T11:20:11Z"}, "message": "Make 'lambda(...) -> ...' parse as a type", "tree": {"sha": "3a96d6b0a33fa79aab0ecf199e9895f3ba393215", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a96d6b0a33fa79aab0ecf199e9895f3ba393215"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eaf9e05611e966344c250353b8e220469885c93c", "comment_count": 3, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eaf9e05611e966344c250353b8e220469885c93c", "html_url": "https://github.com/rust-lang/rust/commit/eaf9e05611e966344c250353b8e220469885c93c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eaf9e05611e966344c250353b8e220469885c93c/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e9b8a28f7c9e85080dd57715e8583c23a3ef802", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e9b8a28f7c9e85080dd57715e8583c23a3ef802", "html_url": "https://github.com/rust-lang/rust/commit/4e9b8a28f7c9e85080dd57715e8583c23a3ef802"}], "stats": {"total": 36, "additions": 10, "deletions": 26}, "files": [{"sha": "b0e5dd793ab565609a3b63fe2a24d23885549697", "filename": "doc/tutorial/func.md", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eaf9e05611e966344c250353b8e220469885c93c/doc%2Ftutorial%2Ffunc.md", "raw_url": "https://github.com/rust-lang/rust/raw/eaf9e05611e966344c250353b8e220469885c93c/doc%2Ftutorial%2Ffunc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Ffunc.md?ref=eaf9e05611e966344c250353b8e220469885c93c", "patch": "@@ -25,13 +25,10 @@ expected to return.\n \n ## Closures\n \n-FIXME Either move entirely to fn~/fn@ nomenclature, or fix compiler to\n-accept lambda as a type\n-\n Normal Rust functions (declared with `fn`) do not close over their\n environment. A `lambda` expression can be used to create a closure.\n \n-    fn make_plus_function(x: int) -> fn@(int) -> int {\n+    fn make_plus_function(x: int) -> lambda(int) -> int {\n         lambda(y: int) -> int { x + y }\n     }\n     let plus_two = make_plus_function(2);"}, {"sha": "b22afb9efdb66cc4a367a908f7b3018428312e98", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/eaf9e05611e966344c250353b8e220469885c93c/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf9e05611e966344c250353b8e220469885c93c/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=eaf9e05611e966344c250353b8e220469885c93c", "patch": "@@ -299,7 +299,7 @@ fn parse_ty_fn(proto: ast::proto, p: parser) -> ast::ty_ {\n     ret ast::ty_fn(proto, inputs.node, ret_ty, ret_style, constrs);\n }\n \n-fn parse_ty_obj(p: parser, &hi: uint) -> ast::ty_ {\n+fn parse_ty_obj(p: parser) -> ast::ty_ {\n     fn parse_method_sig(p: parser) -> ast::ty_method {\n         let flo = p.get_lo_pos();\n         let proto: ast::proto = parse_method_proto(p);\n@@ -320,7 +320,6 @@ fn parse_ty_obj(p: parser, &hi: uint) -> ast::ty_ {\n     }\n     let meths =\n         parse_seq(token::LBRACE, token::RBRACE, none, parse_method_sig, p);\n-    hi = meths.span.hi;\n     ret ast::ty_obj(meths.node);\n }\n \n@@ -475,7 +474,6 @@ fn parse_ret_ty(p: parser, n_args: uint) -> (ast::ret_style, @ast::ty) {\n \n fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n     let lo = p.get_lo_pos();\n-    let hi = lo;\n     let t: ast::ty_;\n     // FIXME: do something with this\n \n@@ -518,7 +516,6 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n     } else if p.peek() == token::LPAREN {\n         p.bump();\n         if p.peek() == token::RPAREN {\n-            hi = p.get_hi_pos();\n             p.bump();\n             t = ast::ty_nil;\n         } else {\n@@ -530,54 +527,44 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n             if vec::len(ts) == 1u {\n                 t = ts[0].node;\n             } else { t = ast::ty_tup(ts); }\n-            hi = p.get_hi_pos();\n             expect(p, token::RPAREN);\n         }\n     } else if p.peek() == token::AT {\n         p.bump();\n-        let mt = parse_mt(p);\n-        hi = mt.ty.span.hi;\n-        t = ast::ty_box(mt);\n+        t = ast::ty_box(parse_mt(p));\n     } else if p.peek() == token::TILDE {\n         p.bump();\n-        let mt = parse_mt(p);\n-        hi = mt.ty.span.hi;\n-        t = ast::ty_uniq(mt);\n+        t = ast::ty_uniq(parse_mt(p));\n     } else if p.peek() == token::BINOP(token::STAR) {\n         p.bump();\n-        let mt = parse_mt(p);\n-        hi = mt.ty.span.hi;\n-        t = ast::ty_ptr(mt);\n+        t = ast::ty_ptr(parse_mt(p));\n     } else if p.peek() == token::LBRACE {\n         let elems =\n             parse_seq(token::LBRACE, token::RBRACE, some(token::COMMA),\n                       parse_ty_field, p);\n-        hi = elems.span.hi;\n+        let hi = elems.span.hi;\n         t = ast::ty_rec(elems.node);\n         if p.peek() == token::COLON {\n             p.bump();\n-            t =\n-                ast::ty_constr(@spanned(lo, hi, t),\n+            t = ast::ty_constr(@spanned(lo, hi, t),\n                                parse_type_constraints(p));\n         }\n     } else if p.peek() == token::LBRACKET {\n         expect(p, token::LBRACKET);\n         t = ast::ty_vec(parse_mt(p));\n-        hi = p.get_hi_pos();\n         expect(p, token::RBRACKET);\n     } else if eat_word(p, \"fn\") {\n         let proto = parse_fn_ty_proto(p);\n         t = parse_ty_fn(proto, p);\n-        alt t { ast::ty_fn(_, _, out, _, _) { hi = out.span.hi; } }\n     } else if eat_word(p, \"block\") {\n         t = parse_ty_fn(ast::proto_block, p);\n-        alt t { ast::ty_fn(_, _, out, _, _) { hi = out.span.hi; } }\n+    } else if eat_word(p, \"lambda\") {\n+        t = parse_ty_fn(ast::proto_shared(ast::sugar_sexy), p);\n     } else if eat_word(p, \"obj\") {\n-        t = parse_ty_obj(p, hi);\n+        t = parse_ty_obj(p);\n     } else if p.peek() == token::MOD_SEP || is_ident(p.peek()) {\n         let path = parse_path(p);\n         t = ast::ty_path(path, p.get_id());\n-        hi = path.span.hi;\n     } else { p.fatal(\"expecting type\"); }\n     ret parse_ty_postfix(t, p, colons_before_params);\n }"}]}