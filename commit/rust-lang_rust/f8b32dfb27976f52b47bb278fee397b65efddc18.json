{"sha": "f8b32dfb27976f52b47bb278fee397b65efddc18", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4YjMyZGZiMjc5NzZmNTJiNDdiYjI3OGZlZTM5N2I2NWVmZGRjMTg=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-19T15:21:28Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-06T04:43:58Z"}, "message": "Remove ExprKind::While from HIR.", "tree": {"sha": "7a816eeb3b3e45500b5f566fcea6107f737b50ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a816eeb3b3e45500b5f566fcea6107f737b50ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8b32dfb27976f52b47bb278fee397b65efddc18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8b32dfb27976f52b47bb278fee397b65efddc18", "html_url": "https://github.com/rust-lang/rust/commit/f8b32dfb27976f52b47bb278fee397b65efddc18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8b32dfb27976f52b47bb278fee397b65efddc18/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "481068a707679257e2a738b40987246e0420e787", "url": "https://api.github.com/repos/rust-lang/rust/commits/481068a707679257e2a738b40987246e0420e787", "html_url": "https://github.com/rust-lang/rust/commit/481068a707679257e2a738b40987246e0420e787"}], "stats": {"total": 386, "additions": 114, "deletions": 272}, "files": [{"sha": "f81d18694136e5871e40706c5e3b11068f3d0569", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=f8b32dfb27976f52b47bb278fee397b65efddc18", "patch": "@@ -165,48 +165,6 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_ast_node(expr.hir_id.local_id, &[blk_exit])\n             }\n \n-            hir::ExprKind::While(ref cond, ref body, _) => {\n-                //\n-                //         [pred]\n-                //           |\n-                //           v 1\n-                //       [loopback] <--+ 5\n-                //           |         |\n-                //           v 2       |\n-                //   +-----[cond]      |\n-                //   |       |         |\n-                //   |       v 4       |\n-                //   |     [body] -----+\n-                //   v 3\n-                // [expr]\n-                //\n-                // Note that `break` and `continue` statements\n-                // may cause additional edges.\n-\n-                let loopback = self.add_dummy_node(&[pred]);              // 1\n-\n-                // Create expr_exit without pred (cond_exit)\n-                let expr_exit = self.add_ast_node(expr.hir_id.local_id, &[]);         // 3\n-\n-                // The LoopScope needs to be on the loop_scopes stack while evaluating the\n-                // condition and the body of the loop (both can break out of the loop)\n-                self.loop_scopes.push(LoopScope {\n-                    loop_id: expr.hir_id.local_id,\n-                    continue_index: loopback,\n-                    break_index: expr_exit\n-                });\n-\n-                let cond_exit = self.expr(&cond, loopback);             // 2\n-\n-                // Add pred (cond_exit) to expr_exit\n-                self.add_contained_edge(cond_exit, expr_exit);\n-\n-                let body_exit = self.block(&body, cond_exit);          // 4\n-                self.add_contained_edge(body_exit, loopback);            // 5\n-                self.loop_scopes.pop();\n-                expr_exit\n-            }\n-\n             hir::ExprKind::Loop(ref body, _, _) => {\n                 //\n                 //     [pred]"}, {"sha": "2d82314f86ac233887006f1b686eb2011b28ec65", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=f8b32dfb27976f52b47bb278fee397b65efddc18", "patch": "@@ -1026,11 +1026,6 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprKind::DropTemps(ref subexpression) => {\n             visitor.visit_expr(subexpression);\n         }\n-        ExprKind::While(ref subexpression, ref block, ref opt_label) => {\n-            walk_list!(visitor, visit_label, opt_label);\n-            visitor.visit_expr(subexpression);\n-            visitor.visit_block(block);\n-        }\n         ExprKind::Loop(ref block, ref opt_label, _) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);"}, {"sha": "011808a7ff96c24664a7e99273ab942a160dae87", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 43, "deletions": 7, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=f8b32dfb27976f52b47bb278fee397b65efddc18", "patch": "@@ -4461,11 +4461,11 @@ impl<'a> LoweringContext<'a> {\n                     };\n \n                     // `match <sub_expr> { ... }`\n-                    let arms = hir_vec![pat_arm, break_arm];\n-                    let match_expr = self.expr(\n+                    let match_expr = self.expr_match(\n                         sub_expr.span,\n-                        hir::ExprKind::Match(sub_expr, arms, hir::MatchSource::WhileLetDesugar),\n-                        ThinVec::new(),\n+                        sub_expr,\n+                        hir_vec![pat_arm, break_arm],\n+                        hir::MatchSource::WhileLetDesugar,\n                     );\n \n                     // `[opt_ident]: loop { ... }`\n@@ -4479,10 +4479,46 @@ impl<'a> LoweringContext<'a> {\n                     loop_expr\n                 } else {\n                     self.with_loop_scope(e.id, |this| {\n-                        hir::ExprKind::While(\n-                            this.with_loop_condition_scope(|this| P(this.lower_expr(cond))),\n-                            this.lower_block(body, false),\n+                        // We desugar: `'label: while $cond $body` into:\n+                        //\n+                        // ```\n+                        // 'label: loop {\n+                        //     match DropTemps($cond) {\n+                        //         true => $block,\n+                        //         _ => break,\n+                        //     }\n+                        // }\n+                        // ```\n+\n+                        // `true => then`:\n+                        let then_pat = this.pat_bool(e.span, true);\n+                        let then_blk = this.lower_block(body, false);\n+                        let then_expr = this.expr_block(then_blk, ThinVec::new());\n+                        let then_arm = this.arm(hir_vec![then_pat], P(then_expr));\n+\n+                        // `_ => break`:\n+                        let else_pat = this.pat_wild(e.span);\n+                        let else_expr = this.expr_break(e.span, ThinVec::new());\n+                        let else_arm = this.arm(hir_vec![else_pat], else_expr);\n+\n+                        // Lower condition:\n+                        let cond = this.with_loop_condition_scope(|this| this.lower_expr(cond));\n+                        // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n+                        // to preserve drop semantics since `if cond { ... }` does not\n+                        // let temporaries live outside of `cond`.\n+                        let cond = this.expr_drop_temps(cond.span, P(cond), ThinVec::new());\n+\n+                        let match_expr = this.expr_match(\n+                            cond.span,\n+                            P(cond),\n+                            vec![then_arm, else_arm].into(),\n+                            hir::MatchSource::WhileDesugar,\n+                        );\n+\n+                        hir::ExprKind::Loop(\n+                            P(this.block_expr(P(match_expr))),\n                             this.lower_label(opt_label),\n+                            hir::LoopSource::While,\n                         )\n                     })\n                 }"}, {"sha": "63f60d0ab9528a564f210b70f39cb0b1bc65c60d", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=f8b32dfb27976f52b47bb278fee397b65efddc18", "patch": "@@ -731,7 +731,7 @@ impl<'hir> Map<'hir> {\n             match *node {\n                 Node::Expr(ref expr) => {\n                     match expr.node {\n-                        ExprKind::While(..) | ExprKind::Loop(..) | ExprKind::Ret(..) => true,\n+                        ExprKind::Loop(..) | ExprKind::Ret(..) => true,\n                         _ => false,\n                     }\n                 }"}, {"sha": "7b760a872387e9c3999a1de7c8cc0dc15d14203f", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=f8b32dfb27976f52b47bb278fee397b65efddc18", "patch": "@@ -1405,7 +1405,6 @@ impl Expr {\n             ExprKind::Lit(_) => ExprPrecedence::Lit,\n             ExprKind::Type(..) | ExprKind::Cast(..) => ExprPrecedence::Cast,\n             ExprKind::DropTemps(ref expr, ..) => expr.precedence(),\n-            ExprKind::While(..) => ExprPrecedence::While,\n             ExprKind::Loop(..) => ExprPrecedence::Loop,\n             ExprKind::Match(..) => ExprPrecedence::Match,\n             ExprKind::Closure(..) => ExprPrecedence::Closure,\n@@ -1464,7 +1463,6 @@ impl Expr {\n             ExprKind::Break(..) |\n             ExprKind::Continue(..) |\n             ExprKind::Ret(..) |\n-            ExprKind::While(..) |\n             ExprKind::Loop(..) |\n             ExprKind::Assign(..) |\n             ExprKind::InlineAsm(..) |\n@@ -1532,10 +1530,6 @@ pub enum ExprKind {\n     /// This construct only exists to tweak the drop order in HIR lowering.\n     /// An example of that is the desugaring of `for` loops.\n     DropTemps(P<Expr>),\n-    /// A while loop, with an optional label\n-    ///\n-    /// I.e., `'label: while expr { <block> }`.\n-    While(P<Expr>, P<Block>, Option<Label>),\n     /// A conditionless loop (can be exited with `break`, `continue`, or `return`).\n     ///\n     /// I.e., `'label: loop { <block> }`.\n@@ -1653,6 +1647,8 @@ pub enum MatchSource {\n     IfLetDesugar {\n         contains_else_clause: bool,\n     },\n+    /// A `while _ { .. }` (which was desugared to a `loop { match _ { .. } }`).\n+    WhileDesugar,\n     /// A `while let _ = _ { .. }` (which was desugared to a\n     /// `loop { match _ { .. } }`).\n     WhileLetDesugar,\n@@ -1669,12 +1665,25 @@ pub enum MatchSource {\n pub enum LoopSource {\n     /// A `loop { .. }` loop.\n     Loop,\n+    /// A `while _ { .. }` loop.\n+    While,\n     /// A `while let _ = _ { .. }` loop.\n     WhileLet,\n     /// A `for _ in _ { .. }` loop.\n     ForLoop,\n }\n \n+impl LoopSource {\n+    pub fn name(self) -> &'static str {\n+        match self {\n+            LoopSource::Loop => \"loop\",\n+            LoopSource::While => \"while\",\n+            LoopSource::WhileLet => \"while let\",\n+            LoopSource::ForLoop => \"for\",\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum LoopIdError {\n     OutsideLoopScope,"}, {"sha": "367e4dba042cd7998de1cb79980660b6c94a11be", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=f8b32dfb27976f52b47bb278fee397b65efddc18", "patch": "@@ -1299,16 +1299,6 @@ impl<'a> State<'a> {\n                 // Print `}`:\n                 self.bclose_maybe_open(expr.span, indent_unit, true);\n             }\n-            hir::ExprKind::While(ref test, ref blk, opt_label) => {\n-                if let Some(label) = opt_label {\n-                    self.print_ident(label.ident);\n-                    self.word_space(\":\");\n-                }\n-                self.head(\"while\");\n-                self.print_expr_as_cond(&test);\n-                self.s.space();\n-                self.print_block(&blk);\n-            }\n             hir::ExprKind::Loop(ref blk, opt_label, _) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n@@ -2289,7 +2279,6 @@ fn expr_requires_semi_to_be_stmt(e: &hir::Expr) -> bool {\n     match e.node {\n         hir::ExprKind::Match(..) |\n         hir::ExprKind::Block(..) |\n-        hir::ExprKind::While(..) |\n         hir::ExprKind::Loop(..) => false,\n         _ => true,\n     }"}, {"sha": "2448db032b9654c39348188af6db5593e87a4c4e", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=f8b32dfb27976f52b47bb278fee397b65efddc18", "patch": "@@ -487,11 +487,6 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 self.walk_block(&blk);\n             }\n \n-            hir::ExprKind::While(ref cond_expr, ref blk, _) => {\n-                self.consume_expr(&cond_expr);\n-                self.walk_block(&blk);\n-            }\n-\n             hir::ExprKind::Unary(_, ref lhs) => {\n                 self.consume_expr(&lhs);\n             }"}, {"sha": "3885d1b6f82bbd11c26a948f86963718547ccc25", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 13, "deletions": 50, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=f8b32dfb27976f52b47bb278fee397b65efddc18", "patch": "@@ -93,7 +93,6 @@\n //!   It is the responsibility of typeck to ensure that there are no\n //!   `return` expressions in a function declared as diverging.\n \n-use self::LoopKind::*;\n use self::LiveNodeKind::*;\n use self::VarKind::*;\n \n@@ -120,14 +119,6 @@ use crate::hir::{Expr, HirId};\n use crate::hir::def_id::DefId;\n use crate::hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n \n-/// For use with `propagate_through_loop`.\n-enum LoopKind<'a> {\n-    /// An endless `loop` loop.\n-    LoopLoop,\n-    /// A `while` loop, with the given expression as condition.\n-    WhileLoop(&'a Expr),\n-}\n-\n #[derive(Copy, Clone, PartialEq)]\n struct Variable(u32);\n \n@@ -517,7 +508,6 @@ fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr) {\n \n       // live nodes required for interesting control flow:\n       hir::ExprKind::Match(..) |\n-      hir::ExprKind::While(..) |\n       hir::ExprKind::Loop(..) => {\n         ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n         intravisit::walk_expr(ir, expr);\n@@ -1055,14 +1045,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 })\n             }\n \n-            hir::ExprKind::While(ref cond, ref blk, _) => {\n-                self.propagate_through_loop(expr, WhileLoop(&cond), &blk, succ)\n-            }\n-\n             // Note that labels have been resolved, so we don't need to look\n             // at the label ident\n             hir::ExprKind::Loop(ref blk, _, _) => {\n-                self.propagate_through_loop(expr, LoopLoop, &blk, succ)\n+                self.propagate_through_loop(expr, &blk, succ)\n             }\n \n             hir::ExprKind::Match(ref e, ref arms, _) => {\n@@ -1353,13 +1339,14 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn propagate_through_loop(&mut self,\n-                              expr: &Expr,\n-                              kind: LoopKind<'_>,\n-                              body: &hir::Block,\n-                              succ: LiveNode)\n-                              -> LiveNode {\n+    fn propagate_through_loop(\n+        &mut self,\n+        expr: &Expr,\n+        body: &hir::Block,\n+        succ: LiveNode\n+    ) -> LiveNode {\n         /*\n+        FIXME: clean up this description.\n \n         We model control flow like this:\n \n@@ -1377,50 +1364,26 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         */\n \n-\n         // first iteration:\n         let mut first_merge = true;\n         let ln = self.live_node(expr.hir_id, expr.span);\n         self.init_empty(ln, succ);\n-        match kind {\n-            LoopLoop => {}\n-            _ => {\n-                // If this is not a `loop` loop, then it's possible we bypass\n-                // the body altogether. Otherwise, the only way is via a `break`\n-                // in the loop body.\n-                self.merge_from_succ(ln, succ, first_merge);\n-                first_merge = false;\n-            }\n-        }\n         debug!(\"propagate_through_loop: using id for loop body {} {}\",\n                expr.hir_id, self.ir.tcx.hir().hir_to_pretty_string(body.hir_id));\n \n         self.break_ln.insert(expr.hir_id, succ);\n \n-        let cond_ln = match kind {\n-            LoopLoop => ln,\n-            WhileLoop(ref cond) => self.propagate_through_expr(&cond, ln),\n-        };\n-\n-        self.cont_ln.insert(expr.hir_id, cond_ln);\n+        self.cont_ln.insert(expr.hir_id, ln);\n \n-        let body_ln = self.propagate_through_block(body, cond_ln);\n+        let body_ln = self.propagate_through_block(body, ln);\n \n         // repeat until fixed point is reached:\n         while self.merge_from_succ(ln, body_ln, first_merge) {\n             first_merge = false;\n-\n-            let new_cond_ln = match kind {\n-                LoopLoop => ln,\n-                WhileLoop(ref cond) => {\n-                    self.propagate_through_expr(&cond, ln)\n-                }\n-            };\n-            assert_eq!(cond_ln, new_cond_ln);\n-            assert_eq!(body_ln, self.propagate_through_block(body, cond_ln));\n+            assert_eq!(body_ln, self.propagate_through_block(body, ln));\n         }\n \n-        cond_ln\n+        ln\n     }\n }\n \n@@ -1520,7 +1483,7 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n \n         // no correctness conditions related to liveness\n         hir::ExprKind::Call(..) | hir::ExprKind::MethodCall(..) |\n-        hir::ExprKind::Match(..) | hir::ExprKind::While(..) | hir::ExprKind::Loop(..) |\n+        hir::ExprKind::Match(..) | hir::ExprKind::Loop(..) |\n         hir::ExprKind::Index(..) | hir::ExprKind::Field(..) |\n         hir::ExprKind::Array(..) | hir::ExprKind::Tup(..) | hir::ExprKind::Binary(..) |\n         hir::ExprKind::Cast(..) | hir::ExprKind::DropTemps(..) | hir::ExprKind::Unary(..) |"}, {"sha": "66d8a2cc1115d1d1ec9b6f7529a724c9b495e0e4", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=f8b32dfb27976f52b47bb278fee397b65efddc18", "patch": "@@ -696,7 +696,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             hir::ExprKind::Unary(..) | hir::ExprKind::Yield(..) |\n             hir::ExprKind::MethodCall(..) | hir::ExprKind::Cast(..) | hir::ExprKind::DropTemps(..) |\n             hir::ExprKind::Array(..) | hir::ExprKind::Tup(..) |\n-            hir::ExprKind::Binary(..) | hir::ExprKind::While(..) |\n+            hir::ExprKind::Binary(..) |\n             hir::ExprKind::Block(..) | hir::ExprKind::Loop(..) | hir::ExprKind::Match(..) |\n             hir::ExprKind::Lit(..) | hir::ExprKind::Break(..) |\n             hir::ExprKind::Continue(..) | hir::ExprKind::Struct(..) | hir::ExprKind::Repeat(..) |"}, {"sha": "88c19715811d79661a84b45899e6090104f2fd0b", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=f8b32dfb27976f52b47bb278fee397b65efddc18", "patch": "@@ -915,11 +915,6 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n                 terminating(body.hir_id.local_id);\n             }\n \n-            hir::ExprKind::While(ref expr, ref body, _) => {\n-                terminating(expr.hir_id.local_id);\n-                terminating(body.hir_id.local_id);\n-            }\n-\n             hir::ExprKind::DropTemps(ref expr) => {\n                 // `DropTemps(expr)` does not denote a conditional scope.\n                 // Rather, we want to achieve the same behavior as `{ let _t = expr; _t }`."}, {"sha": "3221b41ee1d4430ee8507f2b9d64d61cb0cf1166", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=f8b32dfb27976f52b47bb278fee397b65efddc18", "patch": "@@ -1201,11 +1201,10 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n     }\n \n     fn expression_label(ex: &hir::Expr) -> Option<ast::Ident> {\n-        match ex.node {\n-            hir::ExprKind::While(.., Some(label)) | hir::ExprKind::Loop(_, Some(label), _) => {\n-                Some(label.ident)\n-            }\n-            _ => None,\n+        if let hir::ExprKind::Loop(_, Some(label), _) = ex.node {\n+            Some(label.ident)\n+        } else {\n+            None\n         }\n     }\n "}, {"sha": "d98dfb5478a366eefad92ffb70e6b97593d73e69", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=f8b32dfb27976f52b47bb278fee397b65efddc18", "patch": "@@ -64,9 +64,25 @@ declare_lint! {\n \n declare_lint_pass!(WhileTrue => [WHILE_TRUE]);\n \n+fn as_while_cond(expr: &hir::Expr) -> Option<&hir::Expr> {\n+    if let hir::ExprKind::Loop(blk, ..) = &expr.node {\n+        if let Some(match_expr) = &blk.expr {\n+            if let hir::ExprKind::Match(cond, .., hir::MatchSource::WhileDesugar)\n+                = &match_expr.node\n+            {\n+                if let hir::ExprKind::DropTemps(cond) = &cond.node {\n+                    return Some(cond);\n+                }\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for WhileTrue {\n     fn check_expr(&mut self, cx: &LateContext<'_, '_>, e: &hir::Expr) {\n-        if let hir::ExprKind::While(ref cond, ..) = e.node {\n+        if let Some(ref cond) = as_while_cond(e) {\n             if let hir::ExprKind::Lit(ref lit) = cond.node {\n                 if let ast::LitKind::Bool(true) = lit.node {\n                     if lit.span.ctxt() == SyntaxContext::empty() {"}, {"sha": "e433da904a67877bd22a318ae5094ec104b21f68", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 11, "deletions": 40, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=f8b32dfb27976f52b47bb278fee397b65efddc18", "patch": "@@ -138,19 +138,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 join_block.unit()\n             }\n-            ExprKind::Loop {\n-                condition: opt_cond_expr,\n-                body,\n-            } => {\n-                // [block] --> [loop_block] -/eval. cond./-> [loop_block_end] -1-> [exit_block]\n-                //                  ^                               |\n-                //                  |                               0\n-                //                  |                               |\n-                //                  |                               v\n-                //           [body_block_end] <-/eval. body/-- [body_block]\n-                //\n-                // If `opt_cond_expr` is `None`, then the graph is somewhat simplified:\n-                //\n+            ExprKind::Loop { body } => {\n                 // [block]\n                 //    |\n                 //   [loop_block] -> [body_block] -/eval. body/-> [body_block_end]\n@@ -177,33 +165,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     destination.clone(),\n                     move |this| {\n                         // conduct the test, if necessary\n-                        let body_block;\n-                        if let Some(cond_expr) = opt_cond_expr {\n-                            let cond_expr = this.hir.mirror(cond_expr);\n-                            let (true_block, false_block)\n-                                = this.test_bool(loop_block, cond_expr, source_info);\n-                            body_block = true_block;\n-\n-                            // if the test is false, there's no `break` to assign `destination`, so\n-                            // we have to do it\n-                            this.cfg.push_assign_unit(false_block, source_info, destination);\n-                            this.cfg.terminate(\n-                                false_block,\n-                                source_info,\n-                                TerminatorKind::Goto { target: exit_block },\n-                            );\n-                        } else {\n-                            body_block = this.cfg.start_new_block();\n-                            let diverge_cleanup = this.diverge_cleanup();\n-                            this.cfg.terminate(\n-                                loop_block,\n-                                source_info,\n-                                TerminatorKind::FalseUnwind {\n-                                    real_target: body_block,\n-                                    unwind: Some(diverge_cleanup),\n-                                },\n-                            )\n-                        }\n+                        let body_block = this.cfg.start_new_block();\n+                        let diverge_cleanup = this.diverge_cleanup();\n+                        this.cfg.terminate(\n+                            loop_block,\n+                            source_info,\n+                            TerminatorKind::FalseUnwind {\n+                                real_target: body_block,\n+                                unwind: Some(diverge_cleanup),\n+                            },\n+                        );\n \n                         // The \u201creturn\u201d value of the loop body must always be an unit. We therefore\n                         // introduce a unit temporary as the destination for the loop body."}, {"sha": "242afcf5abb2e410f417562b95b00f6ee6381e67", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=f8b32dfb27976f52b47bb278fee397b65efddc18", "patch": "@@ -599,15 +599,8 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                 arms: arms.iter().map(|a| convert_arm(cx, a)).collect(),\n             }\n         }\n-        hir::ExprKind::While(ref cond, ref body, _) => {\n-            ExprKind::Loop {\n-                condition: Some(cond.to_ref()),\n-                body: block::to_expr_ref(cx, body),\n-            }\n-        }\n         hir::ExprKind::Loop(ref body, _, _) => {\n             ExprKind::Loop {\n-                condition: None,\n                 body: block::to_expr_ref(cx, body),\n             }\n         }"}, {"sha": "0638cb462f73b32cc7282aff27b914402b9a8c87", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=f8b32dfb27976f52b47bb278fee397b65efddc18", "patch": "@@ -173,7 +173,6 @@ pub enum ExprKind<'tcx> {\n         source: ExprRef<'tcx>,\n     },\n     Loop {\n-        condition: Option<ExprRef<'tcx>>,\n         body: ExprRef<'tcx>,\n     },\n     Match {"}, {"sha": "d822a26ce591b094b0ca95bc11d255d9153ddffb", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=f8b32dfb27976f52b47bb278fee397b65efddc18", "patch": "@@ -371,7 +371,8 @@ fn check_arms<'a, 'tcx>(\n             match is_useful(cx, &seen, &v, LeaveOutWitness) {\n                 NotUseful => {\n                     match source {\n-                        hir::MatchSource::IfDesugar { .. } => bug!(),\n+                        hir::MatchSource::IfDesugar { .. } |\n+                        hir::MatchSource::WhileDesugar => bug!(),\n                         hir::MatchSource::IfLetDesugar { .. } => {\n                             cx.tcx.lint_hir(\n                                 lint::builtin::IRREFUTABLE_LET_PATTERNS,"}, {"sha": "afe4c78dcfc374194f6293c980fa8aa6659645bc", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=f8b32dfb27976f52b47bb278fee397b65efddc18", "patch": "@@ -12,27 +12,10 @@ use syntax::struct_span_err;\n use syntax_pos::Span;\n use errors::Applicability;\n \n-#[derive(Clone, Copy, Debug, PartialEq)]\n-enum LoopKind {\n-    Loop(hir::LoopSource),\n-    WhileLoop,\n-}\n-\n-impl LoopKind {\n-    fn name(self) -> &'static str {\n-        match self {\n-            LoopKind::Loop(hir::LoopSource::Loop) => \"loop\",\n-            LoopKind::Loop(hir::LoopSource::WhileLet) => \"while let\",\n-            LoopKind::Loop(hir::LoopSource::ForLoop) => \"for\",\n-            LoopKind::WhileLoop => \"while\",\n-        }\n-    }\n-}\n-\n #[derive(Clone, Copy, Debug, PartialEq)]\n enum Context {\n     Normal,\n-    Loop(LoopKind),\n+    Loop(hir::LoopSource),\n     Closure,\n     LabeledBlock,\n     AnonConst,\n@@ -71,14 +54,8 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n \n     fn visit_expr(&mut self, e: &'hir hir::Expr) {\n         match e.node {\n-            hir::ExprKind::While(ref e, ref b, _) => {\n-                self.with_context(Loop(LoopKind::WhileLoop), |v| {\n-                    v.visit_expr(&e);\n-                    v.visit_block(&b);\n-                });\n-            }\n             hir::ExprKind::Loop(ref b, _, source) => {\n-                self.with_context(Loop(LoopKind::Loop(source)), |v| v.visit_block(&b));\n+                self.with_context(Loop(source), |v| v.visit_block(&b));\n             }\n             hir::ExprKind::Closure(_, ref function_decl, b, _, _) => {\n                 self.visit_fn_decl(&function_decl);\n@@ -117,15 +94,14 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                         None\n                     } else {\n                         Some(match self.hir_map.expect_expr(loop_id).node {\n-                            hir::ExprKind::While(..) => LoopKind::WhileLoop,\n-                            hir::ExprKind::Loop(_, _, source) => LoopKind::Loop(source),\n+                            hir::ExprKind::Loop(_, _, source) => source,\n                             ref r => span_bug!(e.span,\n                                                \"break label resolved to a non-loop: {:?}\", r),\n                         })\n                     };\n                     match loop_kind {\n                         None |\n-                        Some(LoopKind::Loop(hir::LoopSource::Loop)) => (),\n+                        Some(hir::LoopSource::Loop) => (),\n                         Some(kind) => {\n                             struct_span_err!(self.sess, e.span, E0571,\n                                              \"`break` with value from a `{}` loop\","}, {"sha": "8ba3a25e3947c1fafa394d69f0dc022efddeb52e", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=f8b32dfb27976f52b47bb278fee397b65efddc18", "patch": "@@ -520,13 +520,6 @@ fn check_expr_kind<'a, 'tcx>(\n             NotPromotable\n         }\n \n-        // Loops (not very meaningful in constants).\n-        hir::ExprKind::While(ref expr, ref box_block, ref _option_label) => {\n-            let _ = v.check_expr(expr);\n-            let _ = v.check_block(box_block);\n-            NotPromotable\n-        }\n-\n         hir::ExprKind::Loop(ref box_block, ref _option_label, ref _loop_source) => {\n             let _ = v.check_block(box_block);\n             NotPromotable"}, {"sha": "b02a7c21027d43e475cf686f670057cf5e23d5ca", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 3, "deletions": 38, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=f8b32dfb27976f52b47bb278fee397b65efddc18", "patch": "@@ -159,11 +159,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Warn for non-block expressions with diverging children.\n         match expr.node {\n-            ExprKind::Block(..) |\n-            ExprKind::Loop(..) | ExprKind::While(..) |\n-            ExprKind::Match(..) => {}\n-\n-            _ => self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\")\n+            ExprKind::Block(..) | ExprKind::Loop(..) | ExprKind::Match(..) => {},\n+            _ => self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\"),\n         }\n \n         // Any expression that produces a value of type `!` must have diverged\n@@ -245,9 +242,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Assign(ref lhs, ref rhs) => {\n                 self.check_expr_assign(expr, expected, lhs, rhs)\n             }\n-            ExprKind::While(ref cond, ref body, _) => {\n-                self.check_expr_while(cond, body, expr)\n-            }\n             ExprKind::Loop(ref body, _, source) => {\n                 self.check_expr_loop(body, source, expected, expr)\n             }\n@@ -702,36 +696,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_expr_while(\n-        &self,\n-        cond: &'tcx hir::Expr,\n-        body: &'tcx hir::Block,\n-        expr: &'tcx hir::Expr\n-    ) -> Ty<'tcx> {\n-        let ctxt = BreakableCtxt {\n-            // Cannot use break with a value from a while loop.\n-            coerce: None,\n-            may_break: false, // Will get updated if/when we find a `break`.\n-        };\n-\n-        let (ctxt, ()) = self.with_breakable_ctxt(expr.hir_id, ctxt, || {\n-            self.check_expr_has_type_or_error(&cond, self.tcx.types.bool);\n-            let cond_diverging = self.diverges.get();\n-            self.check_block_no_value(&body);\n-\n-            // We may never reach the body so it diverging means nothing.\n-            self.diverges.set(cond_diverging);\n-        });\n-\n-        if ctxt.may_break {\n-            // No way to know whether it's diverging because\n-            // of a `break` or an outer `break` or `return`.\n-            self.diverges.set(Diverges::Maybe);\n-        }\n-\n-        self.tcx.mk_unit()\n-    }\n-\n     fn check_expr_loop(\n         &self,\n         body: &'tcx hir::Block,\n@@ -746,6 +710,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Some(CoerceMany::new(coerce_to))\n             }\n \n+            hir::LoopSource::While |\n             hir::LoopSource::WhileLet |\n             hir::LoopSource::ForLoop => {\n                 None"}, {"sha": "5b19614a5b3f6b0f4b7129b987f6c6b425f1a04c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f8b32dfb27976f52b47bb278fee397b65efddc18", "patch": "@@ -3865,7 +3865,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             match expression.node {\n                 ExprKind::Call(..) |\n                 ExprKind::MethodCall(..) |\n-                ExprKind::While(..) |\n                 ExprKind::Loop(..) |\n                 ExprKind::Match(..) |\n                 ExprKind::Block(..) => {"}, {"sha": "f9ebe762e522fbf7e3af53ac991fa4a03aff66c6", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8b32dfb27976f52b47bb278fee397b65efddc18/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=f8b32dfb27976f52b47bb278fee397b65efddc18", "patch": "@@ -685,16 +685,6 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n                 self.set_repeating_scope(repeating_scope);\n             }\n \n-            hir::ExprKind::While(ref cond, ref body, _) => {\n-                let repeating_scope = self.set_repeating_scope(cond.hir_id);\n-                self.visit_expr(&cond);\n-\n-                self.set_repeating_scope(body.hir_id);\n-                self.visit_block(&body);\n-\n-                self.set_repeating_scope(repeating_scope);\n-            }\n-\n             hir::ExprKind::Ret(Some(ref ret_expr)) => {\n                 let call_site_scope = self.call_site_scope;\n                 debug!("}]}