{"sha": "9eb75613f0425743933612b59e65d22596af5165", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllYjc1NjEzZjA0MjU3NDM5MzM2MTJiNTllNjVkMjI1OTZhZjUxNjU=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-06-26T09:56:24Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-06-27T09:17:55Z"}, "message": "Generate `DefId`s for the impl trait of `async` functions", "tree": {"sha": "0fd4577f30d987a5819df3e2d6f2a4c432ae211f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0fd4577f30d987a5819df3e2d6f2a4c432ae211f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9eb75613f0425743933612b59e65d22596af5165", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9eb75613f0425743933612b59e65d22596af5165", "html_url": "https://github.com/rust-lang/rust/commit/9eb75613f0425743933612b59e65d22596af5165", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9eb75613f0425743933612b59e65d22596af5165/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ec5eab368b3320950007b07b00600b9a981827a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ec5eab368b3320950007b07b00600b9a981827a", "html_url": "https://github.com/rust-lang/rust/commit/2ec5eab368b3320950007b07b00600b9a981827a"}], "stats": {"total": 158, "additions": 102, "deletions": 56}, "files": [{"sha": "004121147d904762135009d4f0876339c94167b4", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 44, "deletions": 27, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9eb75613f0425743933612b59e65d22596af5165/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb75613f0425743933612b59e65d22596af5165/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=9eb75613f0425743933612b59e65d22596af5165", "patch": "@@ -863,7 +863,7 @@ impl<'a> LoweringContext<'a> {\n \n         let capture_clause = self.lower_capture_clause(capture_clause);\n         let closure_hir_id = self.lower_node_id(closure_node_id).hir_id;\n-        let decl = self.lower_fn_decl(&decl, None, /* impl trait allowed */ false, false);\n+        let decl = self.lower_fn_decl(&decl, None, /* impl trait allowed */ false, None);\n         let generator = hir::Expr {\n             id: closure_node_id,\n             hir_id: closure_hir_id,\n@@ -1106,7 +1106,7 @@ impl<'a> LoweringContext<'a> {\n                                 ),\n                                 unsafety: this.lower_unsafety(f.unsafety),\n                                 abi: f.abi,\n-                                decl: this.lower_fn_decl(&f.decl, None, false, false),\n+                                decl: this.lower_fn_decl(&f.decl, None, false, None),\n                                 arg_names: this.lower_fn_args_to_names(&f.decl),\n                             }))\n                         },\n@@ -1176,7 +1176,7 @@ impl<'a> LoweringContext<'a> {\n                             |this| this.lower_param_bounds(bounds, itctx),\n                         )\n                     }\n-                    ImplTraitContext::Universal(def_id) => {\n+                    ImplTraitContext::Universal(_def_id) => {\n                         self.lower_node_id(def_node_id);\n                         // Add a definition for the in-band TyParam\n                         let def_index = self\n@@ -1866,18 +1866,18 @@ impl<'a> LoweringContext<'a> {\n     // decl: the unlowered (ast) function declaration.\n     // fn_def_id: if `Some`, impl Trait arguments are lowered into generic parameters on the\n     //      given DefId, otherwise impl Trait is disallowed. Must be `Some` if\n-    //      make_ret_async is true.\n+    //      make_ret_async is also `Some`.\n     // impl_trait_return_allow: determines whether impl Trait can be used in return position.\n     //      This guards against trait declarations and implementations where impl Trait is\n     //      disallowed.\n-    // make_ret_async: if enabled, converts `-> T` into `-> impl Future<Output = T>` in the\n+    // make_ret_async: if `Some`, converts `-> T` into `-> impl Future<Output = T>` in the\n     //      return type. This is used for `async fn` declarations.\n     fn lower_fn_decl(\n         &mut self,\n         decl: &FnDecl,\n         fn_def_id: Option<DefId>,\n         impl_trait_return_allow: bool,\n-        make_ret_async: bool,\n+        make_ret_async: Option<NodeId>,\n     ) -> P<hir::FnDecl> {\n         let inputs = decl.inputs\n             .iter()\n@@ -1890,9 +1890,9 @@ impl<'a> LoweringContext<'a> {\n             })\n             .collect::<HirVec<_>>();\n \n-        let output = if make_ret_async {\n+        let output = if let Some(ret_id) = make_ret_async {\n             self.lower_async_fn_ret_ty(\n-                &inputs, &decl.output, fn_def_id.expect(\"make_ret_async but no fn_def_id\"))\n+                &inputs, &decl.output, fn_def_id.expect(\"make_ret_async but no fn_def_id\"), ret_id)\n         } else {\n             match decl.output {\n                 FunctionRetTy::Ty(ref ty) => match fn_def_id {\n@@ -1928,6 +1928,7 @@ impl<'a> LoweringContext<'a> {\n         inputs: &[P<hir::Ty>],\n         output: &FunctionRetTy,\n         fn_def_id: DefId,\n+        return_impl_trait_id: NodeId,\n     ) -> hir::FunctionRetTy {\n         // Get lifetimes used in the input arguments to the function. Our output type must also\n         // have the same lifetime. FIXME(cramertj) multiple different lifetimes are not allowed\n@@ -2079,7 +2080,7 @@ impl<'a> LoweringContext<'a> {\n         };\n \n         let impl_trait_ty = self.lower_existential_impl_trait(\n-            span, fn_def_id, |this| {\n+            span, fn_def_id, return_impl_trait_id, |this| {\n             let output_ty = match output {\n                 FunctionRetTy::Ty(ty) =>\n                     this.lower_ty(ty, ImplTraitContext::Existential(fn_def_id)),\n@@ -2564,9 +2565,9 @@ impl<'a> LoweringContext<'a> {\n                     // only cares about the input argument patterns in the function\n                     // declaration (decl), not the return types.\n                     let body_id = this.lower_body(Some(decl), |this| {\n-                        if let IsAsync::Async(async_node_id) = header.asyncness {\n+                        if let IsAsync::Async { closure_id, .. } = header.asyncness {\n                             let async_expr = this.make_async_expr(\n-                                CaptureBy::Value, async_node_id, None,\n+                                CaptureBy::Value, closure_id, None,\n                                 |this| {\n                                     let body = this.lower_block(body, false);\n                                     this.expr_block(body, ThinVec::new())\n@@ -2578,12 +2579,17 @@ impl<'a> LoweringContext<'a> {\n                         }\n                     });\n \n+                    let asyncness = match header.asyncness {\n+                        IsAsync::Async { return_impl_trait_id, .. } => Some(return_impl_trait_id),\n+                        IsAsync::NotAsync => None,\n+                    };\n+\n                     let (generics, fn_decl) = this.add_in_band_defs(\n                         generics,\n                         fn_def_id,\n                         AnonymousLifetimeMode::PassThrough,\n                         |this| this.lower_fn_decl(\n-                            decl, Some(fn_def_id), true, header.asyncness.is_async())\n+                            decl, Some(fn_def_id), true, asyncness)\n                     );\n \n                     hir::ItemFn(\n@@ -2906,7 +2912,7 @@ impl<'a> LoweringContext<'a> {\n                     AnonymousLifetimeMode::PassThrough,\n                     |this| {\n                         hir::TraitItemKind::Method(\n-                            this.lower_method_sig(sig, trait_item_def_id, false, false),\n+                            this.lower_method_sig(sig, trait_item_def_id, false, None),\n                             hir::TraitMethod::Required(names),\n                         )\n                     },\n@@ -2924,7 +2930,7 @@ impl<'a> LoweringContext<'a> {\n                     AnonymousLifetimeMode::PassThrough,\n                     |this| {\n                         hir::TraitItemKind::Method(\n-                            this.lower_method_sig(sig, trait_item_def_id, false, false),\n+                            this.lower_method_sig(sig, trait_item_def_id, false, None),\n                             hir::TraitMethod::Provided(body_id),\n                         )\n                     },\n@@ -2995,9 +3001,9 @@ impl<'a> LoweringContext<'a> {\n             }\n             ImplItemKind::Method(ref sig, ref body) => {\n                 let body_id = self.lower_body(Some(&sig.decl), |this| {\n-                    if let IsAsync::Async(async_node_id) = sig.header.asyncness {\n+                    if let IsAsync::Async { closure_id, .. } = sig.header.asyncness {\n                         let async_expr = this.make_async_expr(\n-                            CaptureBy::Value, async_node_id, None,\n+                            CaptureBy::Value, closure_id, None,\n                             |this| {\n                                 let body = this.lower_block(body, false);\n                                 this.expr_block(body, ThinVec::new())\n@@ -3010,6 +3016,11 @@ impl<'a> LoweringContext<'a> {\n                 });\n                 let impl_trait_return_allow = !self.is_in_trait_impl;\n \n+                let asyncness = match sig.header.asyncness {\n+                    IsAsync::Async { return_impl_trait_id, .. } => Some(return_impl_trait_id),\n+                    IsAsync::NotAsync => None,\n+                };\n+\n                 self.add_in_band_defs(\n                     &i.generics,\n                     impl_item_def_id,\n@@ -3020,7 +3031,7 @@ impl<'a> LoweringContext<'a> {\n                                 sig,\n                                 impl_item_def_id,\n                                 impl_trait_return_allow,\n-                                sig.header.asyncness.is_async(),\n+                                asyncness,\n                             ),\n                             body_id,\n                         )\n@@ -3100,8 +3111,8 @@ impl<'a> LoweringContext<'a> {\n                 path_span: Span,\n                 path_segment: &'v PathSegment,\n             ) {\n-                if let Some(ref p) = path_segment.parameters {\n-                    if let PathParameters::Parenthesized(..) = **p {\n+                if let Some(ref p) = path_segment.args {\n+                    if let GenericArgs::Parenthesized(_) = **p {\n                         return;\n                     }\n                 }\n@@ -3123,15 +3134,21 @@ impl<'a> LoweringContext<'a> {\n                 vec\n             }\n             ItemKind::MacroDef(..) => SmallVector::new(),\n-            ItemKind::Fn(ref decl, ..) => {\n+            ItemKind::Fn(ref decl, ref header, ..) => {\n                 let mut ids = SmallVector::one(hir::ItemId { id: i.id });\n+                if let IsAsync::Async { return_impl_trait_id, .. } = header.asyncness {\n+                    ids.push(hir::ItemId { id: return_impl_trait_id });\n+                }\n                 self.lower_impl_trait_ids(decl, &mut ids);\n                 ids\n             },\n             ItemKind::Impl(.., ref items) => {\n                 let mut ids = SmallVector::one(hir::ItemId { id: i.id });\n                 for item in items {\n                     if let ImplItemKind::Method(ref sig, _) = item.node {\n+                        if let IsAsync::Async { return_impl_trait_id, .. } = sig.header.asyncness {\n+                            ids.push(hir::ItemId { id: return_impl_trait_id });\n+                        }\n                         self.lower_impl_trait_ids(&sig.decl, &mut ids);\n                     }\n                 }\n@@ -3214,7 +3231,7 @@ impl<'a> LoweringContext<'a> {\n                         |this| {\n                             (\n                                 // Disallow impl Trait in foreign items\n-                                this.lower_fn_decl(fdec, None, false, false),\n+                                this.lower_fn_decl(fdec, None, false, None),\n                                 this.lower_fn_args_to_names(fdec),\n                             )\n                         },\n@@ -3238,7 +3255,7 @@ impl<'a> LoweringContext<'a> {\n         sig: &MethodSig,\n         fn_def_id: DefId,\n         impl_trait_return_allow: bool,\n-        is_async: bool,\n+        is_async: Option<NodeId>,\n     ) -> hir::MethodSig {\n         hir::MethodSig {\n             header: self.lower_fn_header(sig.header),\n@@ -3278,7 +3295,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_asyncness(&mut self, a: IsAsync) -> hir::IsAsync {\n         match a {\n-            IsAsync::Async(_) => hir::IsAsync::Async,\n+            IsAsync::Async { .. } => hir::IsAsync::Async,\n             IsAsync::NotAsync => hir::IsAsync::NotAsync,\n         }\n     }\n@@ -3581,7 +3598,7 @@ impl<'a> LoweringContext<'a> {\n             ExprKind::Closure(\n                 capture_clause, asyncness, movability, ref decl, ref body, fn_decl_span\n             ) => {\n-                if let IsAsync::Async(async_closure_node_id) = asyncness {\n+                if let IsAsync::Async { async_closure_node_id, .. } = asyncness {\n                     let outer_decl = FnDecl {\n                         inputs: decl.inputs.clone(),\n                         output: FunctionRetTy::Default(fn_decl_span),\n@@ -3590,7 +3607,7 @@ impl<'a> LoweringContext<'a> {\n                     // We need to lower the declaration outside the new scope, because we\n                     // have to conserve the state of being inside a loop condition for the\n                     // closure argument types.\n-                    let fn_decl = self.lower_fn_decl(&outer_decl, None, false, false);\n+                    let fn_decl = self.lower_fn_decl(&outer_decl, None, false, None);\n \n                     self.with_new_scopes(|this| {\n                         // FIXME(cramertj) allow `async` non-`move` closures with\n@@ -3617,7 +3634,7 @@ impl<'a> LoweringContext<'a> {\n                                 Some(&**ty)\n                             } else { None };\n                             let async_body = this.make_async_expr(\n-                                capture_clause, async_closure_node_id, async_ret_ty,\n+                                capture_clause, closure_id, async_ret_ty,\n                                 |this| {\n                                     this.with_new_scopes(|this| this.lower_expr(body))\n                                 });\n@@ -3633,7 +3650,7 @@ impl<'a> LoweringContext<'a> {\n                     })\n                 } else {\n                     // Lower outside new scope to preserve `is_in_loop_condition`.\n-                    let fn_decl = self.lower_fn_decl(decl, None, false, false);\n+                    let fn_decl = self.lower_fn_decl(decl, None, false, None);\n \n                     self.with_new_scopes(|this| {\n                         let mut is_generator = false;"}, {"sha": "47ebc97310213505bde1127b0a00983ef3ebaea4", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9eb75613f0425743933612b59e65d22596af5165/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb75613f0425743933612b59e65d22596af5165/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=9eb75613f0425743933612b59e65d22596af5165", "patch": "@@ -77,6 +77,7 @@ impl<'a> DefCollector<'a> {\n         &mut self,\n         id: NodeId,\n         async_node_id: NodeId,\n+        return_impl_trait_id: NodeId,\n         name: Name,\n         span: Span,\n         visit_fn: impl FnOnce(&mut DefCollector<'a>)\n@@ -86,6 +87,7 @@ impl<'a> DefCollector<'a> {\n         let fn_def_data = DefPathData::ValueNs(name.as_interned_str());\n         let fn_def = self.create_def(id, fn_def_data, ITEM_LIKE_SPACE, span);\n         return self.with_parent(fn_def, |this| {\n+            this.create_def(return_impl_trait_id, DefPathData::ImplTrait, REGULAR_SPACE, span);\n             let closure_def = this.create_def(async_node_id,\n                                   DefPathData::ClosureExpr,\n                                   REGULAR_SPACE,\n@@ -120,10 +122,14 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             ItemKind::Mod(..) if i.ident == keywords::Invalid.ident() => {\n                 return visit::walk_item(self, i);\n             }\n-            ItemKind::Fn(_, FnHeader { asyncness: IsAsync::Async(async_node_id), .. }, ..) => {\n+            ItemKind::Fn(_, FnHeader { asyncness: IsAsync::Async {\n+                closure_id,\n+                return_impl_trait_id,\n+            }, .. }, ..) => {\n                 return self.visit_async_fn(\n                     i.id,\n-                    async_node_id,\n+                    closure_id,\n+                    return_impl_trait_id,\n                     i.ident.name,\n                     i.span,\n                     |this| visit::walk_item(this, i)\n@@ -228,11 +234,15 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n         let def_data = match ii.node {\n             ImplItemKind::Method(MethodSig {\n-                header: FnHeader { asyncness: IsAsync::Async(async_node_id), .. }, ..\n+                header: FnHeader { asyncness: IsAsync::Async {\n+                    closure_id,\n+                    return_impl_trait_id,\n+                }, .. }, ..\n             }, ..) => {\n                 return self.visit_async_fn(\n                     ii.id,\n-                    async_node_id,\n+                    closure_id,\n+                    return_impl_trait_id,\n                     ii.ident.name,\n                     ii.span,\n                     |this| visit::walk_impl_item(this, ii)\n@@ -277,8 +287,8 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n                 // Async closures desugar to closures inside of closures, so\n                 // we must create two defs.\n-                if let IsAsync::Async(async_id) = asyncness {\n-                    let async_def = self.create_def(async_id,\n+                if let IsAsync::Async { closure_id, .. } = asyncness {\n+                    let async_def = self.create_def(closure_id,\n                                                     DefPathData::ClosureExpr,\n                                                     REGULAR_SPACE,\n                                                     expr.span);"}, {"sha": "159850098434eace4ac963a80b325c887132161c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9eb75613f0425743933612b59e65d22596af5165/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb75613f0425743933612b59e65d22596af5165/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=9eb75613f0425743933612b59e65d22596af5165", "patch": "@@ -777,8 +777,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n         visit::walk_fn_ret_ty(self, &declaration.output);\n \n         // Resolve the function body, potentially inside the body of an async closure\n-        if let IsAsync::Async(async_closure_id) = asyncness {\n-            let rib_kind = ClosureRibKind(async_closure_id);\n+        if let IsAsync::Async { closure_id, .. } = asyncness {\n+            let rib_kind = ClosureRibKind(closure_id);\n             self.ribs[ValueNS].push(Rib::new(rib_kind));\n             self.label_ribs.push(Rib::new(rib_kind));\n         }\n@@ -3935,8 +3935,9 @@ impl<'a> Resolver<'a> {\n             // resolve the arguments within the proper scopes so that usages of them inside the\n             // closure are detected as upvars rather than normal closure arg usages.\n             ExprKind::Closure(\n-                _, IsAsync::Async(inner_closure_id), _, ref fn_decl, ref body, _span) =>\n-            {\n+                _, IsAsync::Async { closure_id: inner_closure_id, .. }, _,\n+                ref fn_decl, ref body, _span,\n+            ) => {\n                 let rib_kind = ClosureRibKind(expr.id);\n                 self.ribs[ValueNS].push(Rib::new(rib_kind));\n                 self.label_ribs.push(Rib::new(rib_kind));"}, {"sha": "d38af6a608866a406e6a5beea7204d91f6288f04", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9eb75613f0425743933612b59e65d22596af5165/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb75613f0425743933612b59e65d22596af5165/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9eb75613f0425743933612b59e65d22596af5165", "patch": "@@ -1722,13 +1722,16 @@ pub enum Unsafety {\n \n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum IsAsync {\n-    Async(NodeId),\n+    Async {\n+        closure_id: NodeId,\n+        return_impl_trait_id: NodeId,\n+    },\n     NotAsync,\n }\n \n impl IsAsync {\n     pub fn is_async(self) -> bool {\n-        if let IsAsync::Async(_) = self {\n+        if let IsAsync::Async { .. } = self {\n             true\n         } else {\n             false"}, {"sha": "2a21e4c017112687e664e20b303b929547ba0959", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9eb75613f0425743933612b59e65d22596af5165/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb75613f0425743933612b59e65d22596af5165/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=9eb75613f0425743933612b59e65d22596af5165", "patch": "@@ -1726,7 +1726,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                                     \"labels on blocks are unstable\");\n                 }\n             }\n-            ast::ExprKind::Closure(_, ast::IsAsync::Async(_), ..) => {\n+            ast::ExprKind::Closure(_, ast::IsAsync::Async { .. }, ..) => {\n                 gate_feature_post!(&self, async_await, e.span, \"async closures are unstable\");\n             }\n             ast::ExprKind::Async(..) => {"}, {"sha": "d9d3febc4fe4d2312e33df78c4e37d86eaaee4a2", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9eb75613f0425743933612b59e65d22596af5165/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb75613f0425743933612b59e65d22596af5165/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=9eb75613f0425743933612b59e65d22596af5165", "patch": "@@ -100,6 +100,10 @@ pub trait Folder : Sized {\n         noop_fold_fn_decl(d, self)\n     }\n \n+    fn fold_asyncness(&mut self, a: IsAsync) -> IsAsync {\n+        noop_fold_asyncness(a, self)\n+    }\n+\n     fn fold_block(&mut self, b: P<Block>) -> P<Block> {\n         noop_fold_block(b, self)\n     }\n@@ -669,6 +673,16 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n     }\n }\n \n+pub fn noop_fold_asyncness<T: Folder>(asyncness: IsAsync, fld: &mut T) -> IsAsync {\n+    match asyncness {\n+        IsAsync::Async { closure_id, return_impl_trait_id } => IsAsync::Async {\n+            closure_id: fld.new_id(closure_id),\n+            return_impl_trait_id: fld.new_id(return_impl_trait_id),\n+        },\n+        IsAsync::NotAsync => IsAsync::NotAsync,\n+    }\n+}\n+\n pub fn noop_fold_fn_decl<T: Folder>(decl: P<FnDecl>, fld: &mut T) -> P<FnDecl> {\n     decl.map(|FnDecl {inputs, output, variadic}| FnDecl {\n         inputs: inputs.move_map(|x| fld.fold_arg(x)),\n@@ -996,10 +1010,7 @@ pub fn noop_fold_impl_item<T: Folder>(i: ImplItem, folder: &mut T)\n }\n \n pub fn noop_fold_fn_header<T: Folder>(mut header: FnHeader, folder: &mut T) -> FnHeader {\n-    header.asyncness = match header.asyncness {\n-        IsAsync::Async(node_id) => IsAsync::Async(folder.new_id(node_id)),\n-        IsAsync::NotAsync => IsAsync::NotAsync,\n-    };\n+    header.asyncness = folder.fold_asyncness(header.asyncness);\n     header\n }\n \n@@ -1249,12 +1260,8 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                           arms.move_map(|x| folder.fold_arm(x)))\n             }\n             ExprKind::Closure(capture_clause, asyncness, movability, decl, body, span) => {\n-                let asyncness = match asyncness {\n-                    IsAsync::Async(node_id) => IsAsync::Async(folder.new_id(node_id)),\n-                    IsAsync::NotAsync => IsAsync::NotAsync,\n-                };\n                 ExprKind::Closure(capture_clause,\n-                                  asyncness,\n+                                  folder.fold_asyncness(asyncness),\n                                   movability,\n                                   folder.fold_fn_decl(decl),\n                                   folder.fold_expr(body),\n@@ -1265,7 +1272,11 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                                 opt_label.map(|label| folder.fold_label(label)))\n             }\n             ExprKind::Async(capture_clause, node_id, body) => {\n-                ExprKind::Async(capture_clause, folder.new_id(node_id), folder.fold_block(body))\n+                ExprKind::Async(\n+                    capture_clause,\n+                    folder.new_id(node_id),\n+                    folder.fold_block(body),\n+                )\n             }\n             ExprKind::Assign(el, er) => {\n                 ExprKind::Assign(folder.fold_expr(el), folder.fold_expr(er))"}, {"sha": "4c86a64b0997b4c18fe432fb8f7a9539bad6d0aa", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9eb75613f0425743933612b59e65d22596af5165/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb75613f0425743933612b59e65d22596af5165/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9eb75613f0425743933612b59e65d22596af5165", "patch": "@@ -1299,7 +1299,10 @@ impl<'a> Parser<'a> {\n     /// Parse asyncness: `async` or nothing\n     fn parse_asyncness(&mut self) -> IsAsync {\n         if self.eat_keyword(keywords::Async) {\n-            IsAsync::Async(ast::DUMMY_NODE_ID)\n+            IsAsync::Async {\n+                closure_id: ast::DUMMY_NODE_ID,\n+                return_impl_trait_id: ast::DUMMY_NODE_ID,\n+            }\n         } else {\n             IsAsync::NotAsync\n         }\n@@ -3279,10 +3282,8 @@ impl<'a> Parser<'a> {\n         } else {\n             Movability::Movable\n         };\n-        let asyncness = if self.span.edition() >= Edition::Edition2018\n-            && self.eat_keyword(keywords::Async)\n-        {\n-            IsAsync::Async(ast::DUMMY_NODE_ID)\n+        let asyncness = if self.span.edition() >= Edition::Edition2018 {\n+            self.parse_asyncness()\n         } else {\n             IsAsync::NotAsync\n         };\n@@ -6798,7 +6799,10 @@ impl<'a> Parser<'a> {\n             let fn_span = self.prev_span;\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_fn(unsafety,\n-                                   IsAsync::Async(ast::DUMMY_NODE_ID),\n+                                   IsAsync::Async {\n+                                       closure_id: ast::DUMMY_NODE_ID,\n+                                       return_impl_trait_id: ast::DUMMY_NODE_ID,\n+                                   },\n                                    respan(fn_span, Constness::NotConst),\n                                    Abi::Rust)?;\n             let prev_span = self.prev_span;"}]}