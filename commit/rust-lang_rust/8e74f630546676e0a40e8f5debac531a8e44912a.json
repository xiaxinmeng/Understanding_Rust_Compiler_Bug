{"sha": "8e74f630546676e0a40e8f5debac531a8e44912a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNzRmNjMwNTQ2Njc2ZTBhNDBlOGY1ZGViYWM1MzFhOGU0NDkxMmE=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-12-13T01:26:19Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-12-25T06:09:28Z"}, "message": "review comments: move error reporting to their own methods", "tree": {"sha": "af23cc1e6e5fb6cc5c63e932860cb1c07a99691f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af23cc1e6e5fb6cc5c63e932860cb1c07a99691f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e74f630546676e0a40e8f5debac531a8e44912a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e74f630546676e0a40e8f5debac531a8e44912a", "html_url": "https://github.com/rust-lang/rust/commit/8e74f630546676e0a40e8f5debac531a8e44912a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e74f630546676e0a40e8f5debac531a8e44912a/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "759df5fa357ecc0f4a0dee9a3ac9c8b1c7160cb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/759df5fa357ecc0f4a0dee9a3ac9c8b1c7160cb8", "html_url": "https://github.com/rust-lang/rust/commit/759df5fa357ecc0f4a0dee9a3ac9c8b1c7160cb8"}], "stats": {"total": 396, "additions": 209, "deletions": 187}, "files": [{"sha": "68625e71b0441d879160ca5894572d6018583368", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 209, "deletions": 187, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/8e74f630546676e0a40e8f5debac531a8e44912a/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e74f630546676e0a40e8f5debac531a8e44912a/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=8e74f630546676e0a40e8f5debac531a8e44912a", "patch": "@@ -748,70 +748,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 }\n             },\n         );\n-        if !missing_type_params.is_empty() {\n-            let display = missing_type_params\n-                .iter()\n-                .map(|n| format!(\"`{}`\", n))\n-                .collect::<Vec<_>>()\n-                .join(\", \");\n-            let mut err = struct_span_err!(\n-                tcx.sess,\n-                span,\n-                E0393,\n-                \"the type parameter{} {} must be explicitly specified\",\n-                pluralize!(missing_type_params.len()),\n-                display,\n-            );\n-            err.span_label(\n-                self.tcx().def_span(def_id),\n-                &format!(\n-                    \"type parameter{} {} must be specified for this\",\n-                    pluralize!(missing_type_params.len()),\n-                    display,\n-                ),\n-            );\n-            let mut suggested = false;\n-            if let (Ok(snippet), true) = (\n-                tcx.sess.source_map().span_to_snippet(span),\n-                // Don't suggest setting the type params if there are some already: the order is\n-                // tricky to get right and the user will already know what the syntax is.\n-                generic_args.args.is_empty(),\n-            ) {\n-                if snippet.ends_with('>') {\n-                    // The user wrote `Trait<'a, T>` or similar. To provide an accurate suggestion\n-                    // we would have to preserve the right order. For now, as clearly the user is\n-                    // aware of the syntax, we do nothing.\n-                } else {\n-                    // The user wrote `Iterator`, so we don't have a type we can suggest, but at\n-                    // least we can clue them to the correct syntax `Iterator<Type>`.\n-                    err.span_suggestion(\n-                        span,\n-                        &format!(\n-                            \"set the type parameter{plural} to the desired type{plural}\",\n-                            plural = pluralize!(missing_type_params.len()),\n-                        ),\n-                        format!(\"{}<{}>\", snippet, missing_type_params.join(\", \")),\n-                        Applicability::HasPlaceholders,\n-                    );\n-                    suggested = true;\n-                }\n-            }\n-            if !suggested {\n-                err.span_label(\n-                    span,\n-                    format!(\n-                        \"missing reference{} to {}\",\n-                        pluralize!(missing_type_params.len()),\n-                        display,\n-                    ),\n-                );\n-            }\n-            err.note(&format!(\n-                \"because of the default `Self` reference, type parameters must be \\\n-                               specified on object types\"\n-            ));\n-            err.emit();\n-        }\n+\n+        self.complain_about_missing_type_params(\n+            missing_type_params,\n+            def_id,\n+            span,\n+            generic_args.args.is_empty(),\n+        );\n \n         // Convert associated-type bindings or constraints into a separate vector.\n         // Example: Given this:\n@@ -871,6 +814,77 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n     }\n \n+    fn complain_about_missing_type_params(\n+        &self,\n+        missing_type_params: Vec<String>,\n+        def_id: DefId,\n+        span: Span,\n+        empty_generic_args: bool,\n+    ) {\n+        if missing_type_params.is_empty() {\n+            return;\n+        }\n+        let display =\n+            missing_type_params.iter().map(|n| format!(\"`{}`\", n)).collect::<Vec<_>>().join(\", \");\n+        let mut err = struct_span_err!(\n+            self.tcx().sess,\n+            span,\n+            E0393,\n+            \"the type parameter{} {} must be explicitly specified\",\n+            pluralize!(missing_type_params.len()),\n+            display,\n+        );\n+        err.span_label(\n+            self.tcx().def_span(def_id),\n+            &format!(\n+                \"type parameter{} {} must be specified for this\",\n+                pluralize!(missing_type_params.len()),\n+                display,\n+            ),\n+        );\n+        let mut suggested = false;\n+        if let (Ok(snippet), true) = (\n+            self.tcx().sess.source_map().span_to_snippet(span),\n+            // Don't suggest setting the type params if there are some already: the order is\n+            // tricky to get right and the user will already know what the syntax is.\n+            empty_generic_args,\n+        ) {\n+            if snippet.ends_with('>') {\n+                // The user wrote `Trait<'a, T>` or similar. To provide an accurate suggestion\n+                // we would have to preserve the right order. For now, as clearly the user is\n+                // aware of the syntax, we do nothing.\n+            } else {\n+                // The user wrote `Iterator`, so we don't have a type we can suggest, but at\n+                // least we can clue them to the correct syntax `Iterator<Type>`.\n+                err.span_suggestion(\n+                    span,\n+                    &format!(\n+                        \"set the type parameter{plural} to the desired type{plural}\",\n+                        plural = pluralize!(missing_type_params.len()),\n+                    ),\n+                    format!(\"{}<{}>\", snippet, missing_type_params.join(\", \")),\n+                    Applicability::HasPlaceholders,\n+                );\n+                suggested = true;\n+            }\n+        }\n+        if !suggested {\n+            err.span_label(\n+                span,\n+                format!(\n+                    \"missing reference{} to {}\",\n+                    pluralize!(missing_type_params.len()),\n+                    display,\n+                ),\n+            );\n+        }\n+        err.note(&format!(\n+            \"because of the default `Self` reference, type parameters must be \\\n+                            specified on object types\"\n+        ));\n+        err.emit();\n+    }\n+\n     /// Instantiates the path for the given trait reference, assuming that it's\n     /// bound to a valid trait type. Returns the `DefId` of the defining trait.\n     /// The type _cannot_ be a type other than a trait type.\n@@ -907,13 +921,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n \n-        let path_span = if trait_ref.path.segments.len() == 1 {\n+        let path_span = if let [segment] = &trait_ref.path.segments[..] {\n             // FIXME: `trait_ref.path.span` can point to a full path with multiple\n             // segments, even though `trait_ref.path.segments` is of length `1`. Work\n             // around that bug here, even though it should be fixed elsewhere.\n             // This would otherwise cause an invalid suggestion. For an example, look at\n             // `src/test/ui/issues/issue-28344.rs`.\n-            trait_ref.path.segments[0].ident.span\n+            segment.ident.span\n         } else {\n             trait_ref.path.span\n         };\n@@ -1450,127 +1464,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             associated_types.remove(&projection_bound.projection_def_id());\n         }\n \n-        if !associated_types.is_empty() {\n-            // Account for things like `dyn Foo + 'a` by pointing at the `TraitRef.path`\n-            // `Span` instead of the `PolyTraitRef` `Span`. That way the suggestion will\n-            // be valid, otherwise we would suggest `dyn Foo + 'a<A = Type>`. See tests\n-            // `issue-22434.rs` and `issue-22560.rs` for examples.\n-            let sugg_span = if potential_assoc_types.is_empty() && trait_bounds.len() == 1 {\n-                if trait_bounds[0].trait_ref.path.segments.len() == 1\n-                    && trait_bounds[0].trait_ref.path.segments[0].args.is_none()\n-                {\n-                    // FIXME: `trait_ref.path.span` can point to a full path with multiple\n-                    // segments, even though `trait_ref.path.segments` is of length `1`. Work\n-                    // around that bug here, even though it should be fixed elsewhere.\n-                    // This would otherwise cause an invalid suggestion. For an example, look at\n-                    // `src/test/ui/issues/issue-28344.rs`.\n-                    trait_bounds[0].trait_ref.path.segments[0].ident.span\n-                } else {\n-                    trait_bounds[0].trait_ref.path.span\n-                }\n-            } else {\n-                span\n-            };\n-            let names = associated_types\n-                .iter()\n-                .map(|item_def_id| {\n-                    let assoc_item = tcx.associated_item(*item_def_id);\n-                    let trait_def_id = assoc_item.container.id();\n-                    format!(\n-                        \"`{}` (from trait `{}`)\",\n-                        assoc_item.ident,\n-                        tcx.def_path_str(trait_def_id)\n-                    )\n-                })\n-                .collect::<Vec<_>>()\n-                .join(\", \");\n-            let mut err = struct_span_err!(\n-                tcx.sess,\n-                sugg_span,\n-                E0191,\n-                \"the value of the associated type{} {} must be specified\",\n-                pluralize!(associated_types.len()),\n-                names,\n-            );\n-            let mut suggestions = Vec::new();\n-            let mut applicability = Applicability::MaybeIncorrect;\n-            for (i, item_def_id) in associated_types.iter().enumerate() {\n-                let assoc_item = tcx.associated_item(*item_def_id);\n-                if let Some(sp) = tcx.hir().span_if_local(*item_def_id) {\n-                    err.span_label(sp, format!(\"`{}` defined here\", assoc_item.ident));\n-                }\n-                if potential_assoc_types.len() == associated_types.len() {\n-                    // Only suggest when the amount of missing associated types equals the number of\n-                    // extra type arguments present, as that gives us a relatively high confidence\n-                    // that the user forgot to give the associtated type's name. The canonical\n-                    // example would be trying to use `Iterator<isize>` instead of\n-                    // `Iterator<Item = isize>`.\n-                    if let Ok(snippet) =\n-                        tcx.sess.source_map().span_to_snippet(potential_assoc_types[i])\n-                    {\n-                        suggestions.push((\n-                            potential_assoc_types[i],\n-                            format!(\"{} = {}\", assoc_item.ident, snippet),\n-                        ));\n-                    }\n-                }\n-            }\n-            let mut suggestions_len = suggestions.len();\n-            if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(sugg_span) {\n-                if potential_assoc_types.is_empty() && trait_bounds.len() == 1 &&\n-                    // Do not attempt to suggest when we don't know which path segment needs the\n-                    // type parameter set.\n-                    trait_bounds[0].trait_ref.path.segments.len() == 1\n-                {\n-                    debug!(\"path segments {:?}\", trait_bounds[0].trait_ref.path.segments);\n-                    applicability = Applicability::HasPlaceholders;\n-                    let assoc_types: Vec<String> = associated_types\n-                        .iter()\n-                        .map(|item_def_id| {\n-                            let assoc_item = tcx.associated_item(*item_def_id);\n-                            format!(\"{} = Type\", assoc_item.ident)\n-                        })\n-                        .collect();\n-                    let sugg = assoc_types.join(\", \");\n-                    if snippet.ends_with('>') {\n-                        // The user wrote `Trait<'a>` or similar and we don't have a type we can\n-                        // suggest, but at least we can clue them to the correct syntax\n-                        // `Trait<'a, Item = Type>` while accounting for the `<'a>` in the\n-                        // suggestion.\n-                        suggestions.push((\n-                            sugg_span,\n-                            format!(\"{}, {}>\", &snippet[..snippet.len() - 1], sugg,),\n-                        ));\n-                    } else {\n-                        // The user wrote `Iterator`, so we don't have a type we can suggest, but at\n-                        // least we can clue them to the correct syntax `Iterator<Item = Type>`.\n-                        suggestions.push((sugg_span, format!(\"{}<{}>\", snippet, sugg)));\n-                    }\n-                    suggestions_len = assoc_types.len();\n-                }\n-            }\n-            if suggestions.len() != 1 {\n-                // We don't need this label if there's an inline suggestion, show otherwise.\n-                let names = associated_types\n-                    .iter()\n-                    .map(|t| format!(\"`{}`\", tcx.associated_item(*t).ident))\n-                    .collect::<Vec<_>>()\n-                    .join(\", \");\n-                err.span_label(\n-                    span,\n-                    format!(\n-                        \"associated type{} {} must be specified\",\n-                        pluralize!(associated_types.len()),\n-                        names,\n-                    ),\n-                );\n-            }\n-            if !suggestions.is_empty() {\n-                let msg = format!(\"specify the associated type{}\", pluralize!(suggestions_len));\n-                err.multipart_suggestion(&msg, suggestions, applicability);\n-            }\n-            err.emit();\n-        }\n+        self.complain_about_missing_associated_types(\n+            span,\n+            associated_types,\n+            potential_assoc_types,\n+            trait_bounds,\n+        );\n \n         // De-duplicate auto traits so that, e.g., `dyn Trait + Send + Send` is the same as\n         // `dyn Trait + Send`.\n@@ -1659,6 +1558,129 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         ty\n     }\n \n+    fn complain_about_missing_associated_types(\n+        &self,\n+        span: Span,\n+        associated_types: BTreeSet<DefId>,\n+        potential_assoc_types: Vec<Span>,\n+        trait_bounds: &[hir::PolyTraitRef],\n+    ) {\n+        if associated_types.is_empty() {\n+            return;\n+        }\n+        // Account for things like `dyn Foo + 'a` by pointing at the `TraitRef.path`\n+        // `Span` instead of the `PolyTraitRef` `Span`. That way the suggestion will\n+        // be valid, otherwise we would suggest `dyn Foo + 'a<A = Type>`. See tests\n+        // `issue-22434.rs` and `issue-22560.rs` for examples.\n+        let sugg_span = match (&potential_assoc_types[..], &trait_bounds) {\n+            ([], [bound]) => match &bound.trait_ref.path.segments[..] {\n+                // FIXME: `trait_ref.path.span` can point to a full path with multiple\n+                // segments, even though `trait_ref.path.segments` is of length `1`. Work\n+                // around that bug here, even though it should be fixed elsewhere.\n+                // This would otherwise cause an invalid suggestion. For an example, look at\n+                // `src/test/ui/issues/issue-28344.rs`.\n+                [segment] if segment.args.is_none() => segment.ident.span,\n+                _ => bound.trait_ref.path.span,\n+            },\n+            _ => span,\n+        };\n+        let tcx = self.tcx();\n+        let names = associated_types\n+            .iter()\n+            .map(|item_def_id| {\n+                let assoc_item = tcx.associated_item(*item_def_id);\n+                let trait_def_id = assoc_item.container.id();\n+                format!(\"`{}` (from trait `{}`)\", assoc_item.ident, tcx.def_path_str(trait_def_id))\n+            })\n+            .collect::<Vec<_>>()\n+            .join(\", \");\n+        let mut err = struct_span_err!(\n+            tcx.sess,\n+            sugg_span,\n+            E0191,\n+            \"the value of the associated type{} {} must be specified\",\n+            pluralize!(associated_types.len()),\n+            names,\n+        );\n+        let mut suggestions = Vec::new();\n+        let mut applicability = Applicability::MaybeIncorrect;\n+        for (i, item_def_id) in associated_types.iter().enumerate() {\n+            let assoc_item = tcx.associated_item(*item_def_id);\n+            if let Some(sp) = tcx.hir().span_if_local(*item_def_id) {\n+                err.span_label(sp, format!(\"`{}` defined here\", assoc_item.ident));\n+            }\n+            if potential_assoc_types.len() == associated_types.len() {\n+                // Only suggest when the amount of missing associated types equals the number of\n+                // extra type arguments present, as that gives us a relatively high confidence\n+                // that the user forgot to give the associtated type's name. The canonical\n+                // example would be trying to use `Iterator<isize>` instead of\n+                // `Iterator<Item = isize>`.\n+                if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(potential_assoc_types[i])\n+                {\n+                    suggestions.push((\n+                        potential_assoc_types[i],\n+                        format!(\"{} = {}\", assoc_item.ident, snippet),\n+                    ));\n+                }\n+            }\n+        }\n+        let mut suggestions_len = suggestions.len();\n+        if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(sugg_span) {\n+            if potential_assoc_types.is_empty() && trait_bounds.len() == 1 &&\n+                // Do not attempt to suggest when we don't know which path segment needs the\n+                // type parameter set.\n+                trait_bounds[0].trait_ref.path.segments.len() == 1\n+            {\n+                debug!(\"path segments {:?}\", trait_bounds[0].trait_ref.path.segments);\n+                applicability = Applicability::HasPlaceholders;\n+                let assoc_types: Vec<String> = associated_types\n+                    .iter()\n+                    .map(|item_def_id| {\n+                        let assoc_item = tcx.associated_item(*item_def_id);\n+                        format!(\"{} = Type\", assoc_item.ident)\n+                    })\n+                    .collect();\n+                let sugg = assoc_types.join(\", \");\n+                if snippet.ends_with('>') {\n+                    // The user wrote `Trait<'a>` or similar and we don't have a type we can\n+                    // suggest, but at least we can clue them to the correct syntax\n+                    // `Trait<'a, Item = Type>` while accounting for the `<'a>` in the\n+                    // suggestion.\n+                    suggestions.push((\n+                        sugg_span,\n+                        format!(\"{}, {}>\", &snippet[..snippet.len() - 1], sugg,),\n+                    ));\n+                } else {\n+                    // The user wrote `Iterator`, so we don't have a type we can suggest, but at\n+                    // least we can clue them to the correct syntax `Iterator<Item = Type>`.\n+                    suggestions.push((sugg_span, format!(\"{}<{}>\", snippet, sugg)));\n+                }\n+                suggestions_len = assoc_types.len();\n+            }\n+        }\n+        if suggestions.len() != 1 {\n+            // We don't need this label if there's an inline suggestion, show otherwise.\n+            let names = associated_types\n+                .iter()\n+                .map(|t| format!(\"`{}`\", tcx.associated_item(*t).ident))\n+                .collect::<Vec<_>>()\n+                .join(\", \");\n+            err.span_label(\n+                span,\n+                format!(\n+                    \"associated type{} {} must be specified\",\n+                    pluralize!(associated_types.len()),\n+                    names,\n+                ),\n+            );\n+        }\n+        if !suggestions.is_empty() {\n+            let msg = format!(\"specify the associated type{}\", pluralize!(suggestions_len));\n+            err.multipart_suggestion(&msg, suggestions, applicability);\n+        }\n+        err.emit();\n+    }\n+\n     fn report_ambiguous_associated_type(\n         &self,\n         span: Span,"}]}