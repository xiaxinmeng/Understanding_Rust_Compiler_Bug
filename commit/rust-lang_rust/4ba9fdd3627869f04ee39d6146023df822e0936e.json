{"sha": "4ba9fdd3627869f04ee39d6146023df822e0936e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiYTlmZGQzNjI3ODY5ZjA0ZWUzOWQ2MTQ2MDIzZGY4MjJlMDkzNmU=", "commit": {"author": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-08-26T23:41:18Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-28T00:17:10Z"}, "message": "Remove deprecated modes from libstd/getopts.rs", "tree": {"sha": "66c103bd67786cdb259bb96a901b8ac0da6b36e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66c103bd67786cdb259bb96a901b8ac0da6b36e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ba9fdd3627869f04ee39d6146023df822e0936e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ba9fdd3627869f04ee39d6146023df822e0936e", "html_url": "https://github.com/rust-lang/rust/commit/4ba9fdd3627869f04ee39d6146023df822e0936e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ba9fdd3627869f04ee39d6146023df822e0936e/comments", "author": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e5a0e1da54f385c1ac623bb7cfe6cf19fcde8f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e5a0e1da54f385c1ac623bb7cfe6cf19fcde8f8", "html_url": "https://github.com/rust-lang/rust/commit/0e5a0e1da54f385c1ac623bb7cfe6cf19fcde8f8"}], "stats": {"total": 93, "additions": 50, "deletions": 43}, "files": [{"sha": "e8484664f40a37ec568192f32d5f474bfa81fd0a", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 50, "deletions": 43, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/4ba9fdd3627869f04ee39d6146023df822e0936e/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ba9fdd3627869f04ee39d6146023df822e0936e/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=4ba9fdd3627869f04ee39d6146023df822e0936e", "patch": "@@ -62,6 +62,9 @@\n  *     }\n  */\n \n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n import core::result::{Err, Ok};\n import core::option;\n import core::option::{Some, None};\n@@ -93,37 +96,38 @@ enum occur { req, optional, multi, }\n /// A description of a possible option\n type opt = {name: name, hasarg: hasarg, occur: occur};\n \n-fn mkname(nm: ~str) -> name {\n+fn mkname(nm: &str) -> name {\n+    let unm = str::from_slice(nm);\n     return if str::len(nm) == 1u {\n-            short(str::char_at(nm, 0u))\n-        } else { long(nm) };\n+            short(str::char_at(unm, 0u))\n+        } else { long(unm) };\n }\n \n /// Create an option that is required and takes an argument\n-fn reqopt(name: ~str) -> opt {\n+fn reqopt(name: &str) -> opt {\n     return {name: mkname(name), hasarg: yes, occur: req};\n }\n \n /// Create an option that is optional and takes an argument\n-fn optopt(name: ~str) -> opt {\n+fn optopt(name: &str) -> opt {\n     return {name: mkname(name), hasarg: yes, occur: optional};\n }\n \n /// Create an option that is optional and does not take an argument\n-fn optflag(name: ~str) -> opt {\n+fn optflag(name: &str) -> opt {\n     return {name: mkname(name), hasarg: no, occur: optional};\n }\n \n /// Create an option that is optional and takes an optional argument\n-fn optflagopt(name: ~str) -> opt {\n+fn optflagopt(name: &str) -> opt {\n     return {name: mkname(name), hasarg: maybe, occur: optional};\n }\n \n /**\n  * Create an option that is optional, takes an argument, and may occur\n  * multiple times\n  */\n-fn optmulti(name: ~str) -> opt {\n+fn optmulti(name: &str) -> opt {\n     return {name: mkname(name), hasarg: yes, occur: multi};\n }\n \n@@ -135,18 +139,18 @@ enum optval { val(~str), given, }\n  */\n type matches = {opts: ~[opt], vals: ~[~[optval]], free: ~[~str]};\n \n-fn is_arg(arg: ~str) -> bool {\n+fn is_arg(arg: &str) -> bool {\n     return str::len(arg) > 1u && arg[0] == '-' as u8;\n }\n \n-fn name_str(nm: name) -> ~str {\n-    return match nm {\n+fn name_str(nm: &name) -> ~str {\n+    return match *nm {\n       short(ch) => str::from_char(ch),\n       long(s) => s\n     };\n }\n \n-fn find_opt(opts: ~[opt], nm: name) -> Option<uint> {\n+fn find_opt(opts: &[opt], +nm: name) -> Option<uint> {\n     vec::position(opts, |opt| opt.name == nm)\n }\n \n@@ -163,7 +167,7 @@ enum fail_ {\n }\n \n /// Convert a `fail_` enum into an error string\n-fn fail_str(f: fail_) -> ~str {\n+fn fail_str(+f: fail_) -> ~str {\n     return match f {\n       argument_missing(nm) => ~\"Argument to option '\" + nm + ~\"' missing.\",\n       unrecognized_option(nm) => ~\"Unrecognized option: '\" + nm + ~\"'.\",\n@@ -188,7 +192,7 @@ type result = result::Result<matches, fail_>;\n  * `opt_str`, etc. to interrogate results.  Returns `err(fail_)` on failure.\n  * Use <fail_str> to get an error message.\n  */\n-fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n+fn getopts(args: &[~str], opts: &[opt]) -> result unsafe {\n     let n_opts = vec::len::<opt>(opts);\n     fn f(_x: uint) -> ~[optval] { return ~[]; }\n     let vals = vec::to_mut(vec::from_fn(n_opts, f));\n@@ -261,12 +265,12 @@ fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n                 name_pos += 1u;\n                 let optid = match find_opt(opts, nm) {\n                   Some(id) => id,\n-                  None => return Err(unrecognized_option(name_str(nm)))\n+                  None => return Err(unrecognized_option(name_str(&nm)))\n                 };\n                 match opts[optid].hasarg {\n                   no => {\n                     if !option::is_none::<~str>(i_arg) {\n-                        return Err(unexpected_argument(name_str(nm)));\n+                        return Err(unexpected_argument(name_str(&nm)));\n                     }\n                     vec::push(vals[optid], given);\n                   }\n@@ -283,7 +287,7 @@ fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n                         vec::push(vals[optid],\n                                   val(option::get::<~str>(i_arg)));\n                     } else if i + 1u == l {\n-                        return Err(argument_missing(name_str(nm)));\n+                        return Err(argument_missing(name_str(&nm)));\n                     } else { i += 1u; vec::push(vals[optid], val(args[i])); }\n                   }\n                 }\n@@ -297,42 +301,44 @@ fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n         let occ = opts[i].occur;\n         if occ == req {\n             if n == 0u {\n-                return Err(option_missing(name_str(opts[i].name)));\n+                return Err(option_missing(name_str(&(opts[i].name))));\n             }\n         }\n         if occ != multi {\n             if n > 1u {\n-                return Err(option_duplicated(name_str(opts[i].name)));\n+                return Err(option_duplicated(name_str(&(opts[i].name))));\n             }\n         }\n         i += 1u;\n     }\n-    return Ok({opts: opts, vals: vec::from_mut(vals), free: free});\n+    return Ok({opts: vec::from_slice(opts),\n+               vals: vec::from_mut(vals),\n+               free: free});\n }\n \n-fn opt_vals(m: matches, nm: ~str) -> ~[optval] {\n-    return match find_opt(m.opts, mkname(nm)) {\n-      Some(id) => m.vals[id],\n+fn opt_vals(+mm: matches, nm: &str) -> ~[optval] {\n+    return match find_opt(mm.opts, mkname(nm)) {\n+      Some(id) => mm.vals[id],\n       None => {\n         error!(\"No option '%s' defined\", nm);\n         fail\n       }\n     };\n }\n \n-fn opt_val(m: matches, nm: ~str) -> optval { return opt_vals(m, nm)[0]; }\n+fn opt_val(+mm: matches, nm: &str) -> optval { return opt_vals(mm, nm)[0]; }\n \n /// Returns true if an option was matched\n-fn opt_present(m: matches, nm: ~str) -> bool {\n-    return vec::len::<optval>(opt_vals(m, nm)) > 0u;\n+fn opt_present(+mm: matches, nm: &str) -> bool {\n+    return vec::len::<optval>(opt_vals(mm, nm)) > 0u;\n }\n \n /// Returns true if any of several options were matched\n-fn opts_present(m: matches, names: ~[~str]) -> bool {\n+fn opts_present(+mm: matches, names: &[~str]) -> bool {\n     for vec::each(names) |nm| {\n-        match find_opt(m.opts, mkname(nm)) {\n+        match find_opt(mm.opts, mkname(nm)) {\n           Some(_) => return true,\n-          _ => ()\n+          None    => ()\n         }\n     }\n     return false;\n@@ -345,8 +351,8 @@ fn opts_present(m: matches, names: ~[~str]) -> bool {\n  * Fails if the option was not matched or if the match did not take an\n  * argument\n  */\n-fn opt_str(m: matches, nm: ~str) -> ~str {\n-    return match opt_val(m, nm) { val(s) => s, _ => fail };\n+fn opt_str(+mm: matches, nm: &str) -> ~str {\n+    return match opt_val(mm, nm) { val(s) => s, _ => fail };\n }\n \n /**\n@@ -355,9 +361,9 @@ fn opt_str(m: matches, nm: ~str) -> ~str {\n  * Fails if the no option was provided from the given list, or if the no such\n  * option took an argument\n  */\n-fn opts_str(m: matches, names: ~[~str]) -> ~str {\n+fn opts_str(+mm: matches, names: &[~str]) -> ~str {\n     for vec::each(names) |nm| {\n-        match opt_val(m, nm) {\n+        match opt_val(mm, nm) {\n           val(s) => return s,\n           _ => ()\n         }\n@@ -372,17 +378,17 @@ fn opts_str(m: matches, names: ~[~str]) -> ~str {\n  *\n  * Used when an option accepts multiple values.\n  */\n-fn opt_strs(m: matches, nm: ~str) -> ~[~str] {\n+fn opt_strs(+mm: matches, nm: &str) -> ~[~str] {\n     let mut acc: ~[~str] = ~[];\n-    for vec::each(opt_vals(m, nm)) |v| {\n+    for vec::each(opt_vals(mm, nm)) |v| {\n         match v { val(s) => vec::push(acc, s), _ => () }\n     }\n     return acc;\n }\n \n /// Returns the string argument supplied to a matching option or none\n-fn opt_maybe_str(m: matches, nm: ~str) -> Option<~str> {\n-    let vals = opt_vals(m, nm);\n+fn opt_maybe_str(+mm: matches, nm: &str) -> Option<~str> {\n+    let vals = opt_vals(mm, nm);\n     if vec::len::<optval>(vals) == 0u { return None::<~str>; }\n     return match vals[0] { val(s) => Some::<~str>(s), _ => None::<~str> };\n }\n@@ -395,10 +401,11 @@ fn opt_maybe_str(m: matches, nm: ~str) -> Option<~str> {\n  * present but no argument was provided, and the argument if the option was\n  * present and an argument was provided.\n  */\n-fn opt_default(m: matches, nm: ~str, def: ~str) -> Option<~str> {\n-    let vals = opt_vals(m, nm);\n+fn opt_default(+mm: matches, nm: &str, def: &str) -> Option<~str> {\n+    let vals = opt_vals(mm, nm);\n     if vec::len::<optval>(vals) == 0u { return None::<~str>; }\n-    return match vals[0] { val(s) => Some::<~str>(s), _ => Some::<~str>(def) }\n+    return match vals[0] { val(s) => Some::<~str>(s),\n+                           _      => Some::<~str>(str::from_slice(def)) }\n }\n \n #[cfg(test)]\n@@ -414,7 +421,7 @@ mod tests {\n         unexpected_argument_,\n     }\n \n-    fn check_fail_type(f: fail_, ft: fail_type) {\n+    fn check_fail_type(+f: fail_, ft: fail_type) {\n         match f {\n           argument_missing(_) => assert ft == argument_missing_,\n           unrecognized_option(_) => assert ft == unrecognized_option_,\n@@ -877,7 +884,7 @@ mod tests {\n         let opts = ~[optopt(~\"e\"), optopt(~\"encrypt\")];\n         let matches = match getopts(args, opts) {\n           result::Ok(m) => m,\n-          result::Err(_) => fail\n+          result::Err(_f) => fail\n         };\n         assert opts_present(matches, ~[~\"e\"]);\n         assert opts_present(matches, ~[~\"encrypt\"]);\n@@ -898,7 +905,7 @@ mod tests {\n         let opts = ~[optmulti(~\"L\")];\n         let matches = match getopts(args, opts) {\n           result::Ok(m) => m,\n-          result::Err(_) => fail\n+          result::Err(_f) => fail\n         };\n         assert opts_present(matches, ~[~\"L\"]);\n         assert opts_str(matches, ~[~\"L\"]) == ~\"foo\";"}]}