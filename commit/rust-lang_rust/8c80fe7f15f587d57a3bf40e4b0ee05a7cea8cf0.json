{"sha": "8c80fe7f15f587d57a3bf40e4b0ee05a7cea8cf0", "node_id": "C_kwDOAAsO6NoAKDhjODBmZTdmMTVmNTg3ZDU3YTNiZjQwZTRiMGVlMDVhN2NlYThjZjA", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-11-10T17:04:29Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-11-11T16:31:02Z"}, "message": "Correctly import all attributes from multi-level import", "tree": {"sha": "d482058dd87214eada6eb59269cc1bc0b9588382", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d482058dd87214eada6eb59269cc1bc0b9588382"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c80fe7f15f587d57a3bf40e4b0ee05a7cea8cf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c80fe7f15f587d57a3bf40e4b0ee05a7cea8cf0", "html_url": "https://github.com/rust-lang/rust/commit/8c80fe7f15f587d57a3bf40e4b0ee05a7cea8cf0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c80fe7f15f587d57a3bf40e4b0ee05a7cea8cf0/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01a6f30324deb8f9c9ec4a70c53690c5d073a244", "url": "https://api.github.com/repos/rust-lang/rust/commits/01a6f30324deb8f9c9ec4a70c53690c5d073a244", "html_url": "https://github.com/rust-lang/rust/commit/01a6f30324deb8f9c9ec4a70c53690c5d073a244"}], "stats": {"total": 94, "additions": 87, "deletions": 7}, "files": [{"sha": "c2f78fd5950f7148417f6aaba58cdd30210413b5", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 87, "deletions": 7, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/8c80fe7f15f587d57a3bf40e4b0ee05a7cea8cf0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c80fe7f15f587d57a3bf40e4b0ee05a7cea8cf0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8c80fe7f15f587d57a3bf40e4b0ee05a7cea8cf0", "patch": "@@ -1942,6 +1942,79 @@ fn clean_bare_fn_ty<'tcx>(\n     BareFunctionDecl { unsafety: bare_fn.unsafety, abi: bare_fn.abi, decl, generic_params }\n }\n \n+/// This visitor is used to go through only the \"top level\" of a item and not enter any sub\n+/// item while looking for a given `Ident` which is stored into `item` if found.\n+struct OneLevelVisitor<'hir> {\n+    map: rustc_middle::hir::map::Map<'hir>,\n+    item: Option<&'hir hir::Item<'hir>>,\n+    looking_for: Ident,\n+    target_hir_id: hir::HirId,\n+}\n+\n+impl<'hir> OneLevelVisitor<'hir> {\n+    fn new(map: rustc_middle::hir::map::Map<'hir>, target_hir_id: hir::HirId) -> Self {\n+        Self { map, item: None, looking_for: Ident::empty(), target_hir_id }\n+    }\n+\n+    fn reset(&mut self, looking_for: Ident) {\n+        self.looking_for = looking_for;\n+        self.item = None;\n+    }\n+}\n+\n+impl<'hir> hir::intravisit::Visitor<'hir> for OneLevelVisitor<'hir> {\n+    type NestedFilter = rustc_middle::hir::nested_filter::All;\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.map\n+    }\n+\n+    fn visit_item(&mut self, item: &'hir hir::Item<'hir>) {\n+        if self.item.is_none()\n+            && item.ident == self.looking_for\n+            && matches!(item.kind, hir::ItemKind::Use(_, _))\n+            || item.hir_id() == self.target_hir_id\n+        {\n+            self.item = Some(item);\n+        }\n+    }\n+}\n+\n+/// Because a `Use` item directly links to the imported item, we need to manually go through each\n+/// import one by one. To do so, we go to the parent item and look for the `Ident` into it. Then,\n+/// if we found the \"end item\" (the imported one), we stop there because we don't need its\n+/// documentation. Otherwise, we repeat the same operation until we find the \"end item\".\n+fn get_all_import_attributes<'hir>(\n+    mut item: &hir::Item<'hir>,\n+    tcx: TyCtxt<'hir>,\n+    target_hir_id: hir::HirId,\n+    attributes: &mut Vec<ast::Attribute>,\n+) {\n+    let hir_map = tcx.hir();\n+    let mut visitor = OneLevelVisitor::new(hir_map, target_hir_id);\n+    // If the item is an import and has at least a path with two parts, we go into it.\n+    while let hir::ItemKind::Use(path, _) = item.kind &&\n+        path.segments.len() > 1 &&\n+        let hir::def::Res::Def(_, def_id) = path.segments[path.segments.len() - 2].res\n+    {\n+        if let Some(hir::Node::Item(parent_item)) = hir_map.get_if_local(def_id) {\n+            // We add the attributes from this import into the list.\n+            attributes.extend_from_slice(hir_map.attrs(item.hir_id()));\n+            // We get the `Ident` we will be looking for into `item`.\n+            let looking_for = path.segments[path.segments.len() - 1].ident;\n+            visitor.reset(looking_for);\n+            hir::intravisit::walk_item(&mut visitor, parent_item);\n+            if let Some(i) = visitor.item {\n+                item = i;\n+            } else {\n+                break;\n+            }\n+        } else {\n+            break;\n+        }\n+    }\n+}\n+\n fn clean_maybe_renamed_item<'tcx>(\n     cx: &mut DocContext<'tcx>,\n     item: &hir::Item<'tcx>,\n@@ -2023,13 +2096,20 @@ fn clean_maybe_renamed_item<'tcx>(\n             }\n             _ => unreachable!(\"not yet converted\"),\n         };\n-        if let Some(import_id) = import_id {\n-            let (attrs, cfg) = inline::merge_attrs(\n-                cx,\n-                Some(cx.tcx.parent_module(import_id).to_def_id()),\n-                inline::load_attrs(cx, def_id),\n-                Some(inline::load_attrs(cx, cx.tcx.hir().local_def_id(import_id).to_def_id())),\n-            );\n+\n+        let mut extra_attrs = Vec::new();\n+        if let Some(hir::Node::Item(use_node)) =\n+            import_id.and_then(|hir_id| cx.tcx.hir().find(hir_id))\n+        {\n+            // We get all the various imports' attributes.\n+            get_all_import_attributes(use_node, cx.tcx, item.hir_id(), &mut extra_attrs);\n+        }\n+\n+        if !extra_attrs.is_empty() {\n+            extra_attrs.extend_from_slice(inline::load_attrs(cx, def_id));\n+            let attrs = Attributes::from_ast(&extra_attrs);\n+            let cfg = extra_attrs.cfg(cx.tcx, &cx.cache.hidden_cfg);\n+\n             vec![Item::from_def_id_and_attrs_and_parts(\n                 def_id,\n                 Some(name),"}]}