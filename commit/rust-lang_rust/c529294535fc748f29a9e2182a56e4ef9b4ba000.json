{"sha": "c529294535fc748f29a9e2182a56e4ef9b4ba000", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1MjkyOTQ1MzVmYzc0OGYyOWE5ZTIxODJhNTZlNGVmOWI0YmEwMDA=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2019-09-13T15:08:01Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2019-09-13T15:08:01Z"}, "message": "Regression tests for fn ptr and `#[structural_match]` as discussed in #63479.", "tree": {"sha": "752bd151ed71fa29c8fd7452ce4ea9f85e20494c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/752bd151ed71fa29c8fd7452ce4ea9f85e20494c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c529294535fc748f29a9e2182a56e4ef9b4ba000", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c529294535fc748f29a9e2182a56e4ef9b4ba000", "html_url": "https://github.com/rust-lang/rust/commit/c529294535fc748f29a9e2182a56e4ef9b4ba000", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c529294535fc748f29a9e2182a56e4ef9b4ba000/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7437f770251f6c3c76f75891d48db4d1e26fc0c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/7437f770251f6c3c76f75891d48db4d1e26fc0c2", "html_url": "https://github.com/rust-lang/rust/commit/7437f770251f6c3c76f75891d48db4d1e26fc0c2"}], "stats": {"total": 171, "additions": 171, "deletions": 0}, "files": [{"sha": "5b378fb2a5928ec8787ec87008ef029901e3f004", "filename": "src/test/ui/rfc1445/fn-ptr-is-structurally-matchable.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/c529294535fc748f29a9e2182a56e4ef9b4ba000/src%2Ftest%2Fui%2Frfc1445%2Ffn-ptr-is-structurally-matchable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c529294535fc748f29a9e2182a56e4ef9b4ba000/src%2Ftest%2Fui%2Frfc1445%2Ffn-ptr-is-structurally-matchable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Ffn-ptr-is-structurally-matchable.rs?ref=c529294535fc748f29a9e2182a56e4ef9b4ba000", "patch": "@@ -0,0 +1,135 @@\n+// run-pass\n+\n+// This file checks that fn ptrs are considered structurally matchable.\n+// See also rust-lang/rust#63479.\n+\n+fn main() {\n+    let mut count = 0;\n+\n+    // A type which is not structurally matchable:\n+    struct NotSM;\n+\n+    // And one that is:\n+    #[derive(PartialEq, Eq)]\n+    struct SM;\n+\n+    fn trivial() {}\n+\n+    fn sm_to(_: SM) {}\n+    fn not_sm_to(_: NotSM) {}\n+    fn to_sm() -> SM { SM }\n+    fn to_not_sm() -> NotSM { NotSM }\n+\n+    // To recreate the scenario of interest in #63479, we need to add\n+    // a ref-level-of-indirection so that we descend into the type.\n+\n+    fn r_sm_to(_: &SM) {}\n+    fn r_not_sm_to(_: &NotSM) {}\n+    fn r_to_r_sm(_: &()) -> &SM { &SM }\n+    fn r_to_r_not_sm(_: &()) -> &NotSM { &NotSM }\n+\n+    #[derive(PartialEq, Eq)]\n+    struct Wrap<T>(T);\n+\n+    // In the code below, we put the match input into a local so that\n+    // we can assign it an explicit type that is an fn ptr instead of\n+    // a singleton type of the fn itself that the type inference would\n+    // otherwise assign.\n+\n+    // Check that fn() is #[structural_match]\n+    const CFN1: Wrap<fn()> = Wrap(trivial);\n+    let input: Wrap<fn()> = Wrap(trivial);\n+    match Wrap(input) {\n+        Wrap(CFN1) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that fn(T) is #[structural_match] when T is too.\n+    const CFN2: Wrap<fn(SM)> = Wrap(sm_to);\n+    let input: Wrap<fn(SM)> = Wrap(sm_to);\n+    match Wrap(input) {\n+        Wrap(CFN2) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that fn() -> T is #[structural_match] when T is too.\n+    const CFN3: Wrap<fn() -> SM> = Wrap(to_sm);\n+    let input: Wrap<fn() -> SM> = Wrap(to_sm);\n+    match Wrap(input) {\n+        Wrap(CFN3) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that fn(T) is #[structural_match] even if T is not.\n+    const CFN4: Wrap<fn(NotSM)> = Wrap(not_sm_to);\n+    let input: Wrap<fn(NotSM)> = Wrap(not_sm_to);\n+    match Wrap(input) {\n+        Wrap(CFN4) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that fn() -> T is #[structural_match] even if T is not.\n+    const CFN5: Wrap<fn() -> NotSM> = Wrap(to_not_sm);\n+    let input: Wrap<fn() -> NotSM> = Wrap(to_not_sm);\n+    match Wrap(input) {\n+        Wrap(CFN5) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that fn(&T) is #[structural_match] when T is too.\n+    const CFN6: Wrap<fn(&SM)> = Wrap(r_sm_to);\n+    let input: Wrap<fn(&SM)> = Wrap(r_sm_to);\n+    match Wrap(input) {\n+        Wrap(CFN6) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that fn() -> &T is #[structural_match] when T is too.\n+    const CFN7: Wrap<fn(&()) -> &SM> = Wrap(r_to_r_sm);\n+    let input: Wrap<fn(&()) -> &SM> = Wrap(r_to_r_sm);\n+    match Wrap(input) {\n+        Wrap(CFN7) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that fn(T) is #[structural_match] even if T is not.\n+    const CFN8: Wrap<fn(&NotSM)> = Wrap(r_not_sm_to);\n+    let input: Wrap<fn(&NotSM)> = Wrap(r_not_sm_to);\n+    match Wrap(input) {\n+        Wrap(CFN8) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that fn() -> T is #[structural_match] even if T is not.\n+    const CFN9: Wrap<fn(&()) -> &NotSM> = Wrap(r_to_r_not_sm);\n+    let input: Wrap<fn(&()) -> &NotSM> = Wrap(r_to_r_not_sm);\n+    match Wrap(input) {\n+        Wrap(CFN9) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that a type which has fn ptrs is `#[structural_match]`.\n+    #[derive(PartialEq, Eq)]\n+    struct Foo {\n+        alpha: fn(NotSM),\n+        beta: fn() -> NotSM,\n+        gamma: fn(SM),\n+        delta: fn() -> SM,\n+    }\n+\n+    const CFOO: Foo = Foo {\n+        alpha: not_sm_to,\n+        beta: to_not_sm,\n+        gamma: sm_to,\n+        delta: to_sm,\n+    };\n+\n+    let input = Foo { alpha: not_sm_to, beta: to_not_sm, gamma: sm_to, delta: to_sm };\n+    match input {\n+        CFOO => count += 1,\n+        Foo { .. } => {}\n+    };\n+\n+    // Final count must be 10 now if all\n+    assert_eq!(count, 10);\n+}"}, {"sha": "b3c91cec580bfc777b7b41c5827a5699c549a903", "filename": "src/test/ui/rfc1445/issue-63479-match-fnptr.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c529294535fc748f29a9e2182a56e4ef9b4ba000/src%2Ftest%2Fui%2Frfc1445%2Fissue-63479-match-fnptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c529294535fc748f29a9e2182a56e4ef9b4ba000/src%2Ftest%2Fui%2Frfc1445%2Fissue-63479-match-fnptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fissue-63479-match-fnptr.rs?ref=c529294535fc748f29a9e2182a56e4ef9b4ba000", "patch": "@@ -0,0 +1,36 @@\n+// run-pass\n+\n+// The actual regression test from #63479. (Including this because my\n+// first draft at fn-ptr-is-structurally-matchable.rs failed to actually\n+// cover the case this hit; I've since expanded it accordingly, but the\n+// experience left me wary of leaving this regression test out.)\n+\n+#[derive(Eq)]\n+struct A {\n+  a: i64\n+}\n+\n+impl PartialEq for A {\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        self.a.eq(&other.a)\n+    }\n+}\n+\n+type Fn = fn(&[A]);\n+\n+fn my_fn(_args: &[A]) {\n+  println!(\"hello world\");\n+}\n+\n+const TEST: Fn = my_fn;\n+\n+struct B(Fn);\n+\n+fn main() {\n+  let s = B(my_fn);\n+  match s {\n+    B(TEST) => println!(\"matched\"),\n+    _ => panic!(\"didn't match\")\n+  };\n+}"}]}