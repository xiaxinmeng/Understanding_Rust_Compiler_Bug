{"sha": "97c1711894ec3d8dfabe04f8e7218e86496b1ff9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3YzE3MTE4OTRlYzNkOGRmYWJlMDRmOGU3MjE4ZTg2NDk2YjFmZjk=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2015-02-19T14:27:25Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-02-22T11:01:58Z"}, "message": "Distinguish between AST and various Dummy nodes in CFG.\n\n(Factoring of aatch CFG code, Part 1.)", "tree": {"sha": "43c1e358aacddc352f97a212b5c12f1e209b1e3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43c1e358aacddc352f97a212b5c12f1e209b1e3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97c1711894ec3d8dfabe04f8e7218e86496b1ff9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97c1711894ec3d8dfabe04f8e7218e86496b1ff9", "html_url": "https://github.com/rust-lang/rust/commit/97c1711894ec3d8dfabe04f8e7218e86496b1ff9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97c1711894ec3d8dfabe04f8e7218e86496b1ff9/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "html_url": "https://github.com/rust-lang/rust/commit/eb1b500a9a69b149295c37c2fe2c9409f406f9ea"}], "stats": {"total": 111, "additions": 65, "deletions": 46}, "files": [{"sha": "6d34d546f3d1f46f99d8b1deff9f2c4ac6c30c73", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97c1711894ec3d8dfabe04f8e7218e86496b1ff9/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c1711894ec3d8dfabe04f8e7218e86496b1ff9/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=97c1711894ec3d8dfabe04f8e7218e86496b1ff9", "patch": "@@ -1848,7 +1848,7 @@ impl LintPass for UnconditionalRecursion {\n                 continue\n             }\n             visited.insert(cfg_id);\n-            let node_id = cfg.graph.node_data(idx).id;\n+            let node_id = cfg.graph.node_data(idx).id();\n \n             // is this a recursive call?\n             if node_id != ast::DUMMY_NODE_ID && checker(cx.tcx, impl_node_id, id, name, node_id) {"}, {"sha": "e8df9dfa1b17b7da4e04f3bcc5139134f914ffbc", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 39, "deletions": 34, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/97c1711894ec3d8dfabe04f8e7218e86496b1ff9/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c1711894ec3d8dfabe04f8e7218e86496b1ff9/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=97c1711894ec3d8dfabe04f8e7218e86496b1ff9", "patch": "@@ -36,13 +36,13 @@ struct LoopScope {\n pub fn construct(tcx: &ty::ctxt,\n                  blk: &ast::Block) -> CFG {\n     let mut graph = graph::Graph::new();\n-    let entry = add_initial_dummy_node(&mut graph);\n+    let entry = graph.add_node(CFGNodeData::Entry);\n \n     // `fn_exit` is target of return exprs, which lies somewhere\n     // outside input `blk`. (Distinguishing `fn_exit` and `block_exit`\n     // also resolves chicken-and-egg problem that arises if you try to\n     // have return exprs jump to `block_exit` during construction.)\n-    let fn_exit = add_initial_dummy_node(&mut graph);\n+    let fn_exit = graph.add_node(CFGNodeData::Exit);\n     let block_exit;\n \n     let mut cfg_builder = CFGBuilder {\n@@ -61,10 +61,6 @@ pub fn construct(tcx: &ty::ctxt,\n          exit: fn_exit}\n }\n \n-fn add_initial_dummy_node(g: &mut CFGGraph) -> CFGIndex {\n-    g.add_node(CFGNodeData { id: ast::DUMMY_NODE_ID })\n-}\n-\n impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn block(&mut self, blk: &ast::Block, pred: CFGIndex) -> CFGIndex {\n         let mut stmts_exit = pred;\n@@ -74,19 +70,19 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n         let expr_exit = self.opt_expr(&blk.expr, stmts_exit);\n \n-        self.add_node(blk.id, &[expr_exit])\n+        self.add_ast_node(blk.id, &[expr_exit])\n     }\n \n     fn stmt(&mut self, stmt: &ast::Stmt, pred: CFGIndex) -> CFGIndex {\n         match stmt.node {\n             ast::StmtDecl(ref decl, id) => {\n                 let exit = self.decl(&**decl, pred);\n-                self.add_node(id, &[exit])\n+                self.add_ast_node(id, &[exit])\n             }\n \n             ast::StmtExpr(ref expr, id) | ast::StmtSemi(ref expr, id) => {\n                 let exit = self.expr(&**expr, pred);\n-                self.add_node(id, &[exit])\n+                self.add_ast_node(id, &[exit])\n             }\n \n             ast::StmtMac(..) => {\n@@ -115,33 +111,33 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             ast::PatLit(..) |\n             ast::PatRange(..) |\n             ast::PatWild(_) => {\n-                self.add_node(pat.id, &[pred])\n+                self.add_ast_node(pat.id, &[pred])\n             }\n \n             ast::PatBox(ref subpat) |\n             ast::PatRegion(ref subpat, _) |\n             ast::PatIdent(_, _, Some(ref subpat)) => {\n                 let subpat_exit = self.pat(&**subpat, pred);\n-                self.add_node(pat.id, &[subpat_exit])\n+                self.add_ast_node(pat.id, &[subpat_exit])\n             }\n \n             ast::PatEnum(_, Some(ref subpats)) |\n             ast::PatTup(ref subpats) => {\n                 let pats_exit = self.pats_all(subpats.iter(), pred);\n-                self.add_node(pat.id, &[pats_exit])\n+                self.add_ast_node(pat.id, &[pats_exit])\n             }\n \n             ast::PatStruct(_, ref subpats, _) => {\n                 let pats_exit =\n                     self.pats_all(subpats.iter().map(|f| &f.node.pat), pred);\n-                self.add_node(pat.id, &[pats_exit])\n+                self.add_ast_node(pat.id, &[pats_exit])\n             }\n \n             ast::PatVec(ref pre, ref vec, ref post) => {\n                 let pre_exit = self.pats_all(pre.iter(), pred);\n                 let vec_exit = self.pats_all(vec.iter(), pre_exit);\n                 let post_exit = self.pats_all(post.iter(), vec_exit);\n-                self.add_node(pat.id, &[post_exit])\n+                self.add_ast_node(pat.id, &[post_exit])\n             }\n \n             ast::PatMac(_) => {\n@@ -178,7 +174,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         match expr.node {\n             ast::ExprBlock(ref blk) => {\n                 let blk_exit = self.block(&**blk, pred);\n-                self.add_node(expr.id, &[blk_exit])\n+                self.add_ast_node(expr.id, &[blk_exit])\n             }\n \n             ast::ExprIf(ref cond, ref then, None) => {\n@@ -198,7 +194,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //\n                 let cond_exit = self.expr(&**cond, pred);                // 1\n                 let then_exit = self.block(&**then, cond_exit);          // 2\n-                self.add_node(expr.id, &[cond_exit, then_exit])          // 3,4\n+                self.add_ast_node(expr.id, &[cond_exit, then_exit])      // 3,4\n             }\n \n             ast::ExprIf(ref cond, ref then, Some(ref otherwise)) => {\n@@ -219,7 +215,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 let cond_exit = self.expr(&**cond, pred);                // 1\n                 let then_exit = self.block(&**then, cond_exit);          // 2\n                 let else_exit = self.expr(&**otherwise, cond_exit);      // 3\n-                self.add_node(expr.id, &[then_exit, else_exit])          // 4, 5\n+                self.add_ast_node(expr.id, &[then_exit, else_exit])      // 4, 5\n             }\n \n             ast::ExprIfLet(..) => {\n@@ -247,7 +243,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 // Is the condition considered part of the loop?\n                 let loopback = self.add_dummy_node(&[pred]);              // 1\n                 let cond_exit = self.expr(&**cond, loopback);             // 2\n-                let expr_exit = self.add_node(expr.id, &[cond_exit]);     // 3\n+                let expr_exit = self.add_ast_node(expr.id, &[cond_exit]); // 3\n                 self.loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n                     continue_index: loopback,\n@@ -283,7 +279,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 // may cause additional edges.\n \n                 let loopback = self.add_dummy_node(&[pred]);              // 1\n-                let expr_exit = self.add_node(expr.id, &[]);              // 2\n+                let expr_exit = self.add_ast_node(expr.id, &[]);          // 2\n                 self.loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n                     continue_index: loopback,\n@@ -323,7 +319,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //\n                 let discr_exit = self.expr(&**discr, pred);              // 1\n \n-                let expr_exit = self.add_node(expr.id, &[]);\n+                let expr_exit = self.add_ast_node(expr.id, &[]);\n                 let mut cond_exit = discr_exit;\n                 for arm in arms {\n                     cond_exit = self.add_dummy_node(&[cond_exit]);        // 2\n@@ -354,30 +350,30 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //\n                 let l_exit = self.expr(&**l, pred);                      // 1\n                 let r_exit = self.expr(&**r, l_exit);                    // 2\n-                self.add_node(expr.id, &[l_exit, r_exit])                 // 3,4\n+                self.add_ast_node(expr.id, &[l_exit, r_exit])            // 3,4\n             }\n \n             ast::ExprRet(ref v) => {\n                 let v_exit = self.opt_expr(v, pred);\n-                let b = self.add_node(expr.id, &[v_exit]);\n+                let b = self.add_ast_node(expr.id, &[v_exit]);\n                 self.add_returning_edge(expr, b);\n-                self.add_node(ast::DUMMY_NODE_ID, &[])\n+                self.add_unreachable_node()\n             }\n \n             ast::ExprBreak(label) => {\n                 let loop_scope = self.find_scope(expr, label);\n-                let b = self.add_node(expr.id, &[pred]);\n+                let b = self.add_ast_node(expr.id, &[pred]);\n                 self.add_exiting_edge(expr, b,\n                                       loop_scope, loop_scope.break_index);\n-                self.add_node(ast::DUMMY_NODE_ID, &[])\n+                self.add_unreachable_node()\n             }\n \n             ast::ExprAgain(label) => {\n                 let loop_scope = self.find_scope(expr, label);\n-                let a = self.add_node(expr.id, &[pred]);\n+                let a = self.add_ast_node(expr.id, &[pred]);\n                 self.add_exiting_edge(expr, a,\n                                       loop_scope, loop_scope.continue_index);\n-                self.add_node(ast::DUMMY_NODE_ID, &[])\n+                self.add_unreachable_node()\n             }\n \n             ast::ExprVec(ref elems) => {\n@@ -454,7 +450,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                     let &(_, ref expr, _) = a;\n                     &**expr\n                 }), post_inputs);\n-                self.add_node(expr.id, &[post_outputs])\n+                self.add_ast_node(expr.id, &[post_outputs])\n             }\n \n             ast::ExprMac(..) |\n@@ -481,7 +477,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n         if return_ty.diverges() {\n-            self.add_node(ast::DUMMY_NODE_ID, &[])\n+            self.add_unreachable_node()\n         } else {\n             ret\n         }\n@@ -508,17 +504,26 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         //! Handles case of an expression that evaluates `subexprs` in order\n \n         let subexprs_exit = self.exprs(subexprs, pred);\n-        self.add_node(expr.id, &[subexprs_exit])\n+        self.add_ast_node(expr.id, &[subexprs_exit])\n     }\n \n     fn add_dummy_node(&mut self, preds: &[CFGIndex]) -> CFGIndex {\n-        self.add_node(ast::DUMMY_NODE_ID, preds)\n+        self.add_node(CFGNodeData::Dummy, preds)\n     }\n \n-    fn add_node(&mut self, id: ast::NodeId, preds: &[CFGIndex]) -> CFGIndex {\n+    fn add_ast_node(&mut self, id: ast::NodeId, preds: &[CFGIndex]) -> CFGIndex {\n         assert!(!self.exit_map.contains_key(&id));\n-        let node = self.graph.add_node(CFGNodeData {id: id});\n-        if id != ast::DUMMY_NODE_ID {\n+        assert!(id != ast::DUMMY_NODE_ID);\n+        self.add_node(CFGNodeData::AST(id), preds)\n+    }\n+\n+    fn add_unreachable_node(&mut self) -> CFGIndex {\n+        self.add_node(CFGNodeData::Unreachable, &[])\n+    }\n+\n+    fn add_node(&mut self, data: CFGNodeData, preds: &[CFGIndex]) -> CFGIndex {\n+        let node = self.graph.add_node(data);\n+        if let CFGNodeData::AST(id) = data {\n             assert!(!self.exit_map.contains_key(&id));\n             self.exit_map.insert(id, node);\n         }"}, {"sha": "0c5eca3c12968ee3b93d6b31371109271ef572c0", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97c1711894ec3d8dfabe04f8e7218e86496b1ff9/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c1711894ec3d8dfabe04f8e7218e86496b1ff9/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=97c1711894ec3d8dfabe04f8e7218e86496b1ff9", "patch": "@@ -65,10 +65,10 @@ impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n             dot::LabelText::LabelStr(\"entry\".into_cow())\n         } else if i == self.cfg.exit {\n             dot::LabelText::LabelStr(\"exit\".into_cow())\n-        } else if n.data.id == ast::DUMMY_NODE_ID {\n+        } else if n.data.id() == ast::DUMMY_NODE_ID {\n             dot::LabelText::LabelStr(\"(dummy_node)\".into_cow())\n         } else {\n-            let s = self.ast_map.node_to_string(n.data.id);\n+            let s = self.ast_map.node_to_string(n.data.id());\n             // left-aligns the lines\n             let s = replace_newline_with_backslash_l(s);\n             dot::LabelText::EscStr(s.into_cow())"}, {"sha": "71f6c738522ad494fa2af42a9cb59902e3186993", "filename": "src/librustc/middle/cfg/mod.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/97c1711894ec3d8dfabe04f8e7218e86496b1ff9/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c1711894ec3d8dfabe04f8e7218e86496b1ff9/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs?ref=97c1711894ec3d8dfabe04f8e7218e86496b1ff9", "patch": "@@ -26,9 +26,23 @@ pub struct CFG {\n     pub exit: CFGIndex,\n }\n \n-#[derive(Copy)]\n-pub struct CFGNodeData {\n-    pub id: ast::NodeId\n+#[derive(Copy, PartialEq)]\n+pub enum CFGNodeData {\n+    AST(ast::NodeId),\n+    Entry,\n+    Exit,\n+    Dummy,\n+    Unreachable,\n+}\n+\n+impl CFGNodeData {\n+    pub fn id(&self) -> ast::NodeId {\n+        if let CFGNodeData::AST(id) = *self {\n+            id\n+        } else {\n+            ast::DUMMY_NODE_ID\n+        }\n+    }\n }\n \n pub struct CFGEdgeData {\n@@ -50,6 +64,6 @@ impl CFG {\n     }\n \n     pub fn node_is_reachable(&self, id: ast::NodeId) -> bool {\n-        self.graph.depth_traverse(self.entry).any(|node| node.id == id)\n+        self.graph.depth_traverse(self.entry).any(|node| node.id() == id)\n     }\n }"}, {"sha": "3f0555e93e6255d6c4455f0913d9561217e401b1", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97c1711894ec3d8dfabe04f8e7218e86496b1ff9/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c1711894ec3d8dfabe04f8e7218e86496b1ff9/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=97c1711894ec3d8dfabe04f8e7218e86496b1ff9", "patch": "@@ -157,8 +157,8 @@ fn build_nodeid_to_index(decl: Option<&ast::FnDecl>,\n     }\n \n     cfg.graph.each_node(|node_idx, node| {\n-        if node.data.id != ast::DUMMY_NODE_ID {\n-            index.insert(node.data.id, node_idx);\n+        if node.data.id() != ast::DUMMY_NODE_ID {\n+            index.insert(node.data.id(), node_idx);\n         }\n         true\n     });\n@@ -482,7 +482,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n \n         cfg.graph.each_node(|node_index, node| {\n             debug!(\"DataFlowContext::walk_cfg idx={:?} id={} begin in_out={}\",\n-                   node_index, node.data.id, bits_to_string(in_out));\n+                   node_index, node.data.id(), bits_to_string(in_out));\n \n             let (start, end) = self.dfcx.compute_id_range(node_index);\n "}, {"sha": "a2c9930c0ed2fdc36f4469af01af05eb292f4c28", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97c1711894ec3d8dfabe04f8e7218e86496b1ff9/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c1711894ec3d8dfabe04f8e7218e86496b1ff9/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=97c1711894ec3d8dfabe04f8e7218e86496b1ff9", "patch": "@@ -52,7 +52,7 @@ pub struct DataflowLabeller<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n     fn dataflow_for(&self, e: EntryOrExit, n: &Node<'a>) -> String {\n-        let id = n.1.data.id;\n+        let id = n.1.data.id();\n         debug!(\"dataflow_for({:?}, id={}) {:?}\", e, id, self.variants);\n         let mut sets = \"\".to_string();\n         let mut seen_one = false;"}, {"sha": "b520031d65c1bfc4ad9f1c7fa02d986e3f1e0a6c", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97c1711894ec3d8dfabe04f8e7218e86496b1ff9/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c1711894ec3d8dfabe04f8e7218e86496b1ff9/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=97c1711894ec3d8dfabe04f8e7218e86496b1ff9", "patch": "@@ -1353,7 +1353,7 @@ fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>)\n // the clobbering of the existing value in the return slot.\n fn has_nested_returns(tcx: &ty::ctxt, cfg: &cfg::CFG, blk_id: ast::NodeId) -> bool {\n     for n in cfg.graph.depth_traverse(cfg.entry) {\n-        match tcx.map.find(n.id) {\n+        match tcx.map.find(n.id()) {\n             Some(ast_map::NodeExpr(ex)) => {\n                 if let ast::ExprRet(Some(ref ret_expr)) = ex.node {\n                     let mut visitor = FindNestedReturn::new();"}]}