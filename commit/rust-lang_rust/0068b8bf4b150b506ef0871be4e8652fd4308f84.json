{"sha": "0068b8bf4b150b506ef0871be4e8652fd4308f84", "node_id": "C_kwDOAAsO6NoAKDAwNjhiOGJmNGIxNTBiNTA2ZWYwODcxYmU0ZTg2NTJmZDQzMDhmODQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-12T13:51:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-12T13:51:26Z"}, "message": "Auto merge of #100328 - davidtwco:perf-implications, r=nnethercote\n\npasses: load `defined_lib_features` query less\n\nHopefully addresses the perf regressions from #99212 (see #99905).\n\nRe-structure the stability checks for library features to avoid calling `defined_lib_features` for any more crates than necessary for each of the implications or local feature attributes that need validation.\n\nr? `@ghost` (just checking perf at first)", "tree": {"sha": "a928f68ed4abd803d24799108db4238c85b7e210", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a928f68ed4abd803d24799108db4238c85b7e210"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0068b8bf4b150b506ef0871be4e8652fd4308f84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0068b8bf4b150b506ef0871be4e8652fd4308f84", "html_url": "https://github.com/rust-lang/rust/commit/0068b8bf4b150b506ef0871be4e8652fd4308f84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0068b8bf4b150b506ef0871be4e8652fd4308f84/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "569788e47ee3595c9c6f0e332844d982b3e991c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/569788e47ee3595c9c6f0e332844d982b3e991c2", "html_url": "https://github.com/rust-lang/rust/commit/569788e47ee3595c9c6f0e332844d982b3e991c2"}, {"sha": "5e2e478a470b0fd535600901e5ce579c1deb34ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e2e478a470b0fd535600901e5ce579c1deb34ca", "html_url": "https://github.com/rust-lang/rust/commit/5e2e478a470b0fd535600901e5ce579c1deb34ca"}], "stats": {"total": 127, "additions": 91, "deletions": 36}, "files": [{"sha": "34afea0f02e90dcd3dede3e7e670cf77cbaf19be", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 91, "deletions": 36, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/0068b8bf4b150b506ef0871be4e8652fd4308f84/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0068b8bf4b150b506ef0871be4e8652fd4308f84/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=0068b8bf4b150b506ef0871be4e8652fd4308f84", "patch": "@@ -962,58 +962,113 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n     remaining_lib_features.remove(&sym::libc);\n     remaining_lib_features.remove(&sym::test);\n \n-    // We always collect the lib features declared in the current crate, even if there are\n-    // no unknown features, because the collection also does feature attribute validation.\n-    let local_defined_features = tcx.lib_features(());\n-    let mut all_lib_features: FxHashMap<_, _> =\n-        local_defined_features.to_vec().iter().map(|el| *el).collect();\n-    let mut implications = tcx.stability_implications(rustc_hir::def_id::LOCAL_CRATE).clone();\n-    for &cnum in tcx.crates(()) {\n-        implications.extend(tcx.stability_implications(cnum));\n-        all_lib_features.extend(tcx.defined_lib_features(cnum).iter().map(|el| *el));\n-    }\n-\n-    // Check that every feature referenced by an `implied_by` exists (for features defined in the\n-    // local crate).\n-    for (implied_by, feature) in tcx.stability_implications(rustc_hir::def_id::LOCAL_CRATE) {\n-        // Only `implied_by` needs to be checked, `feature` is guaranteed to exist.\n-        if !all_lib_features.contains_key(implied_by) {\n-            let span = local_defined_features\n-                .stable\n-                .get(feature)\n-                .map(|(_, span)| span)\n-                .or_else(|| local_defined_features.unstable.get(feature))\n-                .expect(\"feature that implied another does not exist\");\n-            tcx.sess\n-                .struct_span_err(\n-                    *span,\n-                    format!(\"feature `{implied_by}` implying `{feature}` does not exist\"),\n-                )\n-                .emit();\n-        }\n-    }\n-\n-    if !remaining_lib_features.is_empty() {\n-        for (feature, since) in all_lib_features.iter() {\n+    /// For each feature in `defined_features`..\n+    ///\n+    /// - If it is in `remaining_lib_features` (those features with `#![feature(..)]` attributes in\n+    ///   the current crate), check if it is stable (or partially stable) and thus an unnecessary\n+    ///   attribute.\n+    /// - If it is in `remaining_implications` (a feature that is referenced by an `implied_by`\n+    ///   from the current crate), then remove it from the remaining implications.\n+    ///\n+    /// Once this function has been invoked for every feature (local crate and all extern crates),\n+    /// then..\n+    ///\n+    /// - If features remain in `remaining_lib_features`, then the user has enabled a feature that\n+    ///   does not exist.\n+    /// - If features remain in `remaining_implications`, the `implied_by` refers to a feature that\n+    ///   does not exist.\n+    ///\n+    /// By structuring the code in this way: checking the features defined from each crate one at a\n+    /// time, less loading from metadata is performed and thus compiler performance is improved.\n+    fn check_features<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        remaining_lib_features: &mut FxIndexMap<&Symbol, Span>,\n+        remaining_implications: &mut FxHashMap<Symbol, Symbol>,\n+        defined_features: &[(Symbol, Option<Symbol>)],\n+        all_implications: &FxHashMap<Symbol, Symbol>,\n+    ) {\n+        for (feature, since) in defined_features {\n             if let Some(since) = since && let Some(span) = remaining_lib_features.get(&feature) {\n                 // Warn if the user has enabled an already-stable lib feature.\n-                if let Some(implies) = implications.get(&feature) {\n+                if let Some(implies) = all_implications.get(&feature) {\n                     unnecessary_partially_stable_feature_lint(tcx, *span, *feature, *implies, *since);\n                 } else {\n                     unnecessary_stable_feature_lint(tcx, *span, *feature, *since);\n                 }\n+\n             }\n-            remaining_lib_features.remove(&feature);\n-            if remaining_lib_features.is_empty() {\n+            remaining_lib_features.remove(feature);\n+\n+            // `feature` is the feature doing the implying, but `implied_by` is the feature with\n+            // the attribute that establishes this relationship. `implied_by` is guaranteed to be a\n+            // feature defined in the local crate because `remaining_implications` is only the\n+            // implications from this crate.\n+            remaining_implications.remove(feature);\n+\n+            if remaining_lib_features.is_empty() && remaining_implications.is_empty() {\n                 break;\n             }\n         }\n     }\n \n+    // All local crate implications need to have the feature that implies it confirmed to exist.\n+    let mut remaining_implications =\n+        tcx.stability_implications(rustc_hir::def_id::LOCAL_CRATE).clone();\n+\n+    // We always collect the lib features declared in the current crate, even if there are\n+    // no unknown features, because the collection also does feature attribute validation.\n+    let local_defined_features = tcx.lib_features(()).to_vec();\n+    if !remaining_lib_features.is_empty() || !remaining_implications.is_empty() {\n+        // Loading the implications of all crates is unavoidable to be able to emit the partial\n+        // stabilization diagnostic, but it can be avoided when there are no\n+        // `remaining_lib_features`.\n+        let mut all_implications = remaining_implications.clone();\n+        for &cnum in tcx.crates(()) {\n+            all_implications.extend(tcx.stability_implications(cnum));\n+        }\n+\n+        check_features(\n+            tcx,\n+            &mut remaining_lib_features,\n+            &mut remaining_implications,\n+            local_defined_features.as_slice(),\n+            &all_implications,\n+        );\n+\n+        for &cnum in tcx.crates(()) {\n+            if remaining_lib_features.is_empty() && remaining_implications.is_empty() {\n+                break;\n+            }\n+            check_features(\n+                tcx,\n+                &mut remaining_lib_features,\n+                &mut remaining_implications,\n+                tcx.defined_lib_features(cnum).to_vec().as_slice(),\n+                &all_implications,\n+            );\n+        }\n+    }\n+\n     for (feature, span) in remaining_lib_features {\n         struct_span_err!(tcx.sess, span, E0635, \"unknown feature `{}`\", feature).emit();\n     }\n \n+    for (implied_by, feature) in remaining_implications {\n+        let local_defined_features = tcx.lib_features(());\n+        let span = local_defined_features\n+            .stable\n+            .get(&feature)\n+            .map(|(_, span)| span)\n+            .or_else(|| local_defined_features.unstable.get(&feature))\n+            .expect(\"feature that implied another does not exist\");\n+        tcx.sess\n+            .struct_span_err(\n+                *span,\n+                format!(\"feature `{implied_by}` implying `{feature}` does not exist\"),\n+            )\n+            .emit();\n+    }\n+\n     // FIXME(#44232): the `used_features` table no longer exists, so we\n     // don't lint about unused features. We should re-enable this one day!\n }"}]}