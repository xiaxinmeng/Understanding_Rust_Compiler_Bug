{"sha": "0b15a66a806a8f46af6ae24f640814f3a69eddfb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiMTVhNjZhODA2YThmNDZhZjZhZTI0ZjY0MDgxNGYzYTY5ZWRkZmI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-06-17T12:40:50Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-07-02T16:25:21Z"}, "message": "account for the pick-constraint edges when reporting errors\n\nAlso, thread through better span info to improve the error message to\nsomething tolerable.", "tree": {"sha": "adff2b234ec2f0f5029b7a2944f9651db672e70d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/adff2b234ec2f0f5029b7a2944f9651db672e70d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b15a66a806a8f46af6ae24f640814f3a69eddfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b15a66a806a8f46af6ae24f640814f3a69eddfb", "html_url": "https://github.com/rust-lang/rust/commit/0b15a66a806a8f46af6ae24f640814f3a69eddfb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b15a66a806a8f46af6ae24f640814f3a69eddfb/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e01c7416a091dc29dd0d349fafb6cc5d3c4d97c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e01c7416a091dc29dd0d349fafb6cc5d3c4d97c", "html_url": "https://github.com/rust-lang/rust/commit/3e01c7416a091dc29dd0d349fafb6cc5d3c4d97c"}], "stats": {"total": 213, "additions": 195, "deletions": 18}, "files": [{"sha": "6f13cd8162965900f0df960c746f5d23a31c9b95", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b15a66a806a8f46af6ae24f640814f3a69eddfb/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b15a66a806a8f46af6ae24f640814f3a69eddfb/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=0b15a66a806a8f46af6ae24f640814f3a69eddfb", "patch": "@@ -910,13 +910,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn pick_constraint(\n         &self,\n         opaque_type_def_id: DefId,\n+        definition_span: Span,\n         hidden_ty: Ty<'tcx>,\n         region: ty::Region<'tcx>,\n         in_regions: &Rc<Vec<ty::Region<'tcx>>>,\n     ) {\n         debug!(\"sub_regions({:?} <: {:?})\", region, in_regions);\n         self.borrow_region_constraints()\n-            .pick_constraint(opaque_type_def_id, hidden_ty, region, in_regions);\n+            .pick_constraint(opaque_type_def_id, definition_span, hidden_ty, region, in_regions);\n     }\n \n     pub fn subtype_predicate("}, {"sha": "9a339db047d3388d6bbd95ed2ca9cb6c34a107c8", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0b15a66a806a8f46af6ae24f640814f3a69eddfb/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b15a66a806a8f46af6ae24f640814f3a69eddfb/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=0b15a66a806a8f46af6ae24f640814f3a69eddfb", "patch": "@@ -12,6 +12,7 @@ use crate::util::nodemap::DefIdMap;\n use errors::DiagnosticBuilder;\n use rustc_data_structures::fx::FxHashMap;\n use std::rc::Rc;\n+use syntax_pos::Span;\n \n pub type OpaqueTypeMap<'tcx> = DefIdMap<OpaqueTypeDecl<'tcx>>;\n \n@@ -33,6 +34,20 @@ pub struct OpaqueTypeDecl<'tcx> {\n     /// then `substs` would be `['a, T]`.\n     pub substs: SubstsRef<'tcx>,\n \n+    /// The span of this particular definition of the opaque type.  So\n+    /// for example:\n+    ///\n+    /// ```\n+    /// existential type Foo;\n+    /// fn bar() -> Foo {\n+    ///             ^^^ this is the span we are looking for!\n+    /// ```\n+    ///\n+    /// In cases where the fn returns `(impl Trait, impl Trait)` or\n+    /// other such combinations, the result is currently\n+    /// over-approximated, but better than nothing.\n+    pub definition_span: Span,\n+\n     /// The type variable that represents the value of the abstract type\n     /// that we require. In other words, after we compile this function,\n     /// we will be created a constraint like:\n@@ -99,12 +114,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// - `param_env` -- the in-scope parameter environment to be used for\n     ///   obligations\n     /// - `value` -- the value within which we are instantiating opaque types\n+    /// - `value_span` -- the span where the value came from, used in error reporting\n     pub fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n         &self,\n         parent_def_id: DefId,\n         body_id: hir::HirId,\n         param_env: ty::ParamEnv<'tcx>,\n         value: &T,\n+        value_span: Span,\n     ) -> InferOk<'tcx, (T, OpaqueTypeMap<'tcx>)> {\n         debug!(\n             \"instantiate_opaque_types(value={:?}, parent_def_id={:?}, body_id={:?}, \\\n@@ -116,6 +133,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             parent_def_id,\n             body_id,\n             param_env,\n+            value_span,\n             opaque_types: Default::default(),\n             obligations: vec![],\n         };\n@@ -427,6 +445,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             tcx: self.tcx,\n             op: |r| self.pick_constraint(\n                 opaque_type_def_id,\n+                opaque_defn.definition_span,\n                 concrete_ty,\n                 r,\n                 &option_regions,\n@@ -807,6 +826,7 @@ struct Instantiator<'a, 'tcx> {\n     parent_def_id: DefId,\n     body_id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n+    value_span: Span,\n     opaque_types: OpaqueTypeMap<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,\n }\n@@ -954,10 +974,18 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         debug!(\"instantiate_opaque_types: param_env={:#?}\", self.param_env,);\n         debug!(\"instantiate_opaque_types: generics={:#?}\", tcx.generics_of(def_id),);\n \n+        // Ideally, we'd get the span where *this specific `ty` came\n+        // from*, but right now we just use the span from the overall\n+        // value being folded. In simple cases like `-> impl Foo`,\n+        // these are the same span, but not in cases like `-> (impl\n+        // Foo, impl Bar)`.\n+        let definition_span = self.value_span;\n+\n         self.opaque_types.insert(\n             def_id,\n             OpaqueTypeDecl {\n                 substs,\n+                definition_span,\n                 concrete_ty: ty_var,\n                 has_required_region_bounds: !required_region_bounds.is_empty(),\n                 origin,"}, {"sha": "1558022fd3172e1b93fb27e95f4fcde83f5b0c38", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0b15a66a806a8f46af6ae24f640814f3a69eddfb/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b15a66a806a8f46af6ae24f640814f3a69eddfb/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=0b15a66a806a8f46af6ae24f640814f3a69eddfb", "patch": "@@ -14,6 +14,7 @@ use crate::ty::ReStatic;\n use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::{ReLateBound, ReVar};\n use crate::ty::{Region, RegionVid};\n+use syntax_pos::Span;\n \n use std::collections::BTreeMap;\n use std::{cmp, fmt, mem};\n@@ -155,6 +156,9 @@ pub struct PickConstraint<'tcx> {\n     /// the def-id of the opaque type causing this constraint: used for error reporting\n     pub opaque_type_def_id: DefId,\n \n+    /// the span where the hidden type was instantiated\n+    pub definition_span: Span,\n+\n     /// the hidden type in which `pick_region` appears: used for error reporting\n     pub hidden_ty: Ty<'tcx>,\n \n@@ -167,14 +171,14 @@ pub struct PickConstraint<'tcx> {\n \n BraceStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for PickConstraint<'tcx> {\n-        opaque_type_def_id, hidden_ty, pick_region, option_regions\n+        opaque_type_def_id, definition_span, hidden_ty, pick_region, option_regions\n     }\n }\n \n BraceStructLiftImpl! {\n     impl<'a, 'tcx> Lift<'tcx> for PickConstraint<'a> {\n         type Lifted = PickConstraint<'tcx>;\n-        opaque_type_def_id, hidden_ty, pick_region, option_regions\n+        opaque_type_def_id, definition_span, hidden_ty, pick_region, option_regions\n     }\n }\n \n@@ -687,6 +691,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     pub fn pick_constraint(\n         &mut self,\n         opaque_type_def_id: DefId,\n+        definition_span: Span,\n         hidden_ty: Ty<'tcx>,\n         pick_region: ty::Region<'tcx>,\n         option_regions: &Rc<Vec<ty::Region<'tcx>>>,\n@@ -699,6 +704,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n         self.data.pick_constraints.push(PickConstraint {\n             opaque_type_def_id,\n+            definition_span,\n             hidden_ty,\n             pick_region,\n             option_regions: option_regions.clone()"}, {"sha": "aa0f7852273abff96310cbc32d62a8c093a8df67", "filename": "src/librustc_mir/borrow_check/nll/pick_constraints.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b15a66a806a8f46af6ae24f640814f3a69eddfb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fpick_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b15a66a806a8f46af6ae24f640814f3a69eddfb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fpick_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fpick_constraints.rs?ref=0b15a66a806a8f46af6ae24f640814f3a69eddfb", "patch": "@@ -5,6 +5,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use std::hash::Hash;\n use std::ops::Index;\n+use syntax_pos::Span;\n \n /// Compactly stores a set of `pick R0 in [R1...Rn]` constraints,\n /// indexed by the region R0.\n@@ -34,6 +35,9 @@ crate struct NllPickConstraint<'tcx> {\n     /// The opaque type whose hidden type is being inferred. (Used in error reporting.)\n     crate opaque_type_def_id: DefId,\n \n+    /// The span where the hidden type was instantiated.\n+    crate definition_span: Span,\n+\n     /// The hidden type in which R0 appears. (Used in error reporting.)\n     crate hidden_ty: Ty<'tcx>,\n \n@@ -79,6 +83,7 @@ impl<'tcx> PickConstraintSet<'tcx, ty::RegionVid> {\n             next_constraint,\n             pick_region_vid,\n             opaque_type_def_id: p_c.opaque_type_def_id,\n+            definition_span: p_c.definition_span,\n             hidden_ty: p_c.hidden_ty,\n             start_index,\n             end_index,"}, {"sha": "34fd3427d326c771020be1f436576febee8d8ba1", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0b15a66a806a8f46af6ae24f640814f3a69eddfb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b15a66a806a8f46af6ae24f640814f3a69eddfb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=0b15a66a806a8f46af6ae24f640814f3a69eddfb", "patch": "@@ -1,4 +1,5 @@\n use crate::borrow_check::nll::constraints::OutlivesConstraint;\n+use crate::borrow_check::nll::region_infer::AppliedPickConstraint;\n use crate::borrow_check::nll::region_infer::RegionInferenceContext;\n use crate::borrow_check::nll::type_check::Locations;\n use crate::borrow_check::nll::universal_regions::DefiningTy;\n@@ -195,6 +196,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         Trace::NotVisited => {\n                             bug!(\"found unvisited region {:?} on path to {:?}\", p, r)\n                         }\n+\n                         Trace::FromOutlivesConstraint(c) => {\n                             result.push(c);\n                             p = c.sup;\n@@ -211,10 +213,30 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // Otherwise, walk over the outgoing constraints and\n             // enqueue any regions we find, keeping track of how we\n             // reached them.\n+\n+            // A constraint like `'r: 'x` can come from our constraint\n+            // graph.\n             let fr_static = self.universal_regions.fr_static;\n-            for constraint in self.constraint_graph\n-                .outgoing_edges(r, &self.constraints, fr_static)\n-            {\n+            let outgoing_edges_from_graph = self.constraint_graph\n+                .outgoing_edges(r, &self.constraints, fr_static);\n+\n+\n+            // But pick-constraints can also give rise to `'r: 'x`\n+            // edges that were not part of the graph initially, so\n+            // watch out for those.\n+            let outgoing_edges_from_picks = self.applied_pick_constraints(r)\n+                .iter()\n+                .map(|&AppliedPickConstraint { best_option, pick_constraint_index, .. }| {\n+                    let p_c = &self.pick_constraints[pick_constraint_index];\n+                    OutlivesConstraint {\n+                        sup: r,\n+                        sub: best_option,\n+                        locations: Locations::All(p_c.definition_span),\n+                        category: ConstraintCategory::OpaqueType,\n+                    }\n+                });\n+\n+            for constraint in outgoing_edges_from_graph.chain(outgoing_edges_from_picks) {\n                 debug_assert_eq!(constraint.sup, r);\n                 let sub_region = constraint.sub;\n                 if let Trace::NotVisited = context[sub_region] {\n@@ -687,7 +709,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     // Finds some region R such that `fr1: R` and `R` is live at\n     // `elem`.\n-    crate fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n+    crate fn find_sub_region_live_at(\n+        &self,\n+        fr1: RegionVid,\n+        elem: Location,\n+    ) -> RegionVid {\n         debug!(\"find_sub_region_live_at(fr1={:?}, elem={:?})\", fr1, elem);\n         self.find_constraint_paths_between_regions(fr1, |r| {\n             // First look for some `r` such that `fr1: r` and `r` is live at `elem`\n@@ -729,8 +755,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         fr1: RegionVid,\n         fr2: RegionVid,\n     ) -> (ConstraintCategory, Span) {\n-        let (category, _, span) =\n-            self.best_blame_constraint(body, fr1, |r| self.provides_universal_region(r, fr1, fr2));\n+        let (category, _, span) = self.best_blame_constraint(\n+            body,\n+            fr1,\n+            |r| self.provides_universal_region(r, fr1, fr2),\n+        );\n         (category, span)\n     }\n "}, {"sha": "db519fad0d9e1054574a0f5ef7daea68cfe15323", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 66, "deletions": 6, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/0b15a66a806a8f46af6ae24f640814f3a69eddfb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b15a66a806a8f46af6ae24f640814f3a69eddfb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=0b15a66a806a8f46af6ae24f640814f3a69eddfb", "patch": "@@ -3,7 +3,7 @@ use crate::borrow_check::nll::constraints::graph::NormalConstraintGraph;\n use crate::borrow_check::nll::constraints::{\n     ConstraintSccIndex, OutlivesConstraint, OutlivesConstraintSet,\n };\n-use crate::borrow_check::nll::pick_constraints::PickConstraintSet;\n+use crate::borrow_check::nll::pick_constraints::{PickConstraintSet, NllPickConstraintIndex};\n use crate::borrow_check::nll::region_infer::values::{\n     PlaceholderIndices, RegionElement, ToElementIndex,\n };\n@@ -21,9 +21,10 @@ use rustc::mir::{\n };\n use rustc::ty::{self, subst::SubstsRef, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc::util::common::{self, ErrorReported};\n+use rustc_data_structures::binary_search_util;\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use crate::rustc_data_structures::graph::WithSuccessors;\n+use rustc_data_structures::graph::WithSuccessors;\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_data_structures::graph::vec_graph::VecGraph;\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -74,6 +75,12 @@ pub struct RegionInferenceContext<'tcx> {\n     /// The \"pick R0 from [R1..Rn]\" constraints, indexed by SCC.\n     pick_constraints: Rc<PickConstraintSet<'tcx, ConstraintSccIndex>>,\n \n+    /// Records the pick-constraints that we applied to each scc.\n+    /// This is useful for error reporting. Once constraint\n+    /// propagation is done, this vector is sorted according to\n+    /// `pick_region_scc`.\n+    pick_constraints_applied: Vec<AppliedPickConstraint>,\n+\n     /// Map closure bounds to a `Span` that should be used for error reporting.\n     closure_bounds_mapping:\n         FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n@@ -109,6 +116,32 @@ pub struct RegionInferenceContext<'tcx> {\n     universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n }\n \n+/// Each time that `apply_pick_constraint` is successful, it appends\n+/// one of these structs to the `pick_constraints_applied` field.\n+/// This is used in error reporting to trace out what happened.\n+///\n+/// The way that `apply_pick_constraint` works is that it effectively\n+/// adds a new lower bound to the SCC it is analyzing: so you wind up\n+/// with `'R: 'O` where `'R` is the pick-region and `'O` is the\n+/// minimal viable option.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]\n+struct AppliedPickConstraint {\n+    /// The SCC that was affected. (The \"pick region\".)\n+    ///\n+    /// The vector if `AppliedPickConstraint` elements is kept sorted\n+    /// by this field.\n+    pick_region_scc: ConstraintSccIndex,\n+\n+    /// The \"best option\" that `apply_pick_constraint` found -- this was\n+    /// added as an \"ad-hoc\" lower-bound to `pick_region_scc`.\n+    best_option: ty::RegionVid,\n+\n+    /// The \"pick constraint index\" -- we can find out details about\n+    /// the constraint from\n+    /// `set.pick_constraints[pick_constraint_index]`.\n+    pick_constraint_index: NllPickConstraintIndex,\n+}\n+\n struct RegionDefinition<'tcx> {\n     /// What kind of variable is this -- a free region? existential\n     /// variable? etc. (See the `NLLRegionVariableOrigin` for more\n@@ -243,6 +276,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             constraint_sccs,\n             rev_constraint_graph: None,\n             pick_constraints,\n+            pick_constraints_applied: Vec::new(),\n             closure_bounds_mapping,\n             scc_universes,\n             scc_representatives,\n@@ -411,6 +445,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.scc_universes[scc]\n     }\n \n+    /// Once region solving has completed, this function will return\n+    /// the pick-constraints that were applied to the value of a given\n+    /// region `r`. See `AppliedPickConstraint`.\n+    fn applied_pick_constraints(&self, r: impl ToRegionVid) -> &[AppliedPickConstraint] {\n+        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+        binary_search_util::binary_search_slice(\n+            &self.pick_constraints_applied,\n+            |applied| applied.pick_region_scc,\n+            &scc,\n+        )\n+    }\n+\n     /// Performs region inference and report errors if we see any\n     /// unsatisfiable constraints. If this is a closure, returns the\n     /// region requirements to propagate to our creator, if any.\n@@ -501,6 +547,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for scc_index in self.constraint_sccs.all_sccs() {\n             self.propagate_constraint_sccs_if_new(scc_index, visited);\n         }\n+\n+        // Sort the applied pick constraints so we can binary search\n+        // through them later.\n+        self.pick_constraints_applied.sort_by_key(|applied| applied.pick_region_scc);\n     }\n \n     /// Computes the value of the SCC `scc_a` if it has not already\n@@ -552,7 +602,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for p_c_i in pick_constraints.indices(scc_a) {\n             self.apply_pick_constraint(\n                 scc_a,\n-                pick_constraints[p_c_i].opaque_type_def_id,\n+                p_c_i,\n                 pick_constraints.option_regions(p_c_i),\n             );\n         }\n@@ -578,7 +628,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn apply_pick_constraint(\n         &mut self,\n         scc: ConstraintSccIndex,\n-        opaque_type_def_id: DefId,\n+        pick_constraint_index: NllPickConstraintIndex,\n         option_regions: &[ty::RegionVid],\n     ) -> bool {\n         debug!(\"apply_pick_constraint(scc={:?}, option_regions={:#?})\", scc, option_regions,);\n@@ -593,7 +643,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             bug!(\n                 \"pick constraint for `{:?}` has an option region `{:?}` \\\n                  that is not a universal region\",\n-                opaque_type_def_id,\n+                self.pick_constraints[pick_constraint_index].opaque_type_def_id,\n                 uh_oh,\n             );\n         }\n@@ -681,7 +731,17 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             best_option,\n             best_option_scc,\n         );\n-        self.scc_values.add_region(scc, best_option_scc)\n+        if self.scc_values.add_region(scc, best_option_scc) {\n+            self.pick_constraints_applied.push(AppliedPickConstraint {\n+                pick_region_scc: scc,\n+                best_option,\n+                pick_constraint_index,\n+            });\n+\n+            true\n+        } else {\n+            false\n+        }\n     }\n \n     /// Compute and return the reverse SCC-based constraint graph (lazilly)."}, {"sha": "09f9b5510d0db7ec223a493592be55ced4c513a6", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b15a66a806a8f46af6ae24f640814f3a69eddfb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b15a66a806a8f46af6ae24f640814f3a69eddfb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=0b15a66a806a8f46af6ae24f640814f3a69eddfb", "patch": "@@ -836,6 +836,7 @@ struct TypeChecker<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     last_span: Span,\n+    body: &'a Body<'tcx>,\n     /// User type annotations are shared between the main MIR and the MIR of\n     /// all of the promoted items.\n     user_type_annotations: &'a CanonicalUserTypeAnnotations<'tcx>,\n@@ -996,6 +997,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             infcx,\n             last_span: DUMMY_SP,\n             mir_def_id,\n+            body,\n             user_type_annotations: &body.user_type_annotations,\n             param_env,\n             region_bound_pairs,\n@@ -1233,6 +1235,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         let infcx = self.infcx;\n         let tcx = infcx.tcx;\n         let param_env = self.param_env;\n+        let body = self.body;\n         debug!(\"eq_opaque_type_and_type: mir_def_id={:?}\", self.mir_def_id);\n         let opaque_type_map = self.fully_perform_op(\n             locations,\n@@ -1248,6 +1251,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             dummy_body_id,\n                             param_env,\n                             &anon_ty,\n+                            locations.span(body),\n                         ));\n                     debug!(\n                         \"eq_opaque_type_and_type: \\"}, {"sha": "b0be37772af39b2a960c60cb63bf3aa4b406192b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0b15a66a806a8f46af6ae24f640814f3a69eddfb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b15a66a806a8f46af6ae24f640814f3a69eddfb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0b15a66a806a8f46af6ae24f640814f3a69eddfb", "patch": "@@ -856,7 +856,8 @@ fn typeck_tables_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ty::TypeckT\n             let revealed_ty = if tcx.features().impl_trait_in_bindings {\n                 fcx.instantiate_opaque_types_from_value(\n                     id,\n-                    &expected_type\n+                    &expected_type,\n+                    body.value.span,\n                 )\n             } else {\n                 expected_type\n@@ -962,7 +963,8 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n                 let revealed_ty = if self.fcx.tcx.features().impl_trait_in_bindings {\n                     self.fcx.instantiate_opaque_types_from_value(\n                         self.parent_id,\n-                        &o_ty\n+                        &o_ty,\n+                        ty.span,\n                     )\n                 } else {\n                     o_ty\n@@ -1058,7 +1060,11 @@ fn check_fn<'a, 'tcx>(\n \n     let declared_ret_ty = fn_sig.output();\n     fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n-    let revealed_ret_ty = fcx.instantiate_opaque_types_from_value(fn_id, &declared_ret_ty);\n+    let revealed_ret_ty = fcx.instantiate_opaque_types_from_value(\n+        fn_id,\n+        &declared_ret_ty,\n+        decl.output.span(),\n+    );\n     fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(revealed_ret_ty)));\n     fn_sig = fcx.tcx.mk_fn_sig(\n         fn_sig.inputs().iter().cloned(),\n@@ -2445,6 +2451,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         parent_id: hir::HirId,\n         value: &T,\n+        value_span: Span,\n     ) -> T {\n         let parent_def_id = self.tcx.hir().local_def_id_from_hir_id(parent_id);\n         debug!(\"instantiate_opaque_types_from_value(parent_def_id={:?}, value={:?})\",\n@@ -2457,6 +2464,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.body_id,\n                 self.param_env,\n                 value,\n+                value_span,\n             )\n         );\n "}, {"sha": "b4cbf0ba8ed44140147261d199c71a7dda6cae60", "filename": "src/test/ui/impl-trait/multiple-lifetimes/error-handling.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0b15a66a806a8f46af6ae24f640814f3a69eddfb/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b15a66a806a8f46af6ae24f640814f3a69eddfb/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.rs?ref=0b15a66a806a8f46af6ae24f640814f3a69eddfb", "patch": "@@ -0,0 +1,21 @@\n+// compile-flags:-Zborrowck=mir\n+\n+#![feature(existential_type)]\n+\n+#[derive(Clone)]\n+struct CopyIfEq<T, U>(T, U);\n+\n+impl<T: Copy> Copy for CopyIfEq<T, T> {}\n+\n+existential type E<'a, 'b>: Sized;\n+//~^ ERROR lifetime may not live long enough\n+\n+fn foo<'a, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n+    let v = CopyIfEq::<*mut _, *mut _>(&mut {x}, &mut y);\n+    let u = v;\n+    let _: *mut &'a i32 = u.1;\n+    unsafe { let _: &'b i32 = *u.0; }\n+    u.0\n+}\n+\n+fn main() {}"}, {"sha": "f42ec5b62f11ef80bbf4c77f4d318f8976d514c8", "filename": "src/test/ui/impl-trait/multiple-lifetimes/error-handling.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0b15a66a806a8f46af6ae24f640814f3a69eddfb/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b15a66a806a8f46af6ae24f640814f3a69eddfb/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.stderr?ref=0b15a66a806a8f46af6ae24f640814f3a69eddfb", "patch": "@@ -0,0 +1,15 @@\n+error: lifetime may not live long enough\n+  --> $DIR/error-handling.rs:10:1\n+   |\n+LL | existential type E<'a, 'b>: Sized;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ opaque type requires that `'a` must outlive `'static`\n+...\n+LL | fn foo<'a, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n+   |        -- lifetime `'a` defined here\n+help: to allow this `impl Trait` to capture borrowed data with lifetime `'a`, add `'a` as a constraint\n+   |\n+LL | existential type E<'a, 'b>: Sized; + 'a\n+   |\n+\n+error: aborting due to previous error\n+"}]}