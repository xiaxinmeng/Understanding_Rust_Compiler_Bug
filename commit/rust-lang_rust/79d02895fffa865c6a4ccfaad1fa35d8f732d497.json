{"sha": "79d02895fffa865c6a4ccfaad1fa35d8f732d497", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZDAyODk1ZmZmYTg2NWM2YTRjY2ZhYWQxZmEzNWQ4ZjczMmQ0OTc=", "commit": {"author": {"name": "Jared Roesch", "email": "roeschinc@gmail.com", "date": "2015-06-24T20:40:54Z"}, "committer": {"name": "Jared Roesch", "email": "roeschinc@gmail.com", "date": "2015-06-27T20:43:20Z"}, "message": "Begin refactor type checking state\n\nThis first patch starts by moving around pieces of state related to\ntype checking. The goal is to slowly unify the type checking state\ninto a single typing context. This initial patch moves the\nParameterEnvironment into the InferCtxt and moves shared tables\nfrom Inherited and ty::ctxt into their own struct Tables. This\nis the foundational work to refactoring the type checker to\nenable future evolution of the language and tooling.", "tree": {"sha": "584bc9abdae9e1949cbdd72494630b5db4fd15ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/584bc9abdae9e1949cbdd72494630b5db4fd15ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79d02895fffa865c6a4ccfaad1fa35d8f732d497", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79d02895fffa865c6a4ccfaad1fa35d8f732d497", "html_url": "https://github.com/rust-lang/rust/commit/79d02895fffa865c6a4ccfaad1fa35d8f732d497", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79d02895fffa865c6a4ccfaad1fa35d8f732d497/comments", "author": {"login": "jroesch", "id": 696509, "node_id": "MDQ6VXNlcjY5NjUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/696509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jroesch", "html_url": "https://github.com/jroesch", "followers_url": "https://api.github.com/users/jroesch/followers", "following_url": "https://api.github.com/users/jroesch/following{/other_user}", "gists_url": "https://api.github.com/users/jroesch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jroesch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jroesch/subscriptions", "organizations_url": "https://api.github.com/users/jroesch/orgs", "repos_url": "https://api.github.com/users/jroesch/repos", "events_url": "https://api.github.com/users/jroesch/events{/privacy}", "received_events_url": "https://api.github.com/users/jroesch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jroesch", "id": 696509, "node_id": "MDQ6VXNlcjY5NjUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/696509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jroesch", "html_url": "https://github.com/jroesch", "followers_url": "https://api.github.com/users/jroesch/followers", "following_url": "https://api.github.com/users/jroesch/following{/other_user}", "gists_url": "https://api.github.com/users/jroesch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jroesch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jroesch/subscriptions", "organizations_url": "https://api.github.com/users/jroesch/orgs", "repos_url": "https://api.github.com/users/jroesch/repos", "events_url": "https://api.github.com/users/jroesch/events{/privacy}", "received_events_url": "https://api.github.com/users/jroesch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ba46f8bbc6fdf10e434faea52b9ca20e0d9f2eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ba46f8bbc6fdf10e434faea52b9ca20e0d9f2eb", "html_url": "https://github.com/rust-lang/rust/commit/2ba46f8bbc6fdf10e434faea52b9ca20e0d9f2eb"}], "stats": {"total": 679, "additions": 427, "deletions": 252}, "files": [{"sha": "2cec42b76bce3359e8f772ea1bda80a492cbabd3", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -61,6 +61,7 @@\n #![feature(str_match_indices)]\n #![feature(vec_push_all)]\n #![feature(wrapping)]\n+#![feature(cell_extras)]\n #![cfg_attr(test, feature(test))]\n \n #![allow(trivial_casts)]"}, {"sha": "f2ae396173bc0c7e2b9ecb62a80f59f75e139be4", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -1027,7 +1027,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    if let Some(item_substs) = tcx.item_substs.borrow().get(&id) {\n+    if let Some(item_substs) = tcx.tables.borrow().item_substs.get(&id) {\n         rbml_w.tag(c::tag_table_item_subst, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.emit_substs(ecx, &item_substs.substs);\n@@ -1051,7 +1051,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                     var_id: var_id,\n                     closure_expr_id: id\n                 };\n-                let upvar_capture = tcx.upvar_capture_map.borrow().get(&upvar_id).unwrap().clone();\n+                let upvar_capture = tcx.tables.borrow().upvar_capture_map.get(&upvar_id).unwrap().clone();\n                 var_id.encode(rbml_w);\n                 upvar_capture.encode(rbml_w);\n             })\n@@ -1074,19 +1074,19 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     }\n \n     let method_call = MethodCall::expr(id);\n-    if let Some(method) = tcx.method_map.borrow().get(&method_call) {\n+    if let Some(method) = tcx.tables.borrow().method_map.get(&method_call) {\n         rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n             rbml_w.id(id);\n             encode_method_callee(ecx, rbml_w, method_call.autoderef, method)\n         })\n     }\n \n-    if let Some(adjustment) = tcx.adjustments.borrow().get(&id) {\n+    if let Some(adjustment) = tcx.tables.borrow().adjustments.get(&id) {\n         match *adjustment {\n             ty::AdjustDerefRef(ref adj) => {\n                 for autoderef in 0..adj.autoderefs {\n                     let method_call = MethodCall::autoderef(id, autoderef as u32);\n-                    if let Some(method) = tcx.method_map.borrow().get(&method_call) {\n+                    if let Some(method) = tcx.tables.borrow().method_map.get(&method_call) {\n                         rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n                             rbml_w.id(id);\n                             encode_method_callee(ecx, rbml_w,\n@@ -1104,14 +1104,14 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    if let Some(closure_type) = tcx.closure_tys.borrow().get(&ast_util::local_def(id)) {\n+    if let Some(closure_type) = tcx.tables.borrow().closure_tys.get(&ast_util::local_def(id)) {\n         rbml_w.tag(c::tag_table_closure_tys, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.emit_closure_type(ecx, closure_type);\n         })\n     }\n \n-    if let Some(closure_kind) = tcx.closure_kinds.borrow().get(&ast_util::local_def(id)) {\n+    if let Some(closure_kind) = tcx.tables.borrow().closure_kinds.get(&ast_util::local_def(id)) {\n         rbml_w.tag(c::tag_table_closure_kinds, |rbml_w| {\n             rbml_w.id(id);\n             encode_closure_kind(rbml_w, *closure_kind)\n@@ -1630,7 +1630,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         let item_substs = ty::ItemSubsts {\n                             substs: val_dsr.read_substs(dcx)\n                         };\n-                        dcx.tcx.item_substs.borrow_mut().insert(\n+                        dcx.tcx.tables.borrow_mut().item_substs.insert(\n                             id, item_substs);\n                     }\n                     c::tag_table_freevars => {\n@@ -1646,7 +1646,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                             closure_expr_id: id\n                         };\n                         let ub: ty::UpvarCapture = Decodable::decode(val_dsr).unwrap();\n-                        dcx.tcx.upvar_capture_map.borrow_mut().insert(upvar_id, ub.tr(dcx));\n+                        dcx.tcx.tables.borrow_mut().upvar_capture_map.insert(upvar_id, ub.tr(dcx));\n                     }\n                     c::tag_table_tcache => {\n                         let type_scheme = val_dsr.read_type_scheme(dcx);\n@@ -1663,22 +1663,22 @@ fn decode_side_tables(dcx: &DecodeContext,\n                             expr_id: id,\n                             autoderef: autoderef\n                         };\n-                        dcx.tcx.method_map.borrow_mut().insert(method_call, method);\n+                        dcx.tcx.tables.borrow_mut().method_map.insert(method_call, method);\n                     }\n                     c::tag_table_adjustments => {\n                         let adj: ty::AutoAdjustment = val_dsr.read_auto_adjustment(dcx);\n-                        dcx.tcx.adjustments.borrow_mut().insert(id, adj);\n+                        dcx.tcx.tables.borrow_mut().adjustments.insert(id, adj);\n                     }\n                     c::tag_table_closure_tys => {\n                         let closure_ty =\n                             val_dsr.read_closure_ty(dcx);\n-                        dcx.tcx.closure_tys.borrow_mut().insert(ast_util::local_def(id),\n+                        dcx.tcx.tables.borrow_mut().closure_tys.insert(ast_util::local_def(id),\n                                                                 closure_ty);\n                     }\n                     c::tag_table_closure_kinds => {\n                         let closure_kind =\n                             val_dsr.read_closure_kind(dcx);\n-                        dcx.tcx.closure_kinds.borrow_mut().insert(ast_util::local_def(id),\n+                        dcx.tcx.tables.borrow_mut().closure_kinds.insert(ast_util::local_def(id),\n                                                                   closure_kind);\n                     }\n                     c::tag_table_cast_kinds => {"}, {"sha": "7d62b6ff900408e62de48bd258153df79f68736e", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -411,7 +411,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             func_or_rcvr: &ast::Expr,\n             args: I) -> CFGIndex {\n         let method_call = ty::MethodCall::expr(call_expr.id);\n-        let fn_ty = match self.tcx.method_map.borrow().get(&method_call) {\n+        let fn_ty = match self.tcx.tables.borrow().method_map.get(&method_call) {\n             Some(method) => method.ty,\n             None => self.tcx.expr_ty_adjusted(func_or_rcvr)\n         };\n@@ -634,6 +634,6 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n     fn is_method_call(&self, expr: &ast::Expr) -> bool {\n         let method_call = ty::MethodCall::expr(expr.id);\n-        self.tcx.method_map.borrow().contains_key(&method_call)\n+        self.tcx.tables.borrow().method_map.contains_key(&method_call)\n     }\n }"}, {"sha": "b156a2c087b021b5e5a5eabe3c079d210f989df8", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -283,12 +283,11 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n \n     fn check_static_type(&self, e: &ast::Expr) {\n         let ty = self.tcx.node_id_to_type(e.id);\n-        let infcx = infer::new_infer_ctxt(self.tcx);\n+        let infcx = infer::new_infer_ctxt(self.tcx, None);\n         let mut fulfill_cx = traits::FulfillmentContext::new(false);\n         let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n         fulfill_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n-        let env = self.tcx.empty_parameter_environment();\n-        match fulfill_cx.select_all_or_error(&infcx, &env) {\n+        match fulfill_cx.select_all_or_error(&infcx, &infcx.parameter_environment) {\n             Ok(()) => { },\n             Err(ref errors) => {\n                 traits::report_fulfillment_errors(&infcx, errors);\n@@ -544,7 +543,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n     match e.node {\n         ast::ExprUnary(..) |\n         ast::ExprBinary(..) |\n-        ast::ExprIndex(..) if v.tcx.method_map.borrow().contains_key(&method_call) => {\n+        ast::ExprIndex(..) if v.tcx.tables.borrow().method_map.contains_key(&method_call) => {\n             v.add_qualif(ConstQualif::NOT_CONST);\n             if v.mode != Mode::Var {\n                 span_err!(v.tcx.sess, e.span, E0011,\n@@ -695,7 +694,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             }\n         }\n         ast::ExprMethodCall(..) => {\n-            let method_did = match v.tcx.method_map.borrow()[&method_call].origin {\n+            let method_did = match v.tcx.tables.borrow().method_map[&method_call].origin {\n                 ty::MethodStatic(did) => Some(did),\n                 _ => None\n             };"}, {"sha": "f61884e213666046ba54f91ec1897c1543a22c49", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -98,6 +98,7 @@ impl<'a> FromIterator<Vec<&'a Pat>> for Matrix<'a> {\n     }\n }\n \n+//NOTE: appears to be the only place other then InferCtxt to contain a ParamEnv\n pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n     pub tcx: &'a ty::ctxt<'tcx>,\n     pub param_env: ParameterEnvironment<'a, 'tcx>,"}, {"sha": "8f19a6e9e152b47bfb486fc9485f30deff449596", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -1031,10 +1031,9 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                                               substs: trait_substs });\n \n     tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n-    let infcx = infer::new_infer_ctxt(tcx);\n+    let infcx = infer::new_infer_ctxt(tcx, None);\n \n-    let param_env = tcx.empty_parameter_environment();\n-    let mut selcx = traits::SelectionContext::new(&infcx, &param_env);\n+    let mut selcx = traits::SelectionContext::new(&infcx, &infcx.parameter_environment);\n     let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n                                              trait_ref.to_poly_trait_predicate());\n     let selection = match selcx.select(&obligation) {"}, {"sha": "d8ee38b847830f941f2eaeceef92f8d0b70f8a87", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn lookup_and_handle_method(&mut self, id: ast::NodeId,\n                                 span: codemap::Span) {\n         let method_call = ty::MethodCall::expr(id);\n-        match self.tcx.method_map.borrow().get(&method_call) {\n+        match self.tcx.tables.borrow().method_map.get(&method_call) {\n             Some(method) => {\n                 match method.origin {\n                     ty::MethodStatic(def_id) => {"}, {"sha": "8084c2b0c39b884a677ee86da98c5889bd282530", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -140,7 +140,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n         match expr.node {\n             ast::ExprMethodCall(_, _, _) => {\n                 let method_call = MethodCall::expr(expr.id);\n-                let base_type = self.tcx.method_map.borrow().get(&method_call).unwrap().ty;\n+                let base_type = self.tcx.tables.borrow().method_map.get(&method_call).unwrap().ty;\n                 debug!(\"effect: method call case, base type is {:?}\",\n                         base_type);\n                 if type_is_unsafe_function(base_type) {"}, {"sha": "25728c50c61f4a6784ae7fccd8d52aa3c7634970", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -257,8 +257,9 @@ impl OverloadedCallType {\n     fn from_closure(tcx: &ty::ctxt, closure_did: ast::DefId)\n                     -> OverloadedCallType {\n         let trait_did =\n-            tcx.closure_kinds\n+            tcx.tables\n                .borrow()\n+               .closure_kinds\n                .get(&closure_did)\n                .expect(\"OverloadedCallType::from_closure: didn't find closure id\")\n                .trait_did(tcx);\n@@ -787,8 +788,10 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     // process.\n     fn walk_adjustment(&mut self, expr: &ast::Expr) {\n         let typer = self.typer;\n-        if let Some(adjustment) = typer.adjustments().borrow().get(&expr.id) {\n-            match *adjustment {\n+        //NOTE(@jroesch): mixed RefCell borrow causes crash\n+        let adj = typer.adjustments().get(&expr.id).map(|x| x.clone());\n+        if let Some(adjustment) = adj {\n+            match adjustment {\n                 ty::AdjustReifyFnPointer |\n                 ty::AdjustUnsafeFnPointer => {\n                     // Creating a closure/fn-pointer or unsizing consumes"}, {"sha": "8e53747e89973c339adb74c2adb1cdc052c742ba", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -77,6 +77,10 @@ pub struct InferCtxt<'a, 'tcx: 'a> {\n \n     // For region variables.\n     region_vars: RegionVarBindings<'a, 'tcx>,\n+\n+    pub parameter_environment: ty::ParameterEnvironment<'a, 'tcx>,\n+\n+    // pub tables: &'a RefCell<ty::Tables<'tcx>>\n }\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n@@ -309,14 +313,16 @@ pub fn fixup_err_to_string(f: fixup_err) -> String {\n     }\n }\n \n-pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>)\n+pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n+                                param_env: Option<ty::ParameterEnvironment<'a, 'tcx>>)\n                                 -> InferCtxt<'a, 'tcx> {\n     InferCtxt {\n         tcx: tcx,\n         type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n         int_unification_table: RefCell::new(UnificationTable::new()),\n         float_unification_table: RefCell::new(UnificationTable::new()),\n         region_vars: RegionVarBindings::new(tcx),\n+        parameter_environment: param_env.unwrap_or(tcx.empty_parameter_environment())\n     }\n }\n "}, {"sha": "7d237a511c4a173240da94101c01a582c85f6dae", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -1150,7 +1150,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           ast::ExprMethodCall(_, _, ref args) => {\n             let method_call = ty::MethodCall::expr(expr.id);\n-            let method_ty = self.ir.tcx.method_map.borrow().get(&method_call).unwrap().ty;\n+            let method_ty = self.ir.tcx.tables.borrow().method_map.get(&method_call).unwrap().ty;\n             let succ = if method_ty.fn_ret().diverges() {\n                 self.s.exit_ln\n             } else {"}, {"sha": "13e127e9126139caed875c100b53c51d17c7b09c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -83,7 +83,7 @@ use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap::Span;\n \n-use std::cell::RefCell;\n+use std::cell::Ref;\n use std::fmt;\n use std::rc::Rc;\n \n@@ -289,7 +289,7 @@ pub trait Typer<'tcx> : ty::ClosureTyper<'tcx> {\n     fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>>;\n     fn node_method_origin(&self, method_call: ty::MethodCall)\n                           -> Option<ty::MethodOrigin<'tcx>>;\n-    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>>;\n+    fn adjustments(&self) -> Ref<NodeMap<ty::AutoAdjustment<'tcx>>>;\n     fn is_method_call(&self, id: ast::NodeId) -> bool;\n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<region::CodeExtent>;\n     fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture>;\n@@ -408,7 +408,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         let unadjusted_ty = try!(self.expr_ty(expr));\n         Ok(unadjusted_ty.adjust(\n             self.tcx(), expr.span, expr.id,\n-            self.typer.adjustments().borrow().get(&expr.id),\n+            self.typer.adjustments().get(&expr.id),\n             |method_call| self.typer.node_method_ty(method_call)))\n     }\n \n@@ -440,7 +440,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     }\n \n     pub fn cat_expr(&self, expr: &ast::Expr) -> McResult<cmt<'tcx>> {\n-        match self.typer.adjustments().borrow().get(&expr.id) {\n+        match self.typer.adjustments().get(&expr.id) {\n             None => {\n                 // No adjustments.\n                 self.cat_expr_unadjusted(expr)"}, {"sha": "6ea726062cad6eab58668bc5dbb82a590f18bf68", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -128,7 +128,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n             }\n             ast::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                match (*self.tcx.method_map.borrow()).get(&method_call).unwrap().origin {\n+                match self.tcx.tables.borrow().method_map.get(&method_call).unwrap().origin {\n                     ty::MethodStatic(def_id) => {\n                         if is_local(def_id) {\n                             if self.def_id_represents_local_inlined_item(def_id) {"}, {"sha": "e6bbae6405bf4f8c4f02ef04a8151a30490e4e72", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -406,7 +406,7 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n         ast::ExprMethodCall(i, _, _) => {\n             span = i.span;\n             let method_call = ty::MethodCall::expr(e.id);\n-            match tcx.method_map.borrow().get(&method_call) {\n+            match tcx.tables.borrow().method_map.get(&method_call) {\n                 Some(method) => {\n                     match method.origin {\n                         ty::MethodStatic(def_id) => {"}, {"sha": "eb839eade143f7a516c41fcf22f1932701149c80", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -351,6 +351,7 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n     }\n }\n \n+// TODO: this is gonna need to be removed ...\n /// Normalizes the parameter environment, reporting errors if they occur.\n pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvironment<'a,'tcx>,\n                                              cause: ObligationCause<'tcx>)\n@@ -396,13 +397,13 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n \n     let elaborated_env = unnormalized_env.with_caller_bounds(predicates);\n \n-    let infcx = infer::new_infer_ctxt(tcx);\n-    let predicates = match fully_normalize(&infcx, &elaborated_env, cause,\n-                                           &elaborated_env.caller_bounds) {\n+    let infcx = infer::new_infer_ctxt(tcx, Some(elaborated_env));\n+    let predicates = match fully_normalize(&infcx, &infcx.parameter_environment, cause,\n+                                           &infcx.parameter_environment.caller_bounds) {\n         Ok(predicates) => predicates,\n         Err(errors) => {\n             report_fulfillment_errors(&infcx, &errors);\n-            return unnormalized_env; // an unnormalized env is better than nothing\n+            return infcx.parameter_environment; // an unnormalized env is better than nothing\n         }\n     };\n \n@@ -420,11 +421,11 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n             // all things considered.\n             let err_msg = fixup_err_to_string(fixup_err);\n             tcx.sess.span_err(span, &err_msg);\n-            return elaborated_env; // an unnormalized env is better than nothing\n+            return infcx.parameter_environment; // an unnormalized env is better than nothing\n         }\n     };\n \n-    elaborated_env.with_caller_bounds(predicates)\n+    infcx.parameter_environment.with_caller_bounds(predicates)\n }\n \n pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,"}, {"sha": "cdf7f6ef9b6b68e9445f70b24dd2f502042b4fd2", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 150, "deletions": 47, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -728,7 +728,7 @@ impl MethodCall {\n \n // maps from an expression id that corresponds to a method call to the details\n // of the method to be invoked\n-pub type MethodMap<'tcx> = RefCell<FnvHashMap<MethodCall, MethodCallee<'tcx>>>;\n+pub type MethodMap<'tcx> = FnvHashMap<MethodCall, MethodCallee<'tcx>>;\n \n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n@@ -815,6 +815,48 @@ pub struct CommonTypes<'tcx> {\n     pub err: Ty<'tcx>,\n }\n \n+pub struct Tables<'tcx> {\n+    /// Stores the types for various nodes in the AST.  Note that this table\n+    /// is not guaranteed to be populated until after typeck.  See\n+    /// typeck::check::fn_ctxt for details.\n+    pub node_types: NodeMap<Ty<'tcx>>,\n+\n+    /// Stores the type parameters which were substituted to obtain the type\n+    /// of this node.  This only applies to nodes that refer to entities\n+    /// parameterized by type parameters, such as generic fns, types, or\n+    /// other items.\n+    pub item_substs: NodeMap<ItemSubsts<'tcx>>,\n+\n+    pub adjustments: NodeMap<ty::AutoAdjustment<'tcx>>,\n+\n+    pub method_map: MethodMap<'tcx>,\n+\n+    /// Borrows\n+    pub upvar_capture_map: UpvarCaptureMap,\n+\n+    /// Records the type of each closure. The def ID is the ID of the\n+    /// expression defining the closure.\n+    pub closure_tys: DefIdMap<ClosureTy<'tcx>>,\n+\n+    /// Records the type of each closure. The def ID is the ID of the\n+    /// expression defining the closure.\n+    pub closure_kinds: DefIdMap<ClosureKind>,\n+}\n+\n+impl<'tcx> Tables<'tcx> {\n+    pub fn empty() -> Tables<'tcx> {\n+        Tables {\n+            node_types: FnvHashMap(),\n+            item_substs: NodeMap(),\n+            adjustments: NodeMap(),\n+            method_map: FnvHashMap(),\n+            upvar_capture_map: FnvHashMap(),\n+            closure_tys: DefIdMap(),\n+            closure_kinds: DefIdMap(),\n+        }\n+    }\n+}\n+\n /// The data structure to keep track of all the information that typechecker\n /// generates so that so that it can be reused and doesn't have to be redone\n /// later on.\n@@ -850,17 +892,9 @@ pub struct ctxt<'tcx> {\n     // borrowck. (They are not used during trans, and hence are not\n     // serialized or needed for cross-crate fns.)\n     free_region_maps: RefCell<NodeMap<FreeRegionMap>>,\n+    // FIXME: jroesch make this a refcell\n \n-    /// Stores the types for various nodes in the AST.  Note that this table\n-    /// is not guaranteed to be populated until after typeck.  See\n-    /// typeck::check::fn_ctxt for details.\n-    node_types: RefCell<NodeMap<Ty<'tcx>>>,\n-\n-    /// Stores the type parameters which were substituted to obtain the type\n-    /// of this node.  This only applies to nodes that refer to entities\n-    /// parameterized by type parameters, such as generic fns, types, or\n-    /// other items.\n-    pub item_substs: RefCell<NodeMap<ItemSubsts<'tcx>>>,\n+    pub tables: RefCell<Tables<'tcx>>,\n \n     /// Maps from a trait item to the trait item \"descriptor\"\n     pub impl_or_trait_items: RefCell<DefIdMap<ImplOrTraitItem<'tcx>>>,\n@@ -894,7 +928,6 @@ pub struct ctxt<'tcx> {\n     pub ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n     pub enum_var_cache: RefCell<DefIdMap<Rc<Vec<Rc<VariantInfo<'tcx>>>>>>,\n     pub ty_param_defs: RefCell<NodeMap<TypeParameterDef<'tcx>>>,\n-    pub adjustments: RefCell<NodeMap<AutoAdjustment<'tcx>>>,\n     pub normalized_cache: RefCell<FnvHashMap<Ty<'tcx>, Ty<'tcx>>>,\n     pub lang_items: middle::lang_items::LanguageItems,\n     /// A mapping of fake provided method def_ids to the default implementation\n@@ -944,26 +977,13 @@ pub struct ctxt<'tcx> {\n     /// FIXME(arielb1): why is this separate from populated_external_types?\n     pub populated_external_primitive_impls: RefCell<DefIdSet>,\n \n-    /// Borrows\n-    pub upvar_capture_map: RefCell<UpvarCaptureMap>,\n-\n     /// These caches are used by const_eval when decoding external constants.\n     pub extern_const_statics: RefCell<DefIdMap<ast::NodeId>>,\n     pub extern_const_variants: RefCell<DefIdMap<ast::NodeId>>,\n     pub extern_const_fns: RefCell<DefIdMap<ast::NodeId>>,\n \n-    pub method_map: MethodMap<'tcx>,\n-\n     pub dependency_formats: RefCell<dependency_format::Dependencies>,\n \n-    /// Records the type of each closure. The def ID is the ID of the\n-    /// expression defining the closure.\n-    pub closure_kinds: RefCell<DefIdMap<ClosureKind>>,\n-\n-    /// Records the type of each closure. The def ID is the ID of the\n-    /// expression defining the closure.\n-    pub closure_tys: RefCell<DefIdMap<ClosureTy<'tcx>>>,\n-\n     pub node_lint_levels: RefCell<FnvHashMap<(ast::NodeId, lint::LintId),\n                                               lint::LevelSource>>,\n \n@@ -1000,9 +1020,16 @@ pub struct ctxt<'tcx> {\n }\n \n impl<'tcx> ctxt<'tcx> {\n-    pub fn node_types(&self) -> Ref<NodeMap<Ty<'tcx>>> { self.node_types.borrow() }\n+    pub fn node_types(&self) -> Ref<NodeMap<Ty<'tcx>>> {\n+        fn projection<'a, 'tcx>(tables: &'a Tables<'tcx>) ->  &'a NodeMap<Ty<'tcx>> {\n+            &tables.node_types\n+        }\n+\n+        Ref::map(self.tables.borrow(), projection)\n+    }\n+\n     pub fn node_type_insert(&self, id: NodeId, ty: Ty<'tcx>) {\n-        self.node_types.borrow_mut().insert(id, ty);\n+        self.tables.borrow_mut().node_types.insert(id, ty);\n     }\n \n     pub fn intern_trait_def(&self, def: TraitDef<'tcx>) -> &'tcx TraitDef<'tcx> {\n@@ -3195,6 +3222,84 @@ impl<'tcx> CommonTypes<'tcx> {\n     }\n }\n \n+/// Create a type context and call the closure with a `&ty::ctxt` reference\n+/// to the context. The closure enforces that the type context and any interned\n+/// value (types, substs, etc.) can only be used while `ty::tls` has a valid\n+/// reference to the context, to allow formatting values that need it.\n+pub fn with_ctxt<'tcx, F, R>(s: Session,\n+                             arenas: &'tcx CtxtArenas<'tcx>,\n+                             def_map: DefMap,\n+                             named_region_map: resolve_lifetime::NamedRegionMap,\n+                             map: ast_map::Map<'tcx>,\n+                             freevars: RefCell<FreevarMap>,\n+                             region_maps: RegionMaps,\n+                             lang_items: middle::lang_items::LanguageItems,\n+                             stability: stability::Index<'tcx>,\n+                             f: F) -> (Session, R)\n+                             where F: FnOnce(&ctxt<'tcx>) -> R\n+{\n+    let mut interner = FnvHashMap();\n+    let common_types = CommonTypes::new(&arenas.type_, &mut interner);\n+\n+    tls::enter(ctxt {\n+        arenas: arenas,\n+        interner: RefCell::new(interner),\n+        substs_interner: RefCell::new(FnvHashMap()),\n+        bare_fn_interner: RefCell::new(FnvHashMap()),\n+        region_interner: RefCell::new(FnvHashMap()),\n+        stability_interner: RefCell::new(FnvHashMap()),\n+        types: common_types,\n+        named_region_map: named_region_map,\n+        region_maps: region_maps,\n+        free_region_maps: RefCell::new(FnvHashMap()),\n+        item_variance_map: RefCell::new(DefIdMap()),\n+        variance_computed: Cell::new(false),\n+        sess: s,\n+        def_map: def_map,\n+        tables: RefCell::new(Tables::empty()),\n+        impl_trait_refs: RefCell::new(DefIdMap()),\n+        trait_defs: RefCell::new(DefIdMap()),\n+        predicates: RefCell::new(DefIdMap()),\n+        super_predicates: RefCell::new(DefIdMap()),\n+        fulfilled_predicates: RefCell::new(traits::FulfilledPredicates::new()),\n+        map: map,\n+        freevars: freevars,\n+        tcache: RefCell::new(DefIdMap()),\n+        rcache: RefCell::new(FnvHashMap()),\n+        tc_cache: RefCell::new(FnvHashMap()),\n+        ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n+        enum_var_cache: RefCell::new(DefIdMap()),\n+        impl_or_trait_items: RefCell::new(DefIdMap()),\n+        trait_item_def_ids: RefCell::new(DefIdMap()),\n+        trait_items_cache: RefCell::new(DefIdMap()),\n+        ty_param_defs: RefCell::new(NodeMap()),\n+        normalized_cache: RefCell::new(FnvHashMap()),\n+        lang_items: lang_items,\n+        provided_method_sources: RefCell::new(DefIdMap()),\n+        struct_fields: RefCell::new(DefIdMap()),\n+        destructor_for_type: RefCell::new(DefIdMap()),\n+        destructors: RefCell::new(DefIdSet()),\n+        inherent_impls: RefCell::new(DefIdMap()),\n+        impl_items: RefCell::new(DefIdMap()),\n+        used_unsafe: RefCell::new(NodeSet()),\n+        used_mut_nodes: RefCell::new(NodeSet()),\n+        populated_external_types: RefCell::new(DefIdSet()),\n+        populated_external_primitive_impls: RefCell::new(DefIdSet()),\n+        extern_const_statics: RefCell::new(DefIdMap()),\n+        extern_const_variants: RefCell::new(DefIdMap()),\n+        extern_const_fns: RefCell::new(DefIdMap()),\n+        dependency_formats: RefCell::new(FnvHashMap()),\n+        node_lint_levels: RefCell::new(FnvHashMap()),\n+        transmute_restrictions: RefCell::new(Vec::new()),\n+        stability: RefCell::new(stability),\n+        selection_cache: traits::SelectionCache::new(),\n+        repr_hint_cache: RefCell::new(DefIdMap()),\n+        const_qualif_map: RefCell::new(NodeMap()),\n+        custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n+        cast_kinds: RefCell::new(NodeMap()),\n+   }, f)\n+}\n+\n struct FlagComputation {\n     flags: TypeFlags,\n \n@@ -3421,8 +3526,7 @@ impl<'tcx> ctxt<'tcx> {\n             variance_computed: Cell::new(false),\n             sess: s,\n             def_map: def_map,\n-            node_types: RefCell::new(FnvHashMap()),\n-            item_substs: RefCell::new(NodeMap()),\n+            tables: RefCell::new(Tables::empty()),\n             impl_trait_refs: RefCell::new(DefIdMap()),\n             trait_defs: RefCell::new(DefIdMap()),\n             predicates: RefCell::new(DefIdMap()),\n@@ -3439,7 +3543,6 @@ impl<'tcx> ctxt<'tcx> {\n             trait_item_def_ids: RefCell::new(DefIdMap()),\n             trait_items_cache: RefCell::new(DefIdMap()),\n             ty_param_defs: RefCell::new(NodeMap()),\n-            adjustments: RefCell::new(NodeMap()),\n             normalized_cache: RefCell::new(FnvHashMap()),\n             lang_items: lang_items,\n             provided_method_sources: RefCell::new(DefIdMap()),\n@@ -3452,14 +3555,10 @@ impl<'tcx> ctxt<'tcx> {\n             used_mut_nodes: RefCell::new(NodeSet()),\n             populated_external_types: RefCell::new(DefIdSet()),\n             populated_external_primitive_impls: RefCell::new(DefIdSet()),\n-            upvar_capture_map: RefCell::new(FnvHashMap()),\n             extern_const_statics: RefCell::new(DefIdMap()),\n             extern_const_variants: RefCell::new(DefIdMap()),\n             extern_const_fns: RefCell::new(DefIdMap()),\n-            method_map: RefCell::new(FnvHashMap()),\n             dependency_formats: RefCell::new(FnvHashMap()),\n-            closure_kinds: RefCell::new(DefIdMap()),\n-            closure_tys: RefCell::new(DefIdMap()),\n             node_lint_levels: RefCell::new(FnvHashMap()),\n             transmute_restrictions: RefCell::new(Vec::new()),\n             stability: RefCell::new(stability),\n@@ -3515,15 +3614,15 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn closure_kind(&self, def_id: ast::DefId) -> ty::ClosureKind {\n-        *self.closure_kinds.borrow().get(&def_id).unwrap()\n+        *self.tables.borrow().closure_kinds.get(&def_id).unwrap()\n     }\n \n     pub fn closure_type(&self,\n                         def_id: ast::DefId,\n                         substs: &subst::Substs<'tcx>)\n                         -> ty::ClosureTy<'tcx>\n     {\n-        self.closure_tys.borrow().get(&def_id).unwrap().subst(self, substs)\n+        self.tables.borrow().closure_tys.get(&def_id).unwrap().subst(self, substs)\n     }\n \n     pub fn type_parameter_def(&self,\n@@ -4369,7 +4468,7 @@ impl<'tcx> TyS<'tcx> {\n                        span: Span)\n                        -> bool\n     {\n-        let infcx = infer::new_infer_ctxt(param_env.tcx());\n+        let infcx = infer::new_infer_ctxt(param_env.tcx(), Some(param_env.clone()));\n \n         let is_impld = traits::type_known_to_meet_builtin_bound(&infcx, param_env,\n                                                                 self, bound, span);\n@@ -5276,11 +5375,11 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn node_id_to_type_opt(&self, id: ast::NodeId) -> Option<Ty<'tcx>> {\n-        self.node_types.borrow().get(&id).cloned()\n+        self.tables.borrow().node_types.get(&id).cloned()\n     }\n \n     pub fn node_id_item_substs(&self, id: ast::NodeId) -> ItemSubsts<'tcx> {\n-        match self.item_substs.borrow().get(&id) {\n+        match self.tables.borrow().item_substs.get(&id) {\n             None => ItemSubsts::empty(),\n             Some(ts) => ts.clone(),\n         }\n@@ -5325,9 +5424,9 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx> {\n         self.expr_ty(expr)\n             .adjust(self, expr.span, expr.id,\n-                    self.adjustments.borrow().get(&expr.id),\n+                    self.tables.borrow().adjustments.get(&expr.id),\n                     |method_call| {\n-            self.method_map.borrow().get(&method_call).map(|method| method.ty)\n+            self.tables.borrow().method_map.get(&method_call).map(|method| method.ty)\n         })\n     }\n \n@@ -6671,11 +6770,11 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn is_method_call(&self, expr_id: ast::NodeId) -> bool {\n-        self.method_map.borrow().contains_key(&MethodCall::expr(expr_id))\n+        self.tables.borrow().method_map.contains_key(&MethodCall::expr(expr_id))\n     }\n \n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n-        Some(self.upvar_capture_map.borrow().get(&upvar_id).unwrap().clone())\n+        Some(self.tables.borrow().upvar_capture_map.get(&upvar_id).unwrap().clone())\n     }\n }\n \n@@ -6689,17 +6788,21 @@ impl<'a,'tcx> Typer<'tcx> for ParameterEnvironment<'a,'tcx> {\n     }\n \n     fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>> {\n-        self.tcx.method_map.borrow().get(&method_call).map(|method| method.ty)\n+        self.tcx.tables.borrow().method_map.get(&method_call).map(|method| method.ty)\n     }\n \n     fn node_method_origin(&self, method_call: ty::MethodCall)\n                           -> Option<ty::MethodOrigin<'tcx>>\n     {\n-        self.tcx.method_map.borrow().get(&method_call).map(|method| method.origin.clone())\n+        self.tcx.tables.borrow().method_map.get(&method_call).map(|method| method.origin.clone())\n     }\n \n-    fn adjustments(&self) -> &RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n-        &self.tcx.adjustments\n+    fn adjustments(&self) -> Ref<NodeMap<ty::AutoAdjustment<'tcx>>> {\n+        fn projection<'a, 'tcx>(tables: &'a Tables<'tcx>) -> &'a NodeMap<ty::AutoAdjustment<'tcx>> {\n+            &tables.adjustments\n+        }\n+\n+        Ref::map(self.tcx.tables.borrow(), projection)\n     }\n \n     fn is_method_call(&self, id: ast::NodeId) -> bool {"}, {"sha": "de2f33e8a4ac9dd3233639804f2428759eec7e17", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -688,7 +688,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyStr => write!(f, \"str\"),\n             TyClosure(ref did, substs) => ty::tls::with(|tcx| {\n                 try!(write!(f, \"[closure\"));\n-                let closure_tys = tcx.closure_tys.borrow();\n+                let closure_tys = &tcx.tables.borrow().closure_tys;\n                 try!(closure_tys.get(did).map(|cty| &cty.sig).and_then(|sig| {\n                     tcx.lift(&substs).map(|substs| sig.subst(tcx, substs))\n                 }).map(|sig| {"}, {"sha": "db48608823d216e1f8278a79b08e4cab0d2cd447", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -1446,7 +1446,7 @@ impl LintPass for UnusedAllocation {\n             _ => return\n         }\n \n-        if let Some(adjustment) = cx.tcx.adjustments.borrow().get(&e.id) {\n+        if let Some(adjustment) = cx.tcx.tables.borrow().adjustments.get(&e.id) {\n             if let ty::AdjustDerefRef(ty::AutoDerefRef { ref autoref, .. }) = *adjustment {\n                 match autoref {\n                     &Some(ty::AutoPtr(_, ast::MutImmutable)) => {\n@@ -1984,7 +1984,7 @@ impl LintPass for UnconditionalRecursion {\n                                           method_id: ast::NodeId,\n                                           method_name: ast::Ident,\n                                           id: ast::NodeId) -> bool {\n-            let did = match tcx.method_map.borrow().get(&ty::MethodCall::expr(id)) {\n+            let did = match tcx.tables.borrow().method_map.get(&ty::MethodCall::expr(id)) {\n                 None => return false,\n                 Some(m) => match m.origin {\n                     // There's no way to know if a method call via a"}, {"sha": "239141df9e8c7be7274d0fd8742aab53daa83a05", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -904,7 +904,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             }\n             ast::ExprMethodCall(ident, _, _) => {\n                 let method_call = MethodCall::expr(expr.id);\n-                match self.tcx.method_map.borrow().get(&method_call) {\n+                match self.tcx.tables.borrow().method_map.get(&method_call) {\n                     None => {\n                         self.tcx.sess.span_bug(expr.span,\n                                                 \"method call not in \\"}, {"sha": "dc692b0e765dd5e9949a920067bdf687ebc99bc4", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -43,6 +43,7 @@\n #![feature(unicode)]\n #![feature(unicode)]\n #![feature(vec_push_all)]\n+#![feature(cell_extras)]\n \n #![allow(trivial_casts)]\n "}, {"sha": "d86242f39cea7763e94e9d3ebff435a0402059f4", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -886,7 +886,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n     fn process_method_call(&mut self,\n                            ex: &ast::Expr,\n                            args: &Vec<P<ast::Expr>>) {\n-        let method_map = self.tcx.method_map.borrow();\n+        let method_map = &self.tcx.tables.borrow().method_map;\n         let method_callee = method_map.get(&ty::MethodCall::expr(ex.id)).unwrap();\n         let (def_id, decl_id) = match method_callee.origin {\n             ty::MethodStatic(def_id) |"}, {"sha": "0cd6bbad03aa9206dfbc3789c62f0f15277e89ac", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -212,7 +212,7 @@ pub fn self_type_for_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n pub fn kind_for_closure(ccx: &CrateContext, closure_id: ast::DefId) -> ty::ClosureKind {\n-    *ccx.tcx().closure_kinds.borrow().get(&closure_id).unwrap()\n+    *ccx.tcx().tables.borrow().closure_kinds.get(&closure_id).unwrap()\n }\n \n pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,"}, {"sha": "dfe807d6c9152012511317d7a797587c6269f2cd", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -518,7 +518,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n             let ref_ty = match node {\n                 ExprId(id) => tcx.node_id_to_type(id),\n                 MethodCallKey(method_call) => {\n-                    tcx.method_map.borrow().get(&method_call).unwrap().ty\n+                    tcx.tables.borrow().method_map.get(&method_call).unwrap().ty\n                 }\n             };\n             let ref_ty = monomorphize::apply_param_substs(tcx,\n@@ -610,7 +610,7 @@ pub fn trans_method_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_method_call\");\n     debug!(\"trans_method_call(call_expr={:?})\", call_expr);\n     let method_call = MethodCall::expr(call_expr.id);\n-    let method_ty = match bcx.tcx().method_map.borrow().get(&method_call) {\n+    let method_ty = match bcx.tcx().tables.borrow().method_map.get(&method_call) {\n         Some(method) => match method.origin {\n             ty::MethodTraitObject(_) => match method.ty.sty {\n                 ty::TyBareFn(_, ref fty) => {"}, {"sha": "b6378062855400c5b885961feede03c4ca34f11a", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -130,7 +130,7 @@ pub fn get_or_create_declaration_if_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tc\n                                                       closure_id: ast::DefId,\n                                                       substs: &Substs<'tcx>)\n                                                       -> Option<Datum<'tcx, Rvalue>> {\n-    if !ccx.tcx().closure_kinds.borrow().contains_key(&closure_id) {\n+    if !ccx.tcx().tables.borrow().closure_kinds.contains_key(&closure_id) {\n         // Not a closure.\n         return None\n     }"}, {"sha": "dc8c92429615d189f7c7c206dd713592bff277c5", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -47,7 +47,7 @@ use util::nodemap::{FnvHashMap, NodeMap};\n use arena::TypedArena;\n use libc::{c_uint, c_char};\n use std::ffi::CString;\n-use std::cell::{Cell, RefCell};\n+use std::cell::{Cell, RefCell, Ref};\n use std::result::Result as StdResult;\n use std::vec::Vec;\n use syntax::ast;\n@@ -353,7 +353,7 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     // section of the executable we're generating.\n     pub llfn: ValueRef,\n \n-    // always an empty parameter-environment\n+    // always an empty parameter-environment NOTE: @jroesch another use of ParamEnv\n     pub param_env: ty::ParameterEnvironment<'a, 'tcx>,\n \n     // The environment argument in a closure.\n@@ -630,8 +630,9 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n \n     fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>> {\n         self.tcx()\n-            .method_map\n+            .tables\n             .borrow()\n+            .method_map\n             .get(&method_call)\n             .map(|method| monomorphize_type(self, method.ty))\n     }\n@@ -640,26 +641,31 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n                           -> Option<ty::MethodOrigin<'tcx>>\n     {\n         self.tcx()\n-            .method_map\n+            .tables\n             .borrow()\n+            .method_map\n             .get(&method_call)\n             .map(|method| method.origin.clone())\n     }\n \n-    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n-        &self.tcx().adjustments\n+    fn adjustments<'a>(&'a self) -> Ref<NodeMap<ty::AutoAdjustment<'tcx>>> {\n+        fn project_adjustments<'a, 'tcx>(tables: &'a ty::Tables<'tcx>) -> &'a NodeMap<ty::AutoAdjustment<'tcx>> {\n+            &tables.adjustments\n+        }\n+\n+        Ref::map(self.tcx().tables.borrow(), project_adjustments)\n     }\n \n     fn is_method_call(&self, id: ast::NodeId) -> bool {\n-        self.tcx().method_map.borrow().contains_key(&ty::MethodCall::expr(id))\n+        self.tcx().tables.borrow().method_map.contains_key(&ty::MethodCall::expr(id))\n     }\n \n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<region::CodeExtent> {\n         self.tcx().region_maps.temporary_scope(rvalue_id)\n     }\n \n     fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n-        Some(self.tcx().upvar_capture_map.borrow().get(&upvar_id).unwrap().clone())\n+        Some(self.tcx().tables.borrow().upvar_capture_map.get(&upvar_id).unwrap().clone())\n     }\n \n     fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool {\n@@ -991,7 +997,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            trait_ref, trait_ref.def_id());\n \n     tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n-    let infcx = infer::new_infer_ctxt(tcx);\n+    let infcx = infer::new_infer_ctxt(tcx, None);\n \n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n@@ -1053,7 +1059,7 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            predicates);\n \n     let tcx = ccx.tcx();\n-    let infcx = infer::new_infer_ctxt(tcx);\n+    let infcx = infer::new_infer_ctxt(tcx, None);\n     let typer = NormalizingClosureTyper::new(tcx);\n     let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n     let mut fulfill_cx = traits::FulfillmentContext::new(false);\n@@ -1070,6 +1076,10 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     drain_fulfillment_cx(&infcx, &mut fulfill_cx, &()).is_ok()\n }\n \n+// NOTE: here is another use of parameter environment without an InferCtxt,\n+// this is obviously related to the typer interface requiring a parameter env.\n+// We should pay attention to this when refactoring\n+// - @jroesch\n pub struct NormalizingClosureTyper<'a,'tcx:'a> {\n     param_env: ty::ParameterEnvironment<'a, 'tcx>\n }\n@@ -1191,7 +1201,7 @@ pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             tcx.node_id_item_substs(id).substs\n         }\n         MethodCallKey(method_call) => {\n-            tcx.method_map.borrow().get(&method_call).unwrap().substs.clone()\n+            tcx.tables.borrow().method_map.get(&method_call).unwrap().substs.clone()\n         }\n     };\n "}, {"sha": "57af688ef60d7bea7af9e1a5d9f098fc2f64081a", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -228,7 +228,7 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let def = ccx.tcx().def_map.borrow().get(&expr.id).unwrap().full_def();\n             match def {\n                 def::DefConst(def_id) | def::DefAssociatedConst(def_id, _) => {\n-                    if !ccx.tcx().adjustments.borrow().contains_key(&expr.id) {\n+                    if !ccx.tcx().tables.borrow().adjustments.contains_key(&expr.id) {\n                         debug!(\"get_const_expr_as_global ({:?}): found const {:?}\",\n                                expr.id, def_id);\n                         return get_const_val(ccx, def_id, expr);\n@@ -281,7 +281,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let mut llconst = llconst;\n     let mut ety_adjusted = monomorphize::apply_param_substs(cx.tcx(), param_substs,\n                                                             &cx.tcx().expr_ty_adjusted(e));\n-    let opt_adj = cx.tcx().adjustments.borrow().get(&e.id).cloned();\n+    let opt_adj = cx.tcx().tables.borrow().adjustments.get(&e.id).cloned();\n     match opt_adj {\n         Some(ty::AdjustReifyFnPointer) => {\n             // FIXME(#19925) once fn item types are\n@@ -894,7 +894,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n           ast::ExprMethodCall(_, _, ref args) => {\n               let arg_vals = map_list(args);\n               let method_call = ty::MethodCall::expr(e.id);\n-              let method_did = match cx.tcx().method_map.borrow()[&method_call].origin {\n+              let method_did = match cx.tcx().tables.borrow().method_map[&method_call].origin {\n                   ty::MethodStatic(did) => did,\n                   _ => cx.sess().span_bug(e.span, \"expected a const method def\")\n               };"}, {"sha": "045cc69bf954b26c357015ed0e80c5edce398d88", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -117,7 +117,7 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n \n-    if bcx.tcx().adjustments.borrow().contains_key(&expr.id) {\n+    if bcx.tcx().tables.borrow().adjustments.contains_key(&expr.id) {\n         // use trans, which may be less efficient but\n         // which will perform the adjustments:\n         let datum = unpack_datum!(bcx, trans(bcx, expr));\n@@ -345,7 +345,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n {\n     let mut bcx = bcx;\n     let mut datum = datum;\n-    let adjustment = match bcx.tcx().adjustments.borrow().get(&expr.id).cloned() {\n+    let adjustment = match bcx.tcx().tables.borrow().adjustments.get(&expr.id).cloned() {\n         None => {\n             return DatumBlock::new(bcx, datum);\n         }\n@@ -372,7 +372,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     // Don't skip a conversion from Box<T> to &T, etc.\n                     ty::TyRef(..) => {\n                         let method_call = MethodCall::autoderef(expr.id, 0);\n-                        if bcx.tcx().method_map.borrow().contains_key(&method_call) {\n+                        if bcx.tcx().tables.borrow().method_map.contains_key(&method_call) {\n                             // Don't skip an overloaded deref.\n                             0\n                         } else {\n@@ -774,8 +774,9 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Check for overloaded index.\n     let method_ty = ccx.tcx()\n-                       .method_map\n+                       .tables\n                        .borrow()\n+                       .method_map\n                        .get(&method_call)\n                        .map(|method| method.ty);\n     let elt_datum = match method_ty {\n@@ -1617,7 +1618,7 @@ fn trans_unary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Otherwise, we should be in the RvalueDpsExpr path.\n     assert!(\n         op == ast::UnDeref ||\n-        !ccx.tcx().method_map.borrow().contains_key(&method_call));\n+        !ccx.tcx().tables.borrow().method_map.contains_key(&method_call));\n \n     let un_ty = expr_ty(bcx, expr);\n \n@@ -1910,7 +1911,7 @@ fn trans_binary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let ccx = bcx.ccx();\n \n     // if overloaded, would be RvalueDpsExpr\n-    assert!(!ccx.tcx().method_map.borrow().contains_key(&MethodCall::expr(expr.id)));\n+    assert!(!ccx.tcx().tables.borrow().method_map.contains_key(&MethodCall::expr(expr.id)));\n \n     match op.node {\n         ast::BiAnd => {\n@@ -1950,7 +1951,12 @@ fn trans_overloaded_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    dest: Option<Dest>,\n                                    autoref: bool)\n                                    -> Result<'blk, 'tcx> {\n-    let method_ty = bcx.tcx().method_map.borrow().get(&method_call).unwrap().ty;\n+    let method_ty = bcx.tcx()\n+                       .tables\n+                       .borrow()\n+                       .method_map\n+                       .get(&method_call).unwrap().ty;\n+\n     callee::trans_call_inner(bcx,\n                              expr.debug_loc(),\n                              monomorphize_type(bcx, method_ty),\n@@ -1973,8 +1979,9 @@ fn trans_overloaded_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     debug!(\"trans_overloaded_call {}\", expr.id);\n     let method_call = MethodCall::expr(expr.id);\n     let method_type = bcx.tcx()\n-                         .method_map\n+                         .tables\n                          .borrow()\n+                         .method_map\n                          .get(&method_call)\n                          .unwrap()\n                          .ty;\n@@ -2154,7 +2161,7 @@ fn trans_assign_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     debug!(\"trans_assign_op(expr={:?})\", expr);\n \n     // User-defined operator methods cannot be used with `+=` etc right now\n-    assert!(!bcx.tcx().method_map.borrow().contains_key(&MethodCall::expr(expr.id)));\n+    assert!(!bcx.tcx().tables.borrow().method_map.contains_key(&MethodCall::expr(expr.id)));\n \n     // Evaluate LHS (destination), which should be an lvalue\n     let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, dst, \"assign_op\"));\n@@ -2229,8 +2236,12 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = bcx;\n \n     // Check for overloaded deref.\n-    let method_ty = ccx.tcx().method_map.borrow()\n+    let method_ty = ccx.tcx()\n+                       .tables\n+                       .borrow()\n+                       .method_map\n                        .get(&method_call).map(|method| method.ty);\n+\n     let datum = match method_ty {\n         Some(method_ty) => {\n             let method_ty = monomorphize_type(bcx, method_ty);\n@@ -2615,7 +2626,7 @@ enum ExprKind {\n }\n \n fn expr_kind(tcx: &ty::ctxt, expr: &ast::Expr) -> ExprKind {\n-    if tcx.method_map.borrow().contains_key(&MethodCall::expr(expr.id)) {\n+    if tcx.tables.borrow().method_map.contains_key(&MethodCall::expr(expr.id)) {\n         // Overloaded operations are generally calls, and hence they are\n         // generated via DPS, but there are a few exceptions:\n         return match expr.node {"}, {"sha": "e46c3b5fab1f784e7a34ebbc55f5a3e4c44ca580", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -109,11 +109,13 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"meth::trans_method_callee\");\n \n     let (origin, method_ty) =\n-        bcx.tcx().method_map\n-                 .borrow()\n-                 .get(&method_call)\n-                 .map(|method| (method.origin.clone(), method.ty))\n-                 .unwrap();\n+        bcx.tcx()\n+           .tables\n+           .borrow()\n+           .method_map\n+           .get(&method_call)\n+           .map(|method| (method.origin.clone(), method.ty))\n+           .unwrap();\n \n     match origin {\n         ty::MethodStatic(did) |"}, {"sha": "fa992511cc19beda817401ff739e752512f45fbc", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -322,8 +322,9 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n     }\n \n     // FIXME(#20304) -- cache\n-\n-    let infcx = infer::new_infer_ctxt(tcx);\n+    // NOTE: @jroesch\n+    // Here is of an example where we do not use a param_env but use a typer instead.\n+    let infcx = infer::new_infer_ctxt(tcx, None);\n     let typer = NormalizingClosureTyper::new(tcx);\n     let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n     let cause = traits::ObligationCause::dummy();"}, {"sha": "c2170686faccb1bedba4849b868e71d615a9239e", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -324,7 +324,7 @@ fn write_overloaded_call_method_map<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                              call_expr: &ast::Expr,\n                                              method_callee: ty::MethodCallee<'tcx>) {\n     let method_call = ty::MethodCall::expr(call_expr.id);\n-    fcx.inh.method_map.borrow_mut().insert(method_call, method_callee);\n+    fcx.inh.tables.borrow_mut().method_map.insert(method_call, method_callee);\n }\n \n #[derive(Debug)]"}, {"sha": "b5ee46ece94be16d505654aaa7dc5f7d68b6bf8b", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -61,7 +61,7 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n         expected_sig);\n \n     let closure_type = fcx.ccx.tcx.mk_closure(expr_def_id,\n-        fcx.ccx.tcx.mk_substs(fcx.inh.param_env.free_substs.clone()));\n+        fcx.ccx.tcx.mk_substs(fcx.inh.infcx.parameter_environment.free_substs.clone()));\n \n     fcx.write_ty(expr.id, closure_type);\n \n@@ -86,9 +86,9 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n            fn_ty.sig,\n            opt_kind);\n \n-    fcx.inh.closure_tys.borrow_mut().insert(expr_def_id, fn_ty);\n+    fcx.inh.tables.borrow_mut().closure_tys.insert(expr_def_id, fn_ty);\n     match opt_kind {\n-        Some(kind) => { fcx.inh.closure_kinds.borrow_mut().insert(expr_def_id, kind); }\n+        Some(kind) => { fcx.inh.tables.borrow_mut().closure_kinds.insert(expr_def_id, kind); }\n         None => { }\n     }\n }"}, {"sha": "dc8ef46a7ba6456aff6c13cf91d72b02f1427ee0", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -43,7 +43,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"compare_impl_method: impl_trait_ref (liberated) = {:?}\",\n            impl_trait_ref);\n \n-    let infcx = infer::new_infer_ctxt(tcx);\n+    let mut infcx = infer::new_infer_ctxt(tcx, None);\n     let mut fulfillment_cx = traits::FulfillmentContext::new(true);\n \n     let trait_to_impl_substs = &impl_trait_ref.substs;\n@@ -240,11 +240,13 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let trait_param_env = impl_param_env.with_caller_bounds(hybrid_preds.into_vec());\n     let trait_param_env = traits::normalize_param_env_or_error(trait_param_env,\n                                                                normalize_cause.clone());\n+    // TODO (@jroesch) this seems ugly, but is a temporary change\n+    infcx.parameter_environment = trait_param_env;\n \n     debug!(\"compare_impl_method: trait_bounds={:?}\",\n-        trait_param_env.caller_bounds);\n+        infcx.parameter_environment.caller_bounds);\n \n-    let mut selcx = traits::SelectionContext::new(&infcx, &trait_param_env);\n+    let mut selcx = traits::SelectionContext::new(&infcx, &infcx.parameter_environment);\n \n     for predicate in impl_pred.fns {\n         let traits::Normalized { value: predicate, .. } =\n@@ -345,7 +347,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     // Check that all obligations are satisfied by the implementation's\n     // version.\n-    match fulfillment_cx.select_all_or_error(&infcx, &trait_param_env) {\n+    match fulfillment_cx.select_all_or_error(&infcx, &infcx.parameter_environment) {\n         Err(ref errors) => { traits::report_fulfillment_errors(&infcx, errors) }\n         Ok(_) => {}\n     }\n@@ -360,7 +362,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // anyway, so it shouldn't be needed there either. Anyway, we can\n     // always add more relations later (it's backwards compat).\n     let mut free_regions = FreeRegionMap::new();\n-    free_regions.relate_free_regions_from_predicates(tcx, &trait_param_env.caller_bounds);\n+    free_regions.relate_free_regions_from_predicates(tcx, &infcx.parameter_environment.caller_bounds);\n \n     infcx.resolve_regions_and_report_errors(&free_regions, impl_m_body_id);\n \n@@ -416,7 +418,7 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\",\n            impl_trait_ref);\n \n-    let infcx = infer::new_infer_ctxt(tcx);\n+    let infcx = infer::new_infer_ctxt(tcx, None);\n     let mut fulfillment_cx = traits::FulfillmentContext::new(true);\n \n     // The below is for the most part highly similar to the procedure"}, {"sha": "4abfd84d8ef3c3d6c73549c2b719660c564ddb2a", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -93,7 +93,8 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n                          ty: named_type } =\n         tcx.lookup_item_type(self_type_did);\n \n-    let infcx = infer::new_infer_ctxt(tcx);\n+    let infcx = infer::new_infer_ctxt(tcx, None);\n+    \n     infcx.commit_if_ok(|snapshot| {\n         let (named_type_to_skolem, skol_map) =\n             infcx.construct_skolemized_subst(named_type_generics, snapshot);"}, {"sha": "5601888a1f0734265da956a8eaf4c3b36481a4b9", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -488,8 +488,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             // Count autoderefs.\n             let autoderef_count = match self.fcx\n                                             .inh\n-                                            .adjustments\n+                                            .tables\n                                             .borrow()\n+                                            .adjustments\n                                             .get(&expr.id) {\n                 Some(&ty::AdjustDerefRef(ref adj)) => adj.autoderefs,\n                 Some(_) | None => 0,\n@@ -527,7 +528,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         // expects. This is annoying and horrible. We\n                         // ought to recode this routine so it doesn't\n                         // (ab)use the normal type checking paths.\n-                        let adj = self.fcx.inh.adjustments.borrow().get(&base_expr.id).cloned();\n+                        let adj = self.fcx.inh.tables.borrow().adjustments.get(&base_expr.id).cloned();\n                         let (autoderefs, unsize) = match adj {\n                             Some(ty::AdjustDerefRef(adr)) => match adr.autoref {\n                                 None => {\n@@ -589,7 +590,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         // if this is an overloaded deref, then re-evaluate with\n                         // a preference for mut\n                         let method_call = MethodCall::expr(expr.id);\n-                        if self.fcx.inh.method_map.borrow().contains_key(&method_call) {\n+                        if self.fcx.inh.tables.borrow().method_map.contains_key(&method_call) {\n                             check::try_overloaded_deref(\n                                 self.fcx,\n                                 expr.span,"}, {"sha": "2cf041919147c67246ecd3555049139e161aca3f", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -477,7 +477,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // FIXME -- Do we want to commit to this behavior for param bounds?\n \n         let bounds: Vec<_> =\n-            self.fcx.inh.param_env.caller_bounds\n+            self.fcx.inh.infcx.parameter_environment.caller_bounds\n             .iter()\n             .filter_map(|predicate| {\n                 match *predicate {\n@@ -742,7 +742,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 _ => continue,\n             };\n \n-            let closure_kinds = self.fcx.inh.closure_kinds.borrow();\n+            let closure_kinds = &self.fcx.inh.tables.borrow().closure_kinds;\n             let closure_kind = match closure_kinds.get(&closure_def_id) {\n                 Some(&k) => k,\n                 None => {\n@@ -845,7 +845,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         debug!(\"assemble_where_clause_candidates(trait_def_id={:?})\",\n                trait_def_id);\n \n-        let caller_predicates = self.fcx.inh.param_env.caller_bounds.clone();\n+        let caller_predicates = self.fcx.inh.infcx.parameter_environment.caller_bounds.clone();\n         for poly_bound in traits::elaborate_predicates(self.tcx(), caller_predicates)\n                           .filter_map(|p| p.to_opt_poly_trait_ref())\n                           .filter(|b| b.def_id() == trait_def_id)"}, {"sha": "058cbe020b7d6b5c79ae2f99954fdd8757687bf0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 73, "deletions": 56, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -97,7 +97,7 @@ use middle::traits::{self, report_fulfillment_errors};\n use middle::ty::{FnSig, GenericPredicates, TypeScheme};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty::{self, HasTypeFlags, RegionEscape, ToPolyTraitRef, Ty};\n-use middle::ty::{MethodCall, MethodCallee, MethodMap};\n+use middle::ty::{MethodCall, MethodCallee};\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use rscope::RegionScope;\n use session::Session;\n@@ -152,16 +152,8 @@ mod op;\n pub struct Inherited<'a, 'tcx: 'a> {\n     infcx: infer::InferCtxt<'a, 'tcx>,\n     locals: RefCell<NodeMap<Ty<'tcx>>>,\n-    param_env: ty::ParameterEnvironment<'a, 'tcx>,\n \n-    // Temporary tables:\n-    node_types: RefCell<NodeMap<Ty<'tcx>>>,\n-    item_substs: RefCell<NodeMap<ty::ItemSubsts<'tcx>>>,\n-    adjustments: RefCell<NodeMap<ty::AutoAdjustment<'tcx>>>,\n-    method_map: MethodMap<'tcx>,\n-    upvar_capture_map: RefCell<ty::UpvarCaptureMap>,\n-    closure_tys: RefCell<DefIdMap<ty::ClosureTy<'tcx>>>,\n-    closure_kinds: RefCell<DefIdMap<ty::ClosureKind>>,\n+    tables: &'a RefCell<ty::Tables<'tcx>>,\n \n     // A mapping from each fn's id to its signature, with all bound\n     // regions replaced with free ones. Unlike the other tables, this\n@@ -303,60 +295,76 @@ impl<'a, 'tcx> mc::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n         let ty = self.node_ty(id);\n         self.resolve_type_vars_or_error(&ty)\n     }\n+\n     fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n-        let ty = self.adjust_expr_ty(expr, self.inh.adjustments.borrow().get(&expr.id));\n+        let ty = self.adjust_expr_ty(expr, self.inh.tables.borrow().adjustments.get(&expr.id));\n         self.resolve_type_vars_or_error(&ty)\n     }\n+\n     fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool {\n         let ty = self.infcx().resolve_type_vars_if_possible(&ty);\n         !traits::type_known_to_meet_builtin_bound(self.infcx(), self, ty, ty::BoundCopy, span)\n     }\n+\n     fn node_method_ty(&self, method_call: ty::MethodCall)\n                       -> Option<Ty<'tcx>> {\n-        self.inh.method_map.borrow()\n-                           .get(&method_call)\n-                           .map(|method| method.ty)\n-                           .map(|ty| self.infcx().resolve_type_vars_if_possible(&ty))\n+        self.inh.tables\n+                .borrow()\n+                .method_map\n+                .get(&method_call)\n+                .map(|method| method.ty)\n+                .map(|ty| self.infcx().resolve_type_vars_if_possible(&ty))\n     }\n+\n     fn node_method_origin(&self, method_call: ty::MethodCall)\n                           -> Option<ty::MethodOrigin<'tcx>>\n     {\n-        self.inh.method_map.borrow()\n-                           .get(&method_call)\n-                           .map(|method| method.origin.clone())\n+        self.inh.tables\n+                .borrow()\n+                .method_map\n+                .get(&method_call)\n+                .map(|method| method.origin.clone())\n     }\n-    fn adjustments(&self) -> &RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n-        &self.inh.adjustments\n+\n+    fn adjustments(&self) -> Ref<NodeMap<ty::AutoAdjustment<'tcx>>> {\n+        fn project_adjustments<'a, 'tcx>(tables: &'a ty::Tables<'tcx>) -> &'a NodeMap<ty::AutoAdjustment<'tcx>> {\n+            &tables.adjustments\n+        }\n+\n+        Ref::map(self.inh.tables.borrow(), project_adjustments)\n     }\n+\n     fn is_method_call(&self, id: ast::NodeId) -> bool {\n-        self.inh.method_map.borrow().contains_key(&ty::MethodCall::expr(id))\n+        self.inh.tables.borrow().method_map.contains_key(&ty::MethodCall::expr(id))\n     }\n+\n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<CodeExtent> {\n         self.param_env().temporary_scope(rvalue_id)\n     }\n+\n     fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n-        self.inh.upvar_capture_map.borrow().get(&upvar_id).cloned()\n+        self.inh.tables.borrow().upvar_capture_map.get(&upvar_id).cloned()\n     }\n }\n \n impl<'a, 'tcx> ty::ClosureTyper<'tcx> for FnCtxt<'a, 'tcx> {\n     fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n-        &self.inh.param_env\n+        &self.inh.infcx.parameter_environment\n     }\n \n     fn closure_kind(&self,\n                     def_id: ast::DefId)\n                     -> Option<ty::ClosureKind>\n     {\n-        self.inh.closure_kinds.borrow().get(&def_id).cloned()\n+        self.inh.tables.borrow().closure_kinds.get(&def_id).cloned()\n     }\n \n     fn closure_type(&self,\n                     def_id: ast::DefId,\n                     substs: &subst::Substs<'tcx>)\n                     -> ty::ClosureTy<'tcx>\n     {\n-        self.inh.closure_tys.borrow().get(&def_id).unwrap().subst(self.tcx(), substs)\n+        self.inh.tables.borrow().closure_tys.get(&def_id).unwrap().subst(self.tcx(), substs)\n     }\n \n     fn closure_upvars(&self,\n@@ -369,19 +377,14 @@ impl<'a, 'tcx> ty::ClosureTyper<'tcx> for FnCtxt<'a, 'tcx> {\n \n impl<'a, 'tcx> Inherited<'a, 'tcx> {\n     fn new(tcx: &'a ty::ctxt<'tcx>,\n+           tables: &'a RefCell<ty::Tables<'tcx>>,\n            param_env: ty::ParameterEnvironment<'a, 'tcx>)\n            -> Inherited<'a, 'tcx> {\n+\n         Inherited {\n-            infcx: infer::new_infer_ctxt(tcx),\n+            infcx: infer::new_infer_ctxt(tcx, Some(param_env)),\n             locals: RefCell::new(NodeMap()),\n-            param_env: param_env,\n-            node_types: RefCell::new(NodeMap()),\n-            item_substs: RefCell::new(NodeMap()),\n-            adjustments: RefCell::new(NodeMap()),\n-            method_map: RefCell::new(FnvHashMap()),\n-            upvar_capture_map: RefCell::new(FnvHashMap()),\n-            closure_tys: RefCell::new(DefIdMap()),\n-            closure_kinds: RefCell::new(DefIdMap()),\n+            tables: tables,\n             fn_sig_map: RefCell::new(NodeMap()),\n             fulfillment_cx: RefCell::new(traits::FulfillmentContext::new(true)),\n             deferred_call_resolutions: RefCell::new(DefIdMap()),\n@@ -424,12 +427,12 @@ pub fn blank_fn_ctxt<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn static_inherited_fields<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>)\n+fn static_inherited_fields<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>, tables: &'a RefCell<ty::Tables<'tcx>>)\n                                     -> Inherited<'a, 'tcx> {\n     // It's kind of a kludge to manufacture a fake function context\n     // and statement context, but we might as well do write the code only once\n     let param_env = ccx.tcx.empty_parameter_environment();\n-    Inherited::new(ccx.tcx, param_env)\n+    Inherited::new(ccx.tcx, &tables, param_env)\n }\n \n struct CheckItemTypesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n@@ -504,16 +507,20 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n {\n     match raw_fty.sty {\n         ty::TyBareFn(_, ref fn_ty) => {\n-            let inh = Inherited::new(ccx.tcx, param_env);\n+            let tables = RefCell::new(ty::Tables::empty());\n+            let inh = Inherited::new(ccx.tcx, &tables, param_env);\n \n             // Compute the fty from point of view of inside fn.\n             let fn_sig =\n-                fn_ty.sig.subst(ccx.tcx, &inh.param_env.free_substs);\n+                fn_ty.sig.subst(ccx.tcx, &inh.infcx.parameter_environment.free_substs);\n             let fn_sig =\n                 ccx.tcx.liberate_late_bound_regions(region::DestructionScopeData::new(body.id),\n                                                     &fn_sig);\n             let fn_sig =\n-                inh.normalize_associated_types_in(&inh.param_env, body.span, body.id, &fn_sig);\n+                inh.normalize_associated_types_in(&inh.infcx.parameter_environment,\n+                                                  body.span,\n+                                                  body.id,\n+                                                  &fn_sig);\n \n             let fcx = check_fn(ccx, fn_ty.unsafety, fn_id, &fn_sig,\n                                decl, fn_id, body, &inh);\n@@ -1198,7 +1205,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     }\n \n     fn get_free_substs(&self) -> Option<&Substs<'tcx>> {\n-        Some(&self.inh.param_env.free_substs)\n+        Some(&self.inh.infcx.parameter_environment.free_substs)\n     }\n \n     fn get_type_parameter_bounds(&self,\n@@ -1207,7 +1214,8 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n                                  -> Result<Vec<ty::PolyTraitRef<'tcx>>, ErrorReported>\n     {\n         let def = self.tcx().type_parameter_def(node_id);\n-        let r = self.inh.param_env.caller_bounds\n+        let r = self.inh.infcx.parameter_environment\n+                                  .caller_bounds\n                                   .iter()\n                                   .filter_map(|predicate| {\n                                       match *predicate {\n@@ -1273,7 +1281,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn param_env(&self) -> &ty::ParameterEnvironment<'a,'tcx> {\n-        &self.inh.param_env\n+        &self.inh.infcx.parameter_environment\n     }\n \n     pub fn sess(&self) -> &Session {\n@@ -1368,7 +1376,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// ! gets replaced with (), unconstrained ints with i32, and unconstrained floats with f64.\n     pub fn default_type_parameters(&self) {\n         use middle::ty::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat, Neither};\n-        for (_, &mut ref ty) in &mut *self.inh.node_types.borrow_mut() {\n+        for (_, &mut ref ty) in &mut self.inh.tables.borrow_mut().node_types {\n             let resolved = self.infcx().resolve_type_vars_if_possible(ty);\n             if self.infcx().type_var_diverges(resolved) {\n                 demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().mk_nil());\n@@ -1390,7 +1398,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn write_ty(&self, node_id: ast::NodeId, ty: Ty<'tcx>) {\n         debug!(\"write_ty({}, {:?}) in fcx {}\",\n                node_id, ty, self.tag());\n-        self.inh.node_types.borrow_mut().insert(node_id, ty);\n+        self.inh.tables.borrow_mut().node_types.insert(node_id, ty);\n     }\n \n     pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts<'tcx>) {\n@@ -1400,7 +1408,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                    substs,\n                    self.tag());\n \n-            self.inh.item_substs.borrow_mut().insert(node_id, substs);\n+            self.inh.tables.borrow_mut().item_substs.insert(node_id, substs);\n         }\n     }\n \n@@ -1426,7 +1434,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return;\n         }\n \n-        self.inh.adjustments.borrow_mut().insert(node_id, adj);\n+        self.inh.tables.borrow_mut().adjustments.insert(node_id, adj);\n     }\n \n     /// Basically whenever we are converting from a type scheme into\n@@ -1627,7 +1635,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn expr_ty(&self, ex: &ast::Expr) -> Ty<'tcx> {\n-        match self.inh.node_types.borrow().get(&ex.id) {\n+        match self.inh.tables.borrow().node_types.get(&ex.id) {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.bug(&format!(\"no type for expr in fcx {}\",\n@@ -1646,13 +1654,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let raw_ty = self.infcx().shallow_resolve(raw_ty);\n         let resolve_ty = |ty: Ty<'tcx>| self.infcx().resolve_type_vars_if_possible(&ty);\n         raw_ty.adjust(self.tcx(), expr.span, expr.id, adjustment, |method_call| {\n-            self.inh.method_map.borrow().get(&method_call)\n+            self.inh.tables.borrow().method_map.get(&method_call)\n                                         .map(|method| resolve_ty(method.ty))\n         })\n     }\n \n     pub fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n-        match self.inh.node_types.borrow().get(&id) {\n+        match self.inh.tables.borrow().node_types.get(&id) {\n             Some(&t) => t,\n             None if self.err_count_since_creation() != 0 => self.tcx().types.err,\n             None => {\n@@ -1665,15 +1673,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn item_substs(&self) -> Ref<NodeMap<ty::ItemSubsts<'tcx>>> {\n-        self.inh.item_substs.borrow()\n+        // NOTE: @jroesch this is hack that appears to be fixed on nightly, will monitor if it changes\n+        // when we upgrade the snapshot compiler\n+        fn project_item_susbts<'a, 'tcx>(tables: &'a ty::Tables<'tcx>) -> &'a NodeMap<ty::ItemSubsts<'tcx>> {\n+            &tables.item_substs\n+        }\n+\n+        Ref::map(self.inh.tables.borrow(), project_item_susbts)\n     }\n \n     pub fn opt_node_ty_substs<F>(&self,\n                                  id: ast::NodeId,\n                                  f: F) where\n         F: FnOnce(&ty::ItemSubsts<'tcx>),\n     {\n-        match self.inh.item_substs.borrow().get(&id) {\n+        match self.inh.tables.borrow().item_substs.get(&id) {\n             Some(s) => { f(s) }\n             None => { }\n         }\n@@ -2039,7 +2053,7 @@ fn make_overloaded_lvalue_return_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             let ret_ty = fcx.tcx().no_late_bound_regions(&ret_ty).unwrap().unwrap();\n \n             if let Some(method_call) = method_call {\n-                fcx.inh.method_map.borrow_mut().insert(method_call, method);\n+                fcx.inh.tables.borrow_mut().method_map.insert(method_call, method);\n             }\n \n             // method returns &T, but the type as visible to user is T, so deref\n@@ -2640,7 +2654,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             Ok(method) => {\n                 let method_ty = method.ty;\n                 let method_call = MethodCall::expr(expr.id);\n-                fcx.inh.method_map.borrow_mut().insert(method_call, method);\n+                fcx.inh.tables.borrow_mut().method_map.insert(method_call, method);\n                 method_ty\n             }\n             Err(error) => {\n@@ -4074,7 +4088,8 @@ fn check_block_with_expected<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n fn check_const_in_type<'a,'tcx>(ccx: &'a CrateCtxt<'a,'tcx>,\n                                 expr: &'tcx ast::Expr,\n                                 expected_type: Ty<'tcx>) {\n-    let inh = static_inherited_fields(ccx);\n+    let tables = RefCell::new(ty::Tables::empty());\n+    let inh = static_inherited_fields(ccx, &tables);\n     let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(expected_type), expr.id);\n     check_const_with_ty(&fcx, expr.span, expr, expected_type);\n }\n@@ -4083,7 +4098,8 @@ fn check_const<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                         sp: Span,\n                         e: &'tcx ast::Expr,\n                         id: ast::NodeId) {\n-    let inh = static_inherited_fields(ccx);\n+    let tables = RefCell::new(ty::Tables::empty());\n+    let inh = static_inherited_fields(ccx, &tables);\n     let rty = ccx.tcx.node_id_to_type(id);\n     let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), e.id);\n     let declty = fcx.ccx.tcx.tcache.borrow().get(&local_def(id)).unwrap().ty;\n@@ -4235,7 +4251,8 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         let rty = ccx.tcx.node_id_to_type(id);\n         let mut disr_vals: Vec<ty::Disr> = Vec::new();\n \n-        let inh = static_inherited_fields(ccx);\n+        let tables = RefCell::new(ty::Tables::empty());\n+        let inh = static_inherited_fields(ccx, &tables);\n         let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), id);\n \n         let (_, repr_type_ty) = ccx.tcx.enum_repr_type(Some(&hint));"}, {"sha": "c419a986f95b189491811fe1a1476af6a0386798", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -330,7 +330,7 @@ fn lookup_op_method<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n \n             // HACK(eddyb) Fully qualified path to work around a resolve bug.\n             let method_call = ::middle::ty::MethodCall::expr(expr.id);\n-            fcx.inh.method_map.borrow_mut().insert(method_call, method);\n+            fcx.inh.tables.borrow_mut().method_map.insert(method_call, method);\n \n             // extract return type for method; all late bound regions\n             // should have been instantiated by now\n@@ -454,4 +454,3 @@ fn is_builtin_binop<'tcx>(cx: &ty::ctxt<'tcx>,\n         }\n     }\n }\n-"}, {"sha": "8f8ec0f7264aa2f8dc965733b1212d35e80b60ec", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -124,7 +124,7 @@ pub fn regionck_expr(fcx: &FnCtxt, e: &ast::Expr) {\n pub fn regionck_item(fcx: &FnCtxt, item: &ast::Item) {\n     let mut rcx = Rcx::new(fcx, RepeatingScope(item.id), item.id, Subject(item.id));\n     let tcx = fcx.tcx();\n-    rcx.free_region_map.relate_free_regions_from_predicates(tcx, &fcx.inh.param_env.caller_bounds);\n+    rcx.free_region_map.relate_free_regions_from_predicates(tcx, &fcx.inh.infcx.parameter_environment.caller_bounds);\n     rcx.visit_region_obligations(item.id);\n     rcx.resolve_regions_and_report_errors();\n }\n@@ -143,7 +143,7 @@ pub fn regionck_fn(fcx: &FnCtxt,\n     }\n \n     let tcx = fcx.tcx();\n-    rcx.free_region_map.relate_free_regions_from_predicates(tcx, &fcx.inh.param_env.caller_bounds);\n+    rcx.free_region_map.relate_free_regions_from_predicates(tcx, &fcx.inh.infcx.parameter_environment.caller_bounds);\n \n     rcx.resolve_regions_and_report_errors();\n \n@@ -254,7 +254,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     }\n \n     fn resolve_method_type(&self, method_call: MethodCall) -> Option<Ty<'tcx>> {\n-        let method_ty = self.fcx.inh.method_map.borrow()\n+        let method_ty = self.fcx.inh.tables.borrow().method_map\n                             .get(&method_call).map(|method| method.ty);\n         method_ty.map(|method_ty| self.resolve_type(method_ty))\n     }\n@@ -267,7 +267,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         } else {\n             ty_unadjusted.adjust(\n                 self.fcx.tcx(), expr.span, expr.id,\n-                self.fcx.inh.adjustments.borrow().get(&expr.id),\n+                self.fcx.inh.tables.borrow().adjustments.get(&expr.id),\n                 |method_call| self.resolve_method_type(method_call))\n         }\n     }\n@@ -511,12 +511,13 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                       expr_ty, ty::ReScope(CodeExtent::from_node_id(expr.id)));\n \n     let method_call = MethodCall::expr(expr.id);\n-    let has_method_map = rcx.fcx.inh.method_map.borrow().contains_key(&method_call);\n+    let has_method_map = rcx.fcx.inh.tables.borrow().method_map.contains_key(&method_call);\n \n     // Check any autoderefs or autorefs that appear.\n-    if let Some(adjustment) = rcx.fcx.inh.adjustments.borrow().get(&expr.id) {\n+    let adjustment = rcx.fcx.inh.tables.borrow().adjustments.get(&expr.id).map(|a| a.clone());\n+    if let Some(adjustment) = adjustment {\n         debug!(\"adjustment={:?}\", adjustment);\n-        match *adjustment {\n+        match adjustment {\n             ty::AdjustDerefRef(ty::AutoDerefRef {autoderefs, ref autoref, ..}) => {\n                 let expr_ty = rcx.resolve_node_type(expr.id);\n                 constrain_autoderefs(rcx, expr, autoderefs, expr_ty);\n@@ -657,7 +658,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         ast::ExprUnary(ast::UnDeref, ref base) => {\n             // For *a, the lifetime of a must enclose the deref\n             let method_call = MethodCall::expr(expr.id);\n-            let base_ty = match rcx.fcx.inh.method_map.borrow().get(&method_call) {\n+            let base_ty = match rcx.fcx.inh.tables.borrow().method_map.get(&method_call) {\n                 Some(method) => {\n                     constrain_call(rcx, expr, Some(&**base),\n                                    None::<ast::Expr>.iter(), true);\n@@ -884,7 +885,9 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n         let method_call = MethodCall::autoderef(deref_expr.id, i as u32);\n         debug!(\"constrain_autoderefs: method_call={:?} (of {:?} total)\", method_call, derefs);\n \n-        derefd_ty = match rcx.fcx.inh.method_map.borrow().get(&method_call) {\n+        let method = rcx.fcx.inh.tables.borrow().method_map.get(&method_call).map(|m| m.clone());\n+\n+        derefd_ty = match method {\n             Some(method) => {\n                 debug!(\"constrain_autoderefs: #{} is overloaded, method={:?}\",\n                        i, method);\n@@ -1018,7 +1021,7 @@ fn type_of_node_must_outlive<'a, 'tcx>(\n     // report errors later on in the writeback phase.\n     let ty0 = rcx.resolve_node_type(id);\n     let ty = ty0.adjust(tcx, origin.span(), id,\n-                        rcx.fcx.inh.adjustments.borrow().get(&id),\n+                        rcx.fcx.inh.tables.borrow().adjustments.get(&id),\n                         |method_call| rcx.resolve_method_type(method_call));\n     debug!(\"constrain_regions_in_type_of_node(\\\n             ty={}, ty0={}, id={}, minimum_lifetime={:?})\",\n@@ -1292,7 +1295,7 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     // Detect by-ref upvar `x`:\n     let cause = match note {\n         mc::NoteUpvarRef(ref upvar_id) => {\n-            let upvar_capture_map = rcx.fcx.inh.upvar_capture_map.borrow_mut();\n+            let upvar_capture_map = &rcx.fcx.inh.tables.borrow_mut().upvar_capture_map;\n             match upvar_capture_map.get(upvar_id) {\n                 Some(&ty::UpvarCapture::ByRef(ref upvar_borrow)) => {\n                     // The mutability of the upvar may have been modified\n@@ -1453,7 +1456,7 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                   origin: infer::SubregionOrigin<'tcx>,\n                                   region: ty::Region,\n                                   generic: &GenericKind<'tcx>) {\n-    let param_env = &rcx.fcx.inh.param_env;\n+    let param_env = &rcx.fcx.inh.infcx.parameter_environment;\n \n     debug!(\"param_must_outlive(region={:?}, generic={:?})\",\n            region,"}, {"sha": "db32b29ebab81aca0ae8ba325b7d36998877c91c", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -129,9 +129,9 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n                      _body: &ast::Block)\n     {\n         let closure_def_id = ast_util::local_def(expr.id);\n-        if !self.fcx.inh.closure_kinds.borrow().contains_key(&closure_def_id) {\n+        if !self.fcx.inh.tables.borrow().closure_kinds.contains_key(&closure_def_id) {\n             self.closures_with_inferred_kinds.insert(expr.id);\n-            self.fcx.inh.closure_kinds.borrow_mut().insert(closure_def_id, ty::FnClosureKind);\n+            self.fcx.inh.tables.borrow_mut().closure_kinds.insert(closure_def_id, ty::FnClosureKind);\n             debug!(\"check_closure: adding closure_id={:?} to closures_with_inferred_kinds\",\n                    closure_def_id);\n         }\n@@ -156,7 +156,7 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n                     }\n                 };\n \n-                self.fcx.inh.upvar_capture_map.borrow_mut().insert(upvar_id, capture_kind);\n+                self.fcx.inh.tables.borrow_mut().upvar_capture_map.insert(upvar_id, capture_kind);\n             }\n         });\n     }\n@@ -267,7 +267,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n                         // to move out of an upvar, this must be a FnOnce closure\n                         self.adjust_closure_kind(upvar_id.closure_expr_id, ty::FnOnceClosureKind);\n \n-                        let mut upvar_capture_map = self.fcx.inh.upvar_capture_map.borrow_mut();\n+                        let upvar_capture_map = &mut self.fcx.inh.tables.borrow_mut().upvar_capture_map;\n                         upvar_capture_map.insert(upvar_id, ty::UpvarCapture::ByValue);\n                     }\n                     mc::NoteClosureEnv(upvar_id) => {\n@@ -374,9 +374,11 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n                 // upvar, then we need to modify the\n                 // borrow_kind of the upvar to make sure it\n                 // is inferred to mutable if necessary\n-                let mut upvar_capture_map = self.fcx.inh.upvar_capture_map.borrow_mut();\n-                let ub = upvar_capture_map.get_mut(&upvar_id).unwrap();\n-                self.adjust_upvar_borrow_kind(upvar_id, ub, borrow_kind);\n+                {\n+                    let upvar_capture_map = &mut self.fcx.inh.tables.borrow_mut().upvar_capture_map;\n+                    let ub = upvar_capture_map.get_mut(&upvar_id).unwrap();\n+                    self.adjust_upvar_borrow_kind(upvar_id, ub, borrow_kind);\n+                }\n \n                 // also need to be in an FnMut closure since this is not an ImmBorrow\n                 self.adjust_closure_kind(upvar_id.closure_expr_id, ty::FnMutClosureKind);\n@@ -442,7 +444,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n         }\n \n         let closure_def_id = ast_util::local_def(closure_id);\n-        let mut closure_kinds = self.fcx.inh.closure_kinds.borrow_mut();\n+        let closure_kinds = &mut self.fcx.inh.tables.borrow_mut().closure_kinds;\n         let existing_kind = *closure_kinds.get(&closure_def_id).unwrap();\n \n         debug!(\"adjust_closure_kind: closure_id={}, existing_kind={:?}, new_kind={:?}\","}, {"sha": "c2852e425b6f9cd0ab291e14e8f77594d21f558e", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -18,6 +18,7 @@ use middle::traits;\n use middle::ty::{self, Ty};\n use middle::ty_fold::{TypeFolder, TypeFoldable, super_fold_ty};\n \n+use std::cell::RefCell;\n use std::collections::HashSet;\n use syntax::ast;\n use syntax::ast_util::local_def;\n@@ -143,7 +144,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                                                 &type_scheme.generics,\n                                                                 &type_predicates,\n                                                                 item.id);\n-        let inh = Inherited::new(ccx.tcx, param_env);\n+        let tables = RefCell::new(ty::Tables::empty());\n+        let inh = Inherited::new(ccx.tcx, &tables, param_env);\n         let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(type_scheme.ty), item.id);\n         f(self, &fcx);\n         fcx.select_all_obligations_or_error();\n@@ -199,7 +201,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n             let type_scheme = fcx.tcx().lookup_item_type(local_def(item.id));\n             let item_ty = fcx.instantiate_type_scheme(item.span,\n-                                                      &fcx.inh.param_env.free_substs,\n+                                                      &fcx.inh.infcx.parameter_environment.free_substs,\n                                                       &type_scheme.ty);\n \n             bounds_checker.check_traits_in_ty(item_ty, item.span);\n@@ -220,7 +222,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             // to free.\n             let self_ty = fcx.tcx().node_id_to_type(item.id);\n             let self_ty = fcx.instantiate_type_scheme(item.span,\n-                                                      &fcx.inh.param_env.free_substs,\n+                                                      &fcx.inh.infcx.parameter_environment.free_substs,\n                                                       &self_ty);\n \n             bounds_checker.check_traits_in_ty(self_ty, item.span);\n@@ -233,7 +235,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             };\n \n             let trait_ref = fcx.instantiate_type_scheme(item.span,\n-                                                        &fcx.inh.param_env.free_substs,\n+                                                        &fcx.inh.infcx.parameter_environment.free_substs,\n                                                         &trait_ref);\n \n             // We are stricter on the trait-ref in an impl than the\n@@ -635,7 +637,7 @@ fn struct_variant<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         .map(|field| {\n             let field_ty = fcx.tcx().node_id_to_type(field.node.id);\n             let field_ty = fcx.instantiate_type_scheme(field.span,\n-                                                       &fcx.inh.param_env.free_substs,\n+                                                       &fcx.inh.infcx.parameter_environment.free_substs,\n                                                        &field_ty);\n             AdtField { ty: field_ty, span: field.span }\n         })\n@@ -660,7 +662,7 @@ fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                             let arg_ty = arg_tys[index];\n                             let arg_ty =\n                                 fcx.instantiate_type_scheme(variant.span,\n-                                                            &fcx.inh.param_env.free_substs,\n+                                                            &fcx.inh.infcx.parameter_environment.free_substs,\n                                                             &arg_ty);\n                             AdtField {\n                                 ty: arg_ty,"}, {"sha": "d990697949659f4887ed9fbe07d8f2505c392395", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -96,14 +96,14 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             let rhs_ty = self.fcx.infcx().resolve_type_vars_if_possible(&rhs_ty);\n \n             if lhs_ty.is_scalar() && rhs_ty.is_scalar() {\n-                self.fcx.inh.method_map.borrow_mut().remove(&MethodCall::expr(e.id));\n+                self.fcx.inh.tables.borrow_mut().method_map.remove(&MethodCall::expr(e.id));\n \n                 // weird but true: the by-ref binops put an\n                 // adjustment on the lhs but not the rhs; the\n                 // adjustment for rhs is kind of baked into the\n                 // system.\n                 if !ast_util::is_by_value_binop(op.node) {\n-                    self.fcx.inh.adjustments.borrow_mut().remove(&lhs.id);\n+                    self.fcx.inh.tables.borrow_mut().adjustments.remove(&lhs.id);\n                 }\n             }\n         }\n@@ -204,7 +204,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             return;\n         }\n \n-        for (upvar_id, upvar_capture) in self.fcx.inh.upvar_capture_map.borrow().iter() {\n+        for (upvar_id, upvar_capture) in self.fcx.inh.tables.borrow().upvar_capture_map.iter() {\n             let new_upvar_capture = match *upvar_capture {\n                 ty::UpvarCapture::ByValue => ty::UpvarCapture::ByValue,\n                 ty::UpvarCapture::ByRef(ref upvar_borrow) => {\n@@ -217,7 +217,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             debug!(\"Upvar capture for {:?} resolved to {:?}\",\n                    upvar_id,\n                    new_upvar_capture);\n-            self.fcx.tcx().upvar_capture_map.borrow_mut().insert(*upvar_id, new_upvar_capture);\n+            self.fcx.tcx().tables.borrow_mut().upvar_capture_map.insert(*upvar_id, new_upvar_capture);\n         }\n     }\n \n@@ -226,13 +226,13 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             return\n         }\n \n-        for (def_id, closure_ty) in self.fcx.inh.closure_tys.borrow().iter() {\n+        for (def_id, closure_ty) in self.fcx.inh.tables.borrow().closure_tys.iter() {\n             let closure_ty = self.resolve(closure_ty, ResolvingClosure(*def_id));\n-            self.fcx.tcx().closure_tys.borrow_mut().insert(*def_id, closure_ty);\n+            self.fcx.tcx().tables.borrow_mut().closure_tys.insert(*def_id, closure_ty);\n         }\n \n-        for (def_id, &closure_kind) in self.fcx.inh.closure_kinds.borrow().iter() {\n-            self.fcx.tcx().closure_kinds.borrow_mut().insert(*def_id, closure_kind);\n+        for (def_id, &closure_kind) in self.fcx.inh.tables.borrow().closure_kinds.iter() {\n+            self.fcx.tcx().tables.borrow_mut().closure_kinds.insert(*def_id, closure_kind);\n         }\n     }\n \n@@ -254,7 +254,8 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     }\n \n     fn visit_adjustments(&self, reason: ResolveReason, id: ast::NodeId) {\n-        match self.fcx.inh.adjustments.borrow_mut().remove(&id) {\n+        let adjustments = self.fcx.inh.tables.borrow_mut().adjustments.remove(&id);\n+        match adjustments {\n             None => {\n                 debug!(\"No adjustments for node {}\", id);\n             }\n@@ -281,7 +282,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                     }\n                 };\n                 debug!(\"Adjustments for node {}: {:?}\", id, resolved_adjustment);\n-                self.tcx().adjustments.borrow_mut().insert(\n+                self.tcx().tables.borrow_mut().adjustments.insert(\n                     id, resolved_adjustment);\n             }\n         }\n@@ -291,7 +292,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                               reason: ResolveReason,\n                               method_call: MethodCall) {\n         // Resolve any method map entry\n-        match self.fcx.inh.method_map.borrow_mut().remove(&method_call) {\n+        let new_method = match self.fcx.inh.tables.borrow_mut().method_map.remove(&method_call) {\n             Some(method) => {\n                 debug!(\"writeback::resolve_method_map_entry(call={:?}, entry={:?})\",\n                        method_call,\n@@ -302,9 +303,17 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                     substs: self.resolve(&method.substs, reason),\n                 };\n \n-                self.tcx().method_map.borrow_mut().insert(\n+                Some(new_method)\n+            }\n+            None => None\n+        };\n+\n+        //NB(jroesch): We need to match twice to avoid a double borrow which would cause an ICE\n+        match new_method {\n+            Some(method) => {\n+                self.tcx().tables.borrow_mut().method_map.insert(\n                     method_call,\n-                    new_method);\n+                    method);\n             }\n             None => {}\n         }"}, {"sha": "5441f0b6772000c8b4b69b80bb1788fa426845bf", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -448,7 +448,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (free)\",\n                    source, target);\n \n-            let infcx = new_infer_ctxt(tcx);\n+            let infcx = new_infer_ctxt(tcx, Some(param_env));\n \n             let check_mutbl = |mt_a: ty::mt<'tcx>, mt_b: ty::mt<'tcx>,\n                                mk_ptr: &Fn(Ty<'tcx>) -> Ty<'tcx>| {\n@@ -540,13 +540,13 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             fulfill_cx.register_predicate_obligation(&infcx, predicate);\n \n             // Check that all transitive obligations are satisfied.\n-            if let Err(errors) = fulfill_cx.select_all_or_error(&infcx, &param_env) {\n+            if let Err(errors) = fulfill_cx.select_all_or_error(&infcx, &infcx.parameter_environment) {\n                 traits::report_fulfillment_errors(&infcx, &errors);\n             }\n \n             // Finally, resolve all regions.\n             let mut free_regions = FreeRegionMap::new();\n-            free_regions.relate_free_regions_from_predicates(tcx, &param_env.caller_bounds);\n+            free_regions.relate_free_regions_from_predicates(tcx, &infcx.parameter_environment.caller_bounds);\n             infcx.resolve_regions_and_report_errors(&free_regions, impl_did.node);\n \n             if let Some(kind) = kind {\n@@ -630,7 +630,7 @@ fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n pub fn check_coherence(crate_context: &CrateCtxt) {\n     CoherenceChecker {\n         crate_context: crate_context,\n-        inference_context: new_infer_ctxt(crate_context.tcx),\n+        inference_context: new_infer_ctxt(crate_context.tcx, None),\n         inherent_impls: RefCell::new(FnvHashMap()),\n     }.check(crate_context.tcx.map.krate());\n     unsafety::check(crate_context.tcx);"}, {"sha": "a851bb93e3fc75b560d0bd65422501554b034d9e", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -133,7 +133,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n                    impl1_def_id,\n                    impl2_def_id);\n \n-            let infcx = infer::new_infer_ctxt(self.tcx);\n+            let infcx = infer::new_infer_ctxt(self.tcx, None);\n             if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n                 self.report_overlap_error(trait_def_id, impl1_def_id, impl2_def_id);\n             }"}, {"sha": "3e2a88e1f79c10002d2b5172c9d3a2aced04ea4f", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -2204,7 +2204,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n                base_type,\n                base_type_free);\n \n-        let infcx = infer::new_infer_ctxt(tcx);\n+        let infcx = infer::new_infer_ctxt(tcx, None);\n         drop(::require_same_types(tcx,\n                                   Some(&infcx),\n                                   false,"}, {"sha": "5d589d2ec78c978dbf65144ae03aa0f26044ce3c", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02895fffa865c6a4ccfaad1fa35d8f732d497/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=79d02895fffa865c6a4ccfaad1fa35d8f732d497", "patch": "@@ -88,6 +88,7 @@ This API is completely unstable and subject to change.\n #![feature(slice_extras)]\n #![feature(staged_api)]\n #![feature(vec_push_all)]\n+#![feature(cell_extras)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n@@ -162,7 +163,7 @@ fn write_substs_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n         assert!(!item_substs.substs.types.needs_infer());\n \n-        tcx.item_substs.borrow_mut().insert(node_id, item_substs);\n+        tcx.tables.borrow_mut().item_substs.insert(node_id, item_substs);\n     }\n }\n \n@@ -187,7 +188,7 @@ fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n {\n     let result = match maybe_infcx {\n         None => {\n-            let infcx = infer::new_infer_ctxt(tcx);\n+            let infcx = infer::new_infer_ctxt(tcx, None);\n             infer::mk_eqty(&infcx, t1_is_expected, infer::Misc(span), t1, t2)\n         }\n         Some(infcx) => {"}]}