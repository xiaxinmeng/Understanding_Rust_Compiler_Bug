{"sha": "d492c6792c4fa24fb542bf457667f45b55b7c093", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0OTJjNjc5MmM0ZmEyNGZiNTQyYmY0NTc2NjdmNDViNTViN2MwOTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-28T16:00:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-28T16:00:00Z"}, "message": "Auto merge of #55433 - kennytm:rollup, r=kennytm\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #55148 (Implement FromStr for PathBuf)\n - #55185 (path suggestions in Rust 2018 should point out the change in semantics)\n - #55191 (Fix sub-variant doc display)\n - #55199 (Impl items have generics)\n - #55244 (Don't rerun MIR passes when inlining)\n - #55252 (Add MaybeUninit::new)\n - #55257 (Allow extern statics with an extern type)\n - #55389 (Remove unnecessary mut in iterator.find_map documentation example, R\u2026)\n - #55406 (Update string.rs)\n - #55412 (Fix an ICE in the min_const_fn analysis)\n - #55421 (Add ManuallyDrop::take)", "tree": {"sha": "9892c6dda3a4ea5cbc0317ff8725ea1929c47d2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9892c6dda3a4ea5cbc0317ff8725ea1929c47d2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d492c6792c4fa24fb542bf457667f45b55b7c093", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d492c6792c4fa24fb542bf457667f45b55b7c093", "html_url": "https://github.com/rust-lang/rust/commit/d492c6792c4fa24fb542bf457667f45b55b7c093", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d492c6792c4fa24fb542bf457667f45b55b7c093/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f5cfa611d392e87166dfe053ca253c3e822d835", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f5cfa611d392e87166dfe053ca253c3e822d835", "html_url": "https://github.com/rust-lang/rust/commit/4f5cfa611d392e87166dfe053ca253c3e822d835"}, {"sha": "db4e77ce91e7cd2b87d217d479658e27f9b0a2db", "url": "https://api.github.com/repos/rust-lang/rust/commits/db4e77ce91e7cd2b87d217d479658e27f9b0a2db", "html_url": "https://github.com/rust-lang/rust/commit/db4e77ce91e7cd2b87d217d479658e27f9b0a2db"}], "stats": {"total": 557, "additions": 386, "deletions": 171}, "files": [{"sha": "ff3587d5d87306af60550c20f71c5d24325ba626", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -413,7 +413,7 @@ impl String {\n     ///\n     /// // These are all done without reallocating...\n     /// let cap = s.capacity();\n-    /// for i in 0..10 {\n+    /// for _ in 0..10 {\n     ///     s.push('a');\n     /// }\n     ///"}, {"sha": "2903c370df898e3d107f6946d14268dd69f09693", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -1857,7 +1857,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [\"lol\", \"NaN\", \"2\", \"5\"];\n     ///\n-    /// let mut first_number = a.iter().find_map(|s| s.parse().ok());\n+    /// let first_number = a.iter().find_map(|s| s.parse().ok());\n     ///\n     /// assert_eq!(first_number, Some(2));\n     /// ```"}, {"sha": "06727d8292d367e422f89d87542a82413d80cc0e", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -82,6 +82,7 @@\n #![feature(const_fn)]\n #![feature(const_int_ops)]\n #![feature(const_fn_union)]\n+#![feature(const_manually_drop_new)]\n #![feature(custom_attribute)]\n #![feature(doc_cfg)]\n #![feature(doc_spotlight)]"}, {"sha": "22016e8cf41742612d1a1e62665ac03f93aec27f", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -973,6 +973,26 @@ impl<T> ManuallyDrop<T> {\n     pub fn into_inner(slot: ManuallyDrop<T>) -> T {\n         slot.value\n     }\n+\n+    /// Takes the contained value out.\n+    ///\n+    /// This method is primarily intended for moving out values in drop.\n+    /// Instead of using [`ManuallyDrop::drop`] to manually drop the value,\n+    /// you can use this method to take the value and use it however desired.\n+    /// `Drop` will be invoked on the returned value following normal end-of-scope rules.\n+    ///\n+    /// If you have ownership of the container, you can use [`ManuallyDrop::into_inner`] instead.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function semantically moves out the contained value without preventing further usage.\n+    /// It is up to the user of this method to ensure that this container is not used again.\n+    #[must_use = \"if you don't need the value, you can use `ManuallyDrop::drop` instead\"]\n+    #[unstable(feature = \"manually_drop_take\", issue = \"55422\")]\n+    #[inline]\n+    pub unsafe fn take(slot: &mut ManuallyDrop<T>) -> T {\n+        ManuallyDrop::into_inner(ptr::read(slot))\n+    }\n }\n \n impl<T: ?Sized> ManuallyDrop<T> {\n@@ -1021,6 +1041,15 @@ pub union MaybeUninit<T> {\n }\n \n impl<T> MaybeUninit<T> {\n+    /// Create a new `MaybeUninit` initialized with the given value.\n+    ///\n+    /// Note that dropping a `MaybeUninit` will never call `T`'s drop code.\n+    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    pub const fn new(val: T) -> MaybeUninit<T> {\n+        MaybeUninit { value: ManuallyDrop::new(val) }\n+    }\n+\n     /// Create a new `MaybeUninit` in an uninitialized state.\n     ///\n     /// Note that dropping a `MaybeUninit` will never call `T`'s drop code."}, {"sha": "4fea07011ccfbb65268e7d443d4e7174732a602c", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -69,13 +69,38 @@ impl<'tcx> HasLocalDecls<'tcx> for Mir<'tcx> {\n     }\n }\n \n+/// The various \"big phases\" that MIR goes through.\n+///\n+/// Warning: ordering of variants is significant\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+pub enum MirPhase {\n+    Build = 0,\n+    Const = 1,\n+    Validated = 2,\n+    Optimized = 3,\n+}\n+\n+impl MirPhase {\n+    /// Gets the index of the current MirPhase within the set of all MirPhases.\n+    pub fn phase_index(&self) -> usize {\n+        *self as usize\n+    }\n+}\n+\n /// Lowered representation of a single function.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Mir<'tcx> {\n     /// List of basic blocks. References to basic block use a newtyped index type `BasicBlock`\n     /// that indexes into this vector.\n     basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n \n+    /// Records how far through the \"desugaring and optimization\" process this particular\n+    /// MIR has traversed. This is particularly useful when inlining, since in that context\n+    /// we instantiate the promoted constants and add them to our promoted vector -- but those\n+    /// promoted items have already been optimized, whereas ours have not. This field allows\n+    /// us to see the difference and forego optimization on the inlined promoted items.\n+    pub phase: MirPhase,\n+\n     /// List of source scopes; these are referenced by statements\n     /// and used for debuginfo. Indexed by a `SourceScope`.\n     pub source_scopes: IndexVec<SourceScope, SourceScopeData>,\n@@ -151,6 +176,7 @@ impl<'tcx> Mir<'tcx> {\n         );\n \n         Mir {\n+            phase: MirPhase::Build,\n             basic_blocks,\n             source_scopes,\n             source_scope_local_data,\n@@ -368,6 +394,7 @@ pub enum Safety {\n }\n \n impl_stable_hash_for!(struct Mir<'tcx> {\n+    phase,\n     basic_blocks,\n     source_scopes,\n     source_scope_local_data,\n@@ -616,6 +643,13 @@ impl_stable_hash_for!(enum self::ImplicitSelfKind {\n     None\n });\n \n+impl_stable_hash_for!(enum self::MirPhase {\n+    Build,\n+    Const,\n+    Validated,\n+    Optimized,\n+});\n+\n mod binding_form_impl {\n     use ich::StableHashingContext;\n     use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n@@ -2905,6 +2939,7 @@ pub enum ClosureOutlivesSubject<'tcx> {\n \n CloneTypeFoldableAndLiftImpls! {\n     BlockTailInfo,\n+    MirPhase,\n     Mutability,\n     SourceInfo,\n     UpvarDecl,\n@@ -2917,6 +2952,7 @@ CloneTypeFoldableAndLiftImpls! {\n \n BraceStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for Mir<'tcx> {\n+        phase,\n         basic_blocks,\n         source_scopes,\n         source_scope_local_data,"}, {"sha": "abdd7fd8d40bf0d220ad2022d1fa47d6f12eb243", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -251,25 +251,17 @@ impl PrintContext {\n     fn parameterized<F: fmt::Write>(&mut self,\n                                     f: &mut F,\n                                     substs: &subst::Substs<'_>,\n-                                    mut did: DefId,\n+                                    did: DefId,\n                                     projections: &[ty::ProjectionPredicate<'_>])\n                                     -> fmt::Result {\n         let key = ty::tls::with(|tcx| tcx.def_key(did));\n-        let mut item_name = if let Some(name) = key.disambiguated_data.data.get_opt_name() {\n-            Some(name)\n-        } else {\n-            did.index = key.parent.unwrap_or_else(\n-                || bug!(\"finding type for {:?}, encountered def-id {:?} with no parent\",\n-                        did, did));\n-            self.parameterized(f, substs, did, projections)?;\n-            return write!(f, \"::{}\", key.disambiguated_data.data.as_interned_str());\n-        };\n \n         let verbose = self.is_verbose;\n         let mut num_supplied_defaults = 0;\n         let mut has_self = false;\n         let mut own_counts: GenericParamCount = Default::default();\n         let mut is_value_path = false;\n+        let mut item_name = Some(key.disambiguated_data.data.as_interned_str());\n         let fn_trait_kind = ty::tls::with(|tcx| {\n             // Unfortunately, some kinds of items (e.g., closures) don't have\n             // generics. So walk back up the find the closest parent that DOES\n@@ -282,6 +274,7 @@ impl PrintContext {\n                     DefPathData::AssocTypeInImpl(_) |\n                     DefPathData::AssocExistentialInImpl(_) |\n                     DefPathData::Trait(_) |\n+                    DefPathData::Impl |\n                     DefPathData::TypeNs(_) => {\n                         break;\n                     }\n@@ -292,7 +285,6 @@ impl PrintContext {\n                     }\n                     DefPathData::CrateRoot |\n                     DefPathData::Misc |\n-                    DefPathData::Impl |\n                     DefPathData::Module(_) |\n                     DefPathData::MacroDef(_) |\n                     DefPathData::ClosureExpr |"}, {"sha": "d92001704285a84a34240e63dc5846faad6aaa0d", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -612,6 +612,13 @@ pub fn const_eval_raw_provider<'a, 'tcx>(\n             other => return other,\n         }\n     }\n+    // the first trace is for replicating an ice\n+    // There's no tracking issue, but the next two lines concatenated link to the discussion on\n+    // zulip. It's not really possible to test this, because it doesn't show up in diagnostics\n+    // or MIR.\n+    // https://rust-lang.zulipchat.com/#narrow/stream/146212-t-compiler.2Fconst-eval/\n+    // subject/anon_const_instance_printing/near/135980032\n+    trace!(\"const eval: {}\", key.value.instance);\n     trace!(\"const eval: {:?}\", key);\n \n     let cid = key.value;"}, {"sha": "cfccb950e8276a64a8a1c998b76f06fae68b9561", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -184,7 +184,6 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n     }\n \n     crate fn borrows(&self) -> &IndexVec<BorrowIndex, BorrowData<'tcx>> { &self.borrow_set.borrows }\n-    pub fn scope_tree(&self) -> &Lrc<region::ScopeTree> { &self.scope_tree }\n \n     pub fn location(&self, idx: BorrowIndex) -> &Location {\n         &self.borrow_set.borrows[idx].reserve_location"}, {"sha": "c19145636e6da101b7580299e3fee13c6c7eacb1", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -724,20 +724,6 @@ impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n             }\n         }\n     }\n-\n-    pub fn new_from_sets(mir: &'a Mir<'tcx>,\n-                         dead_unwinds: &'a BitSet<mir::BasicBlock>,\n-                         sets: AllSets<D::Idx>,\n-                         denotation: D) -> Self {\n-        DataflowAnalysis {\n-            mir,\n-            dead_unwinds,\n-            flow_state: DataflowState {\n-                sets: sets,\n-                operator: denotation,\n-            }\n-        }\n-    }\n }\n \n impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation"}, {"sha": "46c73c27fe10d547548bef204d4217cf2f08fcf6", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 73, "deletions": 57, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -11,7 +11,7 @@\n use borrow_check::nll::type_check;\n use build;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use rustc::mir::{Mir, Promoted};\n+use rustc::mir::{Mir, MirPhase, Promoted};\n use rustc::ty::TyCtxt;\n use rustc::ty::query::Providers;\n use rustc::ty::steal::Steal;\n@@ -155,53 +155,69 @@ pub trait MirPass {\n                           mir: &mut Mir<'tcx>);\n }\n \n-pub macro run_passes($tcx:ident, $mir:ident, $def_id:ident, $suite_index:expr; $($pass:expr,)*) {{\n-    let suite_index: usize = $suite_index;\n-    let run_passes = |mir: &mut _, promoted| {\n+pub fn run_passes(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir: &mut Mir<'tcx>,\n+    def_id: DefId,\n+    mir_phase: MirPhase,\n+    passes: &[&dyn MirPass],\n+) {\n+    let phase_index = mir_phase.phase_index();\n+\n+    let run_passes = |mir: &mut Mir<'tcx>, promoted| {\n+        if mir.phase >= mir_phase {\n+            return;\n+        }\n+\n         let source = MirSource {\n-            def_id: $def_id,\n-            promoted\n+            def_id,\n+            promoted,\n         };\n         let mut index = 0;\n         let mut run_pass = |pass: &dyn MirPass| {\n             let run_hooks = |mir: &_, index, is_after| {\n-                dump_mir::on_mir_pass($tcx, &format_args!(\"{:03}-{:03}\", suite_index, index),\n+                dump_mir::on_mir_pass(tcx, &format_args!(\"{:03}-{:03}\", phase_index, index),\n                                       &pass.name(), source, mir, is_after);\n             };\n             run_hooks(mir, index, false);\n-            pass.run_pass($tcx, source, mir);\n+            pass.run_pass(tcx, source, mir);\n             run_hooks(mir, index, true);\n \n             index += 1;\n         };\n-        $(run_pass(&$pass);)*\n+\n+        for pass in passes {\n+            run_pass(*pass);\n+        }\n+\n+        mir.phase = mir_phase;\n     };\n \n-    run_passes(&mut $mir, None);\n+    run_passes(mir, None);\n \n-    for (index, promoted_mir) in $mir.promoted.iter_enumerated_mut() {\n+    for (index, promoted_mir) in mir.promoted.iter_enumerated_mut() {\n         run_passes(promoted_mir, Some(index));\n \n-        // Let's make sure we don't miss any nested instances\n-        assert!(promoted_mir.promoted.is_empty());\n+        //Let's make sure we don't miss any nested instances\n+        assert!(promoted_mir.promoted.is_empty())\n     }\n-}}\n+}\n \n fn mir_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Mir<'tcx>> {\n     // Unsafety check uses the raw mir, so make sure it is run\n     let _ = tcx.unsafety_check_result(def_id);\n \n     let mut mir = tcx.mir_built(def_id).steal();\n-    run_passes![tcx, mir, def_id, 0;\n+    run_passes(tcx, &mut mir, def_id, MirPhase::Const, &[\n         // Remove all `EndRegion` statements that are not involved in borrows.\n-        cleanup_post_borrowck::CleanEndRegions,\n+        &cleanup_post_borrowck::CleanEndRegions,\n \n         // What we need to do constant evaluation.\n-        simplify::SimplifyCfg::new(\"initial\"),\n-        type_check::TypeckMir,\n-        rustc_peek::SanityCheck,\n-        uniform_array_move_out::UniformArrayMoveOut,\n-    ];\n+        &simplify::SimplifyCfg::new(\"initial\"),\n+        &type_check::TypeckMir,\n+        &rustc_peek::SanityCheck,\n+        &uniform_array_move_out::UniformArrayMoveOut,\n+    ]);\n     tcx.alloc_steal_mir(mir)\n }\n \n@@ -214,11 +230,11 @@ fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n     }\n \n     let mut mir = tcx.mir_const(def_id).steal();\n-    run_passes![tcx, mir, def_id, 1;\n+    run_passes(tcx, &mut mir, def_id, MirPhase::Validated, &[\n         // What we need to run borrowck etc.\n-        qualify_consts::QualifyAndPromoteConstants,\n-        simplify::SimplifyCfg::new(\"qualify-consts\"),\n-    ];\n+        &qualify_consts::QualifyAndPromoteConstants,\n+        &simplify::SimplifyCfg::new(\"qualify-consts\"),\n+    ]);\n     tcx.alloc_steal_mir(mir)\n }\n \n@@ -232,59 +248,59 @@ fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n     }\n \n     let mut mir = tcx.mir_validated(def_id).steal();\n-    run_passes![tcx, mir, def_id, 2;\n+    run_passes(tcx, &mut mir, def_id, MirPhase::Optimized, &[\n         // Remove all things not needed by analysis\n-        no_landing_pads::NoLandingPads,\n-        simplify_branches::SimplifyBranches::new(\"initial\"),\n-        remove_noop_landing_pads::RemoveNoopLandingPads,\n+        &no_landing_pads::NoLandingPads,\n+        &simplify_branches::SimplifyBranches::new(\"initial\"),\n+        &remove_noop_landing_pads::RemoveNoopLandingPads,\n         // Remove all `AscribeUserType` statements.\n-        cleanup_post_borrowck::CleanAscribeUserType,\n+        &cleanup_post_borrowck::CleanAscribeUserType,\n         // Remove all `FakeRead` statements and the borrows that are only\n         // used for checking matches\n-        cleanup_post_borrowck::CleanFakeReadsAndBorrows,\n-        simplify::SimplifyCfg::new(\"early-opt\"),\n+        &cleanup_post_borrowck::CleanFakeReadsAndBorrows,\n+        &simplify::SimplifyCfg::new(\"early-opt\"),\n \n         // These next passes must be executed together\n-        add_call_guards::CriticalCallEdges,\n-        elaborate_drops::ElaborateDrops,\n-        no_landing_pads::NoLandingPads,\n+        &add_call_guards::CriticalCallEdges,\n+        &elaborate_drops::ElaborateDrops,\n+        &no_landing_pads::NoLandingPads,\n         // AddValidation needs to run after ElaborateDrops and before EraseRegions, and it needs\n         // an AllCallEdges pass right before it.\n-        add_call_guards::AllCallEdges,\n-        add_validation::AddValidation,\n+        &add_call_guards::AllCallEdges,\n+        &add_validation::AddValidation,\n         // AddMovesForPackedDrops needs to run after drop\n         // elaboration.\n-        add_moves_for_packed_drops::AddMovesForPackedDrops,\n+        &add_moves_for_packed_drops::AddMovesForPackedDrops,\n \n-        simplify::SimplifyCfg::new(\"elaborate-drops\"),\n+        &simplify::SimplifyCfg::new(\"elaborate-drops\"),\n \n         // No lifetime analysis based on borrowing can be done from here on out.\n \n         // From here on out, regions are gone.\n-        erase_regions::EraseRegions,\n+        &erase_regions::EraseRegions,\n \n-        lower_128bit::Lower128Bit,\n+        &lower_128bit::Lower128Bit,\n \n \n         // Optimizations begin.\n-        uniform_array_move_out::RestoreSubsliceArrayMoveOut,\n-        inline::Inline,\n+        &uniform_array_move_out::RestoreSubsliceArrayMoveOut,\n+        &inline::Inline,\n \n         // Lowering generator control-flow and variables\n         // has to happen before we do anything else to them.\n-        generator::StateTransform,\n-\n-        instcombine::InstCombine,\n-        const_prop::ConstProp,\n-        simplify_branches::SimplifyBranches::new(\"after-const-prop\"),\n-        deaggregator::Deaggregator,\n-        copy_prop::CopyPropagation,\n-        remove_noop_landing_pads::RemoveNoopLandingPads,\n-        simplify::SimplifyCfg::new(\"final\"),\n-        simplify::SimplifyLocals,\n-\n-        add_call_guards::CriticalCallEdges,\n-        dump_mir::Marker(\"PreCodegen\"),\n-    ];\n+        &generator::StateTransform,\n+\n+        &instcombine::InstCombine,\n+        &const_prop::ConstProp,\n+        &simplify_branches::SimplifyBranches::new(\"after-const-prop\"),\n+        &deaggregator::Deaggregator,\n+        &copy_prop::CopyPropagation,\n+        &remove_noop_landing_pads::RemoveNoopLandingPads,\n+        &simplify::SimplifyCfg::new(\"final\"),\n+        &simplify::SimplifyLocals,\n+\n+        &add_call_guards::CriticalCallEdges,\n+        &dump_mir::Marker(\"PreCodegen\"),\n+    ]);\n     tcx.alloc_mir(mir)\n }"}, {"sha": "6ab68789c027ba7bbdeb1a1aea580d676979b47d", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -317,7 +317,8 @@ fn check_terminator(\n             check_place(tcx, mir, location, span, PlaceMode::Read)?;\n             check_operand(tcx, mir, value, span)\n         },\n-        TerminatorKind::SwitchInt { .. } => Err((\n+\n+        TerminatorKind::FalseEdges { .. } | TerminatorKind::SwitchInt { .. } => Err((\n             span,\n             \"`if`, `match`, `&&` and `||` are not stable in const fn\".into(),\n         )),\n@@ -363,7 +364,7 @@ fn check_terminator(\n             cleanup: _,\n         } => check_operand(tcx, mir, cond, span),\n \n-        | TerminatorKind::FalseEdges { .. } | TerminatorKind::FalseUnwind { .. } => span_bug!(\n+        | TerminatorKind::FalseUnwind { .. } => span_bug!(\n             terminator.source_info.span,\n             \"min_const_fn encountered `{:#?}`\",\n             terminator"}, {"sha": "50ab8ef9c7be7cfaa543466579af248d96beaa5a", "filename": "src/librustc_resolve/error_reporting.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -26,7 +26,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         span: Span,\n         path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<Vec<Segment>> {\n+    ) -> Option<(Vec<Segment>, Option<String>)> {\n         debug!(\"make_path_suggestion: span={:?} path={:?}\", span, path);\n         // If we don't have a path to suggest changes to, then return.\n         if path.is_empty() {\n@@ -65,13 +65,13 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<Vec<Segment>> {\n+    ) -> Option<(Vec<Segment>, Option<String>)> {\n         // Replace first ident with `self` and check if that is valid.\n         path[0].ident.name = keywords::SelfValue.name();\n         let result = self.resolve_path(None, &path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n-            Some(path)\n+            Some((path, None))\n         } else {\n             None\n         }\n@@ -89,13 +89,20 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<Vec<Segment>> {\n+    ) -> Option<(Vec<Segment>, Option<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = keywords::Crate.name();\n         let result = self.resolve_path(None, &path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n-            Some(path)\n+            Some((\n+                path,\n+                Some(\n+                    \"`use` statements changed in Rust 2018; read more at \\\n+                     <https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-\\\n+                     clarity.html>\".to_string()\n+                ),\n+            ))\n         } else {\n             None\n         }\n@@ -113,13 +120,13 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<Vec<Segment>> {\n+    ) -> Option<(Vec<Segment>, Option<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = keywords::Super.name();\n         let result = self.resolve_path(None, &path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n-            Some(path)\n+            Some((path, None))\n         } else {\n             None\n         }\n@@ -140,7 +147,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<Vec<Segment>> {\n+    ) -> Option<(Vec<Segment>, Option<String>)> {\n         // Need to clone else we can't call `resolve_path` without a borrow error. We also store\n         // into a `BTreeMap` so we can get consistent ordering (and therefore the same diagnostic)\n         // each time.\n@@ -162,7 +169,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             debug!(\"make_external_crate_suggestion: name={:?} path={:?} result={:?}\",\n                     name, path, result);\n             if let PathResult::Module(..) = result {\n-                return Some(path)\n+                return Some((path, None));\n             }\n         }\n "}, {"sha": "359640ccda2b1eb6360e868f45c0dd69c42df2b6", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 45, "deletions": 20, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -707,7 +707,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                         }\n                     }\n                 });\n-            } else if let Some((span, err)) = error {\n+            } else if let Some((span, err, note)) = error {\n                 errors = true;\n \n                 if let SingleImport { source, ref result, .. } = import.subclass {\n@@ -737,7 +737,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                         &import.subclass,\n                         span,\n                     );\n-                    error_vec.push((span, path, err));\n+                    error_vec.push((span, path, err, note));\n                     seen_spans.insert(span);\n                     prev_root_id = import.root_id;\n                 }\n@@ -829,27 +829,45 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         }\n     }\n \n-    fn throw_unresolved_import_error(&self, error_vec: Vec<(Span, String, String)>,\n-                                     span: Option<MultiSpan>) {\n+    fn throw_unresolved_import_error(\n+        &self,\n+        error_vec: Vec<(Span, String, String, Option<String>)>,\n+        span: Option<MultiSpan>,\n+    ) {\n         let max_span_label_msg_count = 10;  // upper limit on number of span_label message.\n-        let (span, msg) = if error_vec.is_empty() {\n-            (span.unwrap(), \"unresolved import\".to_string())\n+        let (span, msg, note) = if error_vec.is_empty() {\n+            (span.unwrap(), \"unresolved import\".to_string(), None)\n         } else {\n-            let span = MultiSpan::from_spans(error_vec.clone().into_iter()\n-                .map(|elem: (Span, String, String)| { elem.0 })\n-                .collect());\n+            let span = MultiSpan::from_spans(\n+                error_vec.clone().into_iter()\n+                .map(|elem: (Span, String, String, Option<String>)| elem.0)\n+                .collect()\n+            );\n+\n+            let note: Option<String> = error_vec.clone().into_iter()\n+                .filter_map(|elem: (Span, String, String, Option<String>)| elem.3)\n+                .last();\n+\n             let path_vec: Vec<String> = error_vec.clone().into_iter()\n-                .map(|elem: (Span, String, String)| { format!(\"`{}`\", elem.1) })\n+                .map(|elem: (Span, String, String, Option<String>)| format!(\"`{}`\", elem.1))\n                 .collect();\n             let path = path_vec.join(\", \");\n-            let msg = format!(\"unresolved import{} {}\",\n-                if path_vec.len() > 1 { \"s\" } else { \"\" }, path);\n-            (span, msg)\n+            let msg = format!(\n+                \"unresolved import{} {}\",\n+                if path_vec.len() > 1 { \"s\" } else { \"\" },\n+                path\n+            );\n+\n+            (span, msg, note)\n         };\n+\n         let mut err = struct_span_err!(self.resolver.session, span, E0432, \"{}\", &msg);\n         for span_error in error_vec.into_iter().take(max_span_label_msg_count) {\n             err.span_label(span_error.0, span_error.2);\n         }\n+        if let Some(note) = note {\n+            err.note(&note);\n+        }\n         err.emit();\n     }\n \n@@ -945,7 +963,10 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     }\n \n     // If appropriate, returns an error to report.\n-    fn finalize_import(&mut self, directive: &'b ImportDirective<'b>) -> Option<(Span, String)> {\n+    fn finalize_import(\n+        &mut self,\n+        directive: &'b ImportDirective<'b>\n+    ) -> Option<(Span, String, Option<String>)> {\n         self.current_module = directive.parent_scope.module;\n         let ImportDirective { ref module_path, span, .. } = *directive;\n \n@@ -969,15 +990,16 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 return None;\n             }\n             PathResult::Failed(span, msg, true) => {\n-                return if let Some(suggested_path) = self.make_path_suggestion(\n+                return if let Some((suggested_path, note)) = self.make_path_suggestion(\n                     span, module_path.clone(), &directive.parent_scope\n                 ) {\n                     Some((\n                         span,\n-                        format!(\"Did you mean `{}`?\", Segment::names_to_string(&suggested_path))\n+                        format!(\"Did you mean `{}`?\", Segment::names_to_string(&suggested_path)),\n+                        note,\n                     ))\n                 } else {\n-                    Some((span, msg))\n+                    Some((span, msg, None))\n                 };\n             },\n             _ => return None,\n@@ -1002,8 +1024,11 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 if let ModuleOrUniformRoot::Module(module) = module {\n                     if module.def_id() == directive.parent_scope.module.def_id() {\n                         // Importing a module into itself is not allowed.\n-                        return Some((directive.span,\n-                            \"Cannot glob-import a module into itself.\".to_string()));\n+                        return Some((\n+                            directive.span,\n+                            \"Cannot glob-import a module into itself.\".to_string(),\n+                            None,\n+                        ));\n                     }\n                 }\n                 if !is_prelude &&\n@@ -1101,7 +1126,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                         }\n                     }\n                 };\n-                Some((span, msg))\n+                Some((span, msg, None))\n             } else {\n                 // `resolve_ident_in_module` reported a privacy error.\n                 self.import_dummy_binding(directive);"}, {"sha": "ea84e874b1a5b3b9dc6abb2a7f5bad9ff37f3bc5", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -13,7 +13,7 @@ use constrained_type_params::{identify_constrained_type_params, Parameter};\n \n use hir::def_id::DefId;\n use rustc::traits::{self, ObligationCauseCode};\n-use rustc::ty::{self, Lift, Ty, TyCtxt, GenericParamDefKind, TypeFoldable};\n+use rustc::ty::{self, Lift, Ty, TyCtxt, TyKind, GenericParamDefKind, TypeFoldable};\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::util::ExplicitSelf;\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n@@ -119,14 +119,14 @@ pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: Def\n             check_item_fn(tcx, item);\n         }\n         hir::ItemKind::Static(ref ty, ..) => {\n-            check_item_type(tcx, item.id, ty.span);\n+            check_item_type(tcx, item.id, ty.span, false);\n         }\n         hir::ItemKind::Const(ref ty, ..) => {\n-            check_item_type(tcx, item.id, ty.span);\n+            check_item_type(tcx, item.id, ty.span, false);\n         }\n         hir::ItemKind::ForeignMod(ref module) => for it in module.items.iter() {\n             if let hir::ForeignItemKind::Static(ref ty, ..) = it.node {\n-                check_item_type(tcx, it.id, ty.span);\n+                check_item_type(tcx, it.id, ty.span, true);\n             }\n         },\n         hir::ItemKind::Struct(ref struct_def, ref ast_generics) => {\n@@ -340,23 +340,33 @@ fn check_item_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n     })\n }\n \n-fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId, ty_span: Span) {\n+fn check_item_type<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    item_id: ast::NodeId,\n+    ty_span: Span,\n+    allow_foreign_ty: bool,\n+) {\n     debug!(\"check_item_type: {:?}\", item_id);\n \n     for_id(tcx, item_id, ty_span).with_fcx(|fcx, _this| {\n         let ty = fcx.tcx.type_of(fcx.tcx.hir.local_def_id(item_id));\n         let item_ty = fcx.normalize_associated_types_in(ty_span, &ty);\n \n+        let mut forbid_unsized = true;\n+        if allow_foreign_ty {\n+            if let TyKind::Foreign(_) = tcx.struct_tail(item_ty).sty {\n+                forbid_unsized = false;\n+            }\n+        }\n+\n         fcx.register_wf_obligation(item_ty, ty_span, ObligationCauseCode::MiscObligation);\n-        fcx.register_bound(\n-            item_ty,\n-            fcx.tcx.require_lang_item(lang_items::SizedTraitLangItem),\n-            traits::ObligationCause::new(\n-                ty_span,\n-                fcx.body_id,\n-                traits::MiscObligation,\n-            ),\n-        );\n+        if forbid_unsized {\n+            fcx.register_bound(\n+                item_ty,\n+                fcx.tcx.require_lang_item(lang_items::SizedTraitLangItem),\n+                traits::ObligationCause::new(ty_span, fcx.body_id, traits::MiscObligation),\n+            );\n+        }\n \n         vec![] // no implied bounds in a const etc\n     });"}, {"sha": "0fc2473725a16c95db172dd25d4c5217d223cf41", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -3379,10 +3379,10 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 let variant_id = cx.derive_id(format!(\"{}.{}.fields\",\n                                                    ItemType::Variant,\n                                                    variant.name.as_ref().unwrap()));\n-                write!(w, \"<span class='docblock autohide sub-variant' id='{id}'>\",\n+                write!(w, \"<span class='autohide sub-variant' id='{id}'>\",\n                        id = variant_id)?;\n-                write!(w, \"<h3 class='fields'>Fields of <code>{name}</code></h3>\\n\n-                           <table>\", name = variant.name.as_ref().unwrap())?;\n+                write!(w, \"<h3>Fields of <b>{name}</b></h3><div>\",\n+                       name = variant.name.as_ref().unwrap())?;\n                 for field in &s.fields {\n                     use clean::StructFieldItem;\n                     if let StructFieldItem(ref ty) = field.inner {\n@@ -3394,19 +3394,18 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                                                       ItemType::Variant.name_space(),\n                                                       field.name.as_ref().unwrap(),\n                                                       ItemType::StructField.name_space()));\n-                        write!(w, \"<tr><td \\\n-                                   id='{id}'>\\\n-                                   <span id='{ns_id}' class='invisible'>\\\n-                                   <code>{f}:&nbsp;{t}</code></span></td><td>\",\n+                        write!(w, \"<span id=\\\"{id}\\\" class=\\\"variant small-section-header\\\">\\\n+                                   <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n+                                   <span id='{ns_id}' class='invisible'><code>{f}:&nbsp;{t}\\\n+                                   </code></span></span>\",\n                                id = id,\n                                ns_id = ns_id,\n                                f = field.name.as_ref().unwrap(),\n                                t = *ty)?;\n                         document(w, cx, field)?;\n-                        write!(w, \"</td></tr>\")?;\n                     }\n                 }\n-                write!(w, \"</table></span>\")?;\n+                write!(w, \"</div></span>\")?;\n             }\n             render_stability_since(w, variant, it)?;\n         }"}, {"sha": "02229b82b8ac3e76a7a022f99c47a1f4a78137fb", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -1886,7 +1886,7 @@\n             if (hasClass(relatedDoc, \"stability\")) {\n                 relatedDoc = relatedDoc.nextElementSibling;\n             }\n-            if (hasClass(relatedDoc, \"docblock\")) {\n+            if (hasClass(relatedDoc, \"docblock\") || hasClass(relatedDoc, \"sub-variant\")) {\n                 var action = mode;\n                 if (action === \"toggle\") {\n                     if (hasClass(relatedDoc, \"hidden-by-usual-hider\")) {\n@@ -2094,15 +2094,13 @@\n     }\n \n     var hideItemDeclarations = getCurrentValue('rustdoc-item-declarations') === \"false\";\n-    onEach(document.getElementsByClassName('docblock'), function(e) {\n+    function buildToggleWrapper(e) {\n         if (hasClass(e, 'autohide')) {\n             var wrap = e.previousElementSibling;\n             if (wrap && hasClass(wrap, 'toggle-wrapper')) {\n                 var toggle = wrap.childNodes[0];\n-                var extra = false;\n-                if (e.childNodes[0].tagName === 'H3') {\n-                    extra = true;\n-                }\n+                var extra = e.childNodes[0].tagName === 'H3';\n+\n                 e.style.display = 'none';\n                 addClass(wrap, 'collapsed');\n                 onEach(toggle.getElementsByClassName('inner'), function(e) {\n@@ -2127,6 +2125,8 @@\n                 if (hideItemDeclarations === false) {\n                     extraClass = 'collapsed';\n                 }\n+            } else if (hasClass(e, \"sub-variant\")) {\n+                otherMessage = '&nbsp;Show&nbsp;fields';\n             } else if (hasClass(e, \"non-exhaustive\")) {\n                 otherMessage = '&nbsp;This&nbsp;';\n                 if (hasClass(e, \"non-exhaustive-struct\")) {\n@@ -2150,7 +2150,10 @@\n                 collapseDocs(e.previousSibling.childNodes[0], \"toggle\");\n             }\n         }\n-    });\n+    }\n+\n+    onEach(document.getElementsByClassName('docblock'), buildToggleWrapper);\n+    onEach(document.getElementsByClassName('sub-variant'), buildToggleWrapper);\n \n     function createToggleWrapper(tog) {\n         var span = document.createElement('span');"}, {"sha": "8bcb828a5ade1e22f961bf5d68fb3ac1ed1eec5d", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -517,6 +517,10 @@ h4 > code, h3 > code, .invisible > code {\n \tmargin-top: -13px;\n }\n \n+.sub-variant > div > .stability {\n+\tmargin-top: initial;\n+}\n+\n .content .stability::before {\n \tcontent: '\u02ea';\n \tfont-size: 30px;\n@@ -866,7 +870,23 @@ span.since {\n }\n \n .sub-variant, .sub-variant > h3 {\n-\tmargin-top: 0 !important;\n+\tmargin-top: 1px !important;\n+}\n+\n+#main > .sub-variant > h3 {\n+\tfont-size: 15px;\n+\tmargin-left: 25px;\n+\tmargin-bottom: 5px;\n+}\n+\n+.sub-variant > div {\n+\tmargin-left: 20px;\n+\tmargin-bottom: 10px;\n+}\n+\n+.sub-variant > div > span {\n+\tdisplay: block;\n+\tposition: relative;\n }\n \n .toggle-label {"}, {"sha": "a153456370c6f45cbf50c3632b34467d5b3edaf7", "filename": "src/libstd/path.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -87,6 +87,8 @@ use io;\n use iter::{self, FusedIterator};\n use ops::{self, Deref};\n use rc::Rc;\n+use str::FromStr;\n+use string::ParseError;\n use sync::Arc;\n \n use ffi::{OsStr, OsString};\n@@ -1443,6 +1445,15 @@ impl From<String> for PathBuf {\n     }\n }\n \n+#[stable(feature = \"path_from_str\", since = \"1.26.0\")]\n+impl FromStr for PathBuf {\n+    type Err = ParseError;\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        Ok(PathBuf::from(s))\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<P: AsRef<Path>> iter::FromIterator<P> for PathBuf {\n     fn from_iter<I: IntoIterator<Item = P>>(iter: I) -> PathBuf {"}, {"sha": "3d15f20bd05f33bd4098e9918242108897926c1e", "filename": "src/test/mir-opt/end_region_4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fmir-opt%2Fend_region_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fmir-opt%2Fend_region_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_4.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -44,7 +44,7 @@ fn foo(i: i32) {\n //     let mut _5: i32;\n //     bb0: {\n //         StorageLive(_1);\n-//         _1 = D::{{constructor}}(const 0i32,);\n+//         _1 = D(const 0i32,);\n //         FakeRead(ForLet, _1);\n //         StorageLive(_2);\n //         _2 = const 0i32;"}, {"sha": "06d1fbabe16167863d1428bc1c65c37b3f7df22c", "filename": "src/test/mir-opt/end_region_5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fmir-opt%2Fend_region_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fmir-opt%2Fend_region_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_5.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -37,7 +37,7 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     let mut _4: &'18s D;\n //     bb0: {\n //         StorageLive(_1);\n-//         _1 = D::{{constructor}}(const 0i32,);\n+//         _1 = D(const 0i32,);\n //         FakeRead(ForLet, _1);\n //         StorageLive(_3);\n //         StorageLive(_4);"}, {"sha": "d0db23e6de0ee177095cc7f390cdf645502d37d9", "filename": "src/test/mir-opt/end_region_6.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fmir-opt%2Fend_region_6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fmir-opt%2Fend_region_6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_6.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -37,7 +37,7 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     let mut _4: &'24s D;\n //     bb0: {\n //         StorageLive(_1);\n-//         _1 = D::{{constructor}}(const 0i32,);\n+//         _1 = D(const 0i32,);\n //         FakeRead(ForLet, _1);\n //         StorageLive(_3);\n //         StorageLive(_4);"}, {"sha": "c7df440ebe2f31ef212edc28f24cb4fa67a6f442", "filename": "src/test/mir-opt/end_region_7.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_7.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -36,7 +36,7 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     let mut _3: [closure@NodeId(33) d:D];\n //     bb0: {\n //         StorageLive(_1);\n-//         _1 = D::{{constructor}}(const 0i32,);\n+//         _1 = D(const 0i32,);\n //         FakeRead(ForLet, _1);\n //         StorageLive(_3);\n //         _3 = [closure@NodeId(33)] { d: move _1 };"}, {"sha": "9f2a9c3b72e8b6d685acd37f7b03ddfc12a001ff", "filename": "src/test/mir-opt/end_region_8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_8.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -39,7 +39,7 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //    let mut _4: [closure@NodeId(33) r:&'24s D];\n //    bb0: {\n //        StorageLive(_1);\n-//        _1 = D::{{constructor}}(const 0i32,);\n+//        _1 = D(const 0i32,);\n //        FakeRead(ForLet, _1);\n //        StorageLive(_2);\n //        _2 = &'26_1rs _1;"}, {"sha": "eb381dfc5521fb53a7175fe081e4882cdb1c110d", "filename": "src/test/mir-opt/end_region_destruction_extents_1.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -79,16 +79,16 @@ unsafe impl<'a, #[may_dangle] 'b> Drop for D1<'a, 'b> {\n //         StorageLive(_3);\n //         StorageLive(_4);\n //         StorageLive(_5);\n-//         _5 = S1::{{constructor}}(const \"ex1\",);\n+//         _5 = S1(const \"ex1\",);\n //         _4 = &'15ds _5;\n //         _3 = &'15ds (*_4);\n //         StorageLive(_6);\n //         StorageLive(_7);\n //         StorageLive(_8);\n-//         _8 = S1::{{constructor}}(const \"dang1\",);\n+//         _8 = S1(const \"dang1\",);\n //         _7 = &'13s _8;\n //         _6 = &'13s (*_7);\n-//         _2 = D1<'15ds, '13s>::{{constructor}}(move _3, move _6);\n+//         _2 = D1<'15ds, '13s>(move _3, move _6);\n //         EndRegion('13s);\n //         StorageDead(_6);\n //         StorageDead(_3);\n@@ -132,7 +132,7 @@ unsafe impl<'a, #[may_dangle] 'b> Drop for D1<'a, 'b> {\n //         StorageLive(_7);\n //         _7 = &'13s (promoted[0]: S1);\n //         _6 = &'13s (*_7);\n-//         _2 = D1<'15ds, '13s>::{{constructor}}(move _3, move _6);\n+//         _2 = D1<'15ds, '13s>(move _3, move _6);\n //         EndRegion('13s);\n //         StorageDead(_6);\n //         StorageDead(_3);"}, {"sha": "1fe29a29e23181521886faa6d8e782b1d9fd1041", "filename": "src/test/mir-opt/packed-struct-drop-aligned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fmir-opt%2Fpacked-struct-drop-aligned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fmir-opt%2Fpacked-struct-drop-aligned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fpacked-struct-drop-aligned.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -42,7 +42,7 @@ impl Drop for Droppy {\n //     bb0: {\n //         StorageLive(_1);\n //         ...\n-//         _1 = Packed::{{constructor}}(move _2,);\n+//         _1 = Packed(move _2,);\n //         ...\n //         StorageLive(_6);\n //         _6 = move (_1.0: Aligned);"}, {"sha": "67a41bc5dc4addaa52b0efeeb9612c3b3f1ebb8d", "filename": "src/test/ui/consts/single_variant_match_ice.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -0,0 +1,15 @@\n+enum Foo {\n+    Prob,\n+}\n+\n+impl Foo {\n+    pub const fn as_val(&self) -> u8 {\n+        use self::Foo::*;\n+\n+        match *self {\n+            Prob => 0x1, //~ ERROR `if`, `match`, `&&` and `||` are not stable in const fn\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "a0222b0d489a465c33d3441e4e99f59ebb54f281", "filename": "src/test/ui/consts/single_variant_match_ice.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.stderr?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -0,0 +1,8 @@\n+error: `if`, `match`, `&&` and `||` are not stable in const fn\n+  --> $DIR/single_variant_match_ice.rs:10:13\n+   |\n+LL |             Prob => 0x1, //~ ERROR `if`, `match`, `&&` and `||` are not stable in const fn\n+   |             ^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "104970ea448aa4d0cfef1a88016b341875d926da", "filename": "src/test/ui/issues/issue-21554.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fui%2Fissues%2Fissue-21554.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fui%2Fissues%2Fissue-21554.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21554.stderr?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -1,4 +1,4 @@\n-error[E0606]: casting `fn(i32) -> Inches {Inches::{{constructor}}}` as `f32` is invalid\n+error[E0606]: casting `fn(i32) -> Inches {Inches}` as `f32` is invalid\n   --> $DIR/issue-21554.rs:14:5\n    |\n LL |     Inches as f32;"}, {"sha": "4404f88de311b483655fd414b5afada045a410be", "filename": "src/test/ui/issues/issue-35241.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fui%2Fissues%2Fissue-35241.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fui%2Fissues%2Fissue-35241.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35241.stderr?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -9,7 +9,7 @@ LL | fn test() -> Foo { Foo } //~ ERROR mismatched types\n    |              expected `Foo` because of return type\n    |\n    = note: expected type `Foo`\n-              found type `fn(u32) -> Foo {Foo::{{constructor}}}`\n+              found type `fn(u32) -> Foo {Foo}`\n \n error: aborting due to previous error\n "}, {"sha": "1ba47d3b932ef70171f87e442d6d9fbdc506bc57", "filename": "src/test/ui/issues/issue-50411.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fui%2Fissues%2Fissue-50411.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fui%2Fissues%2Fissue-50411.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50411.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -0,0 +1,11 @@\n+// Regression test for #50411: the MIR inliner was causing problems\n+// here because it would inline promoted code (which had already had\n+// elaborate-drops invoked on it) and then try to elaboate drops a\n+// second time. Uncool.\n+\n+// compile-flags:-Zmir-opt-level=3\n+// compile-pass\n+\n+fn main() {\n+    let _ = (0 .. 1).filter(|_| [1].iter().all(|_| true)).count();\n+}"}, {"sha": "0a297e58574f7a742ac6a7952ad725fa4cb58e0a", "filename": "src/test/ui/namespace/namespace-mix.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fui%2Fnamespace%2Fnamespace-mix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fui%2Fnamespace%2Fnamespace-mix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnamespace%2Fnamespace-mix.stderr?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -144,11 +144,11 @@ note: required by `check`\n LL | fn check<T: Impossible>(_: T) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0277]: the trait bound `fn() -> c::TS {c::TS::{{constructor}}}: Impossible` is not satisfied\n+error[E0277]: the trait bound `fn() -> c::TS {c::TS}: Impossible` is not satisfied\n   --> $DIR/namespace-mix.rs:66:5\n    |\n LL |     check(m3::TS); //~ ERROR c::TS\n-   |     ^^^^^ the trait `Impossible` is not implemented for `fn() -> c::TS {c::TS::{{constructor}}}`\n+   |     ^^^^^ the trait `Impossible` is not implemented for `fn() -> c::TS {c::TS}`\n    |\n note: required by `check`\n   --> $DIR/namespace-mix.rs:31:1\n@@ -192,11 +192,11 @@ note: required by `check`\n LL | fn check<T: Impossible>(_: T) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0277]: the trait bound `fn() -> namespace_mix::c::TS {namespace_mix::c::TS::{{constructor}}}: Impossible` is not satisfied\n+error[E0277]: the trait bound `fn() -> namespace_mix::c::TS {namespace_mix::c::TS}: Impossible` is not satisfied\n   --> $DIR/namespace-mix.rs:72:5\n    |\n LL |     check(xm3::TS); //~ ERROR c::TS\n-   |     ^^^^^ the trait `Impossible` is not implemented for `fn() -> namespace_mix::c::TS {namespace_mix::c::TS::{{constructor}}}`\n+   |     ^^^^^ the trait `Impossible` is not implemented for `fn() -> namespace_mix::c::TS {namespace_mix::c::TS}`\n    |\n note: required by `check`\n   --> $DIR/namespace-mix.rs:31:1"}, {"sha": "5151f624b8d98b033532cd95df0ce17e744650a1", "filename": "src/test/ui/privacy/private-inferred-type-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-3.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -14,8 +14,8 @@\n // error-pattern:static `PRIV_STATIC` is private\n // error-pattern:type `ext::PrivEnum` is private\n // error-pattern:type `fn() {<u8 as ext::PrivTrait>::method}` is private\n-// error-pattern:type `fn(u8) -> ext::PrivTupleStruct {ext::PrivTupleStruct::{{constructor}}}` is pr\n-// error-pattern:type `fn(u8) -> ext::PubTupleStruct {ext::PubTupleStruct::{{constructor}}}` is priv\n+// error-pattern:type `fn(u8) -> ext::PrivTupleStruct {ext::PrivTupleStruct}` is private\n+// error-pattern:type `fn(u8) -> ext::PubTupleStruct {ext::PubTupleStruct}` is private\n // error-pattern:type `for<'r> fn(&'r ext::Pub<u8>) {<ext::Pub<u8>>::priv_method}` is private\n \n #![feature(decl_macro)]"}, {"sha": "590ff76b375f23090768106c79e14c7750dc136a", "filename": "src/test/ui/privacy/private-inferred-type-3.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-3.stderr?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -30,15 +30,15 @@ LL |     ext::m!();\n    |\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n-error: type `fn(u8) -> ext::PrivTupleStruct {ext::PrivTupleStruct::{{constructor}}}` is private\n+error: type `fn(u8) -> ext::PrivTupleStruct {ext::PrivTupleStruct}` is private\n   --> $DIR/private-inferred-type-3.rs:26:5\n    |\n LL |     ext::m!();\n    |     ^^^^^^^^^^\n    |\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n-error: type `fn(u8) -> ext::PubTupleStruct {ext::PubTupleStruct::{{constructor}}}` is private\n+error: type `fn(u8) -> ext::PubTupleStruct {ext::PubTupleStruct}` is private\n   --> $DIR/private-inferred-type-3.rs:26:5\n    |\n LL |     ext::m!();"}, {"sha": "58e17b24394a1cae4fcc7ff58e38d6af25ccbfc7", "filename": "src/test/ui/privacy/private-inferred-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -53,9 +53,9 @@ mod m {\n         <u8 as PrivTrait>::method; //~ ERROR type `fn() {<u8 as m::PrivTrait>::method}` is private\n         <u8 as PubTrait>::method; // OK\n         PrivTupleStruct;\n-        //~^ ERROR type `fn(u8) -> m::PrivTupleStruct {m::PrivTupleStruct::{{constructor}}}` is priv\n+        //~^ ERROR type `fn(u8) -> m::PrivTupleStruct {m::PrivTupleStruct}` is private\n         PubTupleStruct;\n-        //~^ ERROR type `fn(u8) -> m::PubTupleStruct {m::PubTupleStruct::{{constructor}}}` is privat\n+        //~^ ERROR type `fn(u8) -> m::PubTupleStruct {m::PubTupleStruct}` is private\n         Pub(0u8).priv_method();\n         //~^ ERROR type `for<'r> fn(&'r m::Pub<u8>) {<m::Pub<u8>>::priv_method}` is private\n     }"}, {"sha": "1ab281cfc251537a599060fa41d470bf8b937edb", "filename": "src/test/ui/privacy/private-inferred-type.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.stderr?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -115,7 +115,7 @@ LL |         <u8 as PrivTrait>::method; //~ ERROR type `fn() {<u8 as m::PrivTrai\n LL |     m::m!();\n    |     -------- in this macro invocation\n \n-error: type `fn(u8) -> m::PrivTupleStruct {m::PrivTupleStruct::{{constructor}}}` is private\n+error: type `fn(u8) -> m::PrivTupleStruct {m::PrivTupleStruct}` is private\n   --> $DIR/private-inferred-type.rs:55:9\n    |\n LL |         PrivTupleStruct;\n@@ -124,7 +124,7 @@ LL |         PrivTupleStruct;\n LL |     m::m!();\n    |     -------- in this macro invocation\n \n-error: type `fn(u8) -> m::PubTupleStruct {m::PubTupleStruct::{{constructor}}}` is private\n+error: type `fn(u8) -> m::PubTupleStruct {m::PubTupleStruct}` is private\n   --> $DIR/private-inferred-type.rs:57:9\n    |\n LL |         PubTupleStruct;"}, {"sha": "2293f4b001749cc45642dad5ae6fd1c840edd75d", "filename": "src/test/ui/rust-2018/local-path-suggestions-2018.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2018.stderr?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -3,6 +3,8 @@ error[E0432]: unresolved import `foo`\n    |\n LL |     use foo::Bar;\n    |         ^^^ Did you mean `crate::foo`?\n+   |\n+   = note: `use` statements changed in Rust 2018; read more at <https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-clarity.html>\n \n error[E0432]: unresolved import `foo`\n   --> $DIR/local-path-suggestions-2018.rs:27:5"}, {"sha": "72e2853b9f03845fa6655ef2ea457c7c77d63971", "filename": "src/test/ui/static/static-extern-type.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fui%2Fstatic%2Fstatic-extern-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d492c6792c4fa24fb542bf457667f45b55b7c093/src%2Ftest%2Fui%2Fstatic%2Fstatic-extern-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatic%2Fstatic-extern-type.rs?ref=d492c6792c4fa24fb542bf457667f45b55b7c093", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+#![feature(extern_types)]\n+\n+pub mod a {\n+    extern \"C\" {\n+        pub type StartFn;\n+        pub static start: StartFn;\n+    }\n+}\n+\n+pub mod b {\n+    #[repr(transparent)]\n+    pub struct TransparentType(::a::StartFn);\n+    extern \"C\" {\n+        pub static start: TransparentType;\n+    }\n+}\n+\n+pub mod c {\n+    #[repr(C)]\n+    pub struct CType(u32, ::b::TransparentType);\n+    extern \"C\" {\n+        pub static start: CType;\n+    }\n+}\n+\n+fn main() {}"}]}