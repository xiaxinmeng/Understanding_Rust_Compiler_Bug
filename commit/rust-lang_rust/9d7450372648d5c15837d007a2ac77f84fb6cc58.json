{"sha": "9d7450372648d5c15837d007a2ac77f84fb6cc58", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkNzQ1MDM3MjY0OGQ1YzE1ODM3ZDAwN2EyYWM3N2Y4NGZiNmNjNTg=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2019-03-16T06:56:30Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2019-03-16T14:39:29Z"}, "message": "Rollup merge of #59025 - aoikonomopoulos:issue-57924, r=varkor\n\nFix generic argument lookup for Self\n\nRewrite the SelfCtor early and use the replacement Def when\ncalculating the path_segs.\n\nNote that this also changes which def is seen by the code that\ncomputes user_self_ty and is_alias_variant_ctor; I don't see a\nimmediate issue with that, but I'm not 100% clear on the\nimplications.\n\nFixes #57924\n\nr? @eddyb", "tree": {"sha": "d3d7117ecec158901872140d73033649b57607c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3d7117ecec158901872140d73033649b57607c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d7450372648d5c15837d007a2ac77f84fb6cc58", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlyNCqMACgkQ/vbIBR0O\nATxI9RAAhfddtUGtd5vY+gHhjANkShIzzhATR0jhzWMPx3Voub6PoTL+7tUXpLJE\n0o6wYPkrcPWUPEgRYzTWnE+JCn2CeT3tfQvZluElkf8iG21rKWtnGidX0ipRMRwd\n1zcA/zwnYr8JurNLlIykH8cUBjsu4K8lMWy3ViN+Gd6eDb6qDHSdcV7VrNBEnkpJ\ncD0QOWjWgrFbVFSIjg3df00Kq2MtbDA/ig4OSZtwg4MoFybJKXfXvEGm/i8KaSf/\nDPRBem/oCYI5ysprTx0YkBf9z83p+Rd/1Ge+mQEEpiM9vQjFwTCeCu86LPTa1LPO\n+12O0d/iSLsB/emC+86qbsqnTuIVWnjBybAEVPjnn59Ma83uGZ40SkbZwam78gPA\nbYEVSzRZ4/+2tCzesiTglqCtrZdGQMThHAxS9KWDwcaDn0Tel1uOp/hQKpMBJAIl\nmpUcaajZUjLcmhJ32smAORlejkemBy10i1hKKxjEadr+vhJDg/F3E/Je3q853bZu\nYdjh4PLe3yMADvmfhUVJ9jeHnQ1Uly3QJYJkOLNLh0iJyFg94CPqH5K/695UgnUJ\n9g7XZJW3lsa6uTAS2XPsGsrW9jMp8Y/2Kmgh3DCWZOh+8PNeSmns6aZk6IWUppfx\nxVVAhoKAfVNwTDLSgFhJ4bwrvHMWSq0fYgdvBI2Z1pE4PddMHlk=\n=g8F5\n-----END PGP SIGNATURE-----", "payload": "tree d3d7117ecec158901872140d73033649b57607c1\nparent d3f30c30eaf56b69cf458656c1a84a931d1108a9\nparent 311025e6a5aad80d028f0771970c43cb4ed025a8\nauthor kennytm <kennytm@gmail.com> 1552719390 +0800\ncommitter kennytm <kennytm@gmail.com> 1552747169 +0800\n\nRollup merge of #59025 - aoikonomopoulos:issue-57924, r=varkor\n\nFix generic argument lookup for Self\n\nRewrite the SelfCtor early and use the replacement Def when\ncalculating the path_segs.\n\nNote that this also changes which def is seen by the code that\ncomputes user_self_ty and is_alias_variant_ctor; I don't see a\nimmediate issue with that, but I'm not 100% clear on the\nimplications.\n\nFixes #57924\n\nr? @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d7450372648d5c15837d007a2ac77f84fb6cc58", "html_url": "https://github.com/rust-lang/rust/commit/9d7450372648d5c15837d007a2ac77f84fb6cc58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d7450372648d5c15837d007a2ac77f84fb6cc58/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3f30c30eaf56b69cf458656c1a84a931d1108a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3f30c30eaf56b69cf458656c1a84a931d1108a9", "html_url": "https://github.com/rust-lang/rust/commit/d3f30c30eaf56b69cf458656c1a84a931d1108a9"}, {"sha": "311025e6a5aad80d028f0771970c43cb4ed025a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/311025e6a5aad80d028f0771970c43cb4ed025a8", "html_url": "https://github.com/rust-lang/rust/commit/311025e6a5aad80d028f0771970c43cb4ed025a8"}], "stats": {"total": 128, "additions": 69, "deletions": 59}, "files": [{"sha": "fa4bb02189f20260877fd0d42349c7ca114e0b1b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 60, "deletions": 59, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/9d7450372648d5c15837d007a2ac77f84fb6cc58/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d7450372648d5c15837d007a2ac77f84fb6cc58/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9d7450372648d5c15837d007a2ac77f84fb6cc58", "patch": "@@ -5288,6 +5288,53 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         Some(original_span.with_lo(original_span.hi() - BytePos(1)))\n     }\n \n+    // Rewrite `SelfCtor` to `StructCtor`\n+    pub fn rewrite_self_ctor(&self, def: Def, span: Span) -> (Def, DefId, Ty<'tcx>) {\n+        let tcx = self.tcx;\n+        if let Def::SelfCtor(impl_def_id) = def {\n+            let ty = self.impl_self_ty(span, impl_def_id).ty;\n+            let adt_def = ty.ty_adt_def();\n+\n+            match adt_def {\n+                Some(adt_def) if adt_def.has_ctor() => {\n+                    let variant = adt_def.non_enum_variant();\n+                    let def = Def::StructCtor(variant.did, variant.ctor_kind);\n+                    (def, variant.did, tcx.type_of(variant.did))\n+                }\n+                _ => {\n+                    let mut err = tcx.sess.struct_span_err(span,\n+                        \"the `Self` constructor can only be used with tuple or unit structs\");\n+                    if let Some(adt_def) = adt_def {\n+                        match adt_def.adt_kind() {\n+                            AdtKind::Enum => {\n+                                err.help(\"did you mean to use one of the enum's variants?\");\n+                            },\n+                            AdtKind::Struct |\n+                            AdtKind::Union => {\n+                                err.span_suggestion(\n+                                    span,\n+                                    \"use curly brackets\",\n+                                    String::from(\"Self { /* fields */ }\"),\n+                                    Applicability::HasPlaceholders,\n+                                );\n+                            }\n+                        }\n+                    }\n+                    err.emit();\n+\n+                    (def, impl_def_id, tcx.types.err)\n+                }\n+            }\n+        } else {\n+            let def_id = def.def_id();\n+\n+            // The things we are substituting into the type should not contain\n+            // escaping late-bound regions, and nor should the base type scheme.\n+            let ty = tcx.type_of(def_id);\n+            (def, def_id, ty)\n+        }\n+    }\n+\n     // Instantiates the given path, which must refer to an item with the given\n     // number of type parameters and type.\n     pub fn instantiate_value_path(&self,\n@@ -5307,6 +5354,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let tcx = self.tcx;\n \n+        match def {\n+            Def::Local(nid) | Def::Upvar(nid, ..) => {\n+                let hid = self.tcx.hir().node_to_hir_id(nid);\n+                let ty = self.local_ty(span, hid).decl_ty;\n+                let ty = self.normalize_associated_types_in(span, &ty);\n+                self.write_ty(hir_id, ty);\n+                return (ty, def);\n+            }\n+            _ => {}\n+        }\n+\n+        let (def, def_id, ty) = self.rewrite_self_ctor(def, span);\n         let path_segs = AstConv::def_ids_for_path_segments(self, segments, self_ty, def);\n \n         let mut user_self_ty = None;\n@@ -5368,17 +5427,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             user_self_ty = None;\n         }\n \n-        match def {\n-            Def::Local(nid) | Def::Upvar(nid, ..) => {\n-                let hid = self.tcx.hir().node_to_hir_id(nid);\n-                let ty = self.local_ty(span, hid).decl_ty;\n-                let ty = self.normalize_associated_types_in(span, &ty);\n-                self.write_ty(hir_id, ty);\n-                return (ty, def);\n-            }\n-            _ => {}\n-        }\n-\n         // Now we have to compare the types that the user *actually*\n         // provided against the types that were *expected*. If the user\n         // did not provide any types, then we want to substitute inference\n@@ -5411,53 +5459,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             tcx.generics_of(*def_id).has_self\n         }).unwrap_or(false);\n \n-        let mut new_def = def;\n-        let (def_id, ty) = match def {\n-            Def::SelfCtor(impl_def_id) => {\n-                let ty = self.impl_self_ty(span, impl_def_id).ty;\n-                let adt_def = ty.ty_adt_def();\n-\n-                match adt_def {\n-                    Some(adt_def) if adt_def.has_ctor() => {\n-                        let variant = adt_def.non_enum_variant();\n-                        new_def = Def::StructCtor(variant.did, variant.ctor_kind);\n-                        (variant.did, tcx.type_of(variant.did))\n-                    }\n-                    _ => {\n-                        let mut err = tcx.sess.struct_span_err(span,\n-                            \"the `Self` constructor can only be used with tuple or unit structs\");\n-                        if let Some(adt_def) = adt_def {\n-                            match adt_def.adt_kind() {\n-                                AdtKind::Enum => {\n-                                    err.help(\"did you mean to use one of the enum's variants?\");\n-                                },\n-                                AdtKind::Struct |\n-                                AdtKind::Union => {\n-                                    err.span_suggestion(\n-                                        span,\n-                                        \"use curly brackets\",\n-                                        String::from(\"Self { /* fields */ }\"),\n-                                        Applicability::HasPlaceholders,\n-                                    );\n-                                }\n-                            }\n-                        }\n-                        err.emit();\n-\n-                        (impl_def_id, tcx.types.err)\n-                    }\n-                }\n-            }\n-            _ => {\n-                let def_id = def.def_id();\n-\n-                // The things we are substituting into the type should not contain\n-                // escaping late-bound regions, and nor should the base type scheme.\n-                let ty = tcx.type_of(def_id);\n-                (def_id, ty)\n-            }\n-        };\n-\n         let substs = AstConv::create_substs_for_generic_args(\n             tcx,\n             def_id,\n@@ -5573,7 +5574,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                ty_substituted);\n         self.write_substs(hir_id, substs);\n \n-        (ty_substituted, new_def)\n+        (ty_substituted, def)\n     }\n \n     fn check_rustc_args_require_const(&self,"}, {"sha": "232596334b0ed9cb4d80421f6d0b5ff3d52c560a", "filename": "src/test/run-pass/issues/issue-57924.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9d7450372648d5c15837d007a2ac77f84fb6cc58/src%2Ftest%2Frun-pass%2Fissues%2Fissue-57924.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d7450372648d5c15837d007a2ac77f84fb6cc58/src%2Ftest%2Frun-pass%2Fissues%2Fissue-57924.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-57924.rs?ref=9d7450372648d5c15837d007a2ac77f84fb6cc58", "patch": "@@ -0,0 +1,9 @@\n+pub struct Gcm<E>(E);\n+\n+impl<E> Gcm<E> {\n+    pub fn crash(e: E) -> Self {\n+        Self::<E>(e)\n+    }\n+}\n+\n+fn main() {}"}]}