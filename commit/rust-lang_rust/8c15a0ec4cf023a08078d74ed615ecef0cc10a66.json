{"sha": "8c15a0ec4cf023a08078d74ed615ecef0cc10a66", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjMTVhMGVjNGNmMDIzYTA4MDc4ZDc0ZWQ2MTVlY2VmMGNjMTBhNjY=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-05-17T13:51:25Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-05-21T14:04:10Z"}, "message": "syntax/ext: collect the ast building traits into a single trait.", "tree": {"sha": "2a2f9d23e845713d92080b3b7616c8c14ed3e14b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a2f9d23e845713d92080b3b7616c8c14ed3e14b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c15a0ec4cf023a08078d74ed615ecef0cc10a66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c15a0ec4cf023a08078d74ed615ecef0cc10a66", "html_url": "https://github.com/rust-lang/rust/commit/8c15a0ec4cf023a08078d74ed615ecef0cc10a66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c15a0ec4cf023a08078d74ed615ecef0cc10a66/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4045da9f4f7290b02bee52caa42504e4ce5406f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4045da9f4f7290b02bee52caa42504e4ce5406f7", "html_url": "https://github.com/rust-lang/rust/commit/4045da9f4f7290b02bee52caa42504e4ce5406f7"}], "stats": {"total": 913, "additions": 420, "deletions": 493}, "files": [{"sha": "a2d88c1f23a8885f4a50b0c44fe59ffdfc9c1608", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 396, "deletions": 92, "changes": 488, "blob_url": "https://github.com/rust-lang/rust/blob/8c15a0ec4cf023a08078d74ed615ecef0cc10a66/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c15a0ec4cf023a08078d74ed615ecef0cc10a66/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=8c15a0ec4cf023a08078d74ed615ecef0cc10a66", "patch": "@@ -8,13 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use abi::AbiSet;\n+use ast::ident;\n use ast;\n+use ast_util;\n use codemap;\n-use codemap::span;\n+use codemap::{span, respan, dummy_sp, spanned};\n use fold;\n use ext::base::ExtCtxt;\n-use ext::build;\n-\n+use ext::quote::rt::*;\n+use opt_vec;\n use opt_vec::OptVec;\n \n pub struct Field {\n@@ -547,14 +550,8 @@ mod syntax {\n     pub use parse;\n }\n \n-trait ExtCtxtMethods {\n-    fn bind_path(&self,\n-                 span: span,\n-                 ident: ast::ident,\n-                 path: @ast::Path,\n-                 bounds: @OptVec<ast::TyParamBound>)\n-                 -> ast::TyParam;\n-    fn expr(&self, span: span, node: ast::expr_) -> @ast::expr;\n+pub trait AstBuilder {\n+    // paths\n     fn path(&self, span: span, strs: ~[ast::ident]) -> @ast::Path;\n     fn path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::Path;\n     fn path_tps(&self, span: span, strs: ~[ast::ident], tps: ~[@ast::Ty])\n@@ -564,16 +561,35 @@ trait ExtCtxtMethods {\n                        strs: ~[ast::ident],\n                        tps: ~[@ast::Ty])\n                        -> @ast::Path;\n-    fn ty_path(&self, span: span, strs: ~[ast::ident], tps: ~[@ast::Ty])\n-               -> @ast::Ty;\n-    fn binder_pat(&self, span: span, nm: ast::ident) -> @ast::pat;\n-    fn stmt(&self, expr: @ast::expr) -> @ast::stmt;\n+\n+    // types\n+    fn ty_path(&self, @ast::Path) -> @ast::Ty;\n+\n+    fn ty_param(&self, id: ast::ident, bounds: @OptVec<ast::TyParamBound>)\n+        -> ast::TyParam;\n+    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty];\n+    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty];\n+    fn ty_field_imm(&self, name: ident, ty: @ast::Ty) -> ast::ty_field;\n+    fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty;\n+    fn ty_infer(&self) -> @ast::Ty;\n+    fn ty_nil_ast_builder(&self) -> @ast::Ty;\n+    fn strip_bounds(&self, bounds: &Generics) -> Generics;\n+\n+\n+    // statements\n+    fn stmt_expr(&self, expr: @ast::expr) -> @ast::stmt;\n+    fn stmt_let(&self, ident: ident, e: @ast::expr) -> @ast::stmt;\n+\n+    // literals\n     fn lit_str(&self, span: span, s: @~str) -> @ast::expr;\n     fn lit_uint(&self, span: span, i: uint) -> @ast::expr;\n-    fn lambda0(&self, blk: ast::blk) -> @ast::expr;\n-    fn lambda1(&self, blk: ast::blk, ident: ast::ident) -> @ast::expr;\n-    fn blk(&self, span: span, stmts: ~[@ast::stmt]) -> ast::blk;\n-    fn expr_blk(&self, expr: @ast::expr) -> ast::blk;\n+\n+    // blocks\n+    fn blk(&self, span: span, stmts: ~[@ast::stmt], expr: Option<@ast::expr>) -> ast::blk;\n+    fn blk_expr(&self, expr: @ast::expr) -> ast::blk;\n+\n+    // expressions\n+    fn expr(&self, span: span, node: ast::expr_) -> @ast::expr;\n     fn expr_path(&self, span: span, strs: ~[ast::ident]) -> @ast::expr;\n     fn expr_path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::expr;\n     fn expr_var(&self, span: span, var: &str) -> @ast::expr;\n@@ -588,6 +604,13 @@ trait ExtCtxtMethods {\n                         ident: ast::ident,\n                         args: ~[@ast::expr])\n                         -> @ast::expr;\n+    fn expr_blk(&self, b: ast::blk) -> @ast::expr;\n+    fn field_imm(&self, name: ident, e: @ast::expr) -> ast::field;\n+    fn expr_struct(&self,\n+                   path: @ast::Path,\n+                   fields: ~[ast::field]) -> @ast::expr;\n+    fn lambda0(&self, blk: ast::blk) -> @ast::expr;\n+    fn lambda1(&self, blk: ast::blk, ident: ast::ident) -> @ast::expr;\n     fn lambda_expr_0(&self, expr: @ast::expr) -> @ast::expr;\n     fn lambda_expr_1(&self, expr: @ast::expr, ident: ast::ident)\n                     -> @ast::expr;\n@@ -597,37 +620,64 @@ trait ExtCtxtMethods {\n                       stmts: ~[@ast::stmt],\n                       ident: ast::ident)\n                       -> @ast::expr;\n-}\n \n-impl ExtCtxtMethods for @ExtCtxt {\n-    fn bind_path(\n-        &self,\n-        _span: span,\n-        ident: ast::ident,\n-        path: @ast::Path,\n-        bounds: @OptVec<ast::TyParamBound>\n-    ) -> ast::TyParam {\n-        let bound = ast::TraitTyParamBound(@ast::trait_ref {\n-            ref_id: self.next_id(),\n-            path: path\n-        });\n+    // items\n+    fn item(&self, name: ident, span: span, node: ast::item_) -> @ast::item;\n \n-        ast::TyParam {\n-            ident: ident,\n-            id: self.next_id(),\n-            bounds: @bounds.prepend(bound)\n-        }\n-    }\n+    fn arg(&self, name: ident, ty: @ast::Ty) -> ast::arg;\n+    fn fn_decl(&self, inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl;\n \n-    fn expr(&self, span: span, node: ast::expr_) -> @ast::expr {\n-        @ast::expr {\n-            id: self.next_id(),\n-            callee_id: self.next_id(),\n-            node: node,\n-            span: span,\n-        }\n-    }\n+    fn item_fn_poly(&self,\n+                    ame: ident,\n+                    inputs: ~[ast::arg],\n+                    output: @ast::Ty,\n+                    generics: Generics,\n+                    body: ast::blk) -> @ast::item;\n+    fn item_fn(&self,\n+               name: ident,\n+               inputs: ~[ast::arg],\n+               output: @ast::Ty,\n+               body: ast::blk) -> @ast::item;\n+\n+    fn variant(&self,\n+               name: ident,\n+               span: span,\n+               tys: ~[@ast::Ty]) -> ast::variant;\n+    fn item_enum_poly(&self,\n+                      name: ident,\n+                      span: span,\n+                      enum_definition: ast::enum_def,\n+                      generics: Generics) -> @ast::item;\n+    fn item_enum(&self,\n+                 name: ident,\n+                 span: span,\n+                 enum_definition: ast::enum_def) -> @ast::item;\n+\n+    fn item_struct_poly(&self,\n+                        name: ident,\n+                        span: span,\n+                        struct_def: ast::struct_def,\n+                        generics: Generics) -> @ast::item;\n+    fn item_struct(&self,\n+                   name: ident,\n+                   span: span,\n+                   struct_def: ast::struct_def) -> @ast::item;\n+\n+    fn item_mod(&self,\n+                name: ident,\n+                span: span,\n+                items: ~[@ast::item]) -> @ast::item;\n+\n+    fn item_ty_poly(&self,\n+                    name: ident,\n+                    span: span,\n+                    ty: @ast::Ty,\n+                    generics: Generics) -> @ast::item;\n+    fn item_ty(&self, name: ident, span: span, ty: @ast::Ty) -> @ast::item;\n+\n+}\n \n+impl AstBuilder for @ExtCtxt {\n     fn path(&self, span: span, strs: ~[ast::ident]) -> @ast::Path {\n         @ast::Path {\n             span: span,\n@@ -678,37 +728,89 @@ impl ExtCtxtMethods for @ExtCtxt {\n         }\n     }\n \n-    fn ty_path(\n-        &self,\n-        span: span,\n-        strs: ~[ast::ident],\n-        tps: ~[@ast::Ty]\n-    ) -> @ast::Ty {\n+    fn ty_path(&self, path: @ast::Path) -> @ast::Ty {\n+        build::mk_ty(*self, path.span,\n+                     ast::ty_path(path, self.next_id()))\n+    }\n+\n+    fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty {\n+        self.ty_path(\n+            self.path_tps_global(dummy_sp(),\n+                                 ~[\n+                                     self.ident_of(\"core\"),\n+                                     self.ident_of(\"option\"),\n+                                     self.ident_of(\"Option\")\n+                                 ],\n+                                 ~[ ty ]))\n+    }\n+\n+    fn ty_field_imm(&self, name: ident, ty: @ast::Ty) -> ast::ty_field {\n+        spanned {\n+            node: ast::ty_field_ {\n+                ident: name,\n+                mt: ast::mt { ty: ty, mutbl: ast::m_imm },\n+            },\n+            span: dummy_sp(),\n+        }\n+    }\n+\n+    fn ty_infer(&self) -> @ast::Ty {\n         @ast::Ty {\n             id: self.next_id(),\n-            node: ast::ty_path(\n-                self.path_tps(span, strs, tps),\n-                self.next_id()),\n-            span: span,\n+            node: ast::ty_infer,\n+            span: dummy_sp(),\n         }\n     }\n \n-    fn binder_pat(&self, span: span, nm: ast::ident) -> @ast::pat {\n-        @ast::pat {\n+    fn ty_param(&self, id: ast::ident, bounds: @OptVec<ast::TyParamBound>)\n+        -> ast::TyParam\n+    {\n+        ast::TyParam { ident: id, id: self.next_id(), bounds: bounds }\n+    }\n+\n+    fn ty_nil_ast_builder(&self) -> @ast::Ty {\n+        @ast::Ty {\n             id: self.next_id(),\n-            node: ast::pat_ident(\n-                ast::bind_by_ref(ast::m_imm),\n-                self.path(span, ~[nm]),\n-                None),\n-            span: span,\n+            node: ast::ty_nil,\n+            span: dummy_sp(),\n+        }\n+    }\n+\n+    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n+        opt_vec::take_vec(\n+            ty_params.map(|p| self.ty_path(\n+                mk_raw_path(dummy_sp(), ~[p.ident]))))\n+    }\n+\n+    fn ty_vars_global(&self,\n+                      ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n+        opt_vec::take_vec(\n+            ty_params.map(|p| self.ty_path(\n+                mk_raw_path(dummy_sp(), ~[p.ident]))))\n+    }\n+\n+    fn strip_bounds(&self, generics: &Generics) -> Generics {\n+        let no_bounds = @opt_vec::Empty;\n+        let new_params = do generics.ty_params.map |ty_param| {\n+            ast::TyParam { bounds: no_bounds, ..copy *ty_param }\n+        };\n+        Generics {\n+            ty_params: new_params,\n+            .. copy *generics\n         }\n     }\n \n-    fn stmt(&self, expr: @ast::expr) -> @ast::stmt {\n+\n+    fn stmt_expr(&self, expr: @ast::expr) -> @ast::stmt {\n         @codemap::spanned { node: ast::stmt_semi(expr, self.next_id()),\n                        span: expr.span }\n     }\n \n+    fn stmt_let(&self, ident: ident, e: @ast::expr) -> @ast::stmt {\n+        let ext_cx = *self;\n+        quote_stmt!( let $ident = $e; )\n+    }\n+\n     fn lit_str(&self, span: span, s: @~str) -> @ast::expr {\n         self.expr(\n             span,\n@@ -729,41 +831,29 @@ impl ExtCtxtMethods for @ExtCtxt {\n                                 span: span}))\n     }\n \n-    fn lambda0(&self, blk: ast::blk) -> @ast::expr {\n-        let ext_cx = *self;\n-        let blk_e = self.expr(copy blk.span, ast::expr_block(copy blk));\n-        quote_expr!( || $blk_e )\n-    }\n-\n-    fn lambda1(&self, blk: ast::blk, ident: ast::ident) -> @ast::expr {\n-        let ext_cx = *self;\n-        let blk_e = self.expr(copy blk.span, ast::expr_block(copy blk));\n-        quote_expr!( |$ident| $blk_e )\n-    }\n-\n-    fn blk(&self, span: span, stmts: ~[@ast::stmt]) -> ast::blk {\n+    fn blk(&self, span: span, stmts: ~[@ast::stmt], expr: Option<@expr>) -> ast::blk {\n         codemap::spanned {\n             node: ast::blk_ {\n                 view_items: ~[],\n                 stmts: stmts,\n-                expr: None,\n+                expr: expr,\n                 id: self.next_id(),\n                 rules: ast::default_blk,\n             },\n             span: span,\n         }\n     }\n \n-    fn expr_blk(&self, expr: @ast::expr) -> ast::blk {\n-        codemap::spanned {\n-            node: ast::blk_ {\n-                view_items: ~[],\n-                stmts: ~[],\n-                expr: Some(expr),\n-                id: self.next_id(),\n-                rules: ast::default_blk,\n-            },\n-            span: expr.span,\n+    fn blk_expr(&self, expr: @ast::expr) -> ast::blk {\n+        self.blk(expr.span, ~[], Some(expr))\n+    }\n+\n+    fn expr(&self, span: span, node: ast::expr_) -> @ast::expr {\n+        @ast::expr {\n+            id: self.next_id(),\n+            callee_id: self.next_id(),\n+            node: node,\n+            span: span,\n         }\n     }\n \n@@ -815,25 +905,239 @@ impl ExtCtxtMethods for @ExtCtxt {\n         self.expr(span,\n                   ast::expr_method_call(expr, ident, ~[], args, ast::NoSugar))\n     }\n+    fn expr_blk(&self, b: ast::blk) -> @ast::expr {\n+        self.expr(dummy_sp(), ast::expr_block(b))\n+    }\n+    fn field_imm(&self, name: ident, e: @ast::expr) -> ast::field {\n+        spanned {\n+            node: ast::field_ { mutbl: ast::m_imm, ident: name, expr: e },\n+            span: dummy_sp(),\n+        }\n+    }\n+    fn expr_struct(&self, path: @ast::Path,\n+                   fields: ~[ast::field]) -> @ast::expr {\n+        @ast::expr {\n+            id: self.next_id(),\n+            callee_id: self.next_id(),\n+            node: ast::expr_struct(path, fields, None),\n+            span: dummy_sp()\n+        }\n+    }\n+\n+\n+    fn lambda0(&self, blk: ast::blk) -> @ast::expr {\n+        let ext_cx = *self;\n+        let blk_e = self.expr(copy blk.span, ast::expr_block(copy blk));\n+        quote_expr!( || $blk_e )\n+    }\n+\n+    fn lambda1(&self, blk: ast::blk, ident: ast::ident) -> @ast::expr {\n+        let ext_cx = *self;\n+        let blk_e = self.expr(copy blk.span, ast::expr_block(copy blk));\n+        quote_expr!( |$ident| $blk_e )\n+    }\n \n     fn lambda_expr_0(&self, expr: @ast::expr) -> @ast::expr {\n-        self.lambda0(self.expr_blk(expr))\n+        self.lambda0(self.blk_expr(expr))\n     }\n \n     fn lambda_expr_1(&self, expr: @ast::expr, ident: ast::ident)\n                     -> @ast::expr {\n-        self.lambda1(self.expr_blk(expr), ident)\n+        self.lambda1(self.blk_expr(expr), ident)\n     }\n \n     fn lambda_stmts_0(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr {\n-        self.lambda0(self.blk(span, stmts))\n+        self.lambda0(self.blk(span, stmts, None))\n     }\n \n     fn lambda_stmts_1(&self,\n                       span: span,\n                       stmts: ~[@ast::stmt],\n                       ident: ast::ident)\n                       -> @ast::expr {\n-        self.lambda1(self.blk(span, stmts), ident)\n+        self.lambda1(self.blk(span, stmts, None), ident)\n+    }\n+\n+\n+    fn arg(&self, name: ident, ty: @ast::Ty) -> ast::arg {\n+        ast::arg {\n+            is_mutbl: false,\n+            ty: ty,\n+            pat: @ast::pat {\n+                id: self.next_id(),\n+                node: ast::pat_ident(\n+                    ast::bind_by_copy,\n+                    ast_util::ident_to_path(dummy_sp(), name),\n+                    None),\n+                span: dummy_sp(),\n+            },\n+            id: self.next_id(),\n+        }\n     }\n+\n+    fn fn_decl(&self, inputs: ~[ast::arg],\n+               output: @ast::Ty) -> ast::fn_decl {\n+        ast::fn_decl {\n+            inputs: inputs,\n+            output: output,\n+            cf: ast::return_val,\n+        }\n+    }\n+\n+    fn item(&self, name: ident, span: span,\n+            node: ast::item_) -> @ast::item {\n+\n+        // XXX: Would be nice if our generated code didn't violate\n+        // Rust coding conventions\n+        let non_camel_case_attribute = respan(dummy_sp(), ast::attribute_ {\n+            style: ast::attr_outer,\n+            value: @respan(dummy_sp(),\n+                          ast::meta_list(@~\"allow\", ~[\n+                              @respan(dummy_sp(),\n+                                      ast::meta_word(\n+                                         @~\"non_camel_case_types\"))\n+                          ])),\n+            is_sugared_doc: false\n+        });\n+\n+        @ast::item { ident: name,\n+                     attrs: ~[non_camel_case_attribute],\n+                     id: self.next_id(),\n+                     node: node,\n+                     vis: ast::public,\n+                     span: span }\n+    }\n+\n+    fn item_fn_poly(&self, name: ident,\n+                    inputs: ~[ast::arg],\n+                    output: @ast::Ty,\n+                    generics: Generics,\n+                    body: ast::blk) -> @ast::item {\n+        self.item(name,\n+                  dummy_sp(),\n+                  ast::item_fn(self.fn_decl(inputs, output),\n+                               ast::impure_fn,\n+                               AbiSet::Rust(),\n+                               generics,\n+                               body))\n+    }\n+\n+    fn item_fn(&self,\n+               name: ident,\n+               inputs: ~[ast::arg],\n+               output: @ast::Ty,\n+               body: ast::blk\n+    ) -> @ast::item {\n+        self.item_fn_poly(\n+            name,\n+            inputs,\n+            output,\n+            ast_util::empty_generics(),\n+            body\n+        )\n+    }\n+\n+    fn variant(&self, name: ident, span: span,\n+               tys: ~[@ast::Ty]) -> ast::variant {\n+        let args = do tys.map |ty| {\n+            ast::variant_arg { ty: *ty, id: self.next_id() }\n+        };\n+\n+        spanned {\n+            node: ast::variant_ {\n+                name: name,\n+                attrs: ~[],\n+                kind: ast::tuple_variant_kind(args),\n+                id: self.next_id(),\n+                disr_expr: None,\n+                vis: ast::public\n+            },\n+            span: span,\n+        }\n+    }\n+\n+    fn item_enum_poly(&self, name: ident, span: span,\n+                      enum_definition: ast::enum_def,\n+                      generics: Generics) -> @ast::item {\n+        self.item(name, span, ast::item_enum(enum_definition, generics))\n+    }\n+\n+    fn item_enum(&self, name: ident, span: span,\n+                 enum_definition: ast::enum_def) -> @ast::item {\n+        self.item_enum_poly(name, span, enum_definition,\n+                            ast_util::empty_generics())\n+    }\n+\n+    fn item_struct(\n+        &self, name: ident,\n+        span: span,\n+        struct_def: ast::struct_def\n+    ) -> @ast::item {\n+        self.item_struct_poly(\n+            name,\n+            span,\n+            struct_def,\n+            ast_util::empty_generics()\n+        )\n+    }\n+\n+    fn item_struct_poly(\n+        &self,\n+        name: ident,\n+        span: span,\n+        struct_def: ast::struct_def,\n+        generics: Generics\n+    ) -> @ast::item {\n+        self.item(name, span, ast::item_struct(@struct_def, generics))\n+    }\n+\n+    fn item_mod(&self, name: ident, span: span,\n+                items: ~[@ast::item]) -> @ast::item {\n+\n+        // XXX: Total hack: import `core::kinds::Owned` to work around a\n+        // parser bug whereby `fn f<T:::kinds::Owned>` doesn't parse.\n+        let vi = ast::view_item_use(~[\n+            @codemap::spanned {\n+                node: ast::view_path_simple(\n+                    self.ident_of(\"Owned\"),\n+                    mk_raw_path(\n+                        codemap::dummy_sp(),\n+                        ~[\n+                            self.ident_of(\"core\"),\n+                            self.ident_of(\"kinds\"),\n+                            self.ident_of(\"Owned\")\n+                        ]\n+                    ),\n+                    self.next_id()\n+                ),\n+                span: codemap::dummy_sp()\n+            }\n+        ]);\n+        let vi = @ast::view_item {\n+            node: vi,\n+            attrs: ~[],\n+            vis: ast::private,\n+            span: codemap::dummy_sp()\n+        };\n+\n+        self.item(\n+            name,\n+            span,\n+            ast::item_mod(ast::_mod {\n+                view_items: ~[vi],\n+                items: items,\n+            })\n+        )\n+    }\n+\n+    fn item_ty_poly(&self, name: ident, span: span, ty: @ast::Ty,\n+                    generics: Generics) -> @ast::item {\n+        self.item(name, span, ast::item_ty(ty, generics))\n+    }\n+\n+    fn item_ty(&self, name: ident, span: span, ty: @ast::Ty) -> @ast::item {\n+        self.item_ty_poly(name, span, ty, ast_util::empty_generics())\n+    }\n+\n+\n }"}, {"sha": "44f47c0d588a4e46318083cf0caa95858c554f5e", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 1, "deletions": 381, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/8c15a0ec4cf023a08078d74ed615ecef0cc10a66/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c15a0ec4cf023a08078d74ed615ecef0cc10a66/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=8c15a0ec4cf023a08078d74ed615ecef0cc10a66", "patch": "@@ -13,16 +13,10 @@\n // To start with, it will be use dummy spans, but it might someday do\n // something smarter.\n \n-use abi::AbiSet;\n use ast::ident;\n use ast;\n-use ast_util;\n-use codemap::{span, respan, dummy_sp, spanned};\n-use codemap;\n-use ext::base::ExtCtxt;\n+use codemap::span;\n use ext::quote::rt::*;\n-use opt_vec;\n-use opt_vec::OptVec;\n \n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n@@ -66,377 +60,3 @@ impl append_types for @ast::Path {\n         }\n     }\n }\n-\n-pub trait ext_ctxt_ast_builder {\n-    fn ty_param(&self, id: ast::ident, bounds: @OptVec<ast::TyParamBound>)\n-        -> ast::TyParam;\n-    fn arg(&self, name: ident, ty: @ast::Ty) -> ast::arg;\n-    fn expr_block(&self, e: @ast::expr) -> ast::blk;\n-    fn fn_decl(&self, inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl;\n-    fn item(&self, name: ident, span: span, node: ast::item_) -> @ast::item;\n-    fn item_fn_poly(&self,\n-                    ame: ident,\n-                    inputs: ~[ast::arg],\n-                    output: @ast::Ty,\n-                    generics: Generics,\n-                    body: ast::blk) -> @ast::item;\n-    fn item_fn(&self,\n-               name: ident,\n-               inputs: ~[ast::arg],\n-               output: @ast::Ty,\n-               body: ast::blk) -> @ast::item;\n-    fn item_enum_poly(&self,\n-                      name: ident,\n-                      span: span,\n-                      enum_definition: ast::enum_def,\n-                      generics: Generics) -> @ast::item;\n-    fn item_enum(&self,\n-                 name: ident,\n-                 span: span,\n-                 enum_definition: ast::enum_def) -> @ast::item;\n-    fn item_struct_poly(&self,\n-                        name: ident,\n-                        span: span,\n-                        struct_def: ast::struct_def,\n-                        generics: Generics) -> @ast::item;\n-    fn item_struct(&self,\n-                   name: ident,\n-                   span: span,\n-                   struct_def: ast::struct_def) -> @ast::item;\n-    fn struct_expr(&self,\n-                   path: @ast::Path,\n-                   fields: ~[ast::field]) -> @ast::expr;\n-    fn variant(&self,\n-               name: ident,\n-               span: span,\n-               tys: ~[@ast::Ty]) -> ast::variant;\n-    fn item_mod(&self,\n-                name: ident,\n-                span: span,\n-                items: ~[@ast::item]) -> @ast::item;\n-    fn ty_path_ast_builder(&self, path: @ast::Path) -> @ast::Ty;\n-    fn item_ty_poly(&self,\n-                    name: ident,\n-                    span: span,\n-                    ty: @ast::Ty,\n-                    generics: Generics) -> @ast::item;\n-    fn item_ty(&self, name: ident, span: span, ty: @ast::Ty) -> @ast::item;\n-    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty];\n-    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty];\n-    fn ty_field_imm(&self, name: ident, ty: @ast::Ty) -> ast::ty_field;\n-    fn field_imm(&self, name: ident, e: @ast::expr) -> ast::field;\n-    fn block(&self, stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk;\n-    fn stmt_let(&self, ident: ident, e: @ast::expr) -> @ast::stmt;\n-    fn stmt_expr(&self, e: @ast::expr) -> @ast::stmt;\n-    fn block_expr(&self, b: ast::blk) -> @ast::expr;\n-    fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty;\n-    fn ty_infer(&self) -> @ast::Ty;\n-    fn ty_nil_ast_builder(&self) -> @ast::Ty;\n-    fn strip_bounds(&self, bounds: &Generics) -> Generics;\n-}\n-\n-impl ext_ctxt_ast_builder for @ExtCtxt {\n-    fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty {\n-        self.ty_path_ast_builder(path_global(~[\n-            self.ident_of(\"core\"),\n-            self.ident_of(\"option\"),\n-            self.ident_of(\"Option\")\n-        ], dummy_sp()).add_ty(ty))\n-    }\n-\n-    fn block_expr(&self, b: ast::blk) -> @ast::expr {\n-        @expr {\n-            id: self.next_id(),\n-            callee_id: self.next_id(),\n-            node: ast::expr_block(b),\n-            span: dummy_sp(),\n-        }\n-    }\n-\n-    fn stmt_expr(&self, e: @ast::expr) -> @ast::stmt {\n-        @spanned { node: ast::stmt_expr(e, self.next_id()),\n-                   span: dummy_sp()}\n-    }\n-\n-    fn stmt_let(&self, ident: ident, e: @ast::expr) -> @ast::stmt {\n-        let ext_cx = *self;\n-        quote_stmt!( let $ident = $e; )\n-    }\n-\n-    fn field_imm(&self, name: ident, e: @ast::expr) -> ast::field {\n-        spanned {\n-            node: ast::field_ { mutbl: ast::m_imm, ident: name, expr: e },\n-            span: dummy_sp(),\n-        }\n-    }\n-\n-    fn ty_field_imm(&self, name: ident, ty: @ast::Ty) -> ast::ty_field {\n-        spanned {\n-            node: ast::ty_field_ {\n-                ident: name,\n-                mt: ast::mt { ty: ty, mutbl: ast::m_imm },\n-            },\n-            span: dummy_sp(),\n-        }\n-    }\n-\n-    fn ty_infer(&self) -> @ast::Ty {\n-        @ast::Ty {\n-            id: self.next_id(),\n-            node: ast::ty_infer,\n-            span: dummy_sp(),\n-        }\n-    }\n-\n-    fn ty_param(&self, id: ast::ident, bounds: @OptVec<ast::TyParamBound>)\n-        -> ast::TyParam\n-    {\n-        ast::TyParam { ident: id, id: self.next_id(), bounds: bounds }\n-    }\n-\n-    fn arg(&self, name: ident, ty: @ast::Ty) -> ast::arg {\n-        ast::arg {\n-            is_mutbl: false,\n-            ty: ty,\n-            pat: @ast::pat {\n-                id: self.next_id(),\n-                node: ast::pat_ident(\n-                    ast::bind_by_copy,\n-                    ast_util::ident_to_path(dummy_sp(), name),\n-                    None),\n-                span: dummy_sp(),\n-            },\n-            id: self.next_id(),\n-        }\n-    }\n-\n-    fn block(&self, stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk {\n-        let blk = ast::blk_ {\n-            view_items: ~[],\n-            stmts: stmts,\n-            expr: Some(e),\n-            id: self.next_id(),\n-            rules: ast::default_blk,\n-        };\n-\n-        spanned { node: blk, span: dummy_sp() }\n-    }\n-\n-    fn expr_block(&self, e: @ast::expr) -> ast::blk {\n-        self.block(~[], e)\n-    }\n-\n-    fn fn_decl(&self, inputs: ~[ast::arg],\n-               output: @ast::Ty) -> ast::fn_decl {\n-        ast::fn_decl {\n-            inputs: inputs,\n-            output: output,\n-            cf: ast::return_val,\n-        }\n-    }\n-\n-    fn item(&self, name: ident, span: span,\n-            node: ast::item_) -> @ast::item {\n-\n-        // XXX: Would be nice if our generated code didn't violate\n-        // Rust coding conventions\n-        let non_camel_case_attribute = respan(dummy_sp(), ast::attribute_ {\n-            style: ast::attr_outer,\n-            value: @respan(dummy_sp(),\n-                          ast::meta_list(@~\"allow\", ~[\n-                              @respan(dummy_sp(),\n-                                      ast::meta_word(\n-                                         @~\"non_camel_case_types\"))\n-                          ])),\n-            is_sugared_doc: false\n-        });\n-\n-        @ast::item { ident: name,\n-                     attrs: ~[non_camel_case_attribute],\n-                     id: self.next_id(),\n-                     node: node,\n-                     vis: ast::public,\n-                     span: span }\n-    }\n-\n-    fn item_fn_poly(&self, name: ident,\n-                    inputs: ~[ast::arg],\n-                    output: @ast::Ty,\n-                    generics: Generics,\n-                    body: ast::blk) -> @ast::item {\n-        self.item(name,\n-                  dummy_sp(),\n-                  ast::item_fn(self.fn_decl(inputs, output),\n-                               ast::impure_fn,\n-                               AbiSet::Rust(),\n-                               generics,\n-                               body))\n-    }\n-\n-    fn item_fn(&self,\n-               name: ident,\n-               inputs: ~[ast::arg],\n-               output: @ast::Ty,\n-               body: ast::blk\n-    ) -> @ast::item {\n-        self.item_fn_poly(\n-            name,\n-            inputs,\n-            output,\n-            ast_util::empty_generics(),\n-            body\n-        )\n-    }\n-\n-    fn item_enum_poly(&self, name: ident, span: span,\n-                      enum_definition: ast::enum_def,\n-                      generics: Generics) -> @ast::item {\n-        self.item(name, span, ast::item_enum(enum_definition, generics))\n-    }\n-\n-    fn item_enum(&self, name: ident, span: span,\n-                 enum_definition: ast::enum_def) -> @ast::item {\n-        self.item_enum_poly(name, span, enum_definition,\n-                            ast_util::empty_generics())\n-    }\n-\n-    fn item_struct(\n-        &self, name: ident,\n-        span: span,\n-        struct_def: ast::struct_def\n-    ) -> @ast::item {\n-        self.item_struct_poly(\n-            name,\n-            span,\n-            struct_def,\n-            ast_util::empty_generics()\n-        )\n-    }\n-\n-    fn item_struct_poly(\n-        &self,\n-        name: ident,\n-        span: span,\n-        struct_def: ast::struct_def,\n-        generics: Generics\n-    ) -> @ast::item {\n-        self.item(name, span, ast::item_struct(@struct_def, generics))\n-    }\n-\n-    fn struct_expr(&self, path: @ast::Path,\n-                   fields: ~[ast::field]) -> @ast::expr {\n-        @ast::expr {\n-            id: self.next_id(),\n-            callee_id: self.next_id(),\n-            node: ast::expr_struct(path, fields, None),\n-            span: dummy_sp()\n-        }\n-    }\n-\n-    fn variant(&self, name: ident, span: span,\n-               tys: ~[@ast::Ty]) -> ast::variant {\n-        let args = do tys.map |ty| {\n-            ast::variant_arg { ty: *ty, id: self.next_id() }\n-        };\n-\n-        spanned {\n-            node: ast::variant_ {\n-                name: name,\n-                attrs: ~[],\n-                kind: ast::tuple_variant_kind(args),\n-                id: self.next_id(),\n-                disr_expr: None,\n-                vis: ast::public\n-            },\n-            span: span,\n-        }\n-    }\n-\n-    fn item_mod(&self, name: ident, span: span,\n-                items: ~[@ast::item]) -> @ast::item {\n-\n-        // XXX: Total hack: import `core::kinds::Owned` to work around a\n-        // parser bug whereby `fn f<T:::kinds::Owned>` doesn't parse.\n-        let vi = ast::view_item_use(~[\n-            @codemap::spanned {\n-                node: ast::view_path_simple(\n-                    self.ident_of(\"Owned\"),\n-                    path(\n-                        ~[\n-                            self.ident_of(\"core\"),\n-                            self.ident_of(\"kinds\"),\n-                            self.ident_of(\"Owned\")\n-                        ],\n-                        codemap::dummy_sp()\n-                    ),\n-                    self.next_id()\n-                ),\n-                span: codemap::dummy_sp()\n-            }\n-        ]);\n-        let vi = @ast::view_item {\n-            node: vi,\n-            attrs: ~[],\n-            vis: ast::private,\n-            span: codemap::dummy_sp()\n-        };\n-\n-        self.item(\n-            name,\n-            span,\n-            ast::item_mod(ast::_mod {\n-                view_items: ~[vi],\n-                items: items,\n-            })\n-        )\n-    }\n-\n-    fn ty_path_ast_builder(&self, path: @ast::Path) -> @ast::Ty {\n-        @ast::Ty {\n-            id: self.next_id(),\n-            node: ast::ty_path(path, self.next_id()),\n-            span: path.span,\n-        }\n-    }\n-\n-    fn ty_nil_ast_builder(&self) -> @ast::Ty {\n-        @ast::Ty {\n-            id: self.next_id(),\n-            node: ast::ty_nil,\n-            span: dummy_sp(),\n-        }\n-    }\n-\n-    fn strip_bounds(&self, generics: &Generics) -> Generics {\n-        let no_bounds = @opt_vec::Empty;\n-        let new_params = do generics.ty_params.map |ty_param| {\n-            ast::TyParam { bounds: no_bounds, ..copy *ty_param }\n-        };\n-        Generics {\n-            ty_params: new_params,\n-            .. copy *generics\n-        }\n-    }\n-\n-    fn item_ty_poly(&self, name: ident, span: span, ty: @ast::Ty,\n-                    generics: Generics) -> @ast::item {\n-        self.item(name, span, ast::item_ty(ty, generics))\n-    }\n-\n-    fn item_ty(&self, name: ident, span: span, ty: @ast::Ty) -> @ast::item {\n-        self.item_ty_poly(name, span, ty, ast_util::empty_generics())\n-    }\n-\n-    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n-        opt_vec::take_vec(\n-            ty_params.map(|p| self.ty_path_ast_builder(\n-                path(~[p.ident], dummy_sp()))))\n-    }\n-\n-    fn ty_vars_global(&self,\n-                      ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n-        opt_vec::take_vec(\n-            ty_params.map(|p| self.ty_path_ast_builder(\n-                path(~[p.ident], dummy_sp()))))\n-    }\n-}"}, {"sha": "4362699378344c626b1193555f94699e0101e638", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8c15a0ec4cf023a08078d74ed615ecef0cc10a66/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c15a0ec4cf023a08078d74ed615ecef0cc10a66/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=8c15a0ec4cf023a08078d74ed615ecef0cc10a66", "patch": "@@ -13,7 +13,8 @@\n use ast;\n use codemap::{dummy_sp, spanned};\n use ext::base::ExtCtxt;\n-use ext::pipes::ast_builder::{append_types, ext_ctxt_ast_builder, path};\n+use ext::build::AstBuilder;\n+use ext::pipes::ast_builder::{append_types, path};\n use ext::pipes::ast_builder::{path_global};\n use ext::pipes::proto::*;\n use ext::quote::rt::*;\n@@ -54,7 +55,7 @@ impl gen_send for message {\n             let arg_names = tys.mapi(|i, _ty| cx.ident_of(~\"x_\"+i.to_str()));\n             let args_ast = vec::map_zip(arg_names, *tys, |n, t| cx.arg(*n, *t));\n \n-            let pipe_ty = cx.ty_path_ast_builder(\n+            let pipe_ty = cx.ty_path(\n                 path(~[this.data_name()], span)\n                 .add_tys(cx.ty_vars_global(&this.generics.ty_params)));\n             let args_ast = vec::append(\n@@ -111,7 +112,7 @@ impl gen_send for message {\n \n             let body = cx.parse_expr(body);\n \n-            let mut rty = cx.ty_path_ast_builder(path(~[next.data_name()],\n+            let mut rty = cx.ty_path(path(~[next.data_name()],\n                                                       span)\n                                                .add_tys(copy next_state.tys));\n             if try {\n@@ -124,7 +125,7 @@ impl gen_send for message {\n                             args_ast,\n                             rty,\n                             self.get_generics(),\n-                            cx.expr_block(body))\n+                            cx.blk_expr(body))\n           }\n \n             message(ref _id, span, ref tys, this, None) => {\n@@ -137,7 +138,7 @@ impl gen_send for message {\n \n                 let args_ast = vec::append(\n                     ~[cx.arg(cx.ident_of(\"pipe\"),\n-                             cx.ty_path_ast_builder(\n+                             cx.ty_path(\n                                  path(~[this.data_name()], span)\n                                  .add_tys(cx.ty_vars_global(\n                                      &this.generics.ty_params))))],\n@@ -179,13 +180,13 @@ impl gen_send for message {\n                                     cx.ty_nil_ast_builder()\n                                 },\n                                 self.get_generics(),\n-                                cx.expr_block(body))\n+                                cx.blk_expr(body))\n             }\n           }\n         }\n \n     fn to_ty(&mut self, cx: @ExtCtxt) -> @ast::Ty {\n-        cx.ty_path_ast_builder(path(~[cx.ident_of(self.name())], self.span())\n+        cx.ty_path(path(~[cx.ident_of(self.name())], self.span())\n           .add_tys(cx.ty_vars_global(&self.get_generics().ty_params)))\n     }\n }\n@@ -217,7 +218,7 @@ impl to_type_decls for state {\n                 };\n \n                 vec::append_one(tys,\n-                                cx.ty_path_ast_builder(\n+                                cx.ty_path(\n                                     path(~[cx.ident_of(dir),\n                                            cx.ident_of(next_name)], span)\n                                     .add_tys(copy next_state.tys)))\n@@ -264,12 +265,12 @@ impl to_type_decls for state {\n                 cx.item_ty_poly(\n                     self.data_name(),\n                     self.span,\n-                    cx.ty_path_ast_builder(\n+                    cx.ty_path(\n                         path_global(~[cx.ident_of(\"core\"),\n                                       cx.ident_of(\"pipes\"),\n                                       cx.ident_of(dir.to_str() + \"Packet\")],\n                              dummy_sp())\n-                        .add_ty(cx.ty_path_ast_builder(\n+                        .add_ty(cx.ty_path(\n                             path(~[cx.ident_of(\"super\"),\n                                    self.data_name()],\n                                  dummy_sp())\n@@ -282,13 +283,13 @@ impl to_type_decls for state {\n                 cx.item_ty_poly(\n                     self.data_name(),\n                     self.span,\n-                    cx.ty_path_ast_builder(\n+                    cx.ty_path(\n                         path_global(~[cx.ident_of(\"core\"),\n                                       cx.ident_of(\"pipes\"),\n                                       cx.ident_of(dir.to_str()\n                                                   + \"PacketBuffered\")],\n                              dummy_sp())\n-                        .add_tys(~[cx.ty_path_ast_builder(\n+                        .add_tys(~[cx.ty_path(\n                             path(~[cx.ident_of(\"super\"),\n                                    self.data_name()],\n                                         dummy_sp())\n@@ -341,7 +342,7 @@ impl gen_init for protocol {\n     }\n \n     fn gen_buffer_init(&self, ext_cx: @ExtCtxt) -> @ast::expr {\n-        ext_cx.struct_expr(path(~[ext_cx.ident_of(\"__Buffer\")],\n+        ext_cx.expr_struct(path(~[ext_cx.ident_of(\"__Buffer\")],\n                                 dummy_sp()),\n                       self.states.map_to_vec(|s| {\n             let fty = s.to_ty(ext_cx);\n@@ -360,15 +361,16 @@ impl gen_init for protocol {\n             data: $buffer_fields,\n         });\n \n-        let entangle_body = ext_cx.block_expr(\n-            ext_cx.block(\n+        let entangle_body = ext_cx.expr_blk(\n+            ext_cx.blk(\n+                dummy_sp(),\n                 self.states.map_to_vec(\n                     |s| ext_cx.parse_stmt(\n                         fmt!(\"data.%s.set_buffer(buffer)\",\n                              s.name))),\n-                ext_cx.parse_expr(fmt!(\n+                Some(ext_cx.parse_expr(fmt!(\n                     \"::core::ptr::to_mut_unsafe_ptr(&mut (data.%s))\",\n-                    self.states[0].name))));\n+                    self.states[0].name)))));\n \n         quote_expr!({\n             let buffer = $buffer;\n@@ -389,7 +391,7 @@ impl gen_init for protocol {\n             }\n         }\n \n-        cx.ty_path_ast_builder(path(~[cx.ident_of(\"super\"),\n+        cx.ty_path(path(~[cx.ident_of(\"super\"),\n                                       cx.ident_of(\"__Buffer\")],\n                                     copy self.span)\n                                .add_tys(cx.ty_vars_global(&params)))"}, {"sha": "4471c5bb9b855b91aaef8bd99f67fcf67f40fa4d", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c15a0ec4cf023a08078d74ed615ecef0cc10a66/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c15a0ec4cf023a08078d74ed615ecef0cc10a66/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=8c15a0ec4cf023a08078d74ed615ecef0cc10a66", "patch": "@@ -11,7 +11,8 @@\n use ast;\n use codemap::span;\n use ext::base::ExtCtxt;\n-use ext::pipes::ast_builder::{append_types, ext_ctxt_ast_builder, path};\n+use ext::build::AstBuilder;\n+use ext::pipes::ast_builder::{append_types, path};\n \n #[deriving(Eq)]\n pub enum direction { send, recv }\n@@ -93,7 +94,7 @@ pub impl state_ {\n \n     /// Returns the type that is used for the messages.\n     fn to_ty(&self, cx: @ExtCtxt) -> @ast::Ty {\n-        cx.ty_path_ast_builder\n+        cx.ty_path\n             (path(~[cx.ident_of(self.name)],self.span).add_tys(\n                 cx.ty_vars(&self.generics.ty_params)))\n     }"}]}