{"sha": "9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljYjE4YTkyYWQ4Nzg1MmM0YzVkNjcyNmI4ZmJlOGMzOGRlZGE0YmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-02T06:08:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-02T06:08:15Z"}, "message": "Auto merge of #48653 - Manishearth:rollup2, r=Manishearth\n\nAnother rollup\n\nNone", "tree": {"sha": "f00265de1b24b45be03ed60902101a9d81b121b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f00265de1b24b45be03ed60902101a9d81b121b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "html_url": "https://github.com/rust-lang/rust/commit/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "html_url": "https://github.com/rust-lang/rust/commit/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f"}, {"sha": "2b3c815ddfefcabd3231ea3bb82443853f2e2254", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b3c815ddfefcabd3231ea3bb82443853f2e2254", "html_url": "https://github.com/rust-lang/rust/commit/2b3c815ddfefcabd3231ea3bb82443853f2e2254"}], "stats": {"total": 1041, "additions": 705, "deletions": 336}, "files": [{"sha": "0d8641e45ed157b90b56fb3dd940ad611b89da99", "filename": ".travis.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -188,7 +188,7 @@ matrix:\n       script:\n         MESSAGE_FILE=$(mktemp -t msg.XXXXXX);\n         . src/ci/docker/x86_64-gnu-tools/repo.sh;\n-        commit_toolstate_change \"$MESSAGE_FILE\" \"$TRAVIS_BUILD_DIR/src/tools/publish_toolstate.py\" \"$(git rev-parse HEAD)\" \"$(git log --format=%s -n1 HEAD)\" \"$MESSAGE_FILE\"\n+        commit_toolstate_change \"$MESSAGE_FILE\" \"$TRAVIS_BUILD_DIR/src/tools/publish_toolstate.py\" \"$(git rev-parse HEAD)\" \"$(git log --format=%s -n1 HEAD)\" \"$MESSAGE_FILE\" \"$TOOLSTATE_REPO_ACCESS_TOKEN\";\n \n env:\n   global:"}, {"sha": "e78bbb82711abdcf48b909cf6a88fa6616b20cfa", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -233,7 +233,7 @@ find out how various parts of the compiler work.\n [IRC]: https://en.wikipedia.org/wiki/Internet_Relay_Chat\n [#rust]: irc://irc.mozilla.org/rust\n [#rust-beginners]: irc://irc.mozilla.org/rust-beginners\n-[rustc-guide]: https://rust-lang-nursery.github.io/rustc-guide/about-this-guide.html\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/about-this-guide.html\n \n ## License\n [license]: #license"}, {"sha": "1df85323c41ef203ebbc4899d93bb24a60606737", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -231,7 +231,7 @@ pub struct ShouldRun<'a> {\n     paths: BTreeSet<PathSet>,\n \n     // If this is a default rule, this is an additional constraint placed on\n-    // it's run. Generally something like compiler docs being enabled.\n+    // its run. Generally something like compiler docs being enabled.\n     is_really_default: bool,\n }\n \n@@ -326,7 +326,9 @@ impl<'a> Builder<'a> {\n                 test::RunPassPretty, test::RunFailPretty, test::RunPassValgrindPretty,\n                 test::RunPassFullDepsPretty, test::RunFailFullDepsPretty, test::RunMake,\n                 test::Crate, test::CrateLibrustc, test::Rustdoc, test::Linkcheck, test::Cargotest,\n-                test::Cargo, test::Rls, test::Docs, test::ErrorIndex, test::Distcheck,\n+                test::Cargo, test::Rls, test::ErrorIndex, test::Distcheck,\n+                test::Nomicon, test::Reference, test::RustdocBook, test::RustByExample,\n+                test::TheBook, test::UnstableBook,\n                 test::Rustfmt, test::Miri, test::Clippy, test::RustdocJS, test::RustdocTheme),\n             Kind::Bench => describe!(test::Crate, test::CrateLibrustc),\n             Kind::Doc => describe!(doc::UnstableBook, doc::UnstableBookGen, doc::TheBook,"}, {"sha": "408d63be6c6bfeed21bbeadfe722bb66f9b220d3", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -629,6 +629,8 @@ impl Step for CodegenBackend {\n             .arg(build.src.join(\"src/librustc_trans/Cargo.toml\"));\n         rustc_cargo_env(build, &mut cargo);\n \n+        let _folder = build.fold_output(|| format!(\"stage{}-rustc_trans\", compiler.stage));\n+\n         match &*self.backend {\n             \"llvm\" | \"emscripten\" => {\n                 // Build LLVM for our target. This will implicitly build the\n@@ -642,7 +644,6 @@ impl Step for CodegenBackend {\n                     features.push_str(\" emscripten\");\n                 }\n \n-                let _folder = build.fold_output(|| format!(\"stage{}-rustc_trans\", compiler.stage));\n                 println!(\"Building stage{} codegen artifacts ({} -> {}, {})\",\n                          compiler.stage, &compiler.host, target, self.backend);\n "}, {"sha": "b27ddfdbc5e583e2a3a91dfe7907390caf412e74", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 69, "deletions": 18, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -78,15 +78,17 @@ fn try_run(build: &Build, cmd: &mut Command) -> bool {\n     true\n }\n \n-fn try_run_quiet(build: &Build, cmd: &mut Command) {\n+fn try_run_quiet(build: &Build, cmd: &mut Command) -> bool {\n     if !build.fail_fast {\n         if !build.try_run_quiet(cmd) {\n             let mut failures = build.delayed_failures.borrow_mut();\n             failures.push(format!(\"{:?}\", cmd));\n+            return false;\n         }\n     } else {\n         build.run_quiet(cmd);\n     }\n+    true\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -994,23 +996,19 @@ impl Step for Compiletest {\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Docs {\n+struct DocTest {\n     compiler: Compiler,\n+    path: &'static str,\n+    name: &'static str,\n+    is_ext_doc: bool,\n }\n \n-impl Step for Docs {\n+impl Step for DocTest {\n     type Output = ();\n-    const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/doc\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Docs {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n-        });\n+        run.never()\n     }\n \n     /// Run `rustdoc --test` for all documentation in `src/doc`.\n@@ -1026,9 +1024,9 @@ impl Step for Docs {\n \n         // Do a breadth-first traversal of the `src/doc` directory and just run\n         // tests for all files that end in `*.md`\n-        let mut stack = vec![build.src.join(\"src/doc\")];\n+        let mut stack = vec![build.src.join(self.path)];\n         let _time = util::timeit();\n-        let _folder = build.fold_output(|| \"test_docs\");\n+        let _folder = build.fold_output(|| format!(\"test_{}\", self.name));\n \n         while let Some(p) = stack.pop() {\n             if p.is_dir() {\n@@ -1046,11 +1044,64 @@ impl Step for Docs {\n                 continue;\n             }\n \n-            markdown_test(builder, compiler, &p);\n+            let test_result = markdown_test(builder, compiler, &p);\n+            if self.is_ext_doc {\n+                let toolstate = if test_result {\n+                    ToolState::TestPass\n+                } else {\n+                    ToolState::TestFail\n+                };\n+                build.save_toolstate(self.name, toolstate);\n+            }\n         }\n     }\n }\n \n+macro_rules! test_book {\n+    ($($name:ident, $path:expr, $book_name:expr, default=$default:expr;)+) => {\n+        $(\n+            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+            pub struct $name {\n+                compiler: Compiler,\n+            }\n+\n+            impl Step for $name {\n+                type Output = ();\n+                const DEFAULT: bool = $default;\n+                const ONLY_HOSTS: bool = true;\n+\n+                fn should_run(run: ShouldRun) -> ShouldRun {\n+                    run.path($path)\n+                }\n+\n+                fn make_run(run: RunConfig) {\n+                    run.builder.ensure($name {\n+                        compiler: run.builder.compiler(run.builder.top_stage, run.host),\n+                    });\n+                }\n+\n+                fn run(self, builder: &Builder) {\n+                    builder.ensure(DocTest {\n+                        compiler: self.compiler,\n+                        path: $path,\n+                        name: $book_name,\n+                        is_ext_doc: !$default,\n+                    });\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+test_book!(\n+    Nomicon, \"src/doc/nomicon\", \"nomicon\", default=false;\n+    Reference, \"src/doc/reference\", \"reference\", default=false;\n+    RustdocBook, \"src/doc/rustdoc\", \"rustdoc\", default=true;\n+    RustByExample, \"src/doc/rust-by-example\", \"rust-by-example\", default=false;\n+    TheBook, \"src/doc/book\", \"book\", default=false;\n+    UnstableBook, \"src/doc/unstable-book\", \"unstable-book\", default=true;\n+);\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct ErrorIndex {\n     compiler: Compiler,\n@@ -1101,13 +1152,13 @@ impl Step for ErrorIndex {\n     }\n }\n \n-fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) {\n+fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) -> bool {\n     let build = builder.build;\n     let mut file = t!(File::open(markdown));\n     let mut contents = String::new();\n     t!(file.read_to_string(&mut contents));\n     if !contents.contains(\"```\") {\n-        return;\n+        return true;\n     }\n \n     println!(\"doc tests for: {}\", markdown.display());\n@@ -1121,9 +1172,9 @@ fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) {\n     cmd.arg(\"--test-args\").arg(test_args);\n \n     if build.config.quiet_tests {\n-        try_run_quiet(build, &mut cmd);\n+        try_run_quiet(build, &mut cmd)\n     } else {\n-        try_run(build, &mut cmd);\n+        try_run(build, &mut cmd)\n     }\n }\n "}, {"sha": "bab9145cbcb9c78ed68ee5c5a06fdf28cca932a6", "filename": "src/ci/docker/x86_64-gnu-tools/Dockerfile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -17,6 +17,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n+COPY x86_64-gnu-tools/checkregression.py /tmp/\n COPY x86_64-gnu-tools/checktools.sh /tmp/\n COPY x86_64-gnu-tools/repo.sh /tmp/\n "}, {"sha": "df791d12645fdea798b18f5df759de51019a5501", "filename": "src/ci/docker/x86_64-gnu-tools/checkregression.py", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fcheckregression.py", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fcheckregression.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fcheckregression.py?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -0,0 +1,40 @@\n+#!/usr/bin/env python\n+# -*- coding: utf-8 -*-\n+\n+# Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+import sys\n+import json\n+\n+if __name__ == '__main__':\n+    os_name = sys.argv[1]\n+    toolstate_file = sys.argv[2]\n+    current_state = sys.argv[3]\n+\n+    with open(toolstate_file, 'r') as f:\n+        toolstate = json.load(f)\n+    with open(current_state, 'r') as f:\n+        current = json.load(f)\n+\n+    regressed = False\n+    for cur in current:\n+        tool = cur['tool']\n+        state = cur[os_name]\n+        new_state = toolstate.get(tool, '')\n+        if new_state < state:\n+            print(\n+                'Error: The state of \"{}\" has regressed from \"{}\" to \"{}\"'\n+                .format(tool, state, new_state)\n+            )\n+            regressed = True\n+\n+    if regressed:\n+        sys.exit(1)"}, {"sha": "da89aa9423b2daa18cf9a9bc500fd63c717ecc64", "filename": "src/ci/docker/x86_64-gnu-tools/checktools.sh", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -17,39 +17,57 @@ TOOLSTATE_FILE=\"$(realpath $2)\"\n OS=\"$3\"\n COMMIT=\"$(git rev-parse HEAD)\"\n CHANGED_FILES=\"$(git diff --name-status HEAD HEAD^)\"\n+SIX_WEEK_CYCLE=\"$(( ($(date +%s) / 604800 - 3) % 6 ))\"\n+# ^ 1970 Jan 1st is a Thursday, and our release dates are also on Thursdays,\n+#   thus we could divide by 604800 (7 days in seconds) directly.\n \n touch \"$TOOLSTATE_FILE\"\n \n set +e\n python2.7 \"$X_PY\" test --no-fail-fast \\\n+    src/doc/book \\\n+    src/doc/nomicon \\\n+    src/doc/reference \\\n+    src/doc/rust-by-example \\\n     src/tools/rls \\\n     src/tools/rustfmt \\\n     src/tools/miri \\\n     src/tools/clippy\n set -e\n \n cat \"$TOOLSTATE_FILE\"\n+echo\n \n-# If this PR is intended to update one of these tools, do not let the build pass\n-# when they do not test-pass.\n-for TOOL in rls rustfmt clippy; do\n-    echo \"Verifying status of $TOOL...\"\n-    if echo \"$CHANGED_FILES\" | grep -q \"^M[[:blank:]]src/tools/$TOOL$\"; then\n-        echo \"This PR updated 'src/tools/$TOOL', verifying if status is 'test-pass'...\"\n-        if grep -vq '\"'\"$TOOL\"'[^\"]*\":\"test-pass\"' \"$TOOLSTATE_FILE\"; then\n+verify_status() {\n+    echo \"Verifying status of $1...\"\n+    if echo \"$CHANGED_FILES\" | grep -q \"^M[[:blank:]]$2$\"; then\n+        echo \"This PR updated '$2', verifying if status is 'test-pass'...\"\n+        if grep -vq '\"'\"$1\"'\":\"test-pass\"' \"$TOOLSTATE_FILE\"; then\n             echo\n-            echo \"\u26a0\ufe0f We detected that this PR updated '$TOOL', but its tests failed.\"\n+            echo \"\u26a0\ufe0f We detected that this PR updated '$1', but its tests failed.\"\n             echo\n-            echo \"If you do intend to update '$TOOL', please check the error messages above and\"\n+            echo \"If you do intend to update '$1', please check the error messages above and\"\n             echo \"commit another update.\"\n             echo\n-            echo \"If you do NOT intend to update '$TOOL', please ensure you did not accidentally\"\n-            echo \"change the submodule at 'src/tools/$TOOL'. You may ask your reviewer for the\"\n+            echo \"If you do NOT intend to update '$1', please ensure you did not accidentally\"\n+            echo \"change the submodule at '$2'. You may ask your reviewer for the\"\n             echo \"proper steps.\"\n             exit 3\n         fi\n     fi\n-done\n+}\n+\n+# If this PR is intended to update one of these tools, do not let the build pass\n+# when they do not test-pass.\n+\n+verify_status book src/doc/book\n+verify_status nomicon src/doc/nomicon\n+verify_status reference src/doc/reference\n+verify_status rust-by-example src/doc/rust-by-example\n+verify_status rls src/tool/rls\n+verify_status rustfmt src/tool/rustfmt\n+verify_status clippy-driver src/tool/clippy\n+#verify_status miri src/tool/miri\n \n if [ \"$RUST_RELEASE_CHANNEL\" = nightly -a -n \"${TOOLSTATE_REPO_ACCESS_TOKEN+is_set}\" ]; then\n     . \"$(dirname $0)/repo.sh\"\n@@ -59,6 +77,11 @@ if [ \"$RUST_RELEASE_CHANNEL\" = nightly -a -n \"${TOOLSTATE_REPO_ACCESS_TOKEN+is_s\n         sed -i \"1 a\\\\\n $COMMIT\\t$(cat \"$TOOLSTATE_FILE\")\n \" \"history/$OS.tsv\"\n+    # if we are at the last week in the 6-week release cycle, reject any kind of regression.\n+    if [ $SIX_WEEK_CYCLE -eq 5 ]; then\n+        python2.7 \"$(dirname $0)/checkregression.py\" \\\n+            \"$OS\" \"$TOOLSTATE_FILE\" \"rust-toolstate/_data/latest.json\"\n+    fi\n     rm -f \"$MESSAGE_FILE\"\n     exit 0\n fi"}, {"sha": "a41ac5bceed27d51b8813e56afb5fe83e23b2239", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 78, "deletions": 76, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -2472,86 +2472,88 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_pat(&mut self, p: &Pat) -> P<hir::Pat> {\n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(p.id);\n+        let node = match p.node {\n+            PatKind::Wild => hir::PatKind::Wild,\n+            PatKind::Ident(ref binding_mode, pth1, ref sub) => {\n+                match self.resolver.get_resolution(p.id).map(|d| d.base_def()) {\n+                    // `None` can occur in body-less function signatures\n+                    def @ None | def @ Some(Def::Local(_)) => {\n+                        let canonical_id = match def {\n+                            Some(Def::Local(id)) => id,\n+                            _ => p.id\n+                        };\n+                        hir::PatKind::Binding(self.lower_binding_mode(binding_mode),\n+                                                canonical_id,\n+                                                respan(pth1.span, pth1.node.name),\n+                                                sub.as_ref().map(|x| self.lower_pat(x)))\n+                    }\n+                    Some(def) => {\n+                        hir::PatKind::Path(hir::QPath::Resolved(None, P(hir::Path {\n+                            span: pth1.span,\n+                            def,\n+                            segments: hir_vec![\n+                                hir::PathSegment::from_name(pth1.node.name)\n+                            ],\n+                        })))\n+                    }\n+                }\n+            }\n+            PatKind::Lit(ref e) => hir::PatKind::Lit(P(self.lower_expr(e))),\n+            PatKind::TupleStruct(ref path, ref pats, ddpos) => {\n+                let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional,\n+                                                ImplTraitContext::Disallowed);\n+                hir::PatKind::TupleStruct(qpath,\n+                                            pats.iter().map(|x| self.lower_pat(x)).collect(),\n+                                            ddpos)\n+            }\n+            PatKind::Path(ref qself, ref path) => {\n+                hir::PatKind::Path(self.lower_qpath(p.id, qself, path, ParamMode::Optional,\n+                                                    ImplTraitContext::Disallowed))\n+            }\n+            PatKind::Struct(ref path, ref fields, etc) => {\n+                let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional,\n+                                                ImplTraitContext::Disallowed);\n+\n+                let fs = fields.iter()\n+                                .map(|f| {\n+                                    Spanned {\n+                                        span: f.span,\n+                                        node: hir::FieldPat {\n+                                            name: self.lower_ident(f.node.ident),\n+                                            pat: self.lower_pat(&f.node.pat),\n+                                            is_shorthand: f.node.is_shorthand,\n+                                        },\n+                                    }\n+                                })\n+                                .collect();\n+                hir::PatKind::Struct(qpath, fs, etc)\n+            }\n+            PatKind::Tuple(ref elts, ddpos) => {\n+                hir::PatKind::Tuple(elts.iter().map(|x| self.lower_pat(x)).collect(), ddpos)\n+            }\n+            PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n+            PatKind::Ref(ref inner, mutbl) => {\n+                hir::PatKind::Ref(self.lower_pat(inner), self.lower_mutability(mutbl))\n+            }\n+            PatKind::Range(ref e1, ref e2, ref end) => {\n+                hir::PatKind::Range(P(self.lower_expr(e1)),\n+                                    P(self.lower_expr(e2)),\n+                                    self.lower_range_end(end))\n+            }\n+            PatKind::Slice(ref before, ref slice, ref after) => {\n+                hir::PatKind::Slice(before.iter().map(|x| self.lower_pat(x)).collect(),\n+                            slice.as_ref().map(|x| self.lower_pat(x)),\n+                            after.iter().map(|x| self.lower_pat(x)).collect())\n+            }\n+            PatKind::Paren(ref inner) => return self.lower_pat(inner),\n+            PatKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n+        };\n \n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(p.id);\n         P(hir::Pat {\n             id: node_id,\n             hir_id,\n-            node: match p.node {\n-                PatKind::Wild => hir::PatKind::Wild,\n-                PatKind::Ident(ref binding_mode, pth1, ref sub) => {\n-                    match self.resolver.get_resolution(p.id).map(|d| d.base_def()) {\n-                        // `None` can occur in body-less function signatures\n-                        def @ None | def @ Some(Def::Local(_)) => {\n-                            let canonical_id = match def {\n-                                Some(Def::Local(id)) => id,\n-                                _ => p.id\n-                            };\n-                            hir::PatKind::Binding(self.lower_binding_mode(binding_mode),\n-                                                  canonical_id,\n-                                                  respan(pth1.span, pth1.node.name),\n-                                                  sub.as_ref().map(|x| self.lower_pat(x)))\n-                        }\n-                        Some(def) => {\n-                            hir::PatKind::Path(hir::QPath::Resolved(None, P(hir::Path {\n-                                span: pth1.span,\n-                                def,\n-                                segments: hir_vec![\n-                                    hir::PathSegment::from_name(pth1.node.name)\n-                                ],\n-                            })))\n-                        }\n-                    }\n-                }\n-                PatKind::Lit(ref e) => hir::PatKind::Lit(P(self.lower_expr(e))),\n-                PatKind::TupleStruct(ref path, ref pats, ddpos) => {\n-                    let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional,\n-                                                 ImplTraitContext::Disallowed);\n-                    hir::PatKind::TupleStruct(qpath,\n-                                              pats.iter().map(|x| self.lower_pat(x)).collect(),\n-                                              ddpos)\n-                }\n-                PatKind::Path(ref qself, ref path) => {\n-                    hir::PatKind::Path(self.lower_qpath(p.id, qself, path, ParamMode::Optional,\n-                                                        ImplTraitContext::Disallowed))\n-                }\n-                PatKind::Struct(ref path, ref fields, etc) => {\n-                    let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional,\n-                                                 ImplTraitContext::Disallowed);\n-\n-                    let fs = fields.iter()\n-                                   .map(|f| {\n-                                       Spanned {\n-                                           span: f.span,\n-                                           node: hir::FieldPat {\n-                                               name: self.lower_ident(f.node.ident),\n-                                               pat: self.lower_pat(&f.node.pat),\n-                                               is_shorthand: f.node.is_shorthand,\n-                                           },\n-                                       }\n-                                   })\n-                                   .collect();\n-                    hir::PatKind::Struct(qpath, fs, etc)\n-                }\n-                PatKind::Tuple(ref elts, ddpos) => {\n-                    hir::PatKind::Tuple(elts.iter().map(|x| self.lower_pat(x)).collect(), ddpos)\n-                }\n-                PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n-                PatKind::Ref(ref inner, mutbl) => {\n-                    hir::PatKind::Ref(self.lower_pat(inner), self.lower_mutability(mutbl))\n-                }\n-                PatKind::Range(ref e1, ref e2, ref end) => {\n-                    hir::PatKind::Range(P(self.lower_expr(e1)),\n-                                        P(self.lower_expr(e2)),\n-                                        self.lower_range_end(end))\n-                }\n-                PatKind::Slice(ref before, ref slice, ref after) => {\n-                    hir::PatKind::Slice(before.iter().map(|x| self.lower_pat(x)).collect(),\n-                                slice.as_ref().map(|x| self.lower_pat(x)),\n-                                after.iter().map(|x| self.lower_pat(x)).collect())\n-                }\n-                PatKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n-            },\n+            node,\n             span: p.span,\n         })\n     }"}, {"sha": "66f34a72edf2d4fce674ae9c15ba32a980861595", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -737,6 +737,7 @@ impl EarlyLintPass for IllegalFloatLiteralPattern {\n                 PatKind::TupleStruct(..) |\n                 PatKind::Ref(..) |\n                 PatKind::Box(..) |\n+                PatKind::Paren(..) |\n                 PatKind::Slice(..) => (),\n \n                 // Extract the expressions and check them"}, {"sha": "a0fc5533f8e5445ce7923538da20163bd9126f58", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -542,7 +542,7 @@ fn foo<T, T>(s: T, u: T) {} // error: the name `T` is already used for a type\n                             //        parameter in this type parameter list\n ```\n \n-Please verify that none of the type parameterss are misspelled, and rename any\n+Please verify that none of the type parameters are misspelled, and rename any\n clashing parameters. Example:\n \n ```\n@@ -551,7 +551,8 @@ fn foo<T, Y>(s: T, u: Y) {} // ok!\n \"##,\n \n E0404: r##\"\n-You tried to implement something which was not a trait on an object.\n+You tried to use something which is not a trait in a trait position, such as\n+a bound or `impl`.\n \n Erroneous code example:\n \n@@ -562,6 +563,14 @@ struct Bar;\n impl Foo for Bar {} // error: `Foo` is not a trait\n ```\n \n+Another erroneous code example:\n+\n+```compile_fail,E0404\n+struct Foo;\n+\n+fn bar<T: Foo>(t: T) {} // error: `Foo` is not a trait\n+```\n+\n Please verify that you didn't misspell the trait's name or otherwise use the\n wrong identifier. Example:\n \n@@ -575,6 +584,17 @@ impl Foo for Bar { // ok!\n     // functions implementation\n }\n ```\n+\n+or\n+\n+```\n+trait Foo {\n+    // some functions\n+}\n+\n+fn bar<T: Foo>(t: T) {} // ok!\n+```\n+\n \"##,\n \n E0405: r##\""}, {"sha": "42bcc62f291c81e44b4a698cfe6d3181369da6f8", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -2163,6 +2163,7 @@ impl<'a> Resolver<'a> {\n         result\n     }\n \n+    /// This is called to resolve a trait reference from an `impl` (i.e. `impl Trait for Foo`)\n     fn with_optional_trait_ref<T, F>(&mut self, opt_trait_ref: Option<&TraitRef>, f: F) -> T\n         where F: FnOnce(&mut Resolver, Option<DefId>) -> T\n     {\n@@ -2172,13 +2173,14 @@ impl<'a> Resolver<'a> {\n             let path: Vec<_> = trait_ref.path.segments.iter()\n                 .map(|seg| respan(seg.span, seg.identifier))\n                 .collect();\n-            let def = self.smart_resolve_path_fragment(trait_ref.ref_id,\n-                                                       None,\n-                                                       &path,\n-                                                       trait_ref.path.span,\n-                                                       trait_ref.path.segments.last().unwrap().span,\n-                                                       PathSource::Trait(AliasPossibility::No))\n-                .base_def();\n+            let def = self.smart_resolve_path_fragment(\n+                trait_ref.ref_id,\n+                None,\n+                &path,\n+                trait_ref.path.span,\n+                trait_ref.path.segments.last().unwrap().span,\n+                PathSource::Trait(AliasPossibility::No)\n+            ).base_def();\n             if def != Def::Err {\n                 new_id = Some(def.def_id());\n                 let span = trait_ref.path.span;"}, {"sha": "57cd47063dcefbe7d8631db764fc4c84b5f3b7de", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -212,7 +212,7 @@ fn from_target_feature(\n         let value = value.as_str();\n         for feature in value.split(',') {\n             if whitelist.contains(feature) {\n-                let llvm_feature = llvm_util::to_llvm_feature(feature);\n+                let llvm_feature = llvm_util::to_llvm_feature(&tcx.sess, feature);\n                 target_features.push(format!(\"+{}\", llvm_feature));\n                 continue\n             }"}, {"sha": "45445a48e233ed160b5ac6c743296d28e95b70ad", "filename": "src/librustc_trans/llvm_util.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibrustc_trans%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibrustc_trans%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fllvm_util.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -81,7 +81,9 @@ unsafe fn configure_llvm(sess: &Session) {\n \n const ARM_WHITELIST: &'static [&'static str] = &[\"neon\", \"v7\", \"vfp2\", \"vfp3\", \"vfp4\"];\n \n-const AARCH64_WHITELIST: &'static [&'static str] = &[\"neon\", \"v7\"];\n+const AARCH64_WHITELIST: &'static [&'static str] = &[\"fp\", \"neon\", \"sve\", \"crc\", \"crypto\",\n+                                                     \"ras\", \"lse\", \"rdm\", \"fp16\", \"rcpc\",\n+                                                     \"dotprod\", \"v8.1a\", \"v8.2a\", \"v8.3a\"];\n \n const X86_WHITELIST: &'static [&'static str] = &[\"aes\", \"avx\", \"avx2\", \"avx512bw\",\n                                                  \"avx512cd\", \"avx512dq\", \"avx512er\",\n@@ -104,12 +106,18 @@ const POWERPC_WHITELIST: &'static [&'static str] = &[\"altivec\",\n \n const MIPS_WHITELIST: &'static [&'static str] = &[\"msa\"];\n \n-pub fn to_llvm_feature(s: &str) -> &str {\n-    match s {\n-        \"pclmulqdq\" => \"pclmul\",\n-        \"rdrand\" => \"rdrnd\",\n-        \"bmi1\" => \"bmi\",\n-        s => s,\n+pub fn to_llvm_feature<'a>(sess: &Session, s: &'a str) -> &'a str {\n+    let arch = if sess.target.target.arch == \"x86_64\" {\n+        \"x86\"\n+    } else {\n+        &*sess.target.target.arch\n+    };\n+    match (arch, s) {\n+        (\"x86\", \"pclmulqdq\") => \"pclmul\",\n+        (\"x86\", \"rdrand\") => \"rdrnd\",\n+        (\"x86\", \"bmi1\") => \"bmi\",\n+        (\"aarch64\", \"fp16\") => \"fullfp16\",\n+        (_, s) => s,\n     }\n }\n \n@@ -118,7 +126,7 @@ pub fn target_features(sess: &Session) -> Vec<Symbol> {\n     target_feature_whitelist(sess)\n         .iter()\n         .filter(|feature| {\n-            let llvm_feature = to_llvm_feature(feature);\n+            let llvm_feature = to_llvm_feature(sess, feature);\n             let cstr = CString::new(llvm_feature).unwrap();\n             unsafe { llvm::LLVMRustHasFeature(target_machine, cstr.as_ptr()) }\n         })"}, {"sha": "99e3a59e2c4f42c8dfa08491446aad33e0aa0269", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 54, "deletions": 6, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use common::{C_i32, C_null};\n use libc::c_uint;\n use llvm::{self, ValueRef, BasicBlockRef};\n use llvm::debuginfo::DIScope;\n@@ -23,6 +24,7 @@ use common::{CodegenCx, Funclet};\n use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebugContext};\n use monomorphize::Instance;\n use abi::{ArgAttribute, FnType, PassMode};\n+use type_::Type;\n \n use syntax_pos::{DUMMY_SP, NO_EXPANSION, BytePos, Span};\n use syntax::symbol::keywords;\n@@ -222,7 +224,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n \n     // Compute debuginfo scopes from MIR scopes.\n     let scopes = debuginfo::create_mir_scopes(cx, mir, &debug_context);\n-    let (landing_pads, funclets) = create_funclets(&bx, &cleanup_kinds, &block_bxs);\n+    let (landing_pads, funclets) = create_funclets(mir, &bx, &cleanup_kinds, &block_bxs);\n \n     let mut fx = FunctionCx {\n         mir,\n@@ -333,6 +335,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n }\n \n fn create_funclets<'a, 'tcx>(\n+    mir: &'a Mir<'tcx>,\n     bx: &Builder<'a, 'tcx>,\n     cleanup_kinds: &IndexVec<mir::BasicBlock, CleanupKind>,\n     block_bxs: &IndexVec<mir::BasicBlock, BasicBlockRef>)\n@@ -341,14 +344,59 @@ fn create_funclets<'a, 'tcx>(\n {\n     block_bxs.iter_enumerated().zip(cleanup_kinds).map(|((bb, &llbb), cleanup_kind)| {\n         match *cleanup_kind {\n-            CleanupKind::Funclet if base::wants_msvc_seh(bx.sess()) => {\n+            CleanupKind::Funclet if base::wants_msvc_seh(bx.sess()) => {}\n+            _ => return (None, None)\n+        }\n+\n+        let cleanup;\n+        let ret_llbb;\n+        match mir[bb].terminator.as_ref().map(|t| &t.kind) {\n+            // This is a basic block that we're aborting the program for,\n+            // notably in an `extern` function. These basic blocks are inserted\n+            // so that we assert that `extern` functions do indeed not panic,\n+            // and if they do we abort the process.\n+            //\n+            // On MSVC these are tricky though (where we're doing funclets). If\n+            // we were to do a cleanuppad (like below) the normal functions like\n+            // `longjmp` would trigger the abort logic, terminating the\n+            // program. Instead we insert the equivalent of `catch(...)` for C++\n+            // which magically doesn't trigger when `longjmp` files over this\n+            // frame.\n+            //\n+            // Lots more discussion can be found on #48251 but this codegen is\n+            // modeled after clang's for:\n+            //\n+            //      try {\n+            //          foo();\n+            //      } catch (...) {\n+            //          bar();\n+            //      }\n+            Some(&mir::TerminatorKind::Abort) => {\n+                let cs_bx = bx.build_sibling_block(&format!(\"cs_funclet{:?}\", bb));\n+                let cp_bx = bx.build_sibling_block(&format!(\"cp_funclet{:?}\", bb));\n+                ret_llbb = cs_bx.llbb();\n+\n+                let cs = cs_bx.catch_switch(None, None, 1);\n+                cs_bx.add_handler(cs, cp_bx.llbb());\n+\n+                // The \"null\" here is actually a RTTI type descriptor for the\n+                // C++ personality function, but `catch (...)` has no type so\n+                // it's null. The 64 here is actually a bitfield which\n+                // represents that this is a catch-all block.\n+                let null = C_null(Type::i8p(bx.cx));\n+                let sixty_four = C_i32(bx.cx, 64);\n+                cleanup = cp_bx.catch_pad(cs, &[null, sixty_four, null]);\n+                cp_bx.br(llbb);\n+            }\n+            _ => {\n                 let cleanup_bx = bx.build_sibling_block(&format!(\"funclet_{:?}\", bb));\n-                let cleanup = cleanup_bx.cleanup_pad(None, &[]);\n+                ret_llbb = cleanup_bx.llbb();\n+                cleanup = cleanup_bx.cleanup_pad(None, &[]);\n                 cleanup_bx.br(llbb);\n-                (Some(cleanup_bx.llbb()), Some(Funclet::new(cleanup)))\n             }\n-            _ => (None, None)\n-        }\n+        };\n+\n+        (Some(ret_llbb), Some(Funclet::new(cleanup)))\n     }).unzip()\n }\n "}, {"sha": "6a6c49c904838bf85acddaab99305fa12107722e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -312,7 +312,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     /// Instantiates the path for the given trait reference, assuming that it's\n     /// bound to a valid trait type. Returns the def_id for the defining trait.\n-    /// Fails if the type is a type other than a trait type.\n+    /// The type _cannot_ be a type other than a trait type.\n     ///\n     /// If the `projections` argument is `None`, then assoc type bindings like `Foo<T=X>`\n     /// are disallowed. Otherwise, they are pushed onto the vector given.\n@@ -330,6 +330,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                         trait_ref.path.segments.last().unwrap())\n     }\n \n+    /// Get the DefId of the given trait ref. It _must_ actually be a trait.\n     fn trait_def_id(&self, trait_ref: &hir::TraitRef) -> DefId {\n         let path = &trait_ref.path;\n         match path.def {\n@@ -338,13 +339,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             Def::Err => {\n                 self.tcx().sess.fatal(\"cannot continue compilation due to previous error\");\n             }\n-            _ => {\n-                span_fatal!(self.tcx().sess, path.span, E0245, \"`{}` is not a trait\",\n-                            self.tcx().hir.node_to_pretty_string(trait_ref.ref_id));\n-            }\n+            _ => unreachable!(),\n         }\n     }\n \n+    /// The given `trait_ref` must actually be trait.\n     pub(super) fn instantiate_poly_trait_ref_inner(&self,\n         trait_ref: &hir::TraitRef,\n         self_ty: Ty<'tcx>,"}, {"sha": "6c195a991c24e9f2b2b8a29a74e55f77d919f24e", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -4802,7 +4802,7 @@ register_diagnostics! {\n //  E0240,\n //  E0241,\n //  E0242,\n-    E0245, // not a trait\n+//  E0245, // not a trait\n //  E0246, // invalid recursive type\n //  E0247,\n //  E0248, // value used as a type, now reported earlier during resolution as E0412"}, {"sha": "1f73054e3beed01f7e93b253a442992b57b66407", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -17,7 +17,7 @@ use io::{self, Initializer, BufReader, LineWriter};\n use sync::{Arc, Mutex, MutexGuard};\n use sys::stdio;\n use sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n-use thread::{LocalKey, LocalKeyState};\n+use thread::LocalKey;\n \n /// Stdout used by print! and println! macros\n thread_local! {\n@@ -663,29 +663,31 @@ pub fn set_print(sink: Option<Box<Write + Send>>) -> Option<Box<Write + Send>> {\n ///\n /// This function is used to print error messages, so it takes extra\n /// care to avoid causing a panic when `local_stream` is unusable.\n-/// For instance, if the TLS key for the local stream is uninitialized\n-/// or already destroyed, or if the local stream is locked by another\n+/// For instance, if the TLS key for the local stream is\n+/// already destroyed, or if the local stream is locked by another\n /// thread, it will just fall back to the global stream.\n ///\n /// However, if the actual I/O causes an error, this function does panic.\n-fn print_to<T>(args: fmt::Arguments,\n-               local_s: &'static LocalKey<RefCell<Option<Box<Write+Send>>>>,\n-               global_s: fn() -> T,\n-               label: &str) where T: Write {\n-    let result = match local_s.state() {\n-        LocalKeyState::Uninitialized |\n-        LocalKeyState::Destroyed => global_s().write_fmt(args),\n-        LocalKeyState::Valid => {\n-            local_s.with(|s| {\n-                if let Ok(mut borrowed) = s.try_borrow_mut() {\n-                    if let Some(w) = borrowed.as_mut() {\n-                        return w.write_fmt(args);\n-                    }\n-                }\n-                global_s().write_fmt(args)\n-            })\n+fn print_to<T>(\n+    args: fmt::Arguments,\n+    local_s: &'static LocalKey<RefCell<Option<Box<Write+Send>>>>,\n+    global_s: fn() -> T,\n+    label: &str,\n+)\n+where\n+    T: Write,\n+{\n+    let result = local_s.try_with(|s| {\n+        if let Ok(mut borrowed) = s.try_borrow_mut() {\n+            if let Some(w) = borrowed.as_mut() {\n+                return w.write_fmt(args);\n+            }\n         }\n-    };\n+        global_s().write_fmt(args)\n+    }).unwrap_or_else(|_| {\n+        global_s().write_fmt(args)\n+    });\n+\n     if let Err(e) = result {\n         panic!(\"failed printing to {}: {}\", label, e);\n     }"}, {"sha": "99479bc56eff30ed9388c04d14168ed90174f331", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 15, "deletions": 113, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -195,64 +195,20 @@ macro_rules! __thread_local_inner {\n     }\n }\n \n-/// Indicator of the state of a thread local storage key.\n-#[unstable(feature = \"thread_local_state\",\n-           reason = \"state querying was recently added\",\n-           issue = \"27716\")]\n-#[derive(Debug, Eq, PartialEq, Copy, Clone)]\n-pub enum LocalKeyState {\n-    /// All keys are in this state whenever a thread starts. Keys will\n-    /// transition to the `Valid` state once the first call to [`with`] happens\n-    /// and the initialization expression succeeds.\n-    ///\n-    /// Keys in the `Uninitialized` state will yield a reference to the closure\n-    /// passed to [`with`] so long as the initialization routine does not panic.\n-    ///\n-    /// [`with`]: ../../std/thread/struct.LocalKey.html#method.with\n-    Uninitialized,\n-\n-    /// Once a key has been accessed successfully, it will enter the `Valid`\n-    /// state. Keys in the `Valid` state will remain so until the thread exits,\n-    /// at which point the destructor will be run and the key will enter the\n-    /// `Destroyed` state.\n-    ///\n-    /// Keys in the `Valid` state will be guaranteed to yield a reference to the\n-    /// closure passed to [`with`].\n-    ///\n-    /// [`with`]: ../../std/thread/struct.LocalKey.html#method.with\n-    Valid,\n-\n-    /// When a thread exits, the destructors for keys will be run (if\n-    /// necessary). While a destructor is running, and possibly after a\n-    /// destructor has run, a key is in the `Destroyed` state.\n-    ///\n-    /// Keys in the `Destroyed` states will trigger a panic when accessed via\n-    /// [`with`].\n-    ///\n-    /// [`with`]: ../../std/thread/struct.LocalKey.html#method.with\n-    Destroyed,\n-}\n-\n /// An error returned by [`LocalKey::try_with`](struct.LocalKey.html#method.try_with).\n-#[unstable(feature = \"thread_local_state\",\n-           reason = \"state querying was recently added\",\n-           issue = \"27716\")]\n+#[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\n pub struct AccessError {\n     _private: (),\n }\n \n-#[unstable(feature = \"thread_local_state\",\n-           reason = \"state querying was recently added\",\n-           issue = \"27716\")]\n+#[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\n impl fmt::Debug for AccessError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"AccessError\").finish()\n     }\n }\n \n-#[unstable(feature = \"thread_local_state\",\n-           reason = \"state querying was recently added\",\n-           issue = \"27716\")]\n+#[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\n impl fmt::Display for AccessError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(\"already destroyed\", f)\n@@ -312,64 +268,21 @@ impl<T: 'static> LocalKey<T> {\n         (*ptr).as_ref().unwrap()\n     }\n \n-    /// Query the current state of this key.\n-    ///\n-    /// A key is initially in the `Uninitialized` state whenever a thread\n-    /// starts. It will remain in this state up until the first call to [`with`]\n-    /// within a thread has run the initialization expression successfully.\n-    ///\n-    /// Once the initialization expression succeeds, the key transitions to the\n-    /// `Valid` state which will guarantee that future calls to [`with`] will\n-    /// succeed within the thread. Some keys might skip the `Uninitialized`\n-    /// state altogether and start in the `Valid` state as an optimization\n-    /// (e.g. keys initialized with a constant expression), but no guarantees\n-    /// are made.\n-    ///\n-    /// When a thread exits, each key will be destroyed in turn, and as keys are\n-    /// destroyed they will enter the `Destroyed` state just before the\n-    /// destructor starts to run. Keys may remain in the `Destroyed` state after\n-    /// destruction has completed. Keys without destructors (e.g. with types\n-    /// that are [`Copy`]), may never enter the `Destroyed` state.\n-    ///\n-    /// Keys in the `Uninitialized` state can be accessed so long as the\n-    /// initialization does not panic. Keys in the `Valid` state are guaranteed\n-    /// to be able to be accessed. Keys in the `Destroyed` state will panic on\n-    /// any call to [`with`].\n-    ///\n-    /// [`with`]: ../../std/thread/struct.LocalKey.html#method.with\n-    /// [`Copy`]: ../../std/marker/trait.Copy.html\n-    #[unstable(feature = \"thread_local_state\",\n-               reason = \"state querying was recently added\",\n-               issue = \"27716\")]\n-    pub fn state(&'static self) -> LocalKeyState {\n-        unsafe {\n-            match (self.inner)() {\n-                Some(cell) => {\n-                    match *cell.get() {\n-                        Some(..) => LocalKeyState::Valid,\n-                        None => LocalKeyState::Uninitialized,\n-                    }\n-                }\n-                None => LocalKeyState::Destroyed,\n-            }\n-        }\n-    }\n-\n     /// Acquires a reference to the value in this TLS key.\n     ///\n     /// This will lazily initialize the value if this thread has not referenced\n     /// this key yet. If the key has been destroyed (which may happen if this is called\n-    /// in a destructor), this function will return a ThreadLocalError.\n+    /// in a destructor), this function will return a `ThreadLocalError`.\n     ///\n     /// # Panics\n     ///\n     /// This function will still `panic!()` if the key is uninitialized and the\n     /// key's initializer panics.\n-    #[unstable(feature = \"thread_local_state\",\n-               reason = \"state querying was recently added\",\n-               issue = \"27716\")]\n+    #[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\n     pub fn try_with<F, R>(&'static self, f: F) -> Result<R, AccessError>\n-                      where F: FnOnce(&T) -> R {\n+    where\n+        F: FnOnce(&T) -> R,\n+    {\n         unsafe {\n             let slot = (self.inner)().ok_or(AccessError {\n                 _private: (),\n@@ -530,7 +443,6 @@ pub mod os {\n mod tests {\n     use sync::mpsc::{channel, Sender};\n     use cell::{Cell, UnsafeCell};\n-    use super::LocalKeyState;\n     use thread;\n \n     struct Foo(Sender<()>);\n@@ -569,21 +481,13 @@ mod tests {\n         struct Foo;\n         impl Drop for Foo {\n             fn drop(&mut self) {\n-                assert!(FOO.state() == LocalKeyState::Destroyed);\n+                assert!(FOO.try_with(|_| ()).is_err());\n             }\n         }\n-        fn foo() -> Foo {\n-            assert!(FOO.state() == LocalKeyState::Uninitialized);\n-            Foo\n-        }\n-        thread_local!(static FOO: Foo = foo());\n+        thread_local!(static FOO: Foo = Foo);\n \n         thread::spawn(|| {\n-            assert!(FOO.state() == LocalKeyState::Uninitialized);\n-            FOO.with(|_| {\n-                assert!(FOO.state() == LocalKeyState::Valid);\n-            });\n-            assert!(FOO.state() == LocalKeyState::Valid);\n+            assert!(FOO.try_with(|_| ()).is_ok());\n         }).join().ok().unwrap();\n     }\n \n@@ -613,7 +517,7 @@ mod tests {\n             fn drop(&mut self) {\n                 unsafe {\n                     HITS += 1;\n-                    if K2.state() == LocalKeyState::Destroyed {\n+                    if K2.try_with(|_| ()).is_err() {\n                         assert_eq!(HITS, 3);\n                     } else {\n                         if HITS == 1 {\n@@ -629,7 +533,7 @@ mod tests {\n             fn drop(&mut self) {\n                 unsafe {\n                     HITS += 1;\n-                    assert!(K1.state() != LocalKeyState::Destroyed);\n+                    assert!(K1.try_with(|_| ()).is_ok());\n                     assert_eq!(HITS, 2);\n                     K1.with(|s| *s.get() = Some(S1));\n                 }\n@@ -648,7 +552,7 @@ mod tests {\n \n         impl Drop for S1 {\n             fn drop(&mut self) {\n-                assert!(K1.state() == LocalKeyState::Destroyed);\n+                assert!(K1.try_with(|_| ()).is_err());\n             }\n         }\n \n@@ -672,9 +576,7 @@ mod tests {\n             fn drop(&mut self) {\n                 let S1(ref tx) = *self;\n                 unsafe {\n-                    if K2.state() != LocalKeyState::Destroyed {\n-                        K2.with(|s| *s.get() = Some(Foo(tx.clone())));\n-                    }\n+                    let _ = K2.try_with(|s| *s.get() = Some(Foo(tx.clone())));\n                 }\n             }\n         }"}, {"sha": "71aee673cfe3ee57e7893a54c1e1823493713693", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -191,7 +191,7 @@ use time::Duration;\n #[macro_use] mod local;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::local::{LocalKey, LocalKeyState, AccessError};\n+pub use self::local::{LocalKey, AccessError};\n \n // The types used by the thread_local! macro to access TLS keys. Note that there\n // are two types, the \"OS\" type and the \"fast\" type. The OS thread local key"}, {"sha": "40000bc378ed0aba6c22f44ee291bae5385b5d9e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -562,7 +562,7 @@ impl Pat {\n             PatKind::TupleStruct(_, ref s, _) | PatKind::Tuple(ref s, _) => {\n                 s.iter().all(|p| p.walk(it))\n             }\n-            PatKind::Box(ref s) | PatKind::Ref(ref s, _) => {\n+            PatKind::Box(ref s) | PatKind::Ref(ref s, _) | PatKind::Paren(ref s) => {\n                 s.walk(it)\n             }\n             PatKind::Slice(ref before, ref slice, ref after) => {\n@@ -656,6 +656,8 @@ pub enum PatKind {\n     /// `[a, b, ..i, y, z]` is represented as:\n     ///     `PatKind::Slice(box [a, b], Some(i), box [y, z])`\n     Slice(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n+    /// Parentheses in patters used for grouping, i.e. `(PAT)`.\n+    Paren(P<Pat>),\n     /// A macro pattern; pre-expansion\n     Mac(Mac),\n }"}, {"sha": "fcd2b236213c023d81b1f955171076ed3796b875", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -705,17 +705,20 @@ impl CodeMap {\n         };\n         debug!(\"find_width_of_character_at_span: snippet=`{:?}`\", snippet);\n \n-        let file_start_pos = local_begin.fm.start_pos.to_usize();\n-        let file_end_pos = local_begin.fm.end_pos.to_usize();\n-        debug!(\"find_width_of_character_at_span: file_start_pos=`{:?}` file_end_pos=`{:?}`\",\n-               file_start_pos, file_end_pos);\n-\n         let mut target = if forwards { end_index + 1 } else { end_index - 1 };\n         debug!(\"find_width_of_character_at_span: initial target=`{:?}`\", target);\n \n-        while !snippet.is_char_boundary(target - start_index)\n-                && target >= file_start_pos && target <= file_end_pos {\n-            target = if forwards { target + 1 } else { target - 1 };\n+        while !snippet.is_char_boundary(target - start_index) && target < source_len {\n+            target = if forwards {\n+                target + 1\n+            } else {\n+                match target.checked_sub(1) {\n+                    Some(target) => target,\n+                    None => {\n+                        break;\n+                    }\n+                }\n+            };\n             debug!(\"find_width_of_character_at_span: target=`{:?}`\", target);\n         }\n         debug!(\"find_width_of_character_at_span: final target=`{:?}`\", target);"}, {"sha": "70ea015de4e309a6b67d8af90a96979b9ef33972", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -449,6 +449,9 @@ declare_features! (\n \n     // Multiple patterns with `|` in `if let` and `while let`\n     (active, if_while_or_patterns, \"1.26.0\", Some(48215)),\n+\n+    // Parentheses in patterns\n+    (active, pattern_parentheses, \"1.26.0\", None),\n );\n \n declare_features! (\n@@ -1663,6 +1666,10 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 gate_feature_post!(&self, dotdoteq_in_patterns, pattern.span,\n                                    \"`..=` syntax in patterns is experimental\");\n             }\n+            PatKind::Paren(..) => {\n+                gate_feature_post!(&self, pattern_parentheses, pattern.span,\n+                                   \"parentheses in patterns are unstable\");\n+            }\n             _ => {}\n         }\n         visit::walk_pat(self, pattern)"}, {"sha": "1963ab45f1a3281e7fabf567710b07d9cbf5d4a9", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -1148,6 +1148,7 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n                        slice.map(|x| folder.fold_pat(x)),\n                        after.move_map(|x| folder.fold_pat(x)))\n             }\n+            PatKind::Paren(inner) => PatKind::Paren(folder.fold_pat(inner)),\n             PatKind::Mac(mac) => PatKind::Mac(folder.fold_mac(mac))\n         },\n         span: folder.new_span(span)"}, {"sha": "881e3e412d4eb4052db4debcabd1a5a8fcf1e9b3", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 40, "deletions": 26, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -3484,33 +3484,47 @@ impl<'a> Parser<'a> {\n         };\n     }\n \n-    fn parse_pat_tuple_elements(&mut self, unary_needs_comma: bool)\n-                                -> PResult<'a, (Vec<P<Pat>>, Option<usize>)> {\n-        let mut fields = vec![];\n-        let mut ddpos = None;\n+    // Parses a parenthesized list of patterns like\n+    // `()`, `(p)`, `(p,)`, `(p, q)`, or `(p, .., q)`. Returns:\n+    // - a vector of the patterns that were parsed\n+    // - an option indicating the index of the `..` element\n+    // - a boolean indicating whether a trailing comma was present.\n+    // Trailing commas are significant because (p) and (p,) are different patterns.\n+    fn parse_parenthesized_pat_list(&mut self) -> PResult<'a, (Vec<P<Pat>>, Option<usize>, bool)> {\n+        self.expect(&token::OpenDelim(token::Paren))?;\n \n-        while !self.check(&token::CloseDelim(token::Paren)) {\n-            if ddpos.is_none() && self.eat(&token::DotDot) {\n-                ddpos = Some(fields.len());\n-                if self.eat(&token::Comma) {\n-                    // `..` needs to be followed by `)` or `, pat`, `..,)` is disallowed.\n-                    fields.push(self.parse_pat()?);\n+        let mut fields = Vec::new();\n+        let mut ddpos = None;\n+        let mut trailing_comma = false;\n+        loop {\n+            if self.eat(&token::DotDot) {\n+                if ddpos.is_none() {\n+                    ddpos = Some(fields.len());\n+                } else {\n+                    // Emit a friendly error, ignore `..` and continue parsing\n+                    self.span_err(self.prev_span,\n+                                  \"`..` can only be used once per tuple or tuple struct pattern\");\n                 }\n-            } else if ddpos.is_some() && self.eat(&token::DotDot) {\n-                // Emit a friendly error, ignore `..` and continue parsing\n-                self.span_err(self.prev_span, \"`..` can only be used once per \\\n-                                               tuple or tuple struct pattern\");\n-            } else {\n+            } else if !self.check(&token::CloseDelim(token::Paren)) {\n                 fields.push(self.parse_pat()?);\n+            } else {\n+                break\n             }\n \n-            if !self.check(&token::CloseDelim(token::Paren)) ||\n-                    (unary_needs_comma && fields.len() == 1 && ddpos.is_none()) {\n-                self.expect(&token::Comma)?;\n+            trailing_comma = self.eat(&token::Comma);\n+            if !trailing_comma {\n+                break\n             }\n         }\n \n-        Ok((fields, ddpos))\n+        if ddpos == Some(fields.len()) && trailing_comma {\n+            // `..` needs to be followed by `)` or `, pat`, `..,)` is disallowed.\n+            self.span_err(self.prev_span, \"trailing comma is not permitted after `..`\");\n+        }\n+\n+        self.expect(&token::CloseDelim(token::Paren))?;\n+\n+        Ok((fields, ddpos, trailing_comma))\n     }\n \n     fn parse_pat_vec_elements(\n@@ -3714,10 +3728,12 @@ impl<'a> Parser<'a> {\n             }\n             token::OpenDelim(token::Paren) => {\n                 // Parse (pat,pat,pat,...) as tuple pattern\n-                self.bump();\n-                let (fields, ddpos) = self.parse_pat_tuple_elements(true)?;\n-                self.expect(&token::CloseDelim(token::Paren))?;\n-                pat = PatKind::Tuple(fields, ddpos);\n+                let (fields, ddpos, trailing_comma) = self.parse_parenthesized_pat_list()?;\n+                pat = if fields.len() == 1 && ddpos.is_none() && !trailing_comma {\n+                    PatKind::Paren(fields.into_iter().nth(0).unwrap())\n+                } else {\n+                    PatKind::Tuple(fields, ddpos)\n+                };\n             }\n             token::OpenDelim(token::Bracket) => {\n                 // Parse [pat,pat,...] as slice pattern\n@@ -3807,9 +3823,7 @@ impl<'a> Parser<'a> {\n                             return Err(self.fatal(\"unexpected `(` after qualified path\"));\n                         }\n                         // Parse tuple struct or enum pattern\n-                        self.bump();\n-                        let (fields, ddpos) = self.parse_pat_tuple_elements(false)?;\n-                        self.expect(&token::CloseDelim(token::Paren))?;\n+                        let (fields, ddpos, _) = self.parse_parenthesized_pat_list()?;\n                         pat = PatKind::TupleStruct(path, fields, ddpos)\n                     }\n                     _ => pat = PatKind::Path(qself, path),"}, {"sha": "77afafbb4e003525fd80f89f0d7e84d978023725", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -2659,6 +2659,11 @@ impl<'a> State<'a> {\n                                    |s, p| s.print_pat(p))?;\n                 self.s.word(\"]\")?;\n             }\n+            PatKind::Paren(ref inner) => {\n+                self.popen()?;\n+                self.print_pat(inner)?;\n+                self.pclose()?;\n+            }\n             PatKind::Mac(ref m) => self.print_mac(m, token::Paren)?,\n         }\n         self.ann.post(self, NodePat(pat))"}, {"sha": "5a24c61cb5aaf8588f28ab255251aadbf2e3ab40", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -425,7 +425,8 @@ pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n             walk_list!(visitor, visit_pat, tuple_elements);\n         }\n         PatKind::Box(ref subpattern) |\n-        PatKind::Ref(ref subpattern, _) => {\n+        PatKind::Ref(ref subpattern, _) |\n+        PatKind::Paren(ref subpattern) => {\n             visitor.visit_pat(subpattern)\n         }\n         PatKind::Ident(_, ref pth1, ref optional_subpattern) => {"}, {"sha": "07b391d327984731a650138ebccd55c624fcdc78", "filename": "src/test/parse-fail/pat-tuple-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Fparse-fail%2Fpat-tuple-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Fparse-fail%2Fpat-tuple-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-tuple-2.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -12,6 +12,6 @@\n \n fn main() {\n     match 0 {\n-        (pat, ..,) => {} //~ ERROR expected pattern, found `)`\n+        (pat, ..,) => {} //~ ERROR trailing comma is not permitted after `..`\n     }\n }"}, {"sha": "9d71ed8fcf3ab6223d4c9b2cbbb82298f6ca39df", "filename": "src/test/run-make/longjmp-across-rust/Makefile", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Frun-make%2Flongjmp-across-rust%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Frun-make%2Flongjmp-across-rust%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flongjmp-across-rust%2FMakefile?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -0,0 +1,5 @@\n+-include ../tools.mk\n+\n+all: $(call NATIVE_STATICLIB,foo)\n+\t$(RUSTC) main.rs\n+\t$(call RUN,main)"}, {"sha": "eb9939576741bad7c11d008b190fd2bf246b973b", "filename": "src/test/run-make/longjmp-across-rust/foo.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Frun-make%2Flongjmp-across-rust%2Ffoo.c", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Frun-make%2Flongjmp-across-rust%2Ffoo.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flongjmp-across-rust%2Ffoo.c?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#include <assert.h>\n+#include <setjmp.h>\n+\n+static jmp_buf ENV;\n+\n+extern void test_middle();\n+\n+void test_start(void(*f)()) {\n+  if (setjmp(ENV) != 0)\n+    return;\n+  f();\n+  assert(0);\n+}\n+\n+void test_end() {\n+  longjmp(ENV, 1);\n+  assert(0);\n+}"}, {"sha": "c420473a560eb2a340414a750b7d4c75155034fe", "filename": "src/test/run-make/longjmp-across-rust/main.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Frun-make%2Flongjmp-across-rust%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Frun-make%2Flongjmp-across-rust%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flongjmp-across-rust%2Fmain.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[link(name = \"foo\", kind = \"static\")]\n+extern {\n+    fn test_start(f: extern fn());\n+    fn test_end();\n+}\n+\n+fn main() {\n+    unsafe {\n+        test_start(test_middle);\n+    }\n+}\n+\n+struct A;\n+\n+impl Drop for A {\n+    fn drop(&mut self) {\n+    }\n+}\n+\n+extern fn test_middle() {\n+    let _a = A;\n+    foo();\n+}\n+\n+fn foo() {\n+    let _a = A;\n+    unsafe {\n+        test_end();\n+    }\n+}"}, {"sha": "a00361a2c9d33d1e8c078d59f0202bc9d722b1f1", "filename": "src/test/run-pass/issue-48508-aux.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Frun-pass%2Fissue-48508-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Frun-pass%2Fissue-48508-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-48508-aux.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-test Not a test. Used by issue-48508.rs\n+\n+pub fn other() -> f64 {\n+    let \u00b5 = 1.0;\n+    \u00b5\n+}"}, {"sha": "1b10d873f11c413654aa844be4ee32c3989b91dc", "filename": "src/test/run-pass/issue-48508.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Frun-pass%2Fissue-48508.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Frun-pass%2Fissue-48508.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-48508.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for issue #48508:\n+//\n+// Confusion between global and local file offsets caused incorrect handling of multibyte character\n+// spans when compiling multiple files. One visible effect was an ICE generating debug information\n+// when a multibyte character is at the end of a scope. The problematic code is actually in\n+// issue-48508-aux.rs\n+\n+// compile-flags:-g\n+// ignore-pretty issue #37195\n+\n+#![feature(non_ascii_idents)]\n+\n+#[path = \"issue-48508-aux.rs\"]\n+mod other_file;\n+\n+fn main() {\n+    other_file::other();\n+}"}, {"sha": "93bddbc533549ef94b6d1eaad01bcee7f6bf8e36", "filename": "src/test/run-pass/issue-48551.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Frun-pass%2Fissue-48551.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Frun-pass%2Fissue-48551.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-48551.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #48551. Covers a case where duplicate candidates\n+// arose during associated type projection.\n+\n+use std::ops::{Mul, MulAssign};\n+\n+pub trait ClosedMul<Right>: Sized + Mul<Right, Output = Self> + MulAssign<Right> {}\n+impl<T, Right> ClosedMul<Right> for T\n+where\n+    T: Mul<Right, Output = T> + MulAssign<Right>,\n+{\n+}\n+\n+pub trait InnerSpace: ClosedMul<<Self as InnerSpace>::Real> {\n+    type Real;\n+}\n+\n+pub trait FiniteDimVectorSpace: ClosedMul<<Self as FiniteDimVectorSpace>::Field> {\n+    type Field;\n+}\n+\n+pub trait FiniteDimInnerSpace\n+    : InnerSpace + FiniteDimVectorSpace<Field = <Self as InnerSpace>::Real> {\n+}\n+\n+pub trait EuclideanSpace: ClosedMul<<Self as EuclideanSpace>::Real> {\n+    type Coordinates: FiniteDimInnerSpace<Real = Self::Real>\n+        + Mul<Self::Real, Output = Self::Coordinates>\n+        + MulAssign<Self::Real>;\n+\n+    type Real;\n+}\n+\n+fn main() {}"}, {"sha": "6d51df63e158a0c7741b9bc5f9e691297c0f53dc", "filename": "src/test/run-pass/pat-tuple-7.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Frun-pass%2Fpat-tuple-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Frun-pass%2Fpat-tuple-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpat-tuple-7.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+#![feature(pattern_parentheses)]\n \n fn main() {\n     match 0 {\n-        (pat) => {} //~ ERROR expected one of `,` or `@`, found `)`\n+        (pat) => assert_eq!(pat, 0)\n     }\n }", "previous_filename": "src/test/parse-fail/pat-tuple-6.rs"}, {"sha": "48a0d4a99ecc9e97a5e15d8bd6f55e6b2751ddb3", "filename": "src/test/run-pass/tls-init-on-init.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Frun-pass%2Ftls-init-on-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Frun-pass%2Ftls-init-on-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftls-init-on-init.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -10,9 +10,9 @@\n \n // ignore-emscripten no threads support\n \n-#![feature(thread_local_state)]\n+#![feature(thread_local_try_with)]\n \n-use std::thread::{self, LocalKeyState};\n+use std::thread;\n use std::sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n \n struct Foo { cnt: usize }\n@@ -37,10 +37,8 @@ impl Drop for Foo {\n             FOO.with(|foo| assert_eq!(foo.cnt, 0));\n         } else {\n             assert_eq!(self.cnt, 0);\n-            match FOO.state() {\n-                LocalKeyState::Valid => panic!(\"should not be in valid state\"),\n-                LocalKeyState::Uninitialized |\n-                LocalKeyState::Destroyed => {}\n+            if FOO.try_with(|_| ()).is_ok() {\n+                panic!(\"should not be in valid state\");\n             }\n         }\n     }"}, {"sha": "552f4c5e829e157655c6b4f8b7ba1c6d18239409", "filename": "src/test/run-pass/tls-try-with.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Frun-pass%2Ftls-try-with.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Frun-pass%2Ftls-try-with.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftls-try-with.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-emscripten no threads support\n \n-#![feature(thread_local_state)]\n+#![feature(thread_local_try_with)]\n \n use std::thread;\n "}, {"sha": "1c6ff5ae8413dec99737f86fc81b0a67810eaee9", "filename": "src/test/ui/error-codes/E0404.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Fui%2Ferror-codes%2FE0404.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Fui%2Ferror-codes%2FE0404.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0404.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -13,5 +13,6 @@ struct Bar;\n \n impl Foo for Bar {} //~ ERROR E0404\n \n-fn main() {\n-}\n+fn main() {}\n+\n+fn baz<T: Foo>(_: T) {} //~ ERROR E0404"}, {"sha": "ac1d2a00cf44842a8f6e36eeb9d0ae6e025ee60d", "filename": "src/test/ui/error-codes/E0404.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Fui%2Ferror-codes%2FE0404.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Fui%2Ferror-codes%2FE0404.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0404.stderr?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -4,6 +4,12 @@ error[E0404]: expected trait, found struct `Foo`\n LL | impl Foo for Bar {} //~ ERROR E0404\n    |      ^^^ not a trait\n \n+error[E0404]: expected trait, found struct `Foo`\n+  --> $DIR/E0404.rs:18:11\n+   |\n+LL | fn baz<T: Foo>(_: T) {} //~ ERROR E0404\n+   |           ^^^ not a trait\n+\n error: cannot continue compilation due to previous error\n \n If you want more information on this error, try using \"rustc --explain E0404\""}, {"sha": "29768018f0e447bb8de78c7faa4ac306f5d50e29", "filename": "src/test/ui/feature-gate-pattern_parentheses.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Fui%2Ffeature-gate-pattern_parentheses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Fui%2Ffeature-gate-pattern_parentheses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-pattern_parentheses.rs?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    match 0 {\n+        (pat) => {} //~ ERROR parentheses in patterns are unstable\n+    }\n+}"}, {"sha": "4fc1441a0fadde5195c3d25ed1e55f4914ca42b2", "filename": "src/test/ui/feature-gate-pattern_parentheses.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Fui%2Ffeature-gate-pattern_parentheses.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftest%2Fui%2Ffeature-gate-pattern_parentheses.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-pattern_parentheses.stderr?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -0,0 +1,11 @@\n+error[E0658]: parentheses in patterns are unstable\n+  --> $DIR/feature-gate-pattern_parentheses.rs:13:9\n+   |\n+LL |         (pat) => {} //~ ERROR parentheses in patterns are unstable\n+   |         ^^^^^\n+   |\n+   = help: add #![feature(pattern_parentheses)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+If you want more information on this error, try using \"rustc --explain E0658\""}, {"sha": "8e23519f57ebca5130913b5ceda69605ff964cfa", "filename": "src/tools/publish_toolstate.py", "status": "modified", "additions": 56, "deletions": 13, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftools%2Fpublish_toolstate.py", "raw_url": "https://github.com/rust-lang/rust/raw/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba/src%2Ftools%2Fpublish_toolstate.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fpublish_toolstate.py?ref=9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "patch": "@@ -17,13 +17,22 @@\n import copy\n import datetime\n import collections\n+import textwrap\n+try:\n+    import urllib2\n+except ImportError:\n+    import urllib.request as urllib2\n \n # List of people to ping when the status of a tool changed.\n MAINTAINERS = {\n     'miri': '@oli-obk @RalfJung @eddyb',\n     'clippy-driver': '@Manishearth @llogiq @mcarton @oli-obk',\n     'rls': '@nrc',\n     'rustfmt': '@nrc',\n+    'book': '@carols10cents @steveklabnik',\n+    'nomicon': '@frewsxcv @Gankro',\n+    'reference': '@steveklabnik @Havvy @matthewjasper @alercah',\n+    'rust-by-example': '@steveklabnik @marioidival @projektir',\n }\n \n \n@@ -38,7 +47,12 @@ def read_current_status(current_commit, path):\n     return {}\n \n \n-def update_latest(current_commit, relevant_pr_number, current_datetime):\n+def update_latest(\n+    current_commit,\n+    relevant_pr_number,\n+    relevant_pr_url,\n+    current_datetime\n+):\n     '''Updates `_data/latest.json` to match build result of the given commit.\n     '''\n     with open('_data/latest.json', 'rb+') as f:\n@@ -50,8 +64,13 @@ def update_latest(current_commit, relevant_pr_number, current_datetime):\n         }\n \n         slug = 'rust-lang/rust'\n-        message = '\ud83d\udce3 Toolstate changed by {}!\\n\\nTested on commit {}@{}.\\n\\n' \\\n-            .format(relevant_pr_number, slug, current_commit)\n+        message = textwrap.dedent('''\\\n+            \ud83d\udce3 Toolstate changed by {}!\n+\n+            Tested on commit {}@{}.\n+            Direct link to PR: <{}>\n+\n+        ''').format(relevant_pr_number, slug, current_commit, relevant_pr_url)\n         anything_changed = False\n         for status in latest:\n             tool = status['tool']\n@@ -68,7 +87,7 @@ def update_latest(current_commit, relevant_pr_number, current_datetime):\n                 elif new < old:\n                     changed = True\n                     message += '\ud83d\udc94 {} on {}: {} \u2192 {} (cc {}).\\n' \\\n-                        .format(tool, os, old, new, MAINTAINERS[tool])\n+                        .format(tool, os, old, new, MAINTAINERS.get(tool))\n \n             if changed:\n                 status['commit'] = current_commit\n@@ -89,17 +108,41 @@ def update_latest(current_commit, relevant_pr_number, current_datetime):\n     cur_datetime = datetime.datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ')\n     cur_commit_msg = sys.argv[2]\n     save_message_to_path = sys.argv[3]\n+    github_token = sys.argv[4]\n \n-    relevant_pr_match = re.search('#[0-9]+', cur_commit_msg)\n+    relevant_pr_match = re.search('#([0-9]+)', cur_commit_msg)\n     if relevant_pr_match:\n-        relevant_pr_number = 'rust-lang/rust' + relevant_pr_match.group(0)\n+        number = relevant_pr_match.group(1)\n+        relevant_pr_number = 'rust-lang/rust#' + number\n+        relevant_pr_url = 'https://github.com/rust-lang/rust/pull/' + number\n     else:\n+        number = '-1'\n         relevant_pr_number = '<unknown PR>'\n-\n-    message = update_latest(cur_commit, relevant_pr_number, cur_datetime)\n-    if message:\n-        print(message)\n-        with open(save_message_to_path, 'w') as f:\n-            f.write(message)\n-    else:\n+        relevant_pr_url = '<unknown>'\n+\n+    message = update_latest(\n+        cur_commit,\n+        relevant_pr_number,\n+        relevant_pr_url,\n+        cur_datetime\n+    )\n+    if not message:\n         print('<Nothing changed>')\n+        sys.exit(0)\n+\n+    print(message)\n+    with open(save_message_to_path, 'w') as f:\n+        f.write(message)\n+\n+    # Write the toolstate comment on the PR as well.\n+    gh_url = 'https://api.github.com/repos/rust-lang/rust/issues/{}/comments' \\\n+        .format(number)\n+    response = urllib2.urlopen(urllib2.Request(\n+        gh_url,\n+        json.dumps({'body': message}),\n+        {\n+            'Authorization': 'token ' + github_token,\n+            'Content-Type': 'application/json',\n+        }\n+    ))\n+    response.read()"}]}