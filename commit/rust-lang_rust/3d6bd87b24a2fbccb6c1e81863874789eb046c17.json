{"sha": "3d6bd87b24a2fbccb6c1e81863874789eb046c17", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkNmJkODdiMjRhMmZiY2NiNmMxZTgxODYzODc0Nzg5ZWIwNDZjMTc=", "commit": {"author": {"name": "Reyk Floeter", "email": "contact@reykfloeter.com", "date": "2021-03-22T11:07:44Z"}, "committer": {"name": "Reyk Floeter", "email": "contact@reykfloeter.com", "date": "2021-03-26T20:12:22Z"}, "message": "unix: Fix feature(unix_socket_ancillary_data) on macos and other BSDs\n\nThis adds support for CMSG handling on macOS and fixes it on OpenBSD\nand other BSDs.\n\nWhen traversing the CMSG list, the previous code had an exception for\nAndroid where the next element after the last pointer could point to\nthe first pointer instead of NULL.  This is actually not specific to\nAndroid: the `libc::CMSG_NXTHDR` implementation for Linux and\nemscripten have a special case to return NULL when the length of the\nprevious element is zero; most other implementations simply return the\nprevious element plus a zero offset in this case.\n\nThis MR additionally adds `SocketAncillary::is_empty` because clippy\nis right that it should be added.", "tree": {"sha": "ce9973fad8cb080a769624d50e68186cb34c22cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce9973fad8cb080a769624d50e68186cb34c22cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d6bd87b24a2fbccb6c1e81863874789eb046c17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d6bd87b24a2fbccb6c1e81863874789eb046c17", "html_url": "https://github.com/rust-lang/rust/commit/3d6bd87b24a2fbccb6c1e81863874789eb046c17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d6bd87b24a2fbccb6c1e81863874789eb046c17/comments", "author": {"login": "reyk", "id": 2347189, "node_id": "MDQ6VXNlcjIzNDcxODk=", "avatar_url": "https://avatars.githubusercontent.com/u/2347189?v=4", "gravatar_id": "", "url": "https://api.github.com/users/reyk", "html_url": "https://github.com/reyk", "followers_url": "https://api.github.com/users/reyk/followers", "following_url": "https://api.github.com/users/reyk/following{/other_user}", "gists_url": "https://api.github.com/users/reyk/gists{/gist_id}", "starred_url": "https://api.github.com/users/reyk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/reyk/subscriptions", "organizations_url": "https://api.github.com/users/reyk/orgs", "repos_url": "https://api.github.com/users/reyk/repos", "events_url": "https://api.github.com/users/reyk/events{/privacy}", "received_events_url": "https://api.github.com/users/reyk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "reyk", "id": 2347189, "node_id": "MDQ6VXNlcjIzNDcxODk=", "avatar_url": "https://avatars.githubusercontent.com/u/2347189?v=4", "gravatar_id": "", "url": "https://api.github.com/users/reyk", "html_url": "https://github.com/reyk", "followers_url": "https://api.github.com/users/reyk/followers", "following_url": "https://api.github.com/users/reyk/following{/other_user}", "gists_url": "https://api.github.com/users/reyk/gists{/gist_id}", "starred_url": "https://api.github.com/users/reyk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/reyk/subscriptions", "organizations_url": "https://api.github.com/users/reyk/orgs", "repos_url": "https://api.github.com/users/reyk/repos", "events_url": "https://api.github.com/users/reyk/events{/privacy}", "received_events_url": "https://api.github.com/users/reyk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8719c51e0e44483cff9b6975a830f6e51812a48", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8719c51e0e44483cff9b6975a830f6e51812a48", "html_url": "https://github.com/rust-lang/rust/commit/b8719c51e0e44483cff9b6975a830f6e51812a48"}], "stats": {"total": 57, "additions": 34, "deletions": 23}, "files": [{"sha": "011ae643f87123bf9cf74539429c48abbd380d19", "filename": "library/std/src/sys/unix/ext/net/ancillary.rs", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3d6bd87b24a2fbccb6c1e81863874789eb046c17/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fancillary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d6bd87b24a2fbccb6c1e81863874789eb046c17/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fancillary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fancillary.rs?ref=3d6bd87b24a2fbccb6c1e81863874789eb046c17", "patch": "@@ -5,9 +5,7 @@ use crate::marker::PhantomData;\n use crate::mem::{size_of, zeroed};\n use crate::os::unix::io::RawFd;\n use crate::path::Path;\n-#[cfg(target_os = \"android\")]\n-use crate::ptr::eq;\n-use crate::ptr::read_unaligned;\n+use crate::ptr::{eq, read_unaligned};\n use crate::slice::from_raw_parts;\n use crate::sys::net::Socket;\n \n@@ -30,12 +28,10 @@ pub(super) fn recv_vectored_with_ancillary_from(\n ) -> io::Result<(usize, bool, io::Result<SocketAddr>)> {\n     unsafe {\n         let mut msg_name: libc::sockaddr_un = zeroed();\n-\n         let mut msg: libc::msghdr = zeroed();\n         msg.msg_name = &mut msg_name as *mut _ as *mut _;\n         msg.msg_namelen = size_of::<libc::sockaddr_un>() as libc::socklen_t;\n         msg.msg_iov = bufs.as_mut_ptr().cast();\n-        msg.msg_control = ancillary.buffer.as_mut_ptr().cast();\n         cfg_if::cfg_if! {\n             if #[cfg(any(target_os = \"android\", all(target_os = \"linux\", target_env = \"gnu\")))] {\n                 msg.msg_iovlen = bufs.len() as libc::size_t;\n@@ -45,13 +41,18 @@ pub(super) fn recv_vectored_with_ancillary_from(\n                           target_os = \"emscripten\",\n                           target_os = \"freebsd\",\n                           all(target_os = \"linux\", target_env = \"musl\",),\n+                          target_os = \"macos\",\n                           target_os = \"netbsd\",\n                           target_os = \"openbsd\",\n                       ))] {\n                 msg.msg_iovlen = bufs.len() as libc::c_int;\n                 msg.msg_controllen = ancillary.buffer.len() as libc::socklen_t;\n             }\n         }\n+        // macos requires that the control pointer is NULL when the len is 0.\n+        if msg.msg_controllen > 0 {\n+            msg.msg_control = ancillary.buffer.as_mut_ptr().cast();\n+        }\n \n         let count = socket.recv_msg(&mut msg)?;\n \n@@ -79,7 +80,6 @@ pub(super) fn send_vectored_with_ancillary_to(\n         msg.msg_name = &mut msg_name as *mut _ as *mut _;\n         msg.msg_namelen = msg_namelen;\n         msg.msg_iov = bufs.as_ptr() as *mut _;\n-        msg.msg_control = ancillary.buffer.as_mut_ptr().cast();\n         cfg_if::cfg_if! {\n             if #[cfg(any(target_os = \"android\", all(target_os = \"linux\", target_env = \"gnu\")))] {\n                 msg.msg_iovlen = bufs.len() as libc::size_t;\n@@ -89,13 +89,18 @@ pub(super) fn send_vectored_with_ancillary_to(\n                           target_os = \"emscripten\",\n                           target_os = \"freebsd\",\n                           all(target_os = \"linux\", target_env = \"musl\",),\n+                          target_os = \"macos\",\n                           target_os = \"netbsd\",\n                           target_os = \"openbsd\",\n                       ))] {\n                 msg.msg_iovlen = bufs.len() as libc::c_int;\n                 msg.msg_controllen = ancillary.length as libc::socklen_t;\n             }\n         }\n+        // macos requires that the control pointer is NULL when the len is 0.\n+        if msg.msg_controllen > 0 {\n+            msg.msg_control = ancillary.buffer.as_mut_ptr().cast();\n+        }\n \n         ancillary.truncated = false;\n \n@@ -147,6 +152,7 @@ fn add_to_ancillary_data<T>(\n                           target_os = \"emscripten\",\n                           target_os = \"freebsd\",\n                           all(target_os = \"linux\", target_env = \"musl\",),\n+                          target_os = \"macos\",\n                           target_os = \"netbsd\",\n                           target_os = \"openbsd\",\n                       ))] {\n@@ -159,14 +165,12 @@ fn add_to_ancillary_data<T>(\n         while !cmsg.is_null() {\n             previous_cmsg = cmsg;\n             cmsg = libc::CMSG_NXTHDR(&msg, cmsg);\n-            cfg_if::cfg_if! {\n-                // Android return the same pointer if it is the last cmsg.\n-                // Therefore, check it if the previous pointer is the same as the current one.\n-                if #[cfg(target_os = \"android\")] {\n-                    if cmsg == previous_cmsg {\n-                        break;\n-                    }\n-                }\n+\n+            // Most operating systems, but not Linux or emscripten, return the previous pointer\n+            // when its length is zero. Therefore, check if the previous pointer is the same as\n+            // the current one.\n+            if eq(cmsg, previous_cmsg) {\n+                break;\n             }\n         }\n \n@@ -184,6 +188,7 @@ fn add_to_ancillary_data<T>(\n                           target_os = \"emscripten\",\n                           target_os = \"freebsd\",\n                           all(target_os = \"linux\", target_env = \"musl\",),\n+                          target_os = \"macos\",\n                           target_os = \"netbsd\",\n                           target_os = \"openbsd\",\n                       ))] {\n@@ -371,6 +376,7 @@ impl<'a> AncillaryData<'a> {\n                               target_os = \"emscripten\",\n                               target_os = \"freebsd\",\n                               all(target_os = \"linux\", target_env = \"musl\",),\n+                              target_os = \"macos\",\n                               target_os = \"netbsd\",\n                               target_os = \"openbsd\",\n                           ))] {\n@@ -421,6 +427,7 @@ impl<'a> Iterator for Messages<'a> {\n                               target_os = \"emscripten\",\n                               target_os = \"freebsd\",\n                               all(target_os = \"linux\", target_env = \"musl\",),\n+                              target_os = \"macos\",\n                               target_os = \"netbsd\",\n                               target_os = \"openbsd\",\n                           ))] {\n@@ -435,15 +442,13 @@ impl<'a> Iterator for Messages<'a> {\n             };\n \n             let cmsg = cmsg.as_ref()?;\n-            cfg_if::cfg_if! {\n-                // Android return the same pointer if it is the last cmsg.\n-                // Therefore, check it if the previous pointer is the same as the current one.\n-                if #[cfg(target_os = \"android\")] {\n-                    if let Some(current) = self.current {\n-                        if eq(current, cmsg) {\n-                            return None;\n-                        }\n-                    }\n+\n+            // Most operating systems, but not Linux or emscripten, return the previous pointer\n+            // when its length is zero. Therefore, check if the previous pointer is the same as\n+            // the current one.\n+            if let Some(current) = self.current {\n+                if eq(current, cmsg) {\n+                    return None;\n                 }\n             }\n \n@@ -514,6 +519,12 @@ impl<'a> SocketAncillary<'a> {\n         self.buffer.len()\n     }\n \n+    /// Returns `true` if the ancillary data is empty.\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn is_empty(&self) -> bool {\n+        self.length == 0\n+    }\n+\n     /// Returns the number of used bytes.\n     #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n     pub fn len(&self) -> usize {"}]}