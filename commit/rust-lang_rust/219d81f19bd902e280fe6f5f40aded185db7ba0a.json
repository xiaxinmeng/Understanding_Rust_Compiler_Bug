{"sha": "219d81f19bd902e280fe6f5f40aded185db7ba0a", "node_id": "C_kwDOAAsO6NoAKDIxOWQ4MWYxOWJkOTAyZTI4MGZlNmY1ZjQwYWRlZDE4NWRiN2JhMGE", "commit": {"author": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2022-04-14T22:29:21Z"}, "committer": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2022-04-14T22:30:53Z"}, "message": "separate flock implementations into separate modules", "tree": {"sha": "5c7d6c52ea1ea52d90a378df9bfe117ac6e9e55d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c7d6c52ea1ea52d90a378df9bfe117ac6e9e55d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/219d81f19bd902e280fe6f5f40aded185db7ba0a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQFKBAABCAA0FiEELriChyEaiMu0yCg7viIhAz7bw3QFAmJYoKoWHGFydXNzZWxs\nMTIzQGdtYWlsLmNvbQAKCRC+IiEDPtvDdGakB/9WZ4UuY9x2YmdkPVHBKI3FeRi0\nSWuoaR7j5Tkrj6dMUrwsrXjea6jEfagV5dLKNDKjzRHID0Qdo7vcvT0/VbLNm+uc\nncQQ/2syR3xzPM+myaNmfu13ASdSrFTieGr/HrzgVICDN0wUWgMu5xeJYIUjeMem\n8lLgkFPU1eh95iv8lUK2+g5yNKjEl6vaWOB83QWK/vLZYy6v/txDRIazzPFfU1K+\nlFPksCfD26pDAx6jubxGHVmL604UYK4115dt8uKBSzHQIWpmmws1o/GSXkrNkzJW\nbUpaKtGysqJ5qTXZtQiC14PFpHGtoRC9EvJlNVRASmNhUIAb7736V+DX15Xy\n=ixOD\n-----END PGP SIGNATURE-----", "payload": "tree 5c7d6c52ea1ea52d90a378df9bfe117ac6e9e55d\nparent e7575f9670f3c837def3d186ae09366c75c7632e\nauthor Andy Russell <arussell123@gmail.com> 1649975361 -0400\ncommitter Andy Russell <arussell123@gmail.com> 1649975453 -0400\n\nseparate flock implementations into separate modules\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/219d81f19bd902e280fe6f5f40aded185db7ba0a", "html_url": "https://github.com/rust-lang/rust/commit/219d81f19bd902e280fe6f5f40aded185db7ba0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/219d81f19bd902e280fe6f5f40aded185db7ba0a/comments", "author": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "committer": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7575f9670f3c837def3d186ae09366c75c7632e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7575f9670f3c837def3d186ae09366c75c7632e", "html_url": "https://github.com/rust-lang/rust/commit/e7575f9670f3c837def3d186ae09366c75c7632e"}], "stats": {"total": 409, "additions": 194, "deletions": 215}, "files": [{"sha": "e395d8dbbbf8b2dea18c1f29a3cfdab2d21ffcd5", "filename": "compiler/rustc_data_structures/src/flock.rs", "status": "modified", "additions": 10, "deletions": 215, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/219d81f19bd902e280fe6f5f40aded185db7ba0a/compiler%2Frustc_data_structures%2Fsrc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/219d81f19bd902e280fe6f5f40aded185db7ba0a/compiler%2Frustc_data_structures%2Fsrc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fflock.rs?ref=219d81f19bd902e280fe6f5f40aded185db7ba0a", "patch": "@@ -7,225 +7,20 @@\n #![allow(non_camel_case_types)]\n #![allow(nonstandard_style)]\n \n-use std::fs::{File, OpenOptions};\n-use std::io;\n-use std::path::Path;\n-\n cfg_if! {\n-    // We use `flock` rather than `fcntl` on Linux, because WSL1 does not support\n-    // `fcntl`-style advisory locks properly (rust-lang/rust#72157).\n-    //\n-    // For other Unix targets we still use `fcntl` because it's more portable than\n-    // `flock`.\n     if #[cfg(target_os = \"linux\")] {\n-        use std::os::unix::prelude::*;\n-\n-        #[derive(Debug)]\n-        pub struct Lock {\n-            _file: File,\n-        }\n-\n-        impl Lock {\n-            pub fn new(p: &Path,\n-                       wait: bool,\n-                       create: bool,\n-                       exclusive: bool)\n-                       -> io::Result<Lock> {\n-                let file = OpenOptions::new()\n-                    .read(true)\n-                    .write(true)\n-                    .create(create)\n-                    .mode(libc::S_IRWXU as u32)\n-                    .open(p)?;\n-\n-                let mut operation = if exclusive {\n-                    libc::LOCK_EX\n-                } else {\n-                    libc::LOCK_SH\n-                };\n-                if !wait {\n-                    operation |= libc::LOCK_NB\n-                }\n-\n-                let ret = unsafe { libc::flock(file.as_raw_fd(), operation) };\n-                if ret == -1 {\n-                    Err(io::Error::last_os_error())\n-                } else {\n-                    Ok(Lock { _file: file })\n-                }\n-            }\n-\n-            pub fn error_unsupported(err: &io::Error) -> bool {\n-                matches!(err.raw_os_error(), Some(libc::ENOTSUP) | Some(libc::ENOSYS))\n-            }\n-        }\n-\n-        // Note that we don't need a Drop impl to execute `flock(fd, LOCK_UN)`. Lock acquired by\n-        // `flock` is associated with the file descriptor and closing the file release it\n-        // automatically.\n+        mod linux;\n+        use linux as imp;\n     } else if #[cfg(unix)] {\n-        use std::mem;\n-        use std::os::unix::prelude::*;\n-\n-        #[derive(Debug)]\n-        pub struct Lock {\n-            file: File,\n-        }\n-\n-        impl Lock {\n-            pub fn new(p: &Path,\n-                       wait: bool,\n-                       create: bool,\n-                       exclusive: bool)\n-                       -> io::Result<Lock> {\n-                let file = OpenOptions::new()\n-                    .read(true)\n-                    .write(true)\n-                    .create(create)\n-                    .mode(libc::S_IRWXU as u32)\n-                    .open(p)?;\n-\n-                let lock_type = if exclusive {\n-                    libc::F_WRLCK\n-                } else {\n-                    libc::F_RDLCK\n-                };\n-\n-                let mut flock: libc::flock = unsafe { mem::zeroed() };\n-                flock.l_type = lock_type as libc::c_short;\n-                flock.l_whence = libc::SEEK_SET as libc::c_short;\n-                flock.l_start = 0;\n-                flock.l_len = 0;\n-\n-                let cmd = if wait { libc::F_SETLKW } else { libc::F_SETLK };\n-                let ret = unsafe {\n-                    libc::fcntl(file.as_raw_fd(), cmd, &flock)\n-                };\n-                if ret == -1 {\n-                    Err(io::Error::last_os_error())\n-                } else {\n-                    Ok(Lock { file })\n-                }\n-            }\n-\n-            pub fn error_unsupported(err: &io::Error) -> bool {\n-                matches!(err.raw_os_error(), Some(libc::ENOTSUP) | Some(libc::ENOSYS))\n-            }\n-        }\n-\n-        impl Drop for Lock {\n-            fn drop(&mut self) {\n-                let mut flock: libc::flock = unsafe { mem::zeroed() };\n-                flock.l_type = libc::F_UNLCK as libc::c_short;\n-                flock.l_whence = libc::SEEK_SET as libc::c_short;\n-                flock.l_start = 0;\n-                flock.l_len = 0;\n-\n-                unsafe {\n-                    libc::fcntl(self.file.as_raw_fd(), libc::F_SETLK, &flock);\n-                }\n-            }\n-        }\n+        mod unix;\n+        use unix as imp;\n     } else if #[cfg(windows)] {\n-        use std::mem;\n-        use std::os::windows::prelude::*;\n-\n-        use winapi::shared::winerror::ERROR_INVALID_FUNCTION;\n-        use winapi::um::minwinbase::{OVERLAPPED, LOCKFILE_FAIL_IMMEDIATELY, LOCKFILE_EXCLUSIVE_LOCK};\n-        use winapi::um::fileapi::LockFileEx;\n-        use winapi::um::winnt::{FILE_SHARE_DELETE, FILE_SHARE_READ, FILE_SHARE_WRITE};\n-\n-        #[derive(Debug)]\n-        pub struct Lock {\n-            _file: File,\n-        }\n-\n-        impl Lock {\n-            pub fn new(p: &Path,\n-                       wait: bool,\n-                       create: bool,\n-                       exclusive: bool)\n-                       -> io::Result<Lock> {\n-                assert!(p.parent().unwrap().exists(),\n-                    \"Parent directory of lock-file must exist: {}\",\n-                    p.display());\n-\n-                let share_mode = FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE;\n-\n-                let mut open_options = OpenOptions::new();\n-                open_options.read(true)\n-                            .share_mode(share_mode);\n-\n-                if create {\n-                    open_options.create(true)\n-                                .write(true);\n-                }\n-\n-                debug!(\"attempting to open lock file `{}`\", p.display());\n-                let file = match open_options.open(p) {\n-                    Ok(file) => {\n-                        debug!(\"lock file opened successfully\");\n-                        file\n-                    }\n-                    Err(err) => {\n-                        debug!(\"error opening lock file: {}\", err);\n-                        return Err(err)\n-                    }\n-                };\n-\n-                let ret = unsafe {\n-                    let mut overlapped: OVERLAPPED = mem::zeroed();\n-\n-                    let mut dwFlags = 0;\n-                    if !wait {\n-                        dwFlags |= LOCKFILE_FAIL_IMMEDIATELY;\n-                    }\n-\n-                    if exclusive {\n-                        dwFlags |= LOCKFILE_EXCLUSIVE_LOCK;\n-                    }\n-\n-                    debug!(\"attempting to acquire lock on lock file `{}`\",\n-                           p.display());\n-                    LockFileEx(file.as_raw_handle(),\n-                               dwFlags,\n-                               0,\n-                               0xFFFF_FFFF,\n-                               0xFFFF_FFFF,\n-                               &mut overlapped)\n-                };\n-                if ret == 0 {\n-                    let err = io::Error::last_os_error();\n-                    debug!(\"failed acquiring file lock: {}\", err);\n-                    Err(err)\n-                } else {\n-                    debug!(\"successfully acquired lock\");\n-                    Ok(Lock { _file: file })\n-                }\n-            }\n-\n-            pub fn error_unsupported(err: &io::Error) -> bool {\n-                err.raw_os_error() == Some(ERROR_INVALID_FUNCTION as i32)\n-            }\n-        }\n-\n-        // Note that we don't need a Drop impl on the Windows: The file is unlocked\n-        // automatically when it's closed.\n+        mod windows;\n+        use windows as imp;\n     } else {\n-        #[derive(Debug)]\n-        pub struct Lock(());\n-\n-        impl Lock {\n-            pub fn new(_p: &Path, _wait: bool, _create: bool, _exclusive: bool)\n-                -> io::Result<Lock>\n-            {\n-                let msg = \"file locks not supported on this platform\";\n-                Err(io::Error::new(io::ErrorKind::Other, msg))\n-            }\n-\n-            pub fn error_unsupported(_err: &io::Error) -> bool {\n-                true\n-            }\n-        }\n+        mod unsupported;\n+        use unsupported as imp;\n     }\n }\n+\n+pub use imp::Lock;"}, {"sha": "bb3ecfbc370c0b3bc0242259bd8191d785deb6a5", "filename": "compiler/rustc_data_structures/src/flock/linux.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/219d81f19bd902e280fe6f5f40aded185db7ba0a/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Flinux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/219d81f19bd902e280fe6f5f40aded185db7ba0a/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Flinux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Flinux.rs?ref=219d81f19bd902e280fe6f5f40aded185db7ba0a", "patch": "@@ -0,0 +1,40 @@\n+//! We use `flock` rather than `fcntl` on Linux, because WSL1 does not support\n+//! `fcntl`-style advisory locks properly (rust-lang/rust#72157). For other Unix\n+//! targets we still use `fcntl` because it's more portable than `flock`.\n+\n+use std::fs::{File, OpenOptions};\n+use std::io;\n+use std::os::unix::prelude::*;\n+use std::path::Path;\n+\n+#[derive(Debug)]\n+pub struct Lock {\n+    _file: File,\n+}\n+\n+impl Lock {\n+    pub fn new(p: &Path, wait: bool, create: bool, exclusive: bool) -> io::Result<Lock> {\n+        let file = OpenOptions::new()\n+            .read(true)\n+            .write(true)\n+            .create(create)\n+            .mode(libc::S_IRWXU as u32)\n+            .open(p)?;\n+\n+        let mut operation = if exclusive { libc::LOCK_EX } else { libc::LOCK_SH };\n+        if !wait {\n+            operation |= libc::LOCK_NB\n+        }\n+\n+        let ret = unsafe { libc::flock(file.as_raw_fd(), operation) };\n+        if ret == -1 { Err(io::Error::last_os_error()) } else { Ok(Lock { _file: file }) }\n+    }\n+\n+    pub fn error_unsupported(err: &io::Error) -> bool {\n+        matches!(err.raw_os_error(), Some(libc::ENOTSUP) | Some(libc::ENOSYS))\n+    }\n+}\n+\n+// Note that we don't need a Drop impl to execute `flock(fd, LOCK_UN)`. A lock acquired by\n+// `flock` is associated with the file descriptor and closing the file releases it\n+// automatically."}, {"sha": "4e5297d582e075d749a6c9e239db06ca0bd4e012", "filename": "compiler/rustc_data_structures/src/flock/unix.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/219d81f19bd902e280fe6f5f40aded185db7ba0a/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/219d81f19bd902e280fe6f5f40aded185db7ba0a/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Funix.rs?ref=219d81f19bd902e280fe6f5f40aded185db7ba0a", "patch": "@@ -0,0 +1,51 @@\n+use std::fs::{File, OpenOptions};\n+use std::io;\n+use std::mem;\n+use std::os::unix::prelude::*;\n+use std::path::Path;\n+\n+#[derive(Debug)]\n+pub struct Lock {\n+    file: File,\n+}\n+\n+impl Lock {\n+    pub fn new(p: &Path, wait: bool, create: bool, exclusive: bool) -> io::Result<Lock> {\n+        let file = OpenOptions::new()\n+            .read(true)\n+            .write(true)\n+            .create(create)\n+            .mode(libc::S_IRWXU as u32)\n+            .open(p)?;\n+\n+        let lock_type = if exclusive { libc::F_WRLCK } else { libc::F_RDLCK };\n+\n+        let mut flock: libc::flock = unsafe { mem::zeroed() };\n+        flock.l_type = lock_type as libc::c_short;\n+        flock.l_whence = libc::SEEK_SET as libc::c_short;\n+        flock.l_start = 0;\n+        flock.l_len = 0;\n+\n+        let cmd = if wait { libc::F_SETLKW } else { libc::F_SETLK };\n+        let ret = unsafe { libc::fcntl(file.as_raw_fd(), cmd, &flock) };\n+        if ret == -1 { Err(io::Error::last_os_error()) } else { Ok(Lock { file }) }\n+    }\n+\n+    pub fn error_unsupported(err: &io::Error) -> bool {\n+        matches!(err.raw_os_error(), Some(libc::ENOTSUP) | Some(libc::ENOSYS))\n+    }\n+}\n+\n+impl Drop for Lock {\n+    fn drop(&mut self) {\n+        let mut flock: libc::flock = unsafe { mem::zeroed() };\n+        flock.l_type = libc::F_UNLCK as libc::c_short;\n+        flock.l_whence = libc::SEEK_SET as libc::c_short;\n+        flock.l_start = 0;\n+        flock.l_len = 0;\n+\n+        unsafe {\n+            libc::fcntl(self.file.as_raw_fd(), libc::F_SETLK, &flock);\n+        }\n+    }\n+}"}, {"sha": "9245fca373dfc4de7c0fda7dc50ff3dd97d96f3f", "filename": "compiler/rustc_data_structures/src/flock/unsupported.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/219d81f19bd902e280fe6f5f40aded185db7ba0a/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Funsupported.rs", "raw_url": "https://github.com/rust-lang/rust/raw/219d81f19bd902e280fe6f5f40aded185db7ba0a/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Funsupported.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Funsupported.rs?ref=219d81f19bd902e280fe6f5f40aded185db7ba0a", "patch": "@@ -0,0 +1,16 @@\n+use std::io;\n+use std::path::Path;\n+\n+#[derive(Debug)]\n+pub struct Lock(());\n+\n+impl Lock {\n+    pub fn new(_p: &Path, _wait: bool, _create: bool, _exclusive: bool) -> io::Result<Lock> {\n+        let msg = \"file locks not supported on this platform\";\n+        Err(io::Error::new(io::ErrorKind::Other, msg))\n+    }\n+\n+    pub fn error_unsupported(_err: &io::Error) -> bool {\n+        true\n+    }\n+}"}, {"sha": "43e6caaa18dcd1d6cf96f73cf6760ed9a195708d", "filename": "compiler/rustc_data_structures/src/flock/windows.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/219d81f19bd902e280fe6f5f40aded185db7ba0a/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/219d81f19bd902e280fe6f5f40aded185db7ba0a/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Fwindows.rs?ref=219d81f19bd902e280fe6f5f40aded185db7ba0a", "patch": "@@ -0,0 +1,77 @@\n+use std::fs::{File, OpenOptions};\n+use std::io;\n+use std::mem;\n+use std::os::windows::prelude::*;\n+use std::path::Path;\n+\n+use winapi::shared::winerror::ERROR_INVALID_FUNCTION;\n+use winapi::um::fileapi::LockFileEx;\n+use winapi::um::minwinbase::{LOCKFILE_EXCLUSIVE_LOCK, LOCKFILE_FAIL_IMMEDIATELY, OVERLAPPED};\n+use winapi::um::winnt::{FILE_SHARE_DELETE, FILE_SHARE_READ, FILE_SHARE_WRITE};\n+\n+#[derive(Debug)]\n+pub struct Lock {\n+    _file: File,\n+}\n+\n+impl Lock {\n+    pub fn new(p: &Path, wait: bool, create: bool, exclusive: bool) -> io::Result<Lock> {\n+        assert!(\n+            p.parent().unwrap().exists(),\n+            \"Parent directory of lock-file must exist: {}\",\n+            p.display()\n+        );\n+\n+        let share_mode = FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE;\n+\n+        let mut open_options = OpenOptions::new();\n+        open_options.read(true).share_mode(share_mode);\n+\n+        if create {\n+            open_options.create(true).write(true);\n+        }\n+\n+        debug!(\"attempting to open lock file `{}`\", p.display());\n+        let file = match open_options.open(p) {\n+            Ok(file) => {\n+                debug!(\"lock file opened successfully\");\n+                file\n+            }\n+            Err(err) => {\n+                debug!(\"error opening lock file: {}\", err);\n+                return Err(err);\n+            }\n+        };\n+\n+        let ret = unsafe {\n+            let mut overlapped: OVERLAPPED = mem::zeroed();\n+\n+            let mut dwFlags = 0;\n+            if !wait {\n+                dwFlags |= LOCKFILE_FAIL_IMMEDIATELY;\n+            }\n+\n+            if exclusive {\n+                dwFlags |= LOCKFILE_EXCLUSIVE_LOCK;\n+            }\n+\n+            debug!(\"attempting to acquire lock on lock file `{}`\", p.display());\n+            LockFileEx(file.as_raw_handle(), dwFlags, 0, 0xFFFF_FFFF, 0xFFFF_FFFF, &mut overlapped)\n+        };\n+        if ret == 0 {\n+            let err = io::Error::last_os_error();\n+            debug!(\"failed acquiring file lock: {}\", err);\n+            Err(err)\n+        } else {\n+            debug!(\"successfully acquired lock\");\n+            Ok(Lock { _file: file })\n+        }\n+    }\n+\n+    pub fn error_unsupported(err: &io::Error) -> bool {\n+        err.raw_os_error() == Some(ERROR_INVALID_FUNCTION as i32)\n+    }\n+}\n+\n+// Note that we don't need a Drop impl on Windows: The file is unlocked\n+// automatically when it's closed."}]}