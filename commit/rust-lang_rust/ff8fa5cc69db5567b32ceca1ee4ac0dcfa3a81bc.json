{"sha": "ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmOGZhNWNjNjlkYjU1NjdiMzJjZWNhMWVlNGFjMGRjZmEzYTgxYmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-22T10:35:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-22T10:35:59Z"}, "message": "Auto merge of #50520 - Zoxc:alloc-misc, r=oli-obk\n\nMisc changes related to Miri allocations\n\nThis builds on top of https://github.com/rust-lang/rust/pull/50249\n\nr? @oli-obk", "tree": {"sha": "907c3d78c0aabc528331812d7b6f71b1f2ec9970", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/907c3d78c0aabc528331812d7b6f71b1f2ec9970"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc", "html_url": "https://github.com/rust-lang/rust/commit/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bbae5f38677e823ba6e23f1e0e105ceee4c6f8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bbae5f38677e823ba6e23f1e0e105ceee4c6f8a", "html_url": "https://github.com/rust-lang/rust/commit/1bbae5f38677e823ba6e23f1e0e105ceee4c6f8a"}, {"sha": "ddc54188fb6774ff1493aa896d9175e112d92cce", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddc54188fb6774ff1493aa896d9175e112d92cce", "html_url": "https://github.com/rust-lang/rust/commit/ddc54188fb6774ff1493aa896d9175e112d92cce"}], "stats": {"total": 640, "additions": 322, "deletions": 318}, "files": [{"sha": "8c4ff718aa6ee54cb880f649441d37a72a4f1913", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 19, "deletions": 31, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc", "patch": "@@ -420,17 +420,6 @@ impl_stable_hash_for!(struct mir::interpret::MemoryPointer {\n     offset\n });\n \n-enum AllocDiscriminant {\n-    Alloc,\n-    Static,\n-    Function,\n-}\n-impl_stable_hash_for!(enum self::AllocDiscriminant {\n-    Alloc,\n-    Static,\n-    Function\n-});\n-\n impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n     fn hash_stable<W: StableHasherResult>(\n         &self,\n@@ -440,30 +429,29 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n         ty::tls::with_opt(|tcx| {\n             trace!(\"hashing {:?}\", *self);\n             let tcx = tcx.expect(\"can't hash AllocIds during hir lowering\");\n-            if let Some(def_id) = tcx.interpret_interner.get_static(*self) {\n-                AllocDiscriminant::Static.hash_stable(hcx, hasher);\n-                trace!(\"hashing {:?} as static {:?}\", *self, def_id);\n-                def_id.hash_stable(hcx, hasher);\n-            } else if let Some(alloc) = tcx.interpret_interner.get_alloc(*self) {\n-                AllocDiscriminant::Alloc.hash_stable(hcx, hasher);\n-                if hcx.alloc_id_recursion_tracker.insert(*self) {\n-                    trace!(\"hashing {:?} as alloc {:#?}\", *self, alloc);\n-                    alloc.hash_stable(hcx, hasher);\n-                    assert!(hcx.alloc_id_recursion_tracker.remove(self));\n-                } else {\n-                    trace!(\"skipping hashing of {:?} due to recursion\", *self);\n-                }\n-            } else if let Some(inst) = tcx.interpret_interner.get_fn(*self) {\n-                trace!(\"hashing {:?} as fn {:#?}\", *self, inst);\n-                AllocDiscriminant::Function.hash_stable(hcx, hasher);\n-                inst.hash_stable(hcx, hasher);\n-            } else {\n-                bug!(\"no allocation for {}\", self);\n-            }\n+            let alloc_kind = tcx.alloc_map.lock().get(*self).expect(\"no value for AllocId\");\n+            alloc_kind.hash_stable(hcx, hasher);\n         });\n     }\n }\n \n+impl<'a, 'gcx, M: HashStable<StableHashingContext<'a>>> HashStable<StableHashingContext<'a>>\n+for mir::interpret::AllocType<'gcx, M> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use mir::interpret::AllocType::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            Function(instance) => instance.hash_stable(hcx, hasher),\n+            Static(def_id) => def_id.hash_stable(hcx, hasher),\n+            Memory(ref mem) => mem.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n+\n impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::Allocation {\n     fn hash_stable<W: StableHasherResult>(\n         &self,"}, {"sha": "6f5401f54dc98a15941f279d68ded7045e91be89", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 119, "deletions": 22, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc", "patch": "@@ -16,13 +16,15 @@ use std::collections::BTreeMap;\n use std::fmt;\n use mir;\n use hir::def_id::DefId;\n-use ty::{self, TyCtxt};\n+use ty::{self, TyCtxt, Instance};\n use ty::layout::{self, Align, HasDataLayout, Size};\n use middle::region;\n use std::iter;\n use std::io;\n+use std::hash::Hash;\n use syntax::ast::Mutability;\n use rustc_serialize::{Encoder, Decoder, Decodable, Encodable};\n+use rustc_data_structures::fx::FxHashMap;\n use byteorder::{WriteBytesExt, ReadBytesExt, LittleEndian, BigEndian};\n \n #[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n@@ -150,7 +152,7 @@ impl<'tcx> MemoryPointer {\n }\n \n \n-#[derive(Copy, Clone, Default, Eq, Hash, Ord, PartialEq, PartialOrd, Debug)]\n+#[derive(Copy, Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug)]\n pub struct AllocId(pub u64);\n \n impl ::rustc_serialize::UseSpecializedEncodable for AllocId {}\n@@ -171,20 +173,25 @@ pub fn specialized_encode_alloc_id<\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     alloc_id: AllocId,\n ) -> Result<(), E::Error> {\n-    if let Some(alloc) = tcx.interpret_interner.get_alloc(alloc_id) {\n-        trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n-        AllocKind::Alloc.encode(encoder)?;\n-        alloc.encode(encoder)?;\n-    } else if let Some(fn_instance) = tcx.interpret_interner.get_fn(alloc_id) {\n-        trace!(\"encoding {:?} with {:#?}\", alloc_id, fn_instance);\n-        AllocKind::Fn.encode(encoder)?;\n-        fn_instance.encode(encoder)?;\n-    } else if let Some(did) = tcx.interpret_interner.get_static(alloc_id) {\n-        // referring to statics doesn't need to know about their allocations, just about its DefId\n-        AllocKind::Static.encode(encoder)?;\n-        did.encode(encoder)?;\n-    } else {\n-        bug!(\"alloc id without corresponding allocation: {}\", alloc_id);\n+    let alloc_type: AllocType<'tcx, &'tcx Allocation> =\n+        tcx.alloc_map.lock().get(alloc_id).expect(\"no value for AllocId\");\n+    match alloc_type {\n+        AllocType::Memory(alloc) => {\n+            trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n+            AllocKind::Alloc.encode(encoder)?;\n+            alloc.encode(encoder)?;\n+        }\n+        AllocType::Function(fn_instance) => {\n+            trace!(\"encoding {:?} with {:#?}\", alloc_id, fn_instance);\n+            AllocKind::Fn.encode(encoder)?;\n+            fn_instance.encode(encoder)?;\n+        }\n+        AllocType::Static(did) => {\n+            // referring to statics doesn't need to know about their allocations,\n+            // just about its DefId\n+            AllocKind::Static.encode(encoder)?;\n+            did.encode(encoder)?;\n+        }\n     }\n     Ok(())\n }\n@@ -200,31 +207,30 @@ pub fn specialized_decode_alloc_id<\n ) -> Result<AllocId, D::Error> {\n     match AllocKind::decode(decoder)? {\n         AllocKind::Alloc => {\n-            let alloc_id = tcx.interpret_interner.reserve();\n+            let alloc_id = tcx.alloc_map.lock().reserve();\n             trace!(\"creating alloc id {:?}\", alloc_id);\n             // insert early to allow recursive allocs\n             cache(decoder, alloc_id);\n \n-            let allocation = Allocation::decode(decoder)?;\n+            let allocation = <&'tcx Allocation as Decodable>::decode(decoder)?;\n             trace!(\"decoded alloc {:?} {:#?}\", alloc_id, allocation);\n-            let allocation = tcx.intern_const_alloc(allocation);\n-            tcx.interpret_interner.intern_at_reserved(alloc_id, allocation);\n+            tcx.alloc_map.lock().set_id_memory(alloc_id, allocation);\n \n             Ok(alloc_id)\n         },\n         AllocKind::Fn => {\n             trace!(\"creating fn alloc id\");\n             let instance = ty::Instance::decode(decoder)?;\n             trace!(\"decoded fn alloc instance: {:?}\", instance);\n-            let id = tcx.interpret_interner.create_fn_alloc(instance);\n+            let id = tcx.alloc_map.lock().create_fn_alloc(instance);\n             trace!(\"created fn alloc id: {:?}\", id);\n             cache(decoder, id);\n             Ok(id)\n         },\n         AllocKind::Static => {\n             trace!(\"creating extern static alloc id at\");\n             let did = DefId::decode(decoder)?;\n-            let alloc_id = tcx.interpret_interner.cache_static(did);\n+            let alloc_id = tcx.alloc_map.lock().intern_static(did);\n             cache(decoder, alloc_id);\n             Ok(alloc_id)\n         },\n@@ -237,6 +243,97 @@ impl fmt::Display for AllocId {\n     }\n }\n \n+#[derive(Debug, Clone, Eq, PartialEq, Hash, RustcDecodable, RustcEncodable)]\n+pub enum AllocType<'tcx, M> {\n+    /// The alloc id is used as a function pointer\n+    Function(Instance<'tcx>),\n+    /// The alloc id points to a static variable\n+    Static(DefId),\n+    /// The alloc id points to memory\n+    Memory(M)\n+}\n+\n+pub struct AllocMap<'tcx, M> {\n+    /// Lets you know what an AllocId refers to\n+    id_to_type: FxHashMap<AllocId, AllocType<'tcx, M>>,\n+\n+    /// Used to ensure that functions and statics only get one associated AllocId\n+    type_interner: FxHashMap<AllocType<'tcx, M>, AllocId>,\n+\n+    /// The AllocId to assign to the next requested id.\n+    /// Always incremented, never gets smaller.\n+    next_id: AllocId,\n+}\n+\n+impl<'tcx, M: fmt::Debug + Eq + Hash + Clone> AllocMap<'tcx, M> {\n+    pub fn new() -> Self {\n+        AllocMap {\n+            id_to_type: FxHashMap(),\n+            type_interner: FxHashMap(),\n+            next_id: AllocId(0),\n+        }\n+    }\n+\n+    /// obtains a new allocation ID that can be referenced but does not\n+    /// yet have an allocation backing it.\n+    pub fn reserve(\n+        &mut self,\n+    ) -> AllocId {\n+        let next = self.next_id;\n+        self.next_id.0 = self.next_id.0\n+            .checked_add(1)\n+            .expect(\"You overflowed a u64 by incrementing by 1... \\\n+                     You've just earned yourself a free drink if we ever meet. \\\n+                     Seriously, how did you do that?!\");\n+        next\n+    }\n+\n+    fn intern(&mut self, alloc_type: AllocType<'tcx, M>) -> AllocId {\n+        if let Some(&alloc_id) = self.type_interner.get(&alloc_type) {\n+            return alloc_id;\n+        }\n+        let id = self.reserve();\n+        debug!(\"creating alloc_type {:?} with id {}\", alloc_type, id);\n+        self.id_to_type.insert(id, alloc_type.clone());\n+        self.type_interner.insert(alloc_type, id);\n+        id\n+    }\n+\n+    // FIXME: Check if functions have identity. If not, we should not intern these,\n+    // but instead create a new id per use.\n+    // Alternatively we could just make comparing function pointers an error.\n+    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> AllocId {\n+        self.intern(AllocType::Function(instance))\n+    }\n+\n+    pub fn get(&self, id: AllocId) -> Option<AllocType<'tcx, M>> {\n+        self.id_to_type.get(&id).cloned()\n+    }\n+\n+    pub fn unwrap_memory(&self, id: AllocId) -> M {\n+        match self.get(id) {\n+            Some(AllocType::Memory(mem)) => mem,\n+            _ => bug!(\"expected allocation id {} to point to memory\", id),\n+        }\n+    }\n+\n+    pub fn intern_static(&mut self, static_id: DefId) -> AllocId {\n+        self.intern(AllocType::Static(static_id))\n+    }\n+\n+    pub fn allocate(&mut self, mem: M) -> AllocId {\n+        let id = self.reserve();\n+        self.set_id_memory(id, mem);\n+        id\n+    }\n+\n+    pub fn set_id_memory(&mut self, id: AllocId, mem: M) {\n+        if let Some(old) = self.id_to_type.insert(id, AllocType::Memory(mem)) {\n+            bug!(\"tried to set allocation id {}, but it was already existing as {:#?}\", id, old);\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug, Eq, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n pub struct Allocation {\n     /// The actual bytes of the allocation."}, {"sha": "66b08f5c3b00b536c52d98709eba7149d807a7a0", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc", "patch": "@@ -1908,17 +1908,15 @@ pub fn print_miri_value<W: Write>(value: Value, ty: Ty, f: &mut W) -> fmt::Resul\n         (Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len)),\n          &TyRef(_, &ty::TyS { sty: TyStr, .. }, _)) => {\n             ty::tls::with(|tcx| {\n-                let alloc = tcx\n-                    .interpret_interner\n-                    .get_alloc(ptr.alloc_id);\n-                if let Some(alloc) = alloc {\n-                    assert_eq!(len as usize as u128, len);\n-                    let slice = &alloc.bytes[(ptr.offset.bytes() as usize)..][..(len as usize)];\n-                    let s = ::std::str::from_utf8(slice)\n-                        .expect(\"non utf8 str from miri\");\n-                    write!(f, \"{:?}\", s)\n-                } else {\n-                    write!(f, \"pointer to erroneous constant {:?}, {:?}\", ptr, len)\n+                match tcx.alloc_map.lock().get(ptr.alloc_id) {\n+                    Some(interpret::AllocType::Memory(alloc)) => {\n+                        assert_eq!(len as usize as u128, len);\n+                        let slice = &alloc.bytes[(ptr.offset.bytes() as usize)..][..(len as usize)];\n+                        let s = ::std::str::from_utf8(slice)\n+                            .expect(\"non utf8 str from miri\");\n+                        write!(f, \"{:?}\", s)\n+                    }\n+                    _ => write!(f, \"pointer to erroneous constant {:?}, {:?}\", ptr, len),\n                 }\n             })\n         },"}, {"sha": "82d796253bd8602aea47c9c54d5f530ef6e86699", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 13, "deletions": 132, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc", "patch": "@@ -32,9 +32,9 @@ use middle::lang_items;\n use middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use middle::stability;\n use mir::{self, Mir, interpret};\n+use mir::interpret::Allocation;\n use ty::subst::{Kind, Substs, Subst};\n use ty::ReprOptions;\n-use ty::Instance;\n use traits;\n use traits::{Clause, Clauses, Goal, Goals};\n use ty::{self, Ty, TypeAndMut};\n@@ -914,7 +914,10 @@ pub struct GlobalCtxt<'tcx> {\n \n     stability_interner: Lock<FxHashSet<&'tcx attr::Stability>>,\n \n-    pub interpret_interner: InterpretInterner<'tcx>,\n+    /// Stores the value of constants (and deduplicates the actual memory)\n+    allocation_interner: Lock<FxHashSet<&'tcx Allocation>>,\n+\n+    pub alloc_map: Lock<interpret::AllocMap<'tcx, &'tcx Allocation>>,\n \n     layout_interner: Lock<FxHashSet<&'tcx LayoutDetails>>,\n \n@@ -929,117 +932,6 @@ pub struct GlobalCtxt<'tcx> {\n     output_filenames: Arc<OutputFilenames>,\n }\n \n-/// Everything needed to efficiently work with interned allocations\n-#[derive(Debug, Default)]\n-pub struct InterpretInterner<'tcx> {\n-    inner: Lock<InterpretInternerInner<'tcx>>,\n-}\n-\n-#[derive(Debug, Default)]\n-struct InterpretInternerInner<'tcx> {\n-    /// Stores the value of constants (and deduplicates the actual memory)\n-    allocs: FxHashSet<&'tcx interpret::Allocation>,\n-\n-    /// Allows obtaining function instance handles via a unique identifier\n-    functions: FxHashMap<interpret::AllocId, Instance<'tcx>>,\n-\n-    /// Inverse map of `interpret_functions`.\n-    /// Used so we don't allocate a new pointer every time we need one\n-    function_cache: FxHashMap<Instance<'tcx>, interpret::AllocId>,\n-\n-    /// Allows obtaining const allocs via a unique identifier\n-    alloc_by_id: FxHashMap<interpret::AllocId, &'tcx interpret::Allocation>,\n-\n-    /// Allows obtaining static def ids via a unique id\n-    statics: FxHashMap<interpret::AllocId, DefId>,\n-\n-    /// The AllocId to assign to the next new regular allocation.\n-    /// Always incremented, never gets smaller.\n-    next_id: interpret::AllocId,\n-\n-    /// Inverse map of `statics`\n-    /// Used so we don't allocate a new pointer every time we need one\n-    static_cache: FxHashMap<DefId, interpret::AllocId>,\n-\n-    /// A cache for basic byte allocations keyed by their contents. This is used to deduplicate\n-    /// allocations for string and bytestring literals.\n-    literal_alloc_cache: FxHashMap<Vec<u8>, interpret::AllocId>,\n-}\n-\n-impl<'tcx> InterpretInterner<'tcx> {\n-    pub fn create_fn_alloc(&self, instance: Instance<'tcx>) -> interpret::AllocId {\n-        if let Some(&alloc_id) = self.inner.borrow().function_cache.get(&instance) {\n-            return alloc_id;\n-        }\n-        let id = self.reserve();\n-        debug!(\"creating fn ptr: {}\", id);\n-        let mut inner = self.inner.borrow_mut();\n-        inner.functions.insert(id, instance);\n-        inner.function_cache.insert(instance, id);\n-        id\n-    }\n-\n-    pub fn get_fn(\n-        &self,\n-        id: interpret::AllocId,\n-    ) -> Option<Instance<'tcx>> {\n-        self.inner.borrow().functions.get(&id).cloned()\n-    }\n-\n-    pub fn get_alloc(\n-        &self,\n-        id: interpret::AllocId,\n-    ) -> Option<&'tcx interpret::Allocation> {\n-        self.inner.borrow().alloc_by_id.get(&id).cloned()\n-    }\n-\n-    pub fn cache_static(\n-        &self,\n-        static_id: DefId,\n-    ) -> interpret::AllocId {\n-        if let Some(alloc_id) = self.inner.borrow().static_cache.get(&static_id).cloned() {\n-            return alloc_id;\n-        }\n-        let alloc_id = self.reserve();\n-        let mut inner = self.inner.borrow_mut();\n-        inner.static_cache.insert(static_id, alloc_id);\n-        inner.statics.insert(alloc_id, static_id);\n-        alloc_id\n-    }\n-\n-    pub fn get_static(\n-        &self,\n-        ptr: interpret::AllocId,\n-    ) -> Option<DefId> {\n-        self.inner.borrow().statics.get(&ptr).cloned()\n-    }\n-\n-    pub fn intern_at_reserved(\n-        &self,\n-        id: interpret::AllocId,\n-        alloc: &'tcx interpret::Allocation,\n-    ) {\n-        if let Some(old) = self.inner.borrow_mut().alloc_by_id.insert(id, alloc) {\n-            bug!(\"tried to intern allocation at {}, but was already existing as {:#?}\", id, old);\n-        }\n-    }\n-\n-    /// obtains a new allocation ID that can be referenced but does not\n-    /// yet have an allocation backing it.\n-    pub fn reserve(\n-        &self,\n-    ) -> interpret::AllocId {\n-        let mut inner = self.inner.borrow_mut();\n-        let next = inner.next_id;\n-        inner.next_id.0 = inner.next_id.0\n-            .checked_add(1)\n-            .expect(\"You overflowed a u64 by incrementing by 1... \\\n-                     You've just earned yourself a free drink if we ever meet. \\\n-                     Seriously, how did you do that?!\");\n-        next\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Get the global TyCtxt.\n     #[inline]\n@@ -1108,9 +1000,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn intern_const_alloc(\n         self,\n-        alloc: interpret::Allocation,\n-    ) -> &'gcx interpret::Allocation {\n-        let allocs = &mut self.interpret_interner.inner.borrow_mut().allocs;\n+        alloc: Allocation,\n+    ) -> &'gcx Allocation {\n+        let allocs = &mut self.allocation_interner.borrow_mut();\n         if let Some(alloc) = allocs.get(&alloc) {\n             return alloc;\n         }\n@@ -1123,23 +1015,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Allocates a byte or string literal for `mir::interpret`\n-    pub fn allocate_cached(self, bytes: &[u8]) -> interpret::AllocId {\n-        // check whether we already allocated this literal or a constant with the same memory\n-        if let Some(&alloc_id) = self.interpret_interner.inner.borrow()\n-                                     .literal_alloc_cache.get(bytes) {\n-            return alloc_id;\n-        }\n+    pub fn allocate_bytes(self, bytes: &[u8]) -> interpret::AllocId {\n         // create an allocation that just contains these bytes\n         let alloc = interpret::Allocation::from_byte_aligned_bytes(bytes);\n         let alloc = self.intern_const_alloc(alloc);\n-\n-        // the next unique id\n-        let id = self.interpret_interner.reserve();\n-        // make the allocation identifiable\n-        self.interpret_interner.inner.borrow_mut().alloc_by_id.insert(id, alloc);\n-        // cache it for the future\n-        self.interpret_interner.inner.borrow_mut().literal_alloc_cache.insert(bytes.to_owned(), id);\n-        id\n+        self.alloc_map.lock().allocate(alloc)\n     }\n \n     pub fn intern_stability(self, stab: attr::Stability) -> &'gcx attr::Stability {\n@@ -1289,7 +1169,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             data_layout,\n             layout_interner: Lock::new(FxHashSet()),\n             stability_interner: Lock::new(FxHashSet()),\n-            interpret_interner: Default::default(),\n+            allocation_interner: Lock::new(FxHashSet()),\n+            alloc_map: Lock::new(interpret::AllocMap::new()),\n             tx_to_llvm_workers: Lock::new(tx),\n             output_filenames: Arc::new(output_filenames.clone()),\n         };\n@@ -2019,7 +1900,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         println!(\"Substs interner: #{}\", self.interners.substs.borrow().len());\n         println!(\"Region interner: #{}\", self.interners.region.borrow().len());\n         println!(\"Stability interner: #{}\", self.stability_interner.borrow().len());\n-        println!(\"Interpret interner: #{}\", self.interpret_interner.inner.borrow().allocs.len());\n+        println!(\"Allocation interner: #{}\", self.allocation_interner.borrow().len());\n         println!(\"Layout interner: #{}\", self.layout_interner.borrow().len());\n     }\n }"}, {"sha": "b975f9e5195864b866544af75552469255b8031a", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc", "patch": "@@ -78,7 +78,7 @@ pub use self::binding::BindingMode;\n pub use self::binding::BindingMode::*;\n \n pub use self::context::{TyCtxt, GlobalArenas, AllArenas, tls, keep_local};\n-pub use self::context::{Lift, TypeckTables, InterpretInterner};\n+pub use self::context::{Lift, TypeckTables};\n \n pub use self::instance::{Instance, InstanceDef};\n "}, {"sha": "d9797bf4985b442dfeafcb439015530f61850afd", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc", "patch": "@@ -1860,6 +1860,14 @@ impl<'tcx> Const<'tcx> {\n         }\n     }\n \n+    #[inline]\n+    pub fn to_byval_value(&self) -> Option<Value> {\n+        match self.val {\n+            ConstVal::Value(val) => val.to_byval_value(),\n+            _ => None,\n+        }\n+    }\n+\n     #[inline]\n     pub fn to_primval(&self) -> Option<PrimVal> {\n         match self.val {"}, {"sha": "07fb683a84f67699dd9974ad1e6905ab3c18f2c0", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 22, "deletions": 26, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc", "patch": "@@ -14,7 +14,7 @@ use rustc_mir::interpret::{read_target_uint, const_val_field};\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc::mir::interpret::{GlobalId, MemoryPointer, PrimVal, Allocation, ConstValue};\n+use rustc::mir::interpret::{GlobalId, MemoryPointer, PrimVal, Allocation, ConstValue, AllocType};\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, HasDataLayout, LayoutOf, Scalar, Size};\n use builder::Builder;\n@@ -44,38 +44,34 @@ pub fn primval_to_llvm(cx: &CodegenCx,\n             }\n         },\n         PrimVal::Ptr(ptr) => {\n-            if let Some(fn_instance) = cx.tcx.interpret_interner.get_fn(ptr.alloc_id) {\n-                callee::get_fn(cx, fn_instance)\n-            } else {\n-                let static_ = cx\n-                    .tcx\n-                    .interpret_interner\n-                    .get_static(ptr.alloc_id);\n-                let base_addr = if let Some(def_id) = static_ {\n-                    assert!(cx.tcx.is_static(def_id).is_some());\n-                    consts::get_static(cx, def_id)\n-                } else if let Some(alloc) = cx.tcx.interpret_interner\n-                                              .get_alloc(ptr.alloc_id) {\n+            let alloc_type = cx.tcx.alloc_map.lock().get(ptr.alloc_id);\n+            let base_addr = match alloc_type {\n+                Some(AllocType::Memory(alloc)) => {\n                     let init = const_alloc_to_llvm(cx, alloc);\n                     if alloc.runtime_mutability == Mutability::Mutable {\n                         consts::addr_of_mut(cx, init, alloc.align, \"byte_str\")\n                     } else {\n                         consts::addr_of(cx, init, alloc.align, \"byte_str\")\n                     }\n-                } else {\n-                    bug!(\"missing allocation {:?}\", ptr.alloc_id);\n-                };\n-\n-                let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n-                    consts::bitcast(base_addr, Type::i8p(cx)),\n-                    &C_usize(cx, ptr.offset.bytes()),\n-                    1,\n-                ) };\n-                if scalar.value != layout::Pointer {\n-                    unsafe { llvm::LLVMConstPtrToInt(llval, llty.to_ref()) }\n-                } else {\n-                    consts::bitcast(llval, llty)\n                 }\n+                Some(AllocType::Function(fn_instance)) => {\n+                    callee::get_fn(cx, fn_instance)\n+                }\n+                Some(AllocType::Static(def_id)) => {\n+                    assert!(cx.tcx.is_static(def_id).is_some());\n+                    consts::get_static(cx, def_id)\n+                }\n+                None => bug!(\"missing allocation {:?}\", ptr.alloc_id),\n+            };\n+            let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n+                consts::bitcast(base_addr, Type::i8p(cx)),\n+                &C_usize(cx, ptr.offset.bytes()),\n+                1,\n+            ) };\n+            if scalar.value != layout::Pointer {\n+                unsafe { llvm::LLVMConstPtrToInt(llval, llty.to_ref()) }\n+            } else {\n+                consts::bitcast(llval, llty)\n             }\n         }\n     }"}, {"sha": "390b82af48a029ad7fc09a21ed3e6534a43dbb17", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc", "patch": "@@ -181,15 +181,15 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         let lit = match *lit {\n             LitKind::Str(ref s, _) => {\n                 let s = s.as_str();\n-                let id = self.tcx.allocate_cached(s.as_bytes());\n+                let id = self.tcx.allocate_bytes(s.as_bytes());\n                 let ptr = MemoryPointer::new(id, Size::from_bytes(0));\n                 ConstValue::ByValPair(\n                     PrimVal::Ptr(ptr),\n                     PrimVal::from_u128(s.len() as u128),\n                 )\n             },\n             LitKind::ByteStr(ref data) => {\n-                let id = self.tcx.allocate_cached(data);\n+                let id = self.tcx.allocate_bytes(data);\n                 let ptr = MemoryPointer::new(id, Size::from_bytes(0));\n                 ConstValue::ByVal(PrimVal::Ptr(ptr))\n             },"}, {"sha": "70e8cd336a31c644eb1e805c3365cd78762f068f", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc", "patch": "@@ -187,10 +187,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n                             .and_then(|t| t.ty.builtin_index())\n                             .map_or(false, |t| t == tcx.types.u8);\n                         assert!(is_array_ptr);\n-                        let alloc = tcx\n-                            .interpret_interner\n-                            .get_alloc(ptr.alloc_id)\n-                            .unwrap();\n+                        let alloc = tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n                         assert_eq!(ptr.offset.bytes(), 0);\n                         // FIXME: check length\n                         alloc.bytes.iter().map(|b| {\n@@ -558,10 +555,7 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n                         .and_then(|t| t.ty.builtin_index())\n                         .map_or(false, |t| t == cx.tcx.types.u8);\n                     if is_array_ptr {\n-                        let alloc = cx.tcx\n-                            .interpret_interner\n-                            .get_alloc(ptr.alloc_id)\n-                            .unwrap();\n+                        let alloc = cx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n                         max_fixed_len = cmp::max(max_fixed_len, alloc.bytes.len() as u64);\n                     }\n                 }\n@@ -945,12 +939,7 @@ fn slice_pat_covered_by_constructor<'tcx>(\n                     .and_then(|t| t.ty.builtin_index())\n                     .map_or(false, |t| t == tcx.types.u8);\n                 assert!(is_array_ptr);\n-                tcx\n-                    .interpret_interner\n-                    .get_alloc(ptr.alloc_id)\n-                    .unwrap()\n-                    .bytes\n-                    .as_ref()\n+                tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id).bytes.as_ref()\n             } else {\n                 bug!()\n             }\n@@ -1088,9 +1077,9 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                             .map_or(false, |t| t == cx.tcx.types.u8);\n                         assert!(is_array_ptr);\n                         let data_len = cx.tcx\n-                            .interpret_interner\n-                            .get_alloc(ptr.alloc_id)\n-                            .unwrap()\n+                            .alloc_map\n+                            .lock()\n+                            .unwrap_memory(ptr.alloc_id)\n                             .bytes\n                             .len();\n                         if wild_patterns.len() == data_len {"}, {"sha": "95ff5c24ecc00d779ea88147f6f931ed1aa05e8a", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 48, "deletions": 9, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc", "patch": "@@ -20,7 +20,7 @@ use interpret::{const_val_field, const_variant_index, self};\n \n use rustc::middle::const_val::ConstVal;\n use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n-use rustc::mir::interpret::{PrimVal, GlobalId, ConstValue};\n+use rustc::mir::interpret::{PrimVal, GlobalId, ConstValue, Value};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n use rustc::ty::layout::Size;\n use rustc::ty::subst::{Substs, Kind};\n@@ -1040,11 +1040,27 @@ pub fn compare_const_vals<'a, 'tcx>(\n     ty: Ty<'tcx>,\n ) -> Option<Ordering> {\n     trace!(\"compare_const_vals: {:?}, {:?}\", a, b);\n+\n+    let from_bool = |v: bool| {\n+        if v {\n+            Some(Ordering::Equal)\n+        } else {\n+            None\n+        }\n+    };\n+\n+    let fallback = || from_bool(a == b);\n+\n+    // Use the fallback if any type differs\n+    if a.ty != b.ty || a.ty != ty {\n+        return fallback();\n+    }\n+\n     // FIXME: This should use assert_bits(ty) instead of use_bits\n     // but triggers possibly bugs due to mismatching of arrays and slices\n     if let (Some(a), Some(b)) = (a.to_bits(ty), b.to_bits(ty)) {\n         use ::rustc_apfloat::Float;\n-        match ty.sty {\n+        return match ty.sty {\n             ty::TyFloat(ast::FloatTy::F32) => {\n                 let l = ::rustc_apfloat::ieee::Single::from_bits(a);\n                 let r = ::rustc_apfloat::ieee::Single::from_bits(b);\n@@ -1062,13 +1078,36 @@ pub fn compare_const_vals<'a, 'tcx>(\n             },\n             _ => Some(a.cmp(&b)),\n         }\n-    } else {\n-        if a == b {\n-            Some(Ordering::Equal)\n-        } else {\n-            None\n+    }\n+\n+    if let ty::TyRef(_, rty, _) = ty.sty {\n+        if let ty::TyStr = rty.sty {\n+            match (a.to_byval_value(), b.to_byval_value()) {\n+                (\n+                    Some(Value::ByValPair(\n+                        PrimVal::Ptr(ptr_a),\n+                        PrimVal::Bytes(size_a))\n+                    ),\n+                    Some(Value::ByValPair(\n+                        PrimVal::Ptr(ptr_b),\n+                        PrimVal::Bytes(size_b))\n+                    )\n+                ) if size_a == size_b => {\n+                    if ptr_a.offset == Size::from_bytes(0) && ptr_b.offset == Size::from_bytes(0) {\n+                        let map = tcx.alloc_map.lock();\n+                        let alloc_a = map.unwrap_memory(ptr_a.alloc_id);\n+                        let alloc_b = map.unwrap_memory(ptr_b.alloc_id);\n+                        if alloc_a.bytes.len() as u64 == size_a as u64 {\n+                            return from_bool(alloc_a == alloc_b);\n+                        }\n+                    }\n+                }\n+                _ => (),\n+            }\n         }\n     }\n+\n+    fallback()\n }\n \n // FIXME: Combine with rustc_mir::hair::cx::const_eval_literal\n@@ -1083,15 +1122,15 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n     let lit = match *lit {\n         LitKind::Str(ref s, _) => {\n             let s = s.as_str();\n-            let id = tcx.allocate_cached(s.as_bytes());\n+            let id = tcx.allocate_bytes(s.as_bytes());\n             let ptr = MemoryPointer::new(id, Size::from_bytes(0));\n             ConstValue::ByValPair(\n                 PrimVal::Ptr(ptr),\n                 PrimVal::from_u128(s.len() as u128),\n             )\n         },\n         LitKind::ByteStr(ref data) => {\n-            let id = tcx.allocate_cached(data);\n+            let id = tcx.allocate_bytes(data);\n             let ptr = MemoryPointer::new(id, Size::from_bytes(0));\n             ConstValue::ByVal(PrimVal::Ptr(ptr))\n         },"}, {"sha": "1b4cde2f6ca8f0effafa2b480882b5ff92c80f96", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc", "patch": "@@ -377,8 +377,9 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n     ) -> EvalResult<'tcx, AllocId> {\n         Ok(ecx\n             .tcx\n-            .interpret_interner\n-            .cache_static(cid.instance.def_id()))\n+            .alloc_map\n+            .lock()\n+            .intern_static(cid.instance.def_id()))\n     }\n \n     fn box_alloc<'a>("}, {"sha": "15103b78ca8ff67977bd41514253a69a682f0c87", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc", "patch": "@@ -229,7 +229,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     }\n \n     pub fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n-        let ptr = self.memory.allocate_cached(s.as_bytes());\n+        let ptr = self.memory.allocate_bytes(s.as_bytes());\n         Ok(Value::ByValPair(\n             PrimVal::Ptr(ptr),\n             PrimVal::from_u128(s.len() as u128),\n@@ -1015,8 +1015,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         if self.tcx.is_static(gid.instance.def_id()).is_some() {\n             let alloc_id = self\n                 .tcx\n-                .interpret_interner\n-                .cache_static(gid.instance.def_id());\n+                .alloc_map\n+                .lock()\n+                .intern_static(gid.instance.def_id());\n             let layout = self.layout_of(ty)?;\n             let ptr = MemoryPointer::new(alloc_id, Size::from_bytes(0));\n             return Ok(Value::ByRef(ptr.into(), layout.align))"}, {"sha": "b2a6e2b452721fb8158eb52abfc461ea390d5a80", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 47, "deletions": 45, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc", "patch": "@@ -11,7 +11,7 @@ use rustc::middle::const_val::{ConstVal, ErrKind};\n \n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc::mir::interpret::{MemoryPointer, AllocId, Allocation, AccessKind, Value, Pointer,\n-                            EvalResult, PrimVal, EvalErrorKind, GlobalId};\n+                            EvalResult, PrimVal, EvalErrorKind, GlobalId, AllocType};\n pub use rustc::mir::interpret::{write_target_uint, write_target_int, read_target_uint};\n \n use super::{EvalContext, Machine};\n@@ -72,12 +72,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     }\n \n     pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> MemoryPointer {\n-        let id = self.tcx.interpret_interner.create_fn_alloc(instance);\n+        let id = self.tcx.alloc_map.lock().create_fn_alloc(instance);\n         MemoryPointer::new(id, Size::from_bytes(0))\n     }\n \n-    pub fn allocate_cached(&mut self, bytes: &[u8]) -> MemoryPointer {\n-        let id = self.tcx.allocate_cached(bytes);\n+    pub fn allocate_bytes(&mut self, bytes: &[u8]) -> MemoryPointer {\n+        let id = self.tcx.allocate_bytes(bytes);\n         MemoryPointer::new(id, Size::from_bytes(0))\n     }\n \n@@ -87,7 +87,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         alloc: Allocation,\n         kind: Option<MemoryKind<M::MemoryKinds>>,\n     ) -> EvalResult<'tcx, AllocId> {\n-        let id = self.tcx.interpret_interner.reserve();\n+        let id = self.tcx.alloc_map.lock().reserve();\n         M::add_lock(self, id);\n         match kind {\n             Some(kind @ MemoryKind::Stack) |\n@@ -177,19 +177,20 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                     \"uninitializedstatic\".to_string(),\n                     format!(\"{:?}\", kind),\n                 ))\n-            } else if self.tcx.interpret_interner.get_fn(ptr.alloc_id).is_some() {\n-                return err!(DeallocatedWrongMemoryKind(\n-                    \"function\".to_string(),\n-                    format!(\"{:?}\", kind),\n-                ))\n-            } else if self.tcx.interpret_interner.get_alloc(ptr.alloc_id).is_some() {\n-                return err!(DeallocatedWrongMemoryKind(\n-                    \"static\".to_string(),\n-                    format!(\"{:?}\", kind),\n-                ))\n             } else {\n-                return err!(DoubleFree)\n-            },\n+                return match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n+                    Some(AllocType::Function(..)) => err!(DeallocatedWrongMemoryKind(\n+                        \"function\".to_string(),\n+                        format!(\"{:?}\", kind),\n+                    )),\n+                    Some(AllocType::Static(..)) |\n+                    Some(AllocType::Memory(..)) => err!(DeallocatedWrongMemoryKind(\n+                        \"static\".to_string(),\n+                        format!(\"{:?}\", kind),\n+                    )),\n+                    None => err!(DoubleFree)\n+                }\n+            }\n         };\n \n         let alloc_kind = self.alloc_kind.remove(&ptr.alloc_id).expect(\"alloc_map out of sync with alloc_kind\");\n@@ -312,19 +313,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 Some(alloc) => Ok(alloc),\n                 None => {\n                     // static alloc?\n-                    if let Some(a) = self.tcx.interpret_interner.get_alloc(id) {\n-                        return Ok(a);\n+                    match self.tcx.alloc_map.lock().get(id) {\n+                        Some(AllocType::Memory(mem)) => Ok(mem),\n+                        Some(AllocType::Function(..)) => {\n+                            Err(EvalErrorKind::DerefFunctionPointer.into())\n+                        }\n+                        Some(AllocType::Static(did)) => {\n+                            self.const_eval_static(did)\n+                        }\n+                        None => Err(EvalErrorKind::DanglingPointerDeref.into()),\n                     }\n-                    // static variable?\n-                    if let Some(did) = self.tcx.interpret_interner.get_static(id) {\n-                        return self.const_eval_static(did);\n-                    }\n-                    // otherwise return an error\n-                    Err(if self.tcx.interpret_interner.get_fn(id).is_some() {\n-                        EvalErrorKind::DerefFunctionPointer.into()\n-                    } else {\n-                        EvalErrorKind::DanglingPointerDeref.into()\n-                    })\n                 },\n             },\n         }\n@@ -342,12 +340,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 Some(alloc) => Ok(alloc),\n                 None => {\n                     // no alloc or immutable alloc? produce an error\n-                    if self.tcx.interpret_interner.get_alloc(id).is_some() {\n-                        err!(ModifiedConstantMemory)\n-                    } else if self.tcx.interpret_interner.get_fn(id).is_some() {\n-                        err!(DerefFunctionPointer)\n-                    } else {\n-                        err!(DanglingPointerDeref)\n+                    match self.tcx.alloc_map.lock().get(id) {\n+                        Some(AllocType::Memory(..)) |\n+                        Some(AllocType::Static(..)) => err!(ModifiedConstantMemory),\n+                        Some(AllocType::Function(..)) => err!(DerefFunctionPointer),\n+                        None => err!(DanglingPointerDeref),\n                     }\n                 },\n             },\n@@ -359,10 +356,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             return err!(InvalidFunctionPointer);\n         }\n         debug!(\"reading fn ptr: {}\", ptr.alloc_id);\n-        self.tcx\n-            .interpret_interner\n-            .get_fn(ptr.alloc_id)\n-            .ok_or(EvalErrorKind::ExecuteMemory.into())\n+        match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n+            Some(AllocType::Function(instance)) => Ok(instance),\n+            _ => Err(EvalErrorKind::ExecuteMemory.into()),\n+        }\n     }\n \n     pub fn get_alloc_kind(&self, id: AllocId) -> Option<MemoryKind<M::MemoryKinds>> {\n@@ -405,15 +402,20 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                         Some(a) => (a, \" (static in the process of initialization)\".to_owned()),\n                         None => {\n                             // static alloc?\n-                            match self.tcx.interpret_interner.get_alloc(id) {\n-                                Some(a) => (a, \"(immutable)\".to_owned()),\n-                                None => if let Some(func) = self.tcx.interpret_interner.get_fn(id) {\n+                            match self.tcx.alloc_map.lock().get(id) {\n+                                Some(AllocType::Memory(a)) => (a, \"(immutable)\".to_owned()),\n+                                Some(AllocType::Function(func)) => {\n                                     trace!(\"{} {}\", msg, func);\n                                     continue;\n-                                } else {\n+                                }\n+                                Some(AllocType::Static(did)) => {\n+                                    trace!(\"{} {:?}\", msg, did);\n+                                    continue;\n+                                }\n+                                None => {\n                                     trace!(\"{} (deallocated)\", msg);\n                                     continue;\n-                                },\n+                                }\n                             }\n                         },\n                     },\n@@ -579,7 +581,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             // ensure llvm knows not to put this into immutable memroy\n             alloc.runtime_mutability = mutability;\n             let alloc = self.tcx.intern_const_alloc(alloc);\n-            self.tcx.interpret_interner.intern_at_reserved(alloc_id, alloc);\n+            self.tcx.alloc_map.lock().set_id_memory(alloc_id, alloc);\n             // recurse into inner allocations\n             for &alloc in alloc.relocations.values() {\n                 self.mark_inner_allocation_initialized(alloc, mutability)?;"}, {"sha": "b181a281ef4e8585b1bfd351e1b49cb7e28eb2aa", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc", "patch": "@@ -203,7 +203,7 @@ use rustc::session::config;\n use rustc::mir::{self, Location, Promoted};\n use rustc::mir::visit::Visitor as MirVisitor;\n use rustc::mir::mono::MonoItem;\n-use rustc::mir::interpret::{PrimVal, GlobalId};\n+use rustc::mir::interpret::{PrimVal, GlobalId, AllocType};\n \n use monomorphize::{self, Instance};\n use rustc::util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n@@ -1146,24 +1146,28 @@ fn collect_miri<'a, 'tcx>(\n     alloc_id: AllocId,\n     output: &mut Vec<MonoItem<'tcx>>,\n ) {\n-    if let Some(did) = tcx.interpret_interner.get_static(alloc_id) {\n-        let instance = Instance::mono(tcx, did);\n-        if should_monomorphize_locally(tcx, &instance) {\n-            trace!(\"collecting static {:?}\", did);\n-            output.push(MonoItem::Static(did));\n-        }\n-    } else if let Some(alloc) = tcx.interpret_interner.get_alloc(alloc_id) {\n-        trace!(\"collecting {:?} with {:#?}\", alloc_id, alloc);\n-        for &inner in alloc.relocations.values() {\n-            collect_miri(tcx, inner, output);\n+    let alloc_type = tcx.alloc_map.lock().get(alloc_id);\n+    match alloc_type {\n+        Some(AllocType::Static(did)) => {\n+            let instance = Instance::mono(tcx, did);\n+            if should_monomorphize_locally(tcx, &instance) {\n+                trace!(\"collecting static {:?}\", did);\n+                output.push(MonoItem::Static(did));\n+            }\n         }\n-    } else if let Some(fn_instance) = tcx.interpret_interner.get_fn(alloc_id) {\n-        if should_monomorphize_locally(tcx, &fn_instance) {\n-            trace!(\"collecting {:?} with {:#?}\", alloc_id, fn_instance);\n-            output.push(create_fn_mono_item(fn_instance));\n+        Some(AllocType::Memory(alloc)) => {\n+            trace!(\"collecting {:?} with {:#?}\", alloc_id, alloc);\n+            for &inner in alloc.relocations.values() {\n+                collect_miri(tcx, inner, output);\n+            }\n+        },\n+        Some(AllocType::Function(fn_instance)) => {\n+            if should_monomorphize_locally(tcx, &fn_instance) {\n+                trace!(\"collecting {:?} with {:#?}\", alloc_id, fn_instance);\n+                output.push(create_fn_mono_item(fn_instance));\n+            }\n         }\n-    } else {\n-        bug!(\"alloc id without corresponding allocation: {}\", alloc_id);\n+        None => bug!(\"alloc id without corresponding allocation: {}\", alloc_id),\n     }\n }\n "}]}