{"sha": "810254b31e0135d1f2dfe9e3717c3c0f69676a86", "node_id": "C_kwDOAAsO6NoAKDgxMDI1NGIzMWUwMTM1ZDFmMmRmZTllMzcxN2MzYzBmNjk2NzZhODY", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-06-18T13:50:37Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-06-20T19:09:55Z"}, "message": "Improve code readability and documentation", "tree": {"sha": "8ef1b0a995a5191811081a36f6eccbfa0a7c3a50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ef1b0a995a5191811081a36f6eccbfa0a7c3a50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/810254b31e0135d1f2dfe9e3717c3c0f69676a86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/810254b31e0135d1f2dfe9e3717c3c0f69676a86", "html_url": "https://github.com/rust-lang/rust/commit/810254b31e0135d1f2dfe9e3717c3c0f69676a86", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/810254b31e0135d1f2dfe9e3717c3c0f69676a86/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dda980dec07fb7093a153180f19f967ce55fe1f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/dda980dec07fb7093a153180f19f967ce55fe1f9", "html_url": "https://github.com/rust-lang/rust/commit/dda980dec07fb7093a153180f19f967ce55fe1f9"}], "stats": {"total": 148, "additions": 94, "deletions": 54}, "files": [{"sha": "11ab3a3f931c3df562ec737dc33ce014d630b37b", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 54, "deletions": 26, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/810254b31e0135d1f2dfe9e3717c3c0f69676a86/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/810254b31e0135d1f2dfe9e3717c3c0f69676a86/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=810254b31e0135d1f2dfe9e3717c3c0f69676a86", "patch": "@@ -103,7 +103,7 @@ fn write_code(\n ) {\n     // This replace allows to fix how the code source with DOS backline characters is displayed.\n     let src = src.replace(\"\\r\\n\", \"\\n\");\n-    let mut closing_tag = \"\";\n+    let mut closing_tags: Vec<&'static str> = Vec::new();\n     Classifier::new(\n         &src,\n         edition,\n@@ -113,8 +113,12 @@ fn write_code(\n     .highlight(&mut |highlight| {\n         match highlight {\n             Highlight::Token { text, class } => string(out, Escape(text), class, &href_context),\n-            Highlight::EnterSpan { class } => closing_tag = enter_span(out, class, &href_context),\n-            Highlight::ExitSpan => exit_span(out, &closing_tag),\n+            Highlight::EnterSpan { class } => {\n+                closing_tags.push(enter_span(out, class, &href_context))\n+            }\n+            Highlight::ExitSpan => {\n+                exit_span(out, closing_tags.pop().expect(\"ExitSpan without EnterSpan\"))\n+            }\n         };\n     });\n }\n@@ -682,8 +686,10 @@ fn enter_span(\n     klass: Class,\n     href_context: &Option<HrefContext<'_, '_, '_>>,\n ) -> &'static str {\n-    string_without_closing_tag(out, \"\", Some(klass), href_context)\n-        .expect(\"no closing tag to close wrapper...\")\n+    string_without_closing_tag(out, \"\", Some(klass), href_context).expect(\n+        \"internal error: enter_span was called with Some(klass) but did not return a \\\n+            closing HTML tag\",\n+    )\n }\n \n /// Called at the end of a span of highlighted text.\n@@ -718,6 +724,15 @@ fn string<T: Display>(\n     }\n }\n \n+/// This function writes `text` into `out` with some modifications depending on `klass`:\n+///\n+/// * If `klass` is `None`, `text` is written into `out` with no modification.\n+/// * If `klass` is `Some` but `klass.get_span()` is `None`, it writes the text wrapped in a\n+///   `<span>` with the provided `klass`.\n+/// * If `klass` is `Some` and has a [`rustc_span::Span`], it then tries to generate a link (`<a>`\n+///   element) by retrieving the link information from the `span_correspondance_map` that was filled\n+///   in `span_map.rs::collect_spans_and_sources`. If it cannot retrieve the information, then it's\n+///   the same as the second point (`klass` is `Some` but doesn't have a [`rustc_span::Span`]).\n fn string_without_closing_tag<T: Display>(\n     out: &mut Buffer,\n     text: T,\n@@ -799,42 +814,55 @@ fn string_without_closing_tag<T: Display>(\n     Some(\"</span>\")\n }\n \n-/// This function is to get the external macro path because they are not in the cache used n\n+/// This function is to get the external macro path because they are not in the cache used in\n /// `href_with_root_path`.\n fn generate_macro_def_id_path(href_context: &HrefContext<'_, '_, '_>, def_id: DefId) -> String {\n     let tcx = href_context.context.shared.tcx;\n     let crate_name = tcx.crate_name(def_id.krate).to_string();\n-    let cache = &href_context.context.cache();\n+    let cache = href_context.context.cache();\n \n     let relative = tcx.def_path(def_id).data.into_iter().filter_map(|elem| {\n         // extern blocks have an empty name\n         let s = elem.data.to_string();\n         if !s.is_empty() { Some(s) } else { None }\n     });\n-    // Check to see if it is a macro 2.0 or built-in macro\n-    let mut path = if matches!(\n-        CStore::from_tcx(tcx).load_macro_untracked(def_id, tcx.sess),\n-        LoadedMacro::MacroDef(def, _)\n-            if matches!(&def.kind, ast::ItemKind::MacroDef(ast_def)\n-                if !ast_def.macro_rules)\n-    ) {\n+    // Check to see if it is a macro 2.0 or built-in macro.\n+    // More information in <https://rust-lang.github.io/rfcs/1584-macros.html>.\n+    let is_macro_2 = match CStore::from_tcx(tcx).load_macro_untracked(def_id, tcx.sess) {\n+        LoadedMacro::MacroDef(def, _) => {\n+            // If `ast_def.macro_rules` is `true`, then it's not a macro 2.0.\n+            matches!(&def.kind, ast::ItemKind::MacroDef(ast_def) if !ast_def.macro_rules)\n+        }\n+        _ => false,\n+    };\n+\n+    let mut path = if is_macro_2 {\n         once(crate_name.clone()).chain(relative).collect()\n     } else {\n-        vec![crate_name.clone(), relative.last().expect(\"relative was empty\")]\n+        vec![crate_name.clone(), relative.last().unwrap()]\n     };\n+    if path.len() < 2 {\n+        // The minimum we can have is the crate name followed by the macro name. If shorter, then\n+        // it means that that `relative` was empty, which is an error.\n+        panic!(\"macro path cannot be empty!\");\n+    }\n \n-    let url_parts = match cache.extern_locations[&def_id.krate] {\n-        ExternalLocation::Remote(ref s) => vec![s.trim_end_matches('/')],\n-        ExternalLocation::Local => vec![href_context.root_path.trim_end_matches('/'), &crate_name],\n-        ExternalLocation::Unknown => panic!(\"unknown crate\"),\n-    };\n+    if let Some(last) = path.last_mut() {\n+        *last = format!(\"macro.{}.html\", last);\n+    }\n \n-    let last = path.pop().unwrap();\n-    let last = format!(\"macro.{}.html\", last);\n-    if path.is_empty() {\n-        format!(\"{}/{}\", url_parts.join(\"/\"), last)\n-    } else {\n-        format!(\"{}/{}/{}\", url_parts.join(\"/\"), path.join(\"/\"), last)\n+    match cache.extern_locations[&def_id.krate] {\n+        ExternalLocation::Remote(ref s) => {\n+            // `ExternalLocation::Remote` always end with a `/`.\n+            format!(\"{}{}\", s, path.join(\"/\"))\n+        }\n+        ExternalLocation::Local => {\n+            // `href_context.root_path` always end with a `/`.\n+            format!(\"{}{}/{}\", href_context.root_path, crate_name, path.join(\"/\"))\n+        }\n+        ExternalLocation::Unknown => {\n+            panic!(\"crate {} not in cache when linkifying macros\", crate_name)\n+        }\n     }\n }\n "}, {"sha": "34d590fb2448c553a7f3f271c1e1f81dd8538ea8", "filename": "src/librustdoc/html/render/span_map.rs", "status": "modified", "additions": 40, "deletions": 28, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/810254b31e0135d1f2dfe9e3717c3c0f69676a86/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/810254b31e0135d1f2dfe9e3717c3c0f69676a86/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs?ref=810254b31e0135d1f2dfe9e3717c3c0f69676a86", "patch": "@@ -88,36 +88,48 @@ impl<'tcx> SpanMapVisitor<'tcx> {\n \n     /// Adds the macro call into the span map. Returns `true` if the `span` was inside a macro\n     /// expansion, whether or not it was added to the span map.\n+    ///\n+    /// The idea for the macro support is to check if the current `Span` comes from expansion. If\n+    /// so, we loop until we find the macro definition by using `outer_expn_data` in a loop.\n+    /// Finally, we get the information about the macro itself (`span` if \"local\", `DefId`\n+    /// otherwise) and store it inside the span map.\n     fn handle_macro(&mut self, span: Span) -> bool {\n-        if span.from_expansion() {\n-            let mut data = span.ctxt().outer_expn_data();\n-            let mut call_site = data.call_site;\n-            while call_site.from_expansion() {\n-                data = call_site.ctxt().outer_expn_data();\n-                call_site = data.call_site;\n-            }\n+        if !span.from_expansion() {\n+            return false;\n+        }\n+        // So if the `span` comes from a macro expansion, we need to get the original\n+        // macro's `DefId`.\n+        let mut data = span.ctxt().outer_expn_data();\n+        let mut call_site = data.call_site;\n+        // Macros can expand to code containing macros, which will in turn be expanded, etc.\n+        // So the idea here is to \"go up\" until we're back to code that was generated from\n+        // macro expansion so that we can get the `DefId` of the original macro that was at the\n+        // origin of this expansion.\n+        while call_site.from_expansion() {\n+            data = call_site.ctxt().outer_expn_data();\n+            call_site = data.call_site;\n+        }\n \n-            if let ExpnKind::Macro(MacroKind::Bang, macro_name) = data.kind {\n-                let link_from_src = if let Some(macro_def_id) = data.macro_def_id {\n-                    if macro_def_id.is_local() {\n-                        LinkFromSrc::Local(clean::Span::new(data.def_site))\n-                    } else {\n-                        LinkFromSrc::External(macro_def_id)\n-                    }\n-                } else {\n-                    return true;\n-                };\n-                let new_span = data.call_site;\n-                let macro_name = macro_name.as_str();\n-                // The \"call_site\" includes the whole macro with its \"arguments\". We only want\n-                // the macro name.\n-                let new_span = new_span.with_hi(new_span.lo() + BytePos(macro_name.len() as u32));\n-                self.matches.insert(new_span, link_from_src);\n+        let macro_name = match data.kind {\n+            ExpnKind::Macro(MacroKind::Bang, macro_name) => macro_name,\n+            // Even though we don't handle this kind of macro, this `data` still comes from\n+            // expansion so we return `true` so we don't go any deeper in this code.\n+            _ => return true,\n+        };\n+        let link_from_src = match data.macro_def_id {\n+            Some(macro_def_id) if macro_def_id.is_local() => {\n+                LinkFromSrc::Local(clean::Span::new(data.def_site))\n             }\n-            true\n-        } else {\n-            false\n-        }\n+            Some(macro_def_id) => LinkFromSrc::External(macro_def_id),\n+            None => return true,\n+        };\n+        let new_span = data.call_site;\n+        let macro_name = macro_name.as_str();\n+        // The \"call_site\" includes the whole macro with its \"arguments\". We only want\n+        // the macro name.\n+        let new_span = new_span.with_hi(new_span.lo() + BytePos(macro_name.len() as u32));\n+        self.matches.insert(new_span, link_from_src);\n+        true\n     }\n }\n \n@@ -175,7 +187,7 @@ impl<'tcx> Visitor<'tcx> for SpanMapVisitor<'tcx> {\n                 }\n             }\n         } else if self.handle_macro(expr.span) {\n-            // We don't want to deeper into the macro.\n+            // We don't want to go deeper into the macro.\n             return;\n         }\n         intravisit::walk_expr(self, expr);"}]}