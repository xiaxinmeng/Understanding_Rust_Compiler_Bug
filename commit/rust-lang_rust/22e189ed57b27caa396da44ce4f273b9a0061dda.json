{"sha": "22e189ed57b27caa396da44ce4f273b9a0061dda", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyZTE4OWVkNTdiMjdjYWEzOTZkYTQ0Y2U0ZjI3M2I5YTAwNjFkZGE=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-07T21:23:58Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-08T02:24:16Z"}, "message": "Add and use an arena for `NameBinding`s", "tree": {"sha": "b66e19bc3abed88910c0df10b4d14a473f9d679b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b66e19bc3abed88910c0df10b4d14a473f9d679b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22e189ed57b27caa396da44ce4f273b9a0061dda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22e189ed57b27caa396da44ce4f273b9a0061dda", "html_url": "https://github.com/rust-lang/rust/commit/22e189ed57b27caa396da44ce4f273b9a0061dda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22e189ed57b27caa396da44ce4f273b9a0061dda/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7366d105cb29100c6522619abbabe57777240778", "url": "https://api.github.com/repos/rust-lang/rust/commits/7366d105cb29100c6522619abbabe57777240778", "html_url": "https://github.com/rust-lang/rust/commit/7366d105cb29100c6522619abbabe57777240778"}], "stats": {"total": 88, "additions": 48, "deletions": 40}, "files": [{"sha": "baed8bb9919ef4bcebf70d8b2072c14b99eaf4d6", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/22e189ed57b27caa396da44ce4f273b9a0061dda/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e189ed57b27caa396da44ce4f273b9a0061dda/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=22e189ed57b27caa396da44ce4f273b9a0061dda", "patch": "@@ -101,14 +101,14 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     fn try_define<T>(&self, parent: Module<'b>, name: Name, ns: Namespace, def: T)\n         where T: ToNameBinding<'b>\n     {\n-        parent.try_define_child(name, ns, def.to_name_binding());\n+        parent.try_define_child(name, ns, self.new_name_binding(def.to_name_binding()));\n     }\n \n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n     /// otherwise, reports an error.\n     fn define<T: ToNameBinding<'b>>(&self, parent: Module<'b>, name: Name, ns: Namespace, def: T) {\n-        let binding = def.to_name_binding();\n-        let old_binding = match parent.try_define_child(name, ns, binding.clone()) {\n+        let binding = self.new_name_binding(def.to_name_binding());\n+        let old_binding = match parent.try_define_child(name, ns, binding) {\n             Some(old_binding) => old_binding,\n             None => return,\n         };"}, {"sha": "528209d5854ce89591227422d233cc722a1d38bf", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/22e189ed57b27caa396da44ce4f273b9a0061dda/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e189ed57b27caa396da44ce4f273b9a0061dda/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=22e189ed57b27caa396da44ce4f273b9a0061dda", "patch": "@@ -794,7 +794,7 @@ pub struct ModuleS<'a> {\n     is_public: bool,\n     is_extern_crate: bool,\n \n-    children: RefCell<HashMap<(Name, Namespace), NameBinding<'a>>>,\n+    children: RefCell<HashMap<(Name, Namespace), &'a NameBinding<'a>>>,\n     imports: RefCell<Vec<ImportDirective>>,\n \n     // The anonymous children of this node. Anonymous children are pseudo-\n@@ -855,21 +855,21 @@ impl<'a> ModuleS<'a> {\n         }\n     }\n \n-    fn get_child(&self, name: Name, ns: Namespace) -> Option<NameBinding<'a>> {\n+    fn get_child(&self, name: Name, ns: Namespace) -> Option<&'a NameBinding<'a>> {\n         self.children.borrow().get(&(name, ns)).cloned()\n     }\n \n     // If the name is not yet defined, define the name and return None.\n     // Otherwise, return the existing definition.\n-    fn try_define_child(&self, name: Name, ns: Namespace, binding: NameBinding<'a>)\n-                        -> Option<NameBinding<'a>> {\n+    fn try_define_child(&self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>)\n+                        -> Option<&'a NameBinding<'a>> {\n         match self.children.borrow_mut().entry((name, ns)) {\n             hash_map::Entry::Vacant(entry) => { entry.insert(binding); None }\n-            hash_map::Entry::Occupied(entry) => { Some(entry.get().clone()) },\n+            hash_map::Entry::Occupied(entry) => { Some(entry.get()) },\n         }\n     }\n \n-    fn for_each_local_child<F: FnMut(Name, Namespace, &NameBinding<'a>)>(&self, mut f: F) {\n+    fn for_each_local_child<F: FnMut(Name, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n         for (&(name, ns), name_binding) in self.children.borrow().iter() {\n             if !name_binding.is_extern_crate() {\n                 f(name, ns, name_binding)\n@@ -1112,6 +1112,7 @@ pub struct Resolver<'a, 'tcx: 'a> {\n \n pub struct ResolverArenas<'a> {\n     modules: arena::TypedArena<ModuleS<'a>>,\n+    name_bindings: arena::TypedArena<NameBinding<'a>>,\n }\n \n #[derive(PartialEq)]\n@@ -1177,6 +1178,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn arenas() -> ResolverArenas<'a> {\n         ResolverArenas {\n             modules: arena::TypedArena::new(),\n+            name_bindings: arena::TypedArena::new(),\n         }\n     }\n \n@@ -1188,6 +1190,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         self.arenas.modules.alloc(ModuleS::new(parent_link, def, external, is_public))\n     }\n \n+    fn new_name_binding(&self, name_binding: NameBinding<'a>) -> &'a NameBinding<'a> {\n+        self.arenas.name_bindings.alloc(name_binding)\n+    }\n+\n     fn new_extern_crate_module(&self, parent_link: ParentLink<'a>, def: Def) -> Module<'a> {\n         let mut module = ModuleS::new(parent_link, Some(def), false, true);\n         module.is_extern_crate = true;\n@@ -1234,7 +1240,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                      -> ResolveResult<(Module<'a>, LastPrivate)> {\n         fn search_parent_externals<'a>(needle: Name, module: Module<'a>) -> Option<Module<'a>> {\n             match module.get_child(needle, TypeNS) {\n-                Some(ref binding) if binding.is_extern_crate() => Some(module),\n+                Some(binding) if binding.is_extern_crate() => Some(module),\n                 _ => match module.parent_link {\n                     ModuleParentLink(ref parent, _) => {\n                         search_parent_externals(needle, parent)\n@@ -1424,7 +1430,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                      name: Name,\n                                      namespace: Namespace,\n                                      record_used: bool)\n-                                     -> ResolveResult<(NameBinding<'a>, bool)> {\n+                                     -> ResolveResult<(&'a NameBinding<'a>, bool)> {\n         debug!(\"(resolving item in lexical scope) resolving `{}` in namespace {:?} in `{}`\",\n                name,\n                namespace,\n@@ -1554,7 +1560,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                               namespace: Namespace,\n                               allow_private_imports: bool,\n                               record_used: bool)\n-                              -> ResolveResult<(NameBinding<'a>, bool)> {\n+                              -> ResolveResult<(&'a NameBinding<'a>, bool)> {\n         debug!(\"(resolving name in module) resolving `{}` in `{}`\",\n                name,\n                module_to_string(&*module_));\n@@ -1580,7 +1586,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     debug!(\"(resolving name in module) import unresolved; bailing out\");\n                     return Indeterminate;\n                 }\n-                if let Some(binding) = import_resolution.binding.clone() {\n+                if let Some(binding) = import_resolution.binding {\n                     debug!(\"(resolving name in module) resolved to import\");\n                     if record_used {\n                         self.record_import_use(name, namespace, &import_resolution);\n@@ -2619,7 +2625,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Success((binding, _)) => {\n                 debug!(\"(resolve bare identifier pattern) succeeded in finding {} at {:?}\",\n                        name,\n-                       &binding);\n+                       binding);\n                 match binding.def() {\n                     None => {\n                         panic!(\"resolved name in the value namespace to a set of name bindings \\\n@@ -3058,7 +3064,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 match this.primitive_type_table.primitive_types.get(last_name) {\n                     Some(_) => None,\n                     None => this.current_module.get_child(*last_name, TypeNS)\n-                                               .as_ref()\n                                                .and_then(NameBinding::module)\n                 }\n             } else {\n@@ -3456,7 +3461,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             for (&(_, ns), import) in search_module.import_resolutions.borrow().iter() {\n                 if ns != TypeNS { continue }\n                 let binding = match import.binding {\n-                    Some(ref binding) => binding,\n+                    Some(binding) => binding,\n                     None => continue,\n                 };\n                 let did = match binding.def() {"}, {"sha": "015b07a7ebf0d36c56fbb026e5c5c6cdb6be0762", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/22e189ed57b27caa396da44ce4f273b9a0061dda/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e189ed57b27caa396da44ce4f273b9a0061dda/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=22e189ed57b27caa396da44ce4f273b9a0061dda", "patch": "@@ -81,7 +81,8 @@ impl ImportDirective {\n \n     // Given the binding to which this directive resolves in a particular namespace,\n     // this returns the binding for the name this directive defines in that namespace.\n-    fn import<'a>(&self, mut binding: NameBinding<'a>) -> NameBinding<'a> {\n+    fn import<'a>(&self, binding: &'a NameBinding<'a>) -> NameBinding<'a> {\n+        let mut binding = binding.clone();\n         if self.shadowable == Shadowable::Always {\n             binding.modifiers = binding.modifiers | DefModifiers::PRELUDE;\n         }\n@@ -107,7 +108,7 @@ pub struct ImportResolution<'a> {\n     pub is_public: bool,\n \n     /// Resolution of the name in the namespace\n-    pub binding: Option<NameBinding<'a>>,\n+    pub binding: Option<&'a NameBinding<'a>>,\n \n     /// The source node of the `use` directive\n     pub id: NodeId,\n@@ -125,7 +126,7 @@ impl<'a> ImportResolution<'a> {\n \n     pub fn shadowable(&self) -> Shadowable {\n         match self.binding {\n-            Some(ref binding) if binding.defined_with(DefModifiers::PRELUDE) =>\n+            Some(binding) if binding.defined_with(DefModifiers::PRELUDE) =>\n                 Shadowable::Always,\n             Some(_) => Shadowable::Never,\n             None => Shadowable::Always,\n@@ -195,7 +196,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n     /// Resolves an `ImportResolvingError` into the correct enum discriminant\n     /// and passes that on to `resolve_error`.\n-    fn import_resolving_error(&self, e: ImportResolvingError) {\n+    fn import_resolving_error(&self, e: ImportResolvingError<'b>) {\n         // If it's a single failed import then create a \"fake\" import\n         // resolution for it so that later resolve stages won't complain.\n         if let SingleImport(target, _) = e.import_directive.subclass {\n@@ -213,11 +214,11 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 debug!(\"(resolving import error) adding fake target to import resolution of `{}`\",\n                        target);\n \n-                let dummy_binding = NameBinding {\n+                let dummy_binding = self.resolver.new_name_binding(NameBinding {\n                     modifiers: DefModifiers::IMPORTABLE,\n                     def_or_module: DefOrModule::Def(Def::Err),\n                     span: None,\n-                };\n+                });\n \n                 resolution.binding = Some(dummy_binding);\n             }\n@@ -367,7 +368,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                               name: Name,\n                               ns: Namespace,\n                               importing_module: Module<'b>) // Module importing the name\n-                              -> (ResolveResult<NameBinding<'b>>, bool) {\n+                              -> (ResolveResult<&'b NameBinding<'b>>, bool) {\n         build_reduced_graph::populate_module_if_necessary(self.resolver, module);\n         if let Some(name_binding) = module.get_child(name, ns) {\n             if name_binding.is_extern_crate() {\n@@ -397,7 +398,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     return (Failed(None), false);\n                 }\n \n-                if let Some(binding) = resolution.binding.clone() {\n+                if let Some(binding) = resolution.binding {\n                     self.resolver.record_import_use(name, ns, &resolution);\n                     (Success(binding), true)\n                 } else {\n@@ -455,9 +456,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             self.resolve_name_in_module(target_module, source, TypeNS, module_);\n \n         match (&value_result, &type_result) {\n-            (&Success(ref name_binding), _) if !value_used_reexport &&\n-                                               directive.is_public &&\n-                                               !name_binding.is_public() => {\n+            (&Success(name_binding), _) if !value_used_reexport &&\n+                                           directive.is_public &&\n+                                           !name_binding.is_public() => {\n                 let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                 let note_msg = format!(\"Consider marking `{}` as `pub` in the imported module\",\n                                         source);\n@@ -466,8 +467,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     .emit();\n             }\n \n-            (_, &Success(ref name_binding)) if !type_used_reexport &&\n-                                               directive.is_public => {\n+            (_, &Success(name_binding)) if !type_used_reexport && directive.is_public => {\n                 if !name_binding.is_public() {\n                     let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                     let note_msg =\n@@ -519,7 +519,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         {\n             let mut check_and_write_import = |namespace, result, used_public: &mut bool| {\n-                let result: &ResolveResult<NameBinding> = result;\n+                let result: &ResolveResult<&NameBinding> = result;\n \n                 let import_resolution = import_resolutions.get_mut(&(target, namespace)).unwrap();\n                 let namespace_name = match namespace {\n@@ -528,7 +528,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 };\n \n                 match *result {\n-                    Success(ref name_binding) => {\n+                    Success(name_binding) => {\n                         debug!(\"(resolving single import) found {:?} target: {:?}\",\n                                namespace_name,\n                                name_binding.def());\n@@ -541,7 +541,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                                              directive.span,\n                                                              target);\n \n-                        import_resolution.binding = Some(directive.import(name_binding.clone()));\n+                        import_resolution.binding =\n+                            Some(self.resolver.new_name_binding(directive.import(name_binding)));\n                         import_resolution.id = directive.id;\n                         import_resolution.is_public = directive.is_public;\n \n@@ -679,14 +680,15 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                   .or_insert_with(|| ImportResolution::new(id, is_public));\n \n             match target_import_resolution.binding {\n-                Some(ref binding) if target_import_resolution.is_public => {\n+                Some(binding) if target_import_resolution.is_public => {\n                     self.check_for_conflicting_import(&dest_import_resolution,\n                                                       import_directive.span,\n                                                       name,\n                                                       ns);\n                     dest_import_resolution.id = id;\n                     dest_import_resolution.is_public = is_public;\n-                    dest_import_resolution.binding = Some(import_directive.import(binding.clone()));\n+                    dest_import_resolution.binding =\n+                        Some(self.resolver.new_name_binding(import_directive.import(binding)));\n                     self.add_export(module_, name, &dest_import_resolution);\n                 }\n                 _ => {}\n@@ -701,7 +703,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                          target_module,\n                                          import_directive,\n                                          (name, ns),\n-                                         name_binding.clone());\n+                                         name_binding);\n         });\n \n         // Record the destination of this import\n@@ -723,7 +725,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                containing_module: Module<'b>,\n                                import_directive: &ImportDirective,\n                                (name, ns): (Name, Namespace),\n-                               name_binding: NameBinding<'b>) {\n+                               name_binding: &'b NameBinding<'b>) {\n         let id = import_directive.id;\n         let is_public = import_directive.is_public;\n \n@@ -761,7 +763,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                  name);\n                 span_err!(self.resolver.session, import_directive.span, E0251, \"{}\", msg);\n             } else {\n-                dest_import_resolution.binding = Some(import_directive.import(name_binding.clone()));\n+                dest_import_resolution.binding =\n+                    Some(self.resolver.new_name_binding(import_directive.import(name_binding)));\n                 dest_import_resolution.id = id;\n                 dest_import_resolution.is_public = is_public;\n                 self.add_export(module_, name, &dest_import_resolution);\n@@ -799,7 +802,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                binding.is_some());\n \n         match *binding {\n-            Some(ref binding) if !binding.defined_with(DefModifiers::PRELUDE) => {\n+            Some(binding) if !binding.defined_with(DefModifiers::PRELUDE) => {\n                 let ns_word = match namespace {\n                     TypeNS => {\n                         match binding.module() {\n@@ -857,7 +860,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         if ns == ValueNS {\n             match import.binding {\n-                Some(ref binding) if !binding.defined_with(DefModifiers::PRELUDE) => {\n+                Some(binding) if !binding.defined_with(DefModifiers::PRELUDE) => {\n                     let mut err = struct_span_err!(self.resolver.session,\n                                                    import_span,\n                                                    E0255,\n@@ -873,7 +876,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             }\n         } else {\n             match import.binding {\n-                Some(ref binding) if !binding.defined_with(DefModifiers::PRELUDE) => {\n+                Some(binding) if !binding.defined_with(DefModifiers::PRELUDE) => {\n                     if name_binding.is_extern_crate() {\n                         let msg = format!(\"import `{0}` conflicts with imported crate \\\n                                            in this module (maybe you meant `use {0}::*`?)\","}]}