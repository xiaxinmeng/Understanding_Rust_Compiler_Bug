{"sha": "571da2c62d0ac6360b78796e764ad5fe0753f553", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3MWRhMmM2MmQwYWM2MzYwYjc4Nzk2ZTc2NGFkNWZlMDc1M2Y1NTM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-11-21T12:20:34Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-11-22T20:27:58Z"}, "message": "refactor unsafety checking of places", "tree": {"sha": "2a6748c282093141f14fa68db1f33369bf90fc86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a6748c282093141f14fa68db1f33369bf90fc86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/571da2c62d0ac6360b78796e764ad5fe0753f553", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/571da2c62d0ac6360b78796e764ad5fe0753f553", "html_url": "https://github.com/rust-lang/rust/commit/571da2c62d0ac6360b78796e764ad5fe0753f553", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/571da2c62d0ac6360b78796e764ad5fe0753f553/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df1c55a47434b2d79dea43673a3a97b9e955ce82", "url": "https://api.github.com/repos/rust-lang/rust/commits/df1c55a47434b2d79dea43673a3a97b9e955ce82", "html_url": "https://github.com/rust-lang/rust/commit/df1c55a47434b2d79dea43673a3a97b9e955ce82"}], "stats": {"total": 163, "additions": 87, "deletions": 76}, "files": [{"sha": "2bd30001a9153999b98bfa7046d5383b509956c0", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/571da2c62d0ac6360b78796e764ad5fe0753f553/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/571da2c62d0ac6360b78796e764ad5fe0753f553/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=571da2c62d0ac6360b78796e764ad5fe0753f553", "patch": "@@ -1744,7 +1744,9 @@ impl<'tcx> Place<'tcx> {\n \n     /// Iterate over the projections in evaluation order, i.e., the first element is the base with\n     /// its projection and then subsequently more projections are added.\n-    pub fn iter_projections(self) -> impl Iterator<Item=(PlaceRef<'tcx>, PlaceElem<'tcx>)> + DoubleEndedIterator {\n+    pub fn iter_projections(\n+        self,\n+    ) -> impl Iterator<Item = (PlaceRef<'tcx>, PlaceElem<'tcx>)> + DoubleEndedIterator {\n         self.projection.iter().enumerate().map(move |(i, proj)| {\n             let base = PlaceRef { local: self.local, projection: &self.projection[..i] };\n             (base, proj)"}, {"sha": "e64955c4986cee0f57fea664ac64d0990b9cd049", "filename": "compiler/rustc_mir/src/transform/check_unsafety.rs", "status": "modified", "additions": 84, "deletions": 75, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/571da2c62d0ac6360b78796e764ad5fe0753f553/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/571da2c62d0ac6360b78796e764ad5fe0753f553/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs?ref=571da2c62d0ac6360b78796e764ad5fe0753f553", "patch": "@@ -181,6 +181,9 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             self.check_mut_borrowing_layout_constrained_field(*place, context.is_mutating_use());\n         }\n \n+        // Check for borrows to packed fields.\n+        // `is_disaligned` already traverses the place to consider all projections after the last\n+        // `Deref`, so this only needs to be called once at the top level.\n         if context.is_borrow() {\n             if util::is_disaligned(self.tcx, self.body, self.param_env, *place) {\n                 self.require_unsafe(\n@@ -190,99 +193,105 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             }\n         }\n \n-        for (i, _elem) in place.projection.iter().enumerate() {\n-            let proj_base = &place.projection[..i];\n-            if context.is_borrow() {\n-                if util::is_disaligned(self.tcx, self.body, self.param_env, *place) {\n+        // Some checks below need the extra metainfo of the local declaration.\n+        let decl = &self.body.local_decls[place.local];\n+\n+        // Check the base local: it might be an unsafe-to-access static. We only check derefs of the\n+        // temporary holding the static pointer to avoid duplicate errors\n+        // <https://github.com/rust-lang/rust/pull/78068#issuecomment-731753506>.\n+        if decl.internal && place.projection.first() == Some(&ProjectionElem::Deref) {\n+            // If the projection root is an artifical local that we introduced when\n+            // desugaring `static`, give a more specific error message\n+            // (avoid the general \"raw pointer\" clause below, that would only be confusing).\n+            if let Some(box LocalInfo::StaticRef { def_id, .. }) = decl.local_info {\n+                if self.tcx.is_mutable_static(def_id) {\n                     self.require_unsafe(\n-                        UnsafetyViolationKind::BorrowPacked,\n-                        UnsafetyViolationDetails::BorrowOfPackedField,\n+                        UnsafetyViolationKind::General,\n+                        UnsafetyViolationDetails::UseOfMutableStatic,\n                     );\n+                    return;\n+                } else if self.tcx.is_foreign_item(def_id) {\n+                    self.require_unsafe(\n+                        UnsafetyViolationKind::General,\n+                        UnsafetyViolationDetails::UseOfExternStatic,\n+                    );\n+                    return;\n                 }\n             }\n-            let source_info = self.source_info;\n-            if let [] = proj_base {\n-                let decl = &self.body.local_decls[place.local];\n-                if decl.internal {\n-                    // If the projection root is an artifical local that we introduced when\n-                    // desugaring `static`, give a more specific error message\n-                    // (avoid the general \"raw pointer\" clause below, that would only be confusing).\n-                    if let Some(box LocalInfo::StaticRef { def_id, .. }) = decl.local_info {\n-                        if self.tcx.is_mutable_static(def_id) {\n-                            self.require_unsafe(\n-                                UnsafetyViolationKind::General,\n-                                UnsafetyViolationDetails::UseOfMutableStatic,\n-                            );\n-                            return;\n-                        } else if self.tcx.is_foreign_item(def_id) {\n-                            self.require_unsafe(\n-                                UnsafetyViolationKind::General,\n-                                UnsafetyViolationDetails::UseOfExternStatic,\n-                            );\n-                            return;\n-                        }\n-                    } else {\n-                        // Internal locals are used in the `move_val_init` desugaring.\n-                        // We want to check unsafety against the source info of the\n-                        // desugaring, rather than the source info of the RHS.\n-                        self.source_info = self.body.local_decls[place.local].source_info;\n-                    }\n+        }\n+\n+        // Check for raw pointer `Deref`.\n+        for (base, proj) in place.iter_projections() {\n+            if proj == ProjectionElem::Deref {\n+                let source_info = self.source_info; // Backup source_info so we can restore it later.\n+                if base.projection.is_empty() && decl.internal {\n+                    // Internal locals are used in the `move_val_init` desugaring.\n+                    // We want to check unsafety against the source info of the\n+                    // desugaring, rather than the source info of the RHS.\n+                    self.source_info = self.body.local_decls[place.local].source_info;\n                 }\n+                let base_ty = base.ty(self.body, self.tcx).ty;\n+                if base_ty.is_unsafe_ptr() {\n+                    self.require_unsafe(\n+                        UnsafetyViolationKind::GeneralAndConstFn,\n+                        UnsafetyViolationDetails::DerefOfRawPointer,\n+                    )\n+                }\n+                self.source_info = source_info; // Restore backed-up source_info.\n+            }\n+        }\n+\n+        // Check for union fields. For this we traverse right-to-left, as the last `Deref` changes\n+        // whether we *read* the union field or potentially *write* to it (if this place is being assigned to).\n+        let mut saw_deref = false;\n+        for (base, proj) in place.iter_projections().rev() {\n+            if proj == ProjectionElem::Deref {\n+                saw_deref = true;\n+                continue;\n             }\n-            let base_ty = Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n-            match base_ty.kind() {\n-                ty::RawPtr(..) => self.require_unsafe(\n-                    UnsafetyViolationKind::GeneralAndConstFn,\n-                    UnsafetyViolationDetails::DerefOfRawPointer,\n-                ),\n-                ty::Adt(adt, _) if adt.is_union() => {\n-                    let assign_to_field = matches!(\n+\n+            let base_ty = base.ty(self.body, self.tcx).ty;\n+            if base_ty.ty_adt_def().map_or(false, |adt| adt.is_union()) {\n+                // If we did not hit a `Deref` yet and the overall place use is an assignment, the\n+                // rules are different.\n+                let assign_to_field = !saw_deref\n+                    && matches!(\n                         context,\n                         PlaceContext::MutatingUse(\n                             MutatingUseContext::Store\n                                 | MutatingUseContext::Drop\n                                 | MutatingUseContext::AsmOutput\n                         )\n                     );\n-                    // If there is a `Deref` further along the projection chain, this is *not* an\n-                    // assignment to a union field. In that case the union field is just read to\n-                    // obtain the pointer/reference.\n-                    let assign_to_field = assign_to_field\n-                        && !place.projection[i..]\n-                            .iter()\n-                            .any(|elem| matches!(elem, ProjectionElem::Deref));\n-                    // If this is just an assignment, determine if the assigned type needs dropping.\n-                    if assign_to_field {\n-                        // We have to check the actual type of the assignment, as that determines if the\n-                        // old value is being dropped.\n-                        let assigned_ty = place.ty(&self.body.local_decls, self.tcx).ty;\n-                        // To avoid semver hazard, we only consider `Copy` and `ManuallyDrop` non-dropping.\n-                        let manually_drop = assigned_ty\n-                            .ty_adt_def()\n-                            .map_or(false, |adt_def| adt_def.is_manually_drop());\n-                        let nodrop = manually_drop\n-                            || assigned_ty.is_copy_modulo_regions(\n-                                self.tcx.at(self.source_info.span),\n-                                self.param_env,\n-                            );\n-                        if !nodrop {\n-                            self.require_unsafe(\n-                                UnsafetyViolationKind::GeneralAndConstFn,\n-                                UnsafetyViolationDetails::AssignToDroppingUnionField,\n-                            );\n-                        } else {\n-                            // write to non-drop union field, safe\n-                        }\n-                    } else {\n+                // If this is just an assignment, determine if the assigned type needs dropping.\n+                if assign_to_field {\n+                    // We have to check the actual type of the assignment, as that determines if the\n+                    // old value is being dropped.\n+                    let assigned_ty = place.ty(&self.body.local_decls, self.tcx).ty;\n+                    // To avoid semver hazard, we only consider `Copy` and `ManuallyDrop` non-dropping.\n+                    let manually_drop = assigned_ty\n+                        .ty_adt_def()\n+                        .map_or(false, |adt_def| adt_def.is_manually_drop());\n+                    let nodrop = manually_drop\n+                        || assigned_ty.is_copy_modulo_regions(\n+                            self.tcx.at(self.source_info.span),\n+                            self.param_env,\n+                        );\n+                    if !nodrop {\n                         self.require_unsafe(\n                             UnsafetyViolationKind::GeneralAndConstFn,\n-                            UnsafetyViolationDetails::AccessToUnionField,\n-                        )\n+                            UnsafetyViolationDetails::AssignToDroppingUnionField,\n+                        );\n+                    } else {\n+                        // write to non-drop union field, safe\n                     }\n+                } else {\n+                    self.require_unsafe(\n+                        UnsafetyViolationKind::GeneralAndConstFn,\n+                        UnsafetyViolationDetails::AccessToUnionField,\n+                    )\n                 }\n-                _ => {}\n             }\n-            self.source_info = source_info;\n         }\n     }\n }"}]}