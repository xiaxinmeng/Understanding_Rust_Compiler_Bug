{"sha": "257d8fce3e38177c3cc357f1ce23db87b69e1682", "node_id": "C_kwDOAAsO6NoAKDI1N2Q4ZmNlM2UzODE3N2MzY2MzNTdmMWNlMjNkYjg3YjY5ZTE2ODI", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-21T17:48:40Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-06-02T17:24:12Z"}, "message": "Do not report mixed label/lifetime shadowing.", "tree": {"sha": "129f84c606ee7c2aa7c6337f2fb68b8873292cd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/129f84c606ee7c2aa7c6337f2fb68b8873292cd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/257d8fce3e38177c3cc357f1ce23db87b69e1682", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/257d8fce3e38177c3cc357f1ce23db87b69e1682", "html_url": "https://github.com/rust-lang/rust/commit/257d8fce3e38177c3cc357f1ce23db87b69e1682", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/257d8fce3e38177c3cc357f1ce23db87b69e1682/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85cbd0bc185c4b9b36162a638c9ec3915df265b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/85cbd0bc185c4b9b36162a638c9ec3915df265b2", "html_url": "https://github.com/rust-lang/rust/commit/85cbd0bc185c4b9b36162a638c9ec3915df265b2"}], "stats": {"total": 156, "additions": 45, "deletions": 111}, "files": [{"sha": "efdedbebbea5e4aad9fa5c4b44211f4782446a83", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 12, "deletions": 38, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/257d8fce3e38177c3cc357f1ce23db87b69e1682/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/257d8fce3e38177c3cc357f1ce23db87b69e1682/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=257d8fce3e38177c3cc357f1ce23db87b69e1682", "patch": "@@ -12,10 +12,6 @@ use crate::{path_names_to_string, BindingError, Finalize, LexicalScopeBinding};\n use crate::{Module, ModuleOrUniformRoot, NameBinding, ParentScope, PathResult};\n use crate::{ResolutionError, Resolver, Segment, UseError};\n \n-use diagnostics::{\n-    original_label, original_lifetime, original_lifetime_param, shadower_label, shadower_lifetime,\n-};\n-\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, AssocCtxt, BoundKind, FnCtxt, FnKind, Visitor};\n use rustc_ast::*;\n@@ -1902,6 +1898,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         let mut function_value_rib = Rib::new(kind);\n         let mut function_lifetime_rib = LifetimeRib::new(lifetime_kind);\n         let mut seen_bindings = FxHashMap::default();\n+        // Store all seen lifetimes names, and whether they were created in the currently processed\n+        // parameter set.\n         let mut seen_lifetimes = FxHashMap::default();\n \n         // We also can't shadow bindings from the parent item\n@@ -1920,20 +1918,11 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n         // Forbid shadowing lifetime bindings\n         for rib in self.lifetime_ribs.iter().rev() {\n-            seen_lifetimes.extend(\n-                rib.bindings.iter().map(|(ident, _)| (*ident, original_lifetime(ident.span))),\n-            );\n+            seen_lifetimes.extend(rib.bindings.iter().map(|(ident, _)| (*ident, false)));\n             if let LifetimeRibKind::Item = rib.kind {\n                 break;\n             }\n         }\n-        for rib in self.label_ribs.iter().rev() {\n-            if rib.kind.is_label_barrier() {\n-                break;\n-            }\n-            seen_lifetimes\n-                .extend(rib.bindings.iter().map(|(ident, _)| (*ident, original_label(ident.span))));\n-        }\n \n         for param in params {\n             let ident = param.ident.normalize_to_macros_2_0();\n@@ -1942,16 +1931,17 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             if let GenericParamKind::Lifetime = param.kind {\n                 match seen_lifetimes.entry(ident) {\n                     Entry::Occupied(entry) => {\n-                        let original = *entry.get();\n-                        diagnostics::signal_shadowing_problem(\n+                        let original = *entry.key();\n+                        let orig_is_param = *entry.get();\n+                        diagnostics::signal_lifetime_shadowing(\n                             self.r.session,\n-                            ident.name,\n                             original,\n-                            shadower_lifetime(param.ident.span),\n-                        )\n+                            param.ident,\n+                            orig_is_param,\n+                        );\n                     }\n                     Entry::Vacant(entry) => {\n-                        entry.insert(original_lifetime_param(param.ident.span));\n+                        entry.insert(true);\n                     }\n                 }\n             } else {\n@@ -3155,26 +3145,10 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 self.diagnostic_metadata.unused_labels.insert(id, label.ident.span);\n             }\n \n-            // Forbid shadowing lifetime bindings\n             let ident = label.ident.normalize_to_macro_rules();\n-            for rib in self.lifetime_ribs.iter().rev() {\n-                if let Some((orig_ident, _)) = rib.bindings.get_key_value(&ident) {\n-                    diagnostics::signal_shadowing_problem(\n-                        self.r.session,\n-                        label.ident.name,\n-                        original_lifetime(orig_ident.span),\n-                        shadower_label(label.ident.span),\n-                    )\n-                }\n-            }\n             for rib in self.label_ribs.iter_mut().rev() {\n-                if let Some((orig_ident, _)) = rib.bindings.get_key_value(&ident) {\n-                    diagnostics::signal_shadowing_problem(\n-                        self.r.session,\n-                        label.ident.name,\n-                        original_label(orig_ident.span),\n-                        shadower_label(label.ident.span),\n-                    )\n+                if let Some((&orig_ident, _)) = rib.bindings.get_key_value(&ident) {\n+                    diagnostics::signal_label_shadowing(self.r.session, orig_ident, label.ident)\n                 }\n                 if rib.kind.is_label_barrier() {\n                     rib.bindings.insert(ident, id);"}, {"sha": "552102be92c1263b3206d1e6f1e8f5248fa3104b", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 33, "deletions": 73, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/257d8fce3e38177c3cc357f1ce23db87b69e1682/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/257d8fce3e38177c3cc357f1ce23db87b69e1682/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=257d8fce3e38177c3cc357f1ce23db87b69e1682", "patch": "@@ -2037,84 +2037,44 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq)]\n-enum ShadowKind {\n-    Label,\n-    Lifetime,\n-}\n-#[derive(Copy, Clone)]\n-pub struct Original {\n-    kind: ShadowKind,\n-    span: Span,\n-    param: bool,\n-}\n-#[derive(Copy, Clone)]\n-pub struct Shadower {\n-    kind: ShadowKind,\n-    span: Span,\n-}\n-\n-pub fn original_label(span: Span) -> Original {\n-    Original { kind: ShadowKind::Label, span, param: false }\n-}\n-pub fn shadower_label(span: Span) -> Shadower {\n-    Shadower { kind: ShadowKind::Label, span }\n-}\n-pub fn original_lifetime(span: Span) -> Original {\n-    Original { kind: ShadowKind::Lifetime, span, param: false }\n-}\n-pub fn original_lifetime_param(span: Span) -> Original {\n-    Original { kind: ShadowKind::Lifetime, span, param: true }\n-}\n-pub fn shadower_lifetime(span: Span) -> Shadower {\n-    Shadower { kind: ShadowKind::Lifetime, span }\n-}\n-\n-impl ShadowKind {\n-    fn desc(&self) -> &'static str {\n-        match *self {\n-            ShadowKind::Label => \"label\",\n-            ShadowKind::Lifetime => \"lifetime\",\n-        }\n-    }\n-}\n-\n-pub fn signal_shadowing_problem(sess: &Session, name: Symbol, orig: Original, shadower: Shadower) {\n-    let mut err = if let (ShadowKind::Lifetime, ShadowKind::Lifetime) = (orig.kind, shadower.kind) {\n-        // lifetime/lifetime shadowing is an error\n-        if orig.param {\n-            struct_span_err!(\n-                sess,\n-                shadower.span,\n-                E0263,\n-                \"lifetime name `{}` declared twice in the same scope\",\n-                name,\n-            )\n-        } else {\n-            struct_span_err!(\n-                sess,\n-                shadower.span,\n-                E0496,\n-                \"lifetime name `{}` shadows a lifetime name that is already in scope\",\n-                name,\n-            )\n-        }\n-        .forget_guarantee()\n+/// Report lifetime/lifetime shadowing as an error.\n+pub fn signal_lifetime_shadowing(\n+    sess: &Session,\n+    orig: Ident,\n+    shadower: Ident,\n+    orig_is_param: bool,\n+) {\n+    let mut err = if orig_is_param {\n+        struct_span_err!(\n+            sess,\n+            shadower.span,\n+            E0263,\n+            \"lifetime name `{}` declared twice in the same scope\",\n+            orig.name,\n+        )\n     } else {\n-        // shadowing involving a label is only a warning, due to issues with\n-        // labels and lifetimes not being macro-hygienic.\n-        sess.struct_span_warn(\n+        struct_span_err!(\n+            sess,\n             shadower.span,\n-            &format!(\n-                \"{} name `{}` shadows a {} name that is already in scope\",\n-                shadower.kind.desc(),\n-                name,\n-                orig.kind.desc()\n-            ),\n+            E0496,\n+            \"lifetime name `{}` shadows a lifetime name that is already in scope\",\n+            orig.name,\n         )\n     };\n     err.span_label(orig.span, \"first declared here\");\n-    err.span_label(shadower.span, format!(\"{} `{}` already in scope\", orig.kind.desc(), name));\n+    err.span_label(shadower.span, format!(\"lifetime `{}` already in scope\", orig.name));\n+    err.emit();\n+}\n+\n+/// Shadowing involving a label is only a warning, due to issues with\n+/// labels and lifetimes not being macro-hygienic.\n+pub fn signal_label_shadowing(sess: &Session, orig: Ident, shadower: Ident) {\n+    let mut err = sess.struct_span_warn(\n+        shadower.span,\n+        &format!(\"label name `{}` shadows a label name that is already in scope\", orig.name),\n+    );\n+    err.span_label(orig.span, \"first declared here\");\n+    err.span_label(shadower.span, format!(\"label `{}` already in scope\", orig.name));\n     err.emit();\n }\n "}]}