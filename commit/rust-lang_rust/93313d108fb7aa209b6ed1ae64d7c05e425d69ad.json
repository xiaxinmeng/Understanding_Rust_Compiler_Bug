{"sha": "93313d108fb7aa209b6ed1ae64d7c05e425d69ad", "node_id": "C_kwDOAAsO6NoAKDkzMzEzZDEwOGZiN2FhMjA5YjZlZDFhZTY0ZDdjMDVlNDI1ZDY5YWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-28T02:29:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-28T02:29:06Z"}, "message": "Auto merge of #95393 - Dylan-DPC:rollup-l72f39g, r=Dylan-DPC\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #88375 (Clarify that ManuallyDrop<T> has same layout as T)\n - #93755 (Allow comparing `Vec`s with different allocators using `==`)\n - #95016 (Docs: make Vec::from_raw_parts documentation less strict)\n - #95098 (impl From<&[T; N]> and From<&mut [T; N]> for Vec<T>)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "c906dbb677174650f3444263bce4f9fdf466c858", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c906dbb677174650f3444263bce4f9fdf466c858"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93313d108fb7aa209b6ed1ae64d7c05e425d69ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93313d108fb7aa209b6ed1ae64d7c05e425d69ad", "html_url": "https://github.com/rust-lang/rust/commit/93313d108fb7aa209b6ed1ae64d7c05e425d69ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93313d108fb7aa209b6ed1ae64d7c05e425d69ad/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3badf5c51c33f15c3934ea0e91d27f60c8605024", "url": "https://api.github.com/repos/rust-lang/rust/commits/3badf5c51c33f15c3934ea0e91d27f60c8605024", "html_url": "https://github.com/rust-lang/rust/commit/3badf5c51c33f15c3934ea0e91d27f60c8605024"}, {"sha": "8bfc03fde037ba4b64c29d14c00b04586dc909cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bfc03fde037ba4b64c29d14c00b04586dc909cf", "html_url": "https://github.com/rust-lang/rust/commit/8bfc03fde037ba4b64c29d14c00b04586dc909cf"}], "stats": {"total": 65, "additions": 56, "deletions": 9}, "files": [{"sha": "1ca5ee55375822f55eb3a2d7695614b39cdabd2f", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 49, "deletions": 3, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/93313d108fb7aa209b6ed1ae64d7c05e425d69ad/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93313d108fb7aa209b6ed1ae64d7c05e425d69ad/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=93313d108fb7aa209b6ed1ae64d7c05e425d69ad", "patch": "@@ -479,20 +479,24 @@ impl<T> Vec<T> {\n     ///\n     /// * `ptr` needs to have been previously allocated via [`String`]/`Vec<T>`\n     ///   (at least, it's highly likely to be incorrect if it wasn't).\n-    /// * `T` needs to have the same size and alignment as what `ptr` was allocated with.\n+    /// * `T` needs to have the same alignment as what `ptr` was allocated with.\n     ///   (`T` having a less strict alignment is not sufficient, the alignment really\n     ///   needs to be equal to satisfy the [`dealloc`] requirement that memory must be\n     ///   allocated and deallocated with the same layout.)\n+    /// * The size of `T` times the `capacity` (ie. the allocated size in bytes) needs\n+    ///   to be the same size as the pointer was allocated with. (Because similar to\n+    ///   alignment, [`dealloc`] must be called with the same layout `size`.)\n     /// * `length` needs to be less than or equal to `capacity`.\n-    /// * `capacity` needs to be the capacity that the pointer was allocated with.\n     ///\n     /// Violating these may cause problems like corrupting the allocator's\n     /// internal data structures. For example it is **not** safe\n     /// to build a `Vec<u8>` from a pointer to a C `char` array with length `size_t`.\n     /// It's also not safe to build one from a `Vec<u16>` and its length, because\n     /// the allocator cares about the alignment, and these two types have different\n     /// alignments. The buffer was allocated with alignment 2 (for `u16`), but after\n-    /// turning it into a `Vec<u8>` it'll be deallocated with alignment 1.\n+    /// turning it into a `Vec<u8>` it'll be deallocated with alignment 1. To avoid\n+    /// these issues, it is often preferable to do casting/transmuting using\n+    /// [`slice::from_raw_parts`] instead.\n     ///\n     /// The ownership of `ptr` is effectively transferred to the\n     /// `Vec<T>` which may then deallocate, reallocate or change the\n@@ -2929,6 +2933,48 @@ impl<T, const N: usize> From<[T; N]> for Vec<T> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n+#[stable(feature = \"vec_from_array_ref\", since = \"1.61.0\")]\n+impl<T: Clone, const N: usize> From<&[T; N]> for Vec<T> {\n+    /// Allocate a `Vec<T>` and fill it by cloning `s`'s items.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!(Vec::from(b\"raw\"), vec![b'r', b'a', b'w']);\n+    /// ```\n+    #[cfg(not(test))]\n+    fn from(s: &[T; N]) -> Vec<T> {\n+        s.to_vec()\n+    }\n+\n+    #[cfg(test)]\n+    fn from(s: &[T; N]) -> Vec<T> {\n+        crate::slice::to_vec(s, Global)\n+    }\n+}\n+\n+#[cfg(not(no_global_oom_handling))]\n+#[stable(feature = \"vec_from_array_ref\", since = \"1.61.0\")]\n+impl<T: Clone, const N: usize> From<&mut [T; N]> for Vec<T> {\n+    /// Allocate a `Vec<T>` and fill it by cloning `s`'s items.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!(Vec::from(&mut [1, 2, 3]), vec![1, 2, 3]);\n+    /// ```\n+    #[cfg(not(test))]\n+    fn from(s: &mut [T; N]) -> Vec<T> {\n+        s.to_vec()\n+    }\n+\n+    #[cfg(test)]\n+    fn from(s: &mut [T; N]) -> Vec<T> {\n+        crate::slice::to_vec(s, Global)\n+    }\n+}\n+\n #[stable(feature = \"vec_from_cow_slice\", since = \"1.14.0\")]\n impl<'a, T> From<Cow<'a, [T]>> for Vec<T>\n where"}, {"sha": "b0cf72577a1be734abca5350b0e7f56461a02f49", "filename": "library/alloc/src/vec/partial_eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93313d108fb7aa209b6ed1ae64d7c05e425d69ad/library%2Falloc%2Fsrc%2Fvec%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93313d108fb7aa209b6ed1ae64d7c05e425d69ad/library%2Falloc%2Fsrc%2Fvec%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fpartial_eq.rs?ref=93313d108fb7aa209b6ed1ae64d7c05e425d69ad", "patch": "@@ -20,7 +20,7 @@ macro_rules! __impl_slice_eq1 {\n     }\n }\n \n-__impl_slice_eq1! { [A: Allocator] Vec<T, A>, Vec<U, A>, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [A1: Allocator, A2: Allocator] Vec<T, A1>, Vec<U, A2>, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n __impl_slice_eq1! { [A: Allocator] Vec<T, A>, &[U], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n __impl_slice_eq1! { [A: Allocator] Vec<T, A>, &mut [U], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n __impl_slice_eq1! { [A: Allocator] &[T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_ref_slice\", since = \"1.46.0\")] }"}, {"sha": "3d719afe49e4a5c0ff1b842e70b5ab75299c18ef", "filename": "library/core/src/mem/manually_drop.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/93313d108fb7aa209b6ed1ae64d7c05e425d69ad/library%2Fcore%2Fsrc%2Fmem%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93313d108fb7aa209b6ed1ae64d7c05e425d69ad/library%2Fcore%2Fsrc%2Fmem%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmanually_drop.rs?ref=93313d108fb7aa209b6ed1ae64d7c05e425d69ad", "patch": "@@ -4,11 +4,12 @@ use crate::ptr;\n /// A wrapper to inhibit compiler from automatically calling `T`\u2019s destructor.\n /// This wrapper is 0-cost.\n ///\n-/// `ManuallyDrop<T>` is subject to the same layout optimizations as `T`.\n-/// As a consequence, it has *no effect* on the assumptions that the compiler makes\n-/// about its contents. For example, initializing a `ManuallyDrop<&mut T>`\n-/// with [`mem::zeroed`] is undefined behavior.\n-/// If you need to handle uninitialized data, use [`MaybeUninit<T>`] instead.\n+/// `ManuallyDrop<T>` is guaranteed to have the same layout as `T`, and is subject\n+/// to the same layout optimizations as `T`. As a consequence, it has *no effect*\n+/// on the assumptions that the compiler makes about its contents. For example,\n+/// initializing a `ManuallyDrop<&mut T>` with [`mem::zeroed`] is undefined\n+/// behavior. If you need to handle uninitialized data, use [`MaybeUninit<T>`]\n+/// instead.\n ///\n /// Note that accessing the value inside a `ManuallyDrop<T>` is safe.\n /// This means that a `ManuallyDrop<T>` whose content has been dropped must not"}]}