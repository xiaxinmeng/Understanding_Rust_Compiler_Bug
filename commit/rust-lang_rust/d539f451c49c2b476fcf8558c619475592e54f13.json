{"sha": "d539f451c49c2b476fcf8558c619475592e54f13", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1MzlmNDUxYzQ5YzJiNDc2ZmNmODU1OGM2MTk0NzU1OTJlNTRmMTM=", "commit": {"author": {"name": "Simon Mazur", "email": "semmaz.box@gmail.com", "date": "2015-09-18T18:34:16Z"}, "committer": {"name": "Simon Mazur", "email": "semmaz.box@gmail.com", "date": "2015-09-20T10:24:47Z"}, "message": "rustdoc: some code style improvements", "tree": {"sha": "79a329858ecc07a5be1f6a999149e9aa88cafa97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79a329858ecc07a5be1f6a999149e9aa88cafa97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d539f451c49c2b476fcf8558c619475592e54f13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d539f451c49c2b476fcf8558c619475592e54f13", "html_url": "https://github.com/rust-lang/rust/commit/d539f451c49c2b476fcf8558c619475592e54f13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d539f451c49c2b476fcf8558c619475592e54f13/comments", "author": {"login": "semmaz", "id": 3989426, "node_id": "MDQ6VXNlcjM5ODk0MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3989426?v=4", "gravatar_id": "", "url": "https://api.github.com/users/semmaz", "html_url": "https://github.com/semmaz", "followers_url": "https://api.github.com/users/semmaz/followers", "following_url": "https://api.github.com/users/semmaz/following{/other_user}", "gists_url": "https://api.github.com/users/semmaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/semmaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/semmaz/subscriptions", "organizations_url": "https://api.github.com/users/semmaz/orgs", "repos_url": "https://api.github.com/users/semmaz/repos", "events_url": "https://api.github.com/users/semmaz/events{/privacy}", "received_events_url": "https://api.github.com/users/semmaz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "semmaz", "id": 3989426, "node_id": "MDQ6VXNlcjM5ODk0MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3989426?v=4", "gravatar_id": "", "url": "https://api.github.com/users/semmaz", "html_url": "https://github.com/semmaz", "followers_url": "https://api.github.com/users/semmaz/followers", "following_url": "https://api.github.com/users/semmaz/following{/other_user}", "gists_url": "https://api.github.com/users/semmaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/semmaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/semmaz/subscriptions", "organizations_url": "https://api.github.com/users/semmaz/orgs", "repos_url": "https://api.github.com/users/semmaz/repos", "events_url": "https://api.github.com/users/semmaz/events{/privacy}", "received_events_url": "https://api.github.com/users/semmaz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "970b86b1bb61eeff8b32372e2a1d5486945f47d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/970b86b1bb61eeff8b32372e2a1d5486945f47d1", "html_url": "https://github.com/rust-lang/rust/commit/970b86b1bb61eeff8b32372e2a1d5486945f47d1"}], "stats": {"total": 41, "additions": 14, "deletions": 27}, "files": [{"sha": "78c2d27f72e7824187c882c8501e9e2dce21efe4", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 14, "deletions": 27, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d539f451c49c2b476fcf8558c619475592e54f13/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539f451c49c2b476fcf8558c619475592e54f13/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=d539f451c49c2b476fcf8558c619475592e54f13", "patch": "@@ -207,9 +207,7 @@ fn stripped_filtered_line<'a>(s: &'a str) -> Option<&'a str> {\n ///\n /// Any leading or trailing whitespace will be trimmed.\n fn collapse_whitespace(s: &str) -> String {\n-    s.split(|c: char| c.is_whitespace()).filter(|s| {\n-        !s.is_empty()\n-    }).collect::<Vec<_>>().join(\" \")\n+    s.split_whitespace().collect::<Vec<_>>().join(\" \")\n }\n \n thread_local!(static USED_HEADER_MAP: RefCell<HashMap<String, usize>> = {\n@@ -277,10 +275,10 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n \n         // Extract the text provided\n         let s = if text.is_null() {\n-            \"\".to_string()\n+            \"\".to_owned()\n         } else {\n             let s = unsafe { (*text).as_bytes() };\n-            str::from_utf8(s).unwrap().to_string()\n+            str::from_utf8(&s).unwrap().to_owned()\n         };\n \n         // Discard '<em>', '<code>' tags and some escaped characters,\n@@ -322,22 +320,15 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n             id\n         });\n \n-        let sec = match opaque.toc_builder {\n-            Some(ref mut builder) => {\n-                builder.push(level as u32, s.clone(), id.clone())\n-            }\n-            None => {\"\"}\n-        };\n+\n+        let sec = opaque.toc_builder.as_mut().map_or(\"\".to_owned(), |builder| {\n+            format!(\"{} \", builder.push(level as u32, s.clone(), id.clone()))\n+        });\n \n         // Render the HTML\n         let text = format!(r##\"<h{lvl} id=\"{id}\" class='section-header'><a\n                            href=\"#{id}\">{sec}{}</a></h{lvl}>\"##,\n-                           s, lvl = level, id = id,\n-                           sec = if sec.is_empty() {\n-                               sec.to_string()\n-                           } else {\n-                               format!(\"{} \", sec)\n-                           });\n+                           s, lvl = level, id = id, sec = sec);\n \n         let text = CString::new(text).unwrap();\n         unsafe { hoedown_buffer_puts(ob, text.as_ptr()) }\n@@ -351,7 +342,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n         _: *const hoedown_renderer_data,\n     ) -> libc::c_int {\n         let content = if text.is_null() {\n-            \"\".to_string()\n+            \"\".to_owned()\n         } else {\n             let bytes = unsafe { (*text).as_bytes() };\n             let s = str::from_utf8(bytes).unwrap();\n@@ -385,10 +376,9 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n \n         hoedown_html_renderer_free(renderer);\n \n-        let mut ret = match opaque.toc_builder {\n-            Some(b) => write!(w, \"<nav id=\\\"TOC\\\">{}</nav>\", b.into_toc()),\n-            None => Ok(())\n-        };\n+        let mut ret = opaque.toc_builder.map_or(Ok(()), |builder| {\n+            write!(w, \"<nav id=\\\"TOC\\\">{}</nav>\", builder.into_toc())\n+        });\n \n         if ret.is_ok() {\n             let buf = (*ob).as_bytes();\n@@ -422,7 +412,7 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n                 stripped_filtered_line(l).unwrap_or(l)\n             });\n             let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n-            tests.add_test(text.to_string(),\n+            tests.add_test(text.to_owned(),\n                            block_info.should_panic, block_info.no_run,\n                            block_info.ignore, block_info.test_harness);\n         }\n@@ -578,10 +568,7 @@ pub fn plain_summary_line(md: &str) -> String {\n                                 md.len() as libc::size_t);\n         hoedown_document_free(document);\n         let plain_slice = (*ob).as_bytes();\n-        let plain = match str::from_utf8(plain_slice) {\n-            Ok(s) => s.to_string(),\n-            Err(_) => \"\".to_string(),\n-        };\n+        let plain = str::from_utf8(plain_slice).unwrap_or(\"\").to_owned();\n         hoedown_buffer_free(ob);\n         plain\n     }"}]}