{"sha": "80a7a87be23dac0cea4f65af07956c653601506d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwYTdhODdiZTIzZGFjMGNlYTRmNjVhZjA3OTU2YzY1MzYwMTUwNmQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-16T07:01:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-16T07:01:07Z"}, "message": "Rollup merge of #74295 - ssomers:btree_comments, r=Mark-Simulacrum\n\nAdd and fix BTreeMap comments\n\nNo code changed (yet)", "tree": {"sha": "03d29acc18d02c3eafc7049714f7cf89bf77d98b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03d29acc18d02c3eafc7049714f7cf89bf77d98b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80a7a87be23dac0cea4f65af07956c653601506d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfD/s0CRBK7hj4Ov3rIwAAdHIIAGq508AizqWgaKgrYAHFqr7A\npRxxJzEiPxlrzVvathdrEaeuMfAvRtfuvnd6bSPgoE04Yv64ZtLgZnysqHcZSo/w\nnp7DE232COlAdUyoY9awvHV0mTaPgSjn6EHlAi7/vqB9HD29TfIIfmmOhvS4y6eC\njctGWTt0T/iSxAdoC5bWH7Y8+QentnsHGUjhxSuPlu9emkEdgTrbsM31jumypcge\nsbxHBu1AeL9hkILU+VxZdTucvnooBcuEfMYLDbBktsMi3WO+R38DUDlwl79VlGP9\n6xUHZUxNvApFUA+dpjwRgfm0f15M16OUB3PWJTCXC3kXP07JaBAFgq97OwmZSEo=\n=Gc20\n-----END PGP SIGNATURE-----\n", "payload": "tree 03d29acc18d02c3eafc7049714f7cf89bf77d98b\nparent 5b10e47433f28f474045c7662a841176f341f743\nparent 2aa3133c530b40ea0448d3c6a5507aeb40aaa558\nauthor Manish Goregaokar <manishsmail@gmail.com> 1594882867 -0700\ncommitter GitHub <noreply@github.com> 1594882867 -0700\n\nRollup merge of #74295 - ssomers:btree_comments, r=Mark-Simulacrum\n\nAdd and fix BTreeMap comments\n\nNo code changed (yet)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80a7a87be23dac0cea4f65af07956c653601506d", "html_url": "https://github.com/rust-lang/rust/commit/80a7a87be23dac0cea4f65af07956c653601506d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80a7a87be23dac0cea4f65af07956c653601506d/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b10e47433f28f474045c7662a841176f341f743", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b10e47433f28f474045c7662a841176f341f743", "html_url": "https://github.com/rust-lang/rust/commit/5b10e47433f28f474045c7662a841176f341f743"}, {"sha": "2aa3133c530b40ea0448d3c6a5507aeb40aaa558", "url": "https://api.github.com/repos/rust-lang/rust/commits/2aa3133c530b40ea0448d3c6a5507aeb40aaa558", "html_url": "https://github.com/rust-lang/rust/commit/2aa3133c530b40ea0448d3c6a5507aeb40aaa558"}], "stats": {"total": 43, "additions": 25, "deletions": 18}, "files": [{"sha": "f3781db1cf784ef9b32654f29cf7632d9f6a9135", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80a7a87be23dac0cea4f65af07956c653601506d/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a7a87be23dac0cea4f65af07956c653601506d/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=80a7a87be23dac0cea4f65af07956c653601506d", "patch": "@@ -1697,6 +1697,8 @@ where\n     pred: F,\n     inner: DrainFilterInner<'a, K, V>,\n }\n+/// Most of the implementation of DrainFilter, independent of the type\n+/// of the predicate, thus also serving for BTreeSet::DrainFilter.\n pub(super) struct DrainFilterInner<'a, K: 'a, V: 'a> {\n     length: &'a mut usize,\n     cur_leaf_edge: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,"}, {"sha": "44f0e25bbd79888e770eaf1c98131a63750bbebf", "filename": "src/liballoc/collections/btree/navigate.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/80a7a87be23dac0cea4f65af07956c653601506d/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a7a87be23dac0cea4f65af07956c653601506d/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=80a7a87be23dac0cea4f65af07956c653601506d", "patch": "@@ -161,15 +161,16 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n     /// Moves the leaf edge handle to the next leaf edge and returns the key and value\n     /// in between, while deallocating any node left behind.\n-    /// Unsafe for three reasons:\n+    /// Unsafe for two reasons:\n     /// - The caller must ensure that the leaf edge is not the last one in the tree\n     ///   and is not a handle previously resulting from counterpart `next_back_unchecked`.\n-    /// - If the leaf edge is the last edge of a node, that node and possibly ancestors\n+    /// - Further use of the updated leaf edge handle is very dangerous. In particular,\n+    ///   if the leaf edge is the last edge of a node, that node and possibly ancestors\n     ///   will be deallocated, while the reference to those nodes in the surviving ancestor\n-    ///   is left dangling; thus further use of the leaf edge handle is dangerous.\n-    ///   It is, however, safe to call this method again on the updated handle.\n-    ///   if the two preconditions above hold.\n-    /// - Using the updated handle may well invalidate the returned references.\n+    ///   is left dangling.\n+    ///   The only safe way to proceed with the updated handle is to compare it, drop it,\n+    ///   call this method again subject to both preconditions listed in the first point,\n+    ///   or call counterpart `next_back_unchecked` subject to its preconditions.\n     pub unsafe fn next_unchecked(&mut self) -> (K, V) {\n         unsafe {\n             replace(self, |leaf_edge| {\n@@ -183,15 +184,16 @@ impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n \n     /// Moves the leaf edge handle to the previous leaf edge and returns the key\n     /// and value in between, while deallocating any node left behind.\n-    /// Unsafe for three reasons:\n+    /// Unsafe for two reasons:\n     /// - The caller must ensure that the leaf edge is not the first one in the tree\n     ///   and is not a handle previously resulting from counterpart `next_unchecked`.\n-    /// - If the lead edge is the first edge of a node, that node and possibly ancestors\n+    /// - Further use of the updated leaf edge handle is very dangerous. In particular,\n+    ///   if the leaf edge is the first edge of a node, that node and possibly ancestors\n     ///   will be deallocated, while the reference to those nodes in the surviving ancestor\n-    ///   is left dangling; thus further use of the leaf edge handle is dangerous.\n-    ///   It is, however, safe to call this method again on the updated handle.\n-    ///   if the two preconditions above hold.\n-    /// - Using the updated handle may well invalidate the returned references.\n+    ///   is left dangling.\n+    ///   The only safe way to proceed with the updated handle is to compare it, drop it,\n+    ///   call this method again subject to both preconditions listed in the first point,\n+    ///   or call counterpart `next_unchecked` subject to its preconditions.\n     pub unsafe fn next_back_unchecked(&mut self) -> (K, V) {\n         unsafe {\n             replace(self, |leaf_edge| {"}, {"sha": "ce74d4f8ee688ec1e1933642d3f1f2f4fd1a1417", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/80a7a87be23dac0cea4f65af07956c653601506d/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a7a87be23dac0cea4f65af07956c653601506d/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=80a7a87be23dac0cea4f65af07956c653601506d", "patch": "@@ -94,7 +94,8 @@ struct InternalNode<K, V> {\n     data: LeafNode<K, V>,\n \n     /// The pointers to the children of this node. `len + 1` of these are considered\n-    /// initialized and valid.\n+    /// initialized and valid. Although during the process of `into_iter` or `drop`,\n+    /// some pointers are dangling while others still need to be traversed.\n     edges: [MaybeUninit<BoxedNode<K, V>>; 2 * B],\n }\n \n@@ -408,7 +409,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n \n impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     /// Unsafely asserts to the compiler some static information about whether this\n-    /// node is a `Leaf`.\n+    /// node is a `Leaf` or an `Internal`.\n     unsafe fn cast_unchecked<NewType>(&mut self) -> NodeRef<marker::Mut<'_>, K, V, NewType> {\n         NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n     }\n@@ -515,7 +516,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n-    /// Adds a key/value pair the end of the node.\n+    /// Adds a key/value pair to the end of the node.\n     pub fn push(&mut self, key: K, val: V) {\n         assert!(self.len() < CAPACITY);\n \n@@ -602,8 +603,10 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n-    /// Removes a key/value pair from the end of this node. If this is an internal node,\n-    /// also removes the edge that was to the right of that pair.\n+    /// Removes a key/value pair from the end of this node and returns the pair.\n+    /// If this is an internal node, also removes the edge that was to the right\n+    /// of that pair and returns the orphaned node that this edge owned with its\n+    /// parent erased.\n     pub fn pop(&mut self) -> (K, V, Option<Root<K, V>>) {\n         assert!(self.len() > 0);\n \n@@ -883,7 +886,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n     }\n \n     /// Unsafely asserts to the compiler some static information about whether the underlying\n-    /// node of this handle is a `Leaf`.\n+    /// node of this handle is a `Leaf` or an `Internal`.\n     unsafe fn cast_unchecked<NewType>(\n         &mut self,\n     ) -> Handle<NodeRef<marker::Mut<'_>, K, V, NewType>, marker::Edge> {"}]}