{"sha": "6a5e6572cbc6ad3260eb454e3505c85631d38e87", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhNWU2NTcyY2JjNmFkMzI2MGViNDU0ZTM1MDVjODU2MzFkMzhlODc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-08-22T18:38:56Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-08-22T18:38:56Z"}, "message": "rustc_metadata: Move some code around to merge impls of `CrateMetadataRef`", "tree": {"sha": "45f371efdf41aa994b21c3deeb25376068524259", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45f371efdf41aa994b21c3deeb25376068524259"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a5e6572cbc6ad3260eb454e3505c85631d38e87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a5e6572cbc6ad3260eb454e3505c85631d38e87", "html_url": "https://github.com/rust-lang/rust/commit/6a5e6572cbc6ad3260eb454e3505c85631d38e87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a5e6572cbc6ad3260eb454e3505c85631d38e87/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15643d5d90af8b288156be604baa2d4eef7209a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/15643d5d90af8b288156be604baa2d4eef7209a4", "html_url": "https://github.com/rust-lang/rust/commit/15643d5d90af8b288156be604baa2d4eef7209a4"}], "stats": {"total": 104, "additions": 51, "deletions": 53}, "files": [{"sha": "43d76e9fdb4c308cbc256b69307e85599a400aee", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 51, "deletions": 53, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/6a5e6572cbc6ad3260eb454e3505c85631d38e87/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a5e6572cbc6ad3260eb454e3505c85631d38e87/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=6a5e6572cbc6ad3260eb454e3505c85631d38e87", "patch": "@@ -1521,6 +1521,57 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         DefPath::make(self.cnum, id, |parent| self.def_key(parent))\n     }\n \n+    fn def_path_hash_unlocked(\n+        &self,\n+        index: DefIndex,\n+        def_path_hashes: &mut FxHashMap<DefIndex, DefPathHash>,\n+    ) -> DefPathHash {\n+        *def_path_hashes.entry(index).or_insert_with(|| {\n+            self.root.tables.def_path_hashes.get(self, index).unwrap().decode(self)\n+        })\n+    }\n+\n+    #[inline]\n+    fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n+        let mut def_path_hashes = self.def_path_hash_cache.lock();\n+        self.def_path_hash_unlocked(index, &mut def_path_hashes)\n+    }\n+\n+    fn all_def_path_hashes_and_def_ids(&self) -> Vec<(DefPathHash, DefId)> {\n+        let mut def_path_hashes = self.def_path_hash_cache.lock();\n+        (0..self.num_def_ids())\n+            .map(|index| {\n+                let index = DefIndex::from_usize(index);\n+                (self.def_path_hash_unlocked(index, &mut def_path_hashes), self.local_def_id(index))\n+            })\n+            .collect()\n+    }\n+\n+    /// Get the `DepNodeIndex` corresponding this crate. The result of this\n+    /// method is cached in the `dep_node_index` field.\n+    fn get_crate_dep_node_index(&self, tcx: TyCtxt<'tcx>) -> DepNodeIndex {\n+        let mut dep_node_index = self.dep_node_index.load();\n+\n+        if unlikely!(dep_node_index == DepNodeIndex::INVALID) {\n+            // We have not cached the DepNodeIndex for this upstream crate yet,\n+            // so use the dep-graph to find it out and cache it.\n+            // Note that multiple threads can enter this block concurrently.\n+            // That is fine because the DepNodeIndex remains constant\n+            // throughout the whole compilation session, and multiple stores\n+            // would always write the same value.\n+\n+            let def_path_hash = self.def_path_hash(CRATE_DEF_INDEX);\n+            let dep_node =\n+                DepNode::from_def_path_hash(def_path_hash, dep_graph::DepKind::CrateMetadata);\n+\n+            dep_node_index = tcx.dep_graph.dep_node_index_of(&dep_node);\n+            assert!(dep_node_index != DepNodeIndex::INVALID);\n+            self.dep_node_index.store(dep_node_index);\n+        }\n+\n+        dep_node_index\n+    }\n+\n     /// Imports the source_map from an external crate into the source_map of the crate\n     /// currently being compiled (the \"local crate\").\n     ///\n@@ -1845,59 +1896,6 @@ impl CrateMetadata {\n     }\n }\n \n-impl<'a, 'tcx> CrateMetadataRef<'a> {\n-    fn def_path_hash_unlocked(\n-        &self,\n-        index: DefIndex,\n-        def_path_hashes: &mut FxHashMap<DefIndex, DefPathHash>,\n-    ) -> DefPathHash {\n-        *def_path_hashes.entry(index).or_insert_with(|| {\n-            self.root.tables.def_path_hashes.get(self, index).unwrap().decode(self)\n-        })\n-    }\n-\n-    #[inline]\n-    fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n-        let mut def_path_hashes = self.def_path_hash_cache.lock();\n-        self.def_path_hash_unlocked(index, &mut def_path_hashes)\n-    }\n-\n-    fn all_def_path_hashes_and_def_ids(&self) -> Vec<(DefPathHash, DefId)> {\n-        let mut def_path_hashes = self.def_path_hash_cache.lock();\n-        (0..self.num_def_ids())\n-            .map(|index| {\n-                let index = DefIndex::from_usize(index);\n-                (self.def_path_hash_unlocked(index, &mut def_path_hashes), self.local_def_id(index))\n-            })\n-            .collect()\n-    }\n-\n-    /// Get the `DepNodeIndex` corresponding this crate. The result of this\n-    /// method is cached in the `dep_node_index` field.\n-    fn get_crate_dep_node_index(&self, tcx: TyCtxt<'tcx>) -> DepNodeIndex {\n-        let mut dep_node_index = self.dep_node_index.load();\n-\n-        if unlikely!(dep_node_index == DepNodeIndex::INVALID) {\n-            // We have not cached the DepNodeIndex for this upstream crate yet,\n-            // so use the dep-graph to find it out and cache it.\n-            // Note that multiple threads can enter this block concurrently.\n-            // That is fine because the DepNodeIndex remains constant\n-            // throughout the whole compilation session, and multiple stores\n-            // would always write the same value.\n-\n-            let def_path_hash = self.def_path_hash(CRATE_DEF_INDEX);\n-            let dep_node =\n-                DepNode::from_def_path_hash(def_path_hash, dep_graph::DepKind::CrateMetadata);\n-\n-            dep_node_index = tcx.dep_graph.dep_node_index_of(&dep_node);\n-            assert!(dep_node_index != DepNodeIndex::INVALID);\n-            self.dep_node_index.store(dep_node_index);\n-        }\n-\n-        dep_node_index\n-    }\n-}\n-\n // Cannot be implemented on 'ProcMacro', as libproc_macro\n // does not depend on librustc_ast\n fn macro_kind(raw: &ProcMacro) -> MacroKind {"}]}