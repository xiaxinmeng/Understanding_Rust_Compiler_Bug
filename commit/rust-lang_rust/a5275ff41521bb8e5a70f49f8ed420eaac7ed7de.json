{"sha": "a5275ff41521bb8e5a70f49f8ed420eaac7ed7de", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1Mjc1ZmY0MTUyMWJiOGU1YTcwZjQ5ZjhlZDQyMGVhYWM3ZWQ3ZGU=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-06-20T19:57:23Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-07-15T14:54:05Z"}, "message": "Don't run everybody_loops for rustdoc\n\nInstead, ignore resolution errors that occur in item bodies.\n\nThe reason this can't ignore item bodies altogether is because\n`const fn` could be used in generic types, for example `[T; f()]`", "tree": {"sha": "c45a96121e03ea4ef4b5e8597b491544376b4f2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c45a96121e03ea4ef4b5e8597b491544376b4f2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5275ff41521bb8e5a70f49f8ed420eaac7ed7de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5275ff41521bb8e5a70f49f8ed420eaac7ed7de", "html_url": "https://github.com/rust-lang/rust/commit/a5275ff41521bb8e5a70f49f8ed420eaac7ed7de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5275ff41521bb8e5a70f49f8ed420eaac7ed7de/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6764c42ab3a7d8875680536ec1e8df7d0ed3100", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6764c42ab3a7d8875680536ec1e8df7d0ed3100", "html_url": "https://github.com/rust-lang/rust/commit/f6764c42ab3a7d8875680536ec1e8df7d0ed3100"}], "stats": {"total": 79, "additions": 50, "deletions": 29}, "files": [{"sha": "1862b47b9adb3b37e6eade69e01677c80b2bb4b6", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a5275ff41521bb8e5a70f49f8ed420eaac7ed7de/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5275ff41521bb8e5a70f49f8ed420eaac7ed7de/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=a5275ff41521bb8e5a70f49f8ed420eaac7ed7de", "patch": "@@ -354,24 +354,13 @@ fn configure_and_expand_inner<'a>(\n         )\n     });\n \n-    // If we're actually rustdoc then there's no need to actually compile\n-    // anything, so switch everything to just looping\n-    let mut should_loop = sess.opts.actually_rustdoc;\n-    if let Some(PpMode::PpmSource(PpSourceMode::PpmEveryBodyLoops)) = sess.opts.pretty {\n-        should_loop |= true;\n-    }\n-    if should_loop {\n-        log::debug!(\"replacing bodies with loop {{}}\");\n-        util::ReplaceBodyWithLoop::new(&mut resolver).visit_crate(&mut krate);\n-    }\n+    let crate_types = sess.crate_types();\n+    let is_proc_macro_crate = crate_types.contains(&CrateType::ProcMacro);\n \n     let has_proc_macro_decls = sess.time(\"AST_validation\", || {\n         rustc_ast_passes::ast_validation::check_crate(sess, &krate, &mut resolver.lint_buffer())\n     });\n \n-    let crate_types = sess.crate_types();\n-    let is_proc_macro_crate = crate_types.contains(&CrateType::ProcMacro);\n-\n     // For backwards compatibility, we don't try to run proc macro injection\n     // if rustdoc is run on a proc macro crate without '--crate-type proc-macro' being\n     // specified. This should only affect users who manually invoke 'rustdoc', as\n@@ -417,7 +406,19 @@ fn configure_and_expand_inner<'a>(\n         println!(\"{}\", json::as_json(&krate));\n     }\n \n-    resolver.resolve_crate(&krate);\n+    // If we're actually rustdoc then avoid giving a name resolution error for `cfg()` items.\n+    // anything, so switch everything to just looping\n+    resolver.resolve_crate(&krate, sess.opts.actually_rustdoc);\n+\n+    //let mut should_loop = sess.opts.actually_rustdoc;\n+    let mut should_loop = false;\n+    if let Some(PpMode::PpmSource(PpSourceMode::PpmEveryBodyLoops)) = sess.opts.pretty {\n+        should_loop |= true;\n+    }\n+    if should_loop {\n+        log::debug!(\"replacing bodies with loop {{}}\");\n+        util::ReplaceBodyWithLoop::new(&mut resolver).visit_crate(&mut krate);\n+    }\n \n     // Needs to go *after* expansion to be able to check the results of macro expansion.\n     sess.time(\"complete_gated_feature_checking\", || {"}, {"sha": "ddce82494e1bad3c82b46a3483b2f28ad9bf30bc", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a5275ff41521bb8e5a70f49f8ed420eaac7ed7de/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5275ff41521bb8e5a70f49f8ed420eaac7ed7de/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=a5275ff41521bb8e5a70f49f8ed420eaac7ed7de", "patch": "@@ -394,6 +394,11 @@ struct LateResolutionVisitor<'a, 'b, 'ast> {\n \n     /// Fields used to add information to diagnostic errors.\n     diagnostic_metadata: DiagnosticMetadata<'ast>,\n+\n+    /// Whether to report resolution errors for item bodies.\n+    ///\n+    /// In particular, rustdoc uses this to avoid giving errors for `cfg()` items.\n+    ignore_bodies: bool,\n }\n \n /// Walks the whole crate in DFS order, visiting each item, resolving names as it goes.\n@@ -627,7 +632,10 @@ impl<'a, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n }\n \n impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n-    fn new(resolver: &'b mut Resolver<'a>) -> LateResolutionVisitor<'a, 'b, 'ast> {\n+    fn new(\n+        resolver: &'b mut Resolver<'a>,\n+        ignore_bodies: bool,\n+    ) -> LateResolutionVisitor<'a, 'b, 'ast> {\n         // During late resolution we only track the module component of the parent scope,\n         // although it may be useful to track other components as well for diagnostics.\n         let graph_root = resolver.graph_root;\n@@ -644,6 +652,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             label_ribs: Vec::new(),\n             current_trait_ref: None,\n             diagnostic_metadata: DiagnosticMetadata::default(),\n+            ignore_bodies,\n         }\n     }\n \n@@ -757,7 +766,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 return if self.is_label_valid_from_rib(i) {\n                     Some(*id)\n                 } else {\n-                    self.r.report_error(\n+                    self.report_error(\n                         original_span,\n                         ResolutionError::UnreachableLabel {\n                             name: label.name,\n@@ -775,7 +784,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             suggestion = suggestion.or_else(|| self.suggestion_for_label_in_rib(i, label));\n         }\n \n-        self.r.report_error(\n+        self.report_error(\n             original_span,\n             ResolutionError::UndeclaredLabel { name: label.name, suggestion },\n         );\n@@ -1008,7 +1017,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             if seen_bindings.contains_key(&ident) {\n                 let span = seen_bindings.get(&ident).unwrap();\n                 let err = ResolutionError::NameAlreadyUsedInParameterList(ident.name, *span);\n-                self.r.report_error(param.ident.span, err);\n+                self.report_error(param.ident.span, err);\n             }\n             seen_bindings.entry(ident).or_insert(param.ident.span);\n \n@@ -1274,7 +1283,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 .is_err()\n             {\n                 let path = &self.current_trait_ref.as_ref().unwrap().1.path;\n-                self.r.report_error(span, err(ident.name, &path_names_to_string(path)));\n+                self.report_error(span, err(ident.name, &path_names_to_string(path)));\n             }\n         }\n     }\n@@ -1390,7 +1399,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             if inconsistent_vars.contains_key(name) {\n                 v.could_be_path = false;\n             }\n-            self.r.report_error(\n+            self.report_error(\n                 *v.origin.iter().next().unwrap(),\n                 ResolutionError::VariableNotBoundInPattern(v),\n             );\n@@ -1400,7 +1409,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         let mut inconsistent_vars = inconsistent_vars.iter().collect::<Vec<_>>();\n         inconsistent_vars.sort();\n         for (name, v) in inconsistent_vars {\n-            self.r.report_error(v.0, ResolutionError::VariableBoundWithDifferentMode(*name, v.1));\n+            self.report_error(v.0, ResolutionError::VariableBoundWithDifferentMode(*name, v.1));\n         }\n \n         // 5) Finally bubble up all the binding maps.\n@@ -1550,7 +1559,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // `Variant(a, a)`:\n                 _ => IdentifierBoundMoreThanOnceInSamePattern,\n             };\n-            self.r.report_error(ident.span, error(ident.name));\n+            self.report_error(ident.span, error(ident.name));\n         }\n \n         // Record as bound if it's valid:\n@@ -1624,7 +1633,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // to something unusable as a pattern (e.g., constructor function),\n                 // but we still conservatively report an error, see\n                 // issues/33118#issuecomment-233962221 for one reason why.\n-                self.r.report_error(\n+                self.report_error(\n                     ident.span,\n                     ResolutionError::BindingShadowsSomethingUnacceptable(\n                         pat_src.descr(),\n@@ -1809,7 +1818,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n             Err(err) => {\n                 if let Some(err) = report_errors_for_call(self, err) {\n-                    self.r.report_error(err.span, err.node);\n+                    self.report_error(err.span, err.node);\n                 }\n \n                 PartialRes::new(Res::Err)\n@@ -1843,6 +1852,15 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n     }\n \n+    /// A wrapper around [`Resolver::report_error`].\n+    ///\n+    /// This doesn't emit errors for function bodies if `ignore_bodies` is set.\n+    fn report_error(&self, span: Span, resolution_error: ResolutionError<'_>) {\n+        if !self.ignore_bodies || self.diagnostic_metadata.current_function.is_none() {\n+            self.r.report_error(span, resolution_error);\n+        }\n+    }\n+\n     // Resolve in alternative namespaces if resolution in the primary namespace fails.\n     fn resolve_qpath_anywhere(\n         &mut self,\n@@ -2339,8 +2357,8 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n }\n \n impl<'a> Resolver<'a> {\n-    pub(crate) fn late_resolve_crate(&mut self, krate: &Crate) {\n-        let mut late_resolution_visitor = LateResolutionVisitor::new(self);\n+    pub(crate) fn late_resolve_crate(&mut self, krate: &Crate, ignore_bodies: bool) {\n+        let mut late_resolution_visitor = LateResolutionVisitor::new(self, ignore_bodies);\n         visit::walk_crate(&mut late_resolution_visitor, krate);\n         for (id, span) in late_resolution_visitor.diagnostic_metadata.unused_labels.iter() {\n             self.lint_buffer.buffer_lint(lint::builtin::UNUSED_LABELS, *id, *span, \"unused label\");"}, {"sha": "786dc28ba0eeca637a42154b5890e54a14374834", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5275ff41521bb8e5a70f49f8ed420eaac7ed7de/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5275ff41521bb8e5a70f49f8ed420eaac7ed7de/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a5275ff41521bb8e5a70f49f8ed420eaac7ed7de", "patch": "@@ -1441,13 +1441,13 @@ impl<'a> Resolver<'a> {\n     }\n \n     /// Entry point to crate resolution.\n-    pub fn resolve_crate(&mut self, krate: &Crate) {\n+    pub fn resolve_crate(&mut self, krate: &Crate, ignore_bodies: bool) {\n         let _prof_timer = self.session.prof.generic_activity(\"resolve_crate\");\n \n         ImportResolver { r: self }.finalize_imports();\n         self.finalize_macro_resolutions();\n \n-        self.late_resolve_crate(krate);\n+        self.late_resolve_crate(krate, ignore_bodies);\n \n         self.check_unused(krate);\n         self.report_errors(krate);"}, {"sha": "8664930bc94f4667f4fe21fe65caf93f6c85eb05", "filename": "src/test/rustdoc/doc-cfg.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5275ff41521bb8e5a70f49f8ed420eaac7ed7de/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5275ff41521bb8e5a70f49f8ed420eaac7ed7de/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs?ref=a5275ff41521bb8e5a70f49f8ed420eaac7ed7de", "patch": "@@ -57,5 +57,7 @@ pub unsafe fn uses_target_feature() {\n //        'This is supported with target feature avx only.'\n #[doc(cfg(target_feature = \"avx\"))]\n pub fn uses_cfg_target_feature() {\n-    uses_target_feature();\n+    unsafe {\n+        uses_target_feature();\n+    }\n }"}]}