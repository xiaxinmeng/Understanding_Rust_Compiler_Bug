{"sha": "a0322defc375d7fd3890225768a85a31f2bdb0be", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwMzIyZGVmYzM3NWQ3ZmQzODkwMjI1NzY4YTg1YTMxZjJiZGIwYmU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-02-14T16:17:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-14T16:17:03Z"}, "message": "Merge #7656\n\n7656: Implement constructor usage search for almost all items r=matklad a=Veykril\n\nThis PR moves the filering for enum constructors to the HIR, with this unprefixed variants as well as when the enum has been renamed via use will then still show up properly.\r\nWe now walk the ast of the `NameRef` up until we find a `PathExpr`(which also handles `CallExpr` for tuple-type structs and variants already) or a `RecordExpr`. For enum search we then take the `path` out of that expression and do a resolution on it to compare it with the definition enum.\r\nWith this PR we now support searching for all constructor literals, Unit-, Tuple- and Record-Structs, Unit-, Tuple- and Record-Variants as well as Unions.\r\n\r\nThere is one shortcoming due to how the search is triggered. Unit Variants constructors can't be searched as we have no position for it to kick off the search(since a comma doesn't have to exist for the last variant).\r\n\r\nCloses #2549 though it doesn't implement it as outlined in the issue since the reference kind was removed recently, though I believe the approach taken here is better personally.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "e09243414c566cde0ecdb500e7441bf21ead1d0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e09243414c566cde0ecdb500e7441bf21ead1d0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0322defc375d7fd3890225768a85a31f2bdb0be", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgKUz/CRBK7hj4Ov3rIwAAdHIIAFcwGvF/ddqUPdFPechxL3fO\nAZiK9WZvuB8CauhqkDYTy2FeMeAc+BHFs1ZBfKpnfe7LndgtSjuUiRzU/3ERKD/h\n+64og+0Nqv9IzmQ9MTpyubRzxDVjPak5V1rwb7/gLzhXg/gUZB1U2zc74a/d2h4x\n8k08XwWxKzh1nlxSoEvjyzuJubcX8L0I2AT1qW8BgWoh9yK9Ifgzf6ILGbeAG0IU\nDIf69enE0yniuLeZlOYFVlMlWs8ddt/9AA6AF4Vkmu6HujT1hn22U6yFzzhWMviv\nYEnCpKfk1M0rcEq/jw1nLTqBsolVhq0E4BdwHvhSe5p6newtgm3mhYN7WINyeJM=\n=n9CF\n-----END PGP SIGNATURE-----\n", "payload": "tree e09243414c566cde0ecdb500e7441bf21ead1d0e\nparent d50a37d3aa473937919030b39587df3d93f9bd8c\nparent 8ac6041bcf7c970104939bdbdda5af4873ebd472\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1613319423 +0000\ncommitter GitHub <noreply@github.com> 1613319423 +0000\n\nMerge #7656\n\n7656: Implement constructor usage search for almost all items r=matklad a=Veykril\n\nThis PR moves the filering for enum constructors to the HIR, with this unprefixed variants as well as when the enum has been renamed via use will then still show up properly.\r\nWe now walk the ast of the `NameRef` up until we find a `PathExpr`(which also handles `CallExpr` for tuple-type structs and variants already) or a `RecordExpr`. For enum search we then take the `path` out of that expression and do a resolution on it to compare it with the definition enum.\r\nWith this PR we now support searching for all constructor literals, Unit-, Tuple- and Record-Structs, Unit-, Tuple- and Record-Variants as well as Unions.\r\n\r\nThere is one shortcoming due to how the search is triggered. Unit Variants constructors can't be searched as we have no position for it to kick off the search(since a comma doesn't have to exist for the last variant).\r\n\r\nCloses #2549 though it doesn't implement it as outlined in the issue since the reference kind was removed recently, though I believe the approach taken here is better personally.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0322defc375d7fd3890225768a85a31f2bdb0be", "html_url": "https://github.com/rust-lang/rust/commit/a0322defc375d7fd3890225768a85a31f2bdb0be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0322defc375d7fd3890225768a85a31f2bdb0be/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d50a37d3aa473937919030b39587df3d93f9bd8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d50a37d3aa473937919030b39587df3d93f9bd8c", "html_url": "https://github.com/rust-lang/rust/commit/d50a37d3aa473937919030b39587df3d93f9bd8c"}, {"sha": "8ac6041bcf7c970104939bdbdda5af4873ebd472", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ac6041bcf7c970104939bdbdda5af4873ebd472", "html_url": "https://github.com/rust-lang/rust/commit/8ac6041bcf7c970104939bdbdda5af4873ebd472"}], "stats": {"total": 275, "additions": 172, "deletions": 103}, "files": [{"sha": "9b228443f86bfdb89ac8dad094f2ed17091731ee", "filename": "crates/assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a0322defc375d7fd3890225768a85a31f2bdb0be/crates%2Fassists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0322defc375d7fd3890225768a85a31f2bdb0be/crates%2Fassists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=a0322defc375d7fd3890225768a85a31f2bdb0be", "patch": "@@ -1,6 +1,5 @@\n-use std::collections::HashMap;\n-\n use ide_db::{defs::Definition, search::FileReference};\n+use rustc_hash::FxHashMap;\n use syntax::{\n     ast::{self, AstNode, AstToken},\n     TextRange,\n@@ -111,7 +110,7 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n                 .collect::<Result<_, _>>()\n                 .map(|b| (file_id, b))\n         })\n-        .collect::<Result<HashMap<_, Vec<_>>, _>>()?;\n+        .collect::<Result<FxHashMap<_, Vec<_>>, _>>()?;\n \n     let init_str = initializer_expr.syntax().text().to_string();\n     let init_in_paren = format!(\"({})\", &init_str);"}, {"sha": "a83b82f1b6ca36f9dfb7daf8457c44270e88b87c", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 170, "deletions": 100, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/a0322defc375d7fd3890225768a85a31f2bdb0be/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0322defc375d7fd3890225768a85a31f2bdb0be/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=a0322defc375d7fd3890225768a85a31f2bdb0be", "patch": "@@ -11,7 +11,7 @@\n \n pub(crate) mod rename;\n \n-use hir::Semantics;\n+use hir::{PathResolution, Semantics};\n use ide_db::{\n     base_db::FileId,\n     defs::{Definition, NameClass, NameRefClass},\n@@ -22,7 +22,7 @@ use rustc_hash::FxHashMap;\n use syntax::{\n     algo::find_node_at_offset,\n     ast::{self, NameOwner},\n-    AstNode, SyntaxNode, TextRange, TokenAtOffset, T,\n+    match_ast, AstNode, SyntaxNode, TextRange, T,\n };\n \n use crate::{display::TryToNav, FilePosition, NavigationTarget};\n@@ -47,29 +47,40 @@ pub(crate) fn find_all_refs(\n     let _p = profile::span(\"find_all_refs\");\n     let syntax = sema.parse(position.file_id).syntax().clone();\n \n-    let (opt_name, ctor_filter): (_, Option<fn(&_) -> bool>) = if let Some(name) =\n-        get_struct_def_name_for_struct_literal_search(&sema, &syntax, position)\n-    {\n-        (\n-            Some(name),\n-            Some(|name_ref| is_record_lit_name_ref(name_ref) || is_call_expr_name_ref(name_ref)),\n-        )\n-    } else if let Some(name) = get_enum_def_name_for_struct_literal_search(&sema, &syntax, position)\n-    {\n-        (Some(name), Some(is_enum_lit_name_ref))\n-    } else {\n-        (sema.find_node_at_offset_with_descend::<ast::Name>(&syntax, position.offset), None)\n-    };\n-\n-    let def = find_def(&sema, &syntax, position, opt_name)?;\n+    let (def, is_literal_search) =\n+        if let Some(name) = get_name_of_item_declaration(&syntax, position) {\n+            (NameClass::classify(sema, &name)?.referenced_or_defined(sema.db), true)\n+        } else {\n+            (find_def(&sema, &syntax, position)?, false)\n+        };\n \n     let mut usages = def.usages(sema).set_scope(search_scope).all();\n-    if let Some(ctor_filter) = ctor_filter {\n+    if is_literal_search {\n         // filter for constructor-literals\n-        usages.references.values_mut().for_each(|it| {\n-            it.retain(|reference| reference.name.as_name_ref().map_or(false, ctor_filter));\n-        });\n-        usages.references.retain(|_, it| !it.is_empty());\n+        let refs = usages.references.values_mut();\n+        match def {\n+            Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Enum(enum_))) => {\n+                refs.for_each(|it| {\n+                    it.retain(|reference| {\n+                        reference\n+                            .name\n+                            .as_name_ref()\n+                            .map_or(false, |name_ref| is_enum_lit_name_ref(sema, enum_, name_ref))\n+                    })\n+                });\n+                usages.references.retain(|_, it| !it.is_empty());\n+            }\n+            Definition::ModuleDef(hir::ModuleDef::Adt(_))\n+            | Definition::ModuleDef(hir::ModuleDef::Variant(_)) => {\n+                refs.for_each(|it| {\n+                    it.retain(|reference| {\n+                        reference.name.as_name_ref().map_or(false, is_lit_name_ref)\n+                    })\n+                });\n+                usages.references.retain(|_, it| !it.is_empty());\n+            }\n+            _ => {}\n+        }\n     }\n     let nav = def.try_to_nav(sema.db)?;\n     let decl_range = nav.focus_or_full_range();\n@@ -89,9 +100,9 @@ fn find_def(\n     sema: &Semantics<RootDatabase>,\n     syntax: &SyntaxNode,\n     position: FilePosition,\n-    opt_name: Option<ast::Name>,\n ) -> Option<Definition> {\n-    if let Some(name) = opt_name {\n+    if let Some(name) = sema.find_node_at_offset_with_descend::<ast::Name>(&syntax, position.offset)\n+    {\n         let class = NameClass::classify(sema, &name)?;\n         Some(class.referenced_or_defined(sema.db))\n     } else if let Some(lifetime) =\n@@ -134,95 +145,85 @@ fn decl_access(def: &Definition, syntax: &SyntaxNode, range: TextRange) -> Optio\n     None\n }\n \n-fn get_struct_def_name_for_struct_literal_search(\n-    sema: &Semantics<RootDatabase>,\n-    syntax: &SyntaxNode,\n-    position: FilePosition,\n-) -> Option<ast::Name> {\n-    if let TokenAtOffset::Between(ref left, ref right) = syntax.token_at_offset(position.offset) {\n-        if right.kind() != T!['{'] && right.kind() != T!['('] {\n-            return None;\n-        }\n-        if let Some(name) =\n-            sema.find_node_at_offset_with_descend::<ast::Name>(&syntax, left.text_range().start())\n-        {\n-            return name.syntax().ancestors().find_map(ast::Struct::cast).and_then(|l| l.name());\n+fn get_name_of_item_declaration(syntax: &SyntaxNode, position: FilePosition) -> Option<ast::Name> {\n+    let token = syntax.token_at_offset(position.offset).right_biased()?;\n+    let kind = token.kind();\n+    if kind == T![;] {\n+        ast::Struct::cast(token.parent())\n+            .filter(|struct_| struct_.field_list().is_none())\n+            .and_then(|struct_| struct_.name())\n+    } else if kind == T!['{'] {\n+        match_ast! {\n+            match (token.parent()) {\n+                ast::RecordFieldList(rfl) => match_ast! {\n+                    match (rfl.syntax().parent()?) {\n+                        ast::Variant(it) => it.name(),\n+                        ast::Struct(it) => it.name(),\n+                        ast::Union(it) => it.name(),\n+                        _ => None,\n+                    }\n+                },\n+                ast::VariantList(vl) => ast::Enum::cast(vl.syntax().parent()?)?.name(),\n+                _ => None,\n+            }\n         }\n-        if sema\n-            .find_node_at_offset_with_descend::<ast::GenericParamList>(\n-                &syntax,\n-                left.text_range().start(),\n-            )\n-            .is_some()\n-        {\n-            return left.ancestors().find_map(ast::Struct::cast).and_then(|l| l.name());\n+    } else if kind == T!['('] {\n+        let tfl = ast::TupleFieldList::cast(token.parent())?;\n+        match_ast! {\n+            match (tfl.syntax().parent()?) {\n+                ast::Variant(it) => it.name(),\n+                ast::Struct(it) => it.name(),\n+                _ => None,\n+            }\n         }\n+    } else {\n+        None\n     }\n-    None\n }\n \n-fn get_enum_def_name_for_struct_literal_search(\n+fn is_enum_lit_name_ref(\n     sema: &Semantics<RootDatabase>,\n-    syntax: &SyntaxNode,\n-    position: FilePosition,\n-) -> Option<ast::Name> {\n-    if let TokenAtOffset::Between(ref left, ref right) = syntax.token_at_offset(position.offset) {\n-        if right.kind() != T!['{'] && right.kind() != T!['('] {\n-            return None;\n-        }\n-        if let Some(name) =\n-            sema.find_node_at_offset_with_descend::<ast::Name>(&syntax, left.text_range().start())\n-        {\n-            return name.syntax().ancestors().find_map(ast::Enum::cast).and_then(|l| l.name());\n-        }\n-        if sema\n-            .find_node_at_offset_with_descend::<ast::GenericParamList>(\n-                &syntax,\n-                left.text_range().start(),\n-            )\n-            .is_some()\n-        {\n-            return left.ancestors().find_map(ast::Enum::cast).and_then(|l| l.name());\n-        }\n-    }\n-    None\n-}\n-\n-fn is_call_expr_name_ref(name_ref: &ast::NameRef) -> bool {\n+    enum_: hir::Enum,\n+    name_ref: &ast::NameRef,\n+) -> bool {\n+    let path_is_variant_of_enum = |path: ast::Path| {\n+        matches!(\n+            sema.resolve_path(&path),\n+            Some(PathResolution::Def(hir::ModuleDef::Variant(variant)))\n+                if variant.parent_enum(sema.db) == enum_\n+        )\n+    };\n     name_ref\n         .syntax()\n         .ancestors()\n-        .find_map(ast::CallExpr::cast)\n-        .and_then(|c| match c.expr()? {\n-            ast::Expr::PathExpr(p) => {\n-                Some(p.path()?.segment()?.name_ref().as_ref() == Some(name_ref))\n+        .find_map(|ancestor| {\n+            match_ast! {\n+                match ancestor {\n+                    ast::PathExpr(path_expr) => path_expr.path().map(path_is_variant_of_enum),\n+                    ast::RecordExpr(record_expr) => record_expr.path().map(path_is_variant_of_enum),\n+                    _ => None,\n+                }\n             }\n-            _ => None,\n         })\n         .unwrap_or(false)\n }\n \n-fn is_record_lit_name_ref(name_ref: &ast::NameRef) -> bool {\n-    name_ref\n-        .syntax()\n-        .ancestors()\n-        .find_map(ast::RecordExpr::cast)\n-        .and_then(|l| l.path())\n-        .and_then(|p| p.segment())\n-        .map(|p| p.name_ref().as_ref() == Some(name_ref))\n-        .unwrap_or(false)\n+fn path_ends_with(path: Option<ast::Path>, name_ref: &ast::NameRef) -> bool {\n+    path.and_then(|path| path.segment())\n+        .and_then(|segment| segment.name_ref())\n+        .map_or(false, |segment| segment == *name_ref)\n }\n \n-fn is_enum_lit_name_ref(name_ref: &ast::NameRef) -> bool {\n-    name_ref\n-        .syntax()\n-        .ancestors()\n-        .find_map(ast::PathExpr::cast)\n-        .and_then(|p| p.path())\n-        .and_then(|p| p.qualifier())\n-        .and_then(|p| p.segment())\n-        .map(|p| p.name_ref().as_ref() == Some(name_ref))\n-        .unwrap_or(false)\n+fn is_lit_name_ref(name_ref: &ast::NameRef) -> bool {\n+    name_ref.syntax().ancestors().find_map(|ancestor| {\n+        match_ast! {\n+            match ancestor {\n+                ast::PathExpr(path_expr) => Some(path_ends_with(path_expr.path(), name_ref)),\n+                ast::RecordExpr(record_expr) => Some(path_ends_with(record_expr.path(), name_ref)),\n+                _ => None,\n+            }\n+        }\n+    }).unwrap_or(false)\n }\n \n #[cfg(test)]\n@@ -312,23 +313,92 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn test_struct_literal_for_union() {\n+        check(\n+            r#\"\n+union Foo $0{\n+    x: u32\n+}\n+\n+fn main() {\n+    let f: Foo;\n+    f = Foo { x: 1 };\n+}\n+\"#,\n+            expect![[r#\"\n+                Foo Union FileId(0) 0..24 6..9\n+\n+                FileId(0) 62..65\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn test_enum_after_space() {\n         check(\n             r#\"\n enum Foo $0{\n     A,\n-    B,\n+    B(),\n+    C{},\n }\n fn main() {\n     let f: Foo;\n     f = Foo::A;\n+    f = Foo::B();\n+    f = Foo::C{};\n }\n \"#,\n             expect![[r#\"\n-                Foo Enum FileId(0) 0..26 5..8\n+                Foo Enum FileId(0) 0..37 5..8\n \n-                FileId(0) 63..66\n+                FileId(0) 74..77\n+                FileId(0) 90..93\n+                FileId(0) 108..111\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_variant_record_after_space() {\n+        check(\n+            r#\"\n+enum Foo {\n+    A $0{ n: i32 },\n+    B,\n+}\n+fn main() {\n+    let f: Foo;\n+    f = Foo::B;\n+    f = Foo::A { n: 92 };\n+}\n+\"#,\n+            expect![[r#\"\n+                A Variant FileId(0) 15..27 15..16\n+\n+                FileId(0) 95..96\n+            \"#]],\n+        );\n+    }\n+    #[test]\n+    fn test_variant_tuple_before_paren() {\n+        check(\n+            r#\"\n+enum Foo {\n+    A$0(i32),\n+    B,\n+}\n+fn main() {\n+    let f: Foo;\n+    f = Foo::B;\n+    f = Foo::A(92);\n+}\n+\"#,\n+            expect![[r#\"\n+                A Variant FileId(0) 15..21 15..16\n+\n+                FileId(0) 89..90\n             \"#]],\n         );\n     }"}]}