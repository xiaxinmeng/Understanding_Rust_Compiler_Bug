{"sha": "e6bae220b7129790805a0689ed1a2f2a2c47aeb4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2YmFlMjIwYjcxMjk3OTA4MDVhMDY4OWVkMWEyZjJhMmM0N2FlYjQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-07-26T18:22:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-26T18:22:29Z"}, "message": "Merge #9701\n\n9701: fix: correctly update diagnostics when files are opened and closed r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "d8f5d97aabd28103caa89bf790b5e95628b27109", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8f5d97aabd28103caa89bf790b5e95628b27109"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6bae220b7129790805a0689ed1a2f2a2c47aeb4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg/v1lCRBK7hj4Ov3rIwAAAwoIAKWf4rotz9Mynij457BOiBWj\nzilhlJ7XaZ0lVwqvEivo185QjIBFyrXHO5Dsid0mO5QGivF7mXWnlkS+RNaVN1bf\nFZnlWNekGMKtYw5qzuXjPeCFis9acoGUngMnu93zKourj0wsb+xpGWzCyI4IFCnR\nYU1hSODqTMvNG2l8JRKn2kRATf6HKoBV65vY0Jn+bjYA/bfCieQOwIy7IyWA5b4I\nGPUn6HXHgGQFOe25Zh7Q8OvMoWIvBOwqHKRpUbY5Ye8wIpDcR8C6q+eBxPwP59O2\nccPwRKSXLOwQI848hHwWhgVbLKLEkE45FHSZqKeu7OZYCPVDaja3k+HK7+smUH8=\n=a9i9\n-----END PGP SIGNATURE-----\n", "payload": "tree d8f5d97aabd28103caa89bf790b5e95628b27109\nparent f0db648cb6785930fa4027fc941c0f1692b5ad59\nparent 891867b1f1aa352c96c1c4416a2846efdcc01670\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1627323749 +0000\ncommitter GitHub <noreply@github.com> 1627323749 +0000\n\nMerge #9701\n\n9701: fix: correctly update diagnostics when files are opened and closed r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6bae220b7129790805a0689ed1a2f2a2c47aeb4", "html_url": "https://github.com/rust-lang/rust/commit/e6bae220b7129790805a0689ed1a2f2a2c47aeb4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6bae220b7129790805a0689ed1a2f2a2c47aeb4/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0db648cb6785930fa4027fc941c0f1692b5ad59", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0db648cb6785930fa4027fc941c0f1692b5ad59", "html_url": "https://github.com/rust-lang/rust/commit/f0db648cb6785930fa4027fc941c0f1692b5ad59"}, {"sha": "891867b1f1aa352c96c1c4416a2846efdcc01670", "url": "https://api.github.com/repos/rust-lang/rust/commits/891867b1f1aa352c96c1c4416a2846efdcc01670", "html_url": "https://github.com/rust-lang/rust/commit/891867b1f1aa352c96c1c4416a2846efdcc01670"}], "stats": {"total": 243, "additions": 143, "deletions": 100}, "files": [{"sha": "cf091510ffad1785f6d8a822636beaa4d8f1edae", "filename": "crates/rust-analyzer/src/document.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f0db648cb6785930fa4027fc941c0f1692b5ad59/crates%2Frust-analyzer%2Fsrc%2Fdocument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0db648cb6785930fa4027fc941c0f1692b5ad59/crates%2Frust-analyzer%2Fsrc%2Fdocument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdocument.rs?ref=f0db648cb6785930fa4027fc941c0f1692b5ad59", "patch": "@@ -1,16 +0,0 @@\n-//! In-memory document information.\n-\n-/// Information about a document that the Language Client\n-/// knows about.\n-/// Its lifetime is driven by the textDocument/didOpen and textDocument/didClose\n-/// client notifications.\n-#[derive(Debug, Clone)]\n-pub(crate) struct DocumentData {\n-    pub(crate) version: i32,\n-}\n-\n-impl DocumentData {\n-    pub(crate) fn new(version: i32) -> Self {\n-        DocumentData { version }\n-    }\n-}"}, {"sha": "b21fff7071a961b20ca0b25871a32fb9199732b7", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e6bae220b7129790805a0689ed1a2f2a2c47aeb4/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6bae220b7129790805a0689ed1a2f2a2c47aeb4/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=e6bae220b7129790805a0689ed1a2f2a2c47aeb4", "patch": "@@ -8,7 +8,7 @@ use std::{sync::Arc, time::Instant};\n use crossbeam_channel::{unbounded, Receiver, Sender};\n use flycheck::FlycheckHandle;\n use ide::{Analysis, AnalysisHost, Cancellable, Change, FileId};\n-use ide_db::base_db::{CrateId, VfsPath};\n+use ide_db::base_db::CrateId;\n use lsp_types::{SemanticTokens, Url};\n use parking_lot::{Mutex, RwLock};\n use project_model::{\n@@ -20,11 +20,11 @@ use vfs::AnchoredPathBuf;\n use crate::{\n     config::Config,\n     diagnostics::{CheckFixes, DiagnosticCollection},\n-    document::DocumentData,\n     from_proto,\n     line_index::{LineEndings, LineIndex},\n     lsp_ext,\n     main_loop::Task,\n+    mem_docs::MemDocs,\n     op_queue::OpQueue,\n     reload::SourceRootConfig,\n     request_metrics::{LatestRequests, RequestMetrics},\n@@ -57,7 +57,7 @@ pub(crate) struct GlobalState {\n     pub(crate) config: Arc<Config>,\n     pub(crate) analysis_host: AnalysisHost,\n     pub(crate) diagnostics: DiagnosticCollection,\n-    pub(crate) mem_docs: FxHashMap<VfsPath, DocumentData>,\n+    pub(crate) mem_docs: MemDocs,\n     pub(crate) semantic_tokens_cache: Arc<Mutex<FxHashMap<Url, SemanticTokens>>>,\n     pub(crate) shutdown_requested: bool,\n     pub(crate) last_reported_status: Option<lsp_ext::ServerStatusParams>,\n@@ -115,7 +115,7 @@ pub(crate) struct GlobalStateSnapshot {\n     pub(crate) analysis: Analysis,\n     pub(crate) check_fixes: CheckFixes,\n     pub(crate) latest_requests: Arc<RwLock<LatestRequests>>,\n-    mem_docs: FxHashMap<VfsPath, DocumentData>,\n+    mem_docs: MemDocs,\n     pub(crate) semantic_tokens_cache: Arc<Mutex<FxHashMap<Url, SemanticTokens>>>,\n     vfs: Arc<RwLock<(vfs::Vfs, FxHashMap<FileId, LineEndings>)>>,\n     pub(crate) workspaces: Arc<Vec<ProjectWorkspace>>,\n@@ -147,7 +147,7 @@ impl GlobalState {\n             config: Arc::new(config.clone()),\n             analysis_host,\n             diagnostics: Default::default(),\n-            mem_docs: FxHashMap::default(),\n+            mem_docs: MemDocs::default(),\n             semantic_tokens_cache: Arc::new(Default::default()),\n             shutdown_requested: false,\n             last_reported_status: None,"}, {"sha": "a5997d69d9ae88b3c674df8cca990b329baeb059", "filename": "crates/rust-analyzer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6bae220b7129790805a0689ed1a2f2a2c47aeb4/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6bae220b7129790805a0689ed1a2f2a2c47aeb4/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flib.rs?ref=e6bae220b7129790805a0689ed1a2f2a2c47aeb4", "patch": "@@ -33,7 +33,7 @@ mod line_index;\n mod request_metrics;\n mod lsp_utils;\n mod thread_pool;\n-mod document;\n+mod mem_docs;\n mod diff;\n mod op_queue;\n pub mod lsp_ext;"}, {"sha": "35fce79f5eb6a4dafaa1baf4e9c53d36e3bc7249", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 71, "deletions": 77, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/e6bae220b7129790805a0689ed1a2f2a2c47aeb4/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6bae220b7129790805a0689ed1a2f2a2c47aeb4/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=e6bae220b7129790805a0689ed1a2f2a2c47aeb4", "patch": "@@ -17,11 +17,11 @@ use vfs::ChangeKind;\n use crate::{\n     config::Config,\n     dispatch::{NotificationDispatcher, RequestDispatcher},\n-    document::DocumentData,\n     from_proto,\n     global_state::{file_id_to_url, url_to_file_id, GlobalState},\n     handlers, lsp_ext,\n     lsp_utils::{apply_document_changes, is_cancelled, notification_is, Progress},\n+    mem_docs::DocumentData,\n     reload::{BuildDataProgress, ProjectWorkspaceProgress},\n     Result,\n };\n@@ -305,7 +305,7 @@ impl GlobalState {\n                             let vfs = &mut self.vfs.write().0;\n                             for (path, contents) in files {\n                                 let path = VfsPath::from(path);\n-                                if !self.mem_docs.contains_key(&path) {\n+                                if !self.mem_docs.contains(&path) {\n                                     vfs.set_file_contents(path, contents);\n                                 }\n                             }\n@@ -406,25 +406,49 @@ impl GlobalState {\n         }\n \n         let state_changed = self.process_changes();\n+        let memdocs_added_or_removed = self.mem_docs.take_changes();\n \n-        if self.is_quiescent() && !was_quiescent {\n-            for flycheck in &self.flycheck {\n-                flycheck.update();\n+        if self.is_quiescent() {\n+            if !was_quiescent {\n+                for flycheck in &self.flycheck {\n+                    flycheck.update();\n+                }\n             }\n-        }\n \n-        if self.is_quiescent() && (!was_quiescent || state_changed) {\n-            self.update_file_notifications_on_threadpool();\n+            if !was_quiescent || state_changed {\n+                // Ensure that only one cache priming task can run at a time\n+                self.prime_caches_queue.request_op();\n+                if self.prime_caches_queue.should_start_op() {\n+                    self.task_pool.handle.spawn_with_sender({\n+                        let snap = self.snapshot();\n+                        move |sender| {\n+                            let cb = |progress| {\n+                                sender.send(Task::PrimeCaches(progress)).unwrap();\n+                            };\n+                            match snap.analysis.prime_caches(cb) {\n+                                Ok(()) => (),\n+                                Err(_canceled) => (),\n+                            }\n+                        }\n+                    });\n+                }\n \n-            // Refresh semantic tokens if the client supports it.\n-            if self.config.semantic_tokens_refresh() {\n-                self.semantic_tokens_cache.lock().clear();\n-                self.send_request::<lsp_types::request::SemanticTokensRefesh>((), |_, _| ());\n+                // Refresh semantic tokens if the client supports it.\n+                if self.config.semantic_tokens_refresh() {\n+                    self.semantic_tokens_cache.lock().clear();\n+                    self.send_request::<lsp_types::request::SemanticTokensRefesh>((), |_, _| ());\n+                }\n+\n+                // Refresh code lens if the client supports it.\n+                if self.config.code_lens_refresh() {\n+                    self.send_request::<lsp_types::request::CodeLensRefresh>((), |_, _| ());\n+                }\n             }\n \n-            // Refresh code lens if the client supports it.\n-            if self.config.code_lens_refresh() {\n-                self.send_request::<lsp_types::request::CodeLensRefresh>((), |_, _| ());\n+            if !was_quiescent || state_changed || memdocs_added_or_removed {\n+                if self.config.publish_diagnostics() {\n+                    self.update_diagnostics()\n+                }\n             }\n         }\n \n@@ -582,53 +606,43 @@ impl GlobalState {\n                     if this\n                         .mem_docs\n                         .insert(path.clone(), DocumentData::new(params.text_document.version))\n-                        .is_some()\n+                        .is_err()\n                     {\n                         log::error!(\"duplicate DidOpenTextDocument: {}\", path)\n                     }\n-                    let changed = this\n-                        .vfs\n+                    this.vfs\n                         .write()\n                         .0\n                         .set_file_contents(path, Some(params.text_document.text.into_bytes()));\n-\n-                    // If the VFS contents are unchanged, update diagnostics, since `handle_event`\n-                    // won't see any changes. This avoids missing diagnostics when opening a file.\n-                    //\n-                    // If the file *was* changed, `handle_event` will already recompute and send\n-                    // diagnostics. We can't do it here, since the *current* file contents might be\n-                    // unset in salsa, since the VFS change hasn't been applied to the database yet.\n-                    if !changed {\n-                        this.maybe_update_diagnostics();\n-                    }\n                 }\n                 Ok(())\n             })?\n             .on::<lsp_types::notification::DidChangeTextDocument>(|this, params| {\n                 if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n-                    let doc = match this.mem_docs.get_mut(&path) {\n-                        Some(doc) => doc,\n+                    match this.mem_docs.get_mut(&path) {\n+                        Some(doc) => {\n+                            // The version passed in DidChangeTextDocument is the version after all edits are applied\n+                            // so we should apply it before the vfs is notified.\n+                            doc.version = params.text_document.version;\n+                        }\n                         None => {\n                             log::error!(\"expected DidChangeTextDocument: {}\", path);\n                             return Ok(());\n                         }\n                     };\n+\n                     let vfs = &mut this.vfs.write().0;\n                     let file_id = vfs.file_id(&path).unwrap();\n                     let mut text = String::from_utf8(vfs.file_contents(file_id).to_vec()).unwrap();\n                     apply_document_changes(&mut text, params.content_changes);\n \n-                    // The version passed in DidChangeTextDocument is the version after all edits are applied\n-                    // so we should apply it before the vfs is notified.\n-                    doc.version = params.text_document.version;\n-\n                     vfs.set_file_contents(path.clone(), Some(text.into_bytes()));\n                 }\n                 Ok(())\n             })?\n             .on::<lsp_types::notification::DidCloseTextDocument>(|this, params| {\n                 if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n-                    if this.mem_docs.remove(&path).is_none() {\n+                    if this.mem_docs.remove(&path).is_err() {\n                         log::error!(\"orphan DidCloseTextDocument: {}\", path);\n                     }\n \n@@ -696,53 +710,33 @@ impl GlobalState {\n             .finish();\n         Ok(())\n     }\n-    fn update_file_notifications_on_threadpool(&mut self) {\n-        self.maybe_update_diagnostics();\n-\n-        // Ensure that only one cache priming task can run at a time\n-        self.prime_caches_queue.request_op();\n-        if self.prime_caches_queue.should_start_op() {\n-            self.task_pool.handle.spawn_with_sender({\n-                let snap = self.snapshot();\n-                move |sender| {\n-                    let cb = |progress| {\n-                        sender.send(Task::PrimeCaches(progress)).unwrap();\n-                    };\n-                    match snap.analysis.prime_caches(cb) {\n-                        Ok(()) => (),\n-                        Err(_canceled) => (),\n-                    }\n-                }\n-            });\n-        }\n-    }\n-    fn maybe_update_diagnostics(&mut self) {\n+\n+    fn update_diagnostics(&mut self) {\n         let subscriptions = self\n             .mem_docs\n-            .keys()\n+            .iter()\n             .map(|path| self.vfs.read().0.file_id(path).unwrap())\n             .collect::<Vec<_>>();\n \n         log::trace!(\"updating notifications for {:?}\", subscriptions);\n-        if self.config.publish_diagnostics() {\n-            let snapshot = self.snapshot();\n-            self.task_pool.handle.spawn(move || {\n-                let diagnostics = subscriptions\n-                    .into_iter()\n-                    .filter_map(|file_id| {\n-                        handlers::publish_diagnostics(&snapshot, file_id)\n-                            .map_err(|err| {\n-                                if !is_cancelled(&*err) {\n-                                    log::error!(\"failed to compute diagnostics: {:?}\", err);\n-                                }\n-                                ()\n-                            })\n-                            .ok()\n-                            .map(|diags| (file_id, diags))\n-                    })\n-                    .collect::<Vec<_>>();\n-                Task::Diagnostics(diagnostics)\n-            })\n-        }\n+\n+        let snapshot = self.snapshot();\n+        self.task_pool.handle.spawn(move || {\n+            let diagnostics = subscriptions\n+                .into_iter()\n+                .filter_map(|file_id| {\n+                    handlers::publish_diagnostics(&snapshot, file_id)\n+                        .map_err(|err| {\n+                            if !is_cancelled(&*err) {\n+                                log::error!(\"failed to compute diagnostics: {:?}\", err);\n+                            }\n+                            ()\n+                        })\n+                        .ok()\n+                        .map(|diags| (file_id, diags))\n+                })\n+                .collect::<Vec<_>>();\n+            Task::Diagnostics(diagnostics)\n+        })\n     }\n }"}, {"sha": "f86a0f66ad8d6b6de7b0339ca7fdf06a882d907d", "filename": "crates/rust-analyzer/src/mem_docs.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e6bae220b7129790805a0689ed1a2f2a2c47aeb4/crates%2Frust-analyzer%2Fsrc%2Fmem_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6bae220b7129790805a0689ed1a2f2a2c47aeb4/crates%2Frust-analyzer%2Fsrc%2Fmem_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmem_docs.rs?ref=e6bae220b7129790805a0689ed1a2f2a2c47aeb4", "patch": "@@ -0,0 +1,65 @@\n+//! In-memory document information.\n+\n+use std::mem;\n+\n+use rustc_hash::FxHashMap;\n+use vfs::VfsPath;\n+\n+/// Holds the set of in-memory documents.\n+///\n+/// For these document, there true contents is maintained by the client. It\n+/// might be different from what's on disk.\n+#[derive(Default, Clone)]\n+pub(crate) struct MemDocs {\n+    mem_docs: FxHashMap<VfsPath, DocumentData>,\n+    added_or_removed: bool,\n+}\n+\n+impl MemDocs {\n+    pub(crate) fn contains(&self, path: &VfsPath) -> bool {\n+        self.mem_docs.contains_key(path)\n+    }\n+    pub(crate) fn insert(&mut self, path: VfsPath, data: DocumentData) -> Result<(), ()> {\n+        self.added_or_removed = true;\n+        match self.mem_docs.insert(path, data) {\n+            Some(_) => Err(()),\n+            None => Ok(()),\n+        }\n+    }\n+    pub(crate) fn remove(&mut self, path: &VfsPath) -> Result<(), ()> {\n+        self.added_or_removed = true;\n+        match self.mem_docs.remove(path) {\n+            Some(_) => Ok(()),\n+            None => Err(()),\n+        }\n+    }\n+    pub(crate) fn get(&self, path: &VfsPath) -> Option<&DocumentData> {\n+        self.mem_docs.get(path)\n+    }\n+    pub(crate) fn get_mut(&mut self, path: &VfsPath) -> Option<&mut DocumentData> {\n+        // NB: don't set `self.added_or_removed` here, as that purposefully only\n+        // tracks changes to the key set.\n+        self.mem_docs.get_mut(path)\n+    }\n+    pub(crate) fn iter(&self) -> impl Iterator<Item = &VfsPath> {\n+        self.mem_docs.keys()\n+    }\n+    pub(crate) fn take_changes(&mut self) -> bool {\n+        mem::replace(&mut self.added_or_removed, false)\n+    }\n+}\n+\n+/// Information about a document that the Language Client\n+/// knows about.\n+/// Its lifetime is driven by the textDocument/didOpen and textDocument/didClose\n+/// client notifications.\n+#[derive(Debug, Clone)]\n+pub(crate) struct DocumentData {\n+    pub(crate) version: i32,\n+}\n+\n+impl DocumentData {\n+    pub(crate) fn new(version: i32) -> Self {\n+        DocumentData { version }\n+    }\n+}"}, {"sha": "0530bf14fc873a85e96653105279135ed3e45fb0", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6bae220b7129790805a0689ed1a2f2a2c47aeb4/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6bae220b7129790805a0689ed1a2f2a2c47aeb4/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=e6bae220b7129790805a0689ed1a2f2a2c47aeb4", "patch": "@@ -403,7 +403,7 @@ impl GlobalState {\n             let mut load = |path: &AbsPath| {\n                 let _p = profile::span(\"GlobalState::load\");\n                 let vfs_path = vfs::VfsPath::from(path.to_path_buf());\n-                if !mem_docs.contains_key(&vfs_path) {\n+                if !mem_docs.contains(&vfs_path) {\n                     let contents = loader.handle.load_sync(path);\n                     vfs.set_file_contents(vfs_path.clone(), contents);\n                 }"}]}