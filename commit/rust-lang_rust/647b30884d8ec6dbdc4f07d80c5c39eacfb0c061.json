{"sha": "647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0N2IzMDg4NGQ4ZWM2ZGJkYzRmMDdkODBjNWMzOWVhY2ZiMGMwNjE=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2016-12-21T12:26:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-12-21T12:26:39Z"}, "message": "Merge pull request #1392 from oli-obk/rustfmt\n\nalso run rustfmt on clippy-lints", "tree": {"sha": "3d2f7547eef86af59f77802442f4241d9cf65ce9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d2f7547eef86af59f77802442f4241d9cf65ce9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "html_url": "https://github.com/rust-lang/rust/commit/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a248e506f1c1d51e2ebfcbc7a4c4f7f58b594745", "url": "https://api.github.com/repos/rust-lang/rust/commits/a248e506f1c1d51e2ebfcbc7a4c4f7f58b594745", "html_url": "https://github.com/rust-lang/rust/commit/a248e506f1c1d51e2ebfcbc7a4c4f7f58b594745"}, {"sha": "55c0c9da8dece23a2b0f690a0cb3670b23aa6391", "url": "https://api.github.com/repos/rust-lang/rust/commits/55c0c9da8dece23a2b0f690a0cb3670b23aa6391", "html_url": "https://github.com/rust-lang/rust/commit/55c0c9da8dece23a2b0f690a0cb3670b23aa6391"}], "stats": {"total": 2663, "additions": 1370, "deletions": 1293}, "files": [{"sha": "3c226c879f26de9343badc9bdb28c9b04b6ea9ca", "filename": ".travis.yml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -24,8 +24,9 @@ install:\n script:\n  - remark -f README.md > /dev/null\n  - python util/update_lints.py -c\n- - PATH=$PATH:~/.cargo/bin cargo fmt -- --write-mode=diff\n  - set -e\n+ - PATH=$PATH:~/.cargo/bin cargo fmt -- --write-mode=diff\n+ - cd clippy_lints && PATH=$PATH:~/.cargo/bin cargo fmt -- --write-mode=diff && cd ..\n  - cargo build --features debugging\n  - cargo test --features debugging\n  - mkdir -p ~/rust/cargo/bin"}, {"sha": "7131e609715b0020f77897482db339c8b91084b6", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -85,7 +85,9 @@ fn check_known_consts(cx: &LateContext, e: &Expr, s: &symbol::Symbol, module: &s\n                           APPROX_CONSTANT,\n                           e.span,\n                           &format!(\"approximate value of `{}::consts::{}` found. \\\n-                                    Consider using it directly\", module, &name));\n+                                    Consider using it directly\",\n+                                   module,\n+                                   &name));\n                 return;\n             }\n         }"}, {"sha": "109f045b619b162c6f6027978d0925775b514820", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -67,7 +67,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n                     span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n                     self.span = Some(expr.span);\n                 }\n-            }\n+            },\n             hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n                 let ty = cx.tcx.tables().expr_ty(arg);\n                 if ty.is_integral() {\n@@ -77,7 +77,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n                     span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n                     self.span = Some(expr.span);\n                 }\n-            }\n+            },\n             _ => (),\n         }\n     }"}, {"sha": "de13c0264e5032e0645f5bace35fe9ad4e0d601d", "filename": "clippy_lints/src/array_indexing.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farray_indexing.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -107,9 +107,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIndexing {\n }\n \n /// Returns an option containing a tuple with the start and end (exclusive) of the range.\n-fn to_const_range(start: Option<Option<ConstVal>>, end: Option<Option<ConstVal>>, limits: RangeLimits,\n-                  array_size: ConstInt)\n-                  -> Option<(ConstInt, ConstInt)> {\n+fn to_const_range(\n+    start: Option<Option<ConstVal>>,\n+    end: Option<Option<ConstVal>>,\n+    limits: RangeLimits,\n+    array_size: ConstInt\n+) -> Option<(ConstInt, ConstInt)> {\n     let start = match start {\n         Some(Some(ConstVal::Integral(x))) => x,\n         Some(_) => return None,\n@@ -123,7 +126,7 @@ fn to_const_range(start: Option<Option<ConstVal>>, end: Option<Option<ConstVal>>\n             } else {\n                 x\n             }\n-        }\n+        },\n         Some(_) => return None,\n         None => array_size,\n     };"}, {"sha": "122a600d7d38f7fd066f61d3bc28e1247f0d2a2b", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 32, "deletions": 47, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -95,13 +95,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                                                expr.span,\n                                                \"variable appears on both sides of an assignment operation\",\n                                                |db| {\n-                                                   if let (Some(snip_a), Some(snip_r)) = (snippet_opt(cx, assignee.span),\n-                                                                                          snippet_opt(cx, rhs.span)) {\n-                                                       db.span_suggestion(expr.span,\n-                                                                          \"replace it with\",\n-                                                                          format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r));\n-                                                   }\n-                                               });\n+                                if let (Some(snip_a), Some(snip_r)) =\n+                                    (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs.span)) {\n+                                    db.span_suggestion(expr.span,\n+                                                       \"replace it with\",\n+                                                       format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r));\n+                                }\n+                            });\n                         };\n                         // lhs op= l op r\n                         if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, l) {\n@@ -113,7 +113,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                         }\n                     }\n                 }\n-            }\n+            },\n             hir::ExprAssign(ref assignee, ref e) => {\n                 if let hir::ExprBinary(op, ref l, ref r) = e.node {\n                     let lint = |assignee: &hir::Expr, rhs: &hir::Expr| {\n@@ -126,7 +126,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                             return; // implements_trait does not work with generics\n                         }\n                         macro_rules! ops {\n-                            ($op:expr, $cx:expr, $ty:expr, $rty:expr, $($trait_name:ident:$full_trait_name:ident),+) => {\n+                            ($op:expr,\n+                             $cx:expr,\n+                             $ty:expr,\n+                             $rty:expr,\n+                             $($trait_name:ident:$full_trait_name:ident),+) => {\n                                 match $op {\n                                     $(hir::$full_trait_name => {\n                                         let [krate, module] = ::utils::paths::OPS_MODULE;\n@@ -140,15 +144,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                                         let parent_fn = cx.tcx.map.get_parent(e.id);\n                                         let parent_impl = cx.tcx.map.get_parent(parent_fn);\n                                         // the crate node is the only one that is not in the map\n-                                        if parent_impl != ast::CRATE_NODE_ID {\n-                                            if let hir::map::Node::NodeItem(item) = cx.tcx.map.get(parent_impl) {\n-                                                if let hir::Item_::ItemImpl(_, _, _, Some(ref trait_ref), _, _) = item.node {\n-                                                    if trait_ref.path.def.def_id() == trait_id {\n-                                                        return;\n-                                                    }\n-                                                }\n-                                            }\n-                                        }\n+                                        if_let_chain!{[\n+                                            parent_impl != ast::CRATE_NODE_ID,\n+                                            let hir::map::Node::NodeItem(item) = cx.tcx.map.get(parent_impl),\n+                                            let hir::Item_::ItemImpl(_, _, _, Some(ref trait_ref), _, _) = item.node,\n+                                            trait_ref.path.def.def_id() == trait_id\n+                                        ], { return; }}\n                                         implements_trait($cx, $ty, trait_id, vec![$rty])\n                                     },)*\n                                     _ => false,\n@@ -176,13 +177,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                                                expr.span,\n                                                \"manual implementation of an assign operation\",\n                                                |db| {\n-                                                   if let (Some(snip_a), Some(snip_r)) = (snippet_opt(cx, assignee.span),\n-                                                                                          snippet_opt(cx, rhs.span)) {\n-                                                       db.span_suggestion(expr.span,\n-                                                                          \"replace it with\",\n-                                                                          format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r));\n-                                                   }\n-                                               });\n+                                if let (Some(snip_a), Some(snip_r)) =\n+                                    (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs.span)) {\n+                                    db.span_suggestion(expr.span,\n+                                                       \"replace it with\",\n+                                                       format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r));\n+                                }\n+                            });\n                         }\n                     };\n                     // a = a op b\n@@ -195,37 +196,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                             hir::BiAdd | hir::BiMul | hir::BiAnd | hir::BiOr | hir::BiBitXor | hir::BiBitAnd |\n                             hir::BiBitOr => {\n                                 lint(assignee, l);\n-                            }\n-                            _ => {}\n+                            },\n+                            _ => {},\n                         }\n                     }\n                 }\n-            }\n-            _ => {}\n+            },\n+            _ => {},\n         }\n     }\n }\n \n fn is_commutative(op: hir::BinOp_) -> bool {\n     use rustc::hir::BinOp_::*;\n     match op {\n-        BiAdd |\n-        BiMul |\n-        BiAnd |\n-        BiOr |\n-        BiBitXor |\n-        BiBitAnd |\n-        BiBitOr |\n-        BiEq |\n-        BiNe => true,\n-        BiSub |\n-        BiDiv |\n-        BiRem |\n-        BiShl |\n-        BiShr |\n-        BiLt |\n-        BiLe |\n-        BiGe |\n-        BiGt => false,\n+        BiAdd | BiMul | BiAnd | BiOr | BiBitXor | BiBitAnd | BiBitOr | BiEq | BiNe => true,\n+        BiSub | BiDiv | BiRem | BiShl | BiShr | BiLt | BiLe | BiGe | BiGt => false,\n     }\n }"}, {"sha": "24fd5a1483dada8a70af061b49d88c7eb73e4066", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -36,9 +36,11 @@ declare_lint! {\n \n /// **What it does:** Checks for `extern crate` and `use` items annotated with lint attributes\n ///\n-/// **Why is this bad?** Lint attributes have no effect on crate imports. Most likely a `!` was forgotten\n+/// **Why is this bad?** Lint attributes have no effect on crate imports. Most likely a `!` was\n+/// forgotten\n ///\n-/// **Known problems:** Technically one might allow `unused_import` on a `use` item, but it's easier to remove the unused item.\n+/// **Known problems:** Technically one might allow `unused_import` on a `use` item,\n+/// but it's easier to remove the unused item.\n ///\n /// **Example:**\n /// ```rust\n@@ -120,7 +122,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n                                 }\n                                 if let Some(mut sugg) = snippet_opt(cx, attr.span) {\n                                     if sugg.len() > 1 {\n-                                        span_lint_and_then(cx, USELESS_ATTRIBUTE, attr.span,\n+                                        span_lint_and_then(cx,\n+                                                           USELESS_ATTRIBUTE,\n+                                                           attr.span,\n                                                            \"useless lint attribute\",\n                                                            |db| {\n                                             sugg.insert(1, '!');\n@@ -181,7 +185,7 @@ fn is_relevant_block(cx: &LateContext, block: &Block) -> bool {\n             StmtExpr(ref expr, _) |\n             StmtSemi(ref expr, _) => {\n                 return is_relevant_expr(cx, expr);\n-            }\n+            },\n         }\n     }\n     block.expr.as_ref().map_or(false, |e| is_relevant_expr(cx, e))\n@@ -191,15 +195,16 @@ fn is_relevant_expr(cx: &LateContext, expr: &Expr) -> bool {\n     match expr.node {\n         ExprBlock(ref block) => is_relevant_block(cx, block),\n         ExprRet(Some(ref e)) => is_relevant_expr(cx, e),\n-        ExprRet(None) | ExprBreak(_, None) => false,\n+        ExprRet(None) |\n+        ExprBreak(_, None) => false,\n         ExprCall(ref path_expr, _) => {\n             if let ExprPath(ref qpath) = path_expr.node {\n                 let fun_id = resolve_node(cx, qpath, path_expr.id).def_id();\n                 !match_def_path(cx, fun_id, &paths::BEGIN_PANIC)\n             } else {\n                 true\n             }\n-        }\n+        },\n         _ => true,\n     }\n }"}, {"sha": "5b860d8cedc7e876af9a941c0c750675d2852b01", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -134,7 +134,7 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n                     } else if mask_value == 0 {\n                         span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n                     }\n-                }\n+                },\n                 BiBitOr => {\n                     if mask_value | cmp_value != cmp_value {\n                         span_lint(cx,\n@@ -144,10 +144,10 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n                                            mask_value,\n                                            cmp_value));\n                     }\n-                }\n+                },\n                 _ => (),\n             }\n-        }\n+        },\n         BiLt | BiGe => {\n             match bit_op {\n                 BiBitAnd => {\n@@ -161,7 +161,7 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n                     } else if mask_value == 0 {\n                         span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n                     }\n-                }\n+                },\n                 BiBitOr => {\n                     if mask_value >= cmp_value {\n                         span_lint(cx,\n@@ -173,11 +173,11 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n                     } else {\n                         check_ineffective_lt(cx, *span, mask_value, cmp_value, \"|\");\n                     }\n-                }\n+                },\n                 BiBitXor => check_ineffective_lt(cx, *span, mask_value, cmp_value, \"^\"),\n                 _ => (),\n             }\n-        }\n+        },\n         BiLe | BiGt => {\n             match bit_op {\n                 BiBitAnd => {\n@@ -191,7 +191,7 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n                     } else if mask_value == 0 {\n                         span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n                     }\n-                }\n+                },\n                 BiBitOr => {\n                     if mask_value > cmp_value {\n                         span_lint(cx,\n@@ -203,11 +203,11 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n                     } else {\n                         check_ineffective_gt(cx, *span, mask_value, cmp_value, \"|\");\n                     }\n-                }\n+                },\n                 BiBitXor => check_ineffective_gt(cx, *span, mask_value, cmp_value, \"^\"),\n                 _ => (),\n             }\n-        }\n+        },\n         _ => (),\n     }\n }\n@@ -244,15 +244,15 @@ fn fetch_int_literal(cx: &LateContext, lit: &Expr) -> Option<u64> {\n             } else {\n                 None\n             }\n-        }\n+        },\n         ExprPath(ref qpath) => {\n             let def = cx.tcx.tables().qpath_def(qpath, lit.id);\n             if let Def::Const(def_id) = def {\n                 lookup_const_by_id(cx.tcx, def_id, None).and_then(|(l, _ty)| fetch_int_literal(cx, l))\n             } else {\n                 None\n             }\n-        }\n+        },\n         _ => None,\n     }\n }"}, {"sha": "2f9a6b161585e00b0eb4eab5e2c5eba598c41ac9", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -110,7 +110,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n                     }\n                 }\n             } else {\n-                let mut visitor = ExVisitor { found_block: None, cx: cx };\n+                let mut visitor = ExVisitor {\n+                    found_block: None,\n+                    cx: cx,\n+                };\n                 walk_expr(&mut visitor, check);\n                 if let Some(block) = visitor.found_block {\n                     span_lint(cx, BLOCK_IN_IF_CONDITION_STMT, block.span, COMPLEX_BLOCK_MESSAGE);"}, {"sha": "979b62f8ce7ec73a8195123fec3e6e6b97e6e8fa", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -94,14 +94,14 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                         BiAnd => return Ok(Bool::And(self.extract(BiAnd, &[lhs, rhs], Vec::new())?)),\n                         _ => (),\n                     }\n-                }\n+                },\n                 ExprLit(ref lit) => {\n                     match lit.node {\n                         LitKind::Bool(true) => return Ok(Bool::True),\n                         LitKind::Bool(false) => return Ok(Bool::False),\n                         _ => (),\n                     }\n-                }\n+                },\n                 _ => (),\n             }\n         }\n@@ -129,7 +129,7 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                         BiLe => mk_expr(BiGt),\n                         _ => continue,\n                     }\n-                }\n+                },\n                 _ => continue,\n             };\n             if SpanlessEq::new(self.cx).ignore_fn().eq_expr(&negated, expr) {\n@@ -156,17 +156,17 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n             True => {\n                 s.push_str(\"true\");\n                 s\n-            }\n+            },\n             False => {\n                 s.push_str(\"false\");\n                 s\n-            }\n+            },\n             Not(ref inner) => {\n                 match **inner {\n                     And(_) | Or(_) => {\n                         s.push('!');\n                         recurse(true, cx, inner, terminals, s)\n-                    }\n+                    },\n                     Term(n) => {\n                         if let ExprBinary(binop, ref lhs, ref rhs) = terminals[n as usize].node {\n                             let op = match binop.node {\n@@ -179,7 +179,7 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n                                 _ => {\n                                     s.push('!');\n                                     return recurse(true, cx, inner, terminals, s);\n-                                }\n+                                },\n                             };\n                             s.push_str(&snip(lhs));\n                             s.push_str(op);\n@@ -189,13 +189,13 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n                             s.push('!');\n                             recurse(false, cx, inner, terminals, s)\n                         }\n-                    }\n+                    },\n                     _ => {\n                         s.push('!');\n                         recurse(false, cx, inner, terminals, s)\n-                    }\n+                    },\n                 }\n-            }\n+            },\n             And(ref v) => {\n                 if brackets {\n                     s.push('(');\n@@ -217,7 +217,7 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n                     s.push(')');\n                 }\n                 s\n-            }\n+            },\n             Or(ref v) => {\n                 if brackets {\n                     s.push('(');\n@@ -231,7 +231,7 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n                     s.push(')');\n                 }\n                 s\n-            }\n+            },\n             Term(n) => {\n                 if brackets {\n                     if let ExprBinary(..) = terminals[n as usize].node {\n@@ -245,7 +245,7 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n                     }\n                 }\n                 s\n-            }\n+            },\n         }\n     }\n     recurse(false, cx, suggestion, terminals, String::new())\n@@ -262,13 +262,13 @@ fn simple_negate(b: Bool) -> Bool {\n                 *el = simple_negate(::std::mem::replace(el, True));\n             }\n             Or(v)\n-        }\n+        },\n         Or(mut v) => {\n             for el in &mut v {\n                 *el = simple_negate(::std::mem::replace(el, True));\n             }\n             And(v)\n-        }\n+        },\n         Not(inner) => *inner,\n     }\n }\n@@ -290,13 +290,13 @@ fn terminal_stats(b: &Bool) -> Stats {\n                     _ => stats.negations += 1,\n                 }\n                 recurse(inner, stats);\n-            }\n+            },\n             And(ref v) | Or(ref v) => {\n                 stats.ops += v.len() - 1;\n                 for inner in v {\n                     recurse(inner, stats);\n                 }\n-            }\n+            },\n             Term(n) => stats.terminals[n as usize] += 1,\n         }\n     }\n@@ -325,7 +325,7 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n             let mut simplified = expr.simplify();\n             for simple in Bool::Not(Box::new(expr.clone())).simplify() {\n                 match simple {\n-                    Bool::Not(_) | Bool::True | Bool::False => {}\n+                    Bool::Not(_) | Bool::True | Bool::False => {},\n                     _ => simplified.push(Bool::Not(Box::new(simple.clone()))),\n                 }\n                 let simple_negated = simple_negate(simple);\n@@ -399,7 +399,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n                 } else {\n                     walk_expr(self, e);\n                 }\n-            }\n+            },\n             _ => walk_expr(self, e),\n         }\n     }"}, {"sha": "85bd419df7320c167fcadadd7ea0dd085b0a0d60", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -2,7 +2,7 @@\n //!\n //! For example, the lint would catch:\n //!\n-//! ```rust\n+//! ```rust,ignore\n //! if x {\n //!     if y {\n //!         println!(\"Hello world\");\n@@ -28,7 +28,7 @@ use utils::sugg::Sugg;\n /// **Known problems:** None.\n ///\n /// **Example:**\n-/// ```rust\n+/// ```rust,ignore\n /// if x {\n ///     if y {\n ///         \u2026\n@@ -48,7 +48,7 @@ use utils::sugg::Sugg;\n ///\n /// Should be written:\n ///\n-/// ```rust\n+/// ```rust.ignore\n /// if x && y {\n ///     \u2026\n /// }\n@@ -92,10 +92,10 @@ fn check_if(cx: &EarlyContext, expr: &ast::Expr) {\n             } else {\n                 check_collapsible_no_if_let(cx, expr, check, then);\n             }\n-        }\n+        },\n         ast::ExprKind::IfLet(_, _, _, Some(ref else_)) => {\n             check_collapsible_maybe_if_let(cx, else_);\n-        }\n+        },\n         _ => (),\n     }\n }\n@@ -120,12 +120,7 @@ fn check_collapsible_maybe_if_let(cx: &EarlyContext, else_: &ast::Expr) {\n     }}\n }\n \n-fn check_collapsible_no_if_let(\n-    cx: &EarlyContext,\n-    expr: &ast::Expr,\n-    check: &ast::Expr,\n-    then: &ast::Block,\n-) {\n+fn check_collapsible_no_if_let(cx: &EarlyContext, expr: &ast::Expr, check: &ast::Expr, then: &ast::Block) {\n     if_let_chain! {[\n         let Some(inner) = expr_block(then),\n         let ast::ExprKind::If(ref check_inner, ref content, None) = inner.node,\n@@ -145,13 +140,14 @@ fn check_collapsible_no_if_let(\n     }}\n }\n \n-/// If the block contains only one expression, returns it.\n+/// If the block contains only one expression, return it.\n fn expr_block(block: &ast::Block) -> Option<&ast::Expr> {\n     let mut it = block.stmts.iter();\n \n     if let (Some(stmt), None) = (it.next(), it.next()) {\n         match stmt.node {\n-            ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => Some(expr),\n+            ast::StmtKind::Expr(ref expr) |\n+            ast::StmtKind::Semi(ref expr) => Some(expr),\n             _ => None,\n         }\n     } else {"}, {"sha": "44288e7d7fcdcf820d14c076aefa7dd3933a8c8b", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -75,18 +75,16 @@ impl PartialEq for Constant {\n             (&Constant::Char(l), &Constant::Char(r)) => l == r,\n             (&Constant::Int(l), &Constant::Int(r)) => {\n                 l.is_negative() == r.is_negative() && l.to_u64_unchecked() == r.to_u64_unchecked()\n-            }\n+            },\n             (&Constant::Float(ref ls, _), &Constant::Float(ref rs, _)) => {\n                 // we want `Fw32 == FwAny` and `FwAny == Fw64`, by transitivity we must have\n                 // `Fw32 == Fw64` so don\u2019t compare them\n                 match (ls.parse::<f64>(), rs.parse::<f64>()) {\n                     // mem::transmute is required to catch non-matching 0.0, -0.0, and NaNs\n-                    (Ok(l), Ok(r)) => unsafe {\n-                        mem::transmute::<f64, u64>(l) == mem::transmute::<f64, u64>(r)\n-                    },\n+                    (Ok(l), Ok(r)) => unsafe { mem::transmute::<f64, u64>(l) == mem::transmute::<f64, u64>(r) },\n                     _ => false,\n                 }\n-            }\n+            },\n             (&Constant::Bool(l), &Constant::Bool(r)) => l == r,\n             (&Constant::Vec(ref l), &Constant::Vec(ref r)) => l == r,\n             (&Constant::Repeat(ref lv, ref ls), &Constant::Repeat(ref rv, ref rs)) => ls == rs && lv == rv,\n@@ -104,34 +102,34 @@ impl Hash for Constant {\n             Constant::Str(ref s, ref k) => {\n                 s.hash(state);\n                 k.hash(state);\n-            }\n+            },\n             Constant::Binary(ref b) => {\n                 b.hash(state);\n-            }\n+            },\n             Constant::Char(c) => {\n                 c.hash(state);\n-            }\n+            },\n             Constant::Int(i) => {\n                 i.to_u64_unchecked().hash(state);\n                 i.is_negative().hash(state);\n-            }\n+            },\n             Constant::Float(ref f, _) => {\n                 // don\u2019t use the width here because of PartialEq implementation\n                 if let Ok(f) = f.parse::<f64>() {\n                     unsafe { mem::transmute::<f64, u64>(f) }.hash(state);\n                 }\n-            }\n+            },\n             Constant::Bool(b) => {\n                 b.hash(state);\n-            }\n+            },\n             Constant::Vec(ref v) |\n             Constant::Tuple(ref v) => {\n                 v.hash(state);\n-            }\n+            },\n             Constant::Repeat(ref c, l) => {\n                 c.hash(state);\n                 l.hash(state);\n-            }\n+            },\n         }\n     }\n }\n@@ -145,19 +143,21 @@ impl PartialOrd for Constant {\n                 } else {\n                     None\n                 }\n-            }\n+            },\n             (&Constant::Char(ref l), &Constant::Char(ref r)) => Some(l.cmp(r)),\n             (&Constant::Int(l), &Constant::Int(r)) => Some(l.cmp(&r)),\n             (&Constant::Float(ref ls, _), &Constant::Float(ref rs, _)) => {\n                 match (ls.parse::<f64>(), rs.parse::<f64>()) {\n-                    (Ok(ref l), Ok(ref r)) => match (l.partial_cmp(r), l.is_sign_positive() == r.is_sign_positive()) {\n-                        // Check for comparison of -0.0 and 0.0\n-                        (Some(Ordering::Equal), false) => None,\n-                        (x, _) => x\n+                    (Ok(ref l), Ok(ref r)) => {\n+                        match (l.partial_cmp(r), l.is_sign_positive() == r.is_sign_positive()) {\n+                            // Check for comparison of -0.0 and 0.0\n+                            (Some(Ordering::Equal), false) => None,\n+                            (x, _) => x,\n+                        }\n                     },\n                     _ => None,\n                 }\n-            }\n+            },\n             (&Constant::Bool(ref l), &Constant::Bool(ref r)) => Some(l.cmp(r)),\n             (&Constant::Tuple(ref l), &Constant::Tuple(ref r)) |\n             (&Constant::Vec(ref l), &Constant::Vec(ref r)) => l.partial_cmp(r),\n@@ -166,7 +166,7 @@ impl PartialOrd for Constant {\n                     Some(Equal) => Some(ls.cmp(rs)),\n                     x => x,\n                 }\n-            }\n+            },\n             _ => None, //TODO: Are there any useful inter-type orderings?\n         }\n     }\n@@ -187,14 +187,14 @@ pub fn lit_to_constant(lit: &LitKind) -> Constant {\n         LitKind::Int(value, LitIntType::Unsigned(UintTy::U64)) => Constant::Int(ConstInt::U64(value as u64)),\n         LitKind::Int(value, LitIntType::Unsigned(UintTy::Us)) => {\n             Constant::Int(ConstInt::Usize(ConstUsize::Us32(value as u32)))\n-        }\n+        },\n         LitKind::Int(value, LitIntType::Signed(IntTy::I8)) => Constant::Int(ConstInt::I8(value as i8)),\n         LitKind::Int(value, LitIntType::Signed(IntTy::I16)) => Constant::Int(ConstInt::I16(value as i16)),\n         LitKind::Int(value, LitIntType::Signed(IntTy::I32)) => Constant::Int(ConstInt::I32(value as i32)),\n         LitKind::Int(value, LitIntType::Signed(IntTy::I64)) => Constant::Int(ConstInt::I64(value as i64)),\n         LitKind::Int(value, LitIntType::Signed(IntTy::Is)) => {\n             Constant::Int(ConstInt::Isize(ConstIsize::Is32(value as i32)))\n-        }\n+        },\n         LitKind::Float(ref is, ty) => Constant::Float(is.to_string(), ty.into()),\n         LitKind::FloatUnsuffixed(ref is) => Constant::Float(is.to_string(), FloatWidth::Any),\n         LitKind::Bool(b) => Constant::Bool(b),\n@@ -260,7 +260,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             ExprTup(ref tup) => self.multi(tup).map(Constant::Tuple),\n             ExprRepeat(ref value, ref number) => {\n                 self.binop_apply(value, number, |v, n| Some(Constant::Repeat(Box::new(v), n.as_u64() as usize)))\n-            }\n+            },\n             ExprUnary(op, ref operand) => {\n                 self.expr(operand).and_then(|o| {\n                     match op {\n@@ -269,7 +269,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n                         UnDeref => Some(o),\n                     }\n                 })\n-            }\n+            },\n             ExprBinary(op, ref left, ref right) => self.binop(op, left, right),\n             // TODO: add other expressions\n             _ => None,\n@@ -280,17 +280,20 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     /// non-constant part\n     fn multi(&mut self, vec: &[Expr]) -> Option<Vec<Constant>> {\n         vec.iter()\n-           .map(|elem| self.expr(elem))\n-           .collect::<Option<_>>()\n+            .map(|elem| self.expr(elem))\n+            .collect::<Option<_>>()\n     }\n \n     /// lookup a possibly constant expression from a ExprPath\n     fn fetch_path(&mut self, qpath: &QPath, id: NodeId) -> Option<Constant> {\n         if let Some(lcx) = self.lcx {\n             let def = lcx.tcx.tables().qpath_def(qpath, id);\n             match def {\n-                Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n-                    let substs = Some(lcx.tcx.tables().node_id_item_substs(id)\n+                Def::Const(def_id) |\n+                Def::AssociatedConst(def_id) => {\n+                    let substs = Some(lcx.tcx\n+                        .tables()\n+                        .node_id_item_substs(id)\n                         .unwrap_or_else(|| lcx.tcx.intern_substs(&[])));\n                     if let Some((const_expr, _ty)) = lookup_const_by_id(lcx.tcx, def_id, substs) {\n                         let ret = self.expr(const_expr);"}, {"sha": "11b85edba3e696711e697ba8c94c3534dc1c3dc7", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -204,8 +204,11 @@ fn lint_match_arms(cx: &LateContext, expr: &Expr) {\n \n                     if let PatKind::Wild = j.pats[0].node {\n                         // if the last arm is _, then i could be integrated into _\n-                        // note that i.pats[0] cannot be _, because that would mean that we're hiding all the subsequent arms, and rust won't compile\n-                        db.span_note(i.body.span, &format!(\"`{}` has the same arm body as the `_` wildcard, consider removing it`\", lhs));\n+                        // note that i.pats[0] cannot be _, because that would mean that we're\n+                        // hiding all the subsequent arms, and rust won't compile\n+                        db.span_note(i.body.span,\n+                                     &format!(\"`{}` has the same arm body as the `_` wildcard, consider removing it`\",\n+                                              lhs));\n                     } else {\n                         db.span_note(i.body.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs));\n                     }\n@@ -245,33 +248,37 @@ fn if_sequence(mut expr: &Expr) -> (SmallVector<&Expr>, SmallVector<&Block>) {\n \n /// Return the list of bindings in a pattern.\n fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<InternedString, ty::Ty<'tcx>> {\n-    fn bindings_impl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat, map: &mut HashMap<InternedString, ty::Ty<'tcx>>) {\n+    fn bindings_impl<'a, 'tcx>(\n+        cx: &LateContext<'a, 'tcx>,\n+        pat: &Pat,\n+        map: &mut HashMap<InternedString, ty::Ty<'tcx>>\n+    ) {\n         match pat.node {\n             PatKind::Box(ref pat) |\n             PatKind::Ref(ref pat, _) => bindings_impl(cx, pat, map),\n             PatKind::TupleStruct(_, ref pats, _) => {\n                 for pat in pats {\n                     bindings_impl(cx, pat, map);\n                 }\n-            }\n+            },\n             PatKind::Binding(_, _, ref ident, ref as_pat) => {\n                 if let Entry::Vacant(v) = map.entry(ident.node.as_str()) {\n                     v.insert(cx.tcx.tables().pat_ty(pat));\n                 }\n                 if let Some(ref as_pat) = *as_pat {\n                     bindings_impl(cx, as_pat, map);\n                 }\n-            }\n+            },\n             PatKind::Struct(_, ref fields, _) => {\n                 for pat in fields {\n                     bindings_impl(cx, &pat.node.pat, map);\n                 }\n-            }\n+            },\n             PatKind::Tuple(ref fields, _) => {\n                 for pat in fields {\n                     bindings_impl(cx, pat, map);\n                 }\n-            }\n+            },\n             PatKind::Slice(ref lhs, ref mid, ref rhs) => {\n                 for pat in lhs {\n                     bindings_impl(cx, pat, map);\n@@ -282,7 +289,7 @@ fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<Interned\n                 for pat in rhs {\n                     bindings_impl(cx, pat, map);\n                 }\n-            }\n+            },\n             PatKind::Lit(..) |\n             PatKind::Range(..) |\n             PatKind::Wild |\n@@ -320,10 +327,10 @@ fn search_same<T, Hash, Eq>(exprs: &[T], hash: Hash, eq: Eq) -> Option<(&T, &T)>\n                         return Some((o, expr));\n                     }\n                 }\n-            }\n+            },\n             Entry::Vacant(v) => {\n                 v.insert(vec![expr]);\n-            }\n+            },\n         }\n     }\n "}, {"sha": "897a578f19a7ca72b551aa9780a0990a9b4f8ac8", "filename": "clippy_lints/src/cyclomatic_complexity.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -136,26 +136,26 @@ impl<'a, 'tcx> Visitor<'tcx> for CCHelper<'a, 'tcx> {\n                 if arms_n > 1 {\n                     self.match_arms += arms_n - 2;\n                 }\n-            }\n+            },\n             ExprCall(ref callee, _) => {\n                 walk_expr(self, e);\n                 let ty = self.cx.tcx.tables().node_id_to_type(callee.id);\n                 match ty.sty {\n                     ty::TyFnDef(_, _, ty) |\n                     ty::TyFnPtr(ty) if ty.sig.skip_binder().output().sty == ty::TyNever => {\n                         self.divergence += 1;\n-                    }\n+                    },\n                     _ => (),\n                 }\n-            }\n+            },\n             ExprClosure(..) => (),\n             ExprBinary(op, _, _) => {\n                 walk_expr(self, e);\n                 match op.node {\n                     BiAnd | BiOr => self.short_circuits += 1,\n                     _ => (),\n                 }\n-            }\n+            },\n             ExprRet(_) => self.returns += 1,\n             _ => walk_expr(self, e),\n         }"}, {"sha": "cda82f46434e167b0144876b105df877444437ca", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -86,8 +86,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Derive {\n }\n \n /// Implementation of the `DERIVE_HASH_XOR_EQ` lint.\n-fn check_hash_peq<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, span: Span, trait_ref: &TraitRef, ty: ty::Ty<'tcx>,\n-                                hash_is_automatically_derived: bool) {\n+fn check_hash_peq<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    span: Span,\n+    trait_ref: &TraitRef,\n+    ty: ty::Ty<'tcx>,\n+    hash_is_automatically_derived: bool\n+) {\n     if_let_chain! {[\n         match_path_old(&trait_ref.path, &paths::HASH),\n         let Some(peq_trait_def_id) = cx.tcx.lang_items.eq_trait()\n@@ -149,18 +154,18 @@ fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref\n                         match field.ty(cx.tcx, substs).sty {\n                             TypeVariants::TyArray(_, size) if size > 32 => {\n                                 return;\n-                            }\n+                            },\n                             TypeVariants::TyFnPtr(..) => {\n                                 return;\n-                            }\n+                            },\n                             TypeVariants::TyTuple(tys) if tys.len() > 12 => {\n                                 return;\n-                            }\n+                            },\n                             _ => (),\n                         }\n                     }\n                 }\n-            }\n+            },\n             _ => (),\n         }\n \n@@ -169,7 +174,7 @@ fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref\n                            item.span,\n                            \"you are implementing `Clone` explicitly on a `Copy` type\",\n                            |db| {\n-                               db.span_note(item.span, \"consider deriving `Clone` or removing `Copy`\");\n-                           });\n+            db.span_note(item.span, \"consider deriving `Clone` or removing `Copy`\");\n+        });\n     }\n }"}, {"sha": "20c82ee466074070a40b146538774a7648ea3c73", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -64,26 +64,21 @@ pub fn strip_doc_comment_decoration((comment, span): (String, Span)) -> Vec<(Str\n     const ONELINERS: &'static [&'static str] = &[\"///!\", \"///\", \"//!\", \"//\"];\n     for prefix in ONELINERS {\n         if comment.starts_with(*prefix) {\n-            return vec![(\n-                comment[prefix.len()..].to_owned(),\n-                Span { lo: span.lo + BytePos(prefix.len() as u32), ..span }\n-            )];\n+            return vec![(comment[prefix.len()..].to_owned(),\n+                         Span { lo: span.lo + BytePos(prefix.len() as u32), ..span })];\n         }\n     }\n \n     if comment.starts_with(\"/*\") {\n-        return comment[3..comment.len() - 2].lines().map(|line| {\n-            let offset = line.as_ptr() as usize - comment.as_ptr() as usize;\n-            debug_assert_eq!(offset as u32 as usize, offset);\n-\n-            (\n-                line.to_owned(),\n-                Span {\n-                    lo: span.lo + BytePos(offset as u32),\n-                    ..span\n-                }\n-            )\n-        }).collect();\n+        return comment[3..comment.len() - 2]\n+            .lines()\n+            .map(|line| {\n+                let offset = line.as_ptr() as usize - comment.as_ptr() as usize;\n+                debug_assert_eq!(offset as u32 as usize, offset);\n+\n+                (line.to_owned(), Span { lo: span.lo + BytePos(offset as u32), ..span })\n+            })\n+            .collect();\n     }\n \n     panic!(\"not a doc-comment: {}\", comment);\n@@ -273,7 +268,9 @@ fn check_doc(cx: &EarlyContext, valid_idents: &[String], docs: &[(String, Span)]\n                             }\n \n                             lookup_parser = parser.clone();\n-                            if let (Some((false, $c)), Some((false, $c))) = (lookup_parser.next(), lookup_parser.next()) {\n+                            let a = lookup_parser.next();\n+                            let b = lookup_parser.next();\n+                            if let (Some((false, $c)), Some((false, $c))) = (a, b) {\n                                 let mut close_count = 3;\n                                 while let Some((false, $c)) = lookup_parser.next() {\n                                     close_count += 1;\n@@ -299,16 +296,17 @@ fn check_doc(cx: &EarlyContext, valid_idents: &[String], docs: &[(String, Span)]\n         match parser.next() {\n             Some((new_line, c)) => {\n                 match c {\n-                    '#' if new_line => { // don\u2019t warn on titles\n+                    '#' if new_line => {\n+                        // don\u2019t warn on titles\n                         parser.next_line();\n-                    }\n+                    },\n                     '`' => {\n                         if try!(check_block!(parser, '`', new_line)) {\n                             continue;\n                         }\n \n                         try!(parser.jump_to('`')); // not a code block, just inline code\n-                    }\n+                    },\n                     '~' => {\n                         if try!(check_block!(parser, '~', new_line)) {\n                             continue;\n@@ -317,7 +315,7 @@ fn check_doc(cx: &EarlyContext, valid_idents: &[String], docs: &[(String, Span)]\n                         // ~ does not introduce inline code, but two of them introduce\n                         // strikethrough. Too bad for the consistency but we don't care about\n                         // strikethrough.\n-                    }\n+                    },\n                     '[' => {\n                         // Check for a reference definition `[foo]:` at the beginning of a line\n                         let mut link = true;\n@@ -335,24 +333,24 @@ fn check_doc(cx: &EarlyContext, valid_idents: &[String], docs: &[(String, Span)]\n \n                         parser.advance_begin();\n                         parser.link = link;\n-                    }\n+                    },\n                     ']' if parser.link => {\n                         parser.link = false;\n \n                         match parser.peek() {\n                             Some('(') => {\n                                 try!(parser.jump_to(')'));\n-                            }\n+                            },\n                             Some('[') => {\n                                 try!(parser.jump_to(']'));\n-                            }\n+                            },\n                             Some(_) => continue,\n                             None => return Err(()),\n                         }\n-                    }\n+                    },\n                     c if !is_path_char(c) => {\n                         parser.advance_begin();\n-                    }\n+                    },\n                     _ => {\n                         if let Some((_, c)) = parser.find(|&(_, c)| !is_path_char(c)) {\n                             parser.put_back(c);\n@@ -361,10 +359,10 @@ fn check_doc(cx: &EarlyContext, valid_idents: &[String], docs: &[(String, Span)]\n                         let (word, span) = parser.word();\n                         check_word(cx, valid_idents, word, span);\n                         parser.advance_begin();\n-                    }\n+                    },\n                 }\n \n-            }\n+            },\n             None => break,\n         }\n     }\n@@ -386,8 +384,7 @@ fn check_word(cx: &EarlyContext, valid_idents: &[String], word: &str, span: Span\n             s\n         };\n \n-        s.chars().all(char::is_alphanumeric) &&\n-        s.chars().filter(|&c| c.is_uppercase()).take(2).count() > 1 &&\n+        s.chars().all(char::is_alphanumeric) && s.chars().filter(|&c| c.is_uppercase()).take(2).count() > 1 &&\n         s.chars().filter(|&c| c.is_lowercase()).take(1).count() > 0\n     }\n "}, {"sha": "2fe53d8cacf4c30e2ee462cf442c55d4e100c144", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -78,7 +78,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for HashMapLint {\n     }\n }\n \n-fn check_cond<'a, 'tcx, 'b>(cx: &'a LateContext<'a, 'tcx>, check: &'b Expr) -> Option<(&'static str, &'b Expr, &'b Expr)> {\n+fn check_cond<'a, 'tcx, 'b>(\n+    cx: &'a LateContext<'a, 'tcx>,\n+    check: &'b Expr\n+) -> Option<(&'static str, &'b Expr, &'b Expr)> {\n     if_let_chain! {[\n         let ExprMethodCall(ref name, _, ref params) = check.node,\n         params.len() >= 2,"}, {"sha": "0bd1740c5459d2ee7232779864de22c04225da41", "filename": "clippy_lints/src/enum_glob_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_glob_use.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -49,7 +49,7 @@ impl EnumGlobUse {\n         if let ItemUse(ref path, UseKind::Glob) = item.node {\n             // FIXME: ask jseyfried why the qpath.def for `use std::cmp::Ordering::*;`\n             // extracted through `ItemUse(ref qpath, UseKind::Glob)` is a `Mod` and not an `Enum`\n-            //if let Def::Enum(_) = path.def {\n+            // if let Def::Enum(_) = path.def {\n             if path.segments.last().and_then(|seg| seg.name.as_str().chars().next()).map_or(false, char::is_uppercase) {\n                 span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");\n             }"}, {"sha": "5ae3fcbb2a1e19d8ff51f8522ca79665e94046f3", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -49,10 +49,13 @@ declare_lint! {\n \n /// **What it does:** Checks for modules that have the same name as their parent module\n ///\n-/// **Why is this bad?** A typical beginner mistake is to have `mod foo;` and again `mod foo { .. }` in `foo.rs`.\n-///                      The expectation is that items inside the inner `mod foo { .. }` are then available\n+/// **Why is this bad?** A typical beginner mistake is to have `mod foo;` and again `mod foo { ..\n+/// }` in `foo.rs`.\n+/// The expectation is that items inside the inner `mod foo { .. }` are then\n+/// available\n ///                      through `foo::x`, but they are only available through `foo::foo::x`.\n-///                      If this is done on purpose, it would be better to choose a more representative module name.\n+/// If this is done on purpose, it would be better to choose a more\n+/// representative module name.\n ///\n /// **Known problems:** None.\n ///\n@@ -78,7 +81,10 @@ pub struct EnumVariantNames {\n \n impl EnumVariantNames {\n     pub fn new(threshold: u64) -> EnumVariantNames {\n-        EnumVariantNames { modules: Vec::new(), threshold: threshold }\n+        EnumVariantNames {\n+            modules: Vec::new(),\n+            threshold: threshold,\n+        }\n     }\n }\n \n@@ -108,8 +114,14 @@ fn partial_rmatch(post: &str, name: &str) -> usize {\n \n // FIXME: #600\n #[allow(while_let_on_iterator)]\n-fn check_variant(cx: &EarlyContext, threshold: u64, def: &EnumDef, item_name: &str,\n-                 item_name_chars: usize, span: Span) {\n+fn check_variant(\n+    cx: &EarlyContext,\n+    threshold: u64,\n+    def: &EnumDef,\n+    item_name: &str,\n+    item_name_chars: usize,\n+    span: Span\n+) {\n     if (def.variants.len() as u64) < threshold {\n         return;\n     }\n@@ -200,7 +212,10 @@ impl EarlyLintPass for EnumVariantNames {\n                 if !mod_camel.is_empty() {\n                     if mod_name == &item_name {\n                         if let ItemKind::Mod(..) = item.node {\n-                            span_lint(cx, MODULE_INCEPTION, item.span, \"module has the same name as its containing module\");\n+                            span_lint(cx,\n+                                      MODULE_INCEPTION,\n+                                      item.span,\n+                                      \"module has the same name as its containing module\");\n                         }\n                     }\n                     if item.vis == Visibility::Public {"}, {"sha": "bfc16a504570a93ee8a1c52e8429ba145fbda37e", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -48,19 +48,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n \n fn is_valid_operator(op: &BinOp) -> bool {\n     match op.node {\n-        BiSub |\n-        BiDiv |\n-        BiEq |\n-        BiLt |\n-        BiLe |\n-        BiGt |\n-        BiGe |\n-        BiNe |\n-        BiAnd |\n-        BiOr |\n-        BiBitXor |\n-        BiBitAnd |\n-        BiBitOr => true,\n+        BiSub | BiDiv | BiEq | BiLt | BiLe | BiGt | BiGe | BiNe | BiAnd | BiOr | BiBitXor | BiBitAnd | BiBitOr => true,\n         _ => false,\n     }\n }"}, {"sha": "ee415b36382439cd000855a40eba0543984133fa", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -46,7 +46,7 @@ fn is_non_trait_box(ty: ty::Ty) -> bool {\n     }\n }\n \n-struct EscapeDelegate<'a, 'tcx: 'a+'gcx, 'gcx: 'a> {\n+struct EscapeDelegate<'a, 'tcx: 'a + 'gcx, 'gcx: 'a> {\n     tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n     set: NodeSet,\n     infcx: &'a InferCtxt<'a, 'gcx, 'gcx>,\n@@ -68,7 +68,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         decl: &'tcx FnDecl,\n         body: &'tcx Expr,\n         _: Span,\n-        id: NodeId,\n+        id: NodeId\n     ) {\n         let param_env = ty::ParameterEnvironment::for_item(cx.tcx, id);\n \n@@ -98,7 +98,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-impl<'a, 'tcx: 'a+'gcx, 'gcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx, 'gcx> {\n+impl<'a, 'tcx: 'a + 'gcx, 'gcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx, 'gcx> {\n     fn consume(&mut self, _: NodeId, _: Span, cmt: cmt<'tcx>, mode: ConsumeMode) {\n         if let Categorization::Local(lid) = cmt.cat {\n             if self.set.contains(&lid) {\n@@ -151,18 +151,26 @@ impl<'a, 'tcx: 'a+'gcx, 'gcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx, 'g\n         }\n \n     }\n-    fn borrow(&mut self, borrow_id: NodeId, _: Span, cmt: cmt<'tcx>, _: &ty::Region, _: ty::BorrowKind,\n-              loan_cause: LoanCause) {\n+    fn borrow(\n+        &mut self,\n+        borrow_id: NodeId,\n+        _: Span,\n+        cmt: cmt<'tcx>,\n+        _: &ty::Region,\n+        _: ty::BorrowKind,\n+        loan_cause: LoanCause\n+    ) {\n         use rustc::ty::adjustment::Adjust;\n \n         if let Categorization::Local(lid) = cmt.cat {\n             if self.set.contains(&lid) {\n-                if let Some(&Adjust::DerefRef { autoderefs, .. }) = self.tcx\n-                                                                        .tables\n-                                                                        .borrow()\n-                                                                        .adjustments\n-                                                                        .get(&borrow_id)\n-                                                                        .map(|a| &a.kind) {\n+                if let Some(&Adjust::DerefRef { autoderefs, .. }) =\n+                    self.tcx\n+                        .tables\n+                        .borrow()\n+                        .adjustments\n+                        .get(&borrow_id)\n+                        .map(|a| &a.kind) {\n                     if LoanCause::AutoRef == loan_cause {\n                         // x.foo()\n                         if autoderefs == 0 {\n@@ -173,14 +181,15 @@ impl<'a, 'tcx: 'a+'gcx, 'gcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx, 'g\n                     }\n                 } else if LoanCause::AddrOf == loan_cause {\n                     // &x\n-                    if let Some(&Adjust::DerefRef { autoderefs, .. }) = self.tcx\n-                                                                            .tables\n-                                                                            .borrow()\n-                                                                            .adjustments\n-                                                                            .get(&self.tcx\n-                                                                            .map\n-                                                                            .get_parent_node(borrow_id))\n-                                                                            .map(|a| &a.kind) {\n+                    if let Some(&Adjust::DerefRef { autoderefs, .. }) =\n+                        self.tcx\n+                            .tables\n+                            .borrow()\n+                            .adjustments\n+                            .get(&self.tcx\n+                                .map\n+                                .get_parent_node(borrow_id))\n+                            .map(|a| &a.kind) {\n                         if autoderefs <= 1 {\n                             // foo(&x) where no extra autoreffing is happening\n                             self.set.remove(&lid);\n@@ -198,7 +207,7 @@ impl<'a, 'tcx: 'a+'gcx, 'gcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx, 'g\n     fn mutate(&mut self, _: NodeId, _: Span, _: cmt<'tcx>, _: MutateMode) {}\n }\n \n-impl<'a, 'tcx: 'a+'gcx, 'gcx: 'a> EscapeDelegate<'a, 'tcx, 'gcx> {\n+impl<'a, 'tcx: 'a + 'gcx, 'gcx: 'a> EscapeDelegate<'a, 'tcx, 'gcx> {\n     fn is_large_box(&self, ty: ty::Ty<'gcx>) -> bool {\n         // Large types need to be boxed to avoid stack\n         // overflows."}, {"sha": "f25014b6805e3b42b07c6ba01e497a09e2cfdd99", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -41,7 +41,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EtaPass {\n                 for arg in args {\n                     check_closure(cx, arg)\n                 }\n-            }\n+            },\n             _ => (),\n         }\n     }\n@@ -65,11 +65,10 @@ fn check_closure(cx: &LateContext, expr: &Expr) {\n                 // Is it an unsafe function? They don't implement the closure traits\n                 ty::TyFnDef(_, _, fn_ty) |\n                 ty::TyFnPtr(fn_ty) => {\n-                    if fn_ty.unsafety == Unsafety::Unsafe ||\n-                       fn_ty.sig.skip_binder().output().sty == ty::TyNever {\n+                    if fn_ty.unsafety == Unsafety::Unsafe || fn_ty.sig.skip_binder().output().sty == ty::TyNever {\n                         return;\n                     }\n-                }\n+                },\n                 _ => (),\n             }\n             for (a1, a2) in decl.inputs.iter().zip(args) {"}, {"sha": "f83b3271d506ae207d0968469a41ec763ca71fc7", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -60,7 +60,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EvalOrderDependence {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // Find a write to a local variable.\n         match expr.node {\n-            ExprAssign(ref lhs, _) | ExprAssignOp(_, ref lhs, _) => {\n+            ExprAssign(ref lhs, _) |\n+            ExprAssignOp(_, ref lhs, _) => {\n                 if let ExprPath(ref qpath) = lhs.node {\n                     if let QPath::Resolved(_, ref path) = *qpath {\n                         if path.segments.len() == 1 {\n@@ -75,13 +76,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EvalOrderDependence {\n                         }\n                     }\n                 }\n-            }\n-            _ => {}\n+            },\n+            _ => {},\n         }\n     }\n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n         match stmt.node {\n-            StmtExpr(ref e, _) | StmtSemi(ref e, _) => DivergenceVisitor { cx: cx }.maybe_walk_expr(e),\n+            StmtExpr(ref e, _) |\n+            StmtSemi(ref e, _) => DivergenceVisitor { cx: cx }.maybe_walk_expr(e),\n             StmtDecl(ref d, _) => {\n                 if let DeclLocal(ref local) = d.node {\n                     if let Local { init: Some(ref e), .. } = **local {\n@@ -110,32 +112,29 @@ impl<'a, 'tcx> DivergenceVisitor<'a, 'tcx> {\n                     // make sure top level arm expressions aren't linted\n                     self.maybe_walk_expr(&*arm.body);\n                 }\n-            }\n+            },\n             _ => walk_expr(self, e),\n         }\n     }\n     fn report_diverging_sub_expr(&mut self, e: &Expr) {\n-        span_lint(\n-            self.cx,\n-            DIVERGING_SUB_EXPRESSION,\n-            e.span,\n-            \"sub-expression diverges\",\n-        );\n+        span_lint(self.cx, DIVERGING_SUB_EXPRESSION, e.span, \"sub-expression diverges\");\n     }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, e: &'tcx Expr) {\n         match e.node {\n-            ExprAgain(_) |\n-            ExprBreak(_, _) |\n-            ExprRet(_) => self.report_diverging_sub_expr(e),\n-            ExprCall(ref func, _) => match self.cx.tcx.tables().expr_ty(func).sty {\n-                ty::TyFnDef(_, _, fn_ty) |\n-                ty::TyFnPtr(fn_ty) => if let ty::TyNever = self.cx.tcx.erase_late_bound_regions(&fn_ty.sig).output().sty {\n-                    self.report_diverging_sub_expr(e);\n-                },\n-                _ => {},\n+            ExprAgain(_) | ExprBreak(_, _) | ExprRet(_) => self.report_diverging_sub_expr(e),\n+            ExprCall(ref func, _) => {\n+                match self.cx.tcx.tables().expr_ty(func).sty {\n+                    ty::TyFnDef(_, _, fn_ty) |\n+                    ty::TyFnPtr(fn_ty) => {\n+                        if let ty::TyNever = self.cx.tcx.erase_late_bound_regions(&fn_ty.sig).output().sty {\n+                            self.report_diverging_sub_expr(e);\n+                        }\n+                    },\n+                    _ => {},\n+                }\n             },\n             ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(e.id);\n@@ -147,7 +146,8 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n                 }\n             },\n             _ => {\n-                // do not lint expressions referencing objects of type `!`, as that required a diverging expression to begin with\n+                // do not lint expressions referencing objects of type `!`, as that required a diverging expression\n+                // to begin with\n             },\n         }\n         self.maybe_walk_expr(e);\n@@ -195,7 +195,7 @@ fn check_for_unsequenced_reads(vis: &mut ReadVisitor) {\n                 // We reached the top of the function, stop.\n                 break;\n             },\n-            _ => { StopEarly::KeepGoing }\n+            _ => StopEarly::KeepGoing,\n         };\n         match stop_early {\n             StopEarly::Stop => break,\n@@ -214,7 +214,7 @@ enum StopEarly {\n     Stop,\n }\n \n-fn check_expr<'a, 'tcx>(vis: & mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr) -> StopEarly {\n+fn check_expr<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr) -> StopEarly {\n     if expr.id == vis.last_expr.id {\n         return StopEarly::KeepGoing;\n     }\n@@ -229,7 +229,7 @@ fn check_expr<'a, 'tcx>(vis: & mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr) -> S\n         ExprRepeat(_, _) |\n         ExprStruct(_, _, _) => {\n             walk_expr(vis, expr);\n-        }\n+        },\n         ExprBinary(op, _, _) |\n         ExprAssignOp(op, _, _) => {\n             if op.node == BiAnd || op.node == BiOr {\n@@ -238,7 +238,7 @@ fn check_expr<'a, 'tcx>(vis: & mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr) -> S\n             } else {\n                 walk_expr(vis, expr);\n             }\n-        }\n+        },\n         ExprClosure(_, _, _, _) => {\n             // Either\n             //\n@@ -252,10 +252,10 @@ fn check_expr<'a, 'tcx>(vis: & mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr) -> S\n             //\n             // This is also the only place we need to stop early (grrr).\n             return StopEarly::Stop;\n-        }\n+        },\n         // All other expressions either have only one child or strictly\n         // sequence the evaluation order of their sub-expressions.\n-        _ => {}\n+        _ => {},\n     }\n \n     vis.last_expr = expr;\n@@ -276,7 +276,7 @@ fn check_stmt<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, stmt: &'tcx Stmt) -> St\n             };\n             local.and_then(|local| local.init.as_ref())\n                 .map_or(StopEarly::KeepGoing, |expr| check_expr(vis, expr))\n-        }\n+        },\n     }\n }\n "}, {"sha": "1894a12a6d3ebc4dfbb9870fbffbeb486ff22861", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -55,15 +55,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     ], {\n                         span_lint(cx, USELESS_FORMAT, span, \"useless use of `format!`\");\n                     }}\n-                }\n+                },\n                 // `format!(\"foo\")` expansion contains `match () { () => [], }`\n                 ExprMatch(ref matchee, _, _) => {\n                     if let ExprTup(ref tup) = matchee.node {\n                         if tup.is_empty() {\n                             span_lint(cx, USELESS_FORMAT, span, \"useless use of `format!`\");\n                         }\n                     }\n-                }\n+                },\n                 _ => (),\n             }\n         }\n@@ -72,8 +72,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n /// Returns the slice of format string parts in an `Arguments::new_v1` call.\n /// Public because it's shared with a lint in print.rs.\n-pub fn get_argument_fmtstr_parts<'a, 'b>(cx: &LateContext<'a, 'b>, expr: &'a Expr)\n-                                         -> Option<Vec<InternedString>> {\n+pub fn get_argument_fmtstr_parts<'a, 'b>(cx: &LateContext<'a, 'b>, expr: &'a Expr) -> Option<Vec<InternedString>> {\n     if_let_chain! {[\n         let ExprBlock(ref block) = expr.node,\n         block.stmts.len() == 1,"}, {"sha": "6fdedaeed43b8a9aa60bb60221a58d8226238ec9", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -62,7 +62,7 @@ impl EarlyLintPass for Formatting {\n                 (&ast::StmtKind::Expr(ref first), &ast::StmtKind::Expr(ref second)) |\n                 (&ast::StmtKind::Expr(ref first), &ast::StmtKind::Semi(ref second)) => {\n                     check_consecutive_ifs(cx, first, second);\n-                }\n+                },\n                 _ => (),\n             }\n         }"}, {"sha": "5ad676e57a088644b4f938256666c00e7e346b99", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -76,7 +76,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n         decl: &'tcx hir::FnDecl,\n         expr: &'tcx hir::Expr,\n         span: Span,\n-        nodeid: ast::NodeId,\n+        nodeid: ast::NodeId\n     ) {\n         use rustc::hir::map::Node::*;\n \n@@ -137,7 +137,7 @@ impl<'a, 'tcx> Functions {\n         unsafety: hir::Unsafety,\n         decl: &'tcx hir::FnDecl,\n         expr: &'tcx hir::Expr,\n-        nodeid: ast::NodeId,\n+        nodeid: ast::NodeId\n     ) {\n         if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(nodeid) {\n             let raw_ptrs = decl.inputs.iter().filter_map(|arg| raw_ptr_arg(cx, arg)).collect::<HashSet<_>>();\n@@ -178,7 +178,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n                         self.check_arg(arg);\n                     }\n                 }\n-            }\n+            },\n             hir::ExprMethodCall(_, _, ref args) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n                 let base_type = self.cx.tcx.tables.borrow().method_map[&method_call].ty;\n@@ -188,7 +188,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n                         self.check_arg(arg);\n                     }\n                 }\n-            }\n+            },\n             hir::ExprUnary(hir::UnDeref, ref ptr) => self.check_arg(ptr),\n             _ => (),\n         }"}, {"sha": "a10a9523ac1b581e7c312c293bbbab0cf88aa9f7", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -41,17 +41,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n                 BiAdd | BiBitOr | BiBitXor => {\n                     check(cx, left, 0, e.span, right.span);\n                     check(cx, right, 0, e.span, left.span);\n-                }\n+                },\n                 BiShl | BiShr | BiSub => check(cx, right, 0, e.span, left.span),\n                 BiMul => {\n                     check(cx, left, 1, e.span, right.span);\n                     check(cx, right, 1, e.span, left.span);\n-                }\n+                },\n                 BiDiv => check(cx, right, 1, e.span, left.span),\n                 BiBitAnd => {\n                     check(cx, left, -1, e.span, right.span);\n                     check(cx, right, -1, e.span, left.span);\n-                }\n+                },\n                 _ => (),\n             }\n         }"}, {"sha": "921cd7f8885e23cd1e07cfdb994cde7731519efa", "filename": "clippy_lints/src/if_let_redundant_pattern_matching.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -45,45 +45,40 @@ impl LintPass for Pass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n \n-        if let ExprMatch(ref op, ref arms, MatchSource::IfLetDesugar{..}) = expr.node {\n+        if let ExprMatch(ref op, ref arms, MatchSource::IfLetDesugar { .. }) = expr.node {\n \n             if arms[0].pats.len() == 1 {\n \n                 let good_method = match arms[0].pats[0].node {\n-                    PatKind::TupleStruct(ref path, ref pats, _) if pats.len() == 1 && pats[0].node == PatKind::Wild =>  {\n-\n+                    PatKind::TupleStruct(ref path, ref pats, _) if pats.len() == 1 && pats[0].node == PatKind::Wild => {\n                         if match_path(path, &paths::RESULT_OK) {\n                             \"is_ok()\"\n                         } else if match_path(path, &paths::RESULT_ERR) {\n                             \"is_err()\"\n                         } else if match_path(path, &paths::OPTION_SOME) {\n                             \"is_some()\"\n                         } else {\n-                            return\n+                            return;\n                         }\n-                    }\n+                    },\n \n-                    PatKind::Path(ref path) if match_path(path, &paths::OPTION_NONE) => {\n-                        \"is_none()\"\n-                    }\n+                    PatKind::Path(ref path) if match_path(path, &paths::OPTION_NONE) => \"is_none()\",\n \n-                    _ => return\n+                    _ => return,\n                 };\n \n                 span_lint_and_then(cx,\n                                    IF_LET_REDUNDANT_PATTERN_MATCHING,\n                                    arms[0].pats[0].span,\n                                    &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n                                    |db| {\n-                                        let span = Span {\n-                                            lo: expr.span.lo,\n-                                            hi: op.span.hi,\n-                                            expn_id: expr.span.expn_id,\n-                                        };\n-                                        db.span_suggestion(span,\n-                                                           \"try this\",\n-                                                           format!(\"if {}.{}\", snippet(cx, op.span, \"_\"), good_method));\n-                                    });\n+                    let span = Span {\n+                        lo: expr.span.lo,\n+                        hi: op.span.hi,\n+                        expn_id: expr.span.expn_id,\n+                    };\n+                    db.span_suggestion(span, \"try this\", format!(\"if {}.{}\", snippet(cx, op.span, \"_\"), good_method));\n+                });\n             }\n \n         }"}, {"sha": "72a3d485bd08069eb3187463150255f2e67a1667", "filename": "clippy_lints/src/if_not_else.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fif_not_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fif_not_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_not_else.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -55,14 +55,14 @@ impl EarlyLintPass for IfNotElse {\n                                            item.span,\n                                            \"Unnecessary boolean `not` operation\",\n                                            \"remove the `!` and swap the blocks of the if/else\");\n-                    }\n+                    },\n                     ExprKind::Binary(ref kind, _, _) if kind.node == BinOpKind::Ne => {\n                         span_help_and_lint(cx,\n                                            IF_NOT_ELSE,\n                                            item.span,\n                                            \"Unnecessary `!=` operation\",\n                                            \"change to `==` and swap the blocks of the if/else\");\n-                    }\n+                    },\n                     _ => (),\n                 }\n             }"}, {"sha": "3b3cd423729b78f6cb916f3444b8bdbed93ddecb", "filename": "clippy_lints/src/items_after_statements.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fitems_after_statements.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -47,9 +47,10 @@ impl EarlyLintPass for ItemsAfterStatements {\n         }\n \n         // skip initial items\n-        let stmts = item.stmts.iter()\n-                              .map(|stmt| &stmt.node)\n-                              .skip_while(|s| matches!(**s, StmtKind::Item(..)));\n+        let stmts = item.stmts\n+            .iter()\n+            .map(|stmt| &stmt.node)\n+            .skip_while(|s| matches!(**s, StmtKind::Item(..)));\n \n         // lint on all further items\n         for stmt in stmts {"}, {"sha": "22835b4884033e1e79d2a419f0e693d425ff3b66", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -107,8 +107,7 @@ fn check_trait_items(cx: &LateContext, item: &Item, trait_items: &[TraitItem]) {\n                 span_lint(cx,\n                           LEN_WITHOUT_IS_EMPTY,\n                           i.span,\n-                          &format!(\"trait `{}` has a `len` method but no `is_empty` method\",\n-                                   item.name));\n+                          &format!(\"trait `{}` has a `len` method but no `is_empty` method\", item.name));\n             }\n         }\n     }\n@@ -118,7 +117,8 @@ fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n     fn is_named_self(cx: &LateContext, item: &ImplItemRef, name: &str) -> bool {\n         &*item.name.as_str() == name &&\n         if let AssociatedItemKind::Method { has_self } = item.kind {\n-            has_self && {\n+            has_self &&\n+            {\n                 let did = cx.tcx.map.local_def_id(item.id.node_id);\n                 let impl_ty = cx.tcx.item_type(did);\n                 impl_ty.fn_args().skip_binder().len() == 1\n@@ -146,9 +146,7 @@ fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n             span_lint(cx,\n                       LEN_WITHOUT_IS_EMPTY,\n                       i.span,\n-                      &format!(\"item `{}` has a public `len` method but {} `is_empty` method\",\n-                               ty,\n-                               is_empty));\n+                      &format!(\"item `{}` has a public `len` method but {} `is_empty` method\", ty, is_empty));\n         }\n     }\n }\n@@ -164,7 +162,7 @@ fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str)\n         (&ExprLit(ref lit), &ExprMethodCall(ref method, _, ref args)) |\n         (&ExprMethodCall(ref method, _, ref args), &ExprLit(ref lit)) => {\n             check_len_zero(cx, span, &method.node, args, lit, op)\n-        }\n+        },\n         _ => (),\n     }\n }\n@@ -199,20 +197,18 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n \n     /// Check the inherent impl's items for an `is_empty(self)` method.\n     fn has_is_empty_impl(cx: &LateContext, id: DefId) -> bool {\n-        cx.tcx.inherent_impls.borrow().get(&id).map_or(false, |impls| impls.iter().any(|imp| {\n-            cx.tcx.associated_items(*imp).any(|item| {\n-                is_is_empty(cx, &item)\n-            })\n-        }))\n+        cx.tcx.inherent_impls.borrow().get(&id).map_or(false, |impls| {\n+            impls.iter().any(|imp| cx.tcx.associated_items(*imp).any(|item| is_is_empty(cx, &item)))\n+        })\n     }\n \n     let ty = &walk_ptrs_ty(cx.tcx.tables().expr_ty(expr));\n     match ty.sty {\n         ty::TyDynamic(..) => {\n             cx.tcx\n-              .associated_items(ty.ty_to_def_id().expect(\"trait impl not found\"))\n-              .any(|item| is_is_empty(cx, &item))\n-        }\n+                .associated_items(ty.ty_to_def_id().expect(\"trait impl not found\"))\n+                .any(|item| is_is_empty(cx, &item))\n+        },\n         ty::TyProjection(_) => ty.ty_to_def_id().map_or(false, |id| has_is_empty_impl(cx, id)),\n         ty::TyAdt(id, _) => has_is_empty_impl(cx, id.did),\n         ty::TyArray(..) | ty::TyStr => true,"}, {"sha": "88d74b01886335e69e58edbee8009119acaa78b1", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -152,7 +152,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n fn check_assign<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     decl: hir::def_id::DefId,\n-    block: &'tcx hir::Block,\n+    block: &'tcx hir::Block\n ) -> Option<&'tcx hir::Expr> {\n     if_let_chain! {[\n         block.expr.is_none(),\n@@ -182,11 +182,7 @@ fn check_assign<'a, 'tcx>(\n     None\n }\n \n-fn used_in_expr<'a, 'tcx: 'a>(\n-    cx: &LateContext<'a, 'tcx>,\n-    id: hir::def_id::DefId,\n-    expr: &'tcx hir::Expr,\n-) -> bool {\n+fn used_in_expr<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, id: hir::def_id::DefId, expr: &'tcx hir::Expr) -> bool {\n     let mut v = UsedVisitor {\n         cx: cx,\n         id: id,"}, {"sha": "3641b476c5fb6d76b0eef9a59ea6acee6bd19a5c", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -173,10 +173,22 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     };\n \n     let mut store = reg.sess.lint_store.borrow_mut();\n-    store.register_removed(\"unstable_as_slice\", \"`Vec::as_slice` has been stabilized in 1.7\");\n-    store.register_removed(\"unstable_as_mut_slice\", \"`Vec::as_mut_slice` has been stabilized in 1.7\");\n-    store.register_removed(\"str_to_string\", \"using `str::to_string` is common even today and specialization will likely happen soon\");\n-    store.register_removed(\"string_to_string\", \"using `string::to_string` is common even today and specialization will likely happen soon\");\n+    store.register_removed(\n+        \"unstable_as_slice\",\n+        \"`Vec::as_slice` has been stabilized in 1.7\",\n+    );\n+    store.register_removed(\n+        \"unstable_as_mut_slice\",\n+        \"`Vec::as_mut_slice` has been stabilized in 1.7\",\n+    );\n+    store.register_removed(\n+        \"str_to_string\",\n+        \"using `str::to_string` is common even today and specialization will likely happen soon\",\n+    );\n+    store.register_removed(\n+        \"string_to_string\",\n+        \"using `string::to_string` is common even today and specialization will likely happen soon\",\n+    );\n     // end deprecated lints, do not remove this comment, it\u2019s used in `update_lints`\n \n     reg.register_late_lint_pass(box serde::Serde);\n@@ -229,7 +241,9 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box map_clone::Pass);\n     reg.register_late_lint_pass(box temporary_assignment::Pass);\n     reg.register_late_lint_pass(box transmute::Transmute);\n-    reg.register_late_lint_pass(box cyclomatic_complexity::CyclomaticComplexity::new(conf.cyclomatic_complexity_threshold));\n+    reg.register_late_lint_pass(\n+        box cyclomatic_complexity::CyclomaticComplexity::new(conf.cyclomatic_complexity_threshold)\n+    );\n     reg.register_late_lint_pass(box escape::Pass{too_large_for_stack: conf.too_large_for_stack});\n     reg.register_early_lint_pass(box misc_early::MiscEarly);\n     reg.register_late_lint_pass(box array_indexing::ArrayIndexing);"}, {"sha": "ba705a84089c3db6e33f5ee4787c2ef992659a60", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 20, "deletions": 29, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -87,30 +87,25 @@ enum RefLt {\n fn bound_lifetimes(bound: &TyParamBound) -> HirVec<&Lifetime> {\n     if let TraitTyParamBound(ref trait_ref, _) = *bound {\n         trait_ref.trait_ref\n-                 .path\n-                 .segments\n-                 .last()\n-                 .expect(\"a path must have at least one segment\")\n-                 .parameters\n-                 .lifetimes()\n+            .path\n+            .segments\n+            .last()\n+            .expect(\"a path must have at least one segment\")\n+            .parameters\n+            .lifetimes()\n     } else {\n         HirVec::new()\n     }\n }\n \n-fn check_fn_inner<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    decl: &'tcx FnDecl,\n-    generics: &'tcx Generics,\n-    span: Span,\n-) {\n+fn check_fn_inner<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl, generics: &'tcx Generics, span: Span) {\n     if in_external_macro(cx, span) || has_where_lifetimes(cx, &generics.where_clause) {\n         return;\n     }\n \n     let bounds_lts = generics.ty_params\n-                             .iter()\n-                             .flat_map(|typ| typ.bounds.iter().flat_map(bound_lifetimes));\n+        .iter()\n+        .flat_map(|typ| typ.bounds.iter().flat_map(bound_lifetimes));\n \n     if could_use_elision(cx, decl, &generics.lifetimes, bounds_lts) {\n         span_lint(cx,\n@@ -121,15 +116,11 @@ fn check_fn_inner<'a, 'tcx>(\n     report_extra_lifetimes(cx, decl, generics);\n }\n \n-fn could_use_elision<\n-    'a,\n-    'tcx: 'a,\n-    T: Iterator<Item = &'tcx Lifetime>\n->(\n+fn could_use_elision<'a, 'tcx: 'a, T: Iterator<Item = &'tcx Lifetime>>(\n     cx: &LateContext<'a, 'tcx>,\n     func: &'tcx FnDecl,\n     named_lts: &'tcx [LifetimeDef],\n-    bounds_lts: T,\n+    bounds_lts: T\n ) -> bool {\n     // There are two scenarios where elision works:\n     // * no output references, all input references have different LT\n@@ -262,13 +253,13 @@ impl<'v, 't> RefVisitor<'v, 't> {\n                         for _ in generics.regions.as_slice() {\n                             self.record(&None);\n                         }\n-                    }\n+                    },\n                     Def::Trait(def_id) => {\n                         let trait_def = self.cx.tcx.trait_defs.borrow()[&def_id];\n                         for _ in &self.cx.tcx.item_generics(trait_def.def_id).regions {\n                             self.record(&None);\n                         }\n-                    }\n+                    },\n                     _ => (),\n                 }\n             }\n@@ -286,10 +277,10 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n         match ty.node {\n             TyRptr(None, _) => {\n                 self.record(&None);\n-            }\n+            },\n             TyPath(ref path) => {\n                 self.collect_anonymous_lifetimes(path, ty);\n-            }\n+            },\n             _ => (),\n         }\n         walk_ty(self, ty);\n@@ -325,14 +316,14 @@ fn has_where_lifetimes<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, where_clause: &\n                         return true;\n                     }\n                 }\n-            }\n+            },\n             WherePredicate::EqPredicate(ref pred) => {\n                 let mut visitor = RefVisitor::new(cx);\n                 walk_ty(&mut visitor, &pred.ty);\n                 if !visitor.lts.is_empty() {\n                     return true;\n                 }\n-            }\n+            },\n         }\n     }\n     false\n@@ -362,9 +353,9 @@ impl<'tcx> Visitor<'tcx> for LifetimeChecker {\n \n fn report_extra_lifetimes<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, func: &'tcx FnDecl, generics: &'tcx Generics) {\n     let hs = generics.lifetimes\n-                     .iter()\n-                     .map(|lt| (lt.lifetime.name, lt.lifetime.span))\n-                     .collect();\n+        .iter()\n+        .map(|lt| (lt.lifetime.name, lt.lifetime.span))\n+        .collect();\n     let mut checker = LifetimeChecker { map: hs };\n \n     walk_generics(&mut checker, generics);"}, {"sha": "9a3defec72df682535d76925c32c269dcf4bf0c8", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 62, "deletions": 72, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -14,9 +14,9 @@ use std::collections::HashMap;\n use syntax::ast;\n use utils::sugg;\n \n-use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, multispan_sugg,\n-            in_external_macro, is_refutable, span_help_and_lint, is_integer_literal,\n-            get_enclosing_block, span_lint_and_then, higher, walk_ptrs_ty, last_path_segment};\n+use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, multispan_sugg, in_external_macro,\n+            is_refutable, span_help_and_lint, is_integer_literal, get_enclosing_block, span_lint_and_then, higher,\n+            walk_ptrs_ty, last_path_segment};\n use utils::paths;\n \n /// **What it does:** Checks for looping over the range of `0..len` of some\n@@ -334,8 +334,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     match *source {\n                         MatchSource::Normal |\n                         MatchSource::IfLetDesugar { .. } => {\n-                            if arms.len() == 2 &&\n-                               arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n+                            if arms.len() == 2 && arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n                                arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n                                is_break_expr(&arms[1].body) {\n                                 if in_external_macro(cx, expr.span) {\n@@ -352,13 +351,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                                    expr.span,\n                                                    \"this loop could be written as a `while let` loop\",\n                                                    |db| {\n-                                                       let sug = format!(\"while let {} = {} {{ .. }}\",\n-                                                                         snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                                                         snippet(cx, matchexpr.span, \"..\"));\n-                                                       db.span_suggestion(expr.span, \"try\", sug);\n-                                                   });\n+                                    let sug = format!(\"while let {} = {} {{ .. }}\",\n+                                                      snippet(cx, arms[0].pats[0].span, \"..\"),\n+                                                      snippet(cx, matchexpr.span, \"..\"));\n+                                    db.span_suggestion(expr.span, \"try\", sug);\n+                                });\n                             }\n-                        }\n+                        },\n                         _ => (),\n                     }\n                 }\n@@ -370,10 +369,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     &ExprMethodCall(method_name, _, ref method_args)) = (pat, &match_expr.node) {\n                 let iter_expr = &method_args[0];\n                 let lhs_constructor = last_path_segment(qpath);\n-                if &*method_name.node.as_str() == \"next\" &&\n-                   match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n-                   &*lhs_constructor.name.as_str() == \"Some\" &&\n-                   !is_refutable(cx, &pat_args[0]) &&\n+                if &*method_name.node.as_str() == \"next\" && match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n+                   &*lhs_constructor.name.as_str() == \"Some\" && !is_refutable(cx, &pat_args[0]) &&\n                    !is_iterator_used_after_while_let(cx, iter_expr) {\n                     let iterator = snippet(cx, method_args[0].span, \"_\");\n                     let loop_var = snippet(cx, pat_args[0].span, \"_\");\n@@ -382,9 +379,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                        expr.span,\n                                        \"this loop could be written as a `for` loop\",\n                                        |db| {\n-                    db.span_suggestion(expr.span,\n-                                       \"try\",\n-                                       format!(\"for {} in {} {{ .. }}\", loop_var, iterator));\n+                        db.span_suggestion(expr.span, \"try\", format!(\"for {} in {} {{ .. }}\", loop_var, iterator));\n                     });\n                 }\n             }\n@@ -412,7 +407,7 @@ fn check_for_loop<'a, 'tcx>(\n     pat: &'tcx Pat,\n     arg: &'tcx Expr,\n     body: &'tcx Expr,\n-    expr: &'tcx Expr,\n+    expr: &'tcx Expr\n ) {\n     check_for_loop_range(cx, pat, arg, body, expr);\n     check_for_loop_reverse_range(cx, arg, expr);\n@@ -428,7 +423,7 @@ fn check_for_loop_range<'a, 'tcx>(\n     pat: &'tcx Pat,\n     arg: &'tcx Expr,\n     body: &'tcx Expr,\n-    expr: &'tcx Expr,\n+    expr: &'tcx Expr\n ) {\n     if let Some(higher::Range { start: Some(start), ref end, limits }) = higher::range(arg) {\n         // the var must be a single name\n@@ -444,9 +439,9 @@ fn check_for_loop_range<'a, 'tcx>(\n             // linting condition: we only indexed one variable\n             if visitor.indexed.len() == 1 {\n                 let (indexed, indexed_extent) = visitor.indexed\n-                                                       .into_iter()\n-                                                       .next()\n-                                                       .unwrap_or_else(|| unreachable!() /* len == 1 */);\n+                    .into_iter()\n+                    .next()\n+                    .unwrap_or_else(|| unreachable!() /* len == 1 */);\n \n                 // ensure that the indexed variable was declared before the loop, see #601\n                 if let Some(indexed_extent) = indexed_extent {\n@@ -472,10 +467,8 @@ fn check_for_loop_range<'a, 'tcx>(\n                             ast::RangeLimits::Closed => {\n                                 let end = sugg::Sugg::hir(cx, end, \"<count>\");\n                                 format!(\".take({})\", end + sugg::ONE)\n-                            }\n-                            ast::RangeLimits::HalfOpen => {\n-                                format!(\".take({})\", snippet(cx, end.span, \"..\"))\n-                            }\n+                            },\n+                            ast::RangeLimits::HalfOpen => format!(\".take({})\", snippet(cx, end.span, \"..\")),\n                         }\n                     }\n                 } else {\n@@ -488,10 +481,10 @@ fn check_for_loop_range<'a, 'tcx>(\n                                        expr.span,\n                                        &format!(\"the loop variable `{}` is used to index `{}`\", ident.node, indexed),\n                                        |db| {\n-                        multispan_sugg(db, \"consider using an iterator\".to_string(), &[\n-                            (pat.span, &format!(\"({}, <item>)\", ident.node)),\n-                            (arg.span, &format!(\"{}.iter().enumerate(){}{}\", indexed, take, skip)),\n-                        ]);\n+                        multispan_sugg(db,\n+                                       \"consider using an iterator\".to_string(),\n+                                       &[(pat.span, &format!(\"({}, <item>)\", ident.node)),\n+                                         (arg.span, &format!(\"{}.iter().enumerate(){}{}\", indexed, take, skip))]);\n                     });\n                 } else {\n                     let repl = if starts_at_zero && take.is_empty() {\n@@ -503,12 +496,13 @@ fn check_for_loop_range<'a, 'tcx>(\n                     span_lint_and_then(cx,\n                                        NEEDLESS_RANGE_LOOP,\n                                        expr.span,\n-                                       &format!(\"the loop variable `{}` is only used to index `{}`.\", ident.node, indexed),\n+                                       &format!(\"the loop variable `{}` is only used to index `{}`.\",\n+                                                ident.node,\n+                                                indexed),\n                                        |db| {\n-                        multispan_sugg(db, \"consider using an iterator\".to_string(), &[\n-                            (pat.span, \"<item>\"),\n-                            (arg.span, &repl),\n-                        ]);\n+                        multispan_sugg(db,\n+                                       \"consider using an iterator\".to_string(),\n+                                       &[(pat.span, \"<item>\"), (arg.span, &repl)]);\n                     });\n                 }\n             }\n@@ -544,7 +538,7 @@ fn check_for_loop_reverse_range(cx: &LateContext, arg: &Expr, expr: &Expr) {\n                 let (sup, eq) = match (start_idx, end_idx) {\n                     (ConstVal::Integral(start_idx), ConstVal::Integral(end_idx)) => {\n                         (start_idx > end_idx, start_idx == end_idx)\n-                    }\n+                    },\n                     _ => (false, false),\n                 };\n \n@@ -562,15 +556,14 @@ fn check_for_loop_reverse_range(cx: &LateContext, arg: &Expr, expr: &Expr) {\n                                        expr.span,\n                                        \"this range is empty so this for loop will never run\",\n                                        |db| {\n-                                           db.span_suggestion(arg.span,\n-                                                              \"consider using the following if \\\n-                                                               you are attempting to iterate \\\n-                                                               over this range in reverse\",\n-                                                              format!(\"({end}{dots}{start}).rev()\",\n-                                                                      end=end_snippet,\n-                                                                      dots=dots,\n-                                                                      start=start_snippet));\n-                                       });\n+                        db.span_suggestion(arg.span,\n+                                           \"consider using the following if you are attempting to iterate over this \\\n+                                            range in reverse\",\n+                                           format!(\"({end}{dots}{start}).rev()\",\n+                                                   end = end_snippet,\n+                                                   dots = dots,\n+                                                   start = start_snippet));\n+                    });\n                 } else if eq && limits != ast::RangeLimits::Closed {\n                     // if they are equal, it's also problematic - this loop\n                     // will never run.\n@@ -608,14 +601,14 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n                                        method_name));\n                 }\n             } else if &*method_name.as_str() == \"into_iter\" && match_trait_method(cx, arg, &paths::INTO_ITERATOR) {\n-                    let object = snippet(cx, args[0].span, \"_\");\n-                    span_lint(cx,\n-                              EXPLICIT_INTO_ITER_LOOP,\n-                              expr.span,\n-                              &format!(\"it is more idiomatic to loop over `{}` instead of `{}.{}()`\",\n-                                       object,\n-                                       object,\n-                                       method_name));\n+                let object = snippet(cx, args[0].span, \"_\");\n+                span_lint(cx,\n+                          EXPLICIT_INTO_ITER_LOOP,\n+                          expr.span,\n+                          &format!(\"it is more idiomatic to loop over `{}` instead of `{}.{}()`\",\n+                                   object,\n+                                   object,\n+                                   method_name));\n \n             } else if &*method_name.as_str() == \"next\" && match_trait_method(cx, arg, &paths::ITERATOR) {\n                 span_lint(cx,\n@@ -662,7 +655,7 @@ fn check_for_loop_explicit_counter<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     arg: &'tcx Expr,\n     body: &'tcx Expr,\n-    expr: &'tcx Expr,\n+    expr: &'tcx Expr\n ) {\n     // Look for variables that are incremented once per loop iteration.\n     let mut visitor = IncrementVisitor {\n@@ -713,7 +706,7 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n     pat: &'tcx Pat,\n     arg: &'tcx Expr,\n     body: &'tcx Expr,\n-    expr: &'tcx Expr,\n+    expr: &'tcx Expr\n ) {\n     let pat_span = pat.span;\n \n@@ -739,10 +732,10 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n                                    &format!(\"you seem to want to iterate on a map's {}s\", kind),\n                                    |db| {\n                     let map = sugg::Sugg::hir(cx, arg, \"map\");\n-                    multispan_sugg(db, \"use the corresponding method\".into(), &[\n-                        (pat_span, &snippet(cx, new_pat_span, kind)),\n-                        (arg_span, &format!(\"{}.{}s()\", map.maybe_par(), kind)),\n-                    ]);\n+                    multispan_sugg(db,\n+                                   \"use the corresponding method\".into(),\n+                                   &[(pat_span, &snippet(cx, new_pat_span, kind)),\n+                                     (arg_span, &format!(\"{}.{}s()\", map.maybe_par(), kind))]);\n                 });\n             }\n         }\n@@ -751,11 +744,7 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n }\n \n /// Return true if the pattern is a `PatWild` or an ident prefixed with `'_'`.\n-fn pat_is_wild<'a, 'tcx: 'a>(\n-    cx: &LateContext<'a, 'tcx>,\n-    pat: &'tcx PatKind,\n-    body: &'tcx Expr,\n-) -> bool {\n+fn pat_is_wild<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, pat: &'tcx PatKind, body: &'tcx Expr) -> bool {\n     match *pat {\n         PatKind::Wild => true,\n         PatKind::Binding(_, _, ident, None) if ident.node.as_str().starts_with('_') => {\n@@ -766,7 +755,7 @@ fn pat_is_wild<'a, 'tcx: 'a>(\n             };\n             walk_expr(&mut visitor, body);\n             !visitor.used\n-        }\n+        },\n         _ => false,\n     }\n }\n@@ -938,10 +927,11 @@ fn extract_first_expr(block: &Block) -> Option<&Expr> {\n         Some(ref expr) if block.stmts.is_empty() => Some(expr),\n         None if !block.stmts.is_empty() => {\n             match block.stmts[0].node {\n-                StmtExpr(ref expr, _) | StmtSemi(ref expr, _) => Some(expr),\n+                StmtExpr(ref expr, _) |\n+                StmtSemi(ref expr, _) => Some(expr),\n                 StmtDecl(..) => None,\n             }\n-        }\n+        },\n         _ => None,\n     }\n }\n@@ -955,7 +945,7 @@ fn is_break_expr(expr: &Expr) -> bool {\n                 Some(subexpr) => is_break_expr(subexpr),\n                 None => false,\n             }\n-        }\n+        },\n         _ => false,\n     }\n }\n@@ -1004,7 +994,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n                                 *state = VarState::DontWarn;\n                             }\n                         }\n-                    }\n+                    },\n                     ExprAssign(ref lhs, _) if lhs.id == expr.id => *state = VarState::DontWarn,\n                     ExprAddrOf(mutability, _) if mutability == MutMutable => *state = VarState::DontWarn,\n                     _ => (),\n@@ -1081,14 +1071,14 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n                 match parent.node {\n                     ExprAssignOp(_, ref lhs, _) if lhs.id == expr.id => {\n                         self.state = VarState::DontWarn;\n-                    }\n+                    },\n                     ExprAssign(ref lhs, ref rhs) if lhs.id == expr.id => {\n                         self.state = if is_integer_literal(rhs, 0) && self.depth == 0 {\n                             VarState::Warn\n                         } else {\n                             VarState::DontWarn\n                         }\n-                    }\n+                    },\n                     ExprAddrOf(mutability, _) if mutability == MutMutable => self.state = VarState::DontWarn,\n                     _ => (),\n                 }"}, {"sha": "f04a4b32de2b63ffa509e099731aab0b69dbf395", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -63,7 +63,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                 }\n                             }\n                         }}\n-                    }\n+                    },\n                     ExprPath(ref path) => {\n                         if match_path(path, &paths::CLONE) {\n                             let type_name = get_type_name(cx, expr, &args[0]).unwrap_or(\"_\");\n@@ -75,7 +75,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                                         type_name),\n                                                &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n                         }\n-                    }\n+                    },\n                     _ => (),\n                 }\n             }\n@@ -91,7 +91,7 @@ fn expr_eq_name(expr: &Expr, id: ast::Name) -> bool {\n                                    parameters: PathParameters::none(),\n                                }];\n             !path.global && path.segments[..] == arg_segment\n-        }\n+        },\n         _ => false,\n     }\n }"}, {"sha": "978e9f5a029fec8b2afe0a0bffa2b1e33fd9c7fa", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 50, "deletions": 41, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -125,7 +125,11 @@ pub struct MatchPass;\n \n impl LintPass for MatchPass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(SINGLE_MATCH, MATCH_REF_PATS, MATCH_BOOL, SINGLE_MATCH_ELSE, MATCH_OVERLAPPING_ARM)\n+        lint_array!(SINGLE_MATCH,\n+                    MATCH_REF_PATS,\n+                    MATCH_BOOL,\n+                    SINGLE_MATCH_ELSE,\n+                    MATCH_OVERLAPPING_ARM)\n     }\n }\n \n@@ -192,7 +196,14 @@ fn check_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm],\n     }\n }\n \n-fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, ty: ty::Ty, els: Option<&Expr>) {\n+fn check_single_match_opt_like(\n+    cx: &LateContext,\n+    ex: &Expr,\n+    arms: &[Arm],\n+    expr: &Expr,\n+    ty: ty::Ty,\n+    els: Option<&Expr>\n+) {\n     // list of candidate Enums we know will never get any more members\n     let candidates = &[(&paths::COW, \"Borrowed\"),\n                        (&paths::COW, \"Cow::Borrowed\"),\n@@ -209,7 +220,7 @@ fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr:\n                 return;\n             }\n             path.to_string()\n-        }\n+        },\n         PatKind::Binding(BindByValue(MutImmutable), _, ident, None) => ident.node.to_string(),\n         PatKind::Path(ref path) => path.to_string(),\n         _ => return,\n@@ -272,16 +283,14 @@ fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n                                          snippet(cx, ex.span, \"b\"),\n                                          expr_block(cx, true_expr, None, \"..\"),\n                                          expr_block(cx, false_expr, None, \"..\")))\n-                        }\n+                        },\n                         (false, true) => {\n                             Some(format!(\"if {} {}\", snippet(cx, ex.span, \"b\"), expr_block(cx, true_expr, None, \"..\")))\n-                        }\n+                        },\n                         (true, false) => {\n                             let test = Sugg::hir(cx, ex, \"..\");\n-                            Some(format!(\"if {} {}\",\n-                                         !test,\n-                                         expr_block(cx, false_expr, None, \"..\")))\n-                        }\n+                            Some(format!(\"if {} {}\", !test, expr_block(cx, false_expr, None, \"..\")))\n+                        },\n                         (true, true) => None,\n                     };\n \n@@ -291,7 +300,7 @@ fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n                 }\n             }\n \n-       });\n+        });\n     }\n }\n \n@@ -333,8 +342,7 @@ fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], source: Match\n                 let ex = Sugg::hir(cx, ex, \"..\");\n                 let template = match_template(expr.span, source, ex.deref());\n                 db.span_suggestion(expr.span,\n-                                   \"instead of prefixing all patterns with `&`, you can \\\n-                                   dereference the expression\",\n+                                   \"instead of prefixing all patterns with `&`, you can dereference the expression\",\n                                    template);\n             });\n         }\n@@ -346,27 +354,28 @@ fn all_ranges(cx: &LateContext, arms: &[Arm]) -> Vec<SpannedRange<ConstVal>> {\n     arms.iter()\n         .flat_map(|arm| {\n             if let Arm { ref pats, guard: None, .. } = *arm {\n-                pats.iter()\n-            } else {\n-                [].iter()\n-            }.filter_map(|pat| {\n-                if_let_chain! {[\n+                    pats.iter()\n+                } else {\n+                    [].iter()\n+                }\n+                .filter_map(|pat| {\n+                    if_let_chain! {[\n                     let PatKind::Range(ref lhs, ref rhs) = pat.node,\n                     let Ok(lhs) = eval_const_expr_partial(cx.tcx, lhs, ExprTypeChecked, None),\n                     let Ok(rhs) = eval_const_expr_partial(cx.tcx, rhs, ExprTypeChecked, None)\n                 ], {\n                     return Some(SpannedRange { span: pat.span, node: (lhs, rhs) });\n                 }}\n \n-                if_let_chain! {[\n+                    if_let_chain! {[\n                     let PatKind::Lit(ref value) = pat.node,\n                     let Ok(value) = eval_const_expr_partial(cx.tcx, value, ExprTypeChecked, None)\n                 ], {\n                     return Some(SpannedRange { span: pat.span, node: (value.clone(), value) });\n                 }}\n \n-                None\n-            })\n+                    None\n+                })\n         })\n         .collect()\n }\n@@ -383,17 +392,17 @@ type TypedRanges = Vec<SpannedRange<ConstInt>>;\n /// `Uint` and `Int` probably don't make sense.\n fn type_ranges(ranges: &[SpannedRange<ConstVal>]) -> TypedRanges {\n     ranges.iter()\n-          .filter_map(|range| {\n-              if let (ConstVal::Integral(start), ConstVal::Integral(end)) = range.node {\n-                  Some(SpannedRange {\n-                      span: range.span,\n-                      node: (start, end),\n-                  })\n-              } else {\n-                  None\n-              }\n-          })\n-          .collect()\n+        .filter_map(|range| {\n+            if let (ConstVal::Integral(start), ConstVal::Integral(end)) = range.node {\n+                Some(SpannedRange {\n+                    span: range.span,\n+                    node: (start, end),\n+                })\n+            } else {\n+                None\n+            }\n+        })\n+        .collect()\n }\n \n fn is_unit_expr(expr: &Expr) -> bool {\n@@ -406,15 +415,15 @@ fn is_unit_expr(expr: &Expr) -> bool {\n \n fn has_only_ref_pats(arms: &[Arm]) -> bool {\n     let mapped = arms.iter()\n-                     .flat_map(|a| &a.pats)\n-                     .map(|p| {\n-                         match p.node {\n-                             PatKind::Ref(..) => Some(true),  // &-patterns\n-                             PatKind::Wild => Some(false),   // an \"anything\" wildcard is also fine\n-                             _ => None,                    // any other pattern is not fine\n-                         }\n-                     })\n-                     .collect::<Option<Vec<bool>>>();\n+        .flat_map(|a| &a.pats)\n+        .map(|p| {\n+            match p.node {\n+                PatKind::Ref(..) => Some(true),  // &-patterns\n+                PatKind::Wild => Some(false),   // an \"anything\" wildcard is also fine\n+                _ => None,                    // any other pattern is not fine\n+            }\n+        })\n+        .collect::<Option<Vec<bool>>>();\n     // look for Some(v) where there's at least one true element\n     mapped.map_or(false, |v| v.iter().any(|el| *el))\n }\n@@ -481,7 +490,7 @@ pub fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &\n                 if ra.node != rb.node {\n                     return Some((ra, rb));\n                 }\n-            }\n+            },\n             (&Kind::End(a, _), &Kind::Start(b, _)) if a != b => (),\n             _ => return Some((a.range(), b.range())),\n         }"}, {"sha": "591b395fe7099d247b68bd427ea8eeeca372f0fb", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 108, "deletions": 95, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -9,10 +9,10 @@ use rustc_const_eval::eval_const_expr_partial;\n use std::borrow::Cow;\n use std::fmt;\n use syntax::codemap::Span;\n-use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, match_path,\n-            match_trait_method, match_type, method_chain_args, return_ty, same_tys, snippet,\n-            span_lint, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth,\n-            last_path_segment, single_segment_path, match_def_path};\n+use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, match_path, match_trait_method,\n+            match_type, method_chain_args, return_ty, same_tys, snippet, span_lint, span_lint_and_then,\n+            span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, last_path_segment, single_segment_path,\n+            match_def_path};\n use utils::paths;\n use utils::sugg;\n \n@@ -616,15 +616,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                 lint_single_char_pattern(cx, expr, &args[pos]);\n                             }\n                         }\n-                    }\n+                    },\n                     _ => (),\n                 }\n-            }\n+            },\n             hir::ExprBinary(op, ref lhs, ref rhs) if op.node == hir::BiEq || op.node == hir::BiNe => {\n                 if !lint_chars_next(cx, expr, lhs, rhs, op.node == hir::BiEq) {\n                     lint_chars_next(cx, expr, rhs, lhs, op.node == hir::BiEq);\n                 }\n-            }\n+            },\n             _ => (),\n         }\n     }\n@@ -695,9 +695,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n /// Checks for the `OR_FUN_CALL` lint.\n fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir::Expr]) {\n     /// Check for `unwrap_or(T::new())` or `unwrap_or(T::default())`.\n-    fn check_unwrap_or_default(cx: &LateContext, name: &str, fun: &hir::Expr, self_expr: &hir::Expr, arg: &hir::Expr,\n-                               or_has_args: bool, span: Span)\n-                               -> bool {\n+    fn check_unwrap_or_default(\n+        cx: &LateContext,\n+        name: &str,\n+        fun: &hir::Expr,\n+        self_expr: &hir::Expr,\n+        arg: &hir::Expr,\n+        or_has_args: bool,\n+        span: Span\n+    ) -> bool {\n         if or_has_args {\n             return false;\n         }\n@@ -708,21 +714,23 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n \n                 if [\"default\", \"new\"].contains(&path) {\n                     let arg_ty = cx.tcx.tables().expr_ty(arg);\n-                    let default_trait_id = if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT) {\n+                    let default_trait_id = if let Some(default_trait_id) =\n+                        get_trait_def_id(cx, &paths::DEFAULT_TRAIT) {\n                         default_trait_id\n                     } else {\n                         return false;\n                     };\n \n                     if implements_trait(cx, arg_ty, default_trait_id, Vec::new()) {\n                         span_lint_and_then(cx,\n-                                  OR_FUN_CALL,\n-                                  span,\n-                                  &format!(\"use of `{}` followed by a call to `{}`\", name, path),\n-                                  |db| {\n-                                      db.span_suggestion(span, \"try this\",\n-                                                          format!(\"{}.unwrap_or_default()\", snippet(cx, self_expr.span, \"_\")));\n-                                  });\n+                                           OR_FUN_CALL,\n+                                           span,\n+                                           &format!(\"use of `{}` followed by a call to `{}`\", name, path),\n+                                           |db| {\n+                            db.span_suggestion(span,\n+                                               \"try this\",\n+                                               format!(\"{}.unwrap_or_default()\", snippet(cx, self_expr.span, \"_\")));\n+                        });\n                         return true;\n                     }\n                 }\n@@ -733,8 +741,15 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n     }\n \n     /// Check for `*or(foo())`.\n-    fn check_general_case(cx: &LateContext, name: &str, fun: &hir::Expr, self_expr: &hir::Expr, arg: &hir::Expr, or_has_args: bool,\n-                          span: Span) {\n+    fn check_general_case(\n+        cx: &LateContext,\n+        name: &str,\n+        fun: &hir::Expr,\n+        self_expr: &hir::Expr,\n+        arg: &hir::Expr,\n+        or_has_args: bool,\n+        span: Span\n+    ) {\n         // don't lint for constant values\n         // FIXME: can we `expect` here instead of match?\n         if let Some(qualif) = cx.tcx.const_qualif_map.borrow().get(&arg.id) {\n@@ -743,18 +758,16 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n             }\n         }\n         // (path, fn_has_argument, methods, suffix)\n-        let know_types: &[(&[_], _, &[_], _)] = &[(&paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n-                                                  (&paths::HASHMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n-                                                  (&paths::OPTION,\n-                                                   false,\n-                                                   &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"],\n-                                                   \"else\"),\n-                                                  (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\")];\n+        let know_types: &[(&[_], _, &[_], _)] =\n+            &[(&paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n+              (&paths::HASHMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n+              (&paths::OPTION, false, &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"], \"else\"),\n+              (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\")];\n \n         let self_ty = cx.tcx.tables().expr_ty(self_expr);\n \n         let (fn_has_arguments, poss, suffix) = if let Some(&(_, fn_has_arguments, poss, suffix)) =\n-                                                      know_types.iter().find(|&&i| match_type(cx, self_ty, i.0)) {\n+            know_types.iter().find(|&&i| match_type(cx, self_ty, i.0)) {\n             (fn_has_arguments, poss, suffix)\n         } else {\n             return;\n@@ -770,7 +783,11 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n             (false, true) => snippet(cx, fun.span, \"..\"),\n         };\n \n-        span_lint_and_then(cx, OR_FUN_CALL, span, &format!(\"use of `{}` followed by a function call\", name), |db| {\n+        span_lint_and_then(cx,\n+                           OR_FUN_CALL,\n+                           span,\n+                           &format!(\"use of `{}` followed by a function call\", name),\n+                           |db| {\n             db.span_suggestion(span,\n                                \"try this\",\n                                format!(\"{}.{}_{}({})\", snippet(cx, self_expr.span, \"_\"), name, suffix, sugg));\n@@ -800,7 +817,9 @@ fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_t\n                                \"using `clone` on a double-reference; \\\n                                 this will copy the reference instead of cloning the inner type\",\n                                |db| if let Some(snip) = sugg::Sugg::hir_opt(cx, arg) {\n-                                   db.span_suggestion(expr.span, \"try dereferencing it\", format!(\"({}).clone()\", snip.deref()));\n+                                   db.span_suggestion(expr.span,\n+                                                      \"try dereferencing it\",\n+                                                      format!(\"({}).clone()\", snip.deref()));\n                                });\n             return; // don't report clone_on_copy\n         }\n@@ -824,12 +843,14 @@ fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_t\n fn lint_vec_extend(cx: &LateContext, expr: &hir::Expr, args: &[hir::Expr]) {\n     let arg_ty = cx.tcx.tables().expr_ty(&args[1]);\n     if let Some(slice) = derefs_to_slice(cx, &args[1], arg_ty) {\n-        span_lint_and_then(cx, EXTEND_FROM_SLICE, expr.span, \"use of `extend` to extend a Vec by a slice\", |db| {\n+        span_lint_and_then(cx,\n+                           EXTEND_FROM_SLICE,\n+                           expr.span,\n+                           \"use of `extend` to extend a Vec by a slice\",\n+                           |db| {\n             db.span_suggestion(expr.span,\n                                \"try this\",\n-                               format!(\"{}.extend_from_slice({})\",\n-                                       snippet(cx, args[0].span, \"_\"),\n-                                       slice));\n+                               format!(\"{}.extend_from_slice({})\", snippet(cx, args[0].span, \"_\"), slice));\n         });\n     }\n }\n@@ -847,18 +868,14 @@ fn lint_string_extend(cx: &LateContext, expr: &hir::Expr, args: &[hir::Expr]) {\n             return;\n         };\n \n-        span_lint_and_then(\n-            cx,\n-            STRING_EXTEND_CHARS,\n-            expr.span,\n-            \"calling `.extend(_.chars())`\",\n-            |db| {\n-                db.span_suggestion(expr.span, \"try this\",\n-                        format!(\"{}.push_str({}{})\",\n-                                snippet(cx, args[0].span, \"_\"),\n-                                ref_str,\n-                                snippet(cx, target.span, \"_\")));\n-            });\n+        span_lint_and_then(cx, STRING_EXTEND_CHARS, expr.span, \"calling `.extend(_.chars())`\", |db| {\n+            db.span_suggestion(expr.span,\n+                               \"try this\",\n+                               format!(\"{}.push_str({}{})\",\n+                                       snippet(cx, args[0].span, \"_\"),\n+                                       ref_str,\n+                                       snippet(cx, target.span, \"_\")));\n+        });\n     }\n }\n \n@@ -888,28 +905,24 @@ fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwr\n     }}\n }\n \n-fn lint_iter_nth(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir::Expr], is_mut: bool){\n-    let mut_str = if is_mut { \"_mut\" } else {\"\"};\n+fn lint_iter_nth(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir::Expr], is_mut: bool) {\n+    let mut_str = if is_mut { \"_mut\" } else { \"\" };\n     let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.tcx.tables().expr_ty(&iter_args[0])).is_some() {\n         \"slice\"\n-    }\n-    else if match_type(cx, cx.tcx.tables().expr_ty(&iter_args[0]), &paths::VEC) {\n+    } else if match_type(cx, cx.tcx.tables().expr_ty(&iter_args[0]), &paths::VEC) {\n         \"Vec\"\n-    }\n-    else if match_type(cx, cx.tcx.tables().expr_ty(&iter_args[0]), &paths::VEC_DEQUE) {\n+    } else if match_type(cx, cx.tcx.tables().expr_ty(&iter_args[0]), &paths::VEC_DEQUE) {\n         \"VecDeque\"\n-    }\n-    else {\n+    } else {\n         return; // caller is not a type that we want to lint\n     };\n \n-    span_lint(\n-        cx,\n-        ITER_NTH,\n-        expr.span,\n-        &format!(\"called `.iter{0}().nth()` on a {1}. Calling `.get{0}()` is both faster and more readable\",\n-                 mut_str, caller_type)\n-    );\n+    span_lint(cx,\n+              ITER_NTH,\n+              expr.span,\n+              &format!(\"called `.iter{0}().nth()` on a {1}. Calling `.get{0}()` is both faster and more readable\",\n+                       mut_str,\n+                       caller_type));\n }\n \n fn lint_get_unwrap(cx: &LateContext, expr: &hir::Expr, get_args: &[hir::Expr], is_mut: bool) {\n@@ -932,32 +945,29 @@ fn lint_get_unwrap(cx: &LateContext, expr: &hir::Expr, get_args: &[hir::Expr], i\n \n     let mut_str = if is_mut { \"_mut\" } else { \"\" };\n     let borrow_str = if is_mut { \"&mut \" } else { \"&\" };\n-    span_lint_and_then(\n-        cx,\n-        GET_UNWRAP,\n-        expr.span,\n-        &format!(\"called `.get{0}().unwrap()` on a {1}. Using `[]` is more clear and more concise\",\n-                 mut_str, caller_type),\n-        |db| {\n-            db.span_suggestion(\n-                expr.span,\n-                \"try this\",\n-                format!(\"{}{}[{}]\", borrow_str, snippet(cx, get_args[0].span, \"_\"),\n-                        snippet(cx, get_args[1].span, \"_\"))\n-            );\n-        }\n-    );\n+    span_lint_and_then(cx,\n+                       GET_UNWRAP,\n+                       expr.span,\n+                       &format!(\"called `.get{0}().unwrap()` on a {1}. Using `[]` is more clear and more concise\",\n+                                mut_str,\n+                                caller_type),\n+                       |db| {\n+        db.span_suggestion(expr.span,\n+                           \"try this\",\n+                           format!(\"{}{}[{}]\",\n+                                   borrow_str,\n+                                   snippet(cx, get_args[0].span, \"_\"),\n+                                   snippet(cx, get_args[1].span, \"_\")));\n+    });\n }\n \n-fn lint_iter_skip_next(cx: &LateContext, expr: &hir::Expr){\n+fn lint_iter_skip_next(cx: &LateContext, expr: &hir::Expr) {\n     // lint if caller of skip is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-         span_lint(\n-            cx,\n-            ITER_SKIP_NEXT,\n-            expr.span,\n-            \"called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\"\n-        );\n+        span_lint(cx,\n+                  ITER_SKIP_NEXT,\n+                  expr.span,\n+                  \"called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\");\n     }\n }\n \n@@ -975,9 +985,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: ty::Ty) -> Option<sug\n \n     if let hir::ExprMethodCall(name, _, ref args) = expr.node {\n         if &*name.node.as_str() == \"iter\" && may_slice(cx, cx.tcx.tables().expr_ty(&args[0])) {\n-            sugg::Sugg::hir_opt(cx, &args[0]).map(|sugg| {\n-                sugg.addr()\n-            })\n+            sugg::Sugg::hir_opt(cx, &args[0]).map(|sugg| sugg.addr())\n         } else {\n             None\n         }\n@@ -991,7 +999,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: ty::Ty) -> Option<sug\n                 } else {\n                     None\n                 }\n-            }\n+            },\n             _ => None,\n         }\n     }\n@@ -1099,8 +1107,8 @@ fn lint_map_unwrap_or_else(cx: &LateContext, expr: &hir::Expr, map_args: &[hir::\n fn lint_filter_next(cx: &LateContext, expr: &hir::Expr, filter_args: &[hir::Expr]) {\n     // lint if caller of `.filter().next()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        let msg = \"called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` \\\n-                   instead.\";\n+        let msg = \"called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n+                   `.find(p)` instead.\";\n         let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n         if filter_snippet.lines().count() <= 1 {\n             // add note if not multi-line\n@@ -1159,12 +1167,17 @@ fn lint_filter_map_flat_map(cx: &LateContext, expr: &hir::Expr, _filter_args: &[\n }\n \n /// lint searching an Iterator followed by `is_some()`\n-fn lint_search_is_some(cx: &LateContext, expr: &hir::Expr, search_method: &str, search_args: &[hir::Expr],\n-                       is_some_args: &[hir::Expr]) {\n+fn lint_search_is_some(\n+    cx: &LateContext,\n+    expr: &hir::Expr,\n+    search_method: &str,\n+    search_args: &[hir::Expr],\n+    is_some_args: &[hir::Expr]\n+) {\n     // lint if caller of search is an Iterator\n     if match_trait_method(cx, &is_some_args[0], &paths::ITERATOR) {\n-        let msg = format!(\"called `is_some()` after searching an `Iterator` with {}. This is more succinctly expressed \\\n-                           by calling `any()`.\",\n+        let msg = format!(\"called `is_some()` after searching an `Iterator` with {}. This is more succinctly \\\n+                           expressed by calling `any()`.\",\n                           search_method);\n         let search_snippet = snippet(cx, search_args[1].span, \"..\");\n         if search_snippet.lines().count() <= 1 {\n@@ -1227,8 +1240,8 @@ fn lint_single_char_pattern(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr)\n                                arg.span,\n                                \"single-character string constant used as pattern\",\n                                |db| {\n-                                   db.span_suggestion(expr.span, \"try using a char instead:\", hint);\n-                               });\n+                db.span_suggestion(expr.span, \"try using a char instead:\", hint);\n+            });\n         }\n     }\n }"}, {"sha": "d4198c97d13f895037aac0835a38134f034d36da", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MinMaxPass {\n                     (MinMax::Min, Some(Ordering::Greater)) => (),\n                     _ => {\n                         span_lint(cx, MIN_MAX, expr.span, \"this min/max combination leads to constant result\");\n-                    }\n+                    },\n                 }\n             }\n         }"}, {"sha": "409a7de86f06d4e57ae19521587d47437f1b73d2", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 40, "deletions": 37, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -8,10 +8,8 @@ use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::eval_const_expr_partial;\n use rustc_const_math::ConstFloat;\n use syntax::codemap::{Span, Spanned, ExpnFormat};\n-use utils::{\n-    get_item_name, get_parent_expr, implements_trait, in_macro, is_integer_literal, match_path,\n-    snippet, span_lint, span_lint_and_then, walk_ptrs_ty, last_path_segment\n-};\n+use utils::{get_item_name, get_parent_expr, implements_trait, in_macro, is_integer_literal, match_path, snippet,\n+            span_lint, span_lint_and_then, walk_ptrs_ty, last_path_segment};\n use utils::sugg::Sugg;\n \n /// **What it does:** Checks for function arguments and let bindings denoted as `ref`.\n@@ -161,13 +159,26 @@ pub struct Pass;\n \n impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(TOPLEVEL_REF_ARG, CMP_NAN, FLOAT_CMP, CMP_OWNED, MODULO_ONE, REDUNDANT_PATTERN,\n+        lint_array!(TOPLEVEL_REF_ARG,\n+                    CMP_NAN,\n+                    FLOAT_CMP,\n+                    CMP_OWNED,\n+                    MODULO_ONE,\n+                    REDUNDANT_PATTERN,\n                     USED_UNDERSCORE_BINDING)\n     }\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n-    fn check_fn(&mut self, cx: &LateContext<'a, 'tcx>, k: FnKind<'tcx>, decl: &'tcx FnDecl, _: &'tcx Expr, _: Span, _: NodeId) {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        k: FnKind<'tcx>,\n+        decl: &'tcx FnDecl,\n+        _: &'tcx Expr,\n+        _: Span,\n+        _: NodeId\n+    ) {\n         if let FnKind::Closure(_) = k {\n             // Does not apply to closures\n             return;\n@@ -236,23 +247,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 if let Some(name) = get_item_name(cx, expr) {\n                     let name = &*name.as_str();\n                     if name == \"eq\" || name == \"ne\" || name == \"is_nan\" || name.starts_with(\"eq_\") ||\n-                        name.ends_with(\"_eq\") {\n+                       name.ends_with(\"_eq\") {\n                         return;\n                     }\n                 }\n-                span_lint_and_then(cx,\n-                                   FLOAT_CMP,\n-                                   expr.span,\n-                                   \"strict comparison of f32 or f64\",\n-                                   |db| {\n-                                       let lhs = Sugg::hir(cx, left, \"..\");\n-                                       let rhs = Sugg::hir(cx, right, \"..\");\n+                span_lint_and_then(cx, FLOAT_CMP, expr.span, \"strict comparison of f32 or f64\", |db| {\n+                    let lhs = Sugg::hir(cx, left, \"..\");\n+                    let rhs = Sugg::hir(cx, right, \"..\");\n \n-                                       db.span_suggestion(expr.span,\n-                                                          \"consider comparing them within some error\",\n-                                                          format!(\"({}).abs() < error\", lhs - rhs));\n-                                       db.span_note(expr.span, \"std::f32::EPSILON and std::f64::EPSILON are available.\");\n-                                   });\n+                    db.span_suggestion(expr.span,\n+                                       \"consider comparing them within some error\",\n+                                       format!(\"({}).abs() < error\", lhs - rhs));\n+                    db.span_note(expr.span, \"std::f32::EPSILON and std::f64::EPSILON are available.\");\n+                });\n             } else if op == BiRem && is_integer_literal(right, 1) {\n                 span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n             }\n@@ -274,23 +281,24 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 } else {\n                     None\n                 }\n-            }\n+            },\n             ExprField(_, spanned) => {\n                 let name = spanned.node.as_str();\n                 if name.starts_with('_') && !name.starts_with(\"__\") {\n                     Some(name)\n                 } else {\n                     None\n                 }\n-            }\n+            },\n             _ => None,\n         };\n         if let Some(binding) = binding {\n             span_lint(cx,\n                       USED_UNDERSCORE_BINDING,\n                       expr.span,\n                       &format!(\"used binding `{}` which is prefixed with an underscore. A leading \\\n-                                underscore signals that a binding will not be used.\", binding));\n+                                underscore signals that a binding will not be used.\",\n+                               binding));\n         }\n     }\n \n@@ -300,9 +308,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 span_lint(cx,\n                           REDUNDANT_PATTERN,\n                           pat.span,\n-                          &format!(\"the `{} @ _` pattern can be written as just `{}`\",\n-                                   ident.node,\n-                                   ident.node));\n+                          &format!(\"the `{} @ _` pattern can be written as just `{}`\", ident.node, ident.node));\n             }\n         }\n     }\n@@ -339,9 +345,8 @@ fn is_allowed(cx: &LateContext, expr: &Expr) -> bool {\n             f64: ::std::f64::NEG_INFINITY,\n         };\n \n-        val.try_cmp(zero) == Ok(Ordering::Equal)\n-            || val.try_cmp(infinity) == Ok(Ordering::Equal)\n-            || val.try_cmp(neg_infinity) == Ok(Ordering::Equal)\n+        val.try_cmp(zero) == Ok(Ordering::Equal) || val.try_cmp(infinity) == Ok(Ordering::Equal) ||\n+        val.try_cmp(neg_infinity) == Ok(Ordering::Equal)\n     } else {\n         false\n     }\n@@ -360,7 +365,7 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr, left: bool, op: S\n             } else {\n                 return;\n             }\n-        }\n+        },\n         ExprCall(ref path, ref v) if v.len() == 1 => {\n             if let ExprPath(ref path) = path.node {\n                 if match_path(path, &[\"String\", \"from_str\"]) || match_path(path, &[\"String\", \"from\"]) {\n@@ -371,7 +376,7 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr, left: bool, op: S\n             } else {\n                 return;\n             }\n-        }\n+        },\n         _ => return,\n     };\n \n@@ -408,8 +413,7 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr, left: bool, op: S\n }\n \n fn is_str_arg(cx: &LateContext, args: &[Expr]) -> bool {\n-    args.len() == 1 &&\n-        matches!(walk_ptrs_ty(cx.tcx.tables().expr_ty(&args[0])).sty, ty::TyStr)\n+    args.len() == 1 && matches!(walk_ptrs_ty(cx.tcx.tables().expr_ty(&args[0])).sty, ty::TyStr)\n }\n \n /// Heuristic to see if an expression is used. Should be compatible with `unused_variables`'s idea\n@@ -430,22 +434,21 @@ fn is_used(cx: &LateContext, expr: &Expr) -> bool {\n /// `#[derive(...)`] or the like).\n fn in_attributes_expansion(cx: &LateContext, expr: &Expr) -> bool {\n     cx.sess().codemap().with_expn_info(expr.span.expn_id, |info_opt| {\n-        info_opt.map_or(false, |info| {\n-            matches!(info.callee.format, ExpnFormat::MacroAttribute(_))\n-        })\n+        info_opt.map_or(false, |info| matches!(info.callee.format, ExpnFormat::MacroAttribute(_)))\n     })\n }\n \n /// Test whether `def` is a variable defined outside a macro.\n fn non_macro_local(cx: &LateContext, def: &def::Def) -> bool {\n     match *def {\n-        def::Def::Local(id) | def::Def::Upvar(id, _, _) => {\n+        def::Def::Local(id) |\n+        def::Def::Upvar(id, _, _) => {\n             if let Some(span) = cx.tcx.map.span_if_local(id) {\n                 !in_macro(cx, span)\n             } else {\n                 true\n             }\n-        }\n+        },\n         _ => false,\n     }\n }"}, {"sha": "e6f044ae9b6ad5d474f3534c50fd574ae50a0c2b", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -168,9 +168,14 @@ pub struct MiscEarly;\n \n impl LintPass for MiscEarly {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(UNNEEDED_FIELD_PATTERN, DUPLICATE_UNDERSCORE_ARGUMENT, REDUNDANT_CLOSURE_CALL,\n-                    DOUBLE_NEG, MIXED_CASE_HEX_LITERALS, UNSEPARATED_LITERAL_SUFFIX,\n-                    ZERO_PREFIXED_LITERAL, BUILTIN_TYPE_SHADOW)\n+        lint_array!(UNNEEDED_FIELD_PATTERN,\n+                    DUPLICATE_UNDERSCORE_ARGUMENT,\n+                    REDUNDANT_CLOSURE_CALL,\n+                    DOUBLE_NEG,\n+                    MIXED_CASE_HEX_LITERALS,\n+                    UNSEPARATED_LITERAL_SUFFIX,\n+                    ZERO_PREFIXED_LITERAL,\n+                    BUILTIN_TYPE_SHADOW)\n     }\n }\n \n@@ -272,22 +277,22 @@ impl EarlyLintPass for MiscEarly {\n                                            expr.span,\n                                            \"Try not to call a closure in the expression where it is declared.\",\n                                            |db| {\n-                                               if decl.inputs.is_empty() {\n-                                                   let hint = snippet(cx, block.span, \"..\").into_owned();\n-                                                   db.span_suggestion(expr.span, \"Try doing something like: \", hint);\n-                                               }\n-                                           });\n+                            if decl.inputs.is_empty() {\n+                                let hint = snippet(cx, block.span, \"..\").into_owned();\n+                                db.span_suggestion(expr.span, \"Try doing something like: \", hint);\n+                            }\n+                        });\n                     }\n                 }\n-            }\n+            },\n             ExprKind::Unary(UnOp::Neg, ref inner) => {\n                 if let ExprKind::Unary(UnOp::Neg, _) = inner.node {\n                     span_lint(cx,\n                               DOUBLE_NEG,\n                               expr.span,\n                               \"`--x` could be misinterpreted as pre-decrement by C programmers, is usually a no-op\");\n                 }\n-            }\n+            },\n             ExprKind::Lit(ref lit) => {\n                 if_let_chain! {[\n                     let LitKind::Int(value, ..) = lit.node,\n@@ -328,8 +333,16 @@ impl EarlyLintPass for MiscEarly {\n                                            lit.span,\n                                            \"this is a decimal constant\",\n                                            |db| {\n-                            db.span_suggestion(lit.span, \"if you mean to use a decimal constant, remove the `0` to remove confusion:\", src[1..].to_string());\n-                            db.span_suggestion(lit.span, \"if you mean to use an octal constant, use `0o`:\", format!(\"0o{}\", &src[1..]));\n+                            db.span_suggestion(\n+                                lit.span,\n+                                \"if you mean to use a decimal constant, remove the `0` to remove confusion:\",\n+                                src[1..].to_string(),\n+                            );\n+                            db.span_suggestion(\n+                                lit.span,\n+                                \"if you mean to use an octal constant, use `0o`:\",\n+                                format!(\"0o{}\", &src[1..]),\n+                            );\n                         });\n                     }\n                 }}\n@@ -351,8 +364,8 @@ impl EarlyLintPass for MiscEarly {\n                         prev = ch;\n                     }\n                 }}\n-            }\n-            _ => ()\n+            },\n+            _ => (),\n         }\n     }\n \n@@ -369,7 +382,12 @@ impl EarlyLintPass for MiscEarly {\n                 let ExprKind::Path(_, ref path) = closure.node\n             ], {\n                 if sp_ident.node == (&path.segments[0]).identifier {\n-                    span_lint(cx, REDUNDANT_CLOSURE_CALL, second.span, \"Closure called just once immediately after it was declared\");\n+                    span_lint(\n+                        cx,\n+                        REDUNDANT_CLOSURE_CALL,\n+                        second.span,\n+                        \"Closure called just once immediately after it was declared\",\n+                    );\n                 }\n             }}\n         }"}, {"sha": "70696ea3908beb1dae77522446eaeeb8d03aa558", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -1,21 +1,24 @@\n-/* This file incorporates work covered by the following copyright and\n- * permission notice:\n- *   Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n- *   file at the top-level directory of this distribution and at\n- *   http://rust-lang.org/COPYRIGHT.\n- *\n- *   Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n- *   http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n- *   <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n- *   option. This file may not be copied, modified, or distributed\n- *   except according to those terms.\n- */\n-\n-/* Note: More specifically this lint is largely inspired (aka copied) from *rustc*'s\n- * [`missing_doc`].\n- *\n- * [`missing_doc`]: https://github.com/rust-lang/rust/blob/d6d05904697d89099b55da3331155392f1db9c00/src/librustc_lint/builtin.rs#L246\n- */\n+// This file incorporates work covered by the following copyright and\n+// permission notice:\n+//   Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+//   file at the top-level directory of this distribution and at\n+//   http://rust-lang.org/COPYRIGHT.\n+//\n+//   Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+//   http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+//   <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+//   option. This file may not be copied, modified, or distributed\n+//   except according to those terms.\n+//\n+\n+// Note: More specifically this lint is largely inspired (aka copied) from *rustc*'s\n+// [`missing_doc`].\n+//\n+// [`missing_doc`]:\n+// https://github.\n+// com/rust-lang/rust/blob/d6d05904697d89099b55da3331155392f1db9c00/src/librustc_lint/builtin.\n+// rs#L246\n+//\n \n use rustc::hir;\n use rustc::lint::*;\n@@ -51,20 +54,14 @@ impl ::std::default::Default for MissingDoc {\n \n impl MissingDoc {\n     pub fn new() -> MissingDoc {\n-        MissingDoc {\n-            doc_hidden_stack: vec![false],\n-        }\n+        MissingDoc { doc_hidden_stack: vec![false] }\n     }\n \n     fn doc_hidden(&self) -> bool {\n         *self.doc_hidden_stack.last().expect(\"empty doc_hidden_stack\")\n     }\n \n-    fn check_missing_docs_attrs(&self,\n-                               cx: &LateContext,\n-                               attrs: &[ast::Attribute],\n-                               sp: Span,\n-                               desc: &'static str) {\n+    fn check_missing_docs_attrs(&self, cx: &LateContext, attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n         // If we're building a test harness, then warning about\n         // documentation is probably not really relevant right now.\n         if cx.sess().opts.test {\n@@ -82,7 +79,8 @@ impl MissingDoc {\n \n         let has_doc = attrs.iter().any(|a| a.is_value_str() && a.name() == \"doc\");\n         if !has_doc {\n-            cx.span_lint(MISSING_DOCS_IN_PRIVATE_ITEMS, sp,\n+            cx.span_lint(MISSING_DOCS_IN_PRIVATE_ITEMS,\n+                         sp,\n                          &format!(\"missing documentation for {}\", desc));\n         }\n     }\n@@ -96,8 +94,10 @@ impl LintPass for MissingDoc {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n     fn enter_lint_attrs(&mut self, _: &LateContext<'a, 'tcx>, attrs: &'tcx [ast::Attribute]) {\n-        let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n-            attr.check_name(\"doc\") && match attr.meta_item_list() {\n+        let doc_hidden = self.doc_hidden() ||\n+                         attrs.iter().any(|attr| {\n+            attr.check_name(\"doc\") &&\n+            match attr.meta_item_list() {\n                 None => false,\n                 Some(l) => attr::list_contains_name(&l[..], \"hidden\"),\n             }\n@@ -151,9 +151,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             ty::TraitContainer(_) => return,\n             ty::ImplContainer(cid) => {\n                 if cx.tcx.impl_trait_ref(cid).is_some() {\n-                    return\n+                    return;\n                 }\n-            }\n+            },\n         }\n \n         let desc = match impl_item.node {"}, {"sha": "7d4326828cb1ef98a122397f8a51169516ad328a", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -64,7 +64,10 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n             intravisit::walk_expr(self, body);\n         } else if let hir::ExprAddrOf(hir::MutMutable, ref e) = expr.node {\n             if let hir::ExprAddrOf(hir::MutMutable, _) = e.node {\n-                span_lint(self.cx, MUT_MUT, expr.span, \"generally you want to avoid `&mut &mut _` if possible\");\n+                span_lint(self.cx,\n+                          MUT_MUT,\n+                          expr.span,\n+                          \"generally you want to avoid `&mut &mut _` if possible\");\n             } else if let TyRef(_, TypeAndMut { mutbl: hir::MutMutable, .. }) = self.cx.tcx.tables().expr_ty(e).sty {\n                 span_lint(self.cx,\n                           MUT_MUT,\n@@ -77,7 +80,10 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         if let hir::TyRptr(_, hir::MutTy { ty: ref pty, mutbl: hir::MutMutable }) = ty.node {\n             if let hir::TyRptr(_, hir::MutTy { mutbl: hir::MutMutable, .. }) = pty.node {\n-                span_lint(self.cx, MUT_MUT, ty.span, \"generally you want to avoid `&mut &mut _` if possible\");\n+                span_lint(self.cx,\n+                          MUT_MUT,\n+                          ty.span,\n+                          \"generally you want to avoid `&mut &mut _` if possible\");\n             }\n \n         }"}, {"sha": "7e7733bed80cf99a14ef3fc61261d35a1b9faea9", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -38,19 +38,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n         match e.node {\n             ExprCall(ref fn_expr, ref arguments) => {\n                 let function_type = borrowed_table.node_types\n-                                                  .get(&fn_expr.id)\n-                                                  .expect(\"A function with an unknown type is called. \\\n-                                                           If this happened, the compiler would have \\\n-                                                           aborted the compilation long ago\");\n+                    .get(&fn_expr.id)\n+                    .expect(\"A function with an unknown type is called. If this happened, the compiler would have \\\n+                             aborted the compilation long ago\");\n                 if let ExprPath(ref path) = fn_expr.node {\n                     check_arguments(cx, arguments, function_type, &path.to_string());\n                 }\n-            }\n+            },\n             ExprMethodCall(ref name, _, ref arguments) => {\n                 let method_call = MethodCall::expr(e.id);\n                 let method_type = borrowed_table.method_map.get(&method_call).expect(\"This should never happen.\");\n                 check_arguments(cx, arguments, method_type.ty, &name.node.as_str())\n-            }\n+            },\n             _ => (),\n         }\n     }\n@@ -71,11 +70,11 @@ fn check_arguments(cx: &LateContext, arguments: &[Expr], type_definition: &TyS,\n                                       argument.span,\n                                       &format!(\"The function/method \\\"{}\\\" doesn't need a mutable reference\", name));\n                         }\n-                    }\n+                    },\n                     _ => (),\n                 }\n             }\n-        }\n+        },\n         _ => (),\n     }\n }"}, {"sha": "5eae3034aff31e9e1f9368cc8c73b861f0340043", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -62,11 +62,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n         if let ExprIf(ref pred, ref then_block, Some(ref else_expr)) = e.node {\n             let reduce = |ret, not| {\n                 let snip = Sugg::hir(cx, pred, \"<predicate>\");\n-                let snip = if not {\n-                    !snip\n-                } else {\n-                    snip\n-                };\n+                let snip = if not { !snip } else { snip };\n \n                 let hint = if ret {\n                     format!(\"return {}\", snip)\n@@ -79,8 +75,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n                                    e.span,\n                                    \"this if-then-else expression returns a bool literal\",\n                                    |db| {\n-                                       db.span_suggestion(e.span, \"you can reduce it to\", hint);\n-                                   });\n+                    db.span_suggestion(e.span, \"you can reduce it to\", hint);\n+                });\n             };\n             match (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n                 (RetBool(true), RetBool(true)) |\n@@ -89,14 +85,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n                               NEEDLESS_BOOL,\n                               e.span,\n                               \"this if-then-else expression will always return true\");\n-                }\n+                },\n                 (RetBool(false), RetBool(false)) |\n                 (Bool(false), Bool(false)) => {\n                     span_lint(cx,\n                               NEEDLESS_BOOL,\n                               e.span,\n                               \"this if-then-else expression will always return false\");\n-                }\n+                },\n                 (RetBool(true), RetBool(false)) => reduce(true, false),\n                 (Bool(true), Bool(false)) => reduce(false, false),\n                 (RetBool(false), RetBool(true)) => reduce(true, true),\n@@ -128,39 +124,39 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoolComparison {\n                                        e.span,\n                                        \"equality checks against true are unnecessary\",\n                                        |db| {\n-                                           db.span_suggestion(e.span, \"try simplifying it as shown:\", hint);\n-                                       });\n-                }\n+                        db.span_suggestion(e.span, \"try simplifying it as shown:\", hint);\n+                    });\n+                },\n                 (Other, Bool(true)) => {\n                     let hint = snippet(cx, left_side.span, \"..\").into_owned();\n                     span_lint_and_then(cx,\n                                        BOOL_COMPARISON,\n                                        e.span,\n                                        \"equality checks against true are unnecessary\",\n                                        |db| {\n-                                           db.span_suggestion(e.span, \"try simplifying it as shown:\", hint);\n-                                       });\n-                }\n+                        db.span_suggestion(e.span, \"try simplifying it as shown:\", hint);\n+                    });\n+                },\n                 (Bool(false), Other) => {\n                     let hint = Sugg::hir(cx, right_side, \"..\");\n                     span_lint_and_then(cx,\n                                        BOOL_COMPARISON,\n                                        e.span,\n                                        \"equality checks against false can be replaced by a negation\",\n                                        |db| {\n-                                           db.span_suggestion(e.span, \"try simplifying it as shown:\", (!hint).to_string());\n-                                       });\n-                }\n+                        db.span_suggestion(e.span, \"try simplifying it as shown:\", (!hint).to_string());\n+                    });\n+                },\n                 (Other, Bool(false)) => {\n                     let hint = Sugg::hir(cx, left_side, \"..\");\n                     span_lint_and_then(cx,\n                                        BOOL_COMPARISON,\n                                        e.span,\n                                        \"equality checks against false can be replaced by a negation\",\n                                        |db| {\n-                                           db.span_suggestion(e.span, \"try simplifying it as shown:\", (!hint).to_string());\n-                                       });\n-                }\n+                        db.span_suggestion(e.span, \"try simplifying it as shown:\", (!hint).to_string());\n+                    });\n+                },\n                 _ => (),\n             }\n         }\n@@ -186,7 +182,7 @@ fn fetch_bool_block(block: &Block) -> Expression {\n             } else {\n                 Expression::Other\n             }\n-        }\n+        },\n         _ => Expression::Other,\n     }\n }\n@@ -200,13 +196,13 @@ fn fetch_bool_expr(expr: &Expr) -> Expression {\n             } else {\n                 Expression::Other\n             }\n-        }\n+        },\n         ExprRet(Some(ref expr)) => {\n             match fetch_bool_expr(expr) {\n                 Expression::Bool(value) => Expression::RetBool(value),\n                 _ => Expression::Other,\n             }\n-        }\n+        },\n         _ => Expression::Other,\n     }\n }"}, {"sha": "f05fdaab1764e20ca9b20a19883d51174f01689d", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -41,7 +41,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n         }\n         if let ExprAddrOf(MutImmutable, ref inner) = e.node {\n             if let ty::TyRef(..) = cx.tcx.tables().expr_ty(inner).sty {\n-                if let Some(&ty::adjustment::Adjust::DerefRef { autoderefs, autoref, .. }) = cx.tcx.tables.borrow().adjustments.get(&e.id).map(|a| &a.kind) {\n+                if let Some(&ty::adjustment::Adjust::DerefRef { autoderefs, autoref, .. }) =\n+                    cx.tcx.tables.borrow().adjustments.get(&e.id).map(|a| &a.kind) {\n                     if autoderefs > 1 && autoref.is_some() {\n                         span_lint(cx,\n                                   NEEDLESS_BORROW,\n@@ -61,10 +62,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n             if let ty::TyRef(_, ref tam) = cx.tcx.tables().pat_ty(pat).sty {\n                 if tam.mutbl == MutImmutable {\n                     if let ty::TyRef(..) = tam.ty.sty {\n-                        span_lint(cx,\n-                                  NEEDLESS_BORROW,\n-                                  pat.span,\n-                                  \"this pattern creates a reference to a reference\")\n+                        span_lint(cx, NEEDLESS_BORROW, pat.span, \"this pattern creates a reference to a reference\")\n                     }\n                 }\n             }"}, {"sha": "9c7b132dd3d6d0b72e9453cbe66c442ffe479c76", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -97,7 +97,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n         decl: &'tcx hir::FnDecl,\n         _: &'tcx hir::Expr,\n         span: Span,\n-        id: ast::NodeId,\n+        id: ast::NodeId\n     ) {\n         if in_external_macro(cx, span) {\n             return;\n@@ -161,7 +161,7 @@ fn can_derive_default<'t, 'c>(ty: ty::Ty<'t>, cx: &LateContext<'c, 't>, default_\n                 }\n             }\n             true\n-        }\n+        },\n         _ => false,\n     }\n }"}, {"sha": "a87c9d0f7365d7642f2d1ac884345d6092d7bfff", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -66,7 +66,7 @@ fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n                 Some(ref base) => has_no_effect(cx, base),\n                 None => true,\n             }\n-        }\n+        },\n         Expr_::ExprCall(ref callee, ref args) => {\n             if let Expr_::ExprPath(ref qpath) = callee.node {\n                 let def = cx.tcx.tables().qpath_def(qpath, callee.id);\n@@ -80,15 +80,15 @@ fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n             } else {\n                 false\n             }\n-        }\n+        },\n         Expr_::ExprBlock(ref block) => {\n             block.stmts.is_empty() &&\n             if let Some(ref expr) = block.expr {\n                 has_no_effect(cx, expr)\n             } else {\n                 false\n             }\n-        }\n+        },\n         _ => false,\n     }\n }\n@@ -148,7 +148,7 @@ fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Exp\n         Expr_::ExprBox(ref inner) => reduce_expression(cx, inner).or_else(|| Some(vec![inner])),\n         Expr_::ExprStruct(_, ref fields, ref base) => {\n             Some(fields.iter().map(|f| &f.expr).chain(base).map(Deref::deref).collect())\n-        }\n+        },\n         Expr_::ExprCall(ref callee, ref args) => {\n             if let Expr_::ExprPath(ref qpath) = callee.node {\n                 let def = cx.tcx.tables().qpath_def(qpath, callee.id);\n@@ -162,7 +162,7 @@ fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Exp\n             } else {\n                 None\n             }\n-        }\n+        },\n         Expr_::ExprBlock(ref block) => {\n             if block.stmts.is_empty() {\n                 block.expr.as_ref().and_then(|e| {\n@@ -176,7 +176,7 @@ fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Exp\n             } else {\n                 None\n             }\n-        }\n+        },\n         _ => None,\n     }\n }"}, {"sha": "a195673a53bcf4a6411c7aa107db588670b879c3", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -88,7 +88,7 @@ impl<'a, 'tcx: 'a, 'b> Visitor<'tcx> for SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n                         self.visit_pat(&field.node.pat);\n                     }\n                 }\n-            }\n+            },\n             _ => walk_pat(self, pat),\n         }\n     }\n@@ -210,8 +210,8 @@ impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n                     diag.span_help(span,\n                                    &format!(\"separate the discriminating character by an \\\n                                                                 underscore like: `{}_{}`\",\n-                                                               &interned_name[..split],\n-                                                               &interned_name[split..]));\n+                                            &interned_name[..split],\n+                                            &interned_name[split..]));\n                 }\n             });\n             return;\n@@ -241,15 +241,17 @@ impl<'a, 'tcx> Visitor<'tcx> for SimilarNamesLocalVisitor<'a, 'tcx> {\n         if let Some(ref init) = local.init {\n             self.apply(|this| walk_expr(this, &**init));\n         }\n-        // add the pattern after the expression because the bindings aren't available yet in the init expression\n+        // add the pattern after the expression because the bindings aren't available yet in the init\n+        // expression\n         SimilarNamesNameVisitor(self).visit_pat(&*local.pat);\n     }\n     fn visit_block(&mut self, blk: &'tcx Block) {\n         self.apply(|this| walk_block(this, blk));\n     }\n     fn visit_arm(&mut self, arm: &'tcx Arm) {\n         self.apply(|this| {\n-            // just go through the first pattern, as either all patterns bind the same bindings or rustc would have errored much earlier\n+            // just go through the first pattern, as either all patterns\n+            // bind the same bindings or rustc would have errored much earlier\n             SimilarNamesNameVisitor(this).visit_pat(&arm.pats[0]);\n             this.apply(|this| walk_expr(this, &arm.body));\n         });"}, {"sha": "65b13688ff626f5ba45fed653f004a1c772e8ebe", "filename": "clippy_lints/src/ok_if_let.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fok_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fok_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fok_if_let.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -15,7 +15,7 @@ use utils::{paths, method_chain_args, span_help_and_lint, match_type, snippet};\n ///         vec.push(bench)\n ///     }\n /// }\n-///```\n+/// ```\n /// Could be written:\n ///\n /// ```rust"}, {"sha": "4216345e48e7570e85c4d74dd1e60053c58b8743", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -71,36 +71,32 @@ fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOp\n             let argument_option = match arguments[1].node {\n                 ExprLit(ref span) => {\n                     if let Spanned { node: LitKind::Bool(lit), .. } = **span {\n-                        if lit {\n-                            Argument::True\n-                        } else {\n-                            Argument::False\n-                        }\n+                        if lit { Argument::True } else { Argument::False }\n                     } else {\n                         return; // The function is called with a literal\n                                 // which is not a boolean literal. This is theoretically\n                                 // possible, but not very likely.\n                     }\n-                }\n+                },\n                 _ => Argument::Unknown,\n             };\n \n             match &*name.node.as_str() {\n                 \"create\" => {\n                     options.push((OpenOption::Create, argument_option));\n-                }\n+                },\n                 \"append\" => {\n                     options.push((OpenOption::Append, argument_option));\n-                }\n+                },\n                 \"truncate\" => {\n                     options.push((OpenOption::Truncate, argument_option));\n-                }\n+                },\n                 \"read\" => {\n                     options.push((OpenOption::Read, argument_option));\n-                }\n+                },\n                 \"write\" => {\n                     options.push((OpenOption::Write, argument_option));\n-                }\n+                },\n                 _ => (),\n             }\n \n@@ -111,11 +107,8 @@ fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOp\n \n fn check_open_options(cx: &LateContext, options: &[(OpenOption, Argument)], span: Span) {\n     let (mut create, mut append, mut truncate, mut read, mut write) = (false, false, false, false, false);\n-    let (mut create_arg, mut append_arg, mut truncate_arg, mut read_arg, mut write_arg) = (false,\n-                                                                                           false,\n-                                                                                           false,\n-                                                                                           false,\n-                                                                                           false);\n+    let (mut create_arg, mut append_arg, mut truncate_arg, mut read_arg, mut write_arg) =\n+        (false, false, false, false, false);\n     // This code is almost duplicated (oh, the irony), but I haven't found a way to unify it.\n \n     for option in options {\n@@ -130,7 +123,7 @@ fn check_open_options(cx: &LateContext, options: &[(OpenOption, Argument)], span\n                     create = true\n                 }\n                 create_arg = create_arg || (arg == Argument::True);;\n-            }\n+            },\n             (OpenOption::Append, arg) => {\n                 if append {\n                     span_lint(cx,\n@@ -141,7 +134,7 @@ fn check_open_options(cx: &LateContext, options: &[(OpenOption, Argument)], span\n                     append = true\n                 }\n                 append_arg = append_arg || (arg == Argument::True);;\n-            }\n+            },\n             (OpenOption::Truncate, arg) => {\n                 if truncate {\n                     span_lint(cx,\n@@ -152,7 +145,7 @@ fn check_open_options(cx: &LateContext, options: &[(OpenOption, Argument)], span\n                     truncate = true\n                 }\n                 truncate_arg = truncate_arg || (arg == Argument::True);\n-            }\n+            },\n             (OpenOption::Read, arg) => {\n                 if read {\n                     span_lint(cx,\n@@ -163,7 +156,7 @@ fn check_open_options(cx: &LateContext, options: &[(OpenOption, Argument)], span\n                     read = true\n                 }\n                 read_arg = read_arg || (arg == Argument::True);;\n-            }\n+            },\n             (OpenOption::Write, arg) => {\n                 if write {\n                     span_lint(cx,\n@@ -174,7 +167,7 @@ fn check_open_options(cx: &LateContext, options: &[(OpenOption, Argument)], span\n                     write = true\n                 }\n                 write_arg = write_arg || (arg == Argument::True);;\n-            }\n+            },\n         }\n     }\n "}, {"sha": "f2e478865497e4211ad0546b31122549e184108b", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -44,12 +44,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OverflowCheckConditional {\n         ], {\n             if let BinOp_::BiLt = op.node {\n                 if let BinOp_::BiAdd = op2.node {\n-                    span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span, \"You are trying to use classic C overflow conditions that will fail in Rust.\");\n+                    span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n+                        \"You are trying to use classic C overflow conditions that will fail in Rust.\");\n                 }\n             }\n             if let BinOp_::BiGt = op.node {\n                 if let BinOp_::BiSub = op2.node {\n-                    span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span, \"You are trying to use classic C underflow conditions that will fail in Rust.\");\n+                    span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n+                        \"You are trying to use classic C underflow conditions that will fail in Rust.\");\n                 }\n             }\n         }}\n@@ -66,12 +68,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OverflowCheckConditional {\n         ], {\n             if let BinOp_::BiGt = op.node {\n                 if let BinOp_::BiAdd = op2.node {\n-                    span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span, \"You are trying to use classic C overflow conditions that will fail in Rust.\");\n+                    span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n+                        \"You are trying to use classic C overflow conditions that will fail in Rust.\");\n                 }\n             }\n             if let BinOp_::BiLt = op.node {\n                 if let BinOp_::BiSub = op2.node {\n-                    span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span, \"You are trying to use classic C underflow conditions that will fail in Rust.\");\n+                    span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n+                        \"You are trying to use classic C underflow conditions that will fail in Rust.\");\n                 }\n             }\n         }}"}, {"sha": "146706646ae4abf5b90d39a63d575ae525525165", "filename": "clippy_lints/src/precedence.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprecedence.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -49,7 +49,7 @@ impl EarlyLintPass for Precedence {\n                                        snippet(cx, left.span, \"..\"),\n                                        op.to_string(),\n                                        snippet(cx, right.span, \"..\")));\n-                }\n+                },\n                 (true, false) => {\n                     span_lint(cx,\n                               PRECEDENCE,\n@@ -59,7 +59,7 @@ impl EarlyLintPass for Precedence {\n                                        snippet(cx, left.span, \"..\"),\n                                        op.to_string(),\n                                        snippet(cx, right.span, \"..\")));\n-                }\n+                },\n                 (false, true) => {\n                     span_lint(cx,\n                               PRECEDENCE,\n@@ -69,7 +69,7 @@ impl EarlyLintPass for Precedence {\n                                        snippet(cx, left.span, \"..\"),\n                                        op.to_string(),\n                                        snippet(cx, right.span, \"..\")));\n-                }\n+                },\n                 _ => (),\n             }\n         }\n@@ -88,7 +88,7 @@ impl EarlyLintPass for Precedence {\n                                           &format!(\"unary minus has lower precedence than method call. Consider \\\n                                                     adding parentheses to clarify your intent: -({})\",\n                                                    snippet(cx, rhs.span, \"..\")));\n-                            }\n+                            },\n                             _ => (),\n                         }\n                     }"}, {"sha": "2f74390cc73e272bdfd44c5e4c48cdae18d169d5", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -117,7 +117,7 @@ fn is_null_path(expr: &Expr) -> bool {\n     if let ExprCall(ref pathexp, ref args) = expr.node {\n         if args.is_empty() {\n             if let ExprPath(ref path) = pathexp.node {\n-                return match_path(path, &paths::PTR_NULL) || match_path(path, &paths::PTR_NULL_MUT)\n+                return match_path(path, &paths::PTR_NULL) || match_path(path, &paths::PTR_NULL_MUT);\n             }\n         }\n     }"}, {"sha": "01829ffea45bd865f0b2b08a3ee8be6f871b9ac9", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -52,8 +52,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StepByZero {\n             let name = &*name.as_str();\n \n             // Range with step_by(0).\n-            if name == \"step_by\" && args.len() == 2 && has_step_by(cx, &args[0]) &&\n-               is_integer_literal(&args[1], 0) {\n+            if name == \"step_by\" && args.len() == 2 && has_step_by(cx, &args[0]) && is_integer_literal(&args[1], 0) {\n                 span_lint(cx,\n                           RANGE_STEP_BY_ZERO,\n                           expr.span,\n@@ -94,7 +93,6 @@ fn has_step_by(cx: &LateContext, expr: &Expr) -> bool {\n     let ty = cx.tcx.tables().expr_ty(expr);\n \n     // Note: `RangeTo`, `RangeToInclusive` and `RangeFull` don't have step_by\n-    match_type(cx, ty, &paths::RANGE)\n-        || match_type(cx, ty, &paths::RANGE_FROM)\n-        || match_type(cx, ty, &paths::RANGE_INCLUSIVE)\n+    match_type(cx, ty, &paths::RANGE) || match_type(cx, ty, &paths::RANGE_FROM) ||\n+    match_type(cx, ty, &paths::RANGE_INCLUSIVE)\n }"}, {"sha": "7c5c5713550a56fde1e6b91449b10268a41bbc15", "filename": "clippy_lints/src/reference.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freference.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -1,4 +1,4 @@\n-use syntax::ast::{Expr,ExprKind,UnOp};\n+use syntax::ast::{Expr, ExprKind, UnOp};\n use rustc::lint::*;\n use utils::{span_lint_and_then, snippet};\n \n@@ -40,15 +40,9 @@ impl EarlyLintPass for Pass {\n     fn check_expr(&mut self, cx: &EarlyContext, e: &Expr) {\n         if let ExprKind::Unary(UnOp::Deref, ref deref_target) = e.node {\n             if let ExprKind::AddrOf(_, ref addrof_target) = without_parens(deref_target).node {\n-                span_lint_and_then(\n-                    cx,\n-                    DEREF_ADDROF,\n-                    e.span,\n-                    \"immediately dereferencing a reference\",\n-                    |db| {\n-                        db.span_suggestion(e.span, \"try this\",\n-                                             format!(\"{}\", snippet(cx, addrof_target.span, \"_\")));\n-                    });\n+                span_lint_and_then(cx, DEREF_ADDROF, e.span, \"immediately dereferencing a reference\", |db| {\n+                    db.span_suggestion(e.span, \"try this\", format!(\"{}\", snippet(cx, addrof_target.span, \"_\")));\n+                });\n             }\n         }\n     }"}, {"sha": "31ac194ca7bf20999ed6844390b5fb74caa08117", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -145,7 +145,7 @@ fn str_span(base: Span, s: &str, c: usize) -> Span {\n                 hi: base.lo + BytePos(h as u32),\n                 ..base\n             }\n-        }\n+        },\n         _ => base,\n     }\n }\n@@ -172,17 +172,18 @@ fn is_trivial_regex(s: &regex_syntax::Expr) -> Option<&'static str> {\n                         (&Expr::Literal { .. }, &Expr::EndText) => Some(\"consider using `str::ends_with`\"),\n                         _ => None,\n                     }\n-                }\n+                },\n                 3 => {\n-                    if let (&Expr::StartText, &Expr::Literal {..}, &Expr::EndText) = (&exprs[0], &exprs[1], &exprs[2]) {\n+                    if let (&Expr::StartText, &Expr::Literal { .. }, &Expr::EndText) =\n+                        (&exprs[0], &exprs[1], &exprs[2]) {\n                         Some(\"consider using `==` on `str`s\")\n                     } else {\n                         None\n                     }\n-                }\n+                },\n                 _ => None,\n             }\n-        }\n+        },\n         _ => None,\n     }\n }\n@@ -213,14 +214,13 @@ fn check_regex(cx: &LateContext, expr: &Expr, utf8: bool) {\n                                            \"trivial regex\",\n                                            &format!(\"consider using {}\", repl));\n                     }\n-                }\n+                },\n                 Err(e) => {\n                     span_lint(cx,\n                               INVALID_REGEX,\n                               str_span(expr.span, r, e.position()),\n-                              &format!(\"regex syntax error: {}\",\n-                                       e.description()));\n-                }\n+                              &format!(\"regex syntax error: {}\", e.description()));\n+                },\n             }\n         }\n     } else if let Some(r) = const_str(cx, expr) {\n@@ -233,15 +233,13 @@ fn check_regex(cx: &LateContext, expr: &Expr, utf8: bool) {\n                                        \"trivial regex\",\n                                        &format!(\"consider using {}\", repl));\n                 }\n-            }\n+            },\n             Err(e) => {\n                 span_lint(cx,\n                           INVALID_REGEX,\n                           expr.span,\n-                          &format!(\"regex syntax error on position {}: {}\",\n-                                   e.position(),\n-                                   e.description()));\n-            }\n+                          &format!(\"regex syntax error on position {}: {}\", e.position(), e.description()));\n+            },\n         }\n     }\n }"}, {"sha": "b9054f72164ba460b289985b2ea68d8baaf4ca89", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -48,9 +48,10 @@ impl ReturnPass {\n     fn check_block_return(&mut self, cx: &EarlyContext, block: &ast::Block) {\n         if let Some(stmt) = block.stmts.last() {\n             match stmt.node {\n-                ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => {\n+                ast::StmtKind::Expr(ref expr) |\n+                ast::StmtKind::Semi(ref expr) => {\n                     self.check_final_expr(cx, expr, Some(stmt.span));\n-                }\n+                },\n                 _ => (),\n             }\n         }\n@@ -65,24 +66,24 @@ impl ReturnPass {\n                 if !expr.attrs.iter().any(attr_is_cfg) {\n                     self.emit_return_lint(cx, span.expect(\"`else return` is not possible\"), inner.span);\n                 }\n-            }\n+            },\n             // a whole block? check it!\n             ast::ExprKind::Block(ref block) => {\n                 self.check_block_return(cx, block);\n-            }\n+            },\n             // an if/if let expr, check both exprs\n             // note, if without else is going to be a type checking error anyways\n             // (except for unit type functions) so we don't match it\n             ast::ExprKind::If(_, ref ifblock, Some(ref elsexpr)) => {\n                 self.check_block_return(cx, ifblock);\n                 self.check_final_expr(cx, elsexpr, None);\n-            }\n+            },\n             // a match expr, check all arms\n             ast::ExprKind::Match(_, ref arms) => {\n                 for arm in arms {\n                     self.check_final_expr(cx, &arm.body, Some(arm.body.span));\n                 }\n-            }\n+            },\n             _ => (),\n         }\n     }\n@@ -135,7 +136,8 @@ impl LintPass for ReturnPass {\n impl EarlyLintPass for ReturnPass {\n     fn check_fn(&mut self, cx: &EarlyContext, kind: FnKind, _: &ast::FnDecl, _: Span, _: ast::NodeId) {\n         match kind {\n-            FnKind::ItemFn(.., block) | FnKind::Method(.., block) => self.check_block_return(cx, block),\n+            FnKind::ItemFn(.., block) |\n+            FnKind::Method(.., block) => self.check_block_return(cx, block),\n             FnKind::Closure(body) => self.check_final_expr(cx, body, None),\n         }\n     }\n@@ -152,4 +154,3 @@ fn attr_is_cfg(attr: &ast::Attribute) -> bool {\n         false\n     }\n }\n-"}, {"sha": "02faf7a204fb3f5279ade4a88990713fd960ae45", "filename": "clippy_lints/src/serde.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fserde.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fserde.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fserde.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -46,8 +46,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Serde {\n                             span_lint(cx,\n                                       SERDE_API_MISUSE,\n                                       span,\n-                                      \"you should not implement `visit_string` without also implementing `visit_str`\",\n-                            );\n+                                      \"you should not implement `visit_string` without also implementing `visit_str`\");\n                         }\n                     }\n                 }"}, {"sha": "9c5b032f6251e5b4636faaf8f1b3b76738c5a11c", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -87,7 +87,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         decl: &'tcx FnDecl,\n         expr: &'tcx Expr,\n         _: Span,\n-        _: NodeId,\n+        _: NodeId\n     ) {\n         if in_external_macro(cx, expr.span) {\n             return;\n@@ -155,7 +155,7 @@ fn check_pat<'a, 'tcx>(\n     pat: &'tcx Pat,\n     init: Option<&'tcx Expr>,\n     span: Span,\n-    bindings: &mut Vec<(Name, Span)>,\n+    bindings: &mut Vec<(Name, Span)>\n ) {\n     // TODO: match more stuff / destructuring\n     match pat.node {\n@@ -178,15 +178,15 @@ fn check_pat<'a, 'tcx>(\n             if let Some(ref p) = *inner {\n                 check_pat(cx, p, init, span, bindings);\n             }\n-        }\n+        },\n         PatKind::Struct(_, ref pfields, _) => {\n             if let Some(init_struct) = init {\n                 if let ExprStruct(_, ref efields, _) = init_struct.node {\n                     for field in pfields {\n                         let name = field.node.name;\n                         let efield = efields.iter()\n-                                            .find(|f| f.name.node == name)\n-                                            .map(|f| &*f.expr);\n+                            .find(|f| f.name.node == name)\n+                            .map(|f| &*f.expr);\n                         check_pat(cx, &field.node.pat, efield, span, bindings);\n                     }\n                 } else {\n@@ -199,7 +199,7 @@ fn check_pat<'a, 'tcx>(\n                     check_pat(cx, &field.node.pat, None, span, bindings);\n                 }\n             }\n-        }\n+        },\n         PatKind::Tuple(ref inner, _) => {\n             if let Some(init_tup) = init {\n                 if let ExprTup(ref tup) = init_tup.node {\n@@ -216,7 +216,7 @@ fn check_pat<'a, 'tcx>(\n                     check_pat(cx, p, None, span, bindings);\n                 }\n             }\n-        }\n+        },\n         PatKind::Box(ref inner) => {\n             if let Some(initp) = init {\n                 if let ExprBox(ref inner_init) = initp.node {\n@@ -227,7 +227,7 @@ fn check_pat<'a, 'tcx>(\n             } else {\n                 check_pat(cx, inner, init, span, bindings);\n             }\n-        }\n+        },\n         PatKind::Ref(ref inner, _) => check_pat(cx, inner, init, span, bindings),\n         // PatVec(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n         _ => (),\n@@ -240,7 +240,7 @@ fn lint_shadow<'a, 'tcx: 'a>(\n     span: Span,\n     pattern_span: Span,\n     init: Option<&'tcx Expr>,\n-    prev_span: Span,\n+    prev_span: Span\n ) {\n     if let Some(expr) = init {\n         if is_self_shadow(name, expr) {\n@@ -250,8 +250,9 @@ fn lint_shadow<'a, 'tcx: 'a>(\n                                &format!(\"`{}` is shadowed by itself in `{}`\",\n                                         snippet(cx, pattern_span, \"_\"),\n                                         snippet(cx, expr.span, \"..\")),\n-                               |db| { db.span_note(prev_span, \"previous binding is here\"); },\n-            );\n+                               |db| {\n+                db.span_note(prev_span, \"previous binding is here\");\n+            });\n         } else if contains_self(cx, name, expr) {\n             span_lint_and_then(cx,\n                                SHADOW_REUSE,\n@@ -260,9 +261,9 @@ fn lint_shadow<'a, 'tcx: 'a>(\n                                         snippet(cx, pattern_span, \"_\"),\n                                         snippet(cx, expr.span, \"..\")),\n                                |db| {\n-                                   db.span_note(expr.span, \"initialization happens here\");\n-                                   db.span_note(prev_span, \"previous binding is here\");\n-                               });\n+                db.span_note(expr.span, \"initialization happens here\");\n+                db.span_note(prev_span, \"previous binding is here\");\n+            });\n         } else {\n             span_lint_and_then(cx,\n                                SHADOW_UNRELATED,\n@@ -271,17 +272,19 @@ fn lint_shadow<'a, 'tcx: 'a>(\n                                         snippet(cx, pattern_span, \"_\"),\n                                         snippet(cx, expr.span, \"..\")),\n                                |db| {\n-                                   db.span_note(expr.span, \"initialization happens here\");\n-                                   db.span_note(prev_span, \"previous binding is here\");\n-                               });\n+                db.span_note(expr.span, \"initialization happens here\");\n+                db.span_note(prev_span, \"previous binding is here\");\n+            });\n         }\n \n     } else {\n         span_lint_and_then(cx,\n                            SHADOW_UNRELATED,\n                            span,\n                            &format!(\"`{}` shadows a previous declaration\", snippet(cx, pattern_span, \"_\")),\n-                           |db| { db.span_note(prev_span, \"previous binding is here\"); });\n+                           |db| {\n+            db.span_note(prev_span, \"previous binding is here\");\n+        });\n     }\n }\n \n@@ -303,18 +306,18 @@ fn check_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, bindings:\n             for e in v {\n                 check_expr(cx, e, bindings)\n             }\n-        }\n+        },\n         ExprIf(ref cond, ref then, ref otherwise) => {\n             check_expr(cx, cond, bindings);\n             check_block(cx, then, bindings);\n             if let Some(ref o) = *otherwise {\n                 check_expr(cx, o, bindings);\n             }\n-        }\n+        },\n         ExprWhile(ref cond, ref block, _) => {\n             check_expr(cx, cond, bindings);\n             check_block(cx, block, bindings);\n-        }\n+        },\n         ExprMatch(ref init, ref arms, _) => {\n             check_expr(cx, init, bindings);\n             let len = bindings.len();\n@@ -329,7 +332,7 @@ fn check_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, bindings:\n                     bindings.truncate(len);\n                 }\n             }\n-        }\n+        },\n         _ => (),\n     }\n }\n@@ -341,14 +344,14 @@ fn check_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: &'tcx Ty, bindings: &mut V\n         TyArray(ref fty, ref expr) => {\n             check_ty(cx, fty, bindings);\n             check_expr(cx, expr, bindings);\n-        }\n+        },\n         TyPtr(MutTy { ty: ref mty, .. }) |\n         TyRptr(_, MutTy { ty: ref mty, .. }) => check_ty(cx, mty, bindings),\n         TyTup(ref tup) => {\n             for t in tup {\n                 check_ty(cx, t, bindings)\n             }\n-        }\n+        },\n         TyTypeof(ref expr) => check_expr(cx, expr, bindings),\n         _ => (),\n     }\n@@ -360,7 +363,7 @@ fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n         ExprAddrOf(_, ref inner) => is_self_shadow(name, inner),\n         ExprBlock(ref block) => {\n             block.stmts.is_empty() && block.expr.as_ref().map_or(false, |e| is_self_shadow(name, e))\n-        }\n+        },\n         ExprUnary(op, ref inner) => (UnDeref == op) && is_self_shadow(name, inner),\n         ExprPath(QPath::Resolved(_, ref path)) => path_eq_name(name, path),\n         _ => false,"}, {"sha": "195b49c72f68427f8f0ebe2cad03e64783f41114", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -122,7 +122,7 @@ fn is_add(cx: &LateContext, src: &Expr, target: &Expr) -> bool {\n         ExprBinary(Spanned { node: BiAdd, .. }, ref left, _) => SpanlessEq::new(cx).eq_expr(target, left),\n         ExprBlock(ref block) => {\n             block.stmts.is_empty() && block.expr.as_ref().map_or(false, |expr| is_add(cx, expr, target))\n-        }\n+        },\n         _ => false,\n     }\n }\n@@ -152,11 +152,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n                                                e.span,\n                                                \"calling `as_bytes()` on a string literal\",\n                                                |db| {\n-                                                   let sugg = format!(\"b{}\", snippet(cx, args[0].span, r#\"\"foo\"\"#));\n-                                                   db.span_suggestion(e.span,\n-                                                                      \"consider using a byte string literal instead\",\n-                                                                      sugg);\n-                                               });\n+                                let sugg = format!(\"b{}\", snippet(cx, args[0].span, r#\"\"foo\"\"#));\n+                                db.span_suggestion(e.span, \"consider using a byte string literal instead\", sugg);\n+                            });\n \n                         }\n                     }"}, {"sha": "8ed7e355879762b491a3c32c34b916a543cd21d5", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -81,7 +81,11 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n             SpanlessEq::new(cx).ignore_fn().eq_expr(tmp_init, lhs1),\n             SpanlessEq::new(cx).ignore_fn().eq_expr(rhs1, lhs2)\n         ], {\n-            fn check_for_slice<'a>(cx: &LateContext, lhs1: &'a Expr, lhs2: &'a Expr) -> Option<(&'a Expr, &'a Expr, &'a Expr)> {\n+            fn check_for_slice<'a>(\n+                cx: &LateContext,\n+                lhs1: &'a Expr,\n+                lhs2: &'a Expr,\n+            ) -> Option<(&'a Expr, &'a Expr, &'a Expr)> {\n                 if let ExprIndex(ref lhs1, ref idx1) = lhs1.node {\n                     if let ExprIndex(ref lhs2, ref idx2) = lhs2.node {\n                         if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, lhs2) {\n@@ -104,7 +108,10 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n                 if let Some(slice) = Sugg::hir_opt(cx, slice) {\n                     (false,\n                      format!(\" elements of `{}`\", slice),\n-                     format!(\"{}.swap({}, {})\", slice.maybe_par(), snippet(cx, idx1.span, \"..\"), snippet(cx, idx2.span, \"..\")))\n+                     format!(\"{}.swap({}, {})\",\n+                             slice.maybe_par(),\n+                             snippet(cx, idx1.span, \"..\"),\n+                             snippet(cx, idx2.span, \"..\")))\n                 } else {\n                     (false, \"\".to_owned(), \"\".to_owned())\n                 }\n@@ -148,7 +155,9 @@ fn check_suspicious_swap(cx: &LateContext, block: &Block) {\n             SpanlessEq::new(cx).ignore_fn().eq_expr(lhs0, rhs1),\n             SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, rhs0)\n         ], {\n-            let (what, lhs, rhs) = if let (Some(first), Some(second)) = (Sugg::hir_opt(cx, lhs0), Sugg::hir_opt(cx, rhs0)) {\n+            let lhs0 = Sugg::hir_opt(cx, lhs0);\n+            let rhs0 = Sugg::hir_opt(cx, rhs0);\n+            let (what, lhs, rhs) = if let (Some(first), Some(second)) = (lhs0, rhs0) {\n                 (format!(\" `{}` and `{}`\", first, second), first.mut_addr().to_string(), second.mut_addr().to_string())\n             } else {\n                 (\"\".to_owned(), \"\".to_owned(), \"\".to_owned())"}, {"sha": "1669b2d65572648f65c708c8c767fca6d0cf668f", "filename": "clippy_lints/src/temporary_assignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftemporary_assignment.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     if is_temporary(base) && !is_adjusted(cx, base) {\n                         span_lint(cx, TEMPORARY_ASSIGNMENT, expr.span, \"assignment to temporary\");\n                     }\n-                }\n+                },\n                 _ => (),\n             }\n         }"}, {"sha": "5e01f891eb1739bf79b5d55d672a838504c18747", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 55, "deletions": 54, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -95,18 +95,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                     let to_ty = cx.tcx.tables().expr_ty(e);\n \n                     match (&from_ty.sty, &to_ty.sty) {\n-                        _ if from_ty == to_ty => span_lint(\n-                            cx,\n-                            USELESS_TRANSMUTE,\n-                            e.span,\n-                            &format!(\"transmute from a type (`{}`) to itself\", from_ty),\n-                        ),\n-                        (&TyRef(_, rty), &TyRawPtr(ptr_ty)) => span_lint_and_then(\n-                            cx,\n-                            USELESS_TRANSMUTE,\n-                            e.span,\n-                            \"transmute from a reference to a pointer\",\n-                            |db| {\n+                        _ if from_ty == to_ty => {\n+                            span_lint(cx,\n+                                      USELESS_TRANSMUTE,\n+                                      e.span,\n+                                      &format!(\"transmute from a type (`{}`) to itself\", from_ty))\n+                        },\n+                        (&TyRef(_, rty), &TyRawPtr(ptr_ty)) => {\n+                            span_lint_and_then(cx,\n+                                               USELESS_TRANSMUTE,\n+                                               e.span,\n+                                               \"transmute from a reference to a pointer\",\n+                                               |db| {\n                                 if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n                                     let sugg = if ptr_ty == rty {\n                                         arg.as_ty(to_ty)\n@@ -116,53 +116,54 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n \n                                     db.span_suggestion(e.span, \"try\", sugg.to_string());\n                                 }\n-                            },\n-                        ),\n+                            })\n+                        },\n                         (&ty::TyInt(_), &TyRawPtr(_)) |\n-                        (&ty::TyUint(_), &TyRawPtr(_)) => span_lint_and_then(\n-                            cx,\n-                            USELESS_TRANSMUTE,\n-                            e.span,\n-                            \"transmute from an integer to a pointer\",\n-                            |db| {\n+                        (&ty::TyUint(_), &TyRawPtr(_)) => {\n+                            span_lint_and_then(cx,\n+                                               USELESS_TRANSMUTE,\n+                                               e.span,\n+                                               \"transmute from an integer to a pointer\",\n+                                               |db| {\n                                 if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n                                     db.span_suggestion(e.span, \"try\", arg.as_ty(&to_ty.to_string()).to_string());\n                                 }\n-                            },\n-                        ),\n+                            })\n+                        },\n                         (&ty::TyFloat(_), &TyRef(..)) |\n                         (&ty::TyFloat(_), &TyRawPtr(_)) |\n                         (&ty::TyChar, &TyRef(..)) |\n-                        (&ty::TyChar, &TyRawPtr(_)) => span_lint(\n-                            cx,\n-                            WRONG_TRANSMUTE,\n-                            e.span,\n-                            &format!(\"transmute from a `{}` to a pointer\", from_ty),\n-                        ),\n-                        (&TyRawPtr(from_ptr), _) if from_ptr.ty == to_ty => span_lint(\n-                            cx,\n-                            CROSSPOINTER_TRANSMUTE,\n-                            e.span,\n-                            &format!(\"transmute from a type (`{}`) to the type that it points to (`{}`)\",\n-                                     from_ty,\n-                                     to_ty),\n-                        ),\n-                        (_, &TyRawPtr(to_ptr)) if to_ptr.ty == from_ty => span_lint(\n-                            cx,\n-                            CROSSPOINTER_TRANSMUTE,\n-                            e.span,\n-                            &format!(\"transmute from a type (`{}`) to a pointer to that type (`{}`)\",\n-                                     from_ty,\n-                                     to_ty),\n-                        ),\n-                        (&TyRawPtr(from_pty), &TyRef(_, to_rty)) => span_lint_and_then(\n-                            cx,\n-                            TRANSMUTE_PTR_TO_REF,\n-                            e.span,\n-                            &format!(\"transmute from a pointer type (`{}`) to a reference type (`{}`)\",\n-                                    from_ty,\n-                                    to_ty),\n-                            |db| {\n+                        (&ty::TyChar, &TyRawPtr(_)) => {\n+                            span_lint(cx,\n+                                      WRONG_TRANSMUTE,\n+                                      e.span,\n+                                      &format!(\"transmute from a `{}` to a pointer\", from_ty))\n+                        },\n+                        (&TyRawPtr(from_ptr), _) if from_ptr.ty == to_ty => {\n+                            span_lint(cx,\n+                                      CROSSPOINTER_TRANSMUTE,\n+                                      e.span,\n+                                      &format!(\"transmute from a type (`{}`) to the type that it points to (`{}`)\",\n+                                               from_ty,\n+                                               to_ty))\n+                        },\n+                        (_, &TyRawPtr(to_ptr)) if to_ptr.ty == from_ty => {\n+                            span_lint(cx,\n+                                      CROSSPOINTER_TRANSMUTE,\n+                                      e.span,\n+                                      &format!(\"transmute from a type (`{}`) to a pointer to that type (`{}`)\",\n+                                               from_ty,\n+                                               to_ty))\n+                        },\n+                        (&TyRawPtr(from_pty), &TyRef(_, to_rty)) => {\n+                            span_lint_and_then(cx,\n+                                               TRANSMUTE_PTR_TO_REF,\n+                                               e.span,\n+                                               &format!(\"transmute from a pointer type (`{}`) to a reference type \\\n+                                                         (`{}`)\",\n+                                                        from_ty,\n+                                                        to_ty),\n+                                               |db| {\n                                 let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n                                 let (deref, cast) = if to_rty.mutbl == Mutability::MutMutable {\n                                     (\"&mut *\", \"*mut\")\n@@ -177,8 +178,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                 };\n \n                                 db.span_suggestion(e.span, \"try\", sugg::make_unop(deref, arg).to_string());\n-                            },\n-                        ),\n+                            })\n+                        },\n                         _ => return,\n                     };\n                 }"}, {"sha": "89bc46074fda4adabf31d47a4428c16d31e0f10f", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 64, "deletions": 58, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -6,8 +6,8 @@ use rustc::ty;\n use std::cmp::Ordering;\n use syntax::ast::{IntTy, UintTy, FloatTy};\n use syntax::codemap::Span;\n-use utils::{comparisons, higher, in_external_macro, in_macro, match_def_path, snippet,\n-            span_help_and_lint, span_lint, opt_def_id, last_path_segment};\n+use utils::{comparisons, higher, in_external_macro, in_macro, match_def_path, snippet, span_help_and_lint, span_lint,\n+            opt_def_id, last_path_segment};\n use utils::paths;\n \n /// Handles all the linting of funky types\n@@ -95,10 +95,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypePass {\n                     }}\n                 } else if match_def_path(cx, def_id, &paths::LINKED_LIST) {\n                     span_help_and_lint(cx,\n-                                        LINKEDLIST,\n-                                        ast_ty.span,\n-                                        \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n-                                        \"a VecDeque might work\");\n+                                       LINKEDLIST,\n+                                       ast_ty.span,\n+                                       \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n+                                       \"a VecDeque might work\");\n                 }\n             }\n         }\n@@ -141,7 +141,7 @@ fn check_let_unit(cx: &LateContext, decl: &Decl) {\n                           decl.span,\n                           &format!(\"this let-binding has unit value. Consider omitting `let {} =`\",\n                                    snippet(cx, local.pat.span, \"..\")));\n-            }\n+            },\n             _ => (),\n         }\n     }\n@@ -211,8 +211,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitCmp {\n                                   &format!(\"{}-comparison of unit values detected. This will always be {}\",\n                                            op.as_str(),\n                                            result));\n-                    }\n-                    _ => ()\n+                    },\n+                    _ => (),\n                 }\n             }\n         }\n@@ -336,11 +336,7 @@ fn is_isize_or_usize(typ: &ty::TyS) -> bool {\n }\n \n fn span_precision_loss_lint(cx: &LateContext, expr: &Expr, cast_from: &ty::TyS, cast_to_f64: bool) {\n-    let mantissa_nbits = if cast_to_f64 {\n-        52\n-    } else {\n-        23\n-    };\n+    let mantissa_nbits = if cast_to_f64 { 52 } else { 23 };\n     let arch_dependent = is_isize_or_usize(cast_from) && cast_to_f64;\n     let arch_dependent_str = \"on targets with 64-bit wide pointers \";\n     let from_nbits_str = if arch_dependent {\n@@ -356,11 +352,7 @@ fn span_precision_loss_lint(cx: &LateContext, expr: &Expr, cast_from: &ty::TyS,\n               &format!(\"casting {0} to {1} causes a loss of precision {2}({0} is {3} bits wide, but {1}'s mantissa \\\n                         is only {4} bits wide)\",\n                        cast_from,\n-                       if cast_to_f64 {\n-                           \"f64\"\n-                       } else {\n-                           \"f32\"\n-                       },\n+                       if cast_to_f64 { \"f64\" } else { \"f32\" },\n                        if arch_dependent {\n                            arch_dependent_str\n                        } else {\n@@ -388,27 +380,27 @@ fn check_truncation_and_wrapping(cx: &LateContext, expr: &Expr, cast_from: &ty::\n              ArchSuffix::None,\n              to_nbits == from_nbits && cast_unsigned_to_signed,\n              ArchSuffix::None)\n-        }\n+        },\n         (true, false) => {\n             (to_nbits <= 32,\n              if to_nbits == 32 {\n-                ArchSuffix::_64\n-            } else {\n-                ArchSuffix::None\n-            },\n+                 ArchSuffix::_64\n+             } else {\n+                 ArchSuffix::None\n+             },\n              to_nbits <= 32 && cast_unsigned_to_signed,\n              ArchSuffix::_32)\n-        }\n+        },\n         (false, true) => {\n             (from_nbits == 64,\n              ArchSuffix::_32,\n              cast_unsigned_to_signed,\n              if from_nbits == 64 {\n-                ArchSuffix::_64\n-            } else {\n-                ArchSuffix::_32\n-            })\n-        }\n+                 ArchSuffix::_64\n+             } else {\n+                 ArchSuffix::_32\n+             })\n+        },\n     };\n     if span_truncation {\n         span_lint(cx,\n@@ -463,7 +455,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n                         if is_isize_or_usize(cast_from) || from_nbits >= to_nbits {\n                             span_precision_loss_lint(cx, expr, cast_from, to_nbits == 64);\n                         }\n-                    }\n+                    },\n                     (false, true) => {\n                         span_lint(cx,\n                                   CAST_POSSIBLE_TRUNCATION,\n@@ -475,7 +467,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n                                       expr.span,\n                                       &format!(\"casting {} to {} may lose the sign of the value\", cast_from, cast_to));\n                         }\n-                    }\n+                    },\n                     (true, true) => {\n                         if cast_from.is_signed() && !cast_to.is_signed() {\n                             span_lint(cx,\n@@ -484,16 +476,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n                                       &format!(\"casting {} to {} may lose the sign of the value\", cast_from, cast_to));\n                         }\n                         check_truncation_and_wrapping(cx, expr, cast_from, cast_to);\n-                    }\n+                    },\n                     (false, false) => {\n-                        if let (&ty::TyFloat(FloatTy::F64), &ty::TyFloat(FloatTy::F32)) = (&cast_from.sty,\n-                                                                                           &cast_to.sty) {\n+                        if let (&ty::TyFloat(FloatTy::F64), &ty::TyFloat(FloatTy::F32)) =\n+                            (&cast_from.sty, &cast_to.sty) {\n                             span_lint(cx,\n                                       CAST_POSSIBLE_TRUNCATION,\n                                       expr.span,\n                                       \"casting f64 to f32 may truncate the value\");\n                         }\n-                    }\n+                    },\n                 }\n             }\n         }\n@@ -536,7 +528,15 @@ impl LintPass for TypeComplexityPass {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeComplexityPass {\n-    fn check_fn(&mut self, cx: &LateContext<'a, 'tcx>, _: FnKind<'tcx>, decl: &'tcx FnDecl, _: &'tcx Expr, _: Span, _: NodeId) {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        _: FnKind<'tcx>,\n+        decl: &'tcx FnDecl,\n+        _: &'tcx Expr,\n+        _: Span,\n+        _: NodeId\n+    ) {\n         self.check_fndecl(cx, decl);\n     }\n \n@@ -629,10 +629,7 @@ impl<'a, 'tcx: 'a> Visitor<'tcx> for TypeComplexityVisitor<'a, 'tcx> {\n             TyInfer | TyPtr(..) | TyRptr(..) => (1, 0),\n \n             // the \"normal\" components of a type: named types, arrays/tuples\n-            TyPath(..) |\n-            TySlice(..) |\n-            TyTup(..) |\n-            TyArray(..) => (10 * self.nest, 1),\n+            TyPath(..) | TySlice(..) | TyTup(..) | TyArray(..) => (10 * self.nest, 1),\n \n             // \"Sum\" of trait bounds\n             TyObjectSum(..) => (20 * self.nest, 0),\n@@ -693,9 +690,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CharLitAsU8 {\n                         let msg = \"casting character literal to u8. `char`s \\\n                                    are 4 bytes wide in rust, so casting to u8 \\\n                                    truncates them\";\n-                        let help = format!(\"Consider using a byte literal \\\n-                                            instead:\\nb{}\",\n-                                           snippet(cx, e.span, \"'x'\"));\n+                        let help = format!(\"Consider using a byte literal instead:\\nb{}\", snippet(cx, e.span, \"'x'\"));\n                         span_help_and_lint(cx, CHAR_LIT_AS_U8, expr.span, msg, &help);\n                     }\n                 }\n@@ -752,8 +747,12 @@ enum AbsurdComparisonResult {\n \n \n \n-fn detect_absurd_comparison<'a>(cx: &LateContext, op: BinOp_, lhs: &'a Expr, rhs: &'a Expr)\n-                                -> Option<(ExtremeExpr<'a>, AbsurdComparisonResult)> {\n+fn detect_absurd_comparison<'a>(\n+    cx: &LateContext,\n+    op: BinOp_,\n+    lhs: &'a Expr,\n+    rhs: &'a Expr\n+) -> Option<(ExtremeExpr<'a>, AbsurdComparisonResult)> {\n     use types::ExtremeType::*;\n     use types::AbsurdComparisonResult::*;\n     use utils::comparisons::*;\n@@ -775,7 +774,7 @@ fn detect_absurd_comparison<'a>(cx: &LateContext, op: BinOp_, lhs: &'a Expr, rhs\n                 (_, Some(r @ ExtremeExpr { which: Minimum, .. })) => (r, AlwaysFalse), // x < min\n                 _ => return None,\n             }\n-        }\n+        },\n         Rel::Le => {\n             match (lx, rx) {\n                 (Some(l @ ExtremeExpr { which: Minimum, .. }), _) => (l, AlwaysTrue), // min <= x\n@@ -784,7 +783,7 @@ fn detect_absurd_comparison<'a>(cx: &LateContext, op: BinOp_, lhs: &'a Expr, rhs\n                 (_, Some(r @ ExtremeExpr { which: Maximum, .. })) => (r, AlwaysTrue), // x <= max\n                 _ => return None,\n             }\n-        }\n+        },\n         Rel::Ne | Rel::Eq => return None,\n     })\n }\n@@ -864,7 +863,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AbsurdExtremeComparisons {\n                                      instead\",\n                                     snippet(cx, lhs.span, \"lhs\"),\n                                     snippet(cx, rhs.span, \"rhs\"))\n-                        }\n+                        },\n                     };\n \n                     let help = format!(\"because {} is the {} value for this type, {}\",\n@@ -967,7 +966,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n                     IntTy::I64 => (FullInt::S(i64::min_value() as i64), FullInt::S(i64::max_value() as i64)),\n                     IntTy::Is => (FullInt::S(isize::min_value() as i64), FullInt::S(isize::max_value() as i64)),\n                 })\n-            }\n+            },\n             TyUint(uint_ty) => {\n                 Some(match uint_ty {\n                     UintTy::U8 => (FullInt::U(u8::min_value() as u64), FullInt::U(u8::max_value() as u64)),\n@@ -976,7 +975,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n                     UintTy::U64 => (FullInt::U(u64::min_value() as u64), FullInt::U(u64::max_value() as u64)),\n                     UintTy::Us => (FullInt::U(usize::min_value() as u64), FullInt::U(usize::max_value() as u64)),\n                 })\n-            }\n+            },\n             _ => None,\n         }\n     } else {\n@@ -1001,7 +1000,7 @@ fn node_as_const_fullint(cx: &LateContext, expr: &Expr) -> Option<FullInt> {\n             } else {\n                 None\n             }\n-        }\n+        },\n         Err(_) => None,\n     }\n }\n@@ -1019,8 +1018,15 @@ fn err_upcast_comparison(cx: &LateContext, span: &Span, expr: &Expr, always: boo\n     }\n }\n \n-fn upcast_comparison_bounds_err(cx: &LateContext, span: &Span, rel: comparisons::Rel,\n-                                lhs_bounds: Option<(FullInt, FullInt)>, lhs: &Expr, rhs: &Expr, invert: bool) {\n+fn upcast_comparison_bounds_err(\n+    cx: &LateContext,\n+    span: &Span,\n+    rel: comparisons::Rel,\n+    lhs_bounds: Option<(FullInt, FullInt)>,\n+    lhs: &Expr,\n+    rhs: &Expr,\n+    invert: bool\n+) {\n     use utils::comparisons::*;\n \n     if let Some((lb, ub)) = lhs_bounds {\n@@ -1036,14 +1042,14 @@ fn upcast_comparison_bounds_err(cx: &LateContext, span: &Span, rel: comparisons:\n                     } else {\n                         ub < norm_rhs_val\n                     }\n-                }\n+                },\n                 Rel::Le => {\n                     if invert {\n                         norm_rhs_val <= lb\n                     } else {\n                         ub <= norm_rhs_val\n                     }\n-                }\n+                },\n                 Rel::Eq | Rel::Ne => unreachable!(),\n             } {\n                 err_upcast_comparison(cx, span, lhs, true)\n@@ -1054,14 +1060,14 @@ fn upcast_comparison_bounds_err(cx: &LateContext, span: &Span, rel: comparisons:\n                     } else {\n                         lb >= norm_rhs_val\n                     }\n-                }\n+                },\n                 Rel::Le => {\n                     if invert {\n                         norm_rhs_val > ub\n                     } else {\n                         lb > norm_rhs_val\n                     }\n-                }\n+                },\n                 Rel::Eq | Rel::Ne => unreachable!(),\n             } {\n                 err_upcast_comparison(cx, span, lhs, false)"}, {"sha": "07afc55ae7f171f091bcd9d2be7178fcf0f33e74", "filename": "clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -38,24 +38,23 @@ impl EarlyLintPass for UnsafeNameRemoval {\n         if let ItemKind::Use(ref item_use) = item.node {\n             match item_use.node {\n                 ViewPath_::ViewPathSimple(ref name, ref path) => {\n-                    unsafe_to_safe_check(\n-                        path.segments\n-                            .last()\n-                            .expect(\"use paths cannot be empty\")\n-                            .identifier,\n-                        *name,\n-                        cx, &item.span\n-                        );\n-                }\n+                    unsafe_to_safe_check(path.segments\n+                                             .last()\n+                                             .expect(\"use paths cannot be empty\")\n+                                             .identifier,\n+                                         *name,\n+                                         cx,\n+                                         &item.span);\n+                },\n                 ViewPath_::ViewPathList(_, ref path_list_items) => {\n                     for path_list_item in path_list_items.iter() {\n                         let plid = path_list_item.node;\n                         if let Some(rename) = plid.rename {\n                             unsafe_to_safe_check(plid.name, rename, cx, &item.span);\n                         };\n                     }\n-                }\n-                ViewPath_::ViewPathGlob(_) => {}\n+                },\n+                ViewPath_::ViewPathGlob(_) => {},\n             }\n         }\n     }\n@@ -68,11 +67,7 @@ fn unsafe_to_safe_check(old_name: Ident, new_name: Ident, cx: &EarlyContext, spa\n         span_lint(cx,\n                   UNSAFE_REMOVED_FROM_NAME,\n                   *span,\n-                  &format!(\n-                \"removed \\\"unsafe\\\" from the name of `{}` in use as `{}`\",\n-                old_str,\n-                new_str\n-            ));\n+                  &format!(\"removed \\\"unsafe\\\" from the name of `{}` in use as `{}`\", old_str, new_str));\n     }\n }\n "}, {"sha": "9017fd6933e81b04f6e66bad4b7aa04217947ceb", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -48,7 +48,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedLabel {\n         decl: &'tcx hir::FnDecl,\n         body: &'tcx hir::Expr,\n         span: Span,\n-        fn_id: ast::NodeId,\n+        fn_id: ast::NodeId\n     ) {\n         if in_macro(cx, span) {\n             return;\n@@ -72,11 +72,11 @@ impl<'a, 'tcx: 'a> Visitor<'tcx> for UnusedLabelVisitor<'a, 'tcx> {\n             hir::ExprBreak(Some(label), _) |\n             hir::ExprAgain(Some(label)) => {\n                 self.labels.remove(&label.name.as_str());\n-            }\n+            },\n             hir::ExprLoop(_, Some(label), _) |\n             hir::ExprWhile(_, _, Some(label)) => {\n                 self.labels.insert(label.node.as_str(), expr.span);\n-            }\n+            },\n             _ => (),\n         }\n "}, {"sha": "f973c2afd27a21ad812eb1192f64e80aa046ac22", "filename": "clippy_lints/src/utils/comparisons.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Futils%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Futils%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fcomparisons.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -18,8 +18,7 @@ pub enum Rel {\n }\n \n /// Put the expression in the form  `lhs < rhs`, `lhs <= rhs`, `lhs == rhs` or `lhs != rhs`.\n-pub fn normalize_comparison<'a>(op: BinOp_, lhs: &'a Expr, rhs: &'a Expr)\n-                                -> Option<(Rel, &'a Expr, &'a Expr)> {\n+pub fn normalize_comparison<'a>(op: BinOp_, lhs: &'a Expr, rhs: &'a Expr) -> Option<(Rel, &'a Expr, &'a Expr)> {\n     match op {\n         BinOp_::BiLt => Some((Rel::Lt, lhs, rhs)),\n         BinOp_::BiLe => Some((Rel::Le, lhs, rhs)),"}, {"sha": "d80fa17e29f736cd0e63b47724eefb4c7885a9d8", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -8,21 +8,20 @@ use syntax::{ast, codemap};\n use toml;\n \n /// Get the configuration file from arguments.\n-pub fn file_from_args(args: &[codemap::Spanned<ast::NestedMetaItemKind>]) -> Result<Option<path::PathBuf>, (&'static str, codemap::Span)> {\n+pub fn file_from_args(args: &[codemap::Spanned<ast::NestedMetaItemKind>])\n+    -> Result<Option<path::PathBuf>, (&'static str, codemap::Span)> {\n     for arg in args.iter().filter_map(|a| a.meta_item()) {\n         if arg.name() == \"conf_file\" {\n             return match arg.node {\n                 ast::MetaItemKind::Word |\n-                ast::MetaItemKind::List(_) => {\n-                    Err((\"`conf_file` must be a named value\", arg.span))\n-                }\n+                ast::MetaItemKind::List(_) => Err((\"`conf_file` must be a named value\", arg.span)),\n                 ast::MetaItemKind::NameValue(ref value) => {\n                     if let ast::LitKind::Str(ref file, _) = value.node {\n                         Ok(Some(file.to_string().into()))\n                     } else {\n                         Err((\"`conf_file` value must be a string\", value.span))\n                     }\n-                }\n+                },\n             };\n         }\n     }\n@@ -38,14 +37,12 @@ pub enum Error {\n     /// The file is not valid TOML.\n     Toml(Vec<toml::ParserError>),\n     /// Type error.\n-    Type(\n-        /// The name of the key.\n-        &'static str,\n-        /// The expected type.\n-        &'static str,\n-        /// The type we got instead.\n-        &'static str\n-    ),\n+    Type(/// The name of the key.\n+         &'static str,\n+         /// The expected type.\n+         &'static str,\n+         /// The type we got instead.\n+         &'static str),\n     /// There is an unknown key is the file.\n     UnknownKey(String),\n }\n@@ -66,10 +63,10 @@ impl fmt::Display for Error {\n                 }\n \n                 Ok(())\n-            }\n+            },\n             Error::Type(key, expected, got) => {\n                 write!(f, \"`{}` is expected to be a `{}` but is a `{}`\", key, expected, got)\n-            }\n+            },\n             Error::UnknownKey(ref key) => write!(f, \"unknown key `{}`\", key),\n         }\n     }\n@@ -134,20 +131,23 @@ macro_rules! define_Conf {\n \n     // how to read the value?\n     (CONV i64, $value: expr) => { $value.as_integer() };\n-    (CONV u64, $value: expr) => { $value.as_integer().iter().filter_map(|&i| if i >= 0 { Some(i as u64) } else { None }).next() };\n+    (CONV u64, $value: expr) => {\n+        $value.as_integer()\n+        .iter()\n+        .filter_map(|&i| if i >= 0 { Some(i as u64) } else { None })\n+        .next()\n+    };\n     (CONV String, $value: expr) => { $value.as_str().map(Into::into) };\n     (CONV Vec<String>, $value: expr) => {{\n         let slice = $value.as_slice();\n \n         if let Some(slice) = slice {\n             if slice.iter().any(|v| v.as_str().is_none()) {\n                 None\n+            } else {\n+                Some(slice.iter().map(|v| v.as_str().expect(\"already checked\").to_owned()).collect())\n             }\n-            else {\n-                Some(slice.iter().map(|v| v.as_str().unwrap_or_else(|| unreachable!()).to_owned()).collect())\n-            }\n-        }\n-        else {\n+        } else {\n             None\n         }\n     }};\n@@ -163,7 +163,19 @@ define_Conf! {\n     /// Lint: CYCLOMATIC_COMPLEXITY. The maximum cyclomatic complexity a function can have\n     (\"cyclomatic-complexity-threshold\", cyclomatic_complexity_threshold, 25 => u64),\n     /// Lint: DOC_MARKDOWN. The list of words this lint should not consider as identifiers needing ticks\n-    (\"doc-valid-idents\", doc_valid_idents, [\"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\", \"DirectX\", \"GPLv2\", \"GPLv3\", \"GitHub\", \"IPv4\", \"IPv6\", \"JavaScript\", \"NaN\", \"OAuth\", \"OpenGL\", \"TrueType\", \"iOS\", \"macOS\"] => Vec<String>),\n+    (\"doc-valid-idents\", doc_valid_idents, [\n+        \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\",\n+        \"DirectX\",\n+        \"GPLv2\", \"GPLv3\",\n+        \"GitHub\",\n+        \"IPv4\", \"IPv6\",\n+        \"JavaScript\",\n+        \"NaN\",\n+        \"OAuth\",\n+        \"OpenGL\",\n+        \"TrueType\",\n+        \"iOS\", \"macOS\",\n+    ] => Vec<String>),\n     /// Lint: TOO_MANY_ARGUMENTS. The maximum number of argument a function or method can have\n     (\"too-many-arguments-threshold\", too_many_arguments_threshold, 7 => u64),\n     /// Lint: TYPE_COMPLEXITY. The maximum complexity a type can have\n@@ -196,7 +208,7 @@ pub fn lookup_conf_file() -> io::Result<Option<path::PathBuf>> {\n                     if e.kind() != io::ErrorKind::NotFound {\n                         return Err(e);\n                     }\n-                }\n+                },\n                 _ => (),\n             }\n         }\n@@ -231,11 +243,11 @@ pub fn read(path: Option<&path::Path>) -> (Conf, Vec<Error>) {\n             }\n \n             buf\n-        }\n+        },\n         Err(err) => {\n             errors.push(err.into());\n             return (conf, errors);\n-        }\n+        },\n     };\n \n     let mut parser = toml::Parser::new(&file);"}, {"sha": "87008307c5f66baf8737a75ea5ec68b0994e6b98", "filename": "clippy_lints/src/utils/constants.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Futils%2Fconstants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Futils%2Fconstants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconstants.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -7,15 +7,5 @@\n /// See also [the reference][reference-types] for a list of such types.\n ///\n /// [reference-types]: https://doc.rust-lang.org/reference.html#types\n-pub const BUILTIN_TYPES: &'static [&'static str] = &[\n-    \"i8\", \"u8\",\n-    \"i16\", \"u16\",\n-    \"i32\", \"u32\",\n-    \"i64\", \"u64\",\n-    \"isize\", \"usize\",\n-    \"f32\",\n-    \"f64\",\n-    \"bool\",\n-    \"str\",\n-    \"char\",\n-];\n+pub const BUILTIN_TYPES: &'static [&'static str] = &[\"i8\", \"u8\", \"i16\", \"u16\", \"i32\", \"u32\", \"i64\", \"u64\", \"isize\",\n+                                                     \"usize\", \"f32\", \"f64\", \"bool\", \"str\", \"char\"];"}, {"sha": "c83dae26fdaa7dbf01288381baf5a6610d23ca65", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -47,9 +47,9 @@ pub fn range(expr: &hir::Expr) -> Option<Range> {\n     /// Find the field named `name` in the field. Always return `Some` for convenience.\n     fn get_field<'a>(name: &str, fields: &'a [hir::Field]) -> Option<&'a hir::Expr> {\n         let expr = &fields.iter()\n-                          .find(|field| field.name.node == name)\n-                          .unwrap_or_else(|| panic!(\"missing {} field for range\", name))\n-                          .expr;\n+            .find(|field| field.name.node == name)\n+            .unwrap_or_else(|| panic!(\"missing {} field for range\", name))\n+            .expr;\n \n         Some(expr)\n     }\n@@ -68,7 +68,7 @@ pub fn range(expr: &hir::Expr) -> Option<Range> {\n             } else {\n                 None\n             }\n-        }\n+        },\n         hir::ExprStruct(ref path, ref fields, None) => {\n             if match_path(path, &paths::RANGE_FROM_STD) || match_path(path, &paths::RANGE_FROM) {\n                 Some(Range {\n@@ -77,7 +77,7 @@ pub fn range(expr: &hir::Expr) -> Option<Range> {\n                     limits: ast::RangeLimits::HalfOpen,\n                 })\n             } else if match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY_STD) ||\n-               match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY) {\n+                      match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY) {\n                 Some(Range {\n                     start: get_field(\"start\", fields),\n                     end: get_field(\"end\", fields),\n@@ -104,7 +104,7 @@ pub fn range(expr: &hir::Expr) -> Option<Range> {\n             } else {\n                 None\n             }\n-        }\n+        },\n         _ => None,\n     }\n }"}, {"sha": "80399825b6d1b309ef2c48d8d3c1311d1919d7e6", "filename": "clippy_lints/src/utils/hir.rs", "status": "modified", "additions": 66, "deletions": 83, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -38,12 +38,11 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         match (&left.node, &right.node) {\n             (&StmtDecl(ref l, _), &StmtDecl(ref r, _)) => {\n                 if let (&DeclLocal(ref l), &DeclLocal(ref r)) = (&l.node, &r.node) {\n-                    both(&l.ty, &r.ty, |l, r| self.eq_ty(l, r)) &&\n-                    both(&l.init, &r.init, |l, r| self.eq_expr(l, r))\n+                    both(&l.ty, &r.ty, |l, r| self.eq_ty(l, r)) && both(&l.init, &r.init, |l, r| self.eq_expr(l, r))\n                 } else {\n                     false\n                 }\n-            }\n+            },\n             (&StmtExpr(ref l, _), &StmtExpr(ref r, _)) |\n             (&StmtSemi(ref l, _), &StmtSemi(ref r, _)) => self.eq_expr(l, r),\n             _ => false,\n@@ -73,64 +72,60 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             (&ExprAssign(ref ll, ref lr), &ExprAssign(ref rl, ref rr)) => self.eq_expr(ll, rl) && self.eq_expr(lr, rr),\n             (&ExprAssignOp(ref lo, ref ll, ref lr), &ExprAssignOp(ref ro, ref rl, ref rr)) => {\n                 lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n-            }\n+            },\n             (&ExprBlock(ref l), &ExprBlock(ref r)) => self.eq_block(l, r),\n             (&ExprBinary(l_op, ref ll, ref lr), &ExprBinary(r_op, ref rl, ref rr)) => {\n                 l_op.node == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr) ||\n                 swap_binop(l_op.node, ll, lr).map_or(false, |(l_op, ll, lr)| {\n                     l_op == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n                 })\n-            }\n-            (&ExprBreak(li, ref le), &ExprBreak(ri, ref re)) =>\n-                both(&li, &ri, |l, r| l.name.as_str() == r.name.as_str())\n-                && both(le, re, |l, r| self.eq_expr(l, r)),\n+            },\n+            (&ExprBreak(li, ref le), &ExprBreak(ri, ref re)) => {\n+                both(&li, &ri, |l, r| l.name.as_str() == r.name.as_str()) && both(le, re, |l, r| self.eq_expr(l, r))\n+            },\n             (&ExprBox(ref l), &ExprBox(ref r)) => self.eq_expr(l, r),\n             (&ExprCall(ref l_fun, ref l_args), &ExprCall(ref r_fun, ref r_args)) => {\n                 !self.ignore_fn && self.eq_expr(l_fun, r_fun) && self.eq_exprs(l_args, r_args)\n-            }\n+            },\n             (&ExprCast(ref lx, ref lt), &ExprCast(ref rx, ref rt)) |\n-            (&ExprType(ref lx, ref lt), &ExprType(ref rx, ref rt)) => {\n-                self.eq_expr(lx, rx) && self.eq_ty(lt, rt)\n-            }\n+            (&ExprType(ref lx, ref lt), &ExprType(ref rx, ref rt)) => self.eq_expr(lx, rx) && self.eq_ty(lt, rt),\n             (&ExprField(ref l_f_exp, ref l_f_ident), &ExprField(ref r_f_exp, ref r_f_ident)) => {\n                 l_f_ident.node == r_f_ident.node && self.eq_expr(l_f_exp, r_f_exp)\n-            }\n+            },\n             (&ExprIndex(ref la, ref li), &ExprIndex(ref ra, ref ri)) => self.eq_expr(la, ra) && self.eq_expr(li, ri),\n             (&ExprIf(ref lc, ref lt, ref le), &ExprIf(ref rc, ref rt, ref re)) => {\n                 self.eq_expr(lc, rc) && self.eq_block(lt, rt) && both(le, re, |l, r| self.eq_expr(l, r))\n-            }\n+            },\n             (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n             (&ExprLoop(ref lb, ref ll, ref lls), &ExprLoop(ref rb, ref rl, ref rls)) => {\n                 lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.node.as_str() == r.node.as_str())\n-            }\n+            },\n             (&ExprMatch(ref le, ref la, ref ls), &ExprMatch(ref re, ref ra, ref rs)) => {\n                 ls == rs && self.eq_expr(le, re) &&\n                 over(la, ra, |l, r| {\n-                    self.eq_expr(&l.body, &r.body) &&\n-                    both(&l.guard, &r.guard, |l, r| self.eq_expr(l, r)) &&\n+                    self.eq_expr(&l.body, &r.body) && both(&l.guard, &r.guard, |l, r| self.eq_expr(l, r)) &&\n                     over(&l.pats, &r.pats, |l, r| self.eq_pat(l, r))\n                 })\n-            }\n+            },\n             (&ExprMethodCall(ref l_name, ref l_tys, ref l_args),\n              &ExprMethodCall(ref r_name, ref r_tys, ref r_args)) => {\n-                !self.ignore_fn && l_name.node == r_name.node &&\n-                over(l_tys, r_tys, |l, r| self.eq_ty(l, r)) &&\n+                !self.ignore_fn && l_name.node == r_name.node && over(l_tys, r_tys, |l, r| self.eq_ty(l, r)) &&\n                 self.eq_exprs(l_args, r_args)\n-            }\n+            },\n             (&ExprRepeat(ref le, ref ll), &ExprRepeat(ref re, ref rl)) => self.eq_expr(le, re) && self.eq_expr(ll, rl),\n             (&ExprRet(ref l), &ExprRet(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n             (&ExprPath(ref l), &ExprPath(ref r)) => self.eq_qpath(l, r),\n             (&ExprStruct(ref l_path, ref lf, ref lo), &ExprStruct(ref r_path, ref rf, ref ro)) => {\n                 self.eq_qpath(l_path, r_path) && both(lo, ro, |l, r| self.eq_expr(l, r)) &&\n                 over(lf, rf, |l, r| self.eq_field(l, r))\n-            }\n+            },\n             (&ExprTup(ref l_tup), &ExprTup(ref r_tup)) => self.eq_exprs(l_tup, r_tup),\n             (&ExprTupField(ref le, li), &ExprTupField(ref re, ri)) => li.node == ri.node && self.eq_expr(le, re),\n             (&ExprUnary(l_op, ref le), &ExprUnary(r_op, ref re)) => l_op == r_op && self.eq_expr(le, re),\n             (&ExprArray(ref l), &ExprArray(ref r)) => self.eq_exprs(l, r),\n             (&ExprWhile(ref lc, ref lb, ref ll), &ExprWhile(ref rc, ref rb, ref rl)) => {\n                 self.eq_expr(lc, rc) && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.node.as_str() == r.node.as_str())\n-            }\n+            },\n             _ => false,\n         }\n     }\n@@ -153,23 +148,23 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             (&PatKind::Box(ref l), &PatKind::Box(ref r)) => self.eq_pat(l, r),\n             (&PatKind::TupleStruct(ref lp, ref la, ls), &PatKind::TupleStruct(ref rp, ref ra, rs)) => {\n                 self.eq_qpath(lp, rp) && over(la, ra, |l, r| self.eq_pat(l, r)) && ls == rs\n-            }\n+            },\n             (&PatKind::Binding(ref lb, _, ref li, ref lp), &PatKind::Binding(ref rb, _, ref ri, ref rp)) => {\n                 lb == rb && li.node.as_str() == ri.node.as_str() && both(lp, rp, |l, r| self.eq_pat(l, r))\n-            }\n+            },\n             (&PatKind::Path(ref l), &PatKind::Path(ref r)) => self.eq_qpath(l, r),\n             (&PatKind::Lit(ref l), &PatKind::Lit(ref r)) => self.eq_expr(l, r),\n             (&PatKind::Tuple(ref l, ls), &PatKind::Tuple(ref r, rs)) => {\n                 ls == rs && over(l, r, |l, r| self.eq_pat(l, r))\n-            }\n+            },\n             (&PatKind::Range(ref ls, ref le), &PatKind::Range(ref rs, ref re)) => {\n                 self.eq_expr(ls, rs) && self.eq_expr(le, re)\n-            }\n+            },\n             (&PatKind::Ref(ref le, ref lm), &PatKind::Ref(ref re, ref rm)) => lm == rm && self.eq_pat(le, re),\n             (&PatKind::Slice(ref ls, ref li, ref le), &PatKind::Slice(ref rs, ref ri, ref re)) => {\n                 over(ls, rs, |l, r| self.eq_pat(l, r)) && over(le, re, |l, r| self.eq_pat(l, r)) &&\n                 both(li, ri, |l, r| self.eq_pat(l, r))\n-            }\n+            },\n             (&PatKind::Wild, &PatKind::Wild) => true,\n             _ => false,\n         }\n@@ -188,8 +183,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n     }\n \n     fn eq_path(&self, left: &Path, right: &Path) -> bool {\n-        left.global == right.global &&\n-        over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r))\n+        left.global == right.global && over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r))\n     }\n \n     fn eq_path_parameters(&self, left: &PathParameters, right: &PathParameters) -> bool {\n@@ -198,35 +192,30 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                 over(&left.lifetimes, &right.lifetimes, |l, r| self.eq_lifetime(l, r)) &&\n                 over(&left.types, &right.types, |l, r| self.eq_ty(l, r)) &&\n                 over(&left.bindings, &right.bindings, |l, r| self.eq_type_binding(l, r))\n-            }\n+            },\n             (&ParenthesizedParameters(ref left), &ParenthesizedParameters(ref right)) => {\n                 over(&left.inputs, &right.inputs, |l, r| self.eq_ty(l, r)) &&\n                 both(&left.output, &right.output, |l, r| self.eq_ty(l, r))\n-            }\n+            },\n             (&AngleBracketedParameters(_), &ParenthesizedParameters(_)) |\n-            (&ParenthesizedParameters(_), &AngleBracketedParameters(_)) => {\n-                false\n-            }\n+            (&ParenthesizedParameters(_), &AngleBracketedParameters(_)) => false,\n         }\n     }\n \n     fn eq_path_segment(&self, left: &PathSegment, right: &PathSegment) -> bool {\n         // The == of idents doesn't work with different contexts,\n         // we have to be explicit about hygiene\n-        left.name.as_str() == right.name.as_str() &&\n-        self.eq_path_parameters(&left.parameters, &right.parameters)\n+        left.name.as_str() == right.name.as_str() && self.eq_path_parameters(&left.parameters, &right.parameters)\n     }\n \n     fn eq_ty(&self, left: &Ty, right: &Ty) -> bool {\n         match (&left.node, &right.node) {\n             (&TySlice(ref l_vec), &TySlice(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n-            (&TyArray(ref lt, ref ll), &TyArray(ref rt, ref rl)) => {\n-                self.eq_ty(lt, rt) && self.eq_expr(ll, rl)\n-            }\n+            (&TyArray(ref lt, ref ll), &TyArray(ref rt, ref rl)) => self.eq_ty(lt, rt) && self.eq_expr(ll, rl),\n             (&TyPtr(ref l_mut), &TyPtr(ref r_mut)) => l_mut.mutbl == r_mut.mutbl && self.eq_ty(&*l_mut.ty, &*r_mut.ty),\n             (&TyRptr(_, ref l_rmut), &TyRptr(_, ref r_rmut)) => {\n                 l_rmut.mutbl == r_rmut.mutbl && self.eq_ty(&*l_rmut.ty, &*r_rmut.ty)\n-            }\n+            },\n             (&TyPath(ref l), &TyPath(ref r)) => self.eq_qpath(l, r),\n             (&TyTup(ref l), &TyTup(ref r)) => over(l, r, |l, r| self.eq_ty(l, r)),\n             (&TyInfer, &TyInfer) => true,\n@@ -241,13 +230,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n \n fn swap_binop<'a>(binop: BinOp_, lhs: &'a Expr, rhs: &'a Expr) -> Option<(BinOp_, &'a Expr, &'a Expr)> {\n     match binop {\n-        BiAdd |\n-        BiMul |\n-        BiBitXor |\n-        BiBitAnd |\n-        BiEq |\n-        BiNe |\n-        BiBitOr => Some((binop, rhs, lhs)),\n+        BiAdd | BiMul | BiBitXor | BiBitAnd | BiEq | BiNe | BiBitOr => Some((binop, rhs, lhs)),\n         BiLt => Some((BiGt, rhs, lhs)),\n         BiLe => Some((BiGe, rhs, lhs)),\n         BiGe => Some((BiLe, rhs, lhs)),\n@@ -316,39 +299,39 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 c.hash(&mut self.s);\n                 m.hash(&mut self.s);\n                 self.hash_expr(e);\n-            }\n+            },\n             ExprAgain(i) => {\n                 let c: fn(_) -> _ = ExprAgain;\n                 c.hash(&mut self.s);\n                 if let Some(i) = i {\n                     self.hash_name(&i.name);\n                 }\n-            }\n+            },\n             ExprAssign(ref l, ref r) => {\n                 let c: fn(_, _) -> _ = ExprAssign;\n                 c.hash(&mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n-            }\n+            },\n             ExprAssignOp(ref o, ref l, ref r) => {\n                 let c: fn(_, _, _) -> _ = ExprAssignOp;\n                 c.hash(&mut self.s);\n                 o.hash(&mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n-            }\n+            },\n             ExprBlock(ref b) => {\n                 let c: fn(_) -> _ = ExprBlock;\n                 c.hash(&mut self.s);\n                 self.hash_block(b);\n-            }\n+            },\n             ExprBinary(op, ref l, ref r) => {\n                 let c: fn(_, _, _) -> _ = ExprBinary;\n                 c.hash(&mut self.s);\n                 op.node.hash(&mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n-            }\n+            },\n             ExprBreak(i, ref j) => {\n                 let c: fn(_, _) -> _ = ExprBreak;\n                 c.hash(&mut self.s);\n@@ -358,46 +341,46 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 if let Some(ref j) = *j {\n                     self.hash_expr(&*j);\n                 }\n-            }\n+            },\n             ExprBox(ref e) => {\n                 let c: fn(_) -> _ = ExprBox;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n-            }\n+            },\n             ExprCall(ref fun, ref args) => {\n                 let c: fn(_, _) -> _ = ExprCall;\n                 c.hash(&mut self.s);\n                 self.hash_expr(fun);\n                 self.hash_exprs(args);\n-            }\n+            },\n             ExprCast(ref e, ref _ty) => {\n                 let c: fn(_, _) -> _ = ExprCast;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 // TODO: _ty\n-            }\n+            },\n             ExprClosure(cap, _, eid, _) => {\n                 let c: fn(_, _, _, _) -> _ = ExprClosure;\n                 c.hash(&mut self.s);\n                 cap.hash(&mut self.s);\n                 self.hash_expr(self.cx.tcx.map.expr(eid));\n-            }\n+            },\n             ExprField(ref e, ref f) => {\n                 let c: fn(_, _) -> _ = ExprField;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 self.hash_name(&f.node);\n-            }\n+            },\n             ExprIndex(ref a, ref i) => {\n                 let c: fn(_, _) -> _ = ExprIndex;\n                 c.hash(&mut self.s);\n                 self.hash_expr(a);\n                 self.hash_expr(i);\n-            }\n+            },\n             ExprInlineAsm(..) => {\n                 let c: fn(_, _, _) -> _ = ExprInlineAsm;\n                 c.hash(&mut self.s);\n-            }\n+            },\n             ExprIf(ref cond, ref t, ref e) => {\n                 let c: fn(_, _, _) -> _ = ExprIf;\n                 c.hash(&mut self.s);\n@@ -406,20 +389,20 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 if let Some(ref e) = *e {\n                     self.hash_expr(e);\n                 }\n-            }\n+            },\n             ExprLit(ref l) => {\n                 let c: fn(_) -> _ = ExprLit;\n                 c.hash(&mut self.s);\n                 l.hash(&mut self.s);\n-            }\n+            },\n             ExprLoop(ref b, ref i, _) => {\n                 let c: fn(_, _, _) -> _ = ExprLoop;\n                 c.hash(&mut self.s);\n                 self.hash_block(b);\n                 if let Some(i) = *i {\n                     self.hash_name(&i.node);\n                 }\n-            }\n+            },\n             ExprMatch(ref e, ref arms, ref s) => {\n                 let c: fn(_, _, _) -> _ = ExprMatch;\n                 c.hash(&mut self.s);\n@@ -434,31 +417,31 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 }\n \n                 s.hash(&mut self.s);\n-            }\n+            },\n             ExprMethodCall(ref name, ref _tys, ref args) => {\n                 let c: fn(_, _, _) -> _ = ExprMethodCall;\n                 c.hash(&mut self.s);\n                 self.hash_name(&name.node);\n                 self.hash_exprs(args);\n-            }\n+            },\n             ExprRepeat(ref e, ref l) => {\n                 let c: fn(_, _) -> _ = ExprRepeat;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 self.hash_expr(l);\n-            }\n+            },\n             ExprRet(ref e) => {\n                 let c: fn(_) -> _ = ExprRet;\n                 c.hash(&mut self.s);\n                 if let Some(ref e) = *e {\n                     self.hash_expr(e);\n                 }\n-            }\n+            },\n             ExprPath(ref qpath) => {\n                 let c: fn(_) -> _ = ExprPath;\n                 c.hash(&mut self.s);\n                 self.hash_qpath(qpath);\n-            }\n+            },\n             ExprStruct(ref path, ref fields, ref expr) => {\n                 let c: fn(_, _, _) -> _ = ExprStruct;\n                 c.hash(&mut self.s);\n@@ -473,38 +456,38 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 if let Some(ref e) = *expr {\n                     self.hash_expr(e);\n                 }\n-            }\n+            },\n             ExprTup(ref tup) => {\n                 let c: fn(_) -> _ = ExprTup;\n                 c.hash(&mut self.s);\n                 self.hash_exprs(tup);\n-            }\n+            },\n             ExprTupField(ref le, li) => {\n                 let c: fn(_, _) -> _ = ExprTupField;\n                 c.hash(&mut self.s);\n \n                 self.hash_expr(le);\n                 li.node.hash(&mut self.s);\n-            }\n+            },\n             ExprType(ref e, ref _ty) => {\n                 let c: fn(_, _) -> _ = ExprType;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 // TODO: _ty\n-            }\n+            },\n             ExprUnary(lop, ref le) => {\n                 let c: fn(_, _) -> _ = ExprUnary;\n                 c.hash(&mut self.s);\n \n                 lop.hash(&mut self.s);\n                 self.hash_expr(le);\n-            }\n+            },\n             ExprArray(ref v) => {\n                 let c: fn(_) -> _ = ExprArray;\n                 c.hash(&mut self.s);\n \n                 self.hash_exprs(v);\n-            }\n+            },\n             ExprWhile(ref cond, ref b, l) => {\n                 let c: fn(_, _, _) -> _ = ExprWhile;\n                 c.hash(&mut self.s);\n@@ -514,7 +497,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 if let Some(l) = l {\n                     self.hash_name(&l.node);\n                 }\n-            }\n+            },\n         }\n     }\n \n@@ -532,12 +515,12 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n         match *p {\n             QPath::Resolved(_, ref path) => {\n                 self.hash_path(path);\n-            }\n+            },\n             QPath::TypeRelative(_, ref path) => {\n                 self.hash_name(&path.name);\n-            }\n+            },\n         }\n-        //self.cx.tcx.tables().qpath_def(p, id).hash(&mut self.s);\n+        // self.cx.tcx.tables().qpath_def(p, id).hash(&mut self.s);\n     }\n \n     pub fn hash_path(&mut self, p: &Path) {\n@@ -558,17 +541,17 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                         self.hash_expr(init);\n                     }\n                 }\n-            }\n+            },\n             StmtExpr(ref expr, _) => {\n                 let c: fn(_, _) -> _ = StmtExpr;\n                 c.hash(&mut self.s);\n                 self.hash_expr(expr);\n-            }\n+            },\n             StmtSemi(ref expr, _) => {\n                 let c: fn(_, _) -> _ = StmtSemi;\n                 c.hash(&mut self.s);\n                 self.hash_expr(expr);\n-            }\n+            },\n         }\n     }\n }"}, {"sha": "79cf15b6c5f5ebfd6328ab966b6aebe48549252d", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -67,25 +67,25 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             hir::ImplItemKind::Type(_) => println!(\"associated type\"),\n         }\n     }\n-/*\n-    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem) {\n-        if !has_attr(&item.attrs) {\n-            return;\n-        }\n-    }\n-\n-    fn check_variant(&mut self, cx: &LateContext<'a, 'tcx>, var: &'tcx hir::Variant, _: &hir::Generics) {\n-        if !has_attr(&var.node.attrs) {\n-            return;\n-        }\n-    }\n-\n-    fn check_struct_field(&mut self, cx: &LateContext<'a, 'tcx>, field: &'tcx hir::StructField) {\n-        if !has_attr(&field.attrs) {\n-            return;\n-        }\n-    }\n-*/\n+    // fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem) {\n+    // if !has_attr(&item.attrs) {\n+    // return;\n+    // }\n+    // }\n+    //\n+    // fn check_variant(&mut self, cx: &LateContext<'a, 'tcx>, var: &'tcx hir::Variant, _:\n+    // &hir::Generics) {\n+    // if !has_attr(&var.node.attrs) {\n+    // return;\n+    // }\n+    // }\n+    //\n+    // fn check_struct_field(&mut self, cx: &LateContext<'a, 'tcx>, field: &'tcx hir::StructField) {\n+    // if !has_attr(&field.attrs) {\n+    // return;\n+    // }\n+    // }\n+    //\n \n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         if !has_attr(&expr.attrs) {\n@@ -115,17 +115,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         }\n         match stmt.node {\n             hir::StmtDecl(ref decl, _) => print_decl(cx, decl),\n-            hir::StmtExpr(ref e, _) | hir::StmtSemi(ref e, _) => print_expr(cx, e, 0),\n-        }\n-    }\n-/*\n-\n-    fn check_foreign_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ForeignItem) {\n-        if !has_attr(&item.attrs) {\n-            return;\n+            hir::StmtExpr(ref e, _) |\n+            hir::StmtSemi(ref e, _) => print_expr(cx, e, 0),\n         }\n     }\n-*/\n+    // fn check_foreign_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ForeignItem) {\n+    // if !has_attr(&item.attrs) {\n+    // return;\n+    // }\n+    // }\n+    //\n }\n \n fn has_attr(attrs: &[Attribute]) -> bool {\n@@ -282,7 +281,7 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n         hir::ExprPath(hir::QPath::TypeRelative(ref ty, ref seg)) => {\n             println!(\"{}Relative Path, {:?}\", ind, ty);\n             println!(\"{}seg: {:?}\", ind, seg);\n-        }\n+        },\n         hir::ExprAddrOf(ref muta, ref e) => {\n             println!(\"{}AddrOf, {}\", ind, ty);\n             println!(\"mutability: {:?}\", muta);\n@@ -356,7 +355,7 @@ fn print_item(cx: &LateContext, item: &hir::Item) {\n             } else {\n                 println!(\"weird extern crate without a crate id\");\n             }\n-        }\n+        },\n         hir::ItemUse(ref path, ref kind) => println!(\"{:?}, {:?}\", path, kind),\n         hir::ItemStatic(..) => println!(\"static item of type {:#?}\", cx.tcx.item_type(did)),\n         hir::ItemConst(..) => println!(\"const item of type {:#?}\", cx.tcx.item_type(did)),"}, {"sha": "cf9e90d62bd4fa2e2760a90d6293f0025350d7a0", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -75,8 +75,8 @@ impl EarlyLintPass for Clippy {\n                                     span_lint(cx,\n                                               CLIPPY_LINTS_INTERNAL,\n                                               item.span,\n-                                              \"this constant should be before the previous constant due to lexical ordering\",\n-                                    );\n+                                              \"this constant should be before the previous constant due to lexical \\\n+                                               ordering\");\n                                 }\n                             }\n                             last_name = Some(name);\n@@ -110,7 +110,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LintWithoutLintPass {\n             if is_lint_ref_type(ty) {\n                 self.declared_lints.insert(item.name, item.span);\n             } else if is_lint_array_type(ty) && item.vis == Visibility::Inherited && item.name == \"ARRAY\" {\n-                let mut collector = LintCollector { output: &mut self.registered_lints, cx: cx };\n+                let mut collector = LintCollector {\n+                    output: &mut self.registered_lints,\n+                    cx: cx,\n+                };\n                 collector.visit_expr(expr);\n             }\n         }"}, {"sha": "77b33d7b58939b14652146a094042781f30a2d52", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 161, "deletions": 121, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -35,23 +35,27 @@ pub type MethodArgs = HirVec<P<Expr>>;\n \n /// Produce a nested chain of if-lets and ifs from the patterns:\n ///\n-///     if_let_chain! {[\n-///         let Some(y) = x,\n-///         y.len() == 2,\n-///         let Some(z) = y,\n-///     ], {\n-///         block\n-///     }}\n+/// ```rust,ignore\n+/// if_let_chain! {[\n+///     let Some(y) = x,\n+///     y.len() == 2,\n+///     let Some(z) = y,\n+/// ], {\n+///     block\n+/// }}\n+/// ```\n ///\n /// becomes\n ///\n-///     if let Some(y) = x {\n-///         if y.len() == 2 {\n-///             if let Some(z) = y {\n-///                 block\n-///             }\n+/// ```rust,ignore\n+/// if let Some(y) = x {\n+///     if y.len() == 2 {\n+///         if let Some(z) = y {\n+///             block\n ///         }\n ///     }\n+/// }\n+/// ```\n #[macro_export]\n macro_rules! if_let_chain {\n     ([let $pat:pat = $expr:expr, $($tt:tt)+], $block:block) => {\n@@ -95,15 +99,17 @@ pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n }\n /// Returns true if this `expn_info` was expanded by any macro.\n pub fn in_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n-    cx.sess().codemap().with_expn_info(span.expn_id, |info| match info {\n-        Some(info) => {\n-            match info.callee.format {\n-                // don't treat range expressions desugared to structs as \"in_macro\"\n-                ExpnFormat::CompilerDesugaring(name) => name != \"...\",\n-                _ => true,\n-            }\n-        },\n-        None => false,\n+    cx.sess().codemap().with_expn_info(span.expn_id, |info| {\n+        match info {\n+            Some(info) => {\n+                match info.callee.format {\n+                    // don't treat range expressions desugared to structs as \"in_macro\"\n+                    ExpnFormat::CompilerDesugaring(name) => name != \"...\",\n+                    _ => true,\n+                }\n+            },\n+            None => false,\n+        }\n     })\n }\n \n@@ -133,7 +139,7 @@ pub fn in_external_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n /// Check if a `DefId`'s path matches the given absolute type path usage.\n ///\n /// # Examples\n-/// ```\n+/// ```rust,ignore\n /// match_def_path(cx, id, &[\"core\", \"option\", \"Option\"])\n /// ```\n ///\n@@ -160,8 +166,7 @@ pub fn match_def_path(cx: &LateContext, def_id: DefId, path: &[&str]) -> bool {\n \n     cx.tcx.push_item_path(&mut apb, def_id);\n \n-    apb.names.len() == path.len() &&\n-    apb.names.iter().zip(path.iter()).all(|(a, &b)| &**a == b)\n+    apb.names.len() == path.len() && apb.names.iter().zip(path.iter()).all(|(a, &b)| &**a == b)\n }\n \n /// Check if type is struct, enum or union type with given def path.\n@@ -177,11 +182,11 @@ pub fn match_impl_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n     let method_call = ty::MethodCall::expr(expr.id);\n \n     let trt_id = cx.tcx\n-                   .tables\n-                   .borrow()\n-                   .method_map\n-                   .get(&method_call)\n-                   .and_then(|callee| cx.tcx.impl_of_method(callee.def_id));\n+        .tables\n+        .borrow()\n+        .method_map\n+        .get(&method_call)\n+        .and_then(|callee| cx.tcx.impl_of_method(callee.def_id));\n     if let Some(trt_id) = trt_id {\n         match_def_path(cx, trt_id, path)\n     } else {\n@@ -194,11 +199,11 @@ pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool\n     let method_call = ty::MethodCall::expr(expr.id);\n \n     let trt_id = cx.tcx\n-                   .tables\n-                   .borrow()\n-                   .method_map\n-                   .get(&method_call)\n-                   .and_then(|callee| cx.tcx.trait_of_item(callee.def_id));\n+        .tables\n+        .borrow()\n+        .method_map\n+        .get(&method_call)\n+        .and_then(|callee| cx.tcx.trait_of_item(callee.def_id));\n     if let Some(trt_id) = trt_id {\n         match_def_path(cx, trt_id, path)\n     } else {\n@@ -208,9 +213,11 @@ pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool\n \n pub fn last_path_segment(path: &QPath) -> &PathSegment {\n     match *path {\n-        QPath::Resolved(_, ref path) => path.segments\n-                                            .last()\n-                                            .expect(\"A path must have at least one segment\"),\n+        QPath::Resolved(_, ref path) => {\n+            path.segments\n+                .last()\n+                .expect(\"A path must have at least one segment\")\n+        },\n         QPath::TypeRelative(_, ref seg) => seg,\n     }\n }\n@@ -226,19 +233,20 @@ pub fn single_segment_path(path: &QPath) -> Option<&PathSegment> {\n /// Match a `Path` against a slice of segment string literals.\n ///\n /// # Examples\n-/// ```\n+/// ```rust,ignore\n /// match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])\n /// ```\n pub fn match_path(path: &QPath, segments: &[&str]) -> bool {\n     match *path {\n         QPath::Resolved(_, ref path) => match_path_old(path, segments),\n-        QPath::TypeRelative(ref ty, ref segment) => match ty.node {\n-            TyPath(ref inner_path) => {\n-                segments.len() > 0 &&\n-                match_path(inner_path, &segments[..(segments.len() - 1)]) &&\n-                segment.name == segments[segments.len() - 1]\n-            },\n-            _ => false,\n+        QPath::TypeRelative(ref ty, ref segment) => {\n+            match ty.node {\n+                TyPath(ref inner_path) => {\n+                    segments.len() > 0 && match_path(inner_path, &segments[..(segments.len() - 1)]) &&\n+                    segment.name == segments[segments.len() - 1]\n+                },\n+                _ => false,\n+            }\n         },\n     }\n }\n@@ -250,7 +258,7 @@ pub fn match_path_old(path: &Path, segments: &[&str]) -> bool {\n /// Match a `Path` against a slice of segment string literals, e.g.\n ///\n /// # Examples\n-/// ```\n+/// ```rust,ignore\n /// match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])\n /// ```\n pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n@@ -265,7 +273,10 @@ pub fn path_to_def(cx: &LateContext, path: &[&str]) -> Option<def::Def> {\n     let crates = cstore.crates();\n     let krate = crates.iter().find(|&&krate| cstore.crate_name(krate) == path[0]);\n     if let Some(krate) = krate {\n-        let krate = DefId { krate: *krate, index: CRATE_DEF_INDEX };\n+        let krate = DefId {\n+            krate: *krate,\n+            index: CRATE_DEF_INDEX,\n+        };\n         let mut items = cstore.item_children(krate);\n         let mut path_it = path.iter().skip(1).peekable();\n \n@@ -306,18 +317,17 @@ pub fn get_trait_def_id(cx: &LateContext, path: &[&str]) -> Option<DefId> {\n \n /// Check whether a type implements a trait.\n /// See also `get_trait_def_id`.\n-pub fn implements_trait<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>, trait_id: DefId,\n-                                  ty_params: Vec<ty::Ty<'tcx>>)\n-                                  -> bool {\n+pub fn implements_trait<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    ty: ty::Ty<'tcx>,\n+    trait_id: DefId,\n+    ty_params: Vec<ty::Ty<'tcx>>\n+) -> bool {\n     cx.tcx.populate_implementations_for_trait_if_necessary(trait_id);\n \n     let ty = cx.tcx.erase_regions(&ty);\n     cx.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n-        let obligation = cx.tcx.predicate_for_trait_def(traits::ObligationCause::dummy(),\n-                                                        trait_id,\n-                                                        0,\n-                                                        ty,\n-                                                        &ty_params);\n+        let obligation = cx.tcx.predicate_for_trait_def(traits::ObligationCause::dummy(), trait_id, 0, ty, &ty_params);\n \n         traits::SelectionContext::new(&infcx).evaluate_obligation_conservatively(&obligation)\n     })\n@@ -368,7 +378,7 @@ pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n /// Convert a span to a code snippet if available, otherwise use default.\n ///\n /// # Example\n-/// ```\n+/// ```rust,ignore\n /// snippet(cx, expr.span, \"..\")\n /// ```\n pub fn snippet<'a, 'b, T: LintContext<'b>>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n@@ -385,7 +395,7 @@ pub fn snippet_opt<'a, T: LintContext<'a>>(cx: &T, span: Span) -> Option<String>\n /// things which need to be printed as such.\n ///\n /// # Example\n-/// ```\n+/// ```rust,ignore\n /// snippet(cx, expr.span, \"..\")\n /// ```\n pub fn snippet_block<'a, 'b, T: LintContext<'b>>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n@@ -395,7 +405,12 @@ pub fn snippet_block<'a, 'b, T: LintContext<'b>>(cx: &T, span: Span, default: &'\n \n /// Like `snippet_block`, but add braces if the expr is not an `ExprBlock`.\n /// Also takes an `Option<String>` which can be put inside the braces.\n-pub fn expr_block<'a, 'b, T: LintContext<'b>>(cx: &T, expr: &Expr, option: Option<String>, default: &'a str) -> Cow<'a, str> {\n+pub fn expr_block<'a, 'b, T: LintContext<'b>>(\n+    cx: &T,\n+    expr: &Expr,\n+    option: Option<String>,\n+    default: &'a str\n+) -> Cow<'a, str> {\n     let code = snippet_block(cx, expr.span, default);\n     let string = option.unwrap_or_default();\n     if let ExprBlock(_) = expr.node {\n@@ -416,32 +431,32 @@ pub fn trim_multiline(s: Cow<str>, ignore_first: bool) -> Cow<str> {\n \n fn trim_multiline_inner(s: Cow<str>, ignore_first: bool, ch: char) -> Cow<str> {\n     let x = s.lines()\n-             .skip(ignore_first as usize)\n-             .filter_map(|l| {\n-                 if l.is_empty() {\n-                     None\n-                 } else {\n-                     // ignore empty lines\n-                     Some(l.char_indices()\n-                           .find(|&(_, x)| x != ch)\n-                           .unwrap_or((l.len(), ch))\n-                           .0)\n-                 }\n-             })\n-             .min()\n-             .unwrap_or(0);\n+        .skip(ignore_first as usize)\n+        .filter_map(|l| {\n+            if l.is_empty() {\n+                None\n+            } else {\n+                // ignore empty lines\n+                Some(l.char_indices()\n+                    .find(|&(_, x)| x != ch)\n+                    .unwrap_or((l.len(), ch))\n+                    .0)\n+            }\n+        })\n+        .min()\n+        .unwrap_or(0);\n     if x > 0 {\n         Cow::Owned(s.lines()\n-                    .enumerate()\n-                    .map(|(i, l)| {\n-                        if (ignore_first && i == 0) || l.is_empty() {\n-                            l\n-                        } else {\n-                            l.split_at(x).1\n-                        }\n-                    })\n-                    .collect::<Vec<_>>()\n-                    .join(\"\\n\"))\n+            .enumerate()\n+            .map(|(i, l)| {\n+                if (ignore_first && i == 0) || l.is_empty() {\n+                    l\n+                } else {\n+                    l.split_at(x).1\n+                }\n+            })\n+            .collect::<Vec<_>>()\n+            .join(\"\\n\"))\n     } else {\n         s\n     }\n@@ -467,7 +482,7 @@ pub fn get_parent_expr<'c>(cx: &'c LateContext, e: &Expr) -> Option<&'c Expr> {\n pub fn get_enclosing_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, node: NodeId) -> Option<&'tcx Block> {\n     let map = &cx.tcx.map;\n     let enclosing_node = map.get_enclosing_scope(node)\n-                            .and_then(|enclosing_id| map.find(enclosing_id));\n+        .and_then(|enclosing_id| map.find(enclosing_id));\n     if let Some(node) = enclosing_node {\n         match node {\n             Node::NodeBlock(block) => Some(block),\n@@ -476,7 +491,7 @@ pub fn get_enclosing_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, node: NodeI\n                     ExprBlock(ref block) => Some(block),\n                     _ => None,\n                 }\n-            }\n+            },\n             _ => None,\n         }\n     } else {\n@@ -496,7 +511,7 @@ impl<'a> DiagnosticWrapper<'a> {\n     fn wiki_link(&mut self, lint: &'static Lint) {\n         if env::var(\"CLIPPY_DISABLE_WIKI_LINKS\").is_err() {\n             self.0.help(&format!(\"for further information visit https://github.com/Manishearth/rust-clippy/wiki#{}\",\n-                               lint.name_lower()));\n+                                 lint.name_lower()));\n         }\n     }\n }\n@@ -508,7 +523,13 @@ pub fn span_lint<'a, T: LintContext<'a>>(cx: &T, lint: &'static Lint, sp: Span,\n     }\n }\n \n-pub fn span_help_and_lint<'a, 'tcx: 'a, T: LintContext<'tcx>>(cx: &'a T, lint: &'static Lint, span: Span, msg: &str, help: &str) {\n+pub fn span_help_and_lint<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n+    cx: &'a T,\n+    lint: &'static Lint,\n+    span: Span,\n+    msg: &str,\n+    help: &str\n+) {\n     let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, span, msg));\n     if cx.current_level(lint) != Level::Allow {\n         db.0.help(help);\n@@ -522,7 +543,7 @@ pub fn span_note_and_lint<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n     span: Span,\n     msg: &str,\n     note_span: Span,\n-    note: &str,\n+    note: &str\n ) {\n     let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, span, msg));\n     if cx.current_level(lint) != Level::Allow {\n@@ -535,8 +556,13 @@ pub fn span_note_and_lint<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n     }\n }\n \n-pub fn span_lint_and_then<'a, 'tcx: 'a, T: LintContext<'tcx>, F>(cx: &'a T, lint: &'static Lint, sp: Span, msg: &str, f: F)\n-    where F: for<'b> FnOnce(&mut DiagnosticBuilder<'b>)\n+pub fn span_lint_and_then<'a, 'tcx: 'a, T: LintContext<'tcx>, F>(\n+    cx: &'a T,\n+    lint: &'static Lint,\n+    sp: Span,\n+    msg: &str,\n+    f: F\n+) where F: for<'b> FnOnce(&mut DiagnosticBuilder<'b>)\n {\n     let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, sp, msg));\n     if cx.current_level(lint) != Level::Allow {\n@@ -652,9 +678,9 @@ fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'\n pub fn is_expn_of(cx: &LateContext, mut span: Span, name: &str) -> Option<Span> {\n     loop {\n         let span_name_span = cx.tcx\n-                               .sess\n-                               .codemap()\n-                               .with_expn_info(span.expn_id, |expn| expn.map(|ei| (ei.callee.name(), ei.call_site)));\n+            .sess\n+            .codemap()\n+            .with_expn_info(span.expn_id, |expn| expn.map(|ei| (ei.callee.name(), ei.call_site)));\n \n         match span_name_span {\n             Some((mac_name, new_span)) if mac_name == name => return Some(new_span),\n@@ -673,9 +699,9 @@ pub fn is_expn_of(cx: &LateContext, mut span: Span, name: &str) -> Option<Span>\n /// `is_direct_expn_of`.\n pub fn is_direct_expn_of(cx: &LateContext, span: Span, name: &str) -> Option<Span> {\n     let span_name_span = cx.tcx\n-                           .sess\n-                           .codemap()\n-                           .with_expn_info(span.expn_id, |expn| expn.map(|ei| (ei.callee.name(), ei.call_site)));\n+        .sess\n+        .codemap()\n+        .with_expn_info(span.expn_id, |expn| expn.map(|ei| (ei.callee.name(), ei.call_site)));\n \n     match span_name_span {\n         Some((mac_name, new_span)) if mac_name == name => Some(new_span),\n@@ -709,11 +735,7 @@ pub fn camel_case_until(s: &str) -> usize {\n             return i;\n         }\n     }\n-    if up {\n-        last_i\n-    } else {\n-        s.len()\n-    }\n+    if up { last_i } else { s.len() }\n }\n \n /// Return index of the last camel-case component of `s`.\n@@ -757,7 +779,12 @@ pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> ty::T\n /// Check if two types are the same.\n // FIXME: this works correctly for lifetimes bounds (`for <'a> Foo<'a>` == `for <'b> Foo<'b>` but\n // not for type parameters.\n-pub fn same_tys<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, a: ty::Ty<'tcx>, b: ty::Ty<'tcx>, parameter_item: NodeId) -> bool {\n+pub fn same_tys<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    a: ty::Ty<'tcx>,\n+    b: ty::Ty<'tcx>,\n+    parameter_item: NodeId\n+) -> bool {\n     let parameter_env = ty::ParameterEnvironment::for_item(cx.tcx, parameter_item);\n     cx.tcx.infer_ctxt(None, Some(parameter_env), Reveal::All).enter(|infcx| {\n         let new_a = a.subst(infcx.tcx, infcx.parameter_environment.free_substs);\n@@ -783,17 +810,21 @@ pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>, env: Node\n /// Return whether a pattern is refutable.\n pub fn is_refutable(cx: &LateContext, pat: &Pat) -> bool {\n     fn is_enum_variant(cx: &LateContext, qpath: &QPath, did: NodeId) -> bool {\n-        matches!(cx.tcx.tables().qpath_def(qpath, did), def::Def::Variant(..) | def::Def::VariantCtor(..))\n+        matches!(cx.tcx.tables().qpath_def(qpath, did),\n+                 def::Def::Variant(..) | def::Def::VariantCtor(..))\n     }\n \n-    fn are_refutable<'a, I: Iterator<Item=&'a Pat>>(cx: &LateContext, mut i: I) -> bool {\n+    fn are_refutable<'a, I: Iterator<Item = &'a Pat>>(cx: &LateContext, mut i: I) -> bool {\n         i.any(|pat| is_refutable(cx, pat))\n     }\n \n     match pat.node {\n-        PatKind::Binding(..) | PatKind::Wild => false,\n-        PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => is_refutable(cx, pat),\n-        PatKind::Lit(..) | PatKind::Range(..) => true,\n+        PatKind::Binding(..) |\n+        PatKind::Wild => false,\n+        PatKind::Box(ref pat) |\n+        PatKind::Ref(ref pat, _) => is_refutable(cx, pat),\n+        PatKind::Lit(..) |\n+        PatKind::Range(..) => true,\n         PatKind::Path(ref qpath) => is_enum_variant(cx, qpath, pat.id),\n         PatKind::Tuple(ref pats, _) => are_refutable(cx, pats.iter().map(|pat| &**pat)),\n         PatKind::Struct(ref qpath, ref fields, _) => {\n@@ -802,17 +833,17 @@ pub fn is_refutable(cx: &LateContext, pat: &Pat) -> bool {\n             } else {\n                 are_refutable(cx, fields.iter().map(|field| &*field.node.pat))\n             }\n-        }\n+        },\n         PatKind::TupleStruct(ref qpath, ref pats, _) => {\n             if is_enum_variant(cx, qpath, pat.id) {\n                 true\n             } else {\n                 are_refutable(cx, pats.iter().map(|pat| &**pat))\n             }\n-        }\n+        },\n         PatKind::Slice(ref head, ref middle, ref tail) => {\n             are_refutable(cx, head.iter().chain(middle).chain(tail.iter()).map(|pat| &**pat))\n-        }\n+        },\n     }\n }\n \n@@ -842,17 +873,26 @@ pub fn remove_blocks(expr: &Expr) -> &Expr {\n \n pub fn opt_def_id(def: Def) -> Option<DefId> {\n     match def {\n-        Def::Fn(id) | Def::Mod(id) | Def::Static(id, _) |\n-        Def::Variant(id) | Def::VariantCtor(id, ..) | Def::Enum(id) | Def::TyAlias(id) |\n-        Def::AssociatedTy(id) | Def::TyParam(id) | Def::Struct(id) | Def::StructCtor(id, ..) |\n-        Def::Union(id) | Def::Trait(id) | Def::Method(id) | Def::Const(id) |\n-        Def::AssociatedConst(id) | Def::Local(id) | Def::Upvar(id, ..) | Def::Macro(id) => {\n-            Some(id)\n-        }\n-\n-        Def::Label(..)  |\n-        Def::PrimTy(..) |\n-        Def::SelfTy(..) |\n-        Def::Err => None,\n+        Def::Fn(id) |\n+        Def::Mod(id) |\n+        Def::Static(id, _) |\n+        Def::Variant(id) |\n+        Def::VariantCtor(id, ..) |\n+        Def::Enum(id) |\n+        Def::TyAlias(id) |\n+        Def::AssociatedTy(id) |\n+        Def::TyParam(id) |\n+        Def::Struct(id) |\n+        Def::StructCtor(id, ..) |\n+        Def::Union(id) |\n+        Def::Trait(id) |\n+        Def::Method(id) |\n+        Def::Const(id) |\n+        Def::AssociatedConst(id) |\n+        Def::Local(id) |\n+        Def::Upvar(id, ..) |\n+        Def::Macro(id) => Some(id),\n+\n+        Def::Label(..) | Def::PrimTy(..) | Def::SelfTy(..) | Def::Err => None,\n     }\n }"}, {"sha": "e4938f1c1edc3f0b910f1003d4540d72d881cf2a", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 40, "deletions": 56, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -29,9 +29,9 @@ pub const ONE: Sugg<'static> = Sugg::NonParen(Cow::Borrowed(\"1\"));\n impl<'a> Display for Sugg<'a> {\n     fn fmt(&self, f: &mut std::fmt::Formatter) -> Result<(), std::fmt::Error> {\n         match *self {\n-            Sugg::NonParen(ref s) | Sugg::MaybeParen(ref s) | Sugg::BinOp(_, ref s) => {\n-                s.fmt(f)\n-            }\n+            Sugg::NonParen(ref s) |\n+            Sugg::MaybeParen(ref s) |\n+            Sugg::BinOp(_, ref s) => s.fmt(f),\n         }\n     }\n }\n@@ -168,10 +168,12 @@ impl<'a> Sugg<'a> {\n         match self {\n             Sugg::NonParen(..) => self,\n             // (x) and (x).y() both don't need additional parens\n-            Sugg::MaybeParen(sugg) => if sugg.starts_with('(') && sugg.ends_with(')') {\n-                Sugg::MaybeParen(sugg)\n-            } else {\n-                Sugg::NonParen(format!(\"({})\", sugg).into())\n+            Sugg::MaybeParen(sugg) => {\n+                if sugg.starts_with('(') && sugg.ends_with(')') {\n+                    Sugg::MaybeParen(sugg)\n+                } else {\n+                    Sugg::NonParen(format!(\"({})\", sugg).into())\n+                }\n             },\n             Sugg::BinOp(_, sugg) => Sugg::NonParen(format!(\"({})\", sugg).into()),\n         }\n@@ -247,18 +249,17 @@ pub fn make_assoc(op: AssocOp, lhs: &Sugg, rhs: &Sugg) -> Sugg<'static> {\n \n     /// Whether the operator is a arithmetic operator (`+`, `-`, `*`, `/`, `%`).\n     fn is_arith(op: &AssocOp) -> bool {\n-        matches!(*op, AssocOp::Add | AssocOp::Subtract | AssocOp::Multiply | AssocOp::Divide | AssocOp::Modulus)\n+        matches!(*op,\n+                 AssocOp::Add | AssocOp::Subtract | AssocOp::Multiply | AssocOp::Divide | AssocOp::Modulus)\n     }\n \n     /// Whether the operator `op` needs parenthesis with the operator `other` in the direction\n     /// `dir`.\n     fn needs_paren(op: &AssocOp, other: &AssocOp, dir: Associativity) -> bool {\n         other.precedence() < op.precedence() ||\n-            (other.precedence() == op.precedence() &&\n-                ((op != other && associativity(op) != dir) ||\n-                 (op == other && associativity(op) != Associativity::Both))) ||\n-             is_shift(op) && is_arith(other) ||\n-             is_shift(other) && is_arith(op)\n+        (other.precedence() == op.precedence() &&\n+         ((op != other && associativity(op) != dir) || (op == other && associativity(op) != Associativity::Both))) ||\n+        is_shift(op) && is_arith(other) || is_shift(other) && is_arith(op)\n     }\n \n     let lhs_paren = if let Sugg::BinOp(ref lop, _) = *lhs {\n@@ -276,24 +277,12 @@ pub fn make_assoc(op: AssocOp, lhs: &Sugg, rhs: &Sugg) -> Sugg<'static> {\n     let lhs = ParenHelper::new(lhs_paren, lhs);\n     let rhs = ParenHelper::new(rhs_paren, rhs);\n     let sugg = match op {\n-        AssocOp::Add |\n-        AssocOp::BitAnd |\n-        AssocOp::BitOr |\n-        AssocOp::BitXor |\n-        AssocOp::Divide |\n-        AssocOp::Equal |\n-        AssocOp::Greater |\n-        AssocOp::GreaterEqual |\n-        AssocOp::LAnd |\n-        AssocOp::LOr |\n-        AssocOp::Less |\n-        AssocOp::LessEqual |\n-        AssocOp::Modulus |\n-        AssocOp::Multiply |\n-        AssocOp::NotEqual |\n-        AssocOp::ShiftLeft |\n-        AssocOp::ShiftRight |\n-        AssocOp::Subtract => format!(\"{} {} {}\", lhs, op.to_ast_binop().expect(\"Those are AST ops\").to_string(), rhs),\n+        AssocOp::Add | AssocOp::BitAnd | AssocOp::BitOr | AssocOp::BitXor | AssocOp::Divide | AssocOp::Equal |\n+        AssocOp::Greater | AssocOp::GreaterEqual | AssocOp::LAnd | AssocOp::LOr | AssocOp::Less |\n+        AssocOp::LessEqual | AssocOp::Modulus | AssocOp::Multiply | AssocOp::NotEqual | AssocOp::ShiftLeft |\n+        AssocOp::ShiftRight | AssocOp::Subtract => {\n+            format!(\"{} {} {}\", lhs, op.to_ast_binop().expect(\"Those are AST ops\").to_string(), rhs)\n+        },\n         AssocOp::Inplace => format!(\"in ({}) {}\", lhs, rhs),\n         AssocOp::Assign => format!(\"{} = {}\", lhs, rhs),\n         AssocOp::AssignOp(op) => format!(\"{} {}= {}\", lhs, binop_to_string(op), rhs),\n@@ -335,11 +324,10 @@ fn associativity(op: &AssocOp) -> Associativity {\n \n     match *op {\n         Inplace | Assign | AssignOp(_) => Associativity::Right,\n-        Add | BitAnd | BitOr | BitXor | LAnd | LOr | Multiply |\n-        As | Colon => Associativity::Both,\n-    Divide | Equal | Greater | GreaterEqual | Less | LessEqual | Modulus | NotEqual | ShiftLeft |\n-        ShiftRight | Subtract => Associativity::Left,\n-        DotDot | DotDotDot => Associativity::None\n+        Add | BitAnd | BitOr | BitXor | LAnd | LOr | Multiply | As | Colon => Associativity::Both,\n+        Divide | Equal | Greater | GreaterEqual | Less | LessEqual | Modulus | NotEqual | ShiftLeft | ShiftRight |\n+        Subtract => Associativity::Left,\n+        DotDot | DotDotDot => Associativity::None,\n     }\n }\n \n@@ -410,18 +398,18 @@ pub trait DiagnosticBuilderExt<'a, T: LintContext<'a>> {\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n+    /// ```rust,ignore\n     /// db.suggest_item_with_attr(cx, item, \"#[derive(Default)]\");\n     /// ```\n-    fn suggest_item_with_attr<D: Display+?Sized>(&mut self, cx: &T, item: Span, msg: &str, attr: &D);\n+    fn suggest_item_with_attr<D: Display + ?Sized>(&mut self, cx: &T, item: Span, msg: &str, attr: &D);\n \n     /// Suggest to add an item before another.\n     ///\n     /// The item should not be indented (expect for inner indentation).\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n+    /// ```rust,ignore\n     /// db.suggest_prepend_item(cx, item,\n     /// \"fn foo() {\n     ///     bar();\n@@ -431,33 +419,29 @@ pub trait DiagnosticBuilderExt<'a, T: LintContext<'a>> {\n }\n \n impl<'a, 'b, 'c, T: LintContext<'c>> DiagnosticBuilderExt<'c, T> for rustc_errors::DiagnosticBuilder<'b> {\n-    fn suggest_item_with_attr<D: Display+?Sized>(&mut self, cx: &T, item: Span, msg: &str, attr: &D) {\n+    fn suggest_item_with_attr<D: Display + ?Sized>(&mut self, cx: &T, item: Span, msg: &str, attr: &D) {\n         if let Some(indent) = indentation(cx, item) {\n-            let span = Span {\n-                hi: item.lo,\n-                ..item\n-            };\n+            let span = Span { hi: item.lo, ..item };\n \n             self.span_suggestion(span, msg, format!(\"{}\\n{}\", attr, indent));\n         }\n     }\n \n     fn suggest_prepend_item(&mut self, cx: &T, item: Span, msg: &str, new_item: &str) {\n         if let Some(indent) = indentation(cx, item) {\n-            let span = Span {\n-                hi: item.lo,\n-                ..item\n-            };\n+            let span = Span { hi: item.lo, ..item };\n \n             let mut first = true;\n-            let new_item = new_item.lines().map(|l| {\n-                if first {\n-                    first = false;\n-                    format!(\"{}\\n\", l)\n-                } else {\n-                    format!(\"{}{}\\n\", indent, l)\n-                }\n-            }).collect::<String>();\n+            let new_item = new_item.lines()\n+                .map(|l| {\n+                    if first {\n+                        first = false;\n+                        format!(\"{}\\n\", l)\n+                    } else {\n+                        format!(\"{}{}\\n\", indent, l)\n+                    }\n+                })\n+                .collect::<String>();\n \n             self.span_suggestion(span, msg, format!(\"{}\\n{}\", new_item, indent));\n         }"}, {"sha": "dd3d4d261d053a26bc25a166e66b0a878afc70c9", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -65,7 +65,7 @@ fn check_vec_macro(cx: &LateContext, vec_args: &higher::VecArgs, span: Span) {\n             } else {\n                 return;\n             }\n-        }\n+        },\n         higher::VecArgs::Vec(args) => {\n             if let Some(last) = args.iter().last() {\n                 let span = Span {\n@@ -78,7 +78,7 @@ fn check_vec_macro(cx: &LateContext, vec_args: &higher::VecArgs, span: Span) {\n             } else {\n                 \"&[]\".into()\n             }\n-        }\n+        },\n     };\n \n     span_lint_and_then(cx, USELESS_VEC, span, \"useless use of `vec!`\", |db| {"}, {"sha": "18d146d49173afa0aa52acb60cb7d51a1e245569", "filename": "rustfmt.toml", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt.toml?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -1,6 +1,8 @@\n max_width = 120\n ideal_width = 100\n-fn_args_density = \"Compressed\"\n fn_call_width = 80\n-fn_args_paren_newline = false\n match_block_trailing_comma = true\n+fn_args_layout = \"Block\"\n+closure_block_indent_threshold = 0\n+fn_return_indent = \"WithWhereClause\"\n+wrap_comments = true"}, {"sha": "0b91c79d21bc3fcb14c04ff6928cf3ffc81ea7d1", "filename": "src/main.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/src%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/src%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -38,19 +38,35 @@ impl ClippyCompilerCalls {\n }\n \n impl<'a> CompilerCalls<'a> for ClippyCompilerCalls {\n-    fn early_callback(&mut self, matches: &getopts::Matches, sopts: &config::Options, cfg: &ast::CrateConfig,\n-                      descriptions: &rustc_errors::registry::Registry, output: ErrorOutputType)\n-                      -> Compilation {\n+    fn early_callback(\n+        &mut self,\n+        matches: &getopts::Matches,\n+        sopts: &config::Options,\n+        cfg: &ast::CrateConfig,\n+        descriptions: &rustc_errors::registry::Registry,\n+        output: ErrorOutputType\n+    ) -> Compilation {\n         self.default.early_callback(matches, sopts, cfg, descriptions, output)\n     }\n-    fn no_input(&mut self, matches: &getopts::Matches, sopts: &config::Options, cfg: &ast::CrateConfig,\n-                odir: &Option<PathBuf>, ofile: &Option<PathBuf>, descriptions: &rustc_errors::registry::Registry)\n-                -> Option<(Input, Option<PathBuf>)> {\n+    fn no_input(\n+        &mut self,\n+        matches: &getopts::Matches,\n+        sopts: &config::Options,\n+        cfg: &ast::CrateConfig,\n+        odir: &Option<PathBuf>,\n+        ofile: &Option<PathBuf>,\n+        descriptions: &rustc_errors::registry::Registry\n+    ) -> Option<(Input, Option<PathBuf>)> {\n         self.default.no_input(matches, sopts, cfg, odir, ofile, descriptions)\n     }\n-    fn late_callback(&mut self, matches: &getopts::Matches, sess: &Session, input: &Input, odir: &Option<PathBuf>,\n-                     ofile: &Option<PathBuf>)\n-                     -> Compilation {\n+    fn late_callback(\n+        &mut self,\n+        matches: &getopts::Matches,\n+        sess: &Session,\n+        input: &Input,\n+        odir: &Option<PathBuf>,\n+        ofile: &Option<PathBuf>\n+    ) -> Compilation {\n         self.default.late_callback(matches, sess, input, odir, ofile)\n     }\n     fn build_controller(&mut self, sess: &Session, matches: &getopts::Matches) -> driver::CompileController<'a> {"}, {"sha": "81cb658df8dea25f24c09e7baf43cbc6e9a6ac91", "filename": "tests/compile-fail/absurd-extreme-comparisons.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/tests%2Fcompile-fail%2Fabsurd-extreme-comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/tests%2Fcompile-fail%2Fabsurd-extreme-comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fabsurd-extreme-comparisons.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -9,7 +9,7 @@ fn main() {\n     let u: u32 = 42;\n \n     u <= 0;\n-    //~^ ERROR this comparison involving the minimum or maximum element for this type contains a case that is always true or always false\n+    //~^ ERROR this comparison involving the minimum or maximum element for this type contains a\n     //~| HELP using u == 0 instead\n     u <= Z;\n     //~^ ERROR this comparison involving\n@@ -41,10 +41,10 @@ fn main() {\n         //~| HELP because 1-1 is the minimum value for this type, this comparison is always false\n     u >= !0;\n         //~^ ERROR this comparison involving\n-        //~| HELP because !0 is the maximum value for this type, the case where the two sides are not equal never occurs, consider using u == !0 instead\n+        //~| HELP consider using u == !0 instead\n     u <= 12 - 2*6;\n         //~^ ERROR this comparison involving\n-        //~| HELP because 12 - 2*6 is the minimum value for this type, the case where the two sides are not equal never occurs, consider using u == 12 - 2*6 instead\n+        //~| HELP consider using u == 12 - 2*6 instead\n \n     let i: i8 = 0;\n     i < -127 - 1;"}, {"sha": "090c39abc9268aa1a3af0e728d8a9baf98e8d3b9", "filename": "tests/compile-fail/block_in_if_condition.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/tests%2Fcompile-fail%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/tests%2Fcompile-fail%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fblock_in_if_condition.rs?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -21,13 +21,13 @@ macro_rules! blocky_too {\n fn macro_if() {\n     if blocky!() {\n     }\n-    \n+\n     if blocky_too!() {\n     }\n }\n \n fn condition_has_block() -> i32 {\n-    if { //~ERROR in an 'if' condition, avoid complex blocks or closures with blocks; instead, move the block or closure higher and bind it with a 'let'\n+    if { //~ERROR in an 'if' condition, avoid complex blocks or closures with blocks;\n         let x = 3;\n         x == 3\n     } {\n@@ -55,12 +55,12 @@ fn pred_test() {\n     // this is a sneaky case, where the block isn't directly in the condition, but is actually\n     // inside a closure that the condition is using.  same principle applies.  add some extra\n     // expressions to make sure linter isn't confused by them.\n-    if v == 3 && sky == \"blue\" && predicate(|x| { let target = 3; x == target }, v) { //~ERROR in an 'if' condition, avoid complex blocks or closures with blocks; instead, move the block or closure higher and bind it with a 'let'\n-\n+    if v == 3 && sky == \"blue\" && predicate(|x| { let target = 3; x == target }, v) {\n+        //~^ERROR in an 'if' condition, avoid complex blocks or closures with blocks;\n     }\n \n-    if predicate(|x| { let target = 3; x == target }, v) { //~ERROR in an 'if' condition, avoid complex blocks or closures with blocks; instead, move the block or closure higher and bind it with a 'let'\n-\n+    if predicate(|x| { let target = 3; x == target }, v) {\n+        //~^ERROR in an 'if' condition, avoid complex blocks or closures with blocks;\n     }\n \n }"}, {"sha": "ddb5d3ab32fde89986ce758e56419b04de3bde19", "filename": "util/update_lints.py", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/util%2Fupdate_lints.py", "raw_url": "https://github.com/rust-lang/rust/raw/647b30884d8ec6dbdc4f07d80c5c39eacfb0c061/util%2Fupdate_lints.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fupdate_lints.py?ref=647b30884d8ec6dbdc4f07d80c5c39eacfb0c061", "patch": "@@ -98,7 +98,10 @@ def gen_deprecated(lints):\n     \"\"\"Declare deprecated lints\"\"\"\n \n     for lint in lints:\n-        yield '    store.register_removed(\"%s\", \"%s\");\\n' % (lint[1], lint[2])\n+        yield '    store.register_removed(\\n'\n+        yield '        \"%s\",\\n' % lint[1]\n+        yield '        \"%s\",\\n' % lint[2]\n+        yield '    );\\n'\n \n \n def replace_region(fn, region_start, region_end, callback,"}]}