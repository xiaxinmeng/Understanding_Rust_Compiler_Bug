{"sha": "542bf8d50ee9edc7754b3977407880640fc0bd68", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0MmJmOGQ1MGVlOWVkYzc3NTRiMzk3NzQwNzg4MDY0MGZjMGJkNjg=", "commit": {"author": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-15T07:22:50Z"}, "committer": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-15T07:56:15Z"}, "message": "misc: fix check for unit body in \"match -> if let\" lint (fixes #172)", "tree": {"sha": "b6828000147755fb25d56eeaf527d6ccbaf132a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6828000147755fb25d56eeaf527d6ccbaf132a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/542bf8d50ee9edc7754b3977407880640fc0bd68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/542bf8d50ee9edc7754b3977407880640fc0bd68", "html_url": "https://github.com/rust-lang/rust/commit/542bf8d50ee9edc7754b3977407880640fc0bd68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/542bf8d50ee9edc7754b3977407880640fc0bd68/comments", "author": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1920cb21c77a21f6409bf9b29d0df7394a1b4d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1920cb21c77a21f6409bf9b29d0df7394a1b4d5", "html_url": "https://github.com/rust-lang/rust/commit/b1920cb21c77a21f6409bf9b29d0df7394a1b4d5"}], "stats": {"total": 77, "additions": 49, "deletions": 28}, "files": [{"sha": "091ea36f2f55a6515e8e681c9618f39f04cbf26a", "filename": "src/misc.rs", "status": "modified", "additions": 37, "deletions": 28, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/542bf8d50ee9edc7754b3977407880640fc0bd68/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542bf8d50ee9edc7754b3977407880640fc0bd68/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=542bf8d50ee9edc7754b3977407880640fc0bd68", "patch": "@@ -6,6 +6,7 @@ use syntax::visit::{FnKind};\n use rustc::lint::{Context, LintPass, LintArray, Lint, Level};\n use rustc::middle::ty;\n use syntax::codemap::{Span, Spanned};\n+use std::borrow::Cow;\n \n use utils::{match_path, snippet, snippet_block, span_lint, span_help_and_lint, walk_ptrs_ty};\n \n@@ -26,39 +27,47 @@ impl LintPass for MiscPass {\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n         if let ExprMatch(ref ex, ref arms, ast::MatchSource::Normal) = expr.node {\n-            if arms.len() == 2 {\n-                if arms[0].guard.is_none() && arms[1].pats.len() == 1 {\n-                    match arms[1].body.node {\n-                        ExprTup(ref v) if v.is_empty() && arms[1].guard.is_none() => (),\n-                        ExprBlock(ref b) if b.stmts.is_empty() && arms[1].guard.is_none() => (),\n-                         _ => return\n-                    }\n-                    // In some cases, an exhaustive match is preferred to catch situations when\n-                    // an enum is extended. So we only consider cases where a `_` wildcard is used\n-                    if arms[1].pats[0].node == PatWild(PatWildSingle) &&\n-                            arms[0].pats.len() == 1 {\n-                        let body_code = snippet_block(cx, arms[0].body.span, \"..\");\n-                        let suggestion = if let ExprBlock(_) = arms[0].body.node {\n-                            body_code.into_owned()\n-                        } else {\n-                            format!(\"{{ {} }}\", body_code)\n-                        };\n-                        span_help_and_lint(cx, SINGLE_MATCH, expr.span,\n-                              \"you seem to be trying to use match for \\\n-                              destructuring a single pattern. Did you mean to \\\n-                              use `if let`?\",\n-                              &*format!(\"try\\nif let {} = {} {}\",\n-                                        snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                        snippet(cx, ex.span, \"..\"),\n-                                        suggestion)\n-                        );\n-                    }\n-                }\n+            // check preconditions: only two arms\n+            if arms.len() == 2 &&\n+                // both of the arms have a single pattern and no guard\n+                arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n+                arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n+                // and the second pattern is a `_` wildcard: this is not strictly necessary,\n+                // since the exhaustiveness check will ensure the last one is a catch-all,\n+                // but in some cases, an explicit match is preferred to catch situations\n+                // when an enum is extended, so we don't consider these cases\n+                arms[1].pats[0].node == PatWild(PatWildSingle) &&\n+                // finally, we don't want any content in the second arm (unit or empty block)\n+                is_unit_expr(&*arms[1].body)\n+            {\n+                let body_code = snippet_block(cx, arms[0].body.span, \"..\");\n+                let body_code = if let ExprBlock(_) = arms[0].body.node {\n+                    body_code\n+                } else {\n+                    Cow::Owned(format!(\"{{ {} }}\", body_code))\n+                };\n+                span_help_and_lint(cx, SINGLE_MATCH, expr.span,\n+                      \"you seem to be trying to use match for \\\n+                      destructuring a single pattern. Did you mean to \\\n+                      use `if let`?\",\n+                      &*format!(\"try\\nif let {} = {} {}\",\n+                                snippet(cx, arms[0].pats[0].span, \"..\"),\n+                                snippet(cx, ex.span, \"..\"),\n+                                body_code)\n+                );\n             }\n         }\n     }\n }\n \n+fn is_unit_expr(expr: &Expr) -> bool {\n+    match expr.node {\n+        ExprTup(ref v) if v.is_empty() => true,\n+        ExprBlock(ref b) if b.stmts.is_empty() && b.expr.is_none() => true,\n+        _ => false,\n+    }\n+}\n+\n \n declare_lint!(pub TOPLEVEL_REF_ARG, Warn,\n               \"a function argument is declared `ref` (i.e. `fn foo(ref x: u8)`, but not \\"}, {"sha": "bf2e7e43a529e52233d5087e695968f13a9b62a0", "filename": "tests/compile-fail/match_if_let.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/542bf8d50ee9edc7754b3977407880640fc0bd68/tests%2Fcompile-fail%2Fmatch_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542bf8d50ee9edc7754b3977407880640fc0bd68/tests%2Fcompile-fail%2Fmatch_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmatch_if_let.rs?ref=542bf8d50ee9edc7754b3977407880640fc0bd68", "patch": "@@ -23,4 +23,16 @@ fn main(){\n         (2...3, 7...9) => println!(\"{:?}\", z),\n         _ => {}\n     }\n+\n+    // Not linted (pattern guards used)\n+    match x {\n+        Some(y) if y == 0 => println!(\"{:?}\", y),\n+        _ => ()\n+    }\n+\n+    // Not linted (content in the else)\n+    match z {\n+        (2...3, 7...9) => println!(\"{:?}\", z),\n+        _ => println!(\"nope\"),\n+    }\n }"}]}