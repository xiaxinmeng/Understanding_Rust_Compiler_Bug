{"sha": "51dfba1185104a64157235dc771953c21d89a284", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxZGZiYTExODUxMDRhNjQxNTcyMzVkYzc3MTk1M2MyMWQ4OWEyODQ=", "commit": {"author": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-13T23:45:09Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:02:50Z"}, "message": "Refactor Vec<CleanupScope> into Option<CleanupScope>.", "tree": {"sha": "a3fd870f516874db9ee0afffbacb92c448ee7db4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3fd870f516874db9ee0afffbacb92c448ee7db4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51dfba1185104a64157235dc771953c21d89a284", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51dfba1185104a64157235dc771953c21d89a284", "html_url": "https://github.com/rust-lang/rust/commit/51dfba1185104a64157235dc771953c21d89a284", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51dfba1185104a64157235dc771953c21d89a284/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91707dc9911d9e10193faaa87e47ea8cb0592818", "url": "https://api.github.com/repos/rust-lang/rust/commits/91707dc9911d9e10193faaa87e47ea8cb0592818", "html_url": "https://github.com/rust-lang/rust/commit/91707dc9911d9e10193faaa87e47ea8cb0592818"}], "stats": {"total": 362, "additions": 128, "deletions": 234}, "files": [{"sha": "0d455d037de9b73b0ba552511241cd966dc4b03d", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51dfba1185104a64157235dc771953c21d89a284/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dfba1185104a64157235dc771953c21d89a284/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=51dfba1185104a64157235dc771953c21d89a284", "patch": "@@ -765,7 +765,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n             funclet_arena: TypedArena::new(),\n             ccx: ccx,\n             debug_context: debug_context,\n-            scopes: RefCell::new(Vec::new()),\n+            cleanup_scope: RefCell::new(None),\n         }\n     }\n "}, {"sha": "f772ff68ac948e0837788a193e2c1c949c6fcbd2", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51dfba1185104a64157235dc771953c21d89a284/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dfba1185104a64157235dc771953c21d89a284/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=51dfba1185104a64157235dc771953c21d89a284", "patch": "@@ -392,9 +392,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let self_scope = fcx.schedule_drop_mem(llenv, closure_ty);\n \n     let bcx = callee.call(bcx, &llargs[self_idx..], dest, None).0;\n-\n-    let bcx = fcx.pop_and_trans_custom_cleanup_scope(bcx, self_scope);\n-\n+    fcx.pop_and_trans_custom_cleanup_scope(&bcx, self_scope);\n     fcx.finish(&bcx);\n \n     ccx.instances().borrow_mut().insert(method_instance, lloncefn);"}, {"sha": "8952fe9d8b8fedc8f42b6765264300f456977914", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 94, "deletions": 185, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/51dfba1185104a64157235dc771953c21d89a284/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dfba1185104a64157235dc771953c21d89a284/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=51dfba1185104a64157235dc771953c21d89a284", "patch": "@@ -152,27 +152,21 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n     /// Removes the top cleanup scope from the stack, which must be a temporary scope, and\n     /// generates the code to do its cleanups for normal exit.\n     pub fn pop_and_trans_custom_cleanup_scope(&self,\n-                                              bcx: BlockAndBuilder<'blk, 'tcx>,\n-                                              custom_scope: Option<CustomScopeIndex>)\n-                                              -> BlockAndBuilder<'blk, 'tcx> {\n+                                              bcx: &BlockAndBuilder<'blk, 'tcx>,\n+                                              custom_scope: Option<()>) {\n         debug!(\"pop_and_trans_custom_cleanup_scope({:?})\", custom_scope);\n \n-        let custom_scope = if let Some(scope) = custom_scope {\n-            scope\n-        } else {\n-            return bcx;\n-        };\n-\n-        assert!(self.is_valid_custom_scope(custom_scope));\n-        assert!(custom_scope.index == self.scopes.borrow().len() - 1);\n+        if custom_scope.is_none() {\n+            return;\n+        }\n \n         let scope = self.pop_scope();\n-        scope.cleanup.trans(bcx.funclet(), bcx)\n+        scope.cleanup.trans(bcx.funclet(), &bcx);\n     }\n \n     /// Schedules a (deep) drop of `val`, which is a pointer to an instance of\n     /// `ty`\n-    pub fn schedule_drop_mem(&self, val: ValueRef, ty: Ty<'tcx>) -> Option<CustomScopeIndex> {\n+    pub fn schedule_drop_mem(&self, val: ValueRef, ty: Ty<'tcx>) -> Option<()> {\n         if !self.type_needs_drop(ty) { return None; }\n         let drop = DropValue {\n             val: val,\n@@ -182,16 +176,15 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n \n         debug!(\"schedule_drop_mem(val={:?}, ty={:?}) skip_dtor={}\", Value(val), ty, drop.skip_dtor);\n \n-        Some(self.push_scope(CleanupScope::new(drop)))\n+        Some(self.set_scope(CleanupScope::new(drop)))\n     }\n \n     /// Issue #23611: Schedules a (deep) drop of the contents of\n     /// `val`, which is a pointer to an instance of struct/enum type\n     /// `ty`. The scheduled code handles extracting the discriminant\n     /// and dropping the contents associated with that variant\n     /// *without* executing any associated drop implementation.\n-    pub fn schedule_drop_adt_contents(&self, val: ValueRef, ty: Ty<'tcx>)\n-        -> Option<CustomScopeIndex> {\n+    pub fn schedule_drop_adt_contents(&self, val: ValueRef, ty: Ty<'tcx>) -> Option<()> {\n         // `if` below could be \"!contents_needs_drop\"; skipping drop\n         // is just an optimization, so sound to be conservative.\n         if !self.type_needs_drop(ty) { return None; }\n@@ -207,15 +200,15 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n                ty,\n                drop.skip_dtor);\n \n-        Some(self.push_scope(CleanupScope::new(drop)))\n+        Some(self.set_scope(CleanupScope::new(drop)))\n     }\n \n     /// Returns true if there are pending cleanups that should execute on panic.\n     pub fn needs_invoke(&self, lpad_present: bool) -> bool {\n         if self.ccx.sess().no_landing_pads() || lpad_present {\n             false\n         } else {\n-            self.scopes_len() > 0\n+            self.has_scope()\n         }\n     }\n \n@@ -228,14 +221,14 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n     /// (The cleanups and resume instruction are created by\n     /// `trans_cleanups_to_exit_scope()`, not in this function itself.)\n     pub fn get_landing_pad(&'blk self) -> BasicBlockRef {\n-        let pad_bcx;\n+        let mut pad_bcx;\n \n         debug!(\"get_landing_pad\");\n \n         // Check if a landing pad block exists; if not, create one.\n         {\n-            let mut scopes = self.scopes.borrow_mut();\n-            let last_scope = scopes.last_mut().unwrap();\n+            let mut last_scope = self.cleanup_scope.borrow_mut();\n+            let mut last_scope = last_scope.as_mut().unwrap();\n             match last_scope.cached_landing_pad {\n                 Some(llbb) => return llbb,\n                 None => {\n@@ -286,165 +279,94 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n \n         // Generate the cleanup block and branch to it.\n         let cleanup_llbb = self.trans_cleanups_to_exit_scope(val);\n-        val.branch(&pad_bcx, cleanup_llbb);\n+        val.branch(&mut pad_bcx, cleanup_llbb);\n \n         return pad_bcx.llbb();\n     }\n \n-    fn is_valid_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool {\n-        let scopes = self.scopes.borrow();\n-        custom_scope.index < scopes.len()\n-    }\n-\n-    fn scopes_len(&self) -> usize {\n-        self.scopes.borrow().len()\n+    fn has_scope(&self) -> bool {\n+        self.cleanup_scope.borrow().is_some()\n     }\n \n-    fn push_scope(&self, scope: CleanupScope<'tcx>) -> CustomScopeIndex {\n-        assert!(self.scopes_len() == 0);\n-        let index = self.scopes_len();\n-        debug!(\"pushing custom cleanup scope: {}\", index);\n-        self.scopes.borrow_mut().push(scope);\n-        CustomScopeIndex { index: index }\n+    fn set_scope(&self, scope: CleanupScope<'tcx>) {\n+        assert!(self.cleanup_scope.borrow().is_none());\n+        *self.cleanup_scope.borrow_mut() = Some(scope);\n     }\n \n     fn pop_scope(&self) -> CleanupScope<'tcx> {\n-        debug!(\"popping cleanup scope {}, {} scopes remaining\",\n-               self.top_scope(|s| s.block_name(\"\")),\n-               self.scopes_len() - 1);\n-\n-        self.scopes.borrow_mut().pop().unwrap()\n+        debug!(\"took cleanup scope {}\", self.top_scope(|s| s.block_name(\"\")));\n+        self.cleanup_scope.borrow_mut().take().unwrap()\n     }\n \n     fn top_scope<R, F>(&self, f: F) -> R where F: FnOnce(&CleanupScope<'tcx>) -> R {\n-        f(self.scopes.borrow().last().unwrap())\n+        f(self.cleanup_scope.borrow().as_ref().unwrap())\n+    }\n+\n+    fn generate_resume_block(&self, label: UnwindKind) -> BasicBlockRef {\n+        // Generate a block that will resume unwinding to the calling function\n+        let bcx = self.build_new_block(\"resume\");\n+        match label {\n+            UnwindKind::LandingPad => {\n+                let addr = self.landingpad_alloca.get().unwrap();\n+                let lp = bcx.load(addr);\n+                Lifetime::End.call(&bcx, addr);\n+                if !bcx.sess().target.target.options.custom_unwind_resume {\n+                    bcx.resume(lp);\n+                } else {\n+                    let exc_ptr = bcx.extract_value(lp, 0);\n+                    bcx.call(bcx.fcx().eh_unwind_resume().reify(bcx.ccx()), &[exc_ptr], None);\n+                }\n+            }\n+            UnwindKind::CleanupPad(_) => {\n+                bcx.cleanup_ret(bcx.cleanup_pad(None, &[]), None);\n+            }\n+        }\n+        bcx.llbb()\n     }\n \n     /// Used when the caller wishes to jump to an early exit, such as a return,\n     /// break, continue, or unwind. This function will generate all cleanups\n     /// between the top of the stack and the exit `label` and return a basic\n     /// block that the caller can branch to.\n-    ///\n-    /// For example, if the current stack of cleanups were as follows:\n-    ///\n-    ///      AST 22\n-    ///      Custom 1\n-    ///      AST 23\n-    ///      Loop 23\n-    ///      Custom 2\n-    ///      AST 24\n-    ///\n-    /// and the `label` specifies a break from `Loop 23`, then this function\n-    /// would generate a series of basic blocks as follows:\n-    ///\n-    ///      Cleanup(AST 24) -> Cleanup(Custom 2) -> break_blk\n-    ///\n-    /// where `break_blk` is the block specified in `Loop 23` as the target for\n-    /// breaks. The return value would be the first basic block in that sequence\n-    /// (`Cleanup(AST 24)`). The caller could then branch to `Cleanup(AST 24)`\n-    /// and it will perform all cleanups and finally branch to the `break_blk`.\n     fn trans_cleanups_to_exit_scope(&'blk self, label: UnwindKind) -> BasicBlockRef {\n-        debug!(\"trans_cleanups_to_exit_scope label={:?} scopes={}\", label, self.scopes_len());\n-\n-        let orig_scopes_len = self.scopes_len();\n-        let mut prev_llbb;\n-        let mut popped_scopes = vec![];\n-\n-        // First we pop off all the cleanup stacks that are\n-        // traversed until the exit is reached, pushing them\n-        // onto the side vector `popped_scopes`. No code is\n-        // generated at this time.\n-        //\n-        // So, continuing the example from above, we would wind up\n-        // with a `popped_scopes` vector of `[AST 24, Custom 2]`.\n-        // (Presuming that there are no cached exits)\n-        loop {\n-            if self.scopes_len() == 0 {\n-                // Generate a block that will resume unwinding to the\n-                // calling function\n-                let bcx = self.build_new_block(\"resume\");\n-                match label {\n-                    UnwindKind::LandingPad => {\n-                        let addr = self.landingpad_alloca.get().unwrap();\n-                        let lp = bcx.load(addr);\n-                        Lifetime::End.call(&bcx, addr);\n-                        if !bcx.sess().target.target.options.custom_unwind_resume {\n-                            bcx.resume(lp);\n-                        } else {\n-                            let exc_ptr = bcx.extract_value(lp, 0);\n-                            bcx.call(\n-                                bcx.fcx().eh_unwind_resume().reify(bcx.ccx()),\n-                                &[exc_ptr],\n-                                bcx.funclet().map(|b| b.bundle()));\n-                        }\n-                    }\n-                    UnwindKind::CleanupPad(_) => {\n-                        let pad = bcx.cleanup_pad(None, &[]);\n-                        bcx.cleanup_ret(pad, None);\n-                    }\n-                }\n-                prev_llbb = bcx.llbb();\n-                break;\n-            }\n+        debug!(\"trans_cleanups_to_exit_scope label={:?} has_scope={}\", label, self.has_scope());\n \n-            // Pop off the scope, since we may be generating\n-            // unwinding code for it.\n-            let top_scope = self.pop_scope();\n-            let cached_exit = top_scope.cached_early_exit(label);\n-            popped_scopes.push(top_scope);\n-\n-            // Check if we have already cached the unwinding of this\n-            // scope for this label. If so, we can stop popping scopes\n-            // and branch to the cached label, since it contains the\n-            // cleanups for any subsequent scopes.\n-            if let Some(exit) = cached_exit {\n-                prev_llbb = exit;\n-                break;\n-            }\n+        // If there is no current scope, then there are no cleanups to run, so we should\n+        // simply generate a resume block which will branch to the label.\n+        if !self.has_scope() {\n+            debug!(\"trans_cleanups_to_exit_scope: returning new block scope\");\n+            return self.generate_resume_block(label);\n         }\n \n-        debug!(\"trans_cleanups_to_exit_scope: popped {} scopes\",\n-               popped_scopes.len());\n-\n-        // Now push the popped scopes back on. As we go,\n-        // we track in `prev_llbb` the exit to which this scope\n-        // should branch when it's done.\n-        //\n-        // So, continuing with our example, we will start out with\n-        // `prev_llbb` being set to `break_blk` (or possibly a cached\n-        // early exit). We will then pop the scopes from `popped_scopes`\n-        // and generate a basic block for each one, prepending it in the\n-        // series and updating `prev_llbb`. So we begin by popping `Custom 2`\n-        // and generating `Cleanup(Custom 2)`. We make `Cleanup(Custom 2)`\n-        // branch to `prev_llbb == break_blk`, giving us a sequence like:\n-        //\n-        //     Cleanup(Custom 2) -> prev_llbb\n-        //\n-        // We then pop `AST 24` and repeat the process, giving us the sequence:\n-        //\n-        //     Cleanup(AST 24) -> Cleanup(Custom 2) -> prev_llbb\n-        //\n-        // At this point, `popped_scopes` is empty, and so the final block\n-        // that we return to the user is `Cleanup(AST 24)`.\n-        while let Some(mut scope) = popped_scopes.pop() {\n-            let name = scope.block_name(\"clean\");\n-            debug!(\"generating cleanup for {}\", name);\n-\n-            let bcx_in = self.build_new_block(&name[..]);\n-            let exit_label = label.start(&bcx_in);\n-            let next_llbb = bcx_in.llbb();\n-            let bcx_out = scope.cleanup.trans(bcx_in.funclet(), bcx_in);\n-            exit_label.branch(&bcx_out, prev_llbb);\n-            prev_llbb = next_llbb;\n-\n-            scope.add_cached_early_exit(exit_label, prev_llbb);\n-            self.push_scope(scope);\n-        }\n+        // Pop off the scope, since we may be generating unwinding code for it.\n+        let mut scope = self.pop_scope();\n+        let cached_exit = scope.cached_early_exit(label);\n+\n+        // Check if we have already cached the unwinding of this\n+        // scope for this label. If so, we can just branch to the cached block.\n+        let exit_llbb = cached_exit.unwrap_or_else(|| self.generate_resume_block(label));\n+\n+        let name = scope.block_name(\"clean\");\n+        debug!(\"generating cleanup for {}\", name);\n+\n+        let mut cleanup = self.build_new_block(&name[..]);\n+\n+        // Insert cleanup instructions into the cleanup block\n+        scope.cleanup.trans(label.get_funclet(&cleanup).as_ref(), &cleanup);\n+\n+        // Insert instruction into cleanup block to branch to the exit\n+        label.branch(&mut cleanup, exit_llbb);\n+\n+        // Cache the work we've done here\n+        // FIXME: Can this get called more than once per scope? If not, no need to cache.\n+        scope.add_cached_early_exit(label, cleanup.llbb());\n+\n+        // Put the scope back\n+        self.set_scope(scope);\n \n-        debug!(\"trans_cleanups_to_exit_scope: prev_llbb={:?}\", prev_llbb);\n+        debug!(\"trans_cleanups_to_exit_scope: llbb={:?}\", cleanup.llbb());\n \n-        assert_eq!(self.scopes_len(), orig_scopes_len);\n-        prev_llbb\n+        cleanup.llbb()\n     }\n }\n \n@@ -483,42 +405,30 @@ impl<'tcx> CleanupScope<'tcx> {\n }\n \n impl UnwindKind {\n-    /// Generates a branch going from `from_bcx` to `to_llbb` where `self` is\n-    /// the exit label attached to the start of `from_bcx`.\n+    /// Generates a branch going from `bcx` to `to_llbb` where `self` is\n+    /// the exit label attached to the start of `bcx`.\n     ///\n     /// Transitions from an exit label to other exit labels depend on the type\n     /// of label. For example with MSVC exceptions unwind exit labels will use\n     /// the `cleanupret` instruction instead of the `br` instruction.\n-    fn branch(&self, from_bcx: &BlockAndBuilder, to_llbb: BasicBlockRef) {\n-        if let UnwindKind::CleanupPad(pad) = *self {\n-            from_bcx.cleanup_ret(pad, Some(to_llbb));\n-        } else {\n-            from_bcx.br(to_llbb);\n+    fn branch(&self, bcx: &BlockAndBuilder, to_llbb: BasicBlockRef) {\n+        match *self {\n+            UnwindKind::CleanupPad(pad) => {\n+                bcx.cleanup_ret(pad, Some(to_llbb));\n+            }\n+            UnwindKind::LandingPad => {\n+                bcx.br(to_llbb);\n+            }\n         }\n     }\n \n-    /// Generates the necessary instructions at the start of `bcx` to prepare\n-    /// for the same kind of early exit label that `self` is.\n-    ///\n-    /// This function will appropriately configure `bcx` based on the kind of\n-    /// label this is. For UnwindExit labels, the `funclet` field of the block will\n-    /// be set to `Some`, and for MSVC exceptions this function will generate a\n-    /// `cleanuppad` instruction at the start of the block so it may be jumped\n-    /// to in the future (e.g. so this block can be cached as an early exit).\n-    ///\n-    /// Returns a new label which will can be used to cache `bcx` in the list of\n-    /// early exits.\n-    fn start(&self, bcx: &BlockAndBuilder) -> UnwindKind {\n+    fn get_funclet(&self, bcx: &BlockAndBuilder) -> Option<Funclet> {\n         match *self {\n-            UnwindKind::CleanupPad(..) => {\n+            UnwindKind::CleanupPad(_) => {\n                 let pad = bcx.cleanup_pad(None, &[]);\n-                bcx.set_funclet(Funclet::msvc(pad));\n-                UnwindKind::CleanupPad(pad)\n-            }\n-            UnwindKind::LandingPad => {\n-                bcx.set_funclet(Funclet::gnu());\n-                *self\n-            }\n+                Funclet::msvc(pad)\n+            },\n+            UnwindKind::LandingPad => Funclet::gnu(),\n         }\n     }\n }\n@@ -544,8 +454,7 @@ pub struct DropValue<'tcx> {\n }\n \n impl<'tcx> DropValue<'tcx> {\n-    fn trans<'blk>(&self, funclet: Option<&'blk Funclet>, bcx: BlockAndBuilder<'blk, 'tcx>)\n-        -> BlockAndBuilder<'blk, 'tcx> {\n+    fn trans<'blk>(&self, funclet: Option<&'blk Funclet>, bcx: &BlockAndBuilder<'blk, 'tcx>) {\n         glue::call_drop_glue(bcx, self.val, self.ty, self.skip_dtor, funclet)\n     }\n }"}, {"sha": "0ef56895ecea6cc87d81077653f1e9da9ece9be1", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/51dfba1185104a64157235dc771953c21d89a284/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dfba1185104a64157235dc771953c21d89a284/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=51dfba1185104a64157235dc771953c21d89a284", "patch": "@@ -317,7 +317,7 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     pub debug_context: debuginfo::FunctionDebugContext,\n \n     // Cleanup scopes.\n-    pub scopes: RefCell<Vec<cleanup::CleanupScope<'tcx>>>,\n+    pub cleanup_scope: RefCell<Option<cleanup::CleanupScope<'tcx>>>,\n }\n \n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n@@ -483,7 +483,7 @@ pub struct BlockAndBuilder<'blk, 'tcx: 'blk> {\n \n     // If this block part of a landing pad, then this is `Some` indicating what\n     // kind of landing pad its in, otherwise this is none.\n-    funclet: Cell<Option<&'blk Funclet>>,\n+    funclet: Option<&'blk Funclet>,\n \n     // The function context for the function to which this block is\n     // attached.\n@@ -499,7 +499,7 @@ impl<'blk, 'tcx> BlockAndBuilder<'blk, 'tcx> {\n         owned_builder.builder.position_at_end(llbb);\n         BlockAndBuilder {\n             llbb: llbb,\n-            funclet: Cell::new(None),\n+            funclet: None,\n             fcx: fcx,\n             owned_builder: owned_builder,\n         }\n@@ -535,17 +535,17 @@ impl<'blk, 'tcx> BlockAndBuilder<'blk, 'tcx> {\n         self.fcx.mir()\n     }\n \n-    pub fn set_funclet(&self, funclet: Option<Funclet>) {\n-        self.set_funclet_ref(funclet.map(|p| &*self.fcx().funclet_arena.alloc(p)))\n+    pub fn set_funclet(&mut self, funclet: Option<Funclet>) {\n+        self.funclet = funclet.map(|p| &*self.fcx().funclet_arena.alloc(p));\n     }\n \n-    pub fn set_funclet_ref(&self, funclet: Option<&'blk Funclet>) {\n+    pub fn set_funclet_ref(&mut self, funclet: Option<&'blk Funclet>) {\n         // FIXME: use an IVar?\n-        self.funclet.set(funclet);\n+        self.funclet = funclet;\n     }\n \n     pub fn funclet(&self) -> Option<&'blk Funclet> {\n-        self.funclet.get()\n+        self.funclet\n     }\n }\n "}, {"sha": "1265381ff21d5baf2c2bbb688e8861bd21449d23", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 19, "deletions": 30, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/51dfba1185104a64157235dc771953c21d89a284/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dfba1185104a64157235dc771953c21d89a284/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=51dfba1185104a64157235dc771953c21d89a284", "patch": "@@ -120,21 +120,17 @@ pub fn get_drop_glue_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn drop_ty<'blk, 'tcx>(\n-    bcx: BlockAndBuilder<'blk, 'tcx>,\n-    v: ValueRef,\n-    t: Ty<'tcx>,\n-) -> BlockAndBuilder<'blk, 'tcx> {\n+fn drop_ty<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>, v: ValueRef, t: Ty<'tcx>) {\n     call_drop_glue(bcx, v, t, false, None)\n }\n \n pub fn call_drop_glue<'blk, 'tcx>(\n-    bcx: BlockAndBuilder<'blk, 'tcx>,\n+    bcx: &BlockAndBuilder<'blk, 'tcx>,\n     v: ValueRef,\n     t: Ty<'tcx>,\n     skip_dtor: bool,\n     funclet: Option<&'blk Funclet>,\n-) -> BlockAndBuilder<'blk, 'tcx> {\n+) {\n     // NB: v is an *alias* of type t here, not a direct value.\n     debug!(\"call_drop_glue(t={:?}, skip_dtor={})\", t, skip_dtor);\n     let _icx = push_ctxt(\"drop_ty\");\n@@ -156,7 +152,6 @@ pub fn call_drop_glue<'blk, 'tcx>(\n         // No drop-hint ==> call standard drop glue\n         bcx.call(glue, &[ptr], funclet.map(|b| b.bundle()));\n     }\n-    bcx\n }\n \n pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> ValueRef {\n@@ -235,7 +230,6 @@ fn trans_custom_dtor<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n {\n     debug!(\"trans_custom_dtor t: {}\", t);\n     let tcx = bcx.tcx();\n-    let mut bcx = bcx;\n \n     let def = t.ty_adt_def().unwrap();\n \n@@ -275,9 +269,9 @@ fn trans_custom_dtor<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n         _ => bug!(\"dtor for {:?} is not an impl???\", t)\n     };\n     let dtor_did = def.destructor().unwrap();\n-    bcx = Callee::def(bcx.ccx(), dtor_did, vtbl.substs).call(bcx, args, None, None).0;\n-\n-    bcx.fcx().pop_and_trans_custom_cleanup_scope(bcx, contents_scope)\n+    let bcx = Callee::def(bcx.ccx(), dtor_did, vtbl.substs).call(bcx, args, None, None).0;\n+    bcx.fcx().pop_and_trans_custom_cleanup_scope(&bcx, contents_scope);\n+    bcx\n }\n \n pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n@@ -411,7 +405,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n             if !type_is_sized(bcx.tcx(), content_ty) {\n                 let llval = get_dataptr(&bcx, v0);\n                 let llbox = bcx.load(llval);\n-                let bcx = drop_ty(bcx, v0, content_ty);\n+                drop_ty(&bcx, v0, content_ty);\n                 // FIXME(#36457) -- we should pass unsized values to drop glue as two arguments\n                 let info = get_meta(&bcx, v0);\n                 let info = bcx.load(info);\n@@ -429,7 +423,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n             } else {\n                 let llval = v0;\n                 let llbox = bcx.load(llval);\n-                let bcx = drop_ty(bcx, llbox, content_ty);\n+                drop_ty(&bcx, llbox, content_ty);\n                 trans_exchange_free_ty(bcx, llbox, content_ty)\n             }\n         }\n@@ -468,22 +462,18 @@ fn drop_structural_ty<'blk, 'tcx>(cx: BlockAndBuilder<'blk, 'tcx>,\n                                   -> BlockAndBuilder<'blk, 'tcx> {\n     let _icx = push_ctxt(\"drop_structural_ty\");\n \n-    fn iter_variant<'blk, 'tcx>(cx: BlockAndBuilder<'blk, 'tcx>,\n+    fn iter_variant<'blk, 'tcx>(cx: &BlockAndBuilder<'blk, 'tcx>,\n                                 t: Ty<'tcx>,\n                                 av: adt::MaybeSizedValue,\n                                 variant: &'tcx ty::VariantDef,\n-                                substs: &Substs<'tcx>)\n-                                -> BlockAndBuilder<'blk, 'tcx> {\n+                                substs: &Substs<'tcx>) {\n         let _icx = push_ctxt(\"iter_variant\");\n         let tcx = cx.tcx();\n-        let mut cx = cx;\n-\n         for (i, field) in variant.fields.iter().enumerate() {\n             let arg = monomorphize::field_ty(tcx, substs, field);\n             let field_ptr = adt::trans_field_ptr(&cx, t, av, Disr::from(variant.disr_val), i);\n-            cx = drop_ty(cx, field_ptr, arg);\n+            drop_ty(&cx, field_ptr, arg);\n         }\n-        return cx;\n     }\n \n     let value = if type_is_sized(cx.tcx(), t) {\n@@ -500,25 +490,24 @@ fn drop_structural_ty<'blk, 'tcx>(cx: BlockAndBuilder<'blk, 'tcx>,\n         ty::TyClosure(def_id, substs) => {\n             for (i, upvar_ty) in substs.upvar_tys(def_id, cx.tcx()).enumerate() {\n                 let llupvar = adt::trans_field_ptr(&cx, t, value, Disr(0), i);\n-                cx = drop_ty(cx, llupvar, upvar_ty);\n+                drop_ty(&cx, llupvar, upvar_ty);\n             }\n         }\n         ty::TyArray(_, n) => {\n             let base = get_dataptr(&cx, value.value);\n             let len = C_uint(cx.ccx(), n);\n             let unit_ty = t.sequence_element_type(cx.tcx());\n-            cx = tvec::slice_for_each(cx, base, unit_ty, len,\n-                |bb, vv| drop_ty(bb, vv, unit_ty));\n+            cx = tvec::slice_for_each(&cx, base, unit_ty, len, |bb, vv| drop_ty(bb, vv, unit_ty));\n         }\n         ty::TySlice(_) | ty::TyStr => {\n             let unit_ty = t.sequence_element_type(cx.tcx());\n-            cx = tvec::slice_for_each(cx, value.value, unit_ty, value.meta,\n+            cx = tvec::slice_for_each(&cx, value.value, unit_ty, value.meta,\n                 |bb, vv| drop_ty(bb, vv, unit_ty));\n         }\n         ty::TyTuple(ref args) => {\n             for (i, arg) in args.iter().enumerate() {\n                 let llfld_a = adt::trans_field_ptr(&cx, t, value, Disr(0), i);\n-                cx = drop_ty(cx, llfld_a, *arg);\n+                drop_ty(&cx, llfld_a, *arg);\n             }\n         }\n         ty::TyAdt(adt, substs) => match adt.adt_kind() {\n@@ -536,7 +525,7 @@ fn drop_structural_ty<'blk, 'tcx>(cx: BlockAndBuilder<'blk, 'tcx>,\n                         cx.store(value.meta, get_meta(&cx, scratch));\n                         scratch\n                     };\n-                    cx = drop_ty(cx, val, field_ty);\n+                    drop_ty(&cx, val, field_ty);\n                 }\n             }\n             AdtKind::Union => {\n@@ -554,13 +543,13 @@ fn drop_structural_ty<'blk, 'tcx>(cx: BlockAndBuilder<'blk, 'tcx>,\n                     (adt::BranchKind::Single, None) => {\n                         if n_variants != 0 {\n                             assert!(n_variants == 1);\n-                            cx = iter_variant(cx, t, adt::MaybeSizedValue::sized(av),\n+                            iter_variant(&cx, t, adt::MaybeSizedValue::sized(av),\n                                             &adt.variants[0], substs);\n                         }\n                     }\n                     (adt::BranchKind::Switch, Some(lldiscrim_a)) => {\n                         let tcx = cx.tcx();\n-                        cx = drop_ty(cx, lldiscrim_a, tcx.types.isize);\n+                        drop_ty(&cx, lldiscrim_a, tcx.types.isize);\n \n                         // Create a fall-through basic block for the \"else\" case of\n                         // the switch instruction we're about to generate. Note that\n@@ -586,7 +575,7 @@ fn drop_structural_ty<'blk, 'tcx>(cx: BlockAndBuilder<'blk, 'tcx>,\n                             let variant_cx = fcx.build_new_block(&variant_cx_name);\n                             let case_val = adt::trans_case(&cx, t, Disr::from(variant.disr_val));\n                             variant_cx.add_case(llswitch, case_val, variant_cx.llbb());\n-                            let variant_cx = iter_variant(variant_cx, t, value, variant, substs);\n+                            iter_variant(&variant_cx, t, value, variant, substs);\n                             variant_cx.br(next_cx.llbb());\n                         }\n                         cx = next_cx;"}, {"sha": "31cbc4074b206d071ad323fcd8bede37c55604fb", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51dfba1185104a64157235dc771953c21d89a284/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dfba1185104a64157235dc771953c21d89a284/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=51dfba1185104a64157235dc771953c21d89a284", "patch": "@@ -98,11 +98,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let size = count.value.as_u64(bcx.tcx().sess.target.uint_type);\n                 let size = C_uint(bcx.ccx(), size);\n                 let base = base::get_dataptr(&bcx, dest.llval);\n-                let bcx = tvec::slice_for_each(bcx, base, tr_elem.ty, size, |bcx, llslot| {\n+                tvec::slice_for_each(&bcx, base, tr_elem.ty, size, |bcx, llslot| {\n                     self.store_operand_direct(&bcx, llslot, tr_elem);\n-                    bcx\n-                });\n-                bcx\n+                })\n             }\n \n             mir::Rvalue::Aggregate(ref kind, ref operands) => {"}, {"sha": "6519d372c72c4815f5b7d78d7d7ef359fdc26565", "filename": "src/librustc_trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51dfba1185104a64157235dc771953c21d89a284/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51dfba1185104a64157235dc771953c21d89a284/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=51dfba1185104a64157235dc771953c21d89a284", "patch": "@@ -16,13 +16,13 @@ use base::*;\n use common::*;\n use rustc::ty::Ty;\n \n-pub fn slice_for_each<'blk, 'tcx, F>(bcx: BlockAndBuilder<'blk, 'tcx>,\n+pub fn slice_for_each<'blk, 'tcx, F>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                                      data_ptr: ValueRef,\n                                      unit_ty: Ty<'tcx>,\n                                      len: ValueRef,\n                                      f: F)\n                                      -> BlockAndBuilder<'blk, 'tcx>\n-    where F: FnOnce(BlockAndBuilder<'blk, 'tcx>, ValueRef) -> BlockAndBuilder<'blk, 'tcx>,\n+    where F: FnOnce(&BlockAndBuilder<'blk, 'tcx>, ValueRef)\n {\n     let _icx = push_ctxt(\"tvec::slice_for_each\");\n     let fcx = bcx.fcx();\n@@ -52,7 +52,7 @@ pub fn slice_for_each<'blk, 'tcx, F>(bcx: BlockAndBuilder<'blk, 'tcx>,\n     let keep_going = header_bcx.icmp(llvm::IntNE, current, end);\n     header_bcx.cond_br(keep_going, body_bcx.llbb(), next_bcx.llbb());\n \n-    let body_bcx = f(body_bcx, if zst { data_ptr } else { current });\n+    f(&body_bcx, if zst { data_ptr } else { current });\n     // FIXME(simulacrum): The code below is identical to the closure (add) above, but using the\n     // closure doesn't compile due to body_bcx still being borrowed when dropped.\n     let next = if zst {"}]}