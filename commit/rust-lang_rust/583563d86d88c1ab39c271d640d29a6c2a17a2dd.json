{"sha": "583563d86d88c1ab39c271d640d29a6c2a17a2dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4MzU2M2Q4NmQ4OGMxYWIzOWMyNzFkNjQwZDI5YTZjMmExN2EyZGQ=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-02-11T19:37:36Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-02-11T19:37:36Z"}, "message": "clean up clean::Static struct", "tree": {"sha": "aba3a0e2ef185988cd952796cd971df4025c3f87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aba3a0e2ef185988cd952796cd971df4025c3f87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/583563d86d88c1ab39c271d640d29a6c2a17a2dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/583563d86d88c1ab39c271d640d29a6c2a17a2dd", "html_url": "https://github.com/rust-lang/rust/commit/583563d86d88c1ab39c271d640d29a6c2a17a2dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/583563d86d88c1ab39c271d640d29a6c2a17a2dd/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "323fb7113bc64886205047c97423882a7f8162f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/323fb7113bc64886205047c97423882a7f8162f2", "html_url": "https://github.com/rust-lang/rust/commit/323fb7113bc64886205047c97423882a7f8162f2"}], "stats": {"total": 134, "additions": 63, "deletions": 71}, "files": [{"sha": "cacca542284d96285b28e93ba34f79af1ad2d0dc", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/583563d86d88c1ab39c271d640d29a6c2a17a2dd/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/583563d86d88c1ab39c271d640d29a6c2a17a2dd/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=583563d86d88c1ab39c271d640d29a6c2a17a2dd", "patch": "@@ -510,7 +510,7 @@ fn build_static(cx: &DocContext<'_>, did: DefId, mutable: bool) -> clean::Static\n     clean::Static {\n         type_: cx.tcx.type_of(did).clean(cx),\n         mutability: if mutable { Mutability::Mut } else { Mutability::Not },\n-        expr: \"\\n\\n\\n\".to_string(), // trigger the \"[definition]\" links\n+        expr: None,\n     }\n }\n "}, {"sha": "10080a8d522b247e2d68a0de39e4f0fd0c1db45c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/583563d86d88c1ab39c271d640d29a6c2a17a2dd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/583563d86d88c1ab39c271d640d29a6c2a17a2dd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=583563d86d88c1ab39c271d640d29a6c2a17a2dd", "patch": "@@ -408,7 +408,7 @@ impl Clean<Constant> for hir::ConstArg {\n                 .tcx\n                 .type_of(cx.tcx.hir().body_owner_def_id(self.value.body).to_def_id())\n                 .clean(cx),\n-            expr: print_const_expr(cx, self.value.body),\n+            expr: print_const_expr(cx.tcx, self.value.body),\n             value: None,\n             is_literal: is_literal_expr(cx, self.value.body.hir_id),\n         }\n@@ -1052,7 +1052,7 @@ impl Clean<Item> for hir::TraitItem<'_> {\n         cx.with_param_env(local_did, || {\n             let inner = match self.kind {\n                 hir::TraitItemKind::Const(ref ty, default) => {\n-                    AssocConstItem(ty.clean(cx), default.map(|e| print_const_expr(cx, e)))\n+                    AssocConstItem(ty.clean(cx), default.map(|e| print_const_expr(cx.tcx, e)))\n                 }\n                 hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n                     let mut m = (sig, &self.generics, body).clean(cx);\n@@ -1093,7 +1093,7 @@ impl Clean<Item> for hir::ImplItem<'_> {\n         cx.with_param_env(local_did, || {\n             let inner = match self.kind {\n                 hir::ImplItemKind::Const(ref ty, expr) => {\n-                    AssocConstItem(ty.clean(cx), Some(print_const_expr(cx, expr)))\n+                    AssocConstItem(ty.clean(cx), Some(print_const_expr(cx.tcx, expr)))\n                 }\n                 hir::ImplItemKind::Fn(ref sig, body) => {\n                     let mut m = (sig, &self.generics, body).clean(cx);\n@@ -1954,14 +1954,12 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n         let mut name = renamed.unwrap_or_else(|| cx.tcx.hir().name(item.hir_id));\n         cx.with_param_env(def_id, || {\n             let kind = match item.kind {\n-                ItemKind::Static(ty, mutability, body_id) => StaticItem(Static {\n-                    type_: ty.clean(cx),\n-                    mutability,\n-                    expr: print_const_expr(cx, body_id),\n-                }),\n+                ItemKind::Static(ty, mutability, body_id) => {\n+                    StaticItem(Static { type_: ty.clean(cx), mutability, expr: Some(body_id) })\n+                }\n                 ItemKind::Const(ty, body_id) => ConstantItem(Constant {\n                     type_: ty.clean(cx),\n-                    expr: print_const_expr(cx, body_id),\n+                    expr: print_const_expr(cx.tcx, body_id),\n                     value: print_evaluated_const(cx, def_id),\n                     is_literal: is_literal_expr(cx, body_id.hir_id),\n                 }),\n@@ -2263,11 +2261,9 @@ impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Symbol>) {\n                         },\n                     })\n                 }\n-                hir::ForeignItemKind::Static(ref ty, mutability) => ForeignStaticItem(Static {\n-                    type_: ty.clean(cx),\n-                    mutability,\n-                    expr: String::new(),\n-                }),\n+                hir::ForeignItemKind::Static(ref ty, mutability) => {\n+                    ForeignStaticItem(Static { type_: ty.clean(cx), mutability, expr: None })\n+                }\n                 hir::ForeignItemKind::Type => ForeignTypeItem,\n             };\n "}, {"sha": "9b8e04a1d239de7ffb9eca4ffebeba921ad4fce2", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/583563d86d88c1ab39c271d640d29a6c2a17a2dd/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/583563d86d88c1ab39c271d640d29a6c2a17a2dd/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=583563d86d88c1ab39c271d640d29a6c2a17a2dd", "patch": "@@ -19,7 +19,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex};\n use rustc_hir::lang_items::LangItem;\n-use rustc_hir::Mutability;\n+use rustc_hir::{BodyId, Mutability};\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::Session;\n@@ -1955,10 +1955,7 @@ crate struct BareFunctionDecl {\n crate struct Static {\n     crate type_: Type,\n     crate mutability: Mutability,\n-    /// It's useful to have the value of a static documented, but I have no\n-    /// desire to represent expressions (that'd basically be all of the AST,\n-    /// which is huge!). So, have a string.\n-    crate expr: String,\n+    crate expr: Option<BodyId>,\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]"}, {"sha": "a711ae0d343c65e00f5abb422be0485bd27dac59", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/583563d86d88c1ab39c271d640d29a6c2a17a2dd/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/583563d86d88c1ab39c271d640d29a6c2a17a2dd/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=583563d86d88c1ab39c271d640d29a6c2a17a2dd", "patch": "@@ -237,7 +237,7 @@ crate fn print_const(cx: &DocContext<'_>, n: &'tcx ty::Const<'_>) -> String {\n         ty::ConstKind::Unevaluated(def, _, promoted) => {\n             let mut s = if let Some(def) = def.as_local() {\n                 let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def.did);\n-                print_const_expr(cx, cx.tcx.hir().body_owned_by(hir_id))\n+                print_const_expr(cx.tcx, cx.tcx.hir().body_owned_by(hir_id))\n             } else {\n                 inline::print_inlined_const(cx, def.did)\n             };\n@@ -326,16 +326,17 @@ crate fn is_literal_expr(cx: &DocContext<'_>, hir_id: hir::HirId) -> bool {\n     false\n }\n \n-crate fn print_const_expr(cx: &DocContext<'_>, body: hir::BodyId) -> String {\n-    let value = &cx.tcx.hir().body(body).value;\n+crate fn print_const_expr(tcx: TyCtxt<'_>, body: hir::BodyId) -> String {\n+    let hir = tcx.hir();\n+    let value = &hir.body(body).value;\n \n     let snippet = if !value.span.from_expansion() {\n-        cx.sess().source_map().span_to_snippet(value.span).ok()\n+        tcx.sess.source_map().span_to_snippet(value.span).ok()\n     } else {\n         None\n     };\n \n-    snippet.unwrap_or_else(|| rustc_hir_pretty::id_to_string(&cx.tcx.hir(), body.hir_id))\n+    snippet.unwrap_or_else(|| rustc_hir_pretty::id_to_string(&hir, body.hir_id))\n }\n \n /// Given a type Path, resolve it to a Type using the TyCtxt"}, {"sha": "7defc4f3f5bb99f0acb9e7dfdeb0de136dc18b9c", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 44, "deletions": 46, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/583563d86d88c1ab39c271d640d29a6c2a17a2dd/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/583563d86d88c1ab39c271d640d29a6c2a17a2dd/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=583563d86d88c1ab39c271d640d29a6c2a17a2dd", "patch": "@@ -6,12 +6,14 @@ use std::convert::From;\n \n use rustc_ast::ast;\n use rustc_hir::def::CtorKind;\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_span::Pos;\n \n use rustdoc_json_types::*;\n \n use crate::clean;\n+use crate::clean::utils::print_const_expr;\n use crate::formats::item_type::ItemType;\n use crate::json::JsonRenderer;\n \n@@ -43,7 +45,7 @@ impl JsonRenderer<'_> {\n                     .collect(),\n                 deprecation: deprecation.map(from_deprecation),\n                 kind: item_type.into(),\n-                inner: kind.into(),\n+                inner: from_clean_item_kind(kind, self.tcx),\n             }),\n         }\n     }\n@@ -144,44 +146,42 @@ crate fn from_def_id(did: DefId) -> Id {\n     Id(format!(\"{}:{}\", did.krate.as_u32(), u32::from(did.index)))\n }\n \n-impl From<clean::ItemKind> for ItemEnum {\n-    fn from(item: clean::ItemKind) -> Self {\n-        use clean::ItemKind::*;\n-        match item {\n-            ModuleItem(m) => ItemEnum::ModuleItem(m.into()),\n-            ExternCrateItem(c, a) => {\n-                ItemEnum::ExternCrateItem { name: c.to_string(), rename: a.map(|x| x.to_string()) }\n-            }\n-            ImportItem(i) => ItemEnum::ImportItem(i.into()),\n-            StructItem(s) => ItemEnum::StructItem(s.into()),\n-            UnionItem(u) => ItemEnum::UnionItem(u.into()),\n-            StructFieldItem(f) => ItemEnum::StructFieldItem(f.into()),\n-            EnumItem(e) => ItemEnum::EnumItem(e.into()),\n-            VariantItem(v) => ItemEnum::VariantItem(v.into()),\n-            FunctionItem(f) => ItemEnum::FunctionItem(f.into()),\n-            ForeignFunctionItem(f) => ItemEnum::FunctionItem(f.into()),\n-            TraitItem(t) => ItemEnum::TraitItem(t.into()),\n-            TraitAliasItem(t) => ItemEnum::TraitAliasItem(t.into()),\n-            MethodItem(m, _) => ItemEnum::MethodItem(from_function_method(m, true)),\n-            TyMethodItem(m) => ItemEnum::MethodItem(from_function_method(m, false)),\n-            ImplItem(i) => ItemEnum::ImplItem(i.into()),\n-            StaticItem(s) => ItemEnum::StaticItem(s.into()),\n-            ForeignStaticItem(s) => ItemEnum::StaticItem(s.into()),\n-            ForeignTypeItem => ItemEnum::ForeignTypeItem,\n-            TypedefItem(t, _) => ItemEnum::TypedefItem(t.into()),\n-            OpaqueTyItem(t) => ItemEnum::OpaqueTyItem(t.into()),\n-            ConstantItem(c) => ItemEnum::ConstantItem(c.into()),\n-            MacroItem(m) => ItemEnum::MacroItem(m.source),\n-            ProcMacroItem(m) => ItemEnum::ProcMacroItem(m.into()),\n-            AssocConstItem(t, s) => ItemEnum::AssocConstItem { type_: t.into(), default: s },\n-            AssocTypeItem(g, t) => ItemEnum::AssocTypeItem {\n-                bounds: g.into_iter().map(Into::into).collect(),\n-                default: t.map(Into::into),\n-            },\n-            StrippedItem(inner) => (*inner).into(),\n-            PrimitiveItem(_) | KeywordItem(_) => {\n-                panic!(\"{:?} is not supported for JSON output\", item)\n-            }\n+fn from_clean_item_kind(item: clean::ItemKind, tcx: TyCtxt<'_>) -> ItemEnum {\n+    use clean::ItemKind::*;\n+    match item {\n+        ModuleItem(m) => ItemEnum::ModuleItem(m.into()),\n+        ExternCrateItem(c, a) => {\n+            ItemEnum::ExternCrateItem { name: c.to_string(), rename: a.map(|x| x.to_string()) }\n+        }\n+        ImportItem(i) => ItemEnum::ImportItem(i.into()),\n+        StructItem(s) => ItemEnum::StructItem(s.into()),\n+        UnionItem(u) => ItemEnum::UnionItem(u.into()),\n+        StructFieldItem(f) => ItemEnum::StructFieldItem(f.into()),\n+        EnumItem(e) => ItemEnum::EnumItem(e.into()),\n+        VariantItem(v) => ItemEnum::VariantItem(v.into()),\n+        FunctionItem(f) => ItemEnum::FunctionItem(f.into()),\n+        ForeignFunctionItem(f) => ItemEnum::FunctionItem(f.into()),\n+        TraitItem(t) => ItemEnum::TraitItem(t.into()),\n+        TraitAliasItem(t) => ItemEnum::TraitAliasItem(t.into()),\n+        MethodItem(m, _) => ItemEnum::MethodItem(from_function_method(m, true)),\n+        TyMethodItem(m) => ItemEnum::MethodItem(from_function_method(m, false)),\n+        ImplItem(i) => ItemEnum::ImplItem(i.into()),\n+        StaticItem(s) => ItemEnum::StaticItem(from_clean_static(s, tcx)),\n+        ForeignStaticItem(s) => ItemEnum::StaticItem(from_clean_static(s, tcx)),\n+        ForeignTypeItem => ItemEnum::ForeignTypeItem,\n+        TypedefItem(t, _) => ItemEnum::TypedefItem(t.into()),\n+        OpaqueTyItem(t) => ItemEnum::OpaqueTyItem(t.into()),\n+        ConstantItem(c) => ItemEnum::ConstantItem(c.into()),\n+        MacroItem(m) => ItemEnum::MacroItem(m.source),\n+        ProcMacroItem(m) => ItemEnum::ProcMacroItem(m.into()),\n+        AssocConstItem(t, s) => ItemEnum::AssocConstItem { type_: t.into(), default: s },\n+        AssocTypeItem(g, t) => ItemEnum::AssocTypeItem {\n+            bounds: g.into_iter().map(Into::into).collect(),\n+            default: t.map(Into::into),\n+        },\n+        StrippedItem(inner) => from_clean_item_kind(*inner, tcx).into(),\n+        PrimitiveItem(_) | KeywordItem(_) => {\n+            panic!(\"{:?} is not supported for JSON output\", item)\n         }\n     }\n }\n@@ -534,13 +534,11 @@ impl From<clean::OpaqueTy> for OpaqueTy {\n     }\n }\n \n-impl From<clean::Static> for Static {\n-    fn from(stat: clean::Static) -> Self {\n-        Static {\n-            type_: stat.type_.into(),\n-            mutable: stat.mutability == ast::Mutability::Mut,\n-            expr: stat.expr,\n-        }\n+fn from_clean_static(stat: clean::Static, tcx: TyCtxt<'_>) -> Static {\n+    Static {\n+        type_: stat.type_.into(),\n+        mutable: stat.mutability == ast::Mutability::Mut,\n+        expr: stat.expr.map(|e| print_const_expr(tcx, e)).unwrap_or_default(),\n     }\n }\n "}]}