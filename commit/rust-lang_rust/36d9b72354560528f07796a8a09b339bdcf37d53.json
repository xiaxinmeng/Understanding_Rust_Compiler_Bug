{"sha": "36d9b72354560528f07796a8a09b339bdcf37d53", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2ZDliNzIzNTQ1NjA1MjhmMDc3OTZhOGEwOWIzMzliZGNmMzdkNTM=", "commit": {"author": {"name": "Vojtech Kral", "email": "vojtech@kral.hk", "date": "2020-10-09T11:06:04Z"}, "committer": {"name": "Vojtech Kral", "email": "vojtech@kral.hk", "date": "2020-10-09T17:59:35Z"}, "message": "liballoc: VecDeque: Add binary search functions", "tree": {"sha": "10726965dde158cc5ddb3939c06ab2b012cf4747", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10726965dde158cc5ddb3939c06ab2b012cf4747"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36d9b72354560528f07796a8a09b339bdcf37d53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36d9b72354560528f07796a8a09b339bdcf37d53", "html_url": "https://github.com/rust-lang/rust/commit/36d9b72354560528f07796a8a09b339bdcf37d53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36d9b72354560528f07796a8a09b339bdcf37d53/comments", "author": {"login": "vojtechkral", "id": 424891, "node_id": "MDQ6VXNlcjQyNDg5MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/424891?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vojtechkral", "html_url": "https://github.com/vojtechkral", "followers_url": "https://api.github.com/users/vojtechkral/followers", "following_url": "https://api.github.com/users/vojtechkral/following{/other_user}", "gists_url": "https://api.github.com/users/vojtechkral/gists{/gist_id}", "starred_url": "https://api.github.com/users/vojtechkral/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vojtechkral/subscriptions", "organizations_url": "https://api.github.com/users/vojtechkral/orgs", "repos_url": "https://api.github.com/users/vojtechkral/repos", "events_url": "https://api.github.com/users/vojtechkral/events{/privacy}", "received_events_url": "https://api.github.com/users/vojtechkral/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vojtechkral", "id": 424891, "node_id": "MDQ6VXNlcjQyNDg5MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/424891?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vojtechkral", "html_url": "https://github.com/vojtechkral", "followers_url": "https://api.github.com/users/vojtechkral/followers", "following_url": "https://api.github.com/users/vojtechkral/following{/other_user}", "gists_url": "https://api.github.com/users/vojtechkral/gists{/gist_id}", "starred_url": "https://api.github.com/users/vojtechkral/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vojtechkral/subscriptions", "organizations_url": "https://api.github.com/users/vojtechkral/orgs", "repos_url": "https://api.github.com/users/vojtechkral/repos", "events_url": "https://api.github.com/users/vojtechkral/events{/privacy}", "received_events_url": "https://api.github.com/users/vojtechkral/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc3d8e3fccb86d6798ce89ca9eb28679908dc526", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc3d8e3fccb86d6798ce89ca9eb28679908dc526", "html_url": "https://github.com/rust-lang/rust/commit/fc3d8e3fccb86d6798ce89ca9eb28679908dc526"}], "stats": {"total": 190, "additions": 189, "deletions": 1}, "files": [{"sha": "1560263684acbd4e3f1d35bd244d08b09f61a392", "filename": "library/alloc/src/collections/vec_deque.rs", "status": "modified", "additions": 149, "deletions": 1, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/36d9b72354560528f07796a8a09b339bdcf37d53/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d9b72354560528f07796a8a09b339bdcf37d53/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs?ref=36d9b72354560528f07796a8a09b339bdcf37d53", "patch": "@@ -2181,7 +2181,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// This method does not allocate and does not change the order of the\n     /// inserted elements. As it returns a mutable slice, this can be used to\n-    /// sort or binary search a deque.\n+    /// sort a deque.\n     ///\n     /// Once the internal storage is contiguous, the [`as_slices`] and\n     /// [`as_mut_slices`] methods will return the entire contents of the\n@@ -2430,6 +2430,154 @@ impl<T> VecDeque<T> {\n             self.wrap_copy(self.tail, self.head, k);\n         }\n     }\n+\n+    /// Binary searches this sorted `VecDeque` for a given element.\n+    ///\n+    /// If the value is found then [`Result::Ok`] is returned, containing the\n+    /// index of the matching element. If there are multiple matches, then any\n+    /// one of the matches could be returned. If the value is not found then\n+    /// [`Result::Err`] is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1, 4]`.\n+    ///\n+    /// ```\n+    /// #![feature(vecdeque_binary_search)]\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let deque: VecDeque<_> = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();\n+    ///\n+    /// assert_eq!(deque.binary_search(&13),  Ok(9));\n+    /// assert_eq!(deque.binary_search(&4),   Err(7));\n+    /// assert_eq!(deque.binary_search(&100), Err(13));\n+    /// let r = deque.binary_search(&1);\n+    /// assert!(matches!(r, Ok(1..=4)));\n+    /// ```\n+    ///\n+    /// If you want to insert an item to a sorted `VecDeque`, while maintaining\n+    /// sort order:\n+    ///\n+    /// ```\n+    /// #![feature(vecdeque_binary_search)]\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut deque: VecDeque<_> = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();\n+    /// let num = 42;\n+    /// let idx = deque.binary_search(&num).unwrap_or_else(|x| x);\n+    /// deque.insert(idx, num);\n+    /// assert_eq!(deque, &[0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 42, 55]);\n+    /// ```\n+    #[unstable(feature = \"vecdeque_binary_search\", issue = \"1\")]\n+    #[inline]\n+    pub fn binary_search(&self, x: &T) -> Result<usize, usize>\n+    where\n+        T: Ord,\n+    {\n+        self.binary_search_by(|e| e.cmp(x))\n+    }\n+\n+    /// Binary searches this sorted `VecDeque` with a comparator function.\n+    ///\n+    /// The comparator function should implement an order consistent\n+    /// with the sort order of the underlying `VecDeque`, returning an\n+    /// order code that indicates whether its argument is `Less`,\n+    /// `Equal` or `Greater` than the desired target.\n+    ///\n+    /// If the value is found then [`Result::Ok`] is returned, containing the\n+    /// index of the matching element. If there are multiple matches, then any\n+    /// one of the matches could be returned. If the value is not found then\n+    /// [`Result::Err`] is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1, 4]`.\n+    ///\n+    /// ```\n+    /// #![feature(vecdeque_binary_search)]\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let deque: VecDeque<_> = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();\n+    ///\n+    /// assert_eq!(deque.binary_search_by(|x| x.cmp(&13)),  Ok(9));\n+    /// assert_eq!(deque.binary_search_by(|x| x.cmp(&4)),   Err(7));\n+    /// assert_eq!(deque.binary_search_by(|x| x.cmp(&100)), Err(13));\n+    /// let r = deque.binary_search_by(|x| x.cmp(&1));\n+    /// assert!(matches!(r, Ok(1..=4)));\n+    /// ```\n+    #[unstable(feature = \"vecdeque_binary_search\", issue = \"1\")]\n+    pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>\n+    where\n+        F: FnMut(&'a T) -> Ordering,\n+    {\n+        if self.is_empty() {\n+            return Err(0);\n+        }\n+\n+        let (front, back) = self.as_slices();\n+\n+        match back.first().map(|elem| f(elem)) {\n+            Some(Ordering::Equal) => return Ok(front.len()),\n+            Some(Ordering::Less) => {\n+                return back[1..]\n+                    .binary_search_by(f)\n+                    .map(|idx| idx + front.len() + 1)\n+                    .map_err(|idx| idx + front.len() + 1);\n+            }\n+            _ => {}\n+        }\n+\n+        front.binary_search_by(f)\n+    }\n+\n+    /// Binary searches this sorted `VecDeque` with a key extraction function.\n+    ///\n+    /// Assumes that the `VecDeque` is sorted by the key, for instance with\n+    /// [`make_contiguous().sort_by_key()`](#method.make_contiguous) using the same\n+    /// key extraction function.\n+    ///\n+    /// If the value is found then [`Result::Ok`] is returned, containing the\n+    /// index of the matching element. If there are multiple matches, then any\n+    /// one of the matches could be returned. If the value is not found then\n+    /// [`Result::Err`] is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Looks up a series of four elements in a slice of pairs sorted by\n+    /// their second elements. The first is found, with a uniquely\n+    /// determined position; the second and third are not found; the\n+    /// fourth could match any position in `[1, 4]`.\n+    ///\n+    /// ```\n+    /// #![feature(vecdeque_binary_search)]\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let deque: VecDeque<_> = vec![(0, 0), (2, 1), (4, 1), (5, 1),\n+    ///          (3, 1), (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),\n+    ///          (1, 21), (2, 34), (4, 55)].into();\n+    ///\n+    /// assert_eq!(deque.binary_search_by_key(&13, |&(a,b)| b),  Ok(9));\n+    /// assert_eq!(deque.binary_search_by_key(&4, |&(a,b)| b),   Err(7));\n+    /// assert_eq!(deque.binary_search_by_key(&100, |&(a,b)| b), Err(13));\n+    /// let r = deque.binary_search_by_key(&1, |&(a,b)| b);\n+    /// assert!(matches!(r, Ok(1..=4)));\n+    /// ```\n+    #[unstable(feature = \"vecdeque_binary_search\", issue = \"1\")]\n+    #[inline]\n+    pub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, mut f: F) -> Result<usize, usize>\n+    where\n+        F: FnMut(&'a T) -> B,\n+        B: Ord,\n+    {\n+        self.binary_search_by(|k| f(k).cmp(b))\n+    }\n }\n \n impl<T: Clone> VecDeque<T> {"}, {"sha": "b7cc03f8eb999403f45f2a70939bbf92f960c569", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36d9b72354560528f07796a8a09b339bdcf37d53/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d9b72354560528f07796a8a09b339bdcf37d53/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=36d9b72354560528f07796a8a09b339bdcf37d53", "patch": "@@ -20,6 +20,7 @@\n #![feature(inplace_iteration)]\n #![feature(iter_map_while)]\n #![feature(int_bits_const)]\n+#![feature(vecdeque_binary_search)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}, {"sha": "05cb3a2c03d79a49780436dfe9889e918af955af", "filename": "library/alloc/tests/vec_deque.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/36d9b72354560528f07796a8a09b339bdcf37d53/library%2Falloc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d9b72354560528f07796a8a09b339bdcf37d53/library%2Falloc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec_deque.rs?ref=36d9b72354560528f07796a8a09b339bdcf37d53", "patch": "@@ -1659,3 +1659,42 @@ fn test_drain_leak() {\n     drop(v);\n     assert_eq!(unsafe { DROPS }, 7);\n }\n+\n+#[test]\n+fn test_binary_search() {\n+    // Contiguous (front only) search:\n+    let deque: VecDeque<_> = vec![1, 2, 3, 5, 6].into();\n+    assert!(deque.as_slices().1.is_empty());\n+    assert_eq!(deque.binary_search(&3), Ok(2));\n+    assert_eq!(deque.binary_search(&4), Err(3));\n+\n+    // Split search (both front & back non-empty):\n+    let mut deque: VecDeque<_> = vec![5, 6].into();\n+    deque.push_front(3);\n+    deque.push_front(2);\n+    deque.push_front(1);\n+    deque.push_back(10);\n+    assert!(!deque.as_slices().0.is_empty());\n+    assert!(!deque.as_slices().1.is_empty());\n+    assert_eq!(deque.binary_search(&0), Err(0));\n+    assert_eq!(deque.binary_search(&1), Ok(0));\n+    assert_eq!(deque.binary_search(&5), Ok(3));\n+    assert_eq!(deque.binary_search(&7), Err(5));\n+    assert_eq!(deque.binary_search(&20), Err(6));\n+}\n+\n+#[test]\n+fn test_binary_search_by() {\n+    let deque: VecDeque<_> = vec![(1,), (2,), (3,), (5,), (6,)].into();\n+\n+    assert_eq!(deque.binary_search_by(|&(v,)| v.cmp(&3)), Ok(2));\n+    assert_eq!(deque.binary_search_by(|&(v,)| v.cmp(&4)), Err(3));\n+}\n+\n+#[test]\n+fn test_binary_search_by_key() {\n+    let deque: VecDeque<_> = vec![(1,), (2,), (3,), (5,), (6,)].into();\n+\n+    assert_eq!(deque.binary_search_by_key(&3, |&(v,)| v), Ok(2));\n+    assert_eq!(deque.binary_search_by_key(&4, |&(v,)| v), Err(3));\n+}"}]}