{"sha": "ec273c3d12b7393f6b81e793ce1c7abd59e3dc67", "node_id": "C_kwDOAAsO6NoAKGVjMjczYzNkMTJiNzM5M2Y2YjgxZTc5M2NlMWM3YWJkNTllM2RjNjc", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-03T09:23:20Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-03T09:42:46Z"}, "message": "Split pattern inference into more functions", "tree": {"sha": "e30dae56db202bf4e953f3ac4f410b5e8dbbaa23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e30dae56db202bf4e953f3ac4f410b5e8dbbaa23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec273c3d12b7393f6b81e793ce1c7abd59e3dc67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec273c3d12b7393f6b81e793ce1c7abd59e3dc67", "html_url": "https://github.com/rust-lang/rust/commit/ec273c3d12b7393f6b81e793ce1c7abd59e3dc67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec273c3d12b7393f6b81e793ce1c7abd59e3dc67/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc2b395e0095236e3c312974fa1e52a467c26324", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc2b395e0095236e3c312974fa1e52a467c26324", "html_url": "https://github.com/rust-lang/rust/commit/fc2b395e0095236e3c312974fa1e52a467c26324"}], "stats": {"total": 406, "additions": 234, "deletions": 172}, "files": [{"sha": "fdb236c11146f86df94570efa4f8f650933270c4", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec273c3d12b7393f6b81e793ce1c7abd59e3dc67/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec273c3d12b7393f6b81e793ce1c7abd59e3dc67/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=ec273c3d12b7393f6b81e793ce1c7abd59e3dc67", "patch": "@@ -85,7 +85,7 @@ pub enum ResolveValueResult {\n     Partial(TypeNs, usize),\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub enum ValueNs {\n     ImplSelf(ImplId),\n     LocalBinding(PatId),"}, {"sha": "f229bf2f644d3e54b34204f37014f403dad196c2", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ec273c3d12b7393f6b81e793ce1c7abd59e3dc67/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec273c3d12b7393f6b81e793ce1c7abd59e3dc67/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=ec273c3d12b7393f6b81e793ce1c7abd59e3dc67", "patch": "@@ -144,44 +144,6 @@ impl Default for BindingMode {\n     }\n }\n \n-/// Used to generalize patterns and assignee expressions.\n-trait PatLike: Into<ExprOrPatId> + Copy {\n-    type BindingMode: Copy;\n-\n-    fn infer(\n-        this: &mut InferenceContext<'_>,\n-        id: Self,\n-        expected_ty: &Ty,\n-        default_bm: Self::BindingMode,\n-    ) -> Ty;\n-}\n-\n-impl PatLike for ExprId {\n-    type BindingMode = ();\n-\n-    fn infer(\n-        this: &mut InferenceContext<'_>,\n-        id: Self,\n-        expected_ty: &Ty,\n-        _: Self::BindingMode,\n-    ) -> Ty {\n-        this.infer_assignee_expr(id, expected_ty)\n-    }\n-}\n-\n-impl PatLike for PatId {\n-    type BindingMode = BindingMode;\n-\n-    fn infer(\n-        this: &mut InferenceContext<'_>,\n-        id: Self,\n-        expected_ty: &Ty,\n-        default_bm: Self::BindingMode,\n-    ) -> Ty {\n-        this.infer_pat(id, expected_ty, default_bm)\n-    }\n-}\n-\n #[derive(Debug)]\n pub(crate) struct InferOk<T> {\n     value: T,\n@@ -581,7 +543,7 @@ impl<'a> InferenceContext<'a> {\n             let ty = self.insert_type_vars(ty);\n             let ty = self.normalize_associated_types_in(ty);\n \n-            self.infer_pat(*pat, &ty, BindingMode::default());\n+            self.infer_top_pat(*pat, &ty);\n         }\n         let error_ty = &TypeRef::Error;\n         let return_ty = if data.has_async_kw() {"}, {"sha": "a186ae836d07ef2eb9b66029f234da4fda1c2569", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ec273c3d12b7393f6b81e793ce1c7abd59e3dc67/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec273c3d12b7393f6b81e793ce1c7abd59e3dc67/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=ec273c3d12b7393f6b81e793ce1c7abd59e3dc67", "patch": "@@ -25,7 +25,9 @@ use syntax::ast::RangeOp;\n use crate::{\n     autoderef::{self, Autoderef},\n     consteval,\n-    infer::{coerce::CoerceMany, find_continuable, BreakableKind},\n+    infer::{\n+        coerce::CoerceMany, find_continuable, pat::contains_explicit_ref_binding, BreakableKind,\n+    },\n     lower::{\n         const_or_path_to_chalk, generic_arg_to_chalk, lower_to_chalk_mutability, ParamLoweringMode,\n     },\n@@ -39,8 +41,8 @@ use crate::{\n };\n \n use super::{\n-    coerce::auto_deref_adjust_steps, find_breakable, BindingMode, BreakableContext, Diverges,\n-    Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch,\n+    coerce::auto_deref_adjust_steps, find_breakable, BreakableContext, Diverges, Expectation,\n+    InferenceContext, InferenceDiagnostic, TypeMismatch,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -111,7 +113,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             &Expr::Let { pat, expr } => {\n                 let input_ty = self.infer_expr(expr, &Expectation::none());\n-                self.infer_pat(pat, &input_ty, BindingMode::default());\n+                self.infer_top_pat(pat, &input_ty);\n                 self.result.standard_types.bool_.clone()\n             }\n             Expr::Block { statements, tail, label, id: _ } => {\n@@ -223,7 +225,7 @@ impl<'a> InferenceContext<'a> {\n                 let pat_ty =\n                     self.resolve_associated_type(into_iter_ty, self.resolve_iterator_item());\n \n-                self.infer_pat(pat, &pat_ty, BindingMode::default());\n+                self.infer_top_pat(pat, &pat_ty);\n                 self.with_breakable_ctx(BreakableKind::Loop, self.err_ty(), label, |this| {\n                     this.infer_expr(body, &Expectation::HasType(TyBuilder::unit()));\n                 });\n@@ -298,7 +300,7 @@ impl<'a> InferenceContext<'a> {\n \n                 // Now go through the argument patterns\n                 for (arg_pat, arg_ty) in args.iter().zip(sig_tys) {\n-                    self.infer_pat(*arg_pat, &arg_ty, BindingMode::default());\n+                    self.infer_top_pat(*arg_pat, &arg_ty);\n                 }\n \n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n@@ -395,7 +397,8 @@ impl<'a> InferenceContext<'a> {\n \n                 for arm in arms.iter() {\n                     self.diverges = Diverges::Maybe;\n-                    let _pat_ty = self.infer_pat(arm.pat, &input_ty, BindingMode::default());\n+                    let input_ty = self.resolve_ty_shallow(&input_ty);\n+                    let _pat_ty = self.infer_top_pat(arm.pat, &input_ty);\n                     if let Some(guard_expr) = arm.guard {\n                         self.infer_expr(\n                             guard_expr,\n@@ -1142,27 +1145,33 @@ impl<'a> InferenceContext<'a> {\n                     let decl_ty = type_ref\n                         .as_ref()\n                         .map(|tr| self.make_ty(tr))\n-                        .unwrap_or_else(|| self.err_ty());\n-\n-                    // Always use the declared type when specified\n-                    let mut ty = decl_ty.clone();\n+                        .unwrap_or_else(|| self.table.new_type_var());\n \n-                    if let Some(expr) = initializer {\n-                        let actual_ty =\n-                            self.infer_expr_coerce(*expr, &Expectation::has_type(decl_ty.clone()));\n-                        if decl_ty.is_unknown() {\n-                            ty = actual_ty;\n+                    let ty = if let Some(expr) = initializer {\n+                        let ty = if contains_explicit_ref_binding(&self.body, *pat) {\n+                            self.infer_expr(*expr, &Expectation::has_type(decl_ty.clone()))\n+                        } else {\n+                            self.infer_expr_coerce(*expr, &Expectation::has_type(decl_ty.clone()))\n+                        };\n+                        if type_ref.is_some() {\n+                            decl_ty\n+                        } else {\n+                            ty\n                         }\n-                    }\n+                    } else {\n+                        decl_ty\n+                    };\n+\n+                    self.infer_top_pat(*pat, &ty);\n \n                     if let Some(expr) = else_branch {\n+                        let previous_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                         self.infer_expr_coerce(\n                             *expr,\n                             &Expectation::HasType(self.result.standard_types.never.clone()),\n                         );\n+                        self.diverges = previous_diverges;\n                     }\n-\n-                    self.infer_pat(*pat, &ty, BindingMode::default());\n                 }\n                 Statement::Expr { expr, .. } => {\n                     self.infer_expr(*expr, &Expectation::none());"}, {"sha": "6481e0b7a719841a5e3b710e4073e784a8b083d5", "filename": "crates/hir-ty/src/infer/pat.rs", "status": "modified", "additions": 198, "deletions": 102, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/ec273c3d12b7393f6b81e793ce1c7abd59e3dc67/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec273c3d12b7393f6b81e793ce1c7abd59e3dc67/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=ec273c3d12b7393f6b81e793ce1c7abd59e3dc67", "patch": "@@ -4,7 +4,8 @@ use std::iter::repeat_with;\n \n use chalk_ir::Mutability;\n use hir_def::{\n-    expr::{BindingAnnotation, Expr, Literal, Pat, PatId},\n+    body::Body,\n+    expr::{BindingAnnotation, Expr, ExprId, ExprOrPatId, Literal, Pat, PatId, RecordFieldPat},\n     path::Path,\n };\n use hir_expand::name::Name;\n@@ -17,7 +18,43 @@ use crate::{\n     static_lifetime, Interner, Scalar, Substitution, Ty, TyBuilder, TyExt, TyKind,\n };\n \n-use super::PatLike;\n+/// Used to generalize patterns and assignee expressions.\n+pub(super) trait PatLike: Into<ExprOrPatId> + Copy {\n+    type BindingMode: Copy;\n+\n+    fn infer(\n+        this: &mut InferenceContext<'_>,\n+        id: Self,\n+        expected_ty: &Ty,\n+        default_bm: Self::BindingMode,\n+    ) -> Ty;\n+}\n+\n+impl PatLike for ExprId {\n+    type BindingMode = ();\n+\n+    fn infer(\n+        this: &mut InferenceContext<'_>,\n+        id: Self,\n+        expected_ty: &Ty,\n+        (): Self::BindingMode,\n+    ) -> Ty {\n+        this.infer_assignee_expr(id, expected_ty)\n+    }\n+}\n+\n+impl PatLike for PatId {\n+    type BindingMode = BindingMode;\n+\n+    fn infer(\n+        this: &mut InferenceContext<'_>,\n+        id: Self,\n+        expected_ty: &Ty,\n+        default_bm: Self::BindingMode,\n+    ) -> Ty {\n+        this.infer_pat(id, expected_ty, default_bm)\n+    }\n+}\n \n impl<'a> InferenceContext<'a> {\n     /// Infers type for tuple struct pattern or its corresponding assignee expression.\n@@ -110,6 +147,7 @@ impl<'a> InferenceContext<'a> {\n         ellipsis: Option<usize>,\n         subs: &[T],\n     ) -> Ty {\n+        let expected = self.resolve_ty_shallow(expected);\n         let expectations = match expected.as_tuple() {\n             Some(parameters) => &*parameters.as_slice(Interner),\n             _ => &[],\n@@ -143,12 +181,11 @@ impl<'a> InferenceContext<'a> {\n             .intern(Interner)\n     }\n \n-    pub(super) fn infer_pat(\n-        &mut self,\n-        pat: PatId,\n-        expected: &Ty,\n-        mut default_bm: BindingMode,\n-    ) -> Ty {\n+    pub(super) fn infer_top_pat(&mut self, pat: PatId, expected: &Ty) -> Ty {\n+        self.infer_pat(pat, expected, BindingMode::default())\n+    }\n+\n+    fn infer_pat(&mut self, pat: PatId, expected: &Ty, mut default_bm: BindingMode) -> Ty {\n         let mut expected = self.resolve_ty_shallow(expected);\n \n         if is_non_ref_pat(self.body, pat) {\n@@ -183,25 +220,17 @@ impl<'a> InferenceContext<'a> {\n                 self.infer_tuple_pat_like(&expected, default_bm, *ellipsis, args)\n             }\n             Pat::Or(pats) => {\n-                if let Some((first_pat, rest)) = pats.split_first() {\n-                    let ty = self.infer_pat(*first_pat, &expected, default_bm);\n-                    for pat in rest {\n-                        self.infer_pat(*pat, &expected, default_bm);\n-                    }\n-                    ty\n-                } else {\n-                    self.err_ty()\n+                for pat in pats.iter() {\n+                    self.infer_pat(*pat, &expected, default_bm);\n                 }\n+                expected.clone()\n             }\n-            Pat::Ref { pat, mutability } => {\n-                let mutability = lower_to_chalk_mutability(*mutability);\n-                let expectation = match expected.as_reference() {\n-                    Some((inner_ty, _lifetime, exp_mut)) => inner_ty.clone(),\n-                    _ => self.result.standard_types.unknown.clone(),\n-                };\n-                let subty = self.infer_pat(*pat, &expectation, default_bm);\n-                TyKind::Ref(mutability, static_lifetime(), subty).intern(Interner)\n-            }\n+            &Pat::Ref { pat, mutability } => self.infer_ref_pat(\n+                pat,\n+                lower_to_chalk_mutability(mutability),\n+                &expected,\n+                default_bm,\n+            ),\n             Pat::TupleStruct { path: p, args: subpats, ellipsis } => self\n                 .infer_tuple_struct_pat_like(\n                     p.as_deref(),\n@@ -221,91 +250,17 @@ impl<'a> InferenceContext<'a> {\n                 self.infer_path(&resolver, path, pat.into()).unwrap_or_else(|| self.err_ty())\n             }\n             Pat::Bind { mode, name: _, subpat } => {\n-                let mode = if mode == &BindingAnnotation::Unannotated {\n-                    default_bm\n-                } else {\n-                    BindingMode::convert(*mode)\n-                };\n-                self.result.pat_binding_modes.insert(pat, mode);\n-\n-                let inner_ty = match subpat {\n-                    Some(subpat) => self.infer_pat(*subpat, &expected, default_bm),\n-                    None => expected,\n-                };\n-                let inner_ty = self.insert_type_vars_shallow(inner_ty);\n-\n-                let bound_ty = match mode {\n-                    BindingMode::Ref(mutability) => {\n-                        TyKind::Ref(mutability, static_lifetime(), inner_ty.clone())\n-                            .intern(Interner)\n-                    }\n-                    BindingMode::Move => inner_ty.clone(),\n-                };\n-                self.write_pat_ty(pat, bound_ty);\n-                return inner_ty;\n+                return self.infer_bind_pat(pat, *mode, default_bm, *subpat, &expected);\n             }\n             Pat::Slice { prefix, slice, suffix } => {\n-                let elem_ty = match expected.kind(Interner) {\n-                    TyKind::Array(st, _) | TyKind::Slice(st) => st.clone(),\n-                    _ => self.err_ty(),\n-                };\n-\n-                for &pat_id in prefix.iter().chain(suffix.iter()) {\n-                    self.infer_pat(pat_id, &elem_ty, default_bm);\n-                }\n-\n-                if let &Some(slice_pat_id) = slice {\n-                    let rest_pat_ty = match expected.kind(Interner) {\n-                        TyKind::Array(_, length) => {\n-                            let len = try_const_usize(length);\n-                            let len = len.and_then(|len| {\n-                                len.checked_sub((prefix.len() + suffix.len()) as u128)\n-                            });\n-                            TyKind::Array(\n-                                elem_ty.clone(),\n-                                usize_const(self.db, len, self.resolver.krate()),\n-                            )\n-                        }\n-                        _ => TyKind::Slice(elem_ty.clone()),\n-                    }\n-                    .intern(Interner);\n-                    self.infer_pat(slice_pat_id, &rest_pat_ty, default_bm);\n-                }\n-\n-                match expected.kind(Interner) {\n-                    TyKind::Array(_, const_) => TyKind::Array(elem_ty, const_.clone()),\n-                    _ => TyKind::Slice(elem_ty),\n-                }\n-                .intern(Interner)\n+                self.infer_slice_pat(&expected, prefix, slice, suffix, default_bm)\n             }\n             Pat::Wild => expected.clone(),\n             Pat::Range { start, end } => {\n                 let start_ty = self.infer_expr(*start, &Expectation::has_type(expected.clone()));\n                 self.infer_expr(*end, &Expectation::has_type(start_ty))\n             }\n-            &Pat::Lit(expr) => {\n-                // FIXME: using `Option` here is a workaround until we can use if-let chains in stable.\n-                let mut pat_ty = None;\n-\n-                // Like slice patterns, byte string patterns can denote both `&[u8; N]` and `&[u8]`.\n-                if let Expr::Literal(Literal::ByteString(_)) = self.body[expr] {\n-                    if let Some((inner, ..)) = expected.as_reference() {\n-                        let inner = self.resolve_ty_shallow(inner);\n-                        if matches!(inner.kind(Interner), TyKind::Slice(_)) {\n-                            let elem_ty = TyKind::Scalar(Scalar::Uint(UintTy::U8)).intern(Interner);\n-                            let slice_ty = TyKind::Slice(elem_ty).intern(Interner);\n-                            let ty = TyKind::Ref(Mutability::Not, static_lifetime(), slice_ty)\n-                                .intern(Interner);\n-                            self.write_expr_ty(expr, ty.clone());\n-                            pat_ty = Some(ty);\n-                        }\n-                    }\n-                }\n-\n-                pat_ty.unwrap_or_else(|| {\n-                    self.infer_expr(expr, &Expectation::has_type(expected.clone()))\n-                })\n-            }\n+            &Pat::Lit(expr) => self.infer_lit_pat(expr, &expected),\n             Pat::Box { inner } => match self.resolve_boxed_box() {\n                 Some(box_adt) => {\n                     let (inner_ty, alloc_ty) = match expected.as_adt() {\n@@ -341,6 +296,109 @@ impl<'a> InferenceContext<'a> {\n         self.write_pat_ty(pat, ty.clone());\n         ty\n     }\n+\n+    fn infer_ref_pat(\n+        &mut self,\n+        pat: PatId,\n+        mutability: Mutability,\n+        expected: &Ty,\n+        default_bm: BindingMode,\n+    ) -> Ty {\n+        let expectation = match expected.as_reference() {\n+            Some((inner_ty, _lifetime, _exp_mut)) => inner_ty.clone(),\n+            _ => self.result.standard_types.unknown.clone(),\n+        };\n+        let subty = self.infer_pat(pat, &expectation, default_bm);\n+        TyKind::Ref(mutability, static_lifetime(), subty).intern(Interner)\n+    }\n+\n+    fn infer_bind_pat(\n+        &mut self,\n+        pat: PatId,\n+        mode: BindingAnnotation,\n+        default_bm: BindingMode,\n+        subpat: Option<PatId>,\n+        expected: &Ty,\n+    ) -> Ty {\n+        let mode = if mode == BindingAnnotation::Unannotated {\n+            default_bm\n+        } else {\n+            BindingMode::convert(mode)\n+        };\n+        self.result.pat_binding_modes.insert(pat, mode);\n+\n+        let inner_ty = match subpat {\n+            Some(subpat) => self.infer_pat(subpat, &expected, default_bm),\n+            None => expected.clone(),\n+        };\n+        let inner_ty = self.insert_type_vars_shallow(inner_ty);\n+\n+        let bound_ty = match mode {\n+            BindingMode::Ref(mutability) => {\n+                TyKind::Ref(mutability, static_lifetime(), inner_ty.clone()).intern(Interner)\n+            }\n+            BindingMode::Move => inner_ty.clone(),\n+        };\n+        self.write_pat_ty(pat, bound_ty);\n+        return inner_ty;\n+    }\n+\n+    fn infer_slice_pat(\n+        &mut self,\n+        expected: &Ty,\n+        prefix: &[PatId],\n+        slice: &Option<PatId>,\n+        suffix: &[PatId],\n+        default_bm: BindingMode,\n+    ) -> Ty {\n+        let elem_ty = match expected.kind(Interner) {\n+            TyKind::Array(st, _) | TyKind::Slice(st) => st.clone(),\n+            _ => self.err_ty(),\n+        };\n+\n+        for &pat_id in prefix.iter().chain(suffix.iter()) {\n+            self.infer_pat(pat_id, &elem_ty, default_bm);\n+        }\n+\n+        if let &Some(slice_pat_id) = slice {\n+            let rest_pat_ty = match expected.kind(Interner) {\n+                TyKind::Array(_, length) => {\n+                    let len = try_const_usize(length);\n+                    let len =\n+                        len.and_then(|len| len.checked_sub((prefix.len() + suffix.len()) as u128));\n+                    TyKind::Array(elem_ty.clone(), usize_const(self.db, len, self.resolver.krate()))\n+                }\n+                _ => TyKind::Slice(elem_ty.clone()),\n+            }\n+            .intern(Interner);\n+            self.infer_pat(slice_pat_id, &rest_pat_ty, default_bm);\n+        }\n+\n+        match expected.kind(Interner) {\n+            TyKind::Array(_, const_) => TyKind::Array(elem_ty, const_.clone()),\n+            _ => TyKind::Slice(elem_ty),\n+        }\n+        .intern(Interner)\n+    }\n+\n+    fn infer_lit_pat(&mut self, expr: ExprId, expected: &Ty) -> Ty {\n+        // Like slice patterns, byte string patterns can denote both `&[u8; N]` and `&[u8]`.\n+        if let Expr::Literal(Literal::ByteString(_)) = self.body[expr] {\n+            if let Some((inner, ..)) = expected.as_reference() {\n+                let inner = self.resolve_ty_shallow(inner);\n+                if matches!(inner.kind(Interner), TyKind::Slice(_)) {\n+                    let elem_ty = TyKind::Scalar(Scalar::Uint(UintTy::U8)).intern(Interner);\n+                    let slice_ty = TyKind::Slice(elem_ty).intern(Interner);\n+                    let ty =\n+                        TyKind::Ref(Mutability::Not, static_lifetime(), slice_ty).intern(Interner);\n+                    self.write_expr_ty(expr, ty.clone());\n+                    return ty;\n+                }\n+            }\n+        }\n+\n+        self.infer_expr(expr, &Expectation::has_type(expected.clone()))\n+    }\n }\n \n fn is_non_ref_pat(body: &hir_def::body::Body, pat: PatId) -> bool {\n@@ -365,3 +423,41 @@ fn is_non_ref_pat(body: &hir_def::body::Body, pat: PatId) -> bool {\n         Pat::Wild | Pat::Bind { .. } | Pat::Ref { .. } | Pat::Box { .. } | Pat::Missing => false,\n     }\n }\n+\n+pub(super) fn contains_explicit_ref_binding(body: &Body, pat_id: PatId) -> bool {\n+    let mut res = false;\n+    walk_pats(body, pat_id, &mut |pat| {\n+        res |= matches!(pat, Pat::Bind { mode: BindingAnnotation::Ref, .. })\n+    });\n+    res\n+}\n+\n+fn walk_pats(body: &Body, pat_id: PatId, f: &mut impl FnMut(&Pat)) {\n+    let pat = &body[pat_id];\n+    f(pat);\n+    match pat {\n+        Pat::Range { .. }\n+        | Pat::Lit(..)\n+        | Pat::Path(..)\n+        | Pat::ConstBlock(..)\n+        | Pat::Wild\n+        | Pat::Missing => {}\n+        &Pat::Bind { subpat, .. } => {\n+            if let Some(subpat) = subpat {\n+                walk_pats(body, subpat, f);\n+            }\n+        }\n+        Pat::Or(args) | Pat::Tuple { args, .. } | Pat::TupleStruct { args, .. } => {\n+            args.iter().copied().for_each(|p| walk_pats(body, p, f));\n+        }\n+        Pat::Ref { pat, .. } => walk_pats(body, *pat, f),\n+        Pat::Slice { prefix, slice, suffix } => {\n+            let total_iter = prefix.iter().chain(slice.iter()).chain(suffix.iter());\n+            total_iter.copied().for_each(|p| walk_pats(body, p, f));\n+        }\n+        Pat::Record { args, .. } => {\n+            args.iter().for_each(|RecordFieldPat { pat, .. }| walk_pats(body, *pat, f));\n+        }\n+        Pat::Box { inner } => walk_pats(body, *inner, f),\n+    }\n+}"}, {"sha": "be67329fee4417189c42474436427f0151723c74", "filename": "crates/hir-ty/src/tests/patterns.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ec273c3d12b7393f6b81e793ce1c7abd59e3dc67/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec273c3d12b7393f6b81e793ce1c7abd59e3dc67/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=ec273c3d12b7393f6b81e793ce1c7abd59e3dc67", "patch": "@@ -953,9 +953,9 @@ fn main() {\n             42..51 'true | ()': bool\n             49..51 '()': ()\n             57..59 '{}': ()\n-            68..80 '(() | true,)': ((),)\n+            68..80 '(() | true,)': (bool,)\n             69..71 '()': ()\n-            69..78 '() | true': ()\n+            69..78 '() | true': bool\n             74..78 'true': bool\n             74..78 'true': bool\n             84..86 '{}': ()\n@@ -964,19 +964,15 @@ fn main() {\n             96..102 '_ | ()': bool\n             100..102 '()': ()\n             108..110 '{}': ()\n-            119..128 '(() | _,)': ((),)\n+            119..128 '(() | _,)': (bool,)\n             120..122 '()': ()\n-            120..126 '() | _': ()\n+            120..126 '() | _': bool\n             125..126 '_': bool\n             132..134 '{}': ()\n             49..51: expected bool, got ()\n-            68..80: expected (bool,), got ((),)\n             69..71: expected bool, got ()\n-            69..78: expected bool, got ()\n             100..102: expected bool, got ()\n-            119..128: expected (bool,), got ((),)\n             120..122: expected bool, got ()\n-            120..126: expected bool, got ()\n         \"#]],\n     );\n }"}, {"sha": "729780fa0c919903a1be2102cc02a70bc6920c78", "filename": "crates/ide/src/inlay_hints/adjustment.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ec273c3d12b7393f6b81e793ce1c7abd59e3dc67/crates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec273c3d12b7393f6b81e793ce1c7abd59e3dc67/crates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs?ref=ec273c3d12b7393f6b81e793ce1c7abd59e3dc67", "patch": "@@ -606,14 +606,13 @@ fn a() {\n     }\n \n     #[test]\n-    fn bug() {\n+    fn let_stmt_explicit_ty() {\n         check_with_config(\n             InlayHintsConfig { adjustment_hints: AdjustmentHints::Always, ..DISABLED_CONFIG },\n             r#\"\n fn main() {\n-    // These should be identical, but they are not...\n-\n     let () = return;\n+           //^^^^^^<never-to-any>\n     let (): () = return;\n                //^^^^^^<never-to-any>\n }"}]}