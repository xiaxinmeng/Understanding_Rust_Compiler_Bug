{"sha": "e87e0bcc0e82a9936eac11077a25af31a612f127", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4N2UwYmNjMGU4MmE5OTM2ZWFjMTEwNzdhMjVhZjMxYTYxMmYxMjc=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2018-01-29T05:44:04Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2018-02-08T03:41:33Z"}, "message": "Add `-Zteach` documentation\n\nAdd extra inline documentation to E0019, E0016, E0013, E0396, E0017,\nE0018, E0010, E0022, E0030, E0029, E0033, E0026 and E0027.", "tree": {"sha": "9c97fc6d48b30b3e8a761b347bcb5ddab7297522", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c97fc6d48b30b3e8a761b347bcb5ddab7297522"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e87e0bcc0e82a9936eac11077a25af31a612f127", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e87e0bcc0e82a9936eac11077a25af31a612f127", "html_url": "https://github.com/rust-lang/rust/commit/e87e0bcc0e82a9936eac11077a25af31a612f127", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e87e0bcc0e82a9936eac11077a25af31a612f127/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29c8276cee4a0eab7e0634ff25c6b47bd9f87c6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/29c8276cee4a0eab7e0634ff25c6b47bd9f87c6c", "html_url": "https://github.com/rust-lang/rust/commit/29c8276cee4a0eab7e0634ff25c6b47bd9f87c6c"}], "stats": {"total": 284, "additions": 229, "deletions": 55}, "files": [{"sha": "8b4b9aaeac848b98c85c1eb3c2aa5b84422314b6", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e87e0bcc0e82a9936eac11077a25af31a612f127/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87e0bcc0e82a9936eac11077a25af31a612f127/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=e87e0bcc0e82a9936eac11077a25af31a612f127", "patch": "@@ -175,6 +175,10 @@ fn configure_main(this: &mut EntryContext) {\n             err.emit();\n             this.session.abort_if_errors();\n         } else {\n+            if this.session.teach(&err.get_code().unwrap()) {\n+                err.note(\"If you don't know the basics of Rust, you can go look to the Rust Book \\\n+                          to get started: https://doc.rust-lang.org/book/\");\n+            }\n             err.emit();\n         }\n     }"}, {"sha": "ed1e1ebfc9f0ac8a93f56c3be8c7cf525368e724", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 138, "deletions": 30, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/e87e0bcc0e82a9936eac11077a25af31a612f127/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87e0bcc0e82a9936eac11077a25af31a612f127/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=e87e0bcc0e82a9936eac11077a25af31a612f127", "patch": "@@ -170,18 +170,40 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n     fn not_const(&mut self) {\n         self.add(Qualif::NOT_CONST);\n         if self.mode != Mode::Fn {\n-            span_err!(self.tcx.sess, self.span, E0019,\n-                      \"{} contains unimplemented expression type\", self.mode);\n+            let mut err = struct_span_err!(\n+                self.tcx.sess,\n+                self.span,\n+                E0019,\n+                \"{} contains unimplemented expression type\",\n+                self.mode\n+            );\n+            if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                err.note(\"A function call isn't allowed in the const's initialization expression \\\n+                          because the expression's value must be known at compile-time.\");\n+                err.note(\"Remember: you can't use a function call inside a const's initialization \\\n+                          expression! However, you can use it anywhere else.\");\n+            }\n+            err.emit();\n         }\n     }\n \n     /// Error about extra statements in a constant.\n     fn statement_like(&mut self) {\n         self.add(Qualif::NOT_CONST);\n         if self.mode != Mode::Fn {\n-            span_err!(self.tcx.sess, self.span, E0016,\n-                      \"blocks in {}s are limited to items and tail expressions\",\n-                      self.mode);\n+            let mut err = struct_span_err!(\n+                self.tcx.sess,\n+                self.span,\n+                E0016,\n+                \"blocks in {}s are limited to items and tail expressions\",\n+                self.mode\n+            );\n+            if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                err.note(\"Blocks in constants may only contain items (such as constant, function \\\n+                          definition, etc...) and a tail expression.\");\n+                err.help(\"To avoid it, you have to replace the non-item object.\");\n+            }\n+            err.emit();\n         }\n     }\n \n@@ -474,9 +496,19 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 }\n \n                 if self.mode == Mode::Const || self.mode == Mode::ConstFn {\n-                    span_err!(self.tcx.sess, self.span, E0013,\n-                              \"{}s cannot refer to statics, use \\\n-                               a constant instead\", self.mode);\n+                    let mut err = struct_span_err!(self.tcx.sess, self.span, E0013,\n+                                                   \"{}s cannot refer to statics, use \\\n+                                                    a constant instead\", self.mode);\n+                    if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                        err.note(\n+                            \"Static and const variables can refer to other const variables. But a \\\n+                             const variable cannot refer to a static variable.\"\n+                        );\n+                        err.help(\n+                            \"To fix this, the value can be extracted as a const and then used.\"\n+                        );\n+                    }\n+                    err.emit()\n                 }\n             }\n             Place::Projection(ref proj) => {\n@@ -497,13 +529,25 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                             if let ty::TyRawPtr(_) = base_ty.sty {\n                                 this.add(Qualif::NOT_CONST);\n                                 if this.mode != Mode::Fn {\n-                                    struct_span_err!(this.tcx.sess,\n-                                        this.span, E0396,\n+                                    let mut err = struct_span_err!(\n+                                        this.tcx.sess,\n+                                        this.span,\n+                                        E0396,\n                                         \"raw pointers cannot be dereferenced in {}s\",\n-                                        this.mode)\n-                                    .span_label(this.span,\n-                                        \"dereference of raw pointer in constant\")\n-                                    .emit();\n+                                        this.mode\n+                                    );\n+                                    err.span_label(this.span,\n+                                                   \"dereference of raw pointer in constant\");\n+                                    if this.tcx.sess.teach(&err.get_code().unwrap()) {\n+                                        err.note(\n+                                            \"The value behind a raw pointer can't be determined \\\n+                                             at compile-time (or even link-time), which means it \\\n+                                             can't be used in a constant expression.\"\n+                                        );\n+                                        err.help(\"A possible fix is to dereference your pointer \\\n+                                                  at some point in run-time.\");\n+                                    }\n+                                    err.emit();\n                                 }\n                             }\n                         }\n@@ -622,12 +666,22 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     if !allow {\n                         self.add(Qualif::NOT_CONST);\n                         if self.mode != Mode::Fn {\n-                            struct_span_err!(self.tcx.sess,  self.span, E0017,\n-                                             \"references in {}s may only refer \\\n-                                              to immutable values\", self.mode)\n-                                .span_label(self.span, format!(\"{}s require immutable values\",\n-                                                                self.mode))\n-                                .emit();\n+                            let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n+                                                           \"references in {}s may only refer \\\n+                                                            to immutable values\", self.mode);\n+                            err.span_label(self.span, format!(\"{}s require immutable values\",\n+                                                                self.mode));\n+                            if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                                err.note(\"References in statics and constants may only refer to \\\n+                                          immutable values.\\n\\n\\\n+                                          Statics are shared everywhere, and if they refer to \\\n+                                          mutable data one might violate memory safety since \\\n+                                          holding multiple mutable references to shared data is \\\n+                                          not allowed.\\n\\n\\\n+                                          If you really want global mutable state, try using \\\n+                                          static mut or a global UnsafeCell.\");\n+                            }\n+                            err.emit();\n                         }\n                     }\n                 } else {\n@@ -668,9 +722,42 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     (CastTy::FnPtr, CastTy::Int(_)) => {\n                         self.add(Qualif::NOT_CONST);\n                         if self.mode != Mode::Fn {\n-                            span_err!(self.tcx.sess, self.span, E0018,\n-                                      \"raw pointers cannot be cast to integers in {}s\",\n-                                      self.mode);\n+                            let mut err = struct_span_err!(\n+                                self.tcx.sess,\n+                                self.span,\n+                                E0018,\n+                                \"raw pointers cannot be cast to integers in {}s\",\n+                                self.mode\n+                            );\n+                            if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                                err.note(\"\\\n+The value of static and constant integers must be known at compile time. You can't cast a pointer \\\n+to an integer because the address of a pointer can vary.\n+\n+For example, if you write:\n+\n+```\n+static MY_STATIC: u32 = 42;\n+static MY_STATIC_ADDR: usize = &MY_STATIC as *const _ as usize;\n+static WHAT: usize = (MY_STATIC_ADDR^17) + MY_STATIC_ADDR;\n+```\n+\n+Then `MY_STATIC_ADDR` would contain the address of `MY_STATIC`. However, the address can change \\\n+when the program is linked, as well as change between different executions due to ASLR, and many \\\n+linkers would not be able to calculate the value of `WHAT`.\n+\n+On the other hand, static and constant pointers can point either to a known numeric address or to \\\n+the address of a symbol.\n+\n+```\n+static MY_STATIC: u32 = 42;\n+static MY_STATIC_ADDR: &'static u32 = &MY_STATIC;\n+const CONST_ADDR: *const u8 = 0x5f3759df as *const u8;\n+```\n+\n+This does not pose a problem by itself because they can't be accessed directly.\");\n+                            }\n+                            err.emit();\n                         }\n                     }\n                     _ => {}\n@@ -701,10 +788,18 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             Rvalue::NullaryOp(NullOp::Box, _) => {\n                 self.add(Qualif::NOT_CONST);\n                 if self.mode != Mode::Fn {\n-                    struct_span_err!(self.tcx.sess, self.span, E0010,\n-                                     \"allocations are not allowed in {}s\", self.mode)\n-                        .span_label(self.span, format!(\"allocation not allowed in {}s\", self.mode))\n-                        .emit();\n+                    let mut err = struct_span_err!(self.tcx.sess, self.span, E0010,\n+                                                   \"allocations are not allowed in {}s\", self.mode);\n+                    err.span_label(self.span, format!(\"allocation not allowed in {}s\", self.mode));\n+                    if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                        err.note(\n+                            \"The value of statics and constants must be known at compile time, \\\n+                             and they live for the entire lifetime of a program. Creating a boxed \\\n+                             value allocates memory on the heap at runtime, and therefore cannot \\\n+                             be done at compile time.\"\n+                        );\n+                    }\n+                    err.emit();\n                 }\n             }\n \n@@ -930,9 +1025,22 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 // Avoid a generic error for other uses of arguments.\n                 if self.qualif.intersects(Qualif::FN_ARGUMENT) {\n                     let decl = &self.mir.local_decls[index];\n-                    span_err!(self.tcx.sess, decl.source_info.span, E0022,\n-                              \"arguments of constant functions can only \\\n-                               be immutable by-value bindings\");\n+                    let mut err = struct_span_err!(\n+                        self.tcx.sess,\n+                        decl.source_info.span,\n+                        E0022,\n+                        \"arguments of constant functions can only be immutable by-value bindings\"\n+                    );\n+                    if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                        err.note(\"Constant functions are not allowed to mutate anything. Thus, \\\n+                                  binding to an argument with a mutable pattern is not allowed.\");\n+                        err.note(\"Remove any mutable bindings from the argument list to fix this \\\n+                                  error. In case you need to mutate the argument, try lazily \\\n+                                  initializing a global variable instead of using a const fn, or \\\n+                                  refactoring the code to a functional style to avoid mutation if \\\n+                                  possible.\");\n+                    }\n+                    err.emit();\n                     return;\n                 }\n             }"}, {"sha": "59864182a7e406fb0d60bdf300909f9989620317", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e87e0bcc0e82a9936eac11077a25af31a612f127/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87e0bcc0e82a9936eac11077a25af31a612f127/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=e87e0bcc0e82a9936eac11077a25af31a612f127", "patch": "@@ -237,10 +237,20 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n                     Ok(Ordering::Less) |\n                     Ok(Ordering::Equal) => {}\n                     Ok(Ordering::Greater) => {\n-                        struct_span_err!(self.tcx.sess, start.span, E0030,\n-                            \"lower range bound must be less than or equal to upper\")\n-                            .span_label(start.span, \"lower bound larger than upper bound\")\n-                            .emit();\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess,\n+                            start.span,\n+                            E0030,\n+                            \"lower range bound must be less than or equal to upper\"\n+                        );\n+                        err.span_label(start.span, \"lower bound larger than upper bound\");\n+                        if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                            err.note(\"When matching against a range, the compiler verifies that \\\n+                                      the range is non-empty. Range patterns include both \\\n+                                      end-points, so this is equivalent to requiring the start of \\\n+                                      the range to be less than or equal to the end of the range.\");\n+                        }\n+                        err.emit();\n                     }\n                     Err(ErrorReported) => {}\n                 }"}, {"sha": "bf253a88d27c2e270f5da4f44f29e7e605ef817f", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 73, "deletions": 21, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/e87e0bcc0e82a9936eac11077a25af31a612f127/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87e0bcc0e82a9936eac11077a25af31a612f127/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=e87e0bcc0e82a9936eac11077a25af31a612f127", "patch": "@@ -214,12 +214,25 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         end.span\n                     };\n \n-                    struct_span_err!(tcx.sess, span, E0029,\n-                        \"only char and numeric types are allowed in range patterns\")\n-                        .span_label(span, \"ranges require char or numeric types\")\n-                        .note(&format!(\"start type: {}\", self.ty_to_string(lhs_ty)))\n-                        .note(&format!(\"end type: {}\", self.ty_to_string(rhs_ty)))\n-                        .emit();\n+                    let mut err = struct_span_err!(\n+                        tcx.sess,\n+                        span,\n+                        E0029,\n+                        \"only char and numeric types are allowed in range patterns\"\n+                    );\n+                    err.span_label(span, \"ranges require char or numeric types\");\n+                    err.note(&format!(\"start type: {}\", self.ty_to_string(lhs_ty)));\n+                    err.note(&format!(\"end type: {}\", self.ty_to_string(rhs_ty)));\n+                    if tcx.sess.teach(&err.get_code().unwrap()) {\n+                        err.note(\n+                            \"In a match expression, only numbers and characters can be matched \\\n+                             against a range. This is because the compiler checks that the range \\\n+                             is non-empty at compile-time, and is unable to evaluate arbitrary \\\n+                             comparison functions. If you want to capture values of an orderable \\\n+                             type between two end-points, you can use a guard.\"\n+                         );\n+                    }\n+                    err.emit();\n                     return;\n                 }\n \n@@ -505,10 +518,25 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // This is \"x = SomeTrait\" being reduced from\n                     // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n                     let type_str = self.ty_to_string(expected);\n-                    struct_span_err!(self.tcx.sess, span, E0033,\n-                              \"type `{}` cannot be dereferenced\", type_str)\n-                        .span_label(span, format!(\"type `{}` cannot be dereferenced\", type_str))\n-                        .emit();\n+                    let mut err = struct_span_err!(\n+                        self.tcx.sess,\n+                        span,\n+                        E0033,\n+                        \"type `{}` cannot be dereferenced\",\n+                        type_str\n+                    );\n+                    err.span_label(span, format!(\"type `{}` cannot be dereferenced\", type_str));\n+                    if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                        err.note(\"\\\n+This error indicates that a pointer to a trait type cannot be implicitly dereferenced by a \\\n+pattern. Every trait defines a type, but because the size of trait implementors isn't fixed, \\\n+this type has no compile-time size. Therefore, all accesses to trait types must be through \\\n+pointers. If you encounter this error you should try to avoid dereferencing the pointer.\n+\n+You can read more about trait objects in the Trait Objects section of the Reference: \\\n+https://doc.rust-lang.org/reference/types.html#trait-objects\");\n+                    }\n+                    err.emit();\n                     return false\n                 }\n             }\n@@ -881,17 +909,33 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             self.field_ty(span, f, substs)\n                         })\n                         .unwrap_or_else(|| {\n-                            struct_span_err!(tcx.sess, span, E0026,\n-                                             \"{} `{}` does not have a field named `{}`\",\n-                                             kind_name,\n-                                             tcx.item_path_str(variant.did),\n-                                             field.name)\n-                                .span_label(span,\n-                                            format!(\"{} `{}` does not have field `{}`\",\n-                                                     kind_name,\n-                                                     tcx.item_path_str(variant.did),\n-                                                     field.name))\n-                                .emit();\n+                            let mut err = struct_span_err!(\n+                                tcx.sess,\n+                                span,\n+                                E0026,\n+                                \"{} `{}` does not have a field named `{}`\",\n+                                kind_name,\n+                                tcx.item_path_str(variant.did),\n+                                field.name\n+                            );\n+                            err.span_label(span,\n+                                           format!(\"{} `{}` does not have field `{}`\",\n+                                                   kind_name,\n+                                                   tcx.item_path_str(variant.did),\n+                                                   field.name));\n+                            if tcx.sess.teach(&err.get_code().unwrap()) {\n+                                err.note(\n+                                    \"This error indicates that a struct pattern attempted to \\\n+                                     extract a non-existent field from a struct. Struct fields \\\n+                                     are identified by the name used before the colon : so struct \\\n+                                     patterns should resemble the declaration of the struct type \\\n+                                     being matched.\\n\\n\\\n+                                     If you are using shorthand field patterns but want to refer \\\n+                                     to the struct field by a different name, you should rename \\\n+                                     it explicitly.\"\n+                                );\n+                            }\n+                            err.emit();\n \n                             tcx.types.err\n                         })\n@@ -927,6 +971,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if variant.ctor_kind == CtorKind::Fn {\n                     diag.note(\"trying to match a tuple variant with a struct variant pattern\");\n                 }\n+                if tcx.sess.teach(&diag.get_code().unwrap()) {\n+                    diag.note(\n+                        \"This error indicates that a pattern for a struct fails to specify a \\\n+                         sub-pattern for every one of the struct's fields. Ensure that each field \\\n+                         from the struct's definition is mentioned in the pattern, or use `..` to \\\n+                         ignore unwanted fields.\"\n+                    );\n+                }\n                 diag.emit();\n             }\n         }"}]}