{"sha": "1bceb98084b0e1010d123f48785a89bc7ad7e40f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiY2ViOTgwODRiMGUxMDEwZDEyM2Y0ODc4NWE4OWJjN2FkN2U0MGY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-08-11T17:44:26Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-08-11T18:01:23Z"}, "message": "typeck: Modify method resolution to use new object adjustments, and\nto favor inherent methods over extension methods.\n\nThe reason to favor inherent methods is that otherwise an impl\nlike\n\n    impl Foo for @Foo { fn method(&self) { self.method() } }\n\ncauses infinite recursion.  The current change to favor inherent methods is\nrather hacky; the method resolution code is in need of a refactoring.", "tree": {"sha": "8444ffe600298b3fccebdf4134b84c1668c6b7a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8444ffe600298b3fccebdf4134b84c1668c6b7a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1bceb98084b0e1010d123f48785a89bc7ad7e40f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1bceb98084b0e1010d123f48785a89bc7ad7e40f", "html_url": "https://github.com/rust-lang/rust/commit/1bceb98084b0e1010d123f48785a89bc7ad7e40f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1bceb98084b0e1010d123f48785a89bc7ad7e40f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "006c6b6be4499fd999ef3f52996b944263baa220", "url": "https://api.github.com/repos/rust-lang/rust/commits/006c6b6be4499fd999ef3f52996b944263baa220", "html_url": "https://github.com/rust-lang/rust/commit/006c6b6be4499fd999ef3f52996b944263baa220"}], "stats": {"total": 457, "additions": 317, "deletions": 140}, "files": [{"sha": "d6342c582f0525dc21e9cbd5f5d30eb4b3218bf3", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1bceb98084b0e1010d123f48785a89bc7ad7e40f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bceb98084b0e1010d123f48785a89bc7ad7e40f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=1bceb98084b0e1010d123f48785a89bc7ad7e40f", "patch": "@@ -586,8 +586,8 @@ impl tr for method_origin {\n                 }\n             )\n           }\n-          typeck::method_trait(did, m, vstore) => {\n-              typeck::method_trait(did.tr(xcx), m, vstore)\n+          typeck::method_trait(did, m) => {\n+              typeck::method_trait(did.tr(xcx), m)\n           }\n         }\n     }"}, {"sha": "aa7b2e55cdc63b423f0b3a06d4b20ba6ace48ece", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bceb98084b0e1010d123f48785a89bc7ad7e40f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bceb98084b0e1010d123f48785a89bc7ad7e40f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=1bceb98084b0e1010d123f48785a89bc7ad7e40f", "patch": "@@ -290,7 +290,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                  method_num: method_num,\n                  _\n             }) |\n-            method_trait(trait_id, method_num, _) => {\n+            method_trait(trait_id, method_num) => {\n                 if trait_id.crate == LOCAL_CRATE {\n                     match tcx.items.find(&trait_id.node) {\n                         Some(&node_item(item, _)) => {"}, {"sha": "14d3a926231107f24b5932df041dfe5e5deccb89", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bceb98084b0e1010d123f48785a89bc7ad7e40f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bceb98084b0e1010d123f48785a89bc7ad7e40f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=1bceb98084b0e1010d123f48785a89bc7ad7e40f", "patch": "@@ -3131,7 +3131,7 @@ pub fn method_call_type_param_defs(tcx: ctxt,\n           typeck::method_param(typeck::method_param {\n               trait_id: trt_id,\n               method_num: n_mth, _}) |\n-          typeck::method_trait(trt_id, n_mth, _) => {\n+          typeck::method_trait(trt_id, n_mth) => {\n             // ...trait methods bounds, in contrast, include only the\n             // method bounds, so we must preprend the tps from the\n             // trait itself.  This ought to be harmonized."}, {"sha": "352836d81e45926e4d2a4e1bcbc5672cc6ae8135", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 265, "deletions": 129, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/1bceb98084b0e1010d123f48785a89bc7ad7e40f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bceb98084b0e1010d123f48785a89bc7ad7e40f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=1bceb98084b0e1010d123f48785a89bc7ad7e40f", "patch": "@@ -94,6 +94,7 @@ use middle::typeck::{method_static, method_trait};\n use middle::typeck::{param_numbered, param_self, param_index};\n use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n use util::common::indenter;\n+use util::ppaux::Repr;\n \n use std::hashmap::HashSet;\n use std::result;\n@@ -147,9 +148,24 @@ pub fn lookup(\n         check_traits: check_traits,\n         autoderef_receiver: autoderef_receiver,\n     };\n-    let mme = lcx.do_lookup(self_ty);\n-    debug!(\"method lookup for %s yielded %?\", expr.repr(fcx.tcx()), mme);\n-    return mme;\n+\n+    let self_ty = structurally_resolved_type(fcx, self_expr.span, self_ty);\n+    debug!(\"method lookup(self_ty=%s, expr=%s, self_expr=%s)\",\n+           self_ty.repr(fcx.tcx()), expr.repr(fcx.tcx()),\n+           self_expr.repr(fcx.tcx()));\n+\n+    debug!(\"searching inherent candidates\");\n+    lcx.push_inherent_candidates(self_ty);\n+    let mme = lcx.search(self_ty);\n+    if mme.is_some() {\n+        return mme;\n+    }\n+\n+    debug!(\"searching extension candidates\");\n+    lcx.reset_candidates();\n+    lcx.push_bound_candidates(self_ty);\n+    lcx.push_extension_candidates();\n+    return lcx.search(self_ty);\n }\n \n pub struct LookupContext<'self> {\n@@ -173,27 +189,28 @@ pub struct LookupContext<'self> {\n  */\n #[deriving(Clone)]\n pub struct Candidate {\n-    rcvr_ty: ty::t,\n+    rcvr_match_condition: RcvrMatchCondition,\n     rcvr_substs: ty::substs,\n     method_ty: @ty::Method,\n     origin: method_origin,\n }\n \n-impl<'self> LookupContext<'self> {\n-    pub fn do_lookup(&self, self_ty: ty::t) -> Option<method_map_entry> {\n-        let self_ty = structurally_resolved_type(self.fcx,\n-                                                     self.self_expr.span,\n-                                                     self_ty);\n-\n-        debug!(\"do_lookup(self_ty=%s, expr=%s, self_expr=%s)\",\n-               self.ty_to_str(self_ty),\n-               self.expr.repr(self.tcx()),\n-               self.self_expr.repr(self.tcx()));\n-\n-        // Prepare the list of candidates\n-        self.push_inherent_candidates(self_ty);\n-        self.push_extension_candidates();\n+/// This type represents the conditions under which the receiver is\n+/// considered to \"match\" a given method candidate. Typically the test\n+/// is whether the receiver is of a particular type. However, this\n+/// type is the type of the receiver *after accounting for the\n+/// method's self type* (e.g., if the method is an `@self` method, we\n+/// have *already verified* that the receiver is of some type `@T` and\n+/// now we must check that the type `T` is correct).  Unfortunately,\n+/// because traits are not types, this is a pain to do.\n+#[deriving(Clone)]\n+enum RcvrMatchCondition {\n+    RcvrMatchesIfObject(ast::def_id),\n+    RcvrMatchesIfSubtype(ty::t)\n+}\n \n+impl<'self> LookupContext<'self> {\n+    fn search(&self, self_ty: ty::t) -> Option<method_map_entry> {\n         let mut self_ty = self_ty;\n         let mut autoderefs = 0;\n         loop {\n@@ -280,20 +297,10 @@ impl<'self> LookupContext<'self> {\n         let mut self_ty = self_ty;\n         loop {\n             match get(self_ty).sty {\n-                ty_param(p) => {\n-                    self.push_inherent_candidates_from_param(self_ty, p);\n-                }\n-                ty_trait(did, ref substs, store, _, _) => {\n-                    self.push_inherent_candidates_from_trait(\n-                        self_ty, did, substs, store);\n+                ty_trait(did, ref substs, _, _, _) => {\n+                    self.push_inherent_candidates_from_trait(did, substs);\n                     self.push_inherent_impl_candidates_for_type(did);\n                 }\n-                ty_self(self_did) => {\n-                    // Call is of the form \"self.foo()\" and appears in one\n-                    // of a trait's default method implementations.\n-                    self.push_inherent_candidates_from_self(\n-                        self_ty, self_did);\n-                }\n                 ty_enum(did, _) | ty_struct(did, _) => {\n                     if self.check_traits == CheckTraitsAndInherentMethods {\n                         self.push_inherent_impl_candidates_for_type(did);\n@@ -312,7 +319,30 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    pub fn push_extension_candidates(&self) {\n+    fn push_bound_candidates(&self, self_ty: ty::t) {\n+        let mut self_ty = self_ty;\n+        loop {\n+            match get(self_ty).sty {\n+                ty_param(p) => {\n+                    self.push_inherent_candidates_from_param(self_ty, p);\n+                }\n+                ty_self(self_did) => {\n+                    // Call is of the form \"self.foo()\" and appears in one\n+                    // of a trait's default method implementations.\n+                    self.push_inherent_candidates_from_self(\n+                        self_ty, self_did);\n+                }\n+                _ => { /* No bound methods in these types */ }\n+            }\n+\n+            self_ty = match self.deref(self_ty) {\n+                None => { return; }\n+                Some(ty) => { ty }\n+            }\n+        }\n+    }\n+\n+    fn push_extension_candidates(&self) {\n         // If the method being called is associated with a trait, then\n         // find all the impls of that trait.  Each of those are\n         // candidates.\n@@ -333,11 +363,9 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    pub fn push_inherent_candidates_from_trait(&self,\n-                                               self_ty: ty::t,\n+    fn push_inherent_candidates_from_trait(&self,\n                                                did: def_id,\n-                                               substs: &ty::substs,\n-                                               store: ty::TraitStore) {\n+                                               substs: &ty::substs) {\n         debug!(\"push_inherent_candidates_from_trait(did=%s, substs=%s)\",\n                self.did_to_str(did),\n                substs_to_str(self.tcx(), substs));\n@@ -351,41 +379,35 @@ impl<'self> LookupContext<'self> {\n         };\n         let method = ms[index];\n \n-        /* FIXME(#5762) we should transform the vstore in accordance\n-           with the self type\n-\n-        match method.self_type {\n-            ast::sty_region(_) => {\n-                return; // inapplicable\n+        match method.explicit_self {\n+            ast::sty_static => {\n+                return; // not a method we can call with dot notation\n             }\n-            ast::sty_region(_) => vstore_slice(r)\n-            ast::sty_box(_) => vstore_box, // NDM mutability, as per #5762\n-            ast::sty_uniq(_) => vstore_uniq\n+            _ => {}\n         }\n-        */\n \n         // It is illegal to invoke a method on a trait instance that\n-        // refers to the `self` type.  Nonetheless, we substitute\n-        // `trait_ty` for `self` here, because it allows the compiler\n-        // to soldier on.  An error will be reported should this\n-        // candidate be selected if the method refers to `self`.\n+        // refers to the `self` type. An error will be reported by\n+        // `enforce_object_limitations()` if the method refers\n+        // to the `Self` type. Substituting ty_err here allows\n+        // compiler to soldier on.\n         //\n-        // NB: `confirm_candidate()` also relies upon this substitution\n-        // for Self.\n+        // NOTE: `confirm_candidate()` also relies upon this substitution\n+        // for Self. (fix)\n         let rcvr_substs = substs {\n-            self_ty: Some(self_ty),\n+            self_ty: Some(ty::mk_err()),\n             ..(*substs).clone()\n         };\n \n         self.inherent_candidates.push(Candidate {\n-            rcvr_ty: self_ty,\n+            rcvr_match_condition: RcvrMatchesIfObject(did),\n             rcvr_substs: rcvr_substs,\n             method_ty: method,\n-            origin: method_trait(did, index, store)\n+            origin: method_trait(did, index)\n         });\n     }\n \n-    pub fn push_inherent_candidates_from_param(&self,\n+    fn push_inherent_candidates_from_param(&self,\n                                                rcvr_ty: ty::t,\n                                                param_ty: param_ty) {\n         debug!(\"push_inherent_candidates_from_param(param_ty=%?)\",\n@@ -438,11 +460,11 @@ impl<'self> LookupContext<'self> {\n                     let method = trait_methods[pos];\n \n                     let cand = Candidate {\n-                        rcvr_ty: self_ty,\n+                        rcvr_match_condition: RcvrMatchesIfSubtype(self_ty),\n                         rcvr_substs: bound_trait_ref.substs.clone(),\n                         method_ty: method,\n                         origin: method_param(\n-                            method_param {\n+                                             method_param {\n                                 trait_id: bound_trait_ref.def_id,\n                                 method_num: pos,\n                                 param_num: param,\n@@ -507,7 +529,7 @@ impl<'self> LookupContext<'self> {\n         } = impl_self_ty(&vcx, location_info, impl_info.did);\n \n         candidates.push(Candidate {\n-            rcvr_ty: impl_ty,\n+            rcvr_match_condition: RcvrMatchesIfSubtype(impl_ty),\n             rcvr_substs: impl_substs,\n             method_ty: method,\n             origin: method_static(method.def_id)\n@@ -583,6 +605,17 @@ impl<'self> LookupContext<'self> {\n                      autoderefs: autoderefs,\n                      autoref: Some(ty::AutoBorrowVec(region, self_mt.mutbl))}))\n             }\n+            ty_trait(did, ref substs, ty::RegionTraitStore(_), mutbl, bounds) => {\n+                let region =\n+                    self.infcx().next_region_var(\n+                        infer::Autoref(self.expr.span));\n+                (ty::mk_trait(tcx, did, substs.clone(),\n+                              ty::RegionTraitStore(region),\n+                              mutbl, bounds),\n+                 ty::AutoDerefRef(ty::AutoDerefRef {\n+                     autoderefs: autoderefs,\n+                     autoref: Some(ty::AutoBorrowObj(region, mutbl))}))\n+            }\n             _ => {\n                 (self_ty,\n                  ty::AutoDerefRef(ty::AutoDerefRef {\n@@ -612,7 +645,8 @@ impl<'self> LookupContext<'self> {\n          * `~[]` to `&[]`. */\n \n         let tcx = self.tcx();\n-        match ty::get(self_ty).sty {\n+        let sty = ty::get(self_ty).sty.clone();\n+        match sty {\n             ty_evec(mt, vstore_box) |\n             ty_evec(mt, vstore_uniq) |\n             ty_evec(mt, vstore_slice(_)) | // NDM(#3148)\n@@ -659,8 +693,20 @@ impl<'self> LookupContext<'self> {\n                     })\n             }\n \n-            ty_trait(*) | ty_closure(*) => {\n-                // NDM---eventually these should be some variant of autoref\n+            ty_trait(trt_did, trt_substs, _, _, b) => {\n+                // Coerce ~/@/&Trait instances to &Trait.\n+\n+                self.search_for_some_kind_of_autorefd_method(\n+                    AutoBorrowObj, autoderefs, [m_const, m_imm, m_mutbl],\n+                    |trt_mut, reg| {\n+                        ty::mk_trait(tcx, trt_did, trt_substs.clone(),\n+                                     RegionTraitStore(reg), trt_mut, b)\n+                    })\n+            }\n+\n+            ty_closure(*) => {\n+                // This case should probably be handled similarly to\n+                // Trait instances.\n                 None\n             }\n \n@@ -840,31 +886,16 @@ impl<'self> LookupContext<'self> {\n                self.cand_to_str(candidate),\n                self.ty_to_str(fty));\n \n-        self.enforce_trait_instance_limitations(fty, candidate);\n+        self.enforce_object_limitations(fty, candidate);\n         self.enforce_drop_trait_limitations(candidate);\n \n         // static methods should never have gotten this far:\n         assert!(candidate.method_ty.explicit_self != sty_static);\n \n         let transformed_self_ty = match candidate.origin {\n-            method_trait(*) => {\n-                match candidate.method_ty.explicit_self {\n-                    sty_region(*) => {\n-                        // FIXME(#5762) again, preserving existing\n-                        // behavior here which (for &self) desires\n-                        // &@Trait where @Trait is the type of the\n-                        // receiver.  Here we fetch the method's\n-                        // transformed_self_ty which will be something\n-                        // like &'a Self.  We then perform a\n-                        // substitution which will replace Self with\n-                        // @Trait.\n-                        let t = candidate.method_ty.transformed_self_ty.unwrap();\n-                        ty::subst(tcx, &candidate.rcvr_substs, t)\n-                    }\n-                    _ => {\n-                        candidate.rcvr_ty\n-                    }\n-                }\n+            method_trait(trait_def_id, _) => {\n+                self.construct_transformed_self_ty_for_object(\n+                    trait_def_id, candidate)\n             }\n             _ => {\n                 let t = candidate.method_ty.transformed_self_ty.unwrap();\n@@ -954,23 +985,88 @@ impl<'self> LookupContext<'self> {\n         self.fcx.write_ty(self.callee_id, fty);\n         self.fcx.write_substs(self.callee_id, all_substs);\n         method_map_entry {\n-            self_ty: rcvr_ty,\n+            self_ty: transformed_self_ty,\n             self_mode: self_mode,\n             explicit_self: candidate.method_ty.explicit_self,\n             origin: candidate.origin,\n         }\n     }\n \n-    pub fn enforce_trait_instance_limitations(&self,\n-                                              method_fty: ty::t,\n-                                              candidate: &Candidate) {\n+    fn construct_transformed_self_ty_for_object(&self,\n+                                                trait_def_id: ast::def_id,\n+                                                candidate: &Candidate) -> ty::t\n+    {\n         /*!\n+         * This is a bit tricky. We have a match against a trait method\n+         * being invoked on an object, and we want to generate the\n+         * self-type. As an example, consider a trait\n+         *\n+         *     trait Foo {\n+         *         fn r_method<'a>(&'a self);\n+         *         fn m_method(@mut self);\n+         *     }\n          *\n-         * There are some limitations to calling functions through a\n-         * trait instance, because (a) the self type is not known\n+         * Now, assuming that `r_method` is being called, we want the\n+         * result to be `&'a Foo`. Assuming that `m_method` is being\n+         * called, we want the result to be `@mut Foo`. Of course,\n+         * this transformation has already been done as part of\n+         * `candidate.method_ty.transformed_self_ty`, but there the\n+         * type is expressed in terms of `Self` (i.e., `&'a Self`, `@mut Self`).\n+         * Because objects are not standalone types, we can't just substitute\n+         * `s/Self/Foo/`, so we must instead perform this kind of hokey\n+         * match below.\n+         */\n+\n+        let substs = ty::substs {regions: candidate.rcvr_substs.regions.clone(),\n+                                 self_ty: None,\n+                                 tps: candidate.rcvr_substs.tps.clone()};\n+        match candidate.method_ty.explicit_self {\n+            ast::sty_static => {\n+                self.bug(~\"static method for object type receiver\");\n+            }\n+            ast::sty_value => {\n+                ty::mk_err() // error reported in `enforce_object_limitations()`\n+            }\n+            ast::sty_region(*) | ast::sty_box(*) | ast::sty_uniq(*) => {\n+                let transformed_self_ty =\n+                    candidate.method_ty.transformed_self_ty.clone().unwrap();\n+                match ty::get(transformed_self_ty).sty {\n+                    ty::ty_rptr(r, mt) => { // must be sty_region\n+                        ty::mk_trait(self.tcx(), trait_def_id,\n+                                     substs, RegionTraitStore(r), mt.mutbl,\n+                                     ty::EmptyBuiltinBounds())\n+                    }\n+                    ty::ty_box(mt) => { // must be sty_box\n+                        ty::mk_trait(self.tcx(), trait_def_id,\n+                                     substs, BoxTraitStore, mt.mutbl,\n+                                     ty::EmptyBuiltinBounds())\n+                    }\n+                    ty::ty_uniq(mt) => { // must be sty_uniq\n+                        ty::mk_trait(self.tcx(), trait_def_id,\n+                                     substs, UniqTraitStore, mt.mutbl,\n+                                     ty::EmptyBuiltinBounds())\n+                    }\n+                    _ => {\n+                        self.bug(\n+                            fmt!(\"'impossible' transformed_self_ty: %s\",\n+                                 transformed_self_ty.repr(self.tcx())));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn enforce_object_limitations(&self,\n+                                  method_fty: ty::t,\n+                                  candidate: &Candidate)\n+    {\n+        /*!\n+         * There are some limitations to calling functions through an\n+         * object, because (a) the self type is not known\n          * (that's the whole point of a trait instance, after all, to\n          * obscure the self type) and (b) the call must go through a\n-         * vtable and hence cannot be monomorphized. */\n+         * vtable and hence cannot be monomorphized.\n+         */\n \n         match candidate.origin {\n             method_static(*) | method_param(*) => {\n@@ -979,21 +1075,39 @@ impl<'self> LookupContext<'self> {\n             method_trait(*) => {}\n         }\n \n-        if ty::type_has_self(method_fty) {\n+        match candidate.method_ty.explicit_self {\n+            ast::sty_static => { // reason (a) above\n+                self.tcx().sess.span_err(\n+                    self.expr.span,\n+                    \"cannot call a method without a receiver \\\n+                     through an object\");\n+            }\n+\n+            ast::sty_value => { // reason (a) above\n+                self.tcx().sess.span_err(\n+                    self.expr.span,\n+                    \"cannot call a method with a by-value receiver \\\n+                     through an object\");\n+            }\n+\n+            ast::sty_region(*) | ast::sty_box(*) | ast::sty_uniq(*) => {}\n+        }\n+\n+        if ty::type_has_self(method_fty) { // reason (a) above\n             self.tcx().sess.span_err(\n                 self.expr.span,\n                 \"cannot call a method whose type contains a \\\n-                 self-type through a boxed trait\");\n+                 self-type through an object\");\n         }\n \n-        if candidate.method_ty.generics.has_type_params() {\n+        if candidate.method_ty.generics.has_type_params() { // reason (b) above\n             self.tcx().sess.span_err(\n                 self.expr.span,\n-                \"cannot call a generic method through a boxed trait\");\n+                \"cannot call a generic method through an object\");\n         }\n     }\n \n-    pub fn enforce_drop_trait_limitations(&self, candidate: &Candidate) {\n+    fn enforce_drop_trait_limitations(&self, candidate: &Candidate) {\n         // No code can call the finalize method explicitly.\n         let bad;\n         match candidate.origin {\n@@ -1003,7 +1117,7 @@ impl<'self> LookupContext<'self> {\n             // XXX: does this properly enforce this on everything now\n             // that self has been merged in? -sully\n             method_param(method_param { trait_id: trait_id, _ }) |\n-            method_trait(trait_id, _, _) => {\n+            method_trait(trait_id, _) => {\n                 bad = self.tcx().destructor_for_type.contains_key(&trait_id);\n             }\n         }\n@@ -1016,51 +1130,31 @@ impl<'self> LookupContext<'self> {\n \n     // `rcvr_ty` is the type of the expression. It may be a subtype of a\n     // candidate method's `self_ty`.\n-    pub fn is_relevant(&self, rcvr_ty: ty::t, candidate: &Candidate) -> bool {\n+    fn is_relevant(&self, rcvr_ty: ty::t, candidate: &Candidate) -> bool {\n         debug!(\"is_relevant(rcvr_ty=%s, candidate=%s)\",\n                self.ty_to_str(rcvr_ty), self.cand_to_str(candidate));\n \n-        // Check for calls to object methods.  We resolve these differently.\n-        //\n-        // FIXME(#5762)---we don't check that an @self method is only called\n-        // on an @Trait object here and so forth\n-        match candidate.origin {\n-            method_trait(*) => {\n-                match candidate.method_ty.explicit_self {\n-                    sty_static | sty_value => {\n-                        return false;\n-                    }\n-                    sty_region(*) => {\n-                        // just echoing current behavior here, which treats\n-                        // an &self method on an @Trait object as requiring\n-                        // an &@Trait receiver (wacky)\n-                    }\n-                    sty_box(*) | sty_uniq(*) => {\n-                        return self.fcx.can_mk_subty(rcvr_ty,\n-                                                     candidate.rcvr_ty).is_ok();\n-                    }\n-                };\n-            }\n-            _ => {}\n-        }\n-\n-        let result = match candidate.method_ty.explicit_self {\n+        return match candidate.method_ty.explicit_self {\n             sty_static => {\n                 debug!(\"(is relevant?) explicit self is static\");\n                 false\n             }\n \n             sty_value => {\n-                debug!(\"(is relevant?) explicit self is by-value\");\n-                self.fcx.can_mk_subty(rcvr_ty, candidate.rcvr_ty).is_ok()\n+                rcvr_matches_ty(self.fcx, rcvr_ty, candidate)\n             }\n \n             sty_region(_, m) => {\n                 debug!(\"(is relevant?) explicit self is a region\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_rptr(_, mt) => {\n                         mutability_matches(mt.mutbl, m) &&\n-                        self.fcx.can_mk_subty(mt.ty, candidate.rcvr_ty).is_ok()\n+                        rcvr_matches_ty(self.fcx, mt.ty, candidate)\n+                    }\n+\n+                    ty::ty_trait(self_did, _, RegionTraitStore(_), self_m, _) => {\n+                        mutability_matches(self_m, m) &&\n+                        rcvr_matches_object(self_did, candidate)\n                     }\n \n                     _ => false\n@@ -1072,7 +1166,12 @@ impl<'self> LookupContext<'self> {\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_box(mt) => {\n                         mutability_matches(mt.mutbl, m) &&\n-                        self.fcx.can_mk_subty(mt.ty, candidate.rcvr_ty).is_ok()\n+                        rcvr_matches_ty(self.fcx, mt.ty, candidate)\n+                    }\n+\n+                    ty::ty_trait(self_did, _, BoxTraitStore, self_m, _) => {\n+                        mutability_matches(self_m, m) &&\n+                        rcvr_matches_object(self_did, candidate)\n                     }\n \n                     _ => false\n@@ -1083,18 +1182,42 @@ impl<'self> LookupContext<'self> {\n                 debug!(\"(is relevant?) explicit self is a unique pointer\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_uniq(mt) => {\n-                        mutability_matches(mt.mutbl, ast::m_imm) &&\n-                        self.fcx.can_mk_subty(mt.ty, candidate.rcvr_ty).is_ok()\n+                        rcvr_matches_ty(self.fcx, mt.ty, candidate)\n+                    }\n+\n+                    ty::ty_trait(self_did, _, UniqTraitStore, _, _) => {\n+                        rcvr_matches_object(self_did, candidate)\n                     }\n \n                     _ => false\n                 }\n             }\n         };\n \n-        debug!(\"(is relevant?) %s\", if result { \"yes\" } else { \"no\" });\n+        fn rcvr_matches_object(self_did: ast::def_id,\n+                               candidate: &Candidate) -> bool {\n+            match candidate.rcvr_match_condition {\n+                RcvrMatchesIfObject(desired_did) => {\n+                    self_did == desired_did\n+                }\n+                RcvrMatchesIfSubtype(_) => {\n+                    false\n+                }\n+            }\n+        }\n \n-        return result;\n+        fn rcvr_matches_ty(fcx: @mut FnCtxt,\n+                           rcvr_ty: ty::t,\n+                           candidate: &Candidate) -> bool {\n+            match candidate.rcvr_match_condition {\n+                RcvrMatchesIfObject(_) => {\n+                    false\n+                }\n+                RcvrMatchesIfSubtype(of_type) => {\n+                    fcx.can_mk_subty(rcvr_ty, of_type).is_ok()\n+                }\n+            }\n+        }\n \n         fn mutability_matches(self_mutbl: ast::mutability,\n                               candidate_mutbl: ast::mutability) -> bool {\n@@ -1120,7 +1243,7 @@ impl<'self> LookupContext<'self> {\n             method_param(ref mp) => {\n                 type_of_trait_method(self.tcx(), mp.trait_id, mp.method_num)\n             }\n-            method_trait(did, idx, _) => {\n+            method_trait(did, idx) => {\n                 type_of_trait_method(self.tcx(), did, idx)\n             }\n         };\n@@ -1141,7 +1264,7 @@ impl<'self> LookupContext<'self> {\n             method_param(ref mp) => {\n                 self.report_param_candidate(idx, (*mp).trait_id)\n             }\n-            method_trait(trait_did, _, _) => {\n+            method_trait(trait_did, _) => {\n                 self.report_trait_candidate(idx, trait_did)\n             }\n         }\n@@ -1214,3 +1337,16 @@ pub fn get_mode_from_explicit_self(explicit_self: ast::explicit_self_) -> SelfMo\n         _ => ty::ByCopy,\n     }\n }\n+\n+impl Repr for RcvrMatchCondition {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        match *self {\n+            RcvrMatchesIfObject(d) => {\n+                fmt!(\"RcvrMatchesIfObject(%s)\", d.repr(tcx))\n+            }\n+            RcvrMatchesIfSubtype(t) => {\n+                fmt!(\"RcvrMatchesIfSubtype(%s)\", t.repr(tcx))\n+            }\n+        }\n+    }\n+}"}, {"sha": "d034277d44af82526360f62b0b392d739f105d3c", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1bceb98084b0e1010d123f48785a89bc7ad7e40f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bceb98084b0e1010d123f48785a89bc7ad7e40f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=1bceb98084b0e1010d123f48785a89bc7ad7e40f", "patch": "@@ -863,7 +863,8 @@ pub mod guarantor {\n \n             ty::AutoBorrowVec(r, _) |\n             ty::AutoBorrowVecRef(r, _) |\n-            ty::AutoBorrowFn(r) => {\n+            ty::AutoBorrowFn(r) |\n+            ty::AutoBorrowObj(r, _) => {\n                 // In each of these cases, what is being borrowed is\n                 // not the (autoderef'd) expr itself but rather the\n                 // contents of the autoderef'd expression (i.e., what\n@@ -1072,7 +1073,8 @@ pub mod guarantor {\n                     Some(ty::AutoPtr(r, _)) |\n                     Some(ty::AutoBorrowVec(r, _)) |\n                     Some(ty::AutoBorrowVecRef(r, _)) |\n-                    Some(ty::AutoBorrowFn(r)) => {\n+                    Some(ty::AutoBorrowFn(r)) |\n+                    Some(ty::AutoBorrowObj(r, _)) => {\n                         // If there is an autoref, then the result of this\n                         // expression will be some sort of borrowed pointer.\n                         expr_ct.cat.guarantor = None;"}, {"sha": "f2bde146ea79cf338f7660b06cce266470982131", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1bceb98084b0e1010d123f48785a89bc7ad7e40f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bceb98084b0e1010d123f48785a89bc7ad7e40f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=1bceb98084b0e1010d123f48785a89bc7ad7e40f", "patch": "@@ -65,7 +65,7 @@ we may want to adjust precisely when coercions occur.\n */\n \n \n-use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowFn};\n+use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowFn, AutoBorrowObj};\n use middle::ty::{AutoDerefRef};\n use middle::ty::{vstore_slice, vstore_box, vstore_uniq};\n use middle::ty::{mt};\n@@ -121,6 +121,12 @@ impl Coerce {\n                 };\n             }\n \n+            ty::ty_trait(_, _, ty::RegionTraitStore(*), _, _) => {\n+                return do self.unpack_actual_value(a) |sty_a| {\n+                    self.coerce_borrowed_object(a, sty_a, b)\n+                };\n+            }\n+\n             ty::ty_ptr(mt_b) => {\n                 return do self.unpack_actual_value(a) |sty_a| {\n                     self.coerce_unsafe_ptr(a, sty_a, b, mt_b)\n@@ -265,6 +271,40 @@ impl Coerce {\n         })))\n     }\n \n+    fn coerce_borrowed_object(&self,\n+                              a: ty::t,\n+                              sty_a: &ty::sty,\n+                              b: ty::t) -> CoerceResult\n+    {\n+        debug!(\"coerce_borrowed_object(a=%s, sty_a=%?, b=%s)\",\n+               a.inf_str(self.infcx), sty_a,\n+               b.inf_str(self.infcx));\n+\n+        let tcx = self.infcx.tcx;\n+        let r_a = self.infcx.next_region_var(Coercion(self.trace));\n+        let trt_mut;\n+\n+        let a_borrowed = match *sty_a {\n+            ty::ty_trait(_, _, ty::RegionTraitStore(_), _, _) => {\n+                return self.subtype(a, b);\n+            }\n+            ty::ty_trait(did, ref substs, _, m, b) => {\n+                trt_mut = m;\n+                ty::mk_trait(tcx, did, substs.clone(),\n+                             ty::RegionTraitStore(r_a), m, b)\n+            }\n+            _ => {\n+                return self.subtype(a, b);\n+            }\n+        };\n+\n+        if_ok!(self.tys(a_borrowed, b));\n+        Ok(Some(@AutoDerefRef(AutoDerefRef {\n+            autoderefs: 0,\n+            autoref: Some(AutoBorrowObj(r_a, trt_mut))\n+        })))\n+    }\n+\n     pub fn coerce_borrowed_fn(&self,\n                               a: ty::t,\n                               sty_a: &ty::sty,"}, {"sha": "53ae80f19facc3354325fcdd3c873c24724162bd", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bceb98084b0e1010d123f48785a89bc7ad7e40f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bceb98084b0e1010d123f48785a89bc7ad7e40f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=1bceb98084b0e1010d123f48785a89bc7ad7e40f", "patch": "@@ -88,7 +88,7 @@ pub enum method_origin {\n     method_param(method_param),\n \n     // method invoked on a trait instance\n-    method_trait(ast::def_id, uint, ty::TraitStore),\n+    method_trait(ast::def_id, uint),\n \n }\n "}, {"sha": "3bc0a7167e9bdd8a2ce7f59c3e466f59293c5ab0", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1bceb98084b0e1010d123f48785a89bc7ad7e40f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bceb98084b0e1010d123f48785a89bc7ad7e40f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=1bceb98084b0e1010d123f48785a89bc7ad7e40f", "patch": "@@ -747,9 +747,8 @@ impl Repr for typeck::method_origin {\n             &typeck::method_param(ref p) => {\n                 p.repr(tcx)\n             }\n-            &typeck::method_trait(def_id, n, st) => {\n-                fmt!(\"method_trait(%s, %?, %s)\", def_id.repr(tcx), n,\n-                     st.repr(tcx))\n+            &typeck::method_trait(def_id, n) => {\n+                fmt!(\"method_trait(%s, %?)\", def_id.repr(tcx), n)\n             }\n         }\n     }"}]}