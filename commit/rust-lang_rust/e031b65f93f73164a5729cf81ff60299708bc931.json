{"sha": "e031b65f93f73164a5729cf81ff60299708bc931", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwMzFiNjVmOTNmNzMxNjRhNTcyOWNmODFmZjYwMjk5NzA4YmM5MzE=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-10-15T16:41:57Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-10-15T16:41:57Z"}, "message": "Merge #110\n\n110: Signature help r=matklad a=kjeremy\n\n@matklad Once this is in shape I would like to add tests. I think a separate PR should be done for returning documentation information and markdown.\r\n\r\nFixes #102 \n\nCo-authored-by: Jeremy A. Kolb <jkolb@ara.com>", "tree": {"sha": "1a891b75af3b436549381e8726c48ec5028a8341", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a891b75af3b436549381e8726c48ec5028a8341"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e031b65f93f73164a5729cf81ff60299708bc931", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e031b65f93f73164a5729cf81ff60299708bc931", "html_url": "https://github.com/rust-lang/rust/commit/e031b65f93f73164a5729cf81ff60299708bc931", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e031b65f93f73164a5729cf81ff60299708bc931/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "8cec1d986161298dbe9cc53f5477e87bfe5d0f47", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cec1d986161298dbe9cc53f5477e87bfe5d0f47", "html_url": "https://github.com/rust-lang/rust/commit/8cec1d986161298dbe9cc53f5477e87bfe5d0f47"}, {"sha": "c9909f42ba4adf55b1e73e7118b48f1b10c80ac6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9909f42ba4adf55b1e73e7118b48f1b10c80ac6", "html_url": "https://github.com/rust-lang/rust/commit/c9909f42ba4adf55b1e73e7118b48f1b10c80ac6"}], "stats": {"total": 327, "additions": 315, "deletions": 12}, "files": [{"sha": "faf945a41f037f478355a667fa7e99aac6248535", "filename": "crates/ra_analysis/src/descriptors.rs", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e031b65f93f73164a5729cf81ff60299708bc931/crates%2Fra_analysis%2Fsrc%2Fdescriptors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e031b65f93f73164a5729cf81ff60299708bc931/crates%2Fra_analysis%2Fsrc%2Fdescriptors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors.rs?ref=e031b65f93f73164a5729cf81ff60299708bc931", "patch": "@@ -4,7 +4,8 @@ use std::{\n use relative_path::RelativePathBuf;\n use ra_syntax::{\n     SmolStr,\n-    ast::{self, NameOwner},\n+    ast::{self, NameOwner, AstNode},\n+    text_utils::is_subrange\n };\n use {\n     FileId,\n@@ -218,3 +219,56 @@ fn resolve_submodule(\n     }\n     (points_to, problem)\n }\n+\n+#[derive(Debug, Clone)]\n+pub struct FnDescriptor {\n+    pub name: String,\n+    pub label : String,\n+    pub ret_type: Option<String>,\n+    pub params: Vec<String>,\n+}\n+\n+impl FnDescriptor {\n+    pub fn new(node: ast::FnDef) -> Option<Self> {\n+        let name = node.name()?.text().to_string();\n+\n+        // Strip the body out for the label.\n+        let label : String = if let Some(body) = node.body() {\n+            let body_range = body.syntax().range();\n+            let label : String = node.syntax().children()\n+                .filter(|child| !is_subrange(body_range, child.range()))\n+                .map(|node| node.text().to_string())\n+                .collect();\n+            label\n+        } else {\n+            node.syntax().text().to_string()\n+        };\n+\n+        let params = FnDescriptor::param_list(node);\n+        let ret_type = node.ret_type().map(|r| r.syntax().text().to_string());\n+\n+        Some(FnDescriptor {\n+            name,\n+            ret_type,\n+            params,\n+            label\n+        })\n+    }\n+\n+    fn param_list(node: ast::FnDef) -> Vec<String> {\n+        let mut res = vec![];\n+        if let Some(param_list) = node.param_list() {\n+            if let Some(self_param) = param_list.self_param() {\n+                res.push(self_param.syntax().text().to_string())\n+            }\n+\n+            // Maybe use param.pat here? See if we can just extract the name?\n+            //res.extend(param_list.params().map(|p| p.syntax().text().to_string()));\n+            res.extend(param_list.params()\n+                .filter_map(|p| p.pat())\n+                .map(|pat| pat.syntax().text().to_string())\n+            );\n+        }\n+        res\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "aad54b977133d32fc185cd713e3b5ea66f527823", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 108, "deletions": 4, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/e031b65f93f73164a5729cf81ff60299708bc931/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e031b65f93f73164a5729cf81ff60299708bc931/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=e031b65f93f73164a5729cf81ff60299708bc931", "patch": "@@ -12,19 +12,18 @@ use relative_path::RelativePath;\n use rustc_hash::FxHashSet;\n use ra_editor::{self, FileSymbol, LineIndex, find_node_at_offset, LocalEdit, resolve_local_name};\n use ra_syntax::{\n-    TextUnit, TextRange, SmolStr, File, AstNode,\n+    TextUnit, TextRange, SmolStr, File, AstNode, SyntaxNodeRef,\n     SyntaxKind::*,\n-    ast::{self, NameOwner},\n+    ast::{self, NameOwner, ArgListOwner, Expr},\n };\n \n use {\n     FileId, FileResolver, Query, Diagnostic, SourceChange, SourceFileEdit, Position, FileSystemEdit,\n     JobToken, CrateGraph, CrateId,\n     roots::{SourceRoot, ReadonlySourceRoot, WritableSourceRoot},\n-    descriptors::{ModuleTreeDescriptor, Problem},\n+    descriptors::{FnDescriptor, ModuleTreeDescriptor, Problem},\n };\n \n-\n #[derive(Clone, Debug)]\n pub(crate) struct FileResolverImp {\n     inner: Arc<FileResolver>\n@@ -306,6 +305,68 @@ impl AnalysisImpl {\n             .collect()\n     }\n \n+    pub fn resolve_callable(&self, file_id: FileId, offset: TextUnit, token: &JobToken)\n+        -> Option<(FnDescriptor, Option<usize>)> {\n+\n+        let root = self.root(file_id);\n+        let file = root.syntax(file_id);\n+        let syntax = file.syntax();\n+\n+        // Find the calling expression and it's NameRef\n+        let calling_node = FnCallNode::with_node(syntax, offset)?;\n+        let name_ref = calling_node.name_ref()?;\n+\n+        // Resolve the function's NameRef (NOTE: this isn't entirely accurate).\n+        let file_symbols = self.index_resolve(name_ref, token);\n+        for (_, fs) in file_symbols {\n+            if fs.kind == FN_DEF {\n+                if let Some(fn_def) = find_node_at_offset(syntax, fs.node_range.start()) {\n+                    if let Some(descriptor) = FnDescriptor::new(fn_def) {\n+                        // If we have a calling expression let's find which argument we are on\n+                        let mut current_parameter = None;\n+\n+                        let num_params = descriptor.params.len();\n+                        let has_self = fn_def.param_list()\n+                            .and_then(|l| l.self_param())\n+                            .is_some();\n+\n+                        if num_params == 1 {\n+                            if !has_self {\n+                                current_parameter = Some(1);\n+                            }\n+                        } else if num_params > 1 {\n+                            // Count how many parameters into the call we are.\n+                            // TODO: This is best effort for now and should be fixed at some point.\n+                            // It may be better to see where we are in the arg_list and then check\n+                            // where offset is in that list (or beyond).\n+                            // Revisit this after we get documentation comments in.\n+                            if let Some(ref arg_list) = calling_node.arg_list() {\n+                                let start = arg_list.syntax().range().start();\n+\n+                                let range_search = TextRange::from_to(start, offset);\n+                                let mut commas: usize = arg_list.syntax().text()\n+                                    .slice(range_search).to_string()\n+                                    .matches(\",\")\n+                                    .count();\n+\n+                                // If we have a method call eat the first param since it's just self.\n+                                if has_self {\n+                                    commas = commas + 1;\n+                                }\n+\n+                                current_parameter = Some(commas);\n+                            }\n+                        }\n+\n+                        return Some((descriptor, current_parameter));\n+                    }\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n     fn index_resolve(&self, name_ref: ast::NameRef, token: &JobToken) -> Vec<(FileId, FileSymbol)> {\n         let name = name_ref.text();\n         let mut query = Query::new(name.to_string());\n@@ -355,3 +416,46 @@ impl CrateGraph {\n         Some(crate_id)\n     }\n }\n+\n+enum FnCallNode<'a> {\n+    CallExpr(ast::CallExpr<'a>),\n+    MethodCallExpr(ast::MethodCallExpr<'a>)\n+}\n+\n+impl<'a> FnCallNode<'a> {\n+    pub fn with_node(syntax: SyntaxNodeRef, offset: TextUnit) -> Option<FnCallNode> {\n+        if let Some(expr) = find_node_at_offset::<ast::CallExpr>(syntax, offset) {\n+            return Some(FnCallNode::CallExpr(expr));\n+        }\n+        if let Some(expr) = find_node_at_offset::<ast::MethodCallExpr>(syntax, offset) {\n+            return Some(FnCallNode::MethodCallExpr(expr));\n+        }\n+        None\n+    }\n+\n+    pub fn name_ref(&self) -> Option<ast::NameRef> {\n+        match *self {\n+            FnCallNode::CallExpr(call_expr) => {\n+                Some(match call_expr.expr()? {\n+                    Expr::PathExpr(path_expr) => {\n+                        path_expr.path()?.segment()?.name_ref()?\n+                    },\n+                    _ => return None\n+                })\n+            },\n+\n+            FnCallNode::MethodCallExpr(call_expr) => {\n+                call_expr.syntax().children()\n+                    .filter_map(ast::NameRef::cast)\n+                    .nth(0)\n+            }\n+        }\n+    }\n+\n+    pub fn arg_list(&self) -> Option<ast::ArgList> {\n+        match *self {\n+            FnCallNode::CallExpr(expr) => expr.arg_list(),\n+            FnCallNode::MethodCallExpr(expr) => expr.arg_list()\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "1aca72ae0073217f6bcc4511ccc4733da3ed8ee9", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e031b65f93f73164a5729cf81ff60299708bc931/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e031b65f93f73164a5729cf81ff60299708bc931/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=e031b65f93f73164a5729cf81ff60299708bc931", "patch": "@@ -38,6 +38,7 @@ pub use ra_editor::{\n     Fold, FoldKind\n };\n pub use job::{JobToken, JobHandle};\n+pub use descriptors::FnDescriptor;\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct FileId(pub u32);\n@@ -236,6 +237,11 @@ impl Analysis {\n         let file = self.imp.file_syntax(file_id);\n         ra_editor::folding_ranges(&file)\n     }\n+\n+    pub fn resolve_callable(&self, file_id: FileId, offset: TextUnit, token: &JobToken)\n+        -> Option<(FnDescriptor, Option<usize>)> {\n+        self.imp.resolve_callable(file_id, offset, token)\n+    }\n }\n \n #[derive(Debug)]"}, {"sha": "755640fb4198cc927c8c40a9cad8514d6fae418d", "filename": "crates/ra_analysis/tests/tests.rs", "status": "modified", "additions": 98, "deletions": 4, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/e031b65f93f73164a5729cf81ff60299708bc931/crates%2Fra_analysis%2Ftests%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e031b65f93f73164a5729cf81ff60299708bc931/crates%2Fra_analysis%2Ftests%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Ftests%2Ftests.rs?ref=e031b65f93f73164a5729cf81ff60299708bc931", "patch": "@@ -1,6 +1,8 @@\n extern crate relative_path;\n extern crate ra_analysis;\n extern crate rustc_hash;\n+extern crate ra_editor;\n+extern crate ra_syntax;\n extern crate test_utils;\n \n use std::{\n@@ -9,8 +11,8 @@ use std::{\n \n use rustc_hash::FxHashMap;\n use relative_path::{RelativePath, RelativePathBuf};\n-use ra_analysis::{Analysis, AnalysisHost, FileId, FileResolver, JobHandle, CrateGraph, CrateId};\n-use test_utils::assert_eq_dbg;\n+use ra_analysis::{Analysis, AnalysisHost, FileId, FileResolver, JobHandle, CrateGraph, CrateId, FnDescriptor};\n+use test_utils::{assert_eq_dbg, extract_offset};\n \n #[derive(Debug)]\n struct FileMap(Vec<(FileId, RelativePathBuf)>);\n@@ -39,7 +41,7 @@ impl FileResolver for FileMap {\n     }\n }\n \n-fn analysis_host(files: &'static [(&'static str, &'static str)]) -> AnalysisHost {\n+fn analysis_host(files: &[(&str, &str)]) -> AnalysisHost {\n     let mut host = AnalysisHost::new();\n     let mut file_map = Vec::new();\n     for (id, &(path, contents)) in files.iter().enumerate() {\n@@ -53,10 +55,20 @@ fn analysis_host(files: &'static [(&'static str, &'static str)]) -> AnalysisHost\n     host\n }\n \n-fn analysis(files: &'static [(&'static str, &'static str)]) -> Analysis {\n+fn analysis(files: &[(&str, &str)]) -> Analysis {\n     analysis_host(files).analysis()\n }\n \n+fn get_signature(text: &str) -> (FnDescriptor, Option<usize>) {\n+    let (offset, code) = extract_offset(text);\n+    let code = code.as_str();\n+\n+    let (_handle, token) = JobHandle::new();\n+    let snap = analysis(&[(\"/lib.rs\", code)]);\n+\n+    snap.resolve_callable(FileId(1), offset, &token).unwrap()\n+}\n+\n #[test]\n fn test_resolve_module() {\n     let snap = analysis(&[\n@@ -145,3 +157,85 @@ fn test_resolve_crate_root() {\n         vec![CrateId(1)],\n     );\n }\n+\n+#[test]\n+fn test_fn_signature_two_args_first() {\n+    let (desc, param) = get_signature(\n+r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo(<|>3, ); }\"#);\n+\n+    assert_eq!(desc.name, \"foo\".to_string());\n+    assert_eq!(desc.params, vec!(\"x\".to_string(),\"y\".to_string()));\n+    assert_eq!(desc.ret_type, Some(\"-> u32\".into()));\n+    assert_eq!(param, Some(0));\n+}\n+\n+#[test]\n+fn test_fn_signature_two_args_second() {\n+    let (desc, param) = get_signature(\n+        r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo(3, <|>); }\"#);\n+\n+    assert_eq!(desc.name, \"foo\".to_string());\n+    assert_eq!(desc.params, vec!(\"x\".to_string(),\"y\".to_string()));\n+    assert_eq!(desc.ret_type, Some(\"-> u32\".into()));\n+    assert_eq!(param, Some(1));\n+}\n+\n+#[test]\n+fn test_fn_signature_for_impl() {\n+    let (desc, param) = get_signature(\n+r#\"struct F; impl F { pub fn new() { F{}} }\n+fn bar() {let _ : F = F::new(<|>);}\"#);\n+\n+    assert_eq!(desc.name, \"new\".to_string());\n+    assert_eq!(desc.params, Vec::<String>::new());\n+    assert_eq!(desc.ret_type, None);\n+    assert_eq!(param, None);\n+}\n+\n+#[test]\n+fn test_fn_signature_for_method_self() {\n+    let (desc, param) = get_signature(\n+r#\"struct F;\n+impl F {\n+    pub fn new() -> F{\n+        F{}\n+    }\n+\n+    pub fn do_it(&self) {}\n+}\n+\n+fn bar() {\n+    let f : F = F::new();\n+    f.do_it(<|>);\n+}\"#);\n+\n+    assert_eq!(desc.name, \"do_it\".to_string());\n+    assert_eq!(desc.params, vec![\"&self\".to_string()]);\n+    assert_eq!(desc.ret_type, None);\n+    assert_eq!(param, None);\n+}\n+\n+#[test]\n+fn test_fn_signature_for_method_with_arg() {\n+    let (desc, param) = get_signature(\n+r#\"struct F;\n+impl F {\n+    pub fn new() -> F{\n+        F{}\n+    }\n+\n+    pub fn do_it(&self, x: i32) {}\n+}\n+\n+fn bar() {\n+    let f : F = F::new();\n+    f.do_it(<|>);\n+}\"#);\n+\n+    assert_eq!(desc.name, \"do_it\".to_string());\n+    assert_eq!(desc.params, vec![\"&self\".to_string(), \"x\".to_string()]);\n+    assert_eq!(desc.ret_type, None);\n+    assert_eq!(param, Some(1));\n+}\n\\ No newline at end of file"}, {"sha": "5598ec75f966be1547ab56f808cb5e3e301c8693", "filename": "crates/ra_lsp_server/src/caps.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e031b65f93f73164a5729cf81ff60299708bc931/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e031b65f93f73164a5729cf81ff60299708bc931/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs?ref=e031b65f93f73164a5729cf81ff60299708bc931", "patch": "@@ -7,6 +7,7 @@ use languageserver_types::{\n     TextDocumentSyncKind,\n     ExecuteCommandOptions,\n     CompletionOptions,\n+    SignatureHelpOptions,\n     DocumentOnTypeFormattingOptions,\n };\n \n@@ -26,7 +27,9 @@ pub fn server_capabilities() -> ServerCapabilities {\n             resolve_provider: None,\n             trigger_characters: None,\n         }),\n-        signature_help_provider: None,\n+        signature_help_provider: Some(SignatureHelpOptions {\n+            trigger_characters: Some(vec![\"(\".to_string(), \",\".to_string()])\n+        }),\n         definition_provider: Some(true),\n         type_definition_provider: None,\n         implementation_provider: None,"}, {"sha": "f65e2a88909417c6d60deaf2095c17d6be4431b1", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e031b65f93f73164a5729cf81ff60299708bc931/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e031b65f93f73164a5729cf81ff60299708bc931/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=e031b65f93f73164a5729cf81ff60299708bc931", "patch": "@@ -411,6 +411,42 @@ pub fn handle_folding_range(\n     Ok(res)\n }\n \n+pub fn handle_signature_help(\n+    world: ServerWorld,\n+    params: req::TextDocumentPositionParams,\n+    token: JobToken,\n+) -> Result<Option<req::SignatureHelp>> {\n+    use languageserver_types::{ParameterInformation, SignatureInformation};\n+\n+    let file_id = params.text_document.try_conv_with(&world)?;\n+    let line_index = world.analysis().file_line_index(file_id);\n+    let offset = params.position.conv_with(&line_index);\n+\n+    if let Some((descriptor, active_param)) = world.analysis().resolve_callable(file_id, offset, &token) {\n+        let parameters : Vec<ParameterInformation> =\n+            descriptor.params.iter().map(|param|\n+                ParameterInformation {\n+                    label: param.clone(),\n+                    documentation: None\n+                }\n+            ).collect();\n+\n+        let sig_info = SignatureInformation {\n+            label: descriptor.label,\n+            documentation: None,\n+            parameters: Some(parameters)\n+        };\n+\n+        Ok(Some(req::SignatureHelp {\n+            signatures: vec![sig_info],\n+            active_signature: Some(0),\n+            active_parameter: active_param.map(|a| a as u64)\n+        }))\n+    } else {\n+        Ok(None)\n+    }\n+}\n+\n pub fn handle_code_action(\n     world: ServerWorld,\n     params: req::CodeActionParams,"}, {"sha": "f4e7cfc330c2eda984de27e4a2f8946a50c3a2c4", "filename": "crates/ra_lsp_server/src/main_loop/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e031b65f93f73164a5729cf81ff60299708bc931/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e031b65f93f73164a5729cf81ff60299708bc931/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fmod.rs?ref=e031b65f93f73164a5729cf81ff60299708bc931", "patch": "@@ -255,6 +255,7 @@ fn on_request(\n         .on::<req::Completion>(handlers::handle_completion)?\n         .on::<req::CodeActionRequest>(handlers::handle_code_action)?\n         .on::<req::FoldingRangeRequest>(handlers::handle_folding_range)?\n+        .on::<req::SignatureHelpRequest>(handlers::handle_signature_help)?\n         .finish();\n     match req {\n         Ok((id, handle)) => {"}, {"sha": "1630edf7faee9d22c6b7e5b81f43e514900ef632", "filename": "crates/ra_lsp_server/src/req.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e031b65f93f73164a5729cf81ff60299708bc931/crates%2Fra_lsp_server%2Fsrc%2Freq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e031b65f93f73164a5729cf81ff60299708bc931/crates%2Fra_lsp_server%2Fsrc%2Freq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Freq.rs?ref=e031b65f93f73164a5729cf81ff60299708bc931", "patch": "@@ -14,6 +14,7 @@ pub use languageserver_types::{\n     CompletionParams, CompletionResponse,\n     DocumentOnTypeFormattingParams,\n     TextDocumentEdit,\n+    SignatureHelp, Hover\n };\n \n pub enum SyntaxTree {}"}, {"sha": "48c9038dc1afe8157f28c5ff5c0d0c4d8f5505a9", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e031b65f93f73164a5729cf81ff60299708bc931/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e031b65f93f73164a5729cf81ff60299708bc931/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=e031b65f93f73164a5729cf81ff60299708bc931", "patch": "@@ -1387,7 +1387,11 @@ impl<'a> AstNode<'a> for PathExpr<'a> {\n     fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n }\n \n-impl<'a> PathExpr<'a> {}\n+impl<'a> PathExpr<'a> {\n+    pub fn path(self) -> Option<Path<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // PathPat\n #[derive(Debug, Clone, Copy)]"}, {"sha": "a904f750550d39a0fce3c0a606855e70cec93d64", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e031b65f93f73164a5729cf81ff60299708bc931/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/e031b65f93f73164a5729cf81ff60299708bc931/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=e031b65f93f73164a5729cf81ff60299708bc931", "patch": "@@ -342,7 +342,7 @@ Grammar(\n         \"TupleExpr\": (),\n         \"ArrayExpr\": (),\n         \"ParenExpr\": (),\n-        \"PathExpr\": (),\n+        \"PathExpr\": (options: [\"Path\"]),\n         \"LambdaExpr\": (\n             options: [\n                 \"ParamList\","}]}