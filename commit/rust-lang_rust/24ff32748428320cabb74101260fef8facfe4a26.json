{"sha": "24ff32748428320cabb74101260fef8facfe4a26", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ZmYzMjc0ODQyODMyMGNhYmI3NDEwMTI2MGZlZjhmYWNmZTRhMjY=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-03-14T16:12:35Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-03-21T17:36:22Z"}, "message": "Add `fn clear_bit` method on BitSlice trait for setting a bit to zero.", "tree": {"sha": "cca80d45f49a302cba2b90d84e4dc2658f4280dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cca80d45f49a302cba2b90d84e4dc2658f4280dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24ff32748428320cabb74101260fef8facfe4a26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24ff32748428320cabb74101260fef8facfe4a26", "html_url": "https://github.com/rust-lang/rust/commit/24ff32748428320cabb74101260fef8facfe4a26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24ff32748428320cabb74101260fef8facfe4a26/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5757e65f7a23d5b946ed8535c966834f95a5e7bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/5757e65f7a23d5b946ed8535c966834f95a5e7bb", "html_url": "https://github.com/rust-lang/rust/commit/5757e65f7a23d5b946ed8535c966834f95a5e7bb"}], "stats": {"total": 193, "additions": 111, "deletions": 82}, "files": [{"sha": "a4aa7ae15744dcb0778eb7711e4470737d775098", "filename": "src/librustc_borrowck/bitslice.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/24ff32748428320cabb74101260fef8facfe4a26/src%2Flibrustc_borrowck%2Fbitslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ff32748428320cabb74101260fef8facfe4a26/src%2Flibrustc_borrowck%2Fbitslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fbitslice.rs?ref=24ff32748428320cabb74101260fef8facfe4a26", "patch": "@@ -13,11 +13,26 @@ use std::mem;\n /// `BitSlice` provides helper methods for treating a `[usize]`\n /// as a bitvector.\n pub trait BitSlice {\n+    fn clear_bit(&mut self, idx: usize) -> bool;\n     fn set_bit(&mut self, idx: usize) -> bool;\n     fn get_bit(&self, idx: usize) -> bool;\n }\n \n impl BitSlice for [usize] {\n+    /// Clears bit at `idx` to 0; returns true iff this changed `self.`\n+    fn clear_bit(&mut self, idx: usize) -> bool {\n+        let words = self;\n+        debug!(\"clear_bit: words={} idx={}\",\n+               bits_to_string(words, words.len() * mem::size_of::<usize>()), bit_str(idx));\n+        let BitLookup { word, bit_in_word, bit_mask } = bit_lookup(idx);\n+        debug!(\"word={} bit_in_word={} bit_mask={}\", word, bit_in_word, bit_mask);\n+        let oldv = words[word];\n+        let newv = oldv & !bit_mask;\n+        words[word] = newv;\n+        oldv != newv\n+    }\n+\n+    /// Sets bit at `idx` to 1; returns true iff this changed `self.`\n     fn set_bit(&mut self, idx: usize) -> bool {\n         let words = self;\n         debug!(\"set_bit: words={} idx={}\",\n@@ -30,14 +45,22 @@ impl BitSlice for [usize] {\n         oldv != newv\n     }\n \n+    /// Extracts value of bit at `idx` in `self`.\n     fn get_bit(&self, idx: usize) -> bool {\n         let words = self;\n         let BitLookup { word, bit_mask, .. } = bit_lookup(idx);\n         (words[word] & bit_mask) != 0\n     }\n }\n \n-struct BitLookup { word: usize, bit_in_word: usize, bit_mask: usize }\n+struct BitLookup {\n+    /// An index of the word holding the bit in original `[usize]` of query.\n+    word: usize,\n+    /// Index of the particular bit within the word holding the bit.\n+    bit_in_word: usize,\n+    /// Word with single 1-bit set corresponding to where the bit is located.\n+    bit_mask: usize,\n+}\n \n #[inline]\n fn bit_lookup(bit: usize) -> BitLookup {"}, {"sha": "2628de2260795f2b15d228c631a41dfb4c9e874a", "filename": "src/librustc_borrowck/borrowck/mir/dataflow.rs", "status": "modified", "additions": 87, "deletions": 81, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/24ff32748428320cabb74101260fef8facfe4a26/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ff32748428320cabb74101260fef8facfe4a26/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs?ref=24ff32748428320cabb74101260fef8facfe4a26", "patch": "@@ -18,7 +18,7 @@ use std::mem;\n use std::usize;\n \n use super::MirBorrowckCtxt;\n-use super::gather_moves::{Location, MoveData, MovePathData, MovePathIndex, PathMap};\n+use super::gather_moves::{Location, MoveData, MovePathData, MovePathIndex, MoveOutIndex, PathMap};\n use super::graphviz;\n use bitslice::BitSlice; // adds set_bit/get_bit to &[usize] bitvector rep.\n \n@@ -35,15 +35,31 @@ impl<'b, 'a: 'b, 'tcx: 'a> Dataflow for MirBorrowckCtxt<'b, 'a, 'tcx> {\n     }\n }\n \n-struct PropagationContext<'c, 'b: 'c, 'a: 'b, 'tcx: 'a> {\n+struct PropagationContext<'c, 'b: 'c, 'a: 'b, 'tcx: 'a, OnReturn>\n+    where OnReturn: Fn(&MoveData, &mut [usize], &repr::Lvalue)\n+{\n     mbcx: &'c mut MirBorrowckCtxt<'b, 'a, 'tcx>,\n     changed: bool,\n+    on_return: OnReturn\n }\n \n impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n     fn propagate(&mut self) {\n         let mut temp = vec![0; self.flow_state.sets.words_per_block];\n-        let mut propcx = PropagationContext { mbcx: &mut *self, changed: true, };\n+        let mut propcx = PropagationContext {\n+            mbcx: &mut *self,\n+            changed: true,\n+            on_return: |move_data, in_out, dest_lval| {\n+                let move_path_index = move_data.rev_lookup.find(dest_lval);\n+                on_all_children_bits(in_out,\n+                                     &move_data.path_map,\n+                                     &move_data.move_paths,\n+                                     move_path_index,\n+                                     &|in_out, mpi| {\n+                                         in_out.clear_bit(mpi.idx().unwrap());\n+                                     });\n+            },\n+        };\n         while propcx.changed {\n             propcx.changed = false;\n             propcx.reset(&mut temp);\n@@ -79,19 +95,22 @@ impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n                     // Every path deinitialized by a *particular move*\n                     // has corresponding bit, \"gen'ed\" (i.e. set)\n                     // here, in dataflow vector\n-                    let retval = sets.gen_set.set_bit(move_index.idx().unwrap());\n-                    assert!(retval);\n+                    zero_to_one(&mut sets.gen_set, *move_index);\n                 }\n                 match stmt.kind {\n                     repr::StatementKind::Assign(ref lvalue, _) => {\n                         // assigning into this `lvalue` kills all\n                         // MoveOuts from it, and *also* all MoveOuts\n                         // for children and associated fragment sets.\n                         let move_path_index = rev_lookup.find(lvalue);\n-                        set_children_kill_bits(sets.kill_set,\n-                                               move_path_index,\n-                                               path_map,\n-                                               move_paths);\n+\n+                        on_all_children_bits(sets.kill_set,\n+                                             path_map,\n+                                             move_paths,\n+                                             move_path_index,\n+                                             &|kill_set, mpi| {\n+                                                 kill_set.set_bit(mpi.idx().unwrap());\n+                                             });\n                     }\n                 }\n             }\n@@ -100,79 +119,47 @@ impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n             debug!(\"terminator {:?} at loc {:?} moves out of move_indexes {:?}\",\n                    terminator, loc, &loc_map[loc]);\n             for move_index in &loc_map[loc] {\n-                let retval = sets.gen_set.set_bit(move_index.idx().unwrap());\n-                assert!(retval);\n+                zero_to_one(&mut sets.gen_set, *move_index);\n             }\n+        }\n \n-            // Note: while below as originally authored could be\n-            // written as an `if let`, it is more future-proof (to MIR\n-            // changes) to use an explicit `match` here.\n-            match *terminator {\n-                None => {}\n-                Some(repr::Terminator::Goto { target: _ }) => {}\n-                Some(repr::Terminator::If { cond: _, targets: _ }) => {}\n-                Some(repr::Terminator::Switch { discr: _, adt_def: _, targets: _ }) => {}\n-                Some(repr::Terminator::SwitchInt { discr: _, switch_ty: _, values: _, targets: _ }) => {}\n-                Some(repr::Terminator::Resume) => {}\n-                Some(repr::Terminator::Return) => {}\n-                Some(repr::Terminator::Drop { value: _, target: _, unwind: _ }) => {\n-                    // either kind of Drop completely invalidates the\n-                    // state of the referenced memory, effectively\n-                    // acting like a MoveOut. Such gen-set additions\n-                    // were added by the loop above over the loc_map.\n-                }\n-                Some(repr::Terminator::Call { func: _, args: _, cleanup: _,\n-                                              ref destination }) => {\n-                    // Note: a followup commit refines this to reflect\n-                    // that the destination will be initialized if the\n-                    // call succeeds (thus killling any MoveOuts for\n-                    // that destination).\n-                    //\n-                    // That is, this code just does the kills\n-                    // unconditionally (which I believe this matches\n-                    // the behavior of the old borrowck dataflow\n-                    // analysis), but this code also is also removed\n-                    // and replaced with something flow-dependent in a\n-                    // followup commit.\n-\n-                    if let Some((ref destination, _)) = *destination {\n-                        let move_path_index = rev_lookup.find(destination);\n-                        set_children_kill_bits(sets.kill_set,\n-                                               move_path_index,\n-                                               path_map,\n-                                               move_paths);\n-                    }\n-                }\n-            }\n+        fn zero_to_one(gen_set: &mut [usize], move_index: MoveOutIndex) {\n+            let retval = gen_set.set_bit(move_index.idx().unwrap());\n+            assert!(retval);\n         }\n+    }\n+}\n \n-        fn set_children_kill_bits(kill_set: &mut [usize],\n-                                  move_path_index: MovePathIndex,\n-                                  path_map: &PathMap,\n-                                  move_paths: &MovePathData) {\n-            assert!(move_path_index.idx().is_some());\n+fn on_all_children_bits<Each>(set: &mut [usize],\n+                              path_map: &PathMap,\n+                              move_paths: &MovePathData,\n+                              move_path_index: MovePathIndex,\n+                              each_child: &Each)\n+    where Each: Fn(&mut [usize], MoveOutIndex)\n+{\n+    assert!(move_path_index.idx().is_some());\n \n-            // 1. set kill bits for all moves that directly\n-            // influence path for `move_path_index`\n-            for move_index in &path_map[move_path_index] {\n-                kill_set.set_bit(move_index.idx().unwrap());\n-            }\n+    // 1. invoke `each_child` callback for all moves that directly\n+    //    influence path for `move_path_index`\n+    for move_index in &path_map[move_path_index] {\n+        each_child(set, *move_index);\n+    }\n \n-            // 2. for each child of the path (that is named in this\n-            //    function), recur.\n-            //\n-            // (Unnamed children are irrelevant to dataflow; by\n-            // definition they have no associated moves.)\n-            let mut child_index = move_paths[move_path_index].first_child;\n-            while let Some(_) = child_index.idx() {\n-                set_children_kill_bits(kill_set, child_index, path_map, move_paths);\n-                child_index = move_paths[child_index].next_sibling;\n-            }\n-        }\n+    // 2. for each child of the path (that is named in this\n+    //    function), recur.\n+    //\n+    // (Unnamed children are irrelevant to dataflow; by\n+    // definition they have no associated moves.)\n+    let mut child_index = move_paths[move_path_index].first_child;\n+    while let Some(_) = child_index.idx() {\n+        on_all_children_bits(set, path_map, move_paths, child_index, each_child);\n+        child_index = move_paths[child_index].next_sibling;\n     }\n }\n \n-impl<'c, 'b: 'c, 'a: 'b, 'tcx: 'a> PropagationContext<'c, 'b, 'a, 'tcx> {\n+impl<'c, 'b: 'c, 'a: 'b, 'tcx: 'a, OnReturn> PropagationContext<'c, 'b, 'a, 'tcx, OnReturn>\n+    where OnReturn: Fn(&MoveData, &mut [usize], &repr::Lvalue)\n+{\n     fn reset(&mut self, bits: &mut [usize]) {\n         let e = if self.mbcx.flow_state.operator.initial_value() {usize::MAX} else {0};\n         for b in bits {\n@@ -190,7 +177,10 @@ impl<'c, 'b: 'c, 'a: 'b, 'tcx: 'a> PropagationContext<'c, 'b, 'a, 'tcx> {\n                 bitwise(in_out, sets.gen_set, &Union);\n                 bitwise(in_out, sets.kill_set, &Subtract);\n             }\n-            flow_state.propagate_bits_into_graph_successors_of(in_out, &mut self.changed, bb);\n+            flow_state.propagate_bits_into_graph_successors_of(in_out,\n+                                                               &mut self.changed,\n+                                                               bb,\n+                                                               &self.on_return);\n         }\n     }\n }\n@@ -405,10 +395,23 @@ impl<D: BitDenotation> DataflowState<D> {\n }\n \n impl<D: BitDenotation> DataflowState<D> {\n-    fn propagate_bits_into_graph_successors_of(&mut self,\n-                                               in_out: &mut [usize],\n-                                               changed: &mut bool,\n-                                               bb: &repr::BasicBlockData) {\n+    /// Propagates the bits of `in_out` into all the successors of `bb`,\n+    /// using bitwise operator denoted by `self.operator`.\n+    ///\n+    /// For most blocks, this is entirely uniform. However, for blocks\n+    /// that end with a call terminator, the effect of the call on the\n+    /// dataflow state may depend on whether the call returned\n+    /// successfully or unwound. To reflect this, the `on_return`\n+    /// callback mutates `in_out` when propagating `in_out` via a call\n+    /// terminator; such mutation is performed *last*, to ensure its\n+    /// side-effects do not leak elsewhere (e.g. into unwind target).\n+    fn propagate_bits_into_graph_successors_of<OnReturn>(\n+        &mut self,\n+        in_out: &mut [usize],\n+        changed: &mut bool,\n+        bb: &repr::BasicBlockData,\n+        on_return: OnReturn) where OnReturn: Fn(&D, &mut [usize], &repr::Lvalue)\n+    {\n         let term = if let Some(ref term) = bb.terminator { term } else { return };\n         match *term {\n             repr::Terminator::Return |\n@@ -435,15 +438,18 @@ impl<D: BitDenotation> DataflowState<D> {\n                 if let Some(ref unwind) = *cleanup {\n                     self.propagate_bits_into_entry_set_for(in_out, changed, unwind);\n                 }\n-                if let Some((_, ref destination)) = *destination {\n-                    self.propagate_bits_into_entry_set_for(in_out, changed, destination);\n+                if let Some((ref dest_lval, ref dest_bb)) = *destination {\n+                    // N.B.: This must be done *last*, after all other\n+                    // propagation, as documented in comment above.\n+                    on_return(&self.operator, in_out, dest_lval);\n+                    self.propagate_bits_into_entry_set_for(in_out, changed, dest_bb);\n                 }\n             }\n         }\n     }\n \n     fn propagate_bits_into_entry_set_for(&mut self,\n-                                         in_out: &mut [usize],\n+                                         in_out: &[usize],\n                                          changed: &mut bool,\n                                          bb: &repr::BasicBlock) {\n         let entry_set = self.sets.for_block(bb.index()).on_entry;"}]}