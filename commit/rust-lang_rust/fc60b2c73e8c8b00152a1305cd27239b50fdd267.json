{"sha": "fc60b2c73e8c8b00152a1305cd27239b50fdd267", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjNjBiMmM3M2U4YzhiMDAxNTJhMTMwNWNkMjcyMzliNTBmZGQyNjc=", "commit": {"author": {"name": "arcnmx", "email": "arcnmx@users.noreply.github.com", "date": "2015-11-11T17:02:55Z"}, "committer": {"name": "arcnmx", "email": "arcnmx@users.noreply.github.com", "date": "2015-11-11T17:02:55Z"}, "message": "Prefer raw::c_char or libc::c_char and fix arm", "tree": {"sha": "4c3f62772b4aabf8a349c1ee1c9d83e809648caf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c3f62772b4aabf8a349c1ee1c9d83e809648caf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc60b2c73e8c8b00152a1305cd27239b50fdd267", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc60b2c73e8c8b00152a1305cd27239b50fdd267", "html_url": "https://github.com/rust-lang/rust/commit/fc60b2c73e8c8b00152a1305cd27239b50fdd267", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc60b2c73e8c8b00152a1305cd27239b50fdd267/comments", "author": {"login": "arcnmx", "id": 13426784, "node_id": "MDQ6VXNlcjEzNDI2Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/13426784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arcnmx", "html_url": "https://github.com/arcnmx", "followers_url": "https://api.github.com/users/arcnmx/followers", "following_url": "https://api.github.com/users/arcnmx/following{/other_user}", "gists_url": "https://api.github.com/users/arcnmx/gists{/gist_id}", "starred_url": "https://api.github.com/users/arcnmx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arcnmx/subscriptions", "organizations_url": "https://api.github.com/users/arcnmx/orgs", "repos_url": "https://api.github.com/users/arcnmx/repos", "events_url": "https://api.github.com/users/arcnmx/events{/privacy}", "received_events_url": "https://api.github.com/users/arcnmx/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arcnmx", "id": 13426784, "node_id": "MDQ6VXNlcjEzNDI2Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/13426784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arcnmx", "html_url": "https://github.com/arcnmx", "followers_url": "https://api.github.com/users/arcnmx/followers", "following_url": "https://api.github.com/users/arcnmx/following{/other_user}", "gists_url": "https://api.github.com/users/arcnmx/gists{/gist_id}", "starred_url": "https://api.github.com/users/arcnmx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arcnmx/subscriptions", "organizations_url": "https://api.github.com/users/arcnmx/orgs", "repos_url": "https://api.github.com/users/arcnmx/repos", "events_url": "https://api.github.com/users/arcnmx/events{/privacy}", "received_events_url": "https://api.github.com/users/arcnmx/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c743a95d74da5af649a6c6b2608f5f65a0da716", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c743a95d74da5af649a6c6b2608f5f65a0da716", "html_url": "https://github.com/rust-lang/rust/commit/8c743a95d74da5af649a6c6b2608f5f65a0da716"}], "stats": {"total": 75, "additions": 36, "deletions": 39}, "files": [{"sha": "2802ecfbb8d4a43adac75a37ed9e07ccc9dc375f", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 30, "deletions": 37, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/fc60b2c73e8c8b00152a1305cd27239b50fdd267/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc60b2c73e8c8b00152a1305cd27239b50fdd267/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=fc60b2c73e8c8b00152a1305cd27239b50fdd267", "patch": "@@ -21,6 +21,7 @@ use libc;\n use mem;\n use ops::Deref;\n use option::Option::{self, Some, None};\n+use os::raw::c_char;\n use result::Result::{self, Ok, Err};\n use slice;\n use str::{self, Utf8Error};\n@@ -36,23 +37,21 @@ use vec::Vec;\n ///\n /// A `CString` is created from either a byte slice or a byte vector. After\n /// being created, a `CString` predominately inherits all of its methods from\n-/// the `Deref` implementation to `[libc::c_char]`. Note that the underlying\n-/// array is represented as an array of `libc::c_char` as opposed to `u8`. A\n+/// the `Deref` implementation to `[os::raw::c_char]`. Note that the underlying\n+/// array is represented as an array of `os::raw::c_char` as opposed to `u8`. A\n /// `u8` slice can be obtained with the `as_bytes` method.  Slices produced from\n /// a `CString` do *not* contain the trailing nul terminator unless otherwise\n /// specified.\n ///\n /// # Examples\n ///\n /// ```no_run\n-/// # #![feature(libc)]\n-/// # extern crate libc;\n /// # fn main() {\n /// use std::ffi::CString;\n-/// use libc;\n+/// use std::os::raw::c_char;\n ///\n /// extern {\n-///     fn my_printer(s: *const libc::c_char);\n+///     fn my_printer(s: *const c_char);\n /// }\n ///\n /// let c_to_print = CString::new(\"Hello, world!\").unwrap();\n@@ -83,11 +82,10 @@ pub struct CString {\n /// Inspecting a foreign C string\n ///\n /// ```no_run\n-/// # #![feature(libc)]\n-/// extern crate libc;\n /// use std::ffi::CStr;\n+/// use std::os::raw::c_char;\n ///\n-/// extern { fn my_string() -> *const libc::c_char; }\n+/// extern { fn my_string() -> *const c_char; }\n ///\n /// fn main() {\n ///     unsafe {\n@@ -100,12 +98,11 @@ pub struct CString {\n /// Passing a Rust-originating C string\n ///\n /// ```no_run\n-/// # #![feature(libc)]\n-/// extern crate libc;\n /// use std::ffi::{CString, CStr};\n+/// use std::os::raw::c_char;\n ///\n /// fn work(data: &CStr) {\n-///     extern { fn work_with(data: *const libc::c_char); }\n+///     extern { fn work_with(data: *const c_char); }\n ///\n ///     unsafe { work_with(data.as_ptr()) }\n /// }\n@@ -119,11 +116,10 @@ pub struct CString {\n /// Converting a foreign C string into a Rust `String`\n ///\n /// ```no_run\n-/// # #![feature(libc)]\n-/// extern crate libc;\n /// use std::ffi::CStr;\n+/// use std::os::raw::c_char;\n ///\n-/// extern { fn my_string() -> *const libc::c_char; }\n+/// extern { fn my_string() -> *const c_char; }\n ///\n /// fn my_string_safe() -> String {\n ///     unsafe {\n@@ -139,10 +135,10 @@ pub struct CString {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct CStr {\n     // FIXME: this should not be represented with a DST slice but rather with\n-    //        just a raw `libc::c_char` along with some form of marker to make\n+    //        just a raw `c_char` along with some form of marker to make\n     //        this an unsized type. Essentially `sizeof(&CStr)` should be the\n     //        same as `sizeof(&c_char)` but `CStr` should be an unsized type.\n-    inner: [libc::c_char]\n+    inner: [c_char]\n }\n \n /// An error returned from `CString::new` to indicate that a nul byte was found\n@@ -169,11 +165,10 @@ impl CString {\n     /// # Examples\n     ///\n     /// ```no_run\n-    /// # #![feature(libc)]\n-    /// extern crate libc;\n     /// use std::ffi::CString;\n+    /// use std::os::raw::c_char;\n     ///\n-    /// extern { fn puts(s: *const libc::c_char); }\n+    /// extern { fn puts(s: *const c_char); }\n     ///\n     /// fn main() {\n     ///     let to_print = CString::new(\"Hello!\").unwrap();\n@@ -220,7 +215,7 @@ impl CString {\n     #[unstable(feature = \"cstr_memory2\", reason = \"recently added\",\n                issue = \"27769\")]\n     #[deprecated(since = \"1.4.0\", reason = \"renamed to from_raw\")]\n-    pub unsafe fn from_ptr(ptr: *const libc::c_char) -> CString {\n+    pub unsafe fn from_ptr(ptr: *const c_char) -> CString {\n         CString::from_raw(ptr as *mut _)\n     }\n \n@@ -230,7 +225,7 @@ impl CString {\n     /// `into_raw`. The length of the string will be recalculated\n     /// using the pointer.\n     #[stable(feature = \"cstr_memory\", since = \"1.4.0\")]\n-    pub unsafe fn from_raw(ptr: *mut libc::c_char) -> CString {\n+    pub unsafe fn from_raw(ptr: *mut c_char) -> CString {\n         let len = libc::strlen(ptr) + 1; // Including the NUL byte\n         let slice = slice::from_raw_parts(ptr, len as usize);\n         CString { inner: mem::transmute(slice) }\n@@ -247,7 +242,7 @@ impl CString {\n     #[unstable(feature = \"cstr_memory2\", reason = \"recently added\",\n                issue = \"27769\")]\n     #[deprecated(since = \"1.4.0\", reason = \"renamed to into_raw\")]\n-    pub fn into_ptr(self) -> *const libc::c_char {\n+    pub fn into_ptr(self) -> *const c_char {\n         self.into_raw() as *const _\n     }\n \n@@ -260,8 +255,8 @@ impl CString {\n     ///\n     /// Failure to call `from_raw` will lead to a memory leak.\n     #[stable(feature = \"cstr_memory\", since = \"1.4.0\")]\n-    pub fn into_raw(self) -> *mut libc::c_char {\n-        Box::into_raw(self.inner) as *mut libc::c_char\n+    pub fn into_raw(self) -> *mut c_char {\n+        Box::into_raw(self.inner) as *mut c_char\n     }\n \n     /// Converts the `CString` into a `String` if it contains valid Unicode data.\n@@ -426,15 +421,13 @@ impl CStr {\n     /// # Examples\n     ///\n     /// ```no_run\n-    /// # #![feature(libc)]\n-    /// # extern crate libc;\n     /// # fn main() {\n     /// use std::ffi::CStr;\n+    /// use std::os::raw::c_char;\n     /// use std::str;\n-    /// use libc;\n     ///\n     /// extern {\n-    ///     fn my_string() -> *const libc::c_char;\n+    ///     fn my_string() -> *const c_char;\n     /// }\n     ///\n     /// unsafe {\n@@ -445,7 +438,7 @@ impl CStr {\n     /// # }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub unsafe fn from_ptr<'a>(ptr: *const libc::c_char) -> &'a CStr {\n+    pub unsafe fn from_ptr<'a>(ptr: *const c_char) -> &'a CStr {\n         let len = libc::strlen(ptr);\n         mem::transmute(slice::from_raw_parts(ptr, len as usize + 1))\n     }\n@@ -456,7 +449,7 @@ impl CStr {\n     /// to a contiguous region of memory terminated with a 0 byte to represent\n     /// the end of the string.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn as_ptr(&self) -> *const libc::c_char {\n+    pub fn as_ptr(&self) -> *const c_char {\n         self.inner.as_ptr()\n     }\n \n@@ -560,14 +553,14 @@ impl ToOwned for CStr {\n mod tests {\n     use prelude::v1::*;\n     use super::*;\n-    use libc;\n+    use os::raw::c_char;\n     use borrow::Cow::{Borrowed, Owned};\n     use hash::{SipHasher, Hash, Hasher};\n \n     #[test]\n     fn c_to_rust() {\n         let data = b\"123\\0\";\n-        let ptr = data.as_ptr() as *const libc::c_char;\n+        let ptr = data.as_ptr() as *const c_char;\n         unsafe {\n             assert_eq!(CStr::from_ptr(ptr).to_bytes(), b\"123\");\n             assert_eq!(CStr::from_ptr(ptr).to_bytes_with_nul(), b\"123\\0\");\n@@ -616,13 +609,13 @@ mod tests {\n     #[test]\n     fn to_str() {\n         let data = b\"123\\xE2\\x80\\xA6\\0\";\n-        let ptr = data.as_ptr() as *const libc::c_char;\n+        let ptr = data.as_ptr() as *const c_char;\n         unsafe {\n             assert_eq!(CStr::from_ptr(ptr).to_str(), Ok(\"123\u2026\"));\n             assert_eq!(CStr::from_ptr(ptr).to_string_lossy(), Borrowed(\"123\u2026\"));\n         }\n         let data = b\"123\\xE2\\0\";\n-        let ptr = data.as_ptr() as *const libc::c_char;\n+        let ptr = data.as_ptr() as *const c_char;\n         unsafe {\n             assert!(CStr::from_ptr(ptr).to_str().is_err());\n             assert_eq!(CStr::from_ptr(ptr).to_string_lossy(), Owned::<str>(format!(\"123\\u{FFFD}\")));\n@@ -632,7 +625,7 @@ mod tests {\n     #[test]\n     fn to_owned() {\n         let data = b\"123\\0\";\n-        let ptr = data.as_ptr() as *const libc::c_char;\n+        let ptr = data.as_ptr() as *const c_char;\n \n         let owned = unsafe { CStr::from_ptr(ptr).to_owned() };\n         assert_eq!(owned.as_bytes_with_nul(), data);\n@@ -641,7 +634,7 @@ mod tests {\n     #[test]\n     fn equal_hash() {\n         let data = b\"123\\xE2\\xFA\\xA6\\0\";\n-        let ptr = data.as_ptr() as *const libc::c_char;\n+        let ptr = data.as_ptr() as *const c_char;\n         let cstr: &'static CStr = unsafe { CStr::from_ptr(ptr) };\n \n         let mut s = SipHasher::new_with_keys(0, 0);"}, {"sha": "f5d234425622a102509f18f7a54faf4854672f2a", "filename": "src/libstd/os/raw.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc60b2c73e8c8b00152a1305cd27239b50fdd267/src%2Flibstd%2Fos%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc60b2c73e8c8b00152a1305cd27239b50fdd267/src%2Flibstd%2Fos%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fraw.rs?ref=fc60b2c73e8c8b00152a1305cd27239b50fdd267", "patch": "@@ -12,9 +12,13 @@\n \n #![stable(feature = \"raw_os\", since = \"1.1.0\")]\n \n-#[cfg(any(target_arch = \"aarch64\", target_os = \"android\"))]\n+#[cfg(all(not(target_os = \"ios\"), not(target_os = \"macos\"),\n+          any(target_arch = \"aarch64\", target_arch = \"arm\",\n+              target_os = \"android\")))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = u8;\n-#[cfg(not(any(target_arch = \"aarch64\", target_os = \"android\")))]\n+#[cfg(any(target_os = \"ios\", target_os = \"macos\",\n+          not(any(target_arch = \"aarch64\", target_arch = \"arm\",\n+                  target_os = \"android\"))))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = i8;\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_schar = i8;\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_uchar = u8;"}]}