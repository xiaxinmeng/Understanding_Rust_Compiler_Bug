{"sha": "cf2329201098c6e3b417548651a1c3dbf19c0dc0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMjMyOTIwMTA5OGM2ZTNiNDE3NTQ4NjUxYTFjM2RiZjE5YzBkYzA=", "commit": {"author": {"name": "Eric Reed", "email": "ereed@mozilla.com", "date": "2013-07-08T20:03:18Z"}, "committer": {"name": "Eric Reed", "email": "ereed@mozilla.com", "date": "2013-07-08T20:03:18Z"}, "message": "Merge remote-tracking branch 'upstream/io' into io\n\nConflicts:\n\tsrc/libstd/rt/uvio.rs", "tree": {"sha": "e970715357ad65a22f289bd708e3e9ede49f9ad2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e970715357ad65a22f289bd708e3e9ede49f9ad2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf2329201098c6e3b417548651a1c3dbf19c0dc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf2329201098c6e3b417548651a1c3dbf19c0dc0", "html_url": "https://github.com/rust-lang/rust/commit/cf2329201098c6e3b417548651a1c3dbf19c0dc0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf2329201098c6e3b417548651a1c3dbf19c0dc0/comments", "author": null, "committer": null, "parents": [{"sha": "b60cf0c5b0cf36625083c2624df9fb35d0af3578", "url": "https://api.github.com/repos/rust-lang/rust/commits/b60cf0c5b0cf36625083c2624df9fb35d0af3578", "html_url": "https://github.com/rust-lang/rust/commit/b60cf0c5b0cf36625083c2624df9fb35d0af3578"}, {"sha": "1098d6980b13dc00e3f20deae987423e3bcae9ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/1098d6980b13dc00e3f20deae987423e3bcae9ce", "html_url": "https://github.com/rust-lang/rust/commit/1098d6980b13dc00e3f20deae987423e3bcae9ce"}], "stats": {"total": 40875, "additions": 23530, "deletions": 17345}, "files": [{"sha": "c84426161796d231876dd1f7bb27f15dbd6d8257", "filename": ".gitmodules", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -1,6 +1,8 @@\n [submodule \"src/llvm\"]\n \tpath = src/llvm\n \turl = https://github.com/brson/llvm.git\n+\tbranch = master\n [submodule \"src/libuv\"]\n \tpath = src/libuv\n \turl = https://github.com/brson/libuv.git\n+\tbranch = master"}, {"sha": "e742886961f4ad467c39b9fa17611d7b0e5c4379", "filename": "AUTHORS.txt", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -10,9 +10,11 @@ Aleksander Balicki <balicki.aleksander@gmail.com>\n Alex Crichton <alex@alexcrichton.com>\n Alex R\u00f8nne Petersen <alex@lycus.org>\n Alexander Stavonin <a.stavonin@gmail.com>\n+Alexei Sholik <alcosholik@gmail.com>\n Andreas Gal <gal@mozilla.com>\n Andrew Dunham <andrew@du.nham.ca>\n Andrew Paseltiner <apaseltiner@gmail.com>\n+Anthony Juckel <ajuckel@gmail.com>\n Arkaitz Jimenez <arkaitzj@gmail.com>\n Armin Ronacher <armin.ronacher@active-4.com>\n Ashok Gautham <ScriptDevil@gmail.com>\n@@ -29,23 +31,32 @@ Benjamin Kircher <benjamin.kircher@gmail.com>\n Benjamin Peterson <benjamin@python.org>\n Bilal Husain <bilal@bilalhusain.com>\n Bill Fallon <bill.fallon@robos.li>\n+Bill Myers <bill_myers@outlook.com>\n+Bill Wendling <wendling@apple.com>\n+Bj\u00f6rn Steinbrink <bsteinbr@gmail.com>\n Brendan Eich <brendan@mozilla.org>\n Brendan Zabarauskas <bjzaba@yahoo.com.au>\n Brett Cannon <brett@python.org>\n Brian Anderson <banderson@mozilla.com>\n Brian J. Burg <burg@cs.washington.edu>\n Brian Leibig <brian.leibig@gmail.com>\n+Bryan Dunsmore <dunsmoreb@gmail.com>\n+Caitlin Potter <snowball@defpixel.com>\n Chris Double <chris.double@double.co.nz>\n Chris Peterson <cpeterson@mozilla.com>\n Chris Pressey <cpressey@gmail.com>\n Cody Schroeder <codys@cs.washington.edu>\n+Corey Richardson <corey@octayn.net>\n Damian Gryski <damian@gryski.com>\n Damien Grassart <damien@grassart.com>\n Damien Schoof <damien.schoof@gmail.com>\n Daniel Brooks <db48x@db48x.net>\n+Daniel Farina <daniel@fdr.io>\n+Dan Luu <danluu@gmail.com>\n Daniel Luz <dev@mernen.com>\n Daniel Micay <danielmicay@gmail.com>\n Daniel Patterson <dbp@riseup.net>\n+Daniel Ralston <Wubbulous@gmail.com>\n Daniel Ursache Dogariu <contact@danniel.net>\n Dave Herman <dherman@mozilla.com>\n David Forsythe <dforsythe@gmail.com>\n@@ -62,17 +73,21 @@ Eric Holmes <eric@ejholmes.net>\n Erick Tryzelaar <erick.tryzelaar@gmail.com>\n Erik Rose <erik@mozilla.com>\n Evan McClanahan <evan@evanmcc.com>\n+Fedor Indutny <fedor.indutny@gmail.com>\n Felix S. Klock II <pnkfelix@pnkfx.org>\n Francisco Souza <f@souza.cc>\n Franklin Chen <franklinchen@franklinchen.com>\n+G\u00e1bor Horv\u00e1th <xazax.hun@gmail.com>\n Gabriel <g2p.code@gmail.com>\n Gareth Daniel Smith <garethdanielsmith@gmail.com>\n+gifnksm <makoto.nksm@gmail.com>\n Glenn Willen <gwillen@nerdnet.org>\n Gon\u00e7alo Cabrita <_@gmcabrita.com>\n Graham Fawcett <fawcett@uwindsor.ca>\n Grahame Bowland <grahame@angrygoats.net>\n Haitao Li <lihaitao@gmail.com>\n hansjorg <hansjorg@gmail.com>\n+Herman J. Radtke III <hermanradtke@gmail.com>\n Huon Wilson <dbau.pp+github@gmail.com>\n Ian D. Bollinger <ian.bollinger@gmail.com>\n Ilyong Cho <ilyoan@gmail.com>\n@@ -83,6 +98,7 @@ Jacob Harris Cryer Kragh <jhckragh@gmail.com>\n Jacob Parker <j3parker@csclub.uwaterloo.ca>\n Jakub Wieczorek <jakubw@jakubw.net>\n James Miller <bladeon@gmail.com>\n+James Tranovich <james@openhorizonlabs.com>\n Jason Orendorff <jorendorff@mozilla.com>\n Jed Davis <jld@panix.com>\n Jeff Balogh <jbalogh@mozilla.com>\n@@ -92,6 +108,7 @@ Jeffrey Yasskin <jyasskin@gmail.com>\n Jeong YunWon <jeong@youknowone.org>\n Jens Nockert <jens@nockert.se>\n Jesse Jones <jesse9jones@gmail.com>\n+Jesse Luehrs <doy@tozt.net>\n Jesse Ruderman <jruderman@gmail.com>\n Jihyun Yu <jihyun@nclab.kaist.ac.kr>\n Jim Blandy <jimb@red-bean.com>\n@@ -104,14 +121,18 @@ Jonathan Sternberg <jonathansternberg@gmail.com>\n Josh Matthews <josh@joshmatthews.net>\n Joshua Clark <joshua.clark@txstate.edu>\n Joshua Wise <joshua@joshuawise.com>\n+Junyoung Cho <june0.cho@samsung.com>\n Jyun-Yan You <jyyou@cs.nctu.edu.tw>\n Kang Seonghoon <kang.seonghoon@mearie.org>\n Kelly Wilson <wilsonk@cpsc.ucalgary.ca>\n Kevin Atkinson <kevina@cs.utah.edu>\n+Kevin Ballard <kevin@sb.org>\n Kevin Cantu <me@kevincantu.org>\n+klutzy <klutzytheklutzy@gmail.com>\n Kyeongwoon Lee <kyeongwoon.lee@samsung.com>\n Laurent Bonnans <bonnans.l@gmail.com>\n Lawrence Vela\u0301zquez <larryv@alum.mit.edu>\n+Leah Hanson <astrieanna@gmail.com>\n Lennart Kudling <github@kudling.de>\n Lindsey Kuper <lindsey@composition.al>\n Luca Bruno <lucab@debian.org>\n@@ -122,6 +143,7 @@ Margaret Meyerhofer <mmeyerho@andrew.cmu.edu>\n Marijn Haverbeke <marijnh@gmail.com>\n Mark Lacey <641@rudkx.com>\n Mark Vian <mrv.caseus@gmail.com>\n+Marti Raudsepp <marti@juffo.org>\n Martin DeMello <martindemello@gmail.com>\n Marvin L\u00f6bel <loebel.marvin@gmail.com>\n Matt Brubeck <mbrubeck@limpet.net>\n@@ -143,43 +165,64 @@ Patrick Walton <pwalton@mozilla.com>\n Patrik K\u00e5rlin <patrik.karlin@gmail.com>\n Paul Stansifer <paul.stansifer@gmail.com>\n Paul Woolcock <pwoolcoc+github@gmail.com>\n+Pavel Panchekha <me@pavpanchekha.com>\n Peter Hull <peterhull90@gmail.com>\n Peter Williams <peter@newton.cx>\n Philipp Br\u00fcschweiler <blei42@gmail.com>\n Rafael \u00c1vila de Esp\u00edndola <respindola@mozilla.com>\n+Ralph Bodenner <rkbodenner+github@gmail.com>\n Ralph Giles <giles@thaumas.net>\n+Ramkumar Ramachandra <artagnon@gmail.com>\n Reuben Morais <reuben.morais@gmail.com>\n Rick Waldron <waldron.rick@gmail.com>\n Rob Arnold <robarnold@cs.cmu.edu>\n+Rob Hoelz <rob@hoelz.ro>\n Roland Tanglao <roland@rolandtanglao.com>\n+Ron Dahlgren <ronald.dahlgren@gmail.com>\n Roy Frostig <rfrostig@mozilla.com>\n Ryan Scheel <ryan.havvy@gmail.com>\n+Samuel Chase <samebchase@gmail.com>\n+Sander Mathijs van Veen <smvv@kompiler.org>\n+Sangeun Kim <sammy.kim@samsung.com>\n+Saurabh Anand <saurabhanandiit@gmail.com>\n+Sean Moon <ssamoon@ucla.edu>\n Sean Stangl <sstangl@mozilla.com>\n Sebastian N. Fernandez <cachobot@gmail.com>\n Seth Pink <sethpink@gmail.com>\n Seo Sanghyeon <sanxiyn@gmail.com>\n sevrak <sevrak@rediffmail.com>\n+SiegeLord <slabode@aim.com>\n Simon Barber-Dueck <sbarberdueck@gmail.com>\n Simon Sapin <simon@exyr.org>\n startling <tdixon51793@gmail.com>\n Stefan Plantikow <stefan.plantikow@googlemail.com>\n Steve Klabnik <steve@steveklabnik.com>\n+Steven De Coeyer <steven@banteng.be>\n+Steven Fackler <sfackler@gmail.com>\n+Steven Stewart-Gallus <sstewartgallus00@langara.bc.ca>\n Taras Shpot <mrshpot@gmail.com>\n Ted Horst <ted.horst@earthlink.net>\n Thad Guidry <thadguidry@gmail.com>\n+Thomas Daede <daede003@umn.edu>\n Tim Chevalier <chevalier@alum.wellesley.edu>\n Tim Taubert <tim@timtaubert.de>\n Tom Lee <github@tomlee.co>\n+Tommy M. McGuire <mcguire@crsr.net>\n Tomoki Aonuma <uasi@99cm.org>\n Tony Young <tony@rfw.name>\n Trinick <slicksilver555@mac.com>\n Tycho Sci <tychosci@gmail.com>\n Tyler Bindon <martica@martica.org>\n+Uwe Dauernheim <uwe@dauernheim.net>\n+Vadim Chugunov <vadimcn@gmail.com>\n Viktor Dahl <pazaconyoman@gmail.com>\n Vincent Belliard <vincent@famillebelliard.fr>\n+Vivek Galatage <vivekgalatage@gmail.com>\n Wade Mealing <wmealing@gmail.com>\n William Ting <william.h.ting@gmail.com>\n Yasuhiro Fujii <y-fujii@mimosa-pudica.net>\n Young-il Choi <duddlf.choi@samsung.com>\n+Youngmin Yoo <youngmin.yoo@samsung.com>\n Youngsoo Son <ysson83@gmail.com>\n Zack Corr <zack@z0w0.me>\n+zofrex <zofrex@gmail.com>"}, {"sha": "de30113ca4b6e10b4743a889b71b3d91ed3becf7", "filename": "Makefile.in", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -139,8 +139,11 @@ endif\n \n # version-string calculation\n CFG_GIT_DIR := $(CFG_SRC_DIR).git\n-CFG_RELEASE = 0.6\n+CFG_RELEASE = 0.7\n CFG_VERSION = $(CFG_RELEASE)\n+# windows exe's need numeric versions - don't use anything but\n+# numbers and dots here\n+CFG_VERSION_WIN = 0.7\n \n ifneq ($(wildcard $(CFG_GIT)),)\n ifneq ($(wildcard $(CFG_GIT_DIR)),)\n@@ -239,29 +242,29 @@ $(foreach target,$(CFG_TARGET_TRIPLES),\\\n # Standard library variables\n ######################################################################\n \n-STDLIB_CRATE := $(S)src/libstd/core.rc\n+STDLIB_CRATE := $(S)src/libstd/std.rs\n STDLIB_INPUTS := $(wildcard $(addprefix $(S)src/libstd/,        \\\n-                                           core.rc *.rs */*.rs */*/*rs */*/*/*rs))\n+                                           *.rs */*.rs */*/*rs */*/*/*rs))\n \n ######################################################################\n # Extra library variables\n ######################################################################\n \n-EXTRALIB_CRATE := $(S)src/libextra/std.rc\n+EXTRALIB_CRATE := $(S)src/libextra/extra.rs\n EXTRALIB_INPUTS := $(wildcard $(addprefix $(S)src/libextra/,          \\\n-                                          std.rc *.rs */*.rs))\n+                                          *.rs */*.rs))\n \n ######################################################################\n # rustc crate variables\n ######################################################################\n \n-COMPILER_CRATE := $(S)src/librustc/rustc.rc\n+COMPILER_CRATE := $(S)src/librustc/rustc.rs\n COMPILER_INPUTS := $(wildcard $(addprefix $(S)src/librustc/,      \\\n-                           rustc.rc *.rs */*.rs */*/*.rs */*/*/*.rs))\n+                           *.rs */*.rs */*/*.rs */*/*/*.rs))\n \n-LIBSYNTAX_CRATE := $(S)src/libsyntax/syntax.rc\n+LIBSYNTAX_CRATE := $(S)src/libsyntax/syntax.rs\n LIBSYNTAX_INPUTS := $(wildcard $(addprefix $(S)src/libsyntax/, \\\n-                            syntax.rc *.rs */*.rs */*/*.rs))\n+                           *.rs */*.rs */*/*.rs))\n \n DRIVER_CRATE := $(S)src/driver/driver.rs\n \n@@ -311,6 +314,7 @@ $(foreach host,$(CFG_HOST_TRIPLES), \\\n export CFG_SRC_DIR\n export CFG_BUILD_DIR\n export CFG_VERSION\n+export CFG_VERSION_WIN\n export CFG_BUILD_TRIPLE\n export CFG_LLVM_ROOT\n export CFG_ENABLE_MINGW_CROSS\n@@ -536,10 +540,19 @@ ALL_TARGET_RULES = $(foreach target,$(CFG_TARGET_TRIPLES), \\\n \t$(foreach host,$(CFG_HOST_TRIPLES), \\\n  all-target-$(target)-host-$(host)))\n \n-all: $(ALL_TARGET_RULES) $(GENERATED) docs\n+all: rustllvm/llvm-auto-clean-stamp \\\n+     $(ALL_TARGET_RULES) $(GENERATED) docs\n \n endif\n \n+# This is used to independently force an LLVM clean rebuild\n+# when we changed something not otherwise captured by builtin\n+# dependencies. In these cases, commit a change that touches\n+# the stamp in the source dir.\n+rustllvm/llvm-auto-clean-stamp: $(S)src/rustllvm/llvm-auto-clean-trigger\n+\t$(Q)$(MAKE) clean-llvm\n+\ttouch $@\n+\n \n ######################################################################\n # Re-configuration"}, {"sha": "f01ed1958c66c73600c0e8bb28e2b0ab1c61b802", "filename": "README.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -42,9 +42,9 @@ packages:\n Assuming you're on a relatively modern *nix system and have met the\n prerequisites, something along these lines should work.\n \n-    $ curl -O http://static.rust-lang.org/dist/rust-0.6.tar.gz\n-    $ tar -xzf rust-0.6.tar.gz\n-    $ cd rust-0.6\n+    $ curl -O http://static.rust-lang.org/dist/rust-0.7.tar.gz\n+    $ tar -xzf rust-0.7.tar.gz\n+    $ cd rust-0.7\n     $ ./configure\n     $ make && make install\n \n@@ -59,8 +59,8 @@ When complete, `make install` will place several programs into\n API-documentation tool, and `rustpkg`, the Rust package manager and build system.\n \n [wiki-start]: https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust\n-[tarball]: http://static.rust-lang.org/dist/rust-0.6.tar.gz\n-[win-exe]: http://static.rust-lang.org/dist/rust-0.6-install.exe\n+[tarball]: http://static.rust-lang.org/dist/rust-0.7.tar.gz\n+[win-exe]: http://static.rust-lang.org/dist/rust-0.7-install.exe\n \n \n ## License"}, {"sha": "33f749d001033650d5b87d4fda5f258b83922334", "filename": "RELEASES.txt", "status": "modified", "additions": 61, "deletions": 37, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/RELEASES.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/RELEASES.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.txt?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -1,79 +1,108 @@\n Version 0.7 (July 2013)\n -----------------------\n \n-   * ??? changes, numerous bugfixes\n-\n-   * Syntax changes\n-      * `use mod` is no longer valid.\n-      * `fail!` and `assert!` accept `~str`, `&'static str` or `fmt!`-style\n-        argument list.\n-      * `Encodable`, `Decodable`, `TotalOrd`, `TotalEq`, `DeepClone` can all\n-        be automatically derived with `#[deriving(...)]`.\n-      * The `Durable` trait is replaced with the `'static` bounds.\n-      * At long last, 'argument modes' no longer exist.\n-      * The `bytes!` macro returns a vector of bytes for string, u8, char,\n-        and unsuffixed integer literals.\n+   * ~2000 changes, numerous bugfixes\n \n-   * Semantic changes\n+   * Language\n+      * `impl`s no longer accept a visibility qualifier. Put them on methods\n+        instead.\n       * The borrow checker has been rewritten with flow-sensitivity, fixing\n         many bugs and inconveniences.\n       * The `self` parameter no longer implicitly means `&'self self`,\n         and can be explicitly marked with a lifetime.\n-      * Structs with the `#[packed]` attribute have byte alignment and\n-        no padding between fields.\n+      * Overloadable compound operators (`+=`, etc.) have been temporarily\n+        removed due to bugs.\n       * The `for` loop protocol now requires `for`-iterators to return `bool`\n         so they compose better.\n+      * The `Durable` trait is replaced with the `'static` bounds.\n+      * Trait default methods work more often.\n+      * Structs with the `#[packed]` attribute have byte alignment and\n+        no padding between fields.\n+      * Type parameters bound by `Copy` must now be copied explicitly with\n+        the `copy` keyword.\n+      * It is now illegal to move out of a dereferenced unsafe pointer.\n       * `Option<~T>` is now represented as a nullable pointer.\n       * `@mut` does dynamic borrow checks correctly.\n-      * Macros TODO\n       * The `main` function is only detected at the topmost level of the crate.\n         The `#[main]` attribute is still valid anywhere.\n       * Struct fields may no longer be mutable. Use inherited mutability.\n-      * The `#[non_owned]` attribute makes a type that would otherwise be\n-        `Owned`, not. TODO this may change to non_send before 0.7\n-      * The `#[mutable]` attribute makes a type that would otherwise be\n-        `Const`, note. TODO this may change to non_freeze before 0.7\n+      * The `#[no_send]` attribute makes a type that would otherwise be\n+        `Send`, not.\n+      * The `#[no_freeze]` attribute makes a type that would otherwise be\n+        `Freeze`, not.\n       * Unbounded recursion will abort the process after reaching the limit\n-        specified by the `RUST_MAX_STACK` environment variable.\n+        specified by the `RUST_MAX_STACK` environment variable (default: 1GB).\n       * The `vecs_implicitly_copyable` lint mode has been removed. Vectors\n         are never implicitly copyable.\n+      * `#[static_assert]` makes compile-time assertions about static bools.\n+      * At long last, 'argument modes' no longer exist.\n+      * The rarely used `use mod` statement no longer exists.\n+\n+   * Syntax extensions\n+      * `fail!` and `assert!` accept `~str`, `&'static str` or `fmt!`-style\n+        argument list.\n+      * `Encodable`, `Decodable`, `Ord`, `TotalOrd`, `TotalEq`, `DeepClone`,\n+        `Rand`, `Zero` and `ToStr` can all be automatically derived with\n+        `#[deriving(...)]`.\n+      * The `bytes!` macro returns a vector of bytes for string, u8, char,\n+        and unsuffixed integer literals.\n \n    * Libraries\n       * The `core` crate was renamed to `std`.\n       * The `std` crate was renamed to `extra`.\n-      * `std::mut` removed.\n+      * More and improved documentation.\n+      * std: `iterator` module for external iterator objects.\n+      * Many old-style (internal, higher-order function) iterators replaced by\n+        implementations of `Iterator`.\n+      * std: Many old internal vector and string iterators,\n+        incl. `any`, `all`. removed.\n+      * std: The `finalize` method of `Drop` renamed to `drop`.\n       * std: The prelude no longer reexports any modules, only types and traits.\n       * std: Prelude additions: `print`, `println`, `FromStr`, `ApproxEq`, `Equiv`,\n         `Iterator`, `IteratorUtil`, many numeric traits, many tuple traits.\n-      * std: `iterator` module for external iterator objects.\n-      * std: new numeric traits: `Fractional`, `Real`, `RealExt`, `Integer`, `Ratio`,\n+      * std: New numeric traits: `Fractional`, `Real`, `RealExt`, `Integer`, `Ratio`,\n         `Algebraic`, `Trigonometric`, `Exponential`, `Primitive`.\n       * std: Tuple traits and accessors defined for up to 12-tuples, e.g.\n         `(0, 1, 2).n2()` or `(0, 1, 2).n2_ref()`.\n-      * std: many types implement `Clone` - tuples, @, @mut. TODO\n+      * std: Many types implement `Clone`.\n       * std: `path` type renamed to `Path`.\n-      * std: Many standalone functions removed in favor of methods in\n-        `vec`, `str`. In the future methods will also work as functions.\n-      * std: `reinterpret_cast` removed. Used `transmute`.\n+      * std: `mut` module and `Mut` type removed.\n+      * std: Many standalone functions removed in favor of methods and iterators\n+        in `vec`, `str`. In the future methods will also work as functions.\n+      * std: `reinterpret_cast` removed. Use `transmute`.\n       * std: ascii string handling in `std::ascii`.\n       * std: `Rand` is implemented for ~/@.\n       * std: `run` module for spawning processes overhauled.\n       * std: Various atomic types added to `unstable::atomic`.\n+      * std: Various types implement `Zero`.\n       * std: `LinearMap` and `LinearSet` renamed to `HashMap` and `HashSet`.\n+      * std: Borrowed pointer functions moved from `ptr` to `borrow`.\n       * std: Added `os::mkdir_recursive`.\n       * std: Added `os::glob` function performs filesystems globs.\n       * std: `FuzzyEq` renamed to `ApproxEq`.\n       * std: `Map` now defines `pop` and `swap` methods.\n+      * std: `Cell` constructors converted to static methods.\n+      * extra: `rc` module adds the reference counted pointers, `Rc` and `RcMut`.\n       * extra: `flate` module moved from `std` to `extra`.\n-      * extra: `FileInput` implements `std::io::Reader`.\n+      * extra: `fileinput` module for iterating over a series of files.\n       * extra: `Complex` number type and `complex` module.\n       * extra: `Rational` number type and `rational` module.\n       * extra: `BigInt`, `BigUint` implement numeric and comparison traits.\n       * extra: `term` uses terminfo now, is more correct.\n+      * extra: `arc` functions converted to methods.\n+      * extra: Implementation of fixed output size variations of SHA-2.\n \n    * Tooling\n-      * `unused_unsafe` lint mode for detecting unnecessary `unsafe` blocks.\n-      * `unused_mut` lint mode for identifying unused `mut` qualifiers.\n+      * `unused_variable`  lint mode for unused variables (default: warn).\n+      * `unused_unsafe` lint mode for detecting unnecessary `unsafe` blocks\n+        (default: warn).\n+      * `unused_mut` lint mode for identifying unused `mut` qualifiers\n+        (default: warn).\n+      * `dead_assignment` lint mode for unread variables (default: warn).\n+      * `unnecessary_allocation` lint mode detects some heap allocations that are\n+        immediately borrowed so could be written without allocating (default: warn).\n+      * `missing_doc` lint mode (default: allow).\n+      * `unreachable_code` lint mode (default: warn).\n       * The `rusti` command has been rewritten and a number of bugs addressed.\n       * rustc outputs in color on more terminals.\n       * rustc accepts a `--link-args` flag to pass arguments to the linker.\n@@ -82,12 +111,7 @@ Version 0.7 (July 2013)\n         dynamic borrowcheck failures for debugging.\n       * rustdoc has a nicer stylesheet.\n       * Various improvements to rustdoc.\n-\n-   * Other\n-      * More and improved library documentation.\n-      * Various improvements on ARM and Android.\n-      * Various improvements to MIPS backend.\n-      * jemalloc is the Rust allocator.\n+      * Improvements to rustpkg (see the detailed release notes).\n \n Version 0.6 (April 2013)\n ------------------------"}, {"sha": "d0a98fbfa75c4e623fb30f466df5ce9dcbdaeacf", "filename": "configure", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/configure", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -834,9 +834,7 @@ do\n         LLVM_TARGET=\"--target=$t\"\n \n         # Disable unused LLVM features\n-        LLVM_OPTS=\"$LLVM_DBG_OPTS --disable-docs \\\n-                   --enable-bindings=none --disable-threads \\\n-                   --disable-pthreads\"\n+        LLVM_OPTS=\"$LLVM_DBG_OPTS --disable-docs --enable-bindings=none\"\n \n         case \"$CFG_C_COMPILER\" in\n             (\"ccache clang\")"}, {"sha": "bb6ab77a80213d0f1305b06ba7eaa88ebdb55413", "filename": "doc/README", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/doc%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/doc%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2FREADME?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -1,10 +1,25 @@\n-The markdown docs are only generated by make when node is installed (use\n-`make doc`). If you don't have node installed you can generate them yourself.\n-Unfortunately there's no real standard for markdown and all the tools work\n-differently. pandoc is one that seems to work well.\n+Pandoc, a universal document converter, is required to generate docs as HTML\n+from Rust's source code. It's available for most platforms here:\n+http://johnmacfarlane.net/pandoc/installing.html\n \n-To generate an html version of a doc do something like:\n-pandoc --from=markdown --to=html --number-sections -o build/doc/rust.html doc/rust.md && git web--browse build/doc/rust.html\n+Node.js (http://nodejs.org/) is also required for generating HTML from\n+the Markdown docs (reference manual, tutorials, etc.) distributed with\n+this git repository.\n+\n+To generate all the docs, run `make docs` from the root of the repository.\n+This will convert the distributed Markdown docs to HTML and generate HTML doc\n+for the 'std' and 'extra' libraries.\n+\n+To generate HTML documentation from one source file/crate, do something like:\n+\n+  rustdoc --output-dir html-doc/ --output-format html ../src/libstd/path.rs\n+\n+(This, of course, requires that you've built/installed the `rustdoc` tool.)\n+\n+To generate an HTML version of a doc from Markdown, without having Node.js\n+installed, do something like:\n+\n+  pandoc --from=markdown --to=html --number-sections -o rust.html rust.md\n \n The syntax for pandoc flavored markdown can be found at:\n http://johnmacfarlane.net/pandoc/README.html#pandocs-markdown"}, {"sha": "cc53d7d17a25a5019b7f9fe01922bbe38a48e3e5", "filename": "doc/rust.md", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -882,11 +882,11 @@ the function name.\n \n ~~~~ {.xfail-test}\n fn iter<T>(seq: &[T], f: &fn(T)) {\n-    for seq.each |elt| { f(elt); }\n+    for seq.iter().advance |elt| { f(elt); }\n }\n fn map<T, U>(seq: &[T], f: &fn(T) -> U) -> ~[U] {\n     let mut acc = ~[];\n-    for seq.each |elt| { acc.push(f(elt)); }\n+    for seq.iter().advance |elt| { acc.push(f(elt)); }\n     acc\n }\n ~~~~\n@@ -1561,8 +1561,11 @@ Supported traits for `deriving` are:\n * `Clone` and `DeepClone`, to perform (deep) copies.\n * `IterBytes`, to iterate over the bytes in a data type.\n * `Rand`, to create a random instance of a data type.\n+* `Zero`, to create an zero (or empty) instance of a data type.\n * `ToStr`, to convert to a string. For a type with this instance,\n-  `obj.to_str()` has the same output as `fmt!(\"%?\", obj)`.\n+  `obj.to_str()` has similar output as `fmt!(\"%?\", obj)`, but it differs in that\n+  each constituent field of the type must also implement `ToStr` and will have\n+  `field.to_str()` invoked to build up the result.\n \n # Statements and expressions\n \n@@ -2326,7 +2329,7 @@ An example of a for loop over the contents of a vector:\n \n let v: &[foo] = &[a, b, c];\n \n-for v.each |e| {\n+for v.iter().advance |e| {\n     bar(*e);\n }\n ~~~~\n@@ -2617,7 +2620,7 @@ assert!(b != \"world\");\n \n The vector type constructor represents a homogeneous array of values of a given type.\n A vector has a fixed size.\n-(Operations like `vec::push` operate solely on owned vectors.)\n+(Operations like `vec.push` operate solely on owned vectors.)\n A vector type can be annotated with a _definite_ size,\n written with a trailing asterisk and integer literal, such as `[int * 10]`.\n Such a definite-sized vector type is a first-class type, since its size is known statically.\n@@ -2859,13 +2862,13 @@ call to the method `make_string`.\n Types in Rust are categorized into kinds, based on various properties of the components of the type.\n The kinds are:\n \n-`Const`\n+`Freeze`\n   : Types of this kind are deeply immutable;\n     they contain no mutable memory locations directly or indirectly via pointers.\n-`Owned`\n+`Send`\n   : Types of this kind can be safely sent between tasks.\n     This kind includes scalars, owning pointers, owned closures, and\n-    structural types containing only other owned types. All `Owned` types are `Static`.\n+    structural types containing only other owned types. All `Send` types are `Static`.\n `Static`\n   : Types of this kind do not contain any borrowed pointers;\n     this can be a useful guarantee for code that breaks borrowing assumptions using [`unsafe` operations](#unsafe-functions).\n@@ -2879,7 +2882,7 @@ The kinds are:\n     trait provides a single method `finalize` that takes no parameters, and is run\n     when values of the type are dropped. Such a method is called a \"destructor\",\n     and are always executed in \"top-down\" order: a value is completely destroyed\n-    before any of the values it owns run their destructors. Only `Owned` types\n+    before any of the values it owns run their destructors. Only `Send` types\n     that do not implement `Copy` can implement `Drop`.\n \n > **Note:** The `finalize` method may be renamed in future versions of Rust.\n@@ -2965,10 +2968,10 @@ frame they are allocated within.\n A task owns all memory it can *safely* reach through local variables,\n as well as managed, owning and borrowed pointers.\n \n-When a task sends a value that has the `Owned` trait to another task,\n+When a task sends a value that has the `Send` trait to another task,\n it loses ownership of the value sent and can no longer refer to it.\n This is statically guaranteed by the combined use of \"move semantics\",\n-and the compiler-checked _meaning_ of the `Owned` trait:\n+and the compiler-checked _meaning_ of the `Send` trait:\n it is only instantiated for (transitively) sendable kinds of data constructor and pointers,\n never including managed or borrowed pointers.\n \n@@ -3113,7 +3116,7 @@ These include:\n   - read-only and read-write shared variables with various safe mutual exclusion patterns\n   - simple locks and semaphores\n \n-When such facilities carry values, the values are restricted to the [`Owned` type-kind](#type-kinds).\n+When such facilities carry values, the values are restricted to the [`Send` type-kind](#type-kinds).\n Restricting communication interfaces to this kind ensures that no borrowed or managed pointers move between tasks.\n Thus access to an entire data structure can be mediated through its owning \"root\" value;\n no further locking or copying is required to avoid data races within the substructure of such a value."}, {"sha": "506fc2ad15a8cdc4545e233ac2a21850017835b9", "filename": "doc/rustpkg.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/doc%2Frustpkg.md", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/doc%2Frustpkg.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frustpkg.md?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -95,12 +95,22 @@ When building a package that is in a `git` repository,\n When building a package that is not under version control,\n or that has no tags, `rustpkg` assumes the intended version is 0.1.\n \n+# Dependencies\n+\n+rustpkg infers dependencies from `extern mod` directives.\n+Thus, there should be no need to pass a `-L` flag to rustpkg to tell it where to find a library.\n+(In the future, it will also be possible to write an `extern mod` directive referring to a remote package.)\n+\n # Custom build scripts\n \n A file called `pkg.rs` at the root level in a workspace is called a *package script*.\n If a package script exists, rustpkg executes it to build the package\n rather than inferring crates as described previously.\n \n+Inside `pkg.rs`, it's possible to call back into rustpkg to finish up the build.\n+`rustpkg::api` contains functions to build, install, or clean libraries and executables\n+in the way rustpkg normally would without custom build logic.\n+\n # Command reference\n \n ## build"}, {"sha": "1da1d046878a71f9eac9d7afc5b50755523419d6", "filename": "doc/tutorial-borrowed-ptr.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/doc%2Ftutorial-borrowed-ptr.md", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/doc%2Ftutorial-borrowed-ptr.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-borrowed-ptr.md?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -234,7 +234,7 @@ would therefore be subject to garbage collection. A heap box that is\n unrooted is one such that no pointer values in the heap point to\n it. It would violate memory safety for the box that was originally\n assigned to `x` to be garbage-collected, since a non-heap\n-pointer---`y`---still points into it.\n+pointer *`y`* still points into it.\n \n > ***Note:*** Our current implementation implements the garbage collector\n > using reference counting and cycle detection.\n@@ -475,7 +475,7 @@ but otherwise it requires that the data reside in immutable memory.\n \n # Returning borrowed pointers\n \n-So far, all of the examples we've looked at use borrowed pointers in a\n+So far, all of the examples we have looked at, use borrowed pointers in a\n \u201cdownward\u201d direction. That is, a method or code block creates a\n borrowed pointer, then uses it within the same scope. It is also\n possible to return borrowed pointers as the result of a function, but\n@@ -509,7 +509,7 @@ guaranteed to refer to a distinct lifetime from the lifetimes of all\n other parameters.\n \n Named lifetimes that appear in function signatures are conceptually\n-the same as the other lifetimes we've seen before, but they are a bit\n+the same as the other lifetimes we have seen before, but they are a bit\n abstract: they don\u2019t refer to a specific expression within `get_x()`,\n but rather to some expression within the *caller of `get_x()`*.  The\n lifetime `r` is actually a kind of *lifetime parameter*: it is defined"}, {"sha": "66bd0b9c1319f4cda407a9c42cdd08a9488adab1", "filename": "doc/tutorial-container.md", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/doc%2Ftutorial-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/doc%2Ftutorial-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-container.md?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -0,0 +1,207 @@\n+% Containers and iterators\n+\n+# Containers\n+\n+The container traits are defined in the `std::container` module.\n+\n+## Unique and managed vectors\n+\n+Vectors have `O(1)` indexing and removal from the end, along with `O(1)`\n+amortized insertion. Vectors are the most common container in Rust, and are\n+flexible enough to fit many use cases.\n+\n+Vectors can also be sorted and used as efficient lookup tables with the\n+`std::vec::bsearch` function, if all the elements are inserted at one time and\n+deletions are unnecessary.\n+\n+## Maps and sets\n+\n+Maps are collections of unique keys with corresponding values, and sets are\n+just unique keys without a corresponding value. The `Map` and `Set` traits in\n+`std::container` define the basic interface.\n+\n+The standard library provides three owned map/set types:\n+\n+* `std::hashmap::HashMap` and `std::hashmap::HashSet`, requiring the keys to\n+  implement `Eq` and `Hash`\n+* `std::trie::TrieMap` and `std::trie::TrieSet`, requiring the keys to be `uint`\n+* `extra::treemap::TreeMap` and `extra::treemap::TreeSet`, requiring the keys\n+  to implement `TotalOrd`\n+\n+These maps do not use managed pointers so they can be sent between tasks as\n+long as the key and value types are sendable. Neither the key or value type has\n+to be copyable.\n+\n+The `TrieMap` and `TreeMap` maps are ordered, while `HashMap` uses an arbitrary\n+order.\n+\n+Each `HashMap` instance has a random 128-bit key to use with a keyed hash,\n+making the order of a set of keys in a given hash table randomized. Rust\n+provides a [SipHash](https://131002.net/siphash/) implementation for any type\n+implementing the `IterBytes` trait.\n+\n+## Double-ended queues\n+\n+The `extra::deque` module implements a double-ended queue with `O(1)` amortized\n+inserts and removals from both ends of the container. It also has `O(1)`\n+indexing like a vector. The contained elements are not required to be copyable,\n+and the queue will be sendable if the contained type is sendable.\n+\n+## Priority queues\n+\n+The `extra::priority_queue` module implements a queue ordered by a key.  The\n+contained elements are not required to be copyable, and the queue will be\n+sendable if the contained type is sendable.\n+\n+Insertions have `O(log n)` time complexity and checking or popping the largest\n+element is `O(1)`. Converting a vector to a priority queue can be done\n+in-place, and has `O(n)` complexity. A priority queue can also be converted to\n+a sorted vector in-place, allowing it to be used for an `O(n log n)` in-place\n+heapsort.\n+\n+# Iterators\n+\n+## Iteration protocol\n+\n+The iteration protocol is defined by the `Iterator` trait in the\n+`std::iterator` module. The minimal implementation of the trait is a `next`\n+method, yielding the next element from an iterator object:\n+\n+~~~\n+/// An infinite stream of zeroes\n+struct ZeroStream;\n+\n+impl Iterator<int> for ZeroStream {\n+    fn next(&mut self) -> Option<int> {\n+        Some(0)\n+    }\n+}\n+~~~~\n+\n+Reaching the end of the iterator is signalled by returning `None` instead of\n+`Some(item)`:\n+\n+~~~\n+/// A stream of N zeroes\n+struct ZeroStream {\n+    priv remaining: uint\n+}\n+\n+impl ZeroStream {\n+    fn new(n: uint) -> ZeroStream {\n+        ZeroStream { remaining: n }\n+    }\n+}\n+\n+impl Iterator<int> for ZeroStream {\n+    fn next(&mut self) -> Option<int> {\n+        if self.remaining == 0 {\n+            None\n+        } else {\n+            self.remaining -= 1;\n+            Some(0)\n+        }\n+    }\n+}\n+~~~\n+\n+## Container iterators\n+\n+Containers implement iteration over the contained elements by returning an\n+iterator object. For example, vectors have four iterators available:\n+\n+* `vector.iter()`, for immutable references to the elements\n+* `vector.mut_iter()`, for mutable references to the elements\n+* `vector.rev_iter()`, for immutable references to the elements in reverse order\n+* `vector.mut_rev_iter()`, for mutable references to the elements in reverse order\n+\n+### Freezing\n+\n+Unlike most other languages with external iterators, Rust has no *iterator\n+invalidation*. As long an iterator is still in scope, the compiler will prevent\n+modification of the container through another handle.\n+\n+~~~\n+let mut xs = [1, 2, 3];\n+{\n+    let _it = xs.iter();\n+\n+    // the vector is frozen for this scope, the compiler will statically\n+    // prevent modification\n+}\n+// the vector becomes unfrozen again at the end of the scope\n+~~~\n+\n+These semantics are due to most container iterators being implemented with `&`\n+and `&mut`.\n+\n+## Iterator adaptors\n+\n+The `IteratorUtil` trait implements common algorithms as methods extending\n+every `Iterator` implementation. For example, the `fold` method will accumulate\n+the items yielded by an `Iterator` into a single value:\n+\n+~~~\n+let xs = [1, 9, 2, 3, 14, 12];\n+let result = xs.iter().fold(0, |accumulator, item| accumulator - *item);\n+assert_eq!(result, -41);\n+~~~\n+\n+Some adaptors return an adaptor object implementing the `Iterator` trait itself:\n+\n+~~~\n+let xs = [1, 9, 2, 3, 14, 12];\n+let ys = [5, 2, 1, 8];\n+let sum = xs.iter().chain_(ys.iter()).fold(0, |a, b| a + *b);\n+assert_eq!(sum, 57);\n+~~~\n+\n+Note that some adaptors like the `chain_` method above use a trailing\n+underscore to work around an issue with method resolve. The underscores will be\n+dropped when they become unnecessary.\n+\n+## For loops\n+\n+The `for` loop syntax is currently in transition, and will switch from the old\n+closure-based iteration protocol to iterator objects. For now, the `advance`\n+adaptor is required as a compatibility shim to use iterators with for loops.\n+\n+~~~\n+let xs = [2, 3, 5, 7, 11, 13, 17];\n+\n+// print out all the elements in the vector\n+for xs.iter().advance |x| {\n+    println(x.to_str())\n+}\n+\n+// print out all but the first 3 elements in the vector\n+for xs.iter().skip(3).advance |x| {\n+    println(x.to_str())\n+}\n+~~~\n+\n+For loops are *often* used with a temporary iterator object, as above. They can\n+also advance the state of an iterator in a mutable location:\n+\n+~~~\n+let xs = [1, 2, 3, 4, 5];\n+let ys = [\"foo\", \"bar\", \"baz\", \"foobar\"];\n+\n+// create an iterator yielding tuples of elements from both vectors\n+let mut it = xs.iter().zip(ys.iter());\n+\n+// print out the pairs of elements up to (&3, &\"baz\")\n+for it.advance |(x, y)| {\n+    println(fmt!(\"%d %s\", *x, *y));\n+\n+    if *x == 3 {\n+        break;\n+    }\n+}\n+\n+// yield and print the last pair from the iterator\n+println(fmt!(\"last: %?\", it.next()));\n+\n+// the iterator is now fully consumed\n+assert!(it.next().is_none());\n+~~~"}, {"sha": "047b57e56a61aa950e1e93228a217c72a9608c6d", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -159,7 +159,7 @@ pub struct Unique<T> {\n     priv ptr: *mut T\n }\n \n-impl<T: Owned> Unique<T> {\n+impl<T: Send> Unique<T> {\n     pub fn new(value: T) -> Unique<T> {\n         unsafe {\n             let ptr = malloc(std::sys::size_of::<T>() as size_t) as *mut T;\n@@ -182,8 +182,8 @@ impl<T: Owned> Unique<T> {\n }\n \n #[unsafe_destructor]\n-impl<T: Owned> Drop for Unique<T> {\n-    fn finalize(&self) {\n+impl<T: Send> Drop for Unique<T> {\n+    fn drop(&self) {\n         unsafe {\n             let x = intrinsics::init(); // dummy value to swap in\n             // moving the object out is needed to call the destructor"}, {"sha": "d302916025c09f9142d8aa0768fb5def2f149bb0", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -283,7 +283,7 @@ let ports = do vec::from_fn(3) |init_val| {\n };\n \n // Wait on each port, accumulating the results\n-let result = ports.foldl(0, |accum, port| *accum + port.recv() );\n+let result = ports.iter().fold(0, |accum, port| accum + port.recv() );\n # fn some_expensive_computation(_i: uint) -> int { 42 }\n ~~~\n \n@@ -481,7 +481,7 @@ an `Error` result.\n TODO: Need discussion of `future_result` in order to make failure\n modes useful.\n \n-But not all failure is created equal. In some cases you might need to\n+But not all failures are created equal. In some cases you might need to\n abort the entire program (perhaps you're writing an assert which, if\n it trips, indicates an unrecoverable logic error); in other cases you\n might want to contain the failure at a certain boundary (perhaps a"}, {"sha": "d3113703c7cc19c2ae56d9604371bb0fbd1b715b", "filename": "doc/tutorial.md", "status": "modified", "additions": 22, "deletions": 116, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -99,9 +99,9 @@ If you've fulfilled those prerequisites, something along these lines\n should work.\n \n ~~~~ {.notrust}\n-$ curl -O http://static.rust-lang.org/dist/rust-0.6.tar.gz\n-$ tar -xzf rust-0.6.tar.gz\n-$ cd rust-0.6\n+$ curl -O http://static.rust-lang.org/dist/rust-0.7.tar.gz\n+$ tar -xzf rust-0.7.tar.gz\n+$ cd rust-0.7\n $ ./configure\n $ make && make install\n ~~~~\n@@ -119,8 +119,8 @@ API-documentation tool; `rustpkg`, the Rust package manager;\n interface for them, and for a few common command line scenarios.\n \n [wiki-start]: https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust\n-[tarball]: http://static.rust-lang.org/dist/rust-0.6.tar.gz\n-[win-exe]: http://static.rust-lang.org/dist/rust-0.6-install.exe\n+[tarball]: http://static.rust-lang.org/dist/rust-0.7.tar.gz\n+[win-exe]: http://static.rust-lang.org/dist/rust-0.7-install.exe\n \n ## Compiling your first program\n \n@@ -1084,8 +1084,8 @@ let managed_box  : @Point = @Point { x: 5.0, y: 1.0 };\n let owned_box    : ~Point = ~Point { x: 7.0, y: 9.0 };\n ~~~\n \n-Suppose we wanted to write a procedure that computed the distance\n-between any two points, no matter where they were stored. For example,\n+Suppose we want to write a procedure that computes the distance\n+between any two points, no matter where they are stored. For example,\n we might like to compute the distance between `on_the_stack` and\n `managed_box`, or between `managed_box` and `owned_box`. One option is\n to define a function that takes two arguments of type point\u2014that is,\n@@ -1230,7 +1230,7 @@ let area = rect.area();\n ~~~\n \n You can write an expression that dereferences any number of pointers\n-automatically. For example, if you felt inclined, you could write\n+automatically. For example, if you feel inclined, you could write\n something silly like\n \n ~~~\n@@ -1281,9 +1281,9 @@ let your_crayons = ~[BananaMania, Beaver, Bittersweet];\n // Add two vectors to create a new one\n let our_crayons = my_crayons + your_crayons;\n \n-// += will append to a vector, provided it lives in a mutable slot\n+// .push_all() will append to a vector, provided it lives in a mutable slot\n let mut my_crayons = my_crayons;\n-my_crayons += your_crayons;\n+my_crayons.push_all(your_crayons);\n ~~~~\n \n > ***Note:*** The above examples of vector addition use owned\n@@ -1396,7 +1396,7 @@ assert!(!crayons.is_empty());\n \n // Iterate over a vector, obtaining a pointer to each element\n // (`for` is explained in the next section)\n-for crayons.each |crayon| {\n+for crayons.iter().advance |crayon| {\n     let delicious_crayon_wax = unwrap_crayon(*crayon);\n     eat_crayon_wax(delicious_crayon_wax);\n }\n@@ -1552,13 +1552,6 @@ fn each(v: &[int], op: &fn(v: &int)) {\n }\n ~~~~\n \n-As an aside, the reason we pass in a *pointer* to an integer rather\n-than the integer itself is that this is how the actual `each()`\n-function for vectors works. `vec::each` though is a\n-[generic](#generics) function, so must be efficient to use for all\n-types. Passing the elements by pointer avoids copying potentially\n-large objects.\n-\n As a caller, if we use a closure to provide the final operator\n argument, we can write it in a way that has a pleasant, block-like\n structure.\n@@ -1614,93 +1607,6 @@ do spawn {\n If you want to see the output of `debug!` statements, you will need to turn on `debug!` logging.\n To enable `debug!` logging, set the RUST_LOG environment variable to the name of your crate, which, for a file named `foo.rs`, will be `foo` (e.g., with bash, `export RUST_LOG=foo`).\n \n-## For loops\n-\n-The most common way to express iteration in Rust is with a `for`\n-loop. Like `do`, `for` is a nice syntax for describing control flow\n-with closures.  Additionally, within a `for` loop, `break`, `loop`,\n-and `return` work just as they do with `while` and `loop`.\n-\n-Consider again our `each` function, this time improved to return\n-immediately when the iteratee returns `false`:\n-\n-~~~~\n-fn each(v: &[int], op: &fn(v: &int) -> bool) -> bool {\n-   let mut n = 0;\n-   while n < v.len() {\n-       if !op(&v[n]) {\n-           return false;\n-       }\n-       n += 1;\n-   }\n-   return true;\n-}\n-~~~~\n-\n-And using this function to iterate over a vector:\n-\n-~~~~\n-# use each = std::vec::each;\n-each([2, 4, 8, 5, 16], |n| {\n-    if *n % 2 != 0 {\n-        println(\"found odd number!\");\n-        false\n-    } else { true }\n-});\n-~~~~\n-\n-With `for`, functions like `each` can be treated more\n-like built-in looping structures. When calling `each`\n-in a `for` loop, instead of returning `false` to break\n-out of the loop, you just write `break`. To skip ahead\n-to the next iteration, write `loop`.\n-\n-~~~~\n-# use each = std::vec::each;\n-for each([2, 4, 8, 5, 16]) |n| {\n-    if *n % 2 != 0 {\n-        println(\"found odd number!\");\n-        break;\n-    }\n-}\n-~~~~\n-\n-As an added bonus, you can use the `return` keyword, which is not\n-normally allowed in closures, in a block that appears as the body of a\n-`for` loop: the meaning of `return` in such a block is to return from\n-the enclosing function, not just the loop body.\n-\n-~~~~\n-# use each = std::vec::each;\n-fn contains(v: &[int], elt: int) -> bool {\n-    for each(v) |x| {\n-        if (*x == elt) { return true; }\n-    }\n-    false\n-}\n-~~~~\n-\n-Notice that, because `each` passes each value by borrowed pointer,\n-the iteratee needs to dereference it before using it.\n-In these situations it can be convenient to lean on Rust's\n-argument patterns to bind `x` to the actual value, not the pointer.\n-\n-~~~~\n-# use each = std::vec::each;\n-# fn contains(v: &[int], elt: int) -> bool {\n-    for each(v) |&x| {\n-        if (x == elt) { return true; }\n-    }\n-#    false\n-# }\n-~~~~\n-\n-`for` syntax only works with stack closures.\n-\n-> ***Note:*** This is, essentially, a special loop protocol:\n-> the keywords `break`, `loop`, and `return` work, in varying degree,\n-> with `while`, `loop`, `do`, and `for` constructs.\n-\n # Methods\n \n Methods are like functions except that they always begin with a special argument,\n@@ -1808,7 +1714,7 @@ s.draw_borrowed();\n ~~~\n \n Implementations may also define standalone (sometimes called \"static\")\n-methods. The absence of a `self` paramater distinguishes such methods.\n+methods. The absence of a `self` parameter distinguishes such methods.\n These methods are the preferred way to define constructor functions.\n \n ~~~~ {.xfail-test}\n@@ -1841,10 +1747,9 @@ vector consisting of the result of applying `function` to each element\n of `vector`:\n \n ~~~~\n-# use std::vec;\n fn map<T, U>(vector: &[T], function: &fn(v: &T) -> U) -> ~[U] {\n     let mut accumulator = ~[];\n-    for vec::each(vector) |element| {\n+    for vector.iter().advance |element| {\n         accumulator.push(function(element));\n     }\n     return accumulator;\n@@ -1979,7 +1884,7 @@ types by the compiler, and may not be overridden:\n > iterations of the language, and often still are.\n \n Additionally, the `Drop` trait is used to define destructors. This\n-trait defines one method called `finalize`, which is automatically\n+trait defines one method called `drop`, which is automatically\n called when a value of the type that implements this trait is\n destroyed, either because the value went out of scope or because the\n garbage collector reclaimed it.\n@@ -1990,15 +1895,15 @@ struct TimeBomb {\n }\n \n impl Drop for TimeBomb {\n-    fn finalize(&self) {\n+    fn drop(&self) {\n         for self.explosivity.times {\n             println(\"blam!\");\n         }\n     }\n }\n ~~~\n \n-It is illegal to call `finalize` directly. Only code inserted by the compiler\n+It is illegal to call `drop` directly. Only code inserted by the compiler\n may call it.\n \n ## Declaring and implementing traits\n@@ -2119,7 +2024,7 @@ generic types.\n ~~~~\n # trait Printable { fn print(&self); }\n fn print_all<T: Printable>(printable_things: ~[T]) {\n-    for printable_things.each |thing| {\n+    for printable_things.iter().advance |thing| {\n         thing.print();\n     }\n }\n@@ -2165,7 +2070,7 @@ However, consider this function:\n trait Drawable { fn draw(&self); }\n \n fn draw_all<T: Drawable>(shapes: ~[T]) {\n-    for shapes.each |shape| { shape.draw(); }\n+    for shapes.iter().advance |shape| { shape.draw(); }\n }\n # let c: Circle = new_circle();\n # draw_all(~[c]);\n@@ -2180,7 +2085,7 @@ an _object_.\n ~~~~\n # trait Drawable { fn draw(&self); }\n fn draw_all(shapes: &[@Drawable]) {\n-    for shapes.each |shape| { shape.draw(); }\n+    for shapes.iter().advance |shape| { shape.draw(); }\n }\n ~~~~\n \n@@ -2319,7 +2224,7 @@ enum ABC { A, B, C }\n \n The full list of derivable traits is `Eq`, `TotalEq`, `Ord`,\n `TotalOrd`, `Encodable` `Decodable`, `Clone`, `DeepClone`,\n-`IterBytes`, `Rand` and `ToStr`.\n+`IterBytes`, `Rand`, `Zero`, and `ToStr`.\n \n # Modules and crates\n \n@@ -2522,7 +2427,7 @@ will not be compiled successfully.\n \n ## A minimal example\n \n-Now for something that you can actually compile yourself. We have\n+Now for something that you can actually compile yourself, we have\n these two files:\n \n ~~~~\n@@ -2622,6 +2527,7 @@ tutorials on individual topics.\n * [Tasks and communication][tasks]\n * [Macros][macros]\n * [The foreign function interface][ffi]\n+* [Containers and iterators](tutorial-container.html)\n \n There is further documentation on the [wiki].\n "}, {"sha": "4e76749f707ee3a29f667a734a21a4022dd57b72", "filename": "man/rustc.1", "status": "modified", "additions": 18, "deletions": 51, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/man%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/man%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustc.1?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -1,4 +1,4 @@\n-.TH RUSTC \"1\" \"February 2013\" \"rustc 0.6\" \"User Commands\"\n+.TH RUSTC \"1\" \"July 2013\" \"rustc 0.7\" \"User Commands\"\n .SH NAME\n rustc \\- rust compiler\n .SH SYNOPSIS\n@@ -33,6 +33,12 @@ Add a directory to the library search path\n \\fB\\-\\-lib\\fR\n Compile a library crate\n .TP\n+\\fB\\-\\-linker\\fR LINKER\n+Program to use for linking instead of the default\n+.TP\n+\\fB\\-\\-link-args\\fR FLAGS\n+A space-separated list of flags passed to the linker\n+.TP\n \\fB\\-\\-ls\\fR\n List the symbols defined by a library crate\n .TP\n@@ -48,6 +54,11 @@ Write output to <filename>\n \\fB\\-\\-opt\\-level\\fR LEVEL\n Optimize with possible levels 0-3\n .TP\n+\\fB\\-\\-passes\\fR NAMES\n+Comma- or space-separated list of optimization passes. Overrides\n+the default passes for the optimization level. A value of 'list'\n+will list the available passes.\n+.TP\n \\fB\\-\\-out\\-dir\\fR DIR\n Write output to compiler-chosen filename in <dir>\n .TP\n@@ -77,6 +88,12 @@ Target triple cpu-manufacturer-kernel[-os] to compile for (see\n http://sources.redhat.com/autobook/autobook/autobook_17.html\n for detail)\n .TP\n+\\fB\\-\\-target-feature\\fR TRIPLE\n+Target-specific attributes (see llc -mattr=help for detail)\n+.TP\n+\\fB\\-\\-android-cross-path\\fR PATH\n+The path to the Android NDK\n+.TP\n \\fB\\-W\\fR help\n Print 'lint' options and default settings\n .TP\n@@ -94,56 +111,6 @@ Set lint forbidden\n .TP\n \\fB\\-Z\\fR FLAG\n Set internal debugging options. Use \"-Z help\" to print available options.\n-\n-Available debug flags are:\n-.RS\n-.IP \\[bu]\n-\\fBverbose\\fR - in general, enable more debug printouts\n-.IP \\[bu]\n-\\fBtime\\-passes\\fR - measure time of each rustc pass\n-.IP \\[bu]\n-\\fBcount\\-llvm\\-insns\\fR - count where LLVM instrs originate\n-.IP \\[bu]\n-\\fBtime\\-llvm\\-passes\\fR - measure time of each LLVM pass\n-.IP \\[bu]\n-\\fBtrans\\-stats\\fR - gather trans statistics\n-.IP \\[bu]\n-\\fBno\\-asm\\-comments\\fR - omit comments when using \\fI\\-S\\fR\n-.IP \\[bu]\n-\\fBno\\-verify\\fR - skip LLVM verification\n-.IP \\[bu]\n-\\fBtrace\\fR - emit trace logs\n-.IP \\[bu]\n-\\fBcoherence\\fR - perform coherence checking\n-.IP \\[bu]\n-\\fBborrowck\\-stats\\fR - gather borrowck statistics\n-.IP \\[bu]\n-\\fBborrowck\\-note\\-pure\\fR - note where purity is req'd\n-.IP \\[bu]\n-\\fBborrowck\\-note\\-loan\\fR - note where loans are req'd\n-.IP \\[bu]\n-\\fBno\\-landing\\-pads\\fR - omit landing pads for unwinding\n-.IP \\[bu]\n-\\fBdebug\\-llvm\\fR - enable debug output from LLVM\n-.IP \\[bu]\n-\\fBcount\\-type\\-sizes\\fR - count the sizes of aggregate types\n-.IP \\[bu]\n-\\fBmeta\\-stats\\fR - gather metadata statistics\n-.IP \\[bu]\n-\\fBno\\-opt\\fR - do not optimize, even if \\fI\\-O\\fR is passed\n-.IP \\[bu]\n-\\fBno\\-monomorphic\\-collapse\\fR - do not collapse template instantiations\n-.IP \\[bu]\n-\\fBgc\\fR - Garbage collect shared data (experimental)\n-.IP \\[bu]\n-\\fBjit\\fR - Execute using JIT (experimental)\n-.IP \\[bu]\n-\\fBextra\\-debug\\-info\\fR - Extra debugging info (experimental)\n-.IP \\[bu]\n-\\fBdebug\\-info\\fR - Produce debug info (experimental)\n-.IP \\[bu]\n-\\fBstatic\\fR - Use or produce static libraries or binaries (experimental)\n-.RE\n .TP\n \\fB\\-v\\fR, \\fB\\-\\-version\\fR\n Print version info and exit"}, {"sha": "fcb6a2b429021fe52b976c8f90cc6190dc3fb8ca", "filename": "mk/clean.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -20,10 +20,10 @@ CLEAN_STAGE_RULES =\t\t\t\t\t\t\t\t\\\n     clean$(stage)_T_$(target)_H_$(host))))\n \n CLEAN_LLVM_RULES = \t\t\t\t\t\t\t\t\\\n- $(foreach target, $(CFG_TARGET_TRIPLES),\t\t\\\n+ $(foreach target, $(CFG_HOST_TRIPLES),\t\t\\\n   clean-llvm$(target))\n \n-.PHONY: clean clean-all clean-misc\n+.PHONY: clean clean-all clean-misc clean-llvm\n \n clean-all: clean clean-llvm\n "}, {"sha": "cb5b3607fca87c1272aae151ab47ccaeb43b71d7", "filename": "mk/dist.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -57,7 +57,7 @@ LICENSE.txt: $(S)COPYRIGHT $(S)LICENSE-APACHE $(S)LICENSE-MIT\n \tcp $< $@\n \n $(PKG_EXE): rust.iss modpath.iss LICENSE.txt rust-logo.ico \\\n-            $(PKG_FILES) all rustc-stage3\n+            $(PKG_FILES) $(CSREQ3_T_$(CFG_BUILD_TRIPLE)_H_$(CFG_BUILD_TRIPLE))\n \t@$(call E, ISCC: $@)\n \t$(Q)\"$(CFG_ISCC)\" $<\n endif"}, {"sha": "f11a3d24b8d2559f0e3dba340e0a888c7c96ef41", "filename": "mk/docs.mk", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -99,6 +99,16 @@ doc/tutorial-macros.html: tutorial-macros.md doc/version_info.html \\\n \t   --include-before-body=doc/version_info.html \\\n            --output=$@\n \n+DOCS += doc/tutorial-container.html\n+doc/tutorial-container.html: tutorial-container.md doc/version_info.html doc/rust.css\n+\t@$(call E, pandoc: $@)\n+\t$(Q)$(CFG_NODE) $(S)doc/prep.js --highlight $< | \\\n+          $(CFG_PANDOC) --standalone --toc \\\n+           --section-divs --number-sections \\\n+           --from=markdown --to=html --css=rust.css \\\n+\t   --include-before-body=doc/version_info.html \\\n+           --output=$@\n+\n DOCS += doc/tutorial-ffi.html\n doc/tutorial-ffi.html: tutorial-ffi.md doc/version_info.html doc/rust.css\n \t@$(call E, pandoc: $@)"}, {"sha": "47ab7c867282cfe9f4115272766f4153aebb9252", "filename": "mk/target.mk", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -13,6 +13,15 @@\n # this exists can be found on issue #2400\n export CFG_COMPILER_TRIPLE\n \n+# The standard libraries should be held up to a higher standard than any old\n+# code, make sure that these common warnings are denied by default. These can\n+# be overridden during development temporarily. For stage0, we allow all these\n+# to suppress warnings which may be bugs in stage0 (should be fixed in stage1+)\n+# NOTE: add \"-A warnings\" after snapshot to WFLAGS_ST0\n+WFLAGS_ST0 = -A unrecognized-lint\n+WFLAGS_ST1 = -D warnings\n+WFLAGS_ST2 = -D warnings\n+\n # TARGET_STAGE_N template: This defines how target artifacts are built\n # for all stage/target architecture combinations. The arguments:\n # $(1) is the stage\n@@ -39,15 +48,15 @@ $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_STDLIB_$(2)): \\\n \t\t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n \t\t| $$(TLIB$(1)_T_$(2)_H_$(3))/\n \t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< && touch $$@\n+\t$$(STAGE$(1)_T_$(2)_H_$(3)) $$(WFLAGS_ST$(1)) -o $$@ $$< && touch $$@\n \n $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_EXTRALIB_$(2)): \\\n \t\t$$(EXTRALIB_CRATE) $$(EXTRALIB_INPUTS) \\\n \t        $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_STDLIB_$(2)) \\\n \t\t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n \t\t| $$(TLIB$(1)_T_$(2)_H_$(3))/\n \t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< && touch $$@\n+\t$$(STAGE$(1)_T_$(2)_H_$(3)) $$(WFLAGS_ST$(1)) -o $$@ $$< && touch $$@\n \n $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBSYNTAX_$(3)): \\\n                 $$(LIBSYNTAX_CRATE) $$(LIBSYNTAX_INPUTS) \\"}, {"sha": "35d567ef771bb2f75f328b2f82b1467d2165ab4d", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -122,9 +122,7 @@ CFG_ADB_TEST_DIR=/data/tmp\n $(info check: android device test dir $(CFG_ADB_TEST_DIR) ready \\\n  $(shell adb remount 1>/dev/null) \\\n  $(shell adb shell mkdir $(CFG_ADB_TEST_DIR) 1>/dev/null) \\\n- $(shell adb shell rm $(CFG_ADB_TEST_DIR)/*.so 1>/dev/null) \\\n- $(shell adb shell rm $(CFG_ADB_TEST_DIR)/*-arm-linux-androideabi 1>/dev/null) \\\n- $(shell adb shell rm $(CFG_ADB_TEST_DIR)/*-arm-linux-androideabi.* 1>/dev/null) \\\n+ $(shell adb shell rm -rf $(CFG_ADB_TEST_DIR)/* 1>/dev/null) \\\n  $(shell adb push $(S)src/etc/adb_run_wrapper.sh $(CFG_ADB_TEST_DIR) 1>/dev/null) \\\n  $(shell adb push $(CFG_ANDROID_CROSS_PATH)/arm-linux-androideabi/lib/armv7-a/libgnustl_shared.so \\\n                   $(CFG_ADB_TEST_DIR) 1>/dev/null) \\"}, {"sha": "0a901358ac1f07f91ee42a3d6859fe7721d634d7", "filename": "mk/tools.mk", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/mk%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/mk%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftools.mk?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -12,23 +12,23 @@\n # and host architectures\n \n # The test runner that runs the cfail/rfail/rpass and bxench tests\n-COMPILETEST_CRATE := $(S)src/compiletest/compiletest.rc\n-COMPILETEST_INPUTS := $(wildcard $(S)src/compiletest/*rs)\n+COMPILETEST_CRATE := $(S)src/compiletest/compiletest.rs\n+COMPILETEST_INPUTS := $(wildcard $(S)src/compiletest/*.rs)\n \n # Rustpkg, the package manager and build system\n-RUSTPKG_LIB := $(S)src/librustpkg/rustpkg.rc\n-RUSTPKG_INPUTS := $(wildcard $(S)src/librustpkg/*rs)\n+RUSTPKG_LIB := $(S)src/librustpkg/rustpkg.rs\n+RUSTPKG_INPUTS := $(wildcard $(S)src/librustpkg/*.rs)\n \n # Rustdoc, the documentation tool\n-RUSTDOC_LIB := $(S)src/librustdoc/rustdoc.rc\n+RUSTDOC_LIB := $(S)src/librustdoc/rustdoc.rs\n RUSTDOC_INPUTS := $(wildcard $(S)src/librustdoc/*.rs)\n \n # Rusti, the JIT REPL\n-RUSTI_LIB := $(S)src/librusti/rusti.rc\n+RUSTI_LIB := $(S)src/librusti/rusti.rs\n RUSTI_INPUTS := $(wildcard $(S)src/librusti/*.rs)\n \n # Rust, the convenience tool\n-RUST_LIB := $(S)src/librust/rust.rc\n+RUST_LIB := $(S)src/librust/rust.rs\n RUST_INPUTS := $(wildcard $(S)src/librust/*.rs)\n \n # FIXME: These are only built for the host arch. Eventually we'll\n@@ -191,7 +191,8 @@ $(foreach host,$(CFG_HOST_TRIPLES),\t\t\t\t\\\n $(foreach target,$(CFG_TARGET_TRIPLES),\t\t\t\t\\\n  $(eval $(call TOOLS_STAGE_N_TARGET,0,1,$(host),$(target)))\t\\\n  $(eval $(call TOOLS_STAGE_N_TARGET,1,2,$(host),$(target)))\t\\\n- $(eval $(call TOOLS_STAGE_N_TARGET,2,3,$(host),$(target)))))\n+ $(eval $(call TOOLS_STAGE_N_TARGET,2,3,$(host),$(target)))\t\\\n+ $(eval $(call TOOLS_STAGE_N_TARGET,3,bogus,$(host),$(target)))))\n \n $(foreach host,$(CFG_HOST_TRIPLES),\t\t\t\t\\\n  $(eval $(call TOOLS_STAGE_N_HOST,0,1,$(host),$(host)))\t\\"}, {"sha": "82206f12fae2e2b47b5adbf45c3f894876823d3a", "filename": "src/compiletest/compiletest.rs", "status": "renamed", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -15,8 +15,8 @@\n #[no_core]; // XXX: Remove after snapshot\n #[no_std];\n \n-extern mod core(name = \"std\", vers = \"0.7-pre\");\n-extern mod extra(name = \"extra\", vers = \"0.7-pre\");\n+extern mod core(name = \"std\", vers = \"0.7\");\n+extern mod extra(name = \"extra\", vers = \"0.7\");\n \n use core::prelude::*;\n use core::*;\n@@ -75,7 +75,7 @@ pub fn parse_config(args: ~[~str]) -> config {\n          ];\n \n     assert!(!args.is_empty());\n-    let args_ = vec::tail(args);\n+    let args_ = args.tail();\n     let matches =\n         &match getopts::getopts(args_, opts) {\n           Ok(m) => m,\n@@ -208,7 +208,8 @@ pub fn make_tests(config: &config) -> ~[test::TestDescAndFn] {\n     debug!(\"making tests from %s\",\n            config.src_base.to_str());\n     let mut tests = ~[];\n-    for os::list_dir_path(&config.src_base).each |file| {\n+    let dirs = os::list_dir_path(&config.src_base);\n+    for dirs.iter().advance |file| {\n         let file = copy *file;\n         debug!(\"inspecting file %s\", file.to_str());\n         if is_test(config, file) {\n@@ -230,11 +231,11 @@ pub fn is_test(config: &config, testfile: &Path) -> bool {\n \n     let mut valid = false;\n \n-    for valid_extensions.each |ext| {\n+    for valid_extensions.iter().advance |ext| {\n         if name.ends_with(*ext) { valid = true; }\n     }\n \n-    for invalid_prefixes.each |pre| {\n+    for invalid_prefixes.iter().advance |pre| {\n         if name.starts_with(*pre) { valid = false; }\n     }\n \n@@ -253,9 +254,17 @@ pub fn make_test(config: &config, testfile: &Path) -> test::TestDescAndFn {\n }\n \n pub fn make_test_name(config: &config, testfile: &Path) -> test::TestName {\n+\n+    // Try to elide redundant long paths\n+    fn shorten(path: &Path) -> ~str {\n+        let filename = path.filename();\n+        let dir = path.pop().filename();\n+        fmt!(\"%s/%s\", dir.get_or_default(~\"\"), filename.get_or_default(~\"\"))\n+    }\n+\n     test::DynTestName(fmt!(\"[%s] %s\",\n                            mode_str(config.mode),\n-                           testfile.to_str()))\n+                           shorten(testfile)))\n }\n \n pub fn make_test_closure(config: &config, testfile: &Path) -> test::TestFn {", "previous_filename": "src/compiletest/compiletest.rc"}, {"sha": "4649d4dfc3c4b913f1f7f38f5cea63e82bd0a8db", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -21,7 +21,7 @@ pub fn load_errors(testfile: &Path) -> ~[ExpectedError] {\n     let mut line_num = 1u;\n     while !rdr.eof() {\n         let ln = rdr.read_line();\n-        error_patterns += parse_expected(line_num, ln);\n+        error_patterns.push_all_move(parse_expected(line_num, ln));\n         line_num += 1u;\n     }\n     return error_patterns;"}, {"sha": "715f6d91e09dd7e36cf58970729757c2cb0fffa2", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -226,8 +226,8 @@ actual:\\n\\\n                          ~\"-L\", config.build_base.to_str(),\n                          ~\"-L\",\n                          aux_output_dir_name(config, testfile).to_str()];\n-        args += split_maybe_args(&config.rustcflags);\n-        args += split_maybe_args(&props.compile_flags);\n+        args.push_all_move(split_maybe_args(&config.rustcflags));\n+        args.push_all_move(split_maybe_args(&props.compile_flags));\n         return ProcArgs {prog: config.rustc_path.to_str(), args: args};\n     }\n }\n@@ -321,13 +321,12 @@ fn check_error_patterns(props: &TestProps,\n     if done { return; }\n \n     let missing_patterns =\n-        vec::slice(props.error_patterns, next_err_idx,\n-                   props.error_patterns.len());\n+        props.error_patterns.slice(next_err_idx, props.error_patterns.len());\n     if missing_patterns.len() == 1u {\n         fatal_ProcRes(fmt!(\"error pattern '%s' not found!\",\n                            missing_patterns[0]), ProcRes);\n     } else {\n-        for missing_patterns.each |pattern| {\n+        for missing_patterns.iter().advance |pattern| {\n             error(fmt!(\"error pattern '%s' not found!\", *pattern));\n         }\n         fatal_ProcRes(~\"multiple error patterns not found\", ProcRes);\n@@ -346,9 +345,9 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n         fatal(~\"process did not return an error status\");\n     }\n \n-    let prefixes = vec::map(expected_errors, |ee| {\n+    let prefixes = expected_errors.iter().transform(|ee| {\n         fmt!(\"%s:%u:\", testfile.to_str(), ee.line)\n-    });\n+    }).collect::<~[~str]>();\n \n     // Scan and extract our error/warning messages,\n     // which look like:\n@@ -358,7 +357,7 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n     // is the ending point, and * represents ANSI color codes.\n     for ProcRes.stderr.line_iter().advance |line| {\n         let mut was_expected = false;\n-        for vec::eachi(expected_errors) |i, ee| {\n+        for expected_errors.iter().enumerate().advance |(i, ee)| {\n             if !found_flags[i] {\n                 debug!(\"prefix=%s ee.kind=%s ee.msg=%s line=%s\",\n                        prefixes[i], ee.kind, ee.msg, line);\n@@ -529,7 +528,7 @@ fn compose_and_run_compiler(\n     let extra_link_args = ~[~\"-L\",\n                             aux_output_dir_name(config, testfile).to_str()];\n \n-    for vec::each(props.aux_builds) |rel_ab| {\n+    for props.aux_builds.iter().advance |rel_ab| {\n         let abs_ab = config.aux_base.push_rel(&Path(*rel_ab));\n         let aux_args =\n             make_compile_args(config, props, ~[~\"--lib\"] + extra_link_args,\n@@ -582,8 +581,8 @@ fn make_compile_args(config: &config, props: &TestProps, extras: ~[~str],\n                      ~\"-o\", xform(config, testfile).to_str(),\n                      ~\"-L\", config.build_base.to_str()]\n         + extras;\n-    args += split_maybe_args(&config.rustcflags);\n-    args += split_maybe_args(&props.compile_flags);\n+    args.push_all_move(split_maybe_args(&config.rustcflags));\n+    args.push_all_move(split_maybe_args(&props.compile_flags));\n     return ProcArgs {prog: config.rustc_path.to_str(), args: args};\n }\n \n@@ -757,7 +756,7 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n     runargs.push(fmt!(\"%s\", config.adb_test_dir));\n     runargs.push(fmt!(\"%s\", prog_short));\n \n-    for args.args.each |tv| {\n+    for args.args.iter().advance |tv| {\n         runargs.push(tv.to_owned());\n     }\n \n@@ -822,7 +821,8 @@ fn _dummy_exec_compiled_test(config: &config, props: &TestProps,\n fn _arm_push_aux_shared_library(config: &config, testfile: &Path) {\n     let tstr = aux_output_dir_name(config, testfile).to_str();\n \n-    for os::list_dir_path(&Path(tstr)).each |file| {\n+    let dirs = os::list_dir_path(&Path(tstr));\n+    for dirs.iter().advance |file| {\n \n         if (file.filetype() == Some(~\".so\")) {\n "}, {"sha": "0f61ede4fc59d4ff467e0917ee82707a306f633c", "filename": "src/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fdriver.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -11,7 +11,7 @@\n #[no_core];\n #[no_std];\n \n-extern mod core(name = \"std\", vers = \"0.7-pre\");\n+extern mod core(name = \"std\", vers = \"0.7\");\n \n #[cfg(rustpkg)]\n extern mod this(name = \"rustpkg\");"}, {"sha": "7cbcf94dd409acd938357a58d59e720678316e8b", "filename": "src/etc/adb_run_wrapper.sh", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Fetc%2Fadb_run_wrapper.sh", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Fetc%2Fadb_run_wrapper.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fadb_run_wrapper.sh?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -17,16 +17,17 @@ then\n \n         L_RET=1\n         L_COUNT=0\n+        cd $PATH\n         while [ $L_RET -eq 1 ]\n         do\n-            LD_LIBRARY_PATH=$PATH $PATH/$RUN $@ 1>$PATH/$RUN.stdout 2>$PATH/$RUN.stderr\n+            TEST_EXEC_ENV=22 LD_LIBRARY_PATH=$PATH $PATH/$RUN $@ 1>$PATH/$RUN.stdout 2>$PATH/$RUN.stderr\n             L_RET=$?\n             if [ $L_COUNT -gt 0 ]\n             then\n                /system/bin/sleep $WAIT\n                /system/bin/sync\n             fi\n-            L_COUNT=`expr $L_COUNT+1`\n+            L_COUNT=$((L_COUNT+1))\n         done\n \n         echo $L_RET > $PATH/$RUN.exitcode"}, {"sha": "36031d31149a9fd47591379dc6b7252449104166", "filename": "src/etc/combine-tests.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Fetc%2Fcombine-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Fetc%2Fcombine-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcombine-tests.py?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -60,7 +60,7 @@ def scrub(b):\n for t in stage2_tests:\n     p = os.path.join(\"test\", \"run-pass\", t)\n     p = p.replace(\"\\\\\", \"\\\\\\\\\")\n-    d.write(\"    out.write_str(~\\\"run-pass [stage2]: %s\\\\n\\\");\\n\" % p)\n+    d.write(\"    out.write_str(\\\"run-pass [stage2]: %s\\\\n\\\");\\n\" % p)\n     d.write(\"    t_%d::main();\\n\" % i)\n     i += 1\n d.write(\"}\\n\")"}, {"sha": "5c2f4f82566b0c90ce01f5c865635b146ab457b3", "filename": "src/etc/ctags.rust", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Fetc%2Fctags.rust", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Fetc%2Fctags.rust", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fctags.rust?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -8,3 +8,4 @@\n --regex-rust=/[ \\t]*static[ \\t]+([a-zA-Z0-9_]+)/\\1/m,consts/\n --regex-rust=/[ \\t]*trait[ \\t]+([a-zA-Z0-9_]+)/\\1/m,traits/\n --regex-rust=/[ \\t]*impl[ \\t]+([a-zA-Z0-9_]+)/\\1/m,impls/\n+--regex-rust=/[ \\t]*macro_rules![ \\t]+([a-zA-Z0-9_]+)/\\1/m,macros/"}, {"sha": "63f1e50fcaf6a6746b76911f413afa77391500a0", "filename": "src/etc/kate/rust.xml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Fetc%2Fkate%2Frust.xml", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Fetc%2Fkate%2Frust.xml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fkate%2Frust.xml?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -7,7 +7,7 @@\n \t<!ENTITY rustIdent \"[a-zA-Z_][a-zA-Z_0-9]*\">\n \t<!ENTITY rustIntSuf \"([iu](8|16|32|64)?)?\">\n ]>\n-<language name=\"Rust\" version=\"0.7-pre\" kateversion=\"2.4\" section=\"Sources\" extensions=\"*.rs;*.rc\" mimetype=\"text/x-rust\" priority=\"15\">\n+<language name=\"Rust\" version=\"0.7\" kateversion=\"2.4\" section=\"Sources\" extensions=\"*.rs;*.rc\" mimetype=\"text/x-rust\" priority=\"15\">\n <highlighting>\n \t<list name=\"fn\">\n \t\t<item> fn </item>"}, {"sha": "0375a041a39e97ab9a009b35fced5d015b0fd3e3", "filename": "src/etc/pkg/rust.iss", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Fetc%2Fpkg%2Frust.iss", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Fetc%2Fpkg%2Frust.iss", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fpkg%2Frust.iss?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -1,4 +1,5 @@\n #define CFG_VERSION GetEnv(\"CFG_VERSION\")\n+#define CFG_VERSION_WIN GetEnv(\"CFG_VERSION_WIN\")\n \n [Setup]\n \n@@ -8,7 +9,7 @@ AppVersion={#CFG_VERSION}\n AppCopyright=Copyright (C) 2006-2013 Mozilla Foundation, MIT license\n AppPublisher=Mozilla Foundation\n AppPublisherURL=http://www.rust-lang.org\n-VersionInfoVersion={#CFG_VERSION}\n+VersionInfoVersion={#CFG_VERSION_WIN}\n LicenseFile=LICENSE.txt\n \n DisableWelcomePage=true"}, {"sha": "2a252f3f1f39486ce8c48d3a72ab06799ea029e1", "filename": "src/etc/unicode.py", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -122,14 +122,14 @@ def ch_prefix(ix):\n \n def emit_bsearch_range_table(f):\n     f.write(\"\"\"\n-    pure fn bsearch_range_table(c: char, r: &[(char,char)]) -> bool {\n-        use cmp::{EQ, LT, GT};\n-        use vec::bsearch;\n+    fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n+        use cmp::{Equal, Less, Greater};\n+        use vec::ImmutableVector;\n         use option::None;\n-        (do bsearch(r) |&(lo,hi)| {\n-            if lo <= c && c <= hi { EQ }\n-            else if hi < c { LT }\n-            else { GT }\n+        (do r.bsearch |&(lo,hi)| {\n+            if lo <= c && c <= hi { Equal }\n+            else if hi < c { Less }\n+            else { Greater }\n         }) != None\n     }\\n\\n\n \"\"\");\n@@ -140,15 +140,15 @@ def emit_property_module(f, mod, tbl):\n     keys.sort()\n     emit_bsearch_range_table(f);\n     for cat in keys:\n-        f.write(\"    const %s_table : &[(char,char)] = &[\\n\" % cat)\n+        f.write(\"    static %s_table : &'static [(char,char)] = &[\\n\" % cat)\n         ix = 0\n         for pair in tbl[cat]:\n             f.write(ch_prefix(ix))\n             f.write(\"(%s, %s)\" % (escape_char(pair[0]), escape_char(pair[1])))\n             ix += 1\n         f.write(\"\\n    ];\\n\\n\")\n \n-        f.write(\"    pub pure fn %s(c: char) -> bool {\\n\" % cat)\n+        f.write(\"    pub fn %s(c: char) -> bool {\\n\" % cat)\n         f.write(\"        bsearch_range_table(c, %s_table)\\n\" % cat)\n         f.write(\"    }\\n\\n\")\n     f.write(\"}\\n\")\n@@ -159,7 +159,7 @@ def emit_property_module_old(f, mod, tbl):\n     keys = tbl.keys()\n     keys.sort()\n     for cat in keys:\n-        f.write(\"    pure fn %s(c: char) -> bool {\\n\" % cat)\n+        f.write(\"    fn %s(c: char) -> bool {\\n\" % cat)\n         f.write(\"        ret alt c {\\n\")\n         prefix = ' '\n         for pair in tbl[cat]:\n@@ -236,8 +236,22 @@ def emit_decomp_module(f, canon, compat):\n \n (canon_decomp, compat_decomp, gencats) = load_unicode_data(\"UnicodeData.txt\")\n \n-# Explain that the source code was generated by this script.\n-rf.write('// The following code was generated by \"src/etc/unicode.py\"\\n\\n')\n+# Preamble\n+rf.write('''// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// The following code was generated by \"src/etc/unicode.py\"\n+\n+#[allow(missing_doc)];\n+\n+''')\n \n emit_property_module(rf, \"general_category\", gencats)\n "}, {"sha": "25e44c62a8a750db4b3e082e45d9b22af47ecb75", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -2,7 +2,7 @@\n \" Language:     Rust\n \" Maintainer:   Patrick Walton <pcwalton@mozilla.com>\n \" Maintainer:   Ben Blum <bblum@cs.cmu.edu>\n-\" Last Change:  2012 Dec 25\n+\" Last Change:  2013 Jun 14\n \n if version < 600\n   syntax clear\n@@ -13,13 +13,16 @@ endif\n syn keyword   rustConditional match if else\n syn keyword   rustOperator    as\n \n-syn keyword   rustKeyword     break copy do drop extern\n+syn match     rustAssert      \"\\<assert\\(\\w\\)*!\"\n+syn match     rustFail        \"\\<fail\\(\\w\\)*!\"\n+syn keyword   rustKeyword     break copy do extern\n syn keyword   rustKeyword     for if impl let log\n syn keyword   rustKeyword     copy do extern\n syn keyword   rustKeyword     for impl let log\n syn keyword   rustKeyword     loop mod once priv pub\n syn keyword   rustKeyword     return\n-syn keyword   rustKeyword     unsafe use while\n+syn keyword   rustKeyword     unsafe while\n+syn keyword   rustKeyword     use nextgroup=rustModPath skipwhite\n \" FIXME: Scoped impl's name is also fallen in this category\n syn keyword   rustKeyword     mod trait struct enum type nextgroup=rustIdentifier skipwhite\n syn keyword   rustKeyword     fn nextgroup=rustFuncName skipwhite\n@@ -45,7 +48,8 @@ syn keyword   rustType        c_longlong c_ulonglong intptr_t uintptr_t\n syn keyword   rustType        off_t dev_t ino_t pid_t mode_t ssize_t\n \n syn keyword   rustTrait       Const Copy Send Owned Sized \" inherent traits\n-syn keyword   rustTrait       Eq Ord Num Ptr\n+syn keyword   rustTrait       Clone Decodable Encodable IterBytes Rand ToStr\n+syn keyword   rustTrait       Eq Ord TotalEq TotalOrd Num Ptr\n syn keyword   rustTrait       Drop Add Sub Mul Quot Rem Neg BitAnd BitOr\n syn keyword   rustTrait       BitXor Shl Shr Index\n \n@@ -72,19 +76,21 @@ syn keyword   rustConstant    STDIN_FILENO STDOUT_FILENO STDERR_FILENO\n \" If foo::bar changes to foo.bar, change this (\"::\" to \"\\.\").\n \" If foo::bar changes to Foo::bar, change this (first \"\\w\" to \"\\u\").\n syn match     rustModPath     \"\\w\\(\\w\\)*::[^<]\"he=e-3,me=e-3\n+syn match     rustModPath     \"\\w\\(\\w\\)*\" contained \" only for 'use path;'\n syn match     rustModPathSep  \"::\"\n \n syn match     rustFuncCall    \"\\w\\(\\w\\)*(\"he=e-1,me=e-1\n syn match     rustFuncCall    \"\\w\\(\\w\\)*::<\"he=e-3,me=e-3 \" foo::<T>();\n \n-syn match     rustMacro       '\\w\\(\\w\\)*!'\n-syn match     rustMacro       '#\\w\\(\\w\\)*'\n+syn match     rustMacro       '\\w\\(\\w\\)*!' contains=rustAssert,rustFail\n+syn match     rustMacro       '#\\w\\(\\w\\)*' contains=rustAssert,rustFail\n \n syn match     rustFormat      display \"%\\(\\d\\+\\$\\)\\=[-+' #0*]*\\(\\d*\\|\\*\\|\\*\\d\\+\\$\\)\\(\\.\\(\\d*\\|\\*\\|\\*\\d\\+\\$\\)\\)\\=\\([hlLjzt]\\|ll\\|hh\\)\\=\\([aAbdiuoxXDOUfFeEgGcCsSpn?]\\|\\[\\^\\=.[^]]*\\]\\)\" contained\n syn match     rustFormat      display \"%%\" contained\n syn region    rustString      start=+L\\=\"+ skip=+\\\\\\\\\\|\\\\\"+ end=+\"+ contains=rustTodo,rustFormat\n \n-syn region    rustAttribute   start=\"#\\[\" end=\"\\]\" contains=rustString\n+syn region    rustAttribute   start=\"#\\[\" end=\"\\]\" contains=rustString,rustDeriving\n+syn region    rustDeriving    start=\"deriving(\" end=\")\" contains=rustTrait\n \n \" Number literals\n syn match     rustNumber      display \"\\<[0-9][0-9_]*\\>\"\n@@ -137,17 +143,24 @@ hi def link rustConditional   Conditional\n hi def link rustIdentifier    Identifier\n hi def link rustModPath       Include\n hi def link rustFuncName      Function\n+hi def link rustFuncCall      Function\n hi def link rustCommentDoc    SpecialComment\n hi def link rustComment       Comment\n hi def link rustMacro         Macro\n hi def link rustType          Type\n hi def link rustTodo          Todo\n hi def link rustAttribute     PreProc\n+hi def link rustDeriving      PreProc\n hi def link rustStorage       StorageClass\n hi def link rustLifetime      Special\n \n \" Other Suggestions:\n+\" hi rustAttribute ctermfg=cyan\n+\" hi rustDeriving ctermfg=cyan\n+\" hi rustAssert ctermfg=yellow\n+\" hi rustFail ctermfg=red\n \" hi rustMacro ctermfg=magenta\n+\" hi rustModPathSep ctermfg=grey\n \n syn sync minlines=200\n syn sync maxlines=500"}, {"sha": "86dcbab93fde6afe107fde940c67507baa481208", "filename": "src/etc/zsh/_rust", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Fetc%2Fzsh%2F_rust", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Fetc%2Fzsh%2F_rust", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fzsh%2F_rust?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -29,36 +29,30 @@ _rustc_opts_switches=(\n     --target'[Target triple cpu-manufacturer-kernel\\[-os\\] to compile]'\n     --target-feature'[Target specific attributes (llc -mattr=help for detail)]'\n     --android-cross-path'[The path to the Android NDK]'\n-    {-W,--warn}'[Set lint warnings]'\n-    {-A,--allow}'[Set lint allowed]'\n-    {-D,--deny}'[Set lint denied]'\n-    {-F,--forbid}'[Set lint forbidden]'\n-    -Z'[Set internal debugging options]'\n     {-v,--version}'[Print version info and exit]'\n )\n-\n _rustc_opts_lint=(\n-    'path-statement:path statements with no effect'\n-    'deprecated-pattern:warn about deprecated uses of pattern bindings'\n-    'non-implicitly-copyable-typarams:passing non implicitly copyable types as copy type params'\n-    'missing-trait-doc:detects missing documentation for traits'\n-    'missing-struct-doc:detects missing documentation for structs'\n-    'ctypes:proper use of core::libc types in foreign modules'\n-    'implicit-copies:implicit copies of non implicitly copyable data'\n-    \"unused-mut:detect mut variables which don't need to be mutable\"\n-    'unused-imports:imports that are never used'\n-    'heap-memory:use of any (~ type or @ type) heap memory'\n-    'default-methods:allow default methods'\n-    'unused-variable:detect variables which are not used in any way'\n-    'dead-assignment:detect assignments that will never be read'\n-    'unrecognized-lint:unrecognized lint attribute'\n-    'type-limits:comparisons made useless by limits of the types involved'\n-    'unused-unsafe:unnecessary use of an `unsafe` block'\n-    'while-true:suggest using loop { } instead of while(true) { }'\n-    'non-camel-case-types:types, variants and traits should have camel case names'\n-    'managed-heap-memory:use of managed (@ type) heap memory'\n-    'unnecessary-allocation:detects unnecessary allocations that can be eliminated'\n-    'owned-heap-memory:use of owned (~ type) heap memory'\n+    'path-statement[path statements with no effect]'\n+    'deprecated-pattern[warn about deprecated uses of pattern bindings]'\n+    'non-implicitly-copyable-typarams[passing non implicitly copyable types as copy type params]'\n+    'missing-trait-doc[detects missing documentation for traits]'\n+    'missing-struct-doc[detects missing documentation for structs]'\n+    'ctypes[proper use of core::libc types in foreign modules]'\n+    'implicit-copies[implicit copies of non implicitly copyable data]'\n+    \"unused-mut[detect mut variables which don't need to be mutable]\"\n+    'unused-imports[imports that are never used]'\n+    'heap-memory[use of any (~ type or @ type) heap memory]'\n+    'default-methods[allow default methods]'\n+    'unused-variable[detect variables which are not used in any way]'\n+    'dead-assignment[detect assignments that will never be read]'\n+    'unrecognized-lint[unrecognized lint attribute]'\n+    'type-limits[comparisons made useless by limits of the types involved]'\n+    'unused-unsafe[unnecessary use of an `unsafe` block]'\n+    'while-true[suggest using loop { } instead of while(true) { }]'\n+    'non-camel-case-types[types, variants and traits should have camel case names]'\n+    'managed-heap-memory[use of managed (@ type) heap memory]'\n+    'unnecessary-allocation[detects unnecessary allocations that can be eliminated]'\n+    'owned-heap-memory[use of owned (~ type) heap memory]'\n )\n \n _rustc_opts_debug=(\n@@ -90,13 +84,20 @@ _rustc_opts_debug=(\n     'lint-llvm:Run the LLVM lint pass on the pre-optimization IR'\n )\n \n-_rustc() {\n-    case $words[2] in\n-        -[WADF]) _describe 'options' _rustc_opts_lint ;;\n-        -Z) _describe 'options' _rustc_opts_debug ;;\n-        -)  _arguments -s -w : \"$_rustc_opts_switches[@]\" ;;\n-        *) _files -g \"*.rs\" ;;\n-  esac\n+_rustc_opts_fun_lint(){\n+    _values -s , 'options' \\\n+        \"$_rustc_opts_lint[@]\"\n+}\n+\n+_rustc_opts_fun_debug(){\n+    _describe 'options' _rustc_opts_debug\n }\n \n-_rustc \"$@\"\n+_arguments -s :  \\\n+    '(-W --warn)'{-W,--warn}'[Set lint warnings]:lint options:_rustc_opts_fun_lint' \\\n+    '(-A --allow)'{-A,--allow}'[Set lint allowed]:lint options:_rustc_opts_fun_lint' \\\n+    '(-D --deny)'{-D,--deny}'[Set lint denied]:lint options:_rustc_opts_fun_lint' \\\n+    '(-F --forbid)'{-F,--forbid}'[Set lint forbidden]:lint options:_rustc_opts_fun_lint' \\\n+    '*-Z[Set internal debugging options]:debug options:_rustc_opts_fun_debug' \\\n+    \"$_rustc_opts_switches[@]\" \\\n+    '*::files:_files -g \"*.rs\"'"}, {"sha": "be9ab863942b1292b02dbd4e401eb66ae55999c8", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -19,7 +19,7 @@\n  *\n  * ~~~ {.rust}\n  * extern mod std;\n- * use std::arc;\n+ * use extra::arc;\n  * let numbers=vec::from_fn(100, |ind| (ind as float)*rand::random());\n  * let shared_numbers=arc::ARC(numbers);\n  *\n@@ -39,15 +39,14 @@\n \n #[allow(missing_doc)];\n \n-use core::prelude::*;\n \n use sync;\n use sync::{Mutex, mutex_with_condvars, RWlock, rwlock_with_condvars};\n \n-use core::cast;\n-use core::unstable::sync::UnsafeAtomicRcBox;\n-use core::task;\n-use core::borrow;\n+use std::cast;\n+use std::unstable::sync::UnsafeAtomicRcBox;\n+use std::task;\n+use std::borrow;\n \n /// As sync::condvar, a mechanism for unlock-and-descheduling and signaling.\n pub struct Condvar<'self> {\n@@ -112,15 +111,15 @@ impl<'self> Condvar<'self> {\n pub struct ARC<T> { x: UnsafeAtomicRcBox<T> }\n \n /// Create an atomically reference counted wrapper.\n-pub fn ARC<T:Const + Owned>(data: T) -> ARC<T> {\n+pub fn ARC<T:Freeze + Send>(data: T) -> ARC<T> {\n     ARC { x: UnsafeAtomicRcBox::new(data) }\n }\n \n /**\n  * Access the underlying data in an atomically reference counted\n  * wrapper.\n  */\n-impl<T:Const+Owned> ARC<T> {\n+impl<T:Freeze+Send> ARC<T> {\n     pub fn get<'a>(&'a self) -> &'a T {\n         unsafe { &*self.x.get_immut() }\n     }\n@@ -133,7 +132,7 @@ impl<T:Const+Owned> ARC<T> {\n  * object. However, one of the `arc` objects can be sent to another task,\n  * allowing them to share the underlying data.\n  */\n-impl<T:Const + Owned> Clone for ARC<T> {\n+impl<T:Freeze + Send> Clone for ARC<T> {\n     fn clone(&self) -> ARC<T> {\n         ARC { x: self.x.clone() }\n     }\n@@ -149,22 +148,22 @@ struct MutexARCInner<T> { lock: Mutex, failed: bool, data: T }\n struct MutexARC<T> { x: UnsafeAtomicRcBox<MutexARCInner<T>> }\n \n /// Create a mutex-protected ARC with the supplied data.\n-pub fn MutexARC<T:Owned>(user_data: T) -> MutexARC<T> {\n+pub fn MutexARC<T:Send>(user_data: T) -> MutexARC<T> {\n     mutex_arc_with_condvars(user_data, 1)\n }\n /**\n  * Create a mutex-protected ARC with the supplied data and a specified number\n  * of condvars (as sync::mutex_with_condvars).\n  */\n-pub fn mutex_arc_with_condvars<T:Owned>(user_data: T,\n+pub fn mutex_arc_with_condvars<T:Send>(user_data: T,\n                                     num_condvars: uint) -> MutexARC<T> {\n     let data =\n         MutexARCInner { lock: mutex_with_condvars(num_condvars),\n                           failed: false, data: user_data };\n     MutexARC { x: UnsafeAtomicRcBox::new(data) }\n }\n \n-impl<T:Owned> Clone for MutexARC<T> {\n+impl<T:Send> Clone for MutexARC<T> {\n     /// Duplicate a mutex-protected ARC, as arc::clone.\n     fn clone(&self) -> MutexARC<T> {\n         // NB: Cloning the underlying mutex is not necessary. Its reference\n@@ -173,7 +172,7 @@ impl<T:Owned> Clone for MutexARC<T> {\n     }\n }\n \n-impl<T:Owned> MutexARC<T> {\n+impl<T:Send> MutexARC<T> {\n \n     /**\n      * Access the underlying mutable data with mutual exclusion from other\n@@ -247,7 +246,7 @@ struct PoisonOnFail {\n }\n \n impl Drop for PoisonOnFail {\n-    fn finalize(&self) {\n+    fn drop(&self) {\n         unsafe {\n             /* assert!(!*self.failed);\n                -- might be false in case of cond.wait() */\n@@ -276,20 +275,21 @@ struct RWARCInner<T> { lock: RWlock, failed: bool, data: T }\n  *\n  * Unlike mutex_arcs, rw_arcs are safe, because they cannot be nested.\n  */\n-#[mutable]\n+#[mutable] // XXX remove after snap\n+#[no_freeze]\n struct RWARC<T> {\n     x: UnsafeAtomicRcBox<RWARCInner<T>>,\n }\n \n /// Create a reader/writer ARC with the supplied data.\n-pub fn RWARC<T:Const + Owned>(user_data: T) -> RWARC<T> {\n+pub fn RWARC<T:Freeze + Send>(user_data: T) -> RWARC<T> {\n     rw_arc_with_condvars(user_data, 1)\n }\n /**\n  * Create a reader/writer ARC with the supplied data and a specified number\n  * of condvars (as sync::rwlock_with_condvars).\n  */\n-pub fn rw_arc_with_condvars<T:Const + Owned>(\n+pub fn rw_arc_with_condvars<T:Freeze + Send>(\n     user_data: T,\n     num_condvars: uint) -> RWARC<T>\n {\n@@ -299,7 +299,7 @@ pub fn rw_arc_with_condvars<T:Const + Owned>(\n     RWARC { x: UnsafeAtomicRcBox::new(data), }\n }\n \n-impl<T:Const + Owned> RWARC<T> {\n+impl<T:Freeze + Send> RWARC<T> {\n     /// Duplicate a rwlock-protected ARC, as arc::clone.\n     pub fn clone(&self) -> RWARC<T> {\n         RWARC {\n@@ -309,7 +309,7 @@ impl<T:Const + Owned> RWARC<T> {\n \n }\n \n-impl<T:Const + Owned> RWARC<T> {\n+impl<T:Freeze + Send> RWARC<T> {\n     /**\n      * Access the underlying data mutably. Locks the rwlock in write mode;\n      * other readers and writers will block.\n@@ -435,8 +435,8 @@ impl<T:Const + Owned> RWARC<T> {\n // lock it. This wraps the unsafety, with the justification that the 'lock'\n // field is never overwritten; only 'failed' and 'data'.\n #[doc(hidden)]\n-fn borrow_rwlock<T:Const + Owned>(state: *const RWARCInner<T>) -> *RWlock {\n-    unsafe { cast::transmute(&const (*state).lock) }\n+fn borrow_rwlock<T:Freeze + Send>(state: *mut RWARCInner<T>) -> *RWlock {\n+    unsafe { cast::transmute(&(*state).lock) }\n }\n \n /// The \"write permission\" token used for RWARC.write_downgrade().\n@@ -452,7 +452,7 @@ pub struct RWReadMode<'self, T> {\n     token: sync::RWlockReadMode<'self>,\n }\n \n-impl<'self, T:Const + Owned> RWWriteMode<'self, T> {\n+impl<'self, T:Freeze + Send> RWWriteMode<'self, T> {\n     /// Access the pre-downgrade RWARC in write mode.\n     pub fn write<U>(&mut self, blk: &fn(x: &mut T) -> U) -> U {\n         match *self {\n@@ -493,7 +493,7 @@ impl<'self, T:Const + Owned> RWWriteMode<'self, T> {\n     }\n }\n \n-impl<'self, T:Const + Owned> RWReadMode<'self, T> {\n+impl<'self, T:Freeze + Send> RWReadMode<'self, T> {\n     /// Access the post-downgrade rwlock in read mode.\n     pub fn read<U>(&self, blk: &fn(x: &T) -> U) -> U {\n         match *self {\n@@ -513,13 +513,13 @@ impl<'self, T:Const + Owned> RWReadMode<'self, T> {\n \n #[cfg(test)]\n mod tests {\n-    use core::prelude::*;\n \n     use arc::*;\n \n-    use core::cell::Cell;\n-    use core::comm;\n-    use core::task;\n+    use std::cell::Cell;\n+    use std::comm;\n+    use std::task;\n+    use std::uint;\n \n     #[test]\n     fn manually_share_arc() {\n@@ -725,7 +725,7 @@ mod tests {\n         }\n \n         // Wait for children to pass their asserts\n-        for children.each |r| {\n+        for children.iter().advance |r| {\n             r.recv();\n         }\n \n@@ -789,18 +789,20 @@ mod tests {\n                 }\n                 assert_eq!(*state, 42);\n                 *state = 31337;\n+                // FIXME: #7372: hits type inference bug with iterators\n                 // send to other readers\n-                for reader_convos.each |x| {\n-                    match *x {\n+                for uint::range(0, reader_convos.len()) |i| {\n+                    match reader_convos[i] {\n                         (ref rc, _) => rc.send(()),\n                     }\n                 }\n             }\n             let read_mode = arc.downgrade(write_mode);\n             do (&read_mode).read |state| {\n+                // FIXME: #7372: hits type inference bug with iterators\n                 // complete handshake with other readers\n-                for reader_convos.each |x| {\n-                    match *x {\n+                for uint::range(0, reader_convos.len()) |i| {\n+                    match reader_convos[i] {\n                         (_, ref rp) => rp.recv(),\n                     }\n                 }"}, {"sha": "f378384c5645cc39284e606a55ec3b48220f3918", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 72, "deletions": 61, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -34,37 +34,27 @@\n \n #[allow(missing_doc)];\n \n-use core::prelude::*;\n \n use list::{MutList, MutCons, MutNil};\n \n-use core::at_vec;\n-use core::cast::{transmute, transmute_mut_region};\n-use core::cast;\n-use core::libc::size_t;\n-use core::ptr;\n-use core::sys::TypeDesc;\n-use core::sys;\n-use core::uint;\n-use core::vec;\n-use core::unstable::intrinsics;\n-\n-pub mod rustrt {\n-    use core::libc::size_t;\n-    use core::sys::TypeDesc;\n-\n-    pub extern {\n-        #[rust_stack]\n-        unsafe fn rust_call_tydesc_glue(root: *u8,\n-                                        tydesc: *TypeDesc,\n-                                        field: size_t);\n-    }\n+use std::at_vec;\n+use std::cast::{transmute, transmute_mut, transmute_mut_region};\n+use std::cast;\n+use std::ptr;\n+use std::sys;\n+use std::uint;\n+use std::vec;\n+use std::unstable::intrinsics;\n+use std::unstable::intrinsics::{TyDesc};\n+\n+#[cfg(not(stage0))]\n+use std::unstable::intrinsics::{get_tydesc};\n+\n+#[cfg(stage0)]\n+unsafe fn get_tydesc<T>() -> *TyDesc {\n+    intrinsics::get_tydesc::<T>() as *TyDesc\n }\n \n-// This probably belongs somewhere else. Needs to be kept in sync with\n-// changes to glue...\n-static tydesc_drop_glue_index: size_t = 3 as size_t;\n-\n // The way arena uses arrays is really deeply awful. The arrays are\n // allocated, and have capacities reserved, but the fill for the array\n // will always stay at 0.\n@@ -74,6 +64,8 @@ struct Chunk {\n     is_pod: bool,\n }\n \n+#[mutable] // XXX remove after snap\n+#[no_freeze]\n pub struct Arena {\n     // The head is separated out from the list as a unbenchmarked\n     // microoptimization, to avoid needing to case on the list to\n@@ -85,7 +77,7 @@ pub struct Arena {\n \n #[unsafe_destructor]\n impl Drop for Arena {\n-    fn finalize(&self) {\n+    fn drop(&self) {\n         unsafe {\n             destroy_chunk(&self.head);\n             for self.chunks.each |chunk| {\n@@ -124,6 +116,19 @@ fn round_up_to(base: uint, align: uint) -> uint {\n     (base + (align - 1)) & !(align - 1)\n }\n \n+#[inline]\n+#[cfg(not(stage0))]\n+unsafe fn call_drop_glue(tydesc: *TyDesc, data: *i8) {\n+    // This function should be inlined when stage0 is gone\n+    ((*tydesc).drop_glue)(data);\n+}\n+\n+#[inline]\n+#[cfg(stage0)]\n+unsafe fn call_drop_glue(tydesc: *TyDesc, data: *i8) {\n+    ((*tydesc).drop_glue)(0 as **TyDesc, data);\n+}\n+\n // Walk down a chunk, running the destructors for any objects stored\n // in it.\n unsafe fn destroy_chunk(chunk: &Chunk) {\n@@ -136,19 +141,18 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n         let (tydesc, is_done) = un_bitpack_tydesc_ptr(*tydesc_data);\n         let (size, align) = ((*tydesc).size, (*tydesc).align);\n \n-        let after_tydesc = idx + sys::size_of::<*TypeDesc>();\n+        let after_tydesc = idx + sys::size_of::<*TyDesc>();\n \n         let start = round_up_to(after_tydesc, align);\n \n         //debug!(\"freeing object: idx = %u, size = %u, align = %u, done = %b\",\n         //       start, size, align, is_done);\n         if is_done {\n-            rustrt::rust_call_tydesc_glue(\n-                ptr::offset(buf, start), tydesc, tydesc_drop_glue_index);\n+            call_drop_glue(tydesc, ptr::offset(buf, start) as *i8);\n         }\n \n         // Find where the next tydesc lives\n-        idx = round_up_to(start + size, sys::pref_align_of::<*TypeDesc>());\n+        idx = round_up_to(start + size, sys::pref_align_of::<*TyDesc>());\n     }\n }\n \n@@ -157,12 +161,12 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n // is necessary in order to properly do cleanup if a failure occurs\n // during an initializer.\n #[inline]\n-unsafe fn bitpack_tydesc_ptr(p: *TypeDesc, is_done: bool) -> uint {\n+unsafe fn bitpack_tydesc_ptr(p: *TyDesc, is_done: bool) -> uint {\n     let p_bits: uint = transmute(p);\n     p_bits | (is_done as uint)\n }\n #[inline]\n-unsafe fn un_bitpack_tydesc_ptr(p: uint) -> (*TypeDesc, bool) {\n+unsafe fn un_bitpack_tydesc_ptr(p: uint) -> (*TyDesc, bool) {\n     (transmute(p & !1), p & 1 == 1)\n }\n \n@@ -182,27 +186,25 @@ impl Arena {\n     #[inline]\n     fn alloc_pod_inner(&mut self, n_bytes: uint, align: uint) -> *u8 {\n         unsafe {\n-            // XXX: Borrow check\n-            let head = transmute_mut_region(&mut self.pod_head);\n-\n-            let start = round_up_to(head.fill, align);\n+            let this = transmute_mut_region(self);\n+            let start = round_up_to(this.pod_head.fill, align);\n             let end = start + n_bytes;\n-            if end > at_vec::capacity(head.data) {\n-                return self.alloc_pod_grow(n_bytes, align);\n+            if end > at_vec::capacity(this.pod_head.data) {\n+                return this.alloc_pod_grow(n_bytes, align);\n             }\n-            head.fill = end;\n+            this.pod_head.fill = end;\n \n             //debug!(\"idx = %u, size = %u, align = %u, fill = %u\",\n             //       start, n_bytes, align, head.fill);\n \n-            ptr::offset(vec::raw::to_ptr(head.data), start)\n+            ptr::offset(vec::raw::to_ptr(this.pod_head.data), start)\n         }\n     }\n \n     #[inline]\n     fn alloc_pod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n         unsafe {\n-            let tydesc = sys::get_type_desc::<T>();\n+            let tydesc = get_tydesc::<T>();\n             let ptr = self.alloc_pod_inner((*tydesc).size, (*tydesc).align);\n             let ptr: *mut T = transmute(ptr);\n             intrinsics::move_val_init(&mut (*ptr), op());\n@@ -227,29 +229,39 @@ impl Arena {\n     fn alloc_nonpod_inner(&mut self, n_bytes: uint, align: uint)\n                           -> (*u8, *u8) {\n         unsafe {\n-            let head = transmute_mut_region(&mut self.head);\n+            let start;\n+            let end;\n+            let tydesc_start;\n+            let after_tydesc;\n+\n+            {\n+                let head = transmute_mut_region(&mut self.head);\n+\n+                tydesc_start = head.fill;\n+                after_tydesc = head.fill + sys::size_of::<*TyDesc>();\n+                start = round_up_to(after_tydesc, align);\n+                end = start + n_bytes;\n+            }\n \n-            let tydesc_start = head.fill;\n-            let after_tydesc = head.fill + sys::size_of::<*TypeDesc>();\n-            let start = round_up_to(after_tydesc, align);\n-            let end = start + n_bytes;\n-            if end > at_vec::capacity(head.data) {\n+            if end > at_vec::capacity(self.head.data) {\n                 return self.alloc_nonpod_grow(n_bytes, align);\n             }\n-            head.fill = round_up_to(end, sys::pref_align_of::<*TypeDesc>());\n+\n+            let head = transmute_mut_region(&mut self.head);\n+            head.fill = round_up_to(end, sys::pref_align_of::<*TyDesc>());\n \n             //debug!(\"idx = %u, size = %u, align = %u, fill = %u\",\n             //       start, n_bytes, align, head.fill);\n \n-            let buf = vec::raw::to_ptr(head.data);\n+            let buf = vec::raw::to_ptr(self.head.data);\n             return (ptr::offset(buf, tydesc_start), ptr::offset(buf, start));\n         }\n     }\n \n     #[inline]\n     fn alloc_nonpod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n         unsafe {\n-            let tydesc = sys::get_type_desc::<T>();\n+            let tydesc = get_tydesc::<T>();\n             let (ty_ptr, ptr) =\n                 self.alloc_nonpod_inner((*tydesc).size, (*tydesc).align);\n             let ty_ptr: *mut uint = transmute(ty_ptr);\n@@ -269,23 +281,22 @@ impl Arena {\n \n     // The external interface\n     #[inline]\n-    pub fn alloc<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n+    pub fn alloc<'a, T>(&'a self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             // XXX: Borrow check\n-            let this = transmute_mut_region(self);\n-            if !intrinsics::needs_drop::<T>() {\n-                return this.alloc_pod(op);\n+            let this = transmute_mut(self);\n+            if intrinsics::needs_drop::<T>() {\n+                this.alloc_nonpod(op)\n+            } else {\n+                this.alloc_pod(op)\n             }\n-            // XXX: Borrow check\n-            let this = transmute_mut_region(self);\n-            this.alloc_nonpod(op)\n         }\n     }\n }\n \n #[test]\n fn test_arena_destructors() {\n-    let mut arena = Arena();\n+    let arena = Arena();\n     for uint::range(0, 10) |i| {\n         // Arena allocate something with drop glue to make sure it\n         // doesn't leak.\n@@ -300,7 +311,7 @@ fn test_arena_destructors() {\n #[should_fail]\n #[ignore(cfg(windows))]\n fn test_arena_destructors_fail() {\n-    let mut arena = Arena();\n+    let arena = Arena();\n     // Put some stuff in the arena.\n     for uint::range(0, 10) |i| {\n         // Arena allocate something with drop glue to make sure it"}, {"sha": "a53a22ee831d43cacd5f054160d076ec59bad285", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -10,9 +10,8 @@\n \n //! Base64 binary-to-text encoding\n \n-use core::prelude::*;\n \n-use core::vec;\n+use std::vec;\n \n /// A trait for converting a value to base64 encoding.\n pub trait ToBase64 {\n@@ -36,8 +35,8 @@ impl<'self> ToBase64 for &'self [u8] {\n      * # Example\n      *\n      * ~~~ {.rust}\n-     * extern mod std;\n-     * use std::base64::ToBase64;\n+     * extern mod extra;\n+     * use extra::base64::ToBase64;\n      *\n      * fn main () {\n      *     let str = [52,32].to_base64();\n@@ -99,8 +98,8 @@ impl<'self> ToBase64 for &'self str {\n      * # Example\n      *\n      * ~~~ {.rust}\n-     * extern mod std;\n-     * use std::base64::ToBase64;\n+     * extern mod extra;\n+     * use extra::base64::ToBase64;\n      *\n      * fn main () {\n      *     let str = \"Hello, World\".to_base64();\n@@ -127,9 +126,9 @@ impl<'self> FromBase64 for &'self [u8] {\n      * # Example\n      *\n      * ~~~ {.rust}\n-     * extern mod std;\n-     * use std::base64::ToBase64;\n-     * use std::base64::FromBase64;\n+     * extern mod extra;\n+     * use extra::base64::ToBase64;\n+     * use extra::base64::FromBase64;\n      *\n      * fn main () {\n      *     let str = [52,32].to_base64();\n@@ -199,18 +198,18 @@ impl<'self> FromBase64 for &'self str {\n      * Convert any base64 encoded string (literal, `@`, `&`, or `~`)\n      * to the byte values it encodes.\n      *\n-     * You can use the `from_bytes` function in `core::str`\n+     * You can use the `from_bytes` function in `std::str`\n      * to turn a `[u8]` into a string with characters corresponding to those values.\n      *\n      * # Example\n      *\n      * This converts a string literal to base64 and back.\n      *\n      * ~~~ {.rust}\n-     * extern mod std;\n-     * use std::base64::ToBase64;\n-     * use std::base64::FromBase64;\n-     * use core::str;\n+     * extern mod extra;\n+     * use extra::base64::ToBase64;\n+     * use extra::base64::FromBase64;\n+     * use std::str;\n      *\n      * fn main () {\n      *     let hello_str = \"Hello, World\".to_base64();"}, {"sha": "30541f832389a72881d38cb00848464d6add2052", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -10,12 +10,11 @@\n \n #[allow(missing_doc)];\n \n-use core::prelude::*;\n \n-use core::cmp;\n-use core::ops;\n-use core::uint;\n-use core::vec;\n+use std::cmp;\n+use std::ops;\n+use std::uint;\n+use std::vec;\n \n struct SmallBitv {\n     /// only the lowest nbits of this value are used. the rest is undefined.\n@@ -476,9 +475,15 @@ impl Bitv {\n      * character is either '0' or '1'.\n      */\n      pub fn to_str(&self) -> ~str {\n-       let mut rs = ~\"\";\n-       for self.each() |i| { if i { rs += \"1\"; } else { rs += \"0\"; } };\n-       rs\n+        let mut rs = ~\"\";\n+        for self.each() |i| {\n+            if i {\n+                rs.push_char('1');\n+            } else {\n+                rs.push_char('0');\n+            }\n+        };\n+        rs\n      }\n \n \n@@ -639,7 +644,7 @@ impl BitvSet {\n         if self.capacity() < other.capacity() {\n             self.bitv.storage.grow(other.capacity() / uint::bits, &0);\n         }\n-        for other.bitv.storage.eachi |i, &w| {\n+        for other.bitv.storage.iter().enumerate().advance |(i, &w)| {\n             let old = self.bitv.storage[i];\n             let new = f(old, w);\n             self.bitv.storage[i] = new;\n@@ -666,13 +671,9 @@ impl BitvSet {\n     pub fn symmetric_difference_with(&mut self, other: &BitvSet) {\n         self.other_op(other, |w1, w2| w1 ^ w2);\n     }\n-}\n-\n-impl BaseIter<uint> for BitvSet {\n-    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n \n-    fn each(&self, blk: &fn(v: &uint) -> bool) -> bool {\n-        for self.bitv.storage.eachi |i, &w| {\n+    pub fn each(&self, blk: &fn(v: &uint) -> bool) -> bool {\n+        for self.bitv.storage.iter().enumerate().advance |(i, &w)| {\n             if !iterate_bits(i * uint::bits, w, |b| blk(&b)) {\n                 return false;\n             }\n@@ -703,8 +704,8 @@ impl cmp::Eq for BitvSet {\n }\n \n impl Container for BitvSet {\n-    fn len(&const self) -> uint { self.size }\n-    fn is_empty(&const self) -> bool { self.size == 0 }\n+    fn len(&self) -> uint { self.size }\n+    fn is_empty(&self) -> bool { self.size == 0 }\n }\n \n impl Mutable for BitvSet {\n@@ -826,7 +827,7 @@ impl BitvSet {\n                    f: &fn(uint, uint, uint) -> bool) -> bool {\n         let min = uint::min(self.bitv.storage.len(),\n                             other.bitv.storage.len());\n-        self.bitv.storage.slice(0, min).eachi(|i, &w| {\n+        self.bitv.storage.slice(0, min).iter().enumerate().advance(|(i, &w)| {\n             f(i * uint::bits, w, other.bitv.storage[i])\n         })\n     }\n@@ -845,12 +846,12 @@ impl BitvSet {\n         let min = uint::min(len1, len2);\n \n         /* only one of these loops will execute and that's the point */\n-        for self.bitv.storage.slice(min, len1).eachi |i, &w| {\n+        for self.bitv.storage.slice(min, len1).iter().enumerate().advance |(i, &w)| {\n             if !f(true, (i + min) * uint::bits, w) {\n                 return false;\n             }\n         }\n-        for other.bitv.storage.slice(min, len2).eachi |i, &w| {\n+        for other.bitv.storage.slice(min, len2).iter().enumerate().advance |(i, &w)| {\n             if !f(false, (i + min) * uint::bits, w) {\n                 return false;\n             }\n@@ -861,15 +862,15 @@ impl BitvSet {\n \n #[cfg(test)]\n mod tests {\n-    use std::test::BenchHarness;\n+    use extra::test::BenchHarness;\n \n     use bitv::*;\n     use bitv;\n \n-    use core::uint;\n-    use core::vec;\n-    use core::rand;\n-    use core::rand::Rng;\n+    use std::uint;\n+    use std::vec;\n+    use std::rand;\n+    use std::rand::Rng;\n \n     static bench_bits : uint = 1 << 14;\n "}, {"sha": "c6e7b5b0aa7cef18265e53e8a5689ac6d45d0d3f", "filename": "src/libextra/c_vec.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fc_vec.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -36,10 +36,9 @@\n  * still held if needed.\n  */\n \n-use core::prelude::*;\n \n-use core::option;\n-use core::ptr;\n+use std::option;\n+use std::ptr;\n \n /**\n  * The type representing a foreign chunk of memory\n@@ -57,7 +56,7 @@ struct DtorRes {\n \n #[unsafe_destructor]\n impl Drop for DtorRes {\n-    fn finalize(&self) {\n+    fn drop(&self) {\n         match self.dtor {\n             option::None => (),\n             option::Some(f) => f()\n@@ -150,17 +149,16 @@ mod tests {\n \n     use c_vec::*;\n \n-    use core::libc::*;\n-    use core::libc;\n+    use std::libc::*;\n+    use std::libc;\n \n     fn malloc(n: size_t) -> CVec<u8> {\n         unsafe {\n             let mem = libc::malloc(n);\n \n             assert!(mem as int != 0);\n \n-            return c_vec_with_dtor(mem as *mut u8, n as uint,\n-                                   || unsafe { free(mem) });\n+            c_vec_with_dtor(mem as *mut u8, n as uint, || free(mem))\n         }\n     }\n "}, {"sha": "44581efc6f07b2e107594dc719c00db5203d34ba", "filename": "src/libextra/comm.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcomm.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -16,12 +16,11 @@ Higher level communication abstractions.\n \n #[allow(missing_doc)];\n \n-use core::prelude::*;\n \n-use core::comm::{GenericChan, GenericSmartChan, GenericPort};\n-use core::comm::{Chan, Port, Selectable, Peekable};\n-use core::comm;\n-use core::pipes;\n+use std::comm::{GenericChan, GenericSmartChan, GenericPort};\n+use std::comm::{Chan, Port, Selectable, Peekable};\n+use std::comm;\n+use std::pipes;\n \n /// An extension of `pipes::stream` that allows both sending and receiving.\n pub struct DuplexStream<T, U> {\n@@ -30,7 +29,7 @@ pub struct DuplexStream<T, U> {\n }\n \n // Allow these methods to be used without import:\n-impl<T:Owned,U:Owned> DuplexStream<T, U> {\n+impl<T:Send,U:Send> DuplexStream<T, U> {\n     pub fn send(&self, x: T) {\n         self.chan.send(x)\n     }\n@@ -48,19 +47,19 @@ impl<T:Owned,U:Owned> DuplexStream<T, U> {\n     }\n }\n \n-impl<T:Owned,U:Owned> GenericChan<T> for DuplexStream<T, U> {\n+impl<T:Send,U:Send> GenericChan<T> for DuplexStream<T, U> {\n     fn send(&self, x: T) {\n         self.chan.send(x)\n     }\n }\n \n-impl<T:Owned,U:Owned> GenericSmartChan<T> for DuplexStream<T, U> {\n+impl<T:Send,U:Send> GenericSmartChan<T> for DuplexStream<T, U> {\n     fn try_send(&self, x: T) -> bool {\n         self.chan.try_send(x)\n     }\n }\n \n-impl<T:Owned,U:Owned> GenericPort<U> for DuplexStream<T, U> {\n+impl<T:Send,U:Send> GenericPort<U> for DuplexStream<T, U> {\n     fn recv(&self) -> U {\n         self.port.recv()\n     }\n@@ -70,20 +69,20 @@ impl<T:Owned,U:Owned> GenericPort<U> for DuplexStream<T, U> {\n     }\n }\n \n-impl<T:Owned,U:Owned> Peekable<U> for DuplexStream<T, U> {\n+impl<T:Send,U:Send> Peekable<U> for DuplexStream<T, U> {\n     fn peek(&self) -> bool {\n         self.port.peek()\n     }\n }\n \n-impl<T:Owned,U:Owned> Selectable for DuplexStream<T, U> {\n+impl<T:Send,U:Send> Selectable for DuplexStream<T, U> {\n     fn header(&mut self) -> *mut pipes::PacketHeader {\n         self.port.header()\n     }\n }\n \n /// Creates a bidirectional stream.\n-pub fn DuplexStream<T:Owned,U:Owned>()\n+pub fn DuplexStream<T:Send,U:Send>()\n     -> (DuplexStream<T, U>, DuplexStream<U, T>)\n {\n     let (p1, c2) = comm::stream();"}, {"sha": "26e8b80d8e3c2fb112399847e10929912acf4c0c", "filename": "src/libextra/crypto/digest.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fcrypto%2Fdigest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fcrypto%2Fdigest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fdigest.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -0,0 +1,87 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+use std::uint;\n+use std::vec;\n+\n+/**\n+ * The Digest trait specifies an interface common to digest functions, such as SHA-1 and the SHA-2\n+ * family of digest functions.\n+ */\n+pub trait Digest {\n+    /**\n+     * Provide message data.\n+     *\n+     * # Arguments\n+     *\n+     * * input - A vector of message data\n+     */\n+    fn input(&mut self, input: &[u8]);\n+\n+    /**\n+     * Retrieve the digest result. This method may be called multiple times.\n+     */\n+    fn result(&mut self, out: &mut [u8]);\n+\n+    /**\n+     * Reset the digest. This method must be called after result() and before supplying more\n+     * data.\n+     */\n+    fn reset(&mut self);\n+\n+    /**\n+     * Get the output size in bits.\n+     */\n+    fn output_bits(&self) -> uint;\n+}\n+\n+fn to_hex(rr: &[u8]) -> ~str {\n+    let mut s = ~\"\";\n+    for rr.iter().advance() |b| {\n+        let hex = uint::to_str_radix(*b as uint, 16u);\n+        if hex.len() == 1 {\n+            s.push_char('0');\n+        }\n+        s.push_str(hex);\n+    }\n+    return s;\n+}\n+\n+/// Contains utility methods for Digests.\n+/// FIXME: #7339: Convert to default methods when issues with them are resolved.\n+pub trait DigestUtil {\n+    /**\n+     * Convenience functon that feeds a string into a digest\n+     *\n+     * # Arguments\n+     *\n+     * * in The string to feed into the digest\n+     */\n+    fn input_str(&mut self, in: &str);\n+\n+    /**\n+     * Convenience functon that retrieves the result of a digest as a\n+     * ~str in hexadecimal format.\n+     */\n+    fn result_str(&mut self) -> ~str;\n+}\n+\n+impl<D: Digest> DigestUtil for D {\n+    fn input_str(&mut self, in: &str) {\n+        self.input(in.as_bytes());\n+    }\n+\n+    fn result_str(&mut self) -> ~str {\n+        let mut buf = vec::from_elem((self.output_bits()+7)/8, 0u8);\n+        self.result(buf);\n+        return to_hex(buf);\n+    }\n+}"}, {"sha": "238e4a4d238d426ffa40520faf901c1ed06667cf", "filename": "src/libextra/crypto/sha1.rs", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fcrypto%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fcrypto%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha1.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -0,0 +1,369 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * An implementation of the SHA-1 cryptographic hash.\n+ *\n+ * First create a `sha1` object using the `sha1` constructor, then\n+ * feed it input using the `input` or `input_str` methods, which may be\n+ * called any number of times.\n+ *\n+ * After the entire input has been fed to the hash read the result using\n+ * the `result` or `result_str` methods.\n+ *\n+ * The `sha1` object may be reused to create multiple hashes by calling\n+ * the `reset` method.\n+ */\n+\n+\n+use digest::Digest;\n+\n+/*\n+ * A SHA-1 implementation derived from Paul E. Jones's reference\n+ * implementation, which is written for clarity, not speed. At some\n+ * point this will want to be rewritten.\n+ */\n+\n+// Some unexported constants\n+static DIGEST_BUF_LEN: uint = 5u;\n+static MSG_BLOCK_LEN: uint = 64u;\n+static WORK_BUF_LEN: uint = 80u;\n+static K0: u32 = 0x5A827999u32;\n+static K1: u32 = 0x6ED9EBA1u32;\n+static K2: u32 = 0x8F1BBCDCu32;\n+static K3: u32 = 0xCA62C1D6u32;\n+\n+/// Structure representing the state of a Sha1 computation\n+pub struct Sha1 {\n+    priv h: [u32, ..DIGEST_BUF_LEN],\n+    priv len_low: u32,\n+    priv len_high: u32,\n+    priv msg_block: [u8, ..MSG_BLOCK_LEN],\n+    priv msg_block_idx: uint,\n+    priv computed: bool,\n+    priv work_buf: [u32, ..WORK_BUF_LEN]\n+}\n+\n+fn add_input(st: &mut Sha1, msg: &[u8]) {\n+    assert!((!st.computed));\n+    for msg.iter().advance |element| {\n+        st.msg_block[st.msg_block_idx] = *element;\n+        st.msg_block_idx += 1;\n+        st.len_low += 8;\n+        if st.len_low == 0 {\n+            st.len_high += 1;\n+            if st.len_high == 0 {\n+                // FIXME: Need better failure mode (#2346)\n+                fail!();\n+            }\n+        }\n+        if st.msg_block_idx == MSG_BLOCK_LEN { process_msg_block(st); }\n+    }\n+}\n+\n+fn process_msg_block(st: &mut Sha1) {\n+    let mut t: int; // Loop counter\n+    let mut w = st.work_buf;\n+\n+    // Initialize the first 16 words of the vector w\n+    t = 0;\n+    while t < 16 {\n+        let mut tmp;\n+        tmp = (st.msg_block[t * 4] as u32) << 24u32;\n+        tmp = tmp | (st.msg_block[t * 4 + 1] as u32) << 16u32;\n+        tmp = tmp | (st.msg_block[t * 4 + 2] as u32) << 8u32;\n+        tmp = tmp | (st.msg_block[t * 4 + 3] as u32);\n+        w[t] = tmp;\n+        t += 1;\n+    }\n+\n+    // Initialize the rest of vector w\n+    while t < 80 {\n+        let val = w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16];\n+        w[t] = circular_shift(1, val);\n+        t += 1;\n+    }\n+    let mut a = st.h[0];\n+    let mut b = st.h[1];\n+    let mut c = st.h[2];\n+    let mut d = st.h[3];\n+    let mut e = st.h[4];\n+    let mut temp: u32;\n+    t = 0;\n+    while t < 20 {\n+        temp = circular_shift(5, a) + (b & c | !b & d) + e + w[t] + K0;\n+        e = d;\n+        d = c;\n+        c = circular_shift(30, b);\n+        b = a;\n+        a = temp;\n+        t += 1;\n+    }\n+    while t < 40 {\n+        temp = circular_shift(5, a) + (b ^ c ^ d) + e + w[t] + K1;\n+        e = d;\n+        d = c;\n+        c = circular_shift(30, b);\n+        b = a;\n+        a = temp;\n+        t += 1;\n+    }\n+    while t < 60 {\n+        temp =\n+            circular_shift(5, a) + (b & c | b & d | c & d) + e + w[t] +\n+                K2;\n+        e = d;\n+        d = c;\n+        c = circular_shift(30, b);\n+        b = a;\n+        a = temp;\n+        t += 1;\n+    }\n+    while t < 80 {\n+        temp = circular_shift(5, a) + (b ^ c ^ d) + e + w[t] + K3;\n+        e = d;\n+        d = c;\n+        c = circular_shift(30, b);\n+        b = a;\n+        a = temp;\n+        t += 1;\n+    }\n+    st.h[0] = st.h[0] + a;\n+    st.h[1] = st.h[1] + b;\n+    st.h[2] = st.h[2] + c;\n+    st.h[3] = st.h[3] + d;\n+    st.h[4] = st.h[4] + e;\n+    st.msg_block_idx = 0;\n+}\n+\n+fn circular_shift(bits: u32, word: u32) -> u32 {\n+    return word << bits | word >> 32u32 - bits;\n+}\n+\n+fn mk_result(st: &mut Sha1, rs: &mut [u8]) {\n+    if !st.computed { pad_msg(st); st.computed = true; }\n+    let mut i = 0;\n+    for st.h.mut_iter().advance |ptr_hpart| {\n+        let hpart = *ptr_hpart;\n+        rs[i]   = (hpart >> 24u32 & 0xFFu32) as u8;\n+        rs[i+1] = (hpart >> 16u32 & 0xFFu32) as u8;\n+        rs[i+2] = (hpart >> 8u32 & 0xFFu32) as u8;\n+        rs[i+3] = (hpart & 0xFFu32) as u8;\n+        i += 4;\n+    }\n+}\n+\n+/*\n+ * According to the standard, the message must be padded to an even\n+ * 512 bits.  The first padding bit must be a '1'.  The last 64 bits\n+ * represent the length of the original message.  All bits in between\n+ * should be 0.  This function will pad the message according to those\n+ * rules by filling the msg_block vector accordingly.  It will also\n+ * call process_msg_block() appropriately.  When it returns, it\n+ * can be assumed that the message digest has been computed.\n+ */\n+fn pad_msg(st: &mut Sha1) {\n+    /*\n+     * Check to see if the current message block is too small to hold\n+     * the initial padding bits and length.  If so, we will pad the\n+     * block, process it, and then continue padding into a second block.\n+     */\n+    if st.msg_block_idx > 55 {\n+        st.msg_block[st.msg_block_idx] = 0x80;\n+        st.msg_block_idx += 1;\n+        while st.msg_block_idx < MSG_BLOCK_LEN {\n+            st.msg_block[st.msg_block_idx] = 0;\n+            st.msg_block_idx += 1;\n+        }\n+        process_msg_block(st);\n+    } else {\n+        st.msg_block[st.msg_block_idx] = 0x80;\n+        st.msg_block_idx += 1;\n+    }\n+    while st.msg_block_idx < 56 {\n+        st.msg_block[st.msg_block_idx] = 0u8;\n+        st.msg_block_idx += 1;\n+    }\n+\n+    // Store the message length as the last 8 octets\n+    st.msg_block[56] = (st.len_high >> 24u32 & 0xFFu32) as u8;\n+    st.msg_block[57] = (st.len_high >> 16u32 & 0xFFu32) as u8;\n+    st.msg_block[58] = (st.len_high >> 8u32 & 0xFFu32) as u8;\n+    st.msg_block[59] = (st.len_high & 0xFFu32) as u8;\n+    st.msg_block[60] = (st.len_low >> 24u32 & 0xFFu32) as u8;\n+    st.msg_block[61] = (st.len_low >> 16u32 & 0xFFu32) as u8;\n+    st.msg_block[62] = (st.len_low >> 8u32 & 0xFFu32) as u8;\n+    st.msg_block[63] = (st.len_low & 0xFFu32) as u8;\n+    process_msg_block(st);\n+}\n+\n+impl Sha1 {\n+    /// Construct a `sha` object\n+    pub fn new() -> Sha1 {\n+        let mut st = Sha1 {\n+            h: [0u32, ..DIGEST_BUF_LEN],\n+            len_low: 0u32,\n+            len_high: 0u32,\n+            msg_block: [0u8, ..MSG_BLOCK_LEN],\n+            msg_block_idx: 0,\n+            computed: false,\n+            work_buf: [0u32, ..WORK_BUF_LEN]\n+        };\n+        st.reset();\n+        return st;\n+    }\n+}\n+\n+impl Digest for Sha1 {\n+    pub fn reset(&mut self) {\n+        self.len_low = 0;\n+        self.len_high = 0;\n+        self.msg_block_idx = 0;\n+        self.h[0] = 0x67452301u32;\n+        self.h[1] = 0xEFCDAB89u32;\n+        self.h[2] = 0x98BADCFEu32;\n+        self.h[3] = 0x10325476u32;\n+        self.h[4] = 0xC3D2E1F0u32;\n+        self.computed = false;\n+    }\n+    pub fn input(&mut self, msg: &[u8]) { add_input(self, msg); }\n+    pub fn result(&mut self, out: &mut [u8]) { return mk_result(self, out); }\n+    pub fn output_bits(&self) -> uint { 160 }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::vec;\n+\n+    use digest::{Digest, DigestUtil};\n+    use sha1::Sha1;\n+\n+    #[test]\n+    fn test() {\n+        struct Test {\n+            input: ~str,\n+            output: ~[u8],\n+            output_str: ~str,\n+        }\n+\n+        fn a_million_letter_a() -> ~str {\n+            let mut i = 0;\n+            let mut rs = ~\"\";\n+            while i < 100000 {\n+                rs.push_str(\"aaaaaaaaaa\");\n+                i += 1;\n+            }\n+            return rs;\n+        }\n+        // Test messages from FIPS 180-1\n+\n+        let fips_180_1_tests = ~[\n+            Test {\n+                input: ~\"abc\",\n+                output: ~[\n+                    0xA9u8, 0x99u8, 0x3Eu8, 0x36u8,\n+                    0x47u8, 0x06u8, 0x81u8, 0x6Au8,\n+                    0xBAu8, 0x3Eu8, 0x25u8, 0x71u8,\n+                    0x78u8, 0x50u8, 0xC2u8, 0x6Cu8,\n+                    0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8,\n+                ],\n+                output_str: ~\"a9993e364706816aba3e25717850c26c9cd0d89d\"\n+            },\n+            Test {\n+                input:\n+                     ~\"abcdbcdecdefdefgefghfghighij\" +\n+                     \"hijkijkljklmklmnlmnomnopnopq\",\n+                output: ~[\n+                    0x84u8, 0x98u8, 0x3Eu8, 0x44u8,\n+                    0x1Cu8, 0x3Bu8, 0xD2u8, 0x6Eu8,\n+                    0xBAu8, 0xAEu8, 0x4Au8, 0xA1u8,\n+                    0xF9u8, 0x51u8, 0x29u8, 0xE5u8,\n+                    0xE5u8, 0x46u8, 0x70u8, 0xF1u8,\n+                ],\n+                output_str: ~\"84983e441c3bd26ebaae4aa1f95129e5e54670f1\"\n+            },\n+            Test {\n+                input: a_million_letter_a(),\n+                output: ~[\n+                    0x34u8, 0xAAu8, 0x97u8, 0x3Cu8,\n+                    0xD4u8, 0xC4u8, 0xDAu8, 0xA4u8,\n+                    0xF6u8, 0x1Eu8, 0xEBu8, 0x2Bu8,\n+                    0xDBu8, 0xADu8, 0x27u8, 0x31u8,\n+                    0x65u8, 0x34u8, 0x01u8, 0x6Fu8,\n+                ],\n+                output_str: ~\"34aa973cd4c4daa4f61eeb2bdbad27316534016f\"\n+            },\n+        ];\n+        // Examples from wikipedia\n+\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output: ~[\n+                    0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8,\n+                    0x7au8, 0x2du8, 0x28u8, 0xfcu8,\n+                    0xedu8, 0x84u8, 0x9eu8, 0xe1u8,\n+                    0xbbu8, 0x76u8, 0xe7u8, 0x39u8,\n+                    0x1bu8, 0x93u8, 0xebu8, 0x12u8,\n+                ],\n+                output_str: ~\"2fd4e1c67a2d28fced849ee1bb76e7391b93eb12\",\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy cog\",\n+                output: ~[\n+                    0xdeu8, 0x9fu8, 0x2cu8, 0x7fu8,\n+                    0xd2u8, 0x5eu8, 0x1bu8, 0x3au8,\n+                    0xfau8, 0xd3u8, 0xe8u8, 0x5au8,\n+                    0x0bu8, 0xd1u8, 0x7du8, 0x9bu8,\n+                    0x10u8, 0x0du8, 0xb4u8, 0xb3u8,\n+                ],\n+                output_str: ~\"de9f2c7fd25e1b3afad3e85a0bd17d9b100db4b3\",\n+            },\n+        ];\n+        let tests = fips_180_1_tests + wikipedia_tests;\n+\n+        // Test that it works when accepting the message all at once\n+\n+        let mut out = [0u8, ..20];\n+\n+        let mut sh = ~Sha1::new();\n+        for tests.iter().advance |t| {\n+            (*sh).input_str(t.input);\n+            sh.result(out);\n+            assert!(vec::eq(t.output, out));\n+\n+            let out_str = (*sh).result_str();\n+            assert_eq!(out_str.len(), 40);\n+            assert!(out_str == t.output_str);\n+\n+            sh.reset();\n+        }\n+\n+\n+        // Test that it works when accepting the message in pieces\n+        for tests.iter().advance |t| {\n+            let len = t.input.len();\n+            let mut left = len;\n+            while left > 0u {\n+                let take = (left + 1u) / 2u;\n+                (*sh).input_str(t.input.slice(len - left, take + len - left));\n+                left = left - take;\n+            }\n+            sh.result(out);\n+            assert!(vec::eq(t.output, out));\n+\n+            let out_str = (*sh).result_str();\n+            assert_eq!(out_str.len(), 40);\n+            assert!(out_str == t.output_str);\n+\n+            sh.reset();\n+        }\n+    }\n+}"}, {"sha": "4b120c7b1184a9fbf2dabc47bbd6438ad89677b7", "filename": "src/libextra/crypto/sha2.rs", "status": "added", "additions": 1123, "deletions": 0, "changes": 1123, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fcrypto%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fcrypto%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha2.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -0,0 +1,1123 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+use std::uint;\n+\n+use digest::Digest;\n+\n+// BitCounter is a specialized structure intended simply for counting the\n+// number of bits that have been processed by the SHA-2 512 family of functions.\n+// It does very little overflow checking since such checking is not necessary\n+// for how it is used. A more generic structure would have to do this checking.\n+// So, don't copy this structure and use it elsewhere!\n+struct BitCounter {\n+    high_bit_count: u64,\n+    low_byte_count: u64\n+}\n+\n+impl BitCounter {\n+    fn add_bytes(&mut self, bytes: uint) {\n+        self.low_byte_count += bytes as u64;\n+        if(self.low_byte_count > 0x1fffffffffffffffu64) {\n+            self.high_bit_count += (self.low_byte_count >> 61);\n+            self.low_byte_count &= 0x1fffffffffffffffu64;\n+        }\n+    }\n+\n+    fn reset(&mut self) {\n+        self.low_byte_count = 0;\n+        self.high_bit_count = 0;\n+    }\n+\n+    fn get_low_bit_count(&self) -> u64 {\n+        self.low_byte_count << 3\n+    }\n+\n+    fn get_high_bit_count(&self) -> u64 {\n+        self.high_bit_count\n+    }\n+}\n+\n+// A structure that represents that state of a digest computation\n+// for the SHA-2 512 family of digest functions\n+struct Engine512 {\n+    input_buffer: [u8, ..8],\n+    input_buffer_idx: uint,\n+    bit_counter: BitCounter,\n+    H0: u64,\n+    H1: u64,\n+    H2: u64,\n+    H3: u64,\n+    H4: u64,\n+    H5: u64,\n+    H6: u64,\n+    H7: u64,\n+    W: [u64, ..80],\n+    W_idx: uint,\n+    finished: bool,\n+}\n+\n+// Convert a [u8] to a u64 in big-endian format\n+fn to_u64(in: &[u8]) -> u64 {\n+    (in[0] as u64) << 56 |\n+    (in[1] as u64) << 48 |\n+    (in[2] as u64) << 40 |\n+    (in[3] as u64) << 32 |\n+    (in[4] as u64) << 24 |\n+    (in[5] as u64) << 16 |\n+    (in[6] as u64) << 8 |\n+    (in[7] as u64)\n+}\n+\n+// Convert a u64 to a [u8] in big endian format\n+fn from_u64(in: u64, out: &mut [u8]) {\n+    out[0] = (in >> 56) as u8;\n+    out[1] = (in >> 48) as u8;\n+    out[2] = (in >> 40) as u8;\n+    out[3] = (in >> 32) as u8;\n+    out[4] = (in >> 24) as u8;\n+    out[5] = (in >> 16) as u8;\n+    out[6] = (in >> 8) as u8;\n+    out[7] = in as u8;\n+}\n+\n+impl Engine512 {\n+    fn input_byte(&mut self, in: u8) {\n+        assert!(!self.finished)\n+\n+        self.input_buffer[self.input_buffer_idx] = in;\n+        self.input_buffer_idx += 1;\n+\n+        if (self.input_buffer_idx == 8) {\n+            self.input_buffer_idx = 0;\n+            let w = to_u64(self.input_buffer);\n+            self.process_word(w);\n+        }\n+\n+        self.bit_counter.add_bytes(1);\n+    }\n+\n+    fn input_vec(&mut self, in: &[u8]) {\n+        assert!(!self.finished)\n+\n+        let mut i = 0;\n+\n+        while i < in.len() && self.input_buffer_idx != 0 {\n+            self.input_byte(in[i]);\n+            i += 1;\n+        }\n+\n+        while in.len() - i >= 8 {\n+            let w = to_u64(in.slice(i, i + 8));\n+            self.process_word(w);\n+            self.bit_counter.add_bytes(8);\n+            i += 8;\n+        }\n+\n+        while i < in.len() {\n+            self.input_byte(in[i]);\n+            i += 1;\n+        }\n+    }\n+\n+    fn reset(&mut self) {\n+        self.bit_counter.reset();\n+        self.finished = false;\n+        self.input_buffer_idx = 0;\n+        self.W_idx = 0;\n+    }\n+\n+    fn process_word(&mut self, in: u64) {\n+        self.W[self.W_idx] = in;\n+        self.W_idx += 1;\n+        if (self.W_idx == 16) {\n+            self.W_idx = 0;\n+            self.process_block();\n+        }\n+    }\n+\n+    fn process_block(&mut self) {\n+        fn ch(x: u64, y: u64, z: u64) -> u64 {\n+            ((x & y) ^ ((!x) & z))\n+        }\n+\n+        fn maj(x: u64, y: u64, z: u64) -> u64 {\n+            ((x & y) ^ (x & z) ^ (y & z))\n+        }\n+\n+        fn sum0(x: u64) -> u64 {\n+            ((x << 36) | (x >> 28)) ^ ((x << 30) | (x >> 34)) ^ ((x << 25) | (x >> 39))\n+        }\n+\n+        fn sum1(x: u64) -> u64 {\n+            ((x << 50) | (x >> 14)) ^ ((x << 46) | (x >> 18)) ^ ((x << 23) | (x >> 41))\n+        }\n+\n+        fn sigma0(x: u64) -> u64 {\n+            ((x << 63) | (x >> 1)) ^ ((x << 56) | (x >> 8)) ^ (x >> 7)\n+        }\n+\n+        fn sigma1(x: u64) -> u64 {\n+            ((x << 45) | (x >> 19)) ^ ((x << 3) | (x >> 61)) ^ (x >> 6)\n+        }\n+\n+        for uint::range(16, 80) |t| {\n+            self.W[t] = sigma1(self.W[t - 2]) + self.W[t - 7] + sigma0(self.W[t - 15]) +\n+                self.W[t - 16];\n+        }\n+\n+        let mut a = self.H0;\n+        let mut b = self.H1;\n+        let mut c = self.H2;\n+        let mut d = self.H3;\n+        let mut e = self.H4;\n+        let mut f = self.H5;\n+        let mut g = self.H6;\n+        let mut h = self.H7;\n+\n+        let mut t = 0;\n+        for uint::range(0, 10) |_| {\n+            h += sum1(e) + ch(e, f, g) + K64[t] + self.W[t];\n+            d += h;\n+            h += sum0(a) + maj(a, b, c);\n+            t += 1;\n+\n+            g += sum1(d) + ch(d, e, f) + K64[t] + self.W[t];\n+            c += g;\n+            g += sum0(h) + maj(h, a, b);\n+            t += 1;\n+\n+            f += sum1(c) + ch(c, d, e) + K64[t] + self.W[t];\n+            b += f;\n+            f += sum0(g) + maj(g, h, a);\n+            t += 1;\n+\n+            e += sum1(b) + ch(b, c, d) + K64[t] + self.W[t];\n+            a += e;\n+            e += sum0(f) + maj(f, g, h);\n+            t += 1;\n+\n+            d += sum1(a) + ch(a, b, c) + K64[t] + self.W[t];\n+            h += d;\n+            d += sum0(e) + maj(e, f, g);\n+            t += 1;\n+\n+            c += sum1(h) + ch(h, a, b) + K64[t] + self.W[t];\n+            g += c;\n+            c += sum0(d) + maj(d, e, f);\n+            t += 1;\n+\n+            b += sum1(g) + ch(g, h, a) + K64[t] + self.W[t];\n+            f += b;\n+            b += sum0(c) + maj(c, d, e);\n+            t += 1;\n+\n+            a += sum1(f) + ch(f, g, h) + K64[t] + self.W[t];\n+            e += a;\n+            a += sum0(b) + maj(b, c, d);\n+            t += 1;\n+        }\n+\n+        self.H0 += a;\n+        self.H1 += b;\n+        self.H2 += c;\n+        self.H3 += d;\n+        self.H4 += e;\n+        self.H5 += f;\n+        self.H6 += g;\n+        self.H7 += h;\n+    }\n+\n+    fn finish(&mut self) {\n+        if (self.finished) {\n+            return;\n+        }\n+\n+        // must get message length before padding is added\n+        let high_bit_count = self.bit_counter.get_high_bit_count();\n+        let low_bit_count = self.bit_counter.get_low_bit_count();\n+\n+        // add padding\n+        self.input_byte(128u8);\n+\n+        while self.input_buffer_idx != 0 {\n+            self.input_byte(0u8);\n+        }\n+\n+        // add length\n+        if (self.W_idx > 14) {\n+            for uint::range(self.W_idx, 16) |_| {\n+                self.process_word(0);\n+            }\n+        }\n+\n+        while self.W_idx < 14 {\n+            self.process_word(0);\n+        }\n+\n+        self.process_word(high_bit_count);\n+        self.process_word(low_bit_count);\n+\n+        self.finished = true;\n+    }\n+\n+    fn result_512(&mut self, out: &mut [u8]) {\n+        self.finish();\n+\n+        from_u64(self.H0, out.mut_slice(0, 8));\n+        from_u64(self.H1, out.mut_slice(8, 16));\n+        from_u64(self.H2, out.mut_slice(16, 24));\n+        from_u64(self.H3, out.mut_slice(24, 32));\n+        from_u64(self.H4, out.mut_slice(32, 40));\n+        from_u64(self.H5, out.mut_slice(40, 48));\n+        from_u64(self.H6, out.mut_slice(48, 56));\n+        from_u64(self.H7, out.mut_slice(56, 64));\n+    }\n+\n+    fn result_384(&mut self, out: &mut [u8]) {\n+        self.finish();\n+\n+        from_u64(self.H0, out.mut_slice(0, 8));\n+        from_u64(self.H1, out.mut_slice(8, 16));\n+        from_u64(self.H2, out.mut_slice(16, 24));\n+        from_u64(self.H3, out.mut_slice(24, 32));\n+        from_u64(self.H4, out.mut_slice(32, 40));\n+        from_u64(self.H5, out.mut_slice(40, 48));\n+    }\n+\n+    fn result_256(&mut self, out: &mut [u8]) {\n+        self.finish();\n+\n+        from_u64(self.H0, out.mut_slice(0, 8));\n+        from_u64(self.H1, out.mut_slice(8, 16));\n+        from_u64(self.H2, out.mut_slice(16, 24));\n+        from_u64(self.H3, out.mut_slice(24, 32));\n+    }\n+\n+    fn result_224(&mut self, out: &mut [u8]) {\n+        self.finish();\n+\n+        from_u64(self.H0, out.mut_slice(0, 8));\n+        from_u64(self.H1, out.mut_slice(8, 16));\n+        from_u64(self.H2, out.mut_slice(16, 24));\n+        from_u32((self.H3 >> 32) as u32, out.mut_slice(24, 28));\n+    }\n+}\n+\n+// Constants necessary for SHA-2 512 family of digests.\n+static K64: [u64, ..80] = [\n+    0x428a2f98d728ae22u64, 0x7137449123ef65cdu64, 0xb5c0fbcfec4d3b2fu64, 0xe9b5dba58189dbbcu64,\n+    0x3956c25bf348b538u64, 0x59f111f1b605d019u64, 0x923f82a4af194f9bu64, 0xab1c5ed5da6d8118u64,\n+    0xd807aa98a3030242u64, 0x12835b0145706fbeu64, 0x243185be4ee4b28cu64, 0x550c7dc3d5ffb4e2u64,\n+    0x72be5d74f27b896fu64, 0x80deb1fe3b1696b1u64, 0x9bdc06a725c71235u64, 0xc19bf174cf692694u64,\n+    0xe49b69c19ef14ad2u64, 0xefbe4786384f25e3u64, 0x0fc19dc68b8cd5b5u64, 0x240ca1cc77ac9c65u64,\n+    0x2de92c6f592b0275u64, 0x4a7484aa6ea6e483u64, 0x5cb0a9dcbd41fbd4u64, 0x76f988da831153b5u64,\n+    0x983e5152ee66dfabu64, 0xa831c66d2db43210u64, 0xb00327c898fb213fu64, 0xbf597fc7beef0ee4u64,\n+    0xc6e00bf33da88fc2u64, 0xd5a79147930aa725u64, 0x06ca6351e003826fu64, 0x142929670a0e6e70u64,\n+    0x27b70a8546d22ffcu64, 0x2e1b21385c26c926u64, 0x4d2c6dfc5ac42aedu64, 0x53380d139d95b3dfu64,\n+    0x650a73548baf63deu64, 0x766a0abb3c77b2a8u64, 0x81c2c92e47edaee6u64, 0x92722c851482353bu64,\n+    0xa2bfe8a14cf10364u64, 0xa81a664bbc423001u64, 0xc24b8b70d0f89791u64, 0xc76c51a30654be30u64,\n+    0xd192e819d6ef5218u64, 0xd69906245565a910u64, 0xf40e35855771202au64, 0x106aa07032bbd1b8u64,\n+    0x19a4c116b8d2d0c8u64, 0x1e376c085141ab53u64, 0x2748774cdf8eeb99u64, 0x34b0bcb5e19b48a8u64,\n+    0x391c0cb3c5c95a63u64, 0x4ed8aa4ae3418acbu64, 0x5b9cca4f7763e373u64, 0x682e6ff3d6b2b8a3u64,\n+    0x748f82ee5defb2fcu64, 0x78a5636f43172f60u64, 0x84c87814a1f0ab72u64, 0x8cc702081a6439ecu64,\n+    0x90befffa23631e28u64, 0xa4506cebde82bde9u64, 0xbef9a3f7b2c67915u64, 0xc67178f2e372532bu64,\n+    0xca273eceea26619cu64, 0xd186b8c721c0c207u64, 0xeada7dd6cde0eb1eu64, 0xf57d4f7fee6ed178u64,\n+    0x06f067aa72176fbau64, 0x0a637dc5a2c898a6u64, 0x113f9804bef90daeu64, 0x1b710b35131c471bu64,\n+    0x28db77f523047d84u64, 0x32caab7b40c72493u64, 0x3c9ebe0a15c9bebcu64, 0x431d67c49c100d4cu64,\n+    0x4cc5d4becb3e42b6u64, 0x597f299cfc657e2au64, 0x5fcb6fab3ad6faecu64, 0x6c44198c4a475817u64\n+];\n+\n+// A structure that represents that state of a digest computation\n+// for the SHA-2 256 family of digest functions\n+struct Engine256 {\n+    input_buffer: [u8, ..4],\n+    input_buffer_idx: uint,\n+    length_bytes: u64,\n+    H0: u32,\n+    H1: u32,\n+    H2: u32,\n+    H3: u32,\n+    H4: u32,\n+    H5: u32,\n+    H6: u32,\n+    H7: u32,\n+    W: [u32, ..64],\n+    W_idx: uint,\n+    finished: bool\n+}\n+\n+// Convert a [u8] to a u32 in big endian format\n+fn to_u32(in: &[u8]) -> u32 {\n+    (in[0] as u32) << 24 |\n+    (in[1] as u32) << 16 |\n+    (in[2] as u32) << 8 |\n+    (in[3] as u32)\n+}\n+\n+// Convert a u32 to a [u8] in big endian format\n+fn from_u32(in: u32, out: &mut [u8]) {\n+    out[0] = (in >> 24) as u8;\n+    out[1] = (in >> 16) as u8;\n+    out[2] = (in >> 8) as u8;\n+    out[3] = in as u8;\n+}\n+\n+impl Engine256 {\n+    fn input_byte(&mut self, in: u8) {\n+        assert!(!self.finished)\n+\n+        self.input_buffer[self.input_buffer_idx] = in;\n+        self.input_buffer_idx += 1;\n+\n+        if (self.input_buffer_idx == 4) {\n+            self.input_buffer_idx = 0;\n+            let w = to_u32(self.input_buffer);\n+            self.process_word(w);\n+        }\n+\n+        self.length_bytes += 1;\n+    }\n+\n+    fn input_vec(&mut self, in: &[u8]) {\n+        assert!(!self.finished)\n+\n+        let mut i = 0;\n+\n+        while i < in.len() && self.input_buffer_idx != 0 {\n+            self.input_byte(in[i]);\n+            i += 1;\n+        }\n+\n+        while in.len() - i >= 4 {\n+            let w = to_u32(in.slice(i, i + 4));\n+            self.process_word(w);\n+            self.length_bytes += 4;\n+            i += 4;\n+        }\n+\n+        while i < in.len() {\n+            self.input_byte(in[i]);\n+            i += 1;\n+        }\n+\n+    }\n+\n+    fn reset(&mut self) {\n+        self.length_bytes = 0;\n+        self.finished = false;\n+        self.input_buffer_idx = 0;\n+        self.W_idx = 0;\n+    }\n+\n+    fn process_word(&mut self, in: u32) {\n+        self.W[self.W_idx] = in;\n+        self.W_idx += 1;\n+        if (self.W_idx == 16) {\n+            self.W_idx = 0;\n+            self.process_block();\n+        }\n+    }\n+\n+    fn process_block(&mut self) {\n+        fn ch(x: u32, y: u32, z: u32) -> u32 {\n+            ((x & y) ^ ((!x) & z))\n+        }\n+\n+        fn maj(x: u32, y: u32, z: u32) -> u32 {\n+            ((x & y) ^ (x & z) ^ (y & z))\n+        }\n+\n+        fn sum0(x: u32) -> u32 {\n+            ((x >> 2) | (x << 30)) ^ ((x >> 13) | (x << 19)) ^ ((x >> 22) | (x << 10))\n+        }\n+\n+        fn sum1(x: u32) -> u32 {\n+            ((x >> 6) | (x << 26)) ^ ((x >> 11) | (x << 21)) ^ ((x >> 25) | (x << 7))\n+        }\n+\n+        fn sigma0(x: u32) -> u32 {\n+            ((x >> 7) | (x << 25)) ^ ((x >> 18) | (x << 14)) ^ (x >> 3)\n+        }\n+\n+        fn sigma1(x: u32) -> u32 {\n+            ((x >> 17) | (x << 15)) ^ ((x >> 19) | (x << 13)) ^ (x >> 10)\n+        }\n+\n+        for uint::range(16, 64) |t| {\n+            self.W[t] = sigma1(self.W[t - 2]) + self.W[t - 7] + sigma0(self.W[t - 15]) +\n+                self.W[t - 16];\n+        }\n+\n+        let mut a = self.H0;\n+        let mut b = self.H1;\n+        let mut c = self.H2;\n+        let mut d = self.H3;\n+        let mut e = self.H4;\n+        let mut f = self.H5;\n+        let mut g = self.H6;\n+        let mut h = self.H7;\n+\n+        let mut t = 0;\n+        for uint::range(0, 8) |_| {\n+            h += sum1(e) + ch(e, f, g) + K32[t] + self.W[t];\n+            d += h;\n+            h += sum0(a) + maj(a, b, c);\n+            t += 1;\n+\n+            g += sum1(d) + ch(d, e, f) + K32[t] + self.W[t];\n+            c += g;\n+            g += sum0(h) + maj(h, a, b);\n+            t += 1;\n+\n+            f += sum1(c) + ch(c, d, e) + K32[t] + self.W[t];\n+            b += f;\n+            f += sum0(g) + maj(g, h, a);\n+            t += 1;\n+\n+            e += sum1(b) + ch(b, c, d) + K32[t] + self.W[t];\n+            a += e;\n+            e += sum0(f) + maj(f, g, h);\n+            t += 1;\n+\n+            d += sum1(a) + ch(a, b, c) + K32[t] + self.W[t];\n+            h += d;\n+            d += sum0(e) + maj(e, f, g);\n+            t += 1;\n+\n+            c += sum1(h) + ch(h, a, b) + K32[t] + self.W[t];\n+            g += c;\n+            c += sum0(d) + maj(d, e, f);\n+            t += 1;\n+\n+            b += sum1(g) + ch(g, h, a) + K32[t] + self.W[t];\n+            f += b;\n+            b += sum0(c) + maj(c, d, e);\n+            t += 1;\n+\n+            a += sum1(f) + ch(f, g, h) + K32[t] + self.W[t];\n+            e += a;\n+            a += sum0(b) + maj(b, c, d);\n+            t += 1;\n+        }\n+\n+        self.H0 += a;\n+        self.H1 += b;\n+        self.H2 += c;\n+        self.H3 += d;\n+        self.H4 += e;\n+        self.H5 += f;\n+        self.H6 += g;\n+        self.H7 += h;\n+    }\n+\n+    fn finish(&mut self) {\n+        if (self.finished) {\n+            return;\n+        }\n+\n+        // must get length before adding padding\n+        let bit_length = self.length_bytes << 3;\n+\n+        // add padding\n+        self.input_byte(128u8);\n+\n+        while self.input_buffer_idx != 0 {\n+            self.input_byte(0u8);\n+        }\n+\n+        // add length\n+        if (self.W_idx > 14) {\n+            for uint::range(self.W_idx, 16) |_| {\n+                self.process_word(0);\n+            }\n+        }\n+\n+        while self.W_idx < 14 {\n+            self.process_word(0);\n+        }\n+\n+        self.process_word((bit_length >> 32) as u32);\n+        self.process_word(bit_length as u32);\n+\n+        self.finished = true;\n+    }\n+\n+    fn result_256(&mut self, out: &mut [u8]) {\n+        self.finish();\n+\n+        from_u32(self.H0, out.mut_slice(0, 4));\n+        from_u32(self.H1, out.mut_slice(4, 8));\n+        from_u32(self.H2, out.mut_slice(8, 12));\n+        from_u32(self.H3, out.mut_slice(12, 16));\n+        from_u32(self.H4, out.mut_slice(16, 20));\n+        from_u32(self.H5, out.mut_slice(20, 24));\n+        from_u32(self.H6, out.mut_slice(24, 28));\n+        from_u32(self.H7, out.mut_slice(28, 32));\n+    }\n+\n+    fn result_224(&mut self, out: &mut [u8]) {\n+        self.finish();\n+\n+        from_u32(self.H0, out.mut_slice(0, 4));\n+        from_u32(self.H1, out.mut_slice(4, 8));\n+        from_u32(self.H2, out.mut_slice(8, 12));\n+        from_u32(self.H3, out.mut_slice(12, 16));\n+        from_u32(self.H4, out.mut_slice(16, 20));\n+        from_u32(self.H5, out.mut_slice(20, 24));\n+        from_u32(self.H6, out.mut_slice(24, 28));\n+    }\n+}\n+\n+static K32: [u32, ..64] = [\n+    0x428a2f98u32, 0x71374491u32, 0xb5c0fbcfu32, 0xe9b5dba5u32,\n+    0x3956c25bu32, 0x59f111f1u32, 0x923f82a4u32, 0xab1c5ed5u32,\n+    0xd807aa98u32, 0x12835b01u32, 0x243185beu32, 0x550c7dc3u32,\n+    0x72be5d74u32, 0x80deb1feu32, 0x9bdc06a7u32, 0xc19bf174u32,\n+    0xe49b69c1u32, 0xefbe4786u32, 0x0fc19dc6u32, 0x240ca1ccu32,\n+    0x2de92c6fu32, 0x4a7484aau32, 0x5cb0a9dcu32, 0x76f988dau32,\n+    0x983e5152u32, 0xa831c66du32, 0xb00327c8u32, 0xbf597fc7u32,\n+    0xc6e00bf3u32, 0xd5a79147u32, 0x06ca6351u32, 0x14292967u32,\n+    0x27b70a85u32, 0x2e1b2138u32, 0x4d2c6dfcu32, 0x53380d13u32,\n+    0x650a7354u32, 0x766a0abbu32, 0x81c2c92eu32, 0x92722c85u32,\n+    0xa2bfe8a1u32, 0xa81a664bu32, 0xc24b8b70u32, 0xc76c51a3u32,\n+    0xd192e819u32, 0xd6990624u32, 0xf40e3585u32, 0x106aa070u32,\n+    0x19a4c116u32, 0x1e376c08u32, 0x2748774cu32, 0x34b0bcb5u32,\n+    0x391c0cb3u32, 0x4ed8aa4au32, 0x5b9cca4fu32, 0x682e6ff3u32,\n+    0x748f82eeu32, 0x78a5636fu32, 0x84c87814u32, 0x8cc70208u32,\n+    0x90befffau32, 0xa4506cebu32, 0xbef9a3f7u32, 0xc67178f2u32\n+];\n+\n+struct Sha512 {\n+    priv engine: Engine512\n+}\n+\n+struct Sha384 {\n+    priv engine: Engine512\n+}\n+\n+struct Sha512Trunc256 {\n+    priv engine: Engine512\n+}\n+\n+struct Sha512Trunc224 {\n+    priv engine: Engine512\n+}\n+\n+struct Sha256 {\n+    priv engine: Engine256\n+}\n+\n+struct Sha224 {\n+    priv engine: Engine256\n+}\n+\n+impl Sha512 {\n+    /**\n+     * Construct an new instance of a SHA-512 digest.\n+     */\n+    pub fn new() -> Sha512 {\n+        Sha512 {\n+            engine: Engine512 {\n+                input_buffer: [0u8, ..8],\n+                input_buffer_idx: 0,\n+                bit_counter: BitCounter { high_bit_count: 0, low_byte_count: 0 },\n+                H0: 0x6a09e667f3bcc908u64,\n+                H1: 0xbb67ae8584caa73bu64,\n+                H2: 0x3c6ef372fe94f82bu64,\n+                H3: 0xa54ff53a5f1d36f1u64,\n+                H4: 0x510e527fade682d1u64,\n+                H5: 0x9b05688c2b3e6c1fu64,\n+                H6: 0x1f83d9abfb41bd6bu64,\n+                H7: 0x5be0cd19137e2179u64,\n+                W: [0u64, ..80],\n+                W_idx: 0,\n+                finished: false,\n+            }\n+        }\n+    }\n+}\n+\n+impl Sha384 {\n+    /**\n+     * Construct an new instance of a SHA-384 digest.\n+     */\n+    pub fn new() -> Sha384 {\n+        Sha384 {\n+            engine: Engine512 {\n+                input_buffer: [0u8, ..8],\n+                input_buffer_idx: 0,\n+                bit_counter: BitCounter { high_bit_count: 0, low_byte_count: 0 },\n+                H0: 0xcbbb9d5dc1059ed8u64,\n+                H1: 0x629a292a367cd507u64,\n+                H2: 0x9159015a3070dd17u64,\n+                H3: 0x152fecd8f70e5939u64,\n+                H4: 0x67332667ffc00b31u64,\n+                H5: 0x8eb44a8768581511u64,\n+                H6: 0xdb0c2e0d64f98fa7u64,\n+                H7: 0x47b5481dbefa4fa4u64,\n+                W: [0u64, ..80],\n+                W_idx: 0,\n+                finished: false,\n+            }\n+        }\n+    }\n+}\n+\n+impl Sha512Trunc256 {\n+    /**\n+     * Construct an new instance of a SHA-512/256 digest.\n+     */\n+    pub fn new() -> Sha512Trunc256 {\n+        Sha512Trunc256 {\n+            engine: Engine512 {\n+                input_buffer: [0u8, ..8],\n+                input_buffer_idx: 0,\n+                bit_counter: BitCounter { high_bit_count: 0, low_byte_count: 0 },\n+                H0: 0x22312194fc2bf72cu64,\n+                H1: 0x9f555fa3c84c64c2u64,\n+                H2: 0x2393b86b6f53b151u64,\n+                H3: 0x963877195940eabdu64,\n+                H4: 0x96283ee2a88effe3u64,\n+                H5: 0xbe5e1e2553863992u64,\n+                H6: 0x2b0199fc2c85b8aau64,\n+                H7: 0x0eb72ddc81c52ca2u64,\n+                W: [0u64, ..80],\n+                W_idx: 0,\n+                finished: false,\n+            }\n+        }\n+    }\n+}\n+\n+impl Sha512Trunc224 {\n+    /**\n+     * Construct an new instance of a SHA-512/224 digest.\n+     */\n+    pub fn new() -> Sha512Trunc224 {\n+        Sha512Trunc224 {\n+            engine: Engine512 {\n+                input_buffer: [0u8, ..8],\n+                input_buffer_idx: 0,\n+                bit_counter: BitCounter { high_bit_count: 0, low_byte_count: 0 },\n+                H0: 0x8c3d37c819544da2u64,\n+                H1: 0x73e1996689dcd4d6u64,\n+                H2: 0x1dfab7ae32ff9c82u64,\n+                H3: 0x679dd514582f9fcfu64,\n+                H4: 0x0f6d2b697bd44da8u64,\n+                H5: 0x77e36f7304c48942u64,\n+                H6: 0x3f9d85a86a1d36c8u64,\n+                H7: 0x1112e6ad91d692a1u64,\n+                W: [0u64, ..80],\n+                W_idx: 0,\n+                finished: false,\n+            }\n+        }\n+    }\n+}\n+\n+impl Sha256 {\n+    /**\n+     * Construct an new instance of a SHA-256 digest.\n+     */\n+    pub fn new() -> Sha256 {\n+        Sha256 {\n+            engine: Engine256 {\n+                input_buffer: [0u8, ..4],\n+                input_buffer_idx: 0,\n+                length_bytes: 0,\n+                H0: 0x6a09e667u32,\n+                H1: 0xbb67ae85u32,\n+                H2: 0x3c6ef372u32,\n+                H3: 0xa54ff53au32,\n+                H4: 0x510e527fu32,\n+                H5: 0x9b05688cu32,\n+                H6: 0x1f83d9abu32,\n+                H7: 0x5be0cd19u32,\n+                W: [0u32, ..64],\n+                W_idx: 0,\n+                finished: false,\n+            }\n+        }\n+    }\n+}\n+\n+impl Sha224 {\n+    /**\n+     * Construct an new instance of a SHA-224 digest.\n+     */\n+    pub fn new() -> Sha224 {\n+        Sha224 {\n+            engine: Engine256 {\n+                input_buffer: [0u8, ..4],\n+                input_buffer_idx: 0,\n+                length_bytes: 0,\n+                H0: 0xc1059ed8u32,\n+                H1: 0x367cd507u32,\n+                H2: 0x3070dd17u32,\n+                H3: 0xf70e5939u32,\n+                H4: 0xffc00b31u32,\n+                H5: 0x68581511u32,\n+                H6: 0x64f98fa7u32,\n+                H7: 0xbefa4fa4u32,\n+                W: [0u32, ..64],\n+                W_idx: 0,\n+                finished: false,\n+            }\n+        }\n+    }\n+}\n+\n+impl Digest for Sha512 {\n+    fn input(&mut self, d: &[u8]) {\n+        self.engine.input_vec(d);\n+    }\n+\n+    fn result(&mut self, out: &mut [u8]) {\n+        self.engine.result_512(out)\n+    }\n+\n+    fn reset(&mut self) {\n+        self.engine.reset();\n+\n+        self.engine.H0 = 0x6a09e667f3bcc908u64;\n+        self.engine.H1 = 0xbb67ae8584caa73bu64;\n+        self.engine.H2 = 0x3c6ef372fe94f82bu64;\n+        self.engine.H3 = 0xa54ff53a5f1d36f1u64;\n+        self.engine.H4 = 0x510e527fade682d1u64;\n+        self.engine.H5 = 0x9b05688c2b3e6c1fu64;\n+        self.engine.H6 = 0x1f83d9abfb41bd6bu64;\n+        self.engine.H7 = 0x5be0cd19137e2179u64;\n+    }\n+\n+    fn output_bits(&self) -> uint { 512 }\n+}\n+\n+impl Digest for Sha384 {\n+    fn input(&mut self, d: &[u8]) {\n+        self.engine.input_vec(d);\n+    }\n+\n+    fn result(&mut self, out: &mut [u8]) {\n+        self.engine.result_384(out)\n+    }\n+\n+    fn reset(&mut self) {\n+        self.engine.reset();\n+\n+        self.engine.H0 = 0xcbbb9d5dc1059ed8u64;\n+        self.engine.H1 = 0x629a292a367cd507u64;\n+        self.engine.H2 = 0x9159015a3070dd17u64;\n+        self.engine.H3 = 0x152fecd8f70e5939u64;\n+        self.engine.H4 = 0x67332667ffc00b31u64;\n+        self.engine.H5 = 0x8eb44a8768581511u64;\n+        self.engine.H6 = 0xdb0c2e0d64f98fa7u64;\n+        self.engine.H7 = 0x47b5481dbefa4fa4u64;\n+    }\n+\n+    fn output_bits(&self) -> uint { 384 }\n+}\n+\n+impl Digest for Sha512Trunc256 {\n+    fn input(&mut self, d: &[u8]) {\n+        self.engine.input_vec(d);\n+    }\n+\n+    fn result(&mut self, out: &mut [u8]) {\n+        self.engine.result_256(out)\n+    }\n+\n+    fn reset(&mut self) {\n+        self.engine.reset();\n+\n+        self.engine.H0 = 0x22312194fc2bf72cu64;\n+        self.engine.H1 = 0x9f555fa3c84c64c2u64;\n+        self.engine.H2 = 0x2393b86b6f53b151u64;\n+        self.engine.H3 = 0x963877195940eabdu64;\n+        self.engine.H4 = 0x96283ee2a88effe3u64;\n+        self.engine.H5 = 0xbe5e1e2553863992u64;\n+        self.engine.H6 = 0x2b0199fc2c85b8aau64;\n+        self.engine.H7 = 0x0eb72ddc81c52ca2u64;\n+    }\n+\n+    fn output_bits(&self) -> uint { 256 }\n+}\n+\n+impl Digest for Sha512Trunc224 {\n+    fn input(&mut self, d: &[u8]) {\n+        self.engine.input_vec(d);\n+    }\n+\n+    fn result(&mut self, out: &mut [u8]) {\n+        self.engine.result_224(out)\n+    }\n+\n+    fn reset(&mut self) {\n+        self.engine.reset();\n+\n+        self.engine.H0 = 0x8c3d37c819544da2u64;\n+        self.engine.H1 = 0x73e1996689dcd4d6u64;\n+        self.engine.H2 = 0x1dfab7ae32ff9c82u64;\n+        self.engine.H3 = 0x679dd514582f9fcfu64;\n+        self.engine.H4 = 0x0f6d2b697bd44da8u64;\n+        self.engine.H5 = 0x77e36f7304c48942u64;\n+        self.engine.H6 = 0x3f9d85a86a1d36c8u64;\n+        self.engine.H7 = 0x1112e6ad91d692a1u64;\n+    }\n+\n+    fn output_bits(&self) -> uint { 224 }\n+}\n+\n+impl Digest for Sha256 {\n+    fn input(&mut self, d: &[u8]) {\n+        self.engine.input_vec(d);\n+    }\n+\n+    fn result(&mut self, out: &mut [u8]) {\n+        self.engine.result_256(out)\n+    }\n+\n+    fn reset(&mut self) {\n+        self.engine.reset();\n+\n+        self.engine.H0 = 0x6a09e667u32;\n+        self.engine.H1 = 0xbb67ae85u32;\n+        self.engine.H2 = 0x3c6ef372u32;\n+        self.engine.H3 = 0xa54ff53au32;\n+        self.engine.H4 = 0x510e527fu32;\n+        self.engine.H5 = 0x9b05688cu32;\n+        self.engine.H6 = 0x1f83d9abu32;\n+        self.engine.H7 = 0x5be0cd19u32;\n+    }\n+\n+    fn output_bits(&self) -> uint { 256 }\n+}\n+\n+impl Digest for Sha224 {\n+    fn input(&mut self, d: &[u8]) {\n+        self.engine.input_vec(d);\n+    }\n+\n+    fn result(&mut self, out: &mut [u8]) {\n+        self.engine.result_224(out)\n+    }\n+\n+    fn reset(&mut self) {\n+        self.engine.reset();\n+\n+        self.engine.H0 = 0xc1059ed8u32;\n+        self.engine.H1 = 0x367cd507u32;\n+        self.engine.H2 = 0x3070dd17u32;\n+        self.engine.H3 = 0xf70e5939u32;\n+        self.engine.H4 = 0xffc00b31u32;\n+        self.engine.H5 = 0x68581511u32;\n+        self.engine.H6 = 0x64f98fa7u32;\n+        self.engine.H7 = 0xbefa4fa4u32;\n+    }\n+\n+    fn output_bits(&self) -> uint { 224 }\n+}\n+\n+\n+#[cfg(test)]\n+mod tests {\n+    use digest::{Digest, DigestUtil};\n+    use sha2::{Sha512, Sha384, Sha512Trunc256, Sha512Trunc224, Sha256, Sha224};\n+\n+    struct Test {\n+        input: ~str,\n+        output_str: ~str,\n+    }\n+\n+    fn test_hash<D: Digest>(sh: &mut D, tests: &[Test]) {\n+        // Test that it works when accepting the message all at once\n+        for tests.iter().advance() |t| {\n+            sh.input_str(t.input);\n+\n+            let out_str = sh.result_str();\n+            assert!(out_str == t.output_str);\n+\n+            sh.reset();\n+        }\n+\n+        // Test that it works when accepting the message in pieces\n+        for tests.iter().advance() |t| {\n+            let len = t.input.len();\n+            let mut left = len;\n+            while left > 0u {\n+                let take = (left + 1u) / 2u;\n+                sh.input_str(t.input.slice(len - left, take + len - left));\n+                left = left - take;\n+            }\n+\n+            let out_str = sh.result_str();\n+            assert!(out_str == t.output_str);\n+\n+            sh.reset();\n+        }\n+    }\n+\n+    #[test]\n+    fn test_sha512() {\n+        // Examples from wikipedia\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"\",\n+                output_str: ~\"cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\" +\n+                             \"47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output_str: ~\"07e547d9586f6a73f73fbac0435ed76951218fb7d0c8d788a309d785436bbb64\" +\n+                             \"2e93a252a954f23912547d1e8a3b5ed6e1bfd7097821233fa0538f3db854fee6\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog.\",\n+                output_str: ~\"91ea1245f20d46ae9a037a989f54f1f790f0a47607eeb8a14d12890cea77a1bb\" +\n+                             \"c6c7ed9cf205e67b7f2b8fd4c7dfd3a7a8617e45f3c463d481c7e586c39ac1ed\"\n+            },\n+        ];\n+\n+        let tests = wikipedia_tests;\n+\n+        let mut sh = ~Sha512::new();\n+\n+        test_hash(sh, tests);\n+    }\n+\n+    #[test]\n+    fn test_sha384() {\n+        // Examples from wikipedia\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"\",\n+                output_str: ~\"38b060a751ac96384cd9327eb1b1e36a21fdb71114be0743\" +\n+                             \"4c0cc7bf63f6e1da274edebfe76f65fbd51ad2f14898b95b\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output_str: ~\"ca737f1014a48f4c0b6dd43cb177b0afd9e5169367544c49\" +\n+                             \"4011e3317dbf9a509cb1e5dc1e85a941bbee3d7f2afbc9b1\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog.\",\n+                output_str: ~\"ed892481d8272ca6df370bf706e4d7bc1b5739fa2177aae6\" +\n+                             \"c50e946678718fc67a7af2819a021c2fc34e91bdb63409d7\"\n+            },\n+        ];\n+\n+        let tests = wikipedia_tests;\n+\n+        let mut sh = ~Sha384::new();\n+\n+        test_hash(sh, tests);\n+    }\n+\n+    #[test]\n+    fn test_sha512_256() {\n+        // Examples from wikipedia\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"\",\n+                output_str: ~\"c672b8d1ef56ed28ab87c3622c5114069bdd3ad7b8f9737498d0c01ecef0967a\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output_str: ~\"dd9d67b371519c339ed8dbd25af90e976a1eeefd4ad3d889005e532fc5bef04d\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog.\",\n+                output_str: ~\"1546741840f8a492b959d9b8b2344b9b0eb51b004bba35c0aebaac86d45264c3\"\n+            },\n+        ];\n+\n+        let tests = wikipedia_tests;\n+\n+        let mut sh = ~Sha512Trunc256::new();\n+\n+        test_hash(sh, tests);\n+    }\n+\n+    #[test]\n+    fn test_sha512_224() {\n+        // Examples from wikipedia\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"\",\n+                output_str: ~\"6ed0dd02806fa89e25de060c19d3ac86cabb87d6a0ddd05c333b84f4\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output_str: ~\"944cd2847fb54558d4775db0485a50003111c8e5daa63fe722c6aa37\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog.\",\n+                output_str: ~\"6d6a9279495ec4061769752e7ff9c68b6b0b3c5a281b7917ce0572de\"\n+            },\n+        ];\n+\n+        let tests = wikipedia_tests;\n+\n+        let mut sh = ~Sha512Trunc224::new();\n+\n+        test_hash(sh, tests);\n+    }\n+\n+    #[test]\n+    fn test_sha256() {\n+        // Examples from wikipedia\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"\",\n+                output_str: ~\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output_str: ~\"d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog.\",\n+                output_str: ~\"ef537f25c895bfa782526529a9b63d97aa631564d5d789c2b765448c8635fb6c\"\n+            },\n+        ];\n+\n+        let tests = wikipedia_tests;\n+\n+        let mut sh = ~Sha256::new();\n+\n+        test_hash(sh, tests);\n+    }\n+\n+    #[test]\n+    fn test_sha224() {\n+        // Examples from wikipedia\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"\",\n+                output_str: ~\"d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output_str: ~\"730e109bd7a8a32b1cb9d9a09aa2325d2430587ddbc0c38bad911525\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog.\",\n+                output_str: ~\"619cba8e8e05826e9b8c519c0a5c68f4fb653e8a3d8aa04bb2c8cd4c\"\n+            },\n+        ];\n+\n+        let tests = wikipedia_tests;\n+\n+        let mut sh = ~Sha224::new();\n+\n+        test_hash(sh, tests);\n+    }\n+}"}, {"sha": "1f424b23430c3b1fb0e028f4a3d96bdf4640d3c9", "filename": "src/libextra/dbg.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdbg.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -12,57 +12,63 @@\n \n #[allow(missing_doc)];\n \n-use core::cast::transmute;\n-use core::sys;\n+use std::cast::transmute;\n+#[cfg(stage0)]\n+use intrinsic::{get_tydesc};\n+#[cfg(not(stage0))]\n+use std::unstable::intrinsics::{get_tydesc};\n \n pub mod rustrt {\n-    use core::sys;\n+    #[cfg(stage0)]\n+    use intrinsic::{TyDesc};\n+    #[cfg(not(stage0))]\n+    use std::unstable::intrinsics::{TyDesc};\n \n     #[abi = \"cdecl\"]\n     pub extern {\n-        pub unsafe fn debug_tydesc(td: *sys::TypeDesc);\n-        pub unsafe fn debug_opaque(td: *sys::TypeDesc, x: *());\n-        pub unsafe fn debug_box(td: *sys::TypeDesc, x: *());\n-        pub unsafe fn debug_tag(td: *sys::TypeDesc, x: *());\n-        pub unsafe fn debug_fn(td: *sys::TypeDesc, x: *());\n-        pub unsafe fn debug_ptrcast(td: *sys::TypeDesc, x: *()) -> *();\n+        pub unsafe fn debug_tydesc(td: *TyDesc);\n+        pub unsafe fn debug_opaque(td: *TyDesc, x: *());\n+        pub unsafe fn debug_box(td: *TyDesc, x: *());\n+        pub unsafe fn debug_tag(td: *TyDesc, x: *());\n+        pub unsafe fn debug_fn(td: *TyDesc, x: *());\n+        pub unsafe fn debug_ptrcast(td: *TyDesc, x: *()) -> *();\n         pub unsafe fn rust_dbg_breakpoint();\n     }\n }\n \n pub fn debug_tydesc<T>() {\n     unsafe {\n-        rustrt::debug_tydesc(sys::get_type_desc::<T>());\n+        rustrt::debug_tydesc(get_tydesc::<T>());\n     }\n }\n \n pub fn debug_opaque<T>(x: T) {\n     unsafe {\n-        rustrt::debug_opaque(sys::get_type_desc::<T>(), transmute(&x));\n+        rustrt::debug_opaque(get_tydesc::<T>(), transmute(&x));\n     }\n }\n \n pub fn debug_box<T>(x: @T) {\n     unsafe {\n-        rustrt::debug_box(sys::get_type_desc::<T>(), transmute(&x));\n+        rustrt::debug_box(get_tydesc::<T>(), transmute(&x));\n     }\n }\n \n pub fn debug_tag<T>(x: T) {\n     unsafe {\n-        rustrt::debug_tag(sys::get_type_desc::<T>(), transmute(&x));\n+        rustrt::debug_tag(get_tydesc::<T>(), transmute(&x));\n     }\n }\n \n pub fn debug_fn<T>(x: T) {\n     unsafe {\n-        rustrt::debug_fn(sys::get_type_desc::<T>(), transmute(&x));\n+        rustrt::debug_fn(get_tydesc::<T>(), transmute(&x));\n     }\n }\n \n pub unsafe fn ptr_cast<T, U>(x: @T) -> @U {\n     transmute(\n-        rustrt::debug_ptrcast(sys::get_type_desc::<T>(), transmute(x)))\n+        rustrt::debug_ptrcast(get_tydesc::<T>(), transmute(x)))\n }\n \n /// Triggers a debugger breakpoint"}, {"sha": "f834860a4f7085cb64838900ce670b6abc5f0f51", "filename": "src/libextra/deque.rs", "status": "modified", "additions": 122, "deletions": 18, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdeque.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -10,11 +10,10 @@\n \n //! A double-ended queue implemented as a circular buffer\n \n-use core::prelude::*;\n-\n-use core::uint;\n-use core::util::replace;\n-use core::vec;\n+use std::uint;\n+use std::util::replace;\n+use std::vec;\n+use std::cast::transmute;\n \n static initial_capacity: uint = 32u; // 2^5\n \n@@ -28,10 +27,10 @@ pub struct Deque<T> {\n \n impl<T> Container for Deque<T> {\n     /// Return the number of elements in the deque\n-    fn len(&const self) -> uint { self.nelts }\n+    fn len(&self) -> uint { self.nelts }\n \n     /// Return true if the deque contains no elements\n-    fn is_empty(&const self) -> bool { self.len() == 0 }\n+    fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n impl<T> Mutable for Deque<T> {\n@@ -137,7 +136,7 @@ impl<T> Deque<T> {\n     ///\n     /// * n - The number of elements to reserve space for\n     pub fn reserve(&mut self, n: uint) {\n-        vec::reserve(&mut self.elts, n);\n+        self.elts.reserve(n);\n     }\n \n     /// Reserve capacity for at least `n` elements in the given deque,\n@@ -151,10 +150,89 @@ impl<T> Deque<T> {\n     ///\n     /// * n - The number of elements to reserve space for\n     pub fn reserve_at_least(&mut self, n: uint) {\n-        vec::reserve_at_least(&mut self.elts, n);\n+        self.elts.reserve_at_least(n);\n+    }\n+\n+    /// Front-to-back iterator.\n+    pub fn iter<'a>(&'a self) -> DequeIterator<'a, T> {\n+    DequeIterator { idx: self.lo, nelts: self.nelts, used: 0, vec: self.elts }\n+    }\n+\n+    /// Front-to-back iterator which returns mutable values.\n+    pub fn mut_iter<'a>(&'a mut self) -> DequeMutIterator<'a, T> {\n+    DequeMutIterator { idx: self.lo, nelts: self.nelts, used: 0, vec: self.elts }\n+    }\n+\n+    /// Back-to-front iterator.\n+    pub fn rev_iter<'a>(&'a self) -> DequeRevIterator<'a, T> {\n+    DequeRevIterator { idx: self.hi - 1u, nelts: self.nelts, used: 0, vec: self.elts }\n+    }\n+\n+    /// Back-to-front iterator which returns mutable values.\n+    pub fn mut_rev_iter<'a>(&'a mut self) -> DequeMutRevIterator<'a, T> {\n+    DequeMutRevIterator { idx: self.hi - 1u, nelts: self.nelts, used: 0, vec: self.elts }\n+    }\n+}\n+\n+macro_rules! iterator {\n+    (impl $name:ident -> $elem:ty, $step:expr) => {\n+        impl<'self, T> Iterator<$elem> for $name<'self, T> {\n+            #[inline]\n+            fn next(&mut self) -> Option<$elem> {\n+                if self.used >= self.nelts {\n+                    return None;\n+                }\n+                let ret = unsafe {\n+                    match self.vec[self.idx % self.vec.len()] {\n+                        Some(ref e) => Some(transmute(e)),\n+                        None => None\n+                    }\n+                };\n+                self.idx += $step;\n+                self.used += 1;\n+                ret\n+            }\n+        }\n     }\n }\n \n+/// Deque iterator\n+pub struct DequeIterator<'self, T> {\n+    priv idx: uint,\n+    priv nelts: uint,\n+    priv used: uint,\n+    priv vec: &'self [Option<T>]\n+}\n+iterator!{impl DequeIterator -> &'self T, 1}\n+\n+/// Deque reverse iterator\n+pub struct DequeRevIterator<'self, T> {\n+    priv idx: uint,\n+    priv nelts: uint,\n+    priv used: uint,\n+    priv vec: &'self [Option<T>]\n+}\n+iterator!{impl DequeRevIterator -> &'self T, -1}\n+\n+/// Deque mutable iterator\n+pub struct DequeMutIterator<'self, T> {\n+    priv idx: uint,\n+    priv nelts: uint,\n+    priv used: uint,\n+    priv vec: &'self mut [Option<T>]\n+\n+}\n+iterator!{impl DequeMutIterator -> &'self mut T, 1}\n+\n+/// Deque mutable reverse iterator\n+pub struct DequeMutRevIterator<'self, T> {\n+    priv idx: uint,\n+    priv nelts: uint,\n+    priv used: uint,\n+    priv vec: &'self mut [Option<T>]\n+}\n+iterator!{impl DequeMutRevIterator -> &'self mut T, -1}\n+\n /// Grow is only called on full elts, so nelts is also len(elts), unlike\n /// elsewhere.\n fn grow<T>(nelts: uint, lo: uint, elts: &mut [Option<T>]) -> ~[Option<T>] {\n@@ -175,9 +253,9 @@ fn get<'r, T>(elts: &'r [Option<T>], i: uint) -> &'r T {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use core::cmp::Eq;\n-    use core::kinds::Copy;\n-    use core::vec::capacity;\n+    use std::cmp::Eq;\n+    use std::kinds::Copy;\n+    use std::int;\n \n     #[test]\n     fn test_simple() {\n@@ -318,8 +396,7 @@ mod tests {\n \n     #[test]\n     fn test_param_taggy() {\n-        test_parameterized::<Taggy>(One(1), Two(1, 2), Three(1, 2, 3),\n-                                    Two(17, 42));\n+        test_parameterized::<Taggy>(One(1), Two(1, 2), Three(1, 2, 3), Two(17, 42));\n     }\n \n     #[test]\n@@ -363,23 +440,50 @@ mod tests {\n         let mut d = Deque::new();\n         d.add_back(0u64);\n         d.reserve(50);\n-        assert_eq!(capacity(&mut d.elts), 50);\n+        assert_eq!(d.elts.capacity(), 50);\n         let mut d = Deque::new();\n         d.add_back(0u32);\n         d.reserve(50);\n-        assert_eq!(capacity(&mut d.elts), 50);\n+        assert_eq!(d.elts.capacity(), 50);\n     }\n \n     #[test]\n     fn test_reserve_at_least() {\n         let mut d = Deque::new();\n         d.add_back(0u64);\n         d.reserve_at_least(50);\n-        assert_eq!(capacity(&mut d.elts), 64);\n+        assert_eq!(d.elts.capacity(), 64);\n         let mut d = Deque::new();\n         d.add_back(0u32);\n         d.reserve_at_least(50);\n-        assert_eq!(capacity(&mut d.elts), 64);\n+        assert_eq!(d.elts.capacity(), 64);\n     }\n \n+    #[test]\n+    fn test_iter() {\n+        let mut d = Deque::new();\n+        for int::range(0,5) |i| {\n+            d.add_back(i);\n+        }\n+        assert_eq!(d.iter().collect::<~[&int]>(), ~[&0,&1,&2,&3,&4]);\n+\n+        for int::range(6,9) |i| {\n+            d.add_front(i);\n+        }\n+        assert_eq!(d.iter().collect::<~[&int]>(), ~[&8,&7,&6,&0,&1,&2,&3,&4]);\n+    }\n+\n+    #[test]\n+    fn test_rev_iter() {\n+        let mut d = Deque::new();\n+        for int::range(0,5) |i| {\n+            d.add_back(i);\n+        }\n+        assert_eq!(d.rev_iter().collect::<~[&int]>(), ~[&4,&3,&2,&1,&0]);\n+\n+        for int::range(6,9) |i| {\n+            d.add_front(i);\n+        }\n+        assert_eq!(d.rev_iter().collect::<~[&int]>(), ~[&4,&3,&2,&1,&0,&6,&7,&8]);\n+    }\n }"}, {"sha": "e7dcb0fd7cee4cafa5e357eb16145152d82ae18c", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 37, "deletions": 63, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -18,11 +18,8 @@ Do not use ==, !=, <, etc on doubly-linked lists -- it may not terminate.\n \n */\n \n-use core::prelude::*;\n \n-use core::managed;\n-use core::old_iter;\n-use core::vec;\n+use std::managed;\n \n pub type DListLink<T> = Option<@mut DListNode<T>>;\n \n@@ -213,6 +210,42 @@ impl<T> DList<T> {\n }\n \n impl<T> DList<T> {\n+    /**\n+     * Iterates through the current contents.\n+     *\n+     * Attempts to access this dlist during iteration are allowed (to\n+     * allow for e.g. breadth-first search with in-place enqueues), but\n+     * removing the current node is forbidden.\n+     */\n+    pub fn each(@mut self, f: &fn(v: &T) -> bool) -> bool {\n+        let mut link = self.peek_n();\n+        while link.is_some() {\n+            let nobe = link.get();\n+            assert!(nobe.linked);\n+\n+            {\n+                let frozen_nobe = &*nobe;\n+                if !f(&frozen_nobe.data) { return false; }\n+            }\n+\n+            // Check (weakly) that the user didn't do a remove.\n+            if self.size == 0 {\n+                fail!(\"The dlist became empty during iteration??\")\n+            }\n+            if !nobe.linked ||\n+                (!((nobe.prev.is_some()\n+                    || managed::mut_ptr_eq(self.hd.expect(\"headless dlist?\"),\n+                                           nobe))\n+                   && (nobe.next.is_some()\n+                    || managed::mut_ptr_eq(self.tl.expect(\"tailless dlist?\"),\n+                                           nobe)))) {\n+                fail!(\"Removing a dlist node during iteration is forbidden!\")\n+            }\n+            link = nobe.next_link();\n+        }\n+        return true;\n+    }\n+\n     /// Get the size of the list. O(1).\n     pub fn len(@mut self) -> uint { self.size }\n     /// Returns true if the list is empty. O(1).\n@@ -484,67 +517,13 @@ impl<T:Copy> DList<T> {\n \n     /// Get data at the list's tail, failing if empty. O(1).\n     pub fn tail(@mut self) -> T { copy self.tail_n().data }\n-\n-    /// Get the elements of the list as a vector. O(n).\n-    pub fn to_vec(@mut self) -> ~[T] {\n-        let mut v = vec::with_capacity(self.size);\n-        for old_iter::eachi(&self) |index,data| {\n-            v[index] = copy *data;\n-        }\n-        v\n-    }\n-}\n-\n-impl<T> BaseIter<T> for @mut DList<T> {\n-    /**\n-     * Iterates through the current contents.\n-     *\n-     * Attempts to access this dlist during iteration are allowed (to\n-     * allow for e.g. breadth-first search with in-place enqueues), but\n-     * removing the current node is forbidden.\n-     */\n-    fn each(&self, f: &fn(v: &T) -> bool) -> bool {\n-        let mut link = self.peek_n();\n-        while link.is_some() {\n-            let nobe = link.get();\n-            assert!(nobe.linked);\n-\n-            {\n-                let frozen_nobe = &*nobe;\n-                if !f(&frozen_nobe.data) { return false; }\n-            }\n-\n-            // Check (weakly) that the user didn't do a remove.\n-            if self.size == 0 {\n-                fail!(\"The dlist became empty during iteration??\")\n-            }\n-            if !nobe.linked ||\n-                (!((nobe.prev.is_some()\n-                    || managed::mut_ptr_eq(self.hd.expect(\"headless dlist?\"),\n-                                           nobe))\n-                   && (nobe.next.is_some()\n-                    || managed::mut_ptr_eq(self.tl.expect(\"tailless dlist?\"),\n-                                           nobe)))) {\n-                fail!(\"Removing a dlist node during iteration is forbidden!\")\n-            }\n-            link = nobe.next_link();\n-        }\n-        return true;\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n #[cfg(test)]\n mod tests {\n-    use core::prelude::*;\n \n     use super::*;\n \n-    use core::old_iter;\n-    use core::vec;\n-\n     #[test]\n     fn test_dlist_concat() {\n         let a = from_vec([1,2]);\n@@ -759,11 +738,6 @@ mod tests {\n         assert_eq!(l.len(), 3);\n     }\n     #[test]\n-    fn test_dlist_foldl() {\n-        let l = from_vec(vec::from_fn(101, |x|x));\n-        assert_eq!(old_iter::foldl(&l, 0, |accum,elem| *accum+*elem), 5050);\n-    }\n-    #[test]\n     fn test_dlist_break_early() {\n         let l = from_vec([1,2,3,4,5]);\n         let mut x = 0;"}, {"sha": "c79b012cfc5b566212b2cd9144cfcfa96ce6e953", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -10,7 +10,8 @@\n \n #[allow(missing_doc)];\n \n-use core::prelude::*;\n+\n+use std::str;\n \n // Simple Extensible Binary Markup Language (ebml) reader and writer on a\n // cursor model. See the specification here:\n@@ -34,6 +35,20 @@ pub struct Doc {\n     end: uint,\n }\n \n+impl Doc {\n+    pub fn get(&self, tag: uint) -> Doc {\n+        reader::get_doc(*self, tag)\n+    }\n+\n+    pub fn as_str_slice<'a>(&'a self) -> &'a str {\n+        str::from_bytes_slice(self.data.slice(self.start, self.end))\n+    }\n+\n+    pub fn as_str(&self) -> ~str {\n+        self.as_str_slice().to_owned()\n+    }\n+}\n+\n pub struct TaggedDoc {\n     tag: uint,\n     doc: Doc,\n@@ -78,30 +93,20 @@ pub mod reader {\n \n     use serialize;\n \n-    use core::prelude::*;\n-    use core::cast::transmute;\n-    use core::int;\n-    use core::io;\n-    use core::ptr::offset;\n-    use core::str;\n-    use core::unstable::intrinsics::bswap32;\n-    use core::vec;\n-\n-    // ebml reading\n+    use std::cast::transmute;\n+    use std::int;\n+    use std::io;\n+    use std::option::{None, Option, Some};\n \n-    impl Doc {\n-        pub fn get(&self, tag: uint) -> Doc {\n-            get_doc(*self, tag)\n-        }\n+    #[cfg(target_arch = \"x86\")]\n+    #[cfg(target_arch = \"x86_64\")]\n+    use std::ptr::offset;\n \n-        pub fn as_str_slice<'a>(&'a self) -> &'a str {\n-            str::from_bytes_slice(self.data.slice(self.start, self.end))\n-        }\n+    #[cfg(target_arch = \"x86\")]\n+    #[cfg(target_arch = \"x86_64\")]\n+    use std::unstable::intrinsics::bswap32;\n \n-        pub fn as_str(&self) -> ~str {\n-            self.as_str_slice().to_owned()\n-        }\n-    }\n+    // ebml reading\n \n     struct Res {\n         val: uint,\n@@ -248,7 +253,7 @@ pub mod reader {\n     }\n \n     pub fn with_doc_data<T>(d: Doc, f: &fn(x: &[u8]) -> T) -> T {\n-        f(vec::slice(*d.data, d.start, d.end))\n+        f(d.data.slice(d.start, d.end))\n     }\n \n \n@@ -372,7 +377,7 @@ pub mod reader {\n         fn read_u8 (&mut self) -> u8  { doc_as_u8 (self.next_doc(EsU8 )) }\n         fn read_uint(&mut self) -> uint {\n             let v = doc_as_u64(self.next_doc(EsUint));\n-            if v > (::core::uint::max_value as u64) {\n+            if v > (::std::uint::max_value as u64) {\n                 fail!(\"uint %? too large for this architecture\", v);\n             }\n             v as uint\n@@ -605,8 +610,8 @@ pub mod reader {\n pub mod writer {\n     use super::*;\n \n-    use core::cast;\n-    use core::io;\n+    use std::cast;\n+    use std::io;\n \n     // ebml writing\n     pub struct Encoder {\n@@ -951,8 +956,8 @@ mod tests {\n     use serialize::Encodable;\n     use serialize;\n \n-    use core::io;\n-    use core::option::{None, Option, Some};\n+    use std::io;\n+    use std::option::{None, Option, Some};\n \n     #[test]\n     fn test_option_int() {"}, {"sha": "50c57b28d223551b73e71e9e835d93548161b6a8", "filename": "src/libextra/extra.rs", "status": "renamed", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -21,7 +21,7 @@ Rust extras are part of the standard Rust distribution.\n */\n \n #[link(name = \"extra\",\n-       vers = \"0.7-pre\",\n+       vers = \"0.7\",\n        uuid = \"122bed0b-c19b-4b82-b0b7-7ae8aead7297\",\n        url = \"https://github.com/mozilla/rust/tree/master/src/libextra\")];\n \n@@ -32,13 +32,9 @@ Rust extras are part of the standard Rust distribution.\n #[deny(non_camel_case_types)];\n #[deny(missing_doc)];\n \n-#[no_std];\n+use std::str::{StrSlice, OwnedStr};\n \n-extern mod core(name = \"std\", vers = \"0.7-pre\");\n-\n-use core::str::{StrSlice, OwnedStr};\n-\n-pub use core::os;\n+pub use std::os;\n \n pub mod uv_ll;\n \n@@ -86,13 +82,20 @@ pub mod sort;\n pub mod dlist;\n pub mod treemap;\n \n+// Crypto\n+#[path=\"crypto/digest.rs\"]\n+pub mod digest;\n+#[path=\"crypto/sha1.rs\"]\n+pub mod sha1;\n+#[path=\"crypto/sha2.rs\"]\n+pub mod sha2;\n+\n // And ... other stuff\n \n pub mod ebml;\n pub mod dbg;\n pub mod getopts;\n pub mod json;\n-pub mod sha1;\n pub mod md4;\n pub mod tempfile;\n pub mod term;\n@@ -128,21 +131,16 @@ pub mod serialize;\n // 'extra' so that macro-expanded references to extra::serialize and such\n // can be resolved within libextra.\n #[doc(hidden)]\n-pub mod std {\n+pub mod extra {\n     pub use serialize;\n     pub use test;\n \n     // For bootstrapping.\n-    pub use core::clone;\n-    pub use core::condition;\n-    pub use core::cmp;\n-    pub use core::sys;\n-    pub use core::unstable;\n-    pub use core::str;\n-    pub use core::os;\n-}\n-#[doc(hidden)]\n-pub mod extra {\n-    pub use serialize;\n-    pub use test;\n+    pub use std::clone;\n+    pub use std::condition;\n+    pub use std::cmp;\n+    pub use std::sys;\n+    pub use std::unstable;\n+    pub use std::str;\n+    pub use std::os;\n }", "previous_filename": "src/libextra/std.rc"}, {"sha": "f91260f475288539af5a7a6395bbe697ab3ac64a", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -57,14 +57,14 @@ For more complicated uses (e.g. if one needs to pause iteration and\n resume it later), a `FileInput` instance can be constructed via the\n `from_vec`, `from_vec_raw` and `from_args` functions.\n \n-Once created, the `each_line` (from the `core::io::ReaderUtil` trait)\n+Once created, the `each_line` (from the `std::io::ReaderUtil` trait)\n and `each_line_state` methods allow one to iterate on the lines; the\n latter provides more information about the position within the\n iteration to the caller.\n \n It is possible (and safe) to skip lines and files using the\n `read_line` and `next_file` methods. Also, `FileInput` implements\n-`core::io::Reader`, and the state will be updated correctly while\n+`std::io::Reader`, and the state will be updated correctly while\n using any of those methods.\n \n E.g. the following program reads until an empty line, pauses for user\n@@ -96,12 +96,10 @@ total line count).\n \n #[allow(missing_doc)];\n \n-use core::prelude::*;\n \n-use core::io::ReaderUtil;\n-use core::io;\n-use core::os;\n-use core::vec;\n+use std::io::ReaderUtil;\n+use std::io;\n+use std::os;\n \n /**\n A summary of the internal state of a `FileInput` object. `line_num`\n@@ -354,13 +352,13 @@ a literal `-`.\n */\n // XXX: stupid, unclear name\n pub fn pathify(vec: &[~str], stdin_hyphen : bool) -> ~[Option<Path>] {\n-    vec::map(vec, |&str : & ~str| {\n-        if stdin_hyphen && str == ~\"-\" {\n+    vec.iter().transform(|str| {\n+        if stdin_hyphen && \"-\" == *str {\n             None\n         } else {\n-            Some(Path(str))\n+            Some(Path(*str))\n         }\n-    })\n+    }).collect()\n }\n \n /**\n@@ -410,18 +408,17 @@ pub fn input_vec_state(files: ~[Option<Path>],\n \n #[cfg(test)]\n mod test {\n-    use core::prelude::*;\n \n     use super::{FileInput, pathify, input_vec, input_vec_state};\n \n-    use core::io;\n-    use core::uint;\n-    use core::vec;\n+    use std::io;\n+    use std::uint;\n+    use std::vec;\n \n     fn make_file(path : &Path, contents: &[~str]) {\n         let file = io::file_writer(path, [io::Create, io::Truncate]).get();\n \n-        for contents.each |&str| {\n+        for contents.iter().advance |&str| {\n             file.write_str(str);\n             file.write_char('\\n');\n         }\n@@ -448,7 +445,7 @@ mod test {\n             |i| fmt!(\"tmp/lib-fileinput-test-fileinput-read-byte-%u.tmp\", i)), true);\n \n         // 3 files containing 0\\n, 1\\n, and 2\\n respectively\n-        for filenames.eachi |i, &filename| {\n+        for filenames.iter().enumerate().advance |(i, &filename)| {\n             make_file(filename.get_ref(), [fmt!(\"%u\", i)]);\n         }\n \n@@ -478,7 +475,7 @@ mod test {\n             |i| fmt!(\"tmp/lib-fileinput-test-fileinput-read-%u.tmp\", i)), true);\n \n         // 3 files containing 1\\n, 2\\n, and 3\\n respectively\n-        for filenames.eachi |i, &filename| {\n+        for filenames.iter().enumerate().advance |(i, &filename)| {\n             make_file(filename.get_ref(), [fmt!(\"%u\", i)]);\n         }\n \n@@ -498,7 +495,7 @@ mod test {\n             3,\n             |i| fmt!(\"tmp/lib-fileinput-test-input-vec-%u.tmp\", i)), true);\n \n-        for filenames.eachi |i, &filename| {\n+        for filenames.iter().enumerate().advance |(i, &filename)| {\n             let contents =\n                 vec::from_fn(3, |j| fmt!(\"%u %u\", i, j));\n             make_file(filename.get_ref(), contents);\n@@ -518,7 +515,7 @@ mod test {\n             3,\n             |i| fmt!(\"tmp/lib-fileinput-test-input-vec-state-%u.tmp\", i)),true);\n \n-        for filenames.eachi |i, &filename| {\n+        for filenames.iter().enumerate().advance |(i, &filename)| {\n             let contents =\n                 vec::from_fn(3, |j| fmt!(\"%u %u\", i, j + 1));\n             make_file(filename.get_ref(), contents);\n@@ -582,7 +579,7 @@ mod test {\n             3,\n             |i| fmt!(\"tmp/lib-fileinput-test-next-file-%u.tmp\", i)),true);\n \n-        for filenames.eachi |i, &filename| {\n+        for filenames.iter().enumerate().advance |(i, &filename)| {\n             let contents =\n                 vec::from_fn(3, |j| fmt!(\"%u %u\", i, j + 1));\n             make_file(&filename.get(), contents);"}, {"sha": "92f9f834f52dada5f844bdc21053d8147c7d047a", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -16,12 +16,12 @@ Simple compression\n \n #[allow(missing_doc)];\n \n-use core::libc::{c_void, size_t, c_int};\n-use core::libc;\n-use core::vec;\n+use std::libc::{c_void, size_t, c_int};\n+use std::libc;\n+use std::vec;\n \n pub mod rustrt {\n-    use core::libc::{c_int, c_void, size_t};\n+    use std::libc::{c_int, c_void, size_t};\n \n     #[link_name = \"rustrt\"]\n     pub extern {\n@@ -44,8 +44,8 @@ static lz_fast : c_int = 0x1;   // LZ with only one probe\n static lz_norm : c_int = 0x80;  // LZ with 128 probes, \"normal\"\n static lz_best : c_int = 0xfff; // LZ with 4095 probes, \"best\"\n \n-pub fn deflate_bytes(bytes: &const [u8]) -> ~[u8] {\n-    do vec::as_const_buf(bytes) |b, len| {\n+pub fn deflate_bytes(bytes: &[u8]) -> ~[u8] {\n+    do vec::as_imm_buf(bytes) |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n             let res =\n@@ -62,8 +62,8 @@ pub fn deflate_bytes(bytes: &const [u8]) -> ~[u8] {\n     }\n }\n \n-pub fn inflate_bytes(bytes: &const [u8]) -> ~[u8] {\n-    do vec::as_const_buf(bytes) |b, len| {\n+pub fn inflate_bytes(bytes: &[u8]) -> ~[u8] {\n+    do vec::as_imm_buf(bytes) |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n             let res =\n@@ -83,9 +83,8 @@ pub fn inflate_bytes(bytes: &const [u8]) -> ~[u8] {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use core::rand;\n-    use core::rand::RngUtil;\n-    use core::prelude::*;\n+    use std::rand;\n+    use std::rand::RngUtil;\n \n     #[test]\n     #[allow(non_implicitly_copyable_typarams)]"}, {"sha": "e8bdc951ca4e789f24ad23b4b1b92e31c791bdef", "filename": "src/libextra/flatpipes.rs", "status": "modified", "additions": 49, "deletions": 55, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflatpipes.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -49,14 +49,13 @@ block the scheduler thread, so will their pipes.\n \n #[allow(missing_doc)];\n \n-use core::prelude::*;\n \n // The basic send/recv interface FlatChan and PortChan will implement\n-use core::io;\n-use core::comm::GenericChan;\n-use core::comm::GenericPort;\n-use core::sys::size_of;\n-use core::vec;\n+use std::io;\n+use std::comm::GenericChan;\n+use std::comm::GenericPort;\n+use std::sys::size_of;\n+use std::vec;\n \n /**\n A FlatPort, consisting of a `BytePort` that receives byte vectors,\n@@ -95,9 +94,9 @@ pub mod serial {\n     use flatpipes::bytepipes::{PipeBytePort, PipeByteChan};\n     use flatpipes::{FlatPort, FlatChan};\n \n-    use core::io::{Reader, Writer};\n-    use core::comm::{Port, Chan};\n-    use core::comm;\n+    use std::io::{Reader, Writer};\n+    use std::comm::{Port, Chan};\n+    use std::comm;\n \n     pub type ReaderPort<T, R> = FlatPort<\n         T, DeserializingUnflattener<DefaultDecoder, T>,\n@@ -166,22 +165,21 @@ Constructors for flat pipes that send POD types using memcpy.\n \n # Safety Note\n \n-This module is currently unsafe because it uses `Copy Owned` as a type\n-parameter bounds meaning POD (plain old data), but `Copy Owned` and\n+This module is currently unsafe because it uses `Copy Send` as a type\n+parameter bounds meaning POD (plain old data), but `Copy Send` and\n POD are not equivelant.\n \n */\n pub mod pod {\n-    use core::prelude::*;\n \n     use flatpipes::flatteners::{PodUnflattener, PodFlattener};\n     use flatpipes::bytepipes::{ReaderBytePort, WriterByteChan};\n     use flatpipes::bytepipes::{PipeBytePort, PipeByteChan};\n     use flatpipes::{FlatPort, FlatChan};\n \n-    use core::io::{Reader, Writer};\n-    use core::comm::{Port, Chan};\n-    use core::comm;\n+    use std::io::{Reader, Writer};\n+    use std::comm::{Port, Chan};\n+    use std::comm;\n \n     pub type ReaderPort<T, R> =\n         FlatPort<T, PodUnflattener<T>, ReaderBytePort<R>>;\n@@ -191,7 +189,7 @@ pub mod pod {\n     pub type PipeChan<T> = FlatChan<T, PodFlattener<T>, PipeByteChan>;\n \n     /// Create a `FlatPort` from a `Reader`\n-    pub fn reader_port<T:Copy + Owned,R:Reader>(\n+    pub fn reader_port<T:Copy + Send,R:Reader>(\n         reader: R\n     ) -> ReaderPort<T, R> {\n         let unflat: PodUnflattener<T> = PodUnflattener::new();\n@@ -200,7 +198,7 @@ pub mod pod {\n     }\n \n     /// Create a `FlatChan` from a `Writer`\n-    pub fn writer_chan<T:Copy + Owned,W:Writer>(\n+    pub fn writer_chan<T:Copy + Send,W:Writer>(\n         writer: W\n     ) -> WriterChan<T, W> {\n         let flat: PodFlattener<T> = PodFlattener::new();\n@@ -209,21 +207,21 @@ pub mod pod {\n     }\n \n     /// Create a `FlatPort` from a `Port<~[u8]>`\n-    pub fn pipe_port<T:Copy + Owned>(port: Port<~[u8]>) -> PipePort<T> {\n+    pub fn pipe_port<T:Copy + Send>(port: Port<~[u8]>) -> PipePort<T> {\n         let unflat: PodUnflattener<T> = PodUnflattener::new();\n         let byte_port = PipeBytePort::new(port);\n         FlatPort::new(unflat, byte_port)\n     }\n \n     /// Create a `FlatChan` from a `Chan<~[u8]>`\n-    pub fn pipe_chan<T:Copy + Owned>(chan: Chan<~[u8]>) -> PipeChan<T> {\n+    pub fn pipe_chan<T:Copy + Send>(chan: Chan<~[u8]>) -> PipeChan<T> {\n         let flat: PodFlattener<T> = PodFlattener::new();\n         let byte_chan = PipeByteChan::new(chan);\n         FlatChan::new(flat, byte_chan)\n     }\n \n     /// Create a pair of `FlatChan` and `FlatPort`, backed by pipes\n-    pub fn pipe_stream<T:Copy + Owned>() -> (PipePort<T>, PipeChan<T>) {\n+    pub fn pipe_stream<T:Copy + Send>() -> (PipePort<T>, PipeChan<T>) {\n         let (port, chan) = comm::stream();\n         return (pipe_port(port), pipe_chan(chan));\n     }\n@@ -307,11 +305,11 @@ impl<T,U:Unflattener<T>,P:BytePort> GenericPort<T> for FlatPort<T, U, P> {\n \n impl<T,F:Flattener<T>,C:ByteChan> GenericChan<T> for FlatChan<T, F, C> {\n     fn send(&self, val: T) {\n-        self.byte_chan.send(CONTINUE.to_vec());\n+        self.byte_chan.send(CONTINUE.to_owned());\n         let bytes = self.flattener.flatten(val);\n         let len = bytes.len() as u64;\n         do io::u64_to_be_bytes(len, size_of::<u64>()) |len_bytes| {\n-            self.byte_chan.send(len_bytes.to_vec());\n+            self.byte_chan.send(len_bytes.to_owned());\n         }\n         self.byte_chan.send(bytes);\n     }\n@@ -337,22 +335,21 @@ impl<T,F:Flattener<T>,C:ByteChan> FlatChan<T, F, C> {\n \n \n pub mod flatteners {\n-    use core::prelude::*;\n \n     use ebml;\n     use flatpipes::{Flattener, Unflattener};\n     use io_util::BufReader;\n     use json;\n     use serialize::{Encoder, Decoder, Encodable, Decodable};\n \n-    use core::cast;\n-    use core::io::{Writer, Reader, ReaderUtil};\n-    use core::io;\n-    use core::ptr;\n-    use core::sys::size_of;\n-    use core::vec;\n+    use std::cast;\n+    use std::io::{Writer, Reader, ReaderUtil};\n+    use std::io;\n+    use std::ptr;\n+    use std::sys::size_of;\n+    use std::vec;\n \n-    // FIXME #4074: Copy + Owned != POD\n+    // FIXME #4074: Copy + Send != POD\n     pub struct PodUnflattener<T> {\n         bogus: ()\n     }\n@@ -361,7 +358,7 @@ pub mod flatteners {\n         bogus: ()\n     }\n \n-    impl<T:Copy + Owned> Unflattener<T> for PodUnflattener<T> {\n+    impl<T:Copy + Send> Unflattener<T> for PodUnflattener<T> {\n         fn unflatten(&self, buf: ~[u8]) -> T {\n             assert!(size_of::<T>() != 0);\n             assert_eq!(size_of::<T>(), buf.len());\n@@ -371,7 +368,7 @@ pub mod flatteners {\n         }\n     }\n \n-    impl<T:Copy + Owned> Flattener<T> for PodFlattener<T> {\n+    impl<T:Copy + Send> Flattener<T> for PodFlattener<T> {\n         fn flatten(&self, val: T) -> ~[u8] {\n             assert!(size_of::<T>() != 0);\n             let val: *T = ptr::to_unsafe_ptr(&val);\n@@ -380,15 +377,15 @@ pub mod flatteners {\n         }\n     }\n \n-    impl<T:Copy + Owned> PodUnflattener<T> {\n+    impl<T:Copy + Send> PodUnflattener<T> {\n         pub fn new() -> PodUnflattener<T> {\n             PodUnflattener {\n                 bogus: ()\n             }\n         }\n     }\n \n-    impl<T:Copy + Owned> PodFlattener<T> {\n+    impl<T:Copy + Send> PodFlattener<T> {\n         pub fn new() -> PodFlattener<T> {\n             PodFlattener {\n                 bogus: ()\n@@ -509,13 +506,12 @@ pub mod flatteners {\n }\n \n pub mod bytepipes {\n-    use core::prelude::*;\n \n     use flatpipes::{ByteChan, BytePort};\n \n-    use core::comm::{Port, Chan};\n-    use core::comm;\n-    use core::io::{Writer, Reader, ReaderUtil};\n+    use std::comm::{Port, Chan};\n+    use std::comm;\n+    use std::io::{Writer, Reader, ReaderUtil};\n \n     pub struct ReaderBytePort<R> {\n         reader: R\n@@ -583,12 +579,12 @@ pub mod bytepipes {\n     impl BytePort for PipeBytePort {\n         fn try_recv(&self, count: uint) -> Option<~[u8]> {\n             if self.buf.len() >= count {\n-                let mut bytes = ::core::util::replace(&mut *self.buf, ~[]);\n+                let mut bytes = ::std::util::replace(&mut *self.buf, ~[]);\n                 *self.buf = bytes.slice(count, bytes.len()).to_owned();\n                 bytes.truncate(count);\n                 return Some(bytes);\n             } else if !self.buf.is_empty() {\n-                let mut bytes = ::core::util::replace(&mut *self.buf, ~[]);\n+                let mut bytes = ::std::util::replace(&mut *self.buf, ~[]);\n                 assert!(count > bytes.len());\n                 match self.try_recv(count - bytes.len()) {\n                     Some(rest) => {\n@@ -637,7 +633,6 @@ pub mod bytepipes {\n \n #[cfg(test)]\n mod test {\n-    use core::prelude::*;\n \n     use flatpipes::{Flattener, Unflattener};\n     use flatpipes::bytepipes::*;\n@@ -647,11 +642,11 @@ mod test {\n     use flatpipes::{BytePort, FlatChan, FlatPort};\n     use net::tcp::TcpSocketBuf;\n \n-    use core::comm;\n-    use core::int;\n-    use core::io::BytesWriter;\n-    use core::result;\n-    use core::task;\n+    use std::comm;\n+    use std::int;\n+    use std::io::BytesWriter;\n+    use std::result;\n+    use std::task;\n \n     #[test]\n     #[ignore(reason = \"ebml failure\")]\n@@ -772,7 +767,7 @@ mod test {\n         writer_chan: WriterChanFactory<F>,\n         port: uint) {\n \n-        use core::cell::Cell;\n+        use std::cell::Cell;\n         use net::ip;\n         use net::tcp;\n         use uv;\n@@ -871,17 +866,16 @@ mod test {\n     // Tests that the different backends behave the same when the\n     // binary streaming protocol is broken\n     mod broken_protocol {\n-        use core::prelude::*;\n \n         use flatpipes::{BytePort, FlatPort};\n         use flatpipes::flatteners::PodUnflattener;\n         use flatpipes::pod;\n         use io_util::BufReader;\n \n-        use core::comm;\n-        use core::io;\n-        use core::sys;\n-        use core::task;\n+        use std::comm;\n+        use std::io;\n+        use std::sys;\n+        use std::task;\n \n         type PortLoader<P> =\n             ~fn(~[u8]) -> FlatPort<int, PodUnflattener<int>, P>;\n@@ -937,7 +931,7 @@ mod test {\n         fn test_try_recv_none3<P:BytePort>(loader: PortLoader<P>) {\n             static CONTINUE: [u8, ..4] = [0xAA, 0xBB, 0xCC, 0xDD];\n             // The control word is followed by garbage\n-            let bytes = CONTINUE.to_vec() + [0];\n+            let bytes = CONTINUE.to_owned() + [0];\n             let port = loader(bytes);\n             let res: Option<int> = port.try_recv();\n             assert!(res.is_none());\n@@ -959,9 +953,9 @@ mod test {\n                 // then undeserializable garbage\n                 let len_bytes = do io::u64_to_be_bytes(\n                     1, sys::size_of::<u64>()) |len_bytes| {\n-                    len_bytes.to_vec()\n+                    len_bytes.to_owned()\n                 };\n-                let bytes = CONTINUE.to_vec() + len_bytes + [0, 0, 0, 0];\n+                let bytes = CONTINUE.to_owned() + len_bytes + [0, 0, 0, 0];\n \n                 let port = loader(bytes);\n "}, {"sha": "4461a4dba5fd4d78291181a7fc7bd6b07d1375bb", "filename": "src/libextra/fun_treemap.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffun_treemap.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -19,10 +19,9 @@\n  * of features.\n  */\n \n-use core::prelude::*;\n \n-use core::cmp::{Eq, Ord};\n-use core::option::{Some, None};\n+use std::cmp::{Eq, Ord};\n+use std::option::{Some, None};\n \n pub type Treemap<K, V> = @TreeNode<K, V>;\n \n@@ -66,9 +65,9 @@ pub fn traverse<K, V: Copy>(m: Treemap<K, V>, f: &fn(&K, &V)) {\n         // matches to me, so I changed it. but that may be a\n         // de-optimization -- tjc\n         Node(@ref k, @ref v, left, right) => {\n-            traverse(left, f);\n+            traverse(left, |k,v| f(k,v));\n             f(k, v);\n-            traverse(right, f);\n+            traverse(right, |k,v| f(k,v));\n         }\n     }\n }"}, {"sha": "3ef71e1731b2eb363646f9bc8d2f8539daad44fe", "filename": "src/libextra/future.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -17,21 +17,20 @@\n  * ~~~ {.rust}\n  * # fn fib(n: uint) -> uint {42};\n  * # fn make_a_sandwich() {};\n- * let mut delayed_fib = std::future::spawn (|| fib(5000) );\n+ * let mut delayed_fib = extra::future::spawn (|| fib(5000) );\n  * make_a_sandwich();\n  * println(fmt!(\"fib(5000) = %?\", delayed_fib.get()))\n  * ~~~\n  */\n \n #[allow(missing_doc)];\n \n-use core::prelude::*;\n \n-use core::cast;\n-use core::cell::Cell;\n-use core::comm::{PortOne, oneshot, send_one, recv_one};\n-use core::task;\n-use core::util::replace;\n+use std::cast;\n+use std::cell::Cell;\n+use std::comm::{PortOne, oneshot, send_one, recv_one};\n+use std::task;\n+use std::util::replace;\n \n #[doc = \"The future type\"]\n pub struct Future<A> {\n@@ -44,7 +43,7 @@ pub struct Future<A> {\n // over ~fn's that have pipes and so forth within!\n #[unsafe_destructor]\n impl<A> Drop for Future<A> {\n-    fn finalize(&self) {}\n+    fn drop(&self) {}\n }\n \n priv enum FutureState<A> {\n@@ -101,7 +100,7 @@ pub fn from_value<A>(val: A) -> Future<A> {\n     Future {state: Forced(val)}\n }\n \n-pub fn from_port<A:Owned>(port: PortOne<A>) -> Future<A> {\n+pub fn from_port<A:Send>(port: PortOne<A>) -> Future<A> {\n     /*!\n      * Create a future from a port\n      *\n@@ -127,7 +126,7 @@ pub fn from_fn<A>(f: ~fn() -> A) -> Future<A> {\n     Future {state: Pending(f)}\n }\n \n-pub fn spawn<A:Owned>(blk: ~fn() -> A) -> Future<A> {\n+pub fn spawn<A:Send>(blk: ~fn() -> A) -> Future<A> {\n     /*!\n      * Create a future from a unique closure.\n      *\n@@ -151,9 +150,9 @@ pub fn spawn<A:Owned>(blk: ~fn() -> A) -> Future<A> {\n mod test {\n     use future::*;\n \n-    use core::cell::Cell;\n-    use core::comm::{oneshot, send_one};\n-    use core::task;\n+    use std::cell::Cell;\n+    use std::comm::{oneshot, send_one};\n+    use std::task;\n \n     #[test]\n     fn test_from_value() {"}, {"sha": "1a494f36c646960789294fa80b2594a7f995a35e", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 52, "deletions": 38, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -81,14 +81,13 @@\n \n #[allow(missing_doc)];\n \n-use core::prelude::*;\n \n-use core::cmp::Eq;\n-use core::result::{Err, Ok};\n-use core::result;\n-use core::option::{Some, None};\n-use core::str;\n-use core::vec;\n+use std::cmp::Eq;\n+use std::result::{Err, Ok};\n+use std::result;\n+use std::option::{Some, None};\n+use std::str;\n+use std::vec;\n \n #[deriving(Eq)]\n pub enum Name {\n@@ -177,7 +176,7 @@ fn name_str(nm: &Name) -> ~str {\n }\n \n fn find_opt(opts: &[Opt], nm: Name) -> Option<uint> {\n-    vec::position(opts, |opt| opt.name == nm)\n+    opts.iter().position_(|opt| opt.name == nm)\n }\n \n /**\n@@ -295,7 +294,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n                 }\n             }\n             let mut name_pos = 0;\n-            for names.each() |nm| {\n+            for names.iter().advance() |nm| {\n                 name_pos += 1;\n                 let optid = match find_opt(opts, copy *nm) {\n                   Some(id) => id,\n@@ -373,7 +372,7 @@ pub fn opt_count(mm: &Matches, nm: &str) -> uint {\n \n /// Returns true if any of several options were matched\n pub fn opts_present(mm: &Matches, names: &[~str]) -> bool {\n-    for names.each |nm| {\n+    for names.iter().advance |nm| {\n         match find_opt(mm.opts, mkname(*nm)) {\n             Some(id) if !mm.vals[id].is_empty() => return true,\n             _ => (),\n@@ -400,7 +399,7 @@ pub fn opt_str(mm: &Matches, nm: &str) -> ~str {\n  * option took an argument\n  */\n pub fn opts_str(mm: &Matches, names: &[~str]) -> ~str {\n-    for names.each |nm| {\n+    for names.iter().advance |nm| {\n         match opt_val(mm, *nm) {\n           Val(ref s) => return copy *s,\n           _ => ()\n@@ -418,10 +417,11 @@ pub fn opts_str(mm: &Matches, names: &[~str]) -> ~str {\n  */\n pub fn opt_strs(mm: &Matches, nm: &str) -> ~[~str] {\n     let mut acc: ~[~str] = ~[];\n-    for vec::each(opt_vals(mm, nm)) |v| {\n+    let r = opt_vals(mm, nm);\n+    for r.iter().advance |v| {\n         match *v { Val(ref s) => acc.push(copy *s), _ => () }\n     }\n-    return acc;\n+    acc\n }\n \n /// Returns the string argument supplied to a matching option or none\n@@ -465,8 +465,8 @@ pub mod groups {\n     use getopts::{HasArg, Long, Maybe, Multi, No, Occur, Opt, Optional, Req};\n     use getopts::{Short, Yes};\n \n-    use core::str;\n-    use core::vec;\n+    use std::str;\n+    use std::vec;\n \n     /** one group of options, e.g., both -h and --help, along with\n      * their shared description and properties\n@@ -592,9 +592,9 @@ pub mod groups {\n      */\n     pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n \n-        let desc_sep = ~\"\\n\" + \" \".repeat(24);\n+        let desc_sep = \"\\n\" + \" \".repeat(24);\n \n-        let rows = vec::map(opts, |optref| {\n+        let mut rows = opts.iter().transform(|optref| {\n             let OptGroup{short_name: short_name,\n                          long_name: long_name,\n                          hint: hint,\n@@ -605,33 +605,47 @@ pub mod groups {\n             let mut row = \" \".repeat(4);\n \n             // short option\n-            row += match short_name.len() {\n-                0 => ~\"\",\n-                1 => ~\"-\" + short_name + \" \",\n+            match short_name.len() {\n+                0 => {}\n+                1 => {\n+                    row.push_char('-');\n+                    row.push_str(short_name);\n+                    row.push_char(' ');\n+                }\n                 _ => fail!(\"the short name should only be 1 ascii char long\"),\n-            };\n+            }\n \n             // long option\n-            row += match long_name.len() {\n-                0 => ~\"\",\n-                _ => ~\"--\" + long_name + \" \",\n-            };\n+            match long_name.len() {\n+                0 => {}\n+                _ => {\n+                    row.push_str(\"--\");\n+                    row.push_str(long_name);\n+                    row.push_char(' ');\n+                }\n+            }\n \n             // arg\n-            row += match hasarg {\n-                No    => ~\"\",\n-                Yes   => hint,\n-                Maybe => ~\"[\" + hint + \"]\",\n-            };\n+            match hasarg {\n+                No => {}\n+                Yes => row.push_str(hint),\n+                Maybe => {\n+                    row.push_char('[');\n+                    row.push_str(hint);\n+                    row.push_char(']');\n+                }\n+            }\n \n             // FIXME: #5516\n             // here we just need to indent the start of the description\n             let rowlen = row.len();\n-            row += if rowlen < 24 {\n-                \" \".repeat(24 - rowlen)\n+            if rowlen < 24 {\n+                for (24 - rowlen).times {\n+                    row.push_char(' ')\n+                }\n             } else {\n-                copy desc_sep\n-            };\n+                row.push_str(desc_sep)\n+            }\n \n             // Normalize desc to contain words separated by one space character\n             let mut desc_normalized_whitespace = ~\"\";\n@@ -648,14 +662,14 @@ pub mod groups {\n \n             // FIXME: #5516\n             // wrapped description\n-            row += desc_rows.connect(desc_sep);\n+            row.push_str(desc_rows.connect(desc_sep));\n \n             row\n         });\n \n         return str::to_owned(brief) +\n                \"\\n\\nOptions:\\n\" +\n-               rows.connect(\"\\n\") +\n+               rows.collect::<~[~str]>().connect(\"\\n\") +\n                \"\\n\\n\";\n     }\n } // end groups module\n@@ -666,8 +680,8 @@ mod tests {\n     use getopts::groups::OptGroup;\n     use getopts::*;\n \n-    use core::result::{Err, Ok};\n-    use core::result;\n+    use std::result::{Err, Ok};\n+    use std::result;\n \n     fn check_fail_type(f: Fail_, ft: FailType) {\n         match f {"}, {"sha": "afefca8ae65bd4d16cb007b645c414d769da9031", "filename": "src/libextra/io_util.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fio_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fio_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fio_util.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::io::{Reader, BytesReader};\n-use core::io;\n+use std::io::{Reader, BytesReader};\n+use std::io;\n+use std::cast;\n \n /// An implementation of the io::Reader interface which reads a buffer of bytes\n pub struct BufReader {\n@@ -29,10 +30,13 @@ impl BufReader {\n     }\n \n     fn as_bytes_reader<A>(&self, f: &fn(&BytesReader) -> A) -> A {\n+        // XXX FIXME(#5723)\n+        let bytes = ::std::util::id::<&[u8]>(self.buf);\n+        let bytes: &'static [u8] = unsafe { cast::transmute(bytes) };\n         // Recreating the BytesReader state every call since\n         // I can't get the borrowing to work correctly\n         let bytes_reader = BytesReader {\n-            bytes: ::core::util::id::<&[u8]>(self.buf),\n+            bytes: bytes,\n             pos: @mut *self.pos\n         };\n "}, {"sha": "210921aa3d7624211b228ff3d03e3916e8c7b6cb", "filename": "src/libextra/json.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -16,16 +16,15 @@\n \n //! json serialization\n \n-use core::prelude::*;\n \n-use core::char;\n-use core::float;\n-use core::hashmap::HashMap;\n-use core::io::{WriterUtil, ReaderUtil};\n-use core::io;\n-use core::str;\n-use core::to_str;\n-use core::vec;\n+use std::char;\n+use std::float;\n+use std::hashmap::HashMap;\n+use std::io::{WriterUtil, ReaderUtil};\n+use std::io;\n+use std::str;\n+use std::to_str;\n+use std::vec;\n \n use serialize::Encodable;\n use serialize;\n@@ -60,25 +59,27 @@ fn escape_str(s: &str) -> ~str {\n     let mut escaped = ~\"\\\"\";\n     for s.iter().advance |c| {\n         match c {\n-          '\"' => escaped += \"\\\\\\\"\",\n-          '\\\\' => escaped += \"\\\\\\\\\",\n-          '\\x08' => escaped += \"\\\\b\",\n-          '\\x0c' => escaped += \"\\\\f\",\n-          '\\n' => escaped += \"\\\\n\",\n-          '\\r' => escaped += \"\\\\r\",\n-          '\\t' => escaped += \"\\\\t\",\n-          _ => escaped += str::from_char(c)\n+          '\"' => escaped.push_str(\"\\\\\\\"\"),\n+          '\\\\' => escaped.push_str(\"\\\\\\\\\"),\n+          '\\x08' => escaped.push_str(\"\\\\b\"),\n+          '\\x0c' => escaped.push_str(\"\\\\f\"),\n+          '\\n' => escaped.push_str(\"\\\\n\"),\n+          '\\r' => escaped.push_str(\"\\\\r\"),\n+          '\\t' => escaped.push_str(\"\\\\t\"),\n+          _ => escaped.push_char(c),\n         }\n     };\n \n-    escaped += \"\\\"\";\n+    escaped.push_char('\"');\n \n     escaped\n }\n \n fn spaces(n: uint) -> ~str {\n     let mut ss = ~\"\";\n-    for n.times { ss.push_str(\" \"); }\n+    for n.times {\n+        ss.push_str(\" \");\n+    }\n     return ss;\n }\n \n@@ -950,7 +951,7 @@ impl serialize::Decoder for Decoder {\n             }\n             ref json => fail!(\"invalid variant: %?\", *json),\n         };\n-        let idx = match vec::position(names, |n| str::eq_slice(*n, name)) {\n+        let idx = match names.iter().position_(|n| str::eq_slice(*n, name)) {\n             Some(idx) => idx,\n             None => fail!(\"Unknown variant name: %?\", name),\n         };\n@@ -1123,7 +1124,7 @@ impl Eq for Json {\n                     &Object(ref d1) => {\n                         if d0.len() == d1.len() {\n                             let mut equal = true;\n-                            for d0.each |k, v0| {\n+                            for d0.iter().advance |(k, v0)| {\n                                 match d1.find(k) {\n                                     Some(v1) if v0 == v1 => { },\n                                     _ => { equal = false; break }\n@@ -1186,12 +1187,12 @@ impl Ord for Json {\n                         let mut d1_flat = ~[];\n \n                         // FIXME #4430: this is horribly inefficient...\n-                        for d0.each |k, v| {\n+                        for d0.iter().advance |(k, v)| {\n                              d0_flat.push((@copy *k, @copy *v));\n                         }\n                         d0_flat.qsort();\n \n-                        for d1.each |k, v| {\n+                        for d1.iter().advance |(k, v)| {\n                             d1_flat.push((@copy *k, @copy *v));\n                         }\n                         d1_flat.qsort();\n@@ -1326,7 +1327,7 @@ impl<A:ToJson> ToJson for ~[A] {\n impl<A:ToJson + Copy> ToJson for HashMap<~str, A> {\n     fn to_json(&self) -> Json {\n         let mut d = HashMap::new();\n-        for self.each |key, value| {\n+        for self.iter().advance |(key, value)| {\n             d.insert(copy *key, value.to_json());\n         }\n         Object(~d)\n@@ -1354,15 +1355,14 @@ impl to_str::ToStr for Error {\n \n #[cfg(test)]\n mod tests {\n-    use core::prelude::*;\n \n     use super::*;\n \n-    use core::hashmap::HashMap;\n-    use core::io;\n-    use core::result;\n+    use std::hashmap::HashMap;\n+    use std::io;\n+    use std::result;\n \n-    use std::serialize::Decodable;\n+    use extra::serialize::Decodable;\n \n     #[deriving(Eq, Encodable, Decodable)]\n     enum Animal {\n@@ -1385,7 +1385,7 @@ mod tests {\n     fn mk_object(items: &[(~str, Json)]) -> Json {\n         let mut d = ~HashMap::new();\n \n-        for items.each |item| {\n+        for items.iter().advance |item| {\n             match *item {\n                 (ref key, ref value) => { d.insert(copy *key, copy *value); },\n             }"}, {"sha": "86b01cf157d89783a01867523ada89ab7f92062f", "filename": "src/libextra/list.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flist.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -10,7 +10,6 @@\n \n //! A standard, garbage-collected linked list.\n \n-use core::prelude::*;\n \n \n #[deriving(Eq)]\n@@ -181,7 +180,7 @@ mod tests {\n     use list::*;\n     use list;\n \n-    use core::option;\n+    use std::option;\n \n     #[test]\n     fn test_is_empty() {"}, {"sha": "6b08fea580f92e32078faba33445c7db741438e9", "filename": "src/libextra/md4.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fmd4.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n \n-use core::uint;\n-use core::vec;\n+use std::uint;\n+use std::vec;\n \n struct Quad {\n     a: u32,\n@@ -59,7 +58,8 @@ pub fn md4(msg: &[u8]) -> Quad {\n     while i < e {\n         let (aa, bb, cc, dd) = (a, b, c, d);\n \n-        let mut (j, base) = (0u, i);\n+        let mut j = 0u;\n+        let mut base = i;\n         while j < 16u {\n             x[j] = (msg[base] as u32) + (msg[base + 1u] as u32 << 8u32) +\n                 (msg[base + 2u] as u32 << 16u32) +\n@@ -118,8 +118,10 @@ pub fn md4_str(msg: &[u8]) -> ~str {\n         let mut i = 0u32;\n         while i < 4u32 {\n             let byte = (u >> (i * 8u32)) as u8;\n-            if byte <= 16u8 { result += \"0\"; }\n-            result += uint::to_str_radix(byte as uint, 16u);\n+            if byte <= 16u8 {\n+                result.push_char('0')\n+            }\n+            result.push_str(uint::to_str_radix(byte as uint, 16u));\n             i += 1u32;\n         }\n     }"}, {"sha": "d18aac684813b0a5242c78c1fcae6f55f512ac26", "filename": "src/libextra/net_ip.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_ip.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -12,13 +12,12 @@\n \n #[allow(missing_doc)];\n \n-use core::prelude::*;\n \n-use core::libc;\n-use core::comm::{stream, SharedChan};\n-use core::ptr;\n-use core::result;\n-use core::str;\n+use std::libc;\n+use std::comm::{stream, SharedChan};\n+use std::ptr;\n+use std::result;\n+use std::str;\n \n use iotask = uv::iotask::IoTask;\n use interact = uv::iotask::interact;\n@@ -55,7 +54,7 @@ pub struct ParseAddrErr {\n  *\n  * # Arguments\n  *\n- * * ip - a `std::net::ip::IpAddr`\n+ * * ip - a `extra::net::ip::IpAddr`\n  */\n pub fn format_addr(ip: &IpAddr) -> ~str {\n     match *ip {\n@@ -80,7 +79,7 @@ pub fn format_addr(ip: &IpAddr) -> ~str {\n  * Get the associated port\n  *\n  * # Arguments\n- * * ip - a `std::net::ip::IpAddr`\n+ * * ip - a `extra::net::ip::IpAddr`\n  */\n pub fn get_port(ip: &IpAddr) -> uint {\n     match *ip {\n@@ -149,16 +148,15 @@ pub fn get_addr(node: &str, iotask: &iotask)\n }\n \n pub mod v4 {\n-    use core::prelude::*;\n \n     use net::ip::{IpAddr, Ipv4, ParseAddrErr};\n     use uv::ll;\n     use uv_ip4_addr = uv::ll::ip4_addr;\n     use uv_ip4_name = uv::ll::ip4_name;\n \n-    use core::cast::transmute;\n-    use core::result;\n-    use core::uint;\n+    use std::cast::transmute;\n+    use std::result;\n+    use std::uint;\n \n     /**\n      * Convert a str to `ip_addr`\n@@ -205,7 +203,7 @@ pub mod v4 {\n         }).collect();\n         if parts.len() != 4 {\n             Err(fmt!(\"'%s' doesn't have 4 parts\", ip))\n-        } else if parts.contains(&256) {\n+        } else if parts.iter().any_(|x| *x == 256u) {\n             Err(fmt!(\"invalid octal in addr '%s'\", ip))\n         } else {\n             Ok(Ipv4Rep {\n@@ -248,13 +246,12 @@ pub mod v4 {\n     }\n }\n pub mod v6 {\n-    use core::prelude::*;\n \n     use net::ip::{IpAddr, Ipv6, ParseAddrErr};\n     use uv_ip6_addr = uv::ll::ip6_addr;\n     use uv_ip6_name = uv::ll::ip6_name;\n \n-    use core::result;\n+    use std::result;\n \n     /**\n      * Convert a str to `ip_addr`\n@@ -371,7 +368,7 @@ mod test {\n     use net_ip::v6;\n     use uv;\n \n-    use core::result;\n+    use std::result;\n \n     #[test]\n     fn test_ip_ipv4_parse_and_format_ip() {\n@@ -426,7 +423,7 @@ mod test {\n         let results = result::unwrap(ga_result);\n         debug!(\"test_get_addr: Number of results for %s: %?\",\n                         localhost_name, results.len());\n-        for results.each |r| {\n+        for results.iter().advance |r| {\n             let ipv_prefix = match *r {\n               Ipv4(_) => ~\"IPv4\",\n               Ipv6(_) => ~\"IPv6\""}, {"sha": "6a22950ec04b0ec9acbdfeaf1ce0aed8d94be17e", "filename": "src/libextra/net_tcp.rs", "status": "modified", "additions": 27, "deletions": 41, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_tcp.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -13,7 +13,6 @@\n \n #[allow(missing_doc)];\n \n-use core::prelude::*;\n \n use future;\n use future_spawn = future::spawn;\n@@ -22,18 +21,18 @@ use uv;\n use uv::iotask;\n use uv::iotask::IoTask;\n \n-use core::io;\n-use core::libc::size_t;\n-use core::libc;\n-use core::comm::{stream, Port, SharedChan};\n-use core::ptr;\n-use core::result::{Result};\n-use core::result;\n-use core::uint;\n-use core::vec;\n+use std::io;\n+use std::libc::size_t;\n+use std::libc;\n+use std::comm::{stream, Port, SharedChan};\n+use std::ptr;\n+use std::result::{Result};\n+use std::result;\n+use std::uint;\n+use std::vec;\n \n pub mod rustrt {\n-    use core::libc;\n+    use std::libc;\n \n     #[nolink]\n     pub extern {\n@@ -57,7 +56,7 @@ pub struct TcpSocket {\n \n #[unsafe_destructor]\n impl Drop for TcpSocket {\n-    fn finalize(&self) {\n+    fn drop(&self) {\n         tear_down_socket_data(self.socket_data)\n     }\n }\n@@ -360,7 +359,7 @@ pub fn write_future(sock: &TcpSocket, raw_write_data: ~[u8])\n  * # Returns\n  *\n  * * A `Result` instance that will either contain a\n- * `core::comm::Port<Result<~[u8], TcpErrData>>` that the user can read\n+ * `std::comm::Port<Result<~[u8], TcpErrData>>` that the user can read\n  * (and * optionally, loop on) from until `read_stop` is called, or a\n  * `TcpErrData` record\n  */\n@@ -619,7 +618,7 @@ pub fn accept(new_conn: TcpNewConnection)\n  * callback's arguments are:\n  *     * `new_conn` - an opaque type that can be passed to\n  *     `net::tcp::accept` in order to be converted to a `TcpSocket`.\n- *     * `kill_ch` - channel of type `core::comm::Chan<Option<tcp_err_data>>`.\n+ *     * `kill_ch` - channel of type `std::comm::Chan<Option<tcp_err_data>>`.\n  *     this channel can be used to send a message to cause `listen` to begin\n  *     closing the underlying libuv data structures.\n  *\n@@ -683,7 +682,7 @@ fn listen_common(host_ip: ip::IpAddr,\n     // will defeat a move sigil, as is done to the host_ip\n     // arg above.. this same pattern works w/o complaint in\n     // tcp::connect (because the iotask::interact cb isn't\n-    // nested within a core::comm::listen block)\n+    // nested within a std::comm::listen block)\n     let loc_ip = copy(host_ip);\n     do iotask::interact(iotask) |loop_ptr| {\n         unsafe {\n@@ -976,9 +975,7 @@ impl io::Writer for TcpSocketBuf {\n         let socket_data_ptr: *TcpSocketData =\n             &(*((*(self.data)).sock).socket_data);\n         let w_result = write_common_impl(socket_data_ptr,\n-                                         vec::slice(data,\n-                                                    0,\n-                                                    data.len()).to_vec());\n+                                         data.slice(0, data.len()).to_owned());\n         if w_result.is_err() {\n             let err_data = w_result.get_err();\n             debug!(\n@@ -1431,7 +1428,6 @@ struct TcpBufferedSocketData {\n \n #[cfg(test)]\n mod test {\n-    use core::prelude::*;\n \n     use net::ip;\n     use net::tcp::{GenericListenErr, TcpConnectErrData, TcpListenErrData};\n@@ -1440,12 +1436,12 @@ mod test {\n     use uv::iotask::IoTask;\n     use uv;\n \n-    use core::cell::Cell;\n-    use core::comm::{stream, SharedChan};\n-    use core::io;\n-    use core::result;\n-    use core::str;\n-    use core::task;\n+    use std::cell::Cell;\n+    use std::comm::{stream, SharedChan};\n+    use std::io;\n+    use std::result;\n+    use std::str;\n+    use std::task;\n \n     // FIXME don't run on fbsd or linux 32 bit (#2064)\n     #[cfg(target_os=\"win32\")]\n@@ -1459,33 +1455,23 @@ mod test {\n \n             #[test]\n             fn test_gl_tcp_server_and_client_ipv4() {\n-                unsafe {\n-                    impl_gl_tcp_ipv4_server_and_client();\n-                }\n+                impl_gl_tcp_ipv4_server_and_client();\n             }\n             #[test]\n             fn test_gl_tcp_get_peer_addr() {\n-                unsafe {\n-                    impl_gl_tcp_ipv4_get_peer_addr();\n-                }\n+                impl_gl_tcp_ipv4_get_peer_addr();\n             }\n             #[test]\n             fn test_gl_tcp_ipv4_client_error_connection_refused() {\n-                unsafe {\n-                    impl_gl_tcp_ipv4_client_error_connection_refused();\n-                }\n+                impl_gl_tcp_ipv4_client_error_connection_refused();\n             }\n             #[test]\n             fn test_gl_tcp_server_address_in_use() {\n-                unsafe {\n-                    impl_gl_tcp_ipv4_server_address_in_use();\n-                }\n+                impl_gl_tcp_ipv4_server_address_in_use();\n             }\n             #[test]\n             fn test_gl_tcp_server_access_denied() {\n-                unsafe {\n-                    impl_gl_tcp_ipv4_server_access_denied();\n-                }\n+                impl_gl_tcp_ipv4_server_access_denied();\n             }\n             // Strange failure on Windows. --pcwalton\n             #[test]\n@@ -1757,7 +1743,7 @@ mod test {\n     }\n \n     pub fn impl_tcp_socket_impl_reader_handles_eof() {\n-        use core::io::{Reader,ReaderUtil};\n+        use std::io::{Reader,ReaderUtil};\n \n         let hl_loop = &uv::global_loop::get();\n         let server_ip = \"127.0.0.1\";"}, {"sha": "9ac58efe79300020994b12bcefc74862432e76fc", "filename": "src/libextra/net_url.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_url.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -12,14 +12,13 @@\n \n #[allow(missing_doc)];\n \n-use core::prelude::*;\n \n-use core::cmp::Eq;\n-use core::io::{Reader, ReaderUtil};\n-use core::io;\n-use core::hashmap::HashMap;\n-use core::to_bytes;\n-use core::uint;\n+use std::cmp::Eq;\n+use std::io::{Reader, ReaderUtil};\n+use std::io;\n+use std::hashmap::HashMap;\n+use std::to_bytes;\n+use std::uint;\n \n #[deriving(Clone, Eq)]\n struct Url {\n@@ -93,10 +92,10 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n                         out.push_char(ch);\n                       }\n \n-                      _ => out += fmt!(\"%%%X\", ch as uint)\n+                      _ => out.push_str(fmt!(\"%%%X\", ch as uint))\n                     }\n                 } else {\n-                    out += fmt!(\"%%%X\", ch as uint);\n+                    out.push_str(fmt!(\"%%%X\", ch as uint));\n                 }\n               }\n             }\n@@ -192,7 +191,7 @@ fn encode_plus(s: &str) -> ~str {\n                 out.push_char(ch);\n               }\n               ' ' => out.push_char('+'),\n-              _ => out += fmt!(\"%%%X\", ch as uint)\n+              _ => out.push_str(fmt!(\"%%%X\", ch as uint))\n             }\n         }\n \n@@ -207,18 +206,18 @@ pub fn encode_form_urlencoded(m: &HashMap<~str, ~[~str]>) -> ~str {\n     let mut out = ~\"\";\n     let mut first = true;\n \n-    for m.each |key, values| {\n+    for m.iter().advance |(key, values)| {\n         let key = encode_plus(*key);\n \n-        for values.each |value| {\n+        for values.iter().advance |value| {\n             if first {\n                 first = false;\n             } else {\n                 out.push_char('&');\n                 first = false;\n             }\n \n-            out += fmt!(\"%s=%s\", key, encode_plus(*value));\n+            out.push_str(fmt!(\"%s=%s\", key, encode_plus(*value)));\n         }\n     }\n \n@@ -342,7 +341,7 @@ fn query_from_str(rawquery: &str) -> Query {\n \n pub fn query_to_str(query: &Query) -> ~str {\n     let mut strvec = ~[];\n-    for query.each |kv| {\n+    for query.iter().advance |kv| {\n         match kv {\n             &(ref k, ref v) => {\n                 strvec.push(fmt!(\"%s=%s\",\n@@ -415,7 +414,9 @@ fn get_authority(rawurl: &str) ->\n     let mut port = None;\n \n     let mut colon_count = 0;\n-    let mut (pos, begin, end) = (0, 2, len);\n+    let mut pos = 0;\n+    let mut begin = 2;\n+    let mut end = len;\n \n     for rawurl.iter().enumerate().advance |(i,c)| {\n         if i < 2 { loop; } // ignore the leading //\n@@ -519,8 +520,9 @@ fn get_authority(rawurl: &str) ->\n     let end = end; // make end immutable so it can be captured\n \n     let host_is_end_plus_one: &fn() -> bool = || {\n+        let xs = ['?', '#', '/'];\n         end+1 == len\n-            && !['?', '#', '/'].contains(&(rawurl[end] as char))\n+            && !xs.iter().any_(|x| *x == (rawurl[end] as char))\n     };\n \n     // finish up\n@@ -800,7 +802,7 @@ mod tests {\n \n     use net_url::*;\n \n-    use core::hashmap::HashMap;\n+    use std::hashmap::HashMap;\n \n     #[test]\n     fn test_url_parse() {"}, {"sha": "9422ad0c9f2e0043b37f70f1223617f7c4df8a5a", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -18,13 +18,12 @@ A BigInt is a combination of BigUint and Sign.\n \n #[allow(missing_doc)];\n \n-use core::prelude::*;\n-use core::cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n-use core::int;\n-use core::num::{IntConvertible, Zero, One, ToStrRadix, FromStrRadix, Orderable};\n-use core::str;\n-use core::uint;\n-use core::vec;\n+use std::cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n+use std::int;\n+use std::num::{IntConvertible, Zero, One, ToStrRadix, FromStrRadix, Orderable};\n+use std::str;\n+use std::uint;\n+use std::vec;\n \n /**\n A BigDigit is a BigUint's composing element.\n@@ -284,23 +283,22 @@ impl Mul<BigUint, BigUint> for BigUint {\n             if n == 1 { return copy *a; }\n \n             let mut carry = 0;\n-            let prod = do vec::map(a.data) |ai| {\n+            let prod = do a.data.iter().transform |ai| {\n                 let (hi, lo) = BigDigit::from_uint(\n                     (*ai as uint) * (n as uint) + (carry as uint)\n                 );\n                 carry = hi;\n                 lo\n-            };\n+            }.collect::<~[BigDigit]>();\n             if carry == 0 { return BigUint::new(prod) };\n             return BigUint::new(prod + [carry]);\n         }\n \n \n         fn cut_at(a: &BigUint, n: uint) -> (BigUint, BigUint) {\n             let mid = uint::min(a.data.len(), n);\n-            return (BigUint::from_slice(vec::slice(a.data, mid,\n-                                                   a.data.len())),\n-                    BigUint::from_slice(vec::slice(a.data, 0, mid)));\n+            return (BigUint::from_slice(a.data.slice(mid, a.data.len())),\n+                    BigUint::from_slice(a.data.slice(0, mid)));\n         }\n \n \n@@ -381,7 +379,8 @@ impl Integer for BigUint {\n             let mut d = Zero::zero::<BigUint>();\n             let mut n = 1;\n             while m >= b {\n-                let mut (d0, d_unit, b_unit) = div_estimate(&m, &b, n);\n+                let (d0, d_unit, b_unit) = div_estimate(&m, &b, n);\n+                let mut d0 = d0;\n                 let mut prod = b * d0;\n                 while prod > m {\n                     // FIXME(#6050): overloaded operators force moves with generic types\n@@ -413,7 +412,7 @@ impl Integer for BigUint {\n                 return (Zero::zero(), Zero::zero(), copy *a);\n             }\n \n-            let an = vec::slice(a.data, a.data.len() - n, a.data.len());\n+            let an = a.data.slice(a.data.len() - n, a.data.len());\n             let bn = *b.data.last();\n             let mut d = ~[];\n             let mut carry = 0;\n@@ -443,7 +442,8 @@ impl Integer for BigUint {\n \n     fn gcd(&self, other: &BigUint) -> BigUint {\n         // Use Euclid's algorithm\n-        let mut (m, n) = (copy *self, copy *other);\n+        let mut m = copy *self;\n+        let mut n = copy *other;\n         while !m.is_zero() {\n             let temp = m;\n             m = n % temp;\n@@ -507,11 +507,11 @@ impl ToStrRadix for BigUint {\n             let mut m      = n;\n             while m > divider {\n                 let (d, m0) = m.div_mod_floor(&divider);\n-                result += [m0.to_uint() as BigDigit];\n+                result.push(m0.to_uint() as BigDigit);\n                 m = d;\n             }\n             if !m.is_zero() {\n-                result += [m.to_uint() as BigDigit];\n+                result.push(m.to_uint() as BigDigit);\n             }\n             return result;\n         }\n@@ -578,7 +578,7 @@ impl BigUint {\n         let mut power: BigUint  = One::one();\n         loop {\n             let start = uint::max(end, unit_len) - unit_len;\n-            match uint::parse_bytes(vec::slice(buf, start, end), radix) {\n+            match uint::parse_bytes(buf.slice(start, end), radix) {\n                 // FIXME(#6102): Assignment operator for BigInt causes ICE\n                 // Some(d) => n += BigUint::from_uint(d) * power,\n                 Some(d) => n = n + BigUint::from_uint(d) * power,\n@@ -618,13 +618,13 @@ impl BigUint {\n         if n_bits == 0 || self.is_zero() { return copy *self; }\n \n         let mut carry = 0;\n-        let shifted = do vec::map(self.data) |elem| {\n+        let shifted = do self.data.iter().transform |elem| {\n             let (hi, lo) = BigDigit::from_uint(\n                 (*elem as uint) << n_bits | (carry as uint)\n             );\n             carry = hi;\n             lo\n-        };\n+        }.collect::<~[BigDigit]>();\n         if carry == 0 { return BigUint::new(shifted); }\n         return BigUint::new(shifted + [carry]);\n     }\n@@ -634,7 +634,7 @@ impl BigUint {\n         if n_unit == 0 { return copy *self; }\n         if self.data.len() < n_unit { return Zero::zero(); }\n         return BigUint::from_slice(\n-            vec::slice(self.data, n_unit, self.data.len())\n+            self.data.slice(n_unit, self.data.len())\n         );\n     }\n \n@@ -1132,7 +1132,7 @@ impl BigInt {\n             sign  = Minus;\n             start = 1;\n         }\n-        return BigUint::parse_bytes(vec::slice(buf, start, buf.len()), radix)\n+        return BigUint::parse_bytes(buf.slice(start, buf.len()), radix)\n             .map_consume(|bu| BigInt::from_biguint(sign, bu));\n     }\n \n@@ -1147,16 +1147,15 @@ impl BigInt {\n \n #[cfg(test)]\n mod biguint_tests {\n-    use core::prelude::*;\n \n     use super::*;\n \n-    use core::cmp::{Less, Equal, Greater};\n-    use core::int;\n-    use core::num::{IntConvertible, Zero, One, FromStrRadix};\n-    use core::str;\n-    use core::uint;\n-    use core::vec;\n+    use std::cmp::{Less, Equal, Greater};\n+    use std::int;\n+    use std::num::{IntConvertible, Zero, One, FromStrRadix};\n+    use std::str;\n+    use std::uint;\n+    use std::vec;\n \n     #[test]\n     fn test_from_slice() {\n@@ -1173,10 +1172,10 @@ mod biguint_tests {\n \n     #[test]\n     fn test_cmp() {\n-        let data = [ &[], &[1], &[2], &[-1], &[0, 1], &[2, 1], &[1, 1, 1]  ]\n+        let data: ~[BigUint] = [ &[], &[1], &[2], &[-1], &[0, 1], &[2, 1], &[1, 1, 1]  ]\n             .map(|v| BigUint::from_slice(*v));\n-        for data.eachi |i, ni| {\n-            for vec::slice(data, i, data.len()).eachi |j0, nj| {\n+        for data.iter().enumerate().advance |(i, ni)| {\n+            for data.slice(i, data.len()).iter().enumerate().advance |(j0, nj)| {\n                 let j = j0 + i;\n                 if i == j {\n                     assert_eq!(ni.cmp(nj), Equal);\n@@ -1349,7 +1348,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_add() {\n-        for sum_triples.each |elm| {\n+        for sum_triples.iter().advance |elm| {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1362,7 +1361,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_sub() {\n-        for sum_triples.each |elm| {\n+        for sum_triples.iter().advance |elm| {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1413,7 +1412,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_mul() {\n-        for mul_triples.each |elm| {\n+        for mul_triples.iter().advance |elm| {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1423,7 +1422,7 @@ mod biguint_tests {\n             assert!(b * a == c);\n         }\n \n-        for div_rem_quadruples.each |elm| {\n+        for div_rem_quadruples.iter().advance |elm| {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1437,7 +1436,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_div_rem() {\n-        for mul_triples.each |elm| {\n+        for mul_triples.iter().advance |elm| {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1451,7 +1450,7 @@ mod biguint_tests {\n             }\n         }\n \n-        for div_rem_quadruples.each |elm| {\n+        for div_rem_quadruples.iter().advance |elm| {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1567,9 +1566,10 @@ mod biguint_tests {\n \n     #[test]\n     fn test_to_str_radix() {\n-        for to_str_pairs().each |num_pair| {\n+        let r = to_str_pairs();\n+        for r.iter().advance |num_pair| {\n             let &(n, rs) = num_pair;\n-            for rs.each |str_pair| {\n+            for rs.iter().advance |str_pair| {\n                 let &(radix, str) = str_pair;\n                 assert_eq!(n.to_str_radix(radix), str);\n             }\n@@ -1578,9 +1578,10 @@ mod biguint_tests {\n \n     #[test]\n     fn test_from_str_radix() {\n-        for to_str_pairs().each |num_pair| {\n+        let r = to_str_pairs();\n+        for r.iter().advance |num_pair| {\n             let &(n, rs) = num_pair;\n-            for rs.each |str_pair| {\n+            for rs.iter().advance |str_pair| {\n                 let &(radix, str) = str_pair;\n                 assert_eq!(&n, &FromStrRadix::from_str_radix(str, radix).get());\n             }\n@@ -1620,15 +1621,14 @@ mod biguint_tests {\n \n #[cfg(test)]\n mod bigint_tests {\n-    use core::prelude::*;\n \n     use super::*;\n \n-    use core::cmp::{Less, Equal, Greater};\n-    use core::int;\n-    use core::num::{IntConvertible, Zero, One, FromStrRadix};\n-    use core::uint;\n-    use core::vec;\n+    use std::cmp::{Less, Equal, Greater};\n+    use std::int;\n+    use std::num::{IntConvertible, Zero, One, FromStrRadix};\n+    use std::uint;\n+    use std::vec;\n \n     #[test]\n     fn test_from_biguint() {\n@@ -1651,8 +1651,8 @@ mod bigint_tests {\n         nums.push(Zero::zero());\n         nums.push_all_move(vs.map(|s| BigInt::from_slice(Plus, *s)));\n \n-        for nums.eachi |i, ni| {\n-            for vec::slice(nums, i, nums.len()).eachi |j0, nj| {\n+        for nums.iter().enumerate().advance |(i, ni)| {\n+            for nums.slice(i, nums.len()).iter().enumerate().advance |(j0, nj)| {\n                 let j = i + j0;\n                 if i == j {\n                     assert_eq!(ni.cmp(nj), Equal);\n@@ -1756,7 +1756,7 @@ mod bigint_tests {\n \n     #[test]\n     fn test_add() {\n-        for sum_triples.each |elm| {\n+        for sum_triples.iter().advance |elm| {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1775,7 +1775,7 @@ mod bigint_tests {\n \n     #[test]\n     fn test_sub() {\n-        for sum_triples.each |elm| {\n+        for sum_triples.iter().advance |elm| {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1832,7 +1832,7 @@ mod bigint_tests {\n \n     #[test]\n     fn test_mul() {\n-        for mul_triples.each |elm| {\n+        for mul_triples.iter().advance |elm| {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1845,7 +1845,7 @@ mod bigint_tests {\n             assert!((-b) * a == -c);\n         }\n \n-        for div_rem_quadruples.each |elm| {\n+        for div_rem_quadruples.iter().advance |elm| {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1884,7 +1884,7 @@ mod bigint_tests {\n             }\n         }\n \n-        for mul_triples.each |elm| {\n+        for mul_triples.iter().advance |elm| {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1894,7 +1894,7 @@ mod bigint_tests {\n             if !b.is_zero() { check(&c, &b, &a, &Zero::zero()); }\n         }\n \n-        for div_rem_quadruples.each |elm| {\n+        for div_rem_quadruples.iter().advance |elm| {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1927,7 +1927,7 @@ mod bigint_tests {\n             check_sub(&a.neg(), b, &q.neg(), &r.neg());\n             check_sub(&a.neg(), &b.neg(), q, &r.neg());\n         }\n-        for mul_triples.each |elm| {\n+        for mul_triples.iter().advance |elm| {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1937,7 +1937,7 @@ mod bigint_tests {\n             if !b.is_zero() { check(&c, &b, &a, &Zero::zero()); }\n         }\n \n-        for div_rem_quadruples.each |elm| {\n+        for div_rem_quadruples.iter().advance |elm| {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);"}, {"sha": "915523443fbc3dc6f59c0f6a169675c51c95dd3d", "filename": "src/libextra/num/complex.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fcomplex.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -11,9 +11,8 @@\n \n //! Complex numbers.\n \n-use core::prelude::*;\n \n-use core::num::{Zero,One,ToStrRadix};\n+use std::num::{Zero,One,ToStrRadix};\n \n // FIXME #1284: handle complex NaN & infinity etc. This\n // probably doesn't map to C's _Complex correctly.\n@@ -193,7 +192,7 @@ impl<T: ToStrRadix + Num + Ord> ToStrRadix for Cmplx<T> {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use core::num::{Zero,One,Real};\n+    use std::num::{Zero,One,Real};\n \n     pub static _0_0i : Complex = Cmplx { re: 0f, im: 0f };\n     pub static _1_0i : Complex = Cmplx { re: 1f, im: 0f };\n@@ -238,14 +237,14 @@ mod test {\n     fn test_scale_unscale() {\n         assert_eq!(_05_05i.scale(2f), _1_1i);\n         assert_eq!(_1_1i.unscale(2f), _05_05i);\n-        for all_consts.each |&c| {\n+        for all_consts.iter().advance |&c| {\n             assert_eq!(c.scale(2f).unscale(2f), c);\n         }\n     }\n \n     #[test]\n     fn test_conj() {\n-        for all_consts.each |&c| {\n+        for all_consts.iter().advance |&c| {\n             assert_eq!(c.conj(), Cmplx::new(c.re, -c.im));\n             assert_eq!(c.conj().conj(), c);\n         }\n@@ -282,20 +281,20 @@ mod test {\n             let (r, theta) = c.to_polar();\n             assert!((c - Cmplx::from_polar(&r, &theta)).norm() < 1e-6);\n         }\n-        for all_consts.each |&c| { test(c); }\n+        for all_consts.iter().advance |&c| { test(c); }\n     }\n \n     mod arith {\n         use super::*;\n-        use core::num::Zero;\n+        use std::num::Zero;\n \n         #[test]\n         fn test_add() {\n             assert_eq!(_05_05i + _05_05i, _1_1i);\n             assert_eq!(_0_1i + _1_0i, _1_1i);\n             assert_eq!(_1_0i + _neg1_1i, _0_1i);\n \n-            for all_consts.each |&c| {\n+            for all_consts.iter().advance |&c| {\n                 assert_eq!(_0_0i + c, c);\n                 assert_eq!(c + _0_0i, c);\n             }\n@@ -307,7 +306,7 @@ mod test {\n             assert_eq!(_0_1i - _1_0i, _neg1_1i);\n             assert_eq!(_0_1i - _neg1_1i, _1_0i);\n \n-            for all_consts.each |&c| {\n+            for all_consts.iter().advance |&c| {\n                 assert_eq!(c - _0_0i, c);\n                 assert_eq!(c - c, _0_0i);\n             }\n@@ -322,15 +321,15 @@ mod test {\n             assert_eq!(_0_1i * _0_1i, -_1_0i);\n             assert_eq!(_0_1i * _0_1i * _0_1i * _0_1i, _1_0i);\n \n-            for all_consts.each |&c| {\n+            for all_consts.iter().advance |&c| {\n                 assert_eq!(c * _1_0i, c);\n                 assert_eq!(_1_0i * c, c);\n             }\n         }\n         #[test]\n         fn test_div() {\n             assert_eq!(_neg1_1i / _0_1i, _1_1i);\n-            for all_consts.each |&c| {\n+            for all_consts.iter().advance |&c| {\n                 if c != Zero::zero() {\n                     assert_eq!(c / c, _1_0i);\n                 }\n@@ -340,7 +339,7 @@ mod test {\n         fn test_neg() {\n             assert_eq!(-_1_0i + _0_1i, _neg1_1i);\n             assert_eq!((-_0_1i) * _0_1i, _1_0i);\n-            for all_consts.each |&c| {\n+            for all_consts.iter().advance |&c| {\n                 assert_eq!(-(-c), c);\n             }\n         }"}, {"sha": "6733599d1ea27811b21a421c0702c007a58fa3d4", "filename": "src/libextra/num/rational.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Frational.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -10,11 +10,10 @@\n \n //! Rational numbers\n \n-use core::prelude::*;\n \n-use core::cmp;\n-use core::from_str::FromStr;\n-use core::num::{Zero,One,ToStrRadix,FromStrRadix,Round};\n+use std::cmp;\n+use std::from_str::FromStr;\n+use std::num::{Zero,One,ToStrRadix,FromStrRadix,Round};\n use super::bigint::BigInt;\n \n /// Represents the ratio between 2 numbers.\n@@ -277,11 +276,10 @@ impl<T: FromStrRadix + Clone + Integer + Ord>\n \n #[cfg(test)]\n mod test {\n-    use core::prelude::*;\n \n     use super::*;\n-    use core::num::{Zero,One,FromStrRadix,IntConvertible};\n-    use core::from_str::FromStr;\n+    use std::num::{Zero,One,FromStrRadix,IntConvertible};\n+    use std::from_str::FromStr;\n \n     pub static _0 : Rational = Ratio { numer: 0, denom: 1};\n     pub static _1 : Rational = Ratio { numer: 1, denom: 1};\n@@ -482,7 +480,8 @@ mod test {\n             assert_eq!(FromStr::from_str::<Rational>(s), None);\n         }\n \n-        for [\"0 /1\", \"abc\", \"\", \"1/\", \"--1/2\",\"3/2/1\"].each |&s| {\n+        let xs = [\"0 /1\", \"abc\", \"\", \"1/\", \"--1/2\",\"3/2/1\"];\n+        for xs.iter().advance |&s| {\n             test(s);\n         }\n     }\n@@ -521,7 +520,8 @@ mod test {\n             assert_eq!(FromStrRadix::from_str_radix::<Rational>(s, 3), None);\n         }\n \n-        for [\"0 /1\", \"abc\", \"\", \"1/\", \"--1/2\",\"3/2/1\", \"3/2\"].each |&s| {\n+        let xs = [\"0 /1\", \"abc\", \"\", \"1/\", \"--1/2\",\"3/2/1\", \"3/2\"];\n+        for xs.iter().advance |&s| {\n             test(s);\n         }\n     }"}, {"sha": "2878a3ee12215c48f718cda16db559a98d4bfe23", "filename": "src/libextra/par.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpar.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -8,13 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n \n-use core::cast;\n-use core::ptr;\n-use core::sys;\n-use core::uint;\n-use core::vec;\n+use std::cast;\n+use std::ptr;\n+use std::sys;\n+use std::uint;\n+use std::vec;\n use future_spawn = future::spawn;\n \n /**\n@@ -33,7 +32,7 @@ static min_granularity : uint = 1024u;\n  * This is used to build most of the other parallel vector functions,\n  * like map or alli.\n  */\n-fn map_slices<A:Copy + Owned,B:Copy + Owned>(\n+fn map_slices<A:Copy + Send,B:Copy + Send>(\n     xs: &[A],\n     f: &fn() -> ~fn(uint, v: &[A]) -> B)\n     -> ~[B] {\n@@ -88,26 +87,26 @@ fn map_slices<A:Copy + Owned,B:Copy + Owned>(\n }\n \n /// A parallel version of map.\n-pub fn map<A:Copy + Owned,B:Copy + Owned>(\n+pub fn map<A:Copy + Send,B:Copy + Send>(\n     xs: &[A], fn_factory: &fn() -> ~fn(&A) -> B) -> ~[B] {\n     vec::concat(map_slices(xs, || {\n         let f = fn_factory();\n         let result: ~fn(uint, &[A]) -> ~[B] =\n-            |_, slice| vec::map(slice, |x| f(x));\n+            |_, slice| slice.iter().transform(|x| f(x)).collect();\n         result\n     }))\n }\n \n /// A parallel version of mapi.\n-pub fn mapi<A:Copy + Owned,B:Copy + Owned>(\n+pub fn mapi<A:Copy + Send,B:Copy + Send>(\n         xs: &[A],\n         fn_factory: &fn() -> ~fn(uint, &A) -> B) -> ~[B] {\n     let slices = map_slices(xs, || {\n         let f = fn_factory();\n         let result: ~fn(uint, &[A]) -> ~[B] = |base, slice| {\n-            vec::mapi(slice, |i, x| {\n+            slice.iter().enumerate().transform(|(i, x)| {\n                 f(i + base, x)\n-            })\n+            }).collect()\n         };\n         result\n     });\n@@ -118,7 +117,7 @@ pub fn mapi<A:Copy + Owned,B:Copy + Owned>(\n }\n \n /// Returns true if the function holds for all elements in the vector.\n-pub fn alli<A:Copy + Owned>(\n+pub fn alli<A:Copy + Send>(\n     xs: &[A],\n     fn_factory: &fn() -> ~fn(uint, &A) -> bool) -> bool\n {\n@@ -133,7 +132,7 @@ pub fn alli<A:Copy + Owned>(\n }\n \n /// Returns true if the function holds for any elements in the vector.\n-pub fn any<A:Copy + Owned>(\n+pub fn any<A:Copy + Send>(\n     xs: &[A],\n     fn_factory: &fn() -> ~fn(&A) -> bool) -> bool {\n     let mapped = map_slices(xs, || {"}, {"sha": "3d1ca4a9818b61572568b195464f9b104cec37e9", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -12,27 +12,16 @@\n \n #[allow(missing_doc)];\n \n-use core::prelude::*;\n \n-use core::old_iter::BaseIter;\n-use core::unstable::intrinsics::{move_val_init, init};\n-use core::util::{replace, swap};\n-use core::vec;\n+use std::unstable::intrinsics::{move_val_init, init};\n+use std::util::{replace, swap};\n+use std::vec;\n \n-#[allow(missing_doc)]\n+/// A priority queue implemented with a binary heap\n pub struct PriorityQueue<T> {\n     priv data: ~[T],\n }\n \n-impl<T:Ord> BaseIter<T> for PriorityQueue<T> {\n-    /// Visit all values in the underlying vector.\n-    ///\n-    /// The values are **not** visited in order.\n-    fn each(&self, f: &fn(&T) -> bool) -> bool { self.data.each(f) }\n-\n-    fn size_hint(&self) -> Option<uint> { self.data.size_hint() }\n-}\n-\n impl<T:Ord> Container for PriorityQueue<T> {\n     /// Returns the length of the queue\n     fn len(&self) -> uint { self.data.len() }\n@@ -47,6 +36,12 @@ impl<T:Ord> Mutable for PriorityQueue<T> {\n }\n \n impl<T:Ord> PriorityQueue<T> {\n+    /// An iterator visiting all values in underlying vector, in\n+    /// arbitrary order.\n+    pub fn iter<'a>(&'a self) -> PriorityQueueIterator<'a, T> {\n+        PriorityQueueIterator { iter: self.data.iter() }\n+    }\n+\n     /// Returns the greatest item in the queue - fails if empty\n     pub fn top<'a>(&'a self) -> &'a T { &self.data[0] }\n \n@@ -56,12 +51,12 @@ impl<T:Ord> PriorityQueue<T> {\n     }\n \n     /// Returns the number of elements the queue can hold without reallocating\n-    pub fn capacity(&self) -> uint { vec::capacity(&self.data) }\n+    pub fn capacity(&self) -> uint { self.data.capacity() }\n \n-    pub fn reserve(&mut self, n: uint) { vec::reserve(&mut self.data, n) }\n+    pub fn reserve(&mut self, n: uint) { self.data.reserve(n) }\n \n     pub fn reserve_at_least(&mut self, n: uint) {\n-        vec::reserve_at_least(&mut self.data, n)\n+        self.data.reserve_at_least(n)\n     }\n \n     /// Pop the greatest item from the queue - fails if empty\n@@ -112,7 +107,7 @@ impl<T:Ord> PriorityQueue<T> {\n         let mut end = q.len();\n         while end > 1 {\n             end -= 1;\n-            vec::swap(q.data, 0, end);\n+            q.data.swap(0, end);\n             q.siftdown_range(0, end)\n         }\n         q.to_vec()\n@@ -183,11 +178,33 @@ impl<T:Ord> PriorityQueue<T> {\n     }\n }\n \n+/// PriorityQueue iterator\n+pub struct PriorityQueueIterator <'self, T> {\n+    priv iter: vec::VecIterator<'self, T>,\n+}\n+\n+impl<'self, T> Iterator<&'self T> for PriorityQueueIterator<'self, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<(&'self T)> { self.iter.next() }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use sort::merge_sort;\n     use priority_queue::PriorityQueue;\n \n+    #[test]\n+    fn test_iterator() {\n+        let data = ~[5, 9, 3];\n+        let iterout = ~[9, 5, 3];\n+        let pq = PriorityQueue::from_vec(data);\n+        let mut i = 0;\n+        for pq.iter().advance |el| {\n+            assert_eq!(*el, iterout[i]);\n+            i += 1;\n+        }\n+    }\n+\n     #[test]\n     fn test_top_and_pop() {\n         let data = ~[2u, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1];"}, {"sha": "86080b343c78b4c1b3deb5431abcf32bfcb3ccd8", "filename": "src/libextra/rc.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frc.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -13,29 +13,29 @@\n /** Task-local reference counted smart pointers\n \n Task-local reference counted smart pointers are an alternative to managed boxes with deterministic\n-destruction. They are restricted to containing types that are either `Owned` or `Const` (or both) to\n+destruction. They are restricted to containing types that are either `Send` or `Freeze` (or both) to\n prevent cycles.\n \n-Neither `Rc<T>` or `RcMut<T>` is ever `Owned` and `RcMut<T>` is never `Const`. If `T` is `Const`, a\n+Neither `Rc<T>` or `RcMut<T>` is ever `Send` and `RcMut<T>` is never `Freeze`. If `T` is `Freeze`, a\n cycle cannot be created with `Rc<T>` because there is no way to modify it after creation.\n \n */\n \n-use core::prelude::*;\n \n-use core::cast;\n-use core::libc::{c_void, size_t, malloc, free};\n-use core::ptr;\n-use core::sys;\n-use core::unstable::intrinsics;\n+use std::cast;\n+use std::libc::{c_void, size_t, malloc, free};\n+use std::ptr;\n+use std::sys;\n+use std::unstable::intrinsics;\n \n struct RcBox<T> {\n     value: T,\n     count: uint\n }\n \n /// Immutable reference counted pointer type\n-#[non_owned]\n+#[unsafe_no_drop_flag]\n+#[no_send]\n pub struct Rc<T> {\n     priv ptr: *mut RcBox<T>,\n }\n@@ -50,12 +50,12 @@ impl<T> Rc<T> {\n }\n \n // FIXME: #6516: should be a static method\n-pub fn rc_from_owned<T: Owned>(value: T) -> Rc<T> {\n+pub fn rc_from_owned<T: Send>(value: T) -> Rc<T> {\n     unsafe { Rc::new(value) }\n }\n \n // FIXME: #6516: should be a static method\n-pub fn rc_from_const<T: Const>(value: T) -> Rc<T> {\n+pub fn rc_from_const<T: Freeze>(value: T) -> Rc<T> {\n     unsafe { Rc::new(value) }\n }\n \n@@ -68,12 +68,14 @@ impl<T> Rc<T> {\n \n #[unsafe_destructor]\n impl<T> Drop for Rc<T> {\n-    fn finalize(&self) {\n+    fn drop(&self) {\n         unsafe {\n-            (*self.ptr).count -= 1;\n-            if (*self.ptr).count == 0 {\n-                ptr::replace_ptr(self.ptr, intrinsics::uninit());\n-                free(self.ptr as *c_void)\n+            if self.ptr.is_not_null() {\n+                (*self.ptr).count -= 1;\n+                if (*self.ptr).count == 0 {\n+                    ptr::replace_ptr(self.ptr, intrinsics::uninit());\n+                    free(self.ptr as *c_void)\n+                }\n             }\n         }\n     }\n@@ -101,7 +103,7 @@ impl<T: DeepClone> DeepClone for Rc<T> {\n #[cfg(test)]\n mod test_rc {\n     use super::*;\n-    use core::cell::Cell;\n+    use std::cell::Cell;\n \n     #[test]\n     fn test_clone() {\n@@ -165,7 +167,10 @@ struct RcMutBox<T> {\n \n /// Mutable reference counted pointer type\n #[non_owned]\n-#[mutable]\n+#[no_send]\n+#[mutable] // XXX remove after snap\n+#[no_freeze]\n+#[unsafe_no_drop_flag]\n pub struct RcMut<T> {\n     priv ptr: *mut RcMutBox<T>,\n }\n@@ -180,12 +185,12 @@ impl<T> RcMut<T> {\n }\n \n // FIXME: #6516: should be a static method\n-pub fn rc_mut_from_owned<T: Owned>(value: T) -> RcMut<T> {\n+pub fn rc_mut_from_owned<T: Send>(value: T) -> RcMut<T> {\n     unsafe { RcMut::new(value) }\n }\n \n // FIXME: #6516: should be a static method\n-pub fn rc_mut_from_const<T: Const>(value: T) -> RcMut<T> {\n+pub fn rc_mut_from_const<T: Freeze>(value: T) -> RcMut<T> {\n     unsafe { RcMut::new(value) }\n }\n \n@@ -218,12 +223,14 @@ impl<T> RcMut<T> {\n \n #[unsafe_destructor]\n impl<T> Drop for RcMut<T> {\n-    fn finalize(&self) {\n+    fn drop(&self) {\n         unsafe {\n-            (*self.ptr).count -= 1;\n-            if (*self.ptr).count == 0 {\n-                ptr::replace_ptr(self.ptr, uninit());\n-                free(self.ptr as *c_void)\n+            if self.ptr.is_not_null() {\n+                (*self.ptr).count -= 1;\n+                if (*self.ptr).count == 0 {\n+                    ptr::replace_ptr(self.ptr, uninit());\n+                    free(self.ptr as *c_void)\n+                }\n             }\n         }\n     }"}, {"sha": "693e3ecb53fb67fb07902eb42f0fedbb1b3b6cba", "filename": "src/libextra/rl.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frl.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -11,14 +11,13 @@\n // FIXME #3921. This is unsafe because linenoise uses global mutable\n // state without mutexes.\n \n-use core::prelude::*;\n \n-use core::libc::{c_char, c_int};\n-use core::local_data;\n-use core::str;\n+use std::libc::{c_char, c_int};\n+use std::local_data;\n+use std::str;\n \n pub mod rustrt {\n-    use core::libc::{c_char, c_int};\n+    use std::libc::{c_char, c_int};\n \n     pub extern {\n         pub unsafe fn linenoise(prompt: *c_char) -> *c_char;"}, {"sha": "8374c1a86e31da4d4b4463b5aee346a672b5b9ec", "filename": "src/libextra/rope.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frope.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -35,11 +35,10 @@\n \n #[allow(missing_doc)];\n \n-use core::prelude::*;\n \n-use core::uint;\n-use core::vec;\n-use core::str;\n+use std::uint;\n+use std::vec;\n+use std::str;\n \n /// The type of ropes.\n pub type Rope = node::Root;\n@@ -447,7 +446,6 @@ pub fn loop_leaves(rope: Rope, it: &fn(node::Leaf) -> bool) -> bool{\n \n pub mod iterator {\n     pub mod leaf {\n-        use core::prelude::*;\n \n         use rope::{Rope, node};\n \n@@ -462,7 +460,6 @@ pub mod iterator {\n         }\n     }\n     pub mod char {\n-        use core::prelude::*;\n \n         use rope::{Rope, node};\n \n@@ -558,13 +555,12 @@ pub fn char_at(rope: Rope, pos: uint) -> char {\n  Section: Implementation\n */\n pub mod node {\n-    use core::prelude::*;\n \n     use rope::node;\n \n-    use core::cast;\n-    use core::uint;\n-    use core::vec;\n+    use std::cast;\n+    use std::uint;\n+    use std::vec;\n \n     /// Implementation of type `rope`\n     pub enum Root {\n@@ -1078,7 +1074,7 @@ pub mod node {\n \n     pub fn loop_chars(node: @Node, it: &fn(c: char) -> bool) -> bool {\n         return loop_leaves(node,|leaf| {\n-            leaf.content.slice(leaf.byte_offset, leaf.byte_len).iter().all(it)\n+            leaf.content.slice(leaf.byte_offset, leaf.byte_len).iter().all(|c| it(c))\n         });\n     }\n \n@@ -1101,7 +1097,7 @@ pub mod node {\n         loop {\n             match (*current) {\n               Leaf(x) => return it(x),\n-              Concat(ref x) => if loop_leaves(x.left, it) { //non tail call\n+              Concat(ref x) => if loop_leaves(x.left, |l| it(l)) { //non tail call\n                 current = x.right;       //tail call\n               } else {\n                 return false;\n@@ -1141,11 +1137,10 @@ pub mod node {\n     }\n \n     pub mod leaf_iterator {\n-        use core::prelude::*;\n \n         use rope::node::{Concat, Leaf, Node, height};\n \n-        use core::vec;\n+        use std::vec;\n \n         pub struct T {\n             stack: ~[@Node],\n@@ -1184,7 +1179,6 @@ pub mod node {\n     }\n \n     pub mod char_iterator {\n-        use core::prelude::*;\n \n         use rope::node::{Leaf, Node};\n         use rope::node::leaf_iterator;\n@@ -1267,12 +1261,11 @@ pub mod node {\n \n #[cfg(test)]\n mod tests {\n-    use core::prelude::*;\n \n     use rope::*;\n \n-    use core::uint;\n-    use core::vec;\n+    use std::uint;\n+    use std::vec;\n \n     //Utility function, used for sanity check\n     fn rope_to_string(r: Rope) -> ~str {"}, {"sha": "6c9453a5a3ba1140067c1286bc46c39ddfd342ae", "filename": "src/libextra/semver.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsemver.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -12,15 +12,14 @@\n \n #[allow(missing_doc)];\n \n-use core::prelude::*;\n \n-use core::char;\n-use core::cmp;\n-use core::io::{ReaderUtil};\n-use core::io;\n-use core::option::{Option, Some, None};\n-use core::to_str::ToStr;\n-use core::uint;\n+use std::char;\n+use std::cmp;\n+use std::io::{ReaderUtil};\n+use std::io;\n+use std::option::{Option, Some, None};\n+use std::to_str::ToStr;\n+use std::uint;\n \n #[deriving(Eq)]\n pub enum Identifier {\n@@ -79,12 +78,12 @@ impl ToStr for Version {\n         let s = if self.pre.is_empty() {\n             s\n         } else {\n-            s + \"-\" + self.pre.map(|i| i.to_str()).connect(\".\")\n+            fmt!(\"%s-%s\", s, self.pre.map(|i| i.to_str()).connect(\".\"))\n         };\n         if self.build.is_empty() {\n             s\n         } else {\n-            s + \"+\" + self.build.map(|i| i.to_str()).connect(\".\")\n+            fmt!(\"%s+%s\", s, self.build.map(|i| i.to_str()).connect(\".\"))\n         }\n     }\n }"}, {"sha": "66b178f49f7f74060ac33b3f0bc3093ca75ba09e", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -17,13 +17,12 @@ Core encoding and decoding interfaces.\n #[allow(missing_doc)];\n #[forbid(non_camel_case_types)];\n \n-use core::prelude::*;\n \n-use core::at_vec;\n-use core::hashmap::{HashMap, HashSet};\n-use core::trie::{TrieMap, TrieSet};\n-use core::uint;\n-use core::vec;\n+use std::at_vec;\n+use std::hashmap::{HashMap, HashSet};\n+use std::trie::{TrieMap, TrieSet};\n+use std::uint;\n+use std::vec;\n use deque::Deque;\n use dlist::DList;\n use treemap::{TreeMap, TreeSet};\n@@ -432,7 +431,7 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for @T {\n impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self [T] {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n-            for self.eachi |i, e| {\n+            for self.iter().enumerate().advance |(i, e)| {\n                 s.emit_seq_elt(i, |s| e.encode(s))\n             }\n         }\n@@ -442,7 +441,7 @@ impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self [T] {\n impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~[T] {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n-            for self.eachi |i, e| {\n+            for self.iter().enumerate().advance |(i, e)| {\n                 s.emit_seq_elt(i, |s| e.encode(s))\n             }\n         }\n@@ -462,7 +461,7 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n impl<S:Encoder,T:Encodable<S>> Encodable<S> for @[T] {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n-            for self.eachi |i, e| {\n+            for self.iter().enumerate().advance |(i, e)| {\n                 s.emit_seq_elt(i, |s| e.encode(s))\n             }\n         }\n@@ -710,7 +709,7 @@ impl<\n     fn encode(&self, e: &mut E) {\n         do e.emit_map(self.len()) |e| {\n             let mut i = 0;\n-            for self.each |key, val| {\n+            for self.iter().advance |(key, val)| {\n                 e.emit_map_elt_key(i, |e| key.encode(e));\n                 e.emit_map_elt_val(i, |e| val.encode(e));\n                 i += 1;\n@@ -744,7 +743,7 @@ impl<\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n             let mut i = 0;\n-            for self.each |e| {\n+            for self.iter().advance |e| {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n                 i += 1;\n             }\n@@ -832,7 +831,7 @@ impl<\n     fn encode(&self, e: &mut E) {\n         do e.emit_map(self.len()) |e| {\n             let mut i = 0;\n-            for self.each |key, val| {\n+            for self.iter().advance |(key, val)| {\n                 e.emit_map_elt_key(i, |e| key.encode(e));\n                 e.emit_map_elt_val(i, |e| val.encode(e));\n                 i += 1;\n@@ -866,7 +865,7 @@ impl<\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n             let mut i = 0;\n-            for self.each |e| {\n+            for self.iter().advance |e| {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n                 i += 1;\n             }\n@@ -901,7 +900,7 @@ pub trait EncoderHelpers {\n impl<S:Encoder> EncoderHelpers for S {\n     fn emit_from_vec<T>(&mut self, v: &[T], f: &fn(&mut S, &T)) {\n         do self.emit_seq(v.len()) |this| {\n-            for v.eachi |i, e| {\n+            for v.iter().enumerate().advance |(i, e)| {\n                 do this.emit_seq_elt(i) |this| {\n                     f(this, e)\n                 }"}, {"sha": "7c4b3f4ce39f7345ddaa9ed49912cc20d14854c9", "filename": "src/libextra/sha1.rs", "status": "removed", "additions": 0, "deletions": 410, "changes": 410, "blob_url": "https://github.com/rust-lang/rust/blob/b60cf0c5b0cf36625083c2624df9fb35d0af3578/src%2Flibextra%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b60cf0c5b0cf36625083c2624df9fb35d0af3578/src%2Flibextra%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsha1.rs?ref=b60cf0c5b0cf36625083c2624df9fb35d0af3578", "patch": "@@ -1,410 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * An implementation of the SHA-1 cryptographic hash.\n- *\n- * First create a `sha1` object using the `sha1` constructor, then\n- * feed it input using the `input` or `input_str` methods, which may be\n- * called any number of times.\n- *\n- * After the entire input has been fed to the hash read the result using\n- * the `result` or `result_str` methods.\n- *\n- * The `sha1` object may be reused to create multiple hashes by calling\n- * the `reset` method.\n- */\n-\n-use core::prelude::*;\n-\n-use core::uint;\n-use core::vec;\n-\n-/*\n- * A SHA-1 implementation derived from Paul E. Jones's reference\n- * implementation, which is written for clarity, not speed. At some\n- * point this will want to be rewritten.\n- */\n-\n-/// The SHA-1 interface\n-trait Sha1 {\n-    /// Provide message input as bytes\n-    fn input(&mut self, &const [u8]);\n-    /// Provide message input as string\n-    fn input_str(&mut self, &str);\n-    /**\n-     * Read the digest as a vector of 20 bytes. After calling this no further\n-     * input may be provided until reset is called.\n-     */\n-    fn result(&mut self) -> ~[u8];\n-    /**\n-     * Read the digest as a hex string. After calling this no further\n-     * input may be provided until reset is called.\n-     */\n-    fn result_str(&mut self) -> ~str;\n-    /// Reset the SHA-1 state for reuse\n-    fn reset(&mut self);\n-}\n-\n-// Some unexported constants\n-static digest_buf_len: uint = 5u;\n-static msg_block_len: uint = 64u;\n-static work_buf_len: uint = 80u;\n-static k0: u32 = 0x5A827999u32;\n-static k1: u32 = 0x6ED9EBA1u32;\n-static k2: u32 = 0x8F1BBCDCu32;\n-static k3: u32 = 0xCA62C1D6u32;\n-\n-\n-/// Construct a `sha` object\n-pub fn sha1() -> @Sha1 {\n-    struct Sha1State\n-        { h: ~[u32],\n-          len_low: u32,\n-          len_high: u32,\n-          msg_block: ~[u8],\n-          msg_block_idx: uint,\n-          computed: bool,\n-          work_buf: @mut ~[u32]};\n-\n-    fn add_input(st: &mut Sha1State, msg: &const [u8]) {\n-        assert!((!st.computed));\n-        for vec::each_const(msg) |element| {\n-            st.msg_block[st.msg_block_idx] = *element;\n-            st.msg_block_idx += 1u;\n-            st.len_low += 8u32;\n-            if st.len_low == 0u32 {\n-                st.len_high += 1u32;\n-                if st.len_high == 0u32 {\n-                    // FIXME: Need better failure mode (#2346)\n-                    fail!();\n-                }\n-            }\n-            if st.msg_block_idx == msg_block_len { process_msg_block(st); }\n-        }\n-    }\n-    fn process_msg_block(st: &mut Sha1State) {\n-        assert_eq!(st.h.len(), digest_buf_len);\n-        assert_eq!(st.work_buf.len(), work_buf_len);\n-        let mut t: int; // Loop counter\n-        let w = st.work_buf;\n-\n-        // Initialize the first 16 words of the vector w\n-        t = 0;\n-        while t < 16 {\n-            let mut tmp;\n-            tmp = (st.msg_block[t * 4] as u32) << 24u32;\n-            tmp = tmp | (st.msg_block[t * 4 + 1] as u32) << 16u32;\n-            tmp = tmp | (st.msg_block[t * 4 + 2] as u32) << 8u32;\n-            tmp = tmp | (st.msg_block[t * 4 + 3] as u32);\n-            w[t] = tmp;\n-            t += 1;\n-        }\n-\n-        // Initialize the rest of vector w\n-        while t < 80 {\n-            let val = w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16];\n-            w[t] = circular_shift(1u32, val);\n-            t += 1;\n-        }\n-        let mut a = st.h[0];\n-        let mut b = st.h[1];\n-        let mut c = st.h[2];\n-        let mut d = st.h[3];\n-        let mut e = st.h[4];\n-        let mut temp: u32;\n-        t = 0;\n-        while t < 20 {\n-            temp = circular_shift(5u32, a) + (b & c | !b & d) + e + w[t] + k0;\n-            e = d;\n-            d = c;\n-            c = circular_shift(30u32, b);\n-            b = a;\n-            a = temp;\n-            t += 1;\n-        }\n-        while t < 40 {\n-            temp = circular_shift(5u32, a) + (b ^ c ^ d) + e + w[t] + k1;\n-            e = d;\n-            d = c;\n-            c = circular_shift(30u32, b);\n-            b = a;\n-            a = temp;\n-            t += 1;\n-        }\n-        while t < 60 {\n-            temp =\n-                circular_shift(5u32, a) + (b & c | b & d | c & d) + e + w[t] +\n-                    k2;\n-            e = d;\n-            d = c;\n-            c = circular_shift(30u32, b);\n-            b = a;\n-            a = temp;\n-            t += 1;\n-        }\n-        while t < 80 {\n-            temp = circular_shift(5u32, a) + (b ^ c ^ d) + e + w[t] + k3;\n-            e = d;\n-            d = c;\n-            c = circular_shift(30u32, b);\n-            b = a;\n-            a = temp;\n-            t += 1;\n-        }\n-        st.h[0] = st.h[0] + a;\n-        st.h[1] = st.h[1] + b;\n-        st.h[2] = st.h[2] + c;\n-        st.h[3] = st.h[3] + d;\n-        st.h[4] = st.h[4] + e;\n-        st.msg_block_idx = 0u;\n-    }\n-    fn circular_shift(bits: u32, word: u32) -> u32 {\n-        return word << bits | word >> 32u32 - bits;\n-    }\n-    fn mk_result(st: &mut Sha1State) -> ~[u8] {\n-        if !(*st).computed { pad_msg(st); (*st).computed = true; }\n-        let mut rs: ~[u8] = ~[];\n-        for st.h.mut_iter().advance |ptr_hpart| {\n-            let hpart = *ptr_hpart;\n-            let a = (hpart >> 24u32 & 0xFFu32) as u8;\n-            let b = (hpart >> 16u32 & 0xFFu32) as u8;\n-            let c = (hpart >> 8u32 & 0xFFu32) as u8;\n-            let d = (hpart & 0xFFu32) as u8;\n-            rs = vec::append(copy rs, [a, b, c, d]);\n-        }\n-        return rs;\n-    }\n-\n-    /*\n-     * According to the standard, the message must be padded to an even\n-     * 512 bits.  The first padding bit must be a '1'.  The last 64 bits\n-     * represent the length of the original message.  All bits in between\n-     * should be 0.  This function will pad the message according to those\n-     * rules by filling the msg_block vector accordingly.  It will also\n-     * call process_msg_block() appropriately.  When it returns, it\n-     * can be assumed that the message digest has been computed.\n-     */\n-    fn pad_msg(st: &mut Sha1State) {\n-        assert_eq!((*st).msg_block.len(), msg_block_len);\n-\n-        /*\n-         * Check to see if the current message block is too small to hold\n-         * the initial padding bits and length.  If so, we will pad the\n-         * block, process it, and then continue padding into a second block.\n-         */\n-        if (*st).msg_block_idx > 55u {\n-            (*st).msg_block[(*st).msg_block_idx] = 0x80u8;\n-            (*st).msg_block_idx += 1u;\n-            while (*st).msg_block_idx < msg_block_len {\n-                (*st).msg_block[(*st).msg_block_idx] = 0u8;\n-                (*st).msg_block_idx += 1u;\n-            }\n-            process_msg_block(st);\n-        } else {\n-            (*st).msg_block[(*st).msg_block_idx] = 0x80u8;\n-            (*st).msg_block_idx += 1u;\n-        }\n-        while (*st).msg_block_idx < 56u {\n-            (*st).msg_block[(*st).msg_block_idx] = 0u8;\n-            (*st).msg_block_idx += 1u;\n-        }\n-\n-        // Store the message length as the last 8 octets\n-        (*st).msg_block[56] = ((*st).len_high >> 24u32 & 0xFFu32) as u8;\n-        (*st).msg_block[57] = ((*st).len_high >> 16u32 & 0xFFu32) as u8;\n-        (*st).msg_block[58] = ((*st).len_high >> 8u32 & 0xFFu32) as u8;\n-        (*st).msg_block[59] = ((*st).len_high & 0xFFu32) as u8;\n-        (*st).msg_block[60] = ((*st).len_low >> 24u32 & 0xFFu32) as u8;\n-        (*st).msg_block[61] = ((*st).len_low >> 16u32 & 0xFFu32) as u8;\n-        (*st).msg_block[62] = ((*st).len_low >> 8u32 & 0xFFu32) as u8;\n-        (*st).msg_block[63] = ((*st).len_low & 0xFFu32) as u8;\n-        process_msg_block(st);\n-    }\n-\n-    impl Sha1 for Sha1State {\n-        fn reset(&mut self) {\n-            assert_eq!(self.h.len(), digest_buf_len);\n-            self.len_low = 0u32;\n-            self.len_high = 0u32;\n-            self.msg_block_idx = 0u;\n-            self.h[0] = 0x67452301u32;\n-            self.h[1] = 0xEFCDAB89u32;\n-            self.h[2] = 0x98BADCFEu32;\n-            self.h[3] = 0x10325476u32;\n-            self.h[4] = 0xC3D2E1F0u32;\n-            self.computed = false;\n-        }\n-        fn input(&mut self, msg: &const [u8]) { add_input(self, msg); }\n-        fn input_str(&mut self, msg: &str) {\n-            add_input(self, msg.as_bytes());\n-        }\n-        fn result(&mut self) -> ~[u8] { return mk_result(self); }\n-        fn result_str(&mut self) -> ~str {\n-            let rr = mk_result(self);\n-            let mut s = ~\"\";\n-            for rr.each |b| {\n-                let hex = uint::to_str_radix(*b as uint, 16u);\n-                if hex.len() == 1 {\n-                    s += \"0\";\n-                }\n-                s += hex;\n-            }\n-            return s;\n-        }\n-    }\n-    let st = Sha1State {\n-         h: vec::from_elem(digest_buf_len, 0u32),\n-         len_low: 0u32,\n-         len_high: 0u32,\n-         msg_block: vec::from_elem(msg_block_len, 0u8),\n-         msg_block_idx: 0u,\n-         computed: false,\n-         work_buf: @mut vec::from_elem(work_buf_len, 0u32)\n-    };\n-    let mut sh = @st as @Sha1;\n-    sh.reset();\n-    return sh;\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use sha1;\n-\n-    #[test]\n-    fn test() {\n-        struct Test {\n-            input: ~str,\n-            output: ~[u8],\n-            output_str: ~str,\n-        }\n-\n-        fn a_million_letter_a() -> ~str {\n-            let mut i = 0;\n-            let mut rs = ~\"\";\n-            while i < 100000 {\n-                rs.push_str(\"aaaaaaaaaa\");\n-                i += 1;\n-            }\n-            return rs;\n-        }\n-        // Test messages from FIPS 180-1\n-\n-        let fips_180_1_tests = ~[\n-            Test {\n-                input: ~\"abc\",\n-                output: ~[\n-                    0xA9u8, 0x99u8, 0x3Eu8, 0x36u8,\n-                    0x47u8, 0x06u8, 0x81u8, 0x6Au8,\n-                    0xBAu8, 0x3Eu8, 0x25u8, 0x71u8,\n-                    0x78u8, 0x50u8, 0xC2u8, 0x6Cu8,\n-                    0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8,\n-                ],\n-                output_str: ~\"a9993e364706816aba3e25717850c26c9cd0d89d\"\n-            },\n-            Test {\n-                input:\n-                     ~\"abcdbcdecdefdefgefghfghighij\" +\n-                     \"hijkijkljklmklmnlmnomnopnopq\",\n-                output: ~[\n-                    0x84u8, 0x98u8, 0x3Eu8, 0x44u8,\n-                    0x1Cu8, 0x3Bu8, 0xD2u8, 0x6Eu8,\n-                    0xBAu8, 0xAEu8, 0x4Au8, 0xA1u8,\n-                    0xF9u8, 0x51u8, 0x29u8, 0xE5u8,\n-                    0xE5u8, 0x46u8, 0x70u8, 0xF1u8,\n-                ],\n-                output_str: ~\"84983e441c3bd26ebaae4aa1f95129e5e54670f1\"\n-            },\n-            Test {\n-                input: a_million_letter_a(),\n-                output: ~[\n-                    0x34u8, 0xAAu8, 0x97u8, 0x3Cu8,\n-                    0xD4u8, 0xC4u8, 0xDAu8, 0xA4u8,\n-                    0xF6u8, 0x1Eu8, 0xEBu8, 0x2Bu8,\n-                    0xDBu8, 0xADu8, 0x27u8, 0x31u8,\n-                    0x65u8, 0x34u8, 0x01u8, 0x6Fu8,\n-                ],\n-                output_str: ~\"34aa973cd4c4daa4f61eeb2bdbad27316534016f\"\n-            },\n-        ];\n-        // Examples from wikipedia\n-\n-        let wikipedia_tests = ~[\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog\",\n-                output: ~[\n-                    0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8,\n-                    0x7au8, 0x2du8, 0x28u8, 0xfcu8,\n-                    0xedu8, 0x84u8, 0x9eu8, 0xe1u8,\n-                    0xbbu8, 0x76u8, 0xe7u8, 0x39u8,\n-                    0x1bu8, 0x93u8, 0xebu8, 0x12u8,\n-                ],\n-                output_str: ~\"2fd4e1c67a2d28fced849ee1bb76e7391b93eb12\",\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy cog\",\n-                output: ~[\n-                    0xdeu8, 0x9fu8, 0x2cu8, 0x7fu8,\n-                    0xd2u8, 0x5eu8, 0x1bu8, 0x3au8,\n-                    0xfau8, 0xd3u8, 0xe8u8, 0x5au8,\n-                    0x0bu8, 0xd1u8, 0x7du8, 0x9bu8,\n-                    0x10u8, 0x0du8, 0xb4u8, 0xb3u8,\n-                ],\n-                output_str: ~\"de9f2c7fd25e1b3afad3e85a0bd17d9b100db4b3\",\n-            },\n-        ];\n-        let tests = fips_180_1_tests + wikipedia_tests;\n-        fn check_vec_eq(v0: ~[u8], v1: ~[u8]) {\n-            assert_eq!(v0.len(), v1.len());\n-            let len = v0.len();\n-            let mut i = 0u;\n-            while i < len {\n-                let a = v0[i];\n-                let b = v1[i];\n-                assert_eq!(a, b);\n-                i += 1u;\n-            }\n-        }\n-        // Test that it works when accepting the message all at once\n-\n-        let mut sh = sha1::sha1();\n-        for tests.each |t| {\n-            sh.input_str(t.input);\n-            let out = sh.result();\n-            check_vec_eq(copy t.output, out);\n-\n-            let out_str = sh.result_str();\n-            assert_eq!(out_str.len(), 40);\n-            assert!(out_str == t.output_str);\n-\n-            sh.reset();\n-        }\n-\n-\n-        // Test that it works when accepting the message in pieces\n-        for tests.each |t| {\n-            let len = t.input.len();\n-            let mut left = len;\n-            while left > 0u {\n-                let take = (left + 1u) / 2u;\n-                sh.input_str(t.input.slice(len - left, take + len - left));\n-                left = left - take;\n-            }\n-            let out = sh.result();\n-            check_vec_eq(copy t.output, out);\n-\n-            let out_str = sh.result_str();\n-            assert_eq!(out_str.len(), 40);\n-            assert!(out_str == t.output_str);\n-\n-            sh.reset();\n-        }\n-    }\n-}"}, {"sha": "9cfe7cf5e4a1b302a09cf529ee5ba849dada74b4", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 48, "deletions": 57, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -15,15 +15,11 @@\n \n #[allow(missing_doc)];\n \n-use core::prelude::*;\n \n-use core::cmp;\n-use core::container::{Container, Mutable, Map, Set};\n-use core::old_iter::BaseIter;\n-use core::old_iter;\n-use core::uint;\n-use core::util::replace;\n-use core::vec;\n+use std::cmp;\n+use std::container::{Container, Mutable, Map, Set};\n+use std::uint;\n+use std::util::replace;\n \n #[allow(missing_doc)]\n pub struct SmallIntMap<T> {\n@@ -58,38 +54,6 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n         self.find(key).is_some()\n     }\n \n-    /// Visit all key-value pairs in order\n-    fn each<'a>(&'a self, it: &fn(&uint, &'a V) -> bool) -> bool {\n-        for uint::range(0, self.v.len()) |i| {\n-            match self.v[i] {\n-              Some(ref elt) => if !it(&i, elt) { return false; },\n-              None => ()\n-            }\n-        }\n-        return true;\n-    }\n-\n-    /// Visit all keys in order\n-    fn each_key(&self, blk: &fn(key: &uint) -> bool) -> bool {\n-        self.each(|k, _| blk(k))\n-    }\n-\n-    /// Visit all values in order\n-    fn each_value<'a>(&'a self, blk: &fn(value: &'a V) -> bool) -> bool {\n-        self.each(|_, v| blk(v))\n-    }\n-\n-    /// Iterate over the map and mutate the contained values\n-    fn mutate_values(&mut self, it: &fn(&uint, &mut V) -> bool) -> bool {\n-        for uint::range(0, self.v.len()) |i| {\n-            match self.v[i] {\n-              Some(ref mut elt) => if !it(&i, elt) { return false; },\n-              None => ()\n-            }\n-        }\n-        return true;\n-    }\n-\n     /// Return a reference to the value corresponding to the key\n     fn find<'a>(&'a self, key: &uint) -> Option<&'a V> {\n         if *key < self.v.len() {\n@@ -121,7 +85,7 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n         let exists = self.contains_key(&key);\n         let len = self.v.len();\n         if len <= key {\n-            vec::grow_fn(&mut self.v, key - len + 1, |_| None);\n+            self.v.grow_fn(key - len + 1, |_| None);\n         }\n         self.v[key] = Some(value);\n         !exists\n@@ -158,6 +122,38 @@ impl<V> SmallIntMap<V> {\n     /// Create an empty SmallIntMap\n     pub fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }\n \n+    /// Visit all key-value pairs in order\n+    pub fn each<'a>(&'a self, it: &fn(&uint, &'a V) -> bool) -> bool {\n+        for uint::range(0, self.v.len()) |i| {\n+            match self.v[i] {\n+              Some(ref elt) => if !it(&i, elt) { return false; },\n+              None => ()\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /// Visit all keys in order\n+    pub fn each_key(&self, blk: &fn(key: &uint) -> bool) -> bool {\n+        self.each(|k, _| blk(k))\n+    }\n+\n+    /// Visit all values in order\n+    pub fn each_value<'a>(&'a self, blk: &fn(value: &'a V) -> bool) -> bool {\n+        self.each(|_, v| blk(v))\n+    }\n+\n+    /// Iterate over the map and mutate the contained values\n+    pub fn mutate_values(&mut self, it: &fn(&uint, &mut V) -> bool) -> bool {\n+        for uint::range(0, self.v.len()) |i| {\n+            match self.v[i] {\n+              Some(ref mut elt) => if !it(&i, elt) { return false; },\n+              None => ()\n+            }\n+        }\n+        return true;\n+    }\n+\n     /// Visit all key-value pairs in reverse order\n     pub fn each_reverse<'a>(&'a self, it: &fn(uint, &'a V) -> bool) -> bool {\n         for uint::range_rev(self.v.len(), 0) |i| {\n@@ -212,12 +208,6 @@ impl Mutable for SmallIntSet {\n     fn clear(&mut self) { self.map.clear() }\n }\n \n-impl BaseIter<uint> for SmallIntSet {\n-    /// Visit all values in order\n-    fn each(&self, f: &fn(&uint) -> bool) -> bool { self.map.each_key(f) }\n-    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n-}\n-\n impl Set<uint> for SmallIntSet {\n     /// Return true if the set contains a value\n     fn contains(&self, value: &uint) -> bool { self.map.contains_key(value) }\n@@ -233,12 +223,14 @@ impl Set<uint> for SmallIntSet {\n     /// Return true if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty uintersection.\n     fn is_disjoint(&self, other: &SmallIntSet) -> bool {\n-        old_iter::all(self, |v| !other.contains(v))\n+        for self.each |v| { if other.contains(v) { return false } }\n+        true\n     }\n \n     /// Return true if the set is a subset of another\n     fn is_subset(&self, other: &SmallIntSet) -> bool {\n-        old_iter::all(self, |v| other.contains(v))\n+        for self.each |v| { if !other.contains(v) { return false } }\n+        true\n     }\n \n     /// Return true if the set is a superset of another\n@@ -286,11 +278,13 @@ impl Set<uint> for SmallIntSet {\n impl SmallIntSet {\n     /// Create an empty SmallIntSet\n     pub fn new() -> SmallIntSet { SmallIntSet{map: SmallIntMap::new()} }\n+\n+    /// Visit all values in order\n+    pub fn each(&self, f: &fn(&uint) -> bool) -> bool { self.map.each_key(f) }\n }\n \n #[cfg(test)]\n mod tests {\n-    use core::prelude::*;\n \n     use super::SmallIntMap;\n \n@@ -385,12 +379,9 @@ mod tests {\n \n #[cfg(test)]\n mod test_set {\n-    use core::prelude::*;\n \n     use super::SmallIntSet;\n \n-    use core::vec;\n-\n     #[test]\n     fn test_disjoint() {\n         let mut xs = SmallIntSet::new();\n@@ -462,7 +453,7 @@ mod test_set {\n         let mut i = 0;\n         let expected = [3, 5, 11, 77];\n         for a.intersection(&b) |x| {\n-            assert!(vec::contains(expected, x));\n+            assert!(expected.contains(x));\n             i += 1\n         }\n         assert_eq!(i, expected.len());\n@@ -485,7 +476,7 @@ mod test_set {\n         let mut i = 0;\n         let expected = [1, 5, 11];\n         for a.difference(&b) |x| {\n-            assert!(vec::contains(expected, x));\n+            assert!(expected.contains(x));\n             i += 1\n         }\n         assert_eq!(i, expected.len());\n@@ -510,7 +501,7 @@ mod test_set {\n         let mut i = 0;\n         let expected = [1, 5, 11, 14, 22];\n         for a.symmetric_difference(&b) |x| {\n-            assert!(vec::contains(expected, x));\n+            assert!(expected.contains(x));\n             i += 1\n         }\n         assert_eq!(i, expected.len());\n@@ -539,7 +530,7 @@ mod test_set {\n         let mut i = 0;\n         let expected = [1, 3, 5, 9, 11, 13, 16, 19, 24];\n         for a.union(&b) |x| {\n-            assert!(vec::contains(expected, x));\n+            assert!(expected.contains(x));\n             i += 1\n         }\n         assert_eq!(i, expected.len());"}, {"sha": "f59a2414aaeb7b40b33c3545aeea42875992a3c8", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 56, "deletions": 60, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -10,12 +10,11 @@\n \n //! Sorting methods\n \n-use core::prelude::*;\n \n-use core::cmp::{Eq, Ord};\n-use core::uint;\n-use core::util::swap;\n-use core::vec;\n+use std::cmp::{Eq, Ord};\n+use std::uint;\n+use std::util::swap;\n+use std::vec;\n \n type Le<'self, T> = &'self fn(v1: &T, v2: &T) -> bool;\n \n@@ -42,7 +41,8 @@ pub fn merge_sort<T:Copy>(v: &[T], le: Le<T>) -> ~[T] {\n         let mid = v_len / 2 + begin;\n         let a = (begin, mid);\n         let b = (mid, end);\n-        return merge(le, merge_sort_(v, a, le), merge_sort_(v, b, le));\n+        return merge(|x,y| le(x,y), merge_sort_(v, a, |x,y| le(x,y)),\n+                                    merge_sort_(v, b, |x,y| le(x,y)));\n     }\n \n     fn merge<T:Copy>(le: Le<T>, a: &[T], b: &[T]) -> ~[T] {\n@@ -57,36 +57,36 @@ pub fn merge_sort<T:Copy>(v: &[T], le: Le<T>) -> ~[T] {\n                 a_ix += 1;\n             } else { rs.push(copy b[b_ix]); b_ix += 1; }\n         }\n-        rs.push_all(vec::slice(a, a_ix, a_len));\n-        rs.push_all(vec::slice(b, b_ix, b_len));\n+        rs.push_all(a.slice(a_ix, a_len));\n+        rs.push_all(b.slice(b_ix, b_len));\n         rs\n     }\n }\n \n fn part<T>(arr: &mut [T], left: uint,\n            right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n-    vec::swap(arr, pivot, right);\n+    arr.swap(pivot, right);\n     let mut storage_index: uint = left;\n     let mut i: uint = left;\n     while i < right {\n         if compare_func(&arr[i], &arr[right]) {\n-            vec::swap(arr, i, storage_index);\n+            arr.swap(i, storage_index);\n             storage_index += 1;\n         }\n         i += 1;\n     }\n-    vec::swap(arr, storage_index, right);\n+    arr.swap(storage_index, right);\n     return storage_index;\n }\n \n fn qsort<T>(arr: &mut [T], left: uint,\n             right: uint, compare_func: Le<T>) {\n     if right > left {\n         let pivot = (left + right) / 2u;\n-        let new_pivot = part::<T>(arr, left, right, pivot, compare_func);\n+        let new_pivot = part::<T>(arr, left, right, pivot, |x,y| compare_func(x,y));\n         if new_pivot != 0u {\n             // Need to do this check before recursing due to overflow\n-            qsort::<T>(arr, left, new_pivot - 1u, compare_func);\n+            qsort::<T>(arr, left, new_pivot - 1u, |x,y| compare_func(x,y));\n         }\n         qsort::<T>(arr, new_pivot + 1u, right, compare_func);\n     }\n@@ -120,29 +120,29 @@ fn qsort3<T:Copy + Ord + Eq>(arr: &mut [T], left: int, right: int) {\n             j -= 1;\n         }\n         if i >= j { break; }\n-        vec::swap(arr, i as uint, j as uint);\n+        arr.swap(i as uint, j as uint);\n         if arr[i] == v {\n             p += 1;\n-            vec::swap(arr, p as uint, i as uint);\n+            arr.swap(p as uint, i as uint);\n         }\n         if v == arr[j] {\n             q -= 1;\n-            vec::swap(arr, j as uint, q as uint);\n+            arr.swap(j as uint, q as uint);\n         }\n     }\n-    vec::swap(arr, i as uint, right as uint);\n+    arr.swap(i as uint, right as uint);\n     j = i - 1;\n     i += 1;\n     let mut k: int = left;\n     while k < p {\n-        vec::swap(arr, k as uint, j as uint);\n+        arr.swap(k as uint, j as uint);\n         k += 1;\n         j -= 1;\n         if k == arr.len() as int { break; }\n     }\n     k = right - 1;\n     while k > q {\n-        vec::swap(arr, i as uint, k as uint);\n+        arr.swap(i as uint, k as uint);\n         k -= 1;\n         i += 1;\n         if k == 0 { break; }\n@@ -201,12 +201,12 @@ pub fn tim_sort<T:Copy + Ord>(array: &mut [T]) {\n     loop {\n         let run_len: uint = {\n             // This scope contains the slice `arr` here:\n-            let arr = vec::mut_slice(array, idx, size);\n+            let arr = array.mut_slice(idx, size);\n             let mut run_len: uint = count_run_ascending(arr);\n \n             if run_len < min_run {\n                 let force = if remaining <= min_run {remaining} else {min_run};\n-                let slice = vec::mut_slice(arr, 0, force);\n+                let slice = arr.mut_slice(0, force);\n                 binarysort(slice, run_len);\n                 run_len = force;\n             }\n@@ -259,7 +259,7 @@ fn binarysort<T:Copy + Ord>(array: &mut [T], start: uint) {\n fn reverse_slice<T>(v: &mut [T], start: uint, end:uint) {\n     let mut i = start;\n     while i < end / 2 {\n-        vec::swap(v, i, end - i - 1);\n+        v.swap(i, end - i - 1);\n         i += 1;\n     }\n }\n@@ -443,14 +443,14 @@ impl<T:Copy + Ord> MergeState<T> {\n         }\n \n         let k = { // constrain lifetime of slice below\n-            let slice = vec::slice(array, b1, b1+l1);\n+            let slice = array.slice(b1, b1+l1);\n             gallop_right(&array[b2], slice, 0)\n         };\n         b1 += k;\n         l1 -= k;\n         if l1 != 0 {\n             let l2 = { // constrain lifetime of slice below\n-                let slice = vec::slice(array, b2, b2+l2);\n+                let slice = array.slice(b2, b2+l2);\n                 gallop_left(&array[b1+l1-1],slice,l2-1)\n             };\n             if l2 > 0 {\n@@ -479,7 +479,7 @@ impl<T:Copy + Ord> MergeState<T> {\n         let mut len1 = len1;\n         let mut len2 = len2;\n \n-        vec::swap(array, dest, c2);\n+        array.swap(dest, c2);\n         dest += 1; c2 += 1; len2 -= 1;\n \n         if len2 == 0 {\n@@ -501,7 +501,7 @@ impl<T:Copy + Ord> MergeState<T> {\n             loop {\n                 assert!(len1 > 1 && len2 != 0);\n                 if array[c2] < tmp[c1] {\n-                    vec::swap(array, dest, c2);\n+                    array.swap(dest, c2);\n                     dest += 1; c2 += 1; len2 -= 1;\n                     count2 += 1; count1 = 0;\n                     if len2 == 0 {\n@@ -526,20 +526,20 @@ impl<T:Copy + Ord> MergeState<T> {\n                 assert!(len1 > 1 && len2 != 0);\n \n                 count1 = {\n-                    let tmp_view = vec::slice(tmp, c1, c1+len1);\n+                    let tmp_view = tmp.slice(c1, c1+len1);\n                     gallop_right(&array[c2], tmp_view, 0)\n                 };\n                 if count1 != 0 {\n                     copy_vec(array, dest, tmp.slice(c1, c1+count1));\n                     dest += count1; c1 += count1; len1 -= count1;\n                     if len1 <= 1 { break_outer = true; break; }\n                 }\n-                vec::swap(array, dest, c2);\n+                array.swap(dest, c2);\n                 dest += 1; c2 += 1; len2 -= 1;\n                 if len2 == 0 { break_outer = true; break; }\n \n                 count2 = {\n-                    let tmp_view = vec::slice(array, c2, c2+len2);\n+                    let tmp_view = array.slice(c2, c2+len2);\n                     gallop_left(&tmp[c1], tmp_view, 0)\n                 };\n                 if count2 != 0 {\n@@ -589,7 +589,7 @@ impl<T:Copy + Ord> MergeState<T> {\n         let mut len1 = len1;\n         let mut len2 = len2;\n \n-        vec::swap(array, dest, c1);\n+        array.swap(dest, c1);\n         dest -= 1; c1 -= 1; len1 -= 1;\n \n         if len1 == 0 {\n@@ -613,7 +613,7 @@ impl<T:Copy + Ord> MergeState<T> {\n             loop {\n                 assert!(len1 != 0 && len2 > 1);\n                 if tmp[c2] < array[c1] {\n-                    vec::swap(array, dest, c1);\n+                    array.swap(dest, c1);\n                     dest -= 1; c1 -= 1; len1 -= 1;\n                     count1 += 1; count2 = 0;\n                     if len1 == 0 {\n@@ -638,7 +638,7 @@ impl<T:Copy + Ord> MergeState<T> {\n                 assert!(len2 > 1 && len1 != 0);\n \n                 { // constrain scope of tmp_view:\n-                    let tmp_view = vec::mut_slice (array, base1, base1+len1);\n+                    let tmp_view = array.mut_slice(base1, base1+len1);\n                     count1 = len1 - gallop_right(\n                         &tmp[c2], tmp_view, len1-1);\n                 }\n@@ -655,7 +655,7 @@ impl<T:Copy + Ord> MergeState<T> {\n \n                 let count2;\n                 { // constrain scope of tmp_view\n-                    let tmp_view = vec::mut_slice(tmp, 0, len2);\n+                    let tmp_view = tmp.mut_slice(0, len2);\n                     count2 = len2 - gallop_left(&array[c1],\n                                                 tmp_view,\n                                                 len2-1);\n@@ -666,7 +666,7 @@ impl<T:Copy + Ord> MergeState<T> {\n                     copy_vec(array, dest+1, tmp.slice(c2+1, c2+1+count2));\n                     if len2 <= 1 { break_outer = true; break; }\n                 }\n-                vec::swap(array, dest, c1);\n+                array.swap(dest, c1);\n                 dest -= 1; c1 -= 1; len1 -= 1;\n                 if len1 == 0 { break_outer = true; break; }\n                 min_gallop -= 1;\n@@ -731,7 +731,7 @@ fn copy_vec<T:Copy>(dest: &mut [T],\n                     from: &[T]) {\n     assert!(s1+from.len() <= dest.len());\n \n-    for from.eachi |i, v| {\n+    for from.iter().enumerate().advance |(i, v)| {\n         dest[s1+i] = copy *v;\n     }\n }\n@@ -743,7 +743,7 @@ fn shift_vec<T:Copy>(dest: &mut [T],\n                      len: uint) {\n     assert!(s1+len <= dest.len());\n \n-    let tmp = dest.slice(s2, s2+len).to_vec();\n+    let tmp = dest.slice(s2, s2+len).to_owned();\n     copy_vec(dest, s1, tmp);\n }\n \n@@ -790,12 +790,11 @@ mod test_qsort3 {\n \n #[cfg(test)]\n mod test_qsort {\n-    use core::prelude::*;\n \n     use sort::*;\n \n-    use core::int;\n-    use core::vec;\n+    use std::int;\n+    use std::vec;\n \n     fn check_sort(v1: &mut [int], v2: &mut [int]) {\n         let len = v1.len();\n@@ -846,7 +845,7 @@ mod test_qsort {\n         let immut_names = names;\n \n         let pairs = vec::zip_slice(expected, immut_names);\n-        for pairs.each |p| {\n+        for pairs.iter().advance |p| {\n             let (a, b) = *p;\n             debug!(\"%d %d\", a, b);\n             assert_eq!(a, b);\n@@ -856,7 +855,6 @@ mod test_qsort {\n \n #[cfg(test)]\n mod tests {\n-    use core::prelude::*;\n \n     use sort::*;\n \n@@ -923,12 +921,11 @@ mod tests {\n \n #[cfg(test)]\n mod test_tim_sort {\n-    use core::prelude::*;\n \n     use sort::tim_sort;\n-    use core::rand::RngUtil;\n-    use core::rand;\n-    use core::vec;\n+    use std::rand::RngUtil;\n+    use std::rand;\n+    use std::vec;\n \n     struct CVal {\n         val: float,\n@@ -1018,15 +1015,14 @@ mod test_tim_sort {\n \n #[cfg(test)]\n mod big_tests {\n-    use core::prelude::*;\n \n     use sort::*;\n \n-    use core::local_data;\n-    use core::rand::RngUtil;\n-    use core::rand;\n-    use core::uint;\n-    use core::vec;\n+    use std::local_data;\n+    use std::rand::RngUtil;\n+    use std::rand;\n+    use std::uint;\n+    use std::vec;\n \n     #[test]\n     fn test_unique() {\n@@ -1053,7 +1049,7 @@ mod big_tests {\n     fn makeRange(n: uint) -> ~[uint] {\n         let one = do vec::from_fn(n) |i| { i };\n         let mut two = copy one;\n-        vec::reverse(two);\n+        two.reverse();\n         vec::append(two, one)\n     }\n \n@@ -1077,7 +1073,7 @@ mod big_tests {\n             tim_sort(arr); // *sort\n             isSorted(arr);\n \n-            vec::reverse(arr);\n+            arr.reverse();\n             tim_sort(arr); // \\sort\n             isSorted(arr);\n \n@@ -1087,7 +1083,7 @@ mod big_tests {\n             for 3.times {\n                 let i1 = rng.gen_uint_range(0, n);\n                 let i2 = rng.gen_uint_range(0, n);\n-                vec::swap(arr, i1, i2);\n+                arr.swap(i1, i2);\n             }\n             tim_sort(arr); // 3sort\n             isSorted(arr);\n@@ -1111,7 +1107,7 @@ mod big_tests {\n             isSorted(arr);\n \n             let mut arr = if n > 4 {\n-                let part = vec::slice(arr, 0, 4);\n+                let part = arr.slice(0, 4);\n                 multiplyVec(part, n)\n             } else { arr };\n             tim_sort(arr); // ~sort\n@@ -1149,7 +1145,7 @@ mod big_tests {\n             tim_sort(arr); // *sort\n             isSorted(arr);\n \n-            vec::reverse(arr);\n+            arr.reverse();\n             tim_sort(arr); // \\sort\n             isSorted(arr);\n \n@@ -1159,7 +1155,7 @@ mod big_tests {\n             for 3.times {\n                 let i1 = rng.gen_uint_range(0, n);\n                 let i2 = rng.gen_uint_range(0, n);\n-                vec::swap(arr, i1, i2);\n+                arr.swap(i1, i2);\n             }\n             tim_sort(arr); // 3sort\n             isSorted(arr);\n@@ -1183,7 +1179,7 @@ mod big_tests {\n             isSorted(arr);\n \n             let mut arr = if n > 4 {\n-                let part = vec::slice(arr, 0, 4);\n+                let part = arr.slice(0, 4);\n                 multiplyVec(part, n)\n             } else { arr };\n             tim_sort(arr); // ~sort\n@@ -1202,12 +1198,12 @@ mod big_tests {\n \n     struct LVal<'self> {\n         val: uint,\n-        key: &'self fn(@uint),\n+        key: &'self fn:Copy(@uint),\n     }\n \n     #[unsafe_destructor]\n     impl<'self> Drop for LVal<'self> {\n-        fn finalize(&self) {\n+        fn drop(&self) {\n             let x = unsafe { local_data::local_data_get(self.key) };\n             match x {\n                 Some(@y) => {"}, {"sha": "8351e4db6b8cc00db8409a3f2be4972c44a470e7", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -10,12 +10,11 @@\n \n #[allow(missing_doc)];\n \n-use core::prelude::*;\n \n-use core::f64;\n-use core::cmp;\n-use core::num;\n-use core::vec;\n+use std::f64;\n+use std::cmp;\n+use std::num;\n+use std::vec;\n use sort;\n \n // NB: this can probably be rewritten in terms of num::Num\n@@ -72,7 +71,7 @@ impl<'self> Stats for &'self [f64] {\n         } else {\n             let mean = self.mean();\n             let mut v = 0.0;\n-            for self.each |s| {\n+            for self.iter().advance |s| {\n                 let x = *s - mean;\n                 v += x*x;\n             }"}, {"sha": "b9d25451a8a9566825189d2c190990c309317c01", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 42, "deletions": 40, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -15,14 +15,13 @@\n  * in std.\n  */\n \n-use core::prelude::*;\n \n-use core::borrow;\n-use core::comm;\n-use core::task;\n-use core::unstable::sync::{Exclusive, exclusive, UnsafeAtomicRcBox};\n-use core::unstable::atomics;\n-use core::util;\n+use std::borrow;\n+use std::comm;\n+use std::task;\n+use std::unstable::sync::{Exclusive, exclusive, UnsafeAtomicRcBox};\n+use std::unstable::atomics;\n+use std::util;\n \n /****************************************************************************\n  * Internals\n@@ -86,7 +85,7 @@ struct SemInner<Q> {\n struct Sem<Q>(Exclusive<SemInner<Q>>);\n \n #[doc(hidden)]\n-fn new_sem<Q:Owned>(count: int, q: Q) -> Sem<Q> {\n+fn new_sem<Q:Send>(count: int, q: Q) -> Sem<Q> {\n     Sem(exclusive(SemInner {\n         count: count, waiters: new_waitqueue(), blocked: q }))\n }\n@@ -101,7 +100,7 @@ fn new_sem_and_signal(count: int, num_condvars: uint)\n }\n \n #[doc(hidden)]\n-impl<Q:Owned> Sem<Q> {\n+impl<Q:Send> Sem<Q> {\n     pub fn acquire(&self) {\n         unsafe {\n             let mut waiter_nobe = None;\n@@ -153,7 +152,7 @@ impl Sem<()> {\n \n #[doc(hidden)]\n impl Sem<~[Waitqueue]> {\n-    pub fn access<U>(&self, blk: &fn() -> U) -> U {\n+    pub fn access_waitqueue<U>(&self, blk: &fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n             do task::unkillable {\n@@ -175,8 +174,8 @@ struct SemReleaseGeneric<'self, Q> { sem: &'self Sem<Q> }\n \n #[doc(hidden)]\n #[unsafe_destructor]\n-impl<'self, Q:Owned> Drop for SemReleaseGeneric<'self, Q> {\n-    fn finalize(&self) {\n+impl<'self, Q:Send> Drop for SemReleaseGeneric<'self, Q> {\n+    fn drop(&self) {\n         self.sem.release();\n     }\n }\n@@ -219,7 +218,7 @@ pub struct Condvar<'self> {\n }\n \n #[unsafe_destructor]\n-impl<'self> Drop for Condvar<'self> { fn finalize(&self) {} }\n+impl<'self> Drop for Condvar<'self> { fn drop(&self) {} }\n \n impl<'self> Condvar<'self> {\n     /**\n@@ -295,7 +294,7 @@ impl<'self> Condvar<'self> {\n \n         #[unsafe_destructor]\n         impl<'self> Drop for CondvarReacquire<'self> {\n-            fn finalize(&self) {\n+            fn drop(&self) {\n                 unsafe {\n                     // Needs to succeed, instead of itself dying.\n                     do task::unkillable {\n@@ -381,7 +380,7 @@ impl Sem<~[Waitqueue]> {\n     // The only other places that condvars get built are rwlock.write_cond()\n     // and rwlock_write_mode.\n     pub fn access_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n-        do self.access {\n+        do self.access_waitqueue {\n             blk(&Condvar { sem: self, order: Nothing })\n         }\n     }\n@@ -456,7 +455,9 @@ impl Clone for Mutex {\n \n impl Mutex {\n     /// Run a function with ownership of the mutex.\n-    pub fn lock<U>(&self, blk: &fn() -> U) -> U { (&self.sem).access(blk) }\n+    pub fn lock<U>(&self, blk: &fn() -> U) -> U {\n+        (&self.sem).access_waitqueue(blk)\n+    }\n \n     /// Run a function with ownership of the mutex and a handle to a condvar.\n     pub fn lock_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n@@ -559,9 +560,11 @@ impl RWlock {\n         unsafe {\n             do task::unkillable {\n                 (&self.order_lock).acquire();\n-                do (&self.access_lock).access {\n+                do (&self.access_lock).access_waitqueue {\n                     (&self.order_lock).release();\n-                    task::rekillable(blk)\n+                    do task::rekillable {\n+                        blk()\n+                    }\n                 }\n             }\n         }\n@@ -689,7 +692,7 @@ struct RWlockReleaseRead<'self> {\n #[doc(hidden)]\n #[unsafe_destructor]\n impl<'self> Drop for RWlockReleaseRead<'self> {\n-    fn finalize(&self) {\n+    fn drop(&self) {\n         unsafe {\n             do task::unkillable {\n                 let state = &mut *self.lock.state.get();\n@@ -726,7 +729,7 @@ struct RWlockReleaseDowngrade<'self> {\n #[doc(hidden)]\n #[unsafe_destructor]\n impl<'self> Drop for RWlockReleaseDowngrade<'self> {\n-    fn finalize(&self) {\n+    fn drop(&self) {\n         unsafe {\n             do task::unkillable {\n                 let writer_or_last_reader;\n@@ -769,12 +772,12 @@ fn RWlockReleaseDowngrade<'r>(lock: &'r RWlock)\n /// The \"write permission\" token used for rwlock.write_downgrade().\n pub struct RWlockWriteMode<'self> { priv lock: &'self RWlock }\n #[unsafe_destructor]\n-impl<'self> Drop for RWlockWriteMode<'self> { fn finalize(&self) {} }\n+impl<'self> Drop for RWlockWriteMode<'self> { fn drop(&self) {} }\n \n /// The \"read permission\" token used for rwlock.write_downgrade().\n pub struct RWlockReadMode<'self> { priv lock: &'self RWlock }\n #[unsafe_destructor]\n-impl<'self> Drop for RWlockReadMode<'self> { fn finalize(&self) {} }\n+impl<'self> Drop for RWlockReadMode<'self> { fn drop(&self) {} }\n \n impl<'self> RWlockWriteMode<'self> {\n     /// Access the pre-downgrade rwlock in write mode.\n@@ -799,16 +802,14 @@ impl<'self> RWlockReadMode<'self> {\n \n #[cfg(test)]\n mod tests {\n-    use core::prelude::*;\n \n     use sync::*;\n \n-    use core::cast;\n-    use core::cell::Cell;\n-    use core::comm;\n-    use core::result;\n-    use core::task;\n-    use core::vec;\n+    use std::cast;\n+    use std::cell::Cell;\n+    use std::comm;\n+    use std::result;\n+    use std::task;\n \n     /************************************************************************\n      * Semaphore tests\n@@ -994,13 +995,13 @@ mod tests {\n         }\n \n         // wait until all children get in the mutex\n-        for ports.each |port| { let _ = port.recv(); }\n+        for ports.iter().advance |port| { let _ = port.recv(); }\n         do m.lock_cond |cond| {\n             let num_woken = cond.broadcast();\n             assert_eq!(num_woken, num_waiters);\n         }\n         // wait until all children wake up\n-        for ports.each |port| { let _ = port.recv(); }\n+        for ports.iter().advance |port| { let _ = port.recv(); }\n     }\n     #[test]\n     fn test_mutex_cond_broadcast() {\n@@ -1085,7 +1086,7 @@ mod tests {\n                     }\n                 }\n             }\n-            for sibling_convos.each |p| {\n+            for sibling_convos.iter().advance |p| {\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n             }\n             do m2.lock { }\n@@ -1094,7 +1095,8 @@ mod tests {\n         };\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n-        for vec::each(p.recv()) |p| { p.recv(); } // wait on all its siblings\n+        let r = p.recv();\n+        for r.iter().advance |p| { p.recv(); } // wait on all its siblings\n         do m.lock_cond |cond| {\n             let woken = cond.broadcast();\n             assert_eq!(woken, 0);\n@@ -1104,7 +1106,7 @@ mod tests {\n         }\n \n         impl Drop for SendOnFailure {\n-            fn finalize(&self) {\n+            fn drop(&self) {\n                 self.c.send(());\n             }\n         }\n@@ -1180,12 +1182,12 @@ mod tests {\n             Write => x.write(blk),\n             Downgrade =>\n                 do x.write_downgrade |mode| {\n-                    (&mode).write(blk);\n+                    do mode.write { blk() };\n                 },\n             DowngradeRead =>\n                 do x.write_downgrade |mode| {\n                     let mode = x.downgrade(mode);\n-                    (&mode).read(blk);\n+                    do mode.read { blk() };\n                 },\n         }\n     }\n@@ -1338,10 +1340,10 @@ mod tests {\n         fn lock_cond(x: &RWlock, downgrade: bool, blk: &fn(c: &Condvar)) {\n             if downgrade {\n                 do x.write_downgrade |mode| {\n-                    (&mode).write_cond(blk)\n+                    do mode.write_cond |c| { blk(c) }\n                 }\n             } else {\n-                x.write_cond(blk)\n+                do x.write_cond |c| { blk(c) }\n             }\n         }\n         let x = ~RWlock();\n@@ -1361,13 +1363,13 @@ mod tests {\n         }\n \n         // wait until all children get in the mutex\n-        for ports.each |port| { let _ = port.recv(); }\n+        for ports.iter().advance |port| { let _ = port.recv(); }\n         do lock_cond(x, dg2) |cond| {\n             let num_woken = cond.broadcast();\n             assert_eq!(num_woken, num_waiters);\n         }\n         // wait until all children wake up\n-        for ports.each |port| { let _ = port.recv(); }\n+        for ports.iter().advance |port| { let _ = port.recv(); }\n     }\n     #[test]\n     fn test_rwlock_cond_broadcast() {"}, {"sha": "49d5dd93869535506e0b24a75343ade58e38a14d", "filename": "src/libextra/task_pool.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftask_pool.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -13,15 +13,14 @@\n /// A task pool abstraction. Useful for achieving predictable CPU\n /// parallelism.\n \n-use core::prelude::*;\n \n-use core::comm::Chan;\n-use core::comm;\n-use core::task::SchedMode;\n-use core::task;\n-use core::vec;\n+use std::comm::Chan;\n+use std::comm;\n+use std::task::SchedMode;\n+use std::task;\n+use std::vec;\n \n-#[cfg(test)] use core::task::SingleThreaded;\n+#[cfg(test)] use std::task::SingleThreaded;\n \n enum Msg<T> {\n     Execute(~fn(&T)),\n@@ -35,8 +34,8 @@ pub struct TaskPool<T> {\n \n #[unsafe_destructor]\n impl<T> Drop for TaskPool<T> {\n-    fn finalize(&self) {\n-        for self.channels.each |channel| {\n+    fn drop(&self) {\n+        for self.channels.iter().advance |channel| {\n             channel.send(Quit);\n         }\n     }"}, {"sha": "f8948f41101e8a7c08d7b89088f760fc53925de4", "filename": "src/libextra/tempfile.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftempfile.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -10,11 +10,10 @@\n \n //! Temporary files and directories\n \n-use core::prelude::*;\n \n-use core::os;\n-use core::rand::RngUtil;\n-use core::rand;\n+use std::os;\n+use std::rand::RngUtil;\n+use std::rand;\n \n /// Attempts to make a temporary directory inside of `tmpdir` whose name will\n /// have the suffix `suffix`. If no directory can be created, None is returned.\n@@ -31,11 +30,10 @@ pub fn mkdtemp(tmpdir: &Path, suffix: &str) -> Option<Path> {\n \n #[cfg(test)]\n mod tests {\n-    use core::prelude::*;\n \n     use tempfile::mkdtemp;\n \n-    use core::os;\n+    use std::os;\n \n     #[test]\n     fn test_mkdtemp() {\n@@ -44,12 +42,12 @@ mod tests {\n         assert!(p.to_str().ends_with(\"foobar\"));\n     }\n \n-    // Ideally these would be in core::os but then core would need\n+    // Ideally these would be in std::os but then core would need\n     // to depend on std\n     #[test]\n     fn recursive_mkdir_rel() {\n-        use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n-        use core::os;\n+        use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n+        use std::os;\n \n         let root = mkdtemp(&os::tmpdir(), \"recursive_mkdir_rel\").\n             expect(\"recursive_mkdir_rel\");\n@@ -67,8 +65,8 @@ mod tests {\n \n     #[test]\n     fn recursive_mkdir_dot() {\n-        use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n-        use core::os;\n+        use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n+        use std::os;\n \n         let dot = Path(\".\");\n         assert!(os::mkdir_recursive(&dot,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n@@ -78,8 +76,8 @@ mod tests {\n \n     #[test]\n     fn recursive_mkdir_rel_2() {\n-        use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n-        use core::os;\n+        use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n+        use std::os;\n \n         let root = mkdtemp(&os::tmpdir(), \"recursive_mkdir_rel_2\").\n             expect(\"recursive_mkdir_rel_2\");\n@@ -102,8 +100,8 @@ mod tests {\n     // Ideally this would be in core, but needs mkdtemp\n     #[test]\n     pub fn test_rmdir_recursive_ok() {\n-        use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n-        use core::os;\n+        use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n+        use std::os;\n \n         let rwx = (S_IRUSR | S_IWUSR | S_IXUSR) as i32;\n "}, {"sha": "e21e5c5fb5853dd791ab32db6c42f0ca88ceab71", "filename": "src/libextra/term.rs", "status": "modified", "additions": 76, "deletions": 54, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -12,47 +12,49 @@\n \n #[allow(missing_doc)];\n \n-use core::prelude::*;\n \n-use core::io;\n-use core::os;\n+use std::io;\n \n-use terminfo::*;\n-use terminfo::searcher::open;\n-use terminfo::parser::compiled::parse;\n-use terminfo::parm::{expand, Number, Variables};\n+#[cfg(not(target_os = \"win32\"))] use std::os;\n+#[cfg(not(target_os = \"win32\"))] use terminfo::*;\n+#[cfg(not(target_os = \"win32\"))] use terminfo::searcher::open;\n+#[cfg(not(target_os = \"win32\"))] use terminfo::parser::compiled::parse;\n+#[cfg(not(target_os = \"win32\"))] use terminfo::parm::{expand, Number, Variables};\n \n // FIXME (#2807): Windows support.\n \n-pub static color_black: u8 = 0u8;\n-pub static color_red: u8 = 1u8;\n-pub static color_green: u8 = 2u8;\n-pub static color_yellow: u8 = 3u8;\n-pub static color_blue: u8 = 4u8;\n-pub static color_magenta: u8 = 5u8;\n-pub static color_cyan: u8 = 6u8;\n-pub static color_light_gray: u8 = 7u8;\n-pub static color_light_grey: u8 = 7u8;\n-pub static color_dark_gray: u8 = 8u8;\n-pub static color_dark_grey: u8 = 8u8;\n-pub static color_bright_red: u8 = 9u8;\n-pub static color_bright_green: u8 = 10u8;\n-pub static color_bright_yellow: u8 = 11u8;\n-pub static color_bright_blue: u8 = 12u8;\n-pub static color_bright_magenta: u8 = 13u8;\n-pub static color_bright_cyan: u8 = 14u8;\n-pub static color_bright_white: u8 = 15u8;\n+pub mod color {\n+    pub type Color = u16;\n+\n+    pub static black:   Color = 0u16;\n+    pub static red:     Color = 1u16;\n+    pub static green:   Color = 2u16;\n+    pub static yellow:  Color = 3u16;\n+    pub static blue:    Color = 4u16;\n+    pub static magenta: Color = 5u16;\n+    pub static cyan:    Color = 6u16;\n+    pub static white:   Color = 7u16;\n+\n+    pub static bright_black:   Color = 8u16;\n+    pub static bright_red:     Color = 9u16;\n+    pub static bright_green:   Color = 10u16;\n+    pub static bright_yellow:  Color = 11u16;\n+    pub static bright_blue:    Color = 12u16;\n+    pub static bright_magenta: Color = 13u16;\n+    pub static bright_cyan:    Color = 14u16;\n+    pub static bright_white:   Color = 15u16;\n+}\n \n #[cfg(not(target_os = \"win32\"))]\n pub struct Terminal {\n-    color_supported: bool,\n+    num_colors: u16,\n     priv out: @io::Writer,\n     priv ti: ~TermInfo\n }\n \n #[cfg(target_os = \"win32\")]\n pub struct Terminal {\n-    color_supported: bool,\n+    num_colors: u16,\n     priv out: @io::Writer,\n }\n \n@@ -66,66 +68,86 @@ impl Terminal {\n \n         let entry = open(term.unwrap());\n         if entry.is_err() {\n-            return Err(entry.get_err());\n+            return Err(entry.unwrap_err());\n         }\n \n-        let ti = parse(entry.get(), false);\n+        let ti = parse(entry.unwrap(), false);\n         if ti.is_err() {\n-            return Err(entry.get_err());\n+            return Err(ti.unwrap_err());\n         }\n \n-        let mut inf = ti.get();\n-        let cs = *inf.numbers.find_or_insert(~\"colors\", 0) >= 16\n-            && inf.strings.find(&~\"setaf\").is_some()\n-            && inf.strings.find_equiv(&(\"setab\")).is_some();\n+        let inf = ti.unwrap();\n+        let nc = if inf.strings.find_equiv(&(\"setaf\")).is_some()\n+                 && inf.strings.find_equiv(&(\"setab\")).is_some() {\n+                     inf.numbers.find_equiv(&(\"colors\")).map_consume_default(0, |&n| n)\n+                 } else { 0 };\n \n-        return Ok(Terminal {out: out, ti: inf, color_supported: cs});\n+        return Ok(Terminal {out: out, ti: inf, num_colors: nc});\n     }\n-    pub fn fg(&self, color: u8) {\n-        if self.color_supported {\n+    /// Sets the foreground color to the given color.\n+    ///\n+    /// If the color is a bright color, but the terminal only supports 8 colors,\n+    /// the corresponding normal color will be used instead.\n+    pub fn fg(&self, color: color::Color) {\n+        let color = self.dim_if_necessary(color);\n+        if self.num_colors > color {\n             let s = expand(*self.ti.strings.find_equiv(&(\"setaf\")).unwrap(),\n                            [Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n-                self.out.write(s.get());\n+                self.out.write(s.unwrap());\n             } else {\n-                warn!(s.get_err());\n+                warn!(\"%s\", s.unwrap_err());\n             }\n         }\n     }\n-    pub fn bg(&self, color: u8) {\n-        if self.color_supported {\n+    /// Sets the background color to the given color.\n+    ///\n+    /// If the color is a bright color, but the terminal only supports 8 colors,\n+    /// the corresponding normal color will be used instead.\n+    pub fn bg(&self, color: color::Color) {\n+        let color = self.dim_if_necessary(color);\n+        if self.num_colors > color {\n             let s = expand(*self.ti.strings.find_equiv(&(\"setab\")).unwrap(),\n                            [Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n-                self.out.write(s.get());\n+                self.out.write(s.unwrap());\n             } else {\n-                warn!(s.get_err());\n+                warn!(\"%s\", s.unwrap_err());\n             }\n         }\n     }\n     pub fn reset(&self) {\n-        if self.color_supported {\n-            let mut vars = Variables::new();\n-            let s = expand(*self.ti.strings.find_equiv(&(\"op\")).unwrap(), [], &mut vars);\n-            if s.is_ok() {\n-                self.out.write(s.get());\n-            } else {\n-                warn!(s.get_err());\n-            }\n+        let mut vars = Variables::new();\n+        let s = do self.ti.strings.find_equiv(&(\"op\"))\n+                       .map_consume_default(Err(~\"can't find terminfo capability `op`\")) |&op| {\n+                           expand(op, [], &mut vars)\n+                       };\n+        if s.is_ok() {\n+            self.out.write(s.unwrap());\n+        } else if self.num_colors > 0 {\n+            warn!(\"%s\", s.unwrap_err());\n+        } else {\n+            debug!(\"%s\", s.unwrap_err());\n         }\n     }\n+\n+    priv fn dim_if_necessary(&self, color: color::Color) -> color::Color {\n+        if color >= self.num_colors && color >= 8 && color < 16 {\n+            color-8\n+        } else { color }\n+    }\n }\n \n #[cfg(target_os = \"win32\")]\n impl Terminal {\n     pub fn new(out: @io::Writer) -> Result<Terminal, ~str> {\n-        return Ok(Terminal {out: out, color_supported: false});\n+        return Ok(Terminal {out: out, num_colors: 0});\n     }\n \n-    pub fn fg(&self, color: u8) {\n+    pub fn fg(&self, _color: color::Color) {\n     }\n \n-    pub fn bg(&self, color: u8) {\n+    pub fn bg(&self, _color: color::Color) {\n     }\n \n     pub fn reset(&self) {"}, {"sha": "b7d21ea0ee3fd00726c0434d918b612c12224151", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 252, "deletions": 34, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -10,9 +10,9 @@\n \n //! Parameterized string expansion\n \n-use core::prelude::*;\n-use core::{char, int, vec};\n-use core::iterator::IteratorUtil;\n+use std::{char, vec, util};\n+use std::num::strconv::{SignNone,SignNeg,SignAll,int_to_str_bytes_common};\n+use std::iterator::IteratorUtil;\n \n #[deriving(Eq)]\n enum States {\n@@ -23,13 +23,21 @@ enum States {\n     PushParam,\n     CharConstant,\n     CharClose,\n-    IntConstant,\n+    IntConstant(int),\n+    FormatPattern(Flags, FormatState),\n     SeekIfElse(int),\n     SeekIfElsePercent(int),\n     SeekIfEnd(int),\n     SeekIfEndPercent(int)\n }\n \n+#[deriving(Eq)]\n+enum FormatState {\n+    FormatStateFlags,\n+    FormatStateWidth,\n+    FormatStatePrecision\n+}\n+\n /// Types of parameters a capability can use\n pub enum Param {\n     String(~str),\n@@ -71,8 +79,6 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n \n     let mut stack: ~[Param] = ~[];\n \n-    let mut intstate = ~[];\n-\n     // Copy parameters into a local vector for mutability\n     let mut mparams = [Number(0), ..9];\n     for mparams.mut_iter().zip(params.iter()).advance |(dst, &src)| {\n@@ -100,26 +106,11 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                             _       => return Err(~\"a non-char was used with %c\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n-                    's' => if stack.len() > 0 {\n-                        match stack.pop() {\n-                            String(s) => output.push_all(s.as_bytes()),\n-                            _         => return Err(~\"a non-str was used with %s\")\n-                        }\n-                    } else { return Err(~\"stack is empty\") },\n-                    'd' => if stack.len() > 0 {\n-                        match stack.pop() {\n-                            Number(x) => {\n-                                let s = x.to_str();\n-                                output.push_all(s.as_bytes())\n-                            }\n-                            _         => return Err(~\"a non-number was used with %d\")\n-                        }\n-                    } else { return Err(~\"stack is empty\") },\n                     'p' => state = PushParam,\n                     'P' => state = SetVar,\n                     'g' => state = GetVar,\n                     '\\'' => state = CharConstant,\n-                    '{' => state = IntConstant,\n+                    '{' => state = IntConstant(0),\n                     'l' => if stack.len() > 0 {\n                         match stack.pop() {\n                             String(s) => stack.push(Number(s.len() as int)),\n@@ -231,6 +222,30 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         (_, _) => return Err(~\"first two params not numbers with %i\")\n                     },\n \n+                    // printf-style support for %doxXs\n+                    'd'|'o'|'x'|'X'|'s' => if stack.len() > 0 {\n+                        let flags = Flags::new();\n+                        let res = format(stack.pop(), FormatOp::from_char(cur), flags);\n+                        if res.is_err() { return res }\n+                        output.push_all(res.unwrap())\n+                    } else { return Err(~\"stack is empty\") },\n+                    ':'|'#'|' '|'.'|'0'..'9' => {\n+                        let mut flags = Flags::new();\n+                        let mut fstate = FormatStateFlags;\n+                        match cur {\n+                            ':' => (),\n+                            '#' => flags.alternate = true,\n+                            ' ' => flags.space = true,\n+                            '.' => fstate = FormatStatePrecision,\n+                            '0'..'9' => {\n+                                flags.width = (cur - '0') as uint;\n+                                fstate = FormatStateWidth;\n+                            }\n+                            _ => util::unreachable()\n+                        }\n+                        state = FormatPattern(flags, fstate);\n+                    }\n+\n                     // conditionals\n                     '?' => (),\n                     't' => if stack.len() > 0 {\n@@ -288,17 +303,61 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     return Err(~\"malformed character constant\");\n                 }\n             },\n-            IntConstant => {\n-                if cur == '}' {\n-                    stack.push(match int::parse_bytes(intstate, 10) {\n-                        Some(n) => Number(n),\n-                        None => return Err(~\"bad int constant\")\n-                    });\n-                    intstate.clear();\n-                    state = Nothing;\n-                } else {\n-                    intstate.push(cur as u8);\n-                    old_state = Nothing;\n+            IntConstant(i) => {\n+                match cur {\n+                    '}' => {\n+                        stack.push(Number(i));\n+                        state = Nothing;\n+                    }\n+                    '0'..'9' => {\n+                        state = IntConstant(i*10 + ((cur - '0') as int));\n+                        old_state = Nothing;\n+                    }\n+                    _ => return Err(~\"bad int constant\")\n+                }\n+            }\n+            FormatPattern(ref mut flags, ref mut fstate) => {\n+                old_state = Nothing;\n+                match (*fstate, cur) {\n+                    (_,'d')|(_,'o')|(_,'x')|(_,'X')|(_,'s') => if stack.len() > 0 {\n+                        let res = format(stack.pop(), FormatOp::from_char(cur), *flags);\n+                        if res.is_err() { return res }\n+                        output.push_all(res.unwrap());\n+                        old_state = state; // will cause state to go to Nothing\n+                    } else { return Err(~\"stack is empty\") },\n+                    (FormatStateFlags,'#') => {\n+                        flags.alternate = true;\n+                    }\n+                    (FormatStateFlags,'-') => {\n+                        flags.left = true;\n+                    }\n+                    (FormatStateFlags,'+') => {\n+                        flags.sign = true;\n+                    }\n+                    (FormatStateFlags,' ') => {\n+                        flags.space = true;\n+                    }\n+                    (FormatStateFlags,'0'..'9') => {\n+                        flags.width = (cur - '0') as uint;\n+                        *fstate = FormatStateWidth;\n+                    }\n+                    (FormatStateFlags,'.') => {\n+                        *fstate = FormatStatePrecision;\n+                    }\n+                    (FormatStateWidth,'0'..'9') => {\n+                        let old = flags.width;\n+                        flags.width = flags.width * 10 + ((cur - '0') as uint);\n+                        if flags.width < old { return Err(~\"format width overflow\") }\n+                    }\n+                    (FormatStateWidth,'.') => {\n+                        *fstate = FormatStatePrecision;\n+                    }\n+                    (FormatStatePrecision,'0'..'9') => {\n+                        let old = flags.precision;\n+                        flags.precision = flags.precision * 10 + ((cur - '0') as uint);\n+                        if flags.precision < old { return Err(~\"format precision overflow\") }\n+                    }\n+                    _ => return Err(~\"invalid format specifier\")\n                 }\n             }\n             SeekIfElse(level) => {\n@@ -349,10 +408,153 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n     Ok(output)\n }\n \n+#[deriving(Eq)]\n+priv struct Flags {\n+    width: uint,\n+    precision: uint,\n+    alternate: bool,\n+    left: bool,\n+    sign: bool,\n+    space: bool\n+}\n+\n+impl Flags {\n+    priv fn new() -> Flags {\n+        Flags{ width: 0, precision: 0, alternate: false,\n+               left: false, sign: false, space: false }\n+    }\n+}\n+\n+priv enum FormatOp {\n+    FormatDigit,\n+    FormatOctal,\n+    FormatHex,\n+    FormatHEX,\n+    FormatString\n+}\n+\n+impl FormatOp {\n+    priv fn from_char(c: char) -> FormatOp {\n+        match c {\n+            'd' => FormatDigit,\n+            'o' => FormatOctal,\n+            'x' => FormatHex,\n+            'X' => FormatHEX,\n+            's' => FormatString,\n+            _ => fail!(\"bad FormatOp char\")\n+        }\n+    }\n+    priv fn to_char(self) -> char {\n+        match self {\n+            FormatDigit => 'd',\n+            FormatOctal => 'o',\n+            FormatHex => 'x',\n+            FormatHEX => 'X',\n+            FormatString => 's'\n+        }\n+    }\n+}\n+\n+priv fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n+    let mut s = match val {\n+        Number(d) => {\n+            match op {\n+                FormatString => {\n+                    return Err(~\"non-number on stack with %s\")\n+                }\n+                _ => {\n+                    let radix = match op {\n+                        FormatDigit => 10,\n+                        FormatOctal => 8,\n+                        FormatHex|FormatHEX => 16,\n+                        FormatString => util::unreachable()\n+                    };\n+                    let mut s = ~[];\n+                    match op {\n+                        FormatDigit => {\n+                            let sign = if flags.sign { SignAll } else { SignNeg };\n+                            do int_to_str_bytes_common(d, radix, sign) |c| {\n+                                s.push(c);\n+                            }\n+                        }\n+                        _ => {\n+                            do int_to_str_bytes_common(d as uint, radix, SignNone) |c| {\n+                                s.push(c);\n+                            }\n+                        }\n+                    };\n+                    if flags.precision > s.len() {\n+                        let mut s_ = vec::with_capacity(flags.precision);\n+                        let n = flags.precision - s.len();\n+                        s_.grow(n, &('0' as u8));\n+                        s_.push_all_move(s);\n+                        s = s_;\n+                    }\n+                    assert!(!s.is_empty(), \"string conversion produced empty result\");\n+                    match op {\n+                        FormatDigit => {\n+                            if flags.space && !(s[0] == '-' as u8 || s[0] == '+' as u8) {\n+                                s.unshift(' ' as u8);\n+                            }\n+                        }\n+                        FormatOctal => {\n+                            if flags.alternate && s[0] != '0' as u8 {\n+                                s.unshift('0' as u8);\n+                            }\n+                        }\n+                        FormatHex => {\n+                            if flags.alternate {\n+                                let s_ = util::replace(&mut s, ~['0' as u8, 'x' as u8]);\n+                                s.push_all_move(s_);\n+                            }\n+                        }\n+                        FormatHEX => {\n+                            s = s.into_ascii().to_upper().into_bytes();\n+                            if flags.alternate {\n+                                let s_ = util::replace(&mut s, ~['0' as u8, 'X' as u8]);\n+                                s.push_all_move(s_);\n+                            }\n+                        }\n+                        FormatString => util::unreachable()\n+                    }\n+                    s\n+                }\n+            }\n+        }\n+        String(s) => {\n+            match op {\n+                FormatString => {\n+                    let mut s = s.as_bytes_with_null_consume();\n+                    s.pop(); // remove the null\n+                    if flags.precision > 0 && flags.precision < s.len() {\n+                        s.truncate(flags.precision);\n+                    }\n+                    s\n+                }\n+                _ => {\n+                    return Err(fmt!(\"non-string on stack with %%%c\", op.to_char()))\n+                }\n+            }\n+        }\n+    };\n+    if flags.width > s.len() {\n+        let n = flags.width - s.len();\n+        if flags.left {\n+            s.grow(n, &(' ' as u8));\n+        } else {\n+            let mut s_ = vec::with_capacity(flags.width);\n+            s_.grow(n, &(' ' as u8));\n+            s_.push_all_move(s);\n+            s = s_;\n+        }\n+    }\n+    Ok(s)\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use core::result::Ok;\n+    use std::result::Ok;\n \n     #[test]\n     fn test_basic_setabf() {\n@@ -443,4 +645,20 @@ mod test {\n         assert!(res.is_ok(), res.unwrap_err());\n         assert_eq!(res.unwrap(), bytes!(\"\\\\E[38;5;42m\").to_owned());\n     }\n+\n+    #[test]\n+    fn test_format() {\n+        let mut varstruct = Variables::new();\n+        let vars = &mut varstruct;\n+        assert_eq!(expand(bytes!(\"%p1%s%p2%2s%p3%2s%p4%.2s\"),\n+                          [String(~\"foo\"), String(~\"foo\"), String(~\"f\"), String(~\"foo\")], vars),\n+                   Ok(bytes!(\"foofoo ffo\").to_owned()));\n+        assert_eq!(expand(bytes!(\"%p1%:-4.2s\"), [String(~\"foo\")], vars),\n+                   Ok(bytes!(\"fo  \").to_owned()));\n+\n+        assert_eq!(expand(bytes!(\"%p1%d%p1%.3d%p1%5d%p1%:+d\"), [Number(1)], vars),\n+                   Ok(bytes!(\"1001    1+1\").to_owned()));\n+        assert_eq!(expand(bytes!(\"%p1%o%p1%#o%p2%6.4x%p2%#6.4X\"), [Number(15), Number(27)], vars),\n+                   Ok(bytes!(\"17017  001b0X001B\").to_owned()));\n+    }\n }"}, {"sha": "063d26d1424b758b75f8eed61cd53626a67fcbb7", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -10,11 +10,10 @@\n \n /// ncurses-compatible compiled terminfo format parsing (term(5))\n \n-use core::prelude::*;\n \n-use core::{vec, int, str};\n-use core::io::Reader;\n-use core::hashmap::HashMap;\n+use std::{vec, int, str};\n+use std::io::Reader;\n+use std::hashmap::HashMap;\n use super::super::TermInfo;\n \n // These are the orders ncurses uses in its compiled format (as of 5.9). Not sure if portable.\n@@ -271,7 +270,7 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n             return Err(~\"error: hit EOF before end of string table\");\n         }\n \n-        for string_offsets.eachi |i, v| {\n+        for string_offsets.iter().enumerate().advance |(i, v)| {\n             let offset = *v;\n             if offset == 0xFFFF { // non-entry\n                 loop;\n@@ -292,12 +291,13 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n \n \n             // Find the offset of the NUL we want to go to\n-            let nulpos = vec::position_between(string_table, offset as uint,\n-                                               string_table_bytes as uint, |&b| b == 0);\n+            let nulpos = string_table.slice(offset as uint, string_table_bytes as uint)\n+                .iter().position_(|&b| b == 0);\n             match nulpos {\n-                Some(x) => {\n+                Some(len) => {\n                     string_map.insert(name.to_owned(),\n-                                      string_table.slice(offset as uint, x).to_owned())\n+                                      string_table.slice(offset as uint,\n+                                                         offset as uint + len).to_owned())\n                 },\n                 None => {\n                     return Err(~\"invalid file: missing NUL in string_table\");"}, {"sha": "15aeeb3e65442422889afddec9e5d7b752c4ad5f", "filename": "src/libextra/terminfo/searcher.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fsearcher.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -11,11 +11,10 @@\n /// Implement ncurses-compatible database discovery\n /// Does not support hashed database, only filesystem!\n \n-use core::prelude::*;\n-use core::{os, str};\n-use core::os::getenv;\n-use core::io::{file_reader, Reader};\n-use path = core::path::Path;\n+use std::{os, str};\n+use std::os::getenv;\n+use std::io::{file_reader, Reader};\n+use path = std::path::Path;\n \n /// Return path to database entry for `term`\n pub fn get_dbpath_for_term(term: &str) -> Option<~path> {\n@@ -55,7 +54,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~path> {\n     };\n \n     // Look for the terminal in all of the search directories\n-    for dirs_to_search.each |p| {\n+    for dirs_to_search.iter().advance |p| {\n         let newp = ~p.push_many(&[str::from_char(first_char), term.to_owned()]);\n         if os::path_exists(p) && os::path_exists(newp) {\n             return Some(newp);"}, {"sha": "0e0231ad3f44af9502e4bb1692fdae2b206eca63", "filename": "src/libextra/terminfo/terminfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fterminfo%2Fterminfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fterminfo%2Fterminfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fterminfo.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::hashmap::HashMap;\n+use std::hashmap::HashMap;\n \n /// A parsed terminfo entry.\n pub struct TermInfo {"}, {"sha": "f3051e083839aee09492e725db6ea766b4af7dc6", "filename": "src/libextra/test.rs", "status": "modified", "additions": 152, "deletions": 156, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -15,21 +15,26 @@\n // simplest interface possible for representing and running tests\n // while providing a base that other test frameworks may build off of.\n \n-use core::prelude::*;\n \n use getopts;\n use sort;\n+use stats::Stats;\n use term;\n-\n-use core::comm::{stream, SharedChan};\n-use core::either;\n-use core::io;\n-use core::option;\n-use core::result;\n-use core::task;\n-use core::to_str::ToStr;\n-use core::uint;\n-use core::vec;\n+use time::precise_time_ns;\n+\n+use std::comm::{stream, SharedChan};\n+use std::either;\n+use std::io;\n+use std::num;\n+use std::option;\n+use std::rand::RngUtil;\n+use std::rand;\n+use std::result;\n+use std::task;\n+use std::to_str::ToStr;\n+use std::u64;\n+use std::uint;\n+use std::vec;\n \n \n // The name of a test. By convention this follows the rules for rust\n@@ -131,7 +136,7 @@ type OptRes = Either<TestOpts, ~str>;\n \n // Parses command line arguments into test options\n pub fn parse_opts(args: &[~str]) -> OptRes {\n-    let args_ = vec::tail(args);\n+    let args_ = args.tail();\n     let opts = ~[getopts::optflag(\"ignored\"),\n                  getopts::optflag(\"test\"),\n                  getopts::optflag(\"bench\"),\n@@ -318,33 +323,33 @@ pub fn run_tests_console(opts: &TestOpts,\n     }\n \n     fn write_ok(out: @io::Writer, use_color: bool) {\n-        write_pretty(out, \"ok\", term::color_green, use_color);\n+        write_pretty(out, \"ok\", term::color::green, use_color);\n     }\n \n     fn write_failed(out: @io::Writer, use_color: bool) {\n-        write_pretty(out, \"FAILED\", term::color_red, use_color);\n+        write_pretty(out, \"FAILED\", term::color::red, use_color);\n     }\n \n     fn write_ignored(out: @io::Writer, use_color: bool) {\n-        write_pretty(out, \"ignored\", term::color_yellow, use_color);\n+        write_pretty(out, \"ignored\", term::color::yellow, use_color);\n     }\n \n     fn write_bench(out: @io::Writer, use_color: bool) {\n-        write_pretty(out, \"bench\", term::color_cyan, use_color);\n+        write_pretty(out, \"bench\", term::color::cyan, use_color);\n     }\n \n     fn write_pretty(out: @io::Writer,\n                     word: &str,\n-                    color: u8,\n+                    color: term::color::Color,\n                     use_color: bool) {\n         let t = term::Terminal::new(out);\n         match t {\n             Ok(term)  => {\n-                if use_color && term.color_supported {\n+                if use_color {\n                     term.fg(color);\n                 }\n                 out.write_str(word);\n-                if use_color && term.color_supported {\n+                if use_color {\n                     term.reset();\n                 }\n             },\n@@ -361,7 +366,7 @@ fn print_failures(st: &ConsoleTestState) {\n         failures.push(name.to_str());\n     }\n     sort::tim_sort(failures);\n-    for failures.each |name| {\n+    for failures.iter().advance |name| {\n         st.out.write_line(fmt!(\"    %s\", name.to_str()));\n     }\n }\n@@ -415,15 +420,15 @@ type MonitorMsg = (TestDesc, TestResult);\n \n fn run_tests(opts: &TestOpts,\n              tests: ~[TestDescAndFn],\n-             callback: @fn(e: TestEvent)) {\n+             callback: &fn(e: TestEvent)) {\n \n     let filtered_tests = filter_tests(opts, tests);\n     let filtered_descs = filtered_tests.map(|t| copy t.desc);\n \n     callback(TeFiltered(filtered_descs));\n \n     let (filtered_tests, filtered_benchs) =\n-        do vec::partition(filtered_tests) |e| {\n+        do filtered_tests.partition |e| {\n         match e.testfn {\n             StaticTestFn(_) | DynTestFn(_) => true,\n             StaticBenchFn(_) | DynBenchFn(_) => false\n@@ -436,7 +441,7 @@ fn run_tests(opts: &TestOpts,\n     debug!(\"using %u test tasks\", concurrency);\n \n     let mut remaining = filtered_tests;\n-    vec::reverse(remaining);\n+    remaining.reverse();\n     let mut pending = 0;\n \n     let (p, ch) = stream();\n@@ -480,7 +485,7 @@ static sched_overcommit : uint = 1;\n static sched_overcommit : uint = 4u;\n \n fn get_concurrency() -> uint {\n-    use core::rt;\n+    use std::rt;\n     let threads = rt::util::default_sched_threads();\n     if threads == 1 { 1 }\n     else { threads * sched_overcommit }\n@@ -558,7 +563,7 @@ pub fn run_test(force_ignore: bool,\n     fn run_test_inner(desc: TestDesc,\n                       monitor_ch: SharedChan<MonitorMsg>,\n                       testfn: ~fn()) {\n-        let testfn_cell = ::core::cell::Cell::new(testfn);\n+        let testfn_cell = ::std::cell::Cell::new(testfn);\n         do task::spawn {\n             let mut result_future = None; // task::future_result(builder);\n \n@@ -600,152 +605,143 @@ fn calc_result(desc: &TestDesc, task_succeeded: bool) -> TestResult {\n     }\n }\n \n-pub mod bench {\n-    use core::prelude::*;\n-\n-    use core::num;\n-    use core::rand::RngUtil;\n-    use core::rand;\n-    use core::u64;\n-    use core::vec;\n-    use stats::Stats;\n-    use test::{BenchHarness, BenchSamples};\n-    use time::precise_time_ns;\n-\n-    impl BenchHarness {\n-        /// Callback for benchmark functions to run in their body.\n-        pub fn iter(&mut self, inner:&fn()) {\n-            self.ns_start = precise_time_ns();\n-            let k = self.iterations;\n-            for u64::range(0, k) |_| {\n-                inner();\n-            }\n-            self.ns_end = precise_time_ns();\n-        }\n-\n-        pub fn ns_elapsed(&mut self) -> u64 {\n-            if self.ns_start == 0 || self.ns_end == 0 {\n-                0\n-            } else {\n-                self.ns_end - self.ns_start\n-            }\n+impl BenchHarness {\n+    /// Callback for benchmark functions to run in their body.\n+    pub fn iter(&mut self, inner:&fn()) {\n+        self.ns_start = precise_time_ns();\n+        let k = self.iterations;\n+        for u64::range(0, k) |_| {\n+            inner();\n         }\n+        self.ns_end = precise_time_ns();\n+    }\n \n-        pub fn ns_per_iter(&mut self) -> u64 {\n-            if self.iterations == 0 {\n-                0\n-            } else {\n-                self.ns_elapsed() / self.iterations\n-            }\n+    pub fn ns_elapsed(&mut self) -> u64 {\n+        if self.ns_start == 0 || self.ns_end == 0 {\n+            0\n+        } else {\n+            self.ns_end - self.ns_start\n         }\n+    }\n \n-        pub fn bench_n(&mut self, n: u64, f: &fn(&mut BenchHarness)) {\n-            self.iterations = n;\n-            debug!(\"running benchmark for %u iterations\",\n-                   n as uint);\n-            f(self);\n+    pub fn ns_per_iter(&mut self) -> u64 {\n+        if self.iterations == 0 {\n+            0\n+        } else {\n+            self.ns_elapsed() / self.iterations\n         }\n+    }\n \n-        // This is the Go benchmark algorithm. It produces a single\n-        // datapoint and always tries to run for 1s.\n-        pub fn go_bench(&mut self, f: &fn(&mut BenchHarness)) {\n-\n-            // Rounds a number down to the nearest power of 10.\n-            fn round_down_10(n: u64) -> u64 {\n-                let mut n = n;\n-                let mut res = 1;\n-                while n > 10 {\n-                    n = n / 10;\n-                    res *= 10;\n-                }\n-                res\n-            }\n+    pub fn bench_n(&mut self, n: u64, f: &fn(&mut BenchHarness)) {\n+        self.iterations = n;\n+        debug!(\"running benchmark for %u iterations\",\n+               n as uint);\n+        f(self);\n+    }\n \n-            // Rounds x up to a number of the form [1eX, 2eX, 5eX].\n-            fn round_up(n: u64) -> u64 {\n-                let base = round_down_10(n);\n-                if n < (2 * base) {\n-                    2 * base\n-                } else if n < (5 * base) {\n-                    5 * base\n-                } else {\n-                    10 * base\n-                }\n+    // This is the Go benchmark algorithm. It produces a single\n+    // datapoint and always tries to run for 1s.\n+    pub fn go_bench(&mut self, f: &fn(&mut BenchHarness)) {\n+\n+        // Rounds a number down to the nearest power of 10.\n+        fn round_down_10(n: u64) -> u64 {\n+            let mut n = n;\n+            let mut res = 1;\n+            while n > 10 {\n+                n = n / 10;\n+                res *= 10;\n             }\n+            res\n+        }\n \n-            // Initial bench run to get ballpark figure.\n-            let mut n = 1_u64;\n-            self.bench_n(n, f);\n-\n-            while n < 1_000_000_000 &&\n-                self.ns_elapsed() < 1_000_000_000 {\n-                let last = n;\n-\n-                // Try to estimate iter count for 1s falling back to 1bn\n-                // iterations if first run took < 1ns.\n-                if self.ns_per_iter() == 0 {\n-                    n = 1_000_000_000;\n-                } else {\n-                    n = 1_000_000_000 / self.ns_per_iter();\n-                }\n-\n-                n = u64::max(u64::min(n+n/2, 100*last), last+1);\n-                n = round_up(n);\n-                self.bench_n(n, f);\n+        // Rounds x up to a number of the form [1eX, 2eX, 5eX].\n+        fn round_up(n: u64) -> u64 {\n+            let base = round_down_10(n);\n+            if n < (2 * base) {\n+                2 * base\n+            } else if n < (5 * base) {\n+                5 * base\n+            } else {\n+                10 * base\n             }\n         }\n \n-        // This is a more statistics-driven benchmark algorithm.\n-        // It stops as quickly as 50ms, so long as the statistical\n-        // properties are satisfactory. If those properties are\n-        // not met, it may run as long as the Go algorithm.\n-        pub fn auto_bench(&mut self, f: &fn(&mut BenchHarness)) -> ~[f64] {\n-\n-            let mut rng = rand::rng();\n-            let mut magnitude = 10;\n-            let mut prev_madp = 0.0;\n+        // Initial bench run to get ballpark figure.\n+        let mut n = 1_u64;\n+        self.bench_n(n, |x| f(x));\n \n-            loop {\n-                let n_samples = rng.gen_uint_range(50, 60);\n-                let n_iter = rng.gen_uint_range(magnitude,\n-                                                magnitude * 2);\n+        while n < 1_000_000_000 &&\n+            self.ns_elapsed() < 1_000_000_000 {\n+            let last = n;\n \n-                let samples = do vec::from_fn(n_samples) |_| {\n-                    self.bench_n(n_iter as u64, f);\n-                    self.ns_per_iter() as f64\n-                };\n+            // Try to estimate iter count for 1s falling back to 1bn\n+            // iterations if first run took < 1ns.\n+            if self.ns_per_iter() == 0 {\n+                n = 1_000_000_000;\n+            } else {\n+                n = 1_000_000_000 / self.ns_per_iter();\n+            }\n \n-                // Eliminate outliers\n-                let med = samples.median();\n-                let mad = samples.median_abs_dev();\n-                let samples = do vec::filter(samples) |f| {\n-                    num::abs(*f - med) <= 3.0 * mad\n-                };\n+            n = u64::max(u64::min(n+n/2, 100*last), last+1);\n+            n = round_up(n);\n+            self.bench_n(n, |x| f(x));\n+        }\n+    }\n \n-                debug!(\"%u samples, median %f, MAD=%f, %u survived filter\",\n-                       n_samples, med as float, mad as float,\n-                       samples.len());\n-\n-                if samples.len() != 0 {\n-                    // If we have _any_ cluster of signal...\n-                    let curr_madp = samples.median_abs_dev_pct();\n-                    if self.ns_elapsed() > 1_000_000 &&\n-                        (curr_madp < 1.0 ||\n-                         num::abs(curr_madp - prev_madp) < 0.1) {\n-                        return samples;\n-                    }\n-                    prev_madp = curr_madp;\n-\n-                    if n_iter > 20_000_000 ||\n-                        self.ns_elapsed() > 20_000_000 {\n-                        return samples;\n-                    }\n+    // This is a more statistics-driven benchmark algorithm.\n+    // It stops as quickly as 50ms, so long as the statistical\n+    // properties are satisfactory. If those properties are\n+    // not met, it may run as long as the Go algorithm.\n+    pub fn auto_bench(&mut self, f: &fn(&mut BenchHarness)) -> ~[f64] {\n+\n+        let mut rng = rand::rng();\n+        let mut magnitude = 10;\n+        let mut prev_madp = 0.0;\n+\n+        loop {\n+            let n_samples = rng.gen_uint_range(50, 60);\n+            let n_iter = rng.gen_uint_range(magnitude,\n+                                            magnitude * 2);\n+\n+            let samples = do vec::from_fn(n_samples) |_| {\n+                self.bench_n(n_iter as u64, |x| f(x));\n+                self.ns_per_iter() as f64\n+            };\n+\n+            // Eliminate outliers\n+            let med = samples.median();\n+            let mad = samples.median_abs_dev();\n+            let samples = do vec::filter(samples) |f| {\n+                num::abs(*f - med) <= 3.0 * mad\n+            };\n+\n+            debug!(\"%u samples, median %f, MAD=%f, %u survived filter\",\n+                   n_samples, med as float, mad as float,\n+                   samples.len());\n+\n+            if samples.len() != 0 {\n+                // If we have _any_ cluster of signal...\n+                let curr_madp = samples.median_abs_dev_pct();\n+                if self.ns_elapsed() > 1_000_000 &&\n+                    (curr_madp < 1.0 ||\n+                     num::abs(curr_madp - prev_madp) < 0.1) {\n+                    return samples;\n                 }\n+                prev_madp = curr_madp;\n \n-                magnitude *= 2;\n+                if n_iter > 20_000_000 ||\n+                    self.ns_elapsed() > 20_000_000 {\n+                    return samples;\n+                }\n             }\n+\n+            magnitude *= 2;\n         }\n     }\n+}\n+\n+pub mod bench {\n+    use test::{BenchHarness, BenchSamples};\n \n     pub fn benchmark(f: &fn(&mut BenchHarness)) -> BenchSamples {\n \n@@ -775,10 +771,10 @@ mod tests {\n                StaticTestName, DynTestName, DynTestFn};\n     use test::{TestOpts, run_test};\n \n-    use core::either;\n-    use core::comm::{stream, SharedChan};\n-    use core::option;\n-    use core::vec;\n+    use std::either;\n+    use std::comm::{stream, SharedChan};\n+    use std::option;\n+    use std::vec;\n \n     #[test]\n     pub fn do_not_run_ignored_tests() {\n@@ -938,7 +934,7 @@ mod tests {\n         {\n             fn testfn() { }\n             let mut tests = ~[];\n-            for names.each |name| {\n+            for names.iter().advance |name| {\n                 let test = TestDescAndFn {\n                     desc: TestDesc {\n                         name: DynTestName(copy *name),\n@@ -964,7 +960,7 @@ mod tests {\n \n         let pairs = vec::zip(expected, filtered);\n \n-        for pairs.each |p| {\n+        for pairs.iter().advance |p| {\n             match *p {\n                 (ref a, ref b) => {\n                     assert!(*a == b.desc.name.to_str());"}, {"sha": "e1f42934b39067a8685b82beda7fcf6804c2c999", "filename": "src/libextra/time.rs", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -10,12 +10,11 @@\n \n #[allow(missing_doc)];\n \n-use core::prelude::*;\n \n-use core::i32;\n-use core::int;\n-use core::io;\n-use core::str;\n+use std::i32;\n+use std::int;\n+use std::io;\n+use std::str;\n \n static NSEC_PER_SEC: i32 = 1_000_000_000_i32;\n \n@@ -849,7 +848,7 @@ priv fn do_strftime(format: &str, tm: &Tm) -> ~str {\n     do io::with_str_reader(format) |rdr| {\n         while !rdr.eof() {\n             match rdr.read_char() {\n-                '%' => buf += parse_type(rdr.read_char(), tm),\n+                '%' => buf.push_str(parse_type(rdr.read_char(), tm)),\n                 ch => buf.push_char(ch)\n             }\n         }\n@@ -862,11 +861,11 @@ priv fn do_strftime(format: &str, tm: &Tm) -> ~str {\n mod tests {\n     use time::*;\n \n-    use core::float;\n-    use core::os;\n-    use core::result;\n-    use core::result::{Err, Ok};\n-    use core::str;\n+    use std::float;\n+    use std::os;\n+    use std::result;\n+    use std::result::{Err, Ok};\n+    use std::str;\n \n     fn test_get_time() {\n         static some_recent_date: i64 = 1325376000i64; // 2012-01-01T00:00:00Z\n@@ -1033,31 +1032,33 @@ mod tests {\n             }\n         }\n \n-        for [\n+        let days = [\n             ~\"Sunday\",\n             ~\"Monday\",\n             ~\"Tuesday\",\n             ~\"Wednesday\",\n             ~\"Thursday\",\n             ~\"Friday\",\n             ~\"Saturday\"\n-        ].each |day| {\n+        ];\n+        for days.iter().advance |day| {\n             assert!(test(*day, \"%A\"));\n         }\n \n-        for [\n+        let days = [\n             ~\"Sun\",\n             ~\"Mon\",\n             ~\"Tue\",\n             ~\"Wed\",\n             ~\"Thu\",\n             ~\"Fri\",\n             ~\"Sat\"\n-        ].each |day| {\n+        ];\n+        for days.iter().advance |day| {\n             assert!(test(*day, \"%a\"));\n         }\n \n-        for [\n+        let months = [\n             ~\"January\",\n             ~\"February\",\n             ~\"March\",\n@@ -1070,11 +1071,12 @@ mod tests {\n             ~\"October\",\n             ~\"November\",\n             ~\"December\"\n-        ].each |day| {\n+        ];\n+        for months.iter().advance |day| {\n             assert!(test(*day, \"%B\"));\n         }\n \n-        for [\n+        let months = [\n             ~\"Jan\",\n             ~\"Feb\",\n             ~\"Mar\",\n@@ -1087,7 +1089,8 @@ mod tests {\n             ~\"Oct\",\n             ~\"Nov\",\n             ~\"Dec\"\n-        ].each |day| {\n+        ];\n+        for months.iter().advance |day| {\n             assert!(test(*day, \"%b\"));\n         }\n \n@@ -1138,6 +1141,9 @@ mod tests {\n         assert!(result::unwrap(strptime(\"-0800\", \"%z\")).tm_gmtoff ==\n             0);\n         assert!(test(\"%\", \"%%\"));\n+\n+        // Test for #7256\n+        assert_eq!(strptime(\"360\", \"%Y-%m-%d\"), Err(~\"Invalid year\"))\n     }\n \n     fn test_ctime() {"}, {"sha": "d957ac43801e576bbcf99632640eba42bc477623", "filename": "src/libextra/timer.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftimer.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -10,18 +10,17 @@\n \n //! Utilities that leverage libuv's `uv_timer_*` API\n \n-use core::prelude::*;\n \n use uv;\n use uv::iotask;\n use uv::iotask::IoTask;\n \n-use core::cast::transmute;\n-use core::cast;\n-use core::comm::{stream, Chan, SharedChan, Port, select2i};\n-use core::either;\n-use core::libc::c_void;\n-use core::libc;\n+use std::cast::transmute;\n+use std::cast;\n+use std::comm::{stream, Chan, SharedChan, Port, select2i};\n+use std::either;\n+use std::libc::c_void;\n+use std::libc;\n \n /**\n  * Wait for timeout period then send provided value over a channel\n@@ -39,7 +38,7 @@ use core::libc;\n  * * ch - a channel of type T to send a `val` on\n  * * val - a value of type T to send over the provided `ch`\n  */\n-pub fn delayed_send<T:Owned>(iotask: &IoTask,\n+pub fn delayed_send<T:Send>(iotask: &IoTask,\n                               msecs: uint,\n                               ch: &Chan<T>,\n                               val: T) {\n@@ -111,19 +110,20 @@ pub fn sleep(iotask: &IoTask, msecs: uint) {\n  *\n  * * `iotask' - `uv::iotask` that the tcp request will run on\n  * * msecs - an mount of time, in milliseconds, to wait to receive\n- * * wait_port - a `core::comm::port<T>` to receive on\n+ * * wait_port - a `std::comm::port<T>` to receive on\n  *\n  * # Returns\n  *\n  * An `Option<T>` representing the outcome of the call. If the call `recv`'d\n  * on the provided port in the allotted timeout period, then the result will\n  * be a `Some(T)`. If not, then `None` will be returned.\n  */\n-pub fn recv_timeout<T:Copy + Owned>(iotask: &IoTask,\n+pub fn recv_timeout<T:Copy + Send>(iotask: &IoTask,\n                                    msecs: uint,\n                                    wait_po: &Port<T>)\n                                    -> Option<T> {\n-    let mut (timeout_po, timeout_ch) = stream::<()>();\n+    let (timeout_po, timeout_ch) = stream::<()>();\n+    let mut timeout_po = timeout_po;\n     delayed_send(iotask, msecs, &timeout_ch, ());\n \n     // XXX: Workaround due to ports and channels not being &mut. They should\n@@ -175,16 +175,15 @@ extern fn delayed_send_close_cb(handle: *uv::ll::uv_timer_t) {\n \n #[cfg(test)]\n mod test {\n-    use core::prelude::*;\n \n     use timer::*;\n     use uv;\n \n-    use core::cell::Cell;\n-    use core::pipes::{stream, SharedChan};\n-    use core::rand::RngUtil;\n-    use core::rand;\n-    use core::task;\n+    use std::cell::Cell;\n+    use std::pipes::{stream, SharedChan};\n+    use std::rand::RngUtil;\n+    use std::rand;\n+    use std::task;\n \n     #[test]\n     fn test_gl_timer_simple_sleep_test() {\n@@ -217,12 +216,12 @@ mod test {\n \n         for repeat.times {\n             let ch = ch.clone();\n-            for spec.each |spec| {\n+            for spec.iter().advance |spec| {\n                 let (times, maxms) = *spec;\n                 let ch = ch.clone();\n                 let hl_loop_clone = hl_loop.clone();\n                 do task::spawn {\n-                    use core::rand::*;\n+                    use std::rand::*;\n                     let mut rng = rng();\n                     for times.times {\n                         sleep(&hl_loop_clone, rng.next() as uint % maxms);"}, {"sha": "5e898f8e59d9d450973b5b205f98fed5ea6d16a3", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 46, "deletions": 65, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -12,10 +12,9 @@\n //! trees. The only requirement for the types is that the key implements\n //! `TotalOrd`.\n \n-use core::prelude::*;\n \n-use core::uint;\n-use core::util::{swap, replace};\n+use std::uint;\n+use std::util::{swap, replace};\n \n // This is implemented as an AA tree, which is a simplified variation of\n // a red-black tree where red (horizontal) nodes can only be added\n@@ -87,10 +86,10 @@ impl<K: Ord + TotalOrd, V> Ord for TreeMap<K, V> {\n \n impl<K: TotalOrd, V> Container for TreeMap<K, V> {\n     /// Return the number of elements in the map\n-    fn len(&const self) -> uint { self.length }\n+    fn len(&self) -> uint { self.length }\n \n     /// Return true if the map contains no elements\n-    fn is_empty(&const self) -> bool { self.root.is_none() }\n+    fn is_empty(&self) -> bool { self.root.is_none() }\n }\n \n impl<K: TotalOrd, V> Mutable for TreeMap<K, V> {\n@@ -107,26 +106,6 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n         self.find(key).is_some()\n     }\n \n-    /// Visit all key-value pairs in order\n-    fn each<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) -> bool {\n-        each(&self.root, f)\n-    }\n-\n-    /// Visit all keys in order\n-    fn each_key(&self, f: &fn(&K) -> bool) -> bool {\n-        self.each(|k, _| f(k))\n-    }\n-\n-    /// Visit all values in order\n-    fn each_value<'a>(&'a self, f: &fn(&'a V) -> bool) -> bool {\n-        self.each(|_, v| f(v))\n-    }\n-\n-    /// Iterate over the map and mutate the contained values\n-    fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool) -> bool {\n-        mutate_values(&mut self.root, f)\n-    }\n-\n     /// Return a reference to the value corresponding to the key\n     fn find<'a>(&'a self, key: &K) -> Option<&'a V> {\n         let mut current: &'a Option<~TreeNode<K, V>> = &self.root;\n@@ -184,6 +163,21 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Create an empty TreeMap\n     pub fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n+    /// Visit all keys in order\n+    pub fn each_key(&self, f: &fn(&K) -> bool) -> bool {\n+        self.iter().advance(|(k, _)| f(k))\n+    }\n+\n+    /// Visit all values in order\n+    pub fn each_value<'a>(&'a self, f: &fn(&'a V) -> bool) -> bool {\n+        self.iter().advance(|(_, v)| f(v))\n+    }\n+\n+    /// Iterate over the map and mutate the contained values\n+    pub fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool) -> bool {\n+        mutate_values(&mut self.root, f)\n+    }\n+\n     /// Visit all key-value pairs in reverse order\n     pub fn each_reverse<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) -> bool {\n         each_reverse(&self.root, f)\n@@ -249,22 +243,6 @@ pub struct TreeSet<T> {\n     priv map: TreeMap<T, ()>\n }\n \n-impl<T: TotalOrd> BaseIter<T> for TreeSet<T> {\n-    /// Visit all values in order\n-    #[inline]\n-    fn each(&self, f: &fn(&T) -> bool) -> bool { self.map.each_key(f) }\n-    #[inline]\n-    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n-}\n-\n-impl<T: TotalOrd> ReverseIter<T> for TreeSet<T> {\n-    /// Visit all values in reverse order\n-    #[inline]\n-    fn each_reverse(&self, f: &fn(&T) -> bool) -> bool {\n-        self.map.each_key_reverse(f)\n-    }\n-}\n-\n impl<T: Eq + TotalOrd> Eq for TreeSet<T> {\n     #[inline]\n     fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }\n@@ -286,11 +264,11 @@ impl<T: Ord + TotalOrd> Ord for TreeSet<T> {\n impl<T: TotalOrd> Container for TreeSet<T> {\n     /// Return the number of elements in the set\n     #[inline]\n-    fn len(&const self) -> uint { self.map.len() }\n+    fn len(&self) -> uint { self.map.len() }\n \n     /// Return true if the set contains no elements\n     #[inline]\n-    fn is_empty(&const self) -> bool { self.map.is_empty() }\n+    fn is_empty(&self) -> bool { self.map.is_empty() }\n }\n \n impl<T: TotalOrd> Mutable for TreeSet<T> {\n@@ -499,6 +477,12 @@ impl<T: TotalOrd> TreeSet<T> {\n     pub fn iter<'a>(&'a self) -> TreeSetIterator<'a, T> {\n         TreeSetIterator{iter: self.map.iter()}\n     }\n+\n+    /// Visit all values in reverse order\n+    #[inline]\n+    pub fn each_reverse(&self, f: &fn(&T) -> bool) -> bool {\n+        self.map.each_key_reverse(f)\n+    }\n }\n \n /// Lazy forward iterator over a set\n@@ -526,14 +510,14 @@ impl<K: TotalOrd, V> TreeNode<K, V> {\n \n fn each<'r, K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n                             f: &fn(&'r K, &'r V) -> bool) -> bool {\n-    node.iter().advance(|x| each(&x.left, f) && f(&x.key, &x.value) &&\n-                            each(&x.right, f))\n+    node.iter().advance(|x| each(&x.left,  |k,v| f(k,v)) && f(&x.key, &x.value) &&\n+                            each(&x.right, |k,v| f(k,v)))\n }\n \n fn each_reverse<'r, K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n                                     f: &fn(&'r K, &'r V) -> bool) -> bool {\n-    node.iter().advance(|x| each_reverse(&x.right, f) && f(&x.key, &x.value) &&\n-                            each_reverse(&x.left, f))\n+    node.iter().advance(|x| each_reverse(&x.right, |k,v| f(k,v)) && f(&x.key, &x.value) &&\n+                            each_reverse(&x.left,  |k,v| f(k,v)))\n }\n \n fn mutate_values<'r, K: TotalOrd, V>(node: &'r mut Option<~TreeNode<K, V>>,\n@@ -542,9 +526,9 @@ fn mutate_values<'r, K: TotalOrd, V>(node: &'r mut Option<~TreeNode<K, V>>,\n     match *node {\n       Some(~TreeNode{key: ref key, value: ref mut value, left: ref mut left,\n                      right: ref mut right, _}) => {\n-        if !mutate_values(left, f) { return false }\n+        if !mutate_values(left,  |k,v| f(k,v)) { return false }\n         if !f(key, value) { return false }\n-        if !mutate_values(right, f) { return false }\n+        if !mutate_values(right, |k,v| f(k,v)) { return false }\n       }\n       None => return false\n     }\n@@ -704,13 +688,11 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n \n #[cfg(test)]\n mod test_treemap {\n-    use core::prelude::*;\n \n     use super::*;\n \n-    use core::rand::RngUtil;\n-    use core::rand;\n-    use core::vec;\n+    use std::rand::RngUtil;\n+    use std::rand;\n \n     #[test]\n     fn find_empty() {\n@@ -781,13 +763,13 @@ mod test_treemap {\n     fn check_equal<K: Eq + TotalOrd, V: Eq>(ctrl: &[(K, V)],\n                                             map: &TreeMap<K, V>) {\n         assert_eq!(ctrl.is_empty(), map.is_empty());\n-        for ctrl.each |x| {\n+        for ctrl.iter().advance |x| {\n             let &(k, v) = x;\n             assert!(map.find(&k).unwrap() == &v)\n         }\n-        for map.each |map_k, map_v| {\n+        for map.iter().advance |(map_k, map_v)| {\n             let mut found = false;\n-            for ctrl.each |x| {\n+            for ctrl.iter().advance |x| {\n                 let &(ctrl_k, ctrl_v) = x;\n                 if *map_k == ctrl_k {\n                     assert!(*map_v == ctrl_v);\n@@ -853,7 +835,7 @@ mod test_treemap {\n             for 90.times {\n                 let k = rng.gen();\n                 let v = rng.gen();\n-                if !ctrl.contains(&(k, v)) {\n+                if !ctrl.iter().any_(|x| x == &(k, v)) {\n                     assert!(map.insert(k, v));\n                     ctrl.push((k, v));\n                     check_structure(&map);\n@@ -863,7 +845,7 @@ mod test_treemap {\n \n             for 30.times {\n                 let r = rng.gen_uint_range(0, ctrl.len());\n-                let (key, _) = vec::remove(&mut ctrl, r);\n+                let (key, _) = ctrl.remove(r);\n                 assert!(map.remove(&key));\n                 check_structure(&map);\n                 check_equal(ctrl, &map);\n@@ -891,7 +873,7 @@ mod test_treemap {\n     }\n \n     #[test]\n-    fn test_each() {\n+    fn test_iterator() {\n         let mut m = TreeMap::new();\n \n         assert!(m.insert(3, 6));\n@@ -901,7 +883,7 @@ mod test_treemap {\n         assert!(m.insert(1, 2));\n \n         let mut n = 0;\n-        for m.each |k, v| {\n+        for m.iter().advance |(k, v)| {\n             assert_eq!(*k, n);\n             assert_eq!(*v, n * 2);\n             n += 1;\n@@ -1026,7 +1008,6 @@ mod test_treemap {\n \n #[cfg(test)]\n mod test_set {\n-    use core::prelude::*;\n \n     use super::*;\n \n@@ -1096,7 +1077,7 @@ mod test_set {\n     }\n \n     #[test]\n-    fn test_each() {\n+    fn test_iterator() {\n         let mut m = TreeSet::new();\n \n         assert!(m.insert(3));\n@@ -1106,7 +1087,7 @@ mod test_set {\n         assert!(m.insert(1));\n \n         let mut n = 0;\n-        for m.each |x| {\n+        for m.iter().advance |x| {\n             println(fmt!(\"%?\", x));\n             assert_eq!(*x, n);\n             n += 1\n@@ -1135,8 +1116,8 @@ mod test_set {\n         let mut set_a = TreeSet::new();\n         let mut set_b = TreeSet::new();\n \n-        for a.each |x| { assert!(set_a.insert(*x)) }\n-        for b.each |y| { assert!(set_b.insert(*y)) }\n+        for a.iter().advance |x| { assert!(set_a.insert(*x)) }\n+        for b.iter().advance |y| { assert!(set_b.insert(*y)) }\n \n         let mut i = 0;\n         for f(&set_a, &set_b) |x| {"}, {"sha": "5501d73ac86802d9cfb07488d66de7599614df68", "filename": "src/libextra/uv_global_loop.rs", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuv_global_loop.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -10,16 +10,15 @@\n \n //! A process-wide libuv event loop for library use.\n \n-use core::prelude::*;\n \n use iotask = uv_iotask;\n use uv_iotask::{IoTask, spawn_iotask};\n \n-use core::comm::Chan;\n-use core::option::{Some, None};\n-use core::task::task;\n-use core::unstable::global::{global_data_clone_create, global_data_clone};\n-use core::unstable::weak_task::weaken_task;\n+use std::comm::Chan;\n+use std::option::{Some, None};\n+use std::task::task;\n+use std::unstable::global::{global_data_clone_create, global_data_clone};\n+use std::unstable::weak_task::weaken_task;\n \n /**\n  * Race-free helper to get access to a global task where a libuv\n@@ -126,11 +125,11 @@ mod test {\n     use uv::ll;\n     use uv_iotask::IoTask;\n \n-    use core::libc;\n-    use core::task;\n-    use core::cast::transmute;\n-    use core::libc::c_void;\n-    use core::comm::{stream, SharedChan, Chan};\n+    use std::libc;\n+    use std::task;\n+    use std::cast::transmute;\n+    use std::libc::c_void;\n+    use std::comm::{stream, SharedChan, Chan};\n \n     extern fn simple_timer_close_cb(timer_ptr: *ll::uv_timer_t) {\n         unsafe {\n@@ -150,9 +149,7 @@ mod test {\n             let hl_loop = &get_gl();\n             do iotask::interact(hl_loop) |_loop_ptr| {\n                 debug!(~\"closing timer\");\n-                unsafe {\n-                    ll::close(timer_ptr, simple_timer_close_cb);\n-                }\n+                ll::close(timer_ptr, simple_timer_close_cb);\n                 debug!(~\"about to deref exit_ch_ptr\");\n                 debug!(~\"after msg sent on deref'd exit_ch\");\n             };\n@@ -169,24 +166,22 @@ mod test {\n             let timer_handle = ll::timer_t();\n             let timer_ptr: *ll::uv_timer_t = &timer_handle;\n             do iotask::interact(iotask) |loop_ptr| {\n-                unsafe {\n-                    debug!(~\"user code inside interact loop!!!\");\n-                    let init_status = ll::timer_init(loop_ptr, timer_ptr);\n-                    if(init_status == 0i32) {\n-                        ll::set_data_for_uv_handle(\n-                            timer_ptr as *libc::c_void,\n-                            exit_ch_ptr);\n-                        let start_status = ll::timer_start(timer_ptr,\n-                                                           simple_timer_cb,\n-                                                           1u, 0u);\n-                        if(start_status != 0i32) {\n-                            fail!(\"failure on ll::timer_start()\");\n-                        }\n-                    }\n-                    else {\n-                        fail!(\"failure on ll::timer_init()\");\n+                debug!(~\"user code inside interact loop!!!\");\n+                let init_status = ll::timer_init(loop_ptr, timer_ptr);\n+                if(init_status == 0i32) {\n+                    ll::set_data_for_uv_handle(\n+                        timer_ptr as *libc::c_void,\n+                        exit_ch_ptr);\n+                    let start_status = ll::timer_start(timer_ptr,\n+                                                       simple_timer_cb,\n+                                                       1u, 0u);\n+                    if(start_status != 0i32) {\n+                        fail!(\"failure on ll::timer_start()\");\n                     }\n                 }\n+                else {\n+                    fail!(\"failure on ll::timer_init()\");\n+                }\n             };\n             exit_po.recv();\n             debug!("}, {"sha": "0a564045d32f06176ab045fa842b77387dcd69d4", "filename": "src/libextra/uv_iotask.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuv_iotask.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -17,14 +17,13 @@\n \n #[allow(missing_doc)];\n \n-use core::prelude::*;\n \n use ll = uv_ll;\n \n-use core::comm::{stream, Port, Chan, SharedChan};\n-use core::libc::c_void;\n-use core::libc;\n-use core::task;\n+use std::comm::{stream, Port, Chan, SharedChan};\n+use std::libc::c_void;\n+use std::libc;\n+use std::task;\n \n /// Used to abstract-away direct interaction with a libuv loop.\n pub struct IoTask {\n@@ -226,7 +225,7 @@ struct AhData {\n \n #[cfg(test)]\n fn impl_uv_iotask_async(iotask: &IoTask) {\n-    use core::ptr;\n+    use std::ptr;\n \n     let async_handle = ll::async_t();\n     let ah_ptr: *ll::uv_async_t = &async_handle;"}, {"sha": "db960f334fdc9cfde270d16c7cc64e7afd407634", "filename": "src/libextra/uv_ll.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuv_ll.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -33,14 +33,13 @@\n #[allow(non_camel_case_types)]; // C types\n #[allow(missing_doc)];\n \n-use core::prelude::*;\n \n-use core::libc::{c_void, size_t};\n-use core::libc;\n-use core::ptr::to_unsafe_ptr;\n-use core::ptr;\n-use core::str;\n-use core::vec;\n+use std::libc::{c_void, size_t};\n+use std::libc;\n+use std::ptr::to_unsafe_ptr;\n+use std::ptr;\n+use std::str;\n+use std::vec;\n \n pub type uv_handle_t = c_void;\n pub type uv_loop_t = c_void;\n@@ -362,7 +361,7 @@ pub struct uv_getaddrinfo_t {\n \n pub mod uv_ll_struct_stubgen {\n \n-    use core::ptr;\n+    use std::ptr;\n \n     use super::{\n         uv_async_t,\n@@ -1228,16 +1227,15 @@ pub unsafe fn addrinfo_as_sockaddr_in6(input: *addrinfo) -> *sockaddr_in6 {\n \n #[cfg(test)]\n mod test {\n-    use core::prelude::*;\n \n     use super::*;\n \n-    use core::comm::{SharedChan, stream, GenericChan, GenericPort};\n-    use core::libc;\n-    use core::str;\n-    use core::sys;\n-    use core::task;\n-    use core::vec;\n+    use std::comm::{SharedChan, stream, GenericChan, GenericPort};\n+    use std::libc;\n+    use std::str;\n+    use std::sys;\n+    use std::task;\n+    use std::vec;\n \n     enum tcp_read_data {\n         tcp_read_eof,\n@@ -1767,9 +1765,7 @@ mod test {\n         mod impl64 {\n             #[test]\n             fn test_uv_ll_tcp_server_and_request() {\n-                unsafe {\n-                    super::super::impl_uv_tcp_server_and_request();\n-                }\n+                super::super::impl_uv_tcp_server_and_request();\n             }\n         }\n         #[cfg(target_arch=\"x86\")]"}, {"sha": "503bd05b7337de5543093faceed0dcf986b2eda3", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -10,24 +10,24 @@\n \n #[allow(missing_doc)];\n \n-use core::prelude::*;\n \n+use digest::DigestUtil;\n use json;\n-use sha1;\n+use sha1::Sha1;\n use serialize::{Encoder, Encodable, Decoder, Decodable};\n use sort;\n \n-use core::cell::Cell;\n-use core::cmp;\n-use core::comm::{PortOne, oneshot, send_one, recv_one};\n-use core::either::{Either, Left, Right};\n-use core::hashmap::HashMap;\n-use core::io;\n-use core::result;\n-use core::run;\n-use core::task;\n-use core::to_bytes;\n-use core::util::replace;\n+use std::cell::Cell;\n+use std::cmp;\n+use std::comm::{PortOne, oneshot, send_one, recv_one};\n+use std::either::{Either, Left, Right};\n+use std::hashmap::HashMap;\n+use std::io;\n+use std::result;\n+use std::run;\n+use std::task;\n+use std::to_bytes;\n+use std::util::replace;\n \n /**\n *\n@@ -106,7 +106,7 @@ struct WorkKey {\n impl to_bytes::IterBytes for WorkKey {\n     #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.kind.iter_bytes(lsb0, f) && self.name.iter_bytes(lsb0, f)\n+        self.kind.iter_bytes(lsb0, |b| f(b)) && self.name.iter_bytes(lsb0, |b| f(b))\n     }\n }\n \n@@ -145,7 +145,7 @@ impl WorkMap {\n impl<S:Encoder> Encodable<S> for WorkMap {\n     fn encode(&self, s: &mut S) {\n         let mut d = ~[];\n-        for self.each |k, v| {\n+        for self.iter().advance |(k, v)| {\n             d.push((copy *k, copy *v))\n         }\n         sort::tim_sort(d);\n@@ -157,7 +157,7 @@ impl<D:Decoder> Decodable<D> for WorkMap {\n     fn decode(d: &mut D) -> WorkMap {\n         let v : ~[(WorkKey,~str)] = Decodable::decode(d);\n         let mut w = WorkMap::new();\n-        for v.each |&(k, v)| {\n+        for v.iter().advance |&(k, v)| {\n             w.insert(copy k, copy v);\n         }\n         w\n@@ -248,16 +248,16 @@ fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n }\n \n fn digest<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n-    let mut sha = sha1::sha1();\n-    sha.input_str(json_encode(t));\n-    sha.result_str()\n+    let mut sha = ~Sha1::new();\n+    (*sha).input_str(json_encode(t));\n+    (*sha).result_str()\n }\n \n fn digest_file(path: &Path) -> ~str {\n-    let mut sha = sha1::sha1();\n+    let mut sha = ~Sha1::new();\n     let s = io::read_whole_file_str(path);\n-    sha.input_str(*s.get_ref());\n-    sha.result_str()\n+    (*sha).input_str(*s.get_ref());\n+    (*sha).result_str()\n }\n \n impl Context {\n@@ -271,7 +271,7 @@ impl Context {\n         }\n     }\n \n-    pub fn prep<T:Owned +\n+    pub fn prep<T:Send +\n                   Encodable<json::Encoder> +\n                   Decodable<json::Decoder>>(@self, // FIXME(#5121)\n                                             fn_name:&str,\n@@ -291,7 +291,7 @@ trait TPrep {\n     fn declare_input(&mut self, kind:&str, name:&str, val:&str);\n     fn is_fresh(&self, cat:&str, kind:&str, name:&str, val:&str) -> bool;\n     fn all_fresh(&self, cat:&str, map:&WorkMap) -> bool;\n-    fn exec<T:Owned +\n+    fn exec<T:Send +\n               Encodable<json::Encoder> +\n               Decodable<json::Decoder>>( // FIXME(#5121)\n         &self, blk: ~fn(&Exec) -> T) -> Work<T>;\n@@ -319,15 +319,15 @@ impl TPrep for Prep {\n     }\n \n     fn all_fresh(&self, cat: &str, map: &WorkMap) -> bool {\n-        for map.each |k, v| {\n+        for map.iter().advance |(k, v)| {\n             if ! self.is_fresh(cat, k.kind, k.name, *v) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n-    fn exec<T:Owned +\n+    fn exec<T:Send +\n               Encodable<json::Encoder> +\n               Decodable<json::Decoder>>( // FIXME(#5121)\n             &self, blk: ~fn(&Exec) -> T) -> Work<T> {\n@@ -364,7 +364,7 @@ impl TPrep for Prep {\n     }\n }\n \n-impl<T:Owned +\n+impl<T:Send +\n        Encodable<json::Encoder> +\n        Decodable<json::Decoder>> Work<T> { // FIXME(#5121)\n     pub fn new(p: @mut Prep, e: Either<T,PortOne<(Exec,T)>>) -> Work<T> {\n@@ -373,7 +373,7 @@ impl<T:Owned +\n }\n \n // FIXME (#3724): movable self. This should be in impl Work.\n-fn unwrap<T:Owned +\n+fn unwrap<T:Send +\n             Encodable<json::Encoder> +\n             Decodable<json::Decoder>>( // FIXME(#5121)\n         w: Work<T>) -> T {\n@@ -402,7 +402,7 @@ fn unwrap<T:Owned +\n \n //#[test]\n fn test() {\n-    use core::io::WriterUtil;\n+    use std::io::WriterUtil;\n \n     let db = @mut Database { db_filename: Path(\"db.json\"),\n                              db_cache: HashMap::new(),"}, {"sha": "30b980a2f858a7c8672d25836ef0ad4aa30ed39e", "filename": "src/librust/rust.rs", "status": "renamed", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrust%2Frust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrust%2Frust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -13,35 +13,22 @@\n // FIXME #2238 Make run only accept source that emits an executable\n \n #[link(name = \"rust\",\n-       vers = \"0.7-pre\",\n+       vers = \"0.7\",\n        uuid = \"4a24da33-5cc8-4037-9352-2cbe9bd9d27c\",\n        url = \"https://github.com/mozilla/rust/tree/master/src/rust\")];\n \n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n \n-#[no_std];\n-\n-extern mod core(name = \"std\");\n-\n extern mod rustpkg;\n extern mod rustdoc;\n extern mod rusti;\n extern mod rustc;\n \n-use core::prelude::*;\n-\n-use core::io;\n-use core::os;\n-use core::run;\n-use core::libc::exit;\n-\n-// For bootstrapping.\n-mod std {\n-    pub use core::os;\n-    pub use core::str;\n-    pub use core::unstable;\n-}\n+use std::io;\n+use std::os;\n+use std::run;\n+use std::libc::exit;\n \n enum ValidUsage {\n     Valid(int), Invalid\n@@ -57,13 +44,13 @@ impl ValidUsage {\n }\n \n enum Action<'self> {\n-    Call(&'self fn(args: &[~str]) -> ValidUsage),\n-    CallMain(&'static str, &'self fn()),\n+    Call(&'self fn:Copy(args: &[~str]) -> ValidUsage),\n+    CallMain(&'static str, &'self fn:Copy()),\n }\n \n enum UsageSource<'self> {\n     UsgStr(&'self str),\n-    UsgCall(&'self fn()),\n+    UsgCall(&'self fn:Copy()),\n }\n \n struct Command<'self> {\n@@ -135,9 +122,9 @@ fn rustc_help() {\n }\n \n fn find_cmd(command_string: &str) -> Option<Command> {\n-    do commands.find |command| {\n+    do commands.iter().find_ |command| {\n         command.cmd == command_string\n-    }\n+    }.map_consume(|x| copy *x)\n }\n \n fn cmd_help(args: &[~str]) -> ValidUsage {\n@@ -222,7 +209,7 @@ fn usage() {\n         \\n\"\n     );\n \n-    for commands.each |command| {\n+    for commands.iter().advance |command| {\n         let padding = \" \".repeat(indent - command.cmd.len());\n         io::println(fmt!(\"    %s%s%s\",\n                          command.cmd, padding, command.usage_line));\n@@ -238,6 +225,12 @@ fn usage() {\n \n pub fn main() {\n     let os_args = os::args();\n+\n+    if (os_args.len() > 1 && (os_args[1] == ~\"-v\" || os_args[1] == ~\"--version\")) {\n+        rustc::version(os_args[0]);\n+        unsafe { exit(0); }\n+    }\n+\n     let args = os_args.tail();\n \n     if !args.is_empty() {", "previous_filename": "src/librust/rust.rc"}, {"sha": "05b6e90c682f0f6030588c444c9df4e5e59a9c8f", "filename": "src/librustc/back/abi.rs", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fabi.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-\n-\n pub static rc_base_field_refcnt: uint = 0u;\n \n pub static task_field_refcnt: uint = 0u;\n@@ -49,20 +46,16 @@ pub static tydesc_field_take_glue: uint = 2u;\n pub static tydesc_field_drop_glue: uint = 3u;\n pub static tydesc_field_free_glue: uint = 4u;\n pub static tydesc_field_visit_glue: uint = 5u;\n-pub static tydesc_field_shape: uint = 6u;\n-pub static tydesc_field_shape_tables: uint = 7u;\n-pub static n_tydesc_fields: uint = 8u;\n+pub static n_tydesc_fields: uint = 6u;\n \n // The two halves of a closure: code and environment.\n pub static fn_field_code: uint = 0u;\n pub static fn_field_box: uint = 1u;\n \n-// The three fields of a trait object/trait instance: vtable, box, and type\n-// description.\n+// The two fields of a trait object/trait instance: vtable and box.\n+// The vtable contains the type descriptor as first element.\n pub static trt_field_vtable: uint = 0u;\n pub static trt_field_box: uint = 1u;\n-// This field is only present in unique trait objects, so it comes last.\n-pub static trt_field_tydesc: uint = 2u;\n \n pub static vec_elt_fill: uint = 0u;\n \n@@ -73,14 +66,4 @@ pub static vec_elt_elems: uint = 2u;\n pub static slice_elt_base: uint = 0u;\n pub static slice_elt_len: uint = 1u;\n \n-pub static worst_case_glue_call_args: uint = 7u;\n-\n pub static abi_version: uint = 1u;\n-\n-pub fn memcpy_glue_name() -> ~str { return ~\"rust_memcpy_glue\"; }\n-\n-pub fn bzero_glue_name() -> ~str { return ~\"rust_bzero_glue\"; }\n-\n-pub fn yield_glue_name() -> ~str { return ~\"rust_yield_glue\"; }\n-\n-pub fn no_op_type_glue_name() -> ~str { return ~\"rust_no_op_type_glue\"; }"}, {"sha": "61d39421b7fd019c1f3f7f5062c783dd4e5b60f3", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 126, "deletions": 131, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n \n use back::rpath;\n use driver::session::Session;\n@@ -19,24 +18,26 @@ use lib;\n use metadata::common::LinkMeta;\n use metadata::{encoder, csearch, cstore};\n use middle::trans::context::CrateContext;\n+use middle::trans::common::gensym_name;\n use middle::ty;\n use util::ppaux;\n \n-use core::char;\n-use core::hash::Streaming;\n-use core::hash;\n-use core::libc::{c_int, c_uint};\n-use core::os::consts::{macos, freebsd, linux, android, win32};\n-use core::os;\n-use core::ptr;\n-use core::rt::io::Writer;\n-use core::run;\n-use core::str;\n-use core::vec;\n+use std::char;\n+use std::hash::Streaming;\n+use std::hash;\n+use std::libc::{c_int, c_uint};\n+use std::os::consts::{macos, freebsd, linux, android, win32};\n+use std::os;\n+use std::ptr;\n+use std::rt::io::Writer;\n+use std::run;\n+use std::str;\n+use std::vec;\n use syntax::ast;\n use syntax::ast_map::{path, path_mod, path_name};\n use syntax::attr;\n use syntax::print::pprust;\n+use syntax::parse::token;\n \n #[deriving(Eq)]\n pub enum output_type {\n@@ -96,19 +97,18 @@ pub fn WriteOutputFile(sess: Session,\n }\n \n pub mod jit {\n-    use core::prelude::*;\n \n     use back::link::llvm_err;\n     use driver::session::Session;\n     use lib::llvm::llvm;\n     use lib::llvm::{ModuleRef, ContextRef};\n     use metadata::cstore;\n \n-    use core::cast;\n-    use core::ptr;\n-    use core::str;\n-    use core::sys;\n-    use core::unstable::intrinsics;\n+    use std::cast;\n+    use std::ptr;\n+    use std::str;\n+    use std::sys;\n+    use std::unstable::intrinsics;\n \n     pub fn exec(sess: Session,\n                 c: ContextRef,\n@@ -124,19 +124,18 @@ pub mod jit {\n             // incase the user wants to use an older extra library.\n \n             let cstore = sess.cstore;\n-            for cstore::get_used_crate_files(cstore).each |cratepath| {\n+            let r = cstore::get_used_crate_files(cstore);\n+            for r.iter().advance |cratepath| {\n                 let path = cratepath.to_str();\n \n                 debug!(\"linking: %s\", path);\n \n-                let _: () = str::as_c_str(\n-                    path,\n-                    |buf_t| {\n-                        if !llvm::LLVMRustLoadCrate(manager, buf_t) {\n-                            llvm_err(sess, ~\"Could not link\");\n-                        }\n-                        debug!(\"linked: %s\", path);\n-                    });\n+                do str::as_c_str(path) |buf_t| {\n+                    if !llvm::LLVMRustLoadCrate(manager, buf_t) {\n+                        llvm_err(sess, ~\"Could not link\");\n+                    }\n+                    debug!(\"linked: %s\", path);\n+                }\n             }\n \n             // We custom-build a JIT execution engine via some rust wrappers\n@@ -181,7 +180,6 @@ pub mod jit {\n }\n \n pub mod write {\n-    use core::prelude::*;\n \n     use back::link::jit;\n     use back::link::{WriteOutputFile, output_type};\n@@ -197,17 +195,16 @@ pub mod write {\n \n     use back::passes;\n \n-    use core::libc::{c_int, c_uint};\n-    use core::path::Path;\n-    use core::run;\n-    use core::str;\n+    use std::libc::{c_int, c_uint};\n+    use std::path::Path;\n+    use std::run;\n+    use std::str;\n \n     pub fn is_object_or_assembly_or_exe(ot: output_type) -> bool {\n-        if ot == output_type_assembly || ot == output_type_object ||\n-               ot == output_type_exe {\n-            return true;\n+        match ot {\n+            output_type_assembly | output_type_object | output_type_exe => true,\n+            _ => false\n         }\n-        return false;\n     }\n \n     pub fn run_passes(sess: Session,\n@@ -290,11 +287,11 @@ pub mod write {\n                   session::Aggressive => LLVMOptAggressive\n                 };\n \n-                let FileType;\n-                if output_type == output_type_object ||\n-                       output_type == output_type_exe {\n-                   FileType = lib::llvm::ObjectFile;\n-                } else { FileType = lib::llvm::AssemblyFile; }\n+                let FileType = match output_type {\n+                    output_type_object | output_type_exe => lib::llvm::ObjectFile,\n+                    _ => lib::llvm::AssemblyFile\n+                };\n+\n                 // Write optimized bitcode if --save-temps was on.\n \n                 if opts.save_temps {\n@@ -384,11 +381,11 @@ pub mod write {\n                             (--android-cross-path)\")\n             }\n         };\n-        let mut cc_args = ~[];\n-        cc_args.push(~\"-c\");\n-        cc_args.push(~\"-o\");\n-        cc_args.push(object.to_str());\n-        cc_args.push(assembly.to_str());\n+\n+        let cc_args = ~[\n+            ~\"-c\",\n+            ~\"-o\", object.to_str(),\n+            assembly.to_str()];\n \n         let prog = run::process_output(cc_prog, cc_args);\n \n@@ -473,20 +470,20 @@ pub fn build_link_meta(sess: Session,\n         let mut cmh_items = ~[];\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess.diagnostic(), linkage_metas);\n-        for linkage_metas.each |meta| {\n-            if \"name\" == attr::get_meta_item_name(*meta) {\n-                match attr::get_meta_item_value_str(*meta) {\n-                  // Changing attr would avoid the need for the copy\n-                  // here\n-                  Some(v) => { name = Some(v); }\n-                  None => cmh_items.push(*meta)\n-                }\n-            } else if \"vers\" == attr::get_meta_item_name(*meta) {\n-                match attr::get_meta_item_value_str(*meta) {\n-                  Some(v) => { vers = Some(v); }\n-                  None => cmh_items.push(*meta)\n-                }\n-            } else { cmh_items.push(*meta); }\n+        for linkage_metas.iter().advance |meta| {\n+            match attr::get_meta_item_value_str(*meta) {\n+                Some(value) => {\n+                    let item_name : &str = attr::get_meta_item_name(*meta);\n+                    match item_name {\n+                        // Changing attr would avoid the need for the copy\n+                        // here\n+                        \"name\" => name = Some(value),\n+                        \"vers\" => vers = Some(value),\n+                        _ => cmh_items.push(*meta)\n+                    }\n+                },\n+                None => cmh_items.push(*meta)\n+            }\n         }\n \n         ProvidedMetas {\n@@ -521,23 +518,23 @@ pub fn build_link_meta(sess: Session,\n               }\n               ast::meta_list(name, ref mis) => {\n                 write_string(symbol_hasher, len_and_str(name));\n-                for mis.each |m_| {\n+                for mis.iter().advance |m_| {\n                     hash(symbol_hasher, m_);\n                 }\n               }\n             }\n         }\n \n         symbol_hasher.reset();\n-        for cmh_items.each |m| {\n+        for cmh_items.iter().advance |m| {\n             hash(symbol_hasher, m);\n         }\n \n-        for dep_hashes.each |dh| {\n+        for dep_hashes.iter().advance |dh| {\n             write_string(symbol_hasher, len_and_str(*dh));\n         }\n \n-    // tjc: allocation is unfortunate; need to change core::hash\n+    // tjc: allocation is unfortunate; need to change std::hash\n         return truncated_hash_result(symbol_hasher).to_managed();\n     }\n \n@@ -548,32 +545,32 @@ pub fn build_link_meta(sess: Session,\n     }\n \n     fn crate_meta_name(sess: Session, output: &Path, opt_name: Option<@str>)\n-                    -> @str {\n-        return match opt_name {\n-              Some(v) => v,\n-              None => {\n+        -> @str {\n+        match opt_name {\n+            Some(v) => v,\n+            None => {\n                 // to_managed could go away if there was a version of\n                 // filestem that returned an @str\n                 let name = session::expect(sess,\n-                                  output.filestem(),\n-                                  || fmt!(\"output file name `%s` doesn't\\\n-                                           appear to have a stem\",\n-                                          output.to_str())).to_managed();\n+                                           output.filestem(),\n+                                           || fmt!(\"output file name `%s` doesn't\\\n+                                                    appear to have a stem\",\n+                                                   output.to_str())).to_managed();\n                 warn_missing(sess, \"name\", name);\n                 name\n-              }\n-            };\n+            }\n+        }\n     }\n \n     fn crate_meta_vers(sess: Session, opt_vers: Option<@str>) -> @str {\n-        return match opt_vers {\n-              Some(v) => v,\n-              None => {\n+        match opt_vers {\n+            Some(v) => v,\n+            None => {\n                 let vers = @\"0.0\";\n                 warn_missing(sess, \"vers\", vers);\n                 vers\n-              }\n-            };\n+            }\n+        }\n     }\n \n     let ProvidedMetas {\n@@ -618,7 +615,7 @@ pub fn symbol_hash(tcx: ty::ctxt,\n     let mut hash = truncated_hash_result(symbol_hasher);\n     // Prefix with _ so that it never blends into adjacent digits\n     hash.unshift_char('_');\n-    // tjc: allocation is unfortunate; need to change core::hash\n+    // tjc: allocation is unfortunate; need to change std::hash\n     hash.to_managed()\n }\n \n@@ -642,15 +639,15 @@ pub fn sanitize(s: &str) -> ~str {\n     for s.iter().advance |c| {\n         match c {\n             // Escape these with $ sequences\n-            '@' => result += \"$SP$\",\n-            '~' => result += \"$UP$\",\n-            '*' => result += \"$RP$\",\n-            '&' => result += \"$BP$\",\n-            '<' => result += \"$LT$\",\n-            '>' => result += \"$GT$\",\n-            '(' => result += \"$LP$\",\n-            ')' => result += \"$RP$\",\n-            ',' => result += \"$C$\",\n+            '@' => result.push_str(\"$SP$\"),\n+            '~' => result.push_str(\"$UP$\"),\n+            '*' => result.push_str(\"$RP$\"),\n+            '&' => result.push_str(\"$BP$\"),\n+            '<' => result.push_str(\"$LT$\"),\n+            '>' => result.push_str(\"$GT$\"),\n+            '(' => result.push_str(\"$LP$\"),\n+            ')' => result.push_str(\"$RP$\"),\n+            ',' => result.push_str(\"$C$\"),\n \n             // '.' doesn't occur in types and functions, so reuse it\n             // for ':'\n@@ -663,9 +660,10 @@ pub fn sanitize(s: &str) -> ~str {\n             | '_' => result.push_char(c),\n \n             _ => {\n-                if c > 'z' && char::is_XID_continue(c) {\n-                    result.push_char(c);\n-                }\n+                let mut tstr = ~\"\";\n+                do char::escape_unicode(c) |c| { tstr.push_char(c); }\n+                result.push_char('$');\n+                result.push_str(tstr.slice_from(1));\n             }\n         }\n     }\n@@ -685,24 +683,26 @@ pub fn mangle(sess: Session, ss: path) -> ~str {\n \n     let mut n = ~\"_ZN\"; // Begin name-sequence.\n \n-    for ss.each |s| {\n-        match *s { path_name(s) | path_mod(s) => {\n-          let sani = sanitize(sess.str_of(s));\n-          n += fmt!(\"%u%s\", sani.len(), sani);\n-        } }\n+    for ss.iter().advance |s| {\n+        match *s {\n+            path_name(s) | path_mod(s) => {\n+                let sani = sanitize(sess.str_of(s));\n+                n.push_str(fmt!(\"%u%s\", sani.len(), sani));\n+            }\n+        }\n     }\n-    n += \"E\"; // End name-sequence.\n+    n.push_char('E'); // End name-sequence.\n     n\n }\n \n pub fn exported_name(sess: Session,\n                      path: path,\n                      hash: &str,\n                      vers: &str) -> ~str {\n-    return mangle(sess,\n-            vec::append_one(\n-            vec::append_one(path, path_name(sess.ident_of(hash))),\n-            path_name(sess.ident_of(vers))));\n+    mangle(sess,\n+           vec::append_one(\n+               vec::append_one(path, path_name(sess.ident_of(hash))),\n+               path_name(sess.ident_of(vers))))\n }\n \n pub fn mangle_exported_name(ccx: &mut CrateContext,\n@@ -733,22 +733,22 @@ pub fn mangle_internal_name_by_type_and_seq(ccx: &mut CrateContext,\n     return mangle(ccx.sess,\n         ~[path_name(ccx.sess.ident_of(s)),\n           path_name(ccx.sess.ident_of(hash)),\n-          path_name((ccx.names)(name))]);\n+          path_name(gensym_name(name))]);\n }\n \n pub fn mangle_internal_name_by_path_and_seq(ccx: &mut CrateContext,\n-                                            path: path,\n+                                            mut path: path,\n                                             flav: &str) -> ~str {\n-    return mangle(ccx.sess,\n-                  vec::append_one(path, path_name((ccx.names)(flav))));\n+    path.push(path_name(gensym_name(flav)));\n+    mangle(ccx.sess, path)\n }\n \n pub fn mangle_internal_name_by_path(ccx: &mut CrateContext, path: path) -> ~str {\n-    return mangle(ccx.sess, path);\n+    mangle(ccx.sess, path)\n }\n \n-pub fn mangle_internal_name_by_seq(ccx: &mut CrateContext, flav: &str) -> ~str {\n-    return fmt!(\"%s_%u\", flav, (ccx.names)(flav).name);\n+pub fn mangle_internal_name_by_seq(_ccx: &mut CrateContext, flav: &str) -> ~str {\n+    return fmt!(\"%s_%u\", flav, token::gensym(flav));\n }\n \n \n@@ -776,8 +776,8 @@ pub fn link_binary(sess: Session,\n     // so we add a condition to make it use gcc.\n     let cc_prog: ~str = match sess.opts.linker {\n         Some(ref linker) => copy *linker,\n-        None => {\n-            if sess.targ_cfg.os == session::os_android {\n+        None => match sess.targ_cfg.os {\n+            session::os_android =>\n                 match &sess.opts.android_cross_path {\n                     &Some(ref path) => {\n                         fmt!(\"%s/bin/arm-linux-androideabi-gcc\", *path)\n@@ -786,12 +786,9 @@ pub fn link_binary(sess: Session,\n                         sess.fatal(\"need Android NDK path for linking \\\n                                     (--android-cross-path)\")\n                     }\n-                }\n-            } else if sess.targ_cfg.os == session::os_win32 {\n-                ~\"gcc\"\n-            } else {\n-                ~\"cc\"\n-            }\n+                },\n+            session::os_win32 => ~\"gcc\",\n+            _ => ~\"cc\"\n         }\n     };\n     // The invocations of cc share some flags across platforms\n@@ -866,22 +863,20 @@ pub fn link_args(sess: Session,\n \n     let mut args = vec::append(~[stage], sess.targ_cfg.target_strs.cc_args);\n \n-    args.push(~\"-o\");\n-    args.push(output.to_str());\n-    args.push(obj_filename.to_str());\n+    args.push_all([\n+        ~\"-o\", output.to_str(),\n+        obj_filename.to_str()]);\n \n-    let lib_cmd;\n-    let os = sess.targ_cfg.os;\n-    if os == session::os_macos {\n-        lib_cmd = ~\"-dynamiclib\";\n-    } else {\n-        lib_cmd = ~\"-shared\";\n-    }\n+    let lib_cmd = match sess.targ_cfg.os {\n+        session::os_macos => ~\"-dynamiclib\",\n+        _ => ~\"-shared\"\n+    };\n \n     // # Crate linking\n \n     let cstore = sess.cstore;\n-    for cstore::get_used_crate_files(cstore).each |cratepath| {\n+    let r = cstore::get_used_crate_files(cstore);\n+    for r.iter().advance |cratepath| {\n         if cratepath.filetype() == Some(~\".rlib\") {\n             args.push(cratepath.to_str());\n             loop;\n@@ -893,7 +888,7 @@ pub fn link_args(sess: Session,\n     }\n \n     let ula = cstore::get_used_link_args(cstore);\n-    for ula.each |arg| { args.push(arg.to_owned()); }\n+    for ula.iter().advance |arg| { args.push(arg.to_owned()); }\n \n     // Add all the link args for external crates.\n     do cstore::iter_crate_data(cstore) |crate_num, _| {\n@@ -911,13 +906,13 @@ pub fn link_args(sess: Session,\n     // to be found at compile time so it is still entirely up to outside\n     // forces to make sure that library can be found at runtime.\n \n-    for sess.opts.addl_lib_search_paths.each |path| {\n+    for sess.opts.addl_lib_search_paths.iter().advance |path| {\n         args.push(~\"-L\" + path.to_str());\n     }\n \n     // The names of the extern libraries\n     let used_libs = cstore::get_used_libraries(cstore);\n-    for used_libs.each |l| { args.push(~\"-l\" + *l); }\n+    for used_libs.iter().advance |l| { args.push(~\"-l\" + *l); }\n \n     if *sess.building_library {\n         args.push(lib_cmd);"}, {"sha": "c1192707c1c157d14cc43cfb7b473355cf2a26be", "filename": "src/librustc/back/passes.rs", "status": "modified", "additions": 98, "deletions": 80, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fback%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fback%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fpasses.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n-use core::str;\n-use core::io;\n+use std::str;\n+use std::io;\n \n use driver::session::{OptLevel, No, Less, Aggressive};\n use driver::session::{Session};\n@@ -23,7 +22,7 @@ pub struct PassManager {\n }\n \n impl Drop for PassManager {\n-    fn finalize(&self) {\n+    fn drop(&self) {\n         unsafe {\n             llvm::LLVMDisposePassManager(self.llpm);\n         }\n@@ -60,94 +59,113 @@ impl PassManager {\n     }\n }\n \n-pub fn create_standard_passes(level:OptLevel) -> ~[~str] {\n-    let mut passes = ~[~\"strip-dead-prototypes\"];\n-\n-    if level == No {\n-        passes.push(~\"always-inline\");\n-        return passes;\n+pub fn create_standard_passes(level: OptLevel) -> ~[~str] {\n+    let mut passes = ~[];\n+\n+    // mostly identical to clang 3.3, all differences are documented with comments\n+\n+    if level != No {\n+        passes.push(~\"targetlibinfo\");\n+        passes.push(~\"no-aa\");\n+        // \"tbaa\" omitted, we don't emit clang-style type-based alias analysis information\n+        passes.push(~\"basicaa\");\n+        passes.push(~\"globalopt\");\n+        passes.push(~\"ipsccp\");\n+        passes.push(~\"deadargelim\");\n+        passes.push(~\"instcombine\");\n+        passes.push(~\"simplifycfg\");\n     }\n \n-    passes.push(~\"targetlibinfo\");\n-\n-    passes.push(~\"scev-aa\");\n-    passes.push(~\"basicaa\");\n-\n-    passes.push(~\"instcombine\");\n-    passes.push(~\"simplifycfg\");\n-    passes.push(~\"scalarrepl-ssa\");\n-    passes.push(~\"early-cse\");\n-\n-    passes.push(~\"globalopt\");\n-    passes.push(~\"ipsccp\");\n-    passes.push(~\"deadargelim\");\n-    passes.push(~\"instcombine\");\n-    passes.push(~\"simplifycfg\");\n+    passes.push(~\"basiccg\");\n \n-    passes.push(~\"prune-eh\");\n-\n-    passes.push(~\"inline\");\n-\n-    passes.push(~\"functionattrs\");\n-\n-    if level == Aggressive {\n-        passes.push(~\"argpromotion\");\n+    if level != No {\n+        passes.push(~\"prune-eh\");\n     }\n \n-    passes.push(~\"scalarrepl-ssa\");\n-    passes.push(~\"early-cse\");\n-    passes.push(~\"simplify-libcalls\");\n-    passes.push(~\"jump-threading\");\n-    passes.push(~\"correlated-propagation\");\n-    passes.push(~\"simplifycfg\");\n-    passes.push(~\"instcombine\");\n-\n-    passes.push(~\"tailcallelim\");\n-    passes.push(~\"simplifycfg\");\n-    passes.push(~\"reassociate\");\n-    passes.push(~\"loop-rotate\");\n-    passes.push(~\"licm\");\n-\n-    passes.push(~\"lcssa\");\n-    passes.push(~\"loop-unswitch\");\n+    passes.push(~\"inline-cost\");\n \n-    passes.push(~\"instcombine\");\n-    passes.push(~\"indvars\");\n-    passes.push(~\"loop-idiom\");\n-    passes.push(~\"loop-deletion\");\n-\n-    if level == Aggressive {\n-        passes.push(~\"loop-vectorize\");\n+    if level == No || level == Less {\n+        passes.push(~\"always-inline\");\n+    } else {\n+        passes.push(~\"inline\");\n     }\n \n-    passes.push(~\"loop-unroll\");\n-\n-    if level != Less {\n-        passes.push(~\"gvn\");\n+    if level != No {\n+        passes.push(~\"functionattrs\");\n+        if level == Aggressive {\n+            passes.push(~\"argpromotion\");\n+        }\n+        passes.push(~\"sroa\");\n+        passes.push(~\"domtree\");\n+        passes.push(~\"early-cse\");\n+        passes.push(~\"simplify-libcalls\");\n+        passes.push(~\"lazy-value-info\");\n+        passes.push(~\"jump-threading\");\n+        passes.push(~\"correlated-propagation\");\n+        passes.push(~\"simplifycfg\");\n+        passes.push(~\"instcombine\");\n+        passes.push(~\"tailcallelim\");\n+        passes.push(~\"simplifycfg\");\n+        passes.push(~\"reassociate\");\n+        passes.push(~\"domtree\");\n+        passes.push(~\"loops\");\n+        passes.push(~\"loop-simplify\");\n+        passes.push(~\"lcssa\");\n+        passes.push(~\"loop-rotate\");\n+        passes.push(~\"licm\");\n+        passes.push(~\"lcssa\");\n+        passes.push(~\"loop-unswitch\");\n+        passes.push(~\"instcombine\");\n+        passes.push(~\"scalar-evolution\");\n+        passes.push(~\"loop-simplify\");\n+        passes.push(~\"lcssa\");\n+        passes.push(~\"indvars\");\n+        passes.push(~\"loop-idiom\");\n+        passes.push(~\"loop-deletion\");\n+        if level == Aggressive {\n+            passes.push(~\"loop-simplify\");\n+            passes.push(~\"lcssa\");\n+            passes.push(~\"loop-vectorize\");\n+            passes.push(~\"loop-simplify\");\n+            passes.push(~\"lcssa\");\n+            passes.push(~\"scalar-evolution\");\n+            passes.push(~\"loop-simplify\");\n+            passes.push(~\"lcssa\");\n+        }\n+        if level != Less {\n+            passes.push(~\"loop-unroll\");\n+            passes.push(~\"memdep\");\n+            passes.push(~\"gvn\");\n+        }\n+        passes.push(~\"memdep\");\n+        passes.push(~\"memcpyopt\");\n+        passes.push(~\"sccp\");\n+        passes.push(~\"instcombine\");\n+        passes.push(~\"lazy-value-info\");\n+        passes.push(~\"jump-threading\");\n+        passes.push(~\"correlated-propagation\");\n+        passes.push(~\"domtree\");\n+        passes.push(~\"memdep\");\n+        passes.push(~\"dse\");\n+        passes.push(~\"adce\");\n+        passes.push(~\"simplifycfg\");\n+        passes.push(~\"instcombine\");\n+        // clang does `strip-dead-prototypes` here, since it does not emit them\n     }\n \n-    passes.push(~\"memcpyopt\");\n-    passes.push(~\"sccp\");\n-\n-    passes.push(~\"instcombine\");\n-    passes.push(~\"jump-threading\");\n-    passes.push(~\"correlated-propagation\");\n-    passes.push(~\"dse\");\n-\n-    passes.push(~\"adce\");\n-    passes.push(~\"simplifycfg\");\n-    passes.push(~\"instsimplify\");\n+    // rustc emits dead prototypes, so always ask LLVM to strip them\n+    passes.push(~\"strip-dead-prototypes\");\n \n     if level != Less {\n         passes.push(~\"globaldce\");\n         passes.push(~\"constmerge\");\n     }\n \n-    return passes;\n+    passes\n }\n \n pub fn populate_pass_manager(sess: Session, pm: &mut PassManager, pass_list:&[~str]) {\n-    for pass_list.each |&nm| {\n+    for pass_list.iter().advance |&nm| {\n         match create_pass(nm) {\n             Some(p) => pm.add_pass(p),\n             None    => sess.warn(fmt!(\"Unknown pass %s\", nm))\n@@ -172,15 +190,15 @@ pub fn list_passes() {\n     io::println(\"\\nAvailable Passes:\");\n \n     io::println(\"\\nAnalysis Passes:\");\n-    for analysis_passes.each |&(name, desc)| {\n+    for analysis_passes.iter().advance |&(name, desc)| {\n         io::println(fmt!(\"    %-30s -- %s\", name, desc));\n     }\n     io::println(\"\\nTransformation Passes:\");\n-    for transform_passes.each |&(name, desc)| {\n+    for transform_passes.iter().advance |&(name, desc)| {\n         io::println(fmt!(\"    %-30s -- %s\", name, desc));\n     }\n     io::println(\"\\nUtility Passes:\");\n-    for utility_passes.each |&(name, desc)| {\n+    for utility_passes.iter().advance |&(name, desc)| {\n         io::println(fmt!(\"    %-30s -- %s\", name, desc));\n     }\n }\n@@ -298,23 +316,23 @@ static utility_passes : &'static [(&'static str, &'static str)] = &'static [\n fn passes_exist() {\n     let mut failed = ~[];\n     unsafe { llvm::LLVMInitializePasses(); }\n-    for analysis_passes.each() |&(name,_)| {\n+    for analysis_passes.iter().advance |&(name,_)| {\n         let pass = create_pass(name);\n         if !pass.is_some() {\n             failed.push(name);\n         } else {\n             unsafe { llvm::LLVMDestroyPass(pass.get()) }\n         }\n     }\n-    for transform_passes.each() |&(name,_)| {\n+    for transform_passes.iter().advance |&(name,_)| {\n         let pass = create_pass(name);\n         if !pass.is_some() {\n             failed.push(name);\n         } else {\n             unsafe { llvm::LLVMDestroyPass(pass.get()) }\n         }\n     }\n-    for utility_passes.each() |&(name,_)| {\n+    for utility_passes.iter().advance |&(name,_)| {\n         let pass = create_pass(name);\n         if !pass.is_some() {\n             failed.push(name);\n@@ -325,7 +343,7 @@ fn passes_exist() {\n \n     if failed.len() > 0 {\n         io::println(\"Some passes don't exist:\");\n-        for failed.each |&n| {\n+        for failed.iter().advance |&n| {\n             io::println(fmt!(\"    %s\", n));\n         }\n         fail!();"}, {"sha": "19dbb941e556669f76022b301922fadef4d143a0", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,23 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n \n use driver::session;\n use metadata::cstore;\n use metadata::filesearch;\n \n-use core::hashmap::HashSet;\n-use core::os;\n-use core::uint;\n-use core::util;\n-use core::vec;\n+use std::hashmap::HashSet;\n+use std::os;\n+use std::uint;\n+use std::util;\n+use std::vec;\n \n fn not_win32(os: session::os) -> bool {\n-  match os {\n-      session::os_win32 => false,\n-      _ => true\n-  }\n+  os != session::os_win32\n }\n \n pub fn get_rpath_flags(sess: session::Session, out_filename: &Path)\n@@ -56,7 +52,7 @@ fn get_sysroot_absolute_rt_lib(sess: session::Session) -> Path {\n }\n \n pub fn rpaths_to_flags(rpaths: &[Path]) -> ~[~str] {\n-    vec::map(rpaths, |rpath| fmt!(\"-Wl,-rpath,%s\",rpath.to_str()))\n+    rpaths.iter().transform(|rpath| fmt!(\"-Wl,-rpath,%s\",rpath.to_str())).collect()\n }\n \n fn get_rpaths(os: session::os,\n@@ -67,7 +63,7 @@ fn get_rpaths(os: session::os,\n     debug!(\"sysroot: %s\", sysroot.to_str());\n     debug!(\"output: %s\", output.to_str());\n     debug!(\"libs:\");\n-    for libs.each |libpath| {\n+    for libs.iter().advance |libpath| {\n         debug!(\"    %s\", libpath.to_str());\n     }\n     debug!(\"target_triple: %s\", target_triple);\n@@ -86,7 +82,7 @@ fn get_rpaths(os: session::os,\n \n     fn log_rpaths(desc: &str, rpaths: &[Path]) {\n         debug!(\"%s rpaths:\", desc);\n-        for rpaths.each |rpath| {\n+        for rpaths.iter().advance |rpath| {\n             debug!(\"    %s\", rpath.to_str());\n         }\n     }\n@@ -107,22 +103,20 @@ fn get_rpaths(os: session::os,\n fn get_rpaths_relative_to_output(os: session::os,\n                                  output: &Path,\n                                  libs: &[Path]) -> ~[Path] {\n-    vec::map(libs, |a| {\n-        get_rpath_relative_to_output(os, output, a)\n-    })\n+    libs.iter().transform(|a| get_rpath_relative_to_output(os, output, a)).collect()\n }\n \n pub fn get_rpath_relative_to_output(os: session::os,\n                                     output: &Path,\n                                     lib: &Path)\n                                  -> Path {\n-    use core::os;\n+    use std::os;\n \n     assert!(not_win32(os));\n \n     // Mac doesn't appear to support $ORIGIN\n     let prefix = match os {\n-        session::os_android |session::os_linux | session::os_freebsd\n+        session::os_android | session::os_linux | session::os_freebsd\n                           => \"$ORIGIN\",\n         session::os_macos => \"@executable_path\",\n         session::os_win32 => util::unreachable()\n@@ -157,17 +151,17 @@ pub fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n     let mut path = ~[];\n     for uint::range(start_idx, len1 - 1) |_i| { path.push(~\"..\"); };\n \n-    path.push_all(vec::slice(split2, start_idx, len2 - 1));\n+    path.push_all(split2.slice(start_idx, len2 - 1));\n \n-    if !path.is_empty() {\n-        return Path(\"\").push_many(path);\n+    return if !path.is_empty() {\n+        Path(\"\").push_many(path)\n     } else {\n-        return Path(\".\");\n+        Path(\".\")\n     }\n }\n \n fn get_absolute_rpaths(libs: &[Path]) -> ~[Path] {\n-    vec::map(libs, |a| get_absolute_rpath(a) )\n+    libs.iter().transform(|a| get_absolute_rpath(a)).collect()\n }\n \n pub fn get_absolute_rpath(lib: &Path) -> Path {\n@@ -188,7 +182,7 @@ pub fn get_install_prefix_rpath(target_triple: &str) -> Path {\n pub fn minimize_rpaths(rpaths: &[Path]) -> ~[Path] {\n     let mut set = HashSet::new();\n     let mut minimized = ~[];\n-    for rpaths.each |rpath| {\n+    for rpaths.iter().advance |rpath| {\n         if set.insert(rpath.to_str()) {\n             minimized.push(copy *rpath);\n         }\n@@ -198,8 +192,7 @@ pub fn minimize_rpaths(rpaths: &[Path]) -> ~[Path] {\n \n #[cfg(unix, test)]\n mod test {\n-    use core::prelude::*;\n-    use core::os;\n+    use std::os;\n \n     // FIXME(#2119): the outer attribute should be #[cfg(unix, test)], then\n     // these redundant #[cfg(test)] blocks can be removed"}, {"sha": "76bba481619859677b262aeb1626d6d537c8b3c3", "filename": "src/librustc/back/upcall.rs", "status": "modified", "additions": 28, "deletions": 33, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fupcall.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -11,8 +11,8 @@\n \n use driver::session;\n use middle::trans::base;\n-use middle::trans::common::{T_fn, T_i8, T_i32, T_int, T_ptr, T_void};\n-use lib::llvm::{ModuleRef, ValueRef, TypeRef};\n+use middle::trans::type_::Type;\n+use lib::llvm::{ModuleRef, ValueRef};\n \n pub struct Upcalls {\n     trace: ValueRef,\n@@ -22,40 +22,35 @@ pub struct Upcalls {\n     reset_stack_limit: ValueRef\n }\n \n-pub fn declare_upcalls(targ_cfg: @session::config,\n-                       llmod: ModuleRef) -> @Upcalls {\n-    fn decl(llmod: ModuleRef, prefix: ~str, name: ~str,\n-            tys: ~[TypeRef], rv: TypeRef) ->\n-       ValueRef {\n-        let arg_tys = tys.map(|t| *t);\n-        let fn_ty = T_fn(arg_tys, rv);\n-        return base::decl_cdecl_fn(llmod, prefix + name, fn_ty);\n-    }\n-    fn nothrow(f: ValueRef) -> ValueRef {\n-        base::set_no_unwind(f); f\n-    }\n-    let d: &fn(a: ~str, b: ~[TypeRef], c: TypeRef) -> ValueRef =\n-        |a,b,c| decl(llmod, ~\"upcall_\", a, b, c);\n-    let dv: &fn(a: ~str, b: ~[TypeRef]) -> ValueRef =\n-        |a,b| decl(llmod, ~\"upcall_\", a, b, T_void());\n+macro_rules! upcall (\n+    (fn $name:ident($($arg:expr),+) -> $ret:expr) => ({\n+        let fn_ty = Type::func([ $($arg),* ], &$ret);\n+        base::decl_cdecl_fn(llmod, ~\"upcall_\" + stringify!($name), fn_ty)\n+    });\n+    (nothrow fn $name:ident($($arg:expr),+) -> $ret:expr) => ({\n+        let fn_ty = Type::func([ $($arg),* ], &$ret);\n+        let decl = base::decl_cdecl_fn(llmod, ~\"upcall_\" + stringify!($name), fn_ty);\n+        base::set_no_unwind(decl);\n+        decl\n+    });\n+    (nothrow fn $name:ident -> $ret:expr) => ({\n+        let fn_ty = Type::func([], &$ret);\n+        let decl = base::decl_cdecl_fn(llmod, ~\"upcall_\" + stringify!($name), fn_ty);\n+        base::set_no_unwind(decl);\n+        decl\n+    })\n+)\n \n-    let int_t = T_int(targ_cfg);\n+pub fn declare_upcalls(targ_cfg: @session::config, llmod: ModuleRef) -> @Upcalls {\n+    let opaque_ptr = Type::i8().ptr_to();\n+    let int_ty = Type::int(targ_cfg.arch);\n \n     @Upcalls {\n-        trace: dv(~\"trace\", ~[T_ptr(T_i8()),\n-                              T_ptr(T_i8()),\n-                              int_t]),\n-        call_shim_on_c_stack:\n-            d(~\"call_shim_on_c_stack\",\n-              // arguments: void *args, void *fn_ptr\n-              ~[T_ptr(T_i8()), T_ptr(T_i8())],\n-              int_t),\n+        trace: upcall!(fn trace(opaque_ptr, opaque_ptr, int_ty) -> Type::void()),\n+        call_shim_on_c_stack: upcall!(fn call_shim_on_c_stack(opaque_ptr, opaque_ptr) -> int_ty),\n         call_shim_on_rust_stack:\n-            d(~\"call_shim_on_rust_stack\",\n-              ~[T_ptr(T_i8()), T_ptr(T_i8())], int_t),\n-        rust_personality:\n-            nothrow(d(~\"rust_personality\", ~[], T_i32())),\n-        reset_stack_limit:\n-            nothrow(dv(~\"reset_stack_limit\", ~[]))\n+            upcall!(fn call_shim_on_rust_stack(opaque_ptr, opaque_ptr) -> int_ty),\n+        rust_personality: upcall!(nothrow fn rust_personality -> Type::i32()),\n+        reset_stack_limit: upcall!(nothrow fn reset_stack_limit -> Type::void())\n     }\n }"}, {"sha": "a32f54fe7bba46bce5b800896bd5a847f9b63dc9", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 47, "deletions": 33, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n \n use back::link;\n use back::{arm, x86, x86_64, mips};\n@@ -19,16 +18,16 @@ use front;\n use lib::llvm::llvm;\n use metadata::{creader, cstore, filesearch};\n use metadata;\n-use middle::{trans, freevars, kind, ty, typeck, lint, astencode};\n+use middle::{trans, freevars, kind, ty, typeck, lint, astencode, reachable};\n use middle;\n use util::common::time;\n use util::ppaux;\n \n-use core::hashmap::HashMap;\n-use core::int;\n-use core::io;\n-use core::os;\n-use core::vec;\n+use std::hashmap::HashMap;\n+use std::int;\n+use std::io;\n+use std::os;\n+use std::vec;\n use extra::getopts::groups::{optopt, optmulti, optflag, optflagopt};\n use extra::getopts::{opt_present};\n use extra::getopts;\n@@ -161,7 +160,7 @@ pub struct compile_upto {\n #[deriving(Eq)]\n pub enum compile_phase {\n     cu_parse,\n-    cu_expand,\n+    cu_expand, // means \"it's already expanded\"\n     cu_typeck,\n     cu_no_trans,\n     cu_everything,\n@@ -181,34 +180,40 @@ pub fn compile_rest(sess: Session,\n \n     let time_passes = sess.time_passes();\n \n-    let mut crate_opt = curr;\n+    let mut crate = curr.unwrap();\n \n     if phases.from == cu_parse || phases.from == cu_everything {\n \n         *sess.building_library = session::building_library(\n-            sess.opts.crate_type, crate_opt.unwrap(), sess.opts.test);\n-\n-        crate_opt = Some(time(time_passes, ~\"expansion\", ||\n+            sess.opts.crate_type, crate, sess.opts.test);\n+\n+        // strip before expansion to allow macros to depend on\n+        // configuration variables e.g/ in\n+        //\n+        //   #[macro_escape] #[cfg(foo)]\n+        //   mod bar { macro_rules! baz!(() => {{}}) }\n+        //\n+        // baz! should not use this definition unless foo is enabled.\n+        crate = time(time_passes, ~\"configuration 1\", ||\n+                     front::config::strip_unconfigured_items(crate));\n+\n+        crate = time(time_passes, ~\"expansion\", ||\n                      syntax::ext::expand::expand_crate(sess.parse_sess, copy cfg,\n-                                                       crate_opt.unwrap())));\n+                                                       crate));\n \n-        crate_opt = Some(time(time_passes, ~\"configuration\", ||\n-                     front::config::strip_unconfigured_items(crate_opt.unwrap())));\n+        // strip again, in case expansion added anything with a #[cfg].\n+        crate = time(time_passes, ~\"configuration 2\", ||\n+                     front::config::strip_unconfigured_items(crate));\n \n-        crate_opt = Some(time(time_passes, ~\"maybe building test harness\", ||\n-                     front::test::modify_for_testing(sess, crate_opt.unwrap())));\n+        crate = time(time_passes, ~\"maybe building test harness\", ||\n+                     front::test::modify_for_testing(sess, crate));\n     }\n \n-    if phases.to == cu_expand { return (crate_opt, None); }\n+    if phases.to == cu_expand { return (Some(crate), None); }\n \n     assert!(phases.from != cu_no_trans);\n \n-    let mut crate = crate_opt.unwrap();\n-\n     let (llcx, llmod, link_meta) = {\n-    crate = time(time_passes, ~\"intrinsic injection\", ||\n-                 front::intrinsic_inject::inject_intrinsic(sess, crate));\n-\n         crate = time(time_passes, ~\"extra injection\", ||\n                      front::std_inject::maybe_inject_libstd_ref(sess, crate));\n \n@@ -293,10 +298,16 @@ pub fn compile_rest(sess: Session,\n         time(time_passes, ~\"kind checking\", ||\n              kind::check_crate(ty_cx, method_map, crate));\n \n+        let reachable_map =\n+            time(time_passes, ~\"reachability checking\", ||\n+                reachable::find_reachable(ty_cx, method_map, crate));\n+\n         time(time_passes, ~\"lint checking\", ||\n              lint::check_crate(ty_cx, crate));\n \n-        if phases.to == cu_no_trans { return (Some(crate), Some(ty_cx)); }\n+        if phases.to == cu_no_trans {\n+            return (Some(crate), Some(ty_cx));\n+        }\n \n         let maps = astencode::Maps {\n             root_map: root_map,\n@@ -309,9 +320,13 @@ pub fn compile_rest(sess: Session,\n \n         let outputs = outputs.get_ref();\n         time(time_passes, ~\"translation\", ||\n-             trans::base::trans_crate(sess, crate, ty_cx,\n+             trans::base::trans_crate(sess,\n+                                      crate,\n+                                      ty_cx,\n                                       &outputs.obj_filename,\n-                                      exp_map2, maps))\n+                                      exp_map2,\n+                                      reachable_map,\n+                                      maps))\n     };\n \n     let outputs = outputs.get_ref();\n@@ -453,7 +468,7 @@ pub fn pretty_print_input(sess: Session, cfg: ast::crate_cfg, input: &input,\n }\n \n pub fn get_os(triple: &str) -> Option<session::os> {\n-    for os_names.each |&(name, os)| {\n+    for os_names.iter().advance |&(name, os)| {\n         if triple.contains(name) { return Some(os) }\n     }\n     None\n@@ -467,7 +482,7 @@ static os_names : &'static [(&'static str, session::os)] = &'static [\n     (\"freebsd\", session::os_freebsd)];\n \n pub fn get_arch(triple: &str) -> Option<abi::Architecture> {\n-    for architecture_abis.each |&(arch, abi)| {\n+    for architecture_abis.iter().advance |&(arch, abi)| {\n         if triple.contains(arch) { return Some(abi) }\n     }\n     None\n@@ -556,7 +571,7 @@ pub fn build_session_options(binary: @str,\n                        lint::deny, lint::forbid];\n     let mut lint_opts = ~[];\n     let lint_dict = lint::get_lint_dict();\n-    for lint_levels.each |level| {\n+    for lint_levels.iter().advance |level| {\n         let level_name = lint::level_to_str(*level);\n \n         // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n@@ -565,7 +580,7 @@ pub fn build_session_options(binary: @str,\n         let level_short = level_short.to_ascii().to_upper().to_str_ascii();\n         let flags = vec::append(getopts::opt_strs(matches, level_short),\n                                 getopts::opt_strs(matches, level_name));\n-        for flags.each |lint_name| {\n+        for flags.iter().advance |lint_name| {\n             let lint_name = lint_name.replace(\"-\", \"_\");\n             match lint_dict.find_equiv(&lint_name) {\n               None => {\n@@ -582,9 +597,9 @@ pub fn build_session_options(binary: @str,\n     let mut debugging_opts = 0u;\n     let debug_flags = getopts::opt_strs(matches, \"Z\");\n     let debug_map = session::debugging_opts_map();\n-    for debug_flags.each |debug_flag| {\n+    for debug_flags.iter().advance |debug_flag| {\n         let mut this_bit = 0u;\n-        for debug_map.each |tuple| {\n+        for debug_map.iter().advance |tuple| {\n             let (name, bit) = match *tuple { (ref a, _, b) => (a, b) };\n             if name == debug_flag { this_bit = bit; break; }\n         }\n@@ -935,7 +950,6 @@ pub fn list_metadata(sess: Session, path: &Path, out: @io::Writer) {\n \n #[cfg(test)]\n mod test {\n-    use core::prelude::*;\n \n     use driver::driver::{build_configuration, build_session};\n     use driver::driver::{build_session_options, optgroups, str_input};"}, {"sha": "ef0b6d6465132cf9c081c8a7f763fcd3cd5c3e11", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 38, "deletions": 30, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n \n use back::link;\n use back::target_strs;\n@@ -29,7 +28,7 @@ use syntax::abi;\n use syntax::parse::token;\n use syntax;\n \n-use core::hashmap::HashMap;\n+use std::hashmap::HashMap;\n \n #[deriving(Eq)]\n pub enum os { os_win32, os_macos, os_linux, os_android, os_freebsd, }\n@@ -45,32 +44,33 @@ pub struct config {\n     float_type: float_ty\n }\n \n-pub static verbose: uint = 1 << 0;\n-pub static time_passes: uint = 1 << 1;\n-pub static count_llvm_insns: uint = 1 << 2;\n-pub static time_llvm_passes: uint = 1 << 3;\n-pub static trans_stats: uint = 1 << 4;\n-pub static asm_comments: uint = 1 << 5;\n-pub static no_verify: uint = 1 << 6;\n-pub static trace: uint = 1 << 7;\n-pub static coherence: uint = 1 << 8;\n-pub static borrowck_stats: uint = 1 << 9;\n-pub static borrowck_note_pure: uint = 1 << 10;\n-pub static borrowck_note_loan: uint = 1 << 11;\n-pub static no_landing_pads: uint = 1 << 12;\n-pub static debug_llvm: uint = 1 << 13;\n-pub static count_type_sizes: uint = 1 << 14;\n-pub static meta_stats: uint = 1 << 15;\n-pub static no_opt: uint = 1 << 16;\n+pub static verbose:                 uint = 1 <<  0;\n+pub static time_passes:             uint = 1 <<  1;\n+pub static count_llvm_insns:        uint = 1 <<  2;\n+pub static time_llvm_passes:        uint = 1 <<  3;\n+pub static trans_stats:             uint = 1 <<  4;\n+pub static asm_comments:            uint = 1 <<  5;\n+pub static no_verify:               uint = 1 <<  6;\n+pub static trace:                   uint = 1 <<  7;\n+pub static coherence:               uint = 1 <<  8;\n+pub static borrowck_stats:          uint = 1 <<  9;\n+pub static borrowck_note_pure:      uint = 1 << 10;\n+pub static borrowck_note_loan:      uint = 1 << 11;\n+pub static no_landing_pads:         uint = 1 << 12;\n+pub static debug_llvm:              uint = 1 << 13;\n+pub static count_type_sizes:        uint = 1 << 14;\n+pub static meta_stats:              uint = 1 << 15;\n+pub static no_opt:                  uint = 1 << 16;\n pub static no_monomorphic_collapse: uint = 1 << 17;\n-pub static gc: uint = 1 << 18;\n-pub static jit: uint = 1 << 19;\n-pub static debug_info: uint = 1 << 20;\n-pub static extra_debug_info: uint = 1 << 21;\n-pub static statik: uint = 1 << 22;\n-pub static print_link_args: uint = 1 << 23;\n-pub static no_debug_borrows: uint = 1 << 24;\n-pub static lint_llvm : uint = 1 << 25;\n+pub static gc:                      uint = 1 << 18;\n+pub static jit:                     uint = 1 << 19;\n+pub static debug_info:              uint = 1 << 20;\n+pub static extra_debug_info:        uint = 1 << 21;\n+pub static statik:                  uint = 1 << 22;\n+pub static print_link_args:         uint = 1 << 23;\n+pub static no_debug_borrows:        uint = 1 << 24;\n+pub static lint_llvm:               uint = 1 << 25;\n+pub static once_fns:                uint = 1 << 26;\n \n pub fn debugging_opts_map() -> ~[(~str, ~str, uint)] {\n     ~[(~\"verbose\", ~\"in general, enable more debug printouts\", verbose),\n@@ -112,6 +112,9 @@ pub fn debugging_opts_map() -> ~[(~str, ~str, uint)] {\n      (~\"lint-llvm\",\n       ~\"Run the LLVM lint pass on the pre-optimization IR\",\n       lint_llvm),\n+     (~\"once-fns\",\n+      ~\"Allow 'once fn' closures to deinitialize captured variables\",\n+      once_fns),\n     ]\n }\n \n@@ -293,6 +296,7 @@ impl Session_ {\n     pub fn debug_borrows(@self) -> bool {\n         self.opts.optimize == No && !self.debugging_opt(no_debug_borrows)\n     }\n+    pub fn once_fns(@self) -> bool { self.debugging_opt(once_fns) }\n \n     // pointless function, now...\n     pub fn str_of(@self, id: ast::ident) -> @str {\n@@ -349,7 +353,7 @@ pub fn expect<T:Copy>(sess: Session,\n }\n \n pub fn building_library(req_crate_type: crate_type,\n-                        crate: @ast::crate,\n+                        crate: &ast::crate,\n                         testing: bool) -> bool {\n     match req_crate_type {\n       bin_crate => false,\n@@ -403,8 +407,12 @@ mod test {\n \n     fn make_crate(with_bin: bool, with_lib: bool) -> @ast::crate {\n         let mut attrs = ~[];\n-        if with_bin { attrs += [make_crate_type_attr(@\"bin\")]; }\n-        if with_lib { attrs += [make_crate_type_attr(@\"lib\")]; }\n+        if with_bin {\n+            attrs.push(make_crate_type_attr(@\"bin\"));\n+        }\n+        if with_lib {\n+            attrs.push(make_crate_type_attr(@\"lib\"));\n+        }\n         @codemap::respan(codemap::dummy_sp(), ast::crate_ {\n             module: ast::_mod { view_items: ~[], items: ~[] },\n             attrs: attrs,"}, {"sha": "b1d4820f062eb797bd57d4d21c52460f0424c0bd", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n \n-use core::option;\n-use core::vec;\n+use std::option;\n+use std::vec;\n use syntax::{ast, fold, attr};\n \n type in_cfg_pred = @fn(attrs: ~[ast::attribute]) -> bool;\n@@ -24,11 +23,11 @@ struct Context {\n // any items that do not belong in the current configuration\n pub fn strip_unconfigured_items(crate: @ast::crate) -> @ast::crate {\n     do strip_items(crate) |attrs| {\n-        in_cfg(/*bad*/copy crate.node.config, attrs)\n+        in_cfg(crate.node.config, attrs)\n     }\n }\n \n-pub fn strip_items(crate: @ast::crate, in_cfg: in_cfg_pred)\n+pub fn strip_items(crate: &ast::crate, in_cfg: in_cfg_pred)\n     -> @ast::crate {\n \n     let ctxt = @Context { in_cfg: in_cfg };\n@@ -44,8 +43,7 @@ pub fn strip_items(crate: @ast::crate, in_cfg: in_cfg_pred)\n           .. *fold::default_ast_fold()};\n \n     let fold = fold::make_fold(precursor);\n-    let res = @fold.fold_crate(&*crate);\n-    return res;\n+    @fold.fold_crate(crate)\n }\n \n fn filter_item(cx: @Context, item: @ast::item) ->\n@@ -92,7 +90,7 @@ fn fold_foreign_mod(\n     ast::foreign_mod {\n         sort: nm.sort,\n         abis: nm.abis,\n-        view_items: vec::map(filtered_view_items, |x| fld.fold_view_item(*x)),\n+        view_items: filtered_view_items.iter().transform(|x| fld.fold_view_item(*x)).collect(),\n         items: filtered_items\n     }\n }\n@@ -143,7 +141,7 @@ fn fold_block(\n     let filtered_view_items =\n         filtered_view_items.map(|x| fld.fold_view_item(*x));\n     let mut resulting_stmts = ~[];\n-    for filtered_stmts.each |stmt| {\n+    for filtered_stmts.iter().advance |stmt| {\n         match fld.fold_stmt(*stmt) {\n             None => {}\n             Some(stmt) => resulting_stmts.push(stmt),\n@@ -183,12 +181,12 @@ fn trait_method_in_cfg(cx: @Context, meth: &ast::trait_method) -> bool {\n \n // Determine if an item should be translated in the current crate\n // configuration based on the item's attributes\n-fn in_cfg(cfg: ast::crate_cfg, attrs: ~[ast::attribute]) -> bool {\n+fn in_cfg(cfg: &[@ast::meta_item], attrs: &[ast::attribute]) -> bool {\n     metas_in_cfg(cfg, attr::attr_metas(attrs))\n }\n \n-pub fn metas_in_cfg(cfg: ast::crate_cfg,\n-                    metas: ~[@ast::meta_item]) -> bool {\n+pub fn metas_in_cfg(cfg: &[@ast::meta_item],\n+                    metas: &[@ast::meta_item]) -> bool {\n     // The \"cfg\" attributes on the item\n     let cfg_metas = attr::find_meta_items_by_name(metas, \"cfg\");\n \n@@ -197,13 +195,13 @@ pub fn metas_in_cfg(cfg: ast::crate_cfg,\n     // which the item is valid\n     let cfg_metas = vec::filter_map(cfg_metas, |i| attr::get_meta_item_list(i));\n \n-    if cfg_metas.all(|c| c.is_empty()) { return true; }\n+    if cfg_metas.iter().all(|c| c.is_empty()) { return true; }\n \n-    cfg_metas.any(|cfg_meta| {\n-        cfg_meta.all(|cfg_mi| {\n+    cfg_metas.iter().any_(|cfg_meta| {\n+        cfg_meta.iter().all(|cfg_mi| {\n             match cfg_mi.node {\n                 ast::meta_list(s, ref it) if \"not\" == s\n-                    => it.all(|mi| !attr::contains(cfg, *mi)),\n+                    => it.iter().all(|mi| !attr::contains(cfg, *mi)),\n                 _ => attr::contains(cfg, *cfg_mi)\n             }\n         })"}, {"sha": "fcb08180a5ea27565ff9f3a854c9981c8df6d866", "filename": "src/librustc/front/intrinsic.rs", "status": "removed", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/b60cf0c5b0cf36625083c2624df9fb35d0af3578/src%2Flibrustc%2Ffront%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b60cf0c5b0cf36625083c2624df9fb35d0af3578/src%2Flibrustc%2Ffront%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fintrinsic.rs?ref=b60cf0c5b0cf36625083c2624df9fb35d0af3578", "patch": "@@ -1,140 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// NB: this file is include_str!'ed into the compiler, re-parsed\n-// and injected into each crate the compiler builds. Keep it small.\n-\n-pub mod intrinsic {\n-    #[allow(missing_doc)];\n-\n-    pub use intrinsic::rusti::visit_tydesc;\n-\n-    // FIXME (#3727): remove this when the interface has settled and the\n-    // version in sys is no longer present.\n-    pub fn get_tydesc<T>() -> *TyDesc {\n-        unsafe {\n-            rusti::get_tydesc::<T>() as *TyDesc\n-        }\n-    }\n-\n-    pub struct TyDesc {\n-        size: uint,\n-        align: uint\n-        // Remaining fields not listed\n-    }\n-\n-    pub enum Opaque { }\n-\n-    pub trait TyVisitor {\n-        fn visit_bot(&self) -> bool;\n-        fn visit_nil(&self) -> bool;\n-        fn visit_bool(&self) -> bool;\n-\n-        fn visit_int(&self) -> bool;\n-        fn visit_i8(&self) -> bool;\n-        fn visit_i16(&self) -> bool;\n-        fn visit_i32(&self) -> bool;\n-        fn visit_i64(&self) -> bool;\n-\n-        fn visit_uint(&self) -> bool;\n-        fn visit_u8(&self) -> bool;\n-        fn visit_u16(&self) -> bool;\n-        fn visit_u32(&self) -> bool;\n-        fn visit_u64(&self) -> bool;\n-\n-        fn visit_float(&self) -> bool;\n-        fn visit_f32(&self) -> bool;\n-        fn visit_f64(&self) -> bool;\n-\n-        fn visit_char(&self) -> bool;\n-        fn visit_str(&self) -> bool;\n-\n-        fn visit_estr_box(&self) -> bool;\n-        fn visit_estr_uniq(&self) -> bool;\n-        fn visit_estr_slice(&self) -> bool;\n-        fn visit_estr_fixed(&self, n: uint, sz: uint, align: uint) -> bool;\n-\n-        fn visit_box(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_ptr(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_rptr(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-\n-        fn visit_vec(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_unboxed_vec(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_evec_box(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_evec_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_evec_slice(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_evec_fixed(&self, n: uint, sz: uint, align: uint,\n-                            mtbl: uint, inner: *TyDesc) -> bool;\n-\n-        fn visit_enter_rec(&self, n_fields: uint,\n-                           sz: uint, align: uint) -> bool;\n-        fn visit_rec_field(&self, i: uint, name: &str,\n-                           mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_leave_rec(&self, n_fields: uint,\n-                           sz: uint, align: uint) -> bool;\n-\n-        fn visit_enter_class(&self, n_fields: uint,\n-                             sz: uint, align: uint) -> bool;\n-        fn visit_class_field(&self, i: uint, name: &str,\n-                             mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_leave_class(&self, n_fields: uint,\n-                             sz: uint, align: uint) -> bool;\n-\n-        fn visit_enter_tup(&self, n_fields: uint,\n-                           sz: uint, align: uint) -> bool;\n-        fn visit_tup_field(&self, i: uint, inner: *TyDesc) -> bool;\n-        fn visit_leave_tup(&self, n_fields: uint,\n-                           sz: uint, align: uint) -> bool;\n-\n-        fn visit_enter_enum(&self, n_variants: uint,\n-                            get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n-                            sz: uint, align: uint) -> bool;\n-        fn visit_enter_enum_variant(&self, variant: uint,\n-                                    disr_val: int,\n-                                    n_fields: uint,\n-                                    name: &str) -> bool;\n-        fn visit_enum_variant_field(&self, i: uint, offset: uint, inner: *TyDesc) -> bool;\n-        fn visit_leave_enum_variant(&self, variant: uint,\n-                                    disr_val: int,\n-                                    n_fields: uint,\n-                                    name: &str) -> bool;\n-        fn visit_leave_enum(&self, n_variants: uint,\n-                            get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n-                            sz: uint, align: uint) -> bool;\n-\n-        fn visit_enter_fn(&self, purity: uint, proto: uint,\n-                          n_inputs: uint, retstyle: uint) -> bool;\n-        fn visit_fn_input(&self, i: uint, mode: uint, inner: *TyDesc) -> bool;\n-        fn visit_fn_output(&self, retstyle: uint, inner: *TyDesc) -> bool;\n-        fn visit_leave_fn(&self, purity: uint, proto: uint,\n-                          n_inputs: uint, retstyle: uint) -> bool;\n-\n-        fn visit_trait(&self) -> bool;\n-        fn visit_var(&self) -> bool;\n-        fn visit_var_integral(&self) -> bool;\n-        fn visit_param(&self, i: uint) -> bool;\n-        fn visit_self(&self) -> bool;\n-        fn visit_type(&self) -> bool;\n-        fn visit_opaque_box(&self) -> bool;\n-        fn visit_constr(&self, inner: *TyDesc) -> bool;\n-        fn visit_closure_ptr(&self, ck: uint) -> bool;\n-    }\n-\n-    pub mod rusti {\n-        use super::{TyDesc, TyVisitor};\n-\n-        #[abi = \"rust-intrinsic\"]\n-        pub extern \"rust-intrinsic\" {\n-            pub fn get_tydesc<T>() -> *();\n-            pub fn visit_tydesc(td: *TyDesc, tv: @TyVisitor);\n-        }\n-    }\n-}"}, {"sha": "0caadc8572e90cf545744b9e2af78d3cdcacd173", "filename": "src/librustc/front/intrinsic_inject.rs", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b60cf0c5b0cf36625083c2624df9fb35d0af3578/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b60cf0c5b0cf36625083c2624df9fb35d0af3578/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs?ref=b60cf0c5b0cf36625083c2624df9fb35d0af3578", "patch": "@@ -1,47 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use core::prelude::*;\n-\n-use core::vec;\n-use driver::session::Session;\n-use syntax::parse;\n-use syntax::ast;\n-use syntax::codemap::spanned;\n-\n-pub fn inject_intrinsic(sess: Session, crate: @ast::crate) -> @ast::crate {\n-    let intrinsic_module = include_str!(\"intrinsic.rs\").to_managed();\n-\n-    let item = parse::parse_item_from_source_str(@\"<intrinsic>\",\n-                                                 intrinsic_module,\n-                                                 /*bad*/copy sess.opts.cfg,\n-                                                 ~[],\n-                                                 sess.parse_sess);\n-    let item =\n-        match item {\n-          Some(i) => i,\n-          None => {\n-            sess.fatal(\"no item found in intrinsic module\");\n-          }\n-        };\n-\n-    let items = vec::append(~[item], crate.node.module.items);\n-\n-    @spanned {\n-        node: ast::crate_ {\n-            module: ast::_mod {\n-                items: items,\n-                .. /*bad*/copy crate.node.module\n-            },\n-            .. /*bad*/copy crate.node\n-        },\n-        .. /*bad*/copy *crate\n-    }\n-}"}, {"sha": "735fe54f3480f4b1c3f8d8b7fdcf235b3111cc2c", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -8,18 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n \n use driver::session::Session;\n \n-use core::vec;\n+use std::vec;\n use syntax::ast;\n use syntax::attr;\n use syntax::codemap::dummy_sp;\n use syntax::codemap;\n use syntax::fold;\n \n-static STD_VERSION: &'static str = \"0.7-pre\";\n+static STD_VERSION: &'static str = \"0.7\";\n \n pub fn maybe_inject_libstd_ref(sess: Session, crate: @ast::crate)\n                                -> @ast::crate {\n@@ -30,11 +29,11 @@ pub fn maybe_inject_libstd_ref(sess: Session, crate: @ast::crate)\n     }\n }\n \n-fn use_std(crate: @ast::crate) -> bool {\n+fn use_std(crate: &ast::crate) -> bool {\n     !attr::attrs_contains_name(crate.node.attrs, \"no_std\")\n }\n \n-fn inject_libstd_ref(sess: Session, crate: @ast::crate) -> @ast::crate {\n+fn inject_libstd_ref(sess: Session, crate: &ast::crate) -> @ast::crate {\n     fn spanned<T:Copy>(x: T) -> codemap::spanned<T> {\n         codemap::spanned { node: x, span: dummy_sp() }\n     }"}, {"sha": "41c70c4c5b417a4f636eaee58c68e48781f9658d", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -10,12 +10,11 @@\n \n // Code that generates a test runner to run all the tests in a crate\n \n-use core::prelude::*;\n \n use driver::session;\n use front::config;\n \n-use core::vec;\n+use std::vec;\n use syntax::ast_util::*;\n use syntax::attr;\n use syntax::codemap::{dummy_sp, span, ExpandedFrom, CallInfo, NameAndSpan};\n@@ -92,7 +91,7 @@ fn generate_test_harness(sess: session::Session,\n     return res;\n }\n \n-fn strip_test_functions(crate: @ast::crate) -> @ast::crate {\n+fn strip_test_functions(crate: &ast::crate) -> @ast::crate {\n     // When not compiling with --test we should not compile the\n     // #[test] functions\n     do config::strip_items(crate) |attrs| {\n@@ -118,7 +117,7 @@ fn fold_mod(cx: @mut TestCtxt,\n \n     let mod_nomain = ast::_mod {\n         view_items: /*bad*/copy m.view_items,\n-        items: vec::map(m.items, |i| nomain(cx, *i)),\n+        items: m.items.iter().transform(|i| nomain(cx, *i)).collect(),\n     };\n \n     fold::noop_fold_mod(&mod_nomain, fld)\n@@ -272,7 +271,7 @@ mod __test {\n */\n \n fn mk_std(cx: &TestCtxt) -> @ast::view_item {\n-    let vers = ast::lit_str(@\"0.7-pre\");\n+    let vers = ast::lit_str(@\"0.7\");\n     let vers = nospan(vers);\n     let mi = ast::meta_name_value(@\"vers\", vers);\n     let mi = nospan(mi);\n@@ -386,7 +385,7 @@ fn is_std(cx: &TestCtxt) -> bool {\n fn mk_test_descs(cx: &TestCtxt) -> @ast::expr {\n     debug!(\"building test vector from %u tests\", cx.testfns.len());\n     let mut descs = ~[];\n-    for cx.testfns.each |test| {\n+    for cx.testfns.iter().advance |test| {\n         descs.push(mk_test_desc_and_fn_rec(cx, test));\n     }\n "}, {"sha": "8ca8c12f412211b0129231b96d6a7c2f5f787a53", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 87, "deletions": 142, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -8,14 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n \n-use core::hashmap::HashMap;\n-use core::libc::{c_uint, c_ushort};\n-use core::option;\n-use core::ptr;\n-use core::str;\n-use core::vec;\n+use std::hashmap::HashMap;\n+use std::libc::{c_uint, c_ushort};\n+use std::option;\n+use std::str;\n+\n+use middle::trans::type_::Type;\n \n pub type Opcode = u32;\n pub type Bool = c_uint;\n@@ -268,7 +267,7 @@ pub mod llvm {\n     use super::{SectionIteratorRef, TargetDataRef, TypeKind, TypeRef, UseRef};\n     use super::{ValueRef, PassRef};\n     use super::debuginfo::*;\n-    use core::libc::{c_char, c_int, c_longlong, c_ushort, c_uint, c_ulonglong};\n+    use std::libc::{c_char, c_int, c_longlong, c_ushort, c_uint, c_ulonglong};\n \n     #[link_args = \"-Lrustllvm -lrustllvm\"]\n     #[link_name = \"rustllvm\"]\n@@ -2121,155 +2120,101 @@ pub fn ConstFCmp(Pred: RealPredicate, V1: ValueRef, V2: ValueRef) -> ValueRef {\n /* Memory-managed object interface to type handles. */\n \n pub struct TypeNames {\n-    type_names: @mut HashMap<TypeRef, @str>,\n-    named_types: @mut HashMap<@str, TypeRef>\n-}\n-\n-pub fn associate_type(tn: @TypeNames, s: @str, t: TypeRef) {\n-    assert!(tn.type_names.insert(t, s));\n-    assert!(tn.named_types.insert(s, t));\n-}\n-\n-pub fn type_has_name(tn: @TypeNames, t: TypeRef) -> Option<@str> {\n-    return tn.type_names.find(&t).map_consume(|x| *x);\n-}\n-\n-pub fn name_has_type(tn: @TypeNames, s: @str) -> Option<TypeRef> {\n-    return tn.named_types.find(&s).map_consume(|x| *x);\n+    type_names: HashMap<TypeRef, ~str>,\n+    named_types: HashMap<~str, TypeRef>\n }\n \n-pub fn mk_type_names() -> @TypeNames {\n-    @TypeNames {\n-        type_names: @mut HashMap::new(),\n-        named_types: @mut HashMap::new()\n+impl TypeNames {\n+    pub fn new() -> TypeNames {\n+        TypeNames {\n+            type_names: HashMap::new(),\n+            named_types: HashMap::new()\n+        }\n     }\n-}\n \n-pub fn type_to_str(names: @TypeNames, ty: TypeRef) -> @str {\n-    return type_to_str_inner(names, [], ty);\n-}\n+    pub fn associate_type(&mut self, s: &str, t: &Type) {\n+        assert!(self.type_names.insert(t.to_ref(), s.to_owned()));\n+        assert!(self.named_types.insert(s.to_owned(), t.to_ref()));\n+    }\n \n-pub fn type_to_str_inner(names: @TypeNames, outer0: &[TypeRef], ty: TypeRef)\n-                      -> @str {\n-    unsafe {\n-        match type_has_name(names, ty) {\n-          option::Some(n) => return n,\n-          _ => {}\n+    pub fn find_name<'r>(&'r self, ty: &Type) -> Option<&'r str> {\n+        match self.type_names.find(&ty.to_ref()) {\n+            Some(a) => Some(a.slice(0, a.len())),\n+            None => None\n         }\n+    }\n \n-        let outer = vec::append_one(outer0.to_vec(), ty);\n+    pub fn find_type(&self, s: &str) -> Option<Type> {\n+        self.named_types.find_equiv(&s).map_consume(|x| Type::from_ref(*x))\n+    }\n \n-        let kind = llvm::LLVMGetTypeKind(ty);\n+    // We have a depth count, because we seem to make infinite types.\n+    pub fn type_to_str_depth(&self, ty: Type, depth: int) -> ~str {\n+        match self.find_name(&ty) {\n+            option::Some(name) => return name.to_owned(),\n+            None => ()\n+        }\n \n-        fn tys_str(names: @TypeNames, outer: &[TypeRef],\n-                   tys: ~[TypeRef]) -> @str {\n-            let mut s = ~\"\";\n-            let mut first: bool = true;\n-            for tys.each |t| {\n-                if first { first = false; } else { s += \", \"; }\n-                s += type_to_str_inner(names, outer, *t);\n-            }\n-            // [Note at-str] FIXME #2543: Could rewrite this without the copy,\n-            // but need better @str support.\n-            return s.to_managed();\n+        if depth == 0 {\n+            return ~\"###\";\n         }\n \n-        match kind {\n-          Void => return @\"Void\",\n-          Half => return @\"Half\",\n-          Float => return @\"Float\",\n-          Double => return @\"Double\",\n-          X86_FP80 => return @\"X86_FP80\",\n-          FP128 => return @\"FP128\",\n-          PPC_FP128 => return @\"PPC_FP128\",\n-          Label => return @\"Label\",\n-          Integer => {\n-            // See [Note at-str]\n-            return fmt!(\"i%d\", llvm::LLVMGetIntTypeWidth(ty)\n-                        as int).to_managed();\n-          }\n-          Function => {\n-            let out_ty: TypeRef = llvm::LLVMGetReturnType(ty);\n-            let n_args = llvm::LLVMCountParamTypes(ty) as uint;\n-            let args = vec::from_elem(n_args, 0 as TypeRef);\n-            llvm::LLVMGetParamTypes(ty, vec::raw::to_ptr(args));\n-            // See [Note at-str]\n-            return fmt!(\"fn(%s) -> %s\",\n-                        tys_str(names, outer, args),\n-                        type_to_str_inner(names, outer, out_ty)).to_managed();\n-          }\n-          Struct => {\n-            let elts = struct_tys(ty);\n-            // See [Note at-str]\n-            return fmt!(\"{%s}\", tys_str(names, outer, elts)).to_managed();\n-          }\n-          Array => {\n-            let el_ty = llvm::LLVMGetElementType(ty);\n-            // See [Note at-str]\n-            return fmt!(\"[%s@ x %u\", type_to_str_inner(names, outer, el_ty),\n-                llvm::LLVMGetArrayLength(ty) as uint).to_managed();\n-          }\n-          Pointer => {\n-            let mut i = 0;\n-            for outer0.each |tout| {\n-                i += 1;\n-                if *tout as int == ty as int {\n-                    let n = outer0.len() - i;\n-                    // See [Note at-str]\n-                    return fmt!(\"*\\\\%d\", n as int).to_managed();\n+        unsafe {\n+            let kind = ty.kind();\n+\n+            match kind {\n+                Void => ~\"Void\",\n+                Half => ~\"Half\",\n+                Float => ~\"Float\",\n+                Double => ~\"Double\",\n+                X86_FP80 => ~\"X86_FP80\",\n+                FP128 => ~\"FP128\",\n+                PPC_FP128 => ~\"PPC_FP128\",\n+                Label => ~\"Label\",\n+                Vector => ~\"Vector\",\n+                Metadata => ~\"Metadata\",\n+                X86_MMX => ~\"X86_MMAX\",\n+                Integer => {\n+                    fmt!(\"i%d\", llvm::LLVMGetIntTypeWidth(ty.to_ref()) as int)\n                 }\n-            }\n-            let addrstr = {\n-                let addrspace = llvm::LLVMGetPointerAddressSpace(ty) as uint;\n-                if addrspace == 0 {\n-                    ~\"\"\n-                } else {\n-                    fmt!(\"addrspace(%u)\", addrspace)\n+                Function => {\n+                    let out_ty = ty.return_type();\n+                    let args = ty.func_params();\n+                    let args =\n+                        args.map(|&ty| self.type_to_str_depth(ty, depth-1)).connect(\", \");\n+                    let out_ty = self.type_to_str_depth(out_ty, depth-1);\n+                    fmt!(\"fn(%s) -> %s\", args, out_ty)\n+                }\n+                Struct => {\n+                    let tys = ty.field_types();\n+                    let tys = tys.map(|&ty| self.type_to_str_depth(ty, depth-1)).connect(\", \");\n+                    fmt!(\"{%s}\", tys)\n+                }\n+                Array => {\n+                    let el_ty = ty.element_type();\n+                    let el_ty = self.type_to_str_depth(el_ty, depth-1);\n+                    let len = ty.array_length();\n+                    fmt!(\"[%s x %u]\", el_ty, len)\n                 }\n-            };\n-            // See [Note at-str]\n-            return fmt!(\"%s*%s\", addrstr, type_to_str_inner(names,\n-                        outer,\n-                        llvm::LLVMGetElementType(ty))).to_managed();\n-          }\n-          Vector => return @\"Vector\",\n-          Metadata => return @\"Metadata\",\n-          X86_MMX => return @\"X86_MMAX\",\n-          _ => fail!()\n+                Pointer => {\n+                    let el_ty = ty.element_type();\n+                    let el_ty = self.type_to_str_depth(el_ty, depth-1);\n+                    fmt!(\"*%s\", el_ty)\n+                }\n+                _ => fail!(\"Unknown Type Kind (%u)\", kind as uint)\n+            }\n         }\n     }\n-}\n \n-pub fn float_width(llt: TypeRef) -> uint {\n-    unsafe {\n-        return match llvm::LLVMGetTypeKind(llt) as int {\n-              1 => 32u,\n-              2 => 64u,\n-              3 => 80u,\n-              4 | 5 => 128u,\n-              _ => fail!(\"llvm_float_width called on a non-float type\")\n-            };\n+    pub fn type_to_str(&self, ty: Type) -> ~str {\n+        self.type_to_str_depth(ty, 30)\n     }\n-}\n \n-pub fn fn_ty_param_tys(fn_ty: TypeRef) -> ~[TypeRef] {\n-    unsafe {\n-        let args = vec::from_elem(llvm::LLVMCountParamTypes(fn_ty) as uint,\n-                                 0 as TypeRef);\n-        llvm::LLVMGetParamTypes(fn_ty, vec::raw::to_ptr(args));\n-        return args;\n-    }\n-}\n-\n-pub fn struct_tys(struct_ty: TypeRef) -> ~[TypeRef] {\n-    unsafe {\n-        let n_elts = llvm::LLVMCountStructElementTypes(struct_ty) as uint;\n-        if n_elts == 0 {\n-            return ~[];\n+    pub fn val_to_str(&self, val: ValueRef) -> ~str {\n+        unsafe {\n+            let ty = Type::from_ref(llvm::LLVMTypeOf(val));\n+            self.type_to_str(ty)\n         }\n-        let mut elts = vec::from_elem(n_elts, ptr::null());\n-        llvm::LLVMGetStructElementTypes(struct_ty, &mut elts[0]);\n-        return elts;\n     }\n }\n \n@@ -2281,7 +2226,7 @@ pub struct target_data_res {\n }\n \n impl Drop for target_data_res {\n-    fn finalize(&self) {\n+    fn drop(&self) {\n         unsafe {\n             llvm::LLVMDisposeTargetData(self.TD);\n         }\n@@ -2318,7 +2263,7 @@ pub struct pass_manager_res {\n }\n \n impl Drop for pass_manager_res {\n-    fn finalize(&self) {\n+    fn drop(&self) {\n         unsafe {\n             llvm::LLVMDisposePassManager(self.PM);\n         }\n@@ -2354,7 +2299,7 @@ pub struct object_file_res {\n }\n \n impl Drop for object_file_res {\n-    fn finalize(&self) {\n+    fn drop(&self) {\n         unsafe {\n             llvm::LLVMDisposeObjectFile(self.ObjectFile);\n         }\n@@ -2391,7 +2336,7 @@ pub struct section_iter_res {\n }\n \n impl Drop for section_iter_res {\n-    fn finalize(&self) {\n+    fn drop(&self) {\n         unsafe {\n             llvm::LLVMDisposeSectionIterator(self.SI);\n         }"}, {"sha": "ddd07c2cb27234092f088a616c3b49d3680f803e", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-\n+use std::cast;\n \n // EBML enum definitions and utils shared by the encoder and decoder\n \n@@ -111,6 +111,7 @@ pub static tag_items_data_item_reexport_def_id: uint = 0x4e;\n pub static tag_items_data_item_reexport_name: uint = 0x4f;\n \n // used to encode crate_ctxt side tables\n+#[deriving(Eq)]\n pub enum astencode_tag { // Reserves 0x50 -- 0x6f\n     tag_ast = 0x50,\n \n@@ -136,6 +137,16 @@ pub enum astencode_tag { // Reserves 0x50 -- 0x6f\n     tag_table_moves_map = 0x63,\n     tag_table_capture_map = 0x64\n }\n+static first_astencode_tag : uint = tag_ast as uint;\n+static last_astencode_tag : uint = tag_table_capture_map as uint;\n+impl astencode_tag {\n+    pub fn from_uint(value : uint) -> Option<astencode_tag> {\n+        let is_a_tag = first_astencode_tag <= value && value <= last_astencode_tag;\n+        if !is_a_tag { None } else {\n+            Some(unsafe { cast::transmute(value as int) })\n+        }\n+    }\n+}\n \n pub static tag_item_trait_method_sort: uint = 0x70;\n \n@@ -164,6 +175,10 @@ pub static tag_item_method_tps: uint = 0x7b;\n pub static tag_item_method_fty: uint = 0x7c;\n pub static tag_item_method_transformed_self_ty: uint = 0x7d;\n \n+pub static tag_mod_child: uint = 0x7e;\n+pub static tag_misc_info: uint = 0x7f;\n+pub static tag_misc_info_crate_items: uint = 0x80;\n+\n pub struct LinkMeta {\n     name: @str,\n     vers: @str,"}, {"sha": "2a712b07564771bfb6a7e442be1e09082db0f0fe", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 32, "deletions": 36, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -10,15 +10,13 @@\n \n //! Validates all used crates and extern libraries and loads their metadata\n \n-use core::prelude::*;\n \n use metadata::cstore;\n use metadata::decoder;\n use metadata::filesearch::FileSearch;\n use metadata::loader;\n \n-use core::hashmap::HashMap;\n-use core::vec;\n+use std::hashmap::HashMap;\n use syntax::attr;\n use syntax::codemap::{span, dummy_sp};\n use syntax::diagnostic::span_handler;\n@@ -30,7 +28,7 @@ use syntax::ast;\n // Traverses an AST, reading all the information about use'd crates and extern\n // libraries necessary for later resolving, typechecking, linking, etc.\n pub fn read_crates(diag: @span_handler,\n-                   crate: @ast::crate,\n+                   crate: &ast::crate,\n                    cstore: @mut cstore::CStore,\n                    filesearch: @FileSearch,\n                    os: loader::os,\n@@ -53,8 +51,8 @@ pub fn read_crates(diag: @span_handler,\n             .. *visit::default_simple_visitor()});\n     visit_crate(e, crate);\n     visit::visit_crate(crate, ((), v));\n-    dump_crates(e.crate_cache);\n-    warn_if_multiple_versions(e, diag, e.crate_cache);\n+    dump_crates(*e.crate_cache);\n+    warn_if_multiple_versions(e, diag, *e.crate_cache);\n }\n \n struct cache_entry {\n@@ -64,9 +62,9 @@ struct cache_entry {\n     metas: @~[@ast::meta_item]\n }\n \n-fn dump_crates(crate_cache: @mut ~[cache_entry]) {\n+fn dump_crates(crate_cache: &[cache_entry]) {\n     debug!(\"resolved crates:\");\n-    for crate_cache.each |entry| {\n+    for crate_cache.iter().advance |entry| {\n         debug!(\"cnum: %?\", entry.cnum);\n         debug!(\"span: %?\", entry.span);\n         debug!(\"hash: %?\", entry.hash);\n@@ -75,33 +73,31 @@ fn dump_crates(crate_cache: @mut ~[cache_entry]) {\n \n fn warn_if_multiple_versions(e: @mut Env,\n                              diag: @span_handler,\n-                             crate_cache: @mut ~[cache_entry]) {\n-    use core::either::*;\n-\n-    let crate_cache = &mut *crate_cache;\n+                             crate_cache: &[cache_entry]) {\n+    use std::either::*;\n \n     if crate_cache.len() != 0u {\n         let name = loader::crate_name_from_metas(\n             *crate_cache[crate_cache.len() - 1].metas\n         );\n \n-        let (matches, non_matches) =\n-            partition(crate_cache.map_to_vec(|&entry| {\n-                let othername = loader::crate_name_from_metas(\n-                    copy *entry.metas);\n-                if name == othername {\n-                    Left(entry)\n-                } else {\n-                    Right(entry)\n-                }\n-            }));\n+        let vec: ~[Either<cache_entry, cache_entry>] = crate_cache.iter().transform(|&entry| {\n+            let othername = loader::crate_name_from_metas(\n+                copy *entry.metas);\n+            if name == othername {\n+                Left(entry)\n+            } else {\n+                Right(entry)\n+            }\n+        }).collect();\n+        let (matches, non_matches) = partition(vec);\n \n         assert!(!matches.is_empty());\n \n         if matches.len() != 1u {\n             diag.handler().warn(\n                 fmt!(\"using multiple versions of crate `%s`\", name));\n-            for matches.each |match_| {\n+            for matches.iter().advance |match_| {\n                 diag.span_note(match_.span, \"used here\");\n                 let attrs = ~[\n                     attr::mk_attr(attr::mk_list_item(\n@@ -111,7 +107,7 @@ fn warn_if_multiple_versions(e: @mut Env,\n             }\n         }\n \n-        warn_if_multiple_versions(e, diag, @mut non_matches);\n+        warn_if_multiple_versions(e, diag, non_matches);\n     }\n }\n \n@@ -126,11 +122,11 @@ struct Env {\n     intr: @ident_interner\n }\n \n-fn visit_crate(e: @mut Env, c: &ast::crate) {\n+fn visit_crate(e: &Env, c: &ast::crate) {\n     let cstore = e.cstore;\n     let link_args = attr::find_attrs_by_name(c.node.attrs, \"link_args\");\n \n-    for link_args.each |a| {\n+    for link_args.iter().advance |a| {\n         match attr::get_meta_item_value_str(attr::attr_meta(*a)) {\n           Some(ref linkarg) => {\n             cstore::add_used_link_args(cstore, *linkarg);\n@@ -152,7 +148,7 @@ fn visit_view_item(e: @mut Env, i: @ast::view_item) {\n     }\n }\n \n-fn visit_item(e: @mut Env, i: @ast::item) {\n+fn visit_item(e: &Env, i: @ast::item) {\n     match i.node {\n       ast::item_foreign_mod(ref fm) => {\n         if fm.abis.is_rust() || fm.abis.is_intrinsic() {\n@@ -191,7 +187,7 @@ fn visit_item(e: @mut Env, i: @ast::item) {\n             ast::anonymous => { /* do nothing */ }\n         }\n \n-        for link_args.each |a| {\n+        for link_args.iter().advance |a| {\n             match attr::get_meta_item_value_str(attr::attr_meta(*a)) {\n                 Some(linkarg) => {\n                     cstore::add_used_link_args(cstore, linkarg);\n@@ -204,26 +200,25 @@ fn visit_item(e: @mut Env, i: @ast::item) {\n     }\n }\n \n-fn metas_with(ident: @str, key: @str, metas: ~[@ast::meta_item])\n+fn metas_with(ident: @str, key: @str, mut metas: ~[@ast::meta_item])\n     -> ~[@ast::meta_item] {\n     let name_items = attr::find_meta_items_by_name(metas, key);\n     if name_items.is_empty() {\n-        vec::append_one(metas, attr::mk_name_value_item_str(key, ident))\n-    } else {\n-        metas\n+        metas.push(attr::mk_name_value_item_str(key, ident));\n     }\n+    metas\n }\n \n fn metas_with_ident(ident: @str, metas: ~[@ast::meta_item])\n     -> ~[@ast::meta_item] {\n     metas_with(ident, @\"name\", metas)\n }\n \n-fn existing_match(e: @mut Env, metas: &[@ast::meta_item], hash: @str)\n+fn existing_match(e: &Env, metas: &[@ast::meta_item], hash: &str)\n                -> Option<int> {\n-    for e.crate_cache.each |c| {\n+    for e.crate_cache.iter().advance |c| {\n         if loader::metadata_matches(*c.metas, metas)\n-            && (hash.is_empty() || c.hash == hash) {\n+            && (hash.is_empty() || c.hash.as_slice() == hash) {\n             return Some(c.cnum);\n         }\n     }\n@@ -303,7 +298,8 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers\n     let mut cnum_map = HashMap::new();\n-    for decoder::get_crate_deps(cdata).each |dep| {\n+    let r = decoder::get_crate_deps(cdata);\n+    for r.iter().advance |dep| {\n         let extrn_cnum = dep.cnum;\n         let cname = dep.name;\n         let cname_str = token::ident_to_str(&dep.name);"}, {"sha": "f336b0f4e4c5e85e242b9dc7db3ac08726637fc6", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -10,25 +10,19 @@\n \n // Searching for information from the cstore\n \n-use core::prelude::*;\n \n use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n use metadata;\n use middle::{ty, resolve};\n \n-use core::vec;\n+use std::vec;\n use reader = extra::ebml::reader;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::diagnostic::expect;\n \n-pub struct ProvidedTraitMethodInfo {\n-    ty: ty::Method,\n-    def_id: ast::def_id\n-}\n-\n pub struct StaticMethodInfo {\n     ident: ast::ident,\n     def_id: ast::def_id,\n@@ -102,18 +96,14 @@ pub fn get_enum_variants(tcx: ty::ctxt, def: ast::def_id)\n     return decoder::get_enum_variants(cstore.intr, cdata, def.node, tcx)\n }\n \n-pub fn get_impls_for_mod(cstore: @mut cstore::CStore, def: ast::def_id,\n-                         name: Option<ast::ident>)\n-                      -> @~[@resolve::Impl] {\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n-    do decoder::get_impls_for_mod(cstore.intr, cdata, def.node, name) |cnum| {\n-        cstore::get_crate_data(cstore, cnum)\n-    }\n+/// Returns information about the given implementation.\n+pub fn get_impl(cstore: @mut cstore::CStore, impl_def_id: ast::def_id)\n+                -> resolve::Impl {\n+    let cdata = cstore::get_crate_data(cstore, impl_def_id.crate);\n+    decoder::get_impl(cstore.intr, cdata, impl_def_id.node)\n }\n \n-pub fn get_method(tcx: ty::ctxt,\n-                  def: ast::def_id) -> ty::Method\n-{\n+pub fn get_method(tcx: ty::ctxt, def: ast::def_id) -> ty::Method {\n     let cdata = cstore::get_crate_data(tcx.cstore, def.crate);\n     decoder::get_method(tcx.cstore.intr, cdata, def.node, tcx)\n }\n@@ -134,7 +124,7 @@ pub fn get_trait_method_def_ids(cstore: @mut cstore::CStore,\n \n pub fn get_provided_trait_methods(tcx: ty::ctxt,\n                                   def: ast::def_id)\n-                               -> ~[ProvidedTraitMethodInfo] {\n+                               -> ~[@ty::Method] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_provided_trait_methods(cstore.intr, cdata, def.node, tcx)\n@@ -229,7 +219,7 @@ pub fn get_impl_trait(tcx: ty::ctxt,\n pub fn get_impl_method(cstore: @mut cstore::CStore,\n                        def: ast::def_id,\n                        mname: ast::ident)\n-                    -> ast::def_id {\n+                    -> Option<ast::def_id> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_impl_method(cstore.intr, cdata, def.node, mname)\n }"}, {"sha": "3413cd341ba42f6eb94bd534a82191df62d5c056", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -12,13 +12,11 @@\n // The crate store - a central repo for information collected about external\n // crates and libraries\n \n-use core::prelude::*;\n \n use metadata::cstore;\n use metadata::decoder;\n \n-use core::hashmap::HashMap;\n-use core::vec;\n+use std::hashmap::HashMap;\n use extra;\n use syntax::ast;\n use syntax::parse::token::ident_interner;\n@@ -86,13 +84,13 @@ pub fn have_crate_data(cstore: &CStore, cnum: ast::crate_num) -> bool {\n \n pub fn iter_crate_data(cstore: &CStore,\n                        i: &fn(ast::crate_num, @crate_metadata)) {\n-    for cstore.metas.each |&k, &v| {\n+    for cstore.metas.iter().advance |(&k, &v)| {\n         i(k, v);\n     }\n }\n \n pub fn add_used_crate_file(cstore: &mut CStore, lib: &Path) {\n-    if !vec::contains(cstore.used_crate_files, lib) {\n+    if !cstore.used_crate_files.contains(lib) {\n         cstore.used_crate_files.push(copy *lib);\n     }\n }\n@@ -104,7 +102,7 @@ pub fn get_used_crate_files(cstore: &CStore) -> ~[Path] {\n pub fn add_used_library(cstore: &mut CStore, lib: @str) -> bool {\n     assert!(!lib.is_empty());\n \n-    if cstore.used_libraries.contains(&lib) { return false; }\n+    if cstore.used_libraries.iter().any_(|x| x == &lib) { return false; }\n     cstore.used_libraries.push(lib);\n     true\n }\n@@ -160,7 +158,7 @@ pub fn get_dep_hashes(cstore: &CStore) -> ~[@str] {\n     };\n \n     debug!(\"sorted:\");\n-    for sorted.each |x| {\n+    for sorted.iter().advance |x| {\n         debug!(\"  hash[%s]: %s\", x.name, x.hash);\n     }\n "}, {"sha": "2c7a991f6146a124c81f0cb481844c9b2764ceaa", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 268, "deletions": 171, "changes": 439, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -10,11 +10,10 @@\n \n // Decoding metadata from a single crate's metadata\n \n-use core::prelude::*;\n \n use metadata::cstore::crate_metadata;\n use metadata::common::*;\n-use metadata::csearch::{ProvidedTraitMethodInfo, StaticMethodInfo};\n+use metadata::csearch::StaticMethodInfo;\n use metadata::csearch;\n use metadata::cstore;\n use metadata::decoder;\n@@ -23,19 +22,18 @@ use metadata::tydecode::{parse_ty_data, parse_def_id,\n                          parse_bare_fn_ty_data, parse_trait_ref_data};\n use middle::{ty, resolve};\n \n-use core::hash::HashUtil;\n-use core::int;\n-use core::io::WriterUtil;\n-use core::io;\n-use core::option;\n-use core::str;\n-use core::vec;\n+use std::hash::HashUtil;\n+use std::int;\n+use std::io::WriterUtil;\n+use std::io;\n+use std::option;\n+use std::str;\n+use std::vec;\n use extra::ebml::reader;\n use extra::ebml;\n use extra::serialize::Decodable;\n use syntax::ast_map;\n use syntax::attr;\n-use syntax::diagnostic::span_handler;\n use syntax::parse::token::{ident_interner, special_idents};\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n@@ -61,7 +59,7 @@ fn lookup_hash(d: ebml::Doc, eq_fn: &fn(x:&[u8]) -> bool, hash: uint) ->\n     let belt = tag_index_buckets_bucket_elt;\n     for reader::tagged_docs(tagged_doc.doc, belt) |elt| {\n         let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4u) as uint;\n-        if eq_fn(vec::slice(*elt.data, elt.start + 4u, elt.end)) {\n+        if eq_fn(elt.data.slice(elt.start + 4u, elt.end)) {\n             return Some(reader::doc_at(d.data, pos).doc);\n         }\n     };\n@@ -73,7 +71,7 @@ pub type GetCrateDataCb<'self> = &'self fn(ast::crate_num) -> cmd;\n pub fn maybe_find_item(item_id: int, items: ebml::Doc) -> Option<ebml::Doc> {\n     fn eq_item(bytes: &[u8], item_id: int) -> bool {\n         return io::u64_from_be_bytes(\n-            vec::slice(bytes, 0u, 4u), 0u, 4u) as int\n+            bytes.slice(0u, 4u), 0u, 4u) as int\n             == item_id;\n     }\n     lookup_hash(items,\n@@ -97,13 +95,12 @@ fn lookup_item(item_id: int, data: @~[u8]) -> ebml::Doc {\n \n #[deriving(Eq)]\n enum Family {\n-    Const,                 // c\n+    ImmStatic,             // c\n+    MutStatic,             // b\n     Fn,                    // f\n     UnsafeFn,              // u\n-    PureFn,                // p\n     StaticMethod,          // F\n     UnsafeStaticMethod,    // U\n-    PureStaticMethod,      // P\n     ForeignFn,             // e\n     Type,                  // y\n     ForeignType,           // T\n@@ -122,13 +119,12 @@ enum Family {\n fn item_family(item: ebml::Doc) -> Family {\n     let fam = reader::get_doc(item, tag_items_data_item_family);\n     match reader::doc_as_u8(fam) as char {\n-      'c' => Const,\n+      'c' => ImmStatic,\n+      'b' => MutStatic,\n       'f' => Fn,\n       'u' => UnsafeFn,\n-      'p' => PureFn,\n       'F' => StaticMethod,\n       'U' => UnsafeStaticMethod,\n-      'P' => PureStaticMethod,\n       'e' => ForeignFn,\n       'y' => Type,\n       'T' => ForeignType,\n@@ -321,11 +317,11 @@ fn item_to_def_like(item: ebml::Doc, did: ast::def_id, cnum: ast::crate_num)\n     -> def_like {\n     let fam = item_family(item);\n     match fam {\n-        Const     => dl_def(ast::def_const(did)),\n+        ImmStatic => dl_def(ast::def_static(did, false)),\n+        MutStatic => dl_def(ast::def_static(did, true)),\n         Struct    => dl_def(ast::def_struct(did)),\n         UnsafeFn  => dl_def(ast::def_fn(did, ast::unsafe_fn)),\n         Fn        => dl_def(ast::def_fn(did, ast::impure_fn)),\n-        PureFn    => dl_def(ast::def_fn(did, ast::pure_fn)),\n         ForeignFn => dl_def(ast::def_fn(did, ast::extern_fn)),\n         UnsafeStaticMethod => {\n             let trait_did_opt = translated_parent_item_opt(cnum, item);\n@@ -335,10 +331,6 @@ fn item_to_def_like(item: ebml::Doc, did: ast::def_id, cnum: ast::crate_num)\n             let trait_did_opt = translated_parent_item_opt(cnum, item);\n             dl_def(ast::def_static_method(did, trait_did_opt, ast::impure_fn))\n         }\n-        PureStaticMethod => {\n-            let trait_did_opt = translated_parent_item_opt(cnum, item);\n-            dl_def(ast::def_static_method(did, trait_did_opt, ast::pure_fn))\n-        }\n         Type | ForeignType => dl_def(ast::def_ty(did)),\n         Mod => dl_def(ast::def_mod(did)),\n         ForeignMod => dl_def(ast::def_foreign_mod(did)),\n@@ -415,7 +407,7 @@ pub fn get_impl_trait(cdata: cmd,\n }\n \n pub fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n-                       name: ast::ident) -> ast::def_id {\n+                       name: ast::ident) -> Option<ast::def_id> {\n     let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n     let mut found = None;\n     for reader::tagged_docs(find_item(id, items), tag_item_impl_method)\n@@ -425,7 +417,7 @@ pub fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n                 found = Some(translate_def_id(cdata, m_did));\n             }\n         }\n-    found.get()\n+    found\n }\n \n pub fn get_symbol(data: @~[u8], id: ast::node_id) -> ~str {\n@@ -465,94 +457,246 @@ pub fn each_lang_item(cdata: cmd, f: &fn(ast::node_id, uint) -> bool) -> bool {\n     return true;\n }\n \n-/// Iterates over all the paths in the given crate.\n-pub fn each_path(intr: @ident_interner,\n-                 cdata: cmd,\n-                 get_crate_data: GetCrateDataCb,\n-                 f: &fn(&str, def_like, ast::visibility) -> bool)\n-                 -> bool {\n-    // FIXME #4572: This function needs to be nuked, as it's impossible to make fast.\n-    // It's the source of most of the performance problems when compiling small crates.\n+struct EachItemContext<'self> {\n+    intr: @ident_interner,\n+    cdata: cmd,\n+    get_crate_data: GetCrateDataCb<'self>,\n+    path_builder: &'self mut ~str,\n+    callback: &'self fn(&str, def_like, ast::visibility) -> bool,\n+}\n \n-    let root = reader::Doc(cdata.data);\n-    let items = reader::get_doc(root, tag_items);\n-    let items_data = reader::get_doc(items, tag_items_data);\n-\n-    // First, go through all the explicit items.\n-    for reader::tagged_docs(items_data, tag_items_data_item) |item_doc| {\n-        let path = ast_map::path_to_str(item_path(item_doc), intr);\n-        let path_is_empty = path.is_empty();\n-        if !path_is_empty {\n-            // Extract the def ID.\n-            let def_id = item_def_id(item_doc, cdata);\n-\n-            // Construct the def for this item.\n-            debug!(\"(each_path) yielding explicit item: %s\", path);\n-            let def_like = item_to_def_like(item_doc, def_id, cdata.cnum);\n-\n-            let vis = item_visibility(item_doc);\n-\n-            // Hand the information off to the iteratee.\n-            if !f(path, def_like, vis) {\n-                return false;\n+impl<'self> EachItemContext<'self> {\n+    // Pushes the given name and returns the old length.\n+    fn push_name(&mut self, string: &str) -> uint {\n+        let path_len = self.path_builder.len();\n+        if path_len != 0 {\n+            self.path_builder.push_str(\"::\")\n+        }\n+        self.path_builder.push_str(string);\n+        path_len\n+    }\n+\n+    // Pops the given name.\n+    fn pop_name(&mut self, old_len: uint) {\n+        // XXX(pcwalton): There's no safe function to do this. :(\n+        unsafe {\n+            str::raw::set_len(self.path_builder, old_len)\n+        }\n+    }\n+\n+    fn process_item_and_pop_name(&mut self,\n+                                 doc: ebml::Doc,\n+                                 def_id: ast::def_id,\n+                                 old_len: uint)\n+                                 -> bool {\n+        let def_like = item_to_def_like(doc, def_id, self.cdata.cnum);\n+        match def_like {\n+            dl_def(def) => {\n+                debug!(\"(iterating over each item of a module) processing \\\n+                        `%s` (def %?)\",\n+                       *self.path_builder,\n+                       def);\n+            }\n+            _ => {\n+                debug!(\"(iterating over each item of a module) processing \\\n+                        `%s` (%d:%d)\",\n+                       *self.path_builder,\n+                       def_id.crate,\n+                       def_id.node);\n             }\n         }\n \n-        // If this is a module, find the reexports.\n-        for each_reexport(item_doc) |reexport_doc| {\n-            let def_id_doc =\n-                reader::get_doc(reexport_doc,\n-                                tag_items_data_item_reexport_def_id);\n-            let def_id = reader::with_doc_data(def_id_doc, parse_def_id);\n-            let def_id = translate_def_id(cdata, def_id);\n-\n-            let reexport_name_doc =\n-                reader::get_doc(reexport_doc,\n-                                tag_items_data_item_reexport_name);\n-            let reexport_name = reexport_name_doc.as_str_slice();\n-\n-            let reexport_path;\n-            if path_is_empty {\n-                reexport_path = reexport_name.to_owned();\n+        let vis = item_visibility(doc);\n+\n+        let mut continue = (self.callback)(*self.path_builder, def_like, vis);\n+\n+        let family = item_family(doc);\n+        if family == ForeignMod {\n+            // These are unnamed; pop the name now.\n+            self.pop_name(old_len)\n+        }\n+\n+        if continue {\n+            // Recurse if necessary.\n+            match family {\n+                Mod | ForeignMod | Trait | Impl => {\n+                    continue = self.each_item_of_module(def_id);\n+                }\n+                ImmStatic | MutStatic | Struct | UnsafeFn | Fn | ForeignFn |\n+                UnsafeStaticMethod | StaticMethod | Type | ForeignType |\n+                Variant | Enum | PublicField | PrivateField |\n+                InheritedField => {}\n+            }\n+        }\n+\n+        if family != ForeignMod {\n+            self.pop_name(old_len)\n+        }\n+\n+        continue\n+    }\n+\n+    fn each_item_of_module(&mut self, def_id: ast::def_id) -> bool {\n+        // This item might not be in this crate. If it's not, look it up.\n+        let (_cdata, items) = if def_id.crate == self.cdata.cnum {\n+            let items = reader::get_doc(reader::Doc(self.cdata.data),\n+                                        tag_items);\n+            (self.cdata, items)\n+        } else {\n+            let crate_data = (self.get_crate_data)(def_id.crate);\n+            let root = reader::Doc(crate_data.data);\n+            (crate_data, reader::get_doc(root, tag_items))\n+        };\n+\n+        // Look up the item.\n+        let item_doc = match maybe_find_item(def_id.node, items) {\n+            None => return false,\n+            Some(item_doc) => item_doc,\n+        };\n+\n+        self.each_child_of_module_or_crate(item_doc)\n+    }\n+\n+    fn each_child_of_module_or_crate(&mut self, item_doc: ebml::Doc) -> bool {\n+        let mut continue = true;\n+\n+        // Iterate over all children.\n+        for reader::tagged_docs(item_doc, tag_mod_child) |child_info_doc| {\n+            let child_def_id = reader::with_doc_data(child_info_doc,\n+                                                     parse_def_id);\n+            let child_def_id = translate_def_id(self.cdata, child_def_id);\n+\n+            // This item may be in yet another crate, if it was the child of\n+            // a reexport.\n+            let other_crates_items = if child_def_id.crate ==\n+                    self.cdata.cnum {\n+                reader::get_doc(reader::Doc(self.cdata.data), tag_items)\n             } else {\n-                reexport_path = path + \"::\" + reexport_name;\n+                let crate_data = (self.get_crate_data)(child_def_id.crate);\n+                let root = reader::Doc(crate_data.data);\n+                reader::get_doc(root, tag_items)\n+            };\n+\n+            debug!(\"(iterating over each item of a module) looking up item \\\n+                    %d:%d in `%s`, crate %d\",\n+                   child_def_id.crate,\n+                   child_def_id.node,\n+                   *self.path_builder,\n+                   self.cdata.cnum);\n+\n+            // Get the item.\n+            match maybe_find_item(child_def_id.node, other_crates_items) {\n+                None => {}\n+                Some(child_item_doc) => {\n+                    // Push the name.\n+                    let child_name = item_name(self.intr, child_item_doc);\n+                    debug!(\"(iterating over each item of a module) pushing \\\n+                            name `%s` onto `%s`\",\n+                           token::ident_to_str(&child_name),\n+                           *self.path_builder);\n+                    let old_len =\n+                        self.push_name(token::ident_to_str(&child_name));\n+\n+                    // Process this item.\n+                    continue = self.process_item_and_pop_name(child_item_doc,\n+                                                              child_def_id,\n+                                                              old_len);\n+\n+                    if !continue {\n+                        break\n+                    }\n+                }\n             }\n+        }\n \n-            // This reexport may be in yet another crate\n-            let other_crates_items = if def_id.crate == cdata.cnum {\n-                items\n+        if !continue {\n+            return false\n+        }\n+\n+        // Iterate over reexports.\n+        for each_reexport(item_doc) |reexport_doc| {\n+            let def_id_doc = reader::get_doc(\n+                reexport_doc,\n+                tag_items_data_item_reexport_def_id);\n+            let orig_def_id = reader::with_doc_data(def_id_doc, parse_def_id);\n+\n+            // NB: was \"cdata\"\n+            let def_id = translate_def_id(self.cdata, orig_def_id);\n+\n+            let name_doc = reader::get_doc(reexport_doc,\n+                                           tag_items_data_item_reexport_name);\n+            let name = name_doc.as_str_slice();\n+\n+            // Push the name.\n+            debug!(\"(iterating over each item of a module) pushing \\\n+                    reexported name `%s` onto `%s` (crate %d, orig %d, \\\n+                    in crate %d)\",\n+                   name,\n+                   *self.path_builder,\n+                   def_id.crate,\n+                   orig_def_id.crate,\n+                   self.cdata.cnum);\n+            let old_len = self.push_name(name);\n+\n+            // This reexport may be in yet another crate.\n+            let other_crates_items = if def_id.crate == self.cdata.cnum {\n+                reader::get_doc(reader::Doc(self.cdata.data), tag_items)\n             } else {\n-                let crate_data = get_crate_data(def_id.crate);\n+                let crate_data = (self.get_crate_data)(def_id.crate);\n                 let root = reader::Doc(crate_data.data);\n                 reader::get_doc(root, tag_items)\n             };\n \n             // Get the item.\n             match maybe_find_item(def_id.node, other_crates_items) {\n                 None => {}\n-                Some(item_doc) => {\n-                    // Construct the def for this item.\n-                    let def_like = item_to_def_like(item_doc,\n-                                                    def_id,\n-                                                    cdata.cnum);\n-\n-                    // Hand the information off to the iteratee.\n-                    debug!(\"(each_path) yielding reexported \\\n-                           item: %s\", reexport_path);\n-\n-                    if (!f(reexport_path, def_like, ast::public)) {\n-                        return false;\n-                    }\n+                Some(reexported_item_doc) => {\n+                    continue = self.process_item_and_pop_name(\n+                        reexported_item_doc,\n+                        def_id,\n+                        old_len);\n                 }\n             }\n+\n+            if !continue {\n+                break\n+            }\n         }\n+\n+        continue\n     }\n+}\n \n-    return true;\n+/// Iterates over all the paths in the given crate.\n+pub fn each_path(intr: @ident_interner,\n+                 cdata: cmd,\n+                 get_crate_data: GetCrateDataCb,\n+                 f: &fn(&str, def_like, ast::visibility) -> bool)\n+                 -> bool {\n+    // FIXME #4572: This function needs to be nuked, as it's impossible to\n+    // make fast. It's the source of most of the performance problems when\n+    // compiling small crates.\n+\n+    let root_doc = reader::Doc(cdata.data);\n+    let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n+    let crate_items_doc = reader::get_doc(misc_info_doc,\n+                                          tag_misc_info_crate_items);\n+\n+    let mut path_builder = ~\"\";\n+\n+    let mut context = EachItemContext {\n+        intr: intr,\n+        cdata: cdata,\n+        get_crate_data: get_crate_data,\n+        path_builder: &mut path_builder,\n+        callback: f,\n+    };\n+\n+    // Iterate over all top-level crate items.\n+    context.each_child_of_module_or_crate(crate_items_doc)\n }\n \n-pub fn get_item_path(cdata: cmd, id: ast::node_id)\n-    -> ast_map::path {\n+pub fn get_item_path(cdata: cmd, id: ast::node_id) -> ast_map::path {\n     item_path(lookup_item(id, cdata.data))\n }\n \n@@ -598,7 +742,7 @@ pub fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n     let mut infos: ~[ty::VariantInfo] = ~[];\n     let variant_ids = enum_variant_ids(item, cdata);\n     let mut disr_val = 0;\n-    for variant_ids.each |did| {\n+    for variant_ids.iter().advance |did| {\n         let item = find_item(did.node, items);\n         let ctor_ty = item_type(ast::def_id { crate: cdata.cnum, node: id},\n                                 item, tcx, cdata);\n@@ -641,7 +785,7 @@ fn get_explicit_self(item: ebml::Doc) -> ast::explicit_self_ {\n         's' => { return ast::sty_static; }\n         'v' => { return ast::sty_value; }\n         '@' => { return ast::sty_box(get_mutability(string[1])); }\n-        '~' => { return ast::sty_uniq(get_mutability(string[1])); }\n+        '~' => { return ast::sty_uniq; }\n         '&' => {\n             // FIXME(#4846) expl. region\n             return ast::sty_region(None, get_mutability(string[1]));\n@@ -668,35 +812,20 @@ fn item_impl_methods(intr: @ident_interner, cdata: cmd, item: ebml::Doc,\n     rslt\n }\n \n-pub fn get_impls_for_mod(intr: @ident_interner,\n-                         cdata: cmd,\n-                         m_id: ast::node_id,\n-                         name: Option<ast::ident>,\n-                         get_cdata: &fn(ast::crate_num) -> cmd)\n-                      -> @~[@resolve::Impl] {\n+/// Returns information about the given implementation.\n+pub fn get_impl(intr: @ident_interner, cdata: cmd, impl_id: ast::node_id)\n+                -> resolve::Impl {\n     let data = cdata.data;\n-    let mod_item = lookup_item(m_id, data);\n-    let mut result = ~[];\n-    for reader::tagged_docs(mod_item, tag_mod_impl) |doc| {\n-        let did = reader::with_doc_data(doc, parse_def_id);\n-        let local_did = translate_def_id(cdata, did);\n-        debug!(\"(get impls for mod) getting did %? for '%?'\",\n-               local_did, name);\n-          // The impl may be defined in a different crate. Ask the caller\n-          // to give us the metadata\n-        let impl_cdata = get_cdata(local_did.crate);\n-        let impl_data = impl_cdata.data;\n-        let item = lookup_item(local_did.node, impl_data);\n-        let nm = item_name(intr, item);\n-        if match name { Some(n) => { n == nm } None => { true } } {\n-           let base_tps = item_ty_param_count(item);\n-           result.push(@resolve::Impl {\n-                did: local_did, ident: nm,\n-                methods: item_impl_methods(intr, impl_cdata, item, base_tps)\n-            });\n-        };\n+    let impl_item = lookup_item(impl_id, data);\n+    let base_tps = item_ty_param_count(impl_item);\n+    resolve::Impl {\n+        did: ast::def_id {\n+            crate: cdata.cnum,\n+            node: impl_id,\n+        },\n+        ident: item_name(intr, impl_item),\n+        methods: item_impl_methods(intr, cdata, impl_item, base_tps),\n     }\n-    @result\n }\n \n pub fn get_method_name_and_explicit_self(\n@@ -750,51 +879,18 @@ pub fn get_trait_method_def_ids(cdata: cmd,\n \n pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n                                   id: ast::node_id, tcx: ty::ctxt) ->\n-        ~[ProvidedTraitMethodInfo] {\n+        ~[@ty::Method] {\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n \n-    for reader::tagged_docs(item, tag_item_trait_method) |mth| {\n-        if item_method_sort(mth) != 'p' { loop; }\n-\n-        let did = item_def_id(mth, cdata);\n-\n-        let type_param_defs =\n-            item_ty_param_defs(mth, tcx, cdata,\n-                               tag_items_data_item_ty_param_bounds);\n-        let name = item_name(intr, mth);\n-        let ty = doc_type(mth, tcx, cdata);\n-\n-        let fty = match ty::get(ty).sty {\n-            ty::ty_bare_fn(ref f) => copy *f,\n-            _ => {\n-                tcx.diag.handler().bug(\"get_provided_trait_methods(): id \\\n-                                        has non-function type\");\n-            }\n-        };\n+    for reader::tagged_docs(item, tag_item_trait_method) |mth_id| {\n+        let did = item_def_id(mth_id, cdata);\n+        let mth = lookup_item(did.node, data);\n \n-        let transformed_self_ty = doc_transformed_self_ty(mth, tcx, cdata);\n-        let explicit_self = get_explicit_self(mth);\n-\n-        let ty_method = ty::Method::new(\n-            name,\n-            ty::Generics {\n-                type_param_defs: type_param_defs,\n-                region_param: None\n-            },\n-            transformed_self_ty,\n-            fty,\n-            explicit_self,\n-            ast::public,\n-            did\n-        );\n-        let provided_trait_method_info = ProvidedTraitMethodInfo {\n-            ty: ty_method,\n-            def_id: did\n-        };\n+        if item_method_sort(mth) != 'p' { loop; }\n \n-        vec::push(&mut result, provided_trait_method_info);\n+        result.push(@get_method(intr, cdata, did.node, tcx));\n     }\n \n     return result;\n@@ -845,16 +941,15 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n     }\n \n     let mut static_impl_methods = ~[];\n-    for impl_method_ids.each |impl_method_id| {\n+    for impl_method_ids.iter().advance |impl_method_id| {\n         let impl_method_doc = lookup_item(impl_method_id.node, cdata.data);\n         let family = item_family(impl_method_doc);\n         match family {\n-            StaticMethod | UnsafeStaticMethod | PureStaticMethod => {\n+            StaticMethod | UnsafeStaticMethod => {\n                 let purity;\n                 match item_family(impl_method_doc) {\n                     StaticMethod => purity = ast::impure_fn,\n                     UnsafeStaticMethod => purity = ast::unsafe_fn,\n-                    PureStaticMethod => purity = ast::pure_fn,\n                     _ => fail!()\n                 }\n \n@@ -927,8 +1022,8 @@ pub fn get_item_visibility(cdata: cmd, id: ast::node_id)\n \n fn family_has_type_params(fam: Family) -> bool {\n     match fam {\n-      Const | ForeignType | Mod | ForeignMod | PublicField | PrivateField\n-      | ForeignFn => false,\n+      ImmStatic | ForeignType | Mod | ForeignMod | PublicField | PrivateField\n+      | ForeignFn | MutStatic => false,\n       _           => true\n     }\n }\n@@ -958,13 +1053,12 @@ fn describe_def(items: ebml::Doc, id: ast::def_id) -> ~str {\n \n fn item_family_to_str(fam: Family) -> ~str {\n     match fam {\n-      Const => ~\"const\",\n+      ImmStatic => ~\"static\",\n+      MutStatic => ~\"static mut\",\n       Fn => ~\"fn\",\n       UnsafeFn => ~\"unsafe fn\",\n-      PureFn => ~\"pure fn\",\n       StaticMethod => ~\"static method\",\n       UnsafeStaticMethod => ~\"unsafe static method\",\n-      PureStaticMethod => ~\"pure static method\",\n       ForeignFn => ~\"foreign fn\",\n       Type => ~\"type\",\n       ForeignType => ~\"foreign type\",\n@@ -1035,7 +1129,8 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::attribute] {\n fn list_meta_items(intr: @ident_interner,\n                    meta_items: ebml::Doc,\n                    out: @io::Writer) {\n-    for get_meta_items(meta_items).each |mi| {\n+    let r = get_meta_items(meta_items);\n+    for r.iter().advance |mi| {\n         out.write_str(fmt!(\"%s\\n\", pprust::meta_item_to_str(*mi, intr)));\n     }\n }\n@@ -1044,7 +1139,8 @@ fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: &str,\n                          out: @io::Writer) {\n     out.write_str(fmt!(\"=Crate Attributes (%s)=\\n\", hash));\n \n-    for get_attributes(md).each |attr| {\n+    let r = get_attributes(md);\n+    for r.iter().advance |attr| {\n         out.write_str(fmt!(\"%s\\n\", pprust::attribute_to_str(*attr, intr)));\n     }\n \n@@ -1084,7 +1180,8 @@ pub fn get_crate_deps(data: @~[u8]) -> ~[crate_dep] {\n fn list_crate_deps(data: @~[u8], out: @io::Writer) {\n     out.write_str(\"=External Dependencies=\\n\");\n \n-    for get_crate_deps(data).each |dep| {\n+    let r = get_crate_deps(data);\n+    for r.iter().advance |dep| {\n         out.write_str(\n             fmt!(\"%d %s-%s-%s\\n\",\n                  dep.cnum, token::ident_to_str(&dep.name), dep.hash, dep.vers));"}, {"sha": "77a8d1792dbc8f667ba7e8fa97c95092bbc492a4", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 251, "deletions": 131, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -10,25 +10,23 @@\n \n // Metadata encoding\n \n-use core::prelude::*;\n \n use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n use metadata::tyencode;\n-use middle::trans::reachable;\n use middle::ty::node_id_to_type;\n use middle::ty;\n use middle;\n use util::ppaux::ty_to_str;\n \n-use core::hash::HashUtil;\n-use core::hashmap::HashMap;\n-use core::int;\n-use core::io;\n-use core::str;\n-use core::uint;\n-use core::vec;\n+use std::hash::HashUtil;\n+use std::hashmap::{HashMap, HashSet};\n+use std::int;\n+use std::io;\n+use std::str;\n+use std::uint;\n+use std::vec;\n use extra::flate;\n use extra::serialize::Encodable;\n use extra;\n@@ -47,7 +45,7 @@ use syntax::parse::token;\n use syntax;\n use writer = extra::ebml::writer;\n \n-use core::cast;\n+use std::cast;\n \n // used by astencode:\n type abbrev_map = @mut HashMap<ty::t, tyencode::ty_abbrev>;\n@@ -60,13 +58,13 @@ pub type encode_inlined_item<'self> = &'self fn(ecx: &EncodeContext,\n pub struct EncodeParams<'self> {\n     diag: @span_handler,\n     tcx: ty::ctxt,\n-    reachable: reachable::map,\n     reexports2: middle::resolve::ExportMap2,\n     item_symbols: &'self HashMap<ast::node_id, ~str>,\n     discrim_symbols: &'self HashMap<ast::node_id, @str>,\n     link_meta: &'self LinkMeta,\n     cstore: @mut cstore::CStore,\n-    encode_inlined_item: encode_inlined_item<'self>\n+    encode_inlined_item: encode_inlined_item<'self>,\n+    reachable: @mut HashSet<ast::node_id>,\n }\n \n struct Stats {\n@@ -75,6 +73,7 @@ struct Stats {\n     dep_bytes: uint,\n     lang_item_bytes: uint,\n     link_args_bytes: uint,\n+    misc_bytes: uint,\n     item_bytes: uint,\n     index_bytes: uint,\n     zero_bytes: uint,\n@@ -87,14 +86,14 @@ pub struct EncodeContext<'self> {\n     diag: @span_handler,\n     tcx: ty::ctxt,\n     stats: @mut Stats,\n-    reachable: reachable::map,\n     reexports2: middle::resolve::ExportMap2,\n     item_symbols: &'self HashMap<ast::node_id, ~str>,\n     discrim_symbols: &'self HashMap<ast::node_id, @str>,\n     link_meta: &'self LinkMeta,\n     cstore: &'self cstore::CStore,\n     encode_inlined_item: encode_inlined_item<'self>,\n-    type_abbrevs: abbrev_map\n+    type_abbrevs: abbrev_map,\n+    reachable: @mut HashSet<ast::node_id>,\n }\n \n pub fn reachable(ecx: &EncodeContext, id: node_id) -> bool {\n@@ -152,13 +151,12 @@ fn encode_trait_ref(ebml_w: &mut writer::Encoder,\n                     ecx: &EncodeContext,\n                     trait_ref: &ty::TraitRef,\n                     tag: uint) {\n-    let r = ecx.reachable;\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        reachable: |a| r.contains(&a),\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n+    };\n \n     ebml_w.start_tag(tag);\n     tyencode::enc_trait_ref(ebml_w.writer, ty_str_ctxt, trait_ref);\n@@ -180,14 +178,13 @@ fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n                              ecx: &EncodeContext,\n                              params: @~[ty::TypeParameterDef],\n                              tag: uint) {\n-    let r = ecx.reachable;\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        reachable: |a| r.contains(&a),\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n-    for params.each |param| {\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n+    };\n+    for params.iter().advance |param| {\n         ebml_w.start_tag(tag);\n         tyencode::enc_type_param_def(ebml_w.writer, ty_str_ctxt, param);\n         ebml_w.end_tag();\n@@ -213,26 +210,24 @@ fn encode_variant_id(ebml_w: &mut writer::Encoder, vid: def_id) {\n pub fn write_type(ecx: &EncodeContext,\n                   ebml_w: &mut writer::Encoder,\n                   typ: ty::t) {\n-    let r = ecx.reachable;\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        reachable: |a| r.contains(&a),\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n+    };\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n \n pub fn write_vstore(ecx: &EncodeContext,\n                     ebml_w: &mut writer::Encoder,\n                     vstore: ty::vstore) {\n-    let r = ecx.reachable;\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        reachable: |a| r.contains(&a),\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n+    };\n     tyencode::enc_vstore(ebml_w.writer, ty_str_ctxt, vstore);\n }\n \n@@ -259,13 +254,12 @@ fn encode_method_fty(ecx: &EncodeContext,\n                      typ: &ty::BareFnTy) {\n     ebml_w.start_tag(tag_item_method_fty);\n \n-    let r = ecx.reachable;\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        reachable: |a| r.contains(&a),\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n+    };\n     tyencode::enc_bare_fn_ty(ebml_w.writer, ty_str_ctxt, typ);\n \n     ebml_w.end_tag();\n@@ -325,7 +319,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n     let mut i = 0;\n     let vi = ty::enum_variants(ecx.tcx,\n                                ast::def_id { crate: local_crate, node: id });\n-    for variants.each |variant| {\n+    for variants.iter().advance |variant| {\n         index.push(entry {val: variant.node.id, pos: ebml_w.writer.tell()});\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(variant.node.id));\n@@ -373,7 +367,7 @@ fn encode_path(ecx: &EncodeContext,\n \n     ebml_w.start_tag(tag_path);\n     ebml_w.wr_tagged_u32(tag_path_len, (path.len() + 1) as u32);\n-    for path.each |pe| {\n+    for path.iter().advance |pe| {\n         encode_path_elt(ecx, ebml_w, *pe);\n     }\n     encode_path_elt(ecx, ebml_w, name);\n@@ -403,8 +397,8 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n                                          -> bool {\n     match ecx.tcx.base_impls.find(&exp.def_id) {\n         Some(implementations) => {\n-            for implementations.each |&base_impl| {\n-                for base_impl.methods.each |&m| {\n+            for implementations.iter().advance |&base_impl| {\n+                for base_impl.methods.iter().advance |&m| {\n                     if m.explicit_self == ast::sty_static {\n                         encode_reexported_static_method(ecx, ebml_w, exp,\n                                                         m.did, m.ident);\n@@ -424,7 +418,7 @@ fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n                                           -> bool {\n     match ecx.tcx.trait_methods_cache.find(&exp.def_id) {\n         Some(methods) => {\n-            for methods.each |&m| {\n+            for methods.iter().advance |&m| {\n                 if m.explicit_self == ast::sty_static {\n                     encode_reexported_static_method(ecx, ebml_w, exp,\n                                                     m.def_id, m.ident);\n@@ -473,20 +467,95 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n     }\n }\n \n+/// Iterates through \"auxiliary node IDs\", which are node IDs that describe\n+/// top-level items that are sub-items of the given item. Specifically:\n+///\n+/// * For enums, iterates through the node IDs of the variants.\n+///\n+/// * For newtype structs, iterates through the node ID of the constructor.\n+fn each_auxiliary_node_id(item: @item, callback: &fn(node_id) -> bool)\n+                          -> bool {\n+    let mut continue = true;\n+    match item.node {\n+        item_enum(ref enum_def, _) => {\n+            for enum_def.variants.iter().advance |variant| {\n+                continue = callback(variant.node.id);\n+                if !continue {\n+                    break\n+                }\n+            }\n+        }\n+        item_struct(struct_def, _) => {\n+            // If this is a newtype struct, return the constructor.\n+            match struct_def.ctor_id {\n+                Some(ctor_id) if struct_def.fields.len() > 0 &&\n+                        struct_def.fields[0].node.kind ==\n+                        ast::unnamed_field => {\n+                    continue = callback(ctor_id);\n+                }\n+                _ => {}\n+            }\n+        }\n+        _ => {}\n+    }\n+\n+    continue\n+}\n+\n+fn encode_reexports(ecx: &EncodeContext,\n+                    ebml_w: &mut writer::Encoder,\n+                    id: node_id,\n+                    path: &[ast_map::path_elt]) {\n+    debug!(\"(encoding info for module) encoding reexports for %d\", id);\n+    match ecx.reexports2.find(&id) {\n+        Some(ref exports) => {\n+            debug!(\"(encoding info for module) found reexports for %d\", id);\n+            for exports.iter().advance |exp| {\n+                debug!(\"(encoding info for module) reexport '%s' for %d\",\n+                       exp.name, id);\n+                ebml_w.start_tag(tag_items_data_item_reexport);\n+                ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n+                ebml_w.wr_str(def_to_str(exp.def_id));\n+                ebml_w.end_tag();\n+                ebml_w.start_tag(tag_items_data_item_reexport_name);\n+                ebml_w.wr_str(exp.name);\n+                ebml_w.end_tag();\n+                ebml_w.end_tag();\n+                encode_reexported_static_methods(ecx, ebml_w, path, exp);\n+            }\n+        }\n+        None => {\n+            debug!(\"(encoding info for module) found no reexports for %d\",\n+                   id);\n+        }\n+    }\n+}\n+\n fn encode_info_for_mod(ecx: &EncodeContext,\n                        ebml_w: &mut writer::Encoder,\n                        md: &_mod,\n                        id: node_id,\n                        path: &[ast_map::path_elt],\n-                       name: ident) {\n+                       name: ident,\n+                       vis: visibility) {\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(id));\n     encode_family(ebml_w, 'm');\n     encode_name(ecx, ebml_w, name);\n     debug!(\"(encoding info for module) encoding info for module ID %d\", id);\n \n     // Encode info about all the module children.\n-    for md.items.each |item| {\n+    for md.items.iter().advance |item| {\n+        ebml_w.start_tag(tag_mod_child);\n+        ebml_w.wr_str(def_to_str(local_def(item.id)));\n+        ebml_w.end_tag();\n+\n+        for each_auxiliary_node_id(*item) |auxiliary_node_id| {\n+            ebml_w.start_tag(tag_mod_child);\n+            ebml_w.wr_str(def_to_str(local_def(auxiliary_node_id)));\n+            ebml_w.end_tag();\n+        }\n+\n         match item.node {\n             item_impl(*) => {\n                 let (ident, did) = (item.ident, item.id);\n@@ -500,35 +569,16 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                 ebml_w.wr_str(def_to_str(local_def(did)));\n                 ebml_w.end_tag();\n             }\n-            _ => {} // FIXME #4573: Encode these too.\n+            _ => {}\n         }\n     }\n \n     encode_path(ecx, ebml_w, path, ast_map::path_mod(name));\n \n-    // Encode the reexports of this module.\n-    debug!(\"(encoding info for module) encoding reexports for %d\", id);\n-    match ecx.reexports2.find(&id) {\n-        Some(ref exports) => {\n-            debug!(\"(encoding info for module) found reexports for %d\", id);\n-            for exports.each |exp| {\n-                debug!(\"(encoding info for module) reexport '%s' for %d\",\n-                       exp.name, id);\n-                ebml_w.start_tag(tag_items_data_item_reexport);\n-                ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n-                ebml_w.wr_str(def_to_str(exp.def_id));\n-                ebml_w.end_tag();\n-                ebml_w.start_tag(tag_items_data_item_reexport_name);\n-                ebml_w.wr_str(exp.name);\n-                ebml_w.end_tag();\n-                ebml_w.end_tag();\n-                encode_reexported_static_methods(ecx, ebml_w, path, exp);\n-            }\n-        }\n-        None => {\n-            debug!(\"(encoding info for module) found no reexports for %d\",\n-                   id);\n-        }\n+    // Encode the reexports of this module, if this module is public.\n+    if vis == public {\n+        debug!(\"(encoding info for module) encoding reexports for %d\", id);\n+        encode_reexports(ecx, ebml_w, id, path);\n     }\n \n     ebml_w.end_tag();\n@@ -574,9 +624,8 @@ fn encode_explicit_self(ebml_w: &mut writer::Encoder, explicit_self: ast::explic\n             ebml_w.writer.write(&[ '@' as u8 ]);\n             encode_mutability(ebml_w, m);\n         }\n-        sty_uniq(m) => {\n+        sty_uniq => {\n             ebml_w.writer.write(&[ '~' as u8 ]);\n-            encode_mutability(ebml_w, m);\n         }\n     }\n \n@@ -617,7 +666,7 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n     let tcx = ecx.tcx;\n      /* We encode both private and public fields -- need to include\n         private fields to get the offsets right */\n-    for fields.each |field| {\n+    for fields.iter().advance |field| {\n         let (nm, vis) = match field.node.kind {\n             named_field(nm, vis) => (nm, vis),\n             unnamed_field => (special_idents::unnamed_field, inherited)\n@@ -731,8 +780,8 @@ fn encode_info_for_method(ecx: &EncodeContext,\n     }\n \n     let mut combined_ty_params = opt_vec::Empty;\n-    combined_ty_params.push_all(&owner_generics.ty_params);\n-    combined_ty_params.push_all(&method_generics.ty_params);\n+    for owner_generics.ty_params.iter().advance |x| { combined_ty_params.push(copy *x) }\n+    for method_generics.ty_params.iter().advance |x| { combined_ty_params.push(copy *x) }\n     let len = combined_ty_params.len();\n     encode_type_param_bounds(ebml_w, ecx, &combined_ty_params);\n \n@@ -753,7 +802,6 @@ fn encode_info_for_method(ecx: &EncodeContext,\n fn purity_fn_family(p: purity) -> char {\n     match p {\n       unsafe_fn => 'u',\n-      pure_fn => 'p',\n       impure_fn => 'f',\n       extern_fn => 'e'\n     }\n@@ -762,7 +810,6 @@ fn purity_fn_family(p: purity) -> char {\n fn purity_static_method_family(p: purity) -> char {\n     match p {\n       unsafe_fn => 'U',\n-      pure_fn => 'P',\n       impure_fn => 'F',\n       _ => fail!(\"extern fn can't be static\")\n     }\n@@ -782,13 +829,6 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                         index: @mut ~[entry<int>],\n                         path: &[ast_map::path_elt]) {\n     let tcx = ecx.tcx;\n-    let must_write =\n-        match item.node {\n-          item_enum(_, _) | item_impl(*) | item_trait(*) | item_struct(*) |\n-          item_mod(*) | item_foreign_mod(*) | item_const(*) => true,\n-          _ => false\n-        };\n-    if !must_write && !reachable(ecx, item.id) { return; }\n \n     fn add_to_index_(item: @item, ebml_w: &writer::Encoder,\n                      index: @mut ~[entry<int>]) {\n@@ -800,13 +840,18 @@ fn encode_info_for_item(ecx: &EncodeContext,\n            ecx.tcx.sess.codemap.span_to_str(item.span));\n \n     match item.node {\n-      item_const(_, _) => {\n+      item_static(_, m, _) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n-        encode_family(ebml_w, 'c');\n+        if m == ast::m_mutbl {\n+            encode_family(ebml_w, 'b');\n+        } else {\n+            encode_family(ebml_w, 'c');\n+        }\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n+        encode_name(ecx, ebml_w, item.ident);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n         ebml_w.end_tag();\n@@ -819,6 +864,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let tps_len = generics.ty_params.len();\n         encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n+        encode_name(ecx, ebml_w, item.ident);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         encode_attributes(ebml_w, item.attrs);\n         if tps_len > 0u || should_inline(item.attrs) {\n@@ -830,15 +876,29 @@ fn encode_info_for_item(ecx: &EncodeContext,\n       }\n       item_mod(ref m) => {\n         add_to_index();\n-        encode_info_for_mod(ecx, ebml_w, m, item.id, path, item.ident);\n+        encode_info_for_mod(ecx,\n+                            ebml_w,\n+                            m,\n+                            item.id,\n+                            path,\n+                            item.ident,\n+                            item.vis);\n       }\n-      item_foreign_mod(_) => {\n+      item_foreign_mod(ref fm) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'n');\n         encode_name(ecx, ebml_w, item.ident);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+\n+        // Encode all the items in this module.\n+        for fm.items.iter().advance |foreign_item| {\n+            ebml_w.start_tag(tag_mod_child);\n+            ebml_w.wr_str(def_to_str(local_def(foreign_item.id)));\n+            ebml_w.end_tag();\n+        }\n+\n         ebml_w.end_tag();\n       }\n       item_ty(_, ref generics) => {\n@@ -862,7 +922,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ecx, ebml_w, item.ident);\n-        for (*enum_definition).variants.each |v| {\n+        for (*enum_definition).variants.iter().advance |v| {\n             encode_variant_id(ebml_w, local_def(v.node.id));\n         }\n         (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n@@ -896,23 +956,6 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n \n-        // If this is a tuple- or enum-like struct, encode the type of the\n-        // constructor.\n-        if struct_def.fields.len() > 0 &&\n-                struct_def.fields[0].node.kind == ast::unnamed_field {\n-            let ctor_id = match struct_def.ctor_id {\n-                Some(ctor_id) => ctor_id,\n-                None => ecx.tcx.sess.bug(\"struct def didn't have ctor id\"),\n-            };\n-\n-            encode_info_for_struct_ctor(ecx,\n-                                        ebml_w,\n-                                        path,\n-                                        item.ident,\n-                                        ctor_id,\n-                                        index);\n-        }\n-\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n@@ -921,7 +964,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n         needs to know*/\n-        for struct_def.fields.each |f| {\n+        for struct_def.fields.iter().advance |f| {\n             match f.node.kind {\n                 named_field(ident, vis) => {\n                    ebml_w.start_tag(tag_item_field);\n@@ -942,6 +985,23 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let bkts = create_index(idx);\n         encode_index(ebml_w, bkts, write_int);\n         ebml_w.end_tag();\n+\n+        // If this is a tuple- or enum-like struct, encode the type of the\n+        // constructor.\n+        if struct_def.fields.len() > 0 &&\n+                struct_def.fields[0].node.kind == ast::unnamed_field {\n+            let ctor_id = match struct_def.ctor_id {\n+                Some(ctor_id) => ctor_id,\n+                None => ecx.tcx.sess.bug(\"struct def didn't have ctor id\"),\n+            };\n+\n+            encode_info_for_struct_ctor(ecx,\n+                                        ebml_w,\n+                                        path,\n+                                        item.ident,\n+                                        ctor_id,\n+                                        index);\n+        }\n       }\n       item_impl(ref generics, opt_trait, ty, ref methods) => {\n         add_to_index();\n@@ -954,13 +1014,14 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n         match ty.node {\n-            ast::ty_path(path, _) if path.idents.len() == 1 => {\n+            ast::ty_path(path, bounds, _) if path.idents.len() == 1 => {\n+                assert!(bounds.is_none());\n                 encode_impl_type_basename(ecx, ebml_w,\n                                           ast_util::path_to_ident(path));\n             }\n             _ => {}\n         }\n-        for methods.each |m| {\n+        for methods.iter().advance |m| {\n             ebml_w.start_tag(tag_item_impl_method);\n             let method_def_id = local_def(m.id);\n             let s = def_to_str(method_def_id);\n@@ -976,9 +1037,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n         // >:-<\n         let mut impl_path = vec::append(~[], path);\n-        impl_path += [ast_map::path_name(item.ident)];\n+        impl_path.push(ast_map::path_name(item.ident));\n \n-        for methods.each |m| {\n+        for methods.iter().advance |m| {\n             index.push(entry {val: m.id, pos: ebml_w.writer.tell()});\n             encode_info_for_method(ecx,\n                                    ebml_w,\n@@ -1001,20 +1062,25 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_trait_ref(ebml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n-        for ty::trait_method_def_ids(tcx, local_def(item.id)).each |&method_def_id| {\n+        for ty::trait_method_def_ids(tcx, local_def(item.id)).iter().advance |&method_def_id| {\n             ebml_w.start_tag(tag_item_trait_method);\n             encode_def_id(ebml_w, method_def_id);\n             ebml_w.end_tag();\n+\n+            ebml_w.start_tag(tag_mod_child);\n+            ebml_w.wr_str(def_to_str(method_def_id));\n+            ebml_w.end_tag();\n         }\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n-        for super_traits.each |ast_trait_ref| {\n+        for super_traits.iter().advance |ast_trait_ref| {\n             let trait_ref = ty::node_id_to_trait_ref(ecx.tcx, ast_trait_ref.ref_id);\n             encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_super_trait_ref);\n         }\n         ebml_w.end_tag();\n \n         // Now output the method info for each method.\n-        for ty::trait_method_def_ids(tcx, local_def(item.id)).eachi |i, &method_def_id| {\n+        let r = ty::trait_method_def_ids(tcx, local_def(item.id));\n+        for r.iter().enumerate().advance |(i, &method_def_id)| {\n             assert_eq!(method_def_id.crate, ast::local_crate);\n \n             let method_ty = ty::method(tcx, method_def_id);\n@@ -1088,7 +1154,6 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 index: @mut ~[entry<int>],\n                                 path: ast_map::path,\n                                 abi: AbiSet) {\n-    if !reachable(ecx, nitem.id) { return; }\n     index.push(entry { val: nitem.id, pos: ebml_w.writer.tell() });\n \n     ebml_w.start_tag(tag_items_data_item);\n@@ -1098,18 +1163,24 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         encode_family(ebml_w, purity_fn_family(purity));\n         encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n+        encode_name(ecx, ebml_w, nitem.ident);\n         if abi.is_intrinsic() {\n             (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_foreign(nitem));\n         } else {\n             encode_symbol(ecx, ebml_w, nitem.id);\n         }\n         encode_path(ecx, ebml_w, path, ast_map::path_name(nitem.ident));\n       }\n-      foreign_item_const(*) => {\n+      foreign_item_static(_, mutbl) => {\n         encode_def_id(ebml_w, local_def(nitem.id));\n-        encode_family(ebml_w, 'c');\n+        if mutbl {\n+            encode_family(ebml_w, 'b');\n+        } else {\n+            encode_family(ebml_w, 'c');\n+        }\n         encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n         encode_symbol(ecx, ebml_w, nitem.id);\n+        encode_name(ecx, ebml_w, nitem.ident);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(nitem.ident));\n       }\n     }\n@@ -1123,9 +1194,13 @@ fn encode_info_for_items(ecx: &EncodeContext,\n     let index = @mut ~[];\n     ebml_w.start_tag(tag_items_data);\n     index.push(entry { val: crate_node_id, pos: ebml_w.writer.tell() });\n-    encode_info_for_mod(ecx, ebml_w, &crate.node.module,\n-                        crate_node_id, [],\n-                        syntax::parse::token::special_idents::invalid);\n+    encode_info_for_mod(ecx,\n+                        ebml_w,\n+                        &crate.node.module,\n+                        crate_node_id,\n+                        [],\n+                        syntax::parse::token::special_idents::invalid,\n+                        public);\n     let items = ecx.tcx.items;\n \n     // See comment in `encode_side_tables_for_ii` in astencode\n@@ -1154,6 +1229,12 @@ fn encode_info_for_items(ecx: &EncodeContext,\n                 visit::visit_foreign_item(ni, (cx, v));\n                 match items.get_copy(&ni.id) {\n                     ast_map::node_foreign_item(_, abi, _, pt) => {\n+                        debug!(\"writing foreign item %s::%s\",\n+                               ast_map::path_to_str(\n+                                *pt,\n+                                token::get_ident_interner()),\n+                                token::ident_to_str(&ni.ident));\n+\n                         let mut ebml_w = copy ebml_w;\n                         // See above\n                         let ecx : &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n@@ -1182,13 +1263,13 @@ fn create_index<T:Copy + Hash + IterBytes>(index: ~[entry<T>]) ->\n    ~[@~[entry<T>]] {\n     let mut buckets: ~[@mut ~[entry<T>]] = ~[];\n     for uint::range(0u, 256u) |_i| { buckets.push(@mut ~[]); };\n-    for index.each |elt| {\n+    for index.iter().advance |elt| {\n         let h = elt.val.hash() as uint;\n         buckets[h % 256].push(copy *elt);\n     }\n \n     let mut buckets_frozen = ~[];\n-    for buckets.each |bucket| {\n+    for buckets.iter().advance |bucket| {\n         buckets_frozen.push(@/*bad*/copy **bucket);\n     }\n     return buckets_frozen;\n@@ -1201,10 +1282,10 @@ fn encode_index<T>(ebml_w: &mut writer::Encoder,\n     ebml_w.start_tag(tag_index);\n     let mut bucket_locs: ~[uint] = ~[];\n     ebml_w.start_tag(tag_index_buckets);\n-    for buckets.each |bucket| {\n+    for buckets.iter().advance |bucket| {\n         bucket_locs.push(ebml_w.writer.tell());\n         ebml_w.start_tag(tag_index_buckets_bucket);\n-        for (**bucket).each |elt| {\n+        for (**bucket).iter().advance |elt| {\n             ebml_w.start_tag(tag_index_buckets_bucket_elt);\n             assert!(elt.pos < 0xffff_ffff);\n             writer.write_be_u32(elt.pos as u32);\n@@ -1215,7 +1296,7 @@ fn encode_index<T>(ebml_w: &mut writer::Encoder,\n     }\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_index_table);\n-    for bucket_locs.each |pos| {\n+    for bucket_locs.iter().advance |pos| {\n         assert!(*pos < 0xffff_ffff);\n         writer.write_be_u32(*pos as u32);\n     }\n@@ -1261,7 +1342,7 @@ fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @meta_item) {\n         ebml_w.start_tag(tag_meta_item_name);\n         ebml_w.writer.write(name.as_bytes());\n         ebml_w.end_tag();\n-        for items.each |inner_item| {\n+        for items.iter().advance |inner_item| {\n             encode_meta_item(ebml_w, *inner_item);\n         }\n         ebml_w.end_tag();\n@@ -1271,7 +1352,7 @@ fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @meta_item) {\n \n fn encode_attributes(ebml_w: &mut writer::Encoder, attrs: &[attribute]) {\n     ebml_w.start_tag(tag_attributes);\n-    for attrs.each |attr| {\n+    for attrs.iter().advance |attr| {\n         ebml_w.start_tag(tag_attribute);\n         encode_meta_item(ebml_w, attr.node.value);\n         ebml_w.end_tag();\n@@ -1313,7 +1394,7 @@ fn synthesize_crate_attrs(ecx: &EncodeContext,\n \n     let mut attrs: ~[attribute] = ~[];\n     let mut found_link_attr = false;\n-    for crate.node.attrs.each |attr| {\n+    for crate.node.attrs.iter().advance |attr| {\n         attrs.push(\n             if \"link\" != attr::get_attr_name(attr)  {\n                 copy *attr\n@@ -1355,21 +1436,21 @@ fn encode_crate_deps(ecx: &EncodeContext,\n \n         // Sanity-check the crate numbers\n         let mut expected_cnum = 1;\n-        for deps.each |n| {\n+        for deps.iter().advance |n| {\n             assert_eq!(n.cnum, expected_cnum);\n             expected_cnum += 1;\n         }\n \n-        // mut -> immutable hack for vec::map\n-        deps.slice(0, deps.len()).to_owned()\n+        deps\n     }\n \n     // We're just going to write a list of crate 'name-hash-version's, with\n     // the assumption that they are numbered 1 to n.\n     // FIXME (#2166): This is not nearly enough to support correct versioning\n     // but is enough to get transitive crate dependencies working.\n     ebml_w.start_tag(tag_crate_deps);\n-    for get_ordered_deps(ecx, cstore).each |dep| {\n+    let r = get_ordered_deps(ecx, cstore);\n+    for r.iter().advance |dep| {\n         encode_crate_dep(ecx, ebml_w, *dep);\n     }\n     ebml_w.end_tag();\n@@ -1403,7 +1484,7 @@ fn encode_link_args(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.start_tag(tag_link_args);\n \n     let link_args = cstore::get_used_link_args(ecx.cstore);\n-    for link_args.each |link_arg| {\n+    for link_args.iter().advance |link_arg| {\n         ebml_w.start_tag(tag_link_args_arg);\n         ebml_w.writer.write_str(link_arg.to_str());\n         ebml_w.end_tag();\n@@ -1412,6 +1493,30 @@ fn encode_link_args(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.end_tag();\n }\n \n+fn encode_misc_info(ecx: &EncodeContext,\n+                    crate: &crate,\n+                    ebml_w: &mut writer::Encoder) {\n+    ebml_w.start_tag(tag_misc_info);\n+    ebml_w.start_tag(tag_misc_info_crate_items);\n+    for crate.node.module.items.iter().advance |&item| {\n+        ebml_w.start_tag(tag_mod_child);\n+        ebml_w.wr_str(def_to_str(local_def(item.id)));\n+        ebml_w.end_tag();\n+\n+        for each_auxiliary_node_id(item) |auxiliary_node_id| {\n+            ebml_w.start_tag(tag_mod_child);\n+            ebml_w.wr_str(def_to_str(local_def(auxiliary_node_id)));\n+            ebml_w.end_tag();\n+        }\n+    }\n+\n+    // Encode reexports for the root module.\n+    encode_reexports(ecx, ebml_w, 0, []);\n+\n+    ebml_w.end_tag();\n+    ebml_w.end_tag();\n+}\n+\n fn encode_crate_dep(ecx: &EncodeContext,\n                     ebml_w: &mut writer::Encoder,\n                     dep: decoder::crate_dep) {\n@@ -1451,29 +1556,39 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n         dep_bytes: 0,\n         lang_item_bytes: 0,\n         link_args_bytes: 0,\n+        misc_bytes: 0,\n         item_bytes: 0,\n         index_bytes: 0,\n         zero_bytes: 0,\n         total_bytes: 0,\n         n_inlines: 0\n     };\n-    let EncodeParams{item_symbols, diag, tcx, reachable, reexports2,\n-                     discrim_symbols, cstore, encode_inlined_item,\n-                     link_meta, _} = parms;\n+    let EncodeParams {\n+        item_symbols,\n+        diag,\n+        tcx,\n+        reexports2,\n+        discrim_symbols,\n+        cstore,\n+        encode_inlined_item,\n+        link_meta,\n+        reachable,\n+        _\n+    } = parms;\n     let type_abbrevs = @mut HashMap::new();\n     let stats = @mut stats;\n     let ecx = EncodeContext {\n         diag: diag,\n         tcx: tcx,\n         stats: stats,\n-        reachable: reachable,\n         reexports2: reexports2,\n         item_symbols: item_symbols,\n         discrim_symbols: discrim_symbols,\n         link_meta: link_meta,\n         cstore: cstore,\n         encode_inlined_item: encode_inlined_item,\n-        type_abbrevs: type_abbrevs\n+        type_abbrevs: type_abbrevs,\n+        reachable: reachable,\n      };\n \n     let mut ebml_w = writer::Encoder(wr as @io::Writer);\n@@ -1499,6 +1614,11 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n     encode_link_args(&ecx, &mut ebml_w);\n     ecx.stats.link_args_bytes = *wr.pos - i;\n \n+    // Encode miscellaneous info.\n+    i = *wr.pos;\n+    encode_misc_info(&ecx, crate, &mut ebml_w);\n+    ecx.stats.misc_bytes = *wr.pos - i;\n+\n     // Encode and index the items.\n     ebml_w.start_tag(tag_items);\n     i = *wr.pos;\n@@ -1514,7 +1634,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n     ecx.stats.total_bytes = *wr.pos;\n \n     if (tcx.sess.meta_stats()) {\n-        for wr.bytes.each |e| {\n+        for wr.bytes.iter().advance |e| {\n             if *e == 0 {\n                 ecx.stats.zero_bytes += 1;\n             }\n@@ -1526,6 +1646,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n         io::println(fmt!(\"       dep bytes: %u\", ecx.stats.dep_bytes));\n         io::println(fmt!(\" lang item bytes: %u\", ecx.stats.lang_item_bytes));\n         io::println(fmt!(\" link args bytes: %u\", ecx.stats.link_args_bytes));\n+        io::println(fmt!(\"      misc bytes: %u\", ecx.stats.misc_bytes));\n         io::println(fmt!(\"      item bytes: %u\", ecx.stats.item_bytes));\n         io::println(fmt!(\"     index bytes: %u\", ecx.stats.index_bytes));\n         io::println(fmt!(\"      zero bytes: %u\", ecx.stats.zero_bytes));\n@@ -1548,7 +1669,6 @@ pub fn encoded_ty(tcx: ty::ctxt, t: ty::t) -> ~str {\n         diag: tcx.diag,\n         ds: def_to_str,\n         tcx: tcx,\n-        reachable: |_id| false,\n         abbrevs: tyencode::ac_no_abbrevs};\n     do io::with_str_writer |wr| {\n         tyencode::enc_ty(wr, cx, t);"}, {"sha": "28866fd568a7829bc0d10566c84f9c89f0938552", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n \n-use core::option;\n-use core::os;\n-use core::result;\n-use core::str;\n+use std::option;\n+use std::os;\n+use std::result;\n+use std::str;\n \n // A module for searching for libraries\n // FIXME (#2658): I'm not happy how this module turned out. Should\n@@ -48,7 +47,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n             debug!(\"filesearch: searching additional lib search paths [%?]\",\n                    self.addl_lib_search_paths.len());\n             // a little weird\n-            self.addl_lib_search_paths.each(f);\n+            self.addl_lib_search_paths.iter().advance(|path| f(path));\n \n             debug!(\"filesearch: searching target lib path\");\n             if !f(&make_target_lib_path(self.sysroot,\n@@ -89,7 +88,8 @@ pub fn search<T:Copy>(filesearch: @FileSearch, pick: pick<T>) -> Option<T> {\n     let mut rslt = None;\n     for filesearch.for_each_lib_search_path() |lib_search_path| {\n         debug!(\"searching %s\", lib_search_path.to_str());\n-        for os::list_dir_path(lib_search_path).each |path| {\n+        let r = os::list_dir_path(lib_search_path);\n+        for r.iter().advance |path| {\n             debug!(\"testing %s\", path.to_str());\n             let maybe_picked = pick(*path);\n             if maybe_picked.is_some() {"}, {"sha": "31577e472678e0c8e4ec7b9b5fa2c0dde1d52f84", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 62, "deletions": 65, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -10,7 +10,6 @@\n \n //! Finds crate binaries and loads their metadata\n \n-use core::prelude::*;\n \n use lib::llvm::{False, llvm, mk_object_file, mk_section_iter};\n use metadata::decoder;\n@@ -24,14 +23,14 @@ use syntax::parse::token::ident_interner;\n use syntax::print::pprust;\n use syntax::{ast, attr};\n \n-use core::cast;\n-use core::io;\n-use core::option;\n-use core::os::consts::{macos, freebsd, linux, android, win32};\n-use core::ptr;\n-use core::str;\n-use core::uint;\n-use core::vec;\n+use std::cast;\n+use std::io;\n+use std::option;\n+use std::os::consts::{macos, freebsd, linux, android, win32};\n+use std::ptr;\n+use std::str;\n+use std::uint;\n+use std::vec;\n use extra::flate;\n \n pub enum os {\n@@ -89,78 +88,76 @@ fn find_library_crate_aux(\n     filesearch: @filesearch::FileSearch\n ) -> Option<(~str, @~[u8])> {\n     let crate_name = crate_name_from_metas(cx.metas);\n-    let prefix: ~str = prefix + crate_name + \"-\";\n-    let suffix: ~str = /*bad*/copy suffix;\n+    let prefix = prefix + crate_name + \"-\";\n \n     let mut matches = ~[];\n-    filesearch::search(filesearch, |path| {\n+    filesearch::search(filesearch, |path| -> Option<()> {\n         debug!(\"inspecting file %s\", path.to_str());\n-        let f: ~str = path.filename().get();\n-        if !(f.starts_with(prefix) && f.ends_with(suffix)) {\n-            debug!(\"skipping %s, doesn't look like %s*%s\", path.to_str(),\n-                   prefix, suffix);\n-            option::None::<()>\n-        } else {\n-            debug!(\"%s is a candidate\", path.to_str());\n-            match get_metadata_section(cx.os, path) {\n-              option::Some(cvec) => {\n-                if !crate_matches(cvec, cx.metas, cx.hash) {\n-                    debug!(\"skipping %s, metadata doesn't match\",\n-                           path.to_str());\n-                    option::None::<()>\n-                } else {\n-                    debug!(\"found %s with matching metadata\", path.to_str());\n-                    matches.push((path.to_str(), cvec));\n-                    option::None::<()>\n+        match path.filename() {\n+            Some(ref f) if f.starts_with(prefix) && f.ends_with(suffix) => {\n+                debug!(\"%s is a candidate\", path.to_str());\n+                match get_metadata_section(cx.os, path) {\n+                    Some(cvec) =>\n+                        if !crate_matches(cvec, cx.metas, cx.hash) {\n+                            debug!(\"skipping %s, metadata doesn't match\",\n+                                   path.to_str());\n+                            None\n+                        } else {\n+                            debug!(\"found %s with matching metadata\", path.to_str());\n+                            matches.push((path.to_str(), cvec));\n+                            None\n+                        },\n+                    _ => {\n+                        debug!(\"could not load metadata for %s\", path.to_str());\n+                        None\n+                    }\n                 }\n-              }\n-              _ => {\n-                debug!(\"could not load metadata for %s\", path.to_str());\n-                option::None::<()>\n-              }\n             }\n-        }\n-    });\n+            _ => {\n+                debug!(\"skipping %s, doesn't look like %s*%s\", path.to_str(),\n+                       prefix, suffix);\n+                None\n+            }\n+        }});\n \n-    if matches.is_empty() {\n-        None\n-    } else if matches.len() == 1u {\n-        Some(/*bad*/copy matches[0])\n-    } else {\n-        cx.diag.span_err(\n-            cx.span, fmt!(\"multiple matching crates for `%s`\", crate_name));\n-        cx.diag.handler().note(\"candidates:\");\n-        for matches.each |&(ident, data)| {\n-            cx.diag.handler().note(fmt!(\"path: %s\", ident));\n-            let attrs = decoder::get_crate_attributes(data);\n-            note_linkage_attrs(cx.intr, cx.diag, attrs);\n+    match matches.len() {\n+        0 => None,\n+        1 => Some(matches[0]),\n+        _ => {\n+            cx.diag.span_err(\n+                    cx.span, fmt!(\"multiple matching crates for `%s`\", crate_name));\n+                cx.diag.handler().note(\"candidates:\");\n+                for matches.iter().advance |&(ident, data)| {\n+                    cx.diag.handler().note(fmt!(\"path: %s\", ident));\n+                    let attrs = decoder::get_crate_attributes(data);\n+                    note_linkage_attrs(cx.intr, cx.diag, attrs);\n+                }\n+                cx.diag.handler().abort_if_errors();\n+                None\n+            }\n         }\n-        cx.diag.handler().abort_if_errors();\n-        None\n-    }\n }\n \n pub fn crate_name_from_metas(metas: &[@ast::meta_item]) -> @str {\n-    let name_items = attr::find_meta_items_by_name(metas, \"name\");\n-    match name_items.last_opt() {\n-        Some(i) => {\n-            match attr::get_meta_item_value_str(*i) {\n-                Some(n) => n,\n-                // FIXME (#2406): Probably want a warning here since the user\n-                // is using the wrong type of meta item.\n-                _ => fail!()\n-            }\n+    for metas.iter().advance |m| {\n+        match m.node {\n+            ast::meta_name_value(s, ref l) if s == @\"name\" =>\n+                match l.node {\n+                    ast::lit_str(s) => return s,\n+                    _ => ()\n+                },\n+            _ => ()\n         }\n-        None => fail!(\"expected to find the crate name\")\n     }\n+    fail!(\"expected to find the crate name\")\n }\n \n pub fn note_linkage_attrs(intr: @ident_interner,\n                           diag: @span_handler,\n                           attrs: ~[ast::attribute]) {\n-    for attr::find_linkage_metas(attrs).each |mi| {\n-        diag.handler().note(fmt!(\"meta: %s\",\n-              pprust::meta_item_to_str(*mi,intr)));\n+    let r = attr::find_linkage_metas(attrs);\n+    for r.iter().advance |mi| {\n+        diag.handler().note(fmt!(\"meta: %s\", pprust::meta_item_to_str(*mi,intr)));\n     }\n }\n \n@@ -182,7 +179,7 @@ pub fn metadata_matches(extern_metas: &[@ast::meta_item],\n     debug!(\"matching %u metadata requirements against %u items\",\n            local_metas.len(), extern_metas.len());\n \n-    for local_metas.each |needed| {\n+    for local_metas.iter().advance |needed| {\n         if !attr::contains(extern_metas, *needed) {\n             return false;\n         }"}, {"sha": "c1fbde524c04722f13c0fb6a6d5a3b3edd4ec999", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -14,13 +14,11 @@\n // tjc note: Would be great to have a `match check` macro equivalent\n // for some of these\n \n-use core::prelude::*;\n \n use middle::ty;\n \n-use core::str;\n-use core::uint;\n-use core::vec;\n+use std::str;\n+use std::uint;\n use syntax::abi::AbiSet;\n use syntax::abi;\n use syntax::ast;\n@@ -190,11 +188,11 @@ fn parse_trait_store(st: &mut PState) -> ty::TraitStore {\n fn parse_substs(st: &mut PState, conv: conv_did) -> ty::substs {\n     let self_r = parse_opt(st, |st| parse_region(st) );\n \n-    let self_ty = parse_opt(st, |st| parse_ty(st, conv) );\n+    let self_ty = parse_opt(st, |st| parse_ty(st, |x,y| conv(x,y)) );\n \n     assert_eq!(next(st), '[');\n     let mut params: ~[ty::t] = ~[];\n-    while peek(st) != ']' { params.push(parse_ty(st, conv)); }\n+    while peek(st) != ']' { params.push(parse_ty(st, |x,y| conv(x,y))); }\n     st.pos = st.pos + 1u;\n \n     return ty::substs {\n@@ -262,15 +260,17 @@ fn parse_opt<T>(st: &mut PState, f: &fn(&mut PState) -> T) -> Option<T> {\n fn parse_str(st: &mut PState, term: char) -> ~str {\n     let mut result = ~\"\";\n     while peek(st) != term {\n-        result += str::from_byte(next_byte(st));\n+        unsafe {\n+            str::raw::push_byte(&mut result, next_byte(st));\n+        }\n     }\n     next(st);\n     return result;\n }\n \n fn parse_trait_ref(st: &mut PState, conv: conv_did) -> ty::TraitRef {\n-    let def = parse_def(st, NominalType, conv);\n-    let substs = parse_substs(st, conv);\n+    let def = parse_def(st, NominalType, |x,y| conv(x,y));\n+    let substs = parse_substs(st, |x,y| conv(x,y));\n     ty::TraitRef {def_id: def, substs: substs}\n }\n \n@@ -300,19 +300,20 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n       'c' => return ty::mk_char(),\n       't' => {\n         assert_eq!(next(st), '[');\n-        let def = parse_def(st, NominalType, conv);\n-        let substs = parse_substs(st, conv);\n+        let def = parse_def(st, NominalType, |x,y| conv(x,y));\n+        let substs = parse_substs(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n         return ty::mk_enum(st.tcx, def, substs);\n       }\n       'x' => {\n         assert_eq!(next(st), '[');\n-        let def = parse_def(st, NominalType, conv);\n-        let substs = parse_substs(st, conv);\n+        let def = parse_def(st, NominalType, |x,y| conv(x,y));\n+        let substs = parse_substs(st, |x,y| conv(x,y));\n         let store = parse_trait_store(st);\n         let mt = parse_mutability(st);\n+        let bounds = parse_bounds(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n-        return ty::mk_trait(st.tcx, def, substs, store, mt);\n+        return ty::mk_trait(st.tcx, def, substs, store, mt, bounds.builtin_bounds);\n       }\n       'p' => {\n         let did = parse_def(st, TypeParameter, conv);\n@@ -344,7 +345,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n       'T' => {\n         assert_eq!(next(st), '[');\n         let mut params = ~[];\n-        while peek(st) != ']' { params.push(parse_ty(st, conv)); }\n+        while peek(st) != ']' { params.push(parse_ty(st, |x,y| conv(x,y))); }\n         st.pos = st.pos + 1u;\n         return ty::mk_tup(st.tcx, params);\n       }\n@@ -378,15 +379,15 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         }\n       }\n       '\"' => {\n-        let _ = parse_def(st, TypeWithId, conv);\n-        let inner = parse_ty(st, conv);\n+        let _ = parse_def(st, TypeWithId, |x,y| conv(x,y));\n+        let inner = parse_ty(st, |x,y| conv(x,y));\n         inner\n       }\n       'B' => ty::mk_opaque_box(st.tcx),\n       'a' => {\n           assert_eq!(next(st), '[');\n-          let did = parse_def(st, NominalType, conv);\n-          let substs = parse_substs(st, conv);\n+          let did = parse_def(st, NominalType, |x,y| conv(x,y));\n+          let substs = parse_substs(st, |x,y| conv(x,y));\n           assert_eq!(next(st), ']');\n           return ty::mk_struct(st.tcx, did, substs);\n       }\n@@ -439,10 +440,9 @@ fn parse_hex(st: &mut PState) -> uint {\n fn parse_purity(c: char) -> purity {\n     match c {\n       'u' => unsafe_fn,\n-      'p' => pure_fn,\n       'i' => impure_fn,\n       'c' => extern_fn,\n-      _ => fail!(\"parse_purity: bad purity\")\n+      _ => fail!(\"parse_purity: bad purity %c\", c)\n     }\n }\n \n@@ -472,8 +472,8 @@ fn parse_closure_ty(st: &mut PState, conv: conv_did) -> ty::ClosureTy {\n     let purity = parse_purity(next(st));\n     let onceness = parse_onceness(next(st));\n     let region = parse_region(st);\n-    let bounds = parse_bounds(st, conv);\n-    let sig = parse_sig(st, conv);\n+    let bounds = parse_bounds(st, |x,y| conv(x,y));\n+    let sig = parse_sig(st, |x,y| conv(x,y));\n     ty::ClosureTy {\n         purity: purity,\n         sigil: sigil,\n@@ -499,7 +499,7 @@ fn parse_sig(st: &mut PState, conv: conv_did) -> ty::FnSig {\n     assert_eq!(next(st), '[');\n     let mut inputs = ~[];\n     while peek(st) != ']' {\n-        inputs.push(parse_ty(st, conv));\n+        inputs.push(parse_ty(st, |x,y| conv(x,y)));\n     }\n     st.pos += 1u; // eat the ']'\n     let ret_ty = parse_ty(st, conv);\n@@ -518,8 +518,8 @@ pub fn parse_def_id(buf: &[u8]) -> ast::def_id {\n         fail!();\n     }\n \n-    let crate_part = vec::slice(buf, 0u, colon_idx);\n-    let def_part = vec::slice(buf, colon_idx + 1u, len);\n+    let crate_part = buf.slice(0u, colon_idx);\n+    let def_part = buf.slice(colon_idx + 1u, len);\n \n     let crate_num = match uint::parse_bytes(crate_part, 10u) {\n        Some(cn) => cn as int,\n@@ -543,8 +543,8 @@ pub fn parse_type_param_def_data(data: &[u8], start: uint,\n }\n \n fn parse_type_param_def(st: &mut PState, conv: conv_did) -> ty::TypeParameterDef {\n-    ty::TypeParameterDef {def_id: parse_def(st, NominalType, conv),\n-                          bounds: @parse_bounds(st, conv)}\n+    ty::TypeParameterDef {def_id: parse_def(st, NominalType, |x,y| conv(x,y)),\n+                          bounds: @parse_bounds(st, |x,y| conv(x,y))}\n }\n \n fn parse_bounds(st: &mut PState, conv: conv_did) -> ty::ParamBounds {\n@@ -555,13 +555,13 @@ fn parse_bounds(st: &mut PState, conv: conv_did) -> ty::ParamBounds {\n     loop {\n         match next(st) {\n             'S' => {\n-                param_bounds.builtin_bounds.add(ty::BoundOwned);\n+                param_bounds.builtin_bounds.add(ty::BoundSend);\n             }\n             'C' => {\n                 param_bounds.builtin_bounds.add(ty::BoundCopy);\n             }\n             'K' => {\n-                param_bounds.builtin_bounds.add(ty::BoundConst);\n+                param_bounds.builtin_bounds.add(ty::BoundFreeze);\n             }\n             'O' => {\n                 param_bounds.builtin_bounds.add(ty::BoundStatic);\n@@ -570,7 +570,7 @@ fn parse_bounds(st: &mut PState, conv: conv_did) -> ty::ParamBounds {\n                 param_bounds.builtin_bounds.add(ty::BoundSized);\n             }\n             'I' => {\n-                param_bounds.trait_bounds.push(@parse_trait_ref(st, conv));\n+                param_bounds.trait_bounds.push(@parse_trait_ref(st, |x,y| conv(x,y)));\n             }\n             '.' => {\n                 return param_bounds;"}, {"sha": "1295653f806c66e8f71283f0294109c7a0a3b5f3", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -10,15 +10,14 @@\n \n // Type encoding\n \n-use core::prelude::*;\n \n use middle::ty::param_ty;\n use middle::ty;\n \n-use core::hashmap::HashMap;\n-use core::io::WriterUtil;\n-use core::io;\n-use core::uint;\n+use std::hashmap::HashMap;\n+use std::io::WriterUtil;\n+use std::io;\n+use std::uint;\n use syntax::abi::AbiSet;\n use syntax::ast;\n use syntax::ast::*;\n@@ -31,7 +30,6 @@ pub struct ctxt {\n     ds: @fn(def_id) -> ~str,\n     // The type context.\n     tcx: ty::ctxt,\n-    reachable: @fn(node_id) -> bool,\n     abbrevs: abbrev_ctxt\n }\n \n@@ -125,7 +123,7 @@ fn enc_substs(w: @io::Writer, cx: @ctxt, substs: &ty::substs) {\n     do enc_opt(w, substs.self_r) |r| { enc_region(w, cx, r) }\n     do enc_opt(w, substs.self_ty) |t| { enc_ty(w, cx, t) }\n     w.write_char('[');\n-    for substs.tps.each |t| { enc_ty(w, cx, *t); }\n+    for substs.tps.iter().advance |t| { enc_ty(w, cx, *t); }\n     w.write_char(']');\n }\n \n@@ -261,18 +259,21 @@ fn enc_sty(w: @io::Writer, cx: @ctxt, st: ty::sty) {\n         enc_substs(w, cx, substs);\n         w.write_char(']');\n       }\n-      ty::ty_trait(def, ref substs, store, mt) => {\n+      ty::ty_trait(def, ref substs, store, mt, bounds) => {\n         w.write_str(&\"x[\");\n         w.write_str((cx.ds)(def));\n         w.write_char('|');\n         enc_substs(w, cx, substs);\n         enc_trait_store(w, cx, store);\n         enc_mutability(w, mt);\n+        let bounds = ty::ParamBounds {builtin_bounds: bounds,\n+                                      trait_bounds: ~[]};\n+        enc_bounds(w, cx, &bounds);\n         w.write_char(']');\n       }\n       ty::ty_tup(ts) => {\n         w.write_str(&\"T[\");\n-        for ts.each |t| { enc_ty(w, cx, *t); }\n+        for ts.iter().advance |t| { enc_ty(w, cx, *t); }\n         w.write_char(']');\n       }\n       ty::ty_box(mt) => { w.write_char('@'); enc_mt(w, cx, mt); }\n@@ -347,7 +348,6 @@ fn enc_sigil(w: @io::Writer, sigil: Sigil) {\n \n fn enc_purity(w: @io::Writer, p: purity) {\n     match p {\n-      pure_fn => w.write_char('p'),\n       impure_fn => w.write_char('i'),\n       unsafe_fn => w.write_char('u'),\n       extern_fn => w.write_char('c')\n@@ -389,7 +389,7 @@ fn enc_closure_ty(w: @io::Writer, cx: @ctxt, ft: &ty::ClosureTy) {\n \n fn enc_fn_sig(w: @io::Writer, cx: @ctxt, fsig: &ty::FnSig) {\n     w.write_char('[');\n-    for fsig.inputs.each |ty| {\n+    for fsig.inputs.iter().advance |ty| {\n         enc_ty(w, cx, *ty);\n     }\n     w.write_char(']');\n@@ -399,15 +399,15 @@ fn enc_fn_sig(w: @io::Writer, cx: @ctxt, fsig: &ty::FnSig) {\n fn enc_bounds(w: @io::Writer, cx: @ctxt, bs: &ty::ParamBounds) {\n     for bs.builtin_bounds.each |bound| {\n         match bound {\n-            ty::BoundOwned => w.write_char('S'),\n+            ty::BoundSend => w.write_char('S'),\n             ty::BoundCopy => w.write_char('C'),\n-            ty::BoundConst => w.write_char('K'),\n+            ty::BoundFreeze => w.write_char('K'),\n             ty::BoundStatic => w.write_char('O'),\n             ty::BoundSized => w.write_char('Z'),\n         }\n     }\n \n-    for bs.trait_bounds.each |&tp| {\n+    for bs.trait_bounds.iter().advance |&tp| {\n         w.write_char('I');\n         enc_trait_ref(w, cx, tp);\n     }"}, {"sha": "c6d7314f1cd9fd2cc1f4acf58b84c09a452b74ad", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 119, "deletions": 94, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n \n use c = metadata::common;\n use cstore = metadata::cstore;\n@@ -24,8 +23,8 @@ use middle::{ty, typeck, moves};\n use middle;\n use util::ppaux::ty_to_str;\n \n-use core::at_vec;\n-use core::uint;\n+use std::at_vec;\n+use std::uint;\n use extra::ebml::reader;\n use extra::ebml;\n use extra::serialize;\n@@ -43,7 +42,7 @@ use syntax::parse::token;\n use syntax;\n use writer = extra::ebml::writer;\n \n-use core::cast;\n+use std::cast;\n \n #[cfg(test)] use syntax::parse;\n #[cfg(test)] use syntax::print::pprust;\n@@ -319,15 +318,10 @@ fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n     });\n \n     match *ii {\n-      ast::ii_item(i) => {\n-        ast::ii_item(fld.fold_item(i).get()) //hack: we're not dropping items\n-      }\n-      ast::ii_method(d, m) => {\n-        ast::ii_method(d, fld.fold_method(m))\n-      }\n-      ast::ii_foreign(i) => {\n-        ast::ii_foreign(fld.fold_foreign_item(i))\n-      }\n+        //hack: we're not dropping items\n+        ast::ii_item(i) => ast::ii_item(fld.fold_item(i).get()),\n+        ast::ii_method(d, m) => ast::ii_method(d, fld.fold_method(m)),\n+        ast::ii_foreign(i) => ast::ii_foreign(fld.fold_foreign_item(i))\n     }\n }\n \n@@ -346,16 +340,10 @@ fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n     });\n \n     match ii {\n-      ast::ii_item(i) => {\n-        ast::ii_item(fld.fold_item(i).get())\n-      }\n-      ast::ii_method(d, m) => {\n-        ast::ii_method(xcx.tr_def_id(d), fld.fold_method(m))\n-      }\n-      ast::ii_foreign(i) => {\n-        ast::ii_foreign(fld.fold_foreign_item(i))\n-      }\n-     }\n+        ast::ii_item(i) => ast::ii_item(fld.fold_item(i).get()),\n+        ast::ii_method(d, m) => ast::ii_method(xcx.tr_def_id(d), fld.fold_method(m)),\n+        ast::ii_foreign(i) => ast::ii_foreign(fld.fold_foreign_item(i)),\n+    }\n }\n \n // ______________________________________________________________________\n@@ -374,22 +362,25 @@ fn decode_def(xcx: @ExtendedDecodeContext, doc: ebml::Doc) -> ast::def {\n impl tr for ast::def {\n     fn tr(&self, xcx: @ExtendedDecodeContext) -> ast::def {\n         match *self {\n-          ast::def_fn(did, p) => { ast::def_fn(did.tr(xcx), p) }\n+          ast::def_fn(did, p) => ast::def_fn(did.tr(xcx), p),\n           ast::def_static_method(did, did2_opt, p) => {\n             ast::def_static_method(did.tr(xcx),\n                                    did2_opt.map(|did2| did2.tr(xcx)),\n                                    p)\n           }\n+          ast::def_method(did0, did1) => {\n+            ast::def_method(did0.tr(xcx), did1.map(|did1| did1.tr(xcx)))\n+          }\n           ast::def_self_ty(nid) => { ast::def_self_ty(xcx.tr_id(nid)) }\n           ast::def_self(nid, i) => { ast::def_self(xcx.tr_id(nid), i) }\n           ast::def_mod(did) => { ast::def_mod(did.tr(xcx)) }\n           ast::def_foreign_mod(did) => { ast::def_foreign_mod(did.tr(xcx)) }\n-          ast::def_const(did) => { ast::def_const(did.tr(xcx)) }\n+          ast::def_static(did, m) => { ast::def_static(did.tr(xcx), m) }\n           ast::def_arg(nid, b) => { ast::def_arg(xcx.tr_id(nid), b) }\n           ast::def_local(nid, b) => { ast::def_local(xcx.tr_id(nid), b) }\n           ast::def_variant(e_did, v_did) => {\n             ast::def_variant(e_did.tr(xcx), v_did.tr(xcx))\n-          }\n+          },\n           ast::def_trait(did) => ast::def_trait(did.tr(xcx)),\n           ast::def_ty(did) => ast::def_ty(did.tr(xcx)),\n           ast::def_prim_ty(p) => ast::def_prim_ty(p),\n@@ -402,9 +393,7 @@ impl tr for ast::def {\n                            xcx.tr_id(nid2),\n                            xcx.tr_id(nid3))\n           }\n-          ast::def_struct(did) => {\n-            ast::def_struct(did.tr(xcx))\n-          }\n+          ast::def_struct(did) => ast::def_struct(did.tr(xcx)),\n           ast::def_region(nid) => ast::def_region(xcx.tr_id(nid)),\n           ast::def_typaram_binder(nid) => {\n             ast::def_typaram_binder(xcx.tr_id(nid))\n@@ -419,12 +408,9 @@ impl tr for ast::def {\n \n impl tr for ty::AutoAdjustment {\n     fn tr(&self, xcx: @ExtendedDecodeContext) -> ty::AutoAdjustment {\n-        match self {\n-            &ty::AutoAddEnv(r, s) => {\n-                ty::AutoAddEnv(r.tr(xcx), s)\n-            }\n-\n-            &ty::AutoDerefRef(ref adr) => {\n+        match *self {\n+            ty::AutoAddEnv(r, s) => ty::AutoAddEnv(r.tr(xcx), s),\n+            ty::AutoDerefRef(ref adr) => {\n                 ty::AutoDerefRef(ty::AutoDerefRef {\n                     autoderefs: adr.autoderefs,\n                     autoref: adr.autoref.map(|ar| ar.tr(xcx)),\n@@ -612,8 +598,10 @@ fn encode_vtable_res(ecx: &e::EncodeContext,\n     // ty::t doesn't work, and there is no way (atm) to have\n     // hand-written encoding routines combine with auto-generated\n     // ones.  perhaps we should fix this.\n-    do ebml_w.emit_from_vec(*dr) |ebml_w, vtable_origin| {\n-        encode_vtable_origin(ecx, ebml_w, vtable_origin)\n+    do ebml_w.emit_from_vec(*dr) |ebml_w, param_tables| {\n+        do ebml_w.emit_from_vec(**param_tables) |ebml_w, vtable_origin| {\n+            encode_vtable_origin(ecx, ebml_w, vtable_origin)\n+        }\n     }\n }\n \n@@ -645,6 +633,13 @@ fn encode_vtable_origin(ecx: &e::EncodeContext,\n                 }\n             }\n           }\n+          typeck::vtable_self(def_id) => {\n+            do ebml_w.emit_enum_variant(\"vtable_self\", 2u, 1u) |ebml_w| {\n+                do ebml_w.emit_enum_variant_arg(0u) |ebml_w| {\n+                    ebml_w.emit_def_id(def_id)\n+                }\n+            }\n+          }\n         }\n     }\n }\n@@ -659,13 +654,17 @@ trait vtable_decoder_helpers {\n impl vtable_decoder_helpers for reader::Decoder {\n     fn read_vtable_res(&mut self, xcx: @ExtendedDecodeContext)\n                       -> typeck::vtable_res {\n-        @self.read_to_vec(|this| this.read_vtable_origin(xcx))\n+        @self.read_to_vec(|this|\n+           @this.read_to_vec(|this|\n+               this.read_vtable_origin(xcx)))\n     }\n \n     fn read_vtable_origin(&mut self, xcx: @ExtendedDecodeContext)\n         -> typeck::vtable_origin {\n         do self.read_enum(\"vtable_origin\") |this| {\n-            do this.read_enum_variant([\"vtable_static\", \"vtable_param\"])\n+            do this.read_enum_variant([\"vtable_static\",\n+                                       \"vtable_param\",\n+                                       \"vtable_self\"])\n                     |this, i| {\n                 match i {\n                   0 => {\n@@ -691,6 +690,13 @@ impl vtable_decoder_helpers for reader::Decoder {\n                         }\n                     )\n                   }\n+                  2 => {\n+                    typeck::vtable_self(\n+                        do this.read_enum_variant_arg(0u) |this| {\n+                            this.read_def_id(xcx)\n+                        }\n+                    )\n+                  }\n                   // hard to avoid - user input\n                   _ => fail!(\"bad enum variant\")\n                 }\n@@ -708,12 +714,12 @@ trait get_ty_str_ctxt {\n \n impl<'self> get_ty_str_ctxt for e::EncodeContext<'self> {\n     fn ty_str_ctxt(&self) -> @tyencode::ctxt {\n-        let r = self.reachable;\n-        @tyencode::ctxt {diag: self.tcx.sess.diagnostic(),\n-                        ds: e::def_to_str,\n-                        tcx: self.tcx,\n-                        reachable: |a| r.contains(&a),\n-                        abbrevs: tyencode::ac_use_abbrevs(self.type_abbrevs)}\n+        @tyencode::ctxt {\n+            diag: self.tcx.sess.diagnostic(),\n+            ds: e::def_to_str,\n+            tcx: self.tcx,\n+            abbrevs: tyencode::ac_use_abbrevs(self.type_abbrevs)\n+        }\n     }\n }\n \n@@ -1110,56 +1116,75 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                 found for id %d (orig %d)\",\n                tag, id, id0);\n \n-        if tag == (c::tag_table_moves_map as uint) {\n-            dcx.maps.moves_map.insert(id);\n-        } else {\n-            let val_doc = entry_doc.get(c::tag_table_val as uint);\n-            let mut val_dsr = reader::Decoder(val_doc);\n-            let val_dsr = &mut val_dsr;\n-            if tag == (c::tag_table_def as uint) {\n-                let def = decode_def(xcx, val_doc);\n-                dcx.tcx.def_map.insert(id, def);\n-            } else if tag == (c::tag_table_node_type as uint) {\n-                let ty = val_dsr.read_ty(xcx);\n-                debug!(\"inserting ty for node %?: %s\",\n-                       id, ty_to_str(dcx.tcx, ty));\n-                dcx.tcx.node_types.insert(id as uint, ty);\n-            } else if tag == (c::tag_table_node_type_subst as uint) {\n-                let tys = val_dsr.read_tys(xcx);\n-                dcx.tcx.node_type_substs.insert(id, tys);\n-            } else if tag == (c::tag_table_freevars as uint) {\n-                let fv_info = @val_dsr.read_to_vec(|val_dsr| {\n-                    @val_dsr.read_freevar_entry(xcx)\n-                });\n-                dcx.tcx.freevars.insert(id, fv_info);\n-            } else if tag == (c::tag_table_tcache as uint) {\n-                let tpbt = val_dsr.read_ty_param_bounds_and_ty(xcx);\n-                let lid = ast::def_id { crate: ast::local_crate, node: id };\n-                dcx.tcx.tcache.insert(lid, tpbt);\n-            } else if tag == (c::tag_table_param_defs as uint) {\n-                let bounds = val_dsr.read_type_param_def(xcx);\n-                dcx.tcx.ty_param_defs.insert(id, bounds);\n-            } else if tag == (c::tag_table_method_map as uint) {\n-                dcx.maps.method_map.insert(\n-                    id,\n-                    val_dsr.read_method_map_entry(xcx));\n-            } else if tag == (c::tag_table_vtable_map as uint) {\n-                dcx.maps.vtable_map.insert(id,\n-                                           val_dsr.read_vtable_res(xcx));\n-            } else if tag == (c::tag_table_adjustments as uint) {\n-                let adj: @ty::AutoAdjustment = @Decodable::decode(val_dsr);\n-                adj.tr(xcx);\n-                dcx.tcx.adjustments.insert(id, adj);\n-            } else if tag == (c::tag_table_capture_map as uint) {\n-                let cvars =\n-                    at_vec::to_managed_consume(\n-                        val_dsr.read_to_vec(\n-                            |val_dsr| val_dsr.read_capture_var(xcx)));\n-                dcx.maps.capture_map.insert(id, cvars);\n-            } else {\n+        match c::astencode_tag::from_uint(tag) {\n+            None => {\n                 xcx.dcx.tcx.sess.bug(\n                     fmt!(\"unknown tag found in side tables: %x\", tag));\n             }\n+            Some(value) => if value == c::tag_table_moves_map {\n+                dcx.maps.moves_map.insert(id);\n+            } else {\n+                let val_doc = entry_doc.get(c::tag_table_val as uint);\n+                let mut val_dsr = reader::Decoder(val_doc);\n+                let val_dsr = &mut val_dsr;\n+\n+                match value {\n+                    c::tag_table_def => {\n+                        let def = decode_def(xcx, val_doc);\n+                        dcx.tcx.def_map.insert(id, def);\n+                    }\n+                    c::tag_table_node_type => {\n+                        let ty = val_dsr.read_ty(xcx);\n+                        debug!(\"inserting ty for node %?: %s\",\n+                               id, ty_to_str(dcx.tcx, ty));\n+                        dcx.tcx.node_types.insert(id as uint, ty);\n+                    }\n+                    c::tag_table_node_type_subst => {\n+                        let tys = val_dsr.read_tys(xcx);\n+                        dcx.tcx.node_type_substs.insert(id, tys);\n+                    }\n+                    c::tag_table_freevars => {\n+                        let fv_info = @val_dsr.read_to_vec(|val_dsr| {\n+                            @val_dsr.read_freevar_entry(xcx)\n+                        });\n+                        dcx.tcx.freevars.insert(id, fv_info);\n+                    }\n+                    c::tag_table_tcache => {\n+                        let tpbt = val_dsr.read_ty_param_bounds_and_ty(xcx);\n+                        let lid = ast::def_id { crate: ast::local_crate, node: id };\n+                        dcx.tcx.tcache.insert(lid, tpbt);\n+                    }\n+                    c::tag_table_param_defs => {\n+                        let bounds = val_dsr.read_type_param_def(xcx);\n+                        dcx.tcx.ty_param_defs.insert(id, bounds);\n+                    }\n+                    c::tag_table_method_map => {\n+                        dcx.maps.method_map.insert(\n+                            id,\n+                            val_dsr.read_method_map_entry(xcx));\n+                    }\n+                    c::tag_table_vtable_map => {\n+                        dcx.maps.vtable_map.insert(id,\n+                                                   val_dsr.read_vtable_res(xcx));\n+                    }\n+                    c::tag_table_adjustments => {\n+                        let adj: @ty::AutoAdjustment = @Decodable::decode(val_dsr);\n+                        adj.tr(xcx);\n+                        dcx.tcx.adjustments.insert(id, adj);\n+                    }\n+                    c::tag_table_capture_map => {\n+                        let cvars =\n+                            at_vec::to_managed_consume(\n+                                val_dsr.read_to_vec(\n+                                    |val_dsr| val_dsr.read_capture_var(xcx)));\n+                        dcx.maps.capture_map.insert(id, cvars);\n+                    }\n+                    _ => {\n+                        xcx.dcx.tcx.sess.bug(\n+                            fmt!(\"unknown tag found in side tables: %x\", tag));\n+                    }\n+                }\n+            }\n         }\n \n         debug!(\">< Side table doc loaded\");\n@@ -1217,7 +1242,7 @@ fn mk_ctxt() -> @fake_ext_ctxt {\n \n #[cfg(test)]\n fn roundtrip(in_item: Option<@ast::item>) {\n-    use core::io;\n+    use std::io;\n \n     let in_item = in_item.get();\n     let bytes = do io::with_bytes_writer |wr| {"}, {"sha": "b2e303d40eecf4add0d2e8318285eb4d9cd10188", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -17,10 +17,9 @@\n // 3. assignments do not affect things loaned out as immutable\n // 4. moves do not affect things loaned out in any way\n \n-use core::prelude::*;\n \n-use core::hashmap::HashSet;\n-use core::uint;\n+use std::hashmap::HashSet;\n+use std::uint;\n use mc = middle::mem_categorization;\n use middle::borrowck::*;\n use middle::moves;\n@@ -118,7 +117,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         //! given `loan_path`\n \n         for self.each_in_scope_loan(scope_id) |loan| {\n-            for loan.restrictions.each |restr| {\n+            for loan.restrictions.iter().advance |restr| {\n                 if restr.loan_path == loan_path {\n                     if !op(loan, restr) {\n                         return false;\n@@ -152,7 +151,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         debug!(\"new_loan_indices = %?\", new_loan_indices);\n \n         for self.each_issued_loan(scope_id) |issued_loan| {\n-            for new_loan_indices.each |&new_loan_index| {\n+            for new_loan_indices.iter().advance |&new_loan_index| {\n                 let new_loan = &self.all_loans[new_loan_index];\n                 self.report_error_if_loans_conflict(issued_loan, new_loan);\n             }\n@@ -210,7 +209,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         };\n         debug!(\"illegal_if=%?\", illegal_if);\n \n-        for loan1.restrictions.each |restr| {\n+        for loan1.restrictions.iter().advance |restr| {\n             if !restr.set.intersects(illegal_if) { loop; }\n             if restr.loan_path != loan2.loan_path { loop; }\n \n@@ -634,7 +633,7 @@ fn check_loans_in_fn<'a>(fk: &visit::fn_kind,\n                                 closure_id: ast::node_id,\n                                 span: span) {\n         let cap_vars = this.bccx.capture_map.get(&closure_id);\n-        for cap_vars.each |cap_var| {\n+        for cap_vars.iter().advance |cap_var| {\n             match cap_var.mode {\n                 moves::CapRef | moves::CapCopy => {\n                     let var_id = ast_util::def_id_of_def(cap_var.def).node;"}, {"sha": "8bb5c4620ef78e196467fa77d3561fcadc557e43", "filename": "src/librustc/middle/borrowck/doc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -359,7 +359,7 @@ of its owner:\n     LIFETIME(LV.f, LT, MQ)              // L-Field\n       LIFETIME(LV, LT, MQ)\n \n-    LIFETIME(*LV, LT, MQ)               // L-Deref-Owned\n+    LIFETIME(*LV, LT, MQ)               // L-Deref-Send\n       TYPE(LV) = ~Ty\n       LIFETIME(LV, LT, MQ)\n \n@@ -504,7 +504,7 @@ must prevent the owned pointer `LV` from being mutated, which means\n that we always add `MUTATE` and `CLAIM` to the restriction set imposed\n on `LV`:\n \n-    RESTRICTIONS(*LV, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Owned-Pointer\n+    RESTRICTIONS(*LV, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Send-Pointer\n       TYPE(LV) = ~Ty\n       RESTRICTIONS(LV, ACTIONS|MUTATE|CLAIM) = RS\n \n@@ -539,14 +539,14 @@ mutable borrowed pointers.\n \n ### Restrictions for loans of const aliasable pointees\n \n-Const pointers are read-only. There may be `&mut` or `&` aliases, and\n+Freeze pointers are read-only. There may be `&mut` or `&` aliases, and\n we can not prevent *anything* but moves in that case. So the\n `RESTRICTIONS` function is only defined if `ACTIONS` is the empty set.\n Because moves from a `&const` or `@const` lvalue are never legal, it\n is not necessary to add any restrictions at all to the final\n result.\n \n-    RESTRICTIONS(*LV, []) = []                         // R-Deref-Const-Borrowed\n+    RESTRICTIONS(*LV, []) = []                         // R-Deref-Freeze-Borrowed\n       TYPE(LV) = &const Ty or @const Ty\n \n ### Restrictions for loans of mutable borrowed pointees"}, {"sha": "c9ea9e2be66ee27efb8bd9d65e9df34516cec13f", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -12,7 +12,6 @@\n  * Computes moves.\n  */\n \n-use core::prelude::*;\n use mc = middle::mem_categorization;\n use middle::borrowck::*;\n use middle::borrowck::move_data::*;\n@@ -71,7 +70,7 @@ pub fn gather_captures(bccx: @BorrowckCtxt,\n                        move_data: &mut MoveData,\n                        closure_expr: @ast::expr) {\n     let captured_vars = bccx.capture_map.get(&closure_expr.id);\n-    for captured_vars.each |captured_var| {\n+    for captured_vars.iter().advance |captured_var| {\n         match captured_var.mode {\n             moves::CapMove => {\n                 let fvar_id = ast_util::def_id_of_def(captured_var.def).node;\n@@ -101,9 +100,7 @@ fn check_is_legal_to_move_from(bccx: @BorrowckCtxt,\n                                cmt0: mc::cmt,\n                                cmt: mc::cmt) -> bool {\n     match cmt.cat {\n-        mc::cat_stack_upvar(*) |\n         mc::cat_implicit_self(*) |\n-        mc::cat_copied_upvar(*) |\n         mc::cat_deref(_, _, mc::region_ptr(*)) |\n         mc::cat_deref(_, _, mc::gc_ptr(*)) |\n         mc::cat_deref(_, _, mc::unsafe_ptr(*)) => {\n@@ -114,6 +111,27 @@ fn check_is_legal_to_move_from(bccx: @BorrowckCtxt,\n             false\n         }\n \n+        // These are separate from the above cases for a better error message.\n+        mc::cat_stack_upvar(*) |\n+        mc::cat_copied_upvar(mc::CopiedUpvar { onceness: ast::Many, _ }) => {\n+            let once_hint = if bccx.tcx.sess.once_fns() {\n+                \" (unless the destination closure type is `once fn')\"\n+            } else {\n+                \"\"\n+            };\n+            bccx.span_err(\n+                cmt0.span,\n+                fmt!(\"cannot move out of %s%s\", bccx.cmt_to_str(cmt), once_hint));\n+            false\n+        }\n+\n+        // Can move out of captured upvars only if the destination closure\n+        // type is 'once'. 1-shot stack closures emit the copied_upvar form\n+        // (see mem_categorization.rs).\n+        mc::cat_copied_upvar(mc::CopiedUpvar { onceness: ast::Once, _ }) => {\n+            true\n+        }\n+\n         // It seems strange to allow a move out of a static item,\n         // but what happens in practice is that you have a\n         // reference to a constant with a type that should be"}, {"sha": "05fc139305c4a96e53e21f71a83151c0e502a259", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -11,7 +11,6 @@\n //! This module implements the check that the lifetime of a borrow\n //! does not exceed the lifetime of the value being borrowed.\n \n-use core::prelude::*;\n \n use middle::borrowck::*;\n use mc = middle::mem_categorization;\n@@ -109,7 +108,7 @@ impl GuaranteeLifetimeContext {\n             }\n \n             mc::cat_downcast(base) |\n-            mc::cat_deref(base, _, mc::uniq_ptr(*)) |  // L-Deref-Owned\n+            mc::cat_deref(base, _, mc::uniq_ptr(*)) |  // L-Deref-Send\n             mc::cat_interior(base, _) => {             // L-Field\n                 self.check(base, discr_scope)\n             }"}, {"sha": "26fa4924ccb523ae6b8989f1eeb7059f410e2015", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -16,7 +16,6 @@\n // their associated scopes.  In phase two, checking loans, we will then make\n // sure that all of these loans are honored.\n \n-use core::prelude::*;\n \n use middle::borrowck::*;\n use middle::borrowck::move_data::MoveData;\n@@ -229,8 +228,8 @@ fn gather_loans_in_expr(ex: @ast::expr,\n \n       ast::expr_match(ex_v, ref arms) => {\n         let cmt = this.bccx.cat_expr(ex_v);\n-        for arms.each |arm| {\n-            for arm.pats.each |pat| {\n+        for arms.iter().advance |arm| {\n+            for arm.pats.iter().advance |pat| {\n                 this.gather_pat(cmt, *pat, arm.body.node.id, ex.id);\n             }\n         }"}, {"sha": "d5377aeb6183997c482c520ec742902566d39dd5", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -10,9 +10,8 @@\n \n //! Computes the restrictions that result from a borrow.\n \n-use core::prelude::*;\n \n-use core::vec;\n+use std::vec;\n use middle::borrowck::*;\n use mc = middle::mem_categorization;\n use middle::ty;\n@@ -103,7 +102,7 @@ impl RestrictionsContext {\n             }\n \n             mc::cat_deref(cmt_base, _, mc::uniq_ptr(*)) => {\n-                // R-Deref-Owned-Pointer\n+                // R-Deref-Send-Pointer\n                 //\n                 // When we borrow the interior of an owned pointer, we\n                 // cannot permit the base to be mutated, because that\n@@ -125,7 +124,7 @@ impl RestrictionsContext {\n \n             mc::cat_deref(_, _, mc::region_ptr(m_const, _)) |\n             mc::cat_deref(_, _, mc::gc_ptr(m_const)) => {\n-                // R-Deref-Const-Borrowed\n+                // R-Deref-Freeze-Borrowed\n                 self.check_no_mutability_control(cmt, restrictions);\n                 Safe\n             }\n@@ -140,7 +139,7 @@ impl RestrictionsContext {\n                 // static errors. For example, if there is code like\n                 //\n                 //    let v = @mut ~[1, 2, 3];\n-                //    for v.each |e| {\n+                //    for v.iter().advance |e| {\n                 //        v.push(e + 1);\n                 //    }\n                 //\n@@ -152,7 +151,7 @@ impl RestrictionsContext {\n                 //\n                 //    let v = @mut ~[1, 2, 3];\n                 //    let w = v;\n-                //    for v.each |e| {\n+                //    for v.iter().advance |e| {\n                 //        w.push(e + 1);\n                 //    }\n                 //\n@@ -165,7 +164,7 @@ impl RestrictionsContext {\n                 //    }\n                 //    ...\n                 //    let v: &V = ...;\n-                //    for v.get_list().each |e| {\n+                //    for v.get_list().iter().advance |e| {\n                 //        v.get_list().push(e + 1);\n                 //    }\n                 match opt_loan_path(cmt_base) {"}, {"sha": "7d667c2043c12bf892fdd23b37fef9a35a7580c5", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -10,7 +10,6 @@\n \n /*! See doc.rs for a thorough explanation of the borrow checker */\n \n-use core::prelude::*;\n \n use mc = middle::mem_categorization;\n use middle::ty;\n@@ -21,10 +20,10 @@ use middle::dataflow::DataFlowOperator;\n use util::common::stmt_set;\n use util::ppaux::{note_and_explain_region, Repr, UserString};\n \n-use core::hashmap::{HashSet, HashMap};\n-use core::io;\n-use core::ops::{BitOr, BitAnd};\n-use core::result::{Result};\n+use std::hashmap::{HashSet, HashMap};\n+use std::io;\n+use std::ops::{BitOr, BitAnd};\n+use std::result::{Result};\n use syntax::ast;\n use syntax::ast_map;\n use syntax::visit;\n@@ -58,7 +57,7 @@ pub fn check_crate(\n     moves_map: moves::MovesMap,\n     moved_variables_set: moves::MovedVariablesSet,\n     capture_map: moves::CaptureMap,\n-    crate: @ast::crate) -> (root_map, write_guard_map)\n+    crate: &ast::crate) -> (root_map, write_guard_map)\n {\n     let bccx = @BorrowckCtxt {\n         tcx: tcx,\n@@ -132,7 +131,7 @@ fn borrowck_fn(fk: &visit::fn_kind,\n                                      LoanDataFlowOperator,\n                                      id_range,\n                                      all_loans.len());\n-            for all_loans.eachi |loan_idx, loan| {\n+            for all_loans.iter().enumerate().advance |(loan_idx, loan)| {\n                 loan_dfcx.add_gen(loan.gen_scope, loan_idx);\n                 loan_dfcx.add_kill(loan.kill_scope, loan_idx);\n             }\n@@ -507,7 +506,7 @@ impl BorrowckCtxt {\n     pub fn report_use_of_moved_value(&self,\n                                      use_span: span,\n                                      use_kind: MovedValueUseKind,\n-                                     lp: @LoanPath,\n+                                     lp: &LoanPath,\n                                      move: &move_data::Move,\n                                      moved_lp: @LoanPath) {\n         let verb = match use_kind {\n@@ -570,7 +569,7 @@ impl BorrowckCtxt {\n \n     pub fn report_reassigned_immutable_variable(&self,\n                                                 span: span,\n-                                                lp: @LoanPath,\n+                                                lp: &LoanPath,\n                                                 assign:\n                                                 &move_data::Assignment) {\n         self.tcx.sess.span_err("}, {"sha": "97fd6ca5cc439fa8b187d622ca7276f9d5549be1", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -15,10 +15,9 @@ comments in the section \"Moves and initialization\" and in `doc.rs`.\n \n */\n \n-use core::prelude::*;\n \n-use core::hashmap::{HashMap, HashSet};\n-use core::uint;\n+use std::hashmap::{HashMap, HashSet};\n+use std::uint;\n use middle::borrowck::*;\n use middle::dataflow::DataFlowContext;\n use middle::dataflow::DataFlowOperator;\n@@ -348,22 +347,22 @@ impl MoveData {\n          * killed by scoping. See `doc.rs` for more details.\n          */\n \n-        for self.moves.eachi |i, move| {\n+        for self.moves.iter().enumerate().advance |(i, move)| {\n             dfcx_moves.add_gen(move.id, i);\n         }\n \n-        for self.var_assignments.eachi |i, assignment| {\n+        for self.var_assignments.iter().enumerate().advance |(i, assignment)| {\n             dfcx_assign.add_gen(assignment.id, i);\n             self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n         }\n \n-        for self.path_assignments.each |assignment| {\n+        for self.path_assignments.iter().advance |assignment| {\n             self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n         }\n \n         // Kill all moves related to a variable `x` when it goes out\n         // of scope:\n-        for self.paths.each |path| {\n+        for self.paths.iter().advance |path| {\n             match *path.loan_path {\n                 LpVar(id) => {\n                     let kill_id = tcx.region_maps.encl_scope(id);\n@@ -375,7 +374,7 @@ impl MoveData {\n         }\n \n         // Kill all assignments when the variable goes out of scope:\n-        for self.var_assignments.eachi |assignment_index, assignment| {\n+        for self.var_assignments.iter().enumerate().advance |(assignment_index, assignment)| {\n             match *self.path(assignment.path).loan_path {\n                 LpVar(id) => {\n                     let kill_id = tcx.region_maps.encl_scope(id);\n@@ -411,7 +410,7 @@ impl MoveData {\n \n         let mut p = self.path(index).first_child;\n         while p != InvalidMovePathIndex {\n-            if !self.each_extending_path(p, f) {\n+            if !self.each_extending_path(p, |x| f(x)) {\n                 return false;\n             }\n             p = self.path(p).next_sibling;\n@@ -507,7 +506,7 @@ impl FlowedMoveData {\n         for self.dfcx_moves.each_bit_on_entry_frozen(id) |index| {\n             let move = &self.move_data.moves[index];\n             let moved_path = move.path;\n-            if base_indices.contains(&moved_path) {\n+            if base_indices.iter().any_(|x| x == &moved_path) {\n                 // Scenario 1 or 2: `loan_path` or some base path of\n                 // `loan_path` was moved.\n                 if !f(move, self.move_data.path(moved_path).loan_path) {\n@@ -536,7 +535,7 @@ impl FlowedMoveData {\n                        -> bool {\n         //! True if `id` is the id of the LHS of an assignment\n \n-        self.move_data.assignee_ids.contains(&id)\n+        self.move_data.assignee_ids.iter().any_(|x| x == &id)\n     }\n \n     pub fn each_assignment_of(&self,"}, {"sha": "59918137467aa14a5b4081f5f516d53d570c3d8a", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n \n use driver::session::Session;\n use middle::resolve;\n@@ -21,7 +20,7 @@ use syntax::codemap;\n use syntax::{visit, ast_util, ast_map};\n \n pub fn check_crate(sess: Session,\n-                   crate: @crate,\n+                   crate: &crate,\n                    ast_map: ast_map::map,\n                    def_map: resolve::DefMap,\n                    method_map: typeck::method_map,\n@@ -43,12 +42,12 @@ pub fn check_item(sess: Session,\n                   (_is_const, v): (bool,\n                                    visit::vt<bool>)) {\n     match it.node {\n-      item_const(_, ex) => {\n+      item_static(_, _, ex) => {\n         (v.visit_expr)(ex, (true, v));\n         check_item_recursion(sess, ast_map, def_map, it);\n       }\n       item_enum(ref enum_definition, _) => {\n-        for (*enum_definition).variants.each |var| {\n+        for (*enum_definition).variants.iter().advance |var| {\n             for var.node.disr_expr.iter().advance |ex| {\n                 (v.visit_expr)(*ex, (true, v));\n             }\n@@ -92,7 +91,7 @@ pub fn check_expr(sess: Session,\n     if is_const {\n         match e.node {\n           expr_unary(_, deref, _) => { }\n-          expr_unary(_, box(_), _) | expr_unary(_, uniq(_), _) => {\n+          expr_unary(_, box(_), _) | expr_unary(_, uniq, _) => {\n             sess.span_err(e.span,\n                           \"disallowed operator in constant expression\");\n             return;\n@@ -124,7 +123,7 @@ pub fn check_expr(sess: Session,\n                              items without type parameters\");\n             }\n             match def_map.find(&e.id) {\n-              Some(&def_const(_)) |\n+              Some(&def_static(*)) |\n               Some(&def_fn(_, _)) |\n               Some(&def_variant(_, _)) |\n               Some(&def_struct(_)) => { }\n@@ -225,7 +224,7 @@ pub fn check_item_recursion(sess: Session,\n     (visitor.visit_item)(it, (env, visitor));\n \n     fn visit_item(it: @item, (env, v): (env, visit::vt<env>)) {\n-        if env.idstack.contains(&(it.id)) {\n+        if env.idstack.iter().any_(|x| x == &(it.id)) {\n             env.sess.span_fatal(env.root_it.span, \"recursive constant\");\n         }\n         env.idstack.push(it.id);\n@@ -235,22 +234,17 @@ pub fn check_item_recursion(sess: Session,\n \n     fn visit_expr(e: @expr, (env, v): (env, visit::vt<env>)) {\n         match e.node {\n-          expr_path(*) => {\n-            match env.def_map.find(&e.id) {\n-              Some(&def_const(def_id)) => {\n-                if ast_util::is_local(def_id) {\n-                  match env.ast_map.get_copy(&def_id.node) {\n-                    ast_map::node_item(it, _) => {\n-                      (v.visit_item)(it, (env, v));\n-                    }\n-                    _ => fail!(\"const not bound to an item\")\n-                  }\n-                }\n-              }\n-              _ => ()\n-            }\n-          }\n-          _ => ()\n+            expr_path(*) => match env.def_map.find(&e.id) {\n+                Some(&def_static(def_id, _)) if ast_util::is_local(def_id) =>\n+                    match env.ast_map.get_copy(&def_id.node) {\n+                        ast_map::node_item(it, _) => {\n+                            (v.visit_item)(it, (env, v));\n+                        }\n+                        _ => fail!(\"const not bound to an item\")\n+                    },\n+                _ => ()\n+            },\n+            _ => ()\n         }\n         visit::visit_expr(e, (env, v));\n     }"}, {"sha": "190602e815d3da22e3dcdf60cb96aa4f1086f569", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -19,7 +19,7 @@ pub struct Context {\n     can_ret: bool\n }\n \n-pub fn check_crate(tcx: ty::ctxt, crate: @crate) {\n+pub fn check_crate(tcx: ty::ctxt, crate: &crate) {\n     visit::visit_crate(crate,\n                        (Context { in_loop: false, can_ret: true },\n                        visit::mk_vt(@visit::Visitor {"}, {"sha": "72896258b2d326052e20bfc8e56369fc652b5bc7", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 48, "deletions": 49, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n \n use middle::const_eval::{compare_const_vals, lookup_const_by_id};\n use middle::const_eval::{eval_const_expr, const_val, const_bool};\n@@ -19,8 +18,8 @@ use middle::typeck::method_map;\n use middle::moves;\n use util::ppaux::ty_to_str;\n \n-use core::uint;\n-use core::vec;\n+use std::uint;\n+use std::vec;\n use extra::sort;\n use syntax::ast::*;\n use syntax::ast_util::{unguarded_pat, walk_pat};\n@@ -36,7 +35,7 @@ pub struct MatchCheckCtxt {\n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: method_map,\n                    moves_map: moves::MovesMap,\n-                   crate: @crate) {\n+                   crate: &crate) {\n     let cx = @MatchCheckCtxt {tcx: tcx,\n                               method_map: method_map,\n                               moves_map: moves_map};\n@@ -50,7 +49,7 @@ pub fn check_crate(tcx: ty::ctxt,\n     tcx.sess.abort_if_errors();\n }\n \n-pub fn expr_is_non_moving_lvalue(cx: @MatchCheckCtxt, expr: @expr) -> bool {\n+pub fn expr_is_non_moving_lvalue(cx: &MatchCheckCtxt, expr: &expr) -> bool {\n     if !ty::expr_is_lval(cx.tcx, cx.method_map, expr) {\n         return false;\n     }\n@@ -64,7 +63,7 @@ pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, (s, v): ((), visit::vt<()>)) {\n       expr_match(scrut, ref arms) => {\n         // First, check legality of move bindings.\n         let is_non_moving_lvalue = expr_is_non_moving_lvalue(cx, ex);\n-        for arms.each |arm| {\n+        for arms.iter().advance |arm| {\n             check_legality_of_move_bindings(cx,\n                                             is_non_moving_lvalue,\n                                             arm.guard.is_some(),\n@@ -108,10 +107,10 @@ pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, (s, v): ((), visit::vt<()>)) {\n }\n \n // Check for unreachable patterns\n-pub fn check_arms(cx: @MatchCheckCtxt, arms: &[arm]) {\n+pub fn check_arms(cx: &MatchCheckCtxt, arms: &[arm]) {\n     let mut seen = ~[];\n-    for arms.each |arm| {\n-        for arm.pats.each |pat| {\n+    for arms.iter().advance |arm| {\n+        for arm.pats.iter().advance |pat| {\n             let v = ~[*pat];\n             match is_useful(cx, &seen, v) {\n               not_useful => {\n@@ -131,7 +130,7 @@ pub fn raw_pat(p: @pat) -> @pat {\n     }\n }\n \n-pub fn check_exhaustive(cx: @MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n+pub fn check_exhaustive(cx: &MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n     assert!((!pats.is_empty()));\n     let ext = match is_useful(cx, &pats.map(|p| ~[*p]), [wild()]) {\n         not_useful => {\n@@ -155,7 +154,7 @@ pub fn check_exhaustive(cx: @MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n                     };\n                     let variants = ty::enum_variants(cx.tcx, id);\n \n-                    match variants.find(|v| v.id == vid) {\n+                    match variants.iter().find_(|v| v.id == vid) {\n                         Some(v) => Some(cx.tcx.sess.str_of(v.name)),\n                         None => {\n                             fail!(\"check_exhaustive: bad variant in ctor\")\n@@ -205,10 +204,10 @@ pub enum ctor {\n \n // Note: is_useful doesn't work on empty types, as the paper notes.\n // So it assumes that v is non-empty.\n-pub fn is_useful(cx: @MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n+pub fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n     if m.len() == 0u { return useful_; }\n     if m[0].len() == 0u { return not_useful; }\n-    let real_pat = match m.find(|r| r[0].id != 0) {\n+    let real_pat = match m.iter().find_(|r| r[0].id != 0) {\n       Some(r) => r[0], None => v[0]\n     };\n     let left_ty = if real_pat.id == 0 { ty::mk_nil() }\n@@ -232,7 +231,7 @@ pub fn is_useful(cx: @MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n                 }\n               }\n               ty::ty_enum(eid, _) => {\n-                for (*ty::enum_variants(cx.tcx, eid)).each |va| {\n+                for (*ty::enum_variants(cx.tcx, eid)).iter().advance |va| {\n                     match is_useful_specialized(cx, m, v, variant(va.id),\n                                                 va.args.len(), left_ty) {\n                       not_useful => (),\n@@ -281,7 +280,7 @@ pub fn is_useful(cx: @MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n     }\n }\n \n-pub fn is_useful_specialized(cx: @MatchCheckCtxt,\n+pub fn is_useful_specialized(cx: &MatchCheckCtxt,\n                              m: &matrix,\n                              v: &[@pat],\n                              ctor: ctor,\n@@ -297,14 +296,14 @@ pub fn is_useful_specialized(cx: @MatchCheckCtxt,\n     }\n }\n \n-pub fn pat_ctor_id(cx: @MatchCheckCtxt, p: @pat) -> Option<ctor> {\n+pub fn pat_ctor_id(cx: &MatchCheckCtxt, p: @pat) -> Option<ctor> {\n     let pat = raw_pat(p);\n     match pat.node {\n       pat_wild => { None }\n       pat_ident(_, _, _) | pat_enum(_, _) => {\n         match cx.tcx.def_map.find(&pat.id) {\n           Some(&def_variant(_, id)) => Some(variant(id)),\n-          Some(&def_const(did)) => {\n+          Some(&def_static(did, false)) => {\n             let const_expr = lookup_const_by_id(cx.tcx, did).get();\n             Some(val(eval_const_expr(cx.tcx, const_expr)))\n           }\n@@ -333,46 +332,46 @@ pub fn pat_ctor_id(cx: @MatchCheckCtxt, p: @pat) -> Option<ctor> {\n     }\n }\n \n-pub fn is_wild(cx: @MatchCheckCtxt, p: @pat) -> bool {\n+pub fn is_wild(cx: &MatchCheckCtxt, p: @pat) -> bool {\n     let pat = raw_pat(p);\n     match pat.node {\n       pat_wild => { true }\n       pat_ident(_, _, _) => {\n         match cx.tcx.def_map.find(&pat.id) {\n-          Some(&def_variant(_, _)) | Some(&def_const(*)) => { false }\n+          Some(&def_variant(_, _)) | Some(&def_static(*)) => { false }\n           _ => { true }\n         }\n       }\n       _ => { false }\n     }\n }\n \n-pub fn missing_ctor(cx: @MatchCheckCtxt,\n+pub fn missing_ctor(cx: &MatchCheckCtxt,\n                     m: &matrix,\n                     left_ty: ty::t)\n                  -> Option<ctor> {\n     match ty::get(left_ty).sty {\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) | ty::ty_tup(_) |\n       ty::ty_struct(*) => {\n-        for m.each |r| {\n+        for m.iter().advance |r| {\n             if !is_wild(cx, r[0]) { return None; }\n         }\n         return Some(single);\n       }\n       ty::ty_enum(eid, _) => {\n         let mut found = ~[];\n-        for m.each |r| {\n+        for m.iter().advance |r| {\n             let r = pat_ctor_id(cx, r[0]);\n             for r.iter().advance |id| {\n-                if !vec::contains(found, id) {\n+                if !found.contains(id) {\n                     found.push(/*bad*/copy *id);\n                 }\n             }\n         }\n         let variants = ty::enum_variants(cx.tcx, eid);\n         if found.len() != (*variants).len() {\n-            for (*variants).each |v| {\n-                if !found.contains(&(variant(v.id))) {\n+            for (*variants).iter().advance |v| {\n+                if !found.iter().any_(|x| x == &(variant(v.id))) {\n                     return Some(variant(v.id));\n                 }\n             }\n@@ -383,7 +382,7 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n       ty::ty_bool => {\n         let mut true_found = false;\n         let mut false_found = false;\n-        for m.each |r| {\n+        for m.iter().advance |r| {\n             match pat_ctor_id(cx, r[0]) {\n               None => (),\n               Some(val(const_bool(true))) => true_found = true,\n@@ -418,12 +417,12 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n                 }\n             }\n         );\n-        vec::dedup(&mut sorted_vec_lens);\n+        sorted_vec_lens.dedup();\n \n         let mut found_slice = false;\n         let mut next = 0;\n         let mut missing = None;\n-        for sorted_vec_lens.each |&(length, slice)| {\n+        for sorted_vec_lens.iter().advance |&(length, slice)| {\n             if length != next {\n                 missing = Some(next);\n                 break;\n@@ -449,14 +448,14 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n     }\n }\n \n-pub fn ctor_arity(cx: @MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n+pub fn ctor_arity(cx: &MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n     match ty::get(ty).sty {\n       ty::ty_tup(ref fs) => fs.len(),\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) => 1u,\n       ty::ty_enum(eid, _) => {\n           let id = match *ctor { variant(id) => id,\n           _ => fail!(\"impossible case\") };\n-        match vec::find(*ty::enum_variants(cx.tcx, eid), |v| v.id == id ) {\n+        match ty::enum_variants(cx.tcx, eid).iter().find_(|v| v.id == id ) {\n             Some(v) => v.args.len(),\n             None => fail!(\"impossible case\")\n         }\n@@ -476,7 +475,7 @@ pub fn wild() -> @pat {\n     @pat {id: 0, node: pat_wild, span: dummy_sp()}\n }\n \n-pub fn specialize(cx: @MatchCheckCtxt,\n+pub fn specialize(cx: &MatchCheckCtxt,\n                   r: &[@pat],\n                   ctor_id: &ctor,\n                   arity: uint,\n@@ -499,7 +498,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                             None\n                         }\n                     }\n-                    Some(&def_const(did)) => {\n+                    Some(&def_static(did, _)) => {\n                         let const_expr =\n                             lookup_const_by_id(cx.tcx, did).get();\n                         let e_v = eval_const_expr(cx.tcx, const_expr);\n@@ -549,7 +548,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n             }\n             pat_enum(_, args) => {\n                 match cx.tcx.def_map.get_copy(&pat_id) {\n-                    def_const(did) => {\n+                    def_static(did, _) => {\n                         let const_expr =\n                             lookup_const_by_id(cx.tcx, did).get();\n                         let e_v = eval_const_expr(cx.tcx, const_expr);\n@@ -613,7 +612,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                         if variant(variant_id) == *ctor_id {\n                             // FIXME #4731: Is this right? --pcw\n                             let args = flds.map(|ty_field| {\n-                                match flds.find(|f|\n+                                match flds.iter().find_(|f|\n                                                 f.ident == ty_field.ident) {\n                                     Some(f) => f.pat,\n                                     _ => wild()\n@@ -643,13 +642,13 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                                          ty_to_str(cx.tcx, left_ty)));\n                             }\n                         }\n-                        let args = vec::map(class_fields, |class_field| {\n-                            match flds.find(|f|\n+                        let args = class_fields.iter().transform(|class_field| {\n+                            match flds.iter().find_(|f|\n                                             f.ident == class_field.ident) {\n                                 Some(f) => f.pat,\n                                 _ => wild()\n                             }\n-                        });\n+                        }).collect();\n                         Some(vec::append(args, vec::to_owned(r.tail())))\n                     }\n                 }\n@@ -743,12 +742,12 @@ pub fn specialize(cx: @MatchCheckCtxt,\n     }\n }\n \n-pub fn default(cx: @MatchCheckCtxt, r: &[@pat]) -> Option<~[@pat]> {\n+pub fn default(cx: &MatchCheckCtxt, r: &[@pat]) -> Option<~[@pat]> {\n     if is_wild(cx, r[0]) { Some(vec::to_owned(r.tail())) }\n     else { None }\n }\n \n-pub fn check_local(cx: @MatchCheckCtxt,\n+pub fn check_local(cx: &MatchCheckCtxt,\n                    loc: @local,\n                    (s, v): ((),\n                             visit::vt<()>)) {\n@@ -766,7 +765,7 @@ pub fn check_local(cx: @MatchCheckCtxt,\n     check_legality_of_move_bindings(cx, is_lvalue, false, [ loc.node.pat ]);\n }\n \n-pub fn check_fn(cx: @MatchCheckCtxt,\n+pub fn check_fn(cx: &MatchCheckCtxt,\n                 kind: &visit::fn_kind,\n                 decl: &fn_decl,\n                 body: &blk,\n@@ -775,22 +774,22 @@ pub fn check_fn(cx: @MatchCheckCtxt,\n                 (s, v): ((),\n                          visit::vt<()>)) {\n     visit::visit_fn(kind, decl, body, sp, id, (s, v));\n-    for decl.inputs.each |input| {\n+    for decl.inputs.iter().advance |input| {\n         if is_refutable(cx, input.pat) {\n             cx.tcx.sess.span_err(input.pat.span,\n                                  \"refutable pattern in function argument\");\n         }\n     }\n }\n \n-pub fn is_refutable(cx: @MatchCheckCtxt, pat: &pat) -> bool {\n+pub fn is_refutable(cx: &MatchCheckCtxt, pat: &pat) -> bool {\n     match cx.tcx.def_map.find(&pat.id) {\n       Some(&def_variant(enum_id, _)) => {\n         if ty::enum_variants(cx.tcx, enum_id).len() != 1u {\n             return true;\n         }\n       }\n-      Some(&def_const(*)) => return true,\n+      Some(&def_static(*)) => return true,\n       _ => ()\n     }\n \n@@ -806,13 +805,13 @@ pub fn is_refutable(cx: @MatchCheckCtxt, pat: &pat) -> bool {\n       }\n       pat_lit(_) | pat_range(_, _) => { true }\n       pat_struct(_, ref fields, _) => {\n-        fields.any(|f| is_refutable(cx, f.pat))\n+        fields.iter().any_(|f| is_refutable(cx, f.pat))\n       }\n       pat_tup(ref elts) => {\n-        elts.any(|elt| is_refutable(cx, *elt))\n+        elts.iter().any_(|elt| is_refutable(cx, *elt))\n       }\n       pat_enum(_, Some(ref args)) => {\n-        args.any(|a| is_refutable(cx, *a))\n+        args.iter().any_(|a| is_refutable(cx, *a))\n       }\n       pat_enum(_,_) => { false }\n       pat_vec(*) => { true }\n@@ -821,15 +820,15 @@ pub fn is_refutable(cx: @MatchCheckCtxt, pat: &pat) -> bool {\n \n // Legality of move bindings checking\n \n-pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n+pub fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                                        is_lvalue: bool,\n                                        has_guard: bool,\n                                        pats: &[@pat]) {\n     let tcx = cx.tcx;\n     let def_map = tcx.def_map;\n     let mut by_ref_span = None;\n     let mut any_by_move = false;\n-    for pats.each |pat| {\n+    for pats.iter().advance |pat| {\n         do pat_bindings(def_map, *pat) |bm, id, span, _path| {\n             match bm {\n                 bind_by_ref(_) => {\n@@ -871,7 +870,7 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n     };\n \n     if !any_by_move { return; } // pointless micro-optimization\n-    for pats.each |pat| {\n+    for pats.iter().advance |pat| {\n         for walk_pat(*pat) |p| {\n             if pat_is_binding(def_map, p) {\n                 match p.node {"}, {"sha": "bf91b6771dcd8110cf452d4704d35cdee20dbdd5", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 32, "deletions": 79, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n \n use metadata::csearch;\n use middle::astencode;\n@@ -18,9 +17,8 @@ use middle;\n use syntax::{ast, ast_map, ast_util, visit};\n use syntax::ast::*;\n \n-use core::float;\n-use core::hashmap::{HashMap, HashSet};\n-use core::vec;\n+use std::float;\n+use std::hashmap::{HashMap, HashSet};\n \n //\n // This pass classifies expressions by their constant-ness.\n@@ -71,11 +69,11 @@ pub fn join(a: constness, b: constness) -> constness {\n     }\n }\n \n-pub fn join_all(cs: &[constness]) -> constness {\n-    cs.iter().fold(integral_const, |a, b| join(a, *b))\n+pub fn join_all<It: Iterator<constness>>(mut cs: It) -> constness {\n+    cs.fold(integral_const, |a, b| join(a, b))\n }\n \n-pub fn classify(e: @expr,\n+pub fn classify(e: &expr,\n                 tcx: ty::ctxt)\n              -> constness {\n     let did = ast_util::local_def(e.id);\n@@ -105,7 +103,7 @@ pub fn classify(e: @expr,\n \n               ast::expr_tup(ref es) |\n               ast::expr_vec(ref es, ast::m_imm) => {\n-                join_all(vec::map(*es, |e| classify(*e, tcx)))\n+                join_all(es.iter().transform(|e| classify(*e, tcx)))\n               }\n \n               ast::expr_vstore(e, vstore) => {\n@@ -119,7 +117,7 @@ pub fn classify(e: @expr,\n               }\n \n               ast::expr_struct(_, ref fs, None) => {\n-                let cs = do vec::map((*fs)) |f| {\n+                let cs = do fs.iter().transform |f| {\n                     classify(f.node.expr, tcx)\n                 };\n                 join_all(cs)\n@@ -164,9 +162,9 @@ pub fn classify(e: @expr,\n     }\n }\n \n-pub fn lookup_const(tcx: ty::ctxt, e: @expr) -> Option<@expr> {\n+pub fn lookup_const(tcx: ty::ctxt, e: &expr) -> Option<@expr> {\n     match tcx.def_map.find(&e.id) {\n-        Some(&ast::def_const(def_id)) => lookup_const_by_id(tcx, def_id),\n+        Some(&ast::def_static(def_id, false)) => lookup_const_by_id(tcx, def_id),\n         _ => None\n     }\n }\n@@ -178,7 +176,7 @@ pub fn lookup_const_by_id(tcx: ty::ctxt,\n         match tcx.items.find(&def_id.node) {\n             None => None,\n             Some(&ast_map::node_item(it, _)) => match it.node {\n-                item_const(_, const_expr) => Some(const_expr),\n+                item_static(_, ast::m_imm, const_expr) => Some(const_expr),\n                 _ => None\n             },\n             Some(_) => None\n@@ -195,15 +193,15 @@ pub fn lookup_const_by_id(tcx: ty::ctxt,\n         match csearch::maybe_get_item_ast(tcx, def_id,\n             |a, b, c, d| astencode::decode_inlined_item(a, b, maps, /*bar*/ copy c, d)) {\n             csearch::found(ast::ii_item(item)) => match item.node {\n-                item_const(_, const_expr) => Some(const_expr),\n+                item_static(_, ast::m_imm, const_expr) => Some(const_expr),\n                 _ => None\n             },\n             _ => None\n         }\n     }\n }\n \n-pub fn lookup_constness(tcx: ty::ctxt, e: @expr) -> constness {\n+pub fn lookup_constness(tcx: ty::ctxt, e: &expr) -> constness {\n     match lookup_const(tcx, e) {\n         Some(rhs) => {\n             let ty = ty::expr_ty(tcx, rhs);\n@@ -217,7 +215,7 @@ pub fn lookup_constness(tcx: ty::ctxt, e: @expr) -> constness {\n     }\n }\n \n-pub fn process_crate(crate: @ast::crate,\n+pub fn process_crate(crate: &ast::crate,\n                      tcx: ty::ctxt) {\n     let v = visit::mk_simple_visitor(@visit::SimpleVisitor {\n         visit_expr_post: |e| { classify(e, tcx); },\n@@ -239,14 +237,14 @@ pub enum const_val {\n     const_bool(bool)\n }\n \n-pub fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n+pub fn eval_const_expr(tcx: middle::ty::ctxt, e: &expr) -> const_val {\n     match eval_const_expr_partial(tcx, e) {\n         Ok(r) => r,\n         Err(s) => tcx.sess.span_fatal(e.span, s)\n     }\n }\n \n-pub fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n+pub fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: &expr)\n                             -> Result<const_val, ~str> {\n     use middle::ty;\n     fn fromb(b: bool) -> Result<const_val, ~str> { Ok(const_int(b as i64)) }\n@@ -406,7 +404,7 @@ pub fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n     }\n }\n \n-pub fn lit_to_const(lit: @lit) -> const_val {\n+pub fn lit_to_const(lit: &lit) -> const_val {\n     match lit.node {\n       lit_str(s) => const_str(s),\n       lit_int(n, _) => const_int(n),\n@@ -420,73 +418,28 @@ pub fn lit_to_const(lit: @lit) -> const_val {\n     }\n }\n \n+fn compare_vals<T : Eq + Ord>(a: T, b: T) -> Option<int> {\n+    Some(if a == b { 0 } else if a < b { -1 } else { 1 })\n+}\n pub fn compare_const_vals(a: &const_val, b: &const_val) -> Option<int> {\n-  match (a, b) {\n-    (&const_int(a), &const_int(b)) => {\n-        if a == b {\n-            Some(0)\n-        } else if a < b {\n-            Some(-1)\n-        } else {\n-            Some(1)\n-        }\n-    }\n-    (&const_uint(a), &const_uint(b)) => {\n-        if a == b {\n-            Some(0)\n-        } else if a < b {\n-            Some(-1)\n-        } else {\n-            Some(1)\n-        }\n-    }\n-    (&const_float(a), &const_float(b)) => {\n-        if a == b {\n-            Some(0)\n-        } else if a < b {\n-            Some(-1)\n-        } else {\n-            Some(1)\n-        }\n-    }\n-    (&const_str(ref a), &const_str(ref b)) => {\n-        if (*a) == (*b) {\n-            Some(0)\n-        } else if (*a) < (*b) {\n-            Some(-1)\n-        } else {\n-            Some(1)\n-        }\n-    }\n-    (&const_bool(a), &const_bool(b)) => {\n-        if a == b {\n-            Some(0)\n-        } else if a < b {\n-            Some(-1)\n-        } else {\n-            Some(1)\n-        }\n-    }\n-    _ => {\n-        None\n+    match (a, b) {\n+        (&const_int(a), &const_int(b)) => compare_vals(a, b),\n+        (&const_uint(a), &const_uint(b)) => compare_vals(a, b),\n+        (&const_float(a), &const_float(b)) => compare_vals(a, b),\n+        (&const_str(a), &const_str(b)) => compare_vals(a, b),\n+        (&const_bool(a), &const_bool(b)) => compare_vals(a, b),\n+        _ => None\n     }\n-  }\n }\n \n-pub fn compare_lit_exprs(tcx: middle::ty::ctxt, a: @expr, b: @expr) -> Option<int> {\n+pub fn compare_lit_exprs(tcx: middle::ty::ctxt, a: &expr, b: &expr) -> Option<int> {\n     compare_const_vals(&eval_const_expr(tcx, a), &eval_const_expr(tcx, b))\n }\n \n-pub fn lit_expr_eq(tcx: middle::ty::ctxt, a: @expr, b: @expr) -> Option<bool> {\n-    match compare_lit_exprs(tcx, a, b) {\n-        Some(val) => Some(val == 0),\n-        None =>  None,\n-    }\n+pub fn lit_expr_eq(tcx: middle::ty::ctxt, a: &expr, b: &expr) -> Option<bool> {\n+    compare_lit_exprs(tcx, a, b).map(|&val| val == 0)\n }\n \n-pub fn lit_eq(a: @lit, b: @lit) -> Option<bool> {\n-    match compare_const_vals(&lit_to_const(a), &lit_to_const(b)) {\n-        Some(val) => Some(val == 0),\n-        None =>  None,\n-    }\n+pub fn lit_eq(a: &lit, b: &lit) -> Option<bool> {\n+    compare_const_vals(&lit_to_const(a), &lit_to_const(b)).map(|&val| val == 0)\n }"}, {"sha": "ac18a9b76cf9a5a71172d6e07088d223e3ecb593", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 41, "deletions": 42, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -16,13 +16,12 @@\n  * GEN and KILL bits for each expression.\n  */\n \n-use core::prelude::*;\n \n-use core::cast;\n-use core::io;\n-use core::uint;\n-use core::vec;\n-use core::hashmap::HashMap;\n+use std::cast;\n+use std::io;\n+use std::uint;\n+use std::vec;\n+use std::hashmap::HashMap;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::ast_util::id_range;\n@@ -132,7 +131,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         debug!(\"add_gen(id=%?, bit=%?)\", id, bit);\n         let (start, end) = self.compute_id_range(id);\n         {\n-            let gens = vec::mut_slice(self.gens, start, end);\n+            let gens = self.gens.mut_slice(start, end);\n             set_bit(gens, bit);\n         }\n     }\n@@ -143,7 +142,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         debug!(\"add_kill(id=%?, bit=%?)\", id, bit);\n         let (start, end) = self.compute_id_range(id);\n         {\n-            let kills = vec::mut_slice(self.kills, start, end);\n+            let kills = self.kills.mut_slice(start, end);\n             set_bit(kills, bit);\n         }\n     }\n@@ -216,7 +215,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n             return true;\n         }\n         let (start, end) = self.compute_id_range_frozen(id);\n-        let on_entry = vec::slice(self.on_entry, start, end);\n+        let on_entry = self.on_entry.slice(start, end);\n         debug!(\"each_bit_on_entry_frozen(id=%?, on_entry=%s)\",\n                id, bits_to_str(on_entry));\n         self.each_bit(on_entry, f)\n@@ -229,7 +228,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         //! Only useful after `propagate()` has been called.\n \n         let (start, end) = self.compute_id_range(id);\n-        let on_entry = vec::slice(self.on_entry, start, end);\n+        let on_entry = self.on_entry.slice(start, end);\n         debug!(\"each_bit_on_entry(id=%?, on_entry=%s)\",\n                id, bits_to_str(on_entry));\n         self.each_bit(on_entry, f)\n@@ -241,7 +240,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         //! Iterates through each bit in the gen set for `id`.\n \n         let (start, end) = self.compute_id_range(id);\n-        let gens = vec::slice(self.gens, start, end);\n+        let gens = self.gens.slice(start, end);\n         debug!(\"each_gen_bit(id=%?, gens=%s)\",\n                id, bits_to_str(gens));\n         self.each_bit(gens, f)\n@@ -255,7 +254,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n             return true;\n         }\n         let (start, end) = self.compute_id_range_frozen(id);\n-        let gens = vec::slice(self.gens, start, end);\n+        let gens = self.gens.slice(start, end);\n         debug!(\"each_gen_bit(id=%?, gens=%s)\",\n                id, bits_to_str(gens));\n         self.each_bit(gens, f)\n@@ -266,7 +265,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n                 f: &fn(uint) -> bool) -> bool {\n         //! Helper for iterating over the bits in a bit set.\n \n-        for words.eachi |word_index, &word| {\n+        for words.iter().enumerate().advance |(word_index, &word)| {\n             if word != 0 {\n                 let base_index = word_index * uint::bits;\n                 for uint::range(0, uint::bits) |offset| {\n@@ -338,18 +337,18 @@ impl<O:DataFlowOperator+Copy+'static> DataFlowContext<O> {\n \n             if self.nodeid_to_bitset.contains_key(&id) {\n                 let (start, end) = self.compute_id_range_frozen(id);\n-                let on_entry = vec::slice(self.on_entry, start, end);\n+                let on_entry = self.on_entry.slice(start, end);\n                 let entry_str = bits_to_str(on_entry);\n \n-                let gens = vec::slice(self.gens, start, end);\n-                let gens_str = if gens.any(|&u| u != 0) {\n+                let gens = self.gens.slice(start, end);\n+                let gens_str = if gens.iter().any_(|&u| u != 0) {\n                     fmt!(\" gen: %s\", bits_to_str(gens))\n                 } else {\n                     ~\"\"\n                 };\n \n-                let kills = vec::slice(self.kills, start, end);\n-                let kills_str = if kills.any(|&u| u != 0) {\n+                let kills = self.kills.slice(start, end);\n+                let kills_str = if kills.iter().any_(|&u| u != 0) {\n                     fmt!(\" kill: %s\", bits_to_str(kills))\n                 } else {\n                     ~\"\"\n@@ -389,7 +388,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n \n         self.merge_with_entry_set(blk.node.id, in_out);\n \n-        for blk.node.stmts.each |&stmt| {\n+        for blk.node.stmts.iter().advance |&stmt| {\n             self.walk_stmt(stmt, in_out, loop_scopes);\n         }\n \n@@ -503,14 +502,14 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n \n                     // func_bits represents the state when the function\n                     // returns\n-                    let mut func_bits = reslice(in_out).to_vec();\n+                    let mut func_bits = reslice(in_out).to_owned();\n \n                     loop_scopes.push(LoopScope {\n                         loop_id: expr.id,\n                         loop_kind: ForLoop,\n-                        break_bits: reslice(in_out).to_vec()\n+                        break_bits: reslice(in_out).to_owned()\n                     });\n-                    for decl.inputs.each |input| {\n+                    for decl.inputs.iter().advance |input| {\n                         self.walk_pat(input.pat, func_bits, loop_scopes);\n                     }\n                     self.walk_block(body, func_bits, loop_scopes);\n@@ -547,7 +546,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 //\n                 self.walk_expr(cond, in_out, loop_scopes);\n \n-                let mut then_bits = reslice(in_out).to_vec();\n+                let mut then_bits = reslice(in_out).to_owned();\n                 self.walk_block(then, then_bits, loop_scopes);\n \n                 self.walk_opt_expr(els, in_out, loop_scopes);\n@@ -569,11 +568,11 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n \n                 self.walk_expr(cond, in_out, loop_scopes);\n \n-                let mut body_bits = reslice(in_out).to_vec();\n+                let mut body_bits = reslice(in_out).to_owned();\n                 loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n                     loop_kind: TrueLoop,\n-                    break_bits: reslice(in_out).to_vec()\n+                    break_bits: reslice(in_out).to_owned()\n                 });\n                 self.walk_block(blk, body_bits, loop_scopes);\n                 self.add_to_entry_set(expr.id, body_bits);\n@@ -591,12 +590,12 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 //    <--+ (break)\n                 //\n \n-                let mut body_bits = reslice(in_out).to_vec();\n+                let mut body_bits = reslice(in_out).to_owned();\n                 self.reset(in_out);\n                 loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n                     loop_kind: TrueLoop,\n-                    break_bits: reslice(in_out).to_vec()\n+                    break_bits: reslice(in_out).to_owned()\n                 });\n                 self.walk_block(blk, body_bits, loop_scopes);\n                 self.add_to_entry_set(expr.id, body_bits);\n@@ -620,20 +619,20 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 //\n                 self.walk_expr(discr, in_out, loop_scopes);\n \n-                let mut guards = reslice(in_out).to_vec();\n+                let mut guards = reslice(in_out).to_owned();\n \n                 // We know that exactly one arm will be taken, so we\n                 // can start out with a blank slate and just union\n                 // together the bits from each arm:\n                 self.reset(in_out);\n \n-                for arms.each |arm| {\n+                for arms.iter().advance |arm| {\n                     // in_out reflects the discr and all guards to date\n                     self.walk_opt_expr(arm.guard, guards, loop_scopes);\n \n                     // determine the bits for the body and then union\n                     // them into `in_out`, which reflects all bodies to date\n-                    let mut body = reslice(guards).to_vec();\n+                    let mut body = reslice(guards).to_owned();\n                     self.walk_pat_alternatives(arm.pats, body, loop_scopes);\n                     self.walk_block(&arm.body, body, loop_scopes);\n                     join_bits(&self.dfcx.oper, body, in_out);\n@@ -644,7 +643,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 self.walk_opt_expr(o_e, in_out, loop_scopes);\n \n                 // is this a return from a `for`-loop closure?\n-                match loop_scopes.position(|s| s.loop_kind == ForLoop) {\n+                match loop_scopes.iter().position_(|s| s.loop_kind == ForLoop) {\n                     Some(i) => {\n                         // if so, add the in_out bits to the state\n                         // upon exit. Remember that we cannot count\n@@ -702,7 +701,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             }\n \n             ast::expr_struct(_, ref fields, with_expr) => {\n-                for fields.each |field| {\n+                for fields.iter().advance |field| {\n                     self.walk_expr(field.node.expr, in_out, loop_scopes);\n                 }\n                 self.walk_opt_expr(with_expr, in_out, loop_scopes);\n@@ -735,7 +734,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n \n             ast::expr_binary(_, op, l, r) if ast_util::lazy_binop(op) => {\n                 self.walk_expr(l, in_out, loop_scopes);\n-                let temp = reslice(in_out).to_vec();\n+                let temp = reslice(in_out).to_owned();\n                 self.walk_expr(r, in_out, loop_scopes);\n                 join_bits(&self.dfcx.oper, temp, in_out);\n             }\n@@ -764,10 +763,10 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             }\n \n             ast::expr_inline_asm(ref inline_asm) => {\n-                for inline_asm.inputs.each |&(_, expr)| {\n+                for inline_asm.inputs.iter().advance |&(_, expr)| {\n                     self.walk_expr(expr, in_out, loop_scopes);\n                 }\n-                for inline_asm.outputs.each |&(_, expr)| {\n+                for inline_asm.outputs.iter().advance |&(_, expr)| {\n                     self.walk_expr(expr, in_out, loop_scopes);\n                 }\n             }\n@@ -835,7 +834,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                   exprs: &[@ast::expr],\n                   in_out: &mut [uint],\n                   loop_scopes: &mut ~[LoopScope]) {\n-        for exprs.each |&expr| {\n+        for exprs.iter().advance |&expr| {\n             self.walk_expr(expr, in_out, loop_scopes);\n         }\n     }\n@@ -896,8 +895,8 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n         // In the general case, the patterns in `pats` are\n         // alternatives, so we must treat this like an N-way select\n         // statement.\n-        let initial_state = reslice(in_out).to_vec();\n-        for pats.each |&pat| {\n+        let initial_state = reslice(in_out).to_owned();\n+        for pats.iter().advance |&pat| {\n             let mut temp = copy initial_state;\n             self.walk_pat(pat, temp, loop_scopes);\n             join_bits(&self.dfcx.oper, temp, in_out);\n@@ -917,7 +916,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             Some(_) => {\n                 match self.tcx().def_map.find(&expr.id) {\n                     Some(&ast::def_label(loop_id)) => {\n-                        match loop_scopes.position(|l| l.loop_id == loop_id) {\n+                        match loop_scopes.iter().position_(|l| l.loop_id == loop_id) {\n                             Some(i) => i,\n                             None => {\n                                 self.tcx().sess.span_bug(\n@@ -953,7 +952,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                id, bits_to_str(pred_bits));\n         let (start, end) = self.dfcx.compute_id_range(id);\n         let changed = { // FIXME(#5074) awkward construction\n-            let on_entry = vec::mut_slice(self.dfcx.on_entry, start, end);\n+            let on_entry = self.dfcx.on_entry.mut_slice(start, end);\n             join_bits(&self.dfcx.oper, pred_bits, on_entry)\n         };\n         if changed {\n@@ -970,7 +969,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                id, mut_bits_to_str(pred_bits));\n         let (start, end) = self.dfcx.compute_id_range(id);\n         let changed = { // FIXME(#5074) awkward construction\n-            let on_entry = vec::mut_slice(self.dfcx.on_entry, start, end);\n+            let on_entry = self.dfcx.on_entry.mut_slice(start, end);\n             let changed = join_bits(&self.dfcx.oper, reslice(pred_bits), on_entry);\n             copy_bits(reslice(on_entry), pred_bits);\n             changed\n@@ -993,7 +992,7 @@ fn bits_to_str(words: &[uint]) -> ~str {\n \n     // Note: this is a little endian printout of bytes.\n \n-    for words.each |&word| {\n+    for words.iter().advance |&word| {\n         let mut v = word;\n         for uint::range(0, uint::bytes) |_| {\n             result.push_char(sep);"}, {"sha": "654cc25c15e8cb25bdf408b791dd910bb11fcdce", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -17,7 +17,7 @@ use middle::typeck::method_map;\n use util::ppaux;\n \n use syntax::ast::{deref, expr_call, expr_inline_asm, expr_method_call};\n-use syntax::ast::{expr_unary, node_id, unsafe_blk, unsafe_fn};\n+use syntax::ast::{expr_unary, node_id, unsafe_blk, unsafe_fn, expr_path};\n use syntax::ast;\n use syntax::codemap::span;\n use syntax::visit::{fk_item_fn, fk_method};\n@@ -47,7 +47,7 @@ fn type_is_unsafe_function(ty: ty::t) -> bool {\n \n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: method_map,\n-                   crate: @ast::crate) {\n+                   crate: &ast::crate) {\n     let context = @mut Context {\n         method_map: method_map,\n         unsafe_context: SafeContext,\n@@ -143,6 +143,14 @@ pub fn check_crate(tcx: ty::ctxt,\n                 expr_inline_asm(*) => {\n                     require_unsafe(expr.span, \"use of inline assembly\")\n                 }\n+                expr_path(*) => {\n+                    match ty::resolve_expr(tcx, expr) {\n+                        ast::def_static(_, true) => {\n+                            require_unsafe(expr.span, \"use of mutable static\")\n+                        }\n+                        _ => {}\n+                    }\n+                }\n                 _ => {}\n             }\n "}, {"sha": "9bcfab0773fff83bc2c20a6841f8e38829f69105", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n \n use driver::session;\n use driver::session::Session;\n@@ -18,7 +17,7 @@ use syntax::codemap::span;\n use syntax::visit::{default_visitor, mk_vt, vt, Visitor, visit_crate, visit_item};\n use syntax::attr::{attrs_contains_name};\n use syntax::ast_map;\n-use core::util;\n+use std::util;\n \n struct EntryContext {\n     session: Session,\n@@ -41,7 +40,7 @@ struct EntryContext {\n \n type EntryVisitor = vt<@mut EntryContext>;\n \n-pub fn find_entry_point(session: Session, crate: @crate, ast_map: ast_map::map) {\n+pub fn find_entry_point(session: Session, crate: &crate, ast_map: ast_map::map) {\n \n     // FIXME #4404 android JNI hacks\n     if *session.building_library &&\n@@ -138,7 +137,7 @@ fn configure_main(ctxt: @mut EntryContext) {\n                                    but you have one or more functions named 'main' that are not \\\n                                    defined at the crate level. Either move the definition or \\\n                                    attach the `#[main]` attribute to override this behavior.\");\n-                for this.non_main_fns.each |&(_, span)| {\n+                for this.non_main_fns.iter().advance |&(_, span)| {\n                     this.session.span_note(span, \"here is a function named 'main'\");\n                 }\n             }"}, {"sha": "ee7c35fb3d553a92e7b8eff19fe139adff553d7d", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -11,12 +11,11 @@\n // A pass that annotates for each loops and functions with the free\n // variables that they contain.\n \n-use core::prelude::*;\n \n use middle::resolve;\n use middle::ty;\n \n-use core::hashmap::HashMap;\n+use std::hashmap::HashMap;\n use syntax::codemap::span;\n use syntax::{ast, ast_util, visit};\n \n@@ -88,7 +87,7 @@ fn collect_freevars(def_map: resolve::DefMap, blk: &ast::blk)\n // efficient as it fully recomputes the free variables at every\n // node of interest rather than building up the free variables in\n // one pass. This could be improved upon if it turns out to matter.\n-pub fn annotate_freevars(def_map: resolve::DefMap, crate: @ast::crate) ->\n+pub fn annotate_freevars(def_map: resolve::DefMap, crate: &ast::crate) ->\n    freevar_map {\n     let freevars = @mut HashMap::new();\n "}, {"sha": "a207985e64c83d462be9cb2202ec63c6ceb000e1", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 107, "deletions": 64, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n \n use middle::freevars::freevar_entry;\n use middle::freevars;\n@@ -17,7 +16,6 @@ use middle::typeck;\n use util::ppaux::{Repr, ty_to_str};\n use util::ppaux::UserString;\n \n-use core::vec;\n use syntax::ast::*;\n use syntax::attr::attrs_contains_name;\n use syntax::codemap::span;\n@@ -32,21 +30,21 @@ use syntax::{visit, ast_util};\n //\n //  send: Things that can be sent on channels or included in spawned closures.\n //  copy: Things that can be copied.\n-//  const: Things thare are deeply immutable. They are guaranteed never to\n+//  freeze: Things thare are deeply immutable. They are guaranteed never to\n //    change, and can be safely shared without copying between tasks.\n-//  owned: Things that do not contain borrowed pointers.\n+//  'static: Things that do not contain borrowed pointers.\n //\n // Send includes scalar types as well as classes and unique types containing\n // only sendable types.\n //\n // Copy includes boxes, closure and unique types containing copyable types.\n //\n-// Const include scalar types, things without non-const fields, and pointers\n-// to const things.\n+// Freeze include scalar types, things without non-const fields, and pointers\n+// to freezable things.\n //\n // This pass ensures that type parameters are only instantiated with types\n // whose kinds are equal or less general than the way the type parameter was\n-// annotated (with the `send`, `copy` or `const` keyword).\n+// annotated (with the `Send`, `Copy` or `Freeze` bound).\n //\n // It also verifies that noncopyable kinds are not copied. Sendability is not\n // applied, since none of our language primitives send. Instead, the sending\n@@ -63,7 +61,7 @@ pub struct Context {\n \n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: typeck::method_map,\n-                   crate: @crate) {\n+                   crate: &crate) {\n     let ctx = Context {\n         tcx: tcx,\n         method_map: method_map,\n@@ -81,8 +79,6 @@ pub fn check_crate(tcx: ty::ctxt,\n     tcx.sess.abort_if_errors();\n }\n \n-type check_fn = @fn(Context, @freevar_entry);\n-\n fn check_struct_safe_for_destructor(cx: Context,\n                                     span: span,\n                                     struct_did: def_id) {\n@@ -93,18 +89,18 @@ fn check_struct_safe_for_destructor(cx: Context,\n             self_ty: None,\n             tps: ~[]\n         });\n-        if !ty::type_is_owned(cx.tcx, struct_ty) {\n+        if !ty::type_is_sendable(cx.tcx, struct_ty) {\n             cx.tcx.sess.span_err(span,\n-                                 \"cannot implement a destructor on a struct \\\n-                                  that is not Owned\");\n+                                 \"cannot implement a destructor on a \\\n+                                  structure that does not satisfy Send\");\n             cx.tcx.sess.span_note(span,\n                                   \"use \\\"#[unsafe_destructor]\\\" on the \\\n                                    implementation to force the compiler to \\\n                                    allow this\");\n         }\n     } else {\n         cx.tcx.sess.span_err(span,\n-                             \"cannot implement a destructor on a struct \\\n+                             \"cannot implement a destructor on a structure \\\n                               with type parameters\");\n         cx.tcx.sess.span_note(span,\n                               \"use \\\"#[unsafe_destructor]\\\" on the \\\n@@ -129,7 +125,8 @@ fn check_item(item: @item, (cx, visitor): (Context, visit::vt<Context>)) {\n                         if cx.tcx.lang_items.drop_trait() == trait_def_id {\n                             // Yes, it's a destructor.\n                             match self_type.node {\n-                                ty_path(_, path_node_id) => {\n+                                ty_path(_, bounds, path_node_id) => {\n+                                    assert!(bounds.is_none());\n                                     let struct_def = cx.tcx.def_map.get_copy(\n                                         &path_node_id);\n                                     let struct_did =\n@@ -162,30 +159,40 @@ fn check_item(item: @item, (cx, visitor): (Context, visit::vt<Context>)) {\n // Yields the appropriate function to check the kind of closed over\n // variables. `id` is the node_id for some expression that creates the\n // closure.\n-fn with_appropriate_checker(cx: Context, id: node_id, b: &fn(check_fn)) {\n-    fn check_for_uniq(cx: Context, fv: @freevar_entry) {\n+fn with_appropriate_checker(cx: Context, id: node_id,\n+                            b: &fn(checker: &fn(Context, @freevar_entry))) {\n+    fn check_for_uniq(cx: Context, fv: &freevar_entry, bounds: ty::BuiltinBounds) {\n         // all captured data must be owned, regardless of whether it is\n         // moved in or copied in.\n         let id = ast_util::def_id_of_def(fv.def).node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n-        if !check_owned(cx, var_t, fv.span) { return; }\n \n         // check that only immutable variables are implicitly copied in\n         check_imm_free_var(cx, fv.def, fv.span);\n+\n+        check_freevar_bounds(cx, fv.span, var_t, bounds, None);\n     }\n \n-    fn check_for_box(cx: Context, fv: @freevar_entry) {\n+    fn check_for_box(cx: Context, fv: &freevar_entry, bounds: ty::BuiltinBounds) {\n         // all captured data must be owned\n         let id = ast_util::def_id_of_def(fv.def).node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n-        if !check_durable(cx.tcx, var_t, fv.span) { return; }\n \n         // check that only immutable variables are implicitly copied in\n         check_imm_free_var(cx, fv.def, fv.span);\n+\n+        check_freevar_bounds(cx, fv.span, var_t, bounds, None);\n     }\n \n-    fn check_for_block(_cx: Context, _fv: @freevar_entry) {\n-        // no restrictions\n+    fn check_for_block(cx: Context, fv: &freevar_entry,\n+                       bounds: ty::BuiltinBounds, region: ty::Region) {\n+        let id = ast_util::def_id_of_def(fv.def).node;\n+        let var_t = ty::node_id_to_type(cx.tcx, id);\n+        // FIXME(#3569): Figure out whether the implicit borrow is actually\n+        // mutable. Currently we assume all upvars are referenced mutably.\n+        let implicit_borrowed_type = ty::mk_mut_rptr(cx.tcx, region, var_t);\n+        check_freevar_bounds(cx, fv.span, implicit_borrowed_type,\n+                             bounds, Some(var_t));\n     }\n \n     fn check_for_bare(cx: Context, fv: @freevar_entry) {\n@@ -196,14 +203,15 @@ fn with_appropriate_checker(cx: Context, id: node_id, b: &fn(check_fn)) {\n \n     let fty = ty::node_id_to_type(cx.tcx, id);\n     match ty::get(fty).sty {\n-        ty::ty_closure(ty::ClosureTy {sigil: OwnedSigil, _}) => {\n-            b(check_for_uniq)\n+        ty::ty_closure(ty::ClosureTy {sigil: OwnedSigil, bounds: bounds, _}) => {\n+            b(|cx, fv| check_for_uniq(cx, fv, bounds))\n         }\n-        ty::ty_closure(ty::ClosureTy {sigil: ManagedSigil, _}) => {\n-            b(check_for_box)\n+        ty::ty_closure(ty::ClosureTy {sigil: ManagedSigil, bounds: bounds, _}) => {\n+            b(|cx, fv| check_for_box(cx, fv, bounds))\n         }\n-        ty::ty_closure(ty::ClosureTy {sigil: BorrowedSigil, _}) => {\n-            b(check_for_block)\n+        ty::ty_closure(ty::ClosureTy {sigil: BorrowedSigil, bounds: bounds,\n+                                      region: region, _}) => {\n+            b(|cx, fv| check_for_block(cx, fv, bounds, region))\n         }\n         ty::ty_bare_fn(_) => {\n             b(check_for_bare)\n@@ -228,7 +236,8 @@ fn check_fn(\n \n     // Check kinds on free variables:\n     do with_appropriate_checker(cx, fn_id) |chk| {\n-        for vec::each(*freevars::get_freevars(cx.tcx, fn_id)) |fv| {\n+        let r = freevars::get_freevars(cx.tcx, fn_id);\n+        for r.iter().advance |fv| {\n             chk(cx, *fv);\n         }\n     }\n@@ -271,15 +280,21 @@ pub fn check_expr(e: @expr, (cx, v): (Context, visit::vt<Context>)) {\n                       type_param_defs.repr(cx.tcx));\n             }\n             for ts.iter().zip(type_param_defs.iter()).advance |(&ty, type_param_def)| {\n-                check_bounds(cx, type_parameter_id, e.span, ty, type_param_def)\n+                check_typaram_bounds(cx, type_parameter_id, e.span, ty, type_param_def)\n             }\n         }\n     }\n \n     match e.node {\n         expr_cast(source, _) => {\n             check_cast_for_escaping_regions(cx, source, e);\n-            check_kind_bounds_of_cast(cx, source, e);\n+            match ty::get(ty::expr_ty(cx.tcx, e)).sty {\n+                ty::ty_trait(_, _, _, _, bounds) => {\n+                    let source_ty = ty::expr_ty(cx.tcx, source);\n+                    check_trait_cast_bounds(cx, e.span, source_ty, bounds)\n+                }\n+                _ => { }\n+            }\n         }\n         expr_copy(expr) => {\n             // Note: This is the only place where we must check whether the\n@@ -307,14 +322,14 @@ pub fn check_expr(e: @expr, (cx, v): (Context, visit::vt<Context>)) {\n \n fn check_ty(aty: @Ty, (cx, v): (Context, visit::vt<Context>)) {\n     match aty.node {\n-      ty_path(_, id) => {\n+      ty_path(_, _, id) => {\n           let r = cx.tcx.node_type_substs.find(&id);\n           for r.iter().advance |ts| {\n               let did = ast_util::def_id_of_def(cx.tcx.def_map.get_copy(&id));\n               let type_param_defs =\n                   ty::lookup_item_type(cx.tcx, did).generics.type_param_defs;\n               for ts.iter().zip(type_param_defs.iter()).advance |(&ty, type_param_def)| {\n-                  check_bounds(cx, aty.id, aty.span, ty, type_param_def)\n+                  check_typaram_bounds(cx, aty.id, aty.span, ty, type_param_def)\n               }\n           }\n       }\n@@ -323,20 +338,29 @@ fn check_ty(aty: @Ty, (cx, v): (Context, visit::vt<Context>)) {\n     visit::visit_ty(aty, (cx, v));\n }\n \n-pub fn check_bounds(cx: Context,\n-                    _type_parameter_id: node_id,\n-                    sp: span,\n-                    ty: ty::t,\n-                    type_param_def: &ty::TypeParameterDef)\n+// Calls \"any_missing\" if any bounds were missing.\n+pub fn check_builtin_bounds(cx: Context, ty: ty::t, bounds: ty::BuiltinBounds,\n+                            any_missing: &fn(ty::BuiltinBounds))\n {\n     let kind = ty::type_contents(cx.tcx, ty);\n     let mut missing = ty::EmptyBuiltinBounds();\n-    for type_param_def.bounds.builtin_bounds.each |bound| {\n+    for bounds.each |bound| {\n         if !kind.meets_bound(cx.tcx, bound) {\n             missing.add(bound);\n         }\n     }\n     if !missing.is_empty() {\n+        any_missing(missing);\n+    }\n+}\n+\n+pub fn check_typaram_bounds(cx: Context,\n+                    _type_parameter_id: node_id,\n+                    sp: span,\n+                    ty: ty::t,\n+                    type_param_def: &ty::TypeParameterDef)\n+{\n+    do check_builtin_bounds(cx, ty, type_param_def.bounds.builtin_bounds) |missing| {\n         cx.tcx.sess.span_err(\n             sp,\n             fmt!(\"instantiating a type parameter with an incompatible type \\\n@@ -346,6 +370,40 @@ pub fn check_bounds(cx: Context,\n     }\n }\n \n+pub fn check_freevar_bounds(cx: Context, sp: span, ty: ty::t,\n+                            bounds: ty::BuiltinBounds, referenced_ty: Option<ty::t>)\n+{\n+    do check_builtin_bounds(cx, ty, bounds) |missing| {\n+        // Will be Some if the freevar is implicitly borrowed (stack closure).\n+        // Emit a less mysterious error message in this case.\n+        match referenced_ty {\n+            Some(rty) => cx.tcx.sess.span_err(sp,\n+                fmt!(\"cannot implicitly borrow variable of type `%s` in a bounded \\\n+                      stack closure (implicit reference does not fulfill `%s`)\",\n+                     ty_to_str(cx.tcx, rty), missing.user_string(cx.tcx))),\n+            None => cx.tcx.sess.span_err(sp,\n+                fmt!(\"cannot capture variable of type `%s`, which does \\\n+                      not fulfill `%s`, in a bounded closure\",\n+                     ty_to_str(cx.tcx, ty), missing.user_string(cx.tcx))),\n+        }\n+        cx.tcx.sess.span_note(\n+            sp,\n+            fmt!(\"this closure's environment must satisfy `%s`\",\n+                 bounds.user_string(cx.tcx)));\n+    }\n+}\n+\n+pub fn check_trait_cast_bounds(cx: Context, sp: span, ty: ty::t,\n+                               bounds: ty::BuiltinBounds) {\n+    do check_builtin_bounds(cx, ty, bounds) |missing| {\n+        cx.tcx.sess.span_err(sp,\n+            fmt!(\"cannot pack type `%s`, which does not fulfill \\\n+                  `%s`, as a trait bounded by %s\",\n+                 ty_to_str(cx.tcx, ty), missing.user_string(cx.tcx),\n+                 bounds.user_string(cx.tcx)));\n+    }\n+}\n+\n fn is_nullary_variant(cx: Context, ex: @expr) -> bool {\n     match ex.node {\n       expr_path(_) => {\n@@ -392,10 +450,10 @@ fn check_copy(cx: Context, ty: ty::t, sp: span, reason: &str) {\n     }\n }\n \n-pub fn check_owned(cx: Context, ty: ty::t, sp: span) -> bool {\n-    if !ty::type_is_owned(cx.tcx, ty) {\n+pub fn check_send(cx: Context, ty: ty::t, sp: span) -> bool {\n+    if !ty::type_is_sendable(cx.tcx, ty) {\n         cx.tcx.sess.span_err(\n-            sp, fmt!(\"value has non-owned type `%s`\",\n+            sp, fmt!(\"value has non-sendable type `%s`\",\n                      ty_to_str(cx.tcx, ty)));\n         false\n     } else {\n@@ -443,14 +501,14 @@ pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: span) -> bool {\n /// `deque<T>`, then whatever borrowed ptrs may appear in `T` also\n /// appear in `deque<T>`.\n ///\n-/// (3) The type parameter is owned (and therefore does not contain\n+/// (3) The type parameter is sendable (and therefore does not contain\n /// borrowed ptrs).\n ///\n /// FIXME(#5723)---This code should probably move into regionck.\n pub fn check_cast_for_escaping_regions(\n     cx: Context,\n-    source: @expr,\n-    target: @expr)\n+    source: &expr,\n+    target: &expr)\n {\n     // Determine what type we are casting to; if it is not an trait, then no\n     // worries.\n@@ -477,12 +535,12 @@ pub fn check_cast_for_escaping_regions(\n     // Check, based on the region associated with the trait, whether it can\n     // possibly escape the enclosing fn item (note that all type parameters\n     // must have been declared on the enclosing fn item).\n-    if target_regions.any(|r| is_re_scope(*r)) {\n+    if target_regions.iter().any_(|r| is_re_scope(*r)) {\n         return; /* case (1) */\n     }\n \n     // Assuming the trait instance can escape, then ensure that each parameter\n-    // either appears in the trait type or is owned.\n+    // either appears in the trait type or is sendable.\n     let target_params = ty::param_tys_in_type(target_ty);\n     let source_ty = ty::expr_ty(cx.tcx, source);\n     ty::walk_regions_and_ty(\n@@ -492,7 +550,7 @@ pub fn check_cast_for_escaping_regions(\n         |_r| {\n             // FIXME(#5723) --- turn this check on once &Objects are usable\n             //\n-            // if !target_regions.any(|t_r| is_subregion_of(cx, *t_r, r)) {\n+            // if !target_regions.iter().any_(|t_r| is_subregion_of(cx, *t_r, r)) {\n             //     cx.tcx.sess.span_err(\n             //         source.span,\n             //         fmt!(\"source contains borrowed pointer with lifetime \\\n@@ -506,7 +564,7 @@ pub fn check_cast_for_escaping_regions(\n         |ty| {\n             match ty::get(ty).sty {\n                 ty::ty_param(source_param) => {\n-                    if target_params.contains(&source_param) {\n+                    if target_params.iter().any_(|x| x == &source_param) {\n                         /* case (2) */\n                     } else {\n                         check_durable(cx.tcx, ty, source.span); /* case (3) */\n@@ -529,18 +587,3 @@ pub fn check_cast_for_escaping_regions(\n     }\n }\n \n-/// Ensures that values placed into a ~Trait are copyable and sendable.\n-pub fn check_kind_bounds_of_cast(cx: Context, source: @expr, target: @expr) {\n-    let target_ty = ty::expr_ty(cx.tcx, target);\n-    match ty::get(target_ty).sty {\n-        ty::ty_trait(_, _, ty::UniqTraitStore, _) => {\n-            let source_ty = ty::expr_ty(cx.tcx, source);\n-            if !ty::type_is_owned(cx.tcx, source_ty) {\n-                cx.tcx.sess.span_err(\n-                    target.span,\n-                    \"uniquely-owned trait objects must be sendable\");\n-            }\n-        }\n-        _ => {} // Nothing to do.\n-    }\n-}"}, {"sha": "0e9361193b0a31a5a9e6640d68089b51c686cb92", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 194, "deletions": 170, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -13,13 +13,12 @@\n // Language items are items that represent concepts intrinsic to the language\n // itself. Examples are:\n //\n-// * Traits that specify \"kinds\"; e.g. \"const\", \"copy\", \"owned\".\n+// * Traits that specify \"kinds\"; e.g. \"Freeze\", \"Copy\", \"Send\".\n //\n-// * Traits that represent operators; e.g. \"add\", \"sub\", \"index\".\n+// * Traits that represent operators; e.g. \"Add\", \"Sub\", \"Index\".\n //\n // * Functions called by the compiler itself.\n \n-use core::prelude::*;\n \n use driver::session::Session;\n use metadata::csearch::each_lang_item;\n@@ -30,74 +29,79 @@ use syntax::ast_util::local_def;\n use syntax::visit::{default_simple_visitor, mk_simple_visitor, SimpleVisitor};\n use syntax::visit::visit_crate;\n \n-use core::hashmap::HashMap;\n+use std::hashmap::HashMap;\n \n pub enum LangItem {\n-    ConstTraitLangItem,         // 0\n-    CopyTraitLangItem,          // 1\n-    OwnedTraitLangItem,         // 2\n-    SizedTraitLangItem,         // 3\n-\n-    DropTraitLangItem,          // 4\n-\n-    AddTraitLangItem,           // 5\n-    SubTraitLangItem,           // 6\n-    MulTraitLangItem,           // 7\n-    DivTraitLangItem,           // 8\n-    RemTraitLangItem,           // 9\n-    NegTraitLangItem,           // 10\n-    NotTraitLangItem,           // 11\n-    BitXorTraitLangItem,        // 11\n-    BitAndTraitLangItem,        // 13\n-    BitOrTraitLangItem,         // 14\n-    ShlTraitLangItem,           // 15\n-    ShrTraitLangItem,           // 16\n-    IndexTraitLangItem,         // 17\n-\n-    EqTraitLangItem,            // 18\n-    OrdTraitLangItem,           // 19\n-\n-    StrEqFnLangItem,            // 20\n-    UniqStrEqFnLangItem,        // 21\n-    AnnihilateFnLangItem,       // 22\n-    LogTypeFnLangItem,          // 23\n-    FailFnLangItem,             // 24\n-    FailBoundsCheckFnLangItem,  // 25\n-    ExchangeMallocFnLangItem,   // 26\n-    ExchangeFreeFnLangItem,     // 27\n-    MallocFnLangItem,           // 28\n-    FreeFnLangItem,             // 29\n-    BorrowAsImmFnLangItem,      // 30\n-    BorrowAsMutFnLangItem,      // 31\n-    ReturnToMutFnLangItem,      // 32\n-    CheckNotBorrowedFnLangItem, // 33\n-    StrDupUniqFnLangItem,       // 34\n-    RecordBorrowFnLangItem,     // 35\n-    UnrecordBorrowFnLangItem,   // 36\n-\n-    StartFnLangItem,            // 37\n+    FreezeTraitLangItem,               // 0\n+    CopyTraitLangItem,                 // 1\n+    SendTraitLangItem,                 // 2\n+    SizedTraitLangItem,                // 3\n+\n+    DropTraitLangItem,                 // 4\n+\n+    AddTraitLangItem,                  // 5\n+    SubTraitLangItem,                  // 6\n+    MulTraitLangItem,                  // 7\n+    DivTraitLangItem,                  // 8\n+    RemTraitLangItem,                  // 9\n+    NegTraitLangItem,                  // 10\n+    NotTraitLangItem,                  // 11\n+    BitXorTraitLangItem,               // 11\n+    BitAndTraitLangItem,               // 13\n+    BitOrTraitLangItem,                // 14\n+    ShlTraitLangItem,                  // 15\n+    ShrTraitLangItem,                  // 16\n+    IndexTraitLangItem,                // 17\n+\n+    EqTraitLangItem,                   // 18\n+    OrdTraitLangItem,                  // 19\n+\n+    StrEqFnLangItem,                   // 20\n+    UniqStrEqFnLangItem,               // 21\n+    AnnihilateFnLangItem,              // 22\n+    LogTypeFnLangItem,                 // 23\n+    FailFnLangItem,                    // 24\n+    FailBoundsCheckFnLangItem,         // 25\n+    ExchangeMallocFnLangItem,          // 26\n+    ClosureExchangeMallocFnLangItem,   // 27\n+    ExchangeFreeFnLangItem,            // 28\n+    MallocFnLangItem,                  // 29\n+    FreeFnLangItem,                    // 30\n+    BorrowAsImmFnLangItem,             // 31\n+    BorrowAsMutFnLangItem,             // 32\n+    ReturnToMutFnLangItem,             // 33\n+    CheckNotBorrowedFnLangItem,        // 34\n+    StrDupUniqFnLangItem,              // 35\n+    RecordBorrowFnLangItem,            // 36\n+    UnrecordBorrowFnLangItem,          // 37\n+\n+    StartFnLangItem,                   // 38\n+\n+    TyDescStructLangItem,              // 39\n+    TyVisitorTraitLangItem,            // 40\n+    OpaqueStructLangItem,              // 41\n }\n \n pub struct LanguageItems {\n-    items: [Option<def_id>, ..38]\n+    items: [Option<def_id>, ..42]\n }\n \n impl LanguageItems {\n     pub fn new() -> LanguageItems {\n         LanguageItems {\n-            items: [ None, ..38 ]\n+            items: [ None, ..42 ]\n         }\n     }\n \n     pub fn each_item(&self, f: &fn(def_id: def_id, i: uint) -> bool) -> bool {\n-        self.items.eachi(|i, &item| f(item.get(), i))\n+        self.items.iter().enumerate().advance(|(i, &item)| f(item.get(), i))\n     }\n \n     pub fn item_name(index: uint) -> &'static str {\n         match index {\n-            0  => \"const\",\n+            0  => \"freeze\",\n             1  => \"copy\",\n-            2  => \"owned\",\n+            2  => \"send\",\n             3  => \"sized\",\n \n             4  => \"drop\",\n@@ -125,216 +129,236 @@ impl LanguageItems {\n             24 => \"fail_\",\n             25 => \"fail_bounds_check\",\n             26 => \"exchange_malloc\",\n-            27 => \"exchange_free\",\n-            28 => \"malloc\",\n-            29 => \"free\",\n-            30 => \"borrow_as_imm\",\n-            31 => \"borrow_as_mut\",\n-            32 => \"return_to_mut\",\n-            33 => \"check_not_borrowed\",\n-            34 => \"strdup_uniq\",\n-            35 => \"record_borrow\",\n-            36 => \"unrecord_borrow\",\n-\n-            37 => \"start\",\n+            27 => \"closure_exchange_malloc\",\n+            28 => \"exchange_free\",\n+            29 => \"malloc\",\n+            30 => \"free\",\n+            31 => \"borrow_as_imm\",\n+            32 => \"borrow_as_mut\",\n+            33 => \"return_to_mut\",\n+            34 => \"check_not_borrowed\",\n+            35 => \"strdup_uniq\",\n+            36 => \"record_borrow\",\n+            37 => \"unrecord_borrow\",\n+\n+            38 => \"start\",\n+\n+            39 => \"ty_desc\",\n+            40 => \"ty_visitor\",\n+            41 => \"opaque\",\n \n             _ => \"???\"\n         }\n     }\n \n     // FIXME #4621: Method macros sure would be nice here.\n \n-    pub fn const_trait(&const self) -> def_id {\n-        self.items[ConstTraitLangItem as uint].get()\n+    pub fn freeze_trait(&self) -> def_id {\n+        self.items[FreezeTraitLangItem as uint].get()\n     }\n-    pub fn copy_trait(&const self) -> def_id {\n+    pub fn copy_trait(&self) -> def_id {\n         self.items[CopyTraitLangItem as uint].get()\n     }\n-    pub fn owned_trait(&const self) -> def_id {\n-        self.items[OwnedTraitLangItem as uint].get()\n+    pub fn send_trait(&self) -> def_id {\n+        self.items[SendTraitLangItem as uint].get()\n     }\n-    pub fn sized_trait(&const self) -> def_id {\n+    pub fn sized_trait(&self) -> def_id {\n         self.items[SizedTraitLangItem as uint].get()\n     }\n \n-    pub fn drop_trait(&const self) -> def_id {\n+    pub fn drop_trait(&self) -> def_id {\n         self.items[DropTraitLangItem as uint].get()\n     }\n \n-    pub fn add_trait(&const self) -> def_id {\n+    pub fn add_trait(&self) -> def_id {\n         self.items[AddTraitLangItem as uint].get()\n     }\n-    pub fn sub_trait(&const self) -> def_id {\n+    pub fn sub_trait(&self) -> def_id {\n         self.items[SubTraitLangItem as uint].get()\n     }\n-    pub fn mul_trait(&const self) -> def_id {\n+    pub fn mul_trait(&self) -> def_id {\n         self.items[MulTraitLangItem as uint].get()\n     }\n-    pub fn div_trait(&const self) -> def_id {\n+    pub fn div_trait(&self) -> def_id {\n         self.items[DivTraitLangItem as uint].get()\n     }\n-    pub fn rem_trait(&const self) -> def_id {\n+    pub fn rem_trait(&self) -> def_id {\n         self.items[RemTraitLangItem as uint].get()\n     }\n-    pub fn neg_trait(&const self) -> def_id {\n+    pub fn neg_trait(&self) -> def_id {\n         self.items[NegTraitLangItem as uint].get()\n     }\n-    pub fn not_trait(&const self) -> def_id {\n+    pub fn not_trait(&self) -> def_id {\n         self.items[NotTraitLangItem as uint].get()\n     }\n-    pub fn bitxor_trait(&const self) -> def_id {\n+    pub fn bitxor_trait(&self) -> def_id {\n         self.items[BitXorTraitLangItem as uint].get()\n     }\n-    pub fn bitand_trait(&const self) -> def_id {\n+    pub fn bitand_trait(&self) -> def_id {\n         self.items[BitAndTraitLangItem as uint].get()\n     }\n-    pub fn bitor_trait(&const self) -> def_id {\n+    pub fn bitor_trait(&self) -> def_id {\n         self.items[BitOrTraitLangItem as uint].get()\n     }\n-    pub fn shl_trait(&const self) -> def_id {\n+    pub fn shl_trait(&self) -> def_id {\n         self.items[ShlTraitLangItem as uint].get()\n     }\n-    pub fn shr_trait(&const self) -> def_id {\n+    pub fn shr_trait(&self) -> def_id {\n         self.items[ShrTraitLangItem as uint].get()\n     }\n-    pub fn index_trait(&const self) -> def_id {\n+    pub fn index_trait(&self) -> def_id {\n         self.items[IndexTraitLangItem as uint].get()\n     }\n \n-    pub fn eq_trait(&const self) -> def_id {\n+    pub fn eq_trait(&self) -> def_id {\n         self.items[EqTraitLangItem as uint].get()\n     }\n-    pub fn ord_trait(&const self) -> def_id {\n+    pub fn ord_trait(&self) -> def_id {\n         self.items[OrdTraitLangItem as uint].get()\n     }\n \n-    pub fn str_eq_fn(&const self) -> def_id {\n+    pub fn str_eq_fn(&self) -> def_id {\n         self.items[StrEqFnLangItem as uint].get()\n     }\n-    pub fn uniq_str_eq_fn(&const self) -> def_id {\n+    pub fn uniq_str_eq_fn(&self) -> def_id {\n         self.items[UniqStrEqFnLangItem as uint].get()\n     }\n-    pub fn annihilate_fn(&const self) -> def_id {\n+    pub fn annihilate_fn(&self) -> def_id {\n         self.items[AnnihilateFnLangItem as uint].get()\n     }\n-    pub fn log_type_fn(&const self) -> def_id {\n+    pub fn log_type_fn(&self) -> def_id {\n         self.items[LogTypeFnLangItem as uint].get()\n     }\n-    pub fn fail_fn(&const self) -> def_id {\n+    pub fn fail_fn(&self) -> def_id {\n         self.items[FailFnLangItem as uint].get()\n     }\n-    pub fn fail_bounds_check_fn(&const self) -> def_id {\n+    pub fn fail_bounds_check_fn(&self) -> def_id {\n         self.items[FailBoundsCheckFnLangItem as uint].get()\n     }\n-    pub fn exchange_malloc_fn(&const self) -> def_id {\n+    pub fn exchange_malloc_fn(&self) -> def_id {\n         self.items[ExchangeMallocFnLangItem as uint].get()\n     }\n-    pub fn exchange_free_fn(&const self) -> def_id {\n+    pub fn closure_exchange_malloc_fn(&self) -> def_id {\n+        self.items[ClosureExchangeMallocFnLangItem as uint].get()\n+    }\n+    pub fn exchange_free_fn(&self) -> def_id {\n         self.items[ExchangeFreeFnLangItem as uint].get()\n     }\n-    pub fn malloc_fn(&const self) -> def_id {\n+    pub fn malloc_fn(&self) -> def_id {\n         self.items[MallocFnLangItem as uint].get()\n     }\n-    pub fn free_fn(&const self) -> def_id {\n+    pub fn free_fn(&self) -> def_id {\n         self.items[FreeFnLangItem as uint].get()\n     }\n-    pub fn borrow_as_imm_fn(&const self) -> def_id {\n+    pub fn borrow_as_imm_fn(&self) -> def_id {\n         self.items[BorrowAsImmFnLangItem as uint].get()\n     }\n-    pub fn borrow_as_mut_fn(&const self) -> def_id {\n+    pub fn borrow_as_mut_fn(&self) -> def_id {\n         self.items[BorrowAsMutFnLangItem as uint].get()\n     }\n-    pub fn return_to_mut_fn(&const self) -> def_id {\n+    pub fn return_to_mut_fn(&self) -> def_id {\n         self.items[ReturnToMutFnLangItem as uint].get()\n     }\n-    pub fn check_not_borrowed_fn(&const self) -> def_id {\n+    pub fn check_not_borrowed_fn(&self) -> def_id {\n         self.items[CheckNotBorrowedFnLangItem as uint].get()\n     }\n-    pub fn strdup_uniq_fn(&const self) -> def_id {\n+    pub fn strdup_uniq_fn(&self) -> def_id {\n         self.items[StrDupUniqFnLangItem as uint].get()\n     }\n-    pub fn record_borrow_fn(&const self) -> def_id {\n+    pub fn record_borrow_fn(&self) -> def_id {\n         self.items[RecordBorrowFnLangItem as uint].get()\n     }\n-    pub fn unrecord_borrow_fn(&const self) -> def_id {\n+    pub fn unrecord_borrow_fn(&self) -> def_id {\n         self.items[UnrecordBorrowFnLangItem as uint].get()\n     }\n-    pub fn start_fn(&const self) -> def_id {\n+    pub fn start_fn(&self) -> def_id {\n         self.items[StartFnLangItem as uint].get()\n     }\n-}\n-\n-fn LanguageItemCollector(crate: @crate,\n-                         session: Session)\n-                      -> LanguageItemCollector {\n-    let mut item_refs = HashMap::new();\n-\n-    item_refs.insert(@\"const\", ConstTraitLangItem as uint);\n-    item_refs.insert(@\"copy\", CopyTraitLangItem as uint);\n-    item_refs.insert(@\"owned\", OwnedTraitLangItem as uint);\n-    item_refs.insert(@\"sized\", SizedTraitLangItem as uint);\n-\n-    item_refs.insert(@\"drop\", DropTraitLangItem as uint);\n-\n-    item_refs.insert(@\"add\", AddTraitLangItem as uint);\n-    item_refs.insert(@\"sub\", SubTraitLangItem as uint);\n-    item_refs.insert(@\"mul\", MulTraitLangItem as uint);\n-    item_refs.insert(@\"div\", DivTraitLangItem as uint);\n-    item_refs.insert(@\"rem\", RemTraitLangItem as uint);\n-    item_refs.insert(@\"neg\", NegTraitLangItem as uint);\n-    item_refs.insert(@\"not\", NotTraitLangItem as uint);\n-    item_refs.insert(@\"bitxor\", BitXorTraitLangItem as uint);\n-    item_refs.insert(@\"bitand\", BitAndTraitLangItem as uint);\n-    item_refs.insert(@\"bitor\", BitOrTraitLangItem as uint);\n-    item_refs.insert(@\"shl\", ShlTraitLangItem as uint);\n-    item_refs.insert(@\"shr\", ShrTraitLangItem as uint);\n-    item_refs.insert(@\"index\", IndexTraitLangItem as uint);\n-\n-    item_refs.insert(@\"eq\", EqTraitLangItem as uint);\n-    item_refs.insert(@\"ord\", OrdTraitLangItem as uint);\n-\n-    item_refs.insert(@\"str_eq\", StrEqFnLangItem as uint);\n-    item_refs.insert(@\"uniq_str_eq\", UniqStrEqFnLangItem as uint);\n-    item_refs.insert(@\"annihilate\", AnnihilateFnLangItem as uint);\n-    item_refs.insert(@\"log_type\", LogTypeFnLangItem as uint);\n-    item_refs.insert(@\"fail_\", FailFnLangItem as uint);\n-    item_refs.insert(@\"fail_bounds_check\",\n-                     FailBoundsCheckFnLangItem as uint);\n-    item_refs.insert(@\"exchange_malloc\", ExchangeMallocFnLangItem as uint);\n-    item_refs.insert(@\"exchange_free\", ExchangeFreeFnLangItem as uint);\n-    item_refs.insert(@\"malloc\", MallocFnLangItem as uint);\n-    item_refs.insert(@\"free\", FreeFnLangItem as uint);\n-    item_refs.insert(@\"borrow_as_imm\", BorrowAsImmFnLangItem as uint);\n-    item_refs.insert(@\"borrow_as_mut\", BorrowAsMutFnLangItem as uint);\n-    item_refs.insert(@\"return_to_mut\", ReturnToMutFnLangItem as uint);\n-    item_refs.insert(@\"check_not_borrowed\",\n-                     CheckNotBorrowedFnLangItem as uint);\n-    item_refs.insert(@\"strdup_uniq\", StrDupUniqFnLangItem as uint);\n-    item_refs.insert(@\"record_borrow\", RecordBorrowFnLangItem as uint);\n-    item_refs.insert(@\"unrecord_borrow\", UnrecordBorrowFnLangItem as uint);\n-    item_refs.insert(@\"start\", StartFnLangItem as uint);\n-\n-    LanguageItemCollector {\n-        crate: crate,\n-        session: session,\n-        items: LanguageItems::new(),\n-        item_refs: item_refs\n+    pub fn ty_desc(&const self) -> def_id {\n+        self.items[TyDescStructLangItem as uint].get()\n+    }\n+    pub fn ty_visitor(&const self) -> def_id {\n+        self.items[TyVisitorTraitLangItem as uint].get()\n+    }\n+    pub fn opaque(&const self) -> def_id {\n+        self.items[OpaqueStructLangItem as uint].get()\n     }\n }\n \n-struct LanguageItemCollector {\n+struct LanguageItemCollector<'self> {\n     items: LanguageItems,\n \n-    crate: @crate,\n+    crate: &'self crate,\n     session: Session,\n \n     item_refs: HashMap<@str, uint>,\n }\n \n-impl LanguageItemCollector {\n+impl<'self> LanguageItemCollector<'self> {\n+    pub fn new<'a>(crate: &'a crate, session: Session)\n+                   -> LanguageItemCollector<'a> {\n+        let mut item_refs = HashMap::new();\n+\n+        item_refs.insert(@\"freeze\", FreezeTraitLangItem as uint);\n+        item_refs.insert(@\"copy\", CopyTraitLangItem as uint);\n+        item_refs.insert(@\"send\", SendTraitLangItem as uint);\n+        item_refs.insert(@\"sized\", SizedTraitLangItem as uint);\n+\n+        item_refs.insert(@\"drop\", DropTraitLangItem as uint);\n+\n+        item_refs.insert(@\"add\", AddTraitLangItem as uint);\n+        item_refs.insert(@\"sub\", SubTraitLangItem as uint);\n+        item_refs.insert(@\"mul\", MulTraitLangItem as uint);\n+        item_refs.insert(@\"div\", DivTraitLangItem as uint);\n+        item_refs.insert(@\"rem\", RemTraitLangItem as uint);\n+        item_refs.insert(@\"neg\", NegTraitLangItem as uint);\n+        item_refs.insert(@\"not\", NotTraitLangItem as uint);\n+        item_refs.insert(@\"bitxor\", BitXorTraitLangItem as uint);\n+        item_refs.insert(@\"bitand\", BitAndTraitLangItem as uint);\n+        item_refs.insert(@\"bitor\", BitOrTraitLangItem as uint);\n+        item_refs.insert(@\"shl\", ShlTraitLangItem as uint);\n+        item_refs.insert(@\"shr\", ShrTraitLangItem as uint);\n+        item_refs.insert(@\"index\", IndexTraitLangItem as uint);\n+\n+        item_refs.insert(@\"eq\", EqTraitLangItem as uint);\n+        item_refs.insert(@\"ord\", OrdTraitLangItem as uint);\n+\n+        item_refs.insert(@\"str_eq\", StrEqFnLangItem as uint);\n+        item_refs.insert(@\"uniq_str_eq\", UniqStrEqFnLangItem as uint);\n+        item_refs.insert(@\"annihilate\", AnnihilateFnLangItem as uint);\n+        item_refs.insert(@\"log_type\", LogTypeFnLangItem as uint);\n+        item_refs.insert(@\"fail_\", FailFnLangItem as uint);\n+        item_refs.insert(@\"fail_bounds_check\",\n+                         FailBoundsCheckFnLangItem as uint);\n+        item_refs.insert(@\"exchange_malloc\", ExchangeMallocFnLangItem as uint);\n+        item_refs.insert(@\"closure_exchange_malloc\", ClosureExchangeMallocFnLangItem as uint);\n+        item_refs.insert(@\"exchange_free\", ExchangeFreeFnLangItem as uint);\n+        item_refs.insert(@\"malloc\", MallocFnLangItem as uint);\n+        item_refs.insert(@\"free\", FreeFnLangItem as uint);\n+        item_refs.insert(@\"borrow_as_imm\", BorrowAsImmFnLangItem as uint);\n+        item_refs.insert(@\"borrow_as_mut\", BorrowAsMutFnLangItem as uint);\n+        item_refs.insert(@\"return_to_mut\", ReturnToMutFnLangItem as uint);\n+        item_refs.insert(@\"check_not_borrowed\",\n+                         CheckNotBorrowedFnLangItem as uint);\n+        item_refs.insert(@\"strdup_uniq\", StrDupUniqFnLangItem as uint);\n+        item_refs.insert(@\"record_borrow\", RecordBorrowFnLangItem as uint);\n+        item_refs.insert(@\"unrecord_borrow\", UnrecordBorrowFnLangItem as uint);\n+        item_refs.insert(@\"start\", StartFnLangItem as uint);\n+        item_refs.insert(@\"ty_desc\", TyDescStructLangItem as uint);\n+        item_refs.insert(@\"ty_visitor\", TyVisitorTraitLangItem as uint);\n+        item_refs.insert(@\"opaque\", OpaqueStructLangItem as uint);\n+\n+        LanguageItemCollector {\n+            crate: crate,\n+            session: session,\n+            items: LanguageItems::new(),\n+            item_refs: item_refs\n+        }\n+    }\n+\n     pub fn match_and_collect_meta_item(&mut self,\n                                        item_def_id: def_id,\n-                                       meta_item: @meta_item) {\n+                                       meta_item: &meta_item) {\n         match meta_item.node {\n             meta_name_value(key, literal) => {\n                 match literal.node {\n@@ -366,7 +390,7 @@ impl LanguageItemCollector {\n \n     pub fn match_and_collect_item(&mut self,\n                                   item_def_id: def_id,\n-                                  key: @str,\n+                                  key: &str,\n                                   value: @str) {\n         if \"lang\" != key {\n             return;    // Didn't match.\n@@ -391,7 +415,7 @@ impl LanguageItemCollector {\n         let this: *mut LanguageItemCollector = &mut *self;\n         visit_crate(self.crate, ((), mk_simple_visitor(@SimpleVisitor {\n             visit_item: |item| {\n-                for item.attrs.each |attribute| {\n+                for item.attrs.iter().advance |attribute| {\n                     unsafe {\n                         (*this).match_and_collect_meta_item(\n                             local_def(item.id),\n@@ -416,7 +440,7 @@ impl LanguageItemCollector {\n     }\n \n     pub fn check_completeness(&self) {\n-        for self.item_refs.each |&key, &item_ref| {\n+        for self.item_refs.iter().advance |(&key, &item_ref)| {\n             match self.items.items[item_ref] {\n                 None => {\n                     self.session.err(fmt!(\"no item found for `%s`\", key));\n@@ -435,10 +459,10 @@ impl LanguageItemCollector {\n     }\n }\n \n-pub fn collect_language_items(crate: @crate,\n+pub fn collect_language_items(crate: &crate,\n                               session: Session)\n                            -> LanguageItems {\n-    let mut collector = LanguageItemCollector(crate, session);\n+    let mut collector = LanguageItemCollector::new(crate, session);\n     collector.collect();\n     let LanguageItemCollector { items, _ } = collector;\n     session.abort_if_errors();"}, {"sha": "ce09f790ef45f4c2b626666328c18cb717f4c0b9", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 81, "deletions": 68, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -8,25 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n \n use driver::session;\n use middle::ty;\n use middle::pat_util;\n use util::ppaux::{ty_to_str};\n \n-use core::char;\n-use core::cmp;\n-use core::hashmap::HashMap;\n-use core::i16;\n-use core::i32;\n-use core::i64;\n-use core::i8;\n-use core::u16;\n-use core::u32;\n-use core::u64;\n-use core::u8;\n-use core::vec;\n+use std::char;\n+use std::cmp;\n+use std::hashmap::HashMap;\n+use std::i16;\n+use std::i32;\n+use std::i64;\n+use std::i8;\n+use std::u16;\n+use std::u32;\n+use std::u64;\n+use std::u8;\n+use std::vec;\n use extra::smallintmap::SmallIntMap;\n use syntax::attr;\n use syntax::codemap::span;\n@@ -96,6 +95,8 @@ pub enum lint {\n \n     missing_doc,\n     unreachable_code,\n+\n+    warnings,\n }\n \n pub fn level_to_str(lv: level) -> &'static str {\n@@ -137,7 +138,7 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n     (\"ctypes\",\n      LintSpec {\n         lint: ctypes,\n-        desc: \"proper use of core::libc types in foreign modules\",\n+        desc: \"proper use of std::libc types in foreign modules\",\n         default: warn\n      }),\n \n@@ -280,6 +281,13 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n         desc: \"detects unreachable code\",\n         default: warn\n     }),\n+\n+    (\"warnings\",\n+     LintSpec {\n+        lint: warnings,\n+        desc: \"mass-change the level for lints which produce warnings\",\n+        default: warn\n+    }),\n ];\n \n /*\n@@ -288,7 +296,7 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n  */\n pub fn get_lint_dict() -> LintDict {\n     let mut map = HashMap::new();\n-    for lint_table.each|&(k, v)| {\n+    for lint_table.iter().advance |&(k, v)| {\n         map.insert(k, v);\n     }\n     return map;\n@@ -352,7 +360,7 @@ impl Context {\n     }\n \n     fn lint_to_str(&self, lint: lint) -> &'static str {\n-        for self.dict.each |k, v| {\n+        for self.dict.iter().advance |(k, v)| {\n             if v.lint == lint {\n                 return *k;\n             }\n@@ -362,10 +370,11 @@ impl Context {\n \n     fn span_lint(&self, lint: lint, span: span, msg: &str) {\n         let (level, src) = match self.curr.find(&(lint as uint)) {\n+            None => { return }\n+            Some(&(warn, src)) => (self.get_level(warnings), src),\n             Some(&pair) => pair,\n-            None => { return; }\n         };\n-        if level == allow { return; }\n+        if level == allow { return }\n \n         let mut note = None;\n         let msg = match src {\n@@ -435,7 +444,8 @@ impl Context {\n \n         // detect doc(hidden)\n         let mut doc_hidden = false;\n-        for attr::find_attrs_by_name(attrs, \"doc\").each |attr| {\n+        let r = attr::find_attrs_by_name(attrs, \"doc\");\n+        for r.iter().advance |attr| {\n             match attr::get_meta_item_list(attr.node.value) {\n                 Some(s) => {\n                     if attr::find_meta_items_by_name(s, \"hidden\").len() > 0 {\n@@ -472,12 +482,12 @@ impl Context {\n         // pair instead of just one visitor.\n         match n {\n             Item(it) => {\n-                for self.visitors.each |&(orig, stopping)| {\n+                for self.visitors.iter().advance |&(orig, stopping)| {\n                     (orig.visit_item)(it, (self, stopping));\n                 }\n             }\n             Crate(c) => {\n-                for self.visitors.each |&(_, stopping)| {\n+                for self.visitors.iter().advance |&(_, stopping)| {\n                     visit::visit_crate(c, (self, stopping));\n                 }\n             }\n@@ -486,7 +496,7 @@ impl Context {\n             // to be a no-op, so manually invoke visit_fn.\n             Method(m) => {\n                 let fk = visit::fk_method(copy m.ident, &m.generics, m);\n-                for self.visitors.each |&(orig, stopping)| {\n+                for self.visitors.iter().advance |&(orig, stopping)| {\n                     (orig.visit_fn)(&fk, &m.decl, &m.body, m.span, m.id,\n                                     (self, stopping));\n                 }\n@@ -497,12 +507,12 @@ impl Context {\n \n pub fn each_lint(sess: session::Session,\n                  attrs: &[ast::attribute],\n-                 f: &fn(@ast::meta_item, level, @str) -> bool) -> bool\n-{\n-    for [allow, warn, deny, forbid].each |&level| {\n+                 f: &fn(@ast::meta_item, level, @str) -> bool) -> bool {\n+    let xs = [allow, warn, deny, forbid];\n+    for xs.iter().advance |&level| {\n         let level_name = level_to_str(level);\n         let attrs = attr::find_attrs_by_name(attrs, level_name);\n-        for attrs.each |attr| {\n+        for attrs.iter().advance |attr| {\n             let meta = attr.node.value;\n             let metas = match meta.node {\n                 ast::meta_list(_, ref metas) => metas,\n@@ -511,7 +521,7 @@ pub fn each_lint(sess: session::Session,\n                     loop;\n                 }\n             };\n-            for metas.each |meta| {\n+            for metas.iter().advance |meta| {\n                 match meta.node {\n                     ast::meta_word(lintname) => {\n                         if !f(*meta, level, lintname) {\n@@ -525,7 +535,7 @@ pub fn each_lint(sess: session::Session,\n             }\n         }\n     }\n-    return true;\n+    true\n }\n \n // Take a visitor, and modify it so that it will not proceed past subitems.\n@@ -690,10 +700,10 @@ fn lint_type_limits() -> visit::vt<@mut Context> {\n     })\n }\n \n-fn check_item_default_methods(cx: &Context, item: @ast::item) {\n+fn check_item_default_methods(cx: &Context, item: &ast::item) {\n     match item.node {\n         ast::item_trait(_, _, ref methods) => {\n-            for methods.each |method| {\n+            for methods.iter().advance |method| {\n                 match *method {\n                     ast::required(*) => {}\n                     ast::provided(*) => {\n@@ -707,41 +717,43 @@ fn check_item_default_methods(cx: &Context, item: @ast::item) {\n     }\n }\n \n-fn check_item_ctypes(cx: &Context, it: @ast::item) {\n-\n-    fn check_foreign_fn(cx: &Context, decl: &ast::fn_decl) {\n-        let tys = vec::map(decl.inputs, |a| a.ty );\n-        for vec::each(vec::append_one(tys, decl.output)) |ty| {\n-            match ty.node {\n-              ast::ty_path(_, id) => {\n+fn check_item_ctypes(cx: &Context, it: &ast::item) {\n+    fn check_ty(cx: &Context, ty: &ast::Ty) {\n+        match ty.node {\n+            ast::ty_path(_, _, id) => {\n                 match cx.tcx.def_map.get_copy(&id) {\n-                  ast::def_prim_ty(ast::ty_int(ast::ty_i)) => {\n-                    cx.span_lint(ctypes, ty.span,\n-                        \"found rust type `int` in foreign module, while \\\n-                         libc::c_int or libc::c_long should be used\");\n-                  }\n-                  ast::def_prim_ty(ast::ty_uint(ast::ty_u)) => {\n-                    cx.span_lint(ctypes, ty.span,\n-                        \"found rust type `uint` in foreign module, while \\\n-                         libc::c_uint or libc::c_ulong should be used\");\n-                  }\n-                  _ => ()\n+                    ast::def_prim_ty(ast::ty_int(ast::ty_i)) => {\n+                        cx.span_lint(ctypes, ty.span,\n+                                \"found rust type `int` in foreign module, while \\\n+                                libc::c_int or libc::c_long should be used\");\n+                    }\n+                    ast::def_prim_ty(ast::ty_uint(ast::ty_u)) => {\n+                        cx.span_lint(ctypes, ty.span,\n+                                \"found rust type `uint` in foreign module, while \\\n+                                libc::c_uint or libc::c_ulong should be used\");\n+                    }\n+                    _ => ()\n                 }\n-              }\n-              _ => ()\n             }\n+            _ => ()\n+        }\n+    }\n+\n+    fn check_foreign_fn(cx: &Context, decl: &ast::fn_decl) {\n+        for decl.inputs.iter().advance |in| {\n+            check_ty(cx, in.ty);\n         }\n+        check_ty(cx, decl.output)\n     }\n \n     match it.node {\n       ast::item_foreign_mod(ref nmod) if !nmod.abis.is_intrinsic() => {\n-        for nmod.items.each |ni| {\n+        for nmod.items.iter().advance |ni| {\n             match ni.node {\n-              ast::foreign_item_fn(ref decl, _, _) => {\n-                check_foreign_fn(cx, decl);\n-              }\n-              // FIXME #4622: Not implemented.\n-              ast::foreign_item_const(*) => {}\n+                ast::foreign_item_fn(ref decl, _, _) => {\n+                    check_foreign_fn(cx, decl);\n+                }\n+                ast::foreign_item_static(t, _) => { check_ty(cx, t); }\n             }\n         }\n       }\n@@ -777,12 +789,13 @@ fn check_type_for_lint(cx: &Context, lint: lint, span: span, ty: ty::t) {\n }\n \n fn check_type(cx: &Context, span: span, ty: ty::t) {\n-    for [managed_heap_memory, owned_heap_memory, heap_memory].each |lint| {\n+    let xs = [managed_heap_memory, owned_heap_memory, heap_memory];\n+    for xs.iter().advance |lint| {\n         check_type_for_lint(cx, *lint, span, ty);\n     }\n }\n \n-fn check_item_heap(cx: &Context, it: @ast::item) {\n+fn check_item_heap(cx: &Context, it: &ast::item) {\n     match it.node {\n       ast::item_fn(*) |\n       ast::item_ty(*) |\n@@ -796,7 +809,7 @@ fn check_item_heap(cx: &Context, it: @ast::item) {\n     // If it's a struct, we also have to check the fields' types\n     match it.node {\n         ast::item_struct(struct_def, _) => {\n-            for struct_def.fields.each |struct_field| {\n+            for struct_def.fields.iter().advance |struct_field| {\n                 check_type(cx, struct_field.span,\n                            ty::node_id_to_type(cx.tcx,\n                                                struct_field.node.id));\n@@ -836,7 +849,7 @@ fn lint_path_statement() -> visit::vt<@mut Context> {\n     })\n }\n \n-fn check_item_non_camel_case_types(cx: &Context, it: @ast::item) {\n+fn check_item_non_camel_case_types(cx: &Context, it: &ast::item) {\n     fn is_camel_case(cx: ty::ctxt, ident: ast::ident) -> bool {\n         let ident = cx.sess.str_of(ident);\n         assert!(!ident.is_empty());\n@@ -860,7 +873,7 @@ fn check_item_non_camel_case_types(cx: &Context, it: @ast::item) {\n         }\n         ast::item_enum(ref enum_definition, _) => {\n             check_case(cx, it.ident, it.span);\n-            for enum_definition.variants.each |variant| {\n+            for enum_definition.variants.iter().advance |variant| {\n                 check_case(cx, variant.node.name, variant.span);\n             }\n         }\n@@ -905,7 +918,7 @@ fn lint_unused_mut() -> visit::vt<@mut Context> {\n     }\n \n     fn visit_fn_decl(cx: &Context, fd: &ast::fn_decl) {\n-        for fd.inputs.each |arg| {\n+        for fd.inputs.iter().advance |arg| {\n             if arg.is_mutbl {\n                 check_pat(cx, arg.pat);\n             }\n@@ -958,7 +971,7 @@ fn lint_session() -> visit::vt<@mut Context> {\n fn lint_unnecessary_allocations() -> visit::vt<@mut Context> {\n     // Warn if string and vector literals with sigils are immediately borrowed.\n     // Those can have the sigil removed.\n-    fn check(cx: &Context, e: @ast::expr) {\n+    fn check(cx: &Context, e: &ast::expr) {\n         match e.node {\n             ast::expr_vstore(e2, ast::expr_vstore_uniq) |\n             ast::expr_vstore(e2, ast::expr_vstore_box) => {\n@@ -1003,7 +1016,7 @@ fn lint_missing_doc() -> visit::vt<@mut Context> {\n         // If we have doc(hidden), nothing to do\n         if cx.doc_hidden { return }\n         // If we're documented, nothing to do\n-        if attrs.any(|a| a.node.is_sugared_doc) { return }\n+        if attrs.iter().any_(|a| a.node.is_sugared_doc) { return }\n \n         // otherwise, warn!\n         cx.span_lint(missing_doc, sp, msg);\n@@ -1052,7 +1065,7 @@ fn lint_missing_doc() -> visit::vt<@mut Context> {\n                 ast::item_struct(sdef, _) if it.vis == ast::public => {\n                     check_attrs(cx, it.attrs, it.span,\n                                 \"missing documentation for a struct\");\n-                    for sdef.fields.each |field| {\n+                    for sdef.fields.iter().advance |field| {\n                         match field.node.kind {\n                             ast::named_field(_, vis) if vis != ast::private => {\n                                 check_attrs(cx, field.node.attrs, field.span,\n@@ -1100,7 +1113,7 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n     }\n \n     // Install command-line options, overriding defaults.\n-    for tcx.sess.opts.lint_opts.each |&(lint, level)| {\n+    for tcx.sess.opts.lint_opts.iter().advance |&(lint, level)| {\n         cx.set_level(lint, level, CommandLine);\n     }\n \n@@ -1157,8 +1170,8 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n \n     // If we missed any lints added to the session, then there's a bug somewhere\n     // in the iteration code.\n-    for tcx.sess.lints.each |_, v| {\n-        for v.each |t| {\n+    for tcx.sess.lints.iter().advance |(_, v)| {\n+        for v.iter().advance |t| {\n             match *t {\n                 (lint, span, ref msg) =>\n                     tcx.sess.span_bug(span, fmt!(\"unprocessed lint %?: %s\","}, {"sha": "83f8b161b7522be7c85dd5669b4824d5695533c7", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -102,20 +102,19 @@\n  *   to return explicitly.\n  */\n \n-use core::prelude::*;\n \n use middle::lint::{unused_variable, dead_assignment};\n use middle::pat_util;\n use middle::ty;\n use middle::typeck;\n use middle::moves;\n \n-use core::cast::transmute;\n-use core::hashmap::HashMap;\n-use core::io;\n-use core::to_str;\n-use core::uint;\n-use core::vec;\n+use std::cast::transmute;\n+use std::hashmap::HashMap;\n+use std::io;\n+use std::to_str;\n+use std::uint;\n+use std::vec;\n use syntax::ast::*;\n use syntax::codemap::span;\n use syntax::parse::token::special_idents;\n@@ -150,7 +149,7 @@ fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {\n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: typeck::method_map,\n                    capture_map: moves::CaptureMap,\n-                   crate: @crate) {\n+                   crate: &crate) {\n     let visitor = visit::mk_vt(@visit::Visitor {\n         visit_fn: visit_fn,\n         visit_local: visit_local,\n@@ -322,7 +321,7 @@ impl IrMaps {\n         self.capture_info_map.insert(node_id, @cs);\n     }\n \n-    pub fn captures(&mut self, expr: @expr) -> @~[CaptureInfo] {\n+    pub fn captures(&mut self, expr: &expr) -> @~[CaptureInfo] {\n         match self.capture_info_map.find(&expr.id) {\n           Some(&caps) => caps,\n           None => {\n@@ -355,7 +354,7 @@ fn visit_fn(fk: &visit::fn_kind,\n         debug!(\"creating fn_maps: %x\", transmute(&*fn_maps));\n     }\n \n-    for decl.inputs.each |arg| {\n+    for decl.inputs.iter().advance |arg| {\n         do pat_util::pat_bindings(this.tcx.def_map, arg.pat)\n                 |_bm, arg_id, _x, path| {\n             debug!(\"adding argument %d\", arg_id);\n@@ -368,7 +367,7 @@ fn visit_fn(fk: &visit::fn_kind,\n     match *fk {\n         fk_method(_, _, method) => {\n             match method.explicit_self.node {\n-                sty_value | sty_region(*) | sty_box(_) | sty_uniq(_) => {\n+                sty_value | sty_region(*) | sty_box(_) | sty_uniq => {\n                     fn_maps.add_variable(Arg(method.self_id,\n                                              special_idents::self_));\n                 }\n@@ -431,7 +430,7 @@ fn visit_local(local: @local, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n \n fn visit_arm(arm: &arm, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n     let def_map = this.tcx.def_map;\n-    for arm.pats.each |pat| {\n+    for arm.pats.iter().advance |pat| {\n         do pat_util::pat_bindings(def_map, *pat) |bm, p_id, sp, path| {\n             debug!(\"adding local variable %d from match with bm %?\",\n                    p_id, bm);\n@@ -470,7 +469,7 @@ fn visit_expr(expr: @expr, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n         // construction site.\n         let cvs = this.capture_map.get(&expr.id);\n         let mut call_caps = ~[];\n-        for cvs.each |cv| {\n+        for cvs.iter().advance |cv| {\n             match moves::moved_variable_node_id_from_def(cv.def) {\n               Some(rv) => {\n                 let cv_ln = this.add_live_node(FreeVarNode(cv.span));\n@@ -596,7 +595,7 @@ impl Liveness {\n         }\n     }\n \n-    pub fn variable_from_path(&self, expr: @expr) -> Option<Variable> {\n+    pub fn variable_from_path(&self, expr: &expr) -> Option<Variable> {\n         match expr.node {\n           expr_path(_) => {\n             let def = self.tcx.def_map.get_copy(&expr.id);\n@@ -923,7 +922,7 @@ impl Liveness {\n         }\n     }\n \n-    pub fn propagate_through_stmt(&self, stmt: @stmt, succ: LiveNode)\n+    pub fn propagate_through_stmt(&self, stmt: &stmt, succ: LiveNode)\n                                   -> LiveNode {\n         match stmt.node {\n           stmt_decl(decl, _) => {\n@@ -940,7 +939,7 @@ impl Liveness {\n         }\n     }\n \n-    pub fn propagate_through_decl(&self, decl: @decl, succ: LiveNode)\n+    pub fn propagate_through_decl(&self, decl: &decl, succ: LiveNode)\n                                   -> LiveNode {\n         match decl.node {\n             decl_local(ref local) => {\n@@ -950,7 +949,7 @@ impl Liveness {\n         }\n     }\n \n-    pub fn propagate_through_local(&self, local: @local, succ: LiveNode)\n+    pub fn propagate_through_local(&self, local: &local, succ: LiveNode)\n                                    -> LiveNode {\n         // Note: we mark the variable as defined regardless of whether\n         // there is an initializer.  Initially I had thought to only mark\n@@ -1075,7 +1074,7 @@ impl Liveness {\n             let ln = self.live_node(expr.id, expr.span);\n             self.init_empty(ln, succ);\n             let mut first_merge = true;\n-            for arms.each |arm| {\n+            for arms.iter().advance |arm| {\n                 let body_succ =\n                     self.propagate_through_block(&arm.body, succ);\n                 let guard_succ =\n@@ -1293,7 +1292,7 @@ impl Liveness {\n     }\n \n     // see comment on propagate_through_lvalue()\n-    pub fn write_lvalue(&self, expr: @expr, succ: LiveNode, acc: uint)\n+    pub fn write_lvalue(&self, expr: &expr, succ: LiveNode, acc: uint)\n                         -> LiveNode {\n         match expr.node {\n           expr_path(_) => self.access_path(expr, succ, acc),\n@@ -1306,7 +1305,7 @@ impl Liveness {\n         }\n     }\n \n-    pub fn access_path(&self, expr: @expr, succ: LiveNode, acc: uint)\n+    pub fn access_path(&self, expr: &expr, succ: LiveNode, acc: uint)\n                        -> LiveNode {\n         let def = self.tcx.def_map.get_copy(&expr.id);\n         match moves::moved_variable_node_id_from_def(def) {\n@@ -1324,7 +1323,7 @@ impl Liveness {\n     }\n \n     pub fn propagate_through_loop(&self,\n-                                  expr: @expr,\n+                                  expr: &expr,\n                                   cond: Option<@expr>,\n                                   body: &blk,\n                                   succ: LiveNode)\n@@ -1453,12 +1452,12 @@ fn check_expr(expr: @expr, (this, vt): (@Liveness, vt<@Liveness>)) {\n       }\n \n       expr_inline_asm(ref ia) => {\n-        for ia.inputs.each |&(_, in)| {\n+        for ia.inputs.iter().advance |&(_, in)| {\n           (vt.visit_expr)(in, (this, vt));\n         }\n \n         // Output operands must be lvalues\n-        for ia.outputs.each |&(_, out)| {\n+        for ia.outputs.iter().advance |&(_, out)| {\n           match out.node {\n             expr_addr_of(_, inner) => {\n               this.check_lvalue(inner, vt);\n@@ -1594,7 +1593,7 @@ impl Liveness {\n     }\n \n     pub fn warn_about_unused_args(&self, decl: &fn_decl, entry_ln: LiveNode) {\n-        for decl.inputs.each |arg| {\n+        for decl.inputs.iter().advance |arg| {\n             do pat_util::pat_bindings(self.tcx.def_map, arg.pat)\n                     |_bm, p_id, sp, _n| {\n                 let var = self.variable(p_id, sp);"}, {"sha": "fd36858ba68801ead844d4e67d3f1a4cee7e6167", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 77, "deletions": 55, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -46,14 +46,13 @@\n  * then an index to jump forward to the relevant item.\n  */\n \n-use core::prelude::*;\n \n use middle::ty;\n use middle::typeck;\n-use util::ppaux::{ty_to_str, region_to_str, Repr};\n+use util::ppaux::{ty_to_str, region_ptr_to_str, Repr};\n use util::common::indenter;\n \n-use core::uint;\n+use std::uint;\n use syntax::ast::{m_imm, m_const, m_mutbl};\n use syntax::ast;\n use syntax::codemap::span;\n@@ -78,7 +77,7 @@ pub enum categorization {\n }\n \n #[deriving(Eq)]\n-struct CopiedUpvar {\n+pub struct CopiedUpvar {\n     upvar_id: ast::node_id,\n     onceness: ast::Onceness,\n }\n@@ -447,19 +446,29 @@ impl mem_categorization_ctxt {\n                    -> cmt {\n         match def {\n           ast::def_fn(*) | ast::def_static_method(*) | ast::def_mod(_) |\n-          ast::def_foreign_mod(_) | ast::def_const(_) |\n+          ast::def_foreign_mod(_) | ast::def_static(_, false) |\n           ast::def_use(_) | ast::def_variant(*) |\n           ast::def_trait(_) | ast::def_ty(_) | ast::def_prim_ty(_) |\n           ast::def_ty_param(*) | ast::def_struct(*) |\n           ast::def_typaram_binder(*) | ast::def_region(_) |\n-          ast::def_label(_) | ast::def_self_ty(*) => {\n-            @cmt_ {\n-                id:id,\n-                span:span,\n-                cat:cat_static_item,\n-                mutbl: McImmutable,\n-                ty:expr_ty\n-            }\n+          ast::def_label(_) | ast::def_self_ty(*) | ast::def_method(*) => {\n+              @cmt_ {\n+                  id:id,\n+                  span:span,\n+                  cat:cat_static_item,\n+                  mutbl: McImmutable,\n+                  ty:expr_ty\n+              }\n+          }\n+\n+          ast::def_static(_, true) => {\n+              @cmt_ {\n+                  id:id,\n+                  span:span,\n+                  cat:cat_static_item,\n+                  mutbl: McDeclared,\n+                  ty:expr_ty\n+              }\n           }\n \n           ast::def_arg(vid, mutbl) => {\n@@ -497,30 +506,41 @@ impl mem_categorization_ctxt {\n               let ty = ty::node_id_to_type(self.tcx, fn_node_id);\n               match ty::get(ty).sty {\n                   ty::ty_closure(ref closure_ty) => {\n-                      let sigil = closure_ty.sigil;\n-                      match sigil {\n-                          ast::BorrowedSigil => {\n-                              let upvar_cmt =\n-                                  self.cat_def(id, span, expr_ty, *inner);\n-                              @cmt_ {\n-                                  id:id,\n-                                  span:span,\n-                                  cat:cat_stack_upvar(upvar_cmt),\n-                                  mutbl:upvar_cmt.mutbl.inherit(),\n-                                  ty:upvar_cmt.ty\n-                              }\n+                      // Decide whether to use implicit reference or by copy/move\n+                      // capture for the upvar. This, combined with the onceness,\n+                      // determines whether the closure can move out of it.\n+                      let var_is_refd = match (closure_ty.sigil, closure_ty.onceness) {\n+                          // Many-shot stack closures can never move out.\n+                          (ast::BorrowedSigil, ast::Many) => true,\n+                          // 1-shot stack closures can move out with \"-Z once-fns\".\n+                          (ast::BorrowedSigil, ast::Once)\n+                              if self.tcx.sess.once_fns() => false,\n+                          (ast::BorrowedSigil, ast::Once) => true,\n+                          // Heap closures always capture by copy/move, and can\n+                          // move out iff they are once.\n+                          (ast::OwnedSigil, _) | (ast::ManagedSigil, _) => false,\n+\n+                      };\n+                      if var_is_refd {\n+                          let upvar_cmt =\n+                              self.cat_def(id, span, expr_ty, *inner);\n+                          @cmt_ {\n+                              id:id,\n+                              span:span,\n+                              cat:cat_stack_upvar(upvar_cmt),\n+                              mutbl:upvar_cmt.mutbl.inherit(),\n+                              ty:upvar_cmt.ty\n                           }\n-                          ast::OwnedSigil | ast::ManagedSigil => {\n-                              // FIXME #2152 allow mutation of moved upvars\n-                              @cmt_ {\n-                                  id:id,\n-                                  span:span,\n-                                  cat:cat_copied_upvar(CopiedUpvar {\n-                                      upvar_id: upvar_id,\n-                                      onceness: closure_ty.onceness}),\n-                                  mutbl:McImmutable,\n-                                  ty:expr_ty\n-                              }\n+                      } else {\n+                          // FIXME #2152 allow mutation of moved upvars\n+                          @cmt_ {\n+                              id:id,\n+                              span:span,\n+                              cat:cat_copied_upvar(CopiedUpvar {\n+                                  upvar_id: upvar_id,\n+                                  onceness: closure_ty.onceness}),\n+                              mutbl:McImmutable,\n+                              ty:expr_ty\n                           }\n                       }\n                   }\n@@ -872,31 +892,31 @@ impl mem_categorization_ctxt {\n                         }\n                     };\n \n-                    for subpats.eachi |i, &subpat| {\n+                    for subpats.iter().enumerate().advance |(i, &subpat)| {\n                         let subpat_ty = self.pat_ty(subpat); // see (*)\n \n                         let subcmt =\n                             self.cat_imm_interior(\n                                 pat, downcast_cmt, subpat_ty,\n                                 InteriorField(PositionalField(i)));\n \n-                        self.cat_pattern(subcmt, subpat, op);\n+                        self.cat_pattern(subcmt, subpat, |x,y| op(x,y));\n                     }\n                 }\n                 Some(&ast::def_fn(*)) |\n                 Some(&ast::def_struct(*)) => {\n-                    for subpats.eachi |i, &subpat| {\n+                    for subpats.iter().enumerate().advance |(i, &subpat)| {\n                         let subpat_ty = self.pat_ty(subpat); // see (*)\n                         let cmt_field =\n                             self.cat_imm_interior(\n                                 pat, cmt, subpat_ty,\n                                 InteriorField(PositionalField(i)));\n-                        self.cat_pattern(cmt_field, subpat, op);\n+                        self.cat_pattern(cmt_field, subpat, |x,y| op(x,y));\n                     }\n                 }\n-                Some(&ast::def_const(*)) => {\n-                    for subpats.each |&subpat| {\n-                        self.cat_pattern(cmt, subpat, op);\n+                Some(&ast::def_static(*)) => {\n+                    for subpats.iter().advance |&subpat| {\n+                        self.cat_pattern(cmt, subpat, |x,y| op(x,y));\n                     }\n                 }\n                 _ => {\n@@ -917,22 +937,22 @@ impl mem_categorization_ctxt {\n \n           ast::pat_struct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n-            for field_pats.each |fp| {\n+            for field_pats.iter().advance |fp| {\n                 let field_ty = self.pat_ty(fp.pat); // see (*)\n                 let cmt_field = self.cat_field(pat, cmt, fp.ident, field_ty);\n-                self.cat_pattern(cmt_field, fp.pat, op);\n+                self.cat_pattern(cmt_field, fp.pat, |x,y| op(x,y));\n             }\n           }\n \n           ast::pat_tup(ref subpats) => {\n             // (p1, ..., pN)\n-            for subpats.eachi |i, &subpat| {\n+            for subpats.iter().enumerate().advance |(i, &subpat)| {\n                 let subpat_ty = self.pat_ty(subpat); // see (*)\n                 let subcmt =\n                     self.cat_imm_interior(\n                         pat, cmt, subpat_ty,\n                         InteriorField(PositionalField(i)));\n-                self.cat_pattern(subcmt, subpat, op);\n+                self.cat_pattern(subcmt, subpat, |x,y| op(x,y));\n             }\n           }\n \n@@ -945,16 +965,16 @@ impl mem_categorization_ctxt {\n \n           ast::pat_vec(ref before, slice, ref after) => {\n               let elt_cmt = self.cat_index(pat, cmt, 0);\n-              for before.each |&before_pat| {\n-                  self.cat_pattern(elt_cmt, before_pat, op);\n+              for before.iter().advance |&before_pat| {\n+                  self.cat_pattern(elt_cmt, before_pat, |x,y| op(x,y));\n               }\n               for slice.iter().advance |&slice_pat| {\n                   let slice_ty = self.pat_ty(slice_pat);\n                   let slice_cmt = self.cat_rvalue(pat, slice_ty);\n-                  self.cat_pattern(slice_cmt, slice_pat, op);\n+                  self.cat_pattern(slice_cmt, slice_pat, |x,y| op(x,y));\n               }\n-              for after.each |&after_pat| {\n-                  self.cat_pattern(elt_cmt, after_pat, op);\n+              for after.iter().advance |&after_pat| {\n+                  self.cat_pattern(elt_cmt, after_pat, |x,y| op(x,y));\n               }\n           }\n \n@@ -1026,7 +1046,7 @@ impl mem_categorization_ctxt {\n     }\n \n     pub fn region_to_str(&self, r: ty::Region) -> ~str {\n-        region_to_str(self.tcx, r)\n+        region_ptr_to_str(self.tcx, r)\n     }\n }\n \n@@ -1041,7 +1061,8 @@ pub fn field_mutbl(tcx: ty::ctxt,\n     // Need to refactor so that struct/enum fields can be treated uniformly.\n     match ty::get(base_ty).sty {\n       ty::ty_struct(did, _) => {\n-        for ty::lookup_struct_fields(tcx, did).each |fld| {\n+        let r = ty::lookup_struct_fields(tcx, did);\n+        for r.iter().advance |fld| {\n             if fld.ident == f_name {\n                 return Some(ast::m_imm);\n             }\n@@ -1050,7 +1071,8 @@ pub fn field_mutbl(tcx: ty::ctxt,\n       ty::ty_enum(*) => {\n         match tcx.def_map.get_copy(&node_id) {\n           ast::def_variant(_, variant_id) => {\n-            for ty::lookup_struct_fields(tcx, variant_id).each |fld| {\n+            let r = ty::lookup_struct_fields(tcx, variant_id);\n+            for r.iter().advance |fld| {\n                 if fld.ident == f_name {\n                     return Some(ast::m_imm);\n                 }"}, {"sha": "c7d338b1976ad94baafc7c57e669e4f5cff55448", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -126,7 +126,6 @@ and so on.\n \n */\n \n-use core::prelude::*;\n \n use middle::pat_util::{pat_bindings};\n use middle::freevars;\n@@ -136,8 +135,8 @@ use util::ppaux;\n use util::ppaux::Repr;\n use util::common::indenter;\n \n-use core::at_vec;\n-use core::hashmap::{HashSet, HashMap};\n+use std::at_vec;\n+use std::hashmap::{HashSet, HashMap};\n use syntax::ast::*;\n use syntax::ast_util;\n use syntax::visit;\n@@ -183,14 +182,15 @@ struct VisitContext {\n     move_maps: MoveMaps\n }\n \n+#[deriving(Eq)]\n enum UseMode {\n     Move,        // This value or something owned by it is moved.\n     Read         // Read no matter what the type.\n }\n \n pub fn compute_moves(tcx: ty::ctxt,\n                      method_map: method_map,\n-                     crate: @crate) -> MoveMaps\n+                     crate: &crate) -> MoveMaps\n {\n     let visitor = visit::mk_vt(@visit::Visitor {\n         visit_expr: compute_modes_for_expr,\n@@ -232,7 +232,7 @@ fn compute_modes_for_expr(expr: @expr,\n \n impl VisitContext {\n     pub fn consume_exprs(&self, exprs: &[@expr], visitor: vt<VisitContext>) {\n-        for exprs.each |expr| {\n+        for exprs.iter().advance |expr| {\n             self.consume_expr(*expr, visitor);\n         }\n     }\n@@ -263,7 +263,7 @@ impl VisitContext {\n \n         debug!(\"consume_block(blk.id=%?)\", blk.node.id);\n \n-        for blk.node.stmts.each |stmt| {\n+        for blk.node.stmts.iter().advance |stmt| {\n             (visitor.visit_stmt)(*stmt, (*self, visitor));\n         }\n \n@@ -335,7 +335,27 @@ impl VisitContext {\n             }\n \n             expr_call(callee, ref args, _) => {    // callee(args)\n-                self.use_expr(callee, Read, visitor);\n+                // Figure out whether the called function is consumed.\n+                let mode = match ty::get(ty::expr_ty(self.tcx, callee)).sty {\n+                    ty::ty_closure(ref cty) => {\n+                        match cty.onceness {\n+                        Once => Move,\n+                        Many => Read,\n+                        }\n+                    },\n+                    ty::ty_bare_fn(*) => Read,\n+                    ref x =>\n+                        self.tcx.sess.span_bug(callee.span,\n+                            fmt!(\"non-function type in moves for expr_call: %?\", x)),\n+                };\n+                // Note we're not using consume_expr, which uses type_moves_by_default\n+                // to determine the mode, for this. The reason is that while stack\n+                // closures should be noncopyable, they shouldn't move by default;\n+                // calling a closure should only consume it if it's once.\n+                if mode == Move {\n+                    self.move_maps.moves_map.insert(callee.id);\n+                }\n+                self.use_expr(callee, mode, visitor);\n                 self.use_fn_args(callee.id, *args, visitor);\n             }\n \n@@ -347,7 +367,7 @@ impl VisitContext {\n             }\n \n             expr_struct(_, ref fields, opt_with) => {\n-                for fields.each |field| {\n+                for fields.iter().advance |field| {\n                     self.consume_expr(field.node.expr, visitor);\n                 }\n \n@@ -370,8 +390,8 @@ impl VisitContext {\n                     // any fields which (1) were not explicitly\n                     // specified and (2) have a type that\n                     // moves-by-default:\n-                    let consume_with = with_fields.any(|tf| {\n-                        !fields.any(|f| f.node.ident == tf.ident) &&\n+                    let consume_with = with_fields.iter().any_(|tf| {\n+                        !fields.iter().any_(|f| f.node.ident == tf.ident) &&\n                             ty::type_moves_by_default(self.tcx, tf.mt.ty)\n                     });\n \n@@ -398,7 +418,7 @@ impl VisitContext {\n             expr_match(discr, ref arms) => {\n                 // We must do this first so that `arms_have_by_move_bindings`\n                 // below knows which bindings are moves.\n-                for arms.each |arm| {\n+                for arms.iter().advance |arm| {\n                     self.consume_arm(arm, visitor);\n                 }\n \n@@ -521,7 +541,7 @@ impl VisitContext {\n     }\n \n     pub fn use_overloaded_operator(&self,\n-                                   expr: @expr,\n+                                   expr: &expr,\n                                    receiver_expr: @expr,\n                                    arg_exprs: &[@expr],\n                                    visitor: vt<VisitContext>)\n@@ -534,7 +554,7 @@ impl VisitContext {\n \n         // for overloaded operatrs, we are always passing in a\n         // borrowed pointer, so it's always read mode:\n-        for arg_exprs.each |arg_expr| {\n+        for arg_exprs.iter().advance |arg_expr| {\n             self.use_expr(*arg_expr, Read, visitor);\n         }\n \n@@ -591,7 +611,7 @@ impl VisitContext {\n                        arg_exprs: &[@expr],\n                        visitor: vt<VisitContext>) {\n         //! Uses the argument expressions.\n-        for arg_exprs.each |arg_expr| {\n+        for arg_exprs.iter().advance |arg_expr| {\n             self.use_fn_arg(*arg_expr, visitor);\n         }\n     }\n@@ -605,8 +625,8 @@ impl VisitContext {\n                                       moves_map: MovesMap,\n                                       arms: &[arm])\n                                       -> Option<@pat> {\n-        for arms.each |arm| {\n-            for arm.pats.each |&pat| {\n+        for arms.iter().advance |arm| {\n+            for arm.pats.iter().advance |&pat| {\n                 for ast_util::walk_pat(pat) |p| {\n                     if moves_map.contains(&p.id) {\n                         return Some(p);"}, {"sha": "f6da8f392cc1d7e9c8f616dd35c1ba525a91e68a", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n \n use middle::resolve;\n \n-use core::hashmap::HashMap;\n+use std::hashmap::HashMap;\n use syntax::ast::*;\n use syntax::ast_util::{path_to_ident, walk_pat};\n use syntax::codemap::span;\n@@ -29,7 +28,7 @@ pub fn pat_id_map(dm: resolve::DefMap, pat: @pat) -> PatIdMap {\n     map\n }\n \n-pub fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: @pat) -> bool {\n+pub fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: &pat) -> bool {\n     match pat.node {\n         pat_enum(_, _) | pat_ident(_, _, None) | pat_struct(*) => {\n             match dm.find(&pat.id) {\n@@ -45,7 +44,7 @@ pub fn pat_is_const(dm: resolve::DefMap, pat: &pat) -> bool {\n     match pat.node {\n         pat_ident(_, _, None) | pat_enum(*) => {\n             match dm.find(&pat.id) {\n-                Some(&def_const(*)) => true,\n+                Some(&def_static(_, false)) => true,\n                 _ => false\n             }\n         }"}, {"sha": "5e544dc06e3dc5c77e44d2a3ad27ca4072074839", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -11,7 +11,6 @@\n // A pass that checks to make sure private fields and methods aren't used\n // outside their scopes.\n \n-use core::prelude::*;\n \n use metadata::csearch;\n use middle::ty::{ty_struct, ty_enum};\n@@ -20,7 +19,7 @@ use middle::typeck::{method_map, method_origin, method_param, method_self};\n use middle::typeck::{method_super};\n use middle::typeck::{method_static, method_trait};\n \n-use core::util::ignore;\n+use std::util::ignore;\n use syntax::ast::{decl_item, def, def_fn, def_id, def_static_method};\n use syntax::ast::{def_variant, expr_field, expr_method_call, expr_path};\n use syntax::ast::{expr_struct, expr_unary, ident, inherited, item_enum};\n@@ -40,7 +39,7 @@ use syntax::visit;\n \n pub fn check_crate<'mm>(tcx: ty::ctxt,\n                    method_map: &'mm method_map,\n-                   crate: @ast::crate) {\n+                   crate: &ast::crate) {\n     let privileged_items = @mut ~[];\n \n     // Adds an item to its scope.\n@@ -52,15 +51,15 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                 *count += 1;\n             }\n             item_impl(_, _, _, ref methods) => {\n-                for methods.each |method| {\n+                for methods.iter().advance |method| {\n                     privileged_items.push(method.id);\n                     *count += 1;\n                 }\n                 privileged_items.push(item.id);\n                 *count += 1;\n             }\n             item_foreign_mod(ref foreign_mod) => {\n-                for foreign_mod.items.each |foreign_item| {\n+                for foreign_mod.items.iter().advance |foreign_item| {\n                     privileged_items.push(foreign_item.id);\n                     *count += 1;\n                 }\n@@ -72,7 +71,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n     // Adds items that are privileged to this scope.\n     let add_privileged_items: @fn(&[@ast::item]) -> uint = |items| {\n         let mut count = 0;\n-        for items.each |&item| {\n+        for items.iter().advance |&item| {\n             add_privileged_item(item, &mut count);\n         }\n         count\n@@ -231,7 +230,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n     let check_field: @fn(span: span, id: ast::def_id, ident: ast::ident) =\n             |span, id, ident| {\n         let fields = ty::lookup_struct_fields(tcx, id);\n-        for fields.each |field| {\n+        for fields.iter().advance |field| {\n             if field.ident != ident { loop; }\n             if field.vis == private {\n                 tcx.sess.span_err(span, fmt!(\"field `%s` is private\",\n@@ -252,7 +251,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                                                          method_id.node);\n             if is_private &&\n                     (container_id.crate != local_crate ||\n-                     !privileged_items.contains(&(container_id.node))) {\n+                     !privileged_items.iter().any_(|x| x == &(container_id.node))) {\n                 tcx.sess.span_err(span,\n                                   fmt!(\"method `%s` is private\",\n                                        token::ident_to_str(name)));\n@@ -280,7 +279,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n             def_fn(def_id, _) => {\n                 if def_id.crate == local_crate {\n                     if local_item_is_private(span, def_id.node) &&\n-                            !privileged_items.contains(&def_id.node) {\n+                            !privileged_items.iter().any_(|x| x == &def_id.node) {\n                         tcx.sess.span_err(span,\n                                           fmt!(\"function `%s` is private\",\n                                                token::ident_to_str(path.idents.last())));\n@@ -324,8 +323,8 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                                     match (*methods)[method_num] {\n                                         provided(method)\n                                              if method.vis == private &&\n-                                             !privileged_items\n-                                             .contains(&(trait_id.node)) => {\n+                                             !privileged_items.iter()\n+                                             .any_(|x| x == &(trait_id.node)) => {\n                                             tcx.sess.span_err(span,\n                                                               fmt!(\"method `%s` is private\",\n                                                                    token::ident_to_str(&method\n@@ -377,7 +376,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n         visit_block: |block, (method_map, visitor)| {\n             // Gather up all the privileged items.\n             let mut n_added = 0;\n-            for block.node.stmts.each |stmt| {\n+            for block.node.stmts.iter().advance |stmt| {\n                 match stmt.node {\n                     stmt_decl(decl, _) => {\n                         match decl.node {\n@@ -409,7 +408,8 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                     match ty::get(ty::type_autoderef(tcx, ty::expr_ty(tcx,\n                                                           base))).sty {\n                         ty_struct(id, _)\n-                        if id.crate != local_crate || !privileged_items.contains(&(id.node)) => {\n+                        if id.crate != local_crate || !privileged_items.iter()\n+                                .any_(|x| x == &(id.node)) => {\n                             debug!(\"(privacy checking) checking field access\");\n                             check_field(expr.span, id, ident);\n                         }\n@@ -422,7 +422,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                                                           base))).sty {\n                         ty_struct(id, _)\n                         if id.crate != local_crate ||\n-                           !privileged_items.contains(&(id.node)) => {\n+                           !privileged_items.iter().any_(|x| x == &(id.node)) => {\n                             match method_map.find(&expr.id) {\n                                 None => {\n                                     tcx.sess.span_bug(expr.span,\n@@ -448,8 +448,8 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                     match ty::get(ty::expr_ty(tcx, expr)).sty {\n                         ty_struct(id, _) => {\n                             if id.crate != local_crate ||\n-                                    !privileged_items.contains(&(id.node)) {\n-                                for (*fields).each |field| {\n+                                    !privileged_items.iter().any_(|x| x == &(id.node)) {\n+                                for (*fields).iter().advance |field| {\n                                         debug!(\"(privacy checking) checking \\\n                                                 field in struct literal\");\n                                     check_field(expr.span, id,\n@@ -459,10 +459,10 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                         }\n                         ty_enum(id, _) => {\n                             if id.crate != local_crate ||\n-                                    !privileged_items.contains(&(id.node)) {\n+                                    !privileged_items.iter().any_(|x| x == &(id.node)) {\n                                 match tcx.def_map.get_copy(&expr.id) {\n                                     def_variant(_, variant_id) => {\n-                                        for (*fields).each |field| {\n+                                        for (*fields).iter().advance |field| {\n                                                 debug!(\"(privacy checking) \\\n                                                         checking field in \\\n                                                         struct variant \\\n@@ -496,7 +496,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                     match ty::get(ty::expr_ty(tcx, operand)).sty {\n                         ty_enum(id, _) => {\n                             if id.crate != local_crate ||\n-                                !privileged_items.contains(&(id.node)) {\n+                                !privileged_items.iter().any_(|x| x == &(id.node)) {\n                                 check_variant(expr.span, id);\n                             }\n                         }\n@@ -514,8 +514,8 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                     match ty::get(ty::pat_ty(tcx, pattern)).sty {\n                         ty_struct(id, _) => {\n                             if id.crate != local_crate ||\n-                                    !privileged_items.contains(&(id.node)) {\n-                                for fields.each |field| {\n+                                    !privileged_items.iter().any_(|x| x == &(id.node)) {\n+                                for fields.iter().advance |field| {\n                                         debug!(\"(privacy checking) checking \\\n                                                 struct pattern\");\n                                     check_field(pattern.span, id,\n@@ -525,11 +525,10 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                         }\n                         ty_enum(enum_id, _) => {\n                             if enum_id.crate != local_crate ||\n-                                    !privileged_items.contains(\n-                                        &enum_id.node) {\n+                                    !privileged_items.iter().any_(|x| x == &enum_id.node) {\n                                 match tcx.def_map.find(&pattern.id) {\n                                     Some(&def_variant(_, variant_id)) => {\n-                                        for fields.each |field| {\n+                                        for fields.iter().advance |field| {\n                                             debug!(\"(privacy checking) \\\n                                                     checking field in \\\n                                                     struct variant pattern\");"}, {"sha": "97bad93dc358a639abdbf24479cf50bcff2ce886", "filename": "src/librustc/middle/reachable.rs", "status": "added", "additions": 434, "deletions": 0, "changes": 434, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -0,0 +1,434 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Finds items that are externally reachable, to determine which items\n+// need to have their metadata (and possibly their AST) serialized.\n+// All items that can be referred to through an exported name are\n+// reachable, and when a reachable thing is inline or generic, it\n+// makes all other generics or inline functions that it references\n+// reachable as well.\n+\n+use std::iterator::IteratorUtil;\n+\n+use middle::ty;\n+use middle::typeck;\n+\n+use std::hashmap::HashSet;\n+use syntax::ast::*;\n+use syntax::ast_map;\n+use syntax::ast_util::def_id_of_def;\n+use syntax::attr;\n+use syntax::parse::token;\n+use syntax::visit::Visitor;\n+use syntax::visit;\n+\n+// Returns true if the given set of attributes contains the `#[inline]`\n+// attribute.\n+fn attributes_specify_inlining(attrs: &[attribute]) -> bool {\n+    attr::attrs_contains_name(attrs, \"inline\")\n+}\n+\n+// Returns true if the given set of generics implies that the item it's\n+// associated with must be inlined.\n+fn generics_require_inlining(generics: &Generics) -> bool {\n+    !generics.ty_params.is_empty()\n+}\n+\n+// Returns true if the given item must be inlined because it may be\n+// monomorphized or it was marked with `#[inline]`. This will only return\n+// true for functions.\n+fn item_might_be_inlined(item: @item) -> bool {\n+    if attributes_specify_inlining(item.attrs) {\n+        return true\n+    }\n+\n+    match item.node {\n+        item_fn(_, _, _, ref generics, _) => {\n+            generics_require_inlining(generics)\n+        }\n+        _ => false,\n+    }\n+}\n+\n+// Returns true if the given type method must be inlined because it may be\n+// monomorphized or it was marked with `#[inline]`.\n+fn ty_method_might_be_inlined(ty_method: &ty_method) -> bool {\n+    attributes_specify_inlining(ty_method.attrs) ||\n+        generics_require_inlining(&ty_method.generics)\n+}\n+\n+// Returns true if the given trait method must be inlined because it may be\n+// monomorphized or it was marked with `#[inline]`.\n+fn trait_method_might_be_inlined(trait_method: &trait_method) -> bool {\n+    match *trait_method {\n+        required(ref ty_method) => ty_method_might_be_inlined(ty_method),\n+        provided(_) => true\n+    }\n+}\n+\n+// The context we're in. If we're in a public context, then public symbols are\n+// marked reachable. If we're in a private context, then only trait\n+// implementations are marked reachable.\n+#[deriving(Eq)]\n+enum PrivacyContext {\n+    PublicContext,\n+    PrivateContext,\n+}\n+\n+// Information needed while computing reachability.\n+struct ReachableContext {\n+    // The type context.\n+    tcx: ty::ctxt,\n+    // The method map, which links node IDs of method call expressions to the\n+    // methods they've been resolved to.\n+    method_map: typeck::method_map,\n+    // The set of items which must be exported in the linkage sense.\n+    reachable_symbols: @mut HashSet<node_id>,\n+    // A worklist of item IDs. Each item ID in this worklist will be inlined\n+    // and will be scanned for further references.\n+    worklist: @mut ~[node_id],\n+}\n+\n+impl ReachableContext {\n+    // Creates a new reachability computation context.\n+    fn new(tcx: ty::ctxt, method_map: typeck::method_map)\n+           -> ReachableContext {\n+        ReachableContext {\n+            tcx: tcx,\n+            method_map: method_map,\n+            reachable_symbols: @mut HashSet::new(),\n+            worklist: @mut ~[],\n+        }\n+    }\n+\n+    // Step 1: Mark all public symbols, and add all public symbols that might\n+    // be inlined to a worklist.\n+    fn mark_public_symbols(&self, crate: @crate) {\n+        let reachable_symbols = self.reachable_symbols;\n+        let worklist = self.worklist;\n+        let visitor = visit::mk_vt(@Visitor {\n+            visit_item: |item, (privacy_context, visitor):\n+                    (PrivacyContext, visit::vt<PrivacyContext>)| {\n+                match item.node {\n+                    item_fn(*) => {\n+                        if privacy_context == PublicContext {\n+                            reachable_symbols.insert(item.id);\n+                        }\n+                        if item_might_be_inlined(item) {\n+                            worklist.push(item.id)\n+                        }\n+                    }\n+                    item_struct(ref struct_def, _) => {\n+                        match struct_def.ctor_id {\n+                            Some(ctor_id) if\n+                                    privacy_context == PublicContext => {\n+                                reachable_symbols.insert(ctor_id);\n+                            }\n+                            Some(_) | None => {}\n+                        }\n+                    }\n+                    item_enum(ref enum_def, _) => {\n+                        if privacy_context == PublicContext {\n+                            for enum_def.variants.iter().advance |variant| {\n+                                reachable_symbols.insert(variant.node.id);\n+                            }\n+                        }\n+                    }\n+                    item_impl(ref generics, trait_ref, _, ref methods) => {\n+                        // XXX(pcwalton): We conservatively assume any methods\n+                        // on a trait implementation are reachable, when this\n+                        // is not the case. We could be more precise by only\n+                        // treating implementations of reachable or cross-\n+                        // crate traits as reachable.\n+\n+                        let should_be_considered_public = |method: @method| {\n+                            (method.vis == public &&\n+                                    privacy_context == PublicContext) ||\n+                                    trait_ref.is_some()\n+                        };\n+\n+                        // Mark all public methods as reachable.\n+                        for methods.iter().advance |&method| {\n+                            if should_be_considered_public(method) {\n+                                reachable_symbols.insert(method.id);\n+                            }\n+                        }\n+\n+                        if generics_require_inlining(generics) {\n+                            // If the impl itself has generics, add all public\n+                            // symbols to the worklist.\n+                            for methods.iter().advance |&method| {\n+                                if should_be_considered_public(method) {\n+                                    worklist.push(method.id)\n+                                }\n+                            }\n+                        } else {\n+                            // Otherwise, add only public methods that have\n+                            // generics to the worklist.\n+                            for methods.iter().advance |method| {\n+                                let generics = &method.generics;\n+                                let attrs = &method.attrs;\n+                                if generics_require_inlining(generics) ||\n+                                        attributes_specify_inlining(*attrs) ||\n+                                        should_be_considered_public(*method) {\n+                                    worklist.push(method.id)\n+                                }\n+                            }\n+                        }\n+                    }\n+                    item_trait(_, _, ref trait_methods) => {\n+                        // Mark all provided methods as reachable.\n+                        if privacy_context == PublicContext {\n+                            for trait_methods.iter().advance |trait_method| {\n+                                match *trait_method {\n+                                    provided(method) => {\n+                                        reachable_symbols.insert(method.id);\n+                                        worklist.push(method.id)\n+                                    }\n+                                    required(_) => {}\n+                                }\n+                            }\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+\n+                if item.vis == public && privacy_context == PublicContext {\n+                    visit::visit_item(item, (PublicContext, visitor))\n+                } else {\n+                    visit::visit_item(item, (PrivateContext, visitor))\n+                }\n+            },\n+            .. *visit::default_visitor()\n+        });\n+\n+        visit::visit_crate(crate, (PublicContext, visitor))\n+    }\n+\n+    // Returns true if the given def ID represents a local item that is\n+    // eligible for inlining and false otherwise.\n+    fn def_id_represents_local_inlined_item(tcx: ty::ctxt, def_id: def_id)\n+                                            -> bool {\n+        if def_id.crate != local_crate {\n+            return false\n+        }\n+\n+        let node_id = def_id.node;\n+        match tcx.items.find(&node_id) {\n+            Some(&ast_map::node_item(item, _)) => {\n+                match item.node {\n+                    item_fn(*) => item_might_be_inlined(item),\n+                    _ => false,\n+                }\n+            }\n+            Some(&ast_map::node_trait_method(trait_method, _, _)) => {\n+                match *trait_method {\n+                    required(_) => false,\n+                    provided(_) => true,\n+                }\n+            }\n+            Some(&ast_map::node_method(method, impl_did, _)) => {\n+                if generics_require_inlining(&method.generics) ||\n+                        attributes_specify_inlining(method.attrs) {\n+                    true\n+                } else {\n+                    // Check the impl. If the generics on the self type of the\n+                    // impl require inlining, this method does too.\n+                    assert!(impl_did.crate == local_crate);\n+                    match tcx.items.find(&impl_did.node) {\n+                        Some(&ast_map::node_item(item, _)) => {\n+                            match item.node {\n+                                item_impl(ref generics, _, _, _) => {\n+                                    generics_require_inlining(generics)\n+                                }\n+                                _ => false\n+                            }\n+                        }\n+                        Some(_) => {\n+                            tcx.sess.span_bug(method.span,\n+                                              \"method is not inside an \\\n+                                               impl?!\")\n+                        }\n+                        None => {\n+                            tcx.sess.span_bug(method.span,\n+                                              \"the impl that this method is \\\n+                                               supposedly inside of doesn't \\\n+                                               exist in the AST map?!\")\n+                        }\n+                    }\n+                }\n+            }\n+            Some(_) => false,\n+            None => false   // This will happen for default methods.\n+        }\n+    }\n+\n+    // Helper function to set up a visitor for `propagate()` below.\n+    fn init_visitor(&self) -> visit::vt<()> {\n+        let (worklist, method_map) = (self.worklist, self.method_map);\n+        let (tcx, reachable_symbols) = (self.tcx, self.reachable_symbols);\n+        visit::mk_vt(@visit::Visitor {\n+            visit_expr: |expr, (_, visitor)| {\n+                match expr.node {\n+                    expr_path(_) => {\n+                        let def = match tcx.def_map.find(&expr.id) {\n+                            Some(&def) => def,\n+                            None => {\n+                                tcx.sess.span_bug(expr.span,\n+                                                  \"def ID not in def map?!\")\n+                            }\n+                        };\n+\n+                        let def_id = def_id_of_def(def);\n+                        if ReachableContext::\n+                                def_id_represents_local_inlined_item(tcx,\n+                                                                     def_id) {\n+                            worklist.push(def_id.node)\n+                        }\n+                        reachable_symbols.insert(def_id.node);\n+                    }\n+                    expr_method_call(*) => {\n+                        match method_map.find(&expr.id) {\n+                            Some(&typeck::method_map_entry {\n+                                origin: typeck::method_static(def_id),\n+                                _\n+                            }) => {\n+                                if ReachableContext::\n+                                    def_id_represents_local_inlined_item(\n+                                        tcx,\n+                                        def_id) {\n+                                    worklist.push(def_id.node)\n+                                }\n+                                reachable_symbols.insert(def_id.node);\n+                            }\n+                            Some(_) => {}\n+                            None => {\n+                                tcx.sess.span_bug(expr.span,\n+                                                  \"method call expression \\\n+                                                   not in method map?!\")\n+                            }\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+\n+                visit::visit_expr(expr, ((), visitor))\n+            },\n+            ..*visit::default_visitor()\n+        })\n+    }\n+\n+    // Step 2: Mark all symbols that the symbols on the worklist touch.\n+    fn propagate(&self) {\n+        let visitor = self.init_visitor();\n+        let mut scanned = HashSet::new();\n+        while self.worklist.len() > 0 {\n+            let search_item = self.worklist.pop();\n+            if scanned.contains(&search_item) {\n+                loop\n+            }\n+            scanned.insert(search_item);\n+            self.reachable_symbols.insert(search_item);\n+\n+            // Find the AST block corresponding to the item and visit it,\n+            // marking all path expressions that resolve to something\n+            // interesting.\n+            match self.tcx.items.find(&search_item) {\n+                Some(&ast_map::node_item(item, _)) => {\n+                    match item.node {\n+                        item_fn(_, _, _, _, ref search_block) => {\n+                            visit::visit_block(search_block, ((), visitor))\n+                        }\n+                        _ => {\n+                            self.tcx.sess.span_bug(item.span,\n+                                                   \"found non-function item \\\n+                                                    in worklist?!\")\n+                        }\n+                    }\n+                }\n+                Some(&ast_map::node_trait_method(trait_method, _, _)) => {\n+                    match *trait_method {\n+                        required(ref ty_method) => {\n+                            self.tcx.sess.span_bug(ty_method.span,\n+                                                   \"found required method in \\\n+                                                    worklist?!\")\n+                        }\n+                        provided(ref method) => {\n+                            visit::visit_block(&method.body, ((), visitor))\n+                        }\n+                    }\n+                }\n+                Some(&ast_map::node_method(ref method, _, _)) => {\n+                    visit::visit_block(&method.body, ((), visitor))\n+                }\n+                Some(_) => {\n+                    let ident_interner = token::get_ident_interner();\n+                    let desc = ast_map::node_id_to_str(self.tcx.items,\n+                                                       search_item,\n+                                                       ident_interner);\n+                    self.tcx.sess.bug(fmt!(\"found unexpected thingy in \\\n+                                            worklist: %s\",\n+                                            desc))\n+                }\n+                None => {\n+                    self.tcx.sess.bug(fmt!(\"found unmapped ID in worklist: \\\n+                                            %d\",\n+                                           search_item))\n+                }\n+            }\n+        }\n+    }\n+\n+    // Step 3: Mark all destructors as reachable.\n+    //\n+    // XXX(pcwalton): This is a conservative overapproximation, but fixing\n+    // this properly would result in the necessity of computing *type*\n+    // reachability, which might result in a compile time loss.\n+    fn mark_destructors_reachable(&self) {\n+        for self.tcx.destructor_for_type.iter().advance\n+                |(_, destructor_def_id)| {\n+            if destructor_def_id.crate == local_crate {\n+                self.reachable_symbols.insert(destructor_def_id.node);\n+            }\n+        }\n+    }\n+}\n+\n+pub fn find_reachable(tcx: ty::ctxt,\n+                      method_map: typeck::method_map,\n+                      crate: @crate)\n+                      -> @mut HashSet<node_id> {\n+    // XXX(pcwalton): We only need to mark symbols that are exported. But this\n+    // is more complicated than just looking at whether the symbol is `pub`,\n+    // because it might be the target of a `pub use` somewhere. For now, I\n+    // think we are fine, because you can't `pub use` something that wasn't\n+    // exported due to the bug whereby `use` only looks through public\n+    // modules even if you're inside the module the `use` appears in. When\n+    // this bug is fixed, however, this code will need to be updated. Probably\n+    // the easiest way to fix this (although a conservative overapproximation)\n+    // is to have the name resolution pass mark all targets of a `pub use` as\n+    // \"must be reachable\".\n+\n+    let reachable_context = ReachableContext::new(tcx, method_map);\n+\n+    // Step 1: Mark all public symbols, and add all public symbols that might\n+    // be inlined to a worklist.\n+    reachable_context.mark_public_symbols(crate);\n+\n+    // Step 2: Mark all symbols that the symbols on the worklist touch.\n+    reachable_context.propagate();\n+\n+    // Step 3: Mark all destructors as reachable.\n+    reachable_context.mark_destructors_reachable();\n+\n+    // Return the set of reachable symbols.\n+    reachable_context.reachable_symbols\n+}\n+"}, {"sha": "f65d3ad464c46ee040fd8bacd0b08242f0f4cb09", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 56, "deletions": 76, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "patch": "@@ -15,9 +15,11 @@ pass builds up the `scope_map`, which describes the parent links in\n the region hierarchy.  The second pass infers which types must be\n region parameterized.\n \n+Most of the documentation on regions can be found in\n+`middle/typeck/infer/region_inference.rs`\n+\n */\n \n-use core::prelude::*;\n \n use driver::session::Session;\n use metadata::csearch;\n@@ -26,16 +28,14 @@ use middle::ty::{region_variance, rv_covariant, rv_invariant};\n use middle::ty::{rv_contravariant, FreeRegion};\n use middle::ty;\n \n-use core::hashmap::{HashMap, HashSet};\n+use std::hashmap::{HashMap, HashSet};\n use syntax::ast_map;\n use syntax::codemap::span;\n use syntax::print::pprust;\n use syntax::parse::token;\n use syntax::parse::token::special_idents;\n use syntax::{ast, visit};\n \n-pub type parent = Option<ast::node_id>;\n-\n /**\n The region maps encode information about region relationships.\n \n@@ -68,17 +68,17 @@ pub struct Context {\n     region_maps: @mut RegionMaps,\n \n     // Scope where variables should be parented to\n-    var_parent: parent,\n+    var_parent: Option<ast::node_id>,\n \n     // Innermost enclosing expression\n-    parent: parent,\n+    parent: Option<ast::node_id>,\n }\n \n impl RegionMaps {\n     pub fn relate_free_regions(&mut self, sub: FreeRegion, sup: FreeRegion) {\n         match self.free_region_map.find_mut(&sub) {\n             Some(sups) => {\n-                if !sups.contains(&sup) {\n+                if !sups.iter().any_(|x| x == &sup) {\n                     sups.push(sup);\n                 }\n                 return;\n@@ -197,12 +197,12 @@ impl RegionMaps {\n         while i < queue.len() {\n             match self.free_region_map.find(&queue[i]) {\n                 Some(parents) => {\n-                    for parents.each |parent| {\n+                    for parents.iter().advance |parent| {\n                         if *parent == sup {\n                             return true;\n                         }\n \n-                        if !queue.contains(parent) {\n+                        if !queue.iter().any_(|x| x == parent) {\n                             queue.push(*parent);\n                         }\n                     }\n@@ -313,28 +313,16 @@ impl RegionMaps {\n     }\n }\n \n-/// Extracts that current parent from cx, failing if there is none.\n-pub fn parent_id(cx: Context, span: span) -> ast::node_id {\n-    match cx.parent {\n-      None => {\n-        cx.sess.span_bug(span, \"crate should not be parent here\");\n-      }\n-      Some(parent_id) => {\n-        parent_id\n-      }\n-    }\n-}\n-\n /// Records the current parent (if any) as the parent of `child_id`.\n-pub fn parent_to_expr(cx: Context, child_id: ast::node_id, sp: span) {\n+fn parent_to_expr(cx: Context, child_id: ast::node_id, sp: span) {\n     debug!(\"region::parent_to_expr(span=%?)\",\n            cx.sess.codemap.span_to_str(sp));\n     for cx.parent.iter().advance |parent_id| {\n         cx.region_maps.record_parent(child_id, *parent_id);\n     }\n }\n \n-pub fn resolve_block(blk: &ast::blk, (cx, visitor): (Context, visit::vt<Context>)) {\n+fn resolve_block(blk: &ast::blk, (cx, visitor): (Context, visit::vt<Context>)) {\n     // Record the parent of this block.\n     parent_to_expr(cx, blk.node.id, blk.span);\n \n@@ -345,17 +333,17 @@ pub fn resolve_block(blk: &ast::blk, (cx, visitor): (Context, visit::vt<Context>\n     visit::visit_block(blk, (new_cx, visitor));\n }\n \n-pub fn resolve_arm(arm: &ast::arm, (cx, visitor): (Context, visit::vt<Context>)) {\n+fn resolve_arm(arm: &ast::arm, (cx, visitor): (Context, visit::vt<Context>)) {\n     visit::visit_arm(arm, (cx, visitor));\n }\n \n-pub fn resolve_pat(pat: @ast::pat, (cx, visitor): (Context, visit::vt<Context>)) {\n+fn resolve_pat(pat: @ast::pat, (cx, visitor): (Context, visit::vt<Context>)) {\n     assert_eq!(cx.var_parent, cx.parent);\n     parent_to_expr(cx, pat.id, pat.span);\n     visit::visit_pat(pat, (cx, visitor));\n }\n \n-pub fn resolve_stmt(stmt: @ast::stmt, (cx, visitor): (Context, visit::vt<Context>)) {\n+fn resolve_stmt(stmt: @ast::stmt, (cx, visitor): (Context, visit::vt<Context>)) {\n     match stmt.node {\n         ast::stmt_decl(*) => {\n             visit::visit_stmt(stmt, (cx, visitor));\n@@ -370,7 +358,7 @@ pub fn resolve_stmt(stmt: @ast::stmt, (cx, visitor): (Context, visit::vt<Context\n     }\n }\n \n-pub fn resolve_expr(expr: @ast::expr, (cx, visitor): (Context, visit::vt<Context>)) {\n+fn resolve_expr(expr: @ast::expr, (cx, visitor): (Context, visit::vt<Context>)) {\n     parent_to_expr(cx, expr.id, expr.span);\n \n     let mut new_cx = cx;\n@@ -409,27 +397,27 @@ pub fn resolve_expr(expr: @ast::expr, (cx, visitor): (Context, visit::vt<Context\n     visit::visit_expr(expr, (new_cx, visitor));\n }\n \n-pub fn resolve_local(local: @ast::local,\n-                     (cx, visitor) : (Context,\n-                                      visit::vt<Context>)) {\n+fn resolve_local(local: @ast::local,\n+                 (cx, visitor) : (Context,\n+                                  visit::vt<Context>)) {\n     assert_eq!(cx.var_parent, cx.parent);\n     parent_to_expr(cx, local.node.id, local.span);\n     visit::visit_local(local, (cx, visitor));\n }\n \n-pub fn resolve_item(item: @ast::item, (cx, visitor): (Context, visit::vt<Context>)) {\n+fn resolve_item(item: @ast::item, (cx, visitor): (Context, visit::vt<Context>)) {\n     // Items create a new outer block scope as far as we're concerned.\n     let new_cx = Context {var_parent: None, parent: None, ..cx};\n     visit::visit_item(item, (new_cx, visitor));\n }\n \n-pub fn resolve_fn(fk: &visit::fn_kind,\n-                  decl: &ast::fn_decl,\n-                  body: &ast::blk,\n-                  sp: span,\n-                  id: ast::node_id,\n-                  (cx, visitor): (Context,\n-                                  visit::vt<Context>)) {\n+fn resolve_fn(fk: &visit::fn_kind,\n+              decl: &ast::fn_decl,\n+              body: &ast::blk,\n+              sp: span,\n+              id: ast::node_id,\n+              (cx, visitor): (Context,\n+                              visit::vt<Context>)) {\n     debug!(\"region::resolve_fn(id=%?, \\\n                                span=%?, \\\n                                body.node.id=%?, \\\n@@ -468,7 +456,7 @@ pub fn resolve_fn(fk: &visit::fn_kind,\n \n pub fn resolve_crate(sess: Session,\n                      def_map: resolve::DefMap,\n-                     crate: @ast::crate) -> @mut RegionMaps\n+                     crate: &ast::crate) -> @mut RegionMaps\n {\n     let region_maps = @mut RegionMaps {\n         scope_map: HashMap::new(),\n@@ -522,14 +510,12 @@ pub struct region_dep {\n     id: ast::node_id\n }\n \n-pub type dep_map = @mut HashMap<ast::node_id, @mut ~[region_dep]>;\n-\n pub struct DetermineRpCtxt {\n     sess: Session,\n     ast_map: ast_map::map,\n     def_map: resolve::DefMap,\n     region_paramd_items: region_paramd_items,\n-    dep_map: dep_map,\n+    dep_map: @mut HashMap<ast::node_id, @mut ~[region_dep]>,\n     worklist: ~[ast::node_id],\n \n     // the innermost enclosing item id\n@@ -619,20 +605,14 @@ impl DetermineRpCtxt {\n                ast_map::node_id_to_str(self.ast_map, self.item_id,\n                                        token::get_ident_interner()),\n                copy self.ambient_variance);\n-        let vec = match self.dep_map.find(&from) {\n-            Some(&vec) => vec,\n-            None => {\n-                let vec = @mut ~[];\n-                let dep_map = self.dep_map;\n-                dep_map.insert(from, vec);\n-                vec\n-            }\n+        let vec = do self.dep_map.find_or_insert_with(from) |_| {\n+            @mut ~[]\n         };\n         let dep = region_dep {\n             ambient_variance: self.ambient_variance,\n             id: self.item_id\n         };\n-        if !vec.contains(&dep) { vec.push(dep); }\n+        if !vec.iter().any_(|x| x == &dep) { vec.push(dep); }\n     }\n \n     // Determines whether a reference to a region that appears in the\n@@ -715,24 +695,24 @@ impl DetermineRpCtxt {\n     }\n }\n \n-pub fn determine_rp_in_item(item: @ast::item,\n-                            (cx, visitor): (@mut DetermineRpCtxt,\n-                                            visit::vt<@mut DetermineRpCtxt>)) {\n+fn determine_rp_in_item(item: @ast::item,\n+                        (cx, visitor): (@mut DetermineRpCtxt,\n+                                        visit::vt<@mut DetermineRpCtxt>)) {\n     do cx.with(item.id, true) {\n         visit::visit_item(item, (cx, visitor));\n     }\n }\n \n-pub fn determine_rp_in_fn(fk: &visit::fn_kind,\n-                          decl: &ast::fn_decl,\n-                          body: &ast::blk,\n-                          _: span,\n-                          _: ast::node_id,\n-                          (cx, visitor): (@mut DetermineRpCtxt,\n-                                          visit::vt<@mut DetermineRpCtxt>)) {\n+fn determine_rp_in_fn(fk: &visit::fn_kind,\n+                      decl: &ast::fn_decl,\n+                      body: &ast::blk,\n+                      _: span,\n+                      _: ast::node_id,\n+                      (cx, visitor): (@mut DetermineRpCtxt,\n+                                      visit::vt<@mut DetermineRpCtxt>)) {\n     do cx.with(cx.item_id, false) {\n         do cx.with_ambient_variance(rv_contravariant) {\n-            for decl.inputs.each |a| {\n+            for decl.inputs.iter().advance |a| {\n                 (visitor.visit_ty)(a.ty, (cx, visitor));\n             }\n         }\n@@ -743,17 +723,17 @@ pub fn determine_rp_in_fn(fk: &visit::fn_kind,\n     }\n }\n \n-pub fn determine_rp_in_ty_method(ty_m: &ast::ty_method,\n-                                 (cx, visitor): (@mut DetermineRpCtxt,\n-                                                 visit::vt<@mut DetermineRpCtxt>)) {\n+fn determine_rp_in_ty_method(ty_m: &ast::ty_method,\n+                             (cx, visitor): (@mut DetermineRpCtxt,\n+                                             visit::vt<@mut DetermineRpCtxt>)) {\n     do cx.with(cx.item_id, false) {\n         visit::visit_ty_method(ty_m, (cx, visitor));\n     }\n }\n \n-pub fn determine_rp_in_ty(ty: @ast::Ty,\n-                          (cx, visitor): (@mut DetermineRpCtxt,\n-                                          visit::vt<@mut DetermineRpCtxt>)) {\n+fn determine_rp_in_ty(ty: @ast::Ty,\n+                      (cx, visitor): (@mut DetermineRpCtxt,\n+                                      visit::vt<@mut DetermineRpCtxt>)) {\n     // we are only interested in types that will require an item to\n     // be region-parameterized.  if cx.item_id is zero, then this type\n     // is not a member of a type defn nor is it a constitutent of an\n@@ -804,7 +784,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n     // then check whether it is region-parameterized and consider\n     // that as a direct dependency.\n     match ty.node {\n-      ast::ty_path(path, id) => {\n+      ast::ty_path(path, _bounds, id) => {\n         match cx.def_map.find(&id) {\n           Some(&ast::def_ty(did)) |\n           Some(&ast::def_trait(did)) |\n@@ -840,10 +820,10 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n         visit_mt(mt, (cx, visitor));\n       }\n \n-      ast::ty_path(path, _) => {\n+      ast::ty_path(path, _bounds, _) => {\n         // type parameters are---for now, anyway---always invariant\n         do cx.with_ambient_variance(rv_invariant) {\n-            for path.types.each |tp| {\n+            for path.types.iter().advance |tp| {\n                 (visitor.visit_ty)(*tp, (cx, visitor));\n             }\n         }\n@@ -856,7 +836,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n         do cx.with(cx.item_id, false) {\n             // parameters are contravariant\n             do cx.with_ambient_variance(rv_contravariant) {\n-                for decl.inputs.each |a| {\n+                for decl.inputs.iter().advance |a| {\n                     (visitor.visit_ty)(a.ty, (cx, visitor));\n                 }\n             }\n@@ -883,7 +863,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n     }\n }\n \n-pub fn determine_rp_in_struct_field(\n+fn determine_rp_in_struct_field(\n         cm: @ast::struct_field,\n         (cx, visitor): (@mut DetermineRpCtxt,\n                         visit::vt<@mut DetermineRpCtxt>)) {\n@@ -893,7 +873,7 @@ pub fn determine_rp_in_struct_field(\n pub fn determine_rp_in_crate(sess: Session,\n                              ast_map: ast_map::map,\n                              def_map: resolve::DefMap,\n-                             crate: @ast::crate)\n+                             crate: &ast::crate)\n                           -> region_paramd_items {\n     let cx = @mut DetermineRpCtxt {\n         sess: sess,\n@@ -936,7 +916,7 @@ pub fn determine_rp_in_crate(sess: Session,\n             match cx.dep_map.find(&c_id) {\n               None => {}\n               Some(deps) => {\n-                for deps.each |dep| {\n+                for deps.iter().advance |dep| {\n                     let v = add_variance(dep.ambient_variance, c_variance);\n                     cx.add_rp(dep.id, v);\n                 }\n@@ -948,7 +928,7 @@ pub fn determine_rp_in_crate(sess: Session,\n     debug!(\"%s\", {\n         debug!(\"Region variance results:\");\n         let region_paramd_items = cx.region_paramd_items;\n-        for region_paramd_items.each |&key, &value| {\n+        for region_paramd_items.iter().advance |(&key, &value)| {\n             debug!(\"item %? (%s) is parameterized with variance %?\",\n                    key,\n                    ast_map::node_id_to_str(ast_map, key,"}, {"sha": "0cbba6b1c363e999a247a4bc3fbbc47a1c53cdb7", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "e5f5315a19c2c9dc38eb752b9991ae529b168e44", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "1d69b20f5c446c5882387077f1023dbe3094592a", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 71, "deletions": 78, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "ab813c0ffc546cf410829db6defc079f8e7bd2b4", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "fadeab0f1f7708bdac1bd52a70889d07c414c0c7", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "d598a6fbcf913e940637a4248364e16fc3ad3f9c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 420, "deletions": 585, "changes": 1005, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/librustc/middle/trans/block.rs", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b60cf0c5b0cf36625083c2624df9fb35d0af3578/src%2Flibrustc%2Fmiddle%2Ftrans%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b60cf0c5b0cf36625083c2624df9fb35d0af3578/src%2Flibrustc%2Fmiddle%2Ftrans%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fblock.rs?ref=b60cf0c5b0cf36625083c2624df9fb35d0af3578"}, {"sha": "8535c84c5cb5e30d4e839dab3bc4216b860671dd", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 163, "deletions": 154, "changes": 317, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "d00479194308b5f8475d66f54a1c7d9631a21325", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 36, "deletions": 55, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "7eac2df10b6c78656df2deaad45f9d9f07344b5e", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 74, "deletions": 77, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "c95ae994cebea3675dbc15d0a8628e7c56b21839", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 85, "deletions": 101, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "8c5a2e70484bcd73ce8f5ce094427578de6989ac", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "8fa86ea77aba90fbd6c720c2ea738a78c1143291", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 253, "deletions": 264, "changes": 517, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "41f1d0e61e53da6b5d07a17f2ef31ddb4e45c302", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 176, "deletions": 100, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "3478925753e22bb1db641282f7953818cdd9c749", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 42, "deletions": 32, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "5b3052a1e1f4c47d632bafe17b72c79136f50dbf", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 165, "deletions": 559, "changes": 724, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "9566f41a45fd7bd868f7d8ccf4c587f7f1c45f4a", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 54, "deletions": 51, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "c2a32ae041e4db443c38fc2e474c310a98b25479", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 53, "deletions": 42, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "dc88ecbe936b09f230b91bc2d15557d964241b95", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 31, "deletions": 27, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "0fe3dfe80c8c9ebe0c89b64d5ed3732821b74b54", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "ac5eb6b067c9ae57d294868eb7a9a3716013eda5", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 444, "deletions": 276, "changes": 720, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "df197ded629ea6210c62e0dc6637a9a219388d08", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 74, "deletions": 80, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "c01f01db5fd150a6cda0a98198f6191f7f4cd6c9", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 160, "deletions": 207, "changes": 367, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "68cf66789bfde2e4d7448717dfc934b1f213ed14", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 151, "deletions": 158, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "893ef3feb5656d637344c3fa2fa6347b5fb4e519", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "f55523b2841882064c4a61f94585974b84761aed", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "9792e623388d234b8e5f94a0449fac36afe2713e", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 155, "deletions": 261, "changes": 416, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "64d6bbec87c48a36d7b9e651a67206b3a02fb55c", "filename": "src/librustc/middle/trans/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "ad48c30747edcc2dc1b68882817719b3ad74335b", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 32, "deletions": 47, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "4641a13604b90aef83b201c493017062a83ebb59", "filename": "src/librustc/middle/trans/reachable.rs", "status": "removed", "additions": 0, "deletions": 246, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/b60cf0c5b0cf36625083c2624df9fb35d0af3578/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b60cf0c5b0cf36625083c2624df9fb35d0af3578/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=b60cf0c5b0cf36625083c2624df9fb35d0af3578"}, {"sha": "9e227da49f8372f7afbbe37e91f4baa59cb5993e", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 65, "deletions": 68, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "89ffb4b5bbaa747e81db0ad078dc11b3eb37d651", "filename": "src/librustc/middle/trans/shape.rs", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b60cf0c5b0cf36625083c2624df9fb35d0af3578/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b60cf0c5b0cf36625083c2624df9fb35d0af3578/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=b60cf0c5b0cf36625083c2624df9fb35d0af3578"}, {"sha": "233508c5f668bfe5b3b15aa399586b7a51df1dfe", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 37, "deletions": 41, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "e52d33fc6e9ae3b437edd474dcb1f9e6c016d42c", "filename": "src/librustc/middle/trans/type_.rs", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "481f08ee192dd56638f8bfc3549491d9abf6ca30", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 108, "deletions": 134, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "b3848f5e86cb8b42907066f46c6346efb9318066", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "ada85c82b304b6a2b8ba9184b5fe436ec9b553b1", "filename": "src/librustc/middle/trans/uniq.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "068ce4e2b33bca3b6b29dc27b9a2a0b7bfc76c6c", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "bbf548d2659a1e77c2e501be71ce07f305fd0ffa", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 257, "deletions": 370, "changes": 627, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "4d2849c521058a42faa3a3da503036256e0b21dc", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 79, "deletions": 41, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "45867ae77e0807f61ad3fe4b786ef41ddca87844", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 47, "deletions": 40, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "cf29d3f7f1f57ef7c2a00fd1be91edb949771b51", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "ee61399113a434fcd5dbb5cda873ce32315e52f2", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 61, "deletions": 49, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "00ebca5abc1476b5777c4c9e6604bd790cd7d5fc", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 440, "deletions": 388, "changes": 828, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "2e41649e4dbb2a0123d95b1b267bd50741669019", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 70, "deletions": 163, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "02c003b7525ef40477b8a9c59508d93f8e1df085", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "d9086334439610d57025d4e19f26f2e8e173407f", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 78, "deletions": 31, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "e5248e01ed79677148ae663cb8a94135ff8b12a4", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "24ac63ac7b079d34423f5413b561952065eae4b8", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 172, "deletions": 217, "changes": 389, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "de05aca61caf52bbcb9bd94c21c1e1b1d6b90d93", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 52, "deletions": 81, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "03d243797b32d1818017fd2f2daca9fa913978b1", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "f03f01732291ffc19b33c544f08783cfc28f957e", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "11bfbc637169e20a81a36397d493acc2c88592b9", "filename": "src/librustc/middle/typeck/infer/doc.rs", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fdoc.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "e533f019b4692724983b2eee1bbdf196a03c823d", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "added", "additions": 472, "deletions": 0, "changes": 472, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "fefbf2336c29fe254cbd9b3401cccec1a071de00", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "b1a6aefd17949830c481313d31fe47f95fbe0e06", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 79, "deletions": 42, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "efb1dc200b521a9045d1111c00abfd9b3e378aa4", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "3360edc6a46787e6041892ca2c3ea82c814a53ad", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 366, "deletions": 298, "changes": 664, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "df6d5dc1b2060060b684104203e9a8e7d1fa6041", "filename": "src/librustc/middle/typeck/infer/region_inference/doc.rs", "status": "added", "additions": 773, "deletions": 0, "changes": 773, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "96cb5d3c747c36f54530e26b69a3ed5be5991329", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "renamed", "additions": 263, "deletions": 767, "changes": 1030, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "previous_filename": "src/librustc/middle/typeck/infer/region_inference.rs"}, {"sha": "941431ce0e3d11742c5310bfa604a558d271b202", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "72178500b54ed2ac41ff76e43a16963fb7f7d302", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "a3d11bedbdc78a29e45c42745fa2fbd8927ec1f6", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "18594f35295a6ee4f5e488af9bbb092872c814c8", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "a7c3350d1d1787cad89aceac3cb4f6c205ad4087", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 68, "deletions": 28, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "bbcfc73853a1e00d292ae078b3ec18afb214c4ea", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "91c875559fec8ef18d6da73134f4fa059e417259", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "a930570dd173845b9dad3aea52397567988a296c", "filename": "src/librustc/rustc.rs", "status": "renamed", "additions": 34, "deletions": 37, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "previous_filename": "src/librustc/rustc.rc"}, {"sha": "1e2e30548ee986d4af28efe56e3730e6ff87e379", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "2bdb6583b2304a962cc2f7f3255eb8a694e58fba", "filename": "src/librustc/util/enum_set.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Futil%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Futil%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fenum_set.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "628940711453411da3b360e6dd510a1b2f12abaf", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 86, "deletions": 54, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "9c586ae95d154ce5048103e8c8c2f16a1ea4c847", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "7655e173e4e2607c3165f6452ca38190c589022c", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "2a9442fbe525b51812c155c09b45e87457f47341", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "dd929fb143b7caf0086fe8e960875b804db60ff1", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "b6728e00fe41ebf771a839a9af2bb52d80951a6a", "filename": "src/librustdoc/demo.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fdemo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fdemo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdemo.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "74d5d467413738b0cab7c811ac0381edd852d0e5", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "b45550c06e44ab40385cf877acd5092bc74f795e", "filename": "src/librustdoc/doc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoc.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "d5d2b4ce6286cea90f1480af57b35880ad05be5d", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "6510384ef01dd8877aaa58274ab2b898b8e53d37", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "1e67f900822cd876547cd96a8cd8546997568be3", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "0705a5c17233ef6a4dc84d5622d588fc6a902f1d", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "9621ea0892b944130f668ccb6edd1936f17fa79e", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "508cf302ede56c0817bb7913c1a0e99878509a70", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "bf782c9d5f321ae846182727dd9a908d216a0575", "filename": "src/librustdoc/parse.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fparse.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "3497e9515c64dd91d613f4d7345beb4dd361ffff", "filename": "src/librustdoc/pass.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpass.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "55ce135f2777a9cbfaf630ad6136dbed85fa351d", "filename": "src/librustdoc/path_pass.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpath_pass.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "cb7da801e96ec01bc81d59cdad75a140c9b29ceb", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "3659d24a254f83b36e66c70e706bae8ef53a0754", "filename": "src/librustdoc/rustdoc.rs", "status": "renamed", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "previous_filename": "src/librustdoc/rustdoc.rc"}, {"sha": "4e297c36dd46d4d3a71adaee8e4f62801e50698d", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "58b7571305d224e66409f0edd6f8fa2dfecb7de6", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "281a59c8cb7af8e132f8e62bda0007a77e1f6d78", "filename": "src/librustdoc/trim_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftrim_pass.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "e40bdb532da932e8fc228b9a6e5bbf910cee7c92", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "7df6b3207802746c02a8afed8be38449f145f2a7", "filename": "src/librustdoc/unindent_pass.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Funindent_pass.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "20e64087442219c463dddc86b946168fafb5a1a0", "filename": "src/librustdoc/util.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustdoc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Futil.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "869b3472422bc207f008f4df69909499e5ae7d4a", "filename": "src/librusti/program.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrusti%2Fprogram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrusti%2Fprogram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Fprogram.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "bbc4b9ff719789478a873c570b3e99c6a4bf0a0d", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "f91d99322390a4577dc272e957ab0f5638b54975", "filename": "src/librusti/rusti.rs", "status": "added", "additions": 687, "deletions": 0, "changes": 687, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "c36c6390a759fe69010cfa2d06946b259e220344", "filename": "src/librustpkg/api.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "c44563d870358eadbbe7c10b56d61fa29ff3ffeb", "filename": "src/librustpkg/conditions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fconditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fconditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fconditions.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "230a0f915ac31bc6854d300f36f1953ce286a82d", "filename": "src/librustpkg/context.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcontext.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "5fe4512603211b6caea05ae1a0afafdc8ee2d63a", "filename": "src/librustpkg/crate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcrate.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "43d727c2989a9bfe6a0dd0491f3d19b65049b50a", "filename": "src/librustpkg/messages.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fmessages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fmessages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fmessages.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "ebe2aa6f92a63b1f3b79e28a2c6f1acc68429a09", "filename": "src/librustpkg/package_id.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fpackage_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fpackage_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_id.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "a508d2ce1535de0cf4e5194be90c25652e97eccd", "filename": "src/librustpkg/package_path.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fpackage_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fpackage_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_path.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "24c1bb9b200f4e21213f25ff6bacd68921038375", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "6371d7263461ee05da0b26ba02e4b1d8e80f5930", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "8ca8ae1b1edfce0aed29eadca76ceeb57f9c6c8d", "filename": "src/librustpkg/rustpkg.rs", "status": "renamed", "additions": 45, "deletions": 33, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "previous_filename": "src/librustpkg/rustpkg.rc"}, {"sha": "d04b2c8f3701ad95e667a1041d65c52c5de41c72", "filename": "src/librustpkg/search.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsearch.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "4acc621e7be245e396eed3ca3943006f0544c674", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 104, "deletions": 48, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "0fd68ca3a20425464c979fc39e3f3d3c11124f1c", "filename": "src/librustpkg/testsuite/fail/src/no-inferred-crates/src/zzyzx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Ftestsuite%2Ffail%2Fsrc%2Fno-inferred-crates%2Fsrc%2Fzzyzx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Ftestsuite%2Ffail%2Fsrc%2Fno-inferred-crates%2Fsrc%2Fzzyzx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Ffail%2Fsrc%2Fno-inferred-crates%2Fsrc%2Fzzyzx.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "dc068eed143efd313d93299be2e0debbc10a0228", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Flib.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0", "previous_filename": "src/librustpkg/testsuite/pass/src/fancy-lib/fancy-lib.rs"}, {"sha": "009f37c8a49e7f1852df964a1ecf698d727886c6", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/pkg.rs", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "c8b2ce97c0c004864bbe1009e1247d6f2afae88b", "filename": "src/librustpkg/testsuite/pass/src/hello-world/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fhello-world%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fhello-world%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fhello-world%2Fmain.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "fee52c3c11f34215e668d3c28156ae00f89c0978", "filename": "src/librustpkg/usage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fusage.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "26e26add3dc266a3fb7c290022383865d757c0c9", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "1ec15c107c7804a18b79b6863d967c3ad36dbe42", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "dd2cf445302a42949a0cecfa008e364af76fd5f0", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "75d0fe7a0b29a64d0e4c49a5bff9ebefd93ff225", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "53ea11f2b0592dfe6b5406ab1390ed2b7e7da42d", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "6a9555f4efcdc1b5671f27bbf0414a53d6b8cc42", "filename": "src/libstd/char.rs", "status": "modified", "additions": 59, "deletions": 49, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "abda76c9ca66054c10c11967e1168fc91b2c56af", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "947aa5708c2967f686e3d54e67603666673286a2", "filename": "src/libstd/clone.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fclone.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "1bb0ff044fe980f5b927994daad399bac2968266", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "04f2d815d081587b20d1ae3f0e932e771ffae19b", "filename": "src/libstd/condition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcondition.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "d6f4c26715a4f6e18c656ab322d6c596c57e7d24", "filename": "src/libstd/container.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcontainer.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "b6da93f9d40ab53b6fdf189ab631a23dfedf81c0", "filename": "src/libstd/either.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "c9e33219fa5033d3917c4af2a4b62e13c6652b3c", "filename": "src/libstd/gc.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "6c3fcd41ed3b9d6fb1b698f95faee702332efa27", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "85dca1154bc09330484fbcd34d58f975073b2846", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 131, "deletions": 61, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "bdcad15f45c444fd9ad8bc70dbab1ec7fc869b6c", "filename": "src/libstd/io.rs", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "4e598a4aa1cd62132edf596df9c62c09693c0110", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "77befbf19aa92f9afb5fe3dc5782bb5f37b6d60a", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 217, "deletions": 19, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "f350e1061680524e9ea7cbb0a24bbafef0b070d6", "filename": "src/libstd/kinds.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkinds.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "f4ea29b5c05e45232c11569e3b622862eee458ac", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 922, "deletions": 319, "changes": 1241, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "c5f2c8ae584d1991b348499e2ee7c75c0628d8fc", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "2c9fcb2999f06b694b8569ba6610555aa16f4757", "filename": "src/libstd/managed.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmanaged.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "0b6eb766b2990077b85cff5063642a415bda42b3", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "c39c7a3a57d213c15839127fe61a181cbb0e8828", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "7a6e3042e7b7523b83b15173db01bfc7c4e67ee3", "filename": "src/libstd/num/float.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "f152d60cb7a355c94944af34cb220a00771908d2", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "b856c3c65ea5aa04e829815a93be8d00e57d6654", "filename": "src/libstd/num/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fnum.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "f6dff4267b7a8f859261cc741e913862c02e2793", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 115, "deletions": 86, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "25e338fcd0f64a80f20027283ea3b260260760c2", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "83bb9eb09088e423443ed168e1d0b244aea667fe", "filename": "src/libstd/old_iter.rs", "status": "removed", "additions": 0, "deletions": 296, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/b60cf0c5b0cf36625083c2624df9fb35d0af3578/src%2Flibstd%2Fold_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b60cf0c5b0cf36625083c2624df9fb35d0af3578/src%2Flibstd%2Fold_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_iter.rs?ref=b60cf0c5b0cf36625083c2624df9fb35d0af3578"}, {"sha": "020131ab119e5080f2407d0851548c8f67e4b99b", "filename": "src/libstd/ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fops.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "643812312582e30d33bdb66713f52ac133e329e3", "filename": "src/libstd/option.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "20c4346d6187312d0acee9abe670e75bed01e1f0", "filename": "src/libstd/os.rs", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "a5e82c31d79008786354acd6dac5569b14224d19", "filename": "src/libstd/path.rs", "status": "modified", "additions": 108, "deletions": 20, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "49713a3a23b9a338e4a42dc656a8700290b2f9d7", "filename": "src/libstd/pipes.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpipes.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "d560ce621eac969d695a3aa09cb5d7c6e9cae3f0", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "473f56ddd7984f1bfea0846210ff7a31f1aaea8e", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "5f96e38a55af498f4cadf801a85f64fbd18709f0", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "e8dad2fc5e862202bf92a2f03f17b0d3f5c8c682", "filename": "src/libstd/rand/distributions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Frand%2Fdistributions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Frand%2Fdistributions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "16ab4771d0de10a837b1584145bef9e933fa4c9e", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "fdda65d3e95b8c9acea2d491f1a3a6def0612275", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 43, "deletions": 61, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "0b099b66ecf0ac1d2b18f01db239bc10d7b9d4df", "filename": "src/libstd/result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "fba6171129762254094300d1618bfcbf6eb6dca0", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}, {"sha": "4b475d743972f25910418399448cc4c06f806a81", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 99, "deletions": 74, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2329201098c6e3b417548651a1c3dbf19c0dc0/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=cf2329201098c6e3b417548651a1c3dbf19c0dc0"}]}