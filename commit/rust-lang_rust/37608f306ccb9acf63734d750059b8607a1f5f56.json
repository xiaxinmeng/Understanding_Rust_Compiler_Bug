{"sha": "37608f306ccb9acf63734d750059b8607a1f5f56", "node_id": "C_kwDOAAsO6NoAKDM3NjA4ZjMwNmNjYjlhY2Y2MzczNGQ3NTAwNTliODYwN2ExZjVmNTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-14T16:58:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-14T16:58:58Z"}, "message": "Auto merge of #14152 - Veykril:path-opt, r=Veykril\n\nReplace some often empty `Vec`s with boxed slices", "tree": {"sha": "9e3cef307c49b646c491f5137155d3e94b282cc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e3cef307c49b646c491f5137155d3e94b282cc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37608f306ccb9acf63734d750059b8607a1f5f56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37608f306ccb9acf63734d750059b8607a1f5f56", "html_url": "https://github.com/rust-lang/rust/commit/37608f306ccb9acf63734d750059b8607a1f5f56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37608f306ccb9acf63734d750059b8607a1f5f56/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "523fea8f25d9dfc483be52c7d274885a8268623c", "url": "https://api.github.com/repos/rust-lang/rust/commits/523fea8f25d9dfc483be52c7d274885a8268623c", "html_url": "https://github.com/rust-lang/rust/commit/523fea8f25d9dfc483be52c7d274885a8268623c"}, {"sha": "4aee911ce41d6ae7a41b74ca83c21bf7f4d2f3d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4aee911ce41d6ae7a41b74ca83c21bf7f4d2f3d9", "html_url": "https://github.com/rust-lang/rust/commit/4aee911ce41d6ae7a41b74ca83c21bf7f4d2f3d9"}], "stats": {"total": 94, "additions": 55, "deletions": 39}, "files": [{"sha": "d4d3c5ef19a60d84d89e7eea8fbc39c1a8a7ca29", "filename": "crates/hir-def/src/item_tree/lower.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/37608f306ccb9acf63734d750059b8607a1f5f56/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37608f306ccb9acf63734d750059b8607a1f5f56/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs?ref=37608f306ccb9acf63734d750059b8607a1f5f56", "patch": "@@ -659,15 +659,16 @@ fn desugar_future_path(orig: TypeRef) -> Path {\n     let path = path![core::future::Future];\n     let mut generic_args: Vec<_> =\n         std::iter::repeat(None).take(path.segments().len() - 1).collect();\n-    let mut last = GenericArgs::empty();\n     let binding = AssociatedTypeBinding {\n         name: name![Output],\n         args: None,\n         type_ref: Some(orig),\n-        bounds: Vec::new(),\n+        bounds: Box::default(),\n     };\n-    last.bindings.push(binding);\n-    generic_args.push(Some(Interned::new(last)));\n+    generic_args.push(Some(Interned::new(GenericArgs {\n+        bindings: Box::new([binding]),\n+        ..GenericArgs::empty()\n+    })));\n \n     Path::from_known_path(path, generic_args)\n }"}, {"sha": "36d4c36a26894550135d732e08ab3f704ae55f7e", "filename": "crates/hir-def/src/path.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37608f306ccb9acf63734d750059b8607a1f5f56/crates%2Fhir-def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37608f306ccb9acf63734d750059b8607a1f5f56/crates%2Fhir-def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpath.rs?ref=37608f306ccb9acf63734d750059b8607a1f5f56", "patch": "@@ -49,15 +49,15 @@ pub struct Path {\n /// also includes bindings of associated types, like in `Iterator<Item = Foo>`.\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct GenericArgs {\n-    pub args: Vec<GenericArg>,\n+    pub args: Box<[GenericArg]>,\n     /// This specifies whether the args contain a Self type as the first\n     /// element. This is the case for path segments like `<T as Trait>`, where\n     /// `T` is actually a type parameter for the path `Trait` specifying the\n     /// Self type. Otherwise, when we have a path `Trait<X, Y>`, the Self type\n     /// is left out.\n     pub has_self_type: bool,\n     /// Associated type bindings like in `Iterator<Item = T>`.\n-    pub bindings: Vec<AssociatedTypeBinding>,\n+    pub bindings: Box<[AssociatedTypeBinding]>,\n     /// Whether these generic args were desugared from `Trait(Arg) -> Output`\n     /// parenthesis notation typically used for the `Fn` traits.\n     pub desugared_from_fn: bool,\n@@ -77,7 +77,7 @@ pub struct AssociatedTypeBinding {\n     /// Bounds for the associated type, like in `Iterator<Item:\n     /// SomeOtherTrait>`. (This is the unstable `associated_type_bounds`\n     /// feature.)\n-    pub bounds: Vec<Interned<TypeBound>>,\n+    pub bounds: Box<[Interned<TypeBound>]>,\n }\n \n /// A single generic argument.\n@@ -212,9 +212,9 @@ impl GenericArgs {\n \n     pub(crate) fn empty() -> GenericArgs {\n         GenericArgs {\n-            args: Vec::new(),\n+            args: Box::default(),\n             has_self_type: false,\n-            bindings: Vec::new(),\n+            bindings: Box::default(),\n             desugared_from_fn: false,\n         }\n     }"}, {"sha": "c85a11db6d1947fa6bdf0f8e11a81eeed8fb6e73", "filename": "crates/hir-def/src/path/lower.rs", "status": "modified", "additions": 36, "deletions": 21, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/37608f306ccb9acf63734d750059b8607a1f5f56/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37608f306ccb9acf63734d750059b8607a1f5f56/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs?ref=37608f306ccb9acf63734d750059b8607a1f5f56", "patch": "@@ -1,5 +1,7 @@\n //! Transforms syntax into `Path` objects, ideally with accounting for hygiene\n \n+use std::iter;\n+\n use crate::type_ref::ConstScalarOrPath;\n \n use either::Either;\n@@ -86,15 +88,26 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx<'_>) -> Option<Path\n                             generic_args.resize(segments.len(), None);\n                         }\n \n+                        let self_type = GenericArg::Type(self_type);\n+\n                         // Insert the type reference (T in the above example) as Self parameter for the trait\n                         let last_segment = generic_args.get_mut(segments.len() - num_segments)?;\n-                        let mut args_inner = match last_segment {\n-                            Some(it) => it.as_ref().clone(),\n-                            None => GenericArgs::empty(),\n-                        };\n-                        args_inner.has_self_type = true;\n-                        args_inner.args.insert(0, GenericArg::Type(self_type));\n-                        *last_segment = Some(Interned::new(args_inner));\n+                        *last_segment = Some(Interned::new(match last_segment.take() {\n+                            Some(it) => GenericArgs {\n+                                args: iter::once(self_type)\n+                                    .chain(it.args.iter().cloned())\n+                                    .collect(),\n+\n+                                has_self_type: true,\n+                                bindings: it.bindings.clone(),\n+                                desugared_from_fn: it.desugared_from_fn,\n+                            },\n+                            None => GenericArgs {\n+                                args: Box::new([self_type]),\n+                                has_self_type: true,\n+                                ..GenericArgs::empty()\n+                            },\n+                        }));\n                     }\n                 }\n             }\n@@ -187,7 +200,7 @@ pub(super) fn lower_generic_args(\n                             .map(|it| Interned::new(TypeBound::from_ast(lower_ctx, it)))\n                             .collect()\n                     } else {\n-                        Vec::new()\n+                        Box::default()\n                     };\n                     bindings.push(AssociatedTypeBinding { name, args, type_ref, bounds });\n                 }\n@@ -208,7 +221,12 @@ pub(super) fn lower_generic_args(\n     if args.is_empty() && bindings.is_empty() {\n         return None;\n     }\n-    Some(GenericArgs { args, has_self_type: false, bindings, desugared_from_fn: false })\n+    Some(GenericArgs {\n+        args: args.into_boxed_slice(),\n+        has_self_type: false,\n+        bindings: bindings.into_boxed_slice(),\n+        desugared_from_fn: false,\n+    })\n }\n \n /// Collect `GenericArgs` from the parts of a fn-like path, i.e. `Fn(X, Y)\n@@ -218,33 +236,30 @@ fn lower_generic_args_from_fn_path(\n     params: Option<ast::ParamList>,\n     ret_type: Option<ast::RetType>,\n ) -> Option<GenericArgs> {\n-    let mut args = Vec::new();\n-    let mut bindings = Vec::new();\n     let params = params?;\n     let mut param_types = Vec::new();\n     for param in params.params() {\n         let type_ref = TypeRef::from_ast_opt(ctx, param.ty());\n         param_types.push(type_ref);\n     }\n-    let arg = GenericArg::Type(TypeRef::Tuple(param_types));\n-    args.push(arg);\n-    if let Some(ret_type) = ret_type {\n+    let args = Box::new([GenericArg::Type(TypeRef::Tuple(param_types))]);\n+    let bindings = if let Some(ret_type) = ret_type {\n         let type_ref = TypeRef::from_ast_opt(ctx, ret_type.ty());\n-        bindings.push(AssociatedTypeBinding {\n+        Box::new([AssociatedTypeBinding {\n             name: name![Output],\n             args: None,\n             type_ref: Some(type_ref),\n-            bounds: Vec::new(),\n-        });\n+            bounds: Box::default(),\n+        }])\n     } else {\n         // -> ()\n         let type_ref = TypeRef::Tuple(Vec::new());\n-        bindings.push(AssociatedTypeBinding {\n+        Box::new([AssociatedTypeBinding {\n             name: name![Output],\n             args: None,\n             type_ref: Some(type_ref),\n-            bounds: Vec::new(),\n-        });\n-    }\n+            bounds: Box::default(),\n+        }])\n+    };\n     Some(GenericArgs { args, has_self_type: false, bindings, desugared_from_fn: true })\n }"}, {"sha": "2d45c8c8da1a5ba56db35223a4a59abf06bf0d6f", "filename": "crates/hir-def/src/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37608f306ccb9acf63734d750059b8607a1f5f56/crates%2Fhir-def%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37608f306ccb9acf63734d750059b8607a1f5f56/crates%2Fhir-def%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpretty.rs?ref=37608f306ccb9acf63734d750059b8607a1f5f56", "patch": "@@ -71,7 +71,7 @@ pub(crate) fn print_generic_args(generics: &GenericArgs, buf: &mut dyn Write) ->\n         first = false;\n         print_generic_arg(arg, buf)?;\n     }\n-    for binding in &generics.bindings {\n+    for binding in generics.bindings.iter() {\n         if !first {\n             write!(buf, \", \")?;\n         }"}, {"sha": "9652b01b91bf6bd8f593560ea332904d98f307ca", "filename": "crates/hir-def/src/type_ref.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37608f306ccb9acf63734d750059b8607a1f5f56/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37608f306ccb9acf63734d750059b8607a1f5f56/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs?ref=37608f306ccb9acf63734d750059b8607a1f5f56", "patch": "@@ -292,7 +292,7 @@ impl TypeRef {\n             }\n             for segment in path.segments().iter() {\n                 if let Some(args_and_bindings) = segment.args_and_bindings {\n-                    for arg in &args_and_bindings.args {\n+                    for arg in args_and_bindings.args.iter() {\n                         match arg {\n                             crate::path::GenericArg::Type(type_ref) => {\n                                 go(type_ref, f);\n@@ -301,11 +301,11 @@ impl TypeRef {\n                             | crate::path::GenericArg::Lifetime(_) => {}\n                         }\n                     }\n-                    for binding in &args_and_bindings.bindings {\n+                    for binding in args_and_bindings.bindings.iter() {\n                         if let Some(type_ref) = &binding.type_ref {\n                             go(type_ref, f);\n                         }\n-                        for bound in &binding.bounds {\n+                        for bound in binding.bounds.iter() {\n                             match bound.as_ref() {\n                                 TypeBound::Path(path, _) | TypeBound::ForLifetime(_, path) => {\n                                     go_path(path, f)"}, {"sha": "b22064d8c42e49be63b872eeb35733b276c34256", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37608f306ccb9acf63734d750059b8607a1f5f56/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37608f306ccb9acf63734d750059b8607a1f5f56/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=37608f306ccb9acf63734d750059b8607a1f5f56", "patch": "@@ -1419,7 +1419,7 @@ impl HirDisplay for Path {\n \n                 write!(f, \"<\")?;\n                 let mut first = true;\n-                for arg in &generic_args.args {\n+                for arg in generic_args.args.iter() {\n                     if first {\n                         first = false;\n                         if generic_args.has_self_type {\n@@ -1431,7 +1431,7 @@ impl HirDisplay for Path {\n                     }\n                     arg.hir_fmt(f)?;\n                 }\n-                for binding in &generic_args.bindings {\n+                for binding in generic_args.bindings.iter() {\n                     if first {\n                         first = false;\n                     } else {\n@@ -1445,7 +1445,7 @@ impl HirDisplay for Path {\n                         }\n                         None => {\n                             write!(f, \": \")?;\n-                            f.write_joined(&binding.bounds, \" + \")?;\n+                            f.write_joined(binding.bounds.iter(), \" + \")?;\n                         }\n                     }\n                 }"}, {"sha": "299646737221d9cdd97d45d636b51dda9700f4c5", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37608f306ccb9acf63734d750059b8607a1f5f56/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37608f306ccb9acf63734d750059b8607a1f5f56/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=37608f306ccb9acf63734d750059b8607a1f5f56", "patch": "@@ -1025,7 +1025,7 @@ impl<'a> TyLoweringContext<'a> {\n         last_segment\n             .into_iter()\n             .filter_map(|segment| segment.args_and_bindings)\n-            .flat_map(|args_and_bindings| &args_and_bindings.bindings)\n+            .flat_map(|args_and_bindings| args_and_bindings.bindings.iter())\n             .flat_map(move |binding| {\n                 let found = associated_type_by_name_including_super_traits(\n                     self.db,\n@@ -1068,7 +1068,7 @@ impl<'a> TyLoweringContext<'a> {\n                         AliasEq { alias: AliasTy::Projection(projection_ty.clone()), ty };\n                     preds.push(crate::wrap_empty_binders(WhereClause::AliasEq(alias_eq)));\n                 }\n-                for bound in &binding.bounds {\n+                for bound in binding.bounds.iter() {\n                     preds.extend(self.lower_type_bound(\n                         bound,\n                         TyKind::Alias(AliasTy::Projection(projection_ty.clone())).intern(Interner),"}]}