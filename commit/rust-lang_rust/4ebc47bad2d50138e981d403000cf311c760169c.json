{"sha": "4ebc47bad2d50138e981d403000cf311c760169c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlYmM0N2JhZDJkNTAxMzhlOTgxZDQwMzAwMGNmMzExYzc2MDE2OWM=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2016-02-09T17:54:53Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2016-02-09T21:00:50Z"}, "message": "Properly document tuples\n\nFixes #29339", "tree": {"sha": "93bb5d3dd1ef73aede2e5fcf3902cb4a98b528fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93bb5d3dd1ef73aede2e5fcf3902cb4a98b528fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ebc47bad2d50138e981d403000cf311c760169c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ebc47bad2d50138e981d403000cf311c760169c", "html_url": "https://github.com/rust-lang/rust/commit/4ebc47bad2d50138e981d403000cf311c760169c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ebc47bad2d50138e981d403000cf311c760169c/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6630a0819553898c3fc0d060cc72a94d62ae1330", "url": "https://api.github.com/repos/rust-lang/rust/commits/6630a0819553898c3fc0d060cc72a94d62ae1330", "html_url": "https://github.com/rust-lang/rust/commit/6630a0819553898c3fc0d060cc72a94d62ae1330"}], "stats": {"total": 111, "additions": 66, "deletions": 45}, "files": [{"sha": "abaabfd129b383d31584a10657dc0a71232f7a3c", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4ebc47bad2d50138e981d403000cf311c760169c/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ebc47bad2d50138e981d403000cf311c760169c/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=4ebc47bad2d50138e981d403000cf311c760169c", "patch": "@@ -8,24 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A finite heterogeneous sequence, `(T, U, ..)`\n-//!\n-//! To access a single element of a tuple one can use the `.0`\n-//! field access syntax.\n-//!\n-//! Indexing starts from zero, so `.0` returns first value, `.1`\n-//! returns second value, and so on. In general, a tuple with *N*\n-//! elements has field accessors from 0 to *N* - 1.\n-//!\n-//! If every type inside a tuple implements one of the following\n-//! traits, then a tuple itself also implements it.\n-//!\n-//! * `Clone`\n-//! * `PartialEq`\n-//! * `Eq`\n-//! * `PartialOrd`\n-//! * `Ord`\n-//! * `Default`\n+// See src/libstd/primitive_docs.rs for documentation.\n \n use clone::Clone;\n use cmp::*;"}, {"sha": "2be8c41a496e0caff3068feb8133a0d27ea969f9", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 65, "deletions": 27, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/4ebc47bad2d50138e981d403000cf311c760169c/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ebc47bad2d50138e981d403000cf311c760169c/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=4ebc47bad2d50138e981d403000cf311c760169c", "patch": "@@ -357,50 +357,88 @@ mod prim_str { }\n //\n /// A finite heterogeneous sequence, `(T, U, ..)`.\n ///\n-/// To access the _N_-th element of a tuple one can use `N` itself\n-/// as a field of the tuple.\n+/// Let's cover each of those in turn:\n ///\n-/// Indexing starts from zero, so `0` returns first value, `1`\n-/// returns second value, and so on. In general, a tuple with _S_\n-/// elements provides aforementioned fields from `0` to `S-1`.\n+/// Tuples are *finite*. In other words, a tuple has a length. Here's a tuple\n+/// of length `3`:\n+///\n+/// ```\n+/// (\"hello\", 5, 'c');\n+/// ```\n+///\n+/// Tuples are *heterogeneous*. This means that each element of the tuple can\n+/// have a different type. In that tuple above, it has the type:\n+///\n+/// ```rust,ignore\n+/// (&'static str, i32, char)\n+/// ```\n+///\n+/// Tuples are a *sequence*. This means that they can be accessed by position;\n+/// this is called 'tuple indexing', and it looks like this:\n+///\n+/// ```rust\n+/// let tuple = (\"hello\", 5, 'c');\n+///\n+/// assert_eq!(tuple.0, \"hello\");\n+/// assert_eq!(tuple.1, 5);\n+/// assert_eq!(tuple.2, 'c');\n+/// ```\n+///\n+/// For more about tuples, see [the book](../../book/primitive-types.html#tuples).\n+///\n+/// # Trait implementations\n ///\n /// If every type inside a tuple implements one of the following\n /// traits, then a tuple itself also implements it.\n ///\n-/// * `Clone`\n-/// * `PartialEq`\n-/// * `Eq`\n-/// * `PartialOrd`\n-/// * `Ord`\n-/// * `Debug`\n-/// * `Default`\n-/// * `Hash`\n+/// * [`Clone`]\n+/// * [`PartialEq`]\n+/// * [`Eq`]\n+/// * [`PartialOrd`]\n+/// * [`Ord`]\n+/// * [`Debug`]\n+/// * [`Default`]\n+/// * [`Hash`]\n+///\n+/// [`Clone`]: ../clone/trait.Clone.html\n+/// [`PartialEq`]: ../cmp/trait.PartialEq.html\n+/// [`Eq`]: ../cmp/trait.Eq.html\n+/// [`PartialOrd`]: ../cmp/trait.PartialOrd.html\n+/// [`Ord`]: ../cmp/trait.Ord.html\n+/// [`Debug`]: ../fmt/trait.Debug.html\n+/// [`Default`]: ../default/trait.Default.html\n+/// [`Hash`]: ../hash/trait.Hash.html\n ///\n /// # Examples\n ///\n-/// Accessing elements of a tuple at specified indices:\n+/// Basic usage:\n ///\n /// ```\n-/// let x = (\"colorless\",  \"green\", \"ideas\", \"sleep\", \"furiously\");\n-/// assert_eq!(x.3, \"sleep\");\n+/// let tuple = (\"hello\", 5, 'c');\n ///\n-/// let v = (3, 3);\n-/// let u = (1, -5);\n-/// assert_eq!(v.0 * u.0 + v.1 * u.1, -12);\n+/// assert_eq!(tuple.0, \"hello\");\n /// ```\n ///\n-/// Using traits implemented for tuples:\n+/// Tuples are often used as a return type when you want to return more than\n+/// one value:\n ///\n /// ```\n-/// let a = (1, 2);\n-/// let b = (3, 4);\n-/// assert!(a != b);\n+/// fn calculate_point() -> (i32, i32) {\n+///     // Don't do a calculation, that's not the point of the example\n+///     (4, 5)\n+/// }\n+///\n+/// let point = calculate_point();\n+///\n+/// assert_eq!(point.0, 4);\n+/// assert_eq!(point.1, 5);\n+///\n+/// // Combining this with patterns can be nicer.\n ///\n-/// let c = b.clone();\n-/// assert!(b == c);\n+/// let (x, y) = calculate_point();\n ///\n-/// let d : (u32, f32) = Default::default();\n-/// assert_eq!(d, (0, 0.0f32));\n+/// assert_eq!(x, 4);\n+/// assert_eq!(y, 5);\n /// ```\n ///\n mod prim_tuple { }"}]}