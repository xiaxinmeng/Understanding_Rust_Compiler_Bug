{"sha": "e010b144d5abcbd0947d0490123ef693a6a17c78", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwMTBiMTQ0ZDVhYmNiZDA5NDdkMDQ5MDEyM2VmNjkzYTZhMTdjNzg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-30T06:27:26Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-30T06:27:26Z"}, "message": "move field list to ast/edit.rs", "tree": {"sha": "fed2cbe36e741a30a94486e47534b35690111a2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fed2cbe36e741a30a94486e47534b35690111a2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e010b144d5abcbd0947d0490123ef693a6a17c78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e010b144d5abcbd0947d0490123ef693a6a17c78", "html_url": "https://github.com/rust-lang/rust/commit/e010b144d5abcbd0947d0490123ef693a6a17c78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e010b144d5abcbd0947d0490123ef693a6a17c78/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0840ec038b2822a424acf238d8db5af569f99a21", "url": "https://api.github.com/repos/rust-lang/rust/commits/0840ec038b2822a424acf238d8db5af569f99a21", "html_url": "https://github.com/rust-lang/rust/commit/0840ec038b2822a424acf238d8db5af569f99a21"}], "stats": {"total": 214, "additions": 106, "deletions": 108}, "files": [{"sha": "5f564be0b24e9f3fb2309f73b552ef139e1c175d", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e010b144d5abcbd0947d0490123ef693a6a17c78/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e010b144d5abcbd0947d0490123ef693a6a17c78/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=e010b144d5abcbd0947d0490123ef693a6a17c78", "patch": "@@ -178,9 +178,7 @@ impl AssistBuilder {\n     }\n \n     pub(crate) fn replace_ast<N: AstNode>(&mut self, old: N, new: N) {\n-        for (from, to) in algo::diff(old.syntax(), new.syntax()) {\n-            self.edit.replace(from.text_range(), to.to_string())\n-        }\n+        algo::diff(old.syntax(), new.syntax()).into_text_edit(&mut self.edit)\n     }\n \n     fn build(self) -> AssistAction {"}, {"sha": "54849b7b0bbbc572f65335a535d8e058208552df", "filename": "crates/ra_assists/src/ast_editor.rs", "status": "modified", "additions": 4, "deletions": 97, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/e010b144d5abcbd0947d0490123ef693a6a17c78/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e010b144d5abcbd0947d0490123ef693a6a17c78/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_editor.rs?ref=e010b144d5abcbd0947d0490123ef693a6a17c78", "patch": "@@ -1,15 +1,12 @@\n use std::{iter, ops::RangeInclusive};\n \n-use arrayvec::ArrayVec;\n-use rustc_hash::FxHashMap;\n-\n-use ra_fmt::leading_indent;\n use ra_syntax::{\n     algo,\n-    ast::{self, make::tokens, TypeBoundsOwner},\n-    AstNode, Direction, InsertPosition, SyntaxElement, T,\n+    ast::{self, TypeBoundsOwner},\n+    AstNode, SyntaxElement,\n };\n use ra_text_edit::TextEditBuilder;\n+use rustc_hash::FxHashMap;\n \n pub struct AstEditor<N: AstNode> {\n     original_ast: N,\n@@ -25,9 +22,7 @@ impl<N: AstNode> AstEditor<N> {\n     }\n \n     pub fn into_text_edit(self, builder: &mut TextEditBuilder) {\n-        for (from, to) in algo::diff(&self.original_ast.syntax(), self.ast().syntax()) {\n-            builder.replace(from.text_range(), to.to_string())\n-        }\n+        algo::diff(&self.original_ast.syntax(), self.ast().syntax()).into_text_edit(builder)\n     }\n \n     pub fn ast(&self) -> &N {\n@@ -46,16 +41,6 @@ impl<N: AstNode> AstEditor<N> {\n         self\n     }\n \n-    #[must_use]\n-    fn insert_children(\n-        &self,\n-        position: InsertPosition<SyntaxElement>,\n-        mut to_insert: impl Iterator<Item = SyntaxElement>,\n-    ) -> N {\n-        let new_syntax = algo::insert_children(self.ast().syntax(), position, &mut to_insert);\n-        N::cast(new_syntax).unwrap()\n-    }\n-\n     #[must_use]\n     fn replace_children(\n         &self,\n@@ -67,84 +52,6 @@ impl<N: AstNode> AstEditor<N> {\n     }\n }\n \n-impl AstEditor<ast::RecordFieldList> {\n-    pub fn append_field(&mut self, field: &ast::RecordField) {\n-        self.insert_field(InsertPosition::Last, field)\n-    }\n-\n-    pub fn insert_field(\n-        &mut self,\n-        position: InsertPosition<&'_ ast::RecordField>,\n-        field: &ast::RecordField,\n-    ) {\n-        let is_multiline = self.ast().syntax().text().contains_char('\\n');\n-        let ws;\n-        let space = if is_multiline {\n-            ws = tokens::WsBuilder::new(&format!(\n-                \"\\n{}    \",\n-                leading_indent(self.ast().syntax()).unwrap_or(\"\".into())\n-            ));\n-            ws.ws()\n-        } else {\n-            tokens::single_space()\n-        };\n-\n-        let mut to_insert: ArrayVec<[SyntaxElement; 4]> = ArrayVec::new();\n-        to_insert.push(space.into());\n-        to_insert.push(field.syntax().clone().into());\n-        to_insert.push(tokens::comma().into());\n-\n-        macro_rules! after_l_curly {\n-            () => {{\n-                let anchor = match self.l_curly() {\n-                    Some(it) => it,\n-                    None => return,\n-                };\n-                InsertPosition::After(anchor)\n-            }};\n-        }\n-\n-        macro_rules! after_field {\n-            ($anchor:expr) => {\n-                if let Some(comma) = $anchor\n-                    .syntax()\n-                    .siblings_with_tokens(Direction::Next)\n-                    .find(|it| it.kind() == T![,])\n-                {\n-                    InsertPosition::After(comma)\n-                } else {\n-                    to_insert.insert(0, tokens::comma().into());\n-                    InsertPosition::After($anchor.syntax().clone().into())\n-                }\n-            };\n-        };\n-\n-        let position = match position {\n-            InsertPosition::First => after_l_curly!(),\n-            InsertPosition::Last => {\n-                if !is_multiline {\n-                    // don't insert comma before curly\n-                    to_insert.pop();\n-                }\n-                match self.ast().fields().last() {\n-                    Some(it) => after_field!(it),\n-                    None => after_l_curly!(),\n-                }\n-            }\n-            InsertPosition::Before(anchor) => {\n-                InsertPosition::Before(anchor.syntax().clone().into())\n-            }\n-            InsertPosition::After(anchor) => after_field!(anchor),\n-        };\n-\n-        self.ast = self.insert_children(position, to_insert.iter().cloned());\n-    }\n-\n-    fn l_curly(&self) -> Option<SyntaxElement> {\n-        self.ast().syntax().children_with_tokens().find(|it| it.kind() == T!['{'])\n-    }\n-}\n-\n impl AstEditor<ast::TypeParam> {\n     pub fn remove_bounds(&mut self) -> &mut Self {\n         let colon = match self.ast.colon_token() {"}, {"sha": "4fa07e3dc12311d4f27ca6c14a88bb649487d11d", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e010b144d5abcbd0947d0490123ef693a6a17c78/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e010b144d5abcbd0947d0490123ef693a6a17c78/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=e010b144d5abcbd0947d0490123ef693a6a17c78", "patch": "@@ -2,10 +2,10 @@ use std::cell::RefCell;\n \n use hir::diagnostics::{AstDiagnostic, Diagnostic as _, DiagnosticSink};\n use itertools::Itertools;\n-use ra_assists::ast_editor::AstEditor;\n use ra_db::SourceDatabase;\n use ra_prof::profile;\n use ra_syntax::{\n+    algo,\n     ast::{self, make, AstNode},\n     Location, SyntaxNode, TextRange, T,\n };\n@@ -56,15 +56,15 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n         })\n     })\n     .on::<hir::diagnostics::MissingFields, _>(|d| {\n-        let node = d.ast(db);\n-        let mut ast_editor = AstEditor::new(node);\n+        let mut field_list = d.ast(db);\n         for f in d.missed_fields.iter() {\n             let field = make::record_field(make::name_ref(&f.to_string()), Some(make::expr_unit()));\n-            ast_editor.append_field(&field);\n+            field_list = field_list.append_field(&field);\n         }\n \n         let mut builder = TextEditBuilder::default();\n-        ast_editor.into_text_edit(&mut builder);\n+        algo::diff(&d.ast(db).syntax(), &field_list.syntax()).into_text_edit(&mut builder);\n+\n         let fix =\n             SourceChange::source_file_edit_from(\"fill struct fields\", file_id, builder.finish());\n         res.borrow_mut().push(Diagnostic {"}, {"sha": "f33d2ad4e36e8dc3d4d67534b9697bc92c2de872", "filename": "crates/ra_syntax/src/algo.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e010b144d5abcbd0947d0490123ef693a6a17c78/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e010b144d5abcbd0947d0490123ef693a6a17c78/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo.rs?ref=e010b144d5abcbd0947d0490123ef693a6a17c78", "patch": "@@ -3,6 +3,7 @@ pub mod visit;\n use std::ops::RangeInclusive;\n \n use itertools::Itertools;\n+use ra_text_edit::TextEditBuilder;\n use rustc_hash::FxHashMap;\n \n use crate::{\n@@ -63,19 +64,31 @@ pub enum InsertPosition<T> {\n     After(T),\n }\n \n+pub struct TreeDiff {\n+    replacements: FxHashMap<SyntaxElement, SyntaxElement>,\n+}\n+\n+impl TreeDiff {\n+    pub fn into_text_edit(&self, builder: &mut TextEditBuilder) {\n+        for (from, to) in self.replacements.iter() {\n+            builder.replace(from.text_range(), to.to_string())\n+        }\n+    }\n+}\n+\n /// Finds minimal the diff, which, applied to `from`, will result in `to`.\n ///\n /// Specifically, returns a map whose keys are descendants of `from` and values\n /// are descendants of `to`, such that  `replace_descendants(from, map) == to`.\n ///\n /// A trivial solution is a singletom map `{ from: to }`, but this function\n /// tries to find a more fine-grained diff.\n-pub fn diff(from: &SyntaxNode, to: &SyntaxNode) -> FxHashMap<SyntaxElement, SyntaxElement> {\n+pub fn diff(from: &SyntaxNode, to: &SyntaxNode) -> TreeDiff {\n     let mut buf = FxHashMap::default();\n     // FIXME: this is both horrible inefficient and gives larger than\n     // necessary diff. I bet there's a cool algorithm to diff trees properly.\n     go(&mut buf, from.clone().into(), to.clone().into());\n-    return buf;\n+    return TreeDiff { replacements: buf };\n \n     fn go(\n         buf: &mut FxHashMap<SyntaxElement, SyntaxElement>,"}, {"sha": "6e64c06758cd9e8caedf2d2106cd6737bdfceaaa", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 81, "deletions": 1, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e010b144d5abcbd0947d0490123ef693a6a17c78/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e010b144d5abcbd0947d0490123ef693a6a17c78/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=e010b144d5abcbd0947d0490123ef693a6a17c78", "patch": "@@ -12,7 +12,7 @@ use crate::{\n         make::{self, tokens},\n         AstNode,\n     },\n-    AstToken, InsertPosition, SmolStr, SyntaxElement,\n+    AstToken, Direction, InsertPosition, SmolStr, SyntaxElement,\n     SyntaxKind::{ATTR, COMMENT, WHITESPACE},\n     SyntaxNode, T,\n };\n@@ -105,6 +105,86 @@ impl ast::ItemList {\n     }\n }\n \n+impl ast::RecordFieldList {\n+    #[must_use]\n+    pub fn append_field(&self, field: &ast::RecordField) -> ast::RecordFieldList {\n+        self.insert_field(InsertPosition::Last, field)\n+    }\n+\n+    #[must_use]\n+    pub fn insert_field(\n+        &self,\n+        position: InsertPosition<&'_ ast::RecordField>,\n+        field: &ast::RecordField,\n+    ) -> ast::RecordFieldList {\n+        let is_multiline = self.syntax().text().contains_char('\\n');\n+        let ws;\n+        let space = if is_multiline {\n+            ws = tokens::WsBuilder::new(&format!(\n+                \"\\n{}    \",\n+                leading_indent(self.syntax()).unwrap_or(\"\".into())\n+            ));\n+            ws.ws()\n+        } else {\n+            tokens::single_space()\n+        };\n+\n+        let mut to_insert: ArrayVec<[SyntaxElement; 4]> = ArrayVec::new();\n+        to_insert.push(space.into());\n+        to_insert.push(field.syntax().clone().into());\n+        to_insert.push(tokens::comma().into());\n+\n+        macro_rules! after_l_curly {\n+            () => {{\n+                let anchor = match self.l_curly() {\n+                    Some(it) => it,\n+                    None => return self.clone(),\n+                };\n+                InsertPosition::After(anchor)\n+            }};\n+        }\n+\n+        macro_rules! after_field {\n+            ($anchor:expr) => {\n+                if let Some(comma) = $anchor\n+                    .syntax()\n+                    .siblings_with_tokens(Direction::Next)\n+                    .find(|it| it.kind() == T![,])\n+                {\n+                    InsertPosition::After(comma)\n+                } else {\n+                    to_insert.insert(0, tokens::comma().into());\n+                    InsertPosition::After($anchor.syntax().clone().into())\n+                }\n+            };\n+        };\n+\n+        let position = match position {\n+            InsertPosition::First => after_l_curly!(),\n+            InsertPosition::Last => {\n+                if !is_multiline {\n+                    // don't insert comma before curly\n+                    to_insert.pop();\n+                }\n+                match self.fields().last() {\n+                    Some(it) => after_field!(it),\n+                    None => after_l_curly!(),\n+                }\n+            }\n+            InsertPosition::Before(anchor) => {\n+                InsertPosition::Before(anchor.syntax().clone().into())\n+            }\n+            InsertPosition::After(anchor) => after_field!(anchor),\n+        };\n+\n+        insert_children(self, position, to_insert.iter().cloned())\n+    }\n+\n+    fn l_curly(&self) -> Option<SyntaxElement> {\n+        self.syntax().children_with_tokens().find(|it| it.kind() == T!['{'])\n+    }\n+}\n+\n pub fn strip_attrs_and_docs<N: ast::AttrsOwner>(node: N) -> N {\n     N::cast(strip_attrs_and_docs_inner(node.syntax().clone())).unwrap()\n }"}]}