{"sha": "51348b068b88d71426d9de93762575cd2bb9a5f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxMzQ4YjA2OGI4OGQ3MTQyNmQ5ZGU5Mzc2MjU3NWNkMmJiOWE1ZjU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-04T07:00:49Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-07T05:19:57Z"}, "message": "native: Deal with the rtio changes", "tree": {"sha": "14ad616076bf9f670aac893d4c24232e94612c74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14ad616076bf9f670aac893d4c24232e94612c74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51348b068b88d71426d9de93762575cd2bb9a5f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51348b068b88d71426d9de93762575cd2bb9a5f5", "html_url": "https://github.com/rust-lang/rust/commit/51348b068b88d71426d9de93762575cd2bb9a5f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51348b068b88d71426d9de93762575cd2bb9a5f5/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da2293c6f6ea9291749f51a4608d50585be835f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/da2293c6f6ea9291749f51a4608d50585be835f0", "html_url": "https://github.com/rust-lang/rust/commit/da2293c6f6ea9291749f51a4608d50585be835f0"}], "stats": {"total": 631, "additions": 313, "deletions": 318}, "files": [{"sha": "b79061dd9d6756d173be8b73ed9468f885faeafd", "filename": "src/libnative/io/addrinfo.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/51348b068b88d71426d9de93762575cd2bb9a5f5/src%2Flibnative%2Fio%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51348b068b88d71426d9de93762575cd2bb9a5f5/src%2Flibnative%2Fio%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Faddrinfo.rs?ref=51348b068b88d71426d9de93762575cd2bb9a5f5", "patch": "@@ -8,21 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ai = std::io::net::addrinfo;\n use libc::{c_char, c_int};\n use libc;\n use std::c_str::CString;\n-use std::io::IoError;\n use std::mem;\n use std::ptr::{null, mut_null};\n+use std::rt::rtio;\n+use std::rt::rtio::IoError;\n \n-use super::net::sockaddr_to_addr;\n+use super::net;\n \n pub struct GetAddrInfoRequest;\n \n impl GetAddrInfoRequest {\n     pub fn run(host: Option<&str>, servname: Option<&str>,\n-               hint: Option<ai::Hint>) -> Result<Vec<ai::Info>, IoError> {\n+               hint: Option<rtio::AddrinfoHint>)\n+        -> Result<Vec<rtio::AddrinfoInfo>, IoError>\n+    {\n         assert!(host.is_some() || servname.is_some());\n \n         let c_host = host.map_or(unsafe { CString::new(null(), true) }, |x| x.to_c_str());\n@@ -61,16 +63,16 @@ impl GetAddrInfoRequest {\n         let mut rp = res;\n         while rp.is_not_null() {\n             unsafe {\n-                let addr = match sockaddr_to_addr(mem::transmute((*rp).ai_addr),\n-                                                  (*rp).ai_addrlen as uint) {\n+                let addr = match net::sockaddr_to_addr(mem::transmute((*rp).ai_addr),\n+                                                       (*rp).ai_addrlen as uint) {\n                     Ok(a) => a,\n                     Err(e) => return Err(e)\n                 };\n-                addrs.push(ai::Info {\n+                addrs.push(rtio::AddrinfoInfo {\n                     address: addr,\n                     family: (*rp).ai_family as uint,\n-                    socktype: None,\n-                    protocol: None,\n+                    socktype: 0,\n+                    protocol: 0,\n                     flags: (*rp).ai_flags as uint\n                 });\n \n@@ -96,21 +98,18 @@ extern \"system\" {\n \n #[cfg(windows)]\n fn get_error(_: c_int) -> IoError {\n-    unsafe {\n-        IoError::from_errno(WSAGetLastError() as uint, true)\n-    }\n+    net::last_error()\n }\n \n #[cfg(not(windows))]\n fn get_error(s: c_int) -> IoError {\n-    use std::io;\n \n     let err_str = unsafe {\n         CString::new(gai_strerror(s), false).as_str().unwrap().to_string()\n     };\n     IoError {\n-        kind: io::OtherIoError,\n-        desc: \"unable to resolve host\",\n+        code: s as uint,\n+        extra: 0,\n         detail: Some(err_str),\n     }\n }"}, {"sha": "fda9b7b1932b0a4b03477c4ecae18dfa2e4ae0de", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 79, "deletions": 102, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/51348b068b88d71426d9de93762575cd2bb9a5f5/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51348b068b88d71426d9de93762575cd2bb9a5f5/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=51348b068b88d71426d9de93762575cd2bb9a5f5", "patch": "@@ -14,12 +14,12 @@ use alloc::arc::Arc;\n use libc::{c_int, c_void};\n use libc;\n use std::c_str::CString;\n-use std::io::IoError;\n-use std::io;\n use std::mem;\n use std::rt::rtio;\n+use std::rt::rtio::IoResult;\n \n-use io::{IoResult, retry, keep_going};\n+use io::{retry, keep_going};\n+use io::util;\n \n pub type fd_t = libc::c_int;\n \n@@ -51,21 +51,21 @@ impl FileDesc {\n     // FIXME(#10465) these functions should not be public, but anything in\n     //               native::io wanting to use them is forced to have all the\n     //               rtio traits in scope\n-    pub fn inner_read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+    pub fn inner_read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let ret = retry(|| unsafe {\n             libc::read(self.fd(),\n                        buf.as_mut_ptr() as *mut libc::c_void,\n                        buf.len() as libc::size_t) as libc::c_int\n         });\n         if ret == 0 {\n-            Err(io::standard_error(io::EndOfFile))\n+            Err(util::eof())\n         } else if ret < 0 {\n             Err(super::last_error())\n         } else {\n             Ok(ret as uint)\n         }\n     }\n-    pub fn inner_write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    pub fn inner_write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let ret = keep_going(buf, |buf, len| {\n             unsafe {\n                 libc::write(self.fd(), buf as *libc::c_void,\n@@ -82,26 +82,14 @@ impl FileDesc {\n     pub fn fd(&self) -> fd_t { self.inner.fd }\n }\n \n-impl io::Reader for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n-        self.inner_read(buf)\n-    }\n-}\n-\n-impl io::Writer for FileDesc {\n-    fn write(&mut self, buf: &[u8]) -> io::IoResult<()> {\n-        self.inner_write(buf)\n-    }\n-}\n-\n impl rtio::RtioFileStream for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<int> {\n         self.inner_read(buf).map(|i| i as int)\n     }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.inner_write(buf)\n     }\n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n+    fn pread(&mut self, buf: &mut [u8], offset: u64) -> IoResult<int> {\n         match retry(|| unsafe {\n             libc::pread(self.fd(), buf.as_ptr() as *libc::c_void,\n                         buf.len() as libc::size_t,\n@@ -111,17 +99,17 @@ impl rtio::RtioFileStream for FileDesc {\n             n => Ok(n as int)\n         }\n     }\n-    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n+    fn pwrite(&mut self, buf: &[u8], offset: u64) -> IoResult<()> {\n         super::mkerr_libc(retry(|| unsafe {\n             libc::pwrite(self.fd(), buf.as_ptr() as *libc::c_void,\n                          buf.len() as libc::size_t, offset as libc::off_t)\n         } as c_int))\n     }\n-    fn seek(&mut self, pos: i64, whence: io::SeekStyle) -> Result<u64, IoError> {\n+    fn seek(&mut self, pos: i64, whence: rtio::SeekStyle) -> IoResult<u64> {\n         let whence = match whence {\n-            io::SeekSet => libc::SEEK_SET,\n-            io::SeekEnd => libc::SEEK_END,\n-            io::SeekCur => libc::SEEK_CUR,\n+            rtio::SeekSet => libc::SEEK_SET,\n+            rtio::SeekEnd => libc::SEEK_END,\n+            rtio::SeekCur => libc::SEEK_CUR,\n         };\n         let n = unsafe { libc::lseek(self.fd(), pos as libc::off_t, whence) };\n         if n < 0 {\n@@ -130,18 +118,18 @@ impl rtio::RtioFileStream for FileDesc {\n             Ok(n as u64)\n         }\n     }\n-    fn tell(&self) -> Result<u64, IoError> {\n+    fn tell(&self) -> IoResult<u64> {\n         let n = unsafe { libc::lseek(self.fd(), 0, libc::SEEK_CUR) };\n         if n < 0 {\n             Err(super::last_error())\n         } else {\n             Ok(n as u64)\n         }\n     }\n-    fn fsync(&mut self) -> Result<(), IoError> {\n+    fn fsync(&mut self) -> IoResult<()> {\n         super::mkerr_libc(retry(|| unsafe { libc::fsync(self.fd()) }))\n     }\n-    fn datasync(&mut self) -> Result<(), IoError> {\n+    fn datasync(&mut self) -> IoResult<()> {\n         return super::mkerr_libc(os_datasync(self.fd()));\n \n         #[cfg(target_os = \"macos\")]\n@@ -157,13 +145,13 @@ impl rtio::RtioFileStream for FileDesc {\n             retry(|| unsafe { libc::fsync(fd) })\n         }\n     }\n-    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n+    fn truncate(&mut self, offset: i64) -> IoResult<()> {\n         super::mkerr_libc(retry(|| unsafe {\n             libc::ftruncate(self.fd(), offset as libc::off_t)\n         }))\n     }\n \n-    fn fstat(&mut self) -> IoResult<io::FileStat> {\n+    fn fstat(&mut self) -> IoResult<rtio::FileStat> {\n         let mut stat: libc::stat = unsafe { mem::zeroed() };\n         match retry(|| unsafe { libc::fstat(self.fd(), &mut stat) }) {\n             0 => Ok(mkstat(&stat)),\n@@ -173,10 +161,10 @@ impl rtio::RtioFileStream for FileDesc {\n }\n \n impl rtio::RtioPipe for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         self.inner_read(buf)\n     }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.inner_write(buf)\n     }\n     fn clone(&self) -> Box<rtio::RtioPipe:Send> {\n@@ -187,28 +175,28 @@ impl rtio::RtioPipe for FileDesc {\n     // impact on the std::io primitives, this is never called via\n     // std::io::PipeStream. If the functionality is exposed in the future, then\n     // these methods will need to be implemented.\n-    fn close_read(&mut self) -> Result<(), IoError> {\n-        Err(io::standard_error(io::InvalidInput))\n+    fn close_read(&mut self) -> IoResult<()> {\n+        Err(super::unimpl())\n     }\n-    fn close_write(&mut self) -> Result<(), IoError> {\n-        Err(io::standard_error(io::InvalidInput))\n+    fn close_write(&mut self) -> IoResult<()> {\n+        Err(super::unimpl())\n     }\n     fn set_timeout(&mut self, _t: Option<u64>) {}\n     fn set_read_timeout(&mut self, _t: Option<u64>) {}\n     fn set_write_timeout(&mut self, _t: Option<u64>) {}\n }\n \n impl rtio::RtioTTY for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         self.inner_read(buf)\n     }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.inner_write(buf)\n     }\n-    fn set_raw(&mut self, _raw: bool) -> Result<(), IoError> {\n+    fn set_raw(&mut self, _raw: bool) -> IoResult<()> {\n         Err(super::unimpl())\n     }\n-    fn get_winsize(&mut self) -> Result<(int, int), IoError> {\n+    fn get_winsize(&mut self) -> IoResult<(int, int)> {\n         Err(super::unimpl())\n     }\n     fn isatty(&self) -> bool { false }\n@@ -249,29 +237,29 @@ impl CFile {\n         }\n     }\n \n-    pub fn flush(&mut self) -> Result<(), IoError> {\n+    pub fn flush(&mut self) -> IoResult<()> {\n         super::mkerr_libc(retry(|| unsafe { libc::fflush(self.file) }))\n     }\n }\n \n impl rtio::RtioFileStream for CFile {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<int> {\n         let ret = keep_going(buf, |buf, len| {\n             unsafe {\n                 libc::fread(buf as *mut libc::c_void, 1, len as libc::size_t,\n                             self.file) as i64\n             }\n         });\n         if ret == 0 {\n-            Err(io::standard_error(io::EndOfFile))\n+            Err(util::eof())\n         } else if ret < 0 {\n             Err(super::last_error())\n         } else {\n             Ok(ret as int)\n         }\n     }\n \n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let ret = keep_going(buf, |buf, len| {\n             unsafe {\n                 libc::fwrite(buf as *libc::c_void, 1, len as libc::size_t,\n@@ -285,17 +273,17 @@ impl rtio::RtioFileStream for CFile {\n         }\n     }\n \n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n+    fn pread(&mut self, buf: &mut [u8], offset: u64) -> IoResult<int> {\n         self.flush().and_then(|()| self.fd.pread(buf, offset))\n     }\n-    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n+    fn pwrite(&mut self, buf: &[u8], offset: u64) -> IoResult<()> {\n         self.flush().and_then(|()| self.fd.pwrite(buf, offset))\n     }\n-    fn seek(&mut self, pos: i64, style: io::SeekStyle) -> Result<u64, IoError> {\n+    fn seek(&mut self, pos: i64, style: rtio::SeekStyle) -> IoResult<u64> {\n         let whence = match style {\n-            io::SeekSet => libc::SEEK_SET,\n-            io::SeekEnd => libc::SEEK_END,\n-            io::SeekCur => libc::SEEK_CUR,\n+            rtio::SeekSet => libc::SEEK_SET,\n+            rtio::SeekEnd => libc::SEEK_END,\n+            rtio::SeekCur => libc::SEEK_CUR,\n         };\n         let n = unsafe { libc::fseek(self.file, pos as libc::c_long, whence) };\n         if n < 0 {\n@@ -304,25 +292,25 @@ impl rtio::RtioFileStream for CFile {\n             Ok(n as u64)\n         }\n     }\n-    fn tell(&self) -> Result<u64, IoError> {\n+    fn tell(&self) -> IoResult<u64> {\n         let ret = unsafe { libc::ftell(self.file) };\n         if ret < 0 {\n             Err(super::last_error())\n         } else {\n             Ok(ret as u64)\n         }\n     }\n-    fn fsync(&mut self) -> Result<(), IoError> {\n+    fn fsync(&mut self) -> IoResult<()> {\n         self.flush().and_then(|()| self.fd.fsync())\n     }\n-    fn datasync(&mut self) -> Result<(), IoError> {\n+    fn datasync(&mut self) -> IoResult<()> {\n         self.flush().and_then(|()| self.fd.fsync())\n     }\n-    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n+    fn truncate(&mut self, offset: i64) -> IoResult<()> {\n         self.flush().and_then(|()| self.fd.truncate(offset))\n     }\n \n-    fn fstat(&mut self) -> IoResult<io::FileStat> {\n+    fn fstat(&mut self) -> IoResult<rtio::FileStat> {\n         self.flush().and_then(|()| self.fd.fstat())\n     }\n }\n@@ -333,20 +321,21 @@ impl Drop for CFile {\n     }\n }\n \n-pub fn open(path: &CString, fm: io::FileMode, fa: io::FileAccess)\n-        -> IoResult<FileDesc> {\n+pub fn open(path: &CString, fm: rtio::FileMode, fa: rtio::FileAccess)\n+    -> IoResult<FileDesc>\n+{\n     let flags = match fm {\n-        io::Open => 0,\n-        io::Append => libc::O_APPEND,\n-        io::Truncate => libc::O_TRUNC,\n+        rtio::Open => 0,\n+        rtio::Append => libc::O_APPEND,\n+        rtio::Truncate => libc::O_TRUNC,\n     };\n     // Opening with a write permission must silently create the file.\n     let (flags, mode) = match fa {\n-        io::Read => (flags | libc::O_RDONLY, 0),\n-        io::Write => (flags | libc::O_WRONLY | libc::O_CREAT,\n-                      libc::S_IRUSR | libc::S_IWUSR),\n-        io::ReadWrite => (flags | libc::O_RDWR | libc::O_CREAT,\n-                          libc::S_IRUSR | libc::S_IWUSR),\n+        rtio::Read => (flags | libc::O_RDONLY, 0),\n+        rtio::Write => (flags | libc::O_WRONLY | libc::O_CREAT,\n+                        libc::S_IRUSR | libc::S_IWUSR),\n+        rtio::ReadWrite => (flags | libc::O_RDWR | libc::O_CREAT,\n+                            libc::S_IRUSR | libc::S_IWUSR),\n     };\n \n     match retry(|| unsafe { libc::open(path.with_ref(|p| p), flags, mode) }) {\n@@ -355,9 +344,9 @@ pub fn open(path: &CString, fm: io::FileMode, fa: io::FileAccess)\n     }\n }\n \n-pub fn mkdir(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n+pub fn mkdir(p: &CString, mode: uint) -> IoResult<()> {\n     super::mkerr_libc(retry(|| unsafe {\n-        libc::mkdir(p.with_ref(|p| p), mode.bits() as libc::mode_t)\n+        libc::mkdir(p.with_ref(|p| p), mode as libc::mode_t)\n     }))\n }\n \n@@ -412,9 +401,9 @@ pub fn rename(old: &CString, new: &CString) -> IoResult<()> {\n     }))\n }\n \n-pub fn chmod(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n+pub fn chmod(p: &CString, mode: uint) -> IoResult<()> {\n     super::mkerr_libc(retry(|| unsafe {\n-        libc::chmod(p.with_ref(|p| p), mode.bits() as libc::mode_t)\n+        libc::chmod(p.with_ref(|p| p), mode as libc::mode_t)\n     }))\n }\n \n@@ -463,19 +452,10 @@ pub fn link(src: &CString, dst: &CString) -> IoResult<()> {\n     }))\n }\n \n-fn mkstat(stat: &libc::stat) -> io::FileStat {\n+fn mkstat(stat: &libc::stat) -> rtio::FileStat {\n     // FileStat times are in milliseconds\n     fn mktime(secs: u64, nsecs: u64) -> u64 { secs * 1000 + nsecs / 1000000 }\n \n-    let kind = match (stat.st_mode as c_int) & libc::S_IFMT {\n-        libc::S_IFREG => io::TypeFile,\n-        libc::S_IFDIR => io::TypeDirectory,\n-        libc::S_IFIFO => io::TypeNamedPipe,\n-        libc::S_IFBLK => io::TypeBlockSpecial,\n-        libc::S_IFLNK => io::TypeSymlink,\n-        _ => io::TypeUnknown,\n-    };\n-\n     #[cfg(not(target_os = \"linux\"), not(target_os = \"android\"))]\n     fn flags(stat: &libc::stat) -> u64 { stat.st_flags as u64 }\n     #[cfg(target_os = \"linux\")] #[cfg(target_os = \"android\")]\n@@ -486,37 +466,35 @@ fn mkstat(stat: &libc::stat) -> io::FileStat {\n     #[cfg(target_os = \"linux\")] #[cfg(target_os = \"android\")]\n     fn gen(_stat: &libc::stat) -> u64 { 0 }\n \n-    io::FileStat {\n+    rtio::FileStat {\n         size: stat.st_size as u64,\n-        kind: kind,\n-        perm: io::FilePermission::from_bits_truncate(stat.st_mode as u32),\n+        kind: stat.st_mode as u64,\n+        perm: stat.st_mode as u64,\n         created: mktime(stat.st_ctime as u64, stat.st_ctime_nsec as u64),\n         modified: mktime(stat.st_mtime as u64, stat.st_mtime_nsec as u64),\n         accessed: mktime(stat.st_atime as u64, stat.st_atime_nsec as u64),\n-        unstable: io::UnstableFileStat {\n-            device: stat.st_dev as u64,\n-            inode: stat.st_ino as u64,\n-            rdev: stat.st_rdev as u64,\n-            nlink: stat.st_nlink as u64,\n-            uid: stat.st_uid as u64,\n-            gid: stat.st_gid as u64,\n-            blksize: stat.st_blksize as u64,\n-            blocks: stat.st_blocks as u64,\n-            flags: flags(stat),\n-            gen: gen(stat),\n-        }\n+        device: stat.st_dev as u64,\n+        inode: stat.st_ino as u64,\n+        rdev: stat.st_rdev as u64,\n+        nlink: stat.st_nlink as u64,\n+        uid: stat.st_uid as u64,\n+        gid: stat.st_gid as u64,\n+        blksize: stat.st_blksize as u64,\n+        blocks: stat.st_blocks as u64,\n+        flags: flags(stat),\n+        gen: gen(stat),\n     }\n }\n \n-pub fn stat(p: &CString) -> IoResult<io::FileStat> {\n+pub fn stat(p: &CString) -> IoResult<rtio::FileStat> {\n     let mut stat: libc::stat = unsafe { mem::zeroed() };\n     match retry(|| unsafe { libc::stat(p.with_ref(|p| p), &mut stat) }) {\n         0 => Ok(mkstat(&stat)),\n         _ => Err(super::last_error()),\n     }\n }\n \n-pub fn lstat(p: &CString) -> IoResult<io::FileStat> {\n+pub fn lstat(p: &CString) -> IoResult<rtio::FileStat> {\n     let mut stat: libc::stat = unsafe { mem::zeroed() };\n     match retry(|| unsafe { libc::lstat(p.with_ref(|p| p), &mut stat) }) {\n         0 => Ok(mkstat(&stat)),\n@@ -537,10 +515,9 @@ pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n #[cfg(test)]\n mod tests {\n     use super::{CFile, FileDesc};\n-    use std::io;\n     use libc;\n     use std::os;\n-    use std::rt::rtio::RtioFileStream;\n+    use std::rt::rtio::{RtioFileStream, SeekSet};\n \n     #[ignore(cfg(target_os = \"freebsd\"))] // hmm, maybe pipes have a tiny buffer\n     #[test]\n@@ -551,7 +528,7 @@ mod tests {\n         let mut reader = FileDesc::new(input, true);\n         let mut writer = FileDesc::new(out, true);\n \n-        writer.inner_write(bytes!(\"test\")).unwrap();\n+        writer.inner_write(bytes!(\"test\")).ok().unwrap();\n         let mut buf = [0u8, ..4];\n         match reader.inner_read(buf) {\n             Ok(4) => {\n@@ -574,9 +551,9 @@ mod tests {\n             assert!(!f.is_null());\n             let mut file = CFile::new(f);\n \n-            file.write(bytes!(\"test\")).unwrap();\n+            file.write(bytes!(\"test\")).ok().unwrap();\n             let mut buf = [0u8, ..4];\n-            let _ = file.seek(0, io::SeekSet).unwrap();\n+            let _ = file.seek(0, SeekSet).ok().unwrap();\n             match file.read(buf) {\n                 Ok(4) => {\n                     assert_eq!(buf[0], 't' as u8);"}, {"sha": "443c82c6a547c53918a3ebd586783ce604268805", "filename": "src/libnative/io/helper_thread.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51348b068b88d71426d9de93762575cd2bb9a5f5/src%2Flibnative%2Fio%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51348b068b88d71426d9de93762575cd2bb9a5f5/src%2Flibnative%2Fio%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fhelper_thread.rs?ref=51348b068b88d71426d9de93762575cd2bb9a5f5", "patch": "@@ -24,9 +24,9 @@\n \n use std::mem;\n use std::rt::bookkeeping;\n+use std::rt::mutex::StaticNativeMutex;\n use std::rt;\n use std::ty::Unsafe;\n-use std::unstable::mutex::StaticNativeMutex;\n \n use task;\n \n@@ -57,7 +57,7 @@ pub struct Helper<M> {\n \n macro_rules! helper_init( (static mut $name:ident: Helper<$m:ty>) => (\n     static mut $name: Helper<$m> = Helper {\n-        lock: ::std::unstable::mutex::NATIVE_MUTEX_INIT,\n+        lock: ::std::rt::mutex::NATIVE_MUTEX_INIT,\n         chan: ::std::ty::Unsafe {\n             value: 0 as *mut Sender<$m>,\n             marker1: ::std::kinds::marker::InvariantType,\n@@ -163,7 +163,7 @@ mod imp {\n     }\n \n     pub fn signal(fd: libc::c_int) {\n-        FileDesc::new(fd, false).inner_write([0]).unwrap();\n+        FileDesc::new(fd, false).inner_write([0]).ok().unwrap();\n     }\n \n     pub fn close(fd: libc::c_int) {"}, {"sha": "3b0dbe2d0dce978e63be79d4c53ef6cdfd302e2a", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 60, "deletions": 54, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/51348b068b88d71426d9de93762575cd2bb9a5f5/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51348b068b88d71426d9de93762575cd2bb9a5f5/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=51348b068b88d71426d9de93762575cd2bb9a5f5", "patch": "@@ -26,16 +26,9 @@\n use libc::c_int;\n use libc;\n use std::c_str::CString;\n-use std::io;\n-use std::io::IoError;\n-use std::io::net::ip::SocketAddr;\n-use std::io::signal::Signum;\n use std::os;\n use std::rt::rtio;\n-use std::rt::rtio::{RtioTcpStream, RtioTcpListener, RtioUdpSocket};\n-use std::rt::rtio::{RtioUnixListener, RtioPipe, RtioFileStream, RtioProcess};\n-use std::rt::rtio::{RtioSignal, RtioTTY, CloseBehavior, RtioTimer, ProcessConfig};\n-use ai = std::io::net::addrinfo;\n+use std::rt::rtio::{IoResult, IoError};\n \n // Local re-exports\n pub use self::file::FileDesc;\n@@ -78,18 +71,23 @@ pub mod pipe;\n #[cfg(unix)]    #[path = \"c_unix.rs\"]  mod c;\n #[cfg(windows)] #[path = \"c_win32.rs\"] mod c;\n \n-pub type IoResult<T> = Result<T, IoError>;\n-\n fn unimpl() -> IoError {\n+    #[cfg(unix)] use ERROR = libc::ENOSYS;\n+    #[cfg(windows)] use ERROR = libc::ERROR_CALL_NOT_IMPLEMENTED;\n     IoError {\n-        kind: io::IoUnavailable,\n-        desc: \"unimplemented I/O interface\",\n+        code: ERROR as uint,\n+        extra: 0,\n         detail: None,\n     }\n }\n \n fn last_error() -> IoError {\n-    IoError::last_error()\n+    let errno = os::errno() as uint;\n+    IoError {\n+        code: os::errno() as uint,\n+        extra: 0,\n+        detail: Some(os::error_string(errno)),\n+    }\n }\n \n // unix has nonzero values as errors\n@@ -166,64 +164,70 @@ impl IoFactory {\n \n impl rtio::IoFactory for IoFactory {\n     // networking\n-    fn tcp_connect(&mut self, addr: SocketAddr,\n-                   timeout: Option<u64>) -> IoResult<Box<RtioTcpStream:Send>> {\n+    fn tcp_connect(&mut self, addr: rtio::SocketAddr,\n+                   timeout: Option<u64>)\n+        -> IoResult<Box<rtio::RtioTcpStream:Send>>\n+    {\n         net::TcpStream::connect(addr, timeout).map(|s| {\n-            box s as Box<RtioTcpStream:Send>\n+            box s as Box<rtio::RtioTcpStream:Send>\n         })\n     }\n-    fn tcp_bind(&mut self, addr: SocketAddr)\n-                -> IoResult<Box<RtioTcpListener:Send>> {\n+    fn tcp_bind(&mut self, addr: rtio::SocketAddr)\n+                -> IoResult<Box<rtio::RtioTcpListener:Send>> {\n         net::TcpListener::bind(addr).map(|s| {\n-            box s as Box<RtioTcpListener:Send>\n+            box s as Box<rtio::RtioTcpListener:Send>\n         })\n     }\n-    fn udp_bind(&mut self, addr: SocketAddr)\n-                -> IoResult<Box<RtioUdpSocket:Send>> {\n-        net::UdpSocket::bind(addr).map(|u| box u as Box<RtioUdpSocket:Send>)\n+    fn udp_bind(&mut self, addr: rtio::SocketAddr)\n+                -> IoResult<Box<rtio::RtioUdpSocket:Send>> {\n+        net::UdpSocket::bind(addr).map(|u| {\n+            box u as Box<rtio::RtioUdpSocket:Send>\n+        })\n     }\n     fn unix_bind(&mut self, path: &CString)\n-                 -> IoResult<Box<RtioUnixListener:Send>> {\n+                 -> IoResult<Box<rtio::RtioUnixListener:Send>> {\n         pipe::UnixListener::bind(path).map(|s| {\n-            box s as Box<RtioUnixListener:Send>\n+            box s as Box<rtio::RtioUnixListener:Send>\n         })\n     }\n     fn unix_connect(&mut self, path: &CString,\n-                    timeout: Option<u64>) -> IoResult<Box<RtioPipe:Send>> {\n+                    timeout: Option<u64>) -> IoResult<Box<rtio::RtioPipe:Send>> {\n         pipe::UnixStream::connect(path, timeout).map(|s| {\n-            box s as Box<RtioPipe:Send>\n+            box s as Box<rtio::RtioPipe:Send>\n         })\n     }\n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n-                          hint: Option<ai::Hint>) -> IoResult<Vec<ai::Info>> {\n+                          hint: Option<rtio::AddrinfoHint>)\n+        -> IoResult<Vec<rtio::AddrinfoInfo>>\n+    {\n         addrinfo::GetAddrInfoRequest::run(host, servname, hint)\n     }\n \n     // filesystem operations\n-    fn fs_from_raw_fd(&mut self, fd: c_int, close: CloseBehavior)\n-                      -> Box<RtioFileStream:Send> {\n+    fn fs_from_raw_fd(&mut self, fd: c_int, close: rtio::CloseBehavior)\n+                      -> Box<rtio::RtioFileStream:Send> {\n         let close = match close {\n             rtio::CloseSynchronously | rtio::CloseAsynchronously => true,\n             rtio::DontClose => false\n         };\n-        box file::FileDesc::new(fd, close) as Box<RtioFileStream:Send>\n+        box file::FileDesc::new(fd, close) as Box<rtio::RtioFileStream:Send>\n     }\n-    fn fs_open(&mut self, path: &CString, fm: io::FileMode, fa: io::FileAccess)\n-        -> IoResult<Box<RtioFileStream:Send>> {\n-        file::open(path, fm, fa).map(|fd| box fd as Box<RtioFileStream:Send>)\n+    fn fs_open(&mut self, path: &CString, fm: rtio::FileMode,\n+               fa: rtio::FileAccess)\n+        -> IoResult<Box<rtio::RtioFileStream:Send>>\n+    {\n+        file::open(path, fm, fa).map(|fd| box fd as Box<rtio::RtioFileStream:Send>)\n     }\n     fn fs_unlink(&mut self, path: &CString) -> IoResult<()> {\n         file::unlink(path)\n     }\n-    fn fs_stat(&mut self, path: &CString) -> IoResult<io::FileStat> {\n+    fn fs_stat(&mut self, path: &CString) -> IoResult<rtio::FileStat> {\n         file::stat(path)\n     }\n-    fn fs_mkdir(&mut self, path: &CString,\n-                mode: io::FilePermission) -> IoResult<()> {\n+    fn fs_mkdir(&mut self, path: &CString, mode: uint) -> IoResult<()> {\n         file::mkdir(path, mode)\n     }\n-    fn fs_chmod(&mut self, path: &CString,\n-                mode: io::FilePermission) -> IoResult<()> {\n+    fn fs_chmod(&mut self, path: &CString, mode: uint) -> IoResult<()> {\n         file::chmod(path, mode)\n     }\n     fn fs_rmdir(&mut self, path: &CString) -> IoResult<()> {\n@@ -235,7 +239,7 @@ impl rtio::IoFactory for IoFactory {\n     fn fs_readdir(&mut self, path: &CString, _flags: c_int) -> IoResult<Vec<CString>> {\n         file::readdir(path)\n     }\n-    fn fs_lstat(&mut self, path: &CString) -> IoResult<io::FileStat> {\n+    fn fs_lstat(&mut self, path: &CString) -> IoResult<rtio::FileStat> {\n         file::lstat(path)\n     }\n     fn fs_chown(&mut self, path: &CString, uid: int, gid: int) -> IoResult<()> {\n@@ -256,39 +260,41 @@ impl rtio::IoFactory for IoFactory {\n     }\n \n     // misc\n-    fn timer_init(&mut self) -> IoResult<Box<RtioTimer:Send>> {\n-        timer::Timer::new().map(|t| box t as Box<RtioTimer:Send>)\n+    fn timer_init(&mut self) -> IoResult<Box<rtio::RtioTimer:Send>> {\n+        timer::Timer::new().map(|t| box t as Box<rtio::RtioTimer:Send>)\n     }\n-    fn spawn(&mut self, cfg: ProcessConfig)\n-            -> IoResult<(Box<RtioProcess:Send>,\n-                         Vec<Option<Box<RtioPipe:Send>>>)> {\n+    fn spawn(&mut self, cfg: rtio::ProcessConfig)\n+            -> IoResult<(Box<rtio::RtioProcess:Send>,\n+                         Vec<Option<Box<rtio::RtioPipe:Send>>>)> {\n         process::Process::spawn(cfg).map(|(p, io)| {\n-            (box p as Box<RtioProcess:Send>,\n+            (box p as Box<rtio::RtioProcess:Send>,\n              io.move_iter().map(|p| p.map(|p| {\n-                 box p as Box<RtioPipe:Send>\n+                 box p as Box<rtio::RtioPipe:Send>\n              })).collect())\n         })\n     }\n     fn kill(&mut self, pid: libc::pid_t, signum: int) -> IoResult<()> {\n         process::Process::kill(pid, signum)\n     }\n-    fn pipe_open(&mut self, fd: c_int) -> IoResult<Box<RtioPipe:Send>> {\n-        Ok(box file::FileDesc::new(fd, true) as Box<RtioPipe:Send>)\n+    fn pipe_open(&mut self, fd: c_int) -> IoResult<Box<rtio::RtioPipe:Send>> {\n+        Ok(box file::FileDesc::new(fd, true) as Box<rtio::RtioPipe:Send>)\n     }\n     fn tty_open(&mut self, fd: c_int, _readable: bool)\n-                -> IoResult<Box<RtioTTY:Send>> {\n+                -> IoResult<Box<rtio::RtioTTY:Send>> {\n+        #[cfg(unix)] use ERROR = libc::ENOTTY;\n+        #[cfg(windows)] use ERROR = libc::ERROR_INVALID_HANDLE;\n         if unsafe { libc::isatty(fd) } != 0 {\n-            Ok(box file::FileDesc::new(fd, true) as Box<RtioTTY:Send>)\n+            Ok(box file::FileDesc::new(fd, true) as Box<rtio::RtioTTY:Send>)\n         } else {\n             Err(IoError {\n-                kind: io::MismatchedFileTypeForOperation,\n-                desc: \"file descriptor is not a TTY\",\n+                code: ERROR as uint,\n+                extra: 0,\n                 detail: None,\n             })\n         }\n     }\n-    fn signal(&mut self, _signal: Signum, _channel: Sender<Signum>)\n-              -> IoResult<Box<RtioSignal:Send>> {\n+    fn signal(&mut self, _signal: int, _cb: Box<rtio::Callback>)\n+              -> IoResult<Box<rtio::RtioSignal:Send>> {\n         Err(unimpl())\n     }\n }"}, {"sha": "68cc5273b5e355c898f646b2b586e1a553fa323f", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 51, "deletions": 50, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/51348b068b88d71426d9de93762575cd2bb9a5f5/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51348b068b88d71426d9de93762575cd2bb9a5f5/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=51348b068b88d71426d9de93762575cd2bb9a5f5", "patch": "@@ -10,13 +10,12 @@\n \n use alloc::arc::Arc;\n use libc;\n-use std::io::net::ip;\n-use std::io;\n use std::mem;\n+use std::rt::mutex;\n use std::rt::rtio;\n-use std::unstable::mutex;\n+use std::rt::rtio::{IoResult, IoError};\n \n-use super::{IoResult, retry, keep_going};\n+use super::{retry, keep_going};\n use super::c;\n use super::util;\n \n@@ -39,9 +38,9 @@ enum InAddr {\n     In6Addr(libc::in6_addr),\n }\n \n-fn ip_to_inaddr(ip: ip::IpAddr) -> InAddr {\n+fn ip_to_inaddr(ip: rtio::IpAddr) -> InAddr {\n     match ip {\n-        ip::Ipv4Addr(a, b, c, d) => {\n+        rtio::Ipv4Addr(a, b, c, d) => {\n             let ip = (a as u32 << 24) |\n                      (b as u32 << 16) |\n                      (c as u32 <<  8) |\n@@ -50,7 +49,7 @@ fn ip_to_inaddr(ip: ip::IpAddr) -> InAddr {\n                 s_addr: mem::from_be32(ip)\n             })\n         }\n-        ip::Ipv6Addr(a, b, c, d, e, f, g, h) => {\n+        rtio::Ipv6Addr(a, b, c, d, e, f, g, h) => {\n             In6Addr(libc::in6_addr {\n                 s6_addr: [\n                     htons(a),\n@@ -67,7 +66,7 @@ fn ip_to_inaddr(ip: ip::IpAddr) -> InAddr {\n     }\n }\n \n-fn addr_to_sockaddr(addr: ip::SocketAddr) -> (libc::sockaddr_storage, uint) {\n+fn addr_to_sockaddr(addr: rtio::SocketAddr) -> (libc::sockaddr_storage, uint) {\n     unsafe {\n         let storage: libc::sockaddr_storage = mem::zeroed();\n         let len = match ip_to_inaddr(addr.ip) {\n@@ -90,11 +89,11 @@ fn addr_to_sockaddr(addr: ip::SocketAddr) -> (libc::sockaddr_storage, uint) {\n     }\n }\n \n-fn socket(addr: ip::SocketAddr, ty: libc::c_int) -> IoResult<sock_t> {\n+fn socket(addr: rtio::SocketAddr, ty: libc::c_int) -> IoResult<sock_t> {\n     unsafe {\n         let fam = match addr.ip {\n-            ip::Ipv4Addr(..) => libc::AF_INET,\n-            ip::Ipv6Addr(..) => libc::AF_INET6,\n+            rtio::Ipv4Addr(..) => libc::AF_INET,\n+            rtio::Ipv6Addr(..) => libc::AF_INET6,\n         };\n         match libc::socket(fam, ty, 0) {\n             -1 => Err(super::last_error()),\n@@ -136,12 +135,16 @@ pub fn getsockopt<T: Copy>(fd: sock_t, opt: libc::c_int,\n }\n \n #[cfg(windows)]\n-fn last_error() -> io::IoError {\n-    io::IoError::from_errno(unsafe { c::WSAGetLastError() } as uint, true)\n+fn last_error() -> IoError {\n+    let code = unsafe { c::WSAGetLastError() as uint };\n+    IoError {\n+        code: code,\n+        detail: Some(os::error_string(code)),\n+    }\n }\n \n #[cfg(not(windows))]\n-fn last_error() -> io::IoError {\n+fn last_error() -> IoError {\n     super::last_error()\n }\n \n@@ -151,7 +154,7 @@ fn last_error() -> io::IoError {\n fn sockname(fd: sock_t,\n             f: unsafe extern \"system\" fn(sock_t, *mut libc::sockaddr,\n                                          *mut libc::socklen_t) -> libc::c_int)\n-    -> IoResult<ip::SocketAddr>\n+    -> IoResult<rtio::SocketAddr>\n {\n     let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n     let mut len = mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n@@ -168,7 +171,7 @@ fn sockname(fd: sock_t,\n }\n \n pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n-                        len: uint) -> IoResult<ip::SocketAddr> {\n+                        len: uint) -> IoResult<rtio::SocketAddr> {\n     match storage.ss_family as libc::c_int {\n         libc::AF_INET => {\n             assert!(len as uint >= mem::size_of::<libc::sockaddr_in>());\n@@ -180,8 +183,8 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n             let b = (ip >> 16) as u8;\n             let c = (ip >>  8) as u8;\n             let d = (ip >>  0) as u8;\n-            Ok(ip::SocketAddr {\n-                ip: ip::Ipv4Addr(a, b, c, d),\n+            Ok(rtio::SocketAddr {\n+                ip: rtio::Ipv4Addr(a, b, c, d),\n                 port: ntohs(storage.sin_port),\n             })\n         }\n@@ -198,13 +201,19 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n             let f = ntohs(storage.sin6_addr.s6_addr[5]);\n             let g = ntohs(storage.sin6_addr.s6_addr[6]);\n             let h = ntohs(storage.sin6_addr.s6_addr[7]);\n-            Ok(ip::SocketAddr {\n-                ip: ip::Ipv6Addr(a, b, c, d, e, f, g, h),\n+            Ok(rtio::SocketAddr {\n+                ip: rtio::Ipv6Addr(a, b, c, d, e, f, g, h),\n                 port: ntohs(storage.sin6_port),\n             })\n         }\n         _ => {\n-            Err(io::standard_error(io::OtherIoError))\n+            #[cfg(unix)] use ERROR = libc::EINVAL;\n+            #[cfg(windows)] use ERROR = libc::WSAEINVAL;\n+            Err(IoError {\n+                code: ERROR as uint,\n+                extra: 0,\n+                detail: None,\n+            })\n         }\n     }\n }\n@@ -258,7 +267,7 @@ impl Inner {\n }\n \n impl TcpStream {\n-    pub fn connect(addr: ip::SocketAddr,\n+    pub fn connect(addr: rtio::SocketAddr,\n                    timeout: Option<u64>) -> IoResult<TcpStream> {\n         let fd = try!(socket(addr, libc::SOCK_STREAM));\n         let ret = TcpStream::new(Inner::new(fd));\n@@ -366,7 +375,7 @@ impl rtio::RtioTcpStream for TcpStream {\n             Err(e) => Err(e)\n         }\n     }\n-    fn peer_name(&mut self) -> IoResult<ip::SocketAddr> {\n+    fn peer_name(&mut self) -> IoResult<rtio::SocketAddr> {\n         sockname(self.fd(), libc::getpeername)\n     }\n     fn control_congestion(&mut self) -> IoResult<()> {\n@@ -411,7 +420,7 @@ impl rtio::RtioTcpStream for TcpStream {\n }\n \n impl rtio::RtioSocket for TcpStream {\n-    fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n+    fn socket_name(&mut self) -> IoResult<rtio::SocketAddr> {\n         sockname(self.fd(), libc::getsockname)\n     }\n }\n@@ -436,7 +445,7 @@ pub struct TcpListener {\n }\n \n impl TcpListener {\n-    pub fn bind(addr: ip::SocketAddr) -> IoResult<TcpListener> {\n+    pub fn bind(addr: rtio::SocketAddr) -> IoResult<TcpListener> {\n         let fd = try!(socket(addr, libc::SOCK_STREAM));\n         let ret = TcpListener { inner: Inner::new(fd) };\n \n@@ -477,7 +486,7 @@ impl rtio::RtioTcpListener for TcpListener {\n }\n \n impl rtio::RtioSocket for TcpListener {\n-    fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n+    fn socket_name(&mut self) -> IoResult<rtio::SocketAddr> {\n         sockname(self.fd(), libc::getsockname)\n     }\n }\n@@ -512,7 +521,7 @@ impl TcpAcceptor {\n }\n \n impl rtio::RtioSocket for TcpAcceptor {\n-    fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n+    fn socket_name(&mut self) -> IoResult<rtio::SocketAddr> {\n         sockname(self.fd(), libc::getsockname)\n     }\n }\n@@ -540,7 +549,7 @@ pub struct UdpSocket {\n }\n \n impl UdpSocket {\n-    pub fn bind(addr: ip::SocketAddr) -> IoResult<UdpSocket> {\n+    pub fn bind(addr: rtio::SocketAddr) -> IoResult<UdpSocket> {\n         let fd = try!(socket(addr, libc::SOCK_DGRAM));\n         let ret = UdpSocket {\n             inner: Arc::new(Inner::new(fd)),\n@@ -570,7 +579,7 @@ impl UdpSocket {\n                    on as libc::c_int)\n     }\n \n-    pub fn set_membership(&mut self, addr: ip::IpAddr,\n+    pub fn set_membership(&mut self, addr: rtio::IpAddr,\n                           opt: libc::c_int) -> IoResult<()> {\n         match ip_to_inaddr(addr) {\n             InAddr(addr) => {\n@@ -606,7 +615,7 @@ impl UdpSocket {\n }\n \n impl rtio::RtioSocket for UdpSocket {\n-    fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n+    fn socket_name(&mut self) -> IoResult<rtio::SocketAddr> {\n         sockname(self.fd(), libc::getsockname)\n     }\n }\n@@ -615,7 +624,7 @@ impl rtio::RtioSocket for UdpSocket {\n #[cfg(unix)]    type msglen_t = libc::size_t;\n \n impl rtio::RtioUdpSocket for UdpSocket {\n-    fn recvfrom(&mut self, buf: &mut [u8]) -> IoResult<(uint, ip::SocketAddr)> {\n+    fn recvfrom(&mut self, buf: &mut [u8]) -> IoResult<(uint, rtio::SocketAddr)> {\n         let fd = self.fd();\n         let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n         let storagep = &mut storage as *mut _ as *mut libc::sockaddr;\n@@ -638,7 +647,7 @@ impl rtio::RtioUdpSocket for UdpSocket {\n         })\n     }\n \n-    fn sendto(&mut self, buf: &[u8], dst: ip::SocketAddr) -> IoResult<()> {\n+    fn sendto(&mut self, buf: &[u8], dst: rtio::SocketAddr) -> IoResult<()> {\n         let (dst, dstlen) = addr_to_sockaddr(dst);\n         let dstp = &dst as *_ as *libc::sockaddr;\n         let dstlen = dstlen as libc::socklen_t;\n@@ -657,32 +666,28 @@ impl rtio::RtioUdpSocket for UdpSocket {\n \n         let n = try!(write(fd, self.write_deadline, buf, false, dolock, dowrite));\n         if n != buf.len() {\n-            Err(io::IoError {\n-                kind: io::ShortWrite(n),\n-                desc: \"couldn't send entire packet at once\",\n-                detail: None,\n-            })\n+            Err(util::short_write(n, \"couldn't send entire packet at once\"))\n         } else {\n             Ok(())\n         }\n     }\n \n-    fn join_multicast(&mut self, multi: ip::IpAddr) -> IoResult<()> {\n+    fn join_multicast(&mut self, multi: rtio::IpAddr) -> IoResult<()> {\n         match multi {\n-            ip::Ipv4Addr(..) => {\n+            rtio::Ipv4Addr(..) => {\n                 self.set_membership(multi, libc::IP_ADD_MEMBERSHIP)\n             }\n-            ip::Ipv6Addr(..) => {\n+            rtio::Ipv6Addr(..) => {\n                 self.set_membership(multi, libc::IPV6_ADD_MEMBERSHIP)\n             }\n         }\n     }\n-    fn leave_multicast(&mut self, multi: ip::IpAddr) -> IoResult<()> {\n+    fn leave_multicast(&mut self, multi: rtio::IpAddr) -> IoResult<()> {\n         match multi {\n-            ip::Ipv4Addr(..) => {\n+            rtio::Ipv4Addr(..) => {\n                 self.set_membership(multi, libc::IP_DROP_MEMBERSHIP)\n             }\n-            ip::Ipv6Addr(..) => {\n+            rtio::Ipv6Addr(..) => {\n                 self.set_membership(multi, libc::IPV6_DROP_MEMBERSHIP)\n             }\n         }\n@@ -821,7 +826,7 @@ pub fn read<T>(fd: sock_t,\n     }\n \n     match ret {\n-        0 => Err(io::standard_error(io::EndOfFile)),\n+        0 => Err(util::eof()),\n         n if n < 0 => Err(last_error()),\n         n => Ok(n as uint)\n     }\n@@ -858,13 +863,9 @@ pub fn write<T>(fd: sock_t,\n             // As with read(), first wait for the socket to be ready for\n             // the I/O operation.\n             match util::await(fd, deadline, util::Writable) {\n-                Err(ref e) if e.kind == io::TimedOut && written > 0 => {\n+                Err(ref e) if e.code == libc::EOF as uint && written > 0 => {\n                     assert!(deadline.is_some());\n-                    return Err(io::IoError {\n-                        kind: io::ShortWrite(written),\n-                        desc: \"short write\",\n-                        detail: None,\n-                    })\n+                    return Err(util::short_write(written, \"short write\"))\n                 }\n                 Err(e) => return Err(e),\n                 Ok(()) => {}"}, {"sha": "7a1134fbe5956109bed023e09ad0e6997ce1b0d8", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/51348b068b88d71426d9de93762575cd2bb9a5f5/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51348b068b88d71426d9de93762575cd2bb9a5f5/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=51348b068b88d71426d9de93762575cd2bb9a5f5", "patch": "@@ -11,13 +11,12 @@\n use alloc::arc::Arc;\n use libc;\n use std::c_str::CString;\n-use std::intrinsics;\n-use std::io;\n use std::mem;\n+use std::rt::mutex;\n use std::rt::rtio;\n-use std::unstable::mutex;\n+use std::rt::rtio::{IoResult, IoError};\n \n-use super::{IoResult, retry};\n+use super::retry;\n use super::net;\n use super::util;\n use super::c;\n@@ -34,15 +33,17 @@ fn addr_to_sockaddr_un(addr: &CString) -> IoResult<(libc::sockaddr_storage, uint\n     // the sun_path length is limited to SUN_LEN (with null)\n     assert!(mem::size_of::<libc::sockaddr_storage>() >=\n             mem::size_of::<libc::sockaddr_un>());\n-    let mut storage: libc::sockaddr_storage = unsafe { intrinsics::init() };\n+    let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n     let s: &mut libc::sockaddr_un = unsafe { mem::transmute(&mut storage) };\n \n     let len = addr.len();\n     if len > s.sun_path.len() - 1 {\n-        return Err(io::IoError {\n-            kind: io::InvalidInput,\n-            desc: \"path must be smaller than SUN_LEN\",\n-            detail: None,\n+        #[cfg(unix)] use ERROR = libc::EINVAL;\n+        #[cfg(windows)] use ERROR = libc::WSAEINVAL;\n+        return Err(IoError {\n+            code: ERROR as uint,\n+            extra: 0,\n+            detail: Some(\"path must be smaller than SUN_LEN\".to_str()),\n         })\n     }\n     s.sun_family = libc::AF_UNIX as libc::sa_family_t;\n@@ -244,7 +245,7 @@ impl UnixAcceptor {\n         if self.deadline != 0 {\n             try!(util::await(self.fd(), Some(self.deadline), util::Readable));\n         }\n-        let mut storage: libc::sockaddr_storage = unsafe { intrinsics::init() };\n+        let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n         let storagep = &mut storage as *mut libc::sockaddr_storage;\n         let size = mem::size_of::<libc::sockaddr_storage>();\n         let mut size = size as libc::socklen_t;"}, {"sha": "8b3f4debe5d18f1380c5df2dbeb2be813d8bdde0", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 43, "deletions": 40, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/51348b068b88d71426d9de93762575cd2bb9a5f5/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51348b068b88d71426d9de93762575cd2bb9a5f5/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=51348b068b88d71426d9de93762575cd2bb9a5f5", "patch": "@@ -10,16 +10,13 @@\n \n use libc::{pid_t, c_void, c_int};\n use libc;\n-use std::io;\n use std::mem;\n use std::os;\n use std::ptr;\n use std::rt::rtio;\n-use std::rt::rtio::ProcessConfig;\n+use std::rt::rtio::{ProcessConfig, IoResult, IoError};\n use std::c_str::CString;\n-use p = std::io::process;\n \n-use super::IoResult;\n use super::file;\n use super::util;\n \n@@ -48,7 +45,7 @@ pub struct Process {\n     handle: *(),\n \n     /// None until finish() is called.\n-    exit_code: Option<p::ProcessExit>,\n+    exit_code: Option<rtio::ProcessExit>,\n \n     /// Manually delivered signal\n     exit_signal: Option<int>,\n@@ -59,28 +56,29 @@ pub struct Process {\n \n #[cfg(unix)]\n enum Req {\n-    NewChild(libc::pid_t, Sender<p::ProcessExit>, u64),\n+    NewChild(libc::pid_t, Sender<rtio::ProcessExit>, u64),\n }\n \n impl Process {\n     /// Creates a new process using native process-spawning abilities provided\n     /// by the OS. Operations on this process will be blocking instead of using\n     /// the runtime for sleeping just this current task.\n     pub fn spawn(cfg: ProcessConfig)\n-        -> Result<(Process, Vec<Option<file::FileDesc>>), io::IoError>\n+        -> IoResult<(Process, Vec<Option<file::FileDesc>>)>\n     {\n         // right now we only handle stdin/stdout/stderr.\n         if cfg.extra_io.len() > 0 {\n             return Err(super::unimpl());\n         }\n \n-        fn get_io(io: p::StdioContainer, ret: &mut Vec<Option<file::FileDesc>>)\n+        fn get_io(io: rtio::StdioContainer,\n+                  ret: &mut Vec<Option<file::FileDesc>>)\n             -> (Option<os::Pipe>, c_int)\n         {\n             match io {\n-                p::Ignored => { ret.push(None); (None, -1) }\n-                p::InheritFd(fd) => { ret.push(None); (None, fd) }\n-                p::CreatePipe(readable, _writable) => {\n+                rtio::Ignored => { ret.push(None); (None, -1) }\n+                rtio::InheritFd(fd) => { ret.push(None); (None, fd) }\n+                rtio::CreatePipe(readable, _writable) => {\n                     let pipe = os::pipe();\n                     let (theirs, ours) = if readable {\n                         (pipe.input, pipe.out)\n@@ -133,7 +131,7 @@ impl rtio::RtioProcess for Process {\n         self.deadline = timeout.map(|i| i + ::io::timer::now()).unwrap_or(0);\n     }\n \n-    fn wait(&mut self) -> IoResult<p::ProcessExit> {\n+    fn wait(&mut self) -> IoResult<rtio::ProcessExit> {\n         match self.exit_code {\n             Some(code) => Ok(code),\n             None => {\n@@ -143,7 +141,7 @@ impl rtio::RtioProcess for Process {\n                 // consider it as having died via a signal.\n                 let code = match self.exit_signal {\n                     None => code,\n-                    Some(signal) if cfg!(windows) => p::ExitSignal(signal),\n+                    Some(signal) if cfg!(windows) => rtio::ExitSignal(signal),\n                     Some(..) => code,\n                 };\n                 self.exit_code = Some(code);\n@@ -152,7 +150,10 @@ impl rtio::RtioProcess for Process {\n         }\n     }\n \n-    fn kill(&mut self, signum: int) -> Result<(), io::IoError> {\n+    fn kill(&mut self, signum: int) -> IoResult<()> {\n+        #[cfg(unix)] use ERROR = libc::EINVAL;\n+        #[cfg(windows)] use ERROR = libc::ERROR_NOTHING_TO_TERMINATE;\n+\n         // On linux (and possibly other unices), a process that has exited will\n         // continue to accept signals because it is \"defunct\". The delivery of\n         // signals will only fail once the child has been reaped. For this\n@@ -169,10 +170,10 @@ impl rtio::RtioProcess for Process {\n         // and we kill it, then on unix we might ending up killing a\n         // newer process that happens to have the same (re-used) id\n         match self.exit_code {\n-            Some(..) => return Err(io::IoError {\n-                kind: io::OtherIoError,\n-                desc: \"can't kill an exited process\",\n-                detail: None,\n+            Some(..) => return Err(IoError {\n+                code: ERROR as uint,\n+                extra: 0,\n+                detail: Some(\"can't kill an exited process\".to_str()),\n             }),\n             None => {}\n         }\n@@ -194,7 +195,7 @@ impl Drop for Process {\n }\n \n #[cfg(windows)]\n-unsafe fn killpid(pid: pid_t, signal: int) -> Result<(), io::IoError> {\n+unsafe fn killpid(pid: pid_t, signal: int) -> IoResult<()> {\n     let handle = libc::OpenProcess(libc::PROCESS_TERMINATE |\n                                    libc::PROCESS_QUERY_INFORMATION,\n                                    libc::FALSE, pid as libc::DWORD);\n@@ -233,7 +234,7 @@ unsafe fn killpid(pid: pid_t, signal: int) -> Result<(), io::IoError> {\n }\n \n #[cfg(not(windows))]\n-unsafe fn killpid(pid: pid_t, signal: int) -> Result<(), io::IoError> {\n+unsafe fn killpid(pid: pid_t, signal: int) -> IoResult<()> {\n     let r = libc::funcs::posix88::signal::kill(pid, signal as c_int);\n     super::mkerr_libc(r)\n }\n@@ -521,12 +522,13 @@ fn spawn_process_os(cfg: ProcessConfig, in_fd: c_int, out_fd: c_int, err_fd: c_i\n                                     (bytes[1] << 16) as i32 |\n                                     (bytes[2] <<  8) as i32 |\n                                     (bytes[3] <<  0) as i32;\n-                        Err(io::IoError::from_errno(errno as uint, false))\n+                        Err(IoError {\n+                            code: errno as uint,\n+                            detail: None,\n+                            extra: 0,\n+                        })\n                     }\n-                    Err(e) => {\n-                        assert!(e.kind == io::BrokenPipe ||\n-                                e.kind == io::EndOfFile,\n-                                \"unexpected error: {}\", e);\n+                    Err(..) => {\n                         Ok(SpawnProcessResult {\n                             pid: pid,\n                             handle: ptr::null()\n@@ -757,7 +759,7 @@ fn free_handle(_handle: *()) {\n }\n \n #[cfg(unix)]\n-fn translate_status(status: c_int) -> p::ProcessExit {\n+fn translate_status(status: c_int) -> rtio::ProcessExit {\n     #![allow(non_snake_case_functions)]\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n@@ -776,9 +778,9 @@ fn translate_status(status: c_int) -> p::ProcessExit {\n     }\n \n     if imp::WIFEXITED(status) {\n-        p::ExitStatus(imp::WEXITSTATUS(status) as int)\n+        rtio::ExitStatus(imp::WEXITSTATUS(status) as int)\n     } else {\n-        p::ExitSignal(imp::WTERMSIG(status) as int)\n+        rtio::ExitSignal(imp::WTERMSIG(status) as int)\n     }\n }\n \n@@ -793,7 +795,7 @@ fn translate_status(status: c_int) -> p::ProcessExit {\n  * with the same id.\n  */\n #[cfg(windows)]\n-fn waitpid(pid: pid_t, deadline: u64) -> IoResult<p::ProcessExit> {\n+fn waitpid(pid: pid_t, deadline: u64) -> IoResult<rtio::ProcessExit> {\n     use libc::types::os::arch::extra::DWORD;\n     use libc::consts::os::extra::{\n         SYNCHRONIZE,\n@@ -828,7 +830,7 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<p::ProcessExit> {\n             }\n             if status != STILL_ACTIVE {\n                 assert!(CloseHandle(process) != 0);\n-                return Ok(p::ExitStatus(status as int));\n+                return Ok(rtio::ExitStatus(status as int));\n             }\n             let interval = if deadline == 0 {\n                 INFINITE\n@@ -853,7 +855,7 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<p::ProcessExit> {\n }\n \n #[cfg(unix)]\n-fn waitpid(pid: pid_t, deadline: u64) -> IoResult<p::ProcessExit> {\n+fn waitpid(pid: pid_t, deadline: u64) -> IoResult<rtio::ProcessExit> {\n     use std::cmp;\n     use std::comm;\n \n@@ -862,7 +864,7 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<p::ProcessExit> {\n     let mut status = 0 as c_int;\n     if deadline == 0 {\n         return match retry(|| unsafe { c::waitpid(pid, &mut status, 0) }) {\n-            -1 => fail!(\"unknown waitpid error: {}\", super::last_error()),\n+            -1 => fail!(\"unknown waitpid error: {}\", super::last_error().code),\n             _ => Ok(translate_status(status)),\n         }\n     }\n@@ -928,8 +930,8 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<p::ProcessExit> {\n         unsafe {\n             let mut pipes = [0, ..2];\n             assert_eq!(libc::pipe(pipes.as_mut_ptr()), 0);\n-            util::set_nonblocking(pipes[0], true).unwrap();\n-            util::set_nonblocking(pipes[1], true).unwrap();\n+            util::set_nonblocking(pipes[0], true).ok().unwrap();\n+            util::set_nonblocking(pipes[1], true).ok().unwrap();\n             WRITE_FD = pipes[1];\n \n             let mut old: c::sigaction = mem::zeroed();\n@@ -945,10 +947,10 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<p::ProcessExit> {\n     fn waitpid_helper(input: libc::c_int,\n                       messages: Receiver<Req>,\n                       (read_fd, old): (libc::c_int, c::sigaction)) {\n-        util::set_nonblocking(input, true).unwrap();\n+        util::set_nonblocking(input, true).ok().unwrap();\n         let mut set: c::fd_set = unsafe { mem::zeroed() };\n         let mut tv: libc::timeval;\n-        let mut active = Vec::<(libc::pid_t, Sender<p::ProcessExit>, u64)>::new();\n+        let mut active = Vec::<(libc::pid_t, Sender<rtio::ProcessExit>, u64)>::new();\n         let max = cmp::max(input, read_fd) + 1;\n \n         'outer: loop {\n@@ -1094,22 +1096,23 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<p::ProcessExit> {\n     }\n }\n \n-fn waitpid_nowait(pid: pid_t) -> Option<p::ProcessExit> {\n+fn waitpid_nowait(pid: pid_t) -> Option<rtio::ProcessExit> {\n     return waitpid_os(pid);\n \n     // This code path isn't necessary on windows\n     #[cfg(windows)]\n-    fn waitpid_os(_pid: pid_t) -> Option<p::ProcessExit> { None }\n+    fn waitpid_os(_pid: pid_t) -> Option<rtio::ProcessExit> { None }\n \n     #[cfg(unix)]\n-    fn waitpid_os(pid: pid_t) -> Option<p::ProcessExit> {\n+    fn waitpid_os(pid: pid_t) -> Option<rtio::ProcessExit> {\n         let mut status = 0 as c_int;\n         match retry(|| unsafe {\n             c::waitpid(pid, &mut status, c::WNOHANG)\n         }) {\n             n if n == pid => Some(translate_status(status)),\n             0 => None,\n-            n => fail!(\"unknown waitpid error `{}`: {}\", n, super::last_error()),\n+            n => fail!(\"unknown waitpid error `{}`: {}\", n,\n+                       super::last_error().code),\n         }\n     }\n }"}, {"sha": "11f9c4b3d8cb8cebe6ef32cdce12213125a0cbd8", "filename": "src/libnative/io/timer_unix.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/51348b068b88d71426d9de93762575cd2bb9a5f5/src%2Flibnative%2Fio%2Ftimer_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51348b068b88d71426d9de93762575cd2bb9a5f5/src%2Flibnative%2Fio%2Ftimer_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_unix.rs?ref=51348b068b88d71426d9de93762575cd2bb9a5f5", "patch": "@@ -51,10 +51,10 @@ use std::mem;\n use std::os;\n use std::ptr;\n use std::rt::rtio;\n+use std::rt::rtio::IoResult;\n use std::sync::atomics;\n use std::comm;\n \n-use io::IoResult;\n use io::c;\n use io::file::FileDesc;\n use io::helper_thread::Helper;\n@@ -67,7 +67,7 @@ pub struct Timer {\n }\n \n struct Inner {\n-    tx: Option<Sender<()>>,\n+    cb: Option<Box<rtio::Callback:Send>>,\n     interval: u64,\n     repeat: bool,\n     target: u64,\n@@ -119,13 +119,13 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n         let mut timer = match active.shift() {\n             Some(timer) => timer, None => return\n         };\n-        let tx = timer.tx.take_unwrap();\n-        if tx.send_opt(()).is_ok() && timer.repeat {\n-            timer.tx = Some(tx);\n+        let mut cb = timer.cb.take_unwrap();\n+        cb.call();\n+        if timer.repeat {\n+            timer.cb = Some(cb);\n             timer.target += timer.interval;\n             insert(timer, active);\n         } else {\n-            drop(tx);\n             dead.push((timer.id, timer));\n         }\n     }\n@@ -190,7 +190,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n \n                 // drain the file descriptor\n                 let mut buf = [0];\n-                assert_eq!(fd.inner_read(buf).unwrap(), 1);\n+                assert_eq!(fd.inner_read(buf).ok().unwrap(), 1);\n             }\n \n             -1 if os::errno() == libc::EINTR as int => {}\n@@ -209,7 +209,7 @@ impl Timer {\n         Ok(Timer {\n             id: id,\n             inner: Some(box Inner {\n-                tx: None,\n+                cb: None,\n                 interval: 0,\n                 target: 0,\n                 repeat: false,\n@@ -245,38 +245,34 @@ impl Timer {\n impl rtio::RtioTimer for Timer {\n     fn sleep(&mut self, msecs: u64) {\n         let mut inner = self.inner();\n-        inner.tx = None; // cancel any previous request\n+        inner.cb = None; // cancel any previous request\n         self.inner = Some(inner);\n \n         Timer::sleep(msecs);\n     }\n \n-    fn oneshot(&mut self, msecs: u64) -> Receiver<()> {\n+    fn oneshot(&mut self, msecs: u64, cb: Box<rtio::Callback:Send>) {\n         let now = now();\n         let mut inner = self.inner();\n \n-        let (tx, rx) = channel();\n         inner.repeat = false;\n-        inner.tx = Some(tx);\n+        inner.cb = Some(cb);\n         inner.interval = msecs;\n         inner.target = now + msecs;\n \n         unsafe { HELPER.send(NewTimer(inner)); }\n-        return rx;\n     }\n \n-    fn period(&mut self, msecs: u64) -> Receiver<()> {\n+    fn period(&mut self, msecs: u64, cb: Box<rtio::Callback:Send>) {\n         let now = now();\n         let mut inner = self.inner();\n \n-        let (tx, rx) = channel();\n         inner.repeat = true;\n-        inner.tx = Some(tx);\n+        inner.cb = Some(cb);\n         inner.interval = msecs;\n         inner.target = now + msecs;\n \n         unsafe { HELPER.send(NewTimer(inner)); }\n-        return rx;\n     }\n }\n "}, {"sha": "a3c5349fa4582a47be58176939d9a2304b2e499d", "filename": "src/libnative/io/util.rs", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/51348b068b88d71426d9de93762575cd2bb9a5f5/src%2Flibnative%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51348b068b88d71426d9de93762575cd2bb9a5f5/src%2Flibnative%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Futil.rs?ref=51348b068b88d71426d9de93762575cd2bb9a5f5", "patch": "@@ -9,11 +9,10 @@\n // except according to those terms.\n \n use libc;\n-use std::io::IoResult;\n-use std::io;\n use std::mem;\n use std::os;\n use std::ptr;\n+use std::rt::rtio::{IoResult, IoError};\n \n use super::c;\n use super::net;\n@@ -25,10 +24,30 @@ pub enum SocketStatus {\n     Writable,\n }\n \n-pub fn timeout(desc: &'static str) -> io::IoError {\n-    io::IoError {\n-        kind: io::TimedOut,\n-        desc: desc,\n+pub fn timeout(desc: &'static str) -> IoError {\n+    #[cfg(unix)] use ERROR = libc::ETIMEDOUT;\n+    #[cfg(windows)] use ERROR = libc::ERROR_OPERATION_ABORTED;\n+    IoError {\n+        code: ERROR as uint,\n+        extra: 0,\n+        detail: Some(desc.to_str()),\n+    }\n+}\n+\n+pub fn short_write(n: uint, desc: &'static str) -> IoError {\n+    #[cfg(unix)] use ERROR = libc::EAGAIN;\n+    #[cfg(windows)] use ERROR = libc::ERROR_OPERATION_ABORTED;\n+    IoError {\n+        code: ERROR as uint,\n+        extra: n,\n+        detail: Some(desc.to_str()),\n+    }\n+}\n+\n+pub fn eof() -> IoError {\n+    IoError {\n+        code: libc::EOF as uint,\n+        extra: 0,\n         detail: None,\n     }\n }\n@@ -100,7 +119,11 @@ pub fn connect_timeout(fd: net::sock_t,\n                     if err == 0 {\n                         Ok(())\n                     } else {\n-                        Err(io::IoError::from_errno(err as uint, true))\n+                        Err(IoError {\n+                            code: err as uint,\n+                            extra: 0,\n+                            detail: Some(os::error_string(err as uint)),\n+                        })\n                     }\n                 }\n             }"}, {"sha": "f16c41d4e28f7c1806cda0089d22b7b57447e7ee", "filename": "src/libnative/task.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/51348b068b88d71426d9de93762575cd2bb9a5f5/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51348b068b88d71426d9de93762575cd2bb9a5f5/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=51348b068b88d71426d9de93762575cd2bb9a5f5", "patch": "@@ -17,15 +17,13 @@\n use std::any::Any;\n use std::mem;\n use std::rt::bookkeeping;\n-use std::rt::env;\n use std::rt::local::Local;\n+use std::rt::mutex::NativeMutex;\n use std::rt::rtio;\n use std::rt::stack;\n-use std::rt::task::{Task, BlockedTask, SendMessage};\n+use std::rt::task::{Task, BlockedTask, TaskOpts};\n use std::rt::thread::Thread;\n use std::rt;\n-use std::task::TaskOpts;\n-use std::unstable::mutex::NativeMutex;\n \n use io;\n use task;\n@@ -51,27 +49,19 @@ fn ops() -> Box<Ops> {\n \n /// Spawns a function with the default configuration\n pub fn spawn(f: proc():Send) {\n-    spawn_opts(TaskOpts::new(), f)\n+    spawn_opts(TaskOpts { name: None, stack_size: None, on_exit: None }, f)\n }\n \n /// Spawns a new task given the configuration options and a procedure to run\n /// inside the task.\n pub fn spawn_opts(opts: TaskOpts, f: proc():Send) {\n-    let TaskOpts {\n-        notify_chan, name, stack_size,\n-        stderr, stdout,\n-    } = opts;\n+    let TaskOpts { name, stack_size, on_exit } = opts;\n \n     let mut task = box Task::new();\n     task.name = name;\n-    task.stderr = stderr;\n-    task.stdout = stdout;\n-    match notify_chan {\n-        Some(chan) => { task.death.on_exit = Some(SendMessage(chan)); }\n-        None => {}\n-    }\n+    task.death.on_exit = on_exit;\n \n-    let stack = stack_size.unwrap_or(env::min_stack());\n+    let stack = stack_size.unwrap_or(rt::min_stack());\n     let task = task;\n     let ops = ops();\n \n@@ -267,9 +257,8 @@ impl rt::Runtime for Ops {\n #[cfg(test)]\n mod tests {\n     use std::rt::local::Local;\n-    use std::rt::task::Task;\n+    use std::rt::task::{Task, TaskOpts};\n     use std::task;\n-    use std::task::TaskOpts;\n     use super::{spawn, spawn_opts, Ops};\n \n     #[test]\n@@ -297,7 +286,7 @@ mod tests {\n         opts.name = Some(\"test\".into_maybe_owned());\n         opts.stack_size = Some(20 * 4096);\n         let (tx, rx) = channel();\n-        opts.notify_chan = Some(tx);\n+        opts.on_exit = Some(proc(r) tx.send(r));\n         spawn_opts(opts, proc() {});\n         assert!(rx.recv().is_ok());\n     }\n@@ -306,7 +295,7 @@ mod tests {\n     fn smoke_opts_fail() {\n         let mut opts = TaskOpts::new();\n         let (tx, rx) = channel();\n-        opts.notify_chan = Some(tx);\n+        opts.on_exit = Some(proc(r) tx.send(r));\n         spawn_opts(opts, proc() { fail!() });\n         assert!(rx.recv().is_err());\n     }"}]}