{"sha": "f74ec6b1b858c13449dc4cfd9231a3a0d82e50df", "node_id": "C_kwDOAAsO6NoAKGY3NGVjNmIxYjg1OGMxMzQ0OWRjNGNmZDkyMzFhM2EwZDgyZTUwZGY", "commit": {"author": {"name": "y21", "email": "30553356+y21@users.noreply.github.com", "date": "2023-04-09T02:56:03Z"}, "committer": {"name": "y21", "email": "30553356+y21@users.noreply.github.com", "date": "2023-05-31T21:52:02Z"}, "message": "new lint: `missing_field_in_debug`\n\nmove some strings into consts, more tests\n\ns/missing_field_in_debug/missing_fields_in_debug\n\ndont trigger in macro expansions\n\nmake dogfood tests happy\n\nminor cleanups\n\nreplace HashSet with FxHashSet\n\nreplace match_def_path with match_type\n\nif_chain -> let chains, fix markdown, allow newtype pattern\n\nfmt\n\nconsider string literal in `.field()` calls as used\n\ndon't intern defined symbol, remove mentions of 'debug_tuple'\n\nspecial-case PD, account for field access through `Deref`", "tree": {"sha": "a97384799662f8207c6e4d666e7f93ce7406e2ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a97384799662f8207c6e4d666e7f93ce7406e2ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f74ec6b1b858c13449dc4cfd9231a3a0d82e50df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f74ec6b1b858c13449dc4cfd9231a3a0d82e50df", "html_url": "https://github.com/rust-lang/rust/commit/f74ec6b1b858c13449dc4cfd9231a3a0d82e50df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f74ec6b1b858c13449dc4cfd9231a3a0d82e50df/comments", "author": {"login": "y21", "id": 30553356, "node_id": "MDQ6VXNlcjMwNTUzMzU2", "avatar_url": "https://avatars.githubusercontent.com/u/30553356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/y21", "html_url": "https://github.com/y21", "followers_url": "https://api.github.com/users/y21/followers", "following_url": "https://api.github.com/users/y21/following{/other_user}", "gists_url": "https://api.github.com/users/y21/gists{/gist_id}", "starred_url": "https://api.github.com/users/y21/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/y21/subscriptions", "organizations_url": "https://api.github.com/users/y21/orgs", "repos_url": "https://api.github.com/users/y21/repos", "events_url": "https://api.github.com/users/y21/events{/privacy}", "received_events_url": "https://api.github.com/users/y21/received_events", "type": "User", "site_admin": false}, "committer": {"login": "y21", "id": 30553356, "node_id": "MDQ6VXNlcjMwNTUzMzU2", "avatar_url": "https://avatars.githubusercontent.com/u/30553356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/y21", "html_url": "https://github.com/y21", "followers_url": "https://api.github.com/users/y21/followers", "following_url": "https://api.github.com/users/y21/following{/other_user}", "gists_url": "https://api.github.com/users/y21/gists{/gist_id}", "starred_url": "https://api.github.com/users/y21/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/y21/subscriptions", "organizations_url": "https://api.github.com/users/y21/orgs", "repos_url": "https://api.github.com/users/y21/repos", "events_url": "https://api.github.com/users/y21/events{/privacy}", "received_events_url": "https://api.github.com/users/y21/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "594a2cba93d8c78f522bdb15de6aeebeebf50a8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/594a2cba93d8c78f522bdb15de6aeebeebf50a8a", "html_url": "https://github.com/rust-lang/rust/commit/594a2cba93d8c78f522bdb15de6aeebeebf50a8a"}], "stats": {"total": 749, "additions": 749, "deletions": 0}, "files": [{"sha": "8b609b47d8192424898cdd006a6b138a7e11081b", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f74ec6b1b858c13449dc4cfd9231a3a0d82e50df/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/f74ec6b1b858c13449dc4cfd9231a3a0d82e50df/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=f74ec6b1b858c13449dc4cfd9231a3a0d82e50df", "patch": "@@ -4963,6 +4963,7 @@ Released 2018-09-13\n [`missing_docs_in_private_items`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_docs_in_private_items\n [`missing_enforced_import_renames`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_enforced_import_renames\n [`missing_errors_doc`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_errors_doc\n+[`missing_fields_in_debug`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_fields_in_debug\n [`missing_inline_in_public_items`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_inline_in_public_items\n [`missing_panics_doc`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_panics_doc\n [`missing_safety_doc`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_safety_doc"}, {"sha": "a7067d8b86aafb1a651affab9d40e552b2703903", "filename": "clippy_lints/src/declared_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f74ec6b1b858c13449dc4cfd9231a3a0d82e50df/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74ec6b1b858c13449dc4cfd9231a3a0d82e50df/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdeclared_lints.rs?ref=f74ec6b1b858c13449dc4cfd9231a3a0d82e50df", "patch": "@@ -430,6 +430,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::missing_const_for_fn::MISSING_CONST_FOR_FN_INFO,\n     crate::missing_doc::MISSING_DOCS_IN_PRIVATE_ITEMS_INFO,\n     crate::missing_enforced_import_rename::MISSING_ENFORCED_IMPORT_RENAMES_INFO,\n+    crate::missing_fields_in_debug::MISSING_FIELDS_IN_DEBUG_INFO,\n     crate::missing_inline::MISSING_INLINE_IN_PUBLIC_ITEMS_INFO,\n     crate::missing_trait_methods::MISSING_TRAIT_METHODS_INFO,\n     crate::mixed_read_write_in_expression::DIVERGING_SUB_EXPRESSION_INFO,"}, {"sha": "a0a89e4967b8fd16784b0c9e908c2da14ca80592", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f74ec6b1b858c13449dc4cfd9231a3a0d82e50df/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74ec6b1b858c13449dc4cfd9231a3a0d82e50df/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=f74ec6b1b858c13449dc4cfd9231a3a0d82e50df", "patch": "@@ -203,6 +203,7 @@ mod missing_assert_message;\n mod missing_const_for_fn;\n mod missing_doc;\n mod missing_enforced_import_rename;\n+mod missing_fields_in_debug;\n mod missing_inline;\n mod missing_trait_methods;\n mod mixed_read_write_in_expression;\n@@ -994,6 +995,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| Box::new(ref_patterns::RefPatterns));\n     store.register_late_pass(|_| Box::new(default_constructed_unit_structs::DefaultConstructedUnitStructs));\n     store.register_early_pass(|| Box::new(needless_else::NeedlessElse));\n+    store.register_late_pass(|_| Box::new(missing_fields_in_debug::MissingFieldsInDebug));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "389a8d04dc2892959e7ca40d44919a66e13f97f4", "filename": "clippy_lints/src/missing_fields_in_debug.rs", "status": "added", "additions": 311, "deletions": 0, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/f74ec6b1b858c13449dc4cfd9231a3a0d82e50df/clippy_lints%2Fsrc%2Fmissing_fields_in_debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74ec6b1b858c13449dc4cfd9231a3a0d82e50df/clippy_lints%2Fsrc%2Fmissing_fields_in_debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_fields_in_debug.rs?ref=f74ec6b1b858c13449dc4cfd9231a3a0d82e50df", "patch": "@@ -0,0 +1,311 @@\n+use std::ops::ControlFlow;\n+\n+use clippy_utils::{\n+    diagnostics::span_lint_and_then,\n+    paths,\n+    ty::match_type,\n+    visitors::{for_each_expr, Visitable},\n+};\n+use rustc_ast::LitKind;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir::{\n+    def::{DefKind, Res},\n+    Expr, ImplItemKind, MatchSource, Node,\n+};\n+use rustc_hir::{Block, PatKind};\n+use rustc_hir::{ExprKind, Impl, ItemKind, QPath, TyKind};\n+use rustc_hir::{ImplItem, Item, VariantData};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::TypeckResults;\n+use rustc_middle::ty::{EarlyBinder, Ty};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{sym, Span, Symbol};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for manual [`core::fmt::Debug`](https://doc.rust-lang.org/core/fmt/trait.Debug.html) implementations that do not use all fields.\n+    ///\n+    /// ### Why is this bad?\n+    /// A common mistake is to forget to update manual `Debug` implementations when adding a new field\n+    /// to a struct or a new variant to an enum.\n+    ///\n+    /// At the same time, it also acts as a style lint to suggest using [`core::fmt::DebugStruct::finish_non_exhaustive`](https://doc.rust-lang.org/core/fmt/struct.DebugStruct.html#method.finish_non_exhaustive)\n+    /// for the times when the user intentionally wants to leave out certain fields (e.g. to hide implementation details).\n+    ///\n+    /// ### Known problems\n+    /// This lint works based on the `DebugStruct` helper types provided by the `Formatter`,\n+    /// so this won't detect `Debug` impls that use the `write!` macro.\n+    /// Oftentimes there is more logic to a `Debug` impl if it uses `write!` macro, so it tries\n+    /// to be on the conservative side and not lint in those cases in an attempt to prevent false positives.\n+    ///\n+    /// This lint also does not look through function calls, so calling `.field(self.as_slice())` for example\n+    /// does not consider fields used inside of `as_slice()` as used by the `Debug` impl.\n+    ///\n+    /// Lastly, it also ignores tuple structs as their `DebugTuple` formatter does not have a `finish_non_exhaustive`\n+    /// method.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// use std::fmt;\n+    /// struct Foo {\n+    ///     data: String,\n+    ///     // implementation detail\n+    ///     hidden_data: i32\n+    /// }\n+    /// impl fmt::Debug for Foo {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         formatter\n+    ///             .debug_struct(\"Foo\")\n+    ///             .field(\"data\", &self.data)\n+    ///             .finish()\n+    ///     }\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::fmt;\n+    /// struct Foo {\n+    ///     data: String,\n+    ///     // implementation detail\n+    ///     hidden_data: i32\n+    /// }\n+    /// impl fmt::Debug for Foo {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         formatter\n+    ///             .debug_struct(\"Foo\")\n+    ///             .field(\"data\", &self.data)\n+    ///             .finish_non_exhaustive()\n+    ///     }\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.70.0\"]\n+    pub MISSING_FIELDS_IN_DEBUG,\n+    pedantic,\n+    \"missing fields in manual `Debug` implementation\"\n+}\n+declare_lint_pass!(MissingFieldsInDebug => [MISSING_FIELDS_IN_DEBUG]);\n+\n+fn report_lints(cx: &LateContext<'_>, span: Span, span_notes: Vec<(Span, &'static str)>) {\n+    span_lint_and_then(\n+        cx,\n+        MISSING_FIELDS_IN_DEBUG,\n+        span,\n+        \"manual `Debug` impl does not include all fields\",\n+        |diag| {\n+            for (span, note) in span_notes {\n+                diag.span_note(span, note);\n+            }\n+            diag.help(\"consider including all fields in this `Debug` impl\")\n+                .help(\"consider calling `.finish_non_exhaustive()` if you intend to ignore fields\");\n+        },\n+    );\n+}\n+\n+/// Checks if we should lint in a block of code\n+///\n+/// The way we check for this condition is by checking if there is\n+/// a call to `Formatter::debug_struct` but no call to `.finish_non_exhaustive()`.\n+fn should_lint<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    typeck_results: &TypeckResults<'tcx>,\n+    block: impl Visitable<'tcx>,\n+) -> bool {\n+    // Is there a call to `DebugStruct::finish_non_exhaustive`? Don't lint if there is.\n+    let mut has_finish_non_exhaustive = false;\n+    // Is there a call to `DebugStruct::debug_struct`? Do lint if there is.\n+    let mut has_debug_struct = false;\n+\n+    for_each_expr(block, |expr| {\n+        if let ExprKind::MethodCall(path, recv, ..) = &expr.kind {\n+            let recv_ty = typeck_results.expr_ty(recv).peel_refs();\n+\n+            if path.ident.name == sym::debug_struct && match_type(cx, recv_ty, &paths::FORMATTER) {\n+                has_debug_struct = true;\n+            } else if path.ident.name == sym!(finish_non_exhaustive) && match_type(cx, recv_ty, &paths::DEBUG_STRUCT) {\n+                has_finish_non_exhaustive = true;\n+            }\n+        }\n+        ControlFlow::<!, _>::Continue(())\n+    });\n+\n+    !has_finish_non_exhaustive && has_debug_struct\n+}\n+\n+/// Checks if the given expression is a call to `DebugStruct::field`\n+/// and the first argument to it is a string literal and if so, returns it\n+///\n+/// Example: `.field(\"foo\", ....)` returns `Some(\"foo\")`\n+fn as_field_call<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    typeck_results: &TypeckResults<'tcx>,\n+    expr: &Expr<'_>,\n+) -> Option<Symbol> {\n+    if let ExprKind::MethodCall(path, recv, [debug_field, _], _) = &expr.kind\n+        && let recv_ty = typeck_results.expr_ty(recv).peel_refs()\n+        && match_type(cx, recv_ty, &paths::DEBUG_STRUCT)\n+        && path.ident.name == sym::field\n+        && let ExprKind::Lit(lit) = &debug_field.kind\n+        && let LitKind::Str(sym, ..) = lit.node\n+    {\n+        Some(sym)\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Attempts to find unused fields assuming that the item is a struct\n+fn check_struct<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    typeck_results: &TypeckResults<'tcx>,\n+    block: &'tcx Block<'tcx>,\n+    self_ty: Ty<'tcx>,\n+    item: &'tcx Item<'tcx>,\n+    data: &VariantData<'_>,\n+) {\n+    // Is there a \"direct\" field access anywhere (i.e. self.foo)?\n+    // We don't want to lint if there is not, because the user might have\n+    // a newtype struct and use fields from the wrapped type only.\n+    let mut has_direct_field_access = false;\n+    let mut field_accesses = FxHashSet::default();\n+\n+    for_each_expr(block, |expr| {\n+        if let ExprKind::Field(target, ident) = expr.kind\n+            && let target_ty = typeck_results.expr_ty_adjusted(target).peel_refs()\n+            && target_ty == self_ty\n+        {\n+            field_accesses.insert(ident.name);\n+            has_direct_field_access = true;\n+        } else if let Some(sym) = as_field_call(cx, typeck_results, expr) {\n+            field_accesses.insert(sym);\n+        }\n+        ControlFlow::<!, _>::Continue(())\n+    });\n+\n+    let span_notes = data\n+        .fields()\n+        .iter()\n+        .filter_map(|field| {\n+            let EarlyBinder(field_ty) = cx.tcx.type_of(field.def_id);\n+            if field_accesses.contains(&field.ident.name) || field_ty.is_phantom_data() {\n+                None\n+            } else {\n+                Some((field.span, \"this field is unused\"))\n+            }\n+        })\n+        .collect::<Vec<_>>();\n+\n+    // only lint if there's also at least one direct field access to allow patterns\n+    // where one might have a newtype struct and uses fields from the wrapped type\n+    if !span_notes.is_empty() && has_direct_field_access {\n+        report_lints(cx, item.span, span_notes);\n+    }\n+}\n+\n+/// Attempts to find unused fields in variants assuming that\n+/// the item is an enum.\n+///\n+/// Currently, only simple cases are detected where the user\n+/// matches on `self` and calls `debug_struct` inside of the arms\n+fn check_enum<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    typeck_results: &TypeckResults<'tcx>,\n+    block: &'tcx Block<'tcx>,\n+    self_ty: Ty<'tcx>,\n+    item: &'tcx Item<'tcx>,\n+) {\n+    let Some(arms) = for_each_expr(block, |expr| {\n+        if let ExprKind::Match(val, arms, MatchSource::Normal) = expr.kind\n+            && let match_ty = typeck_results.expr_ty_adjusted(val).peel_refs()\n+            && match_ty == self_ty\n+        {\n+            ControlFlow::Break(arms)\n+        } else {\n+            ControlFlow::Continue(())\n+        }\n+    }) else {\n+        return;\n+    };\n+\n+    let mut span_notes = Vec::new();\n+\n+    for arm in arms {\n+        if !should_lint(cx, typeck_results, arm.body) {\n+            continue;\n+        }\n+\n+        arm.pat.walk_always(|pat| match pat.kind {\n+            PatKind::Wild => span_notes.push((pat.span, \"unused field here due to wildcard `_`\")),\n+            PatKind::Tuple(_, rest) | PatKind::TupleStruct(.., rest) if rest.as_opt_usize().is_some() => {\n+                span_notes.push((pat.span, \"more unused fields here due to rest pattern `..`\"));\n+            },\n+            PatKind::Struct(.., true) => {\n+                span_notes.push((pat.span, \"more unused fields here due to rest pattern `..`\"));\n+            },\n+            _ => {},\n+        });\n+\n+        let mut field_accesses = FxHashSet::default();\n+        let mut check_field_access = |sym, expr| {\n+            if !typeck_results.expr_ty(expr).is_phantom_data() {\n+                arm.pat.each_binding(|_, _, _, pat_ident| {\n+                    if sym == pat_ident.name {\n+                        field_accesses.insert(pat_ident);\n+                    }\n+                });\n+            }\n+        };\n+\n+        for_each_expr(arm.body, |expr| {\n+            if let ExprKind::Path(QPath::Resolved(_, path)) = expr.kind && let Some(segment) = path.segments.first()\n+            {\n+                check_field_access(segment.ident.name, expr);\n+            } else if let Some(sym) = as_field_call(cx, typeck_results, expr) {\n+                check_field_access(sym, expr);\n+            }\n+            ControlFlow::<!, _>::Continue(())\n+        });\n+\n+        arm.pat.each_binding(|_, _, span, pat_ident| {\n+            if !field_accesses.contains(&pat_ident) {\n+                span_notes.push((span, \"the field referenced by this binding is unused\"));\n+            }\n+        });\n+    }\n+\n+    if !span_notes.is_empty() {\n+        report_lints(cx, item.span, span_notes);\n+    }\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for MissingFieldsInDebug {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx rustc_hir::Item<'tcx>) {\n+        // is this an `impl Debug for X` block?\n+        if let ItemKind::Impl(Impl { of_trait: Some(trait_ref), self_ty, items, .. }) = item.kind\n+            && let Res::Def(DefKind::Trait, trait_def_id) = trait_ref.path.res\n+            && let TyKind::Path(QPath::Resolved(_, self_path)) = &self_ty.kind\n+            && cx.match_def_path(trait_def_id, &[sym::core, sym::fmt, sym::Debug])\n+            // don't trigger if this impl was derived\n+            && !cx.tcx.has_attr(item.owner_id, sym::automatically_derived)\n+            && !item.span.from_expansion()\n+            // find `Debug::fmt` function\n+            && let Some(fmt_item) = items.iter().find(|i| i.ident.name == sym::fmt)\n+            && let ImplItem { kind: ImplItemKind::Fn(_, body_id), .. } = cx.tcx.hir().impl_item(fmt_item.id)\n+            && let body = cx.tcx.hir().body(*body_id)\n+            && let ExprKind::Block(block, _) = body.value.kind\n+            // inspect `self`\n+            && let self_ty = cx.tcx.type_of(self_path.res.def_id()).0.peel_refs()\n+            && let Some(self_adt) = self_ty.ty_adt_def()\n+            && let Some(self_def_id) = self_adt.did().as_local()\n+            && let Some(Node::Item(self_item)) = cx.tcx.hir().find_by_def_id(self_def_id)\n+            // NB: can't call cx.typeck_results() as we are not in a body\n+            && let typeck_results = cx.tcx.typeck_body(*body_id)\n+            && should_lint(cx, typeck_results, block)\n+        {\n+            match &self_item.kind {\n+                ItemKind::Struct(data, _) => check_struct(cx, typeck_results, block, self_ty, item, data),\n+                ItemKind::Enum(..) => check_enum(cx, typeck_results, block, self_ty, item),\n+                _ => {}\n+            }\n+        }\n+    }\n+}"}, {"sha": "3a2b0a72a3de0f3981985ee4c2ca02c04eae7d62", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f74ec6b1b858c13449dc4cfd9231a3a0d82e50df/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74ec6b1b858c13449dc4cfd9231a3a0d82e50df/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=f74ec6b1b858c13449dc4cfd9231a3a0d82e50df", "patch": "@@ -163,3 +163,5 @@ pub const VEC_IS_EMPTY: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"is_empty\"];\n pub const VEC_POP: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"pop\"];\n pub const OPTION_UNWRAP: [&str; 4] = [\"core\", \"option\", \"Option\", \"unwrap\"];\n pub const OPTION_EXPECT: [&str; 4] = [\"core\", \"option\", \"Option\", \"expect\"];\n+pub const FORMATTER: [&str; 3] = [\"core\", \"fmt\", \"Formatter\"];\n+pub const DEBUG_STRUCT: [&str; 4] = [\"core\", \"fmt\", \"builders\", \"DebugStruct\"];"}, {"sha": "72b9e0e2aae5ac0d81164e10038638372ea44b76", "filename": "tests/ui/missing_fields_in_debug.rs", "status": "added", "additions": 319, "deletions": 0, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/f74ec6b1b858c13449dc4cfd9231a3a0d82e50df/tests%2Fui%2Fmissing_fields_in_debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74ec6b1b858c13449dc4cfd9231a3a0d82e50df/tests%2Fui%2Fmissing_fields_in_debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_fields_in_debug.rs?ref=f74ec6b1b858c13449dc4cfd9231a3a0d82e50df", "patch": "@@ -0,0 +1,319 @@\n+#![allow(unused)]\n+#![warn(clippy::missing_fields_in_debug)]\n+\n+use std::fmt;\n+use std::marker::PhantomData;\n+use std::ops::Deref;\n+\n+struct NamedStruct1Ignored {\n+    data: u8,\n+    hidden: u32,\n+}\n+\n+impl fmt::Debug for NamedStruct1Ignored {\n+    // unused field: hidden\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        formatter\n+            .debug_struct(\"NamedStruct1Ignored\")\n+            .field(\"data\", &self.data)\n+            .finish()\n+    }\n+}\n+\n+struct NamedStructMultipleIgnored {\n+    data: u8,\n+    hidden: u32,\n+    hidden2: String,\n+    hidden3: Vec<Vec<i32>>,\n+    hidden4: ((((u8), u16), u32), u64),\n+}\n+\n+impl fmt::Debug for NamedStructMultipleIgnored {\n+    // unused fields: hidden, hidden2, hidden4\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        formatter\n+            .debug_struct(\"NamedStructMultipleIgnored\")\n+            .field(\"data\", &self.data)\n+            .field(\"hidden3\", &self.hidden3)\n+            .finish()\n+    }\n+}\n+\n+struct Unit;\n+\n+// ok\n+impl fmt::Debug for Unit {\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        formatter.debug_struct(\"Unit\").finish()\n+    }\n+}\n+\n+struct UnnamedStruct1Ignored(String);\n+\n+impl fmt::Debug for UnnamedStruct1Ignored {\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        formatter.debug_tuple(\"UnnamedStruct1Ignored\").finish()\n+    }\n+}\n+\n+struct UnnamedStructMultipleIgnored(String, Vec<u8>, i32);\n+\n+// tuple structs are not linted\n+impl fmt::Debug for UnnamedStructMultipleIgnored {\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        formatter\n+            .debug_tuple(\"UnnamedStructMultipleIgnored\")\n+            .field(&self.1)\n+            .finish()\n+    }\n+}\n+\n+struct NamedStructNonExhaustive {\n+    a: u8,\n+    b: String,\n+}\n+\n+// ok\n+impl fmt::Debug for NamedStructNonExhaustive {\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        formatter\n+            .debug_struct(\"NamedStructNonExhaustive\")\n+            .field(\"a\", &self.a)\n+            .finish_non_exhaustive() // should not warn here\n+    }\n+}\n+\n+struct MultiExprDebugImpl {\n+    a: u8,\n+    b: String,\n+}\n+\n+// ok\n+impl fmt::Debug for MultiExprDebugImpl {\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut f = formatter.debug_struct(\"MultiExprDebugImpl\");\n+        f.field(\"a\", &self.a);\n+        f.finish()\n+    }\n+}\n+\n+enum SingleVariantEnumUnnamed {\n+    A(u8),\n+}\n+\n+// ok\n+impl fmt::Debug for SingleVariantEnumUnnamed {\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Self::A(n) => formatter.debug_tuple(\"A\").field(&n).finish(),\n+        }\n+    }\n+}\n+\n+enum MultiVariantEnum {\n+    A(u8),\n+    B { a: u8, b: String },\n+    C,\n+}\n+\n+impl fmt::Debug for MultiVariantEnum {\n+    // match arm Self::B ignores `b`\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Self::A(n) => formatter.debug_tuple(\"A\").field(&n).finish(),\n+            Self::B { a, b } => formatter.debug_struct(\"B\").field(\"a\", &a).finish(),\n+            Self::C => formatter.debug_struct(\"C\").finish(),\n+        }\n+    }\n+}\n+\n+enum MultiVariantEnumOk {\n+    A(u8),\n+    B { a: u8, b: String },\n+    C,\n+}\n+\n+// ok\n+impl fmt::Debug for MultiVariantEnumOk {\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Self::A(n) => formatter.debug_tuple(\"A\").field(&n).finish(),\n+            Self::B { a, b } => formatter.debug_struct(\"B\").field(\"a\", &a).field(\"b\", &b).finish(),\n+            Self::C => formatter.debug_struct(\"C\").finish(),\n+        }\n+    }\n+}\n+\n+enum MultiVariantEnumNonExhaustive {\n+    A(u8),\n+    B { a: u8, b: String },\n+    C,\n+}\n+\n+// ok\n+impl fmt::Debug for MultiVariantEnumNonExhaustive {\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Self::A(n) => formatter.debug_tuple(\"A\").field(&n).finish(),\n+            Self::B { a, b } => formatter.debug_struct(\"B\").field(\"b\", &b).finish_non_exhaustive(),\n+            Self::C => formatter.debug_struct(\"C\").finish(),\n+        }\n+    }\n+}\n+\n+enum MultiVariantRest {\n+    A(u8),\n+    B { a: u8, b: String },\n+    C,\n+}\n+\n+impl fmt::Debug for MultiVariantRest {\n+    // `a` field ignored due to rest pattern\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Self::A(n) => formatter.debug_tuple(\"A\").field(&n).finish(),\n+            Self::B { b, .. } => formatter.debug_struct(\"B\").field(\"b\", &b).finish(),\n+            Self::C => formatter.debug_struct(\"C\").finish(),\n+        }\n+    }\n+}\n+\n+enum MultiVariantRestNonExhaustive {\n+    A(u8),\n+    B { a: u8, b: String },\n+    C,\n+}\n+\n+// ok\n+impl fmt::Debug for MultiVariantRestNonExhaustive {\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Self::A(n) => formatter.debug_tuple(\"A\").field(&n).finish(),\n+            Self::B { b, .. } => formatter.debug_struct(\"B\").field(\"b\", &b).finish_non_exhaustive(),\n+            Self::C => formatter.debug_struct(\"C\").finish(),\n+        }\n+    }\n+}\n+\n+enum Wildcard {\n+    A(u8),\n+    B(String),\n+}\n+\n+// ok\n+impl fmt::Debug for Wildcard {\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Self::A(n) => formatter.debug_tuple(\"A\").field(&n).finish(),\n+            _ => todo!(),\n+        }\n+    }\n+}\n+\n+enum Empty {}\n+\n+// ok\n+impl fmt::Debug for Empty {\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {}\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct DerivedStruct {\n+    a: u8,\n+    b: i32,\n+}\n+\n+#[derive(Debug)]\n+enum DerivedEnum {\n+    A(i32),\n+    B { a: String },\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/pull/10616#discussion_r1166846953\n+\n+struct Inner {\n+    a: usize,\n+    b: usize,\n+}\n+\n+struct HasInner {\n+    inner: Inner,\n+}\n+\n+impl HasInner {\n+    fn get(&self) -> &Inner {\n+        &self.inner\n+    }\n+}\n+\n+impl fmt::Debug for HasInner {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let inner = self.get();\n+\n+        f.debug_struct(\"HasInner\")\n+            .field(\"a\", &inner.a)\n+            .field(\"b\", &inner.b)\n+            .finish()\n+    }\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/pull/10616#discussion_r1170306053\n+struct Foo {\n+    a: u8,\n+    b: u8,\n+}\n+\n+impl fmt::Debug for Foo {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Foo\").field(\"a\", &self.a).field(\"b\", &()).finish()\n+    }\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/pull/10616#discussion_r1175473620\n+mod comment1175473620 {\n+    use super::*;\n+\n+    struct Inner {\n+        a: usize,\n+        b: usize,\n+    }\n+    struct Wrapper(Inner);\n+\n+    impl Deref for Wrapper {\n+        type Target = Inner;\n+\n+        fn deref(&self) -> &Self::Target {\n+            &self.0\n+        }\n+    }\n+\n+    impl fmt::Debug for Wrapper {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.debug_struct(\"Wrapper\")\n+                .field(\"a\", &self.a)\n+                .field(\"b\", &self.b)\n+                .finish()\n+        }\n+    }\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/pull/10616#discussion_r1175488757\n+// PhantomData is an exception and does not need to be included\n+struct WithPD {\n+    a: u8,\n+    b: u8,\n+    c: PhantomData<String>,\n+}\n+\n+impl fmt::Debug for WithPD {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"WithPD\")\n+            .field(\"a\", &self.a)\n+            .field(\"b\", &self.b)\n+            .finish()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "1dc7c0d65e5d2010773a14fba467aa774190be59", "filename": "tests/ui/missing_fields_in_debug.stderr", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/f74ec6b1b858c13449dc4cfd9231a3a0d82e50df/tests%2Fui%2Fmissing_fields_in_debug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f74ec6b1b858c13449dc4cfd9231a3a0d82e50df/tests%2Fui%2Fmissing_fields_in_debug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_fields_in_debug.stderr?ref=f74ec6b1b858c13449dc4cfd9231a3a0d82e50df", "patch": "@@ -0,0 +1,113 @@\n+error: manual `Debug` impl does not include all fields\n+  --> $DIR/missing_fields_in_debug.rs:13:1\n+   |\n+LL | / impl fmt::Debug for NamedStruct1Ignored {\n+LL | |     // unused field: hidden\n+LL | |     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+LL | |         formatter\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+note: this field is unused\n+  --> $DIR/missing_fields_in_debug.rs:10:5\n+   |\n+LL |     hidden: u32,\n+   |     ^^^^^^^^^^^\n+   = help: consider including all fields in this `Debug` impl\n+   = help: consider calling `.finish_non_exhaustive()` if you intend to ignore fields\n+   = note: `-D clippy::missing-fields-in-debug` implied by `-D warnings`\n+\n+error: manual `Debug` impl does not include all fields\n+  --> $DIR/missing_fields_in_debug.rs:31:1\n+   |\n+LL | / impl fmt::Debug for NamedStructMultipleIgnored {\n+LL | |     // unused fields: hidden, hidden2, hidden4\n+LL | |     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+LL | |         formatter\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+note: this field is unused\n+  --> $DIR/missing_fields_in_debug.rs:25:5\n+   |\n+LL |     hidden: u32,\n+   |     ^^^^^^^^^^^\n+note: this field is unused\n+  --> $DIR/missing_fields_in_debug.rs:26:5\n+   |\n+LL |     hidden2: String,\n+   |     ^^^^^^^^^^^^^^^\n+note: this field is unused\n+  --> $DIR/missing_fields_in_debug.rs:28:5\n+   |\n+LL |     hidden4: ((((u8), u16), u32), u64),\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: consider including all fields in this `Debug` impl\n+   = help: consider calling `.finish_non_exhaustive()` if you intend to ignore fields\n+\n+error: manual `Debug` impl does not include all fields\n+  --> $DIR/missing_fields_in_debug.rs:92:1\n+   |\n+LL | / impl fmt::Debug for MultiExprDebugImpl {\n+LL | |     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+LL | |         let mut f = formatter.debug_struct(\"MultiExprDebugImpl\");\n+LL | |         f.field(\"a\", &self.a);\n+LL | |         f.finish()\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+note: this field is unused\n+  --> $DIR/missing_fields_in_debug.rs:88:5\n+   |\n+LL |     b: String,\n+   |     ^^^^^^^^^\n+   = help: consider including all fields in this `Debug` impl\n+   = help: consider calling `.finish_non_exhaustive()` if you intend to ignore fields\n+\n+error: manual `Debug` impl does not include all fields\n+  --> $DIR/missing_fields_in_debug.rs:119:1\n+   |\n+LL | / impl fmt::Debug for MultiVariantEnum {\n+LL | |     // match arm Self::B ignores `b`\n+LL | |     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+LL | |         match self {\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+note: the field referenced by this binding is unused\n+  --> $DIR/missing_fields_in_debug.rs:124:26\n+   |\n+LL |             Self::B { a, b } => formatter.debug_struct(\"B\").field(\"a\", &a).finish(),\n+   |                          ^\n+   = help: consider including all fields in this `Debug` impl\n+   = help: consider calling `.finish_non_exhaustive()` if you intend to ignore fields\n+\n+error: manual `Debug` impl does not include all fields\n+  --> $DIR/missing_fields_in_debug.rs:170:1\n+   |\n+LL | / impl fmt::Debug for MultiVariantRest {\n+LL | |     // `a` field ignored due to rest pattern\n+LL | |     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+LL | |         match self {\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+note: more unused fields here due to rest pattern `..`\n+  --> $DIR/missing_fields_in_debug.rs:175:13\n+   |\n+LL |             Self::B { b, .. } => formatter.debug_struct(\"B\").field(\"b\", &b).finish(),\n+   |             ^^^^^^^^^^^^^^^^^\n+   = help: consider including all fields in this `Debug` impl\n+   = help: consider calling `.finish_non_exhaustive()` if you intend to ignore fields\n+\n+error: aborting due to 5 previous errors\n+"}]}