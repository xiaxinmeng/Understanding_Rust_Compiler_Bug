{"sha": "43b227f3bdea473c69cb5568adfedfbbb18ff929", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzYjIyN2YzYmRlYTQ3M2M2OWNiNTU2OGFkZmVkZmJiYjE4ZmY5Mjk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-03-10T04:25:51Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-04-08T20:41:18Z"}, "message": "rustc: add some abstractions to ty::layout for a more concise API.", "tree": {"sha": "0e0ceddb9fa8195354b29a94c698d15a37dec937", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e0ceddb9fa8195354b29a94c698d15a37dec937"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43b227f3bdea473c69cb5568adfedfbbb18ff929", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43b227f3bdea473c69cb5568adfedfbbb18ff929", "html_url": "https://github.com/rust-lang/rust/commit/43b227f3bdea473c69cb5568adfedfbbb18ff929", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43b227f3bdea473c69cb5568adfedfbbb18ff929/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c977daf97cd7aa8b964b9b89e7ebd2da26022b2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a", "html_url": "https://github.com/rust-lang/rust/commit/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a"}], "stats": {"total": 268, "additions": 188, "deletions": 80}, "files": [{"sha": "8dc298b9c2a1788b1c0fcf0c4e1179c712b820ed", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=43b227f3bdea473c69cb5568adfedfbbb18ff929", "patch": "@@ -89,7 +89,7 @@ impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n             let from = unpack_option_like(self.infcx.tcx.global_tcx(), from);\n             match (&from.sty, sk_to) {\n                 (&ty::TyFnDef(..), SizeSkeleton::Known(size_to))\n-                        if size_to == Pointer.size(&self.infcx.tcx.data_layout) => {\n+                        if size_to == Pointer.size(self.infcx) => {\n                     struct_span_err!(self.infcx.tcx.sess, span, E0591,\n                                      \"`{}` is zero-sized and can't be transmuted to `{}`\",\n                                      from, to)"}, {"sha": "54e5de3909086d55728f54d8c35d6884b5ebda32", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 104, "deletions": 36, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=43b227f3bdea473c69cb5568adfedfbbb18ff929", "patch": "@@ -202,6 +202,16 @@ impl TargetDataLayout {\n     }\n }\n \n+pub trait HasDataLayout: Copy {\n+    fn data_layout(&self) -> &TargetDataLayout;\n+}\n+\n+impl<'a> HasDataLayout for &'a TargetDataLayout {\n+    fn data_layout(&self) -> &TargetDataLayout {\n+        self\n+    }\n+}\n+\n /// Endianness of the target, which must match cfg(target-endian).\n #[derive(Copy, Clone)]\n pub enum Endian {\n@@ -242,7 +252,9 @@ impl Size {\n         Size::from_bytes((self.bytes() + mask) & !mask)\n     }\n \n-    pub fn checked_add(self, offset: Size, dl: &TargetDataLayout) -> Option<Size> {\n+    pub fn checked_add<C: HasDataLayout>(self, offset: Size, cx: C) -> Option<Size> {\n+        let dl = cx.data_layout();\n+\n         // Each Size is less than dl.obj_size_bound(), so the sum is\n         // also less than 1 << 62 (and therefore can't overflow).\n         let bytes = self.bytes() + offset.bytes();\n@@ -254,7 +266,9 @@ impl Size {\n         }\n     }\n \n-    pub fn checked_mul(self, count: u64, dl: &TargetDataLayout) -> Option<Size> {\n+    pub fn checked_mul<C: HasDataLayout>(self, count: u64, cx: C) -> Option<Size> {\n+        let dl = cx.data_layout();\n+\n         // Each Size is less than dl.obj_size_bound(), so the sum is\n         // also less than 1 << 62 (and therefore can't overflow).\n         match self.bytes().checked_mul(count) {\n@@ -354,7 +368,9 @@ impl Integer {\n         }\n     }\n \n-    pub fn align(&self, dl: &TargetDataLayout)-> Align {\n+    pub fn align<C: HasDataLayout>(&self, cx: C) -> Align {\n+        let dl = cx.data_layout();\n+\n         match *self {\n             I1 => dl.i1_align,\n             I8 => dl.i8_align,\n@@ -408,7 +424,9 @@ impl Integer {\n     }\n \n     /// Find the smallest integer with the given alignment.\n-    pub fn for_abi_align(dl: &TargetDataLayout, align: Align) -> Option<Integer> {\n+    pub fn for_abi_align<C: HasDataLayout>(cx: C, align: Align) -> Option<Integer> {\n+        let dl = cx.data_layout();\n+\n         let wanted = align.abi();\n         for &candidate in &[I8, I16, I32, I64] {\n             let ty = Int(candidate);\n@@ -420,7 +438,9 @@ impl Integer {\n     }\n \n     /// Get the Integer type from an attr::IntType.\n-    pub fn from_attr(dl: &TargetDataLayout, ity: attr::IntType) -> Integer {\n+    pub fn from_attr<C: HasDataLayout>(cx: C, ity: attr::IntType) -> Integer {\n+        let dl = cx.data_layout();\n+\n         match ity {\n             attr::SignedInt(IntTy::I8) | attr::UnsignedInt(UintTy::U8) => I8,\n             attr::SignedInt(IntTy::I16) | attr::UnsignedInt(UintTy::U16) => I16,\n@@ -450,7 +470,7 @@ impl Integer {\n         let min_default = I8;\n \n         if let Some(ity) = repr.int {\n-            let discr = Integer::from_attr(&tcx.data_layout, ity);\n+            let discr = Integer::from_attr(tcx, ity);\n             let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };\n             if discr < fit {\n                 bug!(\"Integer::repr_discr: `#[repr]` hint too small for \\\n@@ -491,7 +511,9 @@ pub enum Primitive {\n }\n \n impl Primitive {\n-    pub fn size(self, dl: &TargetDataLayout) -> Size {\n+    pub fn size<C: HasDataLayout>(self, cx: C) -> Size {\n+        let dl = cx.data_layout();\n+\n         match self {\n             Int(I1) | Int(I8) => Size::from_bits(8),\n             Int(I16) => Size::from_bits(16),\n@@ -502,7 +524,9 @@ impl Primitive {\n         }\n     }\n \n-    pub fn align(self, dl: &TargetDataLayout) -> Align {\n+    pub fn align<C: HasDataLayout>(self, cx: C) -> Align {\n+        let dl = cx.data_layout();\n+\n         match self {\n             Int(I1) => dl.i1_align,\n             Int(I8) => dl.i8_align,\n@@ -682,8 +706,8 @@ impl<'a, 'gcx, 'tcx> Struct {\n     }\n \n     /// Determine whether a structure would be zero-sized, given its fields.\n-    pub fn would_be_zero_sized<I>(dl: &TargetDataLayout, fields: I)\n-                                  -> Result<bool, LayoutError<'gcx>>\n+    fn would_be_zero_sized<I>(dl: &TargetDataLayout, fields: I)\n+                              -> Result<bool, LayoutError<'gcx>>\n     where I: Iterator<Item=Result<&'a Layout, LayoutError<'gcx>>> {\n         for field in fields {\n             let field = field?;\n@@ -831,7 +855,7 @@ pub struct Union {\n }\n \n impl<'a, 'gcx, 'tcx> Union {\n-    pub fn new(dl: &TargetDataLayout, packed: bool) -> Union {\n+    fn new(dl: &TargetDataLayout, packed: bool) -> Union {\n         Union {\n             align: if packed { dl.i8_align } else { dl.aggregate_align },\n             min_size: Size::from_bytes(0),\n@@ -840,10 +864,10 @@ impl<'a, 'gcx, 'tcx> Union {\n     }\n \n     /// Extend the Struct with more fields.\n-    pub fn extend<I>(&mut self, dl: &TargetDataLayout,\n-                     fields: I,\n-                     scapegoat: Ty<'gcx>)\n-                     -> Result<(), LayoutError<'gcx>>\n+    fn extend<I>(&mut self, dl: &TargetDataLayout,\n+                 fields: I,\n+                 scapegoat: Ty<'gcx>)\n+                 -> Result<(), LayoutError<'gcx>>\n     where I: Iterator<Item=Result<&'a Layout, LayoutError<'gcx>>> {\n         for (index, field) in fields.enumerate() {\n             let field = field?;\n@@ -1452,7 +1476,9 @@ impl<'a, 'gcx, 'tcx> Layout {\n         }\n     }\n \n-    pub fn size(&self, dl: &TargetDataLayout) -> Size {\n+    pub fn size<C: HasDataLayout>(&self, cx: C) -> Size {\n+        let dl = cx.data_layout();\n+\n         match *self {\n             Scalar { value, .. } | RawNullablePointer { value, .. } => {\n                 value.size(dl)\n@@ -1494,7 +1520,9 @@ impl<'a, 'gcx, 'tcx> Layout {\n         }\n     }\n \n-    pub fn align(&self, dl: &TargetDataLayout) -> Align {\n+    pub fn align<C: HasDataLayout>(&self, cx: C) -> Align {\n+        let dl = cx.data_layout();\n+\n         match *self {\n             Scalar { value, .. } | RawNullablePointer { value, .. } => {\n                 value.align(dl)\n@@ -1534,11 +1562,13 @@ impl<'a, 'gcx, 'tcx> Layout {\n         }\n     }\n \n-    pub fn field_offset(&self,\n-                        dl: &TargetDataLayout,\n-                        i: usize,\n-                        variant_index: Option<usize>)\n-                        -> Size {\n+    pub fn field_offset<C: HasDataLayout>(&self,\n+                                          cx: C,\n+                                          i: usize,\n+                                          variant_index: Option<usize>)\n+                                          -> Size {\n+        let dl = cx.data_layout();\n+\n         match *self {\n             Scalar { .. } |\n             CEnum { .. } |\n@@ -1617,7 +1647,7 @@ impl<'a, 'gcx, 'tcx> SizeSkeleton<'gcx> {\n         // First try computing a static layout.\n         let err = match ty.layout(infcx) {\n             Ok(layout) => {\n-                return Ok(SizeSkeleton::Known(layout.size(&tcx.data_layout)));\n+                return Ok(SizeSkeleton::Known(layout.size(tcx)));\n             }\n             Err(err) => err\n         };\n@@ -1748,27 +1778,64 @@ impl<'tcx> Deref for TyLayout<'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TyLayout<'gcx> {\n-    pub fn of(infcx: &InferCtxt<'a, 'gcx, 'tcx>, ty: Ty<'gcx>)\n-              -> Result<Self, LayoutError<'gcx>> {\n-        let ty = normalize_associated_type(infcx, ty);\n+pub trait HasTyCtxt<'tcx>: HasDataLayout {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n+}\n+\n+impl<'a, 'gcx, 'tcx> HasDataLayout for TyCtxt<'a, 'gcx, 'tcx> {\n+    fn data_layout(&self) -> &TargetDataLayout {\n+        &self.data_layout\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> HasTyCtxt<'gcx> for TyCtxt<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'gcx> {\n+        self.global_tcx()\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> HasDataLayout for &'a InferCtxt<'a, 'gcx, 'tcx> {\n+    fn data_layout(&self) -> &TargetDataLayout {\n+        &self.tcx.data_layout\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> HasTyCtxt<'gcx> for &'a InferCtxt<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'gcx> {\n+        self.tcx.global_tcx()\n+    }\n+}\n+\n+pub trait LayoutTyper<'tcx>: HasTyCtxt<'tcx> {\n+    type TyLayout;\n+\n+    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout;\n+}\n+\n+impl<'a, 'gcx, 'tcx> LayoutTyper<'gcx> for &'a InferCtxt<'a, 'gcx, 'tcx> {\n+    type TyLayout = Result<TyLayout<'gcx>, LayoutError<'gcx>>;\n+\n+    fn layout_of(self, ty: Ty<'gcx>) -> Self::TyLayout {\n+        let ty = normalize_associated_type(self, ty);\n \n         Ok(TyLayout {\n             ty: ty,\n-            layout: ty.layout(infcx)?,\n+            layout: ty.layout(self)?,\n             variant_index: None\n         })\n     }\n+}\n \n+impl<'a, 'tcx> TyLayout<'tcx> {\n     pub fn for_variant(&self, variant_index: usize) -> Self {\n         TyLayout {\n             variant_index: Some(variant_index),\n             ..*self\n         }\n     }\n \n-    pub fn field_offset(&self, dl: &TargetDataLayout, i: usize) -> Size {\n-        self.layout.field_offset(dl, i, self.variant_index)\n+    pub fn field_offset<C: HasDataLayout>(&self, cx: C, i: usize) -> Size {\n+        self.layout.field_offset(cx, i, self.variant_index)\n     }\n \n     pub fn field_count(&self) -> usize {\n@@ -1808,9 +1875,11 @@ impl<'a, 'gcx, 'tcx> TyLayout<'gcx> {\n         }\n     }\n \n-    pub fn field_type(&self, tcx: TyCtxt<'a, 'gcx, 'gcx>, i: usize) -> Ty<'gcx> {\n-        let ptr_field_type = |pointee: Ty<'gcx>| {\n-            let slice = |element: Ty<'gcx>| {\n+    pub fn field_type<C: HasTyCtxt<'tcx>>(&self, cx: C, i: usize) -> Ty<'tcx> {\n+        let tcx = cx.tcx();\n+\n+        let ptr_field_type = |pointee: Ty<'tcx>| {\n+            let slice = |element: Ty<'tcx>| {\n                 assert!(i < 2);\n                 if i == 0 {\n                     tcx.mk_mut_ptr(element)\n@@ -1877,8 +1946,7 @@ impl<'a, 'gcx, 'tcx> TyLayout<'gcx> {\n         }\n     }\n \n-    pub fn field(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>, i: usize)\n-                 -> Result<Self, LayoutError<'gcx>> {\n-        TyLayout::of(infcx, self.field_type(infcx.tcx.global_tcx(), i))\n+    pub fn field<C: LayoutTyper<'tcx>>(&self, cx: C, i: usize) -> C::TyLayout {\n+        cx.layout_of(self.field_type(cx, i))\n     }\n }"}, {"sha": "2318bb81affe67c44c50c0cbf82a1f5a5c24f87d", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=43b227f3bdea473c69cb5568adfedfbbb18ff929", "patch": "@@ -733,7 +733,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                 });\n \n                 if let Layout::General { ref variants, ref size, discr, .. } = *layout {\n-                    let discr_size = Primitive::Int(discr).size(&cx.tcx.data_layout).bytes();\n+                    let discr_size = Primitive::Int(discr).size(cx.tcx).bytes();\n \n                     debug!(\"enum `{}` is {} bytes large with layout:\\n{:#?}\",\n                       t, size.bytes(), layout);"}, {"sha": "b26dd8eed7876f7dc3618b1b0470dbb9452fc671", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=43b227f3bdea473c69cb5568adfedfbbb18ff929", "patch": "@@ -35,13 +35,13 @@ use type_of;\n \n use rustc::hir;\n use rustc::ty::{self, Ty};\n+use rustc::ty::layout::{Layout, LayoutTyper};\n \n use libc::c_uint;\n use std::cmp;\n \n pub use syntax::abi::Abi;\n pub use rustc::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n-use rustc::ty::layout::Layout;\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n enum ArgKind {"}, {"sha": "b15acfb591caa8cac9657f3fcce481a205b84cdf", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=43b227f3bdea473c69cb5568adfedfbbb18ff929", "patch": "@@ -46,8 +46,8 @@ use super::Disr;\n use std;\n \n use llvm::{ValueRef, True, IntEQ, IntNE};\n-use rustc::ty::layout;\n use rustc::ty::{self, Ty};\n+use rustc::ty::layout::{self, LayoutTyper};\n use common::*;\n use builder::Builder;\n use base;\n@@ -246,9 +246,8 @@ fn union_fill(cx: &CrateContext, size: u64, align: u64) -> Type {\n     assert_eq!(size%align, 0);\n     assert_eq!(align.count_ones(), 1, \"Alignment must be a power fof 2. Got {}\", align);\n     let align_units = size/align;\n-    let dl = &cx.tcx().data_layout;\n     let layout_align = layout::Align::from_bytes(align, align).unwrap();\n-    if let Some(ity) = layout::Integer::for_abi_align(dl, layout_align) {\n+    if let Some(ity) = layout::Integer::for_abi_align(cx, layout_align) {\n         Type::array(&Type::from_integer(cx, ity), align_units)\n     } else {\n         Type::array(&Type::vector(&Type::i32(cx), align/4),"}, {"sha": "574b345218be9def7543abb1534eb700aae1e23b", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=43b227f3bdea473c69cb5568adfedfbbb18ff929", "patch": "@@ -1295,8 +1295,8 @@ fn gather_type_sizes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         // (delay format until we actually need it)\n         let record = |kind, opt_discr_size, variants| {\n             let type_desc = format!(\"{:?}\", ty);\n-            let overall_size = layout.size(&tcx.data_layout);\n-            let align = layout.align(&tcx.data_layout);\n+            let overall_size = layout.size(tcx);\n+            let align = layout.align(tcx);\n             tcx.sess.code_stats.borrow_mut().record_type_size(kind,\n                                                               type_desc,\n                                                               align,\n@@ -1332,8 +1332,8 @@ fn gather_type_sizes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n                     session::FieldInfo {\n                         name: field_name.to_string(),\n                         offset: offset.bytes(),\n-                        size: field_layout.size(&tcx.data_layout).bytes(),\n-                        align: field_layout.align(&tcx.data_layout).abi(),\n+                        size: field_layout.size(tcx).bytes(),\n+                        align: field_layout.align(tcx).abi(),\n                     }\n                 }\n             }\n@@ -1343,8 +1343,8 @@ fn gather_type_sizes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n             session::VariantInfo {\n                 name: Some(name.to_string()),\n                 kind: session::SizeKind::Exact,\n-                align: value.align(&tcx.data_layout).abi(),\n-                size: value.size(&tcx.data_layout).bytes(),\n+                align: value.align(tcx).abi(),\n+                size: value.size(tcx).bytes(),\n                 fields: vec![],\n             }\n         };"}, {"sha": "5d58c93538922ab6544adb417c5c1827b396551e", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=43b227f3bdea473c69cb5568adfedfbbb18ff929", "patch": "@@ -27,7 +27,7 @@ use monomorphize;\n use type_::Type;\n use value::Value;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::Layout;\n+use rustc::ty::layout::{Layout, LayoutTyper};\n use rustc::ty::subst::{Subst, Substs};\n use rustc::hir;\n \n@@ -63,7 +63,7 @@ pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n         Layout::UntaggedUnion { .. } |\n         Layout::RawNullablePointer { .. } |\n         Layout::StructWrappedNullablePointer { .. } => {\n-            !layout.is_unsized() && layout.size(&ccx.tcx().data_layout).bytes() == 0\n+            !layout.is_unsized() && layout.size(ccx).bytes() == 0\n         }\n     }\n }\n@@ -126,7 +126,7 @@ pub fn type_is_imm_pair<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n /// Identify types which have size zero at runtime.\n pub fn type_is_zero_size<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     let layout = ccx.layout_of(ty);\n-    !layout.is_unsized() && layout.size(&ccx.tcx().data_layout).bytes() == 0\n+    !layout.is_unsized() && layout.size(ccx).bytes() == 0\n }\n \n /*"}, {"sha": "98fbb64fd55407b467c2bf20dbfb85744b563bfe", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 49, "deletions": 12, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=43b227f3bdea473c69cb5568adfedfbbb18ff929", "patch": "@@ -28,6 +28,7 @@ use type_::Type;\n use rustc_data_structures::base_n;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::layout::{LayoutTyper, TyLayout};\n use session::config::NoDebugInfo;\n use session::Session;\n use session::config;\n@@ -828,18 +829,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         TypeOfDepthLock(self.local())\n     }\n \n-    pub fn layout_of(&self, ty: Ty<'tcx>) -> ty::layout::TyLayout<'tcx> {\n-        self.tcx().infer_ctxt((), traits::Reveal::All).enter(|infcx| {\n-            ty::layout::TyLayout::of(&infcx, ty).unwrap_or_else(|e| {\n-                match e {\n-                    ty::layout::LayoutError::SizeOverflow(_) =>\n-                        self.sess().fatal(&e.to_string()),\n-                    _ => bug!(\"failed to get layout for `{}`: {}\", ty, e)\n-                }\n-            })\n-        })\n-    }\n-\n     pub fn check_overflow(&self) -> bool {\n         self.shared.check_overflow\n     }\n@@ -951,6 +940,54 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> ty::layout::HasDataLayout for &'a SharedCrateContext<'a, 'tcx> {\n+    fn data_layout(&self) -> &ty::layout::TargetDataLayout {\n+        &self.tcx.data_layout\n+    }\n+}\n+\n+impl<'a, 'tcx> ty::layout::HasTyCtxt<'tcx> for &'a SharedCrateContext<'a, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n+}\n+\n+impl<'a, 'tcx> ty::layout::HasDataLayout for &'a CrateContext<'a, 'tcx> {\n+    fn data_layout(&self) -> &ty::layout::TargetDataLayout {\n+        &self.shared.tcx.data_layout\n+    }\n+}\n+\n+impl<'a, 'tcx> ty::layout::HasTyCtxt<'tcx> for &'a CrateContext<'a, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n+        self.shared.tcx\n+    }\n+}\n+\n+impl<'a, 'tcx> LayoutTyper<'tcx> for &'a SharedCrateContext<'a, 'tcx> {\n+    type TyLayout = TyLayout<'tcx>;\n+\n+    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n+        self.tcx().infer_ctxt((), traits::Reveal::All).enter(|infcx| {\n+            infcx.layout_of(ty).unwrap_or_else(|e| {\n+                match e {\n+                    ty::layout::LayoutError::SizeOverflow(_) =>\n+                        self.sess().fatal(&e.to_string()),\n+                    _ => bug!(\"failed to get layout for `{}`: {}\", ty, e)\n+                }\n+            })\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> LayoutTyper<'tcx> for &'a CrateContext<'a, 'tcx> {\n+    type TyLayout = TyLayout<'tcx>;\n+\n+    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n+        self.shared.layout_of(ty)\n+    }\n+}\n+\n pub struct TypeOfDepthLock<'a, 'tcx: 'a>(&'a LocalCrateContext<'tcx>);\n \n impl<'a, 'tcx> Drop for TypeOfDepthLock<'a, 'tcx> {"}, {"sha": "ccb693aa41f4c4a5e8ac78ad33b5d6a1d86e4046", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=43b227f3bdea473c69cb5568adfedfbbb18ff929", "patch": "@@ -35,7 +35,8 @@ use rustc_data_structures::ToHex;\n use {type_of, machine, monomorphize};\n use common::{self, CrateContext};\n use type_::Type;\n-use rustc::ty::{self, AdtKind, Ty, layout};\n+use rustc::ty::{self, AdtKind, Ty};\n+use rustc::ty::layout::{self, LayoutTyper};\n use session::config;\n use util::nodemap::FxHashMap;\n use util::common::path2cstr;\n@@ -900,7 +901,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n         let offsets = match *layout {\n             layout::Univariant { ref variant, .. } => &variant.offsets,\n             layout::Vector { element, count } => {\n-                let element_size = element.size(&cx.tcx().data_layout).bytes();\n+                let element_size = element.size(cx).bytes();\n                 tmp = (0..count).\n                   map(|i| layout::Size::from_bytes(i*element_size))\n                   .collect::<Vec<layout::Size>>();"}, {"sha": "59876a7f2a201da688fe23eda5f397852fd9ceb0", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=43b227f3bdea473c69cb5568adfedfbbb18ff929", "patch": "@@ -18,6 +18,7 @@ use llvm;\n use llvm::{ValueRef};\n use rustc::traits;\n use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::layout::LayoutTyper;\n use common::*;\n use meth;\n use monomorphize;\n@@ -47,7 +48,7 @@ pub fn needs_drop_glue<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>, t: Ty<'tcx>\n             if !scx.type_needs_drop(typ) && scx.type_is_sized(typ) {\n                 scx.tcx().infer_ctxt((), traits::Reveal::All).enter(|infcx| {\n                     let layout = t.layout(&infcx).unwrap();\n-                    if layout.size(&scx.tcx().data_layout).bytes() == 0 {\n+                    if layout.size(scx).bytes() == 0 {\n                         // `Box<ZeroSizeType>` does not allocate.\n                         false\n                     } else {"}, {"sha": "18893ce4ea9a60290915c83720b5417701bd8194", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=43b227f3bdea473c69cb5568adfedfbbb18ff929", "patch": "@@ -12,7 +12,8 @@ use llvm::{self, ValueRef, BasicBlockRef};\n use rustc_const_eval::{ErrKind, ConstEvalErr, note_const_eval_err};\n use rustc::middle::lang_items;\n use rustc::middle::const_val::ConstInt;\n-use rustc::ty::{self, layout, TypeFoldable};\n+use rustc::ty::{self, TypeFoldable};\n+use rustc::ty::layout::{self, LayoutTyper};\n use rustc::mir;\n use abi::{Abi, FnType, ArgType};\n use base::{self, Lifetime};"}, {"sha": "4d5b691c86ebb514def7c8e559a6a2eb39f73b59", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=43b227f3bdea473c69cb5568adfedfbbb18ff929", "patch": "@@ -18,7 +18,8 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n-use rustc::ty::{self, layout, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::layout::{self, LayoutTyper};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::subst::{Kind, Substs, Subst};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n@@ -979,7 +980,6 @@ fn trans_const<'a, 'tcx>(\n     vals: &[ValueRef]\n ) -> ValueRef {\n     let l = ccx.layout_of(t);\n-    let dl = &ccx.tcx().data_layout;\n     let variant_index = match *kind {\n         mir::AggregateKind::Adt(_, index, _, _) => index,\n         _ => 0,\n@@ -1002,7 +1002,7 @@ fn trans_const<'a, 'tcx>(\n             let mut vals_with_discr = vec![lldiscr];\n             vals_with_discr.extend_from_slice(vals);\n             let mut contents = build_const_struct(ccx, &variant, &vals_with_discr[..]);\n-            let needed_padding = l.size(dl).bytes() - variant.stride().bytes();\n+            let needed_padding = l.size(ccx).bytes() - variant.stride().bytes();\n             if needed_padding > 0 {\n                 contents.push(padding(ccx, needed_padding));\n             }"}, {"sha": "fc889604ab88ea900c50afd2ac1e24d04e8b4078", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=43b227f3bdea473c69cb5568adfedfbbb18ff929", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n use llvm::ValueRef;\n-use rustc::ty::{self, layout, Ty, TypeFoldable};\n+use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::layout::{self, LayoutTyper};\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;"}, {"sha": "cc957a4d258735aa2848c9f22799604deea2fbd1", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=43b227f3bdea473c69cb5568adfedfbbb18ff929", "patch": "@@ -11,7 +11,8 @@\n use libc::c_uint;\n use llvm::{self, ValueRef, BasicBlockRef};\n use llvm::debuginfo::DIScope;\n-use rustc::ty::{self, layout};\n+use rustc::ty;\n+use rustc::ty::layout::{self, LayoutTyper};\n use rustc::mir::{self, Mir};\n use rustc::mir::tcx::LvalueTy;\n use rustc::ty::subst::Substs;"}, {"sha": "771a88238b2b73a66cbcdb319bebbf97e9ce5c98", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=43b227f3bdea473c69cb5568adfedfbbb18ff929", "patch": "@@ -10,7 +10,7 @@\n \n use llvm::ValueRef;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::Layout;\n+use rustc::ty::layout::{Layout, LayoutTyper};\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;"}, {"sha": "8f7cb914c47354294c7342dbe17b88e577c02eb2", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=43b227f3bdea473c69cb5568adfedfbbb18ff929", "patch": "@@ -11,7 +11,7 @@\n use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty};\n use rustc::ty::cast::{CastTy, IntTy};\n-use rustc::ty::layout::Layout;\n+use rustc::ty::layout::{Layout, LayoutTyper};\n use rustc::mir::tcx::LvalueTy;\n use rustc::mir;\n use middle::lang_items::ExchangeMallocFnLangItem;"}, {"sha": "c459191561dd6d119e3ae54d229f020830c0ffa5", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b227f3bdea473c69cb5568adfedfbbb18ff929/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=43b227f3bdea473c69cb5568adfedfbbb18ff929", "patch": "@@ -13,6 +13,7 @@ use adt;\n use common::*;\n use machine;\n use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::layout::LayoutTyper;\n use trans_item::DefPathBasedNames;\n use type_::Type;\n \n@@ -117,14 +118,14 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n         return llsizingty;\n     }\n \n-    let r = layout.size(&cx.tcx().data_layout).bytes();\n+    let r = layout.size(cx).bytes();\n     let l = machine::llsize_of_alloc(cx, llsizingty);\n     if r != l {\n         bug!(\"size differs (rustc: {}, llvm: {}) for type `{}` / {:#?}\",\n              r, l, t, layout);\n     }\n \n-    let r = layout.align(&cx.tcx().data_layout).abi();\n+    let r = layout.align(cx).abi();\n     let l = machine::llalign_of_min(cx, llsizingty) as u64;\n     if r != l {\n         bug!(\"align differs (rustc: {}, llvm: {}) for type `{}` / {:#?}\",\n@@ -324,13 +325,11 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n \n impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n     pub fn align_of(&self, ty: Ty<'tcx>) -> machine::llalign {\n-        let layout = self.layout_of(ty);\n-        layout.align(&self.tcx().data_layout).abi() as machine::llalign\n+        self.layout_of(ty).align(self).abi() as machine::llalign\n     }\n \n     pub fn size_of(&self, ty: Ty<'tcx>) -> machine::llsize {\n-        let layout = self.layout_of(ty);\n-        layout.size(&self.tcx().data_layout).bytes() as machine::llsize\n+        self.layout_of(ty).size(self).bytes() as machine::llsize\n     }\n }\n "}]}