{"sha": "cdfd675a63090182fd1c5f2ff58d8eaa115da156", "node_id": "C_kwDOAAsO6NoAKGNkZmQ2NzVhNjMwOTAxODJmZDFjNWYyZmY1OGQ4ZWFhMTE1ZGExNTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-05T06:35:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-05T06:35:12Z"}, "message": "Auto merge of #99867 - spastorino:refactor-remap-lifetimes, r=nikomatsakis\n\nSplit create_def and lowering of lifetimes for opaque types and bare async fns\n\nr? `@cjgillot`\n\nThis work is kind of half-way, but I think it could be merged anyway.\nI think we should be able to remove all the vacant arms in `new_named_lifetime_with_res`, if I'm not wrong that requires visiting more nodes. We can do that as a follow up.\nIn follow-up PRs, besides the thing mentioned previously, I'll be trying to remove `LifetimeCaptureContext`, `captured_lifetimes` as a global data structure, global `binders_to_ignore` and all their friends :).\n\nAlso try to remap in a more general way based on def-ids.", "tree": {"sha": "85180e0a30bcc147e3bfb6378eeb8d85870fb362", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85180e0a30bcc147e3bfb6378eeb8d85870fb362"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdfd675a63090182fd1c5f2ff58d8eaa115da156", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdfd675a63090182fd1c5f2ff58d8eaa115da156", "html_url": "https://github.com/rust-lang/rust/commit/cdfd675a63090182fd1c5f2ff58d8eaa115da156", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdfd675a63090182fd1c5f2ff58d8eaa115da156/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bcf01afdb1c21a30cdf1fd20f9cdef7c482e753", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bcf01afdb1c21a30cdf1fd20f9cdef7c482e753", "html_url": "https://github.com/rust-lang/rust/commit/6bcf01afdb1c21a30cdf1fd20f9cdef7c482e753"}, {"sha": "4170d7390b90b5eee001d6292b3273dec6d67651", "url": "https://api.github.com/repos/rust-lang/rust/commits/4170d7390b90b5eee001d6292b3273dec6d67651", "html_url": "https://github.com/rust-lang/rust/commit/4170d7390b90b5eee001d6292b3273dec6d67651"}], "stats": {"total": 884, "additions": 588, "deletions": 296}, "files": [{"sha": "870a7c0be33dc111ecf907093d225463c56f9cc5", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdfd675a63090182fd1c5f2ff58d8eaa115da156/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfd675a63090182fd1c5f2ff58d8eaa115da156/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=cdfd675a63090182fd1c5f2ff58d8eaa115da156", "patch": "@@ -64,7 +64,7 @@ impl fmt::Debug for Label {\n \n /// A \"Lifetime\" is an annotation of the scope in which variable\n /// can be used, e.g. `'a` in `&'a i32`.\n-#[derive(Clone, Encodable, Decodable, Copy)]\n+#[derive(Clone, Encodable, Decodable, Copy, PartialEq, Eq)]\n pub struct Lifetime {\n     pub id: NodeId,\n     pub ident: Ident,"}, {"sha": "fb6715ff17ee9afca88b21dc6a102168ff1806d4", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/cdfd675a63090182fd1c5f2ff58d8eaa115da156/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfd675a63090182fd1c5f2ff58d8eaa115da156/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=cdfd675a63090182fd1c5f2ff58d8eaa115da156", "patch": "@@ -864,22 +864,21 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             (body_id, generator_option)\n         });\n \n-        self.with_lifetime_binder(closure_id, generic_params, |this, bound_generic_params| {\n-            // Lower outside new scope to preserve `is_in_loop_condition`.\n-            let fn_decl = this.lower_fn_decl(decl, None, FnDeclKind::Closure, None);\n-\n-            let c = self.arena.alloc(hir::Closure {\n-                binder: binder_clause,\n-                capture_clause,\n-                bound_generic_params,\n-                fn_decl,\n-                body: body_id,\n-                fn_decl_span: this.lower_span(fn_decl_span),\n-                movability: generator_option,\n-            });\n+        let bound_generic_params = self.lower_lifetime_binder(closure_id, generic_params);\n+        // Lower outside new scope to preserve `is_in_loop_condition`.\n+        let fn_decl = self.lower_fn_decl(decl, None, FnDeclKind::Closure, None);\n+\n+        let c = self.arena.alloc(hir::Closure {\n+            binder: binder_clause,\n+            capture_clause,\n+            bound_generic_params,\n+            fn_decl,\n+            body: body_id,\n+            fn_decl_span: self.lower_span(fn_decl_span),\n+            movability: generator_option,\n+        });\n \n-            hir::ExprKind::Closure(c)\n-        })\n+        hir::ExprKind::Closure(c)\n     }\n \n     fn generator_movability_for_fn(\n@@ -991,23 +990,23 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             body_id\n         });\n \n-        self.with_lifetime_binder(closure_id, generic_params, |this, bound_generic_params| {\n-            // We need to lower the declaration outside the new scope, because we\n-            // have to conserve the state of being inside a loop condition for the\n-            // closure argument types.\n-            let fn_decl = this.lower_fn_decl(&outer_decl, None, FnDeclKind::Closure, None);\n-\n-            let c = self.arena.alloc(hir::Closure {\n-                binder: binder_clause,\n-                capture_clause,\n-                bound_generic_params,\n-                fn_decl,\n-                body,\n-                fn_decl_span: this.lower_span(fn_decl_span),\n-                movability: None,\n-            });\n-            hir::ExprKind::Closure(c)\n-        })\n+        let bound_generic_params = self.lower_lifetime_binder(closure_id, generic_params);\n+\n+        // We need to lower the declaration outside the new scope, because we\n+        // have to conserve the state of being inside a loop condition for the\n+        // closure argument types.\n+        let fn_decl = self.lower_fn_decl(&outer_decl, None, FnDeclKind::Closure, None);\n+\n+        let c = self.arena.alloc(hir::Closure {\n+            binder: binder_clause,\n+            capture_clause,\n+            bound_generic_params,\n+            fn_decl,\n+            body,\n+            fn_decl_span: self.lower_span(fn_decl_span),\n+            movability: None,\n+        });\n+        hir::ExprKind::Closure(c)\n     }\n \n     /// Destructure the LHS of complex assignments."}, {"sha": "ee4c0036f76981a3ca444557121fa7ab4dde1e27", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cdfd675a63090182fd1c5f2ff58d8eaa115da156/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfd675a63090182fd1c5f2ff58d8eaa115da156/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=cdfd675a63090182fd1c5f2ff58d8eaa115da156", "patch": "@@ -80,7 +80,6 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n             generator_kind: None,\n             task_context: None,\n             current_item: None,\n-            captured_lifetimes: None,\n             impl_trait_defs: Vec::new(),\n             impl_trait_bounds: Vec::new(),\n             allow_try_trait: Some([sym::try_trait_v2, sym::yeet_desugar_details][..].into()),\n@@ -1350,12 +1349,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let mut predicates: SmallVec<[hir::WherePredicate<'hir>; 4]> = SmallVec::new();\n         predicates.extend(generics.params.iter().filter_map(|param| {\n-            let bounds = self.lower_param_bounds(&param.bounds, itctx);\n             self.lower_generic_bound_predicate(\n                 param.ident,\n                 param.id,\n                 &param.kind,\n-                bounds,\n+                &param.bounds,\n+                itctx,\n                 PredicateOrigin::GenericParam,\n             )\n         }));\n@@ -1403,13 +1402,17 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         ident: Ident,\n         id: NodeId,\n         kind: &GenericParamKind,\n-        bounds: &'hir [hir::GenericBound<'hir>],\n+        bounds: &[GenericBound],\n+        itctx: ImplTraitContext,\n         origin: PredicateOrigin,\n     ) -> Option<hir::WherePredicate<'hir>> {\n         // Do not create a clause if we do not have anything inside it.\n         if bounds.is_empty() {\n             return None;\n         }\n+\n+        let bounds = self.lower_param_bounds(bounds, itctx);\n+\n         let ident = self.lower_ident(ident);\n         let param_span = ident.span;\n         let span = bounds\n@@ -1450,11 +1453,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             GenericParamKind::Lifetime => {\n                 let ident_span = self.lower_span(ident.span);\n                 let ident = self.lower_ident(ident);\n-                let res = self.resolver.get_lifetime_res(id).unwrap_or_else(|| {\n-                    panic!(\"Missing resolution for lifetime {:?} at {:?}\", id, ident.span)\n-                });\n                 let lt_id = self.next_node_id();\n-                let lifetime = self.new_named_lifetime_with_res(lt_id, ident_span, ident, res);\n+                let lifetime = self.new_named_lifetime(id, lt_id, ident_span, ident);\n                 Some(hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n                     lifetime,\n                     span,"}, {"sha": "a5b089b032d8b4d506005b694086e71a55e78f40", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 413, "deletions": 255, "changes": 668, "blob_url": "https://github.com/rust-lang/rust/blob/cdfd675a63090182fd1c5f2ff58d8eaa115da156/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfd675a63090182fd1c5f2ff58d8eaa115da156/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=cdfd675a63090182fd1c5f2ff58d8eaa115da156", "patch": "@@ -45,7 +45,7 @@ use rustc_ast::{self as ast, *};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n@@ -56,6 +56,7 @@ use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n use rustc_hir::definitions::DefPathData;\n use rustc_hir::{ConstArg, GenericArg, ItemLocalId, ParamName, TraitCandidate};\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::span_bug;\n use rustc_middle::ty::{ResolverAstLowering, TyCtxt};\n use rustc_session::parse::feature_err;\n use rustc_span::hygiene::MacroKind;\n@@ -77,6 +78,7 @@ mod block;\n mod expr;\n mod index;\n mod item;\n+mod lifetime_collector;\n mod pat;\n mod path;\n \n@@ -110,9 +112,6 @@ struct LoweringContext<'a, 'hir> {\n     is_in_trait_impl: bool,\n     is_in_dyn_type: bool,\n \n-    /// Used to handle lifetimes appearing in impl-traits.\n-    captured_lifetimes: Option<LifetimeCaptureContext>,\n-\n     current_hir_id_owner: LocalDefId,\n     item_local_id_counter: hir::ItemLocalId,\n     local_id_to_def_id: SortedMap<ItemLocalId, LocalDefId>,\n@@ -129,28 +128,6 @@ struct LoweringContext<'a, 'hir> {\n     allow_into_future: Option<Lrc<[Symbol]>>,\n }\n \n-/// When we lower a lifetime, it is inserted in `captures`, and the resolution is modified so\n-/// to point to the lifetime parameter impl-trait will generate.\n-/// When traversing `for<...>` binders, they are inserted in `binders_to_ignore` so we know *not*\n-/// to rebind the introduced lifetimes.\n-#[derive(Debug)]\n-struct LifetimeCaptureContext {\n-    /// parent def_id for new definitions\n-    parent_def_id: LocalDefId,\n-    /// Set of lifetimes to rebind.\n-    captures: FxHashMap<\n-        LocalDefId, // original parameter id\n-        (\n-            Span,        // Span\n-            NodeId,      // synthetized parameter id\n-            ParamName,   // parameter name\n-            LifetimeRes, // original resolution\n-        ),\n-    >,\n-    /// Traversed binders.  The ids in this set should *not* be rebound.\n-    binders_to_ignore: FxHashSet<NodeId>,\n-}\n-\n trait ResolverAstLoweringExt {\n     fn legacy_const_generic_args(&self, expr: &Expr) -> Option<Vec<usize>>;\n     fn get_partial_res(&self, id: NodeId) -> Option<PartialRes>;\n@@ -159,6 +136,12 @@ trait ResolverAstLoweringExt {\n     fn get_lifetime_res(&self, id: NodeId) -> Option<LifetimeRes>;\n     fn take_extra_lifetime_params(&mut self, id: NodeId) -> Vec<(Ident, NodeId, LifetimeRes)>;\n     fn decl_macro_kind(&self, def_id: LocalDefId) -> MacroKind;\n+    /// Record the map from `from` local def id to `to` local def id, on `generics_def_id_map`\n+    /// field.\n+    fn record_def_id_remap(&mut self, from: LocalDefId, to: LocalDefId);\n+    /// Get the previously recorded `to` local def id given the `from` local def id, obtained using\n+    /// `generics_def_id_map` field.\n+    fn get_remapped_def_id(&self, local_def_id: LocalDefId) -> LocalDefId;\n }\n \n impl ResolverAstLoweringExt for ResolverAstLowering {\n@@ -226,6 +209,28 @@ impl ResolverAstLoweringExt for ResolverAstLowering {\n     fn decl_macro_kind(&self, def_id: LocalDefId) -> MacroKind {\n         self.builtin_macro_kinds.get(&def_id).copied().unwrap_or(MacroKind::Bang)\n     }\n+\n+    /// Push a remapping into the top-most map.\n+    /// Panics if no map has been pushed.\n+    /// Remapping is used when creating lowering `-> impl Trait` return\n+    /// types to create the resulting opaque type.\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    fn record_def_id_remap(&mut self, from: LocalDefId, to: LocalDefId) {\n+        self.generics_def_id_map.last_mut().expect(\"no map pushed\").insert(from, to);\n+    }\n+\n+    fn get_remapped_def_id(&self, mut local_def_id: LocalDefId) -> LocalDefId {\n+        for map in &self.generics_def_id_map {\n+            if let Some(r) = map.get(&local_def_id) {\n+                debug!(\"def_id_remapper: remapping from `{local_def_id:?}` to `{r:?}`\");\n+                local_def_id = *r;\n+            } else {\n+                debug!(\"def_id_remapper: no remapping for `{local_def_id:?}` found in map\");\n+            }\n+        }\n+\n+        local_def_id\n+    }\n }\n \n /// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,\n@@ -481,8 +486,24 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         start\n     }\n \n+    /// Given the id of some node in the AST, finds the `LocalDefId` associated with it by the name\n+    /// resolver (if any), after applying any remapping from `get_remapped_def_id`.\n+    ///\n+    /// For example, in a function like `fn foo<'a>(x: &'a u32)`,\n+    /// invoking with the id from the `ast::Lifetime` node found inside\n+    /// the `&'a u32` type would return the `LocalDefId` of the\n+    /// `'a` parameter declared on `foo`.\n+    ///\n+    /// This function also applies remapping from `get_remapped_def_id`.\n+    /// These are used when synthesizing opaque types from `-> impl Trait` return types and so forth.\n+    /// For example, in a function like `fn foo<'a>() -> impl Debug + 'a`,\n+    /// we would create an opaque type `type FooReturn<'a1> = impl Debug + 'a1`.\n+    /// When lowering the `Debug + 'a` bounds, we add a remapping to map `'a` to `'a1`.\n     fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId> {\n-        self.resolver.node_id_to_def_id.get(&node).copied()\n+        self.resolver\n+            .node_id_to_def_id\n+            .get(&node)\n+            .map(|local_def_id| self.resolver.get_remapped_def_id(*local_def_id))\n     }\n \n     fn local_def_id(&self, node: NodeId) -> LocalDefId {\n@@ -542,6 +563,27 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         debug_assert!(_old.is_none())\n     }\n \n+    /// Installs the remapping `remap` in scope while `f` is being executed.\n+    /// This causes references to the `LocalDefId` keys to be changed to\n+    /// refer to the values instead.\n+    ///\n+    /// The remapping is used when one piece of AST expands to multiple\n+    /// pieces of HIR. For example, the function `fn foo<'a>(...) -> impl Debug + 'a`,\n+    /// expands to both a function definition (`foo`) and a TAIT for the return value,\n+    /// both of which have a lifetime parameter `'a`. The remapping allows us to\n+    /// rewrite the `'a` in the return value to refer to the\n+    /// `'a` declared on the TAIT, instead of the function.\n+    fn with_remapping<R>(\n+        &mut self,\n+        remap: FxHashMap<LocalDefId, LocalDefId>,\n+        f: impl FnOnce(&mut Self) -> R,\n+    ) -> R {\n+        self.resolver.generics_def_id_map.push(remap);\n+        let res = f(self);\n+        self.resolver.generics_def_id_map.pop();\n+        res\n+    }\n+\n     fn make_owner_info(&mut self, node: hir::OwnerNode<'hir>) -> &'hir hir::OwnerInfo<'hir> {\n         let attrs = std::mem::take(&mut self.attrs);\n         let mut bodies = std::mem::take(&mut self.bodies);\n@@ -751,40 +793,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         })\n     }\n \n-    /// Setup lifetime capture for and impl-trait.\n-    /// The captures will be added to `captures`.\n-    fn while_capturing_lifetimes<T>(\n-        &mut self,\n-        parent_def_id: LocalDefId,\n-        captures: &mut FxHashMap<LocalDefId, (Span, NodeId, ParamName, LifetimeRes)>,\n-        f: impl FnOnce(&mut Self) -> T,\n-    ) -> T {\n-        let lifetime_stash = std::mem::replace(\n-            &mut self.captured_lifetimes,\n-            Some(LifetimeCaptureContext {\n-                parent_def_id,\n-                captures: std::mem::take(captures),\n-                binders_to_ignore: Default::default(),\n-            }),\n-        );\n-\n-        let ret = f(self);\n-\n-        let ctxt = std::mem::replace(&mut self.captured_lifetimes, lifetime_stash).unwrap();\n-        *captures = ctxt.captures;\n-\n-        ret\n-    }\n-\n-    /// Register a binder to be ignored for lifetime capture.\n-    #[tracing::instrument(level = \"debug\", skip(self, f))]\n+    /// Lowers a lifetime binder that defines `generic_params`, returning the corresponding HIR\n+    /// nodes. The returned list includes any \"extra\" lifetime parameters that were added by the\n+    /// name resolver owing to lifetime elision; this also populates the resolver's node-id->def-id\n+    /// map, so that later calls to `opt_node_id_to_def_id` that refer to these extra lifetime\n+    /// parameters will be successful.\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     #[inline]\n-    fn with_lifetime_binder<T>(\n+    fn lower_lifetime_binder(\n         &mut self,\n         binder: NodeId,\n         generic_params: &[GenericParam],\n-        f: impl FnOnce(&mut Self, &'hir [hir::GenericParam<'hir>]) -> T,\n-    ) -> T {\n+    ) -> &'hir [hir::GenericParam<'hir>] {\n         let mut generic_params: Vec<_> = self.lower_generic_params_mut(generic_params).collect();\n         let extra_lifetimes = self.resolver.take_extra_lifetime_params(binder);\n         debug!(?extra_lifetimes);\n@@ -794,14 +814,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let generic_params = self.arena.alloc_from_iter(generic_params);\n         debug!(?generic_params);\n \n-        if let Some(ctxt) = &mut self.captured_lifetimes {\n-            ctxt.binders_to_ignore.insert(binder);\n-        }\n-        let ret = f(self, generic_params);\n-        if let Some(ctxt) = &mut self.captured_lifetimes {\n-            ctxt.binders_to_ignore.remove(&binder);\n-        }\n-        ret\n+        generic_params\n     }\n \n     fn with_dyn_type_scope<T>(&mut self, in_scope: bool, f: impl FnOnce(&mut Self) -> T) -> T {\n@@ -1222,15 +1235,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 hir::TyKind::Rptr(lifetime, self.lower_mt(mt, itctx))\n             }\n             TyKind::BareFn(ref f) => {\n-                self.with_lifetime_binder(t.id, &f.generic_params, |this, generic_params| {\n-                    hir::TyKind::BareFn(this.arena.alloc(hir::BareFnTy {\n-                        generic_params,\n-                        unsafety: this.lower_unsafety(f.unsafety),\n-                        abi: this.lower_extern(f.ext),\n-                        decl: this.lower_fn_decl(&f.decl, None, FnDeclKind::Pointer, None),\n-                        param_names: this.lower_fn_params_to_names(&f.decl),\n-                    }))\n-                })\n+                let generic_params = self.lower_lifetime_binder(t.id, &f.generic_params);\n+                hir::TyKind::BareFn(self.arena.alloc(hir::BareFnTy {\n+                    generic_params,\n+                    unsafety: self.lower_unsafety(f.unsafety),\n+                    abi: self.lower_extern(f.ext),\n+                    decl: self.lower_fn_decl(&f.decl, None, FnDeclKind::Pointer, None),\n+                    param_names: self.lower_fn_params_to_names(&f.decl),\n+                }))\n             }\n             TyKind::Never => hir::TyKind::Never,\n             TyKind::Tup(ref tys) => hir::TyKind::Tup(\n@@ -1293,17 +1305,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             TyKind::ImplTrait(def_node_id, ref bounds) => {\n                 let span = t.span;\n                 match itctx {\n-                    ImplTraitContext::ReturnPositionOpaqueTy { origin } => self\n-                        .lower_opaque_impl_trait(span, origin, def_node_id, |this| {\n-                            this.lower_param_bounds(bounds, itctx)\n-                        }),\n+                    ImplTraitContext::ReturnPositionOpaqueTy { origin } => {\n+                        self.lower_opaque_impl_trait(span, origin, def_node_id, bounds, itctx)\n+                    }\n                     ImplTraitContext::TypeAliasesOpaqueTy => {\n                         let nested_itctx = ImplTraitContext::TypeAliasesOpaqueTy;\n                         self.lower_opaque_impl_trait(\n                             span,\n                             hir::OpaqueTyOrigin::TyAlias,\n                             def_node_id,\n-                            |this| this.lower_param_bounds(bounds, nested_itctx),\n+                            bounds,\n+                            nested_itctx,\n                         )\n                     }\n                     ImplTraitContext::Universal => {\n@@ -1343,13 +1355,43 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         hir::Ty { kind, span: self.lower_span(t.span), hir_id: self.lower_node_id(t.id) }\n     }\n \n-    #[tracing::instrument(level = \"debug\", skip(self, lower_bounds))]\n+    /// Lowers a `ReturnPositionOpaqueTy` (`-> impl Trait`) or a `TypeAliasesOpaqueTy` (`type F =\n+    /// impl Trait`): this creates the associated Opaque Type (TAIT) definition and then returns a\n+    /// HIR type that references the TAIT.\n+    ///\n+    /// Given a function definition like:\n+    ///\n+    /// ```rust\n+    /// fn test<'a, T: Debug>(x: &'a T) -> impl Debug + 'a {\n+    ///     x\n+    /// }\n+    /// ```\n+    ///\n+    /// we will create a TAIT definition in the HIR like\n+    ///\n+    /// ```\n+    /// type TestReturn<'a, T, 'x> = impl Debug + 'x\n+    /// ```\n+    ///\n+    /// and return a type like `TestReturn<'static, T, 'a>`, so that the function looks like:\n+    ///\n+    /// ```rust\n+    /// fn test<'a, T: Debug>(x: &'a T) -> TestReturn<'static, T, 'a>\n+    /// ```\n+    ///\n+    /// Note the subtlety around type parameters! The new TAIT, `TestReturn`, inherits all the\n+    /// type parameters from the function `test` (this is implemented in the query layer, they aren't\n+    /// added explicitly in the HIR). But this includes all the lifetimes, and we only want to\n+    /// capture the lifetimes that are referenced in the bounds. Therefore, we add *extra* lifetime parameters\n+    /// for the lifetimes that get captured (`'x`, in our example above) and reference those.\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     fn lower_opaque_impl_trait(\n         &mut self,\n         span: Span,\n         origin: hir::OpaqueTyOrigin,\n         opaque_ty_node_id: NodeId,\n-        lower_bounds: impl FnOnce(&mut Self) -> hir::GenericBounds<'hir>,\n+        bounds: &GenericBounds,\n+        itctx: ImplTraitContext,\n     ) -> hir::TyKind<'hir> {\n         // Make sure we know that some funky desugaring has been going on here.\n         // This is a first: there is code in other places like for loop\n@@ -1359,70 +1401,108 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let opaque_ty_span = self.mark_span_with_reason(DesugaringKind::OpaqueTy, span, None);\n \n         let opaque_ty_def_id = self.local_def_id(opaque_ty_node_id);\n+        debug!(?opaque_ty_def_id);\n \n-        let mut collected_lifetimes = FxHashMap::default();\n-        self.with_hir_id_owner(opaque_ty_node_id, |lctx| {\n-            let hir_bounds = if origin == hir::OpaqueTyOrigin::TyAlias {\n-                lower_bounds(lctx)\n-            } else {\n-                lctx.while_capturing_lifetimes(\n-                    opaque_ty_def_id,\n-                    &mut collected_lifetimes,\n-                    lower_bounds,\n-                )\n-            };\n-            debug!(?collected_lifetimes);\n+        // Contains the new lifetime definitions created for the TAIT (if any).\n+        let mut collected_lifetimes = Vec::new();\n \n-            let lifetime_defs = lctx.arena.alloc_from_iter(collected_lifetimes.iter().map(\n-                |(_, &(span, p_id, p_name, _))| {\n-                    let hir_id = lctx.lower_node_id(p_id);\n-                    debug_assert_ne!(lctx.opt_local_def_id(p_id), None);\n+        // If this came from a TAIT (as opposed to a function that returns an RPIT), we only want\n+        // to capture the lifetimes that appear in the bounds. So visit the bounds to find out\n+        // exactly which ones those are.\n+        let lifetimes_to_remap = if origin == hir::OpaqueTyOrigin::TyAlias {\n+            // in a TAIT like `type Foo<'a> = impl Foo<'a>`, we don't keep all the lifetime parameters\n+            Vec::new()\n+        } else {\n+            // in fn return position, like the `fn test<'a>() -> impl Debug + 'a` example,\n+            // we only keep the lifetimes that appear in the `impl Debug` itself:\n+            lifetime_collector::lifetimes_in_bounds(&self.resolver, bounds)\n+        };\n+        debug!(?lifetimes_to_remap);\n \n-                    let kind = if p_name.ident().name == kw::UnderscoreLifetime {\n-                        hir::LifetimeParamKind::Elided\n-                    } else {\n-                        hir::LifetimeParamKind::Explicit\n-                    };\n+        self.with_hir_id_owner(opaque_ty_node_id, |lctx| {\n+            let mut new_remapping = FxHashMap::default();\n+\n+            // If this opaque type is only capturing a subset of the lifetimes (those that appear\n+            // in bounds), then create the new lifetime parameters required and create a mapping\n+            // from the old `'a` (on the function) to the new `'a` (on the opaque type).\n+            collected_lifetimes = lctx.create_lifetime_defs(\n+                opaque_ty_def_id,\n+                &lifetimes_to_remap,\n+                &mut new_remapping,\n+            );\n+            debug!(?collected_lifetimes);\n+            debug!(?new_remapping);\n+\n+            // Install the remapping from old to new (if any):\n+            lctx.with_remapping(new_remapping, |lctx| {\n+                // This creates HIR lifetime definitions as `hir::GenericParam`, in the given\n+                // example `type TestReturn<'a, T, 'x> = impl Debug + 'x`, it creates a collection\n+                // containing `&['x]`.\n+                let lifetime_defs = lctx.arena.alloc_from_iter(collected_lifetimes.iter().map(\n+                    |&(new_node_id, lifetime)| {\n+                        let hir_id = lctx.lower_node_id(new_node_id);\n+                        debug_assert_ne!(lctx.opt_local_def_id(new_node_id), None);\n+\n+                        let (name, kind) = if lifetime.ident.name == kw::UnderscoreLifetime {\n+                            (hir::ParamName::Fresh, hir::LifetimeParamKind::Elided)\n+                        } else {\n+                            (\n+                                hir::ParamName::Plain(lifetime.ident),\n+                                hir::LifetimeParamKind::Explicit,\n+                            )\n+                        };\n \n-                    hir::GenericParam {\n-                        hir_id,\n-                        name: p_name,\n-                        span,\n-                        pure_wrt_drop: false,\n-                        kind: hir::GenericParamKind::Lifetime { kind },\n-                        colon_span: None,\n-                    }\n-                },\n-            ));\n-\n-            debug!(\"lower_opaque_impl_trait: lifetime_defs={:#?}\", lifetime_defs);\n-\n-            let opaque_ty_item = hir::OpaqueTy {\n-                generics: self.arena.alloc(hir::Generics {\n-                    params: lifetime_defs,\n-                    predicates: &[],\n-                    has_where_clause_predicates: false,\n-                    where_clause_span: lctx.lower_span(span),\n-                    span: lctx.lower_span(span),\n-                }),\n-                bounds: hir_bounds,\n-                origin,\n-            };\n+                        hir::GenericParam {\n+                            hir_id,\n+                            name,\n+                            span: lifetime.ident.span,\n+                            pure_wrt_drop: false,\n+                            kind: hir::GenericParamKind::Lifetime { kind },\n+                            colon_span: None,\n+                        }\n+                    },\n+                ));\n+                debug!(?lifetime_defs);\n+\n+                // Then when we lower the param bounds, references to 'a are remapped to 'a1, so we\n+                // get back Debug + 'a1, which is suitable for use on the TAIT.\n+                let hir_bounds = lctx.lower_param_bounds(bounds, itctx);\n+                debug!(?hir_bounds);\n+\n+                let opaque_ty_item = hir::OpaqueTy {\n+                    generics: self.arena.alloc(hir::Generics {\n+                        params: lifetime_defs,\n+                        predicates: &[],\n+                        has_where_clause_predicates: false,\n+                        where_clause_span: lctx.lower_span(span),\n+                        span: lctx.lower_span(span),\n+                    }),\n+                    bounds: hir_bounds,\n+                    origin,\n+                };\n+                debug!(?opaque_ty_item);\n \n-            trace!(\"lower_opaque_impl_trait: {:#?}\", opaque_ty_def_id);\n-            lctx.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span)\n+                lctx.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span)\n+            })\n         });\n \n-        let lifetimes = self.arena.alloc_from_iter(collected_lifetimes.into_iter().map(\n-            |(_, (span, _, p_name, res))| {\n+        // This creates HIR lifetime arguments as `hir::GenericArg`, in the given example `type\n+        // TestReturn<'a, T, 'x> = impl Debug + 'x`, it creates a collection containing `&['x]`.\n+        let lifetimes =\n+            self.arena.alloc_from_iter(collected_lifetimes.into_iter().map(|(_, lifetime)| {\n                 let id = self.next_node_id();\n-                let ident = Ident::new(p_name.ident().name, span);\n-                let l = self.new_named_lifetime_with_res(id, span, ident, res);\n-                hir::GenericArg::Lifetime(l)\n-            },\n-        ));\n+                let span = lifetime.ident.span;\n \n-        debug!(\"lower_opaque_impl_trait: lifetimes={:#?}\", lifetimes);\n+                let ident = if lifetime.ident.name == kw::UnderscoreLifetime {\n+                    Ident::with_dummy_span(kw::UnderscoreLifetime)\n+                } else {\n+                    lifetime.ident\n+                };\n+\n+                let l = self.new_named_lifetime(lifetime.id, id, span, ident);\n+                hir::GenericArg::Lifetime(l)\n+            }));\n+        debug!(?lifetimes);\n \n         // `impl Trait` now just becomes `Foo<'a, 'b, ..>`.\n         hir::TyKind::OpaqueDef(hir::ItemId { def_id: opaque_ty_def_id }, lifetimes)\n@@ -1450,6 +1530,70 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         hir::OwnerNode::Item(self.arena.alloc(opaque_ty_item))\n     }\n \n+    /// Given a `parent_def_id`, a list of `lifetimes_in_bounds and a `remapping` hash to be\n+    /// filled, this function creates new definitions for `Param` and `Fresh` lifetimes, inserts the\n+    /// new definition, adds it to the remapping with the definition of the given lifetime and\n+    /// returns a list of lifetimes to be lowered afterwards.\n+    fn create_lifetime_defs(\n+        &mut self,\n+        parent_def_id: LocalDefId,\n+        lifetimes_in_bounds: &[Lifetime],\n+        remapping: &mut FxHashMap<LocalDefId, LocalDefId>,\n+    ) -> Vec<(NodeId, Lifetime)> {\n+        let mut result = Vec::new();\n+\n+        for lifetime in lifetimes_in_bounds {\n+            let res = self.resolver.get_lifetime_res(lifetime.id).unwrap_or(LifetimeRes::Error);\n+            debug!(?res);\n+\n+            match res {\n+                LifetimeRes::Param { param: old_def_id, binder: _ } => {\n+                    if remapping.get(&old_def_id).is_none() {\n+                        let node_id = self.next_node_id();\n+\n+                        let new_def_id = self.create_def(\n+                            parent_def_id,\n+                            node_id,\n+                            DefPathData::LifetimeNs(lifetime.ident.name),\n+                        );\n+                        remapping.insert(old_def_id, new_def_id);\n+\n+                        result.push((node_id, *lifetime));\n+                    }\n+                }\n+\n+                LifetimeRes::Fresh { param, binder: _ } => {\n+                    debug_assert_eq!(lifetime.ident.name, kw::UnderscoreLifetime);\n+                    let old_def_id = self.local_def_id(param);\n+                    if remapping.get(&old_def_id).is_none() {\n+                        let node_id = self.next_node_id();\n+\n+                        let new_def_id = self.create_def(\n+                            parent_def_id,\n+                            node_id,\n+                            DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n+                        );\n+                        remapping.insert(old_def_id, new_def_id);\n+\n+                        result.push((node_id, *lifetime));\n+                    }\n+                }\n+\n+                LifetimeRes::Static | LifetimeRes::Error => {}\n+\n+                res => {\n+                    let bug_msg = format!(\n+                        \"Unexpected lifetime resolution {:?} for {:?} at {:?}\",\n+                        res, lifetime.ident, lifetime.ident.span\n+                    );\n+                    span_bug!(lifetime.ident.span, \"{}\", bug_msg);\n+                }\n+            }\n+        }\n+\n+        result\n+    }\n+\n     fn lower_fn_params_to_names(&mut self, decl: &FnDecl) -> &'hir [Ident] {\n         // Skip the `...` (`CVarArgs`) trailing arguments from the AST,\n         // as they are not explicit in HIR/Ty function signatures.\n@@ -1582,11 +1726,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     //\n     //     type OpaqueTy<generics_from_parent_fn> = impl Future<Output = T>;\n     //\n-    // `inputs`: lowered types of parameters to the function (used to collect lifetimes)\n     // `output`: unlowered output type (`T` in `-> T`)\n     // `fn_def_id`: `DefId` of the parent function (used to create child impl trait definition)\n     // `opaque_ty_node_id`: `NodeId` of the opaque `impl Trait` type that should be created\n-    // `elided_lt_replacement`: replacement for elided lifetimes in the return type\n     #[tracing::instrument(level = \"debug\", skip(self))]\n     fn lower_async_fn_ret_ty(\n         &mut self,\n@@ -1643,90 +1785,126 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // by the opaque type. This should include all in-scope\n         // lifetime parameters, including those defined in-band.\n \n-        let mut captures = FxHashMap::default();\n+        // Contains the new lifetime definitions created for the TAIT (if any) generated for the\n+        // return type.\n+        let mut collected_lifetimes = Vec::new();\n+        let mut new_remapping = FxHashMap::default();\n \n         let extra_lifetime_params = self.resolver.take_extra_lifetime_params(opaque_ty_node_id);\n         debug!(?extra_lifetime_params);\n         for (ident, outer_node_id, outer_res) in extra_lifetime_params {\n-            let Ident { name, span } = ident;\n             let outer_def_id = self.local_def_id(outer_node_id);\n             let inner_node_id = self.next_node_id();\n \n             // Add a definition for the in scope lifetime def.\n-            self.create_def(opaque_ty_def_id, inner_node_id, DefPathData::LifetimeNs(name));\n+            let inner_def_id = self.create_def(\n+                opaque_ty_def_id,\n+                inner_node_id,\n+                DefPathData::LifetimeNs(ident.name),\n+            );\n+            new_remapping.insert(outer_def_id, inner_def_id);\n \n-            let (p_name, inner_res) = match outer_res {\n+            let inner_res = match outer_res {\n                 // Input lifetime like `'a`:\n                 LifetimeRes::Param { param, .. } => {\n-                    (hir::ParamName::Plain(ident), LifetimeRes::Param { param, binder: fn_node_id })\n+                    LifetimeRes::Param { param, binder: fn_node_id }\n                 }\n                 // Input lifetime like `'1`:\n                 LifetimeRes::Fresh { param, .. } => {\n-                    (hir::ParamName::Fresh, LifetimeRes::Fresh { param, binder: fn_node_id })\n+                    LifetimeRes::Fresh { param, binder: fn_node_id }\n                 }\n                 LifetimeRes::Static | LifetimeRes::Error => continue,\n                 res => {\n-                    panic!(\"Unexpected lifetime resolution {:?} for {:?} at {:?}\", res, ident, span)\n+                    panic!(\n+                        \"Unexpected lifetime resolution {:?} for {:?} at {:?}\",\n+                        res, ident, ident.span\n+                    )\n                 }\n             };\n \n-            captures.insert(outer_def_id, (span, inner_node_id, p_name, inner_res));\n+            let lifetime = Lifetime { id: outer_node_id, ident };\n+            collected_lifetimes.push((inner_node_id, lifetime, Some(inner_res)));\n         }\n \n-        debug!(?captures);\n-\n-        self.with_hir_id_owner(opaque_ty_node_id, |this| {\n-            let future_bound =\n-                this.while_capturing_lifetimes(opaque_ty_def_id, &mut captures, |this| {\n-                    // We have to be careful to get elision right here. The\n-                    // idea is that we create a lifetime parameter for each\n-                    // lifetime in the return type.  So, given a return type\n-                    // like `async fn foo(..) -> &[&u32]`, we lower to `impl\n-                    // Future<Output = &'1 [ &'2 u32 ]>`.\n-                    //\n-                    // Then, we will create `fn foo(..) -> Foo<'_, '_>`, and\n-                    // hence the elision takes place at the fn site.\n-                    this.lower_async_fn_output_type_to_future_bound(output, fn_def_id, span)\n-                });\n-            debug!(\"lower_async_fn_ret_ty: future_bound={:#?}\", future_bound);\n-            debug!(\"lower_async_fn_ret_ty: captures={:#?}\", captures);\n+        debug!(?collected_lifetimes);\n \n-            let generic_params =\n-                this.arena.alloc_from_iter(captures.iter().map(|(_, &(span, p_id, p_name, _))| {\n-                    let hir_id = this.lower_node_id(p_id);\n-                    debug_assert_ne!(this.opt_local_def_id(p_id), None);\n+        // We only want to capture the lifetimes that appear in the bounds. So visit the bounds to\n+        // find out exactly which ones those are.\n+        // in fn return position, like the `fn test<'a>() -> impl Debug + 'a` example,\n+        // we only keep the lifetimes that appear in the `impl Debug` itself:\n+        let lifetimes_to_remap = lifetime_collector::lifetimes_in_ret_ty(&self.resolver, output);\n+        debug!(?lifetimes_to_remap);\n \n-                    let kind = if p_name.ident().name == kw::UnderscoreLifetime {\n-                        hir::LifetimeParamKind::Elided\n-                    } else {\n-                        hir::LifetimeParamKind::Explicit\n-                    };\n+        self.with_hir_id_owner(opaque_ty_node_id, |this| {\n+            // If this opaque type is only capturing a subset of the lifetimes (those that appear\n+            // in bounds), then create the new lifetime parameters required and create a mapping\n+            // from the old `'a` (on the function) to the new `'a` (on the opaque type).\n+            collected_lifetimes.extend(\n+                this.create_lifetime_defs(\n+                    opaque_ty_def_id,\n+                    &lifetimes_to_remap,\n+                    &mut new_remapping,\n+                )\n+                .into_iter()\n+                .map(|(new_node_id, lifetime)| (new_node_id, lifetime, None)),\n+            );\n+            debug!(?collected_lifetimes);\n+            debug!(?new_remapping);\n+\n+            // Install the remapping from old to new (if any):\n+            this.with_remapping(new_remapping, |this| {\n+                // We have to be careful to get elision right here. The\n+                // idea is that we create a lifetime parameter for each\n+                // lifetime in the return type.  So, given a return type\n+                // like `async fn foo(..) -> &[&u32]`, we lower to `impl\n+                // Future<Output = &'1 [ &'2 u32 ]>`.\n+                //\n+                // Then, we will create `fn foo(..) -> Foo<'_, '_>`, and\n+                // hence the elision takes place at the fn site.\n+                let future_bound =\n+                    this.lower_async_fn_output_type_to_future_bound(output, fn_def_id, span);\n+\n+                let generic_params = this.arena.alloc_from_iter(collected_lifetimes.iter().map(\n+                    |&(new_node_id, lifetime, _)| {\n+                        let hir_id = this.lower_node_id(new_node_id);\n+                        debug_assert_ne!(this.opt_local_def_id(new_node_id), None);\n+\n+                        let (name, kind) = if lifetime.ident.name == kw::UnderscoreLifetime {\n+                            (hir::ParamName::Fresh, hir::LifetimeParamKind::Elided)\n+                        } else {\n+                            (\n+                                hir::ParamName::Plain(lifetime.ident),\n+                                hir::LifetimeParamKind::Explicit,\n+                            )\n+                        };\n \n-                    hir::GenericParam {\n-                        hir_id,\n-                        name: p_name,\n-                        span,\n-                        pure_wrt_drop: false,\n-                        kind: hir::GenericParamKind::Lifetime { kind },\n-                        colon_span: None,\n-                    }\n-                }));\n-            debug!(\"lower_async_fn_ret_ty: generic_params={:#?}\", generic_params);\n-\n-            let opaque_ty_item = hir::OpaqueTy {\n-                generics: this.arena.alloc(hir::Generics {\n-                    params: generic_params,\n-                    predicates: &[],\n-                    has_where_clause_predicates: false,\n-                    where_clause_span: this.lower_span(span),\n-                    span: this.lower_span(span),\n-                }),\n-                bounds: arena_vec![this; future_bound],\n-                origin: hir::OpaqueTyOrigin::AsyncFn(fn_def_id),\n-            };\n+                        hir::GenericParam {\n+                            hir_id,\n+                            name,\n+                            span: lifetime.ident.span,\n+                            pure_wrt_drop: false,\n+                            kind: hir::GenericParamKind::Lifetime { kind },\n+                            colon_span: None,\n+                        }\n+                    },\n+                ));\n+                debug!(\"lower_async_fn_ret_ty: generic_params={:#?}\", generic_params);\n+\n+                let opaque_ty_item = hir::OpaqueTy {\n+                    generics: this.arena.alloc(hir::Generics {\n+                        params: generic_params,\n+                        predicates: &[],\n+                        has_where_clause_predicates: false,\n+                        where_clause_span: this.lower_span(span),\n+                        span: this.lower_span(span),\n+                    }),\n+                    bounds: arena_vec![this; future_bound],\n+                    origin: hir::OpaqueTyOrigin::AsyncFn(fn_def_id),\n+                };\n \n-            trace!(\"exist ty from async fn def id: {:#?}\", opaque_ty_def_id);\n-            this.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span)\n+                trace!(\"exist ty from async fn def id: {:#?}\", opaque_ty_def_id);\n+                this.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span)\n+            })\n         });\n \n         // As documented above, we need to create the lifetime\n@@ -1744,13 +1922,24 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         //\n         // For the \"output\" lifetime parameters, we just want to\n         // generate `'_`.\n-        let generic_args =\n-            self.arena.alloc_from_iter(captures.into_iter().map(|(_, (span, _, p_name, res))| {\n+        let generic_args = self.arena.alloc_from_iter(collected_lifetimes.into_iter().map(\n+            |(_, lifetime, res)| {\n                 let id = self.next_node_id();\n-                let ident = Ident::new(p_name.ident().name, span);\n+                let span = lifetime.ident.span;\n+\n+                let ident = if lifetime.ident.name == kw::UnderscoreLifetime {\n+                    Ident::with_dummy_span(kw::UnderscoreLifetime)\n+                } else {\n+                    lifetime.ident\n+                };\n+\n+                let res = res.unwrap_or(\n+                    self.resolver.get_lifetime_res(lifetime.id).unwrap_or(LifetimeRes::Error),\n+                );\n                 let l = self.new_named_lifetime_with_res(id, span, ident, res);\n                 hir::GenericArg::Lifetime(l)\n-            }));\n+            },\n+        ));\n \n         // Create the `Foo<...>` reference itself. Note that the `type\n         // Foo = impl Trait` is, internally, created as a child of the\n@@ -1820,8 +2009,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_lifetime(&mut self, l: &Lifetime) -> hir::Lifetime {\n         let span = self.lower_span(l.ident.span);\n         let ident = self.lower_ident(l.ident);\n-        let res = self.resolver.get_lifetime_res(l.id).unwrap_or(LifetimeRes::Error);\n-        self.new_named_lifetime_with_res(l.id, span, ident, res)\n+        self.new_named_lifetime(l.id, l.id, span, ident)\n     }\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n@@ -1832,67 +2020,41 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         ident: Ident,\n         res: LifetimeRes,\n     ) -> hir::Lifetime {\n-        debug!(?self.captured_lifetimes);\n         let name = match res {\n-            LifetimeRes::Param { mut param, binder } => {\n+            LifetimeRes::Param { param, .. } => {\n                 let p_name = ParamName::Plain(ident);\n-                if let Some(mut captured_lifetimes) = self.captured_lifetimes.take() {\n-                    if !captured_lifetimes.binders_to_ignore.contains(&binder) {\n-                        match captured_lifetimes.captures.entry(param) {\n-                            Entry::Occupied(o) => param = self.local_def_id(o.get().1),\n-                            Entry::Vacant(v) => {\n-                                let p_id = self.next_node_id();\n-                                let p_def_id = self.create_def(\n-                                    captured_lifetimes.parent_def_id,\n-                                    p_id,\n-                                    DefPathData::LifetimeNs(p_name.ident().name),\n-                                );\n-\n-                                v.insert((span, p_id, p_name, res));\n-                                param = p_def_id;\n-                            }\n-                        }\n-                    }\n+                let param = self.resolver.get_remapped_def_id(param);\n \n-                    self.captured_lifetimes = Some(captured_lifetimes);\n-                }\n                 hir::LifetimeName::Param(param, p_name)\n             }\n-            LifetimeRes::Fresh { param, binder } => {\n+            LifetimeRes::Fresh { param, .. } => {\n                 debug_assert_eq!(ident.name, kw::UnderscoreLifetime);\n-                let mut param = self.local_def_id(param);\n-                if let Some(mut captured_lifetimes) = self.captured_lifetimes.take() {\n-                    if !captured_lifetimes.binders_to_ignore.contains(&binder) {\n-                        match captured_lifetimes.captures.entry(param) {\n-                            Entry::Occupied(o) => param = self.local_def_id(o.get().1),\n-                            Entry::Vacant(v) => {\n-                                let p_id = self.next_node_id();\n-                                let p_def_id = self.create_def(\n-                                    captured_lifetimes.parent_def_id,\n-                                    p_id,\n-                                    DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n-                                );\n-\n-                                v.insert((span, p_id, ParamName::Fresh, res));\n-                                param = p_def_id;\n-                            }\n-                        }\n-                    }\n+                let param = self.local_def_id(param);\n \n-                    self.captured_lifetimes = Some(captured_lifetimes);\n-                }\n                 hir::LifetimeName::Param(param, ParamName::Fresh)\n             }\n             LifetimeRes::Infer => hir::LifetimeName::Infer,\n             LifetimeRes::Static => hir::LifetimeName::Static,\n             LifetimeRes::Error => hir::LifetimeName::Error,\n             res => panic!(\"Unexpected lifetime resolution {:?} for {:?} at {:?}\", res, ident, span),\n         };\n-        debug!(?self.captured_lifetimes);\n+\n         debug!(?name);\n         hir::Lifetime { hir_id: self.lower_node_id(id), span: self.lower_span(span), name }\n     }\n \n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    fn new_named_lifetime(\n+        &mut self,\n+        id: NodeId,\n+        new_id: NodeId,\n+        span: Span,\n+        ident: Ident,\n+    ) -> hir::Lifetime {\n+        let res = self.resolver.get_lifetime_res(id).unwrap_or(LifetimeRes::Error);\n+        self.new_named_lifetime_with_res(new_id, span, ident, res)\n+    }\n+\n     fn lower_generic_params_mut<'s>(\n         &'s mut self,\n         params: &'s [GenericParam],\n@@ -1975,14 +2137,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         p: &PolyTraitRef,\n         itctx: ImplTraitContext,\n     ) -> hir::PolyTraitRef<'hir> {\n-        self.with_lifetime_binder(\n-            p.trait_ref.ref_id,\n-            &p.bound_generic_params,\n-            |this, bound_generic_params| {\n-                let trait_ref = this.lower_trait_ref(&p.trait_ref, itctx);\n-                hir::PolyTraitRef { bound_generic_params, trait_ref, span: this.lower_span(p.span) }\n-            },\n-        )\n+        let bound_generic_params =\n+            self.lower_lifetime_binder(p.trait_ref.ref_id, &p.bound_generic_params);\n+        let trait_ref = self.lower_trait_ref(&p.trait_ref, itctx);\n+        hir::PolyTraitRef { bound_generic_params, trait_ref, span: self.lower_span(p.span) }\n     }\n \n     fn lower_mt(&mut self, mt: &MutTy, itctx: ImplTraitContext) -> hir::MutTy<'hir> {\n@@ -2015,7 +2173,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // Add a definition for the in-band `Param`.\n         let def_id = self.local_def_id(node_id);\n \n-        let hir_bounds = self.lower_param_bounds(bounds, ImplTraitContext::Universal);\n         // Set the name to `impl Bound1 + Bound2`.\n         let param = hir::GenericParam {\n             hir_id: self.lower_node_id(node_id),\n@@ -2030,7 +2187,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             ident,\n             node_id,\n             &GenericParamKind::Type { default: None },\n-            hir_bounds,\n+            bounds,\n+            ImplTraitContext::Universal,\n             hir::PredicateOrigin::ImplTrait,\n         );\n "}, {"sha": "81006e00fd4e51c8fb627510166c6b1678bed3f8", "filename": "compiler/rustc_ast_lowering/src/lifetime_collector.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/cdfd675a63090182fd1c5f2ff58d8eaa115da156/compiler%2Frustc_ast_lowering%2Fsrc%2Flifetime_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfd675a63090182fd1c5f2ff58d8eaa115da156/compiler%2Frustc_ast_lowering%2Fsrc%2Flifetime_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flifetime_collector.rs?ref=cdfd675a63090182fd1c5f2ff58d8eaa115da156", "patch": "@@ -0,0 +1,115 @@\n+use super::ResolverAstLoweringExt;\n+use rustc_ast::visit::{self, BoundKind, LifetimeCtxt, Visitor};\n+use rustc_ast::{\n+    FnRetTy, GenericBounds, Lifetime, NodeId, PathSegment, PolyTraitRef, TraitBoundModifier, Ty,\n+    TyKind,\n+};\n+use rustc_hir::def::LifetimeRes;\n+use rustc_middle::span_bug;\n+use rustc_middle::ty::ResolverAstLowering;\n+use rustc_span::symbol::{kw, Ident};\n+use rustc_span::Span;\n+\n+struct LifetimeCollectVisitor<'ast> {\n+    resolver: &'ast ResolverAstLowering,\n+    current_binders: Vec<NodeId>,\n+    collected_lifetimes: Vec<Lifetime>,\n+}\n+\n+impl<'ast> LifetimeCollectVisitor<'ast> {\n+    fn new(resolver: &'ast ResolverAstLowering) -> Self {\n+        Self { resolver, current_binders: Vec::new(), collected_lifetimes: Vec::new() }\n+    }\n+\n+    fn record_lifetime_use(&mut self, lifetime: Lifetime) {\n+        match self.resolver.get_lifetime_res(lifetime.id).unwrap_or(LifetimeRes::Error) {\n+            LifetimeRes::Param { binder, .. } | LifetimeRes::Fresh { binder, .. } => {\n+                if !self.current_binders.contains(&binder) {\n+                    if !self.collected_lifetimes.contains(&lifetime) {\n+                        self.collected_lifetimes.push(lifetime);\n+                    }\n+                }\n+            }\n+            LifetimeRes::Static | LifetimeRes::Error => {\n+                if !self.collected_lifetimes.contains(&lifetime) {\n+                    self.collected_lifetimes.push(lifetime);\n+                }\n+            }\n+            LifetimeRes::Infer => {}\n+            res => {\n+                let bug_msg = format!(\n+                    \"Unexpected lifetime resolution {:?} for {:?} at {:?}\",\n+                    res, lifetime.ident, lifetime.ident.span\n+                );\n+                span_bug!(lifetime.ident.span, \"{}\", bug_msg);\n+            }\n+        }\n+    }\n+\n+    /// This collect lifetimes that are elided, for nodes like `Foo<T>` where there are no explicit\n+    /// lifetime nodes. Is equivalent to having \"pseudo\" nodes introduced for each of the node ids\n+    /// in the list start..end.\n+    fn record_elided_anchor(&mut self, node_id: NodeId, span: Span) {\n+        if let Some(LifetimeRes::ElidedAnchor { start, end }) =\n+            self.resolver.get_lifetime_res(node_id)\n+        {\n+            for i in start..end {\n+                let lifetime = Lifetime { id: i, ident: Ident::new(kw::UnderscoreLifetime, span) };\n+                self.record_lifetime_use(lifetime);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'ast> Visitor<'ast> for LifetimeCollectVisitor<'ast> {\n+    fn visit_lifetime(&mut self, lifetime: &'ast Lifetime, _: LifetimeCtxt) {\n+        self.record_lifetime_use(*lifetime);\n+    }\n+\n+    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'ast PathSegment) {\n+        self.record_elided_anchor(path_segment.id, path_span);\n+        visit::walk_path_segment(self, path_span, path_segment);\n+    }\n+\n+    fn visit_poly_trait_ref(&mut self, t: &'ast PolyTraitRef, m: &'ast TraitBoundModifier) {\n+        self.current_binders.push(t.trait_ref.ref_id);\n+\n+        visit::walk_poly_trait_ref(self, t, m);\n+\n+        self.current_binders.pop();\n+    }\n+\n+    fn visit_ty(&mut self, t: &'ast Ty) {\n+        match t.kind {\n+            TyKind::BareFn(_) => {\n+                self.current_binders.push(t.id);\n+                visit::walk_ty(self, t);\n+                self.current_binders.pop();\n+            }\n+            TyKind::Rptr(None, _) => {\n+                self.record_elided_anchor(t.id, t.span);\n+                visit::walk_ty(self, t);\n+            }\n+            _ => {\n+                visit::walk_ty(self, t);\n+            }\n+        }\n+    }\n+}\n+\n+pub fn lifetimes_in_ret_ty(resolver: &ResolverAstLowering, ret_ty: &FnRetTy) -> Vec<Lifetime> {\n+    let mut visitor = LifetimeCollectVisitor::new(resolver);\n+    visitor.visit_fn_ret_ty(ret_ty);\n+    visitor.collected_lifetimes\n+}\n+\n+pub fn lifetimes_in_bounds(\n+    resolver: &ResolverAstLowering,\n+    bounds: &GenericBounds,\n+) -> Vec<Lifetime> {\n+    let mut visitor = LifetimeCollectVisitor::new(resolver);\n+    for bound in bounds {\n+        visitor.visit_param_bound(bound, BoundKind::Bound);\n+    }\n+    visitor.collected_lifetimes\n+}"}, {"sha": "02da02568d7e525d535445eecbc5f52401ecbdba", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cdfd675a63090182fd1c5f2ff58d8eaa115da156/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfd675a63090182fd1c5f2ff58d8eaa115da156/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=cdfd675a63090182fd1c5f2ff58d8eaa115da156", "patch": "@@ -177,6 +177,11 @@ pub struct ResolverAstLowering {\n     pub label_res_map: NodeMap<ast::NodeId>,\n     /// Resolutions for lifetimes.\n     pub lifetimes_res_map: NodeMap<LifetimeRes>,\n+    /// Mapping from generics `def_id`s to TAIT generics `def_id`s.\n+    /// For each captured lifetime (e.g., 'a), we create a new lifetime parameter that is a generic\n+    /// defined on the TAIT, so we have type Foo<'a1> = ... and we establish a mapping in this\n+    /// field from the original parameter 'a to the new parameter 'a1.\n+    pub generics_def_id_map: Vec<FxHashMap<LocalDefId, LocalDefId>>,\n     /// Lifetime parameters that lowering will have to introduce.\n     pub extra_lifetime_params_map: NodeMap<Vec<(Ident, ast::NodeId, LifetimeRes)>>,\n "}, {"sha": "ef3c3da89c572b6b24b3766ff1db0c68d519d7c5", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cdfd675a63090182fd1c5f2ff58d8eaa115da156/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfd675a63090182fd1c5f2ff58d8eaa115da156/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=cdfd675a63090182fd1c5f2ff58d8eaa115da156", "patch": "@@ -913,6 +913,11 @@ pub struct Resolver<'a> {\n     label_res_map: NodeMap<NodeId>,\n     /// Resolutions for lifetimes.\n     lifetimes_res_map: NodeMap<LifetimeRes>,\n+    /// Mapping from generics `def_id`s to TAIT generics `def_id`s.\n+    /// For each captured lifetime (e.g., 'a), we create a new lifetime parameter that is a generic\n+    /// defined on the TAIT, so we have type Foo<'a1> = ... and we establish a mapping in this\n+    /// field from the original parameter 'a to the new parameter 'a1.\n+    generics_def_id_map: Vec<FxHashMap<LocalDefId, LocalDefId>>,\n     /// Lifetime parameters that lowering will have to introduce.\n     extra_lifetime_params_map: NodeMap<Vec<(Ident, NodeId, LifetimeRes)>>,\n \n@@ -1277,6 +1282,7 @@ impl<'a> Resolver<'a> {\n             import_res_map: Default::default(),\n             label_res_map: Default::default(),\n             lifetimes_res_map: Default::default(),\n+            generics_def_id_map: Vec::new(),\n             extra_lifetime_params_map: Default::default(),\n             extern_crate_map: Default::default(),\n             reexport_map: FxHashMap::default(),\n@@ -1444,6 +1450,7 @@ impl<'a> Resolver<'a> {\n             import_res_map: self.import_res_map,\n             label_res_map: self.label_res_map,\n             lifetimes_res_map: self.lifetimes_res_map,\n+            generics_def_id_map: self.generics_def_id_map,\n             extra_lifetime_params_map: self.extra_lifetime_params_map,\n             next_node_id: self.next_node_id,\n             node_id_to_def_id: self.node_id_to_def_id,\n@@ -1488,6 +1495,7 @@ impl<'a> Resolver<'a> {\n             import_res_map: self.import_res_map.clone(),\n             label_res_map: self.label_res_map.clone(),\n             lifetimes_res_map: self.lifetimes_res_map.clone(),\n+            generics_def_id_map: self.generics_def_id_map.clone(),\n             extra_lifetime_params_map: self.extra_lifetime_params_map.clone(),\n             next_node_id: self.next_node_id.clone(),\n             node_id_to_def_id: self.node_id_to_def_id.clone(),"}, {"sha": "a4e603de1ac24c50221deb0e20fb37ff21ff9c04", "filename": "src/test/ui/impl-trait/rpit-assoc-pair-with-lifetime.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cdfd675a63090182fd1c5f2ff58d8eaa115da156/src%2Ftest%2Fui%2Fimpl-trait%2Frpit-assoc-pair-with-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfd675a63090182fd1c5f2ff58d8eaa115da156/src%2Ftest%2Fui%2Fimpl-trait%2Frpit-assoc-pair-with-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frpit-assoc-pair-with-lifetime.rs?ref=cdfd675a63090182fd1c5f2ff58d8eaa115da156", "patch": "@@ -0,0 +1,7 @@\n+// check-pass\n+\n+pub fn iter<'a>(v: Vec<(u32, &'a u32)>) -> impl DoubleEndedIterator<Item = (u32, &u32)> {\n+    v.into_iter()\n+}\n+\n+fn main() {}"}]}