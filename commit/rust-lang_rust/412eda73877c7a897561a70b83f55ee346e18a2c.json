{"sha": "412eda73877c7a897561a70b83f55ee346e18a2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxMmVkYTczODc3YzdhODk3NTYxYTcwYjgzZjU1ZWUzNDZlMThhMmM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-09T08:08:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-09T08:08:55Z"}, "message": "Merge #3880\n\n3880: Add support for attributes for struct fields r=matklad a=bnjjj\n\nHello I try to solve this example:\r\n```rust\r\nstruct MyStruct {\r\n    my_val: usize,\r\n    #[cfg(feature = \"foo\")]\r\n    bar: bool,\r\n}\r\nimpl MyStruct {\r\n    #[cfg(feature = \"foo\")]\r\n    pub(crate) fn new(my_val: usize, bar: bool) -> Self {\r\n        Self { my_val, bar }\r\n    }\r\n    #[cfg(not(feature = \"foo\"))]\r\n    pub(crate) fn new(my_val: usize, _bar: bool) -> Self {\r\n        Self { my_val }\r\n    }\r\n}\r\n```\r\n\r\nHere is a draft PR to try to solve this issue. In fact for now when i have this kind of example, rust-analyzer tells me that my second Self {} miss the bar field. Which is a bug.\r\n\r\nI have some difficulties to add this features. Here in my draft I share my work about adding attributes support on struct field data. But I'm stuck when I have to fetch attributes from parent expressions. I don't really know how to do that. For the first iteration I just want to solve my issue without solving on all different expressions. And then after I will try to implement that on different kind of expression. I think I have to fetch my FunctionId and then I will be able to find attributes with myFunction.attrs() But I don't know if it's the right way.\r\n\r\n@matklad (or anyone else) if you can help me it would be great :D \n\nCo-authored-by: Benjamin Coenen <5719034+bnjjj@users.noreply.github.com>", "tree": {"sha": "b30c91efe4050087f1935d477db4612357a2665a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b30c91efe4050087f1935d477db4612357a2665a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/412eda73877c7a897561a70b83f55ee346e18a2c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJejtgXCRBK7hj4Ov3rIwAAdHIIAFIsFlWWOL2rH1s/9wv53btM\nJZ3nxE5ZCT6NXilyV5SUI1Gtw6a5oraTYyV/vTxAhn4j04u4uBNWKHo1NW7GYcYL\nFaDFP/tJsACiHEbYOXo6Dm391PYi/0RolBTPPHlnk/ieATgy9+8OEE54bEDgwwk0\nSDDykyrItoI7pR/T8A3aRUDAn25g1m5BsNZWIgKk5tbZYGYTRlMoILg5oQXkBrdd\nSa5n1ijMPqrA8aHtup2cLO+J1lv37vM5cYZH/qarEKkIKF2/3U8Yf2fFDo3jwkkr\nqrxZGh6ipRewWo8DEXeYP9H7mgSFLyt59wcJNYHXmsTNeMCASjFQ/A8pIXk8YsE=\n=1284\n-----END PGP SIGNATURE-----\n", "payload": "tree b30c91efe4050087f1935d477db4612357a2665a\nparent 01e5bd50f30ae22abab0733468d1e1c6dea7d506\nparent 585bb83e2aec9c79dae8c2e031e9165f40937003\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1586419735 +0000\ncommitter GitHub <noreply@github.com> 1586419735 +0000\n\nMerge #3880\n\n3880: Add support for attributes for struct fields r=matklad a=bnjjj\n\nHello I try to solve this example:\r\n```rust\r\nstruct MyStruct {\r\n    my_val: usize,\r\n    #[cfg(feature = \"foo\")]\r\n    bar: bool,\r\n}\r\nimpl MyStruct {\r\n    #[cfg(feature = \"foo\")]\r\n    pub(crate) fn new(my_val: usize, bar: bool) -> Self {\r\n        Self { my_val, bar }\r\n    }\r\n    #[cfg(not(feature = \"foo\"))]\r\n    pub(crate) fn new(my_val: usize, _bar: bool) -> Self {\r\n        Self { my_val }\r\n    }\r\n}\r\n```\r\n\r\nHere is a draft PR to try to solve this issue. In fact for now when i have this kind of example, rust-analyzer tells me that my second Self {} miss the bar field. Which is a bug.\r\n\r\nI have some difficulties to add this features. Here in my draft I share my work about adding attributes support on struct field data. But I'm stuck when I have to fetch attributes from parent expressions. I don't really know how to do that. For the first iteration I just want to solve my issue without solving on all different expressions. And then after I will try to implement that on different kind of expression. I think I have to fetch my FunctionId and then I will be able to find attributes with myFunction.attrs() But I don't know if it's the right way.\r\n\r\n@matklad (or anyone else) if you can help me it would be great :D \n\nCo-authored-by: Benjamin Coenen <5719034+bnjjj@users.noreply.github.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/412eda73877c7a897561a70b83f55ee346e18a2c", "html_url": "https://github.com/rust-lang/rust/commit/412eda73877c7a897561a70b83f55ee346e18a2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/412eda73877c7a897561a70b83f55ee346e18a2c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01e5bd50f30ae22abab0733468d1e1c6dea7d506", "url": "https://api.github.com/repos/rust-lang/rust/commits/01e5bd50f30ae22abab0733468d1e1c6dea7d506", "html_url": "https://github.com/rust-lang/rust/commit/01e5bd50f30ae22abab0733468d1e1c6dea7d506"}, {"sha": "585bb83e2aec9c79dae8c2e031e9165f40937003", "url": "https://api.github.com/repos/rust-lang/rust/commits/585bb83e2aec9c79dae8c2e031e9165f40937003", "html_url": "https://github.com/rust-lang/rust/commit/585bb83e2aec9c79dae8c2e031e9165f40937003"}], "stats": {"total": 65, "additions": 58, "deletions": 7}, "files": [{"sha": "7fc4cd76e1a58b14043aaf23213725707c5862b8", "filename": "crates/ra_hir_def/src/adt.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/412eda73877c7a897561a70b83f55ee346e18a2c/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412eda73877c7a897561a70b83f55ee346e18a2c/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fadt.rs?ref=412eda73877c7a897561a70b83f55ee346e18a2c", "patch": "@@ -54,6 +54,7 @@ pub struct StructFieldData {\n impl StructData {\n     pub(crate) fn struct_data_query(db: &dyn DefDatabase, id: StructId) -> Arc<StructData> {\n         let src = id.lookup(db).source(db);\n+\n         let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n         let variant_data = VariantData::new(db, src.map(|s| s.kind()));\n         let variant_data = Arc::new(variant_data);"}, {"sha": "606ec48b084382f693033aff7733cd9a47e4f547", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/412eda73877c7a897561a70b83f55ee346e18a2c/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412eda73877c7a897561a70b83f55ee346e18a2c/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=412eda73877c7a897561a70b83f55ee346e18a2c", "patch": "@@ -3,15 +3,18 @@\n use std::sync::Arc;\n \n use hir_expand::{\n+    hygiene::Hygiene,\n     name::{name, AsName, Name},\n     AstId, InFile,\n };\n+use ra_cfg::CfgOptions;\n use ra_prof::profile;\n use ra_syntax::ast::{\n     self, AstNode, ImplItem, ModuleItemOwner, NameOwner, TypeAscriptionOwner, VisibilityOwner,\n };\n \n use crate::{\n+    attr::Attrs,\n     db::DefDatabase,\n     path::{path, GenericArgs, Path},\n     src::HasSource,\n@@ -26,6 +29,7 @@ pub struct FunctionData {\n     pub name: Name,\n     pub params: Vec<TypeRef>,\n     pub ret_type: TypeRef,\n+    pub attrs: Attrs,\n     /// True if the first param is `self`. This is relevant to decide whether this\n     /// can be called as a method.\n     pub has_self_param: bool,\n@@ -63,6 +67,8 @@ impl FunctionData {\n                 params.push(type_ref);\n             }\n         }\n+        let attrs = Attrs::new(&src.value, &Hygiene::new(db.upcast(), src.file_id));\n+\n         let ret_type = if let Some(type_ref) = src.value.ret_type().and_then(|rt| rt.type_ref()) {\n             TypeRef::from_ast(type_ref)\n         } else {\n@@ -81,7 +87,7 @@ impl FunctionData {\n         let visibility =\n             RawVisibility::from_ast_with_default(db, vis_default, src.map(|s| s.visibility()));\n \n-        let sig = FunctionData { name, params, ret_type, has_self_param, visibility };\n+        let sig = FunctionData { name, params, ret_type, has_self_param, visibility, attrs };\n         Arc::new(sig)\n     }\n }\n@@ -211,6 +217,7 @@ impl ImplData {\n         let module_id = impl_loc.container.module(db);\n \n         let mut items = Vec::new();\n+\n         if let Some(item_list) = src.value.item_list() {\n             items.extend(collect_impl_items(db, item_list.impl_items(), src.file_id, id));\n             items.extend(collect_impl_items_in_macros(\n@@ -311,39 +318,53 @@ fn collect_impl_items_in_macro(\n     }\n }\n \n+fn is_cfg_enabled(cfg_options: &CfgOptions, attrs: &Attrs) -> bool {\n+    attrs.by_key(\"cfg\").tt_values().all(|tt| cfg_options.is_cfg_enabled(tt) != Some(false))\n+}\n+\n fn collect_impl_items(\n     db: &dyn DefDatabase,\n     impl_items: impl Iterator<Item = ImplItem>,\n     file_id: crate::HirFileId,\n     id: ImplId,\n ) -> Vec<AssocItemId> {\n     let items = db.ast_id_map(file_id);\n+    let crate_graph = db.crate_graph();\n+    let module_id = id.lookup(db).container.module(db);\n \n     impl_items\n-        .map(|item_node| match item_node {\n+        .filter_map(|item_node| match item_node {\n             ast::ImplItem::FnDef(it) => {\n                 let def = FunctionLoc {\n                     container: AssocContainerId::ImplId(id),\n                     ast_id: AstId::new(file_id, items.ast_id(&it)),\n                 }\n                 .intern(db);\n-                def.into()\n+\n+                if !is_cfg_enabled(\n+                    &crate_graph[module_id.krate].cfg_options,\n+                    &db.function_data(def).attrs,\n+                ) {\n+                    None\n+                } else {\n+                    Some(def.into())\n+                }\n             }\n             ast::ImplItem::ConstDef(it) => {\n                 let def = ConstLoc {\n                     container: AssocContainerId::ImplId(id),\n                     ast_id: AstId::new(file_id, items.ast_id(&it)),\n                 }\n                 .intern(db);\n-                def.into()\n+                Some(def.into())\n             }\n             ast::ImplItem::TypeAliasDef(it) => {\n                 let def = TypeAliasLoc {\n                     container: AssocContainerId::ImplId(id),\n                     ast_id: AstId::new(file_id, items.ast_id(&it)),\n                 }\n                 .intern(db);\n-                def.into()\n+                Some(def.into())\n             }\n         })\n         .collect()"}, {"sha": "e45e9ea14d7a0273583bacc9b63de789b84e203b", "filename": "crates/ra_hir_ty/src/expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/412eda73877c7a897561a70b83f55ee346e18a2c/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412eda73877c7a897561a70b83f55ee346e18a2c/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs?ref=412eda73877c7a897561a70b83f55ee346e18a2c", "patch": "@@ -4,8 +4,7 @@ use std::sync::Arc;\n \n use hir_def::{path::path, resolver::HasResolver, AdtId, FunctionId};\n use hir_expand::diagnostics::DiagnosticSink;\n-use ra_syntax::ast;\n-use ra_syntax::AstPtr;\n+use ra_syntax::{ast, AstPtr};\n use rustc_hash::FxHashSet;\n \n use crate::{"}, {"sha": "608408d88c2011c4c3c4ce289b30c50d17d7f947", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/412eda73877c7a897561a70b83f55ee346e18a2c/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/412eda73877c7a897561a70b83f55ee346e18a2c/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=412eda73877c7a897561a70b83f55ee346e18a2c", "patch": "@@ -319,3 +319,33 @@ fn no_such_field_diagnostics() {\n     \"###\n     );\n }\n+\n+#[test]\n+fn no_such_field_with_feature_flag_diagnostics() {\n+    let diagnostics = TestDB::with_files(\n+        r#\"\n+        //- /lib.rs crate:foo cfg:feature=foo\n+        struct MyStruct {\n+            my_val: usize,\n+            #[cfg(feature = \"foo\")]\n+            bar: bool,\n+        }\n+\n+        impl MyStruct {\n+            #[cfg(feature = \"foo\")]\n+            pub(crate) fn new(my_val: usize, bar: bool) -> Self {\n+                Self { my_val, bar }\n+            }\n+\n+            #[cfg(not(feature = \"foo\"))]\n+            pub(crate) fn new(my_val: usize, _bar: bool) -> Self {\n+                Self { my_val }\n+            }\n+        }\n+        \"#,\n+    )\n+    .diagnostics()\n+    .0;\n+\n+    assert_snapshot!(diagnostics, @r###\"\"###);\n+}"}]}