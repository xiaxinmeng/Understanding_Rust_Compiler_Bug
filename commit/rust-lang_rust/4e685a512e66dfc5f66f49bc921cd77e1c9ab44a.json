{"sha": "4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlNjg1YTUxMmU2NmRmYzVmNjZmNDliYzkyMWNkNzdlMWM5YWI0NGE=", "commit": {"author": {"name": "CohenArthur", "email": "arthur.cohen@epita.fr", "date": "2020-08-28T10:10:48Z"}, "committer": {"name": "CohenArthur", "email": "arthur.cohen@epita.fr", "date": "2020-08-28T10:10:48Z"}, "message": "fmt: Run cargo fmt since it is available", "tree": {"sha": "f676288bc3362bcc963cf8d2b4e00bcf5014681b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f676288bc3362bcc963cf8d2b4e00bcf5014681b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "html_url": "https://github.com/rust-lang/rust/commit/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5dec38e94c0c9948ba578ae83ab94ecf4a0edb0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dec38e94c0c9948ba578ae83ab94ecf4a0edb0a", "html_url": "https://github.com/rust-lang/rust/commit/5dec38e94c0c9948ba578ae83ab94ecf4a0edb0a"}], "stats": {"total": 2371, "additions": 1575, "deletions": 796}, "files": [{"sha": "5d1a6c6ade50cba8dbed728365c4fa9c84ddb704", "filename": "src/abi/comments.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fcomments.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -80,7 +80,10 @@ pub(super) fn add_local_place_comments<'tcx>(\n         }\n         CPlaceInner::VarPair(place_local, var1, var2) => {\n             assert_eq!(local, place_local);\n-            (\"ssa\", Cow::Owned(format!(\",var=({}, {})\", var1.index(), var2.index())))\n+            (\n+                \"ssa\",\n+                Cow::Owned(format!(\",var=({}, {})\", var1.index(), var2.index())),\n+            )\n         }\n         CPlaceInner::VarLane(_local, _var, _lane) => unreachable!(),\n         CPlaceInner::Addr(ptr, meta) => {\n@@ -90,15 +93,18 @@ pub(super) fn add_local_place_comments<'tcx>(\n                 Cow::Borrowed(\"\")\n             };\n             match ptr.base_and_offset() {\n-                (crate::pointer::PointerBase::Addr(addr), offset) => {\n-                    (\"reuse\", format!(\"storage={}{}{}\", addr, offset, meta).into())\n-                }\n-                (crate::pointer::PointerBase::Stack(stack_slot), offset) => {\n-                    (\"stack\", format!(\"storage={}{}{}\", stack_slot, offset, meta).into())\n-                }\n-                (crate::pointer::PointerBase::Dangling(align), offset) => {\n-                    (\"zst\", format!(\"align={},offset={}\", align.bytes(), offset).into())\n-                }\n+                (crate::pointer::PointerBase::Addr(addr), offset) => (\n+                    \"reuse\",\n+                    format!(\"storage={}{}{}\", addr, offset, meta).into(),\n+                ),\n+                (crate::pointer::PointerBase::Stack(stack_slot), offset) => (\n+                    \"stack\",\n+                    format!(\"storage={}{}{}\", stack_slot, offset, meta).into(),\n+                ),\n+                (crate::pointer::PointerBase::Dangling(align), offset) => (\n+                    \"zst\",\n+                    format!(\"align={},offset={}\", align.bytes(), offset).into(),\n+                ),\n             }\n         }\n     };\n@@ -111,7 +117,11 @@ pub(super) fn add_local_place_comments<'tcx>(\n         size.bytes(),\n         align.abi.bytes(),\n         align.pref.bytes(),\n-        if extra.is_empty() { \"\" } else { \"              \" },\n+        if extra.is_empty() {\n+            \"\"\n+        } else {\n+            \"              \"\n+        },\n         extra,\n     ));\n }"}, {"sha": "c09c70175e503c313dc7c2f8f81a9090c54e96af", "filename": "src/abi/mod.rs", "status": "modified", "additions": 81, "deletions": 41, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -3,8 +3,8 @@ mod comments;\n mod pass_mode;\n mod returning;\n \n-use rustc_target::spec::abi::Abi;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n+use rustc_target::spec::abi::Abi;\n \n use cranelift_codegen::ir::{AbiParam, ArgumentPurpose};\n \n@@ -14,7 +14,10 @@ use crate::prelude::*;\n pub(crate) use self::returning::{can_return_to_ssa_var, codegen_return};\n \n // Copied from https://github.com/rust-lang/rust/blob/f52c72948aa1dd718cc1f168d21c91c584c0a662/src/librustc_middle/ty/layout.rs#L2301\n-pub(crate) fn fn_sig_for_fn_abi<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> ty::PolyFnSig<'tcx> {\n+pub(crate) fn fn_sig_for_fn_abi<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    instance: Instance<'tcx>,\n+) -> ty::PolyFnSig<'tcx> {\n     use rustc_middle::ty::subst::Subst;\n \n     // FIXME(davidtwco,eddyb): A `ParamEnv` should be passed through to this function.\n@@ -70,10 +73,10 @@ pub(crate) fn fn_sig_for_fn_abi<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx\n             let env_ty = tcx.mk_adt(pin_adt_ref, pin_substs);\n \n             sig.map_bound(|sig| {\n-                let state_did = tcx.require_lang_item(rustc_hir::LangItem::GeneratorStateLangItem, None);\n+                let state_did =\n+                    tcx.require_lang_item(rustc_hir::LangItem::GeneratorStateLangItem, None);\n                 let state_adt_ref = tcx.adt_def(state_did);\n-                let state_substs =\n-                    tcx.intern_substs(&[sig.yield_ty.into(), sig.return_ty.into()]);\n+                let state_substs = tcx.intern_substs(&[sig.yield_ty.into(), sig.return_ty.into()]);\n                 let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n \n                 tcx.mk_fn_sig(\n@@ -102,8 +105,16 @@ fn clif_sig_from_fn_sig<'tcx>(\n         abi => abi,\n     };\n     let (call_conv, inputs, output): (CallConv, Vec<Ty<'tcx>>, Ty<'tcx>) = match abi {\n-        Abi::Rust => (CallConv::triple_default(triple), sig.inputs().to_vec(), sig.output()),\n-        Abi::C | Abi::Unadjusted => (CallConv::triple_default(triple), sig.inputs().to_vec(), sig.output()),\n+        Abi::Rust => (\n+            CallConv::triple_default(triple),\n+            sig.inputs().to_vec(),\n+            sig.output(),\n+        ),\n+        Abi::C | Abi::Unadjusted => (\n+            CallConv::triple_default(triple),\n+            sig.inputs().to_vec(),\n+            sig.output(),\n+        ),\n         Abi::SysV64 => (CallConv::SystemV, sig.inputs().to_vec(), sig.output()),\n         Abi::RustCall => {\n             assert_eq!(sig.inputs().len(), 2);\n@@ -116,7 +127,11 @@ fn clif_sig_from_fn_sig<'tcx>(\n             (CallConv::triple_default(triple), inputs, sig.output())\n         }\n         Abi::System => unreachable!(),\n-        Abi::RustIntrinsic => (CallConv::triple_default(triple), sig.inputs().to_vec(), sig.output()),\n+        Abi::RustIntrinsic => (\n+            CallConv::triple_default(triple),\n+            sig.inputs().to_vec(),\n+            sig.output(),\n+        ),\n         _ => unimplemented!(\"unsupported abi {:?}\", sig.abi),\n     };\n \n@@ -163,10 +178,7 @@ fn clif_sig_from_fn_sig<'tcx>(\n         tcx.layout_of(ParamEnv::reveal_all().and(output)).unwrap(),\n     ) {\n         PassMode::NoPass => (inputs.collect(), vec![]),\n-        PassMode::ByVal(ret_ty) => (\n-            inputs.collect(),\n-            vec![AbiParam::new(ret_ty)],\n-        ),\n+        PassMode::ByVal(ret_ty) => (inputs.collect(), vec![AbiParam::new(ret_ty)]),\n         PassMode::ByValPair(ret_ty_a, ret_ty_b) => (\n             inputs.collect(),\n             vec![AbiParam::new(ret_ty_a), AbiParam::new(ret_ty_b)],\n@@ -202,12 +214,24 @@ pub(crate) fn get_function_name_and_sig<'tcx>(\n     support_vararg: bool,\n ) -> (String, Signature) {\n     assert!(!inst.substs.needs_infer());\n-    let fn_sig =\n-        tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &fn_sig_for_fn_abi(tcx, inst));\n+    let fn_sig = tcx.normalize_erasing_late_bound_regions(\n+        ParamEnv::reveal_all(),\n+        &fn_sig_for_fn_abi(tcx, inst),\n+    );\n     if fn_sig.c_variadic && !support_vararg {\n-        tcx.sess.span_fatal(tcx.def_span(inst.def_id()), \"Variadic function definitions are not yet supported\");\n+        tcx.sess.span_fatal(\n+            tcx.def_span(inst.def_id()),\n+            \"Variadic function definitions are not yet supported\",\n+        );\n     }\n-    let sig = clif_sig_from_fn_sig(tcx, triple, fn_sig, tcx.def_span(inst.def_id()), false, inst.def.requires_caller_location(tcx));\n+    let sig = clif_sig_from_fn_sig(\n+        tcx,\n+        triple,\n+        fn_sig,\n+        tcx.def_span(inst.def_id()),\n+        false,\n+        inst.def.requires_caller_location(tcx),\n+    );\n     (tcx.symbol_name(inst).name.to_string(), sig)\n }\n \n@@ -228,7 +252,8 @@ impl<'tcx, B: Backend + 'static> FunctionCx<'_, 'tcx, B> {\n     pub(crate) fn get_function_ref(&mut self, inst: Instance<'tcx>) -> FuncRef {\n         let func_id = import_function(self.tcx, &mut self.cx.module, inst);\n         let func_ref = self\n-            .cx.module\n+            .cx\n+            .module\n             .declare_func_in_func(func_id, &mut self.bcx.func);\n \n         #[cfg(debug_assertions)]\n@@ -250,11 +275,13 @@ impl<'tcx, B: Backend + 'static> FunctionCx<'_, 'tcx, B> {\n             call_conv: CallConv::triple_default(self.triple()),\n         };\n         let func_id = self\n-            .cx.module\n+            .cx\n+            .module\n             .declare_function(&name, Linkage::Import, &sig)\n             .unwrap();\n         let func_ref = self\n-            .cx.module\n+            .cx\n+            .module\n             .declare_func_in_func(func_id, &mut self.bcx.func);\n         let call_inst = self.bcx.ins().call(func_ref, args);\n         #[cfg(debug_assertions)]\n@@ -376,7 +403,9 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n     assert!(fx.caller_location.is_none());\n     if fx.instance.def.requires_caller_location(fx.tcx) {\n         // Store caller location for `#[track_caller]`.\n-        fx.caller_location = Some(cvalue_for_param(fx, start_block, None, None, fx.tcx.caller_location_ty()).unwrap());\n+        fx.caller_location = Some(\n+            cvalue_for_param(fx, start_block, None, None, fx.tcx.caller_location_ty()).unwrap(),\n+        );\n     }\n \n     fx.bcx.switch_to_block(start_block);\n@@ -502,17 +531,20 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 fx.bcx.ins().jump(ret_block, &[]);\n                 return;\n             }\n-            _ => Some(instance)\n+            _ => Some(instance),\n         }\n     } else {\n         None\n     };\n \n-    let is_cold =\n-        instance.map(|inst|\n-            fx.tcx.codegen_fn_attrs(inst.def_id())\n-                .flags.contains(CodegenFnAttrFlags::COLD))\n-                .unwrap_or(false);\n+    let is_cold = instance\n+        .map(|inst| {\n+            fx.tcx\n+                .codegen_fn_attrs(inst.def_id())\n+                .flags\n+                .contains(CodegenFnAttrFlags::COLD)\n+        })\n+        .unwrap_or(false);\n     if is_cold {\n         fx.cold_blocks.insert(current_block);\n     }\n@@ -524,9 +556,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         let pack_arg = trans_operand(fx, &args[1]);\n \n         let tupled_arguments = match pack_arg.layout().ty.kind {\n-            ty::Tuple(ref tupled_arguments) => {\n-                tupled_arguments\n-            }\n+            ty::Tuple(ref tupled_arguments) => tupled_arguments,\n             _ => bug!(\"argument to function with \\\"rust-call\\\" ABI is not a tuple\"),\n         };\n \n@@ -582,8 +612,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 let nop_inst = fx.bcx.ins().nop();\n                 fx.add_comment(nop_inst, \"indirect call\");\n             }\n-            let func = trans_operand(fx, func)\n-                .load_scalar(fx);\n+            let func = trans_operand(fx, func).load_scalar(fx);\n             (\n                 Some(func),\n                 args.get(0)\n@@ -608,7 +637,10 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 )\n                 .collect::<Vec<_>>();\n \n-            if instance.map(|inst| inst.def.requires_caller_location(fx.tcx)).unwrap_or(false) {\n+            if instance\n+                .map(|inst| inst.def.requires_caller_location(fx.tcx))\n+                .unwrap_or(false)\n+            {\n                 // Pass the caller location for `#[track_caller]`.\n                 let caller_location = fx.get_caller_location(span);\n                 call_args.extend(adjust_arg_for_abi(fx, caller_location).into_iter());\n@@ -637,7 +669,10 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     // FIXME find a cleaner way to support varargs\n     if fn_sig.c_variadic {\n         if fn_sig.abi != Abi::C {\n-            fx.tcx.sess.span_fatal(span, &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi));\n+            fx.tcx.sess.span_fatal(\n+                span,\n+                &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi),\n+            );\n         }\n         let sig_ref = fx.bcx.func.dfg.call_signature(call_inst).unwrap();\n         let abi_params = call_args\n@@ -646,7 +681,9 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 let ty = fx.bcx.func.dfg.value_type(arg);\n                 if !ty.is_int() {\n                     // FIXME set %al to upperbound on float args once floats are supported\n-                    fx.tcx.sess.span_fatal(span, &format!(\"Non int ty {:?} for variadic call\", ty));\n+                    fx.tcx\n+                        .sess\n+                        .span_fatal(span, &format!(\"Non int ty {:?} for variadic call\", ty));\n                 }\n                 AbiParam::new(ty)\n             })\n@@ -700,13 +737,16 @@ pub(crate) fn codegen_drop<'tcx>(\n             _ => {\n                 assert!(!matches!(drop_fn.def, InstanceDef::Virtual(_, _)));\n \n-                let arg_value = drop_place.place_ref(fx, fx.layout_of(fx.tcx.mk_ref(\n-                    &ty::RegionKind::ReErased,\n-                    TypeAndMut {\n-                        ty,\n-                        mutbl: crate::rustc_hir::Mutability::Mut,\n-                    },\n-                )));\n+                let arg_value = drop_place.place_ref(\n+                    fx,\n+                    fx.layout_of(fx.tcx.mk_ref(\n+                        &ty::RegionKind::ReErased,\n+                        TypeAndMut {\n+                            ty,\n+                            mutbl: crate::rustc_hir::Mutability::Mut,\n+                        },\n+                    )),\n+                );\n                 let arg_value = adjust_arg_for_abi(fx, arg_value);\n \n                 let mut call_args: Vec<Value> = arg_value.into_iter().collect::<Vec<_>>();"}, {"sha": "49aaf22058d21be9ca2a58521f9223a1418336e2", "filename": "src/abi/pass_mode.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fpass_mode.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -83,17 +83,17 @@ pub(super) fn get_pass_mode<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx>)\n     } else {\n         match &layout.abi {\n             Abi::Uninhabited => PassMode::NoPass,\n-            Abi::Scalar(scalar) => {\n-                PassMode::ByVal(scalar_to_clif_type(tcx, scalar.clone()))\n-            }\n+            Abi::Scalar(scalar) => PassMode::ByVal(scalar_to_clif_type(tcx, scalar.clone())),\n             Abi::ScalarPair(a, b) => {\n                 let a = scalar_to_clif_type(tcx, a.clone());\n                 let b = scalar_to_clif_type(tcx, b.clone());\n                 if a == types::I128 && b == types::I128 {\n                     // Returning (i128, i128) by-val-pair would take 4 regs, while only 3 are\n                     // available on x86_64. Cranelift gets confused when too many return params\n                     // are used.\n-                    PassMode::ByRef { size: Some(layout.size) }\n+                    PassMode::ByRef {\n+                        size: Some(layout.size),\n+                    }\n                 } else {\n                     PassMode::ByValPair(a, b)\n                 }\n@@ -104,11 +104,15 @@ pub(super) fn get_pass_mode<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx>)\n                 if let Some(vector_ty) = crate::intrinsics::clif_vector_type(tcx, layout) {\n                     PassMode::ByVal(vector_ty)\n                 } else {\n-                    PassMode::ByRef { size: Some(layout.size) }\n+                    PassMode::ByRef {\n+                        size: Some(layout.size),\n+                    }\n                 }\n             }\n \n-            Abi::Aggregate { sized: true } => PassMode::ByRef { size: Some(layout.size) },\n+            Abi::Aggregate { sized: true } => PassMode::ByRef {\n+                size: Some(layout.size),\n+            },\n             Abi::Aggregate { sized: false } => PassMode::ByRef { size: None },\n         }\n     }\n@@ -125,22 +129,18 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n             let (a, b) = arg.load_scalar_pair(fx);\n             Pair(a, b)\n         }\n-        PassMode::ByRef { size: _ } => {\n-            match arg.force_stack(fx) {\n-                (ptr, None) => Single(ptr.get_addr(fx)),\n-                (ptr, Some(meta)) => Pair(ptr.get_addr(fx), meta),\n-            }\n-        }\n+        PassMode::ByRef { size: _ } => match arg.force_stack(fx) {\n+            (ptr, None) => Single(ptr.get_addr(fx)),\n+            (ptr, Some(meta)) => Pair(ptr.get_addr(fx), meta),\n+        },\n     }\n }\n \n pub(super) fn cvalue_for_param<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n     start_block: Block,\n-    #[cfg_attr(not(debug_assertions), allow(unused_variables))]\n-    local: Option<mir::Local>,\n-    #[cfg_attr(not(debug_assertions), allow(unused_variables))]\n-    local_field: Option<usize>,\n+    #[cfg_attr(not(debug_assertions), allow(unused_variables))] local: Option<mir::Local>,\n+    #[cfg_attr(not(debug_assertions), allow(unused_variables))] local_field: Option<usize>,\n     arg_ty: Ty<'tcx>,\n ) -> Option<CValue<'tcx>> {\n     let layout = fx.layout_of(arg_ty);\n@@ -171,7 +171,10 @@ pub(super) fn cvalue_for_param<'tcx>(\n             let (a, b) = block_params.assert_pair();\n             Some(CValue::by_val_pair(a, b, layout))\n         }\n-        PassMode::ByRef { size: Some(_) } => Some(CValue::by_ref(Pointer::new(block_params.assert_single()), layout)),\n+        PassMode::ByRef { size: Some(_) } => Some(CValue::by_ref(\n+            Pointer::new(block_params.assert_single()),\n+            layout,\n+        )),\n         PassMode::ByRef { size: None } => {\n             let (ptr, meta) = block_params.assert_pair();\n             Some(CValue::by_ref_unsized(Pointer::new(ptr), meta, layout))"}, {"sha": "dfb16b5fe4ca3b20652a97f30b925eebe215ea56", "filename": "src/abi/returning.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Freturning.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -5,11 +5,14 @@ fn return_layout<'a, 'tcx>(fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> TyAnd\n     fx.layout_of(fx.monomorphize(&fx.mir.local_decls[RETURN_PLACE].ty))\n }\n \n-pub(crate) fn can_return_to_ssa_var<'tcx>(tcx: TyCtxt<'tcx>, dest_layout: TyAndLayout<'tcx>) -> bool {\n+pub(crate) fn can_return_to_ssa_var<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    dest_layout: TyAndLayout<'tcx>,\n+) -> bool {\n     match get_pass_mode(tcx, dest_layout) {\n         PassMode::NoPass | PassMode::ByVal(_) => true,\n         // FIXME Make it possible to return ByValPair and ByRef to an ssa var.\n-        PassMode::ByValPair(_, _) | PassMode::ByRef { size: _ } => false\n+        PassMode::ByValPair(_, _) | PassMode::ByRef { size: _ } => false,\n     }\n }\n \n@@ -35,8 +38,10 @@ pub(super) fn codegen_return_param(\n         }\n         PassMode::ByRef { size: Some(_) } => {\n             let ret_param = fx.bcx.append_block_param(start_block, fx.pointer_type);\n-            fx.local_map\n-                .insert(RETURN_PLACE, CPlace::for_ptr(Pointer::new(ret_param), ret_layout));\n+            fx.local_map.insert(\n+                RETURN_PLACE,\n+                CPlace::for_ptr(Pointer::new(ret_param), ret_layout),\n+            );\n \n             Single(ret_param)\n         }\n@@ -69,7 +74,7 @@ pub(super) fn codegen_with_call_return_arg<'tcx, B: Backend, T>(\n     let output_pass_mode = get_pass_mode(fx.tcx, ret_layout);\n     let return_ptr = match output_pass_mode {\n         PassMode::NoPass => None,\n-        PassMode::ByRef { size: Some(_)} => match ret_place {\n+        PassMode::ByRef { size: Some(_) } => match ret_place {\n             Some(ret_place) => Some(ret_place.to_ptr().get_addr(fx)),\n             None => Some(fx.bcx.ins().iconst(fx.pointer_type, 43)), // FIXME allocate temp stack slot\n         },"}, {"sha": "894e47dd439caa4518348011d20775be1f005e55", "filename": "src/allocator.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fallocator.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -102,11 +102,13 @@ fn codegen_inner(\n             bcx.seal_all_blocks();\n             bcx.finalize();\n         }\n-        module.define_function(\n-            func_id,\n-            &mut ctx,\n-            &mut cranelift_codegen::binemit::NullTrapSink {},\n-        ).unwrap();\n+        module\n+            .define_function(\n+                func_id,\n+                &mut ctx,\n+                &mut cranelift_codegen::binemit::NullTrapSink {},\n+            )\n+            .unwrap();\n         unwind_context.add_function(func_id, &ctx, module.isa());\n     }\n }"}, {"sha": "055b371f43c3c064dd97bf0edac92f4db7bb84e1", "filename": "src/analyze.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fanalyze.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -1,7 +1,7 @@\n use crate::prelude::*;\n \n-use rustc_middle::mir::StatementKind::*;\n use rustc_index::vec::IndexVec;\n+use rustc_middle::mir::StatementKind::*;\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub(crate) enum SsaKind {\n@@ -10,20 +10,25 @@ pub(crate) enum SsaKind {\n }\n \n pub(crate) fn analyze(fx: &FunctionCx<'_, '_, impl Backend>) -> IndexVec<Local, SsaKind> {\n-    let mut flag_map = fx.mir.local_decls.iter().map(|local_decl| {\n-        let ty = fx.monomorphize(&local_decl.ty);\n-        if fx.clif_type(ty).is_some() || fx.clif_pair_type(ty).is_some() {\n-            SsaKind::Ssa\n-        } else {\n-            SsaKind::NotSsa\n-        }\n-    }).collect::<IndexVec<Local, SsaKind>>();\n+    let mut flag_map = fx\n+        .mir\n+        .local_decls\n+        .iter()\n+        .map(|local_decl| {\n+            let ty = fx.monomorphize(&local_decl.ty);\n+            if fx.clif_type(ty).is_some() || fx.clif_pair_type(ty).is_some() {\n+                SsaKind::Ssa\n+            } else {\n+                SsaKind::NotSsa\n+            }\n+        })\n+        .collect::<IndexVec<Local, SsaKind>>();\n \n     for bb in fx.mir.basic_blocks().iter() {\n         for stmt in bb.statements.iter() {\n             match &stmt.kind {\n                 Assign(place_and_rval) => match &place_and_rval.1 {\n-                    Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place)=> {\n+                    Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place) => {\n                         not_ssa(&mut flag_map, place.local)\n                     }\n                     _ => {}\n@@ -35,7 +40,8 @@ pub(crate) fn analyze(fx: &FunctionCx<'_, '_, impl Backend>) -> IndexVec<Local,\n         match &bb.terminator().kind {\n             TerminatorKind::Call { destination, .. } => {\n                 if let Some((dest_place, _dest_bb)) = destination {\n-                    let dest_layout = fx.layout_of(fx.monomorphize(&dest_place.ty(&fx.mir.local_decls, fx.tcx).ty));\n+                    let dest_layout = fx\n+                        .layout_of(fx.monomorphize(&dest_place.ty(&fx.mir.local_decls, fx.tcx).ty));\n                     if !crate::abi::can_return_to_ssa_var(fx.tcx, dest_layout) {\n                         not_ssa(&mut flag_map, dest_place.local)\n                     }"}, {"sha": "60975c89af6fb815f8c1a26039580ecfe03521a1", "filename": "src/archive.rs", "status": "modified", "additions": 64, "deletions": 41, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Farchive.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -2,9 +2,9 @@ use std::collections::BTreeMap;\n use std::fs::File;\n use std::path::{Path, PathBuf};\n \n-use rustc_session::Session;\n use rustc_codegen_ssa::back::archive::{find_library, ArchiveBuilder};\n use rustc_codegen_ssa::METADATA_FILENAME;\n+use rustc_session::Session;\n \n use object::{Object, SymbolKind};\n \n@@ -167,30 +167,45 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n                     entry.read_to_end(&mut data).unwrap();\n                     data\n                 }\n-                ArchiveEntry::File(file) => {\n-                    std::fs::read(file).unwrap_or_else(|err| {\n-                        sess.fatal(&format!(\"error while reading object file during archive building: {}\", err));\n-                    })\n-                }\n+                ArchiveEntry::File(file) => std::fs::read(file).unwrap_or_else(|err| {\n+                    sess.fatal(&format!(\n+                        \"error while reading object file during archive building: {}\",\n+                        err\n+                    ));\n+                }),\n             };\n \n             if !self.no_builtin_ranlib {\n                 match object::File::parse(&data) {\n                     Ok(object) => {\n-                        symbol_table.insert(entry_name.as_bytes().to_vec(), object.symbols().filter_map(|(_index, symbol)| {\n-                            if symbol.is_undefined() || symbol.is_local() || symbol.kind() != SymbolKind::Data && symbol.kind() != SymbolKind::Text && symbol.kind() != SymbolKind::Tls {\n-                                None\n-                            } else {\n-                                symbol.name().map(|name| name.as_bytes().to_vec())\n-                            }\n-                        }).collect::<Vec<_>>());\n+                        symbol_table.insert(\n+                            entry_name.as_bytes().to_vec(),\n+                            object\n+                                .symbols()\n+                                .filter_map(|(_index, symbol)| {\n+                                    if symbol.is_undefined()\n+                                        || symbol.is_local()\n+                                        || symbol.kind() != SymbolKind::Data\n+                                            && symbol.kind() != SymbolKind::Text\n+                                            && symbol.kind() != SymbolKind::Tls\n+                                    {\n+                                        None\n+                                    } else {\n+                                        symbol.name().map(|name| name.as_bytes().to_vec())\n+                                    }\n+                                })\n+                                .collect::<Vec<_>>(),\n+                        );\n                     }\n                     Err(err) => {\n                         let err = err.to_string();\n                         if err == \"Unknown file magic\" {\n                             // Not an object file; skip it.\n                         } else {\n-                            sess.fatal(&format!(\"error parsing `{}` during archive creation: {}\", entry_name, err));\n+                            sess.fatal(&format!(\n+                                \"error parsing `{}` during archive creation: {}\",\n+                                entry_name, err\n+                            ));\n                         }\n                     }\n                 }\n@@ -200,36 +215,44 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         }\n \n         let mut builder = if self.use_gnu_style_archive {\n-            BuilderKind::Gnu(ar::GnuBuilder::new(\n-                File::create(&self.dst).unwrap_or_else(|err| {\n-                    sess.fatal(&format!(\"error opening destination during archive building: {}\", err));\n-                }),\n-                entries\n-                    .iter()\n-                    .map(|(name, _)| name.as_bytes().to_vec())\n-                    .collect(),\n-                ar::GnuSymbolTableFormat::Size32,\n-                symbol_table,\n-            ).unwrap())\n+            BuilderKind::Gnu(\n+                ar::GnuBuilder::new(\n+                    File::create(&self.dst).unwrap_or_else(|err| {\n+                        sess.fatal(&format!(\n+                            \"error opening destination during archive building: {}\",\n+                            err\n+                        ));\n+                    }),\n+                    entries\n+                        .iter()\n+                        .map(|(name, _)| name.as_bytes().to_vec())\n+                        .collect(),\n+                    ar::GnuSymbolTableFormat::Size32,\n+                    symbol_table,\n+                )\n+                .unwrap(),\n+            )\n         } else {\n-            BuilderKind::Bsd(ar::Builder::new(\n-                File::create(&self.dst).unwrap_or_else(|err| {\n-                    sess.fatal(&format!(\"error opening destination during archive building: {}\", err));\n-                }),\n-                symbol_table,\n-            ).unwrap())\n+            BuilderKind::Bsd(\n+                ar::Builder::new(\n+                    File::create(&self.dst).unwrap_or_else(|err| {\n+                        sess.fatal(&format!(\n+                            \"error opening destination during archive building: {}\",\n+                            err\n+                        ));\n+                    }),\n+                    symbol_table,\n+                )\n+                .unwrap(),\n+            )\n         };\n \n         // Add all files\n         for (entry_name, data) in entries.into_iter() {\n             let header = ar::Header::new(entry_name.into_bytes(), data.len() as u64);\n             match builder {\n-                BuilderKind::Bsd(ref mut builder) => builder\n-                    .append(&header, &mut &*data)\n-                    .unwrap(),\n-                BuilderKind::Gnu(ref mut builder) => builder\n-                    .append(&header, &mut &*data)\n-                    .unwrap(),\n+                BuilderKind::Bsd(ref mut builder) => builder.append(&header, &mut &*data).unwrap(),\n+                BuilderKind::Gnu(ref mut builder) => builder.append(&header, &mut &*data).unwrap(),\n             }\n         }\n \n@@ -246,7 +269,8 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n                 .expect(\"Couldn't run ranlib\");\n \n             if !status.success() {\n-                self.sess.fatal(&format!(\"Ranlib exited with code {:?}\", status.code()));\n+                self.sess\n+                    .fatal(&format!(\"Ranlib exited with code {:?}\", status.code()));\n             }\n         }\n     }\n@@ -263,9 +287,8 @@ impl<'a> ArArchiveBuilder<'a> {\n         let mut i = 0;\n         while let Some(entry) = archive.next_entry() {\n             let entry = entry?;\n-            let file_name = String::from_utf8(entry.header().identifier().to_vec()).map_err(|err| {\n-                std::io::Error::new(std::io::ErrorKind::InvalidData, err)\n-            })?;\n+            let file_name = String::from_utf8(entry.header().identifier().to_vec())\n+                .map_err(|err| std::io::Error::new(std::io::ErrorKind::InvalidData, err))?;\n             if !skip(&file_name) {\n                 self.entries.push((\n                     file_name,"}, {"sha": "2f9f9e3a4f744bf46ed32167385e7d2d32df4cc6", "filename": "src/atomic_shim.rs", "status": "modified", "additions": 112, "deletions": 59, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fatomic_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fatomic_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fatomic_shim.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -7,7 +7,8 @@ use crate::prelude::*;\n \n #[cfg(feature = \"jit\")]\n #[no_mangle]\n-pub static mut __cg_clif_global_atomic_mutex: libc::pthread_mutex_t = libc::PTHREAD_MUTEX_INITIALIZER;\n+pub static mut __cg_clif_global_atomic_mutex: libc::pthread_mutex_t =\n+    libc::PTHREAD_MUTEX_INITIALIZER;\n \n pub(crate) fn init_global_lock(module: &mut Module<impl Backend>, bcx: &mut FunctionBuilder<'_>) {\n     if std::env::var(\"CG_CLIF_JIT\").is_ok() {\n@@ -19,28 +20,42 @@ pub(crate) fn init_global_lock(module: &mut Module<impl Backend>, bcx: &mut Func\n \n     let mut data_ctx = DataContext::new();\n     data_ctx.define_zeroinit(1024); // 1024 bytes should be big enough on all platforms.\n-    let atomic_mutex = module.declare_data(\n-        \"__cg_clif_global_atomic_mutex\",\n-        Linkage::Export,\n-        true,\n-        false,\n-        Some(16),\n-    ).unwrap();\n+    let atomic_mutex = module\n+        .declare_data(\n+            \"__cg_clif_global_atomic_mutex\",\n+            Linkage::Export,\n+            true,\n+            false,\n+            Some(16),\n+        )\n+        .unwrap();\n     module.define_data(atomic_mutex, &data_ctx).unwrap();\n \n-    let pthread_mutex_init = module.declare_function(\"pthread_mutex_init\", Linkage::Import, &cranelift_codegen::ir::Signature {\n-        call_conv: module.target_config().default_call_conv,\n-        params: vec![\n-            AbiParam::new(module.target_config().pointer_type() /* *mut pthread_mutex_t */),\n-            AbiParam::new(module.target_config().pointer_type() /* *const pthread_mutex_attr_t */),\n-        ],\n-        returns: vec![AbiParam::new(types::I32 /* c_int */)],\n-    }).unwrap();\n+    let pthread_mutex_init = module\n+        .declare_function(\n+            \"pthread_mutex_init\",\n+            Linkage::Import,\n+            &cranelift_codegen::ir::Signature {\n+                call_conv: module.target_config().default_call_conv,\n+                params: vec![\n+                    AbiParam::new(\n+                        module.target_config().pointer_type(), /* *mut pthread_mutex_t */\n+                    ),\n+                    AbiParam::new(\n+                        module.target_config().pointer_type(), /* *const pthread_mutex_attr_t */\n+                    ),\n+                ],\n+                returns: vec![AbiParam::new(types::I32 /* c_int */)],\n+            },\n+        )\n+        .unwrap();\n \n     let pthread_mutex_init = module.declare_func_in_func(pthread_mutex_init, bcx.func);\n \n     let atomic_mutex = module.declare_data_in_func(atomic_mutex, bcx.func);\n-    let atomic_mutex = bcx.ins().global_value(module.target_config().pointer_type(), atomic_mutex);\n+    let atomic_mutex = bcx\n+        .ins()\n+        .global_value(module.target_config().pointer_type(), atomic_mutex);\n \n     let nullptr = bcx.ins().iconst(module.target_config().pointer_type(), 0);\n \n@@ -49,7 +64,7 @@ pub(crate) fn init_global_lock(module: &mut Module<impl Backend>, bcx: &mut Func\n \n pub(crate) fn init_global_lock_constructor(\n     module: &mut Module<impl Backend>,\n-    constructor_name: &str\n+    constructor_name: &str,\n ) -> FuncId {\n     let sig = Signature::new(CallConv::SystemV);\n     let init_func_id = module\n@@ -71,61 +86,99 @@ pub(crate) fn init_global_lock_constructor(\n         bcx.seal_all_blocks();\n         bcx.finalize();\n     }\n-    module.define_function(\n-        init_func_id,\n-        &mut ctx,\n-        &mut cranelift_codegen::binemit::NullTrapSink {},\n-    ).unwrap();\n+    module\n+        .define_function(\n+            init_func_id,\n+            &mut ctx,\n+            &mut cranelift_codegen::binemit::NullTrapSink {},\n+        )\n+        .unwrap();\n \n     init_func_id\n }\n \n pub(crate) fn lock_global_lock(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n-    let atomic_mutex = fx.cx.module.declare_data(\n-        \"__cg_clif_global_atomic_mutex\",\n-        Linkage::Import,\n-        true,\n-        false,\n-        None,\n-    ).unwrap();\n-\n-    let pthread_mutex_lock = fx.cx.module.declare_function(\"pthread_mutex_lock\", Linkage::Import, &cranelift_codegen::ir::Signature {\n-        call_conv: fx.cx.module.target_config().default_call_conv,\n-        params: vec![\n-            AbiParam::new(fx.cx.module.target_config().pointer_type() /* *mut pthread_mutex_t */),\n-        ],\n-        returns: vec![AbiParam::new(types::I32 /* c_int */)],\n-    }).unwrap();\n-\n-    let pthread_mutex_lock = fx.cx.module.declare_func_in_func(pthread_mutex_lock, fx.bcx.func);\n+    let atomic_mutex = fx\n+        .cx\n+        .module\n+        .declare_data(\n+            \"__cg_clif_global_atomic_mutex\",\n+            Linkage::Import,\n+            true,\n+            false,\n+            None,\n+        )\n+        .unwrap();\n+\n+    let pthread_mutex_lock = fx\n+        .cx\n+        .module\n+        .declare_function(\n+            \"pthread_mutex_lock\",\n+            Linkage::Import,\n+            &cranelift_codegen::ir::Signature {\n+                call_conv: fx.cx.module.target_config().default_call_conv,\n+                params: vec![AbiParam::new(\n+                    fx.cx.module.target_config().pointer_type(), /* *mut pthread_mutex_t */\n+                )],\n+                returns: vec![AbiParam::new(types::I32 /* c_int */)],\n+            },\n+        )\n+        .unwrap();\n+\n+    let pthread_mutex_lock = fx\n+        .cx\n+        .module\n+        .declare_func_in_func(pthread_mutex_lock, fx.bcx.func);\n \n     let atomic_mutex = fx.cx.module.declare_data_in_func(atomic_mutex, fx.bcx.func);\n-    let atomic_mutex = fx.bcx.ins().global_value(fx.cx.module.target_config().pointer_type(), atomic_mutex);\n+    let atomic_mutex = fx\n+        .bcx\n+        .ins()\n+        .global_value(fx.cx.module.target_config().pointer_type(), atomic_mutex);\n \n     fx.bcx.ins().call(pthread_mutex_lock, &[atomic_mutex]);\n }\n \n pub(crate) fn unlock_global_lock(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n-    let atomic_mutex = fx.cx.module.declare_data(\n-        \"__cg_clif_global_atomic_mutex\",\n-        Linkage::Import,\n-        true,\n-        false,\n-        None,\n-    ).unwrap();\n-\n-    let pthread_mutex_unlock = fx.cx.module.declare_function(\"pthread_mutex_unlock\", Linkage::Import, &cranelift_codegen::ir::Signature {\n-        call_conv: fx.cx.module.target_config().default_call_conv,\n-        params: vec![\n-            AbiParam::new(fx.cx.module.target_config().pointer_type() /* *mut pthread_mutex_t */),\n-        ],\n-        returns: vec![AbiParam::new(types::I32 /* c_int */)],\n-    }).unwrap();\n-\n-    let pthread_mutex_unlock = fx.cx.module.declare_func_in_func(pthread_mutex_unlock, fx.bcx.func);\n+    let atomic_mutex = fx\n+        .cx\n+        .module\n+        .declare_data(\n+            \"__cg_clif_global_atomic_mutex\",\n+            Linkage::Import,\n+            true,\n+            false,\n+            None,\n+        )\n+        .unwrap();\n+\n+    let pthread_mutex_unlock = fx\n+        .cx\n+        .module\n+        .declare_function(\n+            \"pthread_mutex_unlock\",\n+            Linkage::Import,\n+            &cranelift_codegen::ir::Signature {\n+                call_conv: fx.cx.module.target_config().default_call_conv,\n+                params: vec![AbiParam::new(\n+                    fx.cx.module.target_config().pointer_type(), /* *mut pthread_mutex_t */\n+                )],\n+                returns: vec![AbiParam::new(types::I32 /* c_int */)],\n+            },\n+        )\n+        .unwrap();\n+\n+    let pthread_mutex_unlock = fx\n+        .cx\n+        .module\n+        .declare_func_in_func(pthread_mutex_unlock, fx.bcx.func);\n \n     let atomic_mutex = fx.cx.module.declare_data_in_func(atomic_mutex, fx.bcx.func);\n-    let atomic_mutex = fx.bcx.ins().global_value(fx.cx.module.target_config().pointer_type(), atomic_mutex);\n+    let atomic_mutex = fx\n+        .bcx\n+        .ins()\n+        .global_value(fx.cx.module.target_config().pointer_type(), atomic_mutex);\n \n     fx.bcx.ins().call(pthread_mutex_unlock, &[atomic_mutex]);\n }"}, {"sha": "0d654aed160ca2f68835180c05eb80d5dc194f76", "filename": "src/backend.rs", "status": "modified", "additions": 50, "deletions": 29, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbackend.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -5,8 +5,8 @@ use rustc_session::Session;\n \n use cranelift_module::{FuncId, Module};\n \n-use object::{SectionKind, SymbolFlags, RelocationKind, RelocationEncoding};\n use object::write::*;\n+use object::{RelocationEncoding, RelocationKind, SectionKind, SymbolFlags};\n \n use cranelift_object::{ObjectBackend, ObjectBuilder, ObjectProduct};\n \n@@ -20,7 +20,9 @@ pub(crate) trait WriteMetadata {\n \n impl WriteMetadata for object::write::Object {\n     fn add_rustc_section(&mut self, symbol_name: String, data: Vec<u8>, _is_like_osx: bool) {\n-        let segment = self.segment_name(object::write::StandardSegment::Data).to_vec();\n+        let segment = self\n+            .segment_name(object::write::StandardSegment::Data)\n+            .to_vec();\n         let section_id = self.add_section(segment, b\".rustc\".to_vec(), object::SectionKind::Data);\n         let offset = self.append_section_data(section_id, &data, 1);\n         // For MachO and probably PE this is necessary to prevent the linker from throwing away the\n@@ -62,7 +64,8 @@ impl WriteDebugInfo for ObjectProduct {\n             id.name().replace('.', \"__\") // machO expects __debug_info instead of .debug_info\n         } else {\n             id.name().to_string()\n-        }.into_bytes();\n+        }\n+        .into_bytes();\n \n         let segment = self.object.segment_name(StandardSegment::Debug).to_vec();\n         let section_id = self.object.add_section(segment, name, SectionKind::Debug);\n@@ -78,22 +81,27 @@ impl WriteDebugInfo for ObjectProduct {\n         reloc: &DebugReloc,\n     ) {\n         let (symbol, symbol_offset) = match reloc.name {\n-            DebugRelocName::Section(id) => {\n-                (section_map.get(&id).unwrap().1, 0)\n-            }\n+            DebugRelocName::Section(id) => (section_map.get(&id).unwrap().1, 0),\n             DebugRelocName::Symbol(id) => {\n                 let symbol_id = self.function_symbol(FuncId::from_u32(id.try_into().unwrap()));\n-                self.object.symbol_section_and_offset(symbol_id).expect(\"Debug reloc for undef sym???\")\n+                self.object\n+                    .symbol_section_and_offset(symbol_id)\n+                    .expect(\"Debug reloc for undef sym???\")\n             }\n         };\n-        self.object.add_relocation(from.0, Relocation {\n-            offset: u64::from(reloc.offset),\n-            symbol,\n-            kind: RelocationKind::Absolute,\n-            encoding: RelocationEncoding::Generic,\n-            size: reloc.size * 8,\n-            addend: i64::try_from(symbol_offset).unwrap() + reloc.addend,\n-        }).unwrap();\n+        self.object\n+            .add_relocation(\n+                from.0,\n+                Relocation {\n+                    offset: u64::from(reloc.offset),\n+                    symbol,\n+                    kind: RelocationKind::Absolute,\n+                    encoding: RelocationEncoding::Generic,\n+                    size: reloc.size * 8,\n+                    addend: i64::try_from(symbol_offset).unwrap() + reloc.addend,\n+                },\n+            )\n+            .unwrap();\n     }\n }\n \n@@ -105,21 +113,32 @@ pub(crate) trait AddConstructor {\n impl AddConstructor for ObjectProduct {\n     fn add_constructor(&mut self, func_id: FuncId) {\n         let symbol = self.function_symbol(func_id);\n-        let segment = self.object.segment_name(object::write::StandardSegment::Data);\n-        let init_array_section = self.object.add_section(segment.to_vec(), b\".init_array\".to_vec(), SectionKind::Data);\n+        let segment = self\n+            .object\n+            .segment_name(object::write::StandardSegment::Data);\n+        let init_array_section =\n+            self.object\n+                .add_section(segment.to_vec(), b\".init_array\".to_vec(), SectionKind::Data);\n         self.object.append_section_data(\n             init_array_section,\n-            &std::iter::repeat(0).take(8 /*FIXME pointer size*/).collect::<Vec<u8>>(),\n+            &std::iter::repeat(0)\n+                .take(8 /*FIXME pointer size*/)\n+                .collect::<Vec<u8>>(),\n             8,\n         );\n-        self.object.add_relocation(init_array_section, object::write::Relocation {\n-            offset: 0,\n-            size: 64, // FIXME pointer size\n-            kind: RelocationKind::Absolute,\n-            encoding: RelocationEncoding::Generic,\n-            symbol,\n-            addend: 0,\n-        }).unwrap();\n+        self.object\n+            .add_relocation(\n+                init_array_section,\n+                object::write::Relocation {\n+                    offset: 0,\n+                    size: 64, // FIXME pointer size\n+                    kind: RelocationKind::Absolute,\n+                    encoding: RelocationEncoding::Generic,\n+                    symbol,\n+                    addend: 0,\n+                },\n+            )\n+            .unwrap();\n     }\n }\n \n@@ -153,7 +172,7 @@ pub(crate) fn with_object(sess: &Session, name: &str, f: impl FnOnce(&mut Object\n         architecture => sess.fatal(&format!(\n             \"target architecture {:?} is unsupported\",\n             architecture,\n-        ))\n+        )),\n     };\n     let endian = match triple.endianness().unwrap() {\n         target_lexicon::Endianness::Little => object::Endianness::Little,\n@@ -166,15 +185,17 @@ pub(crate) fn with_object(sess: &Session, name: &str, f: impl FnOnce(&mut Object\n     metadata_object.write().unwrap()\n }\n \n-pub(crate) type Backend = impl cranelift_module::Backend<Product: AddConstructor + Emit + WriteDebugInfo>;\n+pub(crate) type Backend =\n+    impl cranelift_module::Backend<Product: AddConstructor + Emit + WriteDebugInfo>;\n \n pub(crate) fn make_module(sess: &Session, name: String) -> Module<Backend> {\n     let module: Module<ObjectBackend> = Module::new(\n         ObjectBuilder::new(\n             crate::build_isa(sess, true),\n             name + \".o\",\n             cranelift_module::default_libcall_names(),\n-        ).unwrap(),\n+        )\n+        .unwrap(),\n     );\n     module\n }"}, {"sha": "342c12ffc4118206688b01e380924cdbe896d23a", "filename": "src/base.rs", "status": "modified", "additions": 157, "deletions": 83, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -1,5 +1,5 @@\n-use rustc_middle::ty::adjustment::PointerCast;\n use rustc_index::vec::IndexVec;\n+use rustc_middle::ty::adjustment::PointerCast;\n \n use crate::prelude::*;\n \n@@ -29,7 +29,9 @@ pub(crate) fn trans_fn<'tcx, B: Backend + 'static>(\n \n     // Predefine blocks\n     let start_block = bcx.create_block();\n-    let block_map: IndexVec<BasicBlock, Block> = (0..mir.basic_blocks().len()).map(|_| bcx.create_block()).collect();\n+    let block_map: IndexVec<BasicBlock, Block> = (0..mir.basic_blocks().len())\n+        .map(|_| bcx.create_block())\n+        .collect();\n \n     // Make FunctionCx\n     let pointer_type = cx.module.target_config().pointer_type();\n@@ -56,15 +58,22 @@ pub(crate) fn trans_fn<'tcx, B: Backend + 'static>(\n         inline_asm_index: 0,\n     };\n \n-    let arg_uninhabited = fx.mir.args_iter().any(|arg| fx.layout_of(fx.monomorphize(&fx.mir.local_decls[arg].ty)).abi.is_uninhabited());\n+    let arg_uninhabited = fx.mir.args_iter().any(|arg| {\n+        fx.layout_of(fx.monomorphize(&fx.mir.local_decls[arg].ty))\n+            .abi\n+            .is_uninhabited()\n+    });\n \n     if arg_uninhabited {\n-        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n+        fx.bcx\n+            .append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n         fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n         crate::trap::trap_unreachable(&mut fx, \"function has uninhabited argument\");\n     } else {\n         tcx.sess.time(\"codegen clif ir\", || {\n-            tcx.sess.time(\"codegen prelude\", || crate::abi::codegen_fn_prelude(&mut fx, start_block));\n+            tcx.sess.time(\"codegen prelude\", || {\n+                crate::abi::codegen_fn_prelude(&mut fx, start_block)\n+            });\n             codegen_fn_content(&mut fx);\n         });\n     }\n@@ -80,21 +89,20 @@ pub(crate) fn trans_fn<'tcx, B: Backend + 'static>(\n     let context = &mut cx.cached_context;\n     context.func = func;\n \n-    crate::pretty_clif::write_clif_file(\n-        tcx,\n-        \"unopt\",\n-        None,\n-        instance,\n-        &context,\n-        &clif_comments,\n-    );\n+    crate::pretty_clif::write_clif_file(tcx, \"unopt\", None, instance, &context, &clif_comments);\n \n     // Verify function\n     verify_func(tcx, &clif_comments, &context.func);\n \n     // Perform rust specific optimizations\n     tcx.sess.time(\"optimize clif ir\", || {\n-        crate::optimize::optimize_function(tcx, instance, context, &cold_blocks, &mut clif_comments);\n+        crate::optimize::optimize_function(\n+            tcx,\n+            instance,\n+            context,\n+            &cold_blocks,\n+            &mut clif_comments,\n+        );\n     });\n \n     // If the return block is not reachable, then the SSA builder may have inserted a `iconst.i128`\n@@ -105,14 +113,15 @@ pub(crate) fn trans_fn<'tcx, B: Backend + 'static>(\n \n     // Define function\n     let module = &mut cx.module;\n-    tcx.sess.time(\n-        \"define function\",\n-        || module.define_function(\n-            func_id,\n-            context,\n-            &mut cranelift_codegen::binemit::NullTrapSink {},\n-        ).unwrap(),\n-    );\n+    tcx.sess.time(\"define function\", || {\n+        module\n+            .define_function(\n+                func_id,\n+                context,\n+                &mut cranelift_codegen::binemit::NullTrapSink {},\n+            )\n+            .unwrap()\n+    });\n \n     // Write optimized function to file for debugging\n     crate::pretty_clif::write_clif_file(\n@@ -130,7 +139,15 @@ pub(crate) fn trans_fn<'tcx, B: Backend + 'static>(\n     let unwind_context = &mut cx.unwind_context;\n     tcx.sess.time(\"generate debug info\", || {\n         if let Some(debug_context) = debug_context {\n-            debug_context.define_function(instance, func_id, &name, isa, context, &source_info_set, local_map);\n+            debug_context.define_function(\n+                instance,\n+                func_id,\n+                &name,\n+                isa,\n+                context,\n+                &source_info_set,\n+                local_map,\n+            );\n         }\n         unwind_context.add_function(func_id, &context, isa);\n     });\n@@ -139,7 +156,11 @@ pub(crate) fn trans_fn<'tcx, B: Backend + 'static>(\n     context.clear();\n }\n \n-pub(crate) fn verify_func(tcx: TyCtxt<'_>, writer: &crate::pretty_clif::CommentWriter, func: &Function) {\n+pub(crate) fn verify_func(\n+    tcx: TyCtxt<'_>,\n+    writer: &crate::pretty_clif::CommentWriter,\n+    func: &Function,\n+) {\n     tcx.sess.time(\"verify clif ir\", || {\n         let flags = cranelift_codegen::settings::Flags::new(cranelift_codegen::settings::builder());\n         match cranelift_codegen::verify_function(&func, &flags) {\n@@ -249,7 +270,9 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n \n                 fx.bcx.switch_to_block(failure);\n \n-                let location = fx.get_caller_location(bb_data.terminator().source_info.span).load_scalar(fx);\n+                let location = fx\n+                    .get_caller_location(bb_data.terminator().source_info.span)\n+                    .load_scalar(fx);\n \n                 let args;\n                 let lang_item = match msg {\n@@ -262,20 +285,30 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n                     _ => {\n                         let msg_str = msg.description();\n                         let msg_ptr = fx.anonymous_str(\"assert\", msg_str);\n-                        let msg_len = fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(msg_str.len()).unwrap());\n+                        let msg_len = fx\n+                            .bcx\n+                            .ins()\n+                            .iconst(fx.pointer_type, i64::try_from(msg_str.len()).unwrap());\n                         args = [msg_ptr, msg_len, location];\n                         rustc_hir::lang_items::PanicFnLangItem\n                     }\n                 };\n \n                 let def_id = fx.tcx.lang_items().require(lang_item).unwrap_or_else(|s| {\n-                    fx.tcx.sess.span_fatal(bb_data.terminator().source_info.span, &s)\n+                    fx.tcx\n+                        .sess\n+                        .span_fatal(bb_data.terminator().source_info.span, &s)\n                 });\n \n                 let instance = Instance::mono(fx.tcx, def_id).polymorphize(fx.tcx);\n                 let symbol_name = fx.tcx.symbol_name(instance).name;\n \n-                fx.lib_call(&*symbol_name, vec![fx.pointer_type, fx.pointer_type, fx.pointer_type], vec![], &args);\n+                fx.lib_call(\n+                    &*symbol_name,\n+                    vec![fx.pointer_type, fx.pointer_type, fx.pointer_type],\n+                    vec![],\n+                    &args,\n+                );\n \n                 crate::trap::trap_unreachable(fx, \"panic lang item returned\");\n             }\n@@ -303,14 +336,16 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n                 cleanup: _,\n                 from_hir_call: _,\n             } => {\n-                fx.tcx.sess.time(\"codegen call\", || crate::abi::codegen_terminator_call(\n-                    fx,\n-                    *fn_span,\n-                    block,\n-                    func,\n-                    args,\n-                    *destination,\n-                ));\n+                fx.tcx.sess.time(\"codegen call\", || {\n+                    crate::abi::codegen_terminator_call(\n+                        fx,\n+                        *fn_span,\n+                        block,\n+                        func,\n+                        args,\n+                        *destination,\n+                    )\n+                });\n             }\n             TerminatorKind::InlineAsm {\n                 template,\n@@ -333,7 +368,10 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n                         fx.bcx.ins().jump(destination_block, &[]);\n                     }\n                     None => {\n-                        crate::trap::trap_unreachable(fx, \"[corruption] Returned from noreturn inline asm\");\n+                        crate::trap::trap_unreachable(\n+                            fx,\n+                            \"[corruption] Returned from noreturn inline asm\",\n+                        );\n                     }\n                 }\n             }\n@@ -370,8 +408,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n \n fn trans_stmt<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n-    #[allow(unused_variables)]\n-    cur_block: Block,\n+    #[allow(unused_variables)] cur_block: Block,\n     stmt: &Statement<'tcx>,\n ) {\n     let _print_guard = crate::PrintOnPanic(|| format!(\"stmt {:?}\", stmt));\n@@ -439,30 +476,24 @@ fn trans_stmt<'tcx>(\n                     let layout = operand.layout();\n                     let val = operand.load_scalar(fx);\n                     let res = match un_op {\n-                        UnOp::Not => {\n-                            match layout.ty.kind {\n-                                ty::Bool => {\n-                                    let res = fx.bcx.ins().icmp_imm(IntCC::Equal, val, 0);\n-                                    CValue::by_val(fx.bcx.ins().bint(types::I8, res), layout)\n-                                }\n-                                ty::Uint(_) | ty::Int(_) => {\n-                                    CValue::by_val(fx.bcx.ins().bnot(val), layout)\n-                                }\n-                                _ => unreachable!(\"un op Not for {:?}\", layout.ty),\n+                        UnOp::Not => match layout.ty.kind {\n+                            ty::Bool => {\n+                                let res = fx.bcx.ins().icmp_imm(IntCC::Equal, val, 0);\n+                                CValue::by_val(fx.bcx.ins().bint(types::I8, res), layout)\n                             }\n-                        }\n+                            ty::Uint(_) | ty::Int(_) => {\n+                                CValue::by_val(fx.bcx.ins().bnot(val), layout)\n+                            }\n+                            _ => unreachable!(\"un op Not for {:?}\", layout.ty),\n+                        },\n                         UnOp::Neg => match layout.ty.kind {\n                             ty::Int(IntTy::I128) => {\n                                 // FIXME remove this case once ineg.i128 works\n                                 let zero = CValue::const_val(fx, layout, 0);\n                                 crate::num::trans_int_binop(fx, BinOp::Sub, zero, operand)\n                             }\n-                            ty::Int(_) => {\n-                                CValue::by_val(fx.bcx.ins().ineg(val), layout)\n-                            }\n-                            ty::Float(_) => {\n-                                CValue::by_val(fx.bcx.ins().fneg(val), layout)\n-                            }\n+                            ty::Int(_) => CValue::by_val(fx.bcx.ins().ineg(val), layout),\n+                            ty::Float(_) => CValue::by_val(fx.bcx.ins().fneg(val), layout),\n                             _ => unreachable!(\"un op Neg for {:?}\", layout.ty),\n                         },\n                     };\n@@ -474,9 +505,14 @@ fn trans_stmt<'tcx>(\n                     match from_ty.kind {\n                         ty::FnDef(def_id, substs) => {\n                             let func_ref = fx.get_function_ref(\n-                                Instance::resolve_for_fn_ptr(fx.tcx, ParamEnv::reveal_all(), def_id, substs)\n-                                    .unwrap()\n-                                    .polymorphize(fx.tcx),\n+                                Instance::resolve_for_fn_ptr(\n+                                    fx.tcx,\n+                                    ParamEnv::reveal_all(),\n+                                    def_id,\n+                                    substs,\n+                                )\n+                                .unwrap()\n+                                .polymorphize(fx.tcx),\n                             );\n                             let func_addr = fx.bcx.ins().func_addr(fx.pointer_type, func_ref);\n                             lval.write_cvalue(fx, CValue::by_val(func_addr, to_layout));\n@@ -505,7 +541,9 @@ fn trans_stmt<'tcx>(\n                                 |ty::TypeAndMut {\n                                      ty: pointee_ty,\n                                      mutbl: _,\n-                                 }| has_ptr_meta(fx.tcx, pointee_ty),\n+                                 }| {\n+                                    has_ptr_meta(fx.tcx, pointee_ty)\n+                                },\n                             )\n                             .unwrap_or(false)\n                     }\n@@ -527,13 +565,20 @@ fn trans_stmt<'tcx>(\n                             _ => unreachable!(\"cast adt {} -> {}\", from_ty, to_ty),\n                         }\n \n-                        use rustc_target::abi::{TagEncoding, Int, Variants};\n+                        use rustc_target::abi::{Int, TagEncoding, Variants};\n \n                         match &operand.layout().variants {\n                             Variants::Single { index } => {\n-                                let discr = operand.layout().ty.discriminant_for_variant(fx.tcx, *index).unwrap();\n+                                let discr = operand\n+                                    .layout()\n+                                    .ty\n+                                    .discriminant_for_variant(fx.tcx, *index)\n+                                    .unwrap();\n                                 let discr = if discr.ty.is_signed() {\n-                                    rustc_middle::mir::interpret::sign_extend(discr.val, fx.layout_of(discr.ty).size)\n+                                    rustc_middle::mir::interpret::sign_extend(\n+                                        discr.val,\n+                                        fx.layout_of(discr.ty).size,\n+                                    )\n                                 } else {\n                                     discr.val\n                                 };\n@@ -550,7 +595,8 @@ fn trans_stmt<'tcx>(\n                                 let cast_to = fx.clif_type(dest_layout.ty).unwrap();\n \n                                 // Read the tag/niche-encoded discriminant from memory.\n-                                let encoded_discr = operand.value_field(fx, mir::Field::new(*tag_field));\n+                                let encoded_discr =\n+                                    operand.value_field(fx, mir::Field::new(*tag_field));\n                                 let encoded_discr = encoded_discr.load_scalar(fx);\n \n                                 // Decode the discriminant (specifically if it's niche-encoded).\n@@ -562,7 +608,7 @@ fn trans_stmt<'tcx>(\n                                 let val = CValue::by_val(val, dest_layout);\n                                 lval.write_cvalue(fx, val);\n                             }\n-                            Variants::Multiple { ..} => unreachable!(),\n+                            Variants::Multiple { .. } => unreachable!(),\n                         }\n                     } else {\n                         let to_clif_ty = fx.clif_type(to_ty).unwrap();\n@@ -578,7 +624,11 @@ fn trans_stmt<'tcx>(\n                         lval.write_cvalue(fx, CValue::by_val(res, dest_layout));\n                     }\n                 }\n-                Rvalue::Cast(CastKind::Pointer(PointerCast::ClosureFnPointer(_)), operand, _to_ty) => {\n+                Rvalue::Cast(\n+                    CastKind::Pointer(PointerCast::ClosureFnPointer(_)),\n+                    operand,\n+                    _to_ty,\n+                ) => {\n                     let operand = trans_operand(fx, operand);\n                     match operand.layout().ty.kind {\n                         ty::Closure(def_id, substs) => {\n@@ -587,7 +637,8 @@ fn trans_stmt<'tcx>(\n                                 def_id,\n                                 substs,\n                                 ty::ClosureKind::FnOnce,\n-                            ).polymorphize(fx.tcx);\n+                            )\n+                            .polymorphize(fx.tcx);\n                             let func_ref = fx.get_function_ref(instance);\n                             let func_addr = fx.bcx.ins().func_addr(fx.pointer_type, func_ref);\n                             lval.write_cvalue(fx, CValue::by_val(func_addr, lval.layout()));\n@@ -660,7 +711,8 @@ fn trans_stmt<'tcx>(\n                         .ty\n                         .is_sized(fx.tcx.at(stmt.source_info.span), ParamEnv::reveal_all()));\n                     let ty_size = fx.layout_of(fx.monomorphize(ty)).size.bytes();\n-                    let val = CValue::const_val(fx, fx.layout_of(fx.tcx.types.usize), ty_size.into());\n+                    let val =\n+                        CValue::const_val(fx, fx.layout_of(fx.tcx.types.usize), ty_size.into());\n                     lval.write_cvalue(fx, val);\n                 }\n                 Rvalue::Aggregate(kind, operands) => match **kind {\n@@ -691,12 +743,12 @@ fn trans_stmt<'tcx>(\n                 inputs,\n             } = &**asm;\n             let rustc_hir::LlvmInlineAsmInner {\n-                asm: asm_code, // Name\n+                asm: asm_code,         // Name\n                 outputs: output_names, // Vec<LlvmInlineAsmOutput>\n                 inputs: input_names,   // Vec<Name>\n-                clobbers,      // Vec<Name>\n-                volatile,      // bool\n-                alignstack,    // bool\n+                clobbers,              // Vec<Name>\n+                volatile,              // bool\n+                alignstack,            // bool\n                 dialect: _,\n                 asm_str_style: _,\n             } = asm;\n@@ -705,9 +757,15 @@ fn trans_stmt<'tcx>(\n                     // Black box\n                 }\n                 \"mov %rbx, %rsi\\n                  cpuid\\n                  xchg %rbx, %rsi\" => {\n-                    assert_eq!(input_names, &[Symbol::intern(\"{eax}\"), Symbol::intern(\"{ecx}\")]);\n+                    assert_eq!(\n+                        input_names,\n+                        &[Symbol::intern(\"{eax}\"), Symbol::intern(\"{ecx}\")]\n+                    );\n                     assert_eq!(output_names.len(), 4);\n-                    for (i, c) in (&[\"={eax}\", \"={esi}\", \"={ecx}\", \"={edx}\"]).iter().enumerate() {\n+                    for (i, c) in (&[\"={eax}\", \"={esi}\", \"={ecx}\", \"={edx}\"])\n+                        .iter()\n+                        .enumerate()\n+                    {\n                         assert_eq!(&output_names[i].constraint.as_str(), c);\n                         assert!(!output_names[i].is_rw);\n                         assert!(!output_names[i].is_indirect);\n@@ -722,13 +780,18 @@ fn trans_stmt<'tcx>(\n                     let leaf = trans_operand(fx, &inputs[0].1).load_scalar(fx); // %eax\n                     let subleaf = trans_operand(fx, &inputs[1].1).load_scalar(fx); // %ecx\n \n-                    let (eax, ebx, ecx, edx) = crate::intrinsics::codegen_cpuid_call(fx, leaf, subleaf);\n+                    let (eax, ebx, ecx, edx) =\n+                        crate::intrinsics::codegen_cpuid_call(fx, leaf, subleaf);\n \n                     assert_eq!(outputs.len(), 4);\n-                    trans_place(fx, outputs[0]).write_cvalue(fx, CValue::by_val(eax, fx.layout_of(fx.tcx.types.u32)));\n-                    trans_place(fx, outputs[1]).write_cvalue(fx, CValue::by_val(ebx, fx.layout_of(fx.tcx.types.u32)));\n-                    trans_place(fx, outputs[2]).write_cvalue(fx, CValue::by_val(ecx, fx.layout_of(fx.tcx.types.u32)));\n-                    trans_place(fx, outputs[3]).write_cvalue(fx, CValue::by_val(edx, fx.layout_of(fx.tcx.types.u32)));\n+                    trans_place(fx, outputs[0])\n+                        .write_cvalue(fx, CValue::by_val(eax, fx.layout_of(fx.tcx.types.u32)));\n+                    trans_place(fx, outputs[1])\n+                        .write_cvalue(fx, CValue::by_val(ebx, fx.layout_of(fx.tcx.types.u32)));\n+                    trans_place(fx, outputs[2])\n+                        .write_cvalue(fx, CValue::by_val(ecx, fx.layout_of(fx.tcx.types.u32)));\n+                    trans_place(fx, outputs[3])\n+                        .write_cvalue(fx, CValue::by_val(edx, fx.layout_of(fx.tcx.types.u32)));\n                 }\n                 \"xgetbv\" => {\n                     assert_eq!(input_names, &[Symbol::intern(\"{ecx}\")]);\n@@ -748,7 +811,12 @@ fn trans_stmt<'tcx>(\n                     crate::trap::trap_unimplemented(fx, \"_xgetbv arch intrinsic is not supported\");\n                 }\n                 // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n-                _ if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") => {\n+                _ if fx\n+                    .tcx\n+                    .symbol_name(fx.instance)\n+                    .name\n+                    .starts_with(\"___chkstk\") =>\n+                {\n                     crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n                 }\n                 _ if fx.tcx.symbol_name(fx.instance).name == \"__alloca\" => {\n@@ -758,7 +826,10 @@ fn trans_stmt<'tcx>(\n                 \"int $$0x29\" => {\n                     crate::trap::trap_unimplemented(fx, \"Windows abort\");\n                 }\n-                _ => fx.tcx.sess.span_fatal(stmt.source_info.span, \"Inline assembly is not supported\"),\n+                _ => fx\n+                    .tcx\n+                    .sess\n+                    .span_fatal(stmt.source_info.span, \"Inline assembly is not supported\"),\n             }\n         }\n         StatementKind::Coverage { .. } => fx.tcx.sess.fatal(\"-Zcoverage is unimplemented\"),\n@@ -771,7 +842,8 @@ fn codegen_array_len<'tcx>(\n ) -> Value {\n     match place.layout().ty.kind {\n         ty::Array(_elem_ty, len) => {\n-            let len = fx.monomorphize(&len)\n+            let len = fx\n+                .monomorphize(&len)\n                 .eval(fx.tcx, ParamEnv::reveal_all())\n                 .eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64;\n             fx.bcx.ins().iconst(fx.pointer_type, len)\n@@ -836,7 +908,9 @@ pub(crate) fn trans_place<'tcx>(\n                         let len = len.unwrap();\n                         cplace = CPlace::for_ptr_with_extra(\n                             ptr.offset_i64(fx, elem_layout.size.bytes() as i64 * i64::from(from)),\n-                            fx.bcx.ins().iadd_imm(len, -(i64::from(from) + i64::from(to))),\n+                            fx.bcx\n+                                .ins()\n+                                .iadd_imm(len, -(i64::from(from) + i64::from(to))),\n                             cplace.layout(),\n                         );\n                     }"}, {"sha": "cbce7d9d1287d6dafd7570378108b49855793ade", "filename": "src/codegen_i128.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodegen_i128.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -98,7 +98,7 @@ pub(crate) fn maybe_codegen<'tcx>(\n             // Optimize `val >> 64`, because compiler_builtins uses it to deconstruct an 128bit\n             // integer into its lsb and msb.\n             // https://github.com/rust-lang-nursery/compiler-builtins/blob/79a6a1603d5672cbb9187ff41ff4d9b5048ac1cb/src/int/mod.rs#L217\n-            if  resolve_value_imm(fx.bcx.func, rhs_val) == Some(64) {\n+            if resolve_value_imm(fx.bcx.func, rhs_val) == Some(64) {\n                 let (lhs_lsb, lhs_msb) = fx.bcx.ins().isplit(lhs_val);\n                 let all_zeros = fx.bcx.ins().iconst(types::I64, 0);\n                 let val = match (bin_op, is_signed) {"}, {"sha": "3c65e7aad21192887766faedc3e81ef6352a24f9", "filename": "src/common.rs", "status": "modified", "additions": 39, "deletions": 21, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -1,6 +1,6 @@\n+use rustc_index::vec::IndexVec;\n use rustc_target::abi::{Integer, Primitive};\n use rustc_target::spec::{HasTargetSpec, Target};\n-use rustc_index::vec::IndexVec;\n \n use cranelift_codegen::ir::{InstructionData, Opcode, ValueDef};\n \n@@ -55,15 +55,20 @@ fn clif_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<types::Typ\n             FloatTy::F64 => types::F64,\n         },\n         ty::FnPtr(_) => pointer_ty(tcx),\n-        ty::RawPtr(TypeAndMut { ty: pointee_ty, mutbl: _ }) | ty::Ref(_, pointee_ty, _) => {\n+        ty::RawPtr(TypeAndMut {\n+            ty: pointee_ty,\n+            mutbl: _,\n+        })\n+        | ty::Ref(_, pointee_ty, _) => {\n             if has_ptr_meta(tcx, pointee_ty) {\n                 return None;\n             } else {\n                 pointer_ty(tcx)\n             }\n         }\n         ty::Adt(adt_def, _) if adt_def.repr.simd() => {\n-            let (element, count) = match &tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap().abi {\n+            let (element, count) = match &tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap().abi\n+            {\n                 Abi::Vector { element, count } => (element.clone(), *count),\n                 _ => unreachable!(),\n             };\n@@ -79,7 +84,10 @@ fn clif_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<types::Typ\n     })\n }\n \n-fn clif_pair_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<(types::Type, types::Type)> {\n+fn clif_pair_type_from_ty<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Option<(types::Type, types::Type)> {\n     Some(match ty.kind {\n         ty::Tuple(substs) if substs.len() == 2 => {\n             let mut types = substs.types();\n@@ -90,11 +98,15 @@ fn clif_pair_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<(type\n             }\n             (a, b)\n         }\n-        ty::RawPtr(TypeAndMut { ty: pointee_ty, mutbl: _ }) | ty::Ref(_, pointee_ty, _) => {\n+        ty::RawPtr(TypeAndMut {\n+            ty: pointee_ty,\n+            mutbl: _,\n+        })\n+        | ty::Ref(_, pointee_ty, _) => {\n             if has_ptr_meta(tcx, pointee_ty) {\n                 (pointer_ty(tcx), pointer_ty(tcx))\n             } else {\n-                return None\n+                return None;\n             }\n         }\n         _ => return None,\n@@ -103,8 +115,15 @@ fn clif_pair_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<(type\n \n /// Is a pointer to this type a fat ptr?\n pub(crate) fn has_ptr_meta<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    let ptr_ty = tcx.mk_ptr(TypeAndMut { ty, mutbl: rustc_hir::Mutability::Not });\n-    match &tcx.layout_of(ParamEnv::reveal_all().and(ptr_ty)).unwrap().abi {\n+    let ptr_ty = tcx.mk_ptr(TypeAndMut {\n+        ty,\n+        mutbl: rustc_hir::Mutability::Not,\n+    });\n+    match &tcx\n+        .layout_of(ParamEnv::reveal_all().and(ptr_ty))\n+        .unwrap()\n+        .abi\n+    {\n         Abi::Scalar(_) => false,\n         Abi::ScalarPair(_, _) => true,\n         abi => unreachable!(\"Abi of ptr to {:?} is {:?}???\", ty, abi),\n@@ -200,7 +219,11 @@ pub(crate) fn resolve_value_imm(func: &Function, val: Value) -> Option<u128> {\n     }\n }\n \n-pub(crate) fn type_min_max_value(bcx: &mut FunctionBuilder<'_>, ty: Type, signed: bool) -> (Value, Value) {\n+pub(crate) fn type_min_max_value(\n+    bcx: &mut FunctionBuilder<'_>,\n+    ty: Type,\n+    signed: bool,\n+) -> (Value, Value) {\n     assert!(ty.is_int());\n \n     if ty == types::I128 {\n@@ -339,13 +362,11 @@ impl<'tcx, B: Backend + 'static> FunctionCx<'_, 'tcx, B> {\n         T: TypeFoldable<'tcx> + Copy,\n     {\n         if let Some(substs) = self.instance.substs_for_mir_body() {\n-            self.tcx.subst_and_normalize_erasing_regions(\n-                substs,\n-                ty::ParamEnv::reveal_all(),\n-                value,\n-            )\n+            self.tcx\n+                .subst_and_normalize_erasing_regions(substs, ty::ParamEnv::reveal_all(), value)\n         } else {\n-            self.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), *value)\n+            self.tcx\n+                .normalize_erasing_regions(ty::ParamEnv::reveal_all(), *value)\n         }\n     }\n \n@@ -385,11 +406,7 @@ impl<'tcx, B: Backend + 'static> FunctionCx<'_, 'tcx, B> {\n             caller.line as u32,\n             caller.col_display as u32 + 1,\n         ));\n-        crate::constant::trans_const_value(\n-            self,\n-            const_loc,\n-            self.tcx.caller_location_ty(),\n-        )\n+        crate::constant::trans_const_value(self, const_loc, self.tcx.caller_location_ty())\n     }\n \n     pub(crate) fn triple(&self) -> &target_lexicon::Triple {\n@@ -406,7 +423,8 @@ impl<'tcx, B: Backend + 'static> FunctionCx<'_, 'tcx, B> {\n         let mut data_ctx = DataContext::new();\n         data_ctx.define(msg.as_bytes().to_vec().into_boxed_slice());\n         let msg_id = self\n-            .cx.module\n+            .cx\n+            .module\n             .declare_data(\n                 &format!(\"__{}_{:08x}\", prefix, msg_hash),\n                 Linkage::Local,"}, {"sha": "d1248110d06cd553a6797fff476fcccf754d8823", "filename": "src/constant.rs", "status": "modified", "additions": 99, "deletions": 39, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -1,13 +1,13 @@\n use rustc_span::DUMMY_SP;\n \n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::ErrorReported;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::interpret::{\n     read_target_uint, AllocId, Allocation, ConstValue, ErrorHandled, GlobalAlloc, Pointer, Scalar,\n };\n use rustc_middle::ty::{Const, ConstKind};\n use rustc_target::abi::Align;\n-use rustc_data_structures::fx::FxHashSet;\n \n use cranelift_codegen::ir::GlobalValueData;\n use cranelift_module::*;\n@@ -41,19 +41,31 @@ pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n         match const_.val {\n             ConstKind::Value(_) => {}\n             ConstKind::Unevaluated(def, ref substs, promoted) => {\n-                if let Err(err) = fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None) {\n+                if let Err(err) =\n+                    fx.tcx\n+                        .const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None)\n+                {\n                     match err {\n                         ErrorHandled::Reported(ErrorReported) | ErrorHandled::Linted => {\n-                            fx.tcx.sess.span_err(constant.span, \"erroneous constant encountered\");\n+                            fx.tcx\n+                                .sess\n+                                .span_err(constant.span, \"erroneous constant encountered\");\n                         }\n                         ErrorHandled::TooGeneric => {\n-                            span_bug!(constant.span, \"codgen encountered polymorphic constant: {:?}\", err);\n+                            span_bug!(\n+                                constant.span,\n+                                \"codgen encountered polymorphic constant: {:?}\",\n+                                err\n+                            );\n                         }\n                     }\n                 }\n             }\n-            ConstKind::Param(_) | ConstKind::Infer(_) | ConstKind::Bound(_, _)\n-            | ConstKind::Placeholder(_) | ConstKind::Error(_) => unreachable!(\"{:?}\", const_),\n+            ConstKind::Param(_)\n+            | ConstKind::Infer(_)\n+            | ConstKind::Bound(_, _)\n+            | ConstKind::Placeholder(_)\n+            | ConstKind::Error(_) => unreachable!(\"{:?}\", const_),\n         }\n     }\n }\n@@ -86,7 +98,10 @@ fn codegen_static_ref<'tcx>(\n     fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n     let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);\n     assert!(!layout.is_unsized(), \"unsized statics aren't supported\");\n-    assert!(matches!(fx.bcx.func.global_values[local_data_id], GlobalValueData::Symbol { tls: false, ..}), \"tls static referenced without Rvalue::ThreadLocalRef\");\n+    assert!(\n+        matches!(fx.bcx.func.global_values[local_data_id], GlobalValueData::Symbol { tls: false, ..}),\n+        \"tls static referenced without Rvalue::ThreadLocalRef\"\n+    );\n     CPlace::for_ptr(crate::pointer::Pointer::new(global_ptr), layout)\n }\n \n@@ -105,14 +120,20 @@ pub(crate) fn trans_constant<'tcx>(\n                 fx,\n                 def.did,\n                 fx.layout_of(fx.monomorphize(&constant.literal.ty)),\n-            ).to_cvalue(fx);\n+            )\n+            .to_cvalue(fx);\n         }\n         ConstKind::Unevaluated(def, ref substs, promoted) => {\n-            match fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None) {\n+            match fx\n+                .tcx\n+                .const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None)\n+            {\n                 Ok(const_val) => const_val,\n                 Err(_) => {\n                     if promoted.is_none() {\n-                        fx.tcx.sess.span_err(constant.span, \"erroneous constant encountered\");\n+                        fx.tcx\n+                            .sess\n+                            .span_err(constant.span, \"erroneous constant encountered\");\n                     }\n                     return crate::trap::trap_unreachable_ret_value(\n                         fx,\n@@ -122,8 +143,11 @@ pub(crate) fn trans_constant<'tcx>(\n                 }\n             }\n         }\n-        ConstKind::Param(_) | ConstKind::Infer(_) | ConstKind::Bound(_, _)\n-        | ConstKind::Placeholder(_) | ConstKind::Error(_) => unreachable!(\"{:?}\", const_),\n+        ConstKind::Param(_)\n+        | ConstKind::Infer(_)\n+        | ConstKind::Bound(_, _)\n+        | ConstKind::Placeholder(_)\n+        | ConstKind::Error(_) => unreachable!(\"{:?}\", const_),\n     };\n \n     trans_const_value(fx, const_val, const_.ty)\n@@ -132,7 +156,7 @@ pub(crate) fn trans_constant<'tcx>(\n pub(crate) fn trans_const_value<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n     const_val: ConstValue<'tcx>,\n-    ty: Ty<'tcx>\n+    ty: Ty<'tcx>,\n ) -> CValue<'tcx> {\n     let layout = fx.layout_of(ty);\n     assert!(!layout.is_unsized(), \"sized const value\");\n@@ -149,7 +173,9 @@ pub(crate) fn trans_const_value<'tcx>(\n             if fx.clif_type(layout.ty).is_none() {\n                 let (size, align) = (layout.size, layout.align.pref);\n                 let mut alloc = Allocation::from_bytes(\n-                    std::iter::repeat(0).take(size.bytes_usize()).collect::<Vec<u8>>(),\n+                    std::iter::repeat(0)\n+                        .take(size.bytes_usize())\n+                        .collect::<Vec<u8>>(),\n                     align,\n                 );\n                 let ptr = Pointer::new(AllocId(!0), Size::ZERO); // The alloc id is never used\n@@ -168,44 +194,58 @@ pub(crate) fn trans_const_value<'tcx>(\n                     let base_addr = match alloc_kind {\n                         Some(GlobalAlloc::Memory(alloc)) => {\n                             fx.cx.constants_cx.todo.push(TodoItem::Alloc(ptr.alloc_id));\n-                            let data_id = data_id_for_alloc_id(&mut fx.cx.module, ptr.alloc_id, alloc.align, alloc.mutability);\n-                            let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+                            let data_id = data_id_for_alloc_id(\n+                                &mut fx.cx.module,\n+                                ptr.alloc_id,\n+                                alloc.align,\n+                                alloc.mutability,\n+                            );\n+                            let local_data_id =\n+                                fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n                             #[cfg(debug_assertions)]\n                             fx.add_comment(local_data_id, format!(\"{:?}\", ptr.alloc_id));\n                             fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n                         }\n                         Some(GlobalAlloc::Function(instance)) => {\n-                            let func_id = crate::abi::import_function(fx.tcx, &mut fx.cx.module, instance);\n-                            let local_func_id = fx.cx.module.declare_func_in_func(func_id, &mut fx.bcx.func);\n+                            let func_id =\n+                                crate::abi::import_function(fx.tcx, &mut fx.cx.module, instance);\n+                            let local_func_id =\n+                                fx.cx.module.declare_func_in_func(func_id, &mut fx.bcx.func);\n                             fx.bcx.ins().func_addr(fx.pointer_type, local_func_id)\n                         }\n                         Some(GlobalAlloc::Static(def_id)) => {\n                             assert!(fx.tcx.is_static(def_id));\n-                            let data_id = data_id_for_static(fx.tcx, &mut fx.cx.module, def_id, false);\n-                            let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+                            let data_id =\n+                                data_id_for_static(fx.tcx, &mut fx.cx.module, def_id, false);\n+                            let local_data_id =\n+                                fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n                             #[cfg(debug_assertions)]\n                             fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n                             fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n                         }\n                         None => bug!(\"missing allocation {:?}\", ptr.alloc_id),\n                     };\n-                    let val = fx.bcx.ins().iadd_imm(base_addr, i64::try_from(ptr.offset.bytes()).unwrap());\n+                    let val = fx\n+                        .bcx\n+                        .ins()\n+                        .iadd_imm(base_addr, i64::try_from(ptr.offset.bytes()).unwrap());\n                     return CValue::by_val(val, layout);\n                 }\n             }\n         }\n-        ConstValue::ByRef { alloc, offset } => {\n-            CValue::by_ref(\n-                pointer_for_allocation(fx, alloc)\n-                    .offset_i64(fx, i64::try_from(offset.bytes()).unwrap()),\n-                layout,\n-            )\n-        }\n+        ConstValue::ByRef { alloc, offset } => CValue::by_ref(\n+            pointer_for_allocation(fx, alloc)\n+                .offset_i64(fx, i64::try_from(offset.bytes()).unwrap()),\n+            layout,\n+        ),\n         ConstValue::Slice { data, start, end } => {\n             let ptr = pointer_for_allocation(fx, data)\n                 .offset_i64(fx, i64::try_from(start).unwrap())\n                 .get_addr(fx);\n-            let len = fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(end.checked_sub(start).unwrap()).unwrap());\n+            let len = fx.bcx.ins().iconst(\n+                fx.pointer_type,\n+                i64::try_from(end.checked_sub(start).unwrap()).unwrap(),\n+            );\n             CValue::by_val_pair(ptr, len, layout)\n         }\n     }\n@@ -254,7 +294,8 @@ fn data_id_for_static(\n         crate::linkage::get_static_linkage(tcx, def_id)\n     } else {\n         if rlinkage == Some(rustc_middle::mir::mono::Linkage::ExternalWeak)\n-        || rlinkage == Some(rustc_middle::mir::mono::Linkage::WeakAny) {\n+            || rlinkage == Some(rustc_middle::mir::mono::Linkage::WeakAny)\n+        {\n             Linkage::Preemptible\n         } else {\n             Linkage::Import\n@@ -309,7 +350,11 @@ fn data_id_for_static(\n             .unwrap();\n         let mut data_ctx = DataContext::new();\n         let data = module.declare_data_in_data(data_id, &mut data_ctx);\n-        data_ctx.define(std::iter::repeat(0).take(pointer_ty(tcx).bytes() as usize).collect());\n+        data_ctx.define(\n+            std::iter::repeat(0)\n+                .take(pointer_ty(tcx).bytes() as usize)\n+                .collect(),\n+        );\n         data_ctx.write_data_addr(0, data, 0);\n         match module.define_data(ref_data_id, &data_ctx) {\n             // Every time the static is referenced there will be another definition of this global,\n@@ -338,7 +383,10 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut Module<impl Backend>, cx: &mu\n             TodoItem::Static(def_id) => {\n                 //println!(\"static {:?}\", def_id);\n \n-                let section_name = tcx.codegen_fn_attrs(def_id).link_section.map(|s| s.as_str());\n+                let section_name = tcx\n+                    .codegen_fn_attrs(def_id)\n+                    .link_section\n+                    .map(|s| s.as_str());\n \n                 let const_ = tcx.const_eval_poly(def_id).unwrap();\n \n@@ -364,15 +412,19 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut Module<impl Backend>, cx: &mu\n             data_ctx.set_segment_section(\"\", &*section_name);\n         }\n \n-        let bytes = alloc.inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len()).to_vec();\n+        let bytes = alloc\n+            .inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len())\n+            .to_vec();\n         data_ctx.define(bytes.into_boxed_slice());\n \n         for &(offset, (_tag, reloc)) in alloc.relocations().iter() {\n             let addend = {\n                 let endianness = tcx.data_layout.endian;\n                 let offset = offset.bytes() as usize;\n                 let ptr_size = tcx.data_layout.pointer_size;\n-                let bytes = &alloc.inspect_with_uninit_and_ptr_outside_interpreter(offset..offset + ptr_size.bytes() as usize);\n+                let bytes = &alloc.inspect_with_uninit_and_ptr_outside_interpreter(\n+                    offset..offset + ptr_size.bytes() as usize,\n+                );\n                 read_target_uint(endianness, bytes).unwrap()\n             };\n \n@@ -390,8 +442,15 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut Module<impl Backend>, cx: &mu\n                     data_id_for_alloc_id(module, reloc, target_alloc.align, target_alloc.mutability)\n                 }\n                 GlobalAlloc::Static(def_id) => {\n-                    if tcx.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) {\n-                        tcx.sess.fatal(&format!(\"Allocation {:?} contains reference to TLS value {:?}\", alloc, def_id));\n+                    if tcx\n+                        .codegen_fn_attrs(def_id)\n+                        .flags\n+                        .contains(CodegenFnAttrFlags::THREAD_LOCAL)\n+                    {\n+                        tcx.sess.fatal(&format!(\n+                            \"Allocation {:?} contains reference to TLS value {:?}\",\n+                            alloc, def_id\n+                        ));\n                     }\n \n                     // Don't push a `TodoItem::Static` here, as it will cause statics used by\n@@ -418,8 +477,9 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n ) -> Option<&'tcx Const<'tcx>> {\n     match operand {\n         Operand::Copy(_) | Operand::Move(_) => None,\n-        Operand::Constant(const_) => {\n-            Some(fx.monomorphize(&const_.literal).eval(fx.tcx, ParamEnv::reveal_all()))\n-        }\n+        Operand::Constant(const_) => Some(\n+            fx.monomorphize(&const_.literal)\n+                .eval(fx.tcx, ParamEnv::reveal_all()),\n+        ),\n     }\n }"}, {"sha": "01cb6d3484db38f9c980b04c7caefb36c95021cc", "filename": "src/debuginfo/emit.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fdebuginfo%2Femit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fdebuginfo%2Femit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Femit.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -83,7 +83,9 @@ impl WriterRelocate {\n                         cranelift_module::FuncId::from_u32(sym.try_into().unwrap()),\n                     );\n                     let val = (addr as u64 as i64 + reloc.addend) as u64;\n-                    self.writer.write_udata_at(reloc.offset as usize, val, reloc.size).unwrap();\n+                    self.writer\n+                        .write_udata_at(reloc.offset as usize, val, reloc.size)\n+                        .unwrap();\n                 }\n             }\n         }"}, {"sha": "798064b07a588b2914c87fb445c3d9cfcd090b18", "filename": "src/debuginfo/line_info.rs", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fdebuginfo%2Fline_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fdebuginfo%2Fline_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fline_info.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -3,13 +3,16 @@ use std::path::{Component, Path};\n \n use crate::prelude::*;\n \n-use rustc_span::{FileName, SourceFile, SourceFileAndLine, Pos, SourceFileHash, SourceFileHashAlgorithm};\n+use rustc_span::{\n+    FileName, Pos, SourceFile, SourceFileAndLine, SourceFileHash, SourceFileHashAlgorithm,\n+};\n \n use cranelift_codegen::binemit::CodeOffset;\n use cranelift_codegen::machinst::MachSrcLoc;\n \n use gimli::write::{\n-    Address, AttributeValue, FileId, LineProgram, LineString, FileInfo, LineStringTable, UnitEntryId,\n+    Address, AttributeValue, FileId, FileInfo, LineProgram, LineString, LineStringTable,\n+    UnitEntryId,\n };\n \n // OPTIMIZATION: It is cheaper to do this in one pass than using `.parent()` and `.file_name()`.\n@@ -18,7 +21,11 @@ fn split_path_dir_and_file(path: &Path) -> (&Path, &OsStr) {\n     let file_name = match iter.next_back() {\n         Some(Component::Normal(p)) => p,\n         component => {\n-            panic!(\"Path component {:?} of path {} is an invalid filename\", component, path.display());\n+            panic!(\n+                \"Path component {:?} of path {} is an invalid filename\",\n+                component,\n+                path.display()\n+            );\n         }\n     };\n     let parent = iter.as_path();\n@@ -27,11 +34,13 @@ fn split_path_dir_and_file(path: &Path) -> (&Path, &OsStr) {\n \n // OPTIMIZATION: Avoid UTF-8 validation on UNIX.\n fn osstr_as_utf8_bytes(path: &OsStr) -> &[u8] {\n-    #[cfg(unix)] {\n+    #[cfg(unix)]\n+    {\n         use std::os::unix::ffi::OsStrExt;\n         return path.as_bytes();\n     }\n-    #[cfg(not(unix))] {\n+    #[cfg(not(unix))]\n+    {\n         return path.to_str().unwrap().as_bytes();\n     }\n }\n@@ -69,11 +78,7 @@ fn line_program_add_file(\n             } else {\n                 line_program.default_directory()\n             };\n-            let file_name = LineString::new(\n-                file_name,\n-                line_program.encoding(),\n-                line_strings,\n-            );\n+            let file_name = LineString::new(file_name, line_program.encoding(), line_strings);\n \n             let info = make_file_info(file.src_hash);\n \n@@ -149,8 +154,7 @@ impl<'tcx> DebugContext<'tcx> {\n             // In order to have a good line stepping behavior in debugger, we overwrite debug\n             // locations of macro expansions with that of the outermost expansion site\n             // (unless the crate is being compiled with `-Z debug-macros`).\n-            let span = if !span.from_expansion() ||\n-                tcx.sess.opts.debugging_opts.debug_macros {\n+            let span = if !span.from_expansion() || tcx.sess.opts.debugging_opts.debug_macros {\n                 span\n             } else {\n                 // Walk up the macro expansion chain until we reach a non-expanded span.\n@@ -163,9 +167,13 @@ impl<'tcx> DebugContext<'tcx> {\n                 Ok(SourceFileAndLine { sf: file, line }) => {\n                     let line_pos = file.line_begin_pos(span.lo());\n \n-                    (file, u64::try_from(line).unwrap() + 1, u64::from((span.lo() - line_pos).to_u32()) + 1)\n+                    (\n+                        file,\n+                        u64::try_from(line).unwrap() + 1,\n+                        u64::from((span.lo() - line_pos).to_u32()) + 1,\n+                    )\n                 }\n-                Err(file) => (file, 0, 0)\n+                Err(file) => (file, 0, 0),\n             };\n \n             // line_program_add_file is very slow.\n@@ -188,10 +196,7 @@ impl<'tcx> DebugContext<'tcx> {\n             line_program.generate_row();\n         };\n \n-        line_program.begin_sequence(Some(Address::Symbol {\n-            symbol,\n-            addend: 0,\n-        }));\n+        line_program.begin_sequence(Some(Address::Symbol { symbol, addend: 0 }));\n \n         let mut func_end = 0;\n \n@@ -220,7 +225,8 @@ impl<'tcx> DebugContext<'tcx> {\n                     let srcloc = func.srclocs[inst];\n                     line_program.row().address_offset = u64::from(offset);\n                     if !srcloc.is_default() {\n-                        let source_info = *source_info_set.get_index(srcloc.bits() as usize).unwrap();\n+                        let source_info =\n+                            *source_info_set.get_index(srcloc.bits() as usize).unwrap();\n                         create_row_for_span(line_program, source_info.span);\n                     } else {\n                         create_row_for_span(line_program, function_span);\n@@ -236,12 +242,12 @@ impl<'tcx> DebugContext<'tcx> {\n         let entry = self.dwarf.unit.get_mut(entry_id);\n         entry.set(\n             gimli::DW_AT_low_pc,\n-            AttributeValue::Address(Address::Symbol {\n-                symbol,\n-                addend: 0,\n-            }),\n+            AttributeValue::Address(Address::Symbol { symbol, addend: 0 }),\n+        );\n+        entry.set(\n+            gimli::DW_AT_high_pc,\n+            AttributeValue::Udata(u64::from(func_end)),\n         );\n-        entry.set(gimli::DW_AT_high_pc, AttributeValue::Udata(u64::from(func_end)));\n \n         self.emit_location(entry_id, function_span);\n "}, {"sha": "04330b6de60ca486d9bfc10b78afd7e38eb00fac", "filename": "src/debuginfo/mod.rs", "status": "modified", "additions": 77, "deletions": 46, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fmod.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -10,8 +10,8 @@ use cranelift_codegen::isa::TargetIsa;\n use cranelift_codegen::ValueLocRange;\n \n use gimli::write::{\n-    Address, AttributeValue, DwarfUnit, Expression, LineProgram,\n-    LineString, Location, LocationList, Range, RangeList, UnitEntryId,\n+    Address, AttributeValue, DwarfUnit, Expression, LineProgram, LineString, Location,\n+    LocationList, Range, RangeList, UnitEntryId,\n };\n use gimli::{Encoding, Format, LineEncoding, RunTimeEndian, X86_64};\n \n@@ -66,7 +66,7 @@ impl<'tcx> DebugContext<'tcx> {\n             Some(path) => {\n                 let name = path.to_string_lossy().into_owned();\n                 (name, None)\n-            },\n+            }\n             None => (tcx.crate_name(LOCAL_CRATE).to_string(), None),\n         };\n \n@@ -141,7 +141,10 @@ impl<'tcx> DebugContext<'tcx> {\n         };\n \n         let type_entry = self.dwarf.unit.get_mut(type_id);\n-        type_entry.set(gimli::DW_AT_name, AttributeValue::String(format!(\"{}\", ty).replace('i', \"u\").into_bytes()));\n+        type_entry.set(\n+            gimli::DW_AT_name,\n+            AttributeValue::String(format!(\"{}\", ty).replace('i', \"u\").into_bytes()),\n+        );\n         type_entry.set(\n             gimli::DW_AT_byte_size,\n             AttributeValue::Udata(u64::from(ty.bytes())),\n@@ -202,18 +205,29 @@ impl<'tcx> DebugContext<'tcx> {\n \n                 for (field_idx, field_def) in variant.fields.iter().enumerate() {\n                     let field_offset = layout.fields.offset(field_idx);\n-                    let field_layout = layout.field(&layout::LayoutCx {\n-                        tcx: self.tcx,\n-                        param_env: ParamEnv::reveal_all(),\n-                    }, field_idx).unwrap();\n+                    let field_layout = layout\n+                        .field(\n+                            &layout::LayoutCx {\n+                                tcx: self.tcx,\n+                                param_env: ParamEnv::reveal_all(),\n+                            },\n+                            field_idx,\n+                        )\n+                        .unwrap();\n \n                     let field_type = self.dwarf_ty(field_layout.ty);\n \n                     let field_id = self.dwarf.unit.add(type_id, gimli::DW_TAG_member);\n                     let field_entry = self.dwarf.unit.get_mut(field_id);\n \n-                    field_entry.set(gimli::DW_AT_name, AttributeValue::String(field_def.ident.as_str().to_string().into_bytes()));\n-                    field_entry.set(gimli::DW_AT_data_member_location, AttributeValue::Udata(field_offset.bytes()));\n+                    field_entry.set(\n+                        gimli::DW_AT_name,\n+                        AttributeValue::String(field_def.ident.as_str().to_string().into_bytes()),\n+                    );\n+                    field_entry.set(\n+                        gimli::DW_AT_data_member_location,\n+                        AttributeValue::Udata(field_offset.bytes()),\n+                    );\n                     field_entry.set(gimli::DW_AT_type, AttributeValue::UnitRef(field_type));\n                 }\n \n@@ -238,10 +252,7 @@ impl<'tcx> DebugContext<'tcx> {\n     fn define_local(&mut self, scope: UnitEntryId, name: String, ty: Ty<'tcx>) -> UnitEntryId {\n         let dw_ty = self.dwarf_ty(ty);\n \n-        let var_id = self\n-            .dwarf\n-            .unit\n-            .add(scope, gimli::DW_TAG_variable);\n+        let var_id = self.dwarf.unit.add(scope, gimli::DW_TAG_variable);\n         let var_entry = self.dwarf.unit.get_mut(var_id);\n \n         var_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n@@ -266,64 +277,73 @@ impl<'tcx> DebugContext<'tcx> {\n         // FIXME: add to appropriate scope instead of root\n         let scope = self.dwarf.unit.root();\n \n-        let entry_id = self\n-            .dwarf\n-            .unit\n-            .add(scope, gimli::DW_TAG_subprogram);\n+        let entry_id = self.dwarf.unit.add(scope, gimli::DW_TAG_subprogram);\n         let entry = self.dwarf.unit.get_mut(entry_id);\n         let name_id = self.dwarf.strings.add(name);\n         // Gdb requires DW_AT_name. Otherwise the DW_TAG_subprogram is skipped.\n-        entry.set(\n-            gimli::DW_AT_name,\n-            AttributeValue::StringRef(name_id),\n-        );\n+        entry.set(gimli::DW_AT_name, AttributeValue::StringRef(name_id));\n         entry.set(\n             gimli::DW_AT_linkage_name,\n             AttributeValue::StringRef(name_id),\n         );\n \n-        let end = self.create_debug_lines(isa, symbol, entry_id, context, mir.span, source_info_set);\n+        let end =\n+            self.create_debug_lines(isa, symbol, entry_id, context, mir.span, source_info_set);\n \n-        self\n-            .unit_range_list\n-            .0\n-            .push(Range::StartLength {\n-                begin: Address::Symbol {\n-                    symbol,\n-                    addend: 0,\n-                },\n-                length: u64::from(end),\n-            });\n+        self.unit_range_list.0.push(Range::StartLength {\n+            begin: Address::Symbol { symbol, addend: 0 },\n+            length: u64::from(end),\n+        });\n \n         if isa.get_mach_backend().is_some() {\n             return; // Not yet implemented for the AArch64 backend.\n         }\n \n         let func_entry = self.dwarf.unit.get_mut(entry_id);\n         // Gdb requires both DW_AT_low_pc and DW_AT_high_pc. Otherwise the DW_TAG_subprogram is skipped.\n-        func_entry.set(gimli::DW_AT_low_pc, AttributeValue::Address(Address::Symbol {\n-            symbol,\n-            addend: 0,\n-        }));\n+        func_entry.set(\n+            gimli::DW_AT_low_pc,\n+            AttributeValue::Address(Address::Symbol { symbol, addend: 0 }),\n+        );\n         // Using Udata for DW_AT_high_pc requires at least DWARF4\n         func_entry.set(gimli::DW_AT_high_pc, AttributeValue::Udata(u64::from(end)));\n \n         // FIXME Remove once actual debuginfo for locals works.\n-        for (i, (param, &val)) in context.func.signature.params.iter().zip(context.func.dfg.block_params(context.func.layout.entry_block().unwrap())).enumerate() {\n+        for (i, (param, &val)) in context\n+            .func\n+            .signature\n+            .params\n+            .iter()\n+            .zip(\n+                context\n+                    .func\n+                    .dfg\n+                    .block_params(context.func.layout.entry_block().unwrap()),\n+            )\n+            .enumerate()\n+        {\n             use cranelift_codegen::ir::ArgumentPurpose;\n             let base_name = match param.purpose {\n                 ArgumentPurpose::Normal => \"arg\",\n                 ArgumentPurpose::StructArgument(_) => \"struct_arg\",\n                 ArgumentPurpose::StructReturn => \"sret\",\n-                ArgumentPurpose::Link | ArgumentPurpose::FramePointer | ArgumentPurpose::CalleeSaved => continue,\n-                ArgumentPurpose::VMContext | ArgumentPurpose::SignatureId | ArgumentPurpose::StackLimit => unreachable!(),\n+                ArgumentPurpose::Link\n+                | ArgumentPurpose::FramePointer\n+                | ArgumentPurpose::CalleeSaved => continue,\n+                ArgumentPurpose::VMContext\n+                | ArgumentPurpose::SignatureId\n+                | ArgumentPurpose::StackLimit => unreachable!(),\n             };\n             let name = format!(\"{}{}\", base_name, i);\n \n             let dw_ty = self.dwarf_ty_for_clif_ty(param.value_type);\n-            let loc = translate_loc(isa, context.func.locations[val], &context.func.stack_slots).unwrap();\n+            let loc =\n+                translate_loc(isa, context.func.locations[val], &context.func.stack_slots).unwrap();\n \n-            let arg_id = self.dwarf.unit.add(entry_id, gimli::DW_TAG_formal_parameter);\n+            let arg_id = self\n+                .dwarf\n+                .unit\n+                .add(entry_id, gimli::DW_TAG_formal_parameter);\n             let var_entry = self.dwarf.unit.get_mut(arg_id);\n \n             var_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n@@ -371,8 +391,10 @@ fn place_location<'tcx>(\n     symbol: usize,\n     context: &Context,\n     local_map: &FxHashMap<mir::Local, CPlace<'tcx>>,\n-    #[allow(rustc::default_hash_types)]\n-    value_labels_ranges: &std::collections::HashMap<ValueLabel, Vec<ValueLocRange>>,\n+    #[allow(rustc::default_hash_types)] value_labels_ranges: &std::collections::HashMap<\n+        ValueLabel,\n+        Vec<ValueLocRange>,\n+    >,\n     place: Place<'tcx>,\n ) -> AttributeValue {\n     assert!(place.projection.is_empty()); // FIXME implement them\n@@ -393,7 +415,12 @@ fn place_location<'tcx>(\n                                 symbol,\n                                 addend: i64::from(value_loc_range.end),\n                             },\n-                            data: translate_loc(isa, value_loc_range.loc, &context.func.stack_slots).unwrap(),\n+                            data: translate_loc(\n+                                isa,\n+                                value_loc_range.loc,\n+                                &context.func.stack_slots,\n+                            )\n+                            .unwrap(),\n                         })\n                         .collect(),\n                 );\n@@ -428,7 +455,11 @@ fn place_location<'tcx>(\n }\n \n // Adapted from https://github.com/CraneStation/wasmtime/blob/5a1845b4caf7a5dba8eda1fef05213a532ed4259/crates/debug/src/transform/expression.rs#L59-L137\n-fn translate_loc(isa: &dyn TargetIsa, loc: ValueLoc, stack_slots: &StackSlots) -> Option<Expression> {\n+fn translate_loc(\n+    isa: &dyn TargetIsa,\n+    loc: ValueLoc,\n+    stack_slots: &StackSlots,\n+) -> Option<Expression> {\n     match loc {\n         ValueLoc::Reg(reg) => {\n             let machine_reg = isa.map_dwarf_register(reg).unwrap();"}, {"sha": "5fc68990b2a5b2d94d03e34373286d1ba0e2ac1b", "filename": "src/debuginfo/unwind.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fdebuginfo%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fdebuginfo%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Funwind.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -1,6 +1,6 @@\n use crate::prelude::*;\n \n-use cranelift_codegen::isa::{TargetIsa, unwind::UnwindInfo};\n+use cranelift_codegen::isa::{unwind::UnwindInfo, TargetIsa};\n \n use gimli::write::{Address, CieId, EhFrame, FrameTable, Section};\n \n@@ -13,13 +13,9 @@ pub(crate) struct UnwindContext<'tcx> {\n }\n \n impl<'tcx> UnwindContext<'tcx> {\n-    pub(crate) fn new(\n-        tcx: TyCtxt<'tcx>,\n-        isa: &dyn TargetIsa,\n-    ) -> Self {\n+    pub(crate) fn new(tcx: TyCtxt<'tcx>, isa: &dyn TargetIsa) -> Self {\n         let mut frame_table = FrameTable::default();\n \n-\n         let cie_id = if let Some(cie) = isa.create_systemv_cie() {\n             Some(frame_table.add_cie(cie))\n         } else {\n@@ -42,19 +38,24 @@ impl<'tcx> UnwindContext<'tcx> {\n \n         match unwind_info {\n             UnwindInfo::SystemV(unwind_info) => {\n-                self.frame_table.add_fde(self.cie_id.unwrap(), unwind_info.to_fde(Address::Symbol {\n-                    symbol: func_id.as_u32() as usize,\n-                    addend: 0,\n-                }));\n-            },\n+                self.frame_table.add_fde(\n+                    self.cie_id.unwrap(),\n+                    unwind_info.to_fde(Address::Symbol {\n+                        symbol: func_id.as_u32() as usize,\n+                        addend: 0,\n+                    }),\n+                );\n+            }\n             UnwindInfo::WindowsX64(_) => {\n                 // FIXME implement this\n             }\n         }\n     }\n \n     pub(crate) fn emit<P: WriteDebugInfo>(self, product: &mut P) {\n-        let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(self.tcx)));\n+        let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(\n+            self.tcx,\n+        )));\n         self.frame_table.write_eh_frame(&mut eh_frame).unwrap();\n \n         if !eh_frame.0.writer.slice().is_empty() {\n@@ -74,7 +75,9 @@ impl<'tcx> UnwindContext<'tcx> {\n         self,\n         jit_module: &mut Module<cranelift_simplejit::SimpleJITBackend>,\n     ) -> Option<UnwindRegistry> {\n-        let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(self.tcx)));\n+        let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(\n+            self.tcx,\n+        )));\n         self.frame_table.write_eh_frame(&mut eh_frame).unwrap();\n \n         if eh_frame.0.writer.slice().is_empty() {"}, {"sha": "53a6acd7c858e0060e517ebd650d8a3da0417f5d", "filename": "src/discriminant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiscriminant.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -1,6 +1,6 @@\n //! Adapted from https://github.com/rust-lang/rust/blob/d760df5aea483aae041c9a241e7acacf48f75035/src/librustc_codegen_ssa/mir/place.rs\n \n-use rustc_target::abi::{TagEncoding, Int, Variants};\n+use rustc_target::abi::{Int, TagEncoding, Variants};\n \n use crate::prelude::*;\n "}, {"sha": "2eecd8c3c0adbd9191702e467a4b5297eceed63d", "filename": "src/driver/aot.rs", "status": "modified", "additions": 110, "deletions": 70, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Faot.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -1,13 +1,13 @@\n use std::path::PathBuf;\n \n+use rustc_codegen_ssa::back::linker::LinkerInfo;\n+use rustc_codegen_ssa::{CodegenResults, CompiledModule, CrateInfo, ModuleKind};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_middle::middle::cstore::EncodedMetadata;\n use rustc_middle::mir::mono::CodegenUnit;\n-use rustc_session::config::{DebugInfo, OutputType};\n use rustc_session::cgu_reuse_tracker::CguReuse;\n-use rustc_codegen_ssa::back::linker::LinkerInfo;\n-use rustc_codegen_ssa::{CrateInfo, CodegenResults, CompiledModule, ModuleKind};\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_session::config::{DebugInfo, OutputType};\n \n use crate::prelude::*;\n \n@@ -21,7 +21,6 @@ fn new_module(tcx: TyCtxt<'_>, name: String) -> Module<crate::backend::Backend>\n \n struct ModuleCodegenResult(CompiledModule, Option<(WorkProductId, WorkProduct)>);\n \n-\n impl<HCX> HashStable<HCX> for ModuleCodegenResult {\n     fn hash_stable(&self, _: &mut HCX, _: &mut StableHasher) {\n         // do nothing\n@@ -37,7 +36,8 @@ fn emit_module<B: Backend>(\n     unwind_context: UnwindContext<'_>,\n     map_product: impl FnOnce(B::Product) -> B::Product,\n ) -> ModuleCodegenResult\n-    where B::Product: AddConstructor + Emit + WriteDebugInfo,\n+where\n+    B::Product: AddConstructor + Emit + WriteDebugInfo,\n {\n     module.finalize_definitions();\n     let mut product = module.finish();\n@@ -55,7 +55,8 @@ fn emit_module<B: Backend>(\n         .temp_path(OutputType::Object, Some(&name));\n     let obj = product.emit();\n     if let Err(err) = std::fs::write(&tmp_file, obj) {\n-        tcx.sess.fatal(&format!(\"error writing object file: {}\", err));\n+        tcx.sess\n+            .fatal(&format!(\"error writing object file: {}\", err));\n     }\n \n     let work_product = if std::env::var(\"CG_CLIF_INCR_CACHE_DISABLED\").is_ok() {\n@@ -88,7 +89,9 @@ fn reuse_workproduct_for_cgu(\n     let mut object = None;\n     let work_product = cgu.work_product(tcx);\n     if let Some(saved_file) = &work_product.saved_file {\n-        let obj_out = tcx.output_filenames(LOCAL_CRATE).temp_path(OutputType::Object, Some(&cgu.name().as_str()));\n+        let obj_out = tcx\n+            .output_filenames(LOCAL_CRATE)\n+            .temp_path(OutputType::Object, Some(&cgu.name().as_str()));\n         object = Some(obj_out.clone());\n         let source_file = rustc_incremental::in_incr_comp_dir(&incr_comp_session_dir, &saved_file);\n         if let Err(err) = rustc_fs_util::link_or_copy(&source_file, &obj_out) {\n@@ -120,22 +123,30 @@ fn module_codegen(tcx: TyCtxt<'_>, cgu_name: rustc_span::Symbol) -> ModuleCodege\n     // Initialize the global atomic mutex using a constructor for proc-macros.\n     // FIXME implement atomic instructions in Cranelift.\n     let mut init_atomics_mutex_from_constructor = None;\n-    if tcx.sess.crate_types().contains(&rustc_session::config::CrateType::ProcMacro) {\n-        if mono_items.iter().any(|(mono_item, _)| {\n-            match mono_item {\n-                rustc_middle::mir::mono::MonoItem::Static(def_id) => {\n-                    tcx.symbol_name(Instance::mono(tcx, *def_id)).name.contains(\"__rustc_proc_macro_decls_\")\n-                }\n-                _ => false,\n-            }\n+    if tcx\n+        .sess\n+        .crate_types()\n+        .contains(&rustc_session::config::CrateType::ProcMacro)\n+    {\n+        if mono_items.iter().any(|(mono_item, _)| match mono_item {\n+            rustc_middle::mir::mono::MonoItem::Static(def_id) => tcx\n+                .symbol_name(Instance::mono(tcx, *def_id))\n+                .name\n+                .contains(\"__rustc_proc_macro_decls_\"),\n+            _ => false,\n         }) {\n-            init_atomics_mutex_from_constructor = Some(crate::atomic_shim::init_global_lock_constructor(&mut module, &format!(\"{}_init_atomics_mutex\", cgu_name.as_str())));\n+            init_atomics_mutex_from_constructor =\n+                Some(crate::atomic_shim::init_global_lock_constructor(\n+                    &mut module,\n+                    &format!(\"{}_init_atomics_mutex\", cgu_name.as_str()),\n+                ));\n         }\n     }\n \n     let mut cx = crate::CodegenCx::new(tcx, module, tcx.sess.opts.debuginfo != DebugInfo::None);\n     super::codegen_mono_items(&mut cx, mono_items);\n-    let (mut module, global_asm, debug, mut unwind_context) = tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n+    let (mut module, global_asm, debug, mut unwind_context) =\n+        tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n     crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module, &mut unwind_context);\n \n     let codegen_result = emit_module(\n@@ -151,7 +162,7 @@ fn module_codegen(tcx: TyCtxt<'_>, cgu_name: rustc_span::Symbol) -> ModuleCodege\n             }\n \n             product\n-        }\n+        },\n     );\n \n     codegen_global_asm(tcx, &cgu.name().as_str(), &global_asm);\n@@ -181,40 +192,46 @@ pub(super) fn run_aot(\n     }\n \n     let modules = super::time(tcx, \"codegen mono items\", || {\n-        cgus.iter().map(|cgu| {\n-            let cgu_reuse = determine_cgu_reuse(tcx, cgu);\n-            tcx.sess.cgu_reuse_tracker.set_actual_reuse(&cgu.name().as_str(), cgu_reuse);\n-\n-            match cgu_reuse {\n-                _ if std::env::var(\"CG_CLIF_INCR_CACHE_DISABLED\").is_ok() => {}\n-                CguReuse::No => {}\n-                CguReuse::PreLto => {\n-                    return reuse_workproduct_for_cgu(tcx, &*cgu, &mut work_products);\n+        cgus.iter()\n+            .map(|cgu| {\n+                let cgu_reuse = determine_cgu_reuse(tcx, cgu);\n+                tcx.sess\n+                    .cgu_reuse_tracker\n+                    .set_actual_reuse(&cgu.name().as_str(), cgu_reuse);\n+\n+                match cgu_reuse {\n+                    _ if std::env::var(\"CG_CLIF_INCR_CACHE_DISABLED\").is_ok() => {}\n+                    CguReuse::No => {}\n+                    CguReuse::PreLto => {\n+                        return reuse_workproduct_for_cgu(tcx, &*cgu, &mut work_products);\n+                    }\n+                    CguReuse::PostLto => unreachable!(),\n                 }\n-                CguReuse::PostLto => unreachable!(),\n-            }\n-\n-            let dep_node = cgu.codegen_dep_node(tcx);\n-            let (ModuleCodegenResult(module, work_product), _) =\n-                tcx.dep_graph.with_task(dep_node, tcx, cgu.name(), module_codegen, rustc_middle::dep_graph::hash_result);\n \n-            if let Some((id, product)) = work_product {\n-                work_products.insert(id, product);\n-            }\n+                let dep_node = cgu.codegen_dep_node(tcx);\n+                let (ModuleCodegenResult(module, work_product), _) = tcx.dep_graph.with_task(\n+                    dep_node,\n+                    tcx,\n+                    cgu.name(),\n+                    module_codegen,\n+                    rustc_middle::dep_graph::hash_result,\n+                );\n+\n+                if let Some((id, product)) = work_product {\n+                    work_products.insert(id, product);\n+                }\n \n-            module\n-        }).collect::<Vec<_>>()\n+                module\n+            })\n+            .collect::<Vec<_>>()\n     });\n \n     tcx.sess.abort_if_errors();\n \n     let mut allocator_module = new_module(tcx, \"allocator_shim\".to_string());\n     let mut allocator_unwind_context = UnwindContext::new(tcx, allocator_module.isa());\n-    let created_alloc_shim = crate::allocator::codegen(\n-        tcx,\n-        &mut allocator_module,\n-        &mut allocator_unwind_context,\n-    );\n+    let created_alloc_shim =\n+        crate::allocator::codegen(tcx, &mut allocator_module, &mut allocator_unwind_context);\n \n     let allocator_module = if created_alloc_shim {\n         let ModuleCodegenResult(module, work_product) = emit_module(\n@@ -257,7 +274,8 @@ pub(super) fn run_aot(\n             });\n \n             if let Err(err) = std::fs::write(&tmp_file, obj) {\n-                tcx.sess.fatal(&format!(\"error writing metadata object file: {}\", err));\n+                tcx.sess\n+                    .fatal(&format!(\"error writing metadata object file: {}\", err));\n             }\n \n             (metadata_cgu_name, tmp_file)\n@@ -277,17 +295,20 @@ pub(super) fn run_aot(\n         rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n     }\n \n-    Box::new((CodegenResults {\n-        crate_name: tcx.crate_name(LOCAL_CRATE),\n-        modules,\n-        allocator_module,\n-        metadata_module,\n-        crate_hash: tcx.crate_hash(LOCAL_CRATE),\n-        metadata,\n-        windows_subsystem: None, // Windows is not yet supported\n-        linker_info: LinkerInfo::new(tcx),\n-        crate_info: CrateInfo::new(tcx),\n-    }, work_products))\n+    Box::new((\n+        CodegenResults {\n+            crate_name: tcx.crate_name(LOCAL_CRATE),\n+            modules,\n+            allocator_module,\n+            metadata_module,\n+            crate_hash: tcx.crate_hash(LOCAL_CRATE),\n+            metadata,\n+            windows_subsystem: None, // Windows is not yet supported\n+            linker_info: LinkerInfo::new(tcx),\n+            crate_info: CrateInfo::new(tcx),\n+        },\n+        work_products,\n+    ))\n }\n \n fn codegen_global_asm(tcx: TyCtxt<'_>, cgu_name: &str, global_asm: &str) {\n@@ -308,23 +329,30 @@ fn codegen_global_asm(tcx: TyCtxt<'_>, cgu_name: &str, global_asm: &str) {\n \n         // FIXME fix linker error on macOS\n         if cfg!(not(feature = \"inline_asm\")) {\n-            tcx.sess.fatal(\"asm! and global_asm! support is disabled while compiling rustc_codegen_cranelift\");\n+            tcx.sess.fatal(\n+                \"asm! and global_asm! support is disabled while compiling rustc_codegen_cranelift\",\n+            );\n         } else {\n-            tcx.sess.fatal(\"asm! and global_asm! are not yet supported on macOS and Windows\");\n+            tcx.sess\n+                .fatal(\"asm! and global_asm! are not yet supported on macOS and Windows\");\n         }\n     }\n \n     let assembler = crate::toolchain::get_toolchain_binary(tcx.sess, \"as\");\n     let linker = crate::toolchain::get_toolchain_binary(tcx.sess, \"ld\");\n \n     // Remove all LLVM style comments\n-    let global_asm = global_asm.lines().map(|line| {\n-        if let Some(index) = line.find(\"//\") {\n-            &line[0..index]\n-        } else {\n-            line\n-        }\n-    }).collect::<Vec<_>>().join(\"\\n\");\n+    let global_asm = global_asm\n+        .lines()\n+        .map(|line| {\n+            if let Some(index) = line.find(\"//\") {\n+                &line[0..index]\n+            } else {\n+                line\n+            }\n+        })\n+        .collect::<Vec<_>>()\n+        .join(\"\\n\");\n \n     let output_object_file = tcx\n         .output_filenames(LOCAL_CRATE)\n@@ -333,22 +361,30 @@ fn codegen_global_asm(tcx: TyCtxt<'_>, cgu_name: &str, global_asm: &str) {\n     // Assemble `global_asm`\n     let global_asm_object_file = add_file_stem_postfix(output_object_file.clone(), \".asm\");\n     let mut child = Command::new(assembler)\n-        .arg(\"-o\").arg(&global_asm_object_file)\n+        .arg(\"-o\")\n+        .arg(&global_asm_object_file)\n         .stdin(Stdio::piped())\n         .spawn()\n         .expect(\"Failed to spawn `as`.\");\n-    child.stdin.take().unwrap().write_all(global_asm.as_bytes()).unwrap();\n+    child\n+        .stdin\n+        .take()\n+        .unwrap()\n+        .write_all(global_asm.as_bytes())\n+        .unwrap();\n     let status = child.wait().expect(\"Failed to wait for `as`.\");\n     if !status.success() {\n-        tcx.sess.fatal(&format!(\"Failed to assemble `{}`\", global_asm));\n+        tcx.sess\n+            .fatal(&format!(\"Failed to assemble `{}`\", global_asm));\n     }\n \n     // Link the global asm and main object file together\n     let main_object_file = add_file_stem_postfix(output_object_file.clone(), \".main\");\n     std::fs::rename(&output_object_file, &main_object_file).unwrap();\n     let status = Command::new(linker)\n         .arg(\"-r\") // Create a new object file\n-        .arg(\"-o\").arg(output_object_file)\n+        .arg(\"-o\")\n+        .arg(output_object_file)\n         .arg(&main_object_file)\n         .arg(&global_asm_object_file)\n         .status()\n@@ -383,7 +419,11 @@ fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguR\n     }\n \n     let work_product_id = &cgu.work_product_id();\n-    if tcx.dep_graph.previous_work_product(work_product_id).is_none() {\n+    if tcx\n+        .dep_graph\n+        .previous_work_product(work_product_id)\n+        .is_none()\n+    {\n         // We don't have anything cached for this CGU. This can happen\n         // if the CGU did not exist in the previous session.\n         return CguReuse::No;"}, {"sha": "195cea02cde8786f8efaf8e3d0c9ae2e75908f47", "filename": "src/driver/jit.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fjit.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -11,9 +11,18 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>) -> ! {\n     // Rustc opens us without the RTLD_GLOBAL flag, so __cg_clif_global_atomic_mutex will not be\n     // exported. We fix this by opening ourself again as global.\n     // FIXME remove once atomic_shim is gone\n-    let cg_dylib = std::ffi::OsString::from(&tcx.sess.opts.debugging_opts.codegen_backend.as_ref().unwrap());\n-    std::mem::forget(libloading::os::unix::Library::open(Some(cg_dylib), libc::RTLD_NOW | libc::RTLD_GLOBAL).unwrap());\n-\n+    let cg_dylib = std::ffi::OsString::from(\n+        &tcx.sess\n+            .opts\n+            .debugging_opts\n+            .codegen_backend\n+            .as_ref()\n+            .unwrap(),\n+    );\n+    std::mem::forget(\n+        libloading::os::unix::Library::open(Some(cg_dylib), libc::RTLD_NOW | libc::RTLD_GLOBAL)\n+            .unwrap(),\n+    );\n \n     let imported_symbols = load_imported_symbols_for_jit(tcx);\n \n@@ -54,10 +63,11 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>) -> ! {\n \n     let mut cx = crate::CodegenCx::new(tcx, jit_module, false);\n \n-    let (mut jit_module, global_asm, _debug, mut unwind_context) = super::time(tcx, \"codegen mono items\", || {\n-        super::codegen_mono_items(&mut cx, mono_items);\n-        tcx.sess.time(\"finalize CodegenCx\", || cx.finalize())\n-    });\n+    let (mut jit_module, global_asm, _debug, mut unwind_context) =\n+        super::time(tcx, \"codegen mono items\", || {\n+            super::codegen_mono_items(&mut cx, mono_items);\n+            tcx.sess.time(\"finalize CodegenCx\", || cx.finalize())\n+        });\n     if !global_asm.is_empty() {\n         tcx.sess.fatal(\"Global asm is not supported in JIT mode\");\n     }"}, {"sha": "304add6f60434443e265999b97fe662ae2ad9aac", "filename": "src/driver/mod.rs", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fmod.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -17,13 +17,17 @@ pub(crate) fn codegen_crate(\n     tcx.sess.abort_if_errors();\n \n     if std::env::var(\"CG_CLIF_JIT\").is_ok()\n-        && tcx.sess.crate_types().contains(&rustc_session::config::CrateType::Executable)\n+        && tcx\n+            .sess\n+            .crate_types()\n+            .contains(&rustc_session::config::CrateType::Executable)\n     {\n         #[cfg(feature = \"jit\")]\n         let _: ! = jit::run_jit(tcx);\n \n         #[cfg(not(feature = \"jit\"))]\n-        tcx.sess.fatal(\"jit support was disabled when compiling rustc_codegen_cranelift\");\n+        tcx.sess\n+            .fatal(\"jit support was disabled when compiling rustc_codegen_cranelift\");\n     }\n \n     aot::run_aot(tcx, metadata, need_metadata_module)\n@@ -37,8 +41,12 @@ fn codegen_mono_items<'tcx>(\n         for &(mono_item, (linkage, visibility)) in &mono_items {\n             match mono_item {\n                 MonoItem::Fn(instance) => {\n-                    let (name, sig) =\n-                        get_function_name_and_sig(cx.tcx, cx.module.isa().triple(), instance, false);\n+                    let (name, sig) = get_function_name_and_sig(\n+                        cx.tcx,\n+                        cx.module.isa().triple(),\n+                        instance,\n+                        false,\n+                    );\n                     let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n                     cx.module.declare_function(&name, linkage, &sig).unwrap();\n                 }\n@@ -85,7 +93,8 @@ fn trans_mono_item<'tcx, B: Backend + 'static>(\n                 }\n             });\n \n-            tcx.sess.time(\"codegen fn\", || crate::base::trans_fn(cx, inst, linkage));\n+            tcx.sess\n+                .time(\"codegen fn\", || crate::base::trans_fn(cx, inst, linkage));\n         }\n         MonoItem::Static(def_id) => {\n             crate::constant::codegen_static(&mut cx.constants_cx, def_id);\n@@ -103,12 +112,21 @@ fn trans_mono_item<'tcx, B: Backend + 'static>(\n }\n \n fn time<R>(tcx: TyCtxt<'_>, name: &'static str, f: impl FnOnce() -> R) -> R {\n-    if std::env::var(\"CG_CLIF_DISPLAY_CG_TIME\").as_ref().map(|val| &**val) == Ok(\"1\") {\n+    if std::env::var(\"CG_CLIF_DISPLAY_CG_TIME\")\n+        .as_ref()\n+        .map(|val| &**val)\n+        == Ok(\"1\")\n+    {\n         println!(\"[{:<30}: {}] start\", tcx.crate_name(LOCAL_CRATE), name);\n         let before = std::time::Instant::now();\n         let res = tcx.sess.time(name, f);\n         let after = std::time::Instant::now();\n-        println!(\"[{:<30}: {}] end time: {:?}\", tcx.crate_name(LOCAL_CRATE), name, after - before);\n+        println!(\n+            \"[{:<30}: {}] end time: {:?}\",\n+            tcx.crate_name(LOCAL_CRATE),\n+            name,\n+            after - before\n+        );\n         res\n     } else {\n         tcx.sess.time(name, f)"}, {"sha": "35b175917446c8378f57a02c041657cffcacebc7", "filename": "src/inline_asm.rs", "status": "modified", "additions": 92, "deletions": 23, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finline_asm.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -2,7 +2,7 @@ use crate::prelude::*;\n \n use std::fmt::Write;\n \n-use rustc_ast::ast::{InlineAsmTemplatePiece, InlineAsmOptions};\n+use rustc_ast::ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_middle::mir::InlineAsmOperand;\n use rustc_target::asm::*;\n \n@@ -45,21 +45,46 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n             InlineAsmOperand::In { reg, ref value } => {\n                 let reg = expect_reg(reg);\n                 clobbered_regs.push((reg, new_slot(reg.reg_class())));\n-                inputs.push((reg, new_slot(reg.reg_class()), crate::base::trans_operand(fx, value).load_scalar(fx)));\n+                inputs.push((\n+                    reg,\n+                    new_slot(reg.reg_class()),\n+                    crate::base::trans_operand(fx, value).load_scalar(fx),\n+                ));\n             }\n-            InlineAsmOperand::Out { reg, late: _, place } => {\n+            InlineAsmOperand::Out {\n+                reg,\n+                late: _,\n+                place,\n+            } => {\n                 let reg = expect_reg(reg);\n                 clobbered_regs.push((reg, new_slot(reg.reg_class())));\n                 if let Some(place) = place {\n-                    outputs.push((reg, new_slot(reg.reg_class()), crate::base::trans_place(fx, place)));\n+                    outputs.push((\n+                        reg,\n+                        new_slot(reg.reg_class()),\n+                        crate::base::trans_place(fx, place),\n+                    ));\n                 }\n             }\n-            InlineAsmOperand::InOut { reg, late: _, ref in_value, out_place } => {\n+            InlineAsmOperand::InOut {\n+                reg,\n+                late: _,\n+                ref in_value,\n+                out_place,\n+            } => {\n                 let reg = expect_reg(reg);\n                 clobbered_regs.push((reg, new_slot(reg.reg_class())));\n-                inputs.push((reg, new_slot(reg.reg_class()), crate::base::trans_operand(fx, in_value).load_scalar(fx)));\n+                inputs.push((\n+                    reg,\n+                    new_slot(reg.reg_class()),\n+                    crate::base::trans_operand(fx, in_value).load_scalar(fx),\n+                ));\n                 if let Some(out_place) = out_place {\n-                    outputs.push((reg, new_slot(reg.reg_class()), crate::base::trans_place(fx, out_place)));\n+                    outputs.push((\n+                        reg,\n+                        new_slot(reg.reg_class()),\n+                        crate::base::trans_place(fx, out_place),\n+                    ));\n                 }\n             }\n             InlineAsmOperand::Const { value: _ } => todo!(),\n@@ -70,9 +95,21 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n \n     let inline_asm_index = fx.inline_asm_index;\n     fx.inline_asm_index += 1;\n-    let asm_name = format!(\"{}__inline_asm_{}\", fx.tcx.symbol_name(fx.instance).name, inline_asm_index);\n+    let asm_name = format!(\n+        \"{}__inline_asm_{}\",\n+        fx.tcx.symbol_name(fx.instance).name,\n+        inline_asm_index\n+    );\n \n-    let generated_asm = generate_asm_wrapper(&asm_name, InlineAsmArch::X86_64, options, template, clobbered_regs, &inputs, &outputs);\n+    let generated_asm = generate_asm_wrapper(\n+        &asm_name,\n+        InlineAsmArch::X86_64,\n+        options,\n+        template,\n+        clobbered_regs,\n+        &inputs,\n+        &outputs,\n+    );\n     fx.cx.global_asm.push_str(&generated_asm);\n \n     call_inline_asm(fx, &asm_name, slot_size, inputs, outputs);\n@@ -90,7 +127,12 @@ fn generate_asm_wrapper(\n     let mut generated_asm = String::new();\n     writeln!(generated_asm, \".globl {}\", asm_name).unwrap();\n     writeln!(generated_asm, \".type {},@function\", asm_name).unwrap();\n-    writeln!(generated_asm, \".section .text.{},\\\"ax\\\",@progbits\", asm_name).unwrap();\n+    writeln!(\n+        generated_asm,\n+        \".section .text.{},\\\"ax\\\",@progbits\",\n+        asm_name\n+    )\n+    .unwrap();\n     writeln!(generated_asm, \"{}:\", asm_name).unwrap();\n \n     generated_asm.push_str(\".intel_syntax noprefix\\n\");\n@@ -120,7 +162,11 @@ fn generate_asm_wrapper(\n             InlineAsmTemplatePiece::String(s) => {\n                 generated_asm.push_str(s);\n             }\n-            InlineAsmTemplatePiece::Placeholder { operand_idx: _, modifier: _, span: _ } => todo!(),\n+            InlineAsmTemplatePiece::Placeholder {\n+                operand_idx: _,\n+                modifier: _,\n+                span: _,\n+            } => todo!(),\n         }\n     }\n     generated_asm.push('\\n');\n@@ -147,7 +193,7 @@ fn generate_asm_wrapper(\n     }\n \n     generated_asm.push_str(\".att_syntax\\n\");\n-    writeln!(generated_asm, \".size {name}, .-{name}\", name=asm_name).unwrap();\n+    writeln!(generated_asm, \".size {name}, .-{name}\", name = asm_name).unwrap();\n     generated_asm.push_str(\".text\\n\");\n     generated_asm.push_str(\"\\n\\n\");\n \n@@ -169,25 +215,41 @@ fn call_inline_asm<'tcx>(\n     #[cfg(debug_assertions)]\n     fx.add_comment(stack_slot, \"inline asm scratch slot\");\n \n-    let inline_asm_func = fx.cx.module.declare_function(asm_name, Linkage::Import, &Signature {\n-        call_conv: CallConv::SystemV,\n-        params: vec![AbiParam::new(fx.pointer_type)],\n-        returns: vec![],\n-    }).unwrap();\n-    let inline_asm_func = fx.cx.module.declare_func_in_func(inline_asm_func, &mut fx.bcx.func);\n+    let inline_asm_func = fx\n+        .cx\n+        .module\n+        .declare_function(\n+            asm_name,\n+            Linkage::Import,\n+            &Signature {\n+                call_conv: CallConv::SystemV,\n+                params: vec![AbiParam::new(fx.pointer_type)],\n+                returns: vec![],\n+            },\n+        )\n+        .unwrap();\n+    let inline_asm_func = fx\n+        .cx\n+        .module\n+        .declare_func_in_func(inline_asm_func, &mut fx.bcx.func);\n     #[cfg(debug_assertions)]\n     fx.add_comment(inline_asm_func, asm_name);\n \n     for (_reg, offset, value) in inputs {\n-        fx.bcx.ins().stack_store(value, stack_slot, i32::try_from(offset.bytes()).unwrap());\n+        fx.bcx\n+            .ins()\n+            .stack_store(value, stack_slot, i32::try_from(offset.bytes()).unwrap());\n     }\n \n     let stack_slot_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n     fx.bcx.ins().call(inline_asm_func, &[stack_slot_addr]);\n \n     for (_reg, offset, place) in outputs {\n         let ty = fx.clif_type(place.layout().ty).unwrap();\n-        let value = fx.bcx.ins().stack_load(ty, stack_slot, i32::try_from(offset.bytes()).unwrap());\n+        let value = fx\n+            .bcx\n+            .ins()\n+            .stack_load(ty, stack_slot, i32::try_from(offset.bytes()).unwrap());\n         place.write_cvalue(fx, CValue::by_val(value, place.layout()));\n     }\n }\n@@ -203,18 +265,25 @@ fn save_register(generated_asm: &mut String, arch: InlineAsmArch, reg: InlineAsm\n     match arch {\n         InlineAsmArch::X86_64 => {\n             write!(generated_asm, \"    mov [rbp+0x{:x}], \", offset.bytes()).unwrap();\n-            reg.emit(generated_asm, InlineAsmArch::X86_64, None).unwrap();\n+            reg.emit(generated_asm, InlineAsmArch::X86_64, None)\n+                .unwrap();\n             generated_asm.push('\\n');\n         }\n         _ => unimplemented!(\"save_register for {:?}\", arch),\n     }\n }\n \n-fn restore_register(generated_asm: &mut String, arch: InlineAsmArch, reg: InlineAsmReg, offset: Size) {\n+fn restore_register(\n+    generated_asm: &mut String,\n+    arch: InlineAsmArch,\n+    reg: InlineAsmReg,\n+    offset: Size,\n+) {\n     match arch {\n         InlineAsmArch::X86_64 => {\n             generated_asm.push_str(\"    mov \");\n-            reg.emit(generated_asm, InlineAsmArch::X86_64, None).unwrap();\n+            reg.emit(generated_asm, InlineAsmArch::X86_64, None)\n+                .unwrap();\n             writeln!(generated_asm, \", [rbp+0x{:x}]\", offset.bytes()).unwrap();\n         }\n         _ => unimplemented!(\"restore_register for {:?}\", arch),"}, {"sha": "48891ab25452fbe8d276c340192afd2693958af1", "filename": "src/intrinsics/cpuid.rs", "status": "modified", "additions": 38, "deletions": 15, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fintrinsics%2Fcpuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fintrinsics%2Fcpuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fcpuid.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -29,37 +29,60 @@ pub(crate) fn codegen_cpuid_call<'tcx>(\n \n     fx.bcx.switch_to_block(leaf_0);\n     let max_basic_leaf = fx.bcx.ins().iconst(types::I32, 1);\n-    let vend0 = fx.bcx.ins().iconst(types::I32, i64::from(u32::from_le_bytes(*b\"Genu\")));\n-    let vend2 = fx.bcx.ins().iconst(types::I32, i64::from(u32::from_le_bytes(*b\"ineI\")));\n-    let vend1 = fx.bcx.ins().iconst(types::I32, i64::from(u32::from_le_bytes(*b\"ntel\")));\n-    fx.bcx.ins().jump(dest, &[max_basic_leaf, vend0, vend1, vend2]);\n+    let vend0 = fx\n+        .bcx\n+        .ins()\n+        .iconst(types::I32, i64::from(u32::from_le_bytes(*b\"Genu\")));\n+    let vend2 = fx\n+        .bcx\n+        .ins()\n+        .iconst(types::I32, i64::from(u32::from_le_bytes(*b\"ineI\")));\n+    let vend1 = fx\n+        .bcx\n+        .ins()\n+        .iconst(types::I32, i64::from(u32::from_le_bytes(*b\"ntel\")));\n+    fx.bcx\n+        .ins()\n+        .jump(dest, &[max_basic_leaf, vend0, vend1, vend2]);\n \n     fx.bcx.switch_to_block(leaf_1);\n     let cpu_signature = fx.bcx.ins().iconst(types::I32, 0);\n     let additional_information = fx.bcx.ins().iconst(types::I32, 0);\n-    let ecx_features = fx.bcx.ins().iconst(\n-        types::I32,\n-        0,\n+    let ecx_features = fx.bcx.ins().iconst(types::I32, 0);\n+    let edx_features = fx\n+        .bcx\n+        .ins()\n+        .iconst(types::I32, 1 << 25 /* sse */ | 1 << 26 /* sse2 */);\n+    fx.bcx.ins().jump(\n+        dest,\n+        &[\n+            cpu_signature,\n+            additional_information,\n+            ecx_features,\n+            edx_features,\n+        ],\n     );\n-    let edx_features = fx.bcx.ins().iconst(\n-        types::I32,\n-        1 << 25 /* sse */ | 1 << 26 /* sse2 */,\n-    );\n-    fx.bcx.ins().jump(dest, &[cpu_signature, additional_information, ecx_features, edx_features]);\n \n     fx.bcx.switch_to_block(leaf_8000_0000);\n     let extended_max_basic_leaf = fx.bcx.ins().iconst(types::I32, 0);\n     let zero = fx.bcx.ins().iconst(types::I32, 0);\n-    fx.bcx.ins().jump(dest, &[extended_max_basic_leaf, zero, zero, zero]);\n+    fx.bcx\n+        .ins()\n+        .jump(dest, &[extended_max_basic_leaf, zero, zero, zero]);\n \n     fx.bcx.switch_to_block(leaf_8000_0001);\n     let zero = fx.bcx.ins().iconst(types::I32, 0);\n     let proc_info_ecx = fx.bcx.ins().iconst(types::I32, 0);\n     let proc_info_edx = fx.bcx.ins().iconst(types::I32, 0);\n-    fx.bcx.ins().jump(dest, &[zero, zero, proc_info_ecx, proc_info_edx]);\n+    fx.bcx\n+        .ins()\n+        .jump(dest, &[zero, zero, proc_info_ecx, proc_info_edx]);\n \n     fx.bcx.switch_to_block(unsupported_leaf);\n-    crate::trap::trap_unreachable(fx, \"__cpuid_count arch intrinsic doesn't yet support specified leaf\");\n+    crate::trap::trap_unreachable(\n+        fx,\n+        \"__cpuid_count arch intrinsic doesn't yet support specified leaf\",\n+    );\n \n     fx.bcx.switch_to_block(dest);\n     fx.bcx.ins().nop();"}, {"sha": "e8bd3e4ac3efbb113e5864dc79c0ab0ff02f0357", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -108,7 +108,7 @@ macro call_intrinsic_match {\n     }\n }\n \n-macro atomic_binop_return_old($fx:expr, $op:ident<$T:ident>($ptr:ident, $src:ident) -> $ret:ident)  {\n+macro atomic_binop_return_old($fx:expr, $op:ident<$T:ident>($ptr:ident, $src:ident) -> $ret:ident) {\n     crate::atomic_shim::lock_global_lock($fx);\n \n     let clif_ty = $fx.clif_type($T).unwrap();\n@@ -144,7 +144,13 @@ macro validate_atomic_type($fx:ident, $intrinsic:ident, $span:ident, $ty:expr) {\n     match $ty.kind {\n         ty::Uint(_) | ty::Int(_) => {}\n         _ => {\n-            $fx.tcx.sess.span_err($span, &format!(\"`{}` intrinsic: expected basic integer type, found `{:?}`\", $intrinsic, $ty));\n+            $fx.tcx.sess.span_err(\n+                $span,\n+                &format!(\n+                    \"`{}` intrinsic: expected basic integer type, found `{:?}`\",\n+                    $intrinsic, $ty\n+                ),\n+            );\n             // Prevent verifier error\n             crate::trap::trap_unreachable($fx, \"compilation should not have succeeded\");\n             return;\n@@ -170,10 +176,15 @@ fn lane_type_and_count<'tcx>(\n         rustc_target::abi::FieldsShape::Array { stride: _, count } => u16::try_from(count).unwrap(),\n         _ => unreachable!(\"lane_type_and_count({:?})\", layout),\n     };\n-    let lane_layout = layout.field(&ty::layout::LayoutCx {\n-        tcx,\n-        param_env: ParamEnv::reveal_all(),\n-    }, 0).unwrap();\n+    let lane_layout = layout\n+        .field(\n+            &ty::layout::LayoutCx {\n+                tcx,\n+                param_env: ParamEnv::reveal_all(),\n+            },\n+            0,\n+        )\n+        .unwrap();\n     (lane_layout, lane_count)\n }\n \n@@ -405,10 +416,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                     trap_unreachable(fx, \"[corruption] Called intrinsic::unreachable.\");\n                 }\n                 \"transmute\" => {\n-                    trap_unreachable(\n-                        fx,\n-                        \"[corruption] Transmuting to uninhabited type.\",\n-                    );\n+                    trap_unreachable(fx, \"[corruption] Transmuting to uninhabited type.\");\n                 }\n                 _ => unimplemented!(\"unsupported instrinsic {}\", intrinsic),\n             }"}, {"sha": "cb6e1d2098355ed78a7c5c8e9aa24d925f99e66b", "filename": "src/intrinsics/simd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fsimd.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -1,5 +1,5 @@\n-use crate::prelude::*;\n use super::*;\n+use crate::prelude::*;\n \n pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Backend>,"}, {"sha": "249c58b90311ec3f0b49da1bd45e40cb3d96abd8", "filename": "src/lib.rs", "status": "modified", "additions": 40, "deletions": 23, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -1,4 +1,11 @@\n-#![feature(rustc_private, decl_macro, type_alias_impl_trait, associated_type_bounds, never_type, try_blocks)]\n+#![feature(\n+    rustc_private,\n+    decl_macro,\n+    type_alias_impl_trait,\n+    associated_type_bounds,\n+    never_type,\n+    try_blocks\n+)]\n #![warn(rust_2018_idioms)]\n #![warn(unused_lifetimes)]\n \n@@ -7,6 +14,7 @@ extern crate flate2;\n extern crate libc;\n #[macro_use]\n extern crate rustc_middle;\n+extern crate rustc_ast;\n extern crate rustc_codegen_ssa;\n extern crate rustc_data_structures;\n extern crate rustc_errors;\n@@ -19,22 +27,21 @@ extern crate rustc_session;\n extern crate rustc_span;\n extern crate rustc_symbol_mangling;\n extern crate rustc_target;\n-extern crate rustc_ast;\n \n // This prevents duplicating functions and statics that are already part of the host rustc process.\n #[allow(unused_extern_crates)]\n extern crate rustc_driver;\n \n use std::any::Any;\n \n+use rustc_codegen_ssa::traits::CodegenBackend;\n+use rustc_codegen_ssa::CodegenResults;\n use rustc_errors::ErrorReported;\n use rustc_middle::dep_graph::{DepGraph, WorkProduct, WorkProductId};\n use rustc_middle::middle::cstore::{EncodedMetadata, MetadataLoader};\n-use rustc_session::Session;\n-use rustc_session::config::OutputFilenames;\n use rustc_middle::ty::query::Providers;\n-use rustc_codegen_ssa::CodegenResults;\n-use rustc_codegen_ssa::traits::CodegenBackend;\n+use rustc_session::config::OutputFilenames;\n+use rustc_session::Session;\n \n use cranelift_codegen::settings::{self, Configurable};\n \n@@ -46,8 +53,8 @@ mod allocator;\n mod analyze;\n mod archive;\n mod atomic_shim;\n-mod base;\n mod backend;\n+mod base;\n mod cast;\n mod codegen_i128;\n mod common;\n@@ -77,26 +84,29 @@ mod prelude {\n     pub(crate) use rustc_ast::ast::{FloatTy, IntTy, UintTy};\n     pub(crate) use rustc_span::Span;\n \n-    pub(crate) use rustc_middle::bug;\n     pub(crate) use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+    pub(crate) use rustc_middle::bug;\n     pub(crate) use rustc_middle::mir::{self, *};\n     pub(crate) use rustc_middle::ty::layout::{self, TyAndLayout};\n-    pub(crate) use rustc_target::abi::{Abi, LayoutOf, Scalar, Size, VariantIdx};\n     pub(crate) use rustc_middle::ty::{\n         self, FnSig, Instance, InstanceDef, ParamEnv, Ty, TyCtxt, TypeAndMut, TypeFoldable,\n     };\n+    pub(crate) use rustc_target::abi::{Abi, LayoutOf, Scalar, Size, VariantIdx};\n \n     pub(crate) use rustc_data_structures::fx::FxHashMap;\n \n     pub(crate) use rustc_index::vec::Idx;\n \n-    pub(crate) use cranelift_codegen::Context;\n     pub(crate) use cranelift_codegen::entity::EntitySet;\n-    pub(crate) use cranelift_codegen::ir::{AbiParam, Block, ExternalName, FuncRef, Inst, InstBuilder, MemFlags, Signature, SourceLoc, StackSlot, StackSlotData, StackSlotKind, TrapCode, Type, Value};\n     pub(crate) use cranelift_codegen::ir::condcodes::{FloatCC, IntCC};\n     pub(crate) use cranelift_codegen::ir::function::Function;\n     pub(crate) use cranelift_codegen::ir::types;\n+    pub(crate) use cranelift_codegen::ir::{\n+        AbiParam, Block, ExternalName, FuncRef, Inst, InstBuilder, MemFlags, Signature, SourceLoc,\n+        StackSlot, StackSlotData, StackSlotKind, TrapCode, Type, Value,\n+    };\n     pub(crate) use cranelift_codegen::isa::{self, CallConv};\n+    pub(crate) use cranelift_codegen::Context;\n     pub(crate) use cranelift_frontend::{FunctionBuilder, FunctionBuilderContext, Variable};\n     pub(crate) use cranelift_module::{\n         self, Backend, DataContext, DataId, FuncId, Linkage, Module,\n@@ -133,17 +143,10 @@ struct CodegenCx<'tcx, B: Backend + 'static> {\n }\n \n impl<'tcx, B: Backend + 'static> CodegenCx<'tcx, B> {\n-    fn new(\n-        tcx: TyCtxt<'tcx>,\n-        module: Module<B>,\n-        debug_info: bool,\n-    ) -> Self {\n+    fn new(tcx: TyCtxt<'tcx>, module: Module<B>, debug_info: bool) -> Self {\n         let unwind_context = UnwindContext::new(tcx, module.isa());\n         let debug_context = if debug_info {\n-            Some(DebugContext::new(\n-                tcx,\n-                module.isa(),\n-            ))\n+            Some(DebugContext::new(tcx, module.isa()))\n         } else {\n             None\n         };\n@@ -159,9 +162,21 @@ impl<'tcx, B: Backend + 'static> CodegenCx<'tcx, B> {\n         }\n     }\n \n-    fn finalize(mut self) -> (Module<B>, String, Option<DebugContext<'tcx>>, UnwindContext<'tcx>) {\n+    fn finalize(\n+        mut self,\n+    ) -> (\n+        Module<B>,\n+        String,\n+        Option<DebugContext<'tcx>>,\n+        UnwindContext<'tcx>,\n+    ) {\n         self.constants_cx.finalize(self.tcx, &mut self.module);\n-        (self.module, self.global_asm, self.debug_context, self.unwind_context)\n+        (\n+            self.module,\n+            self.global_asm,\n+            self.debug_context,\n+            self.unwind_context,\n+        )\n     }\n }\n \n@@ -220,7 +235,9 @@ impl CodegenBackend for CraneliftCodegenBackend {\n         sess: &Session,\n         dep_graph: &DepGraph,\n     ) -> Result<Box<dyn Any>, ErrorReported> {\n-        let (codegen_results, work_products) = *ongoing_codegen.downcast::<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>)>().unwrap();\n+        let (codegen_results, work_products) = *ongoing_codegen\n+            .downcast::<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>)>()\n+            .unwrap();\n \n         sess.time(\"serialize_work_products\", move || {\n             rustc_incremental::save_work_product_index(sess, &dep_graph, work_products)"}, {"sha": "fe5d1d64443630b5e8905ef36ce49f797716aa2b", "filename": "src/linkage.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Flinkage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Flinkage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flinkage.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -2,7 +2,11 @@ use rustc_middle::mir::mono::{Linkage as RLinkage, MonoItem, Visibility};\n \n use crate::prelude::*;\n \n-pub(crate) fn get_clif_linkage(mono_item: MonoItem<'_>, linkage: RLinkage, visibility: Visibility) -> Linkage {\n+pub(crate) fn get_clif_linkage(\n+    mono_item: MonoItem<'_>,\n+    linkage: RLinkage,\n+    visibility: Visibility,\n+) -> Linkage {\n     match (linkage, visibility) {\n         (RLinkage::External, Visibility::Default) => Linkage::Export,\n         (RLinkage::Internal, Visibility::Default) => Linkage::Local,"}, {"sha": "c31657d5f0ca8a1a881141f25014ae513e60c1cc", "filename": "src/main_shim.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain_shim.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -26,7 +26,13 @@ pub(crate) fn maybe_create_entry_wrapper(\n         return;\n     }\n \n-    create_entry_fn(tcx, module, unwind_context, main_def_id, use_start_lang_item);\n+    create_entry_fn(\n+        tcx,\n+        module,\n+        unwind_context,\n+        main_def_id,\n+        use_start_lang_item,\n+    );\n \n     fn create_entry_fn(\n         tcx: TyCtxt<'_>,\n@@ -114,7 +120,8 @@ pub(crate) fn maybe_create_entry_wrapper(\n             cmain_func_id,\n             &mut ctx,\n             &mut cranelift_codegen::binemit::NullTrapSink {},\n-        ).unwrap();\n+        )\n+        .unwrap();\n         unwind_context.add_function(cmain_func_id, &ctx, m.isa());\n     }\n }"}, {"sha": "67137b0fa3bcbef7154b1066a48ff666ad6e99a1", "filename": "src/metadata.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmetadata.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -2,12 +2,12 @@ use std::convert::TryFrom;\n use std::fs::File;\n use std::path::Path;\n \n-use rustc_middle::middle::cstore::{EncodedMetadata, MetadataLoader};\n-use rustc_session::config;\n-use rustc_middle::ty::TyCtxt;\n use rustc_codegen_ssa::METADATA_FILENAME;\n use rustc_data_structures::owning_ref::{self, OwningRef};\n use rustc_data_structures::rustc_erase_owner;\n+use rustc_middle::middle::cstore::{EncodedMetadata, MetadataLoader};\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::config;\n use rustc_target::spec::Target;\n \n use crate::backend::WriteMetadata;\n@@ -27,7 +27,7 @@ impl MetadataLoader for CraneliftMetadataLoader {\n             if entry.header().identifier() == METADATA_FILENAME.as_bytes() {\n                 let mut buf = Vec::with_capacity(\n                     usize::try_from(entry.header().size())\n-                        .expect(\"Rlib metadata file too big to load into memory.\")\n+                        .expect(\"Rlib metadata file too big to load into memory.\"),\n                 );\n                 ::std::io::copy(&mut entry, &mut buf).map_err(|e| format!(\"{:?}\", e))?;\n                 let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf).into();\n@@ -59,7 +59,10 @@ impl MetadataLoader for CraneliftMetadataLoader {\n }\n \n // Adapted from https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src/librustc_codegen_llvm/base.rs#L47-L112\n-pub(crate) fn write_metadata<P: WriteMetadata>(tcx: TyCtxt<'_>, product: &mut P) -> EncodedMetadata {\n+pub(crate) fn write_metadata<P: WriteMetadata>(\n+    tcx: TyCtxt<'_>,\n+    product: &mut P,\n+) -> EncodedMetadata {\n     use flate2::write::DeflateEncoder;\n     use flate2::Compression;\n     use std::io::Write;"}, {"sha": "60a4337111a8d69176c6e85db779a008ffaec980", "filename": "src/num.rs", "status": "modified", "additions": 40, "deletions": 13, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnum.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -253,16 +253,27 @@ pub(crate) fn trans_checked_int_binop<'tcx>(\n                     let lhs = fx.bcx.ins().uextend(ty.double_width().unwrap(), lhs);\n                     let rhs = fx.bcx.ins().uextend(ty.double_width().unwrap(), rhs);\n                     let val = fx.bcx.ins().imul(lhs, rhs);\n-                    let has_overflow = fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, val, (1 << ty.bits()) - 1);\n+                    let has_overflow = fx.bcx.ins().icmp_imm(\n+                        IntCC::UnsignedGreaterThan,\n+                        val,\n+                        (1 << ty.bits()) - 1,\n+                    );\n                     let val = fx.bcx.ins().ireduce(ty, val);\n                     (val, has_overflow)\n                 }\n                 types::I8 | types::I16 | types::I32 if signed => {\n                     let lhs = fx.bcx.ins().sextend(ty.double_width().unwrap(), lhs);\n                     let rhs = fx.bcx.ins().sextend(ty.double_width().unwrap(), rhs);\n                     let val = fx.bcx.ins().imul(lhs, rhs);\n-                    let has_underflow = fx.bcx.ins().icmp_imm(IntCC::SignedLessThan, val, -(1 << (ty.bits() - 1)));\n-                    let has_overflow = fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThan, val, (1 << (ty.bits() - 1)) - 1);\n+                    let has_underflow =\n+                        fx.bcx\n+                            .ins()\n+                            .icmp_imm(IntCC::SignedLessThan, val, -(1 << (ty.bits() - 1)));\n+                    let has_overflow = fx.bcx.ins().icmp_imm(\n+                        IntCC::SignedGreaterThan,\n+                        val,\n+                        (1 << (ty.bits() - 1)) - 1,\n+                    );\n                     let val = fx.bcx.ins().ireduce(ty, val);\n                     (val, fx.bcx.ins().bor(has_underflow, has_overflow))\n                 }\n@@ -275,12 +286,18 @@ pub(crate) fn trans_checked_int_binop<'tcx>(\n                     } else {\n                         let val_hi = fx.bcx.ins().smulhi(lhs, rhs);\n                         let not_all_zero = fx.bcx.ins().icmp_imm(IntCC::NotEqual, val_hi, 0);\n-                        let not_all_ones = fx.bcx.ins().icmp_imm(IntCC::NotEqual, val_hi, u64::try_from((1u128 << ty.bits()) - 1).unwrap() as i64);\n+                        let not_all_ones = fx.bcx.ins().icmp_imm(\n+                            IntCC::NotEqual,\n+                            val_hi,\n+                            u64::try_from((1u128 << ty.bits()) - 1).unwrap() as i64,\n+                        );\n                         fx.bcx.ins().band(not_all_zero, not_all_ones)\n                     };\n                     (val, has_overflow)\n                 }\n-                types::I128 => unreachable!(\"i128 should have been handled by codegen_i128::maybe_codegen\"),\n+                types::I128 => {\n+                    unreachable!(\"i128 should have been handled by codegen_i128::maybe_codegen\")\n+                }\n                 _ => unreachable!(\"invalid non-integer type {}\", ty),\n             }\n         }\n@@ -291,8 +308,10 @@ pub(crate) fn trans_checked_int_binop<'tcx>(\n             let val = fx.bcx.ins().ishl(lhs, actual_shift);\n             let ty = fx.bcx.func.dfg.value_type(val);\n             let max_shift = i64::from(ty.bits()) - 1;\n-            let has_overflow =\n-                fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n+            let has_overflow = fx\n+                .bcx\n+                .ins()\n+                .icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n             (val, has_overflow)\n         }\n         BinOp::Shr => {\n@@ -306,8 +325,10 @@ pub(crate) fn trans_checked_int_binop<'tcx>(\n             };\n             let ty = fx.bcx.func.dfg.value_type(val);\n             let max_shift = i64::from(ty.bits()) - 1;\n-            let has_overflow =\n-                fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n+            let has_overflow = fx\n+                .bcx\n+                .ins()\n+                .icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n             (val, has_overflow)\n         }\n         _ => bug!(\n@@ -323,7 +344,10 @@ pub(crate) fn trans_checked_int_binop<'tcx>(\n     // FIXME directly write to result place instead\n     let out_place = CPlace::new_stack_slot(\n         fx,\n-        fx.layout_of(fx.tcx.mk_tup([in_lhs.layout().ty, fx.tcx.types.bool].iter())),\n+        fx.layout_of(\n+            fx.tcx\n+                .mk_tup([in_lhs.layout().ty, fx.tcx.types.bool].iter()),\n+        ),\n     );\n     let out_layout = out_place.layout();\n     out_place.write_cvalue(fx, CValue::by_val_pair(res, has_overflow, out_layout));\n@@ -382,9 +406,12 @@ pub(crate) fn trans_ptr_binop<'tcx>(\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n ) -> CValue<'tcx> {\n-    let is_thin_ptr = in_lhs.layout().ty.builtin_deref(true).map(|TypeAndMut { ty, mutbl: _}| {\n-        !has_ptr_meta(fx.tcx, ty)\n-    }).unwrap_or(true);\n+    let is_thin_ptr = in_lhs\n+        .layout()\n+        .ty\n+        .builtin_deref(true)\n+        .map(|TypeAndMut { ty, mutbl: _ }| !has_ptr_meta(fx.tcx, ty))\n+        .unwrap_or(true);\n \n     if is_thin_ptr {\n         match bin_op {"}, {"sha": "f02732014d1e3e44e2bcf63b58edf7e53b145486", "filename": "src/optimize/code_layout.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Foptimize%2Fcode_layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Foptimize%2Fcode_layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foptimize%2Fcode_layout.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -15,7 +15,10 @@ pub(super) fn optimize_function(ctx: &mut Context, cold_blocks: &EntitySet<Block\n     // bytecodealliance/cranelift#1339 is implemented.\n \n     let mut block_insts = FxHashMap::default();\n-    for block in cold_blocks.keys().filter(|&block| cold_blocks.contains(block)) {\n+    for block in cold_blocks\n+        .keys()\n+        .filter(|&block| cold_blocks.contains(block))\n+    {\n         let insts = ctx.func.layout.block_insts(block).collect::<Vec<_>>();\n         for &inst in &insts {\n             ctx.func.layout.remove_inst(inst);\n@@ -25,7 +28,10 @@ pub(super) fn optimize_function(ctx: &mut Context, cold_blocks: &EntitySet<Block\n     }\n \n     // And then append them at the back again.\n-    for block in cold_blocks.keys().filter(|&block| cold_blocks.contains(block)) {\n+    for block in cold_blocks\n+        .keys()\n+        .filter(|&block| cold_blocks.contains(block))\n+    {\n         ctx.func.layout.append_block(block);\n         for inst in block_insts.remove(&block).unwrap() {\n             ctx.func.layout.append_inst(inst, block);"}, {"sha": "7ce6daee205147befe3d2106c5c17e2c07fa1f0e", "filename": "src/optimize/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Foptimize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Foptimize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foptimize%2Fmod.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -5,8 +5,7 @@ mod stack2reg;\n \n pub(crate) fn optimize_function<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    #[cfg_attr(not(debug_assertions), allow(unused_variables))]\n-    instance: Instance<'tcx>,\n+    #[cfg_attr(not(debug_assertions), allow(unused_variables))] instance: Instance<'tcx>,\n     ctx: &mut Context,\n     cold_blocks: &EntitySet<Block>,\n     clif_comments: &mut crate::pretty_clif::CommentWriter,"}, {"sha": "7c0bd2710a6eaac4f0520555dcde88fc449fb505", "filename": "src/optimize/stack2reg.rs", "status": "modified", "additions": 151, "deletions": 62, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Foptimize%2Fstack2reg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Foptimize%2Fstack2reg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foptimize%2Fstack2reg.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -16,8 +16,8 @@ use std::ops::Not;\n use rustc_data_structures::fx::{FxHashSet, FxHasher};\n \n use cranelift_codegen::cursor::{Cursor, FuncCursor};\n-use cranelift_codegen::ir::{InstructionData, Opcode, ValueDef};\n use cranelift_codegen::ir::immediates::Offset32;\n+use cranelift_codegen::ir::{InstructionData, Opcode, ValueDef};\n \n use hashbrown::HashSet;\n use std::hash::BuildHasherDefault;\n@@ -55,31 +55,41 @@ struct StackSlotUsage {\n \n impl StackSlotUsage {\n     fn potential_stores_for_load(&self, ctx: &Context, load: Inst) -> Vec<Inst> {\n-        self.stack_store.iter().cloned().filter(|&store| {\n-            match spatial_overlap(&ctx.func, store, load) {\n-                SpatialOverlap::No => false, // Can never be the source of the loaded value.\n-                SpatialOverlap::Partial | SpatialOverlap::Full => true,\n-            }\n-        }).filter(|&store| {\n-            match temporal_order(ctx, store, load) {\n-                TemporalOrder::NeverBefore => false, // Can never be the source of the loaded value.\n-                TemporalOrder::MaybeBefore | TemporalOrder::DefinitivelyBefore => true,\n-            }\n-        }).collect::<Vec<Inst>>()\n+        self.stack_store\n+            .iter()\n+            .cloned()\n+            .filter(|&store| {\n+                match spatial_overlap(&ctx.func, store, load) {\n+                    SpatialOverlap::No => false, // Can never be the source of the loaded value.\n+                    SpatialOverlap::Partial | SpatialOverlap::Full => true,\n+                }\n+            })\n+            .filter(|&store| {\n+                match temporal_order(ctx, store, load) {\n+                    TemporalOrder::NeverBefore => false, // Can never be the source of the loaded value.\n+                    TemporalOrder::MaybeBefore | TemporalOrder::DefinitivelyBefore => true,\n+                }\n+            })\n+            .collect::<Vec<Inst>>()\n     }\n \n     fn potential_loads_of_store(&self, ctx: &Context, store: Inst) -> Vec<Inst> {\n-        self.stack_load.iter().cloned().filter(|&load| {\n-            match spatial_overlap(&ctx.func, store, load) {\n-                SpatialOverlap::No => false, // Can never be the source of the loaded value.\n-                SpatialOverlap::Partial | SpatialOverlap::Full => true,\n-            }\n-        }).filter(|&load| {\n-            match temporal_order(ctx, store, load) {\n-                TemporalOrder::NeverBefore => false, // Can never be the source of the loaded value.\n-                TemporalOrder::MaybeBefore | TemporalOrder::DefinitivelyBefore => true,\n-            }\n-        }).collect::<Vec<Inst>>()\n+        self.stack_load\n+            .iter()\n+            .cloned()\n+            .filter(|&load| {\n+                match spatial_overlap(&ctx.func, store, load) {\n+                    SpatialOverlap::No => false, // Can never be the source of the loaded value.\n+                    SpatialOverlap::Partial | SpatialOverlap::Full => true,\n+                }\n+            })\n+            .filter(|&load| {\n+                match temporal_order(ctx, store, load) {\n+                    TemporalOrder::NeverBefore => false, // Can never be the source of the loaded value.\n+                    TemporalOrder::MaybeBefore | TemporalOrder::DefinitivelyBefore => true,\n+                }\n+            })\n+            .collect::<Vec<Inst>>()\n     }\n \n     fn remove_unused_stack_addr(func: &mut Function, inst: Inst) {\n@@ -134,22 +144,34 @@ impl<'a> OptimizeContext<'a> {\n                         stack_slot,\n                         offset: _,\n                     } => {\n-                        stack_slot_usage_map.entry(OrdStackSlot(stack_slot)).or_insert_with(StackSlotUsage::default).stack_addr.insert(inst);\n+                        stack_slot_usage_map\n+                            .entry(OrdStackSlot(stack_slot))\n+                            .or_insert_with(StackSlotUsage::default)\n+                            .stack_addr\n+                            .insert(inst);\n                     }\n                     InstructionData::StackLoad {\n                         opcode: Opcode::StackLoad,\n                         stack_slot,\n                         offset: _,\n                     } => {\n-                        stack_slot_usage_map.entry(OrdStackSlot(stack_slot)).or_insert_with(StackSlotUsage::default).stack_load.insert(inst);\n+                        stack_slot_usage_map\n+                            .entry(OrdStackSlot(stack_slot))\n+                            .or_insert_with(StackSlotUsage::default)\n+                            .stack_load\n+                            .insert(inst);\n                     }\n                     InstructionData::StackStore {\n                         opcode: Opcode::StackStore,\n                         arg: _,\n                         stack_slot,\n                         offset: _,\n                     } => {\n-                        stack_slot_usage_map.entry(OrdStackSlot(stack_slot)).or_insert_with(StackSlotUsage::default).stack_store.insert(inst);\n+                        stack_slot_usage_map\n+                            .entry(OrdStackSlot(stack_slot))\n+                            .or_insert_with(StackSlotUsage::default)\n+                            .stack_store\n+                            .insert(inst);\n                     }\n                     _ => {}\n                 }\n@@ -165,7 +187,6 @@ impl<'a> OptimizeContext<'a> {\n \n pub(super) fn optimize_function(\n     ctx: &mut Context,\n-    #[cfg_attr(not(debug_assertions), allow(unused_variables))]\n     clif_comments: &mut crate::pretty_clif::CommentWriter,\n ) {\n     combine_stack_addr_with_load_store(&mut ctx.func);\n@@ -176,7 +197,8 @@ pub(super) fn optimize_function(\n \n     remove_unused_stack_addr_and_stack_load(&mut opt_ctx);\n \n-    #[cfg(debug_assertions)] {\n+    #[cfg(debug_assertions)]\n+    {\n         for (&OrdStackSlot(stack_slot), usage) in &opt_ctx.stack_slot_usage_map {\n             clif_comments.add_comment(stack_slot, format!(\"used by: {:?}\", usage));\n         }\n@@ -194,26 +216,34 @@ pub(super) fn optimize_function(\n \n             #[cfg(debug_assertions)]\n             for &store in &potential_stores {\n-                clif_comments.add_comment(load, format!(\n-                    \"Potential store -> load forwarding {} -> {} ({:?}, {:?})\",\n-                    opt_ctx.ctx.func.dfg.display_inst(store, None),\n-                    opt_ctx.ctx.func.dfg.display_inst(load, None),\n-                    spatial_overlap(&opt_ctx.ctx.func, store, load),\n-                    temporal_order(&opt_ctx.ctx, store, load),\n-                ));\n+                clif_comments.add_comment(\n+                    load,\n+                    format!(\n+                        \"Potential store -> load forwarding {} -> {} ({:?}, {:?})\",\n+                        opt_ctx.ctx.func.dfg.display_inst(store, None),\n+                        opt_ctx.ctx.func.dfg.display_inst(load, None),\n+                        spatial_overlap(&opt_ctx.ctx.func, store, load),\n+                        temporal_order(&opt_ctx.ctx, store, load),\n+                    ),\n+                );\n             }\n \n             match *potential_stores {\n                 [] => {\n                     #[cfg(debug_assertions)]\n                     clif_comments.add_comment(load, format!(\"[BUG?] Reading uninitialized memory\"));\n                 }\n-                [store] if spatial_overlap(&opt_ctx.ctx.func, store, load) == SpatialOverlap::Full && temporal_order(&opt_ctx.ctx, store, load) == TemporalOrder::DefinitivelyBefore => {\n+                [store]\n+                    if spatial_overlap(&opt_ctx.ctx.func, store, load) == SpatialOverlap::Full\n+                        && temporal_order(&opt_ctx.ctx, store, load)\n+                            == TemporalOrder::DefinitivelyBefore =>\n+                {\n                     // Only one store could have been the origin of the value.\n                     let stored_value = opt_ctx.ctx.func.dfg.inst_args(store)[0];\n \n                     #[cfg(debug_assertions)]\n-                    clif_comments.add_comment(load, format!(\"Store to load forward {} -> {}\", store, load));\n+                    clif_comments\n+                        .add_comment(load, format!(\"Store to load forward {} -> {}\", store, load));\n \n                     users.change_load_to_alias(&mut opt_ctx.ctx.func, load, stored_value);\n                 }\n@@ -226,21 +256,31 @@ pub(super) fn optimize_function(\n \n             #[cfg(debug_assertions)]\n             for &load in &potential_loads {\n-                clif_comments.add_comment(store, format!(\n-                    \"Potential load from store {} <- {} ({:?}, {:?})\",\n-                    opt_ctx.ctx.func.dfg.display_inst(load, None),\n-                    opt_ctx.ctx.func.dfg.display_inst(store, None),\n-                    spatial_overlap(&opt_ctx.ctx.func, store, load),\n-                    temporal_order(&opt_ctx.ctx, store, load),\n-                ));\n+                clif_comments.add_comment(\n+                    store,\n+                    format!(\n+                        \"Potential load from store {} <- {} ({:?}, {:?})\",\n+                        opt_ctx.ctx.func.dfg.display_inst(load, None),\n+                        opt_ctx.ctx.func.dfg.display_inst(store, None),\n+                        spatial_overlap(&opt_ctx.ctx.func, store, load),\n+                        temporal_order(&opt_ctx.ctx, store, load),\n+                    ),\n+                );\n             }\n \n             if potential_loads.is_empty() {\n                 // Never loaded; can safely remove all stores and the stack slot.\n                 // FIXME also remove stores when there is always a next store before a load.\n \n                 #[cfg(debug_assertions)]\n-                clif_comments.add_comment(store, format!(\"Remove dead stack store {} of {}\", opt_ctx.ctx.func.dfg.display_inst(store, None), stack_slot.0));\n+                clif_comments.add_comment(\n+                    store,\n+                    format!(\n+                        \"Remove dead stack store {} of {}\",\n+                        opt_ctx.ctx.func.dfg.display_inst(store, None),\n+                        stack_slot.0\n+                    ),\n+                );\n \n                 users.remove_dead_store(&mut opt_ctx.ctx.func, store);\n             }\n@@ -258,24 +298,52 @@ fn combine_stack_addr_with_load_store(func: &mut Function) {\n     while let Some(_block) = cursor.next_block() {\n         while let Some(inst) = cursor.next_inst() {\n             match cursor.func.dfg[inst] {\n-                InstructionData::Load { opcode: Opcode::Load, arg: addr, flags: _, offset } => {\n-                    if cursor.func.dfg.ctrl_typevar(inst) == types::I128 || cursor.func.dfg.ctrl_typevar(inst).is_vector() {\n+                InstructionData::Load {\n+                    opcode: Opcode::Load,\n+                    arg: addr,\n+                    flags: _,\n+                    offset,\n+                } => {\n+                    if cursor.func.dfg.ctrl_typevar(inst) == types::I128\n+                        || cursor.func.dfg.ctrl_typevar(inst).is_vector()\n+                    {\n                         continue; // WORKAROUD: stack_load.i128 not yet implemented\n                     }\n-                    if let Some((stack_slot, stack_addr_offset)) = try_get_stack_slot_and_offset_for_addr(cursor.func, addr) {\n-                        if let Some(combined_offset) = offset.try_add_i64(stack_addr_offset.into()) {\n+                    if let Some((stack_slot, stack_addr_offset)) =\n+                        try_get_stack_slot_and_offset_for_addr(cursor.func, addr)\n+                    {\n+                        if let Some(combined_offset) = offset.try_add_i64(stack_addr_offset.into())\n+                        {\n                             let ty = cursor.func.dfg.ctrl_typevar(inst);\n-                            cursor.func.dfg.replace(inst).stack_load(ty, stack_slot, combined_offset);\n+                            cursor.func.dfg.replace(inst).stack_load(\n+                                ty,\n+                                stack_slot,\n+                                combined_offset,\n+                            );\n                         }\n                     }\n                 }\n-                InstructionData::Store { opcode: Opcode::Store, args: [value, addr], flags: _, offset } => {\n-                    if cursor.func.dfg.ctrl_typevar(inst) == types::I128 || cursor.func.dfg.ctrl_typevar(inst).is_vector() {\n+                InstructionData::Store {\n+                    opcode: Opcode::Store,\n+                    args: [value, addr],\n+                    flags: _,\n+                    offset,\n+                } => {\n+                    if cursor.func.dfg.ctrl_typevar(inst) == types::I128\n+                        || cursor.func.dfg.ctrl_typevar(inst).is_vector()\n+                    {\n                         continue; // WORKAROUND: stack_store.i128 not yet implemented\n                     }\n-                    if let Some((stack_slot, stack_addr_offset)) = try_get_stack_slot_and_offset_for_addr(cursor.func, addr) {\n-                        if let Some(combined_offset) = offset.try_add_i64(stack_addr_offset.into()) {\n-                            cursor.func.dfg.replace(inst).stack_store(value, stack_slot, combined_offset);\n+                    if let Some((stack_slot, stack_addr_offset)) =\n+                        try_get_stack_slot_and_offset_for_addr(cursor.func, addr)\n+                    {\n+                        if let Some(combined_offset) = offset.try_add_i64(stack_addr_offset.into())\n+                        {\n+                            cursor.func.dfg.replace(inst).stack_store(\n+                                value,\n+                                stack_slot,\n+                                combined_offset,\n+                            );\n                         }\n                     }\n                 }\n@@ -296,7 +364,10 @@ fn remove_unused_stack_addr_and_stack_load(opt_ctx: &mut OptimizeContext<'_>) {\n                 if let ValueDef::Result(arg_origin, 0) = cursor.func.dfg.value_def(arg) {\n                     match cursor.func.dfg[arg_origin].opcode() {\n                         Opcode::StackAddr | Opcode::StackLoad => {\n-                            stack_addr_load_insts_users.entry(arg_origin).or_insert_with(FxHashSet::default).insert(inst);\n+                            stack_addr_load_insts_users\n+                                .entry(arg_origin)\n+                                .or_insert_with(FxHashSet::default)\n+                                .insert(inst);\n                         }\n                         _ => {}\n                     }\n@@ -309,7 +380,8 @@ fn remove_unused_stack_addr_and_stack_load(opt_ctx: &mut OptimizeContext<'_>) {\n     for inst in stack_addr_load_insts_users.keys() {\n         let mut is_recorded_stack_addr_or_stack_load = false;\n         for stack_slot_users in opt_ctx.stack_slot_usage_map.values() {\n-            is_recorded_stack_addr_or_stack_load |= stack_slot_users.stack_addr.contains(inst) || stack_slot_users.stack_load.contains(inst);\n+            is_recorded_stack_addr_or_stack_load |= stack_slot_users.stack_addr.contains(inst)\n+                || stack_slot_users.stack_load.contains(inst);\n         }\n         assert!(is_recorded_stack_addr_or_stack_load);\n     }\n@@ -323,23 +395,37 @@ fn remove_unused_stack_addr_and_stack_load(opt_ctx: &mut OptimizeContext<'_>) {\n     for stack_slot_users in opt_ctx.stack_slot_usage_map.values_mut() {\n         stack_slot_users\n             .stack_addr\n-            .drain_filter(|inst| !(stack_addr_load_insts_users.get(inst).map(|users| users.is_empty()).unwrap_or(true)))\n+            .drain_filter(|inst| {\n+                !(stack_addr_load_insts_users\n+                    .get(inst)\n+                    .map(|users| users.is_empty())\n+                    .unwrap_or(true))\n+            })\n             .for_each(|inst| StackSlotUsage::remove_unused_stack_addr(&mut func, inst));\n \n         stack_slot_users\n             .stack_load\n-            .drain_filter(|inst| !(stack_addr_load_insts_users.get(inst).map(|users| users.is_empty()).unwrap_or(true)))\n+            .drain_filter(|inst| {\n+                !(stack_addr_load_insts_users\n+                    .get(inst)\n+                    .map(|users| users.is_empty())\n+                    .unwrap_or(true))\n+            })\n             .for_each(|inst| StackSlotUsage::remove_unused_load(&mut func, inst));\n     }\n }\n \n-fn try_get_stack_slot_and_offset_for_addr(func: &Function, addr: Value) -> Option<(StackSlot, Offset32)> {\n+fn try_get_stack_slot_and_offset_for_addr(\n+    func: &Function,\n+    addr: Value,\n+) -> Option<(StackSlot, Offset32)> {\n     if let ValueDef::Result(addr_inst, 0) = func.dfg.value_def(addr) {\n         if let InstructionData::StackLoad {\n             opcode: Opcode::StackAddr,\n             stack_slot,\n             offset,\n-        } = func.dfg[addr_inst] {\n+        } = func.dfg[addr_inst]\n+        {\n             return Some((stack_slot, offset));\n         }\n     }\n@@ -390,7 +476,10 @@ fn spatial_overlap(func: &Function, src: Inst, dest: Inst) -> SpatialOverlap {\n     }\n \n     let src_end: i64 = src_offset.try_add_i64(i64::from(src_size)).unwrap().into();\n-    let dest_end: i64 = dest_offset.try_add_i64(i64::from(dest_size)).unwrap().into();\n+    let dest_end: i64 = dest_offset\n+        .try_add_i64(i64::from(dest_size))\n+        .unwrap()\n+        .into();\n     if src_end <= dest_offset.into() || dest_end <= src_offset.into() {\n         return SpatialOverlap::No;\n     }"}, {"sha": "5295b296cde5a1a292abe975d5b38a2d8959a7ec", "filename": "src/pointer.rs", "status": "modified", "additions": 40, "deletions": 16, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpointer.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -32,7 +32,10 @@ impl Pointer {\n         }\n     }\n \n-    pub(crate) fn const_addr<'a, 'tcx>(fx: &mut FunctionCx<'a, 'tcx, impl Backend>, addr: i64) -> Self {\n+    pub(crate) fn const_addr<'a, 'tcx>(\n+        fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+        addr: i64,\n+    ) -> Self {\n         let addr = fx.bcx.ins().iconst(fx.pointer_type, addr);\n         Pointer {\n             base: PointerBase::Addr(addr),\n@@ -62,10 +65,15 @@ impl Pointer {\n                     fx.bcx.ins().iadd_imm(base_addr, offset)\n                 }\n             }\n-            PointerBase::Stack(stack_slot) => fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, self.offset),\n-            PointerBase::Dangling(align) => {\n-                fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap())\n+            PointerBase::Stack(stack_slot) => {\n+                fx.bcx\n+                    .ins()\n+                    .stack_addr(fx.pointer_type, stack_slot, self.offset)\n             }\n+            PointerBase::Dangling(align) => fx\n+                .bcx\n+                .ins()\n+                .iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap()),\n         }\n     }\n \n@@ -89,19 +97,27 @@ impl Pointer {\n             }\n         } else {\n             let base_offset: i64 = self.offset.into();\n-            if let Some(new_offset) = base_offset.checked_add(extra_offset){\n+            if let Some(new_offset) = base_offset.checked_add(extra_offset) {\n                 let base_addr = match self.base {\n                     PointerBase::Addr(addr) => addr,\n-                    PointerBase::Stack(stack_slot) => fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0),\n-                    PointerBase::Dangling(align) => fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap()),\n+                    PointerBase::Stack(stack_slot) => {\n+                        fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0)\n+                    }\n+                    PointerBase::Dangling(align) => fx\n+                        .bcx\n+                        .ins()\n+                        .iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap()),\n                 };\n                 let addr = fx.bcx.ins().iadd_imm(base_addr, new_offset);\n                 Pointer {\n                     base: PointerBase::Addr(addr),\n                     offset: Offset32::new(0),\n                 }\n             } else {\n-                panic!(\"self.offset ({}) + extra_offset ({}) not representable in i64\", base_offset, extra_offset);\n+                panic!(\n+                    \"self.offset ({}) + extra_offset ({}) not representable in i64\",\n+                    base_offset, extra_offset\n+                );\n             }\n         }\n     }\n@@ -117,14 +133,20 @@ impl Pointer {\n                 offset: self.offset,\n             },\n             PointerBase::Stack(stack_slot) => {\n-                let base_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, self.offset);\n+                let base_addr = fx\n+                    .bcx\n+                    .ins()\n+                    .stack_addr(fx.pointer_type, stack_slot, self.offset);\n                 Pointer {\n                     base: PointerBase::Addr(fx.bcx.ins().iadd(base_addr, extra_offset)),\n                     offset: Offset32::new(0),\n                 }\n             }\n             PointerBase::Dangling(align) => {\n-                let addr = fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap());\n+                let addr = fx\n+                    .bcx\n+                    .ins()\n+                    .iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap());\n                 Pointer {\n                     base: PointerBase::Addr(fx.bcx.ins().iadd(addr, extra_offset)),\n                     offset: self.offset,\n@@ -141,12 +163,14 @@ impl Pointer {\n     ) -> Value {\n         match self.base {\n             PointerBase::Addr(base_addr) => fx.bcx.ins().load(ty, flags, base_addr, self.offset),\n-            PointerBase::Stack(stack_slot) => if ty == types::I128 || ty.is_vector() {\n-                // WORKAROUND for stack_load.i128 and stack_load.iXxY not being implemented\n-                let base_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n-                fx.bcx.ins().load(ty, flags, base_addr, self.offset)\n-            } else {\n-                fx.bcx.ins().stack_load(ty, stack_slot, self.offset)\n+            PointerBase::Stack(stack_slot) => {\n+                if ty == types::I128 || ty.is_vector() {\n+                    // WORKAROUND for stack_load.i128 and stack_load.iXxY not being implemented\n+                    let base_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n+                    fx.bcx.ins().load(ty, flags, base_addr, self.offset)\n+                } else {\n+                    fx.bcx.ins().stack_load(ty, stack_slot, self.offset)\n+                }\n             }\n             PointerBase::Dangling(_align) => unreachable!(),\n         }"}, {"sha": "6d8d085529c46ff7679b623251e446f4d27bd30d", "filename": "src/pretty_clif.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpretty_clif.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -196,7 +196,7 @@ impl<B: Backend + 'static> FunctionCx<'_, '_, B> {\n         entity: E,\n         comment: S,\n     ) {\n-       self.clif_comments.add_comment(entity, comment);\n+        self.clif_comments.add_comment(entity, comment);\n     }\n }\n \n@@ -210,7 +210,13 @@ pub(crate) fn write_clif_file<'tcx>(\n ) {\n     use std::io::Write;\n \n-    if !cfg!(debug_assertions) && !tcx.sess.opts.output_types.contains_key(&OutputType::LlvmAssembly) {\n+    if !cfg!(debug_assertions)\n+        && !tcx\n+            .sess\n+            .opts\n+            .output_types\n+            .contains_key(&OutputType::LlvmAssembly)\n+    {\n         return;\n     }\n "}, {"sha": "a5d9b5e751a20de50a5b9f87912454ea2daa03d0", "filename": "src/target_features_whitelist.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Ftarget_features_whitelist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Ftarget_features_whitelist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftarget_features_whitelist.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -107,8 +107,10 @@ const POWERPC_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"vsx\", Some(sym::powerpc_target_feature)),\n ];\n \n-const MIPS_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] =\n-    &[(\"fp64\", Some(sym::mips_target_feature)), (\"msa\", Some(sym::mips_target_feature))];\n+const MIPS_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n+    (\"fp64\", Some(sym::mips_target_feature)),\n+    (\"msa\", Some(sym::mips_target_feature)),\n+];\n \n const RISCV_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"m\", Some(sym::riscv_target_feature)),"}, {"sha": "121f4477b80e0da072887f1e4ef3128608f84927", "filename": "src/toolchain.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Ftoolchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Ftoolchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftoolchain.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -7,9 +7,10 @@ use rustc_target::spec::LinkerFlavor;\n /// Tries to infer the path of a binary for the target toolchain from the linker name.\n pub(crate) fn get_toolchain_binary(sess: &Session, tool: &str) -> PathBuf {\n     let (mut linker, _linker_flavor) = linker_and_flavor(sess);\n-    let linker_file_name = linker.file_name().and_then(|name| name.to_str()).unwrap_or_else(|| {\n-        sess.fatal(\"couldn't extract file name from specified linker\")\n-    });\n+    let linker_file_name = linker\n+        .file_name()\n+        .and_then(|name| name.to_str())\n+        .unwrap_or_else(|| sess.fatal(\"couldn't extract file name from specified linker\"));\n \n     if linker_file_name == \"ld.lld\" {\n         if tool != \"ld\" {\n@@ -68,9 +69,12 @@ fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n                 flavor,\n             )),\n             (Some(linker), None) => {\n-                let stem = linker.file_stem().and_then(|stem| stem.to_str()).unwrap_or_else(|| {\n-                    sess.fatal(\"couldn't extract file stem from specified linker\")\n-                });\n+                let stem = linker\n+                    .file_stem()\n+                    .and_then(|stem| stem.to_str())\n+                    .unwrap_or_else(|| {\n+                        sess.fatal(\"couldn't extract file stem from specified linker\")\n+                    });\n \n                 let flavor = if stem == \"emcc\" {\n                     LinkerFlavor::Em\n@@ -99,7 +103,11 @@ fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n \n     // linker and linker flavor specified via command line have precedence over what the target\n     // specification specifies\n-    if let Some(ret) = infer_from(sess, sess.opts.cg.linker.clone(), sess.opts.cg.linker_flavor) {\n+    if let Some(ret) = infer_from(\n+        sess,\n+        sess.opts.cg.linker.clone(),\n+        sess.opts.cg.linker_flavor,\n+    ) {\n         return ret;\n     }\n "}, {"sha": "e69e63e4d49e9aff1b4f818e7b66c4ff08f342d7", "filename": "src/trap.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftrap.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -2,7 +2,8 @@ use crate::prelude::*;\n \n fn codegen_print(fx: &mut FunctionCx<'_, '_, impl cranelift_module::Backend>, msg: &str) {\n     let puts = fx\n-        .cx.module\n+        .cx\n+        .module\n         .declare_function(\n             \"puts\",\n             Linkage::Import,"}, {"sha": "847c5fc7870025f758fd73e3d4d1c9b3c5210719", "filename": "src/value_and_place.rs", "status": "modified", "additions": 127, "deletions": 69, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -33,7 +33,8 @@ fn codegen_field<'tcx>(\n             _ => {\n                 // We have to align the offset for DST's\n                 let unaligned_offset = field_offset.bytes();\n-                let (_, unsized_align) = crate::unsize::size_and_align_of_dst(fx, field_layout, extra);\n+                let (_, unsized_align) =\n+                    crate::unsize::size_and_align_of_dst(fx, field_layout, extra);\n \n                 let one = fx.bcx.ins().iconst(pointer_ty(fx.tcx), 1);\n                 let align_sub_1 = fx.bcx.ins().isub(unsized_align, one);\n@@ -42,18 +43,19 @@ fn codegen_field<'tcx>(\n                 let and_rhs = fx.bcx.ins().isub(zero, unsized_align);\n                 let offset = fx.bcx.ins().band(and_lhs, and_rhs);\n \n-                (\n-                    base.offset_value(fx, offset),\n-                    field_layout,\n-                )\n+                (base.offset_value(fx, offset), field_layout)\n             }\n         }\n     } else {\n         simple(fx)\n     }\n }\n \n-fn scalar_pair_calculate_b_offset(tcx: TyCtxt<'_>, a_scalar: &Scalar, b_scalar: &Scalar) -> Offset32 {\n+fn scalar_pair_calculate_b_offset(\n+    tcx: TyCtxt<'_>,\n+    a_scalar: &Scalar,\n+    b_scalar: &Scalar,\n+) -> Offset32 {\n     let b_offset = a_scalar\n         .value\n         .size(&tcx)\n@@ -77,15 +79,23 @@ impl<'tcx> CValue<'tcx> {\n         CValue(CValueInner::ByRef(ptr, None), layout)\n     }\n \n-    pub(crate) fn by_ref_unsized(ptr: Pointer, meta: Value, layout: TyAndLayout<'tcx>) -> CValue<'tcx> {\n+    pub(crate) fn by_ref_unsized(\n+        ptr: Pointer,\n+        meta: Value,\n+        layout: TyAndLayout<'tcx>,\n+    ) -> CValue<'tcx> {\n         CValue(CValueInner::ByRef(ptr, Some(meta)), layout)\n     }\n \n     pub(crate) fn by_val(value: Value, layout: TyAndLayout<'tcx>) -> CValue<'tcx> {\n         CValue(CValueInner::ByVal(value), layout)\n     }\n \n-    pub(crate) fn by_val_pair(value: Value, extra: Value, layout: TyAndLayout<'tcx>) -> CValue<'tcx> {\n+    pub(crate) fn by_val_pair(\n+        value: Value,\n+        extra: Value,\n+        layout: TyAndLayout<'tcx>,\n+    ) -> CValue<'tcx> {\n         CValue(CValueInner::ByValPair(value, extra), layout)\n     }\n \n@@ -94,7 +104,10 @@ impl<'tcx> CValue<'tcx> {\n     }\n \n     // FIXME remove\n-    pub(crate) fn force_stack(self, fx: &mut FunctionCx<'_, 'tcx, impl Backend>) -> (Pointer, Option<Value>) {\n+    pub(crate) fn force_stack(\n+        self,\n+        fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n+    ) -> (Pointer, Option<Value>) {\n         let layout = self.1;\n         match self.0 {\n             CValueInner::ByRef(ptr, meta) => (ptr, meta),\n@@ -122,7 +135,8 @@ impl<'tcx> CValue<'tcx> {\n                     Abi::Scalar(ref scalar) => scalar_to_clif_type(fx.tcx, scalar.clone()),\n                     Abi::Vector { ref element, count } => {\n                         scalar_to_clif_type(fx.tcx, element.clone())\n-                            .by(u16::try_from(count).unwrap()).unwrap()\n+                            .by(u16::try_from(count).unwrap())\n+                            .unwrap()\n                     }\n                     _ => unreachable!(\"{:?}\", layout.ty),\n                 };\n@@ -153,7 +167,9 @@ impl<'tcx> CValue<'tcx> {\n                 let val2 = ptr.offset(fx, b_offset).load(fx, clif_ty2, MemFlags::new());\n                 (val1, val2)\n             }\n-            CValueInner::ByRef(_, Some(_)) => bug!(\"load_scalar_pair for unsized value not allowed\"),\n+            CValueInner::ByRef(_, Some(_)) => {\n+                bug!(\"load_scalar_pair for unsized value not allowed\")\n+            }\n             CValueInner::ByVal(_) => bug!(\"Please use load_scalar for ByVal\"),\n             CValueInner::ByValPair(val1, val2) => (val1, val2),\n         }\n@@ -166,33 +182,29 @@ impl<'tcx> CValue<'tcx> {\n     ) -> CValue<'tcx> {\n         let layout = self.1;\n         match self.0 {\n-            CValueInner::ByVal(val) => {\n-                match layout.abi {\n-                    Abi::Vector { element: _, count } => {\n-                        let count = u8::try_from(count).expect(\"SIMD type with more than 255 lanes???\");\n-                        let field = u8::try_from(field.index()).unwrap();\n-                        assert!(field < count);\n-                        let lane = fx.bcx.ins().extractlane(val, field);\n-                        let field_layout = layout.field(&*fx, usize::from(field));\n-                        CValue::by_val(lane, field_layout)\n-                    }\n-                    _ => unreachable!(\"value_field for ByVal with abi {:?}\", layout.abi),\n+            CValueInner::ByVal(val) => match layout.abi {\n+                Abi::Vector { element: _, count } => {\n+                    let count = u8::try_from(count).expect(\"SIMD type with more than 255 lanes???\");\n+                    let field = u8::try_from(field.index()).unwrap();\n+                    assert!(field < count);\n+                    let lane = fx.bcx.ins().extractlane(val, field);\n+                    let field_layout = layout.field(&*fx, usize::from(field));\n+                    CValue::by_val(lane, field_layout)\n                 }\n-            }\n-            CValueInner::ByValPair(val1, val2) => {\n-                match layout.abi {\n-                    Abi::ScalarPair(_, _) => {\n-                        let val = match field.as_u32() {\n-                            0 => val1,\n-                            1 => val2,\n-                            _ => bug!(\"field should be 0 or 1\"),\n-                        };\n-                        let field_layout = layout.field(&*fx, usize::from(field));\n-                        CValue::by_val(val, field_layout)\n-                    }\n-                    _ => unreachable!(\"value_field for ByValPair with abi {:?}\", layout.abi),\n+                _ => unreachable!(\"value_field for ByVal with abi {:?}\", layout.abi),\n+            },\n+            CValueInner::ByValPair(val1, val2) => match layout.abi {\n+                Abi::ScalarPair(_, _) => {\n+                    let val = match field.as_u32() {\n+                        0 => val1,\n+                        1 => val2,\n+                        _ => bug!(\"field should be 0 or 1\"),\n+                    };\n+                    let field_layout = layout.field(&*fx, usize::from(field));\n+                    CValue::by_val(val, field_layout)\n                 }\n-            }\n+                _ => unreachable!(\"value_field for ByValPair with abi {:?}\", layout.abi),\n+            },\n             CValueInner::ByRef(ptr, None) => {\n                 let (field_ptr, field_layout) = codegen_field(fx, ptr, None, layout, field);\n                 CValue::by_ref(field_ptr, field_layout)\n@@ -201,7 +213,11 @@ impl<'tcx> CValue<'tcx> {\n         }\n     }\n \n-    pub(crate) fn unsize_value(self, fx: &mut FunctionCx<'_, 'tcx, impl Backend>, dest: CPlace<'tcx>) {\n+    pub(crate) fn unsize_value(\n+        self,\n+        fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n+        dest: CPlace<'tcx>,\n+    ) {\n         crate::unsize::coerce_unsized_into(fx, self, dest);\n     }\n \n@@ -217,7 +233,11 @@ impl<'tcx> CValue<'tcx> {\n \n         match layout.ty.kind {\n             ty::Bool => {\n-                assert!(const_val == 0 || const_val == 1, \"Invalid bool 0x{:032X}\", const_val);\n+                assert!(\n+                    const_val == 0 || const_val == 1,\n+                    \"Invalid bool 0x{:032X}\",\n+                    const_val\n+                );\n             }\n             _ => {}\n         }\n@@ -254,8 +274,14 @@ impl<'tcx> CValue<'tcx> {\n     }\n \n     pub(crate) fn cast_pointer_to(self, layout: TyAndLayout<'tcx>) -> Self {\n-        assert!(matches!(self.layout().ty.kind, ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..)));\n-        assert!(matches!(layout.ty.kind, ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..)));\n+        assert!(matches!(\n+            self.layout().ty.kind,\n+            ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..)\n+        ));\n+        assert!(matches!(\n+            layout.ty.kind,\n+            ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..)\n+        ));\n         assert_eq!(self.layout().abi, layout.abi);\n         CValue(self.0, layout)\n     }\n@@ -319,8 +345,7 @@ impl<'tcx> CPlace<'tcx> {\n     ) -> CPlace<'tcx> {\n         let var = Variable::with_u32(fx.next_ssa_var);\n         fx.next_ssa_var += 1;\n-        fx.bcx\n-            .declare_var(var, fx.clif_type(layout.ty).unwrap());\n+        fx.bcx.declare_var(var, fx.clif_type(layout.ty).unwrap());\n         CPlace {\n             inner: CPlaceInner::Var(local, var),\n             layout,\n@@ -353,7 +378,11 @@ impl<'tcx> CPlace<'tcx> {\n         }\n     }\n \n-    pub(crate) fn for_ptr_with_extra(ptr: Pointer, extra: Value, layout: TyAndLayout<'tcx>) -> CPlace<'tcx> {\n+    pub(crate) fn for_ptr_with_extra(\n+        ptr: Pointer,\n+        extra: Value,\n+        layout: TyAndLayout<'tcx>,\n+    ) -> CPlace<'tcx> {\n         CPlace {\n             inner: CPlaceInner::Addr(ptr, Some(extra)),\n             layout,\n@@ -365,19 +394,23 @@ impl<'tcx> CPlace<'tcx> {\n         match self.inner {\n             CPlaceInner::Var(_local, var) => {\n                 let val = fx.bcx.use_var(var);\n-                fx.bcx.set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+                fx.bcx\n+                    .set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n                 CValue::by_val(val, layout)\n             }\n             CPlaceInner::VarPair(_local, var1, var2) => {\n                 let val1 = fx.bcx.use_var(var1);\n-                fx.bcx.set_val_label(val1, cranelift_codegen::ir::ValueLabel::new(var1.index()));\n+                fx.bcx\n+                    .set_val_label(val1, cranelift_codegen::ir::ValueLabel::new(var1.index()));\n                 let val2 = fx.bcx.use_var(var2);\n-                fx.bcx.set_val_label(val2, cranelift_codegen::ir::ValueLabel::new(var2.index()));\n+                fx.bcx\n+                    .set_val_label(val2, cranelift_codegen::ir::ValueLabel::new(var2.index()));\n                 CValue::by_val_pair(val1, val2, layout)\n             }\n             CPlaceInner::VarLane(_local, var, lane) => {\n                 let val = fx.bcx.use_var(var);\n-                fx.bcx.set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+                fx.bcx\n+                    .set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n                 let val = fx.bcx.ins().extractlane(val, lane);\n                 CValue::by_val(val, layout)\n             }\n@@ -407,15 +440,22 @@ impl<'tcx> CPlace<'tcx> {\n         }\n     }\n \n-    pub(crate) fn write_cvalue(self, fx: &mut FunctionCx<'_, 'tcx, impl Backend>, from: CValue<'tcx>) {\n+    pub(crate) fn write_cvalue(\n+        self,\n+        fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n+        from: CValue<'tcx>,\n+    ) {\n         fn assert_assignable<'tcx>(\n             fx: &FunctionCx<'_, 'tcx, impl Backend>,\n             from_ty: Ty<'tcx>,\n             to_ty: Ty<'tcx>,\n         ) {\n             match (&from_ty.kind, &to_ty.kind) {\n                 (ty::Ref(_, a, _), ty::Ref(_, b, _))\n-                | (ty::RawPtr(TypeAndMut { ty: a, mutbl: _}), ty::RawPtr(TypeAndMut { ty: b, mutbl: _})) => {\n+                | (\n+                    ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }),\n+                    ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }),\n+                ) => {\n                     assert_assignable(fx, a, b);\n                 }\n                 (ty::FnPtr(_), ty::FnPtr(_)) => {\n@@ -478,8 +518,7 @@ impl<'tcx> CPlace<'tcx> {\n         self,\n         fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n         from: CValue<'tcx>,\n-        #[cfg_attr(not(debug_assertions), allow(unused_variables))]\n-        method: &'static str,\n+        #[cfg_attr(not(debug_assertions), allow(unused_variables))] method: &'static str,\n     ) {\n         fn transmute_value<'tcx>(\n             fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n@@ -492,16 +531,17 @@ impl<'tcx> CPlace<'tcx> {\n                 (_, _) if src_ty == dst_ty => data,\n \n                 // This is a `write_cvalue_transmute`.\n-                (types::I32, types::F32) | (types::F32, types::I32)\n-                    | (types::I64, types::F64) | (types::F64, types::I64) => {\n-                        fx.bcx.ins().bitcast(dst_ty, data)\n-                }\n+                (types::I32, types::F32)\n+                | (types::F32, types::I32)\n+                | (types::I64, types::F64)\n+                | (types::F64, types::I64) => fx.bcx.ins().bitcast(dst_ty, data),\n                 _ if src_ty.is_vector() && dst_ty.is_vector() => {\n                     fx.bcx.ins().raw_bitcast(dst_ty, data)\n                 }\n                 _ => unreachable!(\"write_cvalue_transmute: {:?} -> {:?}\", src_ty, dst_ty),\n             };\n-            fx.bcx.set_val_label(data, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+            fx.bcx\n+                .set_val_label(data, cranelift_codegen::ir::ValueLabel::new(var.index()));\n             fx.bcx.def_var(var, data);\n         }\n \n@@ -516,7 +556,14 @@ impl<'tcx> CPlace<'tcx> {\n             };\n             fx.add_comment(\n                 fx.bcx.func.layout.last_inst(cur_block).unwrap(),\n-                format!(\"{}: {:?}: {:?} <- {:?}: {:?}\", method, self.inner(), self.layout().ty, from.0, from.layout().ty),\n+                format!(\n+                    \"{}: {:?}: {:?} <- {:?}: {:?}\",\n+                    method,\n+                    self.inner(),\n+                    self.layout().ty,\n+                    from.0,\n+                    from.layout().ty\n+                ),\n             );\n         }\n \n@@ -540,13 +587,15 @@ impl<'tcx> CPlace<'tcx> {\n \n                 // First get the old vector\n                 let vector = fx.bcx.use_var(var);\n-                fx.bcx.set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+                fx.bcx\n+                    .set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n \n                 // Next insert the written lane into the vector\n                 let vector = fx.bcx.ins().insertlane(vector, data, lane);\n \n                 // Finally write the new vector\n-                fx.bcx.set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+                fx.bcx\n+                    .set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n                 fx.bcx.def_var(var, vector);\n \n                 return;\n@@ -571,7 +620,9 @@ impl<'tcx> CPlace<'tcx> {\n                 let (value, extra) = from.load_scalar_pair(fx);\n                 let b_offset = scalar_pair_calculate_b_offset(fx.tcx, a_scalar, b_scalar);\n                 to_ptr.store(fx, value, MemFlags::new());\n-                to_ptr.offset(fx, b_offset).store(fx, extra, MemFlags::new());\n+                to_ptr\n+                    .offset(fx, b_offset)\n+                    .store(fx, extra, MemFlags::new());\n                 return;\n             }\n             _ => {}\n@@ -628,14 +679,18 @@ impl<'tcx> CPlace<'tcx> {\n                 let layout = layout.field(&*fx, field.index());\n \n                 match field.as_u32() {\n-                    0 => return CPlace {\n-                        inner: CPlaceInner::Var(local, var1),\n-                        layout,\n-                    },\n-                    1 => return CPlace {\n-                        inner: CPlaceInner::Var(local, var2),\n-                        layout,\n-                    },\n+                    0 => {\n+                        return CPlace {\n+                            inner: CPlaceInner::Var(local, var1),\n+                            layout,\n+                        }\n+                    }\n+                    1 => {\n+                        return CPlace {\n+                            inner: CPlaceInner::Var(local, var2),\n+                            layout,\n+                        }\n+                    }\n                     _ => unreachable!(\"field should be 0 or 1\"),\n                 }\n             }\n@@ -677,7 +732,10 @@ impl<'tcx> CPlace<'tcx> {\n             let (addr, extra) = self.to_cvalue(fx).load_scalar_pair(fx);\n             CPlace::for_ptr_with_extra(Pointer::new(addr), extra, inner_layout)\n         } else {\n-            CPlace::for_ptr(Pointer::new(self.to_cvalue(fx).load_scalar(fx)), inner_layout)\n+            CPlace::for_ptr(\n+                Pointer::new(self.to_cvalue(fx).load_scalar(fx)),\n+                inner_layout,\n+            )\n         }\n     }\n "}, {"sha": "d23b077148e594102491537bb26bb1dd55e82d0a", "filename": "src/vtable.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e685a512e66dfc5f66f49bc921cd77e1c9ab44a/src%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvtable.rs?ref=4e685a512e66dfc5f66f49bc921cd77e1c9ab44a", "patch": "@@ -51,10 +51,7 @@ pub(crate) fn get_ptr_and_method_ref<'tcx>(\n         arg.load_scalar_pair(fx)\n     } else {\n         let (ptr, vtable) = arg.try_to_ptr().unwrap();\n-        (\n-            ptr.get_addr(fx),\n-            vtable.unwrap()\n-        )\n+        (ptr.get_addr(fx), vtable.unwrap())\n     };\n \n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes();\n@@ -92,8 +89,11 @@ fn build_vtable<'tcx>(\n     let tcx = fx.tcx;\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n \n-    let drop_in_place_fn =\n-        import_function(tcx, &mut fx.cx.module, Instance::resolve_drop_in_place(tcx, layout.ty).polymorphize(fx.tcx));\n+    let drop_in_place_fn = import_function(\n+        tcx,\n+        &mut fx.cx.module,\n+        Instance::resolve_drop_in_place(tcx, layout.ty).polymorphize(fx.tcx),\n+    );\n \n     let mut components: Vec<_> = vec![Some(drop_in_place_fn), None, None];\n \n@@ -109,7 +109,9 @@ fn build_vtable<'tcx>(\n             Some(import_function(\n                 tcx,\n                 &mut fx.cx.module,\n-                Instance::resolve_for_vtable(tcx, ParamEnv::reveal_all(), def_id, substs).unwrap().polymorphize(fx.tcx),\n+                Instance::resolve_for_vtable(tcx, ParamEnv::reveal_all(), def_id, substs)\n+                    .unwrap()\n+                    .polymorphize(fx.tcx),\n             ))\n         })\n     });\n@@ -133,7 +135,8 @@ fn build_vtable<'tcx>(\n     }\n \n     let data_id = fx\n-        .cx.module\n+        .cx\n+        .module\n         .declare_data(\n             &format!(\n                 \"__vtable.{}.for.{:?}.{}\","}]}