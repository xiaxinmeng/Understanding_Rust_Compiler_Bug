{"sha": "418b23a5389482c2889c5c01f7f31ba5061c5bc5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxOGIyM2E1Mzg5NDgyYzI4ODljNWMwMWY3ZjMxYmE1MDYxYzViYzU=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-26T20:39:25Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-26T20:39:25Z"}, "message": "Various bits of trans lint, nothing major.", "tree": {"sha": "31b9074d2b0a3d91f8a6012bff417a2172983ac0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31b9074d2b0a3d91f8a6012bff417a2172983ac0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/418b23a5389482c2889c5c01f7f31ba5061c5bc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/418b23a5389482c2889c5c01f7f31ba5061c5bc5", "html_url": "https://github.com/rust-lang/rust/commit/418b23a5389482c2889c5c01f7f31ba5061c5bc5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/418b23a5389482c2889c5c01f7f31ba5061c5bc5/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2746d20c839df05b2c04663f19398b23eddac737", "url": "https://api.github.com/repos/rust-lang/rust/commits/2746d20c839df05b2c04663f19398b23eddac737", "html_url": "https://github.com/rust-lang/rust/commit/2746d20c839df05b2c04663f19398b23eddac737"}], "stats": {"total": 61, "additions": 36, "deletions": 25}, "files": [{"sha": "761da0440ba0cdcefb68b88c29f1fa90220a1a25", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 36, "deletions": 25, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/418b23a5389482c2889c5c01f7f31ba5061c5bc5/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418b23a5389482c2889c5c01f7f31ba5061c5bc5/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=418b23a5389482c2889c5c01f7f31ba5061c5bc5", "patch": "@@ -1228,7 +1228,7 @@ fn dynamic_size_of(@block_ctxt cx, ty.t t) -> result {\n             auto elt_size = size_of(bcx, e);\n             bcx = elt_size.bcx;\n             auto aligned_off = align_to(bcx, off, elt_align.val);\n-            off = cx.build.Add(aligned_off, elt_size.val);\n+            off = bcx.build.Add(aligned_off, elt_size.val);\n             max_align = umax(bcx, max_align, elt_align.val);\n         }\n         off = align_to(bcx, off, max_align);\n@@ -1488,7 +1488,7 @@ fn trans_raw_malloc(@block_ctxt cx, TypeRef llptr_ty, ValueRef llsize)\n     // FIXME: need a table to collect tydesc globals.\n     auto tydesc = C_int(0);\n     auto rslt = trans_upcall(cx, \"upcall_malloc\", vec(llsize, tydesc));\n-    rslt = res(rslt.bcx, vi2p(cx, rslt.val, llptr_ty));\n+    rslt = res(rslt.bcx, vi2p(rslt.bcx, rslt.val, llptr_ty));\n     ret rslt;\n }\n \n@@ -1949,6 +1949,8 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v0, ty.t t) {\n                        ty.type_is_native(cx.fcx.lcx.ccx.tcx, t) ||\n                        ty.type_is_nil(cx.fcx.lcx.ccx.tcx, t)) {\n                 rslt = res(cx, C_nil());\n+            } else {\n+                rslt = res(cx, C_nil());\n             }\n         }\n     }\n@@ -2356,7 +2358,7 @@ fn iter_structural_ty_full(@block_ctxt cx,\n \n         auto r = f(inner_cx, box_a_ptr, box_b_ptr, tbox);\n         r.bcx.build.Br(next_cx.llbb);\n-        ret res(next_cx, r.val);\n+        ret res(next_cx, C_nil());\n     }\n \n     alt (ty.struct(cx.fcx.lcx.ccx.tcx, t)) {\n@@ -2626,7 +2628,7 @@ fn iter_sequence(@block_ctxt cx,\n         auto p1 = vi2p(bcx, bcx.build.Add(vp2i(bcx, p0), len),\n                        T_ptr(llunit_ty));\n \n-        ret iter_sequence_inner(cx, p0, p1, elt_ty, f);\n+        ret iter_sequence_inner(bcx, p0, p1, elt_ty, f);\n     }\n \n     alt (ty.struct(cx.fcx.lcx.ccx.tcx, t)) {\n@@ -2660,11 +2662,13 @@ fn call_tydesc_glue_full(@block_ctxt cx, ValueRef v,\n                                 llrawptr));\n }\n \n-fn call_tydesc_glue(@block_ctxt cx, ValueRef v, ty.t t, int field) {\n+fn call_tydesc_glue(@block_ctxt cx, ValueRef v,\n+                    ty.t t, int field) -> result {\n     auto td = get_tydesc(cx, t);\n     call_tydesc_glue_full(td.bcx,\n                           spill_if_immediate(td.bcx, v, t),\n                           td.val, field);\n+    ret res(td.bcx, C_nil());\n }\n \n fn call_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs, ty.t t,\n@@ -2705,7 +2709,7 @@ fn call_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs, ty.t t,\n \n fn take_ty(@block_ctxt cx, ValueRef v, ty.t t) -> result {\n     if (!ty.type_is_scalar(cx.fcx.lcx.ccx.tcx, t)) {\n-        call_tydesc_glue(cx, v, t, abi.tydesc_field_take_glue);\n+        ret call_tydesc_glue(cx, v, t, abi.tydesc_field_take_glue);\n     }\n     ret res(cx, C_nil());\n }\n@@ -2727,7 +2731,7 @@ fn drop_ty(@block_ctxt cx,\n            ty.t t) -> result {\n \n     if (!ty.type_is_scalar(cx.fcx.lcx.ccx.tcx, t)) {\n-        call_tydesc_glue(cx, v, t, abi.tydesc_field_drop_glue);\n+        ret call_tydesc_glue(cx, v, t, abi.tydesc_field_drop_glue);\n     }\n     ret res(cx, C_nil());\n }\n@@ -3529,7 +3533,7 @@ fn trans_for_each(@block_ctxt cx,\n     auto lltydescsptr = cx.build.GEP(llenvptr,\n                                      vec(C_int(0),\n                                          C_int(abi.box_rc_field_body),\n-                                         C_int(3)));\n+                                         C_int(abi.closure_elt_ty_params)));\n     auto i = 0u;\n     while (i < tydesc_count) {\n         auto lltydescptr = cx.build.GEP(lltydescsptr,\n@@ -3563,8 +3567,10 @@ fn trans_for_each(@block_ctxt cx,\n \n     // Populate the upvars from the environment.\n     auto llremoteenvptr = bcx.build.PointerCast(fcx.llenv, llenvptrty);\n-    auto llremotebindingsptrptr = bcx.build.GEP(llremoteenvptr,\n-        vec(C_int(0), C_int(abi.box_rc_field_body), C_int(2)));\n+    auto llremotebindingsptrptr =\n+        bcx.build.GEP(llremoteenvptr, vec(C_int(0),\n+                                          C_int(abi.box_rc_field_body),\n+                                          C_int(abi.closure_elt_bindings)));\n     auto llremotebindingsptr = bcx.build.Load(llremotebindingsptrptr);\n \n     i = 0u;\n@@ -3579,10 +3585,11 @@ fn trans_for_each(@block_ctxt cx,\n     }\n \n     // Populate the type parameters from the environment.\n-    auto llremotetydescsptr = bcx.build.GEP(llremoteenvptr,\n-                                            vec(C_int(0),\n-                                                C_int(abi.box_rc_field_body),\n-                                                C_int(3)));\n+    auto llremotetydescsptr =\n+        bcx.build.GEP(llremoteenvptr,\n+                      vec(C_int(0),\n+                          C_int(abi.box_rc_field_body),\n+                          C_int(abi.closure_elt_ty_params)));\n \n     i = 0u;\n     while (i < tydesc_count) {\n@@ -3903,7 +3910,7 @@ fn lval_generic_fn(@block_ctxt cx,\n     }\n \n     if (_vec.len[ty.t](tys) != 0u) {\n-        auto bcx = cx;\n+        auto bcx = lv.res.bcx;\n         let vec[ValueRef] tydescs = vec();\n         for (ty.t t in tys) {\n             auto td = get_tydesc(bcx, t);\n@@ -4497,7 +4504,7 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n             for (ValueRef v in bound_vals) {\n                 auto bound = bcx.build.GEP(bindings,\n                                            vec(C_int(0), C_int(i as int)));\n-                bcx = copy_ty(r.bcx, INIT, bound, v, bound_tys.(i)).bcx;\n+                bcx = copy_ty(bcx, INIT, bound, v, bound_tys.(i)).bcx;\n                 i += 1u;\n             }\n \n@@ -5324,7 +5331,7 @@ fn trans_break_cont(@block_ctxt cx, bool to_end) -> result {\n                         }\n                     }\n                 }\n-                ret res(new_sub_block_ctxt(cx, \"unreachable\"), C_nil());\n+                ret res(bcx, C_nil());\n             }\n             case (_) {\n                 alt (cleanup_cx.parent) {\n@@ -5333,7 +5340,7 @@ fn trans_break_cont(@block_ctxt cx, bool to_end) -> result {\n             }\n         }\n     }\n-    ret res(cx, C_nil()); // Never reached. Won't compile otherwise.\n+    fail;\n }\n \n fn trans_break(@block_ctxt cx) -> result {\n@@ -5357,7 +5364,11 @@ fn trans_ret(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n             val = r.val;\n             bcx = copy_ty(bcx, INIT, cx.fcx.llretptr, val, t).bcx;\n         }\n-        case (_) { /* fall through */  }\n+        case (_) {\n+            auto t = llvm.LLVMGetElementType(val_ty(cx.fcx.llretptr));\n+            auto null = lib.llvm.llvm.LLVMConstNull(t);\n+            bcx.build.Store(null, cx.fcx.llretptr);\n+        }\n     }\n \n     // Run all cleanups and back out.\n@@ -6052,7 +6063,7 @@ fn trans_fn(@local_ctxt cx, &ast._fn f, ast.def_id fid,\n     new_builder(fcx.llallocas).Br(lltop);\n }\n \n-fn trans_vtbl(@local_ctxt cx, \n+fn trans_vtbl(@local_ctxt cx,\n               TypeRef llself_ty,\n               ty.t self_ty,\n               &ast._obj ob,\n@@ -6085,7 +6096,7 @@ fn trans_vtbl(@local_ctxt cx,\n         cx.ccx.item_ids.insert(m.node.id, llfn);\n         cx.ccx.item_symbols.insert(m.node.id, s);\n \n-        trans_fn(mcx, m.node.meth, m.node.id, \n+        trans_fn(mcx, m.node.meth, m.node.id,\n                  some[tup(TypeRef, ty.t)](tup(llself_ty, self_ty)),\n                  ty_params, m.node.ann);\n         methods += vec(llfn);\n@@ -6146,7 +6157,7 @@ fn trans_obj(@local_ctxt cx, &ast._obj ob, ast.def_id oid,\n \n     auto fcx = new_fn_ctxt(cx, llctor_decl);\n     create_llargs_for_fn_args(fcx, ast.proto_fn,\n-                              none[tup(TypeRef, ty.t)], \n+                              none[tup(TypeRef, ty.t)],\n                               ret_ty_of_fn(cx.ccx, ann),\n                               fn_args, ty_params);\n \n@@ -6289,7 +6300,7 @@ fn trans_tag_variant(@local_ctxt cx, ast.def_id tag_id,\n     auto fcx = new_fn_ctxt(cx, llfndecl);\n \n     create_llargs_for_fn_args(fcx, ast.proto_fn,\n-                              none[tup(TypeRef, ty.t)], \n+                              none[tup(TypeRef, ty.t)],\n                               ret_ty_of_fn(cx.ccx, variant.node.ann),\n                               fn_args, ty_params);\n \n@@ -6718,7 +6729,7 @@ fn collect_item_2(@crate_ctxt ccx, @walk_ctxt wcx, @ast.item i) {\n fn collect_items(@crate_ctxt ccx, @ast.crate crate) {\n     auto wcx = new_walk_ctxt();\n     auto visitor0 = walk.default_visitor();\n-    auto visitor1 = rec(visit_native_item_pre = \n+    auto visitor1 = rec(visit_native_item_pre =\n                           bind collect_native_item(ccx, wcx, _),\n                         visit_item_pre = bind collect_item_1(ccx, wcx, _),\n                         visit_item_post = bind leave_item(wcx, _)\n@@ -6760,7 +6771,7 @@ fn collect_tag_ctors(@crate_ctxt ccx, @ast.crate crate) {\n \n fn trans_constant(@crate_ctxt ccx, @walk_ctxt wcx, @ast.item it) {\n     enter_item(wcx, it);\n-    \n+\n     alt (it.node) {\n         case (ast.item_tag(?ident, ?variants, _, ?tag_id, _)) {\n             auto i = 0u;"}]}