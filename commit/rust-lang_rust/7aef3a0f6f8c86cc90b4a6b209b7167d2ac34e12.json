{"sha": "7aef3a0f6f8c86cc90b4a6b209b7167d2ac34e12", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhZWYzYTBmNmY4Yzg2Y2M5MGI0YTZiMjA5YjcxNjdkMmFjMzRlMTI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-29T19:58:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-29T19:58:24Z"}, "message": "Rollup merge of #71804 - petrochenkov:static-pie, r=cuviper\n\nlinker: Support `-static-pie` and `-static -shared`\n\nThis PR adds support for passing linker arguments for creating statically linked position-independent executables and \"statically linked\" shared libraries.\n\nTherefore it incorporates the majority of https://github.com/rust-lang/rust/pull/70740 except for the linker rerun hack and actually flipping the \"`static-pie` is supported\" switch for musl targets.", "tree": {"sha": "b34777f56cd32709880200dd6833c70394606db1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b34777f56cd32709880200dd6833c70394606db1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7aef3a0f6f8c86cc90b4a6b209b7167d2ac34e12", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe0WlgCRBK7hj4Ov3rIwAAdHIIAFnUzHxjtMNc/i8+8dSpVyLa\n1+WHy5/By9KVqZzWcoTt7Dx0kWIMVXEXDOoU5gPOs5+yCchnlWKlg4HprIvY8d9i\nNBXj+ZJqQsU1M224ycGyVdtdnPQX84p6Ve8YSyPYmxJ5Dm9Ru1tw6q3nVrTgrUX/\nSQ//EjKOxZZoG3DCelXwpw00wvyigM52PS3aLl60C52Al7ufYKg4FzyHff/EkPjY\nz/YcAti9ztf/GqxElyZKhpqVCegVigh1dJL/MBqHXjND5WqUqakDrePtQ7hmF1Ee\ngFmNCOd6xnH6wipVunu320pvDHrvrTxuX2zXks4t8Fkruo10SFSOtevLznlyDAU=\n=e7va\n-----END PGP SIGNATURE-----\n", "payload": "tree b34777f56cd32709880200dd6833c70394606db1\nparent 1cfe0e9c635c41309ec852c5f296f7e77fec6940\nparent 96a466c3128945627c2f81ec13b8ae98be7c3749\nauthor Ralf Jung <post@ralfj.de> 1590782304 +0200\ncommitter GitHub <noreply@github.com> 1590782304 +0200\n\nRollup merge of #71804 - petrochenkov:static-pie, r=cuviper\n\nlinker: Support `-static-pie` and `-static -shared`\n\nThis PR adds support for passing linker arguments for creating statically linked position-independent executables and \"statically linked\" shared libraries.\n\nTherefore it incorporates the majority of https://github.com/rust-lang/rust/pull/70740 except for the linker rerun hack and actually flipping the \"`static-pie` is supported\" switch for musl targets.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7aef3a0f6f8c86cc90b4a6b209b7167d2ac34e12", "html_url": "https://github.com/rust-lang/rust/commit/7aef3a0f6f8c86cc90b4a6b209b7167d2ac34e12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7aef3a0f6f8c86cc90b4a6b209b7167d2ac34e12/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cfe0e9c635c41309ec852c5f296f7e77fec6940", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cfe0e9c635c41309ec852c5f296f7e77fec6940", "html_url": "https://github.com/rust-lang/rust/commit/1cfe0e9c635c41309ec852c5f296f7e77fec6940"}, {"sha": "96a466c3128945627c2f81ec13b8ae98be7c3749", "url": "https://api.github.com/repos/rust-lang/rust/commits/96a466c3128945627c2f81ec13b8ae98be7c3749", "html_url": "https://github.com/rust-lang/rust/commit/96a466c3128945627c2f81ec13b8ae98be7c3749"}], "stats": {"total": 261, "additions": 127, "deletions": 134}, "files": [{"sha": "dcce1d45298cc5012855b380739d86e07961402a", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7aef3a0f6f8c86cc90b4a6b209b7167d2ac34e12/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aef3a0f6f8c86cc90b4a6b209b7167d2ac34e12/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=7aef3a0f6f8c86cc90b4a6b209b7167d2ac34e12", "patch": "@@ -1194,9 +1194,10 @@ fn link_output_kind(sess: &Session, crate_type: CrateType) -> LinkOutputKind {\n     };\n \n     // Adjust the output kind to target capabilities.\n-    let pic_exe_supported = sess.target.target.options.position_independent_executables;\n-    let static_pic_exe_supported = false; // FIXME: Add this option to target specs.\n-    let static_dylib_supported = sess.target.target.options.crt_static_allows_dylibs;\n+    let opts = &sess.target.target.options;\n+    let pic_exe_supported = opts.position_independent_executables;\n+    let static_pic_exe_supported = opts.static_position_independent_executables;\n+    let static_dylib_supported = opts.crt_static_allows_dylibs;\n     match kind {\n         LinkOutputKind::DynamicPicExe if !pic_exe_supported => LinkOutputKind::DynamicNoPicExe,\n         LinkOutputKind::StaticPicExe if !static_pic_exe_supported => LinkOutputKind::StaticNoPicExe,\n@@ -1580,16 +1581,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     }\n \n     // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n-    // FIXME: Support `StaticPicExe` correctly.\n-    match link_output_kind {\n-        LinkOutputKind::DynamicPicExe | LinkOutputKind::StaticPicExe => {\n-            cmd.position_independent_executable()\n-        }\n-        LinkOutputKind::DynamicNoPicExe | LinkOutputKind::StaticNoPicExe => {\n-            cmd.no_position_independent_executable()\n-        }\n-        _ => {}\n-    }\n+    cmd.set_output_kind(link_output_kind, out_filename);\n \n     // OBJECT-FILES-NO, AUDIT-ORDER\n     add_relro_args(cmd, sess);\n@@ -1618,17 +1610,6 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n         tmpdir,\n     );\n \n-    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n-    // FIXME: Merge with the previous `link_output_kind` match,\n-    // and support `StaticPicExe` and `StaticDylib` correctly.\n-    match link_output_kind {\n-        LinkOutputKind::StaticNoPicExe | LinkOutputKind::StaticPicExe => {\n-            cmd.build_static_executable()\n-        }\n-        LinkOutputKind::DynamicDylib | LinkOutputKind::StaticDylib => cmd.build_dylib(out_filename),\n-        _ => {}\n-    }\n-\n     // OBJECT-FILES-NO, AUDIT-ORDER\n     if sess.opts.cg.profile_generate.enabled() {\n         cmd.pgo_gen();"}, {"sha": "46c365efdb5fab9470d67ae2537b0512d39ce615", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 117, "deletions": 110, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/7aef3a0f6f8c86cc90b4a6b209b7167d2ac34e12/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aef3a0f6f8c86cc90b4a6b209b7167d2ac34e12/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=7aef3a0f6f8c86cc90b4a6b209b7167d2ac34e12", "patch": "@@ -17,7 +17,7 @@ use rustc_serialize::{json, Encoder};\n use rustc_session::config::{self, CrateType, DebugInfo, LinkerPluginLto, Lto, OptLevel, Strip};\n use rustc_session::Session;\n use rustc_span::symbol::Symbol;\n-use rustc_target::spec::{LinkerFlavor, LldFlavor};\n+use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor};\n \n /// Disables non-English messages from localized linkers.\n /// Such messages may cause issues with text encoding on Windows (#35785)\n@@ -101,6 +101,7 @@ impl LinkerInfo {\n /// MSVC linker (e.g., `link.exe`) is being used.\n pub trait Linker {\n     fn cmd(&mut self) -> &mut Command;\n+    fn set_output_kind(&mut self, output_kind: LinkOutputKind, out_filename: &Path);\n     fn link_dylib(&mut self, lib: Symbol);\n     fn link_rust_dylib(&mut self, lib: Symbol, path: &Path);\n     fn link_framework(&mut self, framework: Symbol);\n@@ -113,8 +114,6 @@ pub trait Linker {\n     fn output_filename(&mut self, path: &Path);\n     fn add_object(&mut self, path: &Path);\n     fn gc_sections(&mut self, keep_metadata: bool);\n-    fn position_independent_executable(&mut self);\n-    fn no_position_independent_executable(&mut self);\n     fn full_relro(&mut self);\n     fn partial_relro(&mut self);\n     fn no_relro(&mut self);\n@@ -124,8 +123,6 @@ pub trait Linker {\n     fn debuginfo(&mut self, strip: Strip);\n     fn no_crt_objects(&mut self);\n     fn no_default_libraries(&mut self);\n-    fn build_dylib(&mut self, out_filename: &Path);\n-    fn build_static_executable(&mut self);\n     fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType);\n     fn subsystem(&mut self, subsystem: &str);\n     fn group_start(&mut self);\n@@ -232,12 +229,94 @@ impl<'a> GccLinker<'a> {\n         let target_cpu = self.target_cpu;\n         self.linker_arg(&format!(\"-plugin-opt=mcpu={}\", target_cpu));\n     }\n+\n+    fn build_dylib(&mut self, out_filename: &Path) {\n+        // On mac we need to tell the linker to let this library be rpathed\n+        if self.sess.target.target.options.is_like_osx {\n+            self.cmd.arg(\"-dynamiclib\");\n+            self.linker_arg(\"-dylib\");\n+\n+            // Note that the `osx_rpath_install_name` option here is a hack\n+            // purely to support rustbuild right now, we should get a more\n+            // principled solution at some point to force the compiler to pass\n+            // the right `-Wl,-install_name` with an `@rpath` in it.\n+            if self.sess.opts.cg.rpath || self.sess.opts.debugging_opts.osx_rpath_install_name {\n+                self.linker_arg(\"-install_name\");\n+                let mut v = OsString::from(\"@rpath/\");\n+                v.push(out_filename.file_name().unwrap());\n+                self.linker_arg(&v);\n+            }\n+        } else {\n+            self.cmd.arg(\"-shared\");\n+            if self.sess.target.target.options.is_like_windows {\n+                // The output filename already contains `dll_suffix` so\n+                // the resulting import library will have a name in the\n+                // form of libfoo.dll.a\n+                let implib_name =\n+                    out_filename.file_name().and_then(|file| file.to_str()).map(|file| {\n+                        format!(\n+                            \"{}{}{}\",\n+                            self.sess.target.target.options.staticlib_prefix,\n+                            file,\n+                            self.sess.target.target.options.staticlib_suffix\n+                        )\n+                    });\n+                if let Some(implib_name) = implib_name {\n+                    let implib = out_filename.parent().map(|dir| dir.join(&implib_name));\n+                    if let Some(implib) = implib {\n+                        self.linker_arg(&format!(\"--out-implib,{}\", (*implib).to_str().unwrap()));\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n \n impl<'a> Linker for GccLinker<'a> {\n     fn cmd(&mut self) -> &mut Command {\n         &mut self.cmd\n     }\n+\n+    fn set_output_kind(&mut self, output_kind: LinkOutputKind, out_filename: &Path) {\n+        match output_kind {\n+            LinkOutputKind::DynamicNoPicExe => {\n+                if !self.is_ld {\n+                    self.cmd.arg(\"-no-pie\");\n+                }\n+            }\n+            LinkOutputKind::DynamicPicExe => {\n+                // `-pie` works for both gcc wrapper and ld.\n+                self.cmd.arg(\"-pie\");\n+            }\n+            LinkOutputKind::StaticNoPicExe => {\n+                // `-static` works for both gcc wrapper and ld.\n+                self.cmd.arg(\"-static\");\n+                if !self.is_ld {\n+                    self.cmd.arg(\"-no-pie\");\n+                }\n+            }\n+            LinkOutputKind::StaticPicExe => {\n+                if !self.is_ld {\n+                    // Note that combination `-static -pie` doesn't work as expected\n+                    // for the gcc wrapper, `-static` in that case suppresses `-pie`.\n+                    self.cmd.arg(\"-static-pie\");\n+                } else {\n+                    // `--no-dynamic-linker` and `-z text` are not strictly necessary for producing\n+                    // a static pie, but currently passed because gcc and clang pass them.\n+                    // The former suppresses the `INTERP` ELF header specifying dynamic linker,\n+                    // which is otherwise implicitly injected by ld (but not lld).\n+                    // The latter doesn't change anything, only ensures that everything is pic.\n+                    self.cmd.args(&[\"-static\", \"-pie\", \"--no-dynamic-linker\", \"-z\", \"text\"]);\n+                }\n+            }\n+            LinkOutputKind::DynamicDylib => self.build_dylib(out_filename),\n+            LinkOutputKind::StaticDylib => {\n+                self.cmd.arg(\"-static\");\n+                self.build_dylib(out_filename);\n+            }\n+        }\n+    }\n+\n     fn link_dylib(&mut self, lib: Symbol) {\n         self.hint_dynamic();\n         self.cmd.arg(format!(\"-l{}\", lib));\n@@ -262,14 +341,6 @@ impl<'a> Linker for GccLinker<'a> {\n     fn add_object(&mut self, path: &Path) {\n         self.cmd.arg(path);\n     }\n-    fn position_independent_executable(&mut self) {\n-        self.cmd.arg(\"-pie\");\n-    }\n-    fn no_position_independent_executable(&mut self) {\n-        if !self.is_ld {\n-            self.cmd.arg(\"-no-pie\");\n-        }\n-    }\n     fn full_relro(&mut self) {\n         self.linker_arg(\"-zrelro\");\n         self.linker_arg(\"-znow\");\n@@ -280,9 +351,6 @@ impl<'a> Linker for GccLinker<'a> {\n     fn no_relro(&mut self) {\n         self.linker_arg(\"-znorelro\");\n     }\n-    fn build_static_executable(&mut self) {\n-        self.cmd.arg(\"-static\");\n-    }\n \n     fn link_rust_dylib(&mut self, lib: Symbol, _path: &Path) {\n         self.hint_dynamic();\n@@ -418,47 +486,6 @@ impl<'a> Linker for GccLinker<'a> {\n         }\n     }\n \n-    fn build_dylib(&mut self, out_filename: &Path) {\n-        // On mac we need to tell the linker to let this library be rpathed\n-        if self.sess.target.target.options.is_like_osx {\n-            self.cmd.arg(\"-dynamiclib\");\n-            self.linker_arg(\"-dylib\");\n-\n-            // Note that the `osx_rpath_install_name` option here is a hack\n-            // purely to support rustbuild right now, we should get a more\n-            // principled solution at some point to force the compiler to pass\n-            // the right `-Wl,-install_name` with an `@rpath` in it.\n-            if self.sess.opts.cg.rpath || self.sess.opts.debugging_opts.osx_rpath_install_name {\n-                self.linker_arg(\"-install_name\");\n-                let mut v = OsString::from(\"@rpath/\");\n-                v.push(out_filename.file_name().unwrap());\n-                self.linker_arg(&v);\n-            }\n-        } else {\n-            self.cmd.arg(\"-shared\");\n-            if self.sess.target.target.options.is_like_windows {\n-                // The output filename already contains `dll_suffix` so\n-                // the resulting import library will have a name in the\n-                // form of libfoo.dll.a\n-                let implib_name =\n-                    out_filename.file_name().and_then(|file| file.to_str()).map(|file| {\n-                        format!(\n-                            \"{}{}{}\",\n-                            self.sess.target.target.options.staticlib_prefix,\n-                            file,\n-                            self.sess.target.target.options.staticlib_suffix\n-                        )\n-                    });\n-                if let Some(implib_name) = implib_name {\n-                    let implib = out_filename.parent().map(|dir| dir.join(&implib_name));\n-                    if let Some(implib) = implib {\n-                        self.linker_arg(&format!(\"--out-implib,{}\", (*implib).to_str().unwrap()));\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType) {\n         // Symbol visibility in object files typically takes care of this.\n         if crate_type == CrateType::Executable\n@@ -582,24 +609,29 @@ impl<'a> Linker for MsvcLinker<'a> {\n     fn cmd(&mut self) -> &mut Command {\n         &mut self.cmd\n     }\n+\n+    fn set_output_kind(&mut self, output_kind: LinkOutputKind, out_filename: &Path) {\n+        match output_kind {\n+            LinkOutputKind::DynamicNoPicExe\n+            | LinkOutputKind::DynamicPicExe\n+            | LinkOutputKind::StaticNoPicExe\n+            | LinkOutputKind::StaticPicExe => {}\n+            LinkOutputKind::DynamicDylib | LinkOutputKind::StaticDylib => {\n+                self.cmd.arg(\"/DLL\");\n+                let mut arg: OsString = \"/IMPLIB:\".into();\n+                arg.push(out_filename.with_extension(\"dll.lib\"));\n+                self.cmd.arg(arg);\n+            }\n+        }\n+    }\n+\n     fn link_rlib(&mut self, lib: &Path) {\n         self.cmd.arg(lib);\n     }\n     fn add_object(&mut self, path: &Path) {\n         self.cmd.arg(path);\n     }\n \n-    fn build_dylib(&mut self, out_filename: &Path) {\n-        self.cmd.arg(\"/DLL\");\n-        let mut arg: OsString = \"/IMPLIB:\".into();\n-        arg.push(out_filename.with_extension(\"dll.lib\"));\n-        self.cmd.arg(arg);\n-    }\n-\n-    fn build_static_executable(&mut self) {\n-        // noop\n-    }\n-\n     fn gc_sections(&mut self, _keep_metadata: bool) {\n         // MSVC's ICF (Identical COMDAT Folding) link optimization is\n         // slow for Rust and thus we disable it by default when not in\n@@ -632,14 +664,6 @@ impl<'a> Linker for MsvcLinker<'a> {\n         self.cmd.arg(&format!(\"{}.lib\", lib));\n     }\n \n-    fn position_independent_executable(&mut self) {\n-        // noop\n-    }\n-\n-    fn no_position_independent_executable(&mut self) {\n-        // noop\n-    }\n-\n     fn full_relro(&mut self) {\n         // noop\n     }\n@@ -817,6 +841,9 @@ impl<'a> Linker for EmLinker<'a> {\n     fn cmd(&mut self) -> &mut Command {\n         &mut self.cmd\n     }\n+\n+    fn set_output_kind(&mut self, _output_kind: LinkOutputKind, _out_filename: &Path) {}\n+\n     fn include_path(&mut self, path: &Path) {\n         self.cmd.arg(\"-L\").arg(path);\n     }\n@@ -856,14 +883,6 @@ impl<'a> Linker for EmLinker<'a> {\n         self.add_object(lib);\n     }\n \n-    fn position_independent_executable(&mut self) {\n-        // noop\n-    }\n-\n-    fn no_position_independent_executable(&mut self) {\n-        // noop\n-    }\n-\n     fn full_relro(&mut self) {\n         // noop\n     }\n@@ -925,14 +944,6 @@ impl<'a> Linker for EmLinker<'a> {\n         self.cmd.args(&[\"-s\", \"DEFAULT_LIBRARY_FUNCS_TO_INCLUDE=[]\"]);\n     }\n \n-    fn build_dylib(&mut self, _out_filename: &Path) {\n-        bug!(\"building dynamic library is unsupported on Emscripten\")\n-    }\n-\n-    fn build_static_executable(&mut self) {\n-        // noop\n-    }\n-\n     fn export_symbols(&mut self, _tmpdir: &Path, crate_type: CrateType) {\n         let symbols = &self.info.exports[&crate_type];\n \n@@ -1031,6 +1042,18 @@ impl<'a> Linker for WasmLd<'a> {\n         &mut self.cmd\n     }\n \n+    fn set_output_kind(&mut self, output_kind: LinkOutputKind, _out_filename: &Path) {\n+        match output_kind {\n+            LinkOutputKind::DynamicNoPicExe\n+            | LinkOutputKind::DynamicPicExe\n+            | LinkOutputKind::StaticNoPicExe\n+            | LinkOutputKind::StaticPicExe => {}\n+            LinkOutputKind::DynamicDylib | LinkOutputKind::StaticDylib => {\n+                self.cmd.arg(\"--no-entry\");\n+            }\n+        }\n+    }\n+\n     fn link_dylib(&mut self, lib: Symbol) {\n         self.cmd.arg(\"-l\").sym_arg(lib);\n     }\n@@ -1059,16 +1082,12 @@ impl<'a> Linker for WasmLd<'a> {\n         self.cmd.arg(path);\n     }\n \n-    fn position_independent_executable(&mut self) {}\n-\n     fn full_relro(&mut self) {}\n \n     fn partial_relro(&mut self) {}\n \n     fn no_relro(&mut self) {}\n \n-    fn build_static_executable(&mut self) {}\n-\n     fn link_rust_dylib(&mut self, lib: Symbol, _path: &Path) {\n         self.cmd.arg(\"-l\").sym_arg(lib);\n     }\n@@ -1124,10 +1143,6 @@ impl<'a> Linker for WasmLd<'a> {\n \n     fn no_default_libraries(&mut self) {}\n \n-    fn build_dylib(&mut self, _out_filename: &Path) {\n-        self.cmd.arg(\"--no-entry\");\n-    }\n-\n     fn export_symbols(&mut self, _tmpdir: &Path, crate_type: CrateType) {\n         for sym in self.info.exports[&crate_type].iter() {\n             self.cmd.arg(\"--export\").arg(&sym);\n@@ -1143,8 +1158,6 @@ impl<'a> Linker for WasmLd<'a> {\n \n     fn subsystem(&mut self, _subsystem: &str) {}\n \n-    fn no_position_independent_executable(&mut self) {}\n-\n     fn finalize(&mut self) {}\n \n     // Not needed for now with LLD\n@@ -1207,6 +1220,8 @@ impl<'a> Linker for PtxLinker<'a> {\n         &mut self.cmd\n     }\n \n+    fn set_output_kind(&mut self, _output_kind: LinkOutputKind, _out_filename: &Path) {}\n+\n     fn link_rlib(&mut self, path: &Path) {\n         self.cmd.arg(\"--rlib\").arg(path);\n     }\n@@ -1273,16 +1288,12 @@ impl<'a> Linker for PtxLinker<'a> {\n         panic!(\"frameworks not supported\")\n     }\n \n-    fn position_independent_executable(&mut self) {}\n-\n     fn full_relro(&mut self) {}\n \n     fn partial_relro(&mut self) {}\n \n     fn no_relro(&mut self) {}\n \n-    fn build_static_executable(&mut self) {}\n-\n     fn gc_sections(&mut self, _keep_metadata: bool) {}\n \n     fn pgo_gen(&mut self) {}\n@@ -1295,14 +1306,10 @@ impl<'a> Linker for PtxLinker<'a> {\n         self.sess.warn(\"Windows Control Flow Guard is not supported by this linker.\");\n     }\n \n-    fn build_dylib(&mut self, _out_filename: &Path) {}\n-\n     fn export_symbols(&mut self, _tmpdir: &Path, _crate_type: CrateType) {}\n \n     fn subsystem(&mut self, _subsystem: &str) {}\n \n-    fn no_position_independent_executable(&mut self) {}\n-\n     fn group_start(&mut self) {}\n \n     fn group_end(&mut self) {}"}, {"sha": "c9558879a1c6ec621a620a18c9df07f4d5c2416d", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7aef3a0f6f8c86cc90b4a6b209b7167d2ac34e12/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aef3a0f6f8c86cc90b4a6b209b7167d2ac34e12/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=7aef3a0f6f8c86cc90b4a6b209b7167d2ac34e12", "patch": "@@ -856,6 +856,8 @@ pub struct TargetOptions {\n     /// the functions in the executable are not randomized and can be used\n     /// during an exploit of a vulnerability in any code.\n     pub position_independent_executables: bool,\n+    /// Executables that are both statically linked and position-independent are supported.\n+    pub static_position_independent_executables: bool,\n     /// Determines if the target always requires using the PLT for indirect\n     /// library calls or not. This controls the default value of the `-Z plt` flag.\n     pub needs_plt: bool,\n@@ -1029,6 +1031,7 @@ impl Default for TargetOptions {\n             has_rpath: false,\n             no_default_libraries: true,\n             position_independent_executables: false,\n+            static_position_independent_executables: false,\n             needs_plt: false,\n             relro_level: RelroLevel::None,\n             pre_link_objects: Default::default(),\n@@ -1433,6 +1436,7 @@ impl Target {\n         key!(has_rpath, bool);\n         key!(no_default_libraries, bool);\n         key!(position_independent_executables, bool);\n+        key!(static_position_independent_executables, bool);\n         key!(needs_plt, bool);\n         key!(relro_level, RelroLevel)?;\n         key!(archive_format);\n@@ -1664,6 +1668,7 @@ impl ToJson for Target {\n         target_option_val!(has_rpath);\n         target_option_val!(no_default_libraries);\n         target_option_val!(position_independent_executables);\n+        target_option_val!(static_position_independent_executables);\n         target_option_val!(needs_plt);\n         target_option_val!(relro_level);\n         target_option_val!(archive_format);"}]}