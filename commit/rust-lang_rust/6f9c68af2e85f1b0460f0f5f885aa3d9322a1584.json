{"sha": "6f9c68af2e85f1b0460f0f5f885aa3d9322a1584", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmOWM2OGFmMmU4NWYxYjA0NjBmMGY1Zjg4NWFhM2Q5MzIyYTE1ODQ=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-08-26T00:07:29Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-08-26T01:30:31Z"}, "message": "Add _opt variants to str byte-conversion functions\n\nAdd _opt variants to from_bytes, from_bytes_owned, and from_bytes_slice.\nThese variants return an Option instead of raising a condition/failing.", "tree": {"sha": "1a42e02751d3f139d16d25336e4d0b69de60e056", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a42e02751d3f139d16d25336e4d0b69de60e056"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f9c68af2e85f1b0460f0f5f885aa3d9322a1584", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f9c68af2e85f1b0460f0f5f885aa3d9322a1584", "html_url": "https://github.com/rust-lang/rust/commit/6f9c68af2e85f1b0460f0f5f885aa3d9322a1584", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f9c68af2e85f1b0460f0f5f885aa3d9322a1584/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "491bc3568c87dadaba4d342135bd308961c6e0ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/491bc3568c87dadaba4d342135bd308961c6e0ef", "html_url": "https://github.com/rust-lang/rust/commit/491bc3568c87dadaba4d342135bd308961c6e0ef"}], "stats": {"total": 117, "additions": 108, "deletions": 9}, "files": [{"sha": "950d1bd134f54387fefe766d25687b3c623ba79d", "filename": "src/libstd/str.rs", "status": "modified", "additions": 108, "deletions": 9, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/6f9c68af2e85f1b0460f0f5f885aa3d9322a1584/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f9c68af2e85f1b0460f0f5f885aa3d9322a1584/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=6f9c68af2e85f1b0460f0f5f885aa3d9322a1584", "patch": "@@ -56,12 +56,23 @@ Section: Creating a string\n pub fn from_bytes(vv: &[u8]) -> ~str {\n     use str::not_utf8::cond;\n \n-    if !is_utf8(vv) {\n-        let first_bad_byte = *vv.iter().find(|&b| !is_utf8([*b])).unwrap();\n-        cond.raise(fmt!(\"from_bytes: input is not UTF-8; first bad byte is %u\",\n-                        first_bad_byte as uint))\n+    match from_bytes_opt(vv) {\n+        None => {\n+            let first_bad_byte = *vv.iter().find(|&b| !is_utf8([*b])).unwrap();\n+            cond.raise(fmt!(\"from_bytes: input is not UTF-8; first bad byte is %u\",\n+                            first_bad_byte as uint))\n+        }\n+        Some(s) => s\n+    }\n+}\n+\n+/// Convert a vector of bytes to a new UTF-8 string, if possible.\n+/// Returns None if the vector contains invalid UTF-8.\n+pub fn from_bytes_opt(vv: &[u8]) -> Option<~str> {\n+    if is_utf8(vv) {\n+        Some(unsafe { raw::from_bytes(vv) })\n     } else {\n-        return unsafe { raw::from_bytes(vv) }\n+        None\n     }\n }\n \n@@ -78,7 +89,17 @@ pub fn from_bytes_owned(vv: ~[u8]) -> ~str {\n         cond.raise(fmt!(\"from_bytes: input is not UTF-8; first bad byte is %u\",\n                         first_bad_byte as uint))\n     } else {\n-        return unsafe { raw::from_bytes_owned(vv) }\n+        unsafe { raw::from_bytes_owned(vv) }\n+    }\n+}\n+\n+/// Consumes a vector of bytes to create a new utf-8 string.\n+/// Returns None if the vector contains invalid UTF-8.\n+pub fn from_bytes_owned_opt(vv: ~[u8]) -> Option<~str> {\n+    if is_utf8(vv) {\n+        Some(unsafe { raw::from_bytes_owned(vv) })\n+    } else {\n+        None\n     }\n }\n \n@@ -91,8 +112,16 @@ pub fn from_bytes_owned(vv: ~[u8]) -> ~str {\n ///\n /// Fails if invalid UTF-8\n pub fn from_bytes_slice<'a>(v: &'a [u8]) -> &'a str {\n-    assert!(is_utf8(v));\n-    unsafe { cast::transmute(v) }\n+    from_bytes_slice_opt(v).expect(\"from_bytes_slice: not utf-8\")\n+}\n+\n+/// Converts a vector to a string slice without performing any allocations.\n+///\n+/// Returns None if the slice is not utf-8.\n+pub fn from_bytes_slice_opt<'a>(v: &'a [u8]) -> Option<&'a str> {\n+    if is_utf8(v) {\n+        Some(unsafe { cast::transmute(v) })\n+    } else { None }\n }\n \n impl ToStr for ~str {\n@@ -2358,7 +2387,7 @@ impl Zero for @str {\n #[cfg(test)]\n mod tests {\n     use container::Container;\n-    use option::Some;\n+    use option::{None, Some};\n     use libc::c_char;\n     use libc;\n     use ptr;\n@@ -3539,6 +3568,76 @@ mod tests {\n         let mut s = ~\"\\u00FC\"; // \u00fc\n         s.truncate(1);\n     }\n+\n+    #[test]\n+    fn test_str_from_bytes_slice() {\n+        let xs = bytes!(\"hello\");\n+        assert_eq!(from_bytes_slice(xs), \"hello\");\n+\n+        let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        assert_eq!(from_bytes_slice(xs), \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_str_from_bytes_slice_invalid() {\n+        let xs = bytes!(\"hello\", 0xff);\n+        let _ = from_bytes_slice(xs);\n+    }\n+\n+    #[test]\n+    fn test_str_from_bytes_slice_opt() {\n+        let xs = bytes!(\"hello\");\n+        assert_eq!(from_bytes_slice_opt(xs), Some(\"hello\"));\n+\n+        let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        assert_eq!(from_bytes_slice_opt(xs), Some(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n+\n+        let xs = bytes!(\"hello\", 0xff);\n+        assert_eq!(from_bytes_slice_opt(xs), None);\n+    }\n+\n+    #[test]\n+    fn test_str_from_bytes() {\n+        let xs = bytes!(\"hello\");\n+        assert_eq!(from_bytes(xs), ~\"hello\");\n+\n+        let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        assert_eq!(from_bytes(xs), ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+    }\n+\n+    #[test]\n+    fn test_str_from_bytes_opt() {\n+        let xs = bytes!(\"hello\").to_owned();\n+        assert_eq!(from_bytes_opt(xs), Some(~\"hello\"));\n+\n+        let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        assert_eq!(from_bytes_opt(xs), Some(~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n+\n+        let xs = bytes!(\"hello\", 0xff);\n+        assert_eq!(from_bytes_opt(xs), None);\n+    }\n+\n+    #[test]\n+    fn test_str_from_bytes_owned() {\n+        let xs = bytes!(\"hello\").to_owned();\n+        assert_eq!(from_bytes_owned(xs), ~\"hello\");\n+\n+        let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\").to_owned();\n+        assert_eq!(from_bytes_owned(xs), ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+    }\n+\n+    #[test]\n+    fn test_str_from_bytes_owned_opt() {\n+        let xs = bytes!(\"hello\").to_owned();\n+        assert_eq!(from_bytes_owned_opt(xs), Some(~\"hello\"));\n+\n+        let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\").to_owned();\n+        assert_eq!(from_bytes_owned_opt(xs), Some(~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n+\n+        let xs = bytes!(\"hello\", 0xff).to_owned();\n+        assert_eq!(from_bytes_owned_opt(xs), None);\n+    }\n }\n \n #[cfg(test)]"}]}