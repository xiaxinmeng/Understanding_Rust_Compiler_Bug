{"sha": "961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2MWJhOGY5ZWZiYjUxZDgwZTdlNzNhNjA5ZjY1ODdjMGZmYTA2MjM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-16T15:58:39Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-18T07:48:56Z"}, "message": "syntax: Factor out common fields from `SyntaxExtension` variants", "tree": {"sha": "3864832e7a6bbf638639d0d0233f6c816548ec66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3864832e7a6bbf638639d0d0233f6c816548ec66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "html_url": "https://github.com/rust-lang/rust/commit/961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "704ab2ba10c4d878f879047cdac94a61751ce943", "url": "https://api.github.com/repos/rust-lang/rust/commits/704ab2ba10c4d878f879047cdac94a61751ce943", "html_url": "https://github.com/rust-lang/rust/commit/704ab2ba10c4d878f879047cdac94a61751ce943"}], "stats": {"total": 618, "additions": 269, "deletions": 349}, "files": [{"sha": "0e38e2865d89372c53e6489dda43924efe03727d", "filename": "src/doc/unstable-book/src/language-features/plugin.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "raw_url": "https://github.com/rust-lang/rust/raw/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md?ref=961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "patch": "@@ -132,7 +132,7 @@ The advantages over a simple `fn(&str) -> u32` are:\n In addition to procedural macros, you can define new\n [`derive`](../../reference/attributes/derive.md)-like attributes and other kinds\n of extensions.  See `Registry::register_syntax_extension` and the\n-`SyntaxExtension` enum.  For a more involved macro example, see\n+`SyntaxExtension` struct.  For a more involved macro example, see\n [`regex_macros`](https://github.com/rust-lang/regex/blob/master/regex_macros/src/lib.rs).\n \n "}, {"sha": "ecc165ca5ea9fe1b4fcbe485812e0b690813a776", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "patch": "@@ -91,7 +91,7 @@ impl MutVisitor for ExpandAllocatorDirectives<'_> {\n             call_site: item.span, // use the call site of the static\n             def_site: None,\n             format: MacroAttribute(Symbol::intern(name)),\n-            allow_internal_unstable: Some(vec![sym::rustc_attrs].into()),\n+            allow_internal_unstable: Some([sym::rustc_attrs][..].into()),\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n             edition: self.sess.edition,"}, {"sha": "d3d00fa4adcfe0be332716564c268a05c9303714", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "patch": "@@ -26,7 +26,7 @@ use std::{cmp, fs};\n \n use syntax::ast;\n use syntax::attr;\n-use syntax::ext::base::SyntaxExtension;\n+use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use syntax::symbol::{Symbol, sym};\n use syntax::visit;\n use syntax::{span_err, span_fatal};\n@@ -611,33 +611,31 @@ impl<'a> CrateLoader<'a> {\n         };\n \n         let extensions = decls.iter().map(|&decl| {\n-            match decl {\n+            let (name, kind, helper_attrs) = match decl {\n                 ProcMacro::CustomDerive { trait_name, attributes, client } => {\n-                    let attrs = attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n-                    (trait_name, SyntaxExtension::Derive(\n-                        Box::new(ProcMacroDerive {\n-                            client,\n-                            attrs: attrs.clone(),\n-                        }),\n-                        attrs,\n-                        root.edition,\n-                    ))\n+                    let helper_attrs =\n+                        attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n+                    (\n+                        trait_name,\n+                        SyntaxExtensionKind::Derive(Box::new(ProcMacroDerive {\n+                            client, attrs: helper_attrs.clone()\n+                        })),\n+                        helper_attrs,\n+                    )\n                 }\n-                ProcMacro::Attr { name, client } => {\n-                    (name, SyntaxExtension::Attr(\n-                        Box::new(AttrProcMacro { client }),\n-                        root.edition,\n-                    ))\n-                }\n-                ProcMacro::Bang { name, client } => {\n-                    (name, SyntaxExtension::Bang {\n-                        expander: Box::new(BangProcMacro { client }),\n-                        allow_internal_unstable: None,\n-                        edition: root.edition,\n-                    })\n-                }\n-            }\n-        }).map(|(name, ext)| (Symbol::intern(name), Lrc::new(ext))).collect();\n+                ProcMacro::Attr { name, client } => (\n+                    name, SyntaxExtensionKind::Attr(Box::new(AttrProcMacro { client })), Vec::new()\n+                ),\n+                ProcMacro::Bang { name, client } => (\n+                    name, SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client })), Vec::new()\n+                )\n+            };\n+\n+            (Symbol::intern(name), Lrc::new(SyntaxExtension {\n+                helper_attrs,\n+                ..SyntaxExtension::default(kind, root.edition)\n+            }))\n+        }).collect();\n \n         // Intentionally leak the dynamic library. We can't ever unload it\n         // since the library can make things that will live arbitrarily long."}, {"sha": "04a9c4e9a1a11c1083f8d50778965b80c65f6521", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "patch": "@@ -30,9 +30,11 @@ use syntax::ast;\n use syntax::attr;\n use syntax::source_map;\n use syntax::edition::Edition;\n+use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use syntax::parse::source_file_to_stream;\n use syntax::parse::parser::emit_unclosed_delims;\n use syntax::symbol::{Symbol, sym};\n+use syntax_ext::proc_macro_impl::BangProcMacro;\n use syntax_pos::{Span, NO_EXPANSION, FileName};\n use rustc_data_structures::bit_set::BitSet;\n \n@@ -427,14 +429,11 @@ impl cstore::CStore {\n         if let Some(ref proc_macros) = data.proc_macros {\n             return LoadedMacro::ProcMacro(proc_macros[id.index.to_proc_macro_index()].1.clone());\n         } else if data.name == sym::proc_macro && data.item_name(id.index) == sym::quote {\n-            use syntax::ext::base::SyntaxExtension;\n-            use syntax_ext::proc_macro_impl::BangProcMacro;\n-\n             let client = proc_macro::bridge::client::Client::expand1(proc_macro::quote);\n-            let ext = SyntaxExtension::Bang {\n-                expander: Box::new(BangProcMacro { client }),\n-                allow_internal_unstable: Some(vec![sym::proc_macro_def_site].into()),\n-                edition: data.root.edition,\n+            let kind = SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client }));\n+            let ext = SyntaxExtension {\n+                allow_internal_unstable: Some([sym::proc_macro_def_site][..].into()),\n+                ..SyntaxExtension::default(kind, data.root.edition)\n             };\n             return LoadedMacro::ProcMacro(Lrc::new(ext));\n         }"}, {"sha": "a776966bda489aeccff1a9dc9ac3f1ec4d145620", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "patch": "@@ -511,8 +511,9 @@ impl<'a, 'tcx> CrateMetadata {\n         if !self.is_proc_macro(index) {\n             self.entry(index).kind.def_kind()\n         } else {\n-            let kind = self.proc_macros.as_ref().unwrap()[index.to_proc_macro_index()].1.kind();\n-            Some(DefKind::Macro(kind))\n+            Some(DefKind::Macro(\n+                self.proc_macros.as_ref().unwrap()[index.to_proc_macro_index()].1.macro_kind()\n+            ))\n         }\n     }\n \n@@ -739,7 +740,7 @@ impl<'a, 'tcx> CrateMetadata {\n             if id == CRATE_DEF_INDEX {\n                 for (id, &(name, ref ext)) in proc_macros.iter().enumerate() {\n                     let res = Res::Def(\n-                        DefKind::Macro(ext.kind()),\n+                        DefKind::Macro(ext.macro_kind()),\n                         self.local_def_id(DefIndex::from_proc_macro_index(id)),\n                     );\n                     let ident = Ident::with_empty_ctxt(name);"}, {"sha": "16d484e2a98f2e699edc0078c41c61bdd1972544", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "patch": "@@ -4,9 +4,8 @@ use rustc::lint::{EarlyLintPassObject, LateLintPassObject, LintId, Lint};\n use rustc::session::Session;\n use rustc::util::nodemap::FxHashMap;\n \n-use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension};\n+use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind, NamedSyntaxExtension};\n use syntax::ext::base::MacroExpanderFn;\n-use syntax::ext::hygiene::Transparency;\n use syntax::symbol::{Symbol, sym};\n use syntax::ast;\n use syntax::feature_gate::AttributeType;\n@@ -89,28 +88,21 @@ impl<'a> Registry<'a> {\n         if name == sym::macro_rules {\n             panic!(\"user-defined macros may not be named `macro_rules`\");\n         }\n-        if let SyntaxExtension::LegacyBang { def_info: ref mut def_info @ None, .. } = extension {\n-            *def_info = Some((ast::CRATE_NODE_ID, self.krate_span));\n+        if extension.def_info.is_none() {\n+            extension.def_info = Some((ast::CRATE_NODE_ID, self.krate_span));\n         }\n         self.syntax_exts.push((name, extension));\n     }\n \n     /// Register a macro of the usual kind.\n     ///\n     /// This is a convenience wrapper for `register_syntax_extension`.\n-    /// It builds for you a `SyntaxExtension::LegacyBang` that calls `expander`,\n+    /// It builds for you a `SyntaxExtensionKind::LegacyBang` that calls `expander`,\n     /// and also takes care of interning the macro's name.\n     pub fn register_macro(&mut self, name: &str, expander: MacroExpanderFn) {\n-        self.register_syntax_extension(Symbol::intern(name), SyntaxExtension::LegacyBang {\n-            expander: Box::new(expander),\n-            def_info: None,\n-            transparency: Transparency::SemiTransparent,\n-            allow_internal_unstable: None,\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            unstable_feature: None,\n-            edition: self.sess.edition(),\n-        });\n+        let kind = SyntaxExtensionKind::LegacyBang(Box::new(expander));\n+        let ext = SyntaxExtension::default(kind, self.sess.edition());\n+        self.register_syntax_extension(Symbol::intern(name), ext);\n     }\n \n     /// Register a compiler lint pass."}, {"sha": "bb4edf355f8b5e0347a1999fd8a150db1c88f790", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "patch": "@@ -29,7 +29,7 @@ use syntax::attr;\n \n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind, NodeId};\n use syntax::ast::{MetaItemKind, StmtKind, TraitItem, TraitItemKind, Variant};\n-use syntax::ext::base::{MacroKind, SyntaxExtension};\n+use syntax::ext::base::{MacroKind, SyntaxExtension, SyntaxExtensionKind};\n use syntax::ext::base::Determinacy::Undetermined;\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n@@ -772,9 +772,12 @@ impl<'a> Resolver<'a> {\n     pub fn get_macro(&mut self, res: Res) -> Lrc<SyntaxExtension> {\n         let def_id = match res {\n             Res::Def(DefKind::Macro(..), def_id) => def_id,\n-            Res::NonMacroAttr(attr_kind) => return Lrc::new(SyntaxExtension::NonMacroAttr {\n-                mark_used: attr_kind == NonMacroAttrKind::Tool,\n-            }),\n+            Res::NonMacroAttr(attr_kind) => return Lrc::new(SyntaxExtension::default(\n+                SyntaxExtensionKind::NonMacroAttr {\n+                    mark_used: attr_kind == NonMacroAttrKind::Tool\n+                },\n+                self.session.edition(),\n+            )),\n             _ => panic!(\"expected `DefKind::Macro` or `Res::NonMacroAttr`\"),\n         };\n         if let Some(ext) = self.macro_map.get(&def_id) {"}, {"sha": "89e28330be7e3b7f6dcd7c5b1ba53356e4890428", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "patch": "@@ -15,7 +15,7 @@ use syntax::ast::{self, Ident};\n use syntax::attr;\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Determinacy};\n-use syntax::ext::base::{MacroKind, SyntaxExtension};\n+use syntax::ext::base::{MacroKind, SyntaxExtension, SyntaxExtensionKind};\n use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n@@ -174,7 +174,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             krate: CrateNum::BuiltinMacros,\n             index: DefIndex::from(self.macro_map.len()),\n         };\n-        let kind = ext.kind();\n+        let kind = ext.macro_kind();\n         self.macro_map.insert(def_id, ext);\n         let binding = self.arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Res(Res::Def(DefKind::Macro(kind), def_id), false),\n@@ -211,7 +211,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n             Ok((res, ext)) => (res, ext),\n             Err(Determinacy::Determined) if kind == MacroKind::Attr => {\n                 // Replace unresolved attributes with used inert attributes for better recovery.\n-                return Ok(Some(Lrc::new(SyntaxExtension::NonMacroAttr { mark_used: true })));\n+                let kind = SyntaxExtensionKind::NonMacroAttr { mark_used: true };\n+                return Ok(Some(Lrc::new(SyntaxExtension::default(kind, self.session.edition()))));\n             }\n             Err(determinacy) => return Err(determinacy),\n         };\n@@ -226,7 +227,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 self.macro_def_scope(invoc.expansion_data.mark).normal_ancestor_id;\n             self.definitions.add_parent_module_of_macro_def(invoc.expansion_data.mark,\n                                                             normal_module_def_id);\n-            invoc.expansion_data.mark.set_default_transparency(ext.default_transparency());\n+            invoc.expansion_data.mark.set_default_transparency(ext.default_transparency);\n         }\n \n         Ok(Some(ext))\n@@ -241,11 +242,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn check_unused_macros(&self) {\n         for did in self.unused_macros.iter() {\n-            let id_span = match *self.macro_map[did] {\n-                SyntaxExtension::LegacyBang { def_info, .. } => def_info,\n-                _ => None,\n-            };\n-            if let Some((id, span)) = id_span {\n+            if let Some((id, span)) = self.macro_map[did].def_info {\n                 let lint = lint::builtin::UNUSED_MACROS;\n                 let msg = \"unused macro definition\";\n                 self.session.buffer_lint(lint, id, span, msg);\n@@ -585,17 +582,12 @@ impl<'a> Resolver<'a> {\n                         let parent_scope = ParentScope { derives: Vec::new(), ..*parent_scope };\n                         match self.resolve_macro_to_res(derive, MacroKind::Derive,\n                                                         &parent_scope, true, force) {\n-                            Ok((_, ext)) => {\n-                                if let SyntaxExtension::Derive(_, helpers, _) = &*ext {\n-                                    if helpers.contains(&ident.name) {\n-                                        let binding =\n-                                            (Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n-                                            ty::Visibility::Public, derive.span, Mark::root())\n-                                            .to_name_binding(self.arenas);\n-                                        result = Ok((binding, Flags::empty()));\n-                                        break;\n-                                    }\n-                                }\n+                            Ok((_, ext)) => if ext.helper_attrs.contains(&ident.name) {\n+                                let binding = (Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n+                                               ty::Visibility::Public, derive.span, Mark::root())\n+                                               .to_name_binding(self.arenas);\n+                                result = Ok((binding, Flags::empty()));\n+                                break;\n                             }\n                             Err(Determinacy::Determined) => {}\n                             Err(Determinacy::Undetermined) =>"}, {"sha": "9259b3b5d3abb1b1ed91505ee9590550fac3616a", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "patch": "@@ -3,7 +3,7 @@\n use std::iter::once;\n \n use syntax::ast;\n-use syntax::ext::base::{MacroKind, SyntaxExtension};\n+use syntax::ext::base::MacroKind;\n use syntax::symbol::sym;\n use syntax_pos::Span;\n \n@@ -470,18 +470,12 @@ fn build_macro(cx: &DocContext<'_>, did: DefId, name: ast::Name) -> clean::ItemE\n             })\n         }\n         LoadedMacro::ProcMacro(ext) => {\n-            let helpers = match &*ext {\n-                &SyntaxExtension::Derive(_, ref syms, ..) => { syms.clean(cx) }\n-                _ => Vec::new(),\n-            };\n-\n             clean::ProcMacroItem(clean::ProcMacro {\n-                kind: ext.kind(),\n-                helpers,\n+                kind: ext.macro_kind(),\n+                helpers: ext.helper_attrs.clean(cx),\n             })\n         }\n     }\n-\n }\n \n /// A trait's generics clause actually contains all of the predicates for all of"}, {"sha": "68b96a408294b9429aff7b525d47d575ef6355f5", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "patch": "@@ -423,7 +423,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n \n /// Resolves a string as a macro.\n fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n-    use syntax::ext::base::{MacroKind, SyntaxExtension};\n+    use syntax::ext::base::{MacroKind, SyntaxExtensionKind};\n     let segment = ast::PathSegment::from_ident(Ident::from_str(path_str));\n     let path = ast::Path { segments: vec![segment], span: DUMMY_SP };\n     cx.enter_resolver(|resolver| {\n@@ -433,7 +433,7 @@ fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n             if let Res::Def(DefKind::Macro(MacroKind::ProcMacroStub), _) = res {\n                 // skip proc-macro stubs, they'll cause `get_macro` to crash\n             } else {\n-                if let SyntaxExtension::LegacyBang { .. } = *resolver.get_macro(res) {\n+                if let SyntaxExtensionKind::LegacyBang(..) = resolver.get_macro(res).kind {\n                     return Some(res.map_id(|_| panic!(\"unexpected id\")));\n                 }\n             }"}, {"sha": "04cef0bba24bf537eb8b1e771f6452dc88621b00", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 87, "deletions": 61, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "patch": "@@ -15,6 +15,7 @@ use crate::tokenstream::{self, TokenStream};\n use errors::{DiagnosticBuilder, DiagnosticId};\n use smallvec::{smallvec, SmallVec};\n use syntax_pos::{Span, MultiSpan, DUMMY_SP};\n+use syntax_pos::hygiene::{ExpnInfo, ExpnFormat};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{self, Lrc};\n@@ -548,46 +549,26 @@ impl MacroKind {\n     }\n }\n \n-/// An enum representing the different kinds of syntax extensions.\n-pub enum SyntaxExtension {\n+/// A syntax extension kind.\n+pub enum SyntaxExtensionKind {\n     /// A token-based function-like macro.\n-    Bang {\n+    Bang(\n         /// An expander with signature TokenStream -> TokenStream.\n-        expander: Box<dyn ProcMacro + sync::Sync + sync::Send>,\n-        /// Whitelist of unstable features that are treated as stable inside this macro.\n-        allow_internal_unstable: Option<Lrc<[Symbol]>>,\n-        /// Edition of the crate in which this macro is defined.\n-        edition: Edition,\n-    },\n+        Box<dyn ProcMacro + sync::Sync + sync::Send>,\n+    ),\n \n     /// An AST-based function-like macro.\n-    LegacyBang {\n+    LegacyBang(\n         /// An expander with signature TokenStream -> AST.\n-        expander: Box<dyn TTMacroExpander + sync::Sync + sync::Send>,\n-        /// Some info about the macro's definition point.\n-        def_info: Option<(ast::NodeId, Span)>,\n-        /// Hygienic properties of identifiers produced by this macro.\n-        transparency: Transparency,\n-        /// Whitelist of unstable features that are treated as stable inside this macro.\n-        allow_internal_unstable: Option<Lrc<[Symbol]>>,\n-        /// Suppresses the `unsafe_code` lint for code produced by this macro.\n-        allow_internal_unsafe: bool,\n-        /// Enables the macro helper hack (`ident!(...)` -> `$crate::ident!(...)`) for this macro.\n-        local_inner_macros: bool,\n-        /// The macro's feature name and tracking issue number if it is unstable.\n-        unstable_feature: Option<(Symbol, u32)>,\n-        /// Edition of the crate in which this macro is defined.\n-        edition: Edition,\n-    },\n+        Box<dyn TTMacroExpander + sync::Sync + sync::Send>,\n+    ),\n \n     /// A token-based attribute macro.\n     Attr(\n         /// An expander with signature (TokenStream, TokenStream) -> TokenStream.\n         /// The first TokenSteam is the attribute itself, the second is the annotated item.\n         /// The produced TokenSteam replaces the input TokenSteam.\n         Box<dyn AttrProcMacro + sync::Sync + sync::Send>,\n-        /// Edition of the crate in which this macro is defined.\n-        Edition,\n     ),\n \n     /// An AST-based attribute macro.\n@@ -599,7 +580,8 @@ pub enum SyntaxExtension {\n     ),\n \n     /// A trivial attribute \"macro\" that does nothing,\n-    /// only keeps the attribute and marks it as known.\n+    /// only keeps the attribute and marks it as inert,\n+    /// thus making it ineligible for further expansion.\n     NonMacroAttr {\n         /// Suppresses the `unused_attributes` lint for this attribute.\n         mark_used: bool,\n@@ -610,10 +592,6 @@ pub enum SyntaxExtension {\n         /// An expander with signature TokenStream -> TokenStream (not yet).\n         /// The produced TokenSteam is appended to the input TokenSteam.\n         Box<dyn MultiItemModifier + sync::Sync + sync::Send>,\n-        /// Names of helper attributes registered by this macro.\n-        Vec<Symbol>,\n-        /// Edition of the crate in which this macro is defined.\n-        Edition,\n     ),\n \n     /// An AST-based derive macro.\n@@ -624,42 +602,90 @@ pub enum SyntaxExtension {\n     ),\n }\n \n+/// A struct representing a macro definition in \"lowered\" form ready for expansion.\n+pub struct SyntaxExtension {\n+    /// A syntax extension kind.\n+    pub kind: SyntaxExtensionKind,\n+    /// Some info about the macro's definition point.\n+    pub def_info: Option<(ast::NodeId, Span)>,\n+    /// Hygienic properties of spans produced by this macro by default.\n+    pub default_transparency: Transparency,\n+    /// Whitelist of unstable features that are treated as stable inside this macro.\n+    pub allow_internal_unstable: Option<Lrc<[Symbol]>>,\n+    /// Suppresses the `unsafe_code` lint for code produced by this macro.\n+    pub allow_internal_unsafe: bool,\n+    /// Enables the macro helper hack (`ident!(...)` -> `$crate::ident!(...)`) for this macro.\n+    pub local_inner_macros: bool,\n+    /// The macro's feature name and tracking issue number if it is unstable.\n+    pub unstable_feature: Option<(Symbol, u32)>,\n+    /// Names of helper attributes registered by this macro.\n+    pub helper_attrs: Vec<Symbol>,\n+    /// Edition of the crate in which this macro is defined.\n+    pub edition: Edition,\n+}\n+\n+impl SyntaxExtensionKind {\n+    /// When a syntax extension is constructed,\n+    /// its transparency can often be inferred from its kind.\n+    fn default_transparency(&self) -> Transparency {\n+        match self {\n+            SyntaxExtensionKind::Bang(..) |\n+            SyntaxExtensionKind::Attr(..) |\n+            SyntaxExtensionKind::Derive(..) |\n+            SyntaxExtensionKind::NonMacroAttr { .. } => Transparency::Opaque,\n+            SyntaxExtensionKind::LegacyBang(..) |\n+            SyntaxExtensionKind::LegacyAttr(..) |\n+            SyntaxExtensionKind::LegacyDerive(..) => Transparency::SemiTransparent,\n+        }\n+    }\n+}\n+\n impl SyntaxExtension {\n     /// Returns which kind of macro calls this syntax extension.\n-    pub fn kind(&self) -> MacroKind {\n-        match *self {\n-            SyntaxExtension::Bang { .. } |\n-            SyntaxExtension::LegacyBang { .. } => MacroKind::Bang,\n-            SyntaxExtension::Attr(..) |\n-            SyntaxExtension::LegacyAttr(..) |\n-            SyntaxExtension::NonMacroAttr { .. } => MacroKind::Attr,\n-            SyntaxExtension::Derive(..) |\n-            SyntaxExtension::LegacyDerive(..) => MacroKind::Derive,\n+    pub fn macro_kind(&self) -> MacroKind {\n+        match self.kind {\n+            SyntaxExtensionKind::Bang(..) |\n+            SyntaxExtensionKind::LegacyBang(..) => MacroKind::Bang,\n+            SyntaxExtensionKind::Attr(..) |\n+            SyntaxExtensionKind::LegacyAttr(..) |\n+            SyntaxExtensionKind::NonMacroAttr { .. } => MacroKind::Attr,\n+            SyntaxExtensionKind::Derive(..) |\n+            SyntaxExtensionKind::LegacyDerive(..) => MacroKind::Derive,\n         }\n     }\n \n-    pub fn default_transparency(&self) -> Transparency {\n-        match *self {\n-            SyntaxExtension::LegacyBang { transparency, .. } => transparency,\n-            SyntaxExtension::Bang { .. } |\n-            SyntaxExtension::Attr(..) |\n-            SyntaxExtension::Derive(..) |\n-            SyntaxExtension::NonMacroAttr { .. } => Transparency::Opaque,\n-            SyntaxExtension::LegacyAttr(..) |\n-            SyntaxExtension::LegacyDerive(..) => Transparency::SemiTransparent,\n+    /// Constructs a syntax extension with default properties.\n+    pub fn default(kind: SyntaxExtensionKind, edition: Edition) -> SyntaxExtension {\n+        SyntaxExtension {\n+            def_info: None,\n+            default_transparency: kind.default_transparency(),\n+            allow_internal_unstable: None,\n+            allow_internal_unsafe: false,\n+            local_inner_macros: false,\n+            unstable_feature: None,\n+            helper_attrs: Vec::new(),\n+            edition,\n+            kind,\n         }\n     }\n \n-    pub fn edition(&self, default_edition: Edition) -> Edition {\n-        match *self {\n-            SyntaxExtension::Bang { edition, .. } |\n-            SyntaxExtension::LegacyBang { edition, .. } |\n-            SyntaxExtension::Attr(.., edition) |\n-            SyntaxExtension::Derive(.., edition) => edition,\n-            // Unstable legacy stuff\n-            SyntaxExtension::NonMacroAttr { .. } |\n-            SyntaxExtension::LegacyAttr(..) |\n-            SyntaxExtension::LegacyDerive(..) => default_edition,\n+    fn expn_format(&self, symbol: Symbol) -> ExpnFormat {\n+        match self.kind {\n+            SyntaxExtensionKind::Bang(..) |\n+            SyntaxExtensionKind::LegacyBang(..) => ExpnFormat::MacroBang(symbol),\n+            _ => ExpnFormat::MacroAttribute(symbol),\n+        }\n+    }\n+\n+    crate fn expn_info(&self, call_site: Span, format: &str) -> ExpnInfo {\n+        ExpnInfo {\n+            call_site,\n+            def_site: self.def_info.map(|(_, span)| span),\n+            format: self.expn_format(Symbol::intern(format)),\n+            allow_internal_unstable: self.allow_internal_unstable.clone(),\n+            allow_internal_unsafe: self.allow_internal_unsafe,\n+            local_inner_macros: self.local_inner_macros,\n+            edition: self.edition,\n         }\n     }\n }"}, {"sha": "33620cb80f940cabbd9def26d3e98fb2560db99f", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "patch": "@@ -64,7 +64,7 @@ pub fn add_derived_markers<T>(cx: &mut ExtCtxt<'_>, span: Span, traits: &[ast::P\n         call_site: span,\n         def_site: None,\n         format: ExpnFormat::MacroAttribute(Symbol::intern(&pretty_name)),\n-        allow_internal_unstable: Some(vec![sym::rustc_attrs, sym::structural_match].into()),\n+        allow_internal_unstable: Some([sym::rustc_attrs, sym::structural_match][..].into()),\n         allow_internal_unsafe: false,\n         local_inner_macros: false,\n         edition: cx.parse_sess.edition,"}, {"sha": "4e759c5e528654a1b3bfa86f2bd71cd9ba89078f", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 47, "deletions": 131, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "patch": "@@ -1,7 +1,7 @@\n use crate::ast::{self, Block, Ident, LitKind, NodeId, PatKind, Path};\n use crate::ast::{MacStmtStyle, StmtKind, ItemKind};\n use crate::attr::{self, HasAttrs};\n-use crate::source_map::{ExpnInfo, MacroBang, MacroAttribute, dummy_spanned, respan};\n+use crate::source_map::{dummy_spanned, respan};\n use crate::config::StripUnconfigured;\n use crate::ext::base::*;\n use crate::ext::derive::{add_derived_markers, collect_derives};\n@@ -22,7 +22,6 @@ use crate::util::map_in_place::MapInPlace;\n use errors::{Applicability, FatalError};\n use smallvec::{smallvec, SmallVec};\n use syntax_pos::{Span, DUMMY_SP, FileName};\n-use syntax_pos::hygiene::ExpnFormat;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n@@ -189,10 +188,10 @@ impl AstFragmentKind {\n     }\n }\n \n-fn macro_bang_format(path: &ast::Path) -> ExpnFormat {\n-    // We don't want to format a path using pretty-printing,\n-    // `format!(\"{}\", path)`, because that tries to insert\n-    // line-breaks and is slow.\n+// We don't want to format a path using pretty-printing,\n+// `format!(\"{}\", path)`, because that tries to insert\n+// line-breaks and is slow.\n+fn fast_print_path(path: &ast::Path) -> String {\n     let mut path_str = String::with_capacity(64);\n     for (i, segment) in path.segments.iter().enumerate() {\n         if i != 0 {\n@@ -202,8 +201,7 @@ fn macro_bang_format(path: &ast::Path) -> ExpnFormat {\n             path_str.push_str(&segment.ident.as_str())\n         }\n     }\n-\n-    MacroBang(Symbol::intern(&path_str))\n+    path_str\n }\n \n pub struct Invocation {\n@@ -388,8 +386,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         derives.push(mark);\n                         let item = match self.cx.resolver.resolve_macro_path(\n                                 path, MacroKind::Derive, Mark::root(), Vec::new(), false) {\n-                            Ok(ext) => match *ext {\n-                                SyntaxExtension::LegacyDerive(..) => item_with_markers.clone(),\n+                            Ok(ext) => match ext.kind {\n+                                SyntaxExtensionKind::LegacyDerive(..) => item_with_markers.clone(),\n                                 _ => item.clone(),\n                             },\n                             _ => item.clone(),\n@@ -509,7 +507,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     fn expand_invoc(&mut self, invoc: Invocation, ext: &SyntaxExtension) -> Option<AstFragment> {\n         if invoc.fragment_kind == AstFragmentKind::ForeignItems &&\n            !self.cx.ecfg.macros_in_extern_enabled() {\n-            if let SyntaxExtension::NonMacroAttr { .. } = *ext {} else {\n+            if let SyntaxExtensionKind::NonMacroAttr { .. } = ext.kind {} else {\n                 emit_feature_err(&self.cx.parse_sess, sym::macros_in_extern,\n                                  invoc.span(), GateIssue::Language,\n                                  \"macro invocations in `extern {}` blocks are experimental\");\n@@ -548,34 +546,25 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             _ => unreachable!(),\n         };\n \n-        if let SyntaxExtension::NonMacroAttr { mark_used: false } = *ext {} else {\n-            // Macro attrs are always used when expanded,\n-            // non-macro attrs are considered used when the field says so.\n-            attr::mark_used(&attr);\n-        }\n-        invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n-            call_site: attr.span,\n-            def_site: None,\n-            format: MacroAttribute(Symbol::intern(&attr.path.to_string())),\n-            allow_internal_unstable: None,\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            edition: ext.edition(self.cx.parse_sess.edition),\n-        });\n+        let expn_info = ext.expn_info(attr.span, &fast_print_path(&attr.path));\n+        invoc.expansion_data.mark.set_expn_info(expn_info);\n \n-        match *ext {\n-            SyntaxExtension::NonMacroAttr { .. } => {\n+        match &ext.kind {\n+            SyntaxExtensionKind::NonMacroAttr { mark_used } => {\n                 attr::mark_known(&attr);\n+                if *mark_used {\n+                    attr::mark_used(&attr);\n+                }\n                 item.visit_attrs(|attrs| attrs.push(attr));\n                 Some(invoc.fragment_kind.expect_from_annotatables(iter::once(item)))\n             }\n-            SyntaxExtension::LegacyAttr(ref mac) => {\n+            SyntaxExtensionKind::LegacyAttr(expander) => {\n                 let meta = attr.parse_meta(self.cx.parse_sess)\n                                .map_err(|mut e| { e.emit(); }).ok()?;\n-                let item = mac.expand(self.cx, attr.span, &meta, item);\n+                let item = expander.expand(self.cx, attr.span, &meta, item);\n                 Some(invoc.fragment_kind.expect_from_annotatables(item))\n             }\n-            SyntaxExtension::Attr(ref mac, ..) => {\n+            SyntaxExtensionKind::Attr(expander) => {\n                 self.gate_proc_macro_attr_item(attr.span, &item);\n                 let item_tok = TokenTree::token(token::Interpolated(Lrc::new(match item {\n                     Annotatable::Item(item) => token::NtItem(item),\n@@ -586,13 +575,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     Annotatable::Expr(expr) => token::NtExpr(expr),\n                 })), DUMMY_SP).into();\n                 let input = self.extract_proc_macro_attr_input(attr.tokens, attr.span);\n-                let tok_result = mac.expand(self.cx, attr.span, input, item_tok);\n+                let tok_result = expander.expand(self.cx, attr.span, input, item_tok);\n                 let res = self.parse_ast_fragment(tok_result, invoc.fragment_kind,\n                                                   &attr.path, attr.span);\n                 self.gate_proc_macro_expansion(attr.span, &res);\n                 res\n             }\n-            SyntaxExtension::Derive(..) | SyntaxExtension::LegacyDerive(..) => {\n+            SyntaxExtensionKind::Derive(..) | SyntaxExtensionKind::LegacyDerive(..) => {\n                 self.cx.span_err(attr.span, &format!(\"`{}` is a derive macro\", attr.path));\n                 self.cx.trace_macros_diag();\n                 invoc.fragment_kind.dummy(attr.span)\n@@ -701,21 +690,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let path = &mac.node.path;\n \n         let ident = ident.unwrap_or_else(|| Ident::invalid());\n-        let validate_and_set_expn_info = |this: &mut Self, // arg instead of capture\n-                                          def_site_span: Option<Span>,\n-                                          allow_internal_unstable,\n-                                          allow_internal_unsafe,\n-                                          local_inner_macros,\n-                                          // can't infer this type\n-                                          unstable_feature: Option<(Symbol, u32)>,\n-                                          edition| {\n-\n+        let validate_and_set_expn_info = |this: &mut Self| {\n             // feature-gate the macro invocation\n-            if let Some((feature, issue)) = unstable_feature {\n+            if let Some((feature, issue)) = ext.unstable_feature {\n                 let crate_span = this.cx.current_expansion.crate_span.unwrap();\n                 // don't stability-check macros in the same crate\n                 // (the only time this is null is for syntax extensions registered as macros)\n-                if def_site_span.map_or(false, |def_span| !crate_span.contains(def_span))\n+                if ext.def_info.map_or(false, |(_, def_span)| !crate_span.contains(def_span))\n                     && !span.allows_unstable(feature)\n                     && this.cx.ecfg.features.map_or(true, |feats| {\n                     // macro features will count as lib features\n@@ -734,62 +715,40 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 this.cx.trace_macros_diag();\n                 return Err(kind.dummy(span));\n             }\n-            mark.set_expn_info(ExpnInfo {\n-                call_site: span,\n-                def_site: def_site_span,\n-                format: macro_bang_format(path),\n-                allow_internal_unstable,\n-                allow_internal_unsafe,\n-                local_inner_macros,\n-                edition,\n-            });\n+            mark.set_expn_info(ext.expn_info(span, &fast_print_path(path)));\n             Ok(())\n         };\n \n-        let opt_expanded = match *ext {\n-            SyntaxExtension::LegacyBang {\n-                ref expander,\n-                def_info,\n-                ref allow_internal_unstable,\n-                allow_internal_unsafe,\n-                local_inner_macros,\n-                unstable_feature,\n-                edition,\n-                ..\n-            } => {\n-                if let Err(dummy_span) = validate_and_set_expn_info(self, def_info.map(|(_, s)| s),\n-                                                                    allow_internal_unstable.clone(),\n-                                                                    allow_internal_unsafe,\n-                                                                    local_inner_macros,\n-                                                                    unstable_feature,\n-                                                                    edition) {\n+        let opt_expanded = match &ext.kind {\n+            SyntaxExtensionKind::LegacyBang(expander) => {\n+                if let Err(dummy_span) = validate_and_set_expn_info(self) {\n                     dummy_span\n                 } else {\n                     kind.make_from(expander.expand(\n                         self.cx,\n                         span,\n                         mac.node.stream(),\n-                        def_info.map(|(_, s)| s),\n+                        ext.def_info.map(|(_, s)| s),\n                     ))\n                 }\n             }\n \n-            SyntaxExtension::Attr(..) |\n-            SyntaxExtension::LegacyAttr(..) |\n-            SyntaxExtension::NonMacroAttr { .. } => {\n+            SyntaxExtensionKind::Attr(..) |\n+            SyntaxExtensionKind::LegacyAttr(..) |\n+            SyntaxExtensionKind::NonMacroAttr { .. } => {\n                 self.cx.span_err(path.span,\n                                  &format!(\"`{}` can only be used in attributes\", path));\n                 self.cx.trace_macros_diag();\n                 kind.dummy(span)\n             }\n \n-            SyntaxExtension::Derive(..) | SyntaxExtension::LegacyDerive(..) => {\n+            SyntaxExtensionKind::Derive(..) | SyntaxExtensionKind::LegacyDerive(..) => {\n                 self.cx.span_err(path.span, &format!(\"`{}` is a derive macro\", path));\n                 self.cx.trace_macros_diag();\n                 kind.dummy(span)\n             }\n \n-            SyntaxExtension::Bang { ref expander, ref allow_internal_unstable, edition } => {\n+            SyntaxExtensionKind::Bang(expander) => {\n                 if ident.name != kw::Invalid {\n                     let msg =\n                         format!(\"macro {}! expects no ident argument, given '{}'\", path, ident);\n@@ -798,19 +757,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     kind.dummy(span)\n                 } else {\n                     self.gate_proc_macro_expansion_kind(span, kind);\n-                    invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n-                        call_site: span,\n-                        // FIXME procedural macros do not have proper span info\n-                        // yet, when they do, we should use it here.\n-                        def_site: None,\n-                        format: macro_bang_format(path),\n-                        // FIXME probably want to follow macro_rules macros here.\n-                        allow_internal_unstable: allow_internal_unstable.clone(),\n-                        allow_internal_unsafe: false,\n-                        local_inner_macros: false,\n-                        edition,\n-                    });\n-\n+                    let expn_info = ext.expn_info(span, &fast_print_path(path));\n+                    invoc.expansion_data.mark.set_expn_info(expn_info);\n                     let tok_result = expander.expand(self.cx, span, mac.node.stream());\n                     let result = self.parse_ast_fragment(tok_result, kind, path, span);\n                     self.gate_proc_macro_expansion(span, &result);\n@@ -867,55 +815,23 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             return None;\n         }\n \n-        let pretty_name = Symbol::intern(&format!(\"derive({})\", path));\n-        let span = path.span;\n-        let attr = ast::Attribute {\n-            path, span,\n-            tokens: TokenStream::empty(),\n-            // irrelevant:\n-            id: ast::AttrId(0), style: ast::AttrStyle::Outer, is_sugared_doc: false,\n-        };\n-\n-        let mut expn_info = ExpnInfo {\n-            call_site: span,\n-            def_site: None,\n-            format: MacroAttribute(pretty_name),\n-            allow_internal_unstable: None,\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            edition: ext.edition(self.cx.parse_sess.edition),\n-        };\n-\n-        match ext {\n-            SyntaxExtension::Derive(expander, ..) | SyntaxExtension::LegacyDerive(expander) => {\n-                let meta = match ext {\n-                    SyntaxExtension::Derive(..) => ast::MetaItem { // FIXME(jseyfried) avoid this\n-                        path: Path::from_ident(Ident::invalid()),\n-                        span: DUMMY_SP,\n-                        node: ast::MetaItemKind::Word,\n-                    },\n-                    _ => {\n-                        expn_info.allow_internal_unstable = Some(vec![\n-                            sym::rustc_attrs,\n-                            Symbol::intern(\"derive_clone_copy\"),\n-                            Symbol::intern(\"derive_eq\"),\n-                            // RustcDeserialize and RustcSerialize\n-                            Symbol::intern(\"libstd_sys_internals\"),\n-                        ].into());\n-                        attr.meta()?\n-                    }\n-                };\n-\n+        match &ext.kind {\n+            SyntaxExtensionKind::Derive(expander) |\n+            SyntaxExtensionKind::LegacyDerive(expander) => {\n+                let expn_info =\n+                    ext.expn_info(path.span, &format!(\"derive({})\", fast_print_path(&path)));\n                 invoc.expansion_data.mark.set_expn_info(expn_info);\n-                let span = span.with_ctxt(self.cx.backtrace());\n+\n+                let meta = ast::MetaItem { node: ast::MetaItemKind::Word, span: path.span, path };\n+                let span = meta.span.with_ctxt(self.cx.backtrace());\n                 let items = expander.expand(self.cx, span, &meta, item);\n                 Some(invoc.fragment_kind.expect_from_annotatables(items))\n             }\n             _ => {\n-                let msg = &format!(\"macro `{}` may not be used for derive attributes\", attr.path);\n-                self.cx.span_err(span, msg);\n+                let msg = &format!(\"macro `{}` may not be used for derive attributes\", path);\n+                self.cx.span_err(path.span, msg);\n                 self.cx.trace_macros_diag();\n-                invoc.fragment_kind.dummy(span)\n+                invoc.fragment_kind.dummy(path.span)\n             }\n         }\n     }"}, {"sha": "7f051c260ec822a88b50dea9e0293bb160e46ff0", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "patch": "@@ -1,6 +1,7 @@\n use crate::{ast, attr};\n use crate::edition::Edition;\n-use crate::ext::base::{DummyResult, ExtCtxt, MacResult, SyntaxExtension, TTMacroExpander};\n+use crate::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n+use crate::ext::base::{DummyResult, ExtCtxt, MacResult, TTMacroExpander};\n use crate::ext::expand::{AstFragment, AstFragmentKind};\n use crate::ext::hygiene::Transparency;\n use crate::ext::tt::macro_parser::{Success, Error, Failure};\n@@ -376,7 +377,7 @@ pub fn compile(\n         valid,\n     });\n \n-    let transparency = if attr::contains_name(&def.attrs, sym::rustc_transparent_macro) {\n+    let default_transparency = if attr::contains_name(&def.attrs, sym::rustc_transparent_macro) {\n         Transparency::Transparent\n     } else if body.legacy {\n         Transparency::SemiTransparent\n@@ -426,14 +427,15 @@ pub fn compile(\n         }\n     });\n \n-    SyntaxExtension::LegacyBang {\n-        expander,\n+    SyntaxExtension {\n+        kind: SyntaxExtensionKind::LegacyBang(expander),\n         def_info: Some((def.id, def.span)),\n-        transparency,\n+        default_transparency,\n         allow_internal_unstable,\n         allow_internal_unsafe,\n         local_inner_macros,\n         unstable_feature,\n+        helper_attrs: Vec::new(),\n         edition,\n     }\n }"}, {"sha": "9072ad7b30fdf0465a3c836053395410e4f5ff13", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "patch": "@@ -20,7 +20,7 @@ fn ignored_span(sp: Span, edition: Edition) -> Span {\n         call_site: DUMMY_SP,\n         def_site: None,\n         format: MacroAttribute(Symbol::intern(\"std_inject\")),\n-        allow_internal_unstable: Some(vec![sym::prelude_import].into()),\n+        allow_internal_unstable: Some([sym::prelude_import][..].into()),\n         allow_internal_unsafe: false,\n         local_inner_macros: false,\n         edition,"}, {"sha": "0e1b10c14f17e437bff8b3461e160dfd89fce298", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "patch": "@@ -284,7 +284,7 @@ fn generate_test_harness(sess: &ParseSess,\n         call_site: DUMMY_SP,\n         def_site: None,\n         format: MacroAttribute(sym::test_case),\n-        allow_internal_unstable: Some(vec![sym::main, sym::test, sym::rustc_attrs].into()),\n+        allow_internal_unstable: Some([sym::main, sym::test, sym::rustc_attrs][..].into()),\n         allow_internal_unsafe: false,\n         local_inner_macros: false,\n         edition: sess.edition,"}, {"sha": "e4a413dda09c6fad3d0db969f02587240c62c608", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "patch": "@@ -2,7 +2,9 @@\n \n use rustc_data_structures::sync::Lrc;\n use syntax::ast::{self, MetaItem};\n-use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension, Resolver, MultiItemModifier};\n+use syntax::edition::Edition;\n+use syntax::ext::base::{Annotatable, ExtCtxt, Resolver, MultiItemModifier};\n+use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use syntax::ext::build::AstBuilder;\n use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ptr::P;\n@@ -67,11 +69,24 @@ macro_rules! derive_traits {\n             }\n         }\n \n-        pub fn register_builtin_derives(resolver: &mut dyn Resolver) {\n+        pub fn register_builtin_derives(resolver: &mut dyn Resolver, edition: Edition) {\n+            let allow_internal_unstable = Some([\n+                sym::rustc_attrs,\n+                Symbol::intern(\"derive_clone_copy\"),\n+                Symbol::intern(\"derive_eq\"),\n+                Symbol::intern(\"libstd_sys_internals\"), // RustcDeserialize and RustcSerialize\n+            ][..].into());\n+\n             $(\n                 resolver.add_builtin(\n                     ast::Ident::with_empty_ctxt(Symbol::intern($name)),\n-                    Lrc::new(SyntaxExtension::LegacyDerive(Box::new(BuiltinDerive($func))))\n+                    Lrc::new(SyntaxExtension {\n+                        allow_internal_unstable: allow_internal_unstable.clone(),\n+                        ..SyntaxExtension::default(\n+                            SyntaxExtensionKind::LegacyDerive(Box::new(BuiltinDerive($func))),\n+                            edition,\n+                        )\n+                    }),\n                 );\n             )*\n         }"}, {"sha": "d29d93a8678fb2b9a16d915dc0d3b55f4cc6e84b", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 30, "deletions": 39, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "patch": "@@ -43,32 +43,31 @@ pub mod proc_macro_impl;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n \n-use syntax::ext::base::{MacroExpanderFn, NamedSyntaxExtension, SyntaxExtension};\n-use syntax::ext::hygiene::Transparency;\n+use syntax::ext::base::MacroExpanderFn;\n+use syntax::ext::base::{NamedSyntaxExtension, SyntaxExtension, SyntaxExtensionKind};\n use syntax::edition::Edition;\n use syntax::symbol::{sym, Symbol};\n \n pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n                          user_exts: Vec<NamedSyntaxExtension>,\n                          edition: Edition) {\n-    deriving::register_builtin_derives(resolver);\n+    deriving::register_builtin_derives(resolver, edition);\n \n     let mut register = |name, ext| {\n         resolver.add_builtin(ast::Ident::with_empty_ctxt(name), Lrc::new(ext));\n     };\n     macro_rules! register {\n         ($( $name:ident: $f:expr, )*) => { $(\n-            register(Symbol::intern(stringify!($name)),\n-                     SyntaxExtension::LegacyBang {\n-                        expander: Box::new($f as MacroExpanderFn),\n-                        def_info: None,\n-                        transparency: Transparency::SemiTransparent,\n-                        allow_internal_unstable: None,\n-                        allow_internal_unsafe: false,\n-                        local_inner_macros: false,\n-                        unstable_feature: None,\n-                        edition,\n-                    });\n+            register(Symbol::intern(stringify!($name)), SyntaxExtension::default(\n+                SyntaxExtensionKind::LegacyBang(Box::new($f as MacroExpanderFn)), edition\n+            ));\n+        )* }\n+    }\n+    macro_rules! register_attr {\n+        ($( $name:ident: $f:expr, )*) => { $(\n+            register(Symbol::intern(stringify!($name)), SyntaxExtension::default(\n+                SyntaxExtensionKind::LegacyAttr(Box::new($f)), edition\n+            ));\n         )* }\n     }\n \n@@ -97,33 +96,25 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n         assert: assert::expand_assert,\n     }\n \n-    register(sym::test_case, SyntaxExtension::LegacyAttr(Box::new(test_case::expand)));\n-    register(sym::test, SyntaxExtension::LegacyAttr(Box::new(test::expand_test)));\n-    register(sym::bench, SyntaxExtension::LegacyAttr(Box::new(test::expand_bench)));\n+    register_attr! {\n+        test_case: test_case::expand,\n+        test: test::expand_test,\n+        bench: test::expand_bench,\n+    }\n \n     // format_args uses `unstable` things internally.\n-    register(Symbol::intern(\"format_args\"),\n-             SyntaxExtension::LegacyBang {\n-                expander: Box::new(format::expand_format_args),\n-                def_info: None,\n-                transparency: Transparency::SemiTransparent,\n-                allow_internal_unstable: Some(vec![sym::fmt_internals].into()),\n-                allow_internal_unsafe: false,\n-                local_inner_macros: false,\n-                unstable_feature: None,\n-                edition,\n-            });\n-    register(sym::format_args_nl,\n-             SyntaxExtension::LegacyBang {\n-                 expander: Box::new(format::expand_format_args_nl),\n-                 def_info: None,\n-                 transparency: Transparency::SemiTransparent,\n-                 allow_internal_unstable: Some(vec![sym::fmt_internals].into()),\n-                 allow_internal_unsafe: false,\n-                 local_inner_macros: false,\n-                 unstable_feature: None,\n-                 edition,\n-             });\n+    register(Symbol::intern(\"format_args\"), SyntaxExtension {\n+        allow_internal_unstable: Some([sym::fmt_internals][..].into()),\n+        ..SyntaxExtension::default(\n+            SyntaxExtensionKind::LegacyBang(Box::new(format::expand_format_args)), edition\n+        )\n+    });\n+    register(sym::format_args_nl, SyntaxExtension {\n+        allow_internal_unstable: Some([sym::fmt_internals][..].into()),\n+        ..SyntaxExtension::default(\n+            SyntaxExtensionKind::LegacyBang(Box::new(format::expand_format_args_nl)), edition\n+        )\n+    });\n \n     for (name, ext) in user_exts {\n         register(name, ext);"}, {"sha": "cdef5c6a9f48b41608c8e5700e38b114e1e7da72", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "patch": "@@ -351,10 +351,9 @@ fn mk_decls(\n         call_site: DUMMY_SP,\n         def_site: None,\n         format: MacroAttribute(sym::proc_macro),\n-        allow_internal_unstable: Some(vec![\n-            sym::rustc_attrs,\n-            Symbol::intern(\"proc_macro_internals\"),\n-        ].into()),\n+        allow_internal_unstable: Some([\n+            sym::rustc_attrs, Symbol::intern(\"proc_macro_internals\")\n+        ][..].into()),\n         allow_internal_unsafe: false,\n         local_inner_macros: false,\n         edition: cx.parse_sess.edition,"}, {"sha": "a8c8456a3bcf8387255e674aebe5d29286dbf963", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "patch": "@@ -66,7 +66,7 @@ pub fn expand_test_or_bench(\n             call_site: DUMMY_SP,\n             def_site: None,\n             format: MacroAttribute(sym::test),\n-            allow_internal_unstable: Some(vec![sym::rustc_attrs, sym::test].into()),\n+            allow_internal_unstable: Some([sym::rustc_attrs, sym::test][..].into()),\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n             edition: cx.parse_sess.edition,"}, {"sha": "ce17cf2a6e789cbd0b006c5b2c54605efea5611a", "filename": "src/libsyntax_ext/test_case.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibsyntax_ext%2Ftest_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Flibsyntax_ext%2Ftest_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_case.rs?ref=961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "patch": "@@ -41,7 +41,7 @@ pub fn expand(\n             call_site: DUMMY_SP,\n             def_site: None,\n             format: MacroAttribute(sym::test_case),\n-            allow_internal_unstable: Some(vec![sym::test, sym::rustc_attrs].into()),\n+            allow_internal_unstable: Some([sym::test, sym::rustc_attrs][..].into()),\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n             edition: ecx.parse_sess.edition,"}, {"sha": "4cf8a4e33c52626bee51f84611cc645fb083d051", "filename": "src/test/run-pass-fulldeps/auxiliary/plugin-args.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba8f9efbb51d80e7e73a609f6587c0ffa0623/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin-args.rs?ref=961ba8f9efbb51d80e7e73a609f6587c0ffa0623", "patch": "@@ -11,8 +11,8 @@ extern crate rustc_plugin;\n use std::borrow::ToOwned;\n use syntax::ast;\n use syntax::ext::build::AstBuilder;\n-use syntax::ext::base::{SyntaxExtension, TTMacroExpander, ExtCtxt, MacResult, MacEager};\n-use syntax::ext::hygiene::Transparency;\n+use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n+use syntax::ext::base::{TTMacroExpander, ExtCtxt, MacResult, MacEager};\n use syntax::print::pprust;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n@@ -38,15 +38,7 @@ impl TTMacroExpander for Expander {\n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     let args = reg.args().to_owned();\n-    reg.register_syntax_extension(Symbol::intern(\"plugin_args\"),\n-        SyntaxExtension::LegacyBang {\n-            expander: Box::new(Expander { args: args, }),\n-            def_info: None,\n-            transparency: Transparency::SemiTransparent,\n-            allow_internal_unstable: None,\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            unstable_feature: None,\n-            edition: reg.sess.edition(),\n-        });\n+    reg.register_syntax_extension(Symbol::intern(\"plugin_args\"), SyntaxExtension::default(\n+        SyntaxExtensionKind::LegacyBang(Box::new(Expander { args })), reg.sess.edition()\n+    ));\n }"}]}