{"sha": "5dde29c947ec1e6b0a52c7f3ccb0771d2a7736f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkZGUyOWM5NDdlYzFlNmIwYTUyYzdmM2NjYjA3NzFkMmE3NzM2ZjQ=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-08T20:07:22Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-08T20:07:22Z"}, "message": "std: Fix tuple lexicographical order\n\nUse the definition, where R is <, <=, >=, or >\n\n    [x, ..xs] R [y, ..ys]  =  if x != y { x R y } else { xs R ys }\n\nPreviously, tuples would only implement < and derive the other\ncomparisons from it; this is incorrect. Included are several testcases\ninvolving NaN comparisons that are now correct.\n\nPreviously, tuples would consider an element equal if both a < b and\nb < a were false, this was also incorrect.", "tree": {"sha": "a909e87fc09de83c9400c38116a9a7e47c7c7d71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a909e87fc09de83c9400c38116a9a7e47c7c7d71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5dde29c947ec1e6b0a52c7f3ccb0771d2a7736f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5dde29c947ec1e6b0a52c7f3ccb0771d2a7736f4", "html_url": "https://github.com/rust-lang/rust/commit/5dde29c947ec1e6b0a52c7f3ccb0771d2a7736f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5dde29c947ec1e6b0a52c7f3ccb0771d2a7736f4/comments", "author": null, "committer": null, "parents": [{"sha": "86da55e85b1f1dd520111b52d1f76c61ea43b382", "url": "https://api.github.com/repos/rust-lang/rust/commits/86da55e85b1f1dd520111b52d1f76c61ea43b382", "html_url": "https://github.com/rust-lang/rust/commit/86da55e85b1f1dd520111b52d1f76c61ea43b382"}], "stats": {"total": 42, "additions": 28, "deletions": 14}, "files": [{"sha": "238b14ed554d589b709414eba1ec3d960e450bf8", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5dde29c947ec1e6b0a52c7f3ccb0771d2a7736f4/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dde29c947ec1e6b0a52c7f3ccb0771d2a7736f4/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=5dde29c947ec1e6b0a52c7f3ccb0771d2a7736f4", "patch": "@@ -197,17 +197,23 @@ macro_rules! tuple_impls {\n                 }\n \n                 #[cfg(not(test))]\n-                impl<$($T:Ord),+> Ord for ($($T,)+) {\n+                impl<$($T:Ord + Eq),+> Ord for ($($T,)+) {\n                     #[inline]\n                     fn lt(&self, other: &($($T,)+)) -> bool {\n-                        lexical_lt!($(self.$get_ref_fn(), other.$get_ref_fn()),+)\n+                        lexical_ord!(lt, $(self.$get_ref_fn(), other.$get_ref_fn()),+)\n                     }\n                     #[inline]\n-                    fn le(&self, other: &($($T,)+)) -> bool { !(*other).lt(&(*self)) }\n+                    fn le(&self, other: &($($T,)+)) -> bool {\n+                        lexical_ord!(le, $(self.$get_ref_fn(), other.$get_ref_fn()),+)\n+                    }\n                     #[inline]\n-                    fn ge(&self, other: &($($T,)+)) -> bool { !(*self).lt(other) }\n+                    fn ge(&self, other: &($($T,)+)) -> bool {\n+                        lexical_ord!(ge, $(self.$get_ref_fn(), other.$get_ref_fn()),+)\n+                    }\n                     #[inline]\n-                    fn gt(&self, other: &($($T,)+)) -> bool { (*other).lt(&(*self)) }\n+                    fn gt(&self, other: &($($T,)+)) -> bool {\n+                        lexical_ord!(gt, $(self.$get_ref_fn(), other.$get_ref_fn()),+)\n+                    }\n                 }\n \n                 #[cfg(not(test))]\n@@ -234,17 +240,16 @@ macro_rules! tuple_impls {\n     }\n }\n \n-// Constructs an expression that performs a lexical less-than\n-// ordering.  The values are interleaved, so the macro invocation for\n-// `(a1, a2, a3) < (b1, b2, b3)` would be `lexical_lt!(a1, b1, a2, b2,\n+// Constructs an expression that performs a lexical ordering using method $rel.\n+// The values are interleaved, so the macro invocation for\n+// `(a1, a2, a3) < (b1, b2, b3)` would be `lexical_ord!(lt, a1, b1, a2, b2,\n // a3, b3)` (and similarly for `lexical_cmp`)\n-macro_rules! lexical_lt {\n-    ($a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {\n-        if *$a < *$b { true }\n-        else if !(*$b < *$a) { lexical_lt!($($rest_a, $rest_b),+) }\n-        else { false }\n+macro_rules! lexical_ord {\n+    ($rel: ident, $a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {\n+        if *$a != *$b { lexical_ord!($rel, $a, $b) }\n+        else { lexical_ord!($rel, $($rest_a, $rest_b),+) }\n     };\n-    ($a:expr, $b:expr) => { *$a < *$b };\n+    ($rel: ident, $a:expr, $b:expr) => { (*$a) . $rel ($b) };\n }\n \n macro_rules! lexical_cmp {\n@@ -436,6 +441,8 @@ mod tests {\n     fn test_tuple_cmp() {\n         let (small, big) = ((1u, 2u, 3u), (3u, 2u, 1u));\n \n+        let nan = 0.0/0.0;\n+\n         // Eq\n         assert_eq!(small, small);\n         assert_eq!(big, big);\n@@ -456,6 +463,13 @@ mod tests {\n         assert!(big >= small);\n         assert!(big >= big);\n \n+        assert!(!((1.0, 2.0) < (nan, 3.0)));\n+        assert!(!((1.0, 2.0) <= (nan, 3.0)));\n+        assert!(!((1.0, 2.0) > (nan, 3.0)));\n+        assert!(!((1.0, 2.0) >= (nan, 3.0)));\n+        assert!(((1.0, 2.0) < (2.0, nan)));\n+        assert!(!((2.0, 2.0) < (2.0, nan)));\n+\n         // TotalEq\n         assert!(small.equals(&small));\n         assert!(big.equals(&big));"}]}