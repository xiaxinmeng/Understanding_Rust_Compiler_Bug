{"sha": "15dd15861c377fd968b1e9f4080525383b2728b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1ZGQxNTg2MWMzNzdmZDk2OGIxZTlmNDA4MDUyNTM4M2IyNzI4YjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-24T07:09:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-24T07:09:40Z"}, "message": "Auto merge of #1256 - JOE1994:rw_widestr_helpers, r=RalfJung\n\nhelper functions for env_var emulation in Windows\n\nMoving some of the changes submitted in PR #1225, in order to prevent the original PR from bloating too much.", "tree": {"sha": "562618b4d8b9a91ae166b8525efa5c867a2d5b6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/562618b4d8b9a91ae166b8525efa5c867a2d5b6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15dd15861c377fd968b1e9f4080525383b2728b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15dd15861c377fd968b1e9f4080525383b2728b6", "html_url": "https://github.com/rust-lang/rust/commit/15dd15861c377fd968b1e9f4080525383b2728b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15dd15861c377fd968b1e9f4080525383b2728b6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5f1a299378e8be934f42ab14cabce4a2dab7d00", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5f1a299378e8be934f42ab14cabce4a2dab7d00", "html_url": "https://github.com/rust-lang/rust/commit/e5f1a299378e8be934f42ab14cabce4a2dab7d00"}, {"sha": "5f9167bdaa033f568b2528881b0fe3a2cdac27dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f9167bdaa033f568b2528881b0fe3a2cdac27dc", "html_url": "https://github.com/rust-lang/rust/commit/5f9167bdaa033f568b2528881b0fe3a2cdac27dc"}], "stats": {"total": 135, "additions": 123, "deletions": 12}, "files": [{"sha": "76c5308cfd35b1ecd20c84ff8c3e42947c540245", "filename": "src/helpers.rs", "status": "modified", "additions": 112, "deletions": 3, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/15dd15861c377fd968b1e9f4080525383b2728b6/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15dd15861c377fd968b1e9f4080525383b2728b6/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=15dd15861c377fd968b1e9f4080525383b2728b6", "patch": "@@ -1,4 +1,4 @@\n-use std::ffi::OsStr;\n+use std::ffi::{OsStr, OsString};\n use std::{iter, mem};\n use std::convert::TryFrom;\n \n@@ -456,6 +456,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n+    /// Dispatches to appropriate implementations for reading an OsString from Memory,\n+    /// depending on the interpretation target.\n+    /// FIXME: Use `Cow` to avoid copies\n+    fn read_os_str_from_target_str(&self, scalar: Scalar<Tag>) -> InterpResult<'tcx, OsString> {\n+        let target_os = self.eval_context_ref().tcx.sess.target.target.target_os.as_str();\n+        match target_os {\n+            \"linux\" | \"macos\" => self.read_os_str_from_c_str(scalar).map(|x| x.to_os_string()),\n+            \"windows\" => self.read_os_str_from_wide_str(scalar),\n+            unsupported => throw_unsup_format!(\"OsString support for target OS `{}` not yet available\", unsupported),\n+        }\n+    }\n+\n     /// Helper function to read an OsString from a null-terminated sequence of bytes, which is what\n     /// the Unix APIs usually handle.\n     fn read_os_str_from_c_str<'a>(&'a self, scalar: Scalar<Tag>) -> InterpResult<'tcx, &'a OsStr>\n@@ -471,14 +483,37 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         fn bytes_to_os_str<'tcx, 'a>(bytes: &'a [u8]) -> InterpResult<'tcx, &'a OsStr> {\n             let s = std::str::from_utf8(bytes)\n                 .map_err(|_| err_unsup_format!(\"{:?} is not a valid utf-8 string\", bytes))?;\n-            Ok(&OsStr::new(s))\n+            Ok(OsStr::new(s))\n         }\n \n         let this = self.eval_context_ref();\n         let bytes = this.memory.read_c_str(scalar)?;\n         bytes_to_os_str(bytes)\n     }\n \n+    /// Helper function to read an OsString from a 0x0000-terminated sequence of u16,\n+    /// which is what the Windows APIs usually handle.\n+    fn read_os_str_from_wide_str<'a>(&'a self, scalar: Scalar<Tag>) -> InterpResult<'tcx, OsString>\n+    where\n+        'tcx: 'a,\n+        'mir: 'a,\n+    {\n+        #[cfg(windows)]\n+        pub fn u16vec_to_osstring<'tcx, 'a>(u16_vec: Vec<u16>) -> InterpResult<'tcx, OsString> {\n+            Ok(std::os::windows::ffi::OsStringExt::from_wide(&u16_vec[..]))\n+        }\n+        #[cfg(not(windows))]\n+        pub fn u16vec_to_osstring<'tcx, 'a>(u16_vec: Vec<u16>) -> InterpResult<'tcx, OsString> {\n+            let s = String::from_utf16(&u16_vec[..])\n+                .map_err(|_| err_unsup_format!(\"{:?} is not a valid utf-16 string\", u16_vec))?;\n+            Ok(s.into())\n+        }\n+\n+        let u16_vec = self.eval_context_ref().memory.read_wide_str(scalar)?;\n+        u16vec_to_osstring(u16_vec)\n+    }\n+\n+\n     /// Helper function to write an OsStr as a null-terminated sequence of bytes, which is what\n     /// the Unix APIs usually handle. This function returns `Ok((false, length))` without trying\n     /// to write if `size` is not large enough to fit the contents of `os_string` plus a null\n@@ -518,6 +553,66 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok((true, string_length))\n     }\n \n+    /// Helper function to write an OsStr as a 0x0000-terminated u16-sequence, which is what\n+    /// the Windows APIs usually handle. This function returns `Ok((false, length))` without trying\n+    /// to write if `size` is not large enough to fit the contents of `os_string` plus a null\n+    /// terminator. It returns `Ok((true, length))` if the writing process was successful. The\n+    /// string length returned does not include the null terminator.\n+    fn write_os_str_to_wide_str(\n+        &mut self,\n+        os_str: &OsStr,\n+        mplace: MPlaceTy<'tcx, Tag>,\n+        size: u64,\n+    ) -> InterpResult<'tcx, (bool, u64)> {\n+        #[cfg(windows)]\n+        fn os_str_to_u16vec<'tcx>(os_str: &OsStr) -> InterpResult<'tcx, Vec<u16>> {\n+            Ok(std::os::windows::ffi::OsStrExt::encode_wide(os_str).collect())\n+        }\n+        #[cfg(not(windows))]\n+        fn os_str_to_u16vec<'tcx>(os_str: &OsStr) -> InterpResult<'tcx, Vec<u16>> {\n+            // On non-Windows platforms the best we can do to transform Vec<u16> from/to OS strings is to do the\n+            // intermediate transformation into strings. Which invalidates non-utf8 paths that are actually\n+            // valid.\n+            os_str\n+                .to_str()\n+                .map(|s| s.encode_utf16().collect())\n+                .ok_or_else(|| err_unsup_format!(\"{:?} is not a valid utf-8 string\", os_str).into())\n+        }\n+\n+        let u16_vec = os_str_to_u16vec(os_str)?;\n+        // If `size` is smaller or equal than `bytes.len()`, writing `bytes` plus the required\n+        // 0x0000 terminator to memory would cause an out-of-bounds access.\n+        let string_length = u64::try_from(u16_vec.len()).unwrap();\n+        if size <= string_length {\n+            return Ok((false, string_length));\n+        }\n+\n+        let this = self.eval_context_mut();\n+\n+        // Store the UTF-16 string.\n+        let char_size = Size::from_bytes(2);\n+        for (idx, c) in u16_vec.into_iter().chain(iter::once(0x0000)).enumerate() {\n+            let place = this.mplace_field(mplace, idx as u64)?; \n+            this.write_scalar(Scalar::from_uint(c, char_size), place.into())?;\n+        }\n+        Ok((true, string_length))\n+    }\n+\n+    /// Dispatches to appropriate implementations for allocating & writing OsString in Memory,\n+    /// depending on the interpretation target.\n+    fn alloc_os_str_as_target_str(\n+        &mut self,\n+        os_str: &OsStr,\n+        memkind: MemoryKind<MiriMemoryKind>,\n+    ) -> InterpResult<'tcx, Pointer<Tag>> {\n+        let target_os = self.eval_context_ref().tcx.sess.target.target.target_os.as_str();\n+        match target_os {\n+            \"linux\" | \"macos\" => Ok(self.alloc_os_str_as_c_str(os_str, memkind)),\n+            \"windows\" => Ok(self.alloc_os_str_as_wide_str(os_str, memkind)),\n+            unsupported => throw_unsup_format!(\"OsString support for target OS `{}` not yet available\", unsupported),\n+        }\n+    }\n+\n     fn alloc_os_str_as_c_str(\n         &mut self,\n         os_str: &OsStr,\n@@ -528,7 +623,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let arg_type = this.tcx.mk_array(this.tcx.types.u8, size);\n         let arg_place = this.allocate(this.layout_of(arg_type).unwrap(), memkind);\n-        self.write_os_str_to_c_str(os_str, arg_place.ptr, size).unwrap();\n+        assert!(self.write_os_str_to_c_str(os_str, arg_place.ptr, size).unwrap().0);\n+        arg_place.ptr.assert_ptr()\n+    }\n+\n+    fn alloc_os_str_as_wide_str(\n+        &mut self,\n+        os_str: &OsStr,\n+        memkind: MemoryKind<MiriMemoryKind>,\n+    ) -> Pointer<Tag> {\n+        let size = u64::try_from(os_str.len()).unwrap().checked_add(1).unwrap(); // Make space for `0x0000` terminator.\n+        let this = self.eval_context_mut();\n+\n+        let arg_type = this.tcx.mk_array(this.tcx.types.u16, size);\n+        let arg_place = this.allocate(this.layout_of(arg_type).unwrap(), memkind);\n+        assert!(self.write_os_str_to_wide_str(os_str, arg_place, size).unwrap().0);\n         arg_place.ptr.assert_ptr()\n     }\n }"}, {"sha": "6b18cd25a1b0f0a74366c088b3c34b0b30c68b4f", "filename": "src/shims/env.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/15dd15861c377fd968b1e9f4080525383b2728b6/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15dd15861c377fd968b1e9f4080525383b2728b6/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=15dd15861c377fd968b1e9f4080525383b2728b6", "patch": "@@ -13,7 +13,7 @@ use rustc_mir::interpret::Pointer;\n #[derive(Default)]\n pub struct EnvVars<'tcx> {\n     /// Stores pointers to the environment variables. These variables must be stored as\n-    /// null-terminated C strings with the `\"{name}={value}\"` format.\n+    /// null-terminated target strings (c_str or wide_str) with the `\"{name}={value}\"` format.\n     map: FxHashMap<OsString, Pointer<Tag>>,\n \n     /// Place where the `environ` static is stored. Lazily initialized, but then never changes.\n@@ -29,7 +29,7 @@ impl<'tcx> EnvVars<'tcx> {\n             for (name, value) in env::vars() {\n                 if !excluded_env_vars.contains(&name) {\n                     let var_ptr =\n-                        alloc_env_var_as_c_str(name.as_ref(), value.as_ref(), ecx);\n+                        alloc_env_var_as_target_str(name.as_ref(), value.as_ref(), ecx)?;\n                     ecx.machine.env_vars.map.insert(OsString::from(name), var_ptr);\n                 }\n             }\n@@ -38,21 +38,23 @@ impl<'tcx> EnvVars<'tcx> {\n     }\n }\n \n-fn alloc_env_var_as_c_str<'mir, 'tcx>(\n+fn alloc_env_var_as_target_str<'mir, 'tcx>(\n     name: &OsStr,\n     value: &OsStr,\n     ecx: &mut InterpCx<'mir, 'tcx, Evaluator<'tcx>>,\n-) -> Pointer<Tag> {\n+) -> InterpResult<'tcx, Pointer<Tag>> {\n     let mut name_osstring = name.to_os_string();\n     name_osstring.push(\"=\");\n     name_osstring.push(value);\n-    ecx.alloc_os_str_as_c_str(name_osstring.as_os_str(), MiriMemoryKind::Machine.into())\n+    Ok(ecx.alloc_os_str_as_target_str(name_osstring.as_os_str(), MiriMemoryKind::Machine.into())?)\n }\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     fn getenv(&mut self, name_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, Scalar<Tag>> {\n         let this = self.eval_context_mut();\n+        let target_os = this.tcx.sess.target.target.target_os.as_str();\n+        assert!(target_os == \"linux\" || target_os == \"macos\", \"`{}` is only available for the UNIX target family\");\n \n         let name_ptr = this.read_scalar(name_op)?.not_undef()?;\n         let name = this.read_os_str_from_c_str(name_ptr)?;\n@@ -74,17 +76,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let name_ptr = this.read_scalar(name_op)?.not_undef()?;\n         let value_ptr = this.read_scalar(value_op)?.not_undef()?;\n-        let value = this.read_os_str_from_c_str(value_ptr)?;\n+        let value = this.read_os_str_from_target_str(value_ptr)?;\n         let mut new = None;\n         if !this.is_null(name_ptr)? {\n-            let name = this.read_os_str_from_c_str(name_ptr)?;\n+            let name = this.read_os_str_from_target_str(name_ptr)?;\n             if !name.is_empty() && !name.to_string_lossy().contains('=') {\n                 new = Some((name.to_owned(), value.to_owned()));\n             }\n         }\n         if let Some((name, value)) = new {\n-            let var_ptr = alloc_env_var_as_c_str(&name, &value, &mut this);\n-            if let Some(var) = this.machine.env_vars.map.insert(name.to_owned(), var_ptr) {\n+            let var_ptr = alloc_env_var_as_target_str(&name, &value, &mut this)?;\n+            if let Some(var) = this.machine.env_vars.map.insert(name, var_ptr) {\n                 this.memory\n                     .deallocate(var, None, MiriMemoryKind::Machine.into())?;\n             }"}]}