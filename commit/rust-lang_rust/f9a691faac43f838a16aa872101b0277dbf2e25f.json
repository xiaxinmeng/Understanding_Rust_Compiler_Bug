{"sha": "f9a691faac43f838a16aa872101b0277dbf2e25f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5YTY5MWZhYWM0M2Y4MzhhMTZhYTg3MjEwMWIwMjc3ZGJmMmUyNWY=", "commit": {"author": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2020-04-08T17:43:43Z"}, "committer": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2020-04-09T03:54:36Z"}, "message": "de-abuse TyKind::Error: handle empty slices in array patterns", "tree": {"sha": "4e617aa3785f32d5caae0760d9e43b422174e24c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e617aa3785f32d5caae0760d9e43b422174e24c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9a691faac43f838a16aa872101b0277dbf2e25f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9a691faac43f838a16aa872101b0277dbf2e25f", "html_url": "https://github.com/rust-lang/rust/commit/f9a691faac43f838a16aa872101b0277dbf2e25f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9a691faac43f838a16aa872101b0277dbf2e25f/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d249d756374737eb014079901ac132f1e1ed905e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d249d756374737eb014079901ac132f1e1ed905e", "html_url": "https://github.com/rust-lang/rust/commit/d249d756374737eb014079901ac132f1e1ed905e"}], "stats": {"total": 31, "additions": 16, "deletions": 15}, "files": [{"sha": "5dcb6d8fdc787c8ac762bfdd090dce4beb521c0c", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f9a691faac43f838a16aa872101b0277dbf2e25f/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9a691faac43f838a16aa872101b0277dbf2e25f/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=f9a691faac43f838a16aa872101b0277dbf2e25f", "patch": "@@ -1353,32 +1353,34 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         def_bm: BindingMode,\n         ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n-        let err = self.tcx.types.err;\n         let expected = self.structurally_resolved_type(span, expected);\n-        let (element_ty, slice_ty, inferred) = match expected.kind {\n+        let (element_ty, opt_slice_ty, inferred) = match expected.kind {\n             // An array, so we might have something like `let [a, b, c] = [0, 1, 2];`.\n             ty::Array(element_ty, len) => {\n                 let min = before.len() as u64 + after.len() as u64;\n-                let (slice_ty, expected) =\n+                let (opt_slice_ty, expected) =\n                     self.check_array_pat_len(span, element_ty, expected, slice, len, min);\n-                (element_ty, slice_ty, expected)\n+                // we can get opt_slice_ty == None in cases that are not an error, e.g. if the\n+                // slice covers 0 elements or if slice is None.\n+                (element_ty, opt_slice_ty, expected)\n             }\n-            ty::Slice(element_ty) => (element_ty, expected, expected),\n+            ty::Slice(element_ty) => (element_ty, Some(expected), expected),\n             // The expected type must be an array or slice, but was neither, so error.\n             _ => {\n                 if !expected.references_error() {\n                     self.error_expected_array_or_slice(span, expected);\n                 }\n-                (err, err, err)\n+                let err = self.tcx.types.err;\n+                (err, None, err)\n             }\n         };\n \n         // Type check all the patterns before `slice`.\n         for elt in before {\n             self.check_pat(&elt, element_ty, def_bm, ti);\n         }\n-        // Type check the `slice`, if present, against its expected type.\n-        if let Some(slice) = slice {\n+        // Type check the `slice`, if present, against its expected type, if there is one.\n+        if let (Some(slice), Some(slice_ty)) = (slice, opt_slice_ty) {\n             self.check_pat(&slice, slice_ty, def_bm, ti);\n         }\n         // Type check the elements after `slice`, if present.\n@@ -1390,9 +1392,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Type check the length of an array pattern.\n     ///\n-    /// Returns both the type of the variable length pattern\n-    /// (or `tcx.err` in case there is none),\n-    /// and the potentially inferred array type.\n+    /// Returns both the type of the variable length pattern (or `None`), and the potentially\n+    /// inferred array type.\n     fn check_array_pat_len(\n         &self,\n         span: Span,\n@@ -1401,7 +1402,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         slice: Option<&'tcx Pat<'tcx>>,\n         len: &ty::Const<'tcx>,\n         min_len: u64,\n-    ) -> (Ty<'tcx>, Ty<'tcx>) {\n+    ) -> (Option<Ty<'tcx>>, Ty<'tcx>) {\n         if let Some(len) = len.try_eval_usize(self.tcx, self.param_env) {\n             // Now we know the length...\n             if slice.is_none() {\n@@ -1414,7 +1415,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             } else if let Some(pat_len) = len.checked_sub(min_len) {\n                 // The variable-length pattern was there,\n                 // so it has an array type with the remaining elements left as its size...\n-                return (self.tcx.mk_array(element_ty, pat_len), arr_ty);\n+                return (Some(self.tcx.mk_array(element_ty, pat_len)), arr_ty);\n             } else {\n                 // ...however, in this case, there were no remaining elements.\n                 // That is, the slice pattern requires more than the array type offers.\n@@ -1425,14 +1426,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // which we can use to infer the length of the array.\n             let updated_arr_ty = self.tcx.mk_array(element_ty, min_len);\n             self.demand_eqtype(span, updated_arr_ty, arr_ty);\n-            return (self.tcx.types.err, updated_arr_ty);\n+            return (None, updated_arr_ty);\n         } else {\n             // We have a variable-length pattern and don't know the array length.\n             // This happens if we have e.g.,\n             // `let [a, b, ..] = arr` where `arr: [T; N]` where `const N: usize`.\n             self.error_scrutinee_unfixed_length(span);\n         }\n-        (self.tcx.types.err, arr_ty)\n+        (None, arr_ty)\n     }\n \n     fn error_scrutinee_inconsistent_length(&self, span: Span, min_len: u64, size: u64) {"}]}