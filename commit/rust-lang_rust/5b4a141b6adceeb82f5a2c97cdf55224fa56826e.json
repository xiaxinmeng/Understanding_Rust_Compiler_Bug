{"sha": "5b4a141b6adceeb82f5a2c97cdf55224fa56826e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViNGExNDFiNmFkY2VlYjgyZjVhMmM5N2NkZjU1MjI0ZmE1NjgyNmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-28T21:26:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-28T21:26:30Z"}, "message": "auto merge of #12616 : alexcrichton/rust/size, r=huonw\n\nI've been playing around with code size when linking to libstd recently, and these were some findings I found that really helped code size. I started out by eliminating all I/O implementations from libnative and instead just return an unimplemented error.\r\n\r\nIn doing so, a `fn main() {}` executable was ~378K before this patch, and about 170K after the patch. These size wins are all pretty minor, but they all seemed pretty reasonable to me. With native I/O not stubbed out, this takes the size of an LTO executable from 675K to 400K.", "tree": {"sha": "bc3e975c830c50d72ae5ac89c339a9ef43d70a2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc3e975c830c50d72ae5ac89c339a9ef43d70a2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b4a141b6adceeb82f5a2c97cdf55224fa56826e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b4a141b6adceeb82f5a2c97cdf55224fa56826e", "html_url": "https://github.com/rust-lang/rust/commit/5b4a141b6adceeb82f5a2c97cdf55224fa56826e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b4a141b6adceeb82f5a2c97cdf55224fa56826e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84ebf74ee2f163461cf021b3d415171e8b5ef8be", "url": "https://api.github.com/repos/rust-lang/rust/commits/84ebf74ee2f163461cf021b3d415171e8b5ef8be", "html_url": "https://github.com/rust-lang/rust/commit/84ebf74ee2f163461cf021b3d415171e8b5ef8be"}, {"sha": "ddc1c21264898f6a5d12cf03bba30f1f08b73665", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddc1c21264898f6a5d12cf03bba30f1f08b73665", "html_url": "https://github.com/rust-lang/rust/commit/ddc1c21264898f6a5d12cf03bba30f1f08b73665"}], "stats": {"total": 233, "additions": 119, "deletions": 114}, "files": [{"sha": "6ac1f2b369244a3dacd51bd1ac58fc771769e297", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b4a141b6adceeb82f5a2c97cdf55224fa56826e/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b4a141b6adceeb82f5a2c97cdf55224fa56826e/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=5b4a141b6adceeb82f5a2c97cdf55224fa56826e", "patch": "@@ -470,7 +470,7 @@ fn spawn_process_os(config: p::ProcessConfig,\n                 Err(e) => {\n                     assert!(e.kind == io::BrokenPipe ||\n                             e.kind == io::EndOfFile,\n-                            \"unexpected error: {:?}\", e);\n+                            \"unexpected error: {}\", e);\n                     Ok(SpawnProcessResult {\n                         pid: pid,\n                         handle: ptr::null()\n@@ -744,7 +744,7 @@ fn waitpid(pid: pid_t) -> p::ProcessExit {\n \n         let mut status = 0 as c_int;\n         match retry(|| unsafe { wait::waitpid(pid, &mut status, 0) }) {\n-            -1 => fail!(\"unknown waitpid error: {:?}\", super::last_error()),\n+            -1 => fail!(\"unknown waitpid error: {}\", super::last_error()),\n             _ => {\n                 if imp::WIFEXITED(status) {\n                     p::ExitStatus(imp::WEXITSTATUS(status) as int)"}, {"sha": "6f584991f85bb9e3bdea52525c6cb54f8e51713e", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5b4a141b6adceeb82f5a2c97cdf55224fa56826e/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b4a141b6adceeb82f5a2c97cdf55224fa56826e/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=5b4a141b6adceeb82f5a2c97cdf55224fa56826e", "patch": "@@ -149,7 +149,14 @@ macro_rules! fail(\n         // function to pass to format_args!, *and* we need the\n         // file and line numbers right here; so an inner bare fn\n         // is our only choice.\n-        #[inline]\n+        //\n+        // LLVM doesn't tend to inline this, presumably because begin_unwind_fmt\n+        // is #[cold] and #[inline(never)] and because this is flagged as cold\n+        // as returning !. We really do want this to be inlined, however,\n+        // because it's just a tiny wrapper. Small wins (156K to 149K in size)\n+        // were seen when forcing this to be inlined, and that number just goes\n+        // up with the number of calls to fail!()\n+        #[inline(always)]\n         fn run_fmt(fmt: &::std::fmt::Arguments) -> ! {\n             ::std::rt::begin_unwind_fmt(fmt, file!(), line!())\n         }"}, {"sha": "00497b6f0eaf06ffa0b66ceb06974a383e74fa2e", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5b4a141b6adceeb82f5a2c97cdf55224fa56826e/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b4a141b6adceeb82f5a2c97cdf55224fa56826e/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=5b4a141b6adceeb82f5a2c97cdf55224fa56826e", "patch": "@@ -532,19 +532,19 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Div<T,T>+\n         ) -> Option<T> {\n     match exponent {\n         ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n-          => fail!(\"from_str_bytes_common: radix {:?} incompatible with \\\n+          => fail!(\"from_str_bytes_common: radix {} incompatible with \\\n                     use of 'e' as decimal exponent\", radix),\n         ExpBin if radix >= DIGIT_P_RADIX       // binary exponent 'p'\n-          => fail!(\"from_str_bytes_common: radix {:?} incompatible with \\\n+          => fail!(\"from_str_bytes_common: radix {} incompatible with \\\n                     use of 'p' as binary exponent\", radix),\n         _ if special && radix >= DIGIT_I_RADIX // first digit of 'inf'\n-          => fail!(\"from_str_bytes_common: radix {:?} incompatible with \\\n+          => fail!(\"from_str_bytes_common: radix {} incompatible with \\\n                     special values 'inf' and 'NaN'\", radix),\n         _ if (radix as int) < 2\n-          => fail!(\"from_str_bytes_common: radix {:?} to low, \\\n+          => fail!(\"from_str_bytes_common: radix {} to low, \\\n                     must lie in the range [2, 36]\", radix),\n         _ if (radix as int) > 36\n-          => fail!(\"from_str_bytes_common: radix {:?} to high, \\\n+          => fail!(\"from_str_bytes_common: radix {} to high, \\\n                     must lie in the range [2, 36]\", radix),\n         _ => ()\n     }"}, {"sha": "ff54a80ce997f9900bc9959a8be32729802ea534", "filename": "src/libstd/rt/crate_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b4a141b6adceeb82f5a2c97cdf55224fa56826e/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b4a141b6adceeb82f5a2c97cdf55224fa56826e/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=5b4a141b6adceeb82f5a2c97cdf55224fa56826e", "patch": "@@ -123,7 +123,7 @@ fn version(crate_map: &CrateMap) -> i32 {\n \n fn do_iter_crate_map<'a>(\n                      crate_map: &'a CrateMap<'a>,\n-                     f: |&ModEntry|,\n+                     f: |&'a ModEntry<'a>|,\n                      visited: &mut ~[*CrateMap<'a>]) {\n     let raw = crate_map as *CrateMap<'a>;\n     if visited.bsearch(|a| (*a as uint).cmp(&(raw as uint))).is_some() {\n@@ -149,7 +149,7 @@ fn do_iter_crate_map<'a>(\n }\n \n /// Iterates recursively over `crate_map` and all child crate maps\n-pub fn iter_crate_map<'a>(crate_map: &'a CrateMap<'a>, f: |&ModEntry|) {\n+pub fn iter_crate_map<'a>(crate_map: &'a CrateMap<'a>, f: |&'a ModEntry<'a>|) {\n     let mut v = ~[];\n     do_iter_crate_map(crate_map, f, &mut v);\n }"}, {"sha": "aa024a53b89ecc812c12675d82d631cb74cff306", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 94, "deletions": 100, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/5b4a141b6adceeb82f5a2c97cdf55224fa56826e/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b4a141b6adceeb82f5a2c97cdf55224fa56826e/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=5b4a141b6adceeb82f5a2c97cdf55224fa56826e", "patch": "@@ -13,13 +13,14 @@ use from_str::from_str;\n use iter::Iterator;\n use libc::exit;\n use option::{Some, None, Option};\n+use os;\n use rt::crate_map::{ModEntry, CrateMap, iter_crate_map, get_crate_map};\n-use str::StrSlice;\n+use str::{Str, StrSlice};\n use vec::{ImmutableVector, MutableTotalOrdVector, OwnedVector};\n-#[cfg(test)] use cast::transmute;\n+use vec_ng::Vec;\n \n-struct LogDirective {\n-    name: Option<~str>,\n+struct LogDirective<'a> {\n+    name: Option<&'a str>,\n     level: u32\n }\n \n@@ -58,36 +59,39 @@ fn parse_log_level(level: &str) -> Option<u32> {\n /// and return a vector with log directives.\n /// Valid log levels are 0-255, with the most likely ones being 1-4 (defined in std::).\n /// Also supports string log levels of error, warn, info, and debug\n-fn parse_logging_spec(spec: ~str) -> ~[LogDirective]{\n-    let mut dirs = ~[];\n+fn parse_logging_spec<'a>(spec: &'a str) -> Vec<LogDirective<'a>> {\n+    let mut dirs = Vec::new();\n     for s in spec.split(',') {\n-        let parts: ~[&str] = s.split('=').collect();\n-        let mut log_level;\n-        let mut name = Some(parts[0].to_owned());\n-        match parts.len() {\n-            1 => {\n+        if s.len() == 0 { continue }\n+        let mut parts = s.split('=');\n+        let log_level;\n+        let name;\n+        match (parts.next(), parts.next(), parts.next()) {\n+            (Some(part0), None, None) => {\n                 //if the single argument is a log-level string or number,\n                 //treat that as a global fallback\n-                let possible_log_level = parse_log_level(parts[0]);\n+                let possible_log_level = parse_log_level(part0);\n                 match possible_log_level {\n                     Some(num) => {\n                         name = None;\n                         log_level = num;\n                     },\n-                    _ => {\n-                        log_level = MAX_LOG_LEVEL\n+                    None => {\n+                        log_level = MAX_LOG_LEVEL;\n+                        name = Some(part0);\n                     }\n                 }\n             }\n-            2 => {\n-                let possible_log_level = parse_log_level(parts[1]);\n+            (Some(part0), Some(part1), None) => {\n+                let possible_log_level = parse_log_level(part1);\n                 match possible_log_level {\n                     Some(num) => {\n+                        name = Some(part0);\n                         log_level = num;\n                     },\n                     _ => {\n                         rterrln!(\"warning: invalid logging spec '{}', \\\n-                                  ignoring it\", parts[1]);\n+                                  ignoring it\", part1);\n                         continue\n                     }\n                 }\n@@ -98,8 +102,7 @@ fn parse_logging_spec(spec: ~str) -> ~[LogDirective]{\n                 continue\n             }\n         }\n-        let dir = LogDirective {name: name, level: log_level};\n-        dirs.push(dir);\n+        dirs.push(LogDirective { name: name, level: log_level });\n     }\n     return dirs;\n }\n@@ -134,27 +137,24 @@ fn update_entry(dirs: &[LogDirective], entry: &ModEntry) -> u32 {\n \n /// Set log level for every entry in crate_map according to the sepecification\n /// in settings\n-fn update_log_settings(crate_map: &CrateMap, settings: ~str) {\n-    let mut dirs = ~[];\n-    if settings.len() > 0 {\n-        if settings == ~\"::help\" || settings == ~\"?\" {\n-            rterrln!(\"\\nCrate log map:\\n\");\n+fn update_log_settings(crate_map: &CrateMap, settings: &str) {\n+    if settings == \"::help\" || settings == \"?\" {\n+        rterrln!(\"\\nCrate log map:\\n\");\n \n-            let mut entries = ~[];\n-            iter_crate_map(crate_map, |entry| entries.push(entry.name.to_owned()));\n-            entries.sort();\n+        let mut entries = Vec::new();\n+        iter_crate_map(crate_map, |entry| entries.push(entry.name));\n+        entries.as_mut_slice().sort();\n \n-            for name in entries.iter() {\n-                rterrln!(\" {}\", *name);\n-            }\n-            unsafe { exit(1); }\n+        for name in entries.iter() {\n+            rterrln!(\" {}\", *name);\n         }\n-        dirs = parse_logging_spec(settings);\n+        unsafe { exit(1); }\n     }\n+    let dirs = parse_logging_spec(settings);\n \n     let mut n_matches: u32 = 0;\n     iter_crate_map(crate_map, |entry| {\n-        let m = update_entry(dirs, entry);\n+        let m = update_entry(dirs.as_slice(), entry);\n         n_matches += m;\n     });\n \n@@ -169,18 +169,12 @@ fn update_log_settings(crate_map: &CrateMap, settings: ~str) {\n /// Configure logging by traversing the crate map and setting the\n /// per-module global logging flags based on the logging spec\n pub fn init() {\n-    use os;\n-\n     let log_spec = os::getenv(\"RUST_LOG\");\n     match get_crate_map() {\n         Some(crate_map) => {\n             match log_spec {\n-                Some(spec) => {\n-                    update_log_settings(crate_map, spec);\n-                }\n-                None => {\n-                    update_log_settings(crate_map, ~\"\");\n-                }\n+                Some(spec) => update_log_settings(crate_map, spec.as_slice()),\n+                None => update_log_settings(crate_map, \"\"),\n             }\n         },\n         _ => {\n@@ -197,124 +191,124 @@ pub fn init() {\n // Tests for parse_logging_spec()\n #[test]\n fn parse_logging_spec_valid() {\n-    let dirs = parse_logging_spec(~\"crate1::mod1=1,crate1::mod2,crate2=4\");\n+    let dirs = parse_logging_spec(\"crate1::mod1=1,crate1::mod2,crate2=4\");\n+    let dirs = dirs.as_slice();\n     assert_eq!(dirs.len(), 3);\n-    assert!(dirs[0].name == Some(~\"crate1::mod1\"));\n+    assert_eq!(dirs[0].name, Some(\"crate1::mod1\"));\n     assert_eq!(dirs[0].level, 1);\n \n-    assert!(dirs[1].name == Some(~\"crate1::mod2\"));\n+    assert_eq!(dirs[1].name, Some(\"crate1::mod2\"));\n     assert_eq!(dirs[1].level, MAX_LOG_LEVEL);\n \n-    assert!(dirs[2].name == Some(~\"crate2\"));\n+    assert_eq!(dirs[2].name, Some(\"crate2\"));\n     assert_eq!(dirs[2].level, 4);\n }\n \n #[test]\n fn parse_logging_spec_invalid_crate() {\n     // test parse_logging_spec with multiple = in specification\n-    let dirs = parse_logging_spec(~\"crate1::mod1=1=2,crate2=4\");\n+    let dirs = parse_logging_spec(\"crate1::mod1=1=2,crate2=4\");\n+    let dirs = dirs.as_slice();\n     assert_eq!(dirs.len(), 1);\n-    assert!(dirs[0].name == Some(~\"crate2\"));\n+    assert_eq!(dirs[0].name, Some(\"crate2\"));\n     assert_eq!(dirs[0].level, 4);\n }\n \n #[test]\n fn parse_logging_spec_invalid_log_level() {\n     // test parse_logging_spec with 'noNumber' as log level\n-    let dirs = parse_logging_spec(~\"crate1::mod1=noNumber,crate2=4\");\n+    let dirs = parse_logging_spec(\"crate1::mod1=noNumber,crate2=4\");\n+    let dirs = dirs.as_slice();\n     assert_eq!(dirs.len(), 1);\n-    assert!(dirs[0].name == Some(~\"crate2\"));\n+    assert_eq!(dirs[0].name, Some(\"crate2\"));\n     assert_eq!(dirs[0].level, 4);\n }\n \n #[test]\n fn parse_logging_spec_string_log_level() {\n     // test parse_logging_spec with 'warn' as log level\n-    let dirs = parse_logging_spec(~\"crate1::mod1=wrong,crate2=warn\");\n+    let dirs = parse_logging_spec(\"crate1::mod1=wrong,crate2=warn\");\n+    let dirs = dirs.as_slice();\n     assert_eq!(dirs.len(), 1);\n-    assert!(dirs[0].name == Some(~\"crate2\"));\n+    assert_eq!(dirs[0].name, Some(\"crate2\"));\n     assert_eq!(dirs[0].level, 2);\n }\n \n #[test]\n fn parse_logging_spec_global() {\n     // test parse_logging_spec with no crate\n-    let dirs = parse_logging_spec(~\"warn,crate2=4\");\n+    let dirs = parse_logging_spec(\"warn,crate2=4\");\n+    let dirs = dirs.as_slice();\n     assert_eq!(dirs.len(), 2);\n-    assert!(dirs[0].name == None);\n+    assert_eq!(dirs[0].name, None);\n     assert_eq!(dirs[0].level, 2);\n-    assert!(dirs[1].name == Some(~\"crate2\"));\n+    assert_eq!(dirs[1].name, Some(\"crate2\"));\n     assert_eq!(dirs[1].level, 4);\n }\n \n // Tests for update_entry\n #[test]\n fn update_entry_match_full_path() {\n-    let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n-                 LogDirective {name: Some(~\"crate2\"), level: 3}];\n-    let level = &mut 0;\n-    unsafe {\n-        let entry= &ModEntry {name:\"crate1::mod1\", log_level: level};\n-        let m = update_entry(dirs, transmute(entry));\n-        assert!(*entry.log_level == 2);\n-        assert!(m == 1);\n+    let dirs = [LogDirective { name: Some(\"crate1::mod1\"), level: 2 },\n+                LogDirective { name: Some(\"crate2\"), level: 3 }];\n+    let mut level = 0;\n+    {\n+        let entry = &ModEntry { name: \"crate1::mod1\", log_level: &mut level };\n+        assert_eq!(update_entry(dirs, entry), 1);\n     }\n+    assert_eq!(level, 2);\n }\n \n #[test]\n fn update_entry_no_match() {\n-    let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n-                 LogDirective {name: Some(~\"crate2\"), level: 3}];\n-    let level = &mut 0;\n-    unsafe {\n-        let entry= &ModEntry {name: \"crate3::mod1\", log_level: level};\n-        let m = update_entry(dirs, transmute(entry));\n-        assert!(*entry.log_level == DEFAULT_LOG_LEVEL);\n-        assert!(m == 0);\n+    let dirs = [LogDirective { name: Some(\"crate1::mod1\"), level: 2 },\n+                LogDirective { name: Some(\"crate2\"), level: 3 }];\n+    let mut level = 0;\n+    {\n+        let entry = &ModEntry { name: \"crate3::mod1\", log_level: &mut level };\n+        assert_eq!(update_entry(dirs, entry), 0);\n     }\n+    assert_eq!(level, DEFAULT_LOG_LEVEL);\n }\n \n #[test]\n fn update_entry_match_beginning() {\n-    let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n-                 LogDirective {name: Some(~\"crate2\"), level: 3}];\n-    let level = &mut 0;\n-    unsafe {\n-        let entry= &ModEntry {name: \"crate2::mod1\", log_level: level};\n-        let m = update_entry(dirs, transmute(entry));\n-        assert!(*entry.log_level == 3);\n-        assert!(m == 1);\n+    let dirs = [LogDirective { name: Some(\"crate1::mod1\"), level: 2 },\n+                LogDirective { name: Some(\"crate2\"), level: 3 }];\n+    let mut level = 0;\n+    {\n+        let entry= &ModEntry {name: \"crate2::mod1\", log_level: &mut level};\n+        assert_eq!(update_entry(dirs, entry), 1);\n     }\n+    assert_eq!(level, 3);\n }\n \n #[test]\n fn update_entry_match_beginning_longest_match() {\n-    let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n-                 LogDirective {name: Some(~\"crate2\"), level: 3},\n-                 LogDirective {name: Some(~\"crate2::mod\"), level: 4}];\n-    let level = &mut 0;\n-    unsafe {\n-        let entry = &ModEntry {name: \"crate2::mod1\", log_level: level};\n-        let m = update_entry(dirs, transmute(entry));\n-        assert!(*entry.log_level == 4);\n-        assert!(m == 1);\n+    let dirs = [LogDirective { name: Some(\"crate1::mod1\"), level: 2 },\n+                LogDirective { name: Some(\"crate2\"), level: 3 },\n+                LogDirective { name: Some(\"crate2::mod\"), level: 4 }];\n+    let mut level = 0;\n+    {\n+        let entry = &ModEntry { name: \"crate2::mod1\", log_level: &mut level };\n+        assert_eq!(update_entry(dirs, entry), 1);\n     }\n+    assert_eq!(level, 4);\n }\n \n #[test]\n fn update_entry_match_default() {\n-    let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n-                 LogDirective {name: None, level: 3}\n-                ];\n-    let level = &mut 0;\n-    unsafe {\n-        let entry= &ModEntry {name: \"crate1::mod1\", log_level: level};\n-        let m = update_entry(dirs, transmute(entry));\n-        assert!(*entry.log_level == 2);\n-        assert!(m == 1);\n-        let entry= &ModEntry {name: \"crate2::mod2\", log_level: level};\n-        let m = update_entry(dirs, transmute(entry));\n-        assert!(*entry.log_level == 3);\n-        assert!(m == 1);\n+    let dirs = [LogDirective { name: Some(\"crate1::mod1\"), level: 2 },\n+                LogDirective { name: None, level: 3 }];\n+    let mut level = 0;\n+    {\n+        let entry = &ModEntry { name: \"crate1::mod1\", log_level: &mut level };\n+        assert_eq!(update_entry(dirs, entry), 1);\n+    }\n+    assert_eq!(level, 2);\n+    {\n+        let entry = &ModEntry { name: \"crate2::mod2\", log_level: &mut level };\n+        assert_eq!(update_entry(dirs, entry), 1);\n     }\n+    assert_eq!(level, 3);\n }"}, {"sha": "10369a52f0f17306b237a017ad637e63d7c072b5", "filename": "src/libstd/sync/arc.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5b4a141b6adceeb82f5a2c97cdf55224fa56826e/src%2Flibstd%2Fsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b4a141b6adceeb82f5a2c97cdf55224fa56826e/src%2Flibstd%2Fsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Farc.rs?ref=5b4a141b6adceeb82f5a2c97cdf55224fa56826e", "patch": "@@ -80,7 +80,8 @@ impl<T: Send> UnsafeArc<T> {\n     #[inline]\n     pub fn get(&self) -> *mut T {\n         unsafe {\n-            assert!((*self.data).count.load(Relaxed) > 0);\n+            // FIXME(#12049): this needs some sort of debug assertion\n+            if cfg!(test) { assert!((*self.data).count.load(Relaxed) > 0); }\n             return &mut (*self.data).data as *mut T;\n         }\n     }\n@@ -90,7 +91,8 @@ impl<T: Send> UnsafeArc<T> {\n     #[inline]\n     pub fn get_immut(&self) -> *T {\n         unsafe {\n-            assert!((*self.data).count.load(Relaxed) > 0);\n+            // FIXME(#12049): this needs some sort of debug assertion\n+            if cfg!(test) { assert!((*self.data).count.load(Relaxed) > 0); }\n             return &(*self.data).data as *T;\n         }\n     }\n@@ -109,7 +111,8 @@ impl<T: Send> Clone for UnsafeArc<T> {\n         unsafe {\n             // This barrier might be unnecessary, but I'm not sure...\n             let old_count = (*self.data).count.fetch_add(1, Acquire);\n-            assert!(old_count >= 1);\n+            // FIXME(#12049): this needs some sort of debug assertion\n+            if cfg!(test) { assert!(old_count >= 1); }\n             return UnsafeArc { data: self.data };\n         }\n     }\n@@ -127,7 +130,8 @@ impl<T> Drop for UnsafeArc<T>{\n             // Must be acquire+release, not just release, to make sure this\n             // doesn't get reordered to after the unwrapper pointer load.\n             let old_count = (*self.data).count.fetch_sub(1, SeqCst);\n-            assert!(old_count >= 1);\n+            // FIXME(#12049): this needs some sort of debug assertion\n+            if cfg!(test) { assert!(old_count >= 1); }\n             if old_count == 1 {\n                 let _: ~ArcData<T> = cast::transmute(self.data);\n             }"}]}