{"sha": "bf48a2d50d82cccac58d7c4c73700eaf66926aee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmNDhhMmQ1MGQ4MmNjY2FjNThkN2M0YzczNzAwZWFmNjY5MjZhZWU=", "commit": {"author": {"name": "JarredAllen", "email": "jarredallen73@gmail.com", "date": "2020-03-05T18:35:05Z"}, "committer": {"name": "JarredAllen", "email": "jarredallen73@gmail.com", "date": "2020-07-03T23:47:38Z"}, "message": "Lint for if let Some(x) = ... instead of Option::map_or", "tree": {"sha": "5b00296706529c153d3b70ead64f5c87337759fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b00296706529c153d3b70ead64f5c87337759fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf48a2d50d82cccac58d7c4c73700eaf66926aee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf48a2d50d82cccac58d7c4c73700eaf66926aee", "html_url": "https://github.com/rust-lang/rust/commit/bf48a2d50d82cccac58d7c4c73700eaf66926aee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf48a2d50d82cccac58d7c4c73700eaf66926aee/comments", "author": {"login": "JarredAllen", "id": 19656507, "node_id": "MDQ6VXNlcjE5NjU2NTA3", "avatar_url": "https://avatars.githubusercontent.com/u/19656507?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JarredAllen", "html_url": "https://github.com/JarredAllen", "followers_url": "https://api.github.com/users/JarredAllen/followers", "following_url": "https://api.github.com/users/JarredAllen/following{/other_user}", "gists_url": "https://api.github.com/users/JarredAllen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JarredAllen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JarredAllen/subscriptions", "organizations_url": "https://api.github.com/users/JarredAllen/orgs", "repos_url": "https://api.github.com/users/JarredAllen/repos", "events_url": "https://api.github.com/users/JarredAllen/events{/privacy}", "received_events_url": "https://api.github.com/users/JarredAllen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JarredAllen", "id": 19656507, "node_id": "MDQ6VXNlcjE5NjU2NTA3", "avatar_url": "https://avatars.githubusercontent.com/u/19656507?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JarredAllen", "html_url": "https://github.com/JarredAllen", "followers_url": "https://api.github.com/users/JarredAllen/followers", "following_url": "https://api.github.com/users/JarredAllen/following{/other_user}", "gists_url": "https://api.github.com/users/JarredAllen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JarredAllen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JarredAllen/subscriptions", "organizations_url": "https://api.github.com/users/JarredAllen/orgs", "repos_url": "https://api.github.com/users/JarredAllen/repos", "events_url": "https://api.github.com/users/JarredAllen/events{/privacy}", "received_events_url": "https://api.github.com/users/JarredAllen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57cdf2dc16e1833008ae5b120cb2c045d267dda8", "url": "https://api.github.com/repos/rust-lang/rust/commits/57cdf2dc16e1833008ae5b120cb2c045d267dda8", "html_url": "https://github.com/rust-lang/rust/commit/57cdf2dc16e1833008ae5b120cb2c045d267dda8"}], "stats": {"total": 381, "additions": 381, "deletions": 0}, "files": [{"sha": "1a081bb85feab6c5ed35df1bbf0bf2d0aa2f8159", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bf48a2d50d82cccac58d7c4c73700eaf66926aee/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/bf48a2d50d82cccac58d7c4c73700eaf66926aee/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=bf48a2d50d82cccac58d7c4c73700eaf66926aee", "patch": "@@ -1577,6 +1577,7 @@ Released 2018-09-13\n [`op_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#op_ref\n [`option_as_ref_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_as_ref_deref\n [`option_env_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_env_unwrap\n+[`option_if_let_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_if_let_else\n [`option_map_or_none`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_or_none\n [`option_map_unit_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_unit_fn\n [`option_option`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_option"}, {"sha": "cd91e7ceb32a8aeb88ddc7d38bb022743d791cce", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bf48a2d50d82cccac58d7c4c73700eaf66926aee/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf48a2d50d82cccac58d7c4c73700eaf66926aee/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=bf48a2d50d82cccac58d7c4c73700eaf66926aee", "patch": "@@ -264,6 +264,7 @@ mod non_copy_const;\n mod non_expressive_names;\n mod open_options;\n mod option_env_unwrap;\n+mod option_if_let_else;\n mod overflow_check_conditional;\n mod panic_unimplemented;\n mod partialeq_ne_impl;\n@@ -734,6 +735,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &non_expressive_names::SIMILAR_NAMES,\n         &open_options::NONSENSICAL_OPEN_OPTIONS,\n         &option_env_unwrap::OPTION_ENV_UNWRAP,\n+        &option_if_let_else::OPTION_IF_LET_ELSE,\n         &overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL,\n         &panic_unimplemented::PANIC,\n         &panic_unimplemented::PANIC_PARAMS,\n@@ -1052,6 +1054,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box redundant_pub_crate::RedundantPubCrate::default());\n     store.register_late_pass(|| box unnamed_address::UnnamedAddress);\n     store.register_late_pass(|| box dereference::Dereferencing);\n+    store.register_late_pass(|| box option_if_let_else::OptionIfLetElse);\n     store.register_late_pass(|| box future_not_send::FutureNotSend);\n     store.register_late_pass(|| box utils::internal_lints::CollapsibleCalls);\n     store.register_late_pass(|| box if_let_mutex::IfLetMutex);\n@@ -1369,6 +1372,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&non_expressive_names::MANY_SINGLE_CHAR_NAMES),\n         LintId::of(&open_options::NONSENSICAL_OPEN_OPTIONS),\n         LintId::of(&option_env_unwrap::OPTION_ENV_UNWRAP),\n+        LintId::of(&option_if_let_else::OPTION_IF_LET_ELSE),\n         LintId::of(&overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL),\n         LintId::of(&panic_unimplemented::PANIC_PARAMS),\n         LintId::of(&partialeq_ne_impl::PARTIALEQ_NE_IMPL),\n@@ -1517,6 +1521,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&new_without_default::NEW_WITHOUT_DEFAULT),\n         LintId::of(&non_expressive_names::JUST_UNDERSCORES_AND_DIGITS),\n         LintId::of(&non_expressive_names::MANY_SINGLE_CHAR_NAMES),\n+        LintId::of(&option_if_let_else::OPTION_IF_LET_ELSE),\n         LintId::of(&panic_unimplemented::PANIC_PARAMS),\n         LintId::of(&ptr::CMP_NULL),\n         LintId::of(&ptr::PTR_ARG),"}, {"sha": "f092f1297c1bbf71ccd0c2a589b54eba4ec2018c", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/bf48a2d50d82cccac58d7c4c73700eaf66926aee/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf48a2d50d82cccac58d7c4c73700eaf66926aee/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=bf48a2d50d82cccac58d7c4c73700eaf66926aee", "patch": "@@ -0,0 +1,202 @@\n+use crate::utils::sugg::Sugg;\n+use crate::utils::{match_type, paths, span_lint_and_sugg};\n+use if_chain::if_chain;\n+\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n+use rustc_hir::*;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+use std::marker::PhantomData;\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Lints usage of  `if let Some(v) = ... { y } else { x }` which is more\n+    /// idiomatically done with `Option::map_or` (if the else bit is a simple\n+    /// expression) or `Option::map_or_else` (if the else bit is a longer\n+    /// block).\n+    ///\n+    /// **Why is this bad?**\n+    /// Using the dedicated functions of the Option type is clearer and\n+    /// more concise than an if let expression.\n+    ///\n+    /// **Known problems:**\n+    /// This lint uses whether the block is just an expression or if it has\n+    /// more statements to decide whether to use `Option::map_or` or\n+    /// `Option::map_or_else`. If you have a single expression which calls\n+    /// an expensive function, then it would be more efficient to use\n+    /// `Option::map_or_else`, but this lint would suggest `Option::map_or`.\n+    ///\n+    /// Also, this lint uses a deliberately conservative metric for checking\n+    /// if the inside of either body contains breaks or continues which will\n+    /// cause it to not suggest a fix if either block contains a loop with\n+    /// continues or breaks contained within the loop.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// # let optional: Option<u32> = Some(0);\n+    /// let _ = if let Some(foo) = optional {\n+    ///     foo\n+    /// } else {\n+    ///     5\n+    /// };\n+    /// let _ = if let Some(foo) = optional {\n+    ///     foo\n+    /// } else {\n+    ///     let y = do_complicated_function();\n+    ///     y*y\n+    /// };\n+    /// ```\n+    ///\n+    /// should be\n+    ///\n+    /// ```rust\n+    /// # let optional: Option<u32> = Some(0);\n+    /// let _ = optional.map_or(5, |foo| foo);\n+    /// let _ = optional.map_or_else(||{\n+    ///     let y = do_complicated_function;\n+    ///     y*y\n+    /// }, |foo| foo);\n+    /// ```\n+    pub OPTION_IF_LET_ELSE,\n+    style,\n+    \"reimplementation of Option::map_or\"\n+}\n+\n+declare_lint_pass!(OptionIfLetElse => [OPTION_IF_LET_ELSE]);\n+\n+/// Returns true iff the given expression is the result of calling Result::ok\n+fn is_result_ok(cx: &LateContext<'_, '_>, expr: &'_ Expr<'_>) -> bool {\n+    if_chain! {\n+        if let ExprKind::MethodCall(ref path, _, &[ref receiver]) = &expr.kind;\n+        if path.ident.name.to_ident_string() == \"ok\";\n+        if match_type(cx, &cx.tables.expr_ty(&receiver), &paths::RESULT);\n+        then {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+/// A struct containing information about occurences of the\n+/// `if let Some(..) = .. else` construct that this lint detects.\n+struct OptionIfLetElseOccurence {\n+    option: String,\n+    method_sugg: String,\n+    some_expr: String,\n+    none_expr: String,\n+}\n+\n+struct ReturnBreakContinueVisitor<'tcx> {\n+    seen_return_break_continue: bool,\n+    phantom_data: PhantomData<&'tcx bool>,\n+}\n+impl<'tcx> ReturnBreakContinueVisitor<'tcx> {\n+    fn new() -> ReturnBreakContinueVisitor<'tcx> {\n+        ReturnBreakContinueVisitor {\n+            seen_return_break_continue: false,\n+            phantom_data: PhantomData,\n+        }\n+    }\n+}\n+impl<'tcx> Visitor<'tcx> for ReturnBreakContinueVisitor<'tcx> {\n+    type Map = Map<'tcx>;\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n+        if self.seen_return_break_continue {\n+            // No need to look farther if we've already seen one of them\n+            return;\n+        }\n+        match &ex.kind {\n+            ExprKind::Ret(..) | ExprKind::Break(..) | ExprKind::Continue(..) => {\n+                self.seen_return_break_continue = true;\n+            },\n+            // Something special could be done here to handle while or for loop\n+            // desugaring, as this will detect a break if there's a while loop\n+            // or a for loop inside the expression.\n+            _ => {\n+                rustc_hir::intravisit::walk_expr(self, ex);\n+            },\n+        }\n+    }\n+}\n+\n+fn contains_return_break_continue<'tcx>(expression: &'tcx Expr<'tcx>) -> bool {\n+    let mut recursive_visitor: ReturnBreakContinueVisitor<'tcx> = ReturnBreakContinueVisitor::new();\n+    recursive_visitor.visit_expr(expression);\n+    recursive_visitor.seen_return_break_continue\n+}\n+\n+/// If this expression is the option if let/else construct we're detecting, then\n+/// this function returns an OptionIfLetElseOccurence struct with details if\n+/// this construct is found, or None if this construct is not found.\n+fn detect_option_if_let_else<'a>(cx: &LateContext<'_, 'a>, expr: &'a Expr<'a>) -> Option<OptionIfLetElseOccurence> {\n+    //(String, String, String, String)> {\n+    if_chain! {\n+        if let ExprKind::Match(let_body, arms, MatchSource::IfLetDesugar{contains_else_clause: true}) = &expr.kind;\n+        if arms.len() == 2;\n+        if match_type(cx, &cx.tables.expr_ty(let_body), &paths::OPTION);\n+        if !is_result_ok(cx, let_body); // Don't lint on Result::ok because a different lint does it already\n+        if let PatKind::TupleStruct(_, &[inner_pat], _) = &arms[0].pat.kind;\n+        if let PatKind::Binding(_, _, id, _) = &inner_pat.kind;\n+        if !contains_return_break_continue(arms[0].body);\n+        if !contains_return_break_continue(arms[1].body);\n+        then {\n+            let some_body = if let ExprKind::Block(Block { stmts: statements, expr: Some(expr), .. }, _)\n+                = &arms[0].body.kind {\n+                if let &[] = &statements {\n+                    expr\n+                } else {\n+                    &arms[0].body\n+                }\n+            } else {\n+                return None;\n+            };\n+            let (none_body, method_sugg) = if let ExprKind::Block(Block { stmts: statements, expr: Some(expr), .. }, _)\n+                = &arms[1].body.kind {\n+                if let &[] = &statements {\n+                    (expr, \"map_or\")\n+                } else {\n+                    (&arms[1].body, \"map_or_else\")\n+                }\n+            } else {\n+                return None;\n+            };\n+            let capture_name = id.name.to_ident_string();\n+            Some(OptionIfLetElseOccurence {\n+                option: format!(\"{}\", Sugg::hir(cx, let_body, \"..\")),\n+                method_sugg: format!(\"{}\", method_sugg),\n+                some_expr: format!(\"|{}| {}\", capture_name, Sugg::hir(cx, some_body, \"..\")),\n+                none_expr: format!(\"{}{}\", if method_sugg == \"map_or\" { \"\" } else { \"|| \" }, Sugg::hir(cx, none_body, \"..\"))\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OptionIfLetElse {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        if let Some(detection) = detect_option_if_let_else(cx, expr) {\n+            span_lint_and_sugg(\n+                cx,\n+                OPTION_IF_LET_ELSE,\n+                expr.span,\n+                format!(\"use Option::{} instead of an if let/else\", detection.method_sugg).as_str(),\n+                \"try\",\n+                format!(\n+                    \"{}.{}({}, {})\",\n+                    detection.option, detection.method_sugg, detection.none_expr, detection.some_expr\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}"}, {"sha": "b499d565fa7f950e2e9e6d57a814a993e7465093", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bf48a2d50d82cccac58d7c4c73700eaf66926aee/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf48a2d50d82cccac58d7c4c73700eaf66926aee/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=bf48a2d50d82cccac58d7c4c73700eaf66926aee", "patch": "@@ -1620,6 +1620,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"option_env_unwrap\",\n     },\n+    Lint {\n+        name: \"option_if_let_else\",\n+        group: \"style\",\n+        desc: \"reimplementation of Option::map_or\",\n+        deprecation: None,\n+        module: \"option_if_let_else\",\n+    },\n     Lint {\n         name: \"option_map_or_none\",\n         group: \"style\","}, {"sha": "3aa895120d1967d40b6953cbf5840a5246c33c5a", "filename": "tests/ui/option_if_let_else.fixed", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/bf48a2d50d82cccac58d7c4c73700eaf66926aee/tests%2Fui%2Foption_if_let_else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/bf48a2d50d82cccac58d7c4c73700eaf66926aee/tests%2Fui%2Foption_if_let_else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.fixed?ref=bf48a2d50d82cccac58d7c4c73700eaf66926aee", "patch": "@@ -0,0 +1,48 @@\n+// run-rustfix\n+#![warn(clippy::option_if_let_else)]\n+\n+fn bad1(string: Option<&str>) -> (bool, &str) {\n+    string.map_or((false, \"hello\"), |x| (true, x))\n+}\n+\n+fn longer_body(arg: Option<u32>) -> u32 {\n+    arg.map_or(13, |x| {\n+        let y = x * x;\n+        y * y\n+    })\n+}\n+\n+fn test_map_or_else(arg: Option<u32>) {\n+    let _ = arg.map_or_else(|| {\n+        let mut y = 1;\n+        y = (y + 2 / y) / 2;\n+        y = (y + 2 / y) / 2;\n+        y\n+    }, |x| x * x * x * x);\n+}\n+\n+fn negative_tests(arg: Option<u32>) -> u32 {\n+    let _ = if let Some(13) = arg { \"unlucky\" } else { \"lucky\" };\n+    for _ in 0..10 {\n+        let _ = if let Some(x) = arg {\n+            x\n+        } else {\n+            continue;\n+        };\n+    }\n+    let _ = if let Some(x) = arg {\n+        return x;\n+    } else {\n+        5\n+    };\n+    7\n+}\n+\n+fn main() {\n+    let optional = Some(5);\n+    let _ = optional.map_or(5, |x| x + 2);\n+    let _ = bad1(None);\n+    let _ = longer_body(None);\n+    test_map_or_else(None);\n+    let _ = negative_tests(None);\n+}"}, {"sha": "7d029b0bcf48ce2e9d8812947b3168d48b5a447a", "filename": "tests/ui/option_if_let_else.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bf48a2d50d82cccac58d7c4c73700eaf66926aee/tests%2Fui%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf48a2d50d82cccac58d7c4c73700eaf66926aee/tests%2Fui%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.rs?ref=bf48a2d50d82cccac58d7c4c73700eaf66926aee", "patch": "@@ -0,0 +1,56 @@\n+// run-rustfix\n+#![warn(clippy::option_if_let_else)]\n+\n+fn bad1(string: Option<&str>) -> (bool, &str) {\n+    if let Some(x) = string {\n+        (true, x)\n+    } else {\n+        (false, \"hello\")\n+    }\n+}\n+\n+fn longer_body(arg: Option<u32>) -> u32 {\n+    if let Some(x) = arg {\n+        let y = x * x;\n+        y * y\n+    } else {\n+        13\n+    }\n+}\n+\n+fn test_map_or_else(arg: Option<u32>) {\n+    let _ = if let Some(x) = arg {\n+        x * x * x * x\n+    } else {\n+        let mut y = 1;\n+        y = (y + 2 / y) / 2;\n+        y = (y + 2 / y) / 2;\n+        y\n+    };\n+}\n+\n+fn negative_tests(arg: Option<u32>) -> u32 {\n+    let _ = if let Some(13) = arg { \"unlucky\" } else { \"lucky\" };\n+    for _ in 0..10 {\n+        let _ = if let Some(x) = arg {\n+            x\n+        } else {\n+            continue;\n+        };\n+    }\n+    let _ = if let Some(x) = arg {\n+        return x;\n+    } else {\n+        5\n+    };\n+    7\n+}\n+\n+fn main() {\n+    let optional = Some(5);\n+    let _ = if let Some(x) = optional { x + 2 } else { 5 };\n+    let _ = bad1(None);\n+    let _ = longer_body(None);\n+    test_map_or_else(None);\n+    let _ = negative_tests(None);\n+}"}, {"sha": "d6cf083673341e9c3064a17254359de29054bbc6", "filename": "tests/ui/option_if_let_else.stderr", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/bf48a2d50d82cccac58d7c4c73700eaf66926aee/tests%2Fui%2Foption_if_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bf48a2d50d82cccac58d7c4c73700eaf66926aee/tests%2Fui%2Foption_if_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.stderr?ref=bf48a2d50d82cccac58d7c4c73700eaf66926aee", "patch": "@@ -0,0 +1,62 @@\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:5:5\n+   |\n+LL | /     if let Some(x) = string {\n+LL | |         (true, x)\n+LL | |     } else {\n+LL | |         (false, \"hello\")\n+LL | |     }\n+   | |_____^ help: try: `string.map_or((false, \"hello\"), |x| (true, x))`\n+   |\n+   = note: `-D clippy::option-if-let-else` implied by `-D warnings`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:13:5\n+   |\n+LL | /     if let Some(x) = arg {\n+LL | |         let y = x * x;\n+LL | |         y * y\n+LL | |     } else {\n+LL | |         13\n+LL | |     }\n+   | |_____^\n+   |\n+help: try\n+   |\n+LL |     arg.map_or(13, |x| {\n+LL |         let y = x * x;\n+LL |         y * y\n+LL |     })\n+   |\n+\n+error: use Option::map_or_else instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:22:13\n+   |\n+LL |       let _ = if let Some(x) = arg {\n+   |  _____________^\n+LL | |         x * x * x * x\n+LL | |     } else {\n+LL | |         let mut y = 1;\n+...  |\n+LL | |         y\n+LL | |     };\n+   | |_____^\n+   |\n+help: try\n+   |\n+LL |     let _ = arg.map_or_else(|| {\n+LL |         let mut y = 1;\n+LL |         y = (y + 2 / y) / 2;\n+LL |         y = (y + 2 / y) / 2;\n+LL |         y\n+LL |     }, |x| x * x * x * x);\n+   |\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:51:13\n+   |\n+LL |     let _ = if let Some(x) = optional { x + 2 } else { 5 };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `optional.map_or(5, |x| x + 2)`\n+\n+error: aborting due to 4 previous errors\n+"}]}