{"sha": "9861df47601cf6cb105d390db6c3a753dea7622e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4NjFkZjQ3NjAxY2Y2Y2IxMDVkMzkwZGI2YzNhNzUzZGVhNzYyMmU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-07-30T04:32:11Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-08-02T14:28:11Z"}, "message": "rustc_const_math: use apfloat::ieee::{Single,Double} in ConstFloat.", "tree": {"sha": "e90e559f38347e47da38de7af058d9117ef1098e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e90e559f38347e47da38de7af058d9117ef1098e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9861df47601cf6cb105d390db6c3a753dea7622e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9861df47601cf6cb105d390db6c3a753dea7622e", "html_url": "https://github.com/rust-lang/rust/commit/9861df47601cf6cb105d390db6c3a753dea7622e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9861df47601cf6cb105d390db6c3a753dea7622e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1409d205ad030743007d819374c6b3efa3570f64", "url": "https://api.github.com/repos/rust-lang/rust/commits/1409d205ad030743007d819374c6b3efa3570f64", "html_url": "https://github.com/rust-lang/rust/commit/1409d205ad030743007d819374c6b3efa3570f64"}], "stats": {"total": 324, "additions": 180, "deletions": 144}, "files": [{"sha": "6790c2ac7decec5e4887ef4a589e97b321a0d5b5", "filename": "src/librustc/ich/impls_const_math.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9861df47601cf6cb105d390db6c3a753dea7622e/src%2Flibrustc%2Fich%2Fimpls_const_math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9861df47601cf6cb105d390db6c3a753dea7622e/src%2Flibrustc%2Fich%2Fimpls_const_math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_const_math.rs?ref=9861df47601cf6cb105d390db6c3a753dea7622e", "patch": "@@ -11,9 +11,9 @@\n //! This module contains `HashStable` implementations for various data types\n //! from `rustc_const_math` in no particular order.\n \n-impl_stable_hash_for!(enum ::rustc_const_math::ConstFloat {\n-    F32(val),\n-    F64(val)\n+impl_stable_hash_for!(struct ::rustc_const_math::ConstFloat {\n+    ty,\n+    bits\n });\n \n impl_stable_hash_for!(enum ::rustc_const_math::ConstInt {"}, {"sha": "eb45fd9c0e0a44246c9fd8e558bac1aac050e9cd", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/9861df47601cf6cb105d390db6c3a753dea7622e/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9861df47601cf6cb105d390db6c3a753dea7622e/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=9861df47601cf6cb105d390db6c3a753dea7622e", "patch": "@@ -26,6 +26,7 @@ use rustc::util::nodemap::DefIdMap;\n \n use syntax::abi::Abi;\n use syntax::ast;\n+use syntax::attr;\n use rustc::hir::{self, Expr};\n use syntax_pos::Span;\n \n@@ -560,8 +561,15 @@ fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ty::TyUint(ast::UintTy::Us) => {\n             Ok(Integral(Usize(ConstUsize::new_truncating(v, tcx.sess.target.uint_type))))\n         },\n-        ty::TyFloat(ast::FloatTy::F64) => Ok(Float(F64(val.to_f64()))),\n-        ty::TyFloat(ast::FloatTy::F32) => Ok(Float(F32(val.to_f32()))),\n+        ty::TyFloat(fty) => {\n+            if let Some(i) = val.to_u128() {\n+                Ok(Float(ConstFloat::from_u128(i, fty)))\n+            } else {\n+                // The value must be negative, go through signed integers.\n+                let i = val.to_u128_unchecked() as i128;\n+                Ok(Float(ConstFloat::from_i128(i, fty)))\n+            }\n+        }\n         ty::TyRawPtr(_) => Err(ErrKind::UnimplementedConstVal(\"casting an address to a raw ptr\")),\n         ty::TyChar => match val {\n             U8(u) => Ok(Char(u as char)),\n@@ -574,30 +582,25 @@ fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn cast_const_float<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               val: ConstFloat,\n                               ty: Ty<'tcx>) -> CastResult<'tcx> {\n+    let int_width = |ty| {\n+        ty::layout::Integer::from_attr(tcx, ty).size().bits() as usize\n+    };\n     match ty.sty {\n-        ty::TyInt(_) | ty::TyUint(_) => {\n-            let i = match val {\n-                F32(f) if f >= 0.0 => U128(f as u128),\n-                F64(f) if f >= 0.0 => U128(f as u128),\n-\n-                F32(f) => I128(f as i128),\n-                F64(f) => I128(f as i128)\n-            };\n-\n-            if let (I128(_), &ty::TyUint(_)) = (i, &ty.sty) {\n-                return Err(CannotCast);\n+        ty::TyInt(ity) => {\n+            if let Some(i) = val.to_i128(int_width(attr::SignedInt(ity))) {\n+                cast_const_int(tcx, I128(i), ty)\n+            } else {\n+                Err(CannotCast)\n+            }\n+        }\n+        ty::TyUint(uty) => {\n+            if let Some(i) = val.to_u128(int_width(attr::UnsignedInt(uty))) {\n+                cast_const_int(tcx, U128(i), ty)\n+            } else {\n+                Err(CannotCast)\n             }\n-\n-            cast_const_int(tcx, i, ty)\n         }\n-        ty::TyFloat(ast::FloatTy::F64) => Ok(Float(F64(match val {\n-            F32(f) => f as f64,\n-            F64(f) => f\n-        }))),\n-        ty::TyFloat(ast::FloatTy::F32) => Ok(Float(F32(match val {\n-            F64(f) => f as f32,\n-            F32(f) => f\n-        }))),\n+        ty::TyFloat(fty) => Ok(Float(val.convert(fty))),\n         _ => Err(CannotCast),\n     }\n }\n@@ -691,11 +694,7 @@ fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n \n fn parse_float<'tcx>(num: &str, fty: ast::FloatTy)\n                      -> Result<ConstFloat, ErrKind<'tcx>> {\n-    let val = match fty {\n-        ast::FloatTy::F32 => num.parse::<f32>().map(F32),\n-        ast::FloatTy::F64 => num.parse::<f64>().map(F64)\n-    };\n-    val.map_err(|_| {\n+    ConstFloat::from_str(num, fty).map_err(|_| {\n         // FIXME(#31407) this is only necessary because float parsing is buggy\n         UnimplementedConstVal(\"could not evaluate float literal (see issue #31407)\")\n     })"}, {"sha": "719f6b6a7b3221965447d8370d5ae016e494586b", "filename": "src/librustc_const_math/float.rs", "status": "modified", "additions": 138, "deletions": 66, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/9861df47601cf6cb105d390db6c3a753dea7622e/src%2Flibrustc_const_math%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9861df47601cf6cb105d390db6c3a753dea7622e/src%2Flibrustc_const_math%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Ffloat.rs?ref=9861df47601cf6cb105d390db6c3a753dea7622e", "patch": "@@ -9,102 +9,164 @@\n // except according to those terms.\n \n use std::cmp::Ordering;\n-use std::hash;\n-use std::mem::transmute;\n+use std::num::ParseFloatError;\n+\n+use syntax::ast;\n+\n+use rustc_apfloat::{Float, FloatConvert, Status};\n+use rustc_apfloat::ieee::{Single, Double};\n \n use super::err::*;\n \n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n-pub enum ConstFloat {\n-    F32(f32),\n-    F64(f64)\n+// Note that equality for `ConstFloat` means that the it is the same\n+// constant, not that the rust values are equal. In particular, `NaN\n+// == NaN` (at least if it's the same NaN; distinct encodings for NaN\n+// are considering unequal).\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub struct ConstFloat {\n+    pub ty: ast::FloatTy,\n+\n+    // This is a bit inefficient but it makes conversions below more\n+    // ergonomic, and all of this will go away once `miri` is merged.\n+    pub bits: u128,\n }\n-pub use self::ConstFloat::*;\n \n impl ConstFloat {\n     /// Description of the type, not the value\n     pub fn description(&self) -> &'static str {\n-        match *self {\n-            F32(_) => \"f32\",\n-            F64(_) => \"f64\",\n-        }\n+        self.ty.ty_to_string()\n     }\n \n     pub fn is_nan(&self) -> bool {\n-        match *self {\n-            F32(f) => f.is_nan(),\n-            F64(f) => f.is_nan(),\n+        match self.ty {\n+            ast::FloatTy::F32 => Single::from_bits(self.bits).is_nan(),\n+            ast::FloatTy::F64 => Double::from_bits(self.bits).is_nan(),\n         }\n     }\n \n     /// Compares the values if they are of the same type\n     pub fn try_cmp(self, rhs: Self) -> Result<Ordering, ConstMathErr> {\n-        match (self, rhs) {\n-            (F64(a), F64(b))  => {\n+        match (self.ty, rhs.ty) {\n+            (ast::FloatTy::F64, ast::FloatTy::F64)  => {\n+                let a = Double::from_bits(self.bits);\n+                let b = Double::from_bits(rhs.bits);\n                 // This is pretty bad but it is the existing behavior.\n-                Ok(if a == b {\n-                    Ordering::Equal\n-                } else if a < b {\n-                    Ordering::Less\n-                } else {\n-                    Ordering::Greater\n-                })\n+                Ok(a.partial_cmp(&b).unwrap_or(Ordering::Greater))\n             }\n \n-            (F32(a), F32(b)) => {\n-                Ok(if a == b {\n-                    Ordering::Equal\n-                } else if a < b {\n-                    Ordering::Less\n-                } else {\n-                    Ordering::Greater\n-                })\n+            (ast::FloatTy::F32, ast::FloatTy::F32) => {\n+                let a = Single::from_bits(self.bits);\n+                let b = Single::from_bits(rhs.bits);\n+                Ok(a.partial_cmp(&b).unwrap_or(Ordering::Greater))\n             }\n \n             _ => Err(CmpBetweenUnequalTypes),\n         }\n     }\n-}\n \n-/// Note that equality for `ConstFloat` means that the it is the same\n-/// constant, not that the rust values are equal. In particular, `NaN\n-/// == NaN` (at least if it's the same NaN; distinct encodings for NaN\n-/// are considering unequal).\n-impl PartialEq for ConstFloat {\n-    fn eq(&self, other: &Self) -> bool {\n-        match (*self, *other) {\n-            (F64(a), F64(b)) => {\n-                unsafe{transmute::<_,u64>(a) == transmute::<_,u64>(b)}\n+    pub fn from_i128(input: i128, ty: ast::FloatTy) -> Self {\n+        let bits = match ty {\n+            ast::FloatTy::F32 => Single::from_i128(input).value.to_bits(),\n+            ast::FloatTy::F64 => Double::from_i128(input).value.to_bits()\n+        };\n+        ConstFloat { bits, ty }\n+    }\n+\n+    pub fn from_u128(input: u128, ty: ast::FloatTy) -> Self {\n+        let bits = match ty {\n+            ast::FloatTy::F32 => Single::from_u128(input).value.to_bits(),\n+            ast::FloatTy::F64 => Double::from_u128(input).value.to_bits()\n+        };\n+        ConstFloat { bits, ty }\n+    }\n+\n+    pub fn from_str(num: &str, ty: ast::FloatTy) -> Result<Self, ParseFloatError> {\n+        let bits = match ty {\n+            ast::FloatTy::F32 => {\n+                let rust_bits = num.parse::<f32>()?.to_bits() as u128;\n+                let apfloat = num.parse::<Single>().unwrap_or_else(|e| {\n+                    panic!(\"apfloat::ieee::Single failed to parse `{}`: {:?}\", num, e);\n+                });\n+                let apfloat_bits = apfloat.to_bits();\n+                assert!(rust_bits == apfloat_bits,\n+                    \"apfloat::ieee::Single gave different result for `{}`: \\\n+                     {}({:#x}) vs Rust's {}({:#x})\",\n+                    num, apfloat, apfloat_bits,\n+                    Single::from_bits(rust_bits), rust_bits);\n+                apfloat_bits\n             }\n-            (F32(a), F32(b)) => {\n-                unsafe{transmute::<_,u32>(a) == transmute::<_,u32>(b)}\n+            ast::FloatTy::F64 => {\n+                let rust_bits = num.parse::<f64>()?.to_bits() as u128;\n+                let apfloat = num.parse::<Double>().unwrap_or_else(|e| {\n+                    panic!(\"apfloat::ieee::Double failed to parse `{}`: {:?}\", num, e);\n+                });\n+                let apfloat_bits = apfloat.to_bits();\n+                assert!(rust_bits == apfloat_bits,\n+                    \"apfloat::ieee::Double gave different result for `{}`: \\\n+                     {}({:#x}) vs Rust's {}({:#x})\",\n+                    num, apfloat, apfloat_bits,\n+                    Double::from_bits(rust_bits), rust_bits);\n+                apfloat_bits\n             }\n-            _ => false\n+        };\n+        Ok(ConstFloat { bits, ty })\n+    }\n+\n+    pub fn to_i128(self, width: usize) -> Option<i128> {\n+        assert!(width <= 128);\n+        let r = match self.ty {\n+            ast::FloatTy::F32 => Single::from_bits(self.bits).to_i128(width),\n+            ast::FloatTy::F64 => Double::from_bits(self.bits).to_i128(width)\n+        };\n+        if r.status.intersects(Status::INVALID_OP) {\n+            None\n+        } else {\n+            Some(r.value)\n         }\n     }\n-}\n \n-impl Eq for ConstFloat {}\n+    pub fn to_u128(self, width: usize) -> Option<u128> {\n+        assert!(width <= 128);\n+        let r = match self.ty {\n+            ast::FloatTy::F32 => Single::from_bits(self.bits).to_u128(width),\n+            ast::FloatTy::F64 => Double::from_bits(self.bits).to_u128(width)\n+        };\n+        if r.status.intersects(Status::INVALID_OP) {\n+            None\n+        } else {\n+            Some(r.value)\n+        }\n+    }\n \n-impl hash::Hash for ConstFloat {\n-    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n-        match *self {\n-            F64(a) => {\n-                unsafe { transmute::<_,u64>(a) }.hash(state)\n+    pub fn convert(self, to: ast::FloatTy) -> Self {\n+        let bits = match (self.ty, to) {\n+            (ast::FloatTy::F32, ast::FloatTy::F32) |\n+            (ast::FloatTy::F64, ast::FloatTy::F64) => return self,\n+\n+            (ast::FloatTy::F32, ast::FloatTy::F64) => {\n+                Double::to_bits(Single::from_bits(self.bits).convert(&mut false).value)\n             }\n-            F32(a) => {\n-                unsafe { transmute::<_,u32>(a) }.hash(state)\n+            (ast::FloatTy::F64, ast::FloatTy::F32) => {\n+                Single::to_bits(Double::from_bits(self.bits).convert(&mut false).value)\n             }\n-        }\n+        };\n+        ConstFloat { bits, ty: to }\n     }\n }\n \n impl ::std::fmt::Display for ConstFloat {\n     fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n-        match *self {\n-            F32(f) => write!(fmt, \"{}f32\", f),\n-            F64(f) => write!(fmt, \"{}f64\", f),\n+        match self.ty {\n+            ast::FloatTy::F32 => write!(fmt, \"{:#}\", Single::from_bits(self.bits))?,\n+            ast::FloatTy::F64 => write!(fmt, \"{:#}\", Double::from_bits(self.bits))?,\n         }\n+        write!(fmt, \"{}\", self.ty)\n+    }\n+}\n+\n+impl ::std::fmt::Debug for ConstFloat {\n+    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n+        ::std::fmt::Display::fmt(self, fmt)\n     }\n }\n \n@@ -113,11 +175,20 @@ macro_rules! derive_binop {\n         impl ::std::ops::$op for ConstFloat {\n             type Output = Result<Self, ConstMathErr>;\n             fn $func(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-                match (self, rhs) {\n-                    (F32(a), F32(b)) => Ok(F32(a.$func(b))),\n-                    (F64(a), F64(b)) => Ok(F64(a.$func(b))),\n-                    _ => Err(UnequalTypes(Op::$op)),\n-                }\n+                let bits = match (self.ty, rhs.ty) {\n+                    (ast::FloatTy::F32, ast::FloatTy::F32) =>{\n+                        let a = Single::from_bits(self.bits);\n+                        let b = Single::from_bits(rhs.bits);\n+                        a.$func(b).value.to_bits()\n+                    }\n+                    (ast::FloatTy::F64, ast::FloatTy::F64) => {\n+                        let a = Double::from_bits(self.bits);\n+                        let b = Double::from_bits(rhs.bits);\n+                        a.$func(b).value.to_bits()\n+                    }\n+                    _ => return Err(UnequalTypes(Op::$op)),\n+                };\n+                Ok(ConstFloat { bits, ty: self.ty })\n             }\n         }\n     }\n@@ -132,9 +203,10 @@ derive_binop!(Rem, rem);\n impl ::std::ops::Neg for ConstFloat {\n     type Output = Self;\n     fn neg(self) -> Self {\n-        match self {\n-            F32(f) => F32(-f),\n-            F64(f) => F64(-f),\n-        }\n+        let bits = match self.ty {\n+            ast::FloatTy::F32 => (-Single::from_bits(self.bits)).to_bits(),\n+            ast::FloatTy::F64 => (-Double::from_bits(self.bits)).to_bits(),\n+        };\n+        ConstFloat { bits, ty: self.ty }\n     }\n }"}, {"sha": "65471416e8007465ed3ad229f2a3fb1a910440e0", "filename": "src/librustc_const_math/int.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9861df47601cf6cb105d390db6c3a753dea7622e/src%2Flibrustc_const_math%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9861df47601cf6cb105d390db6c3a753dea7622e/src%2Flibrustc_const_math%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fint.rs?ref=9861df47601cf6cb105d390db6c3a753dea7622e", "patch": "@@ -211,48 +211,6 @@ impl ConstInt {\n         }\n     }\n \n-    pub fn to_f32(self) -> f32 {\n-        match self {\n-            I8(i) => i as f32,\n-            I16(i) => i as f32,\n-            I32(i) => i as f32,\n-            I64(i) => i as f32,\n-            I128(i) => i as f32,\n-            Isize(Is16(i)) => i as f32,\n-            Isize(Is32(i)) => i as f32,\n-            Isize(Is64(i)) => i as f32,\n-            U8(i) => i as f32,\n-            U16(i) => i as f32,\n-            U32(i) => i as f32,\n-            U64(i) => i as f32,\n-            U128(i) => i as f32,\n-            Usize(Us16(i)) => i as f32,\n-            Usize(Us32(i)) => i as f32,\n-            Usize(Us64(i)) => i as f32,\n-        }\n-    }\n-\n-    pub fn to_f64(self) -> f64 {\n-        match self {\n-            I8(i) => i as f64,\n-            I16(i) => i as f64,\n-            I32(i) => i as f64,\n-            I64(i) => i as f64,\n-            I128(i) => i as f64,\n-            Isize(Is16(i)) => i as f64,\n-            Isize(Is32(i)) => i as f64,\n-            Isize(Is64(i)) => i as f64,\n-            U8(i) => i as f64,\n-            U16(i) => i as f64,\n-            U32(i) => i as f64,\n-            U64(i) => i as f64,\n-            U128(i) => i as f64,\n-            Usize(Us16(i)) => i as f64,\n-            Usize(Us32(i)) => i as f64,\n-            Usize(Us64(i)) => i as f64,\n-        }\n-    }\n-\n     pub fn is_negative(&self) -> bool {\n         match *self {\n             I8(v) => v < 0,"}, {"sha": "3947edecb5aff20215fe82888e3e4534b5660ce4", "filename": "src/librustc_const_math/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9861df47601cf6cb105d390db6c3a753dea7622e/src%2Flibrustc_const_math%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9861df47601cf6cb105d390db6c3a753dea7622e/src%2Flibrustc_const_math%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Flib.rs?ref=9861df47601cf6cb105d390db6c3a753dea7622e", "patch": "@@ -26,6 +26,8 @@\n #![feature(i128)]\n #![feature(i128_type)]\n \n+extern crate rustc_apfloat;\n+\n extern crate syntax;\n \n extern crate serialize as rustc_serialize; // used by deriving"}, {"sha": "7ece5a42ca19e18b06470853b8b3fcd2164d09d9", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9861df47601cf6cb105d390db6c3a753dea7622e/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9861df47601cf6cb105d390db6c3a753dea7622e/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=9861df47601cf6cb105d390db6c3a753dea7622e", "patch": "@@ -11,7 +11,7 @@\n use llvm::{self, ValueRef};\n use rustc::middle::const_val::{ConstEvalErr, ConstVal, ErrKind};\n use rustc_const_math::ConstInt::*;\n-use rustc_const_math::ConstFloat::*;\n+use rustc_const_math::ConstFloat;\n use rustc_const_math::{ConstInt, ConstMathErr};\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n@@ -95,8 +95,13 @@ impl<'tcx> Const<'tcx> {\n                              -> Const<'tcx> {\n         let llty = type_of::type_of(ccx, ty);\n         let val = match cv {\n-            ConstVal::Float(F32(v)) => C_floating_f64(v as f64, llty),\n-            ConstVal::Float(F64(v)) => C_floating_f64(v, llty),\n+            ConstVal::Float(v) => {\n+                let v_f64 = match v {\n+                    ConstFloat::F32(v) => f32::from_bits(v) as f64,\n+                    ConstFloat::F64(v) => f64::from_bits(v)\n+                };\n+                C_floating_f64(v_f64, llty)\n+            }\n             ConstVal::Bool(v) => C_bool(ccx, v),\n             ConstVal::Integral(ref i) => return Const::from_constint(ccx, i),\n             ConstVal::Str(ref v) => C_str_slice(ccx, v.clone()),"}, {"sha": "81dd1932894fb326e944e6af5c035d9616fe38e4", "filename": "src/test/mir-opt/deaggregator_test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9861df47601cf6cb105d390db6c3a753dea7622e/src%2Ftest%2Fmir-opt%2Fdeaggregator_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9861df47601cf6cb105d390db6c3a753dea7622e/src%2Ftest%2Fmir-opt%2Fdeaggregator_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdeaggregator_test.rs?ref=9861df47601cf6cb105d390db6c3a753dea7622e", "patch": "@@ -25,7 +25,7 @@ fn main() {}\n // bb0: {\n //     _2 = _1;\n //     _3 = _2;\n-//     _0 = Baz { x: _3, y: const F32(0), z: const false };\n+//     _0 = Baz { x: _3, y: const 0f32, z: const false };\n //     return;\n // }\n // END rustc.node13.Deaggregator.before.mir\n@@ -34,7 +34,7 @@ fn main() {}\n //     _2 = _1;\n //     _3 = _2;\n //     (_0.0: usize) = _3;\n-//     (_0.1: f32) = const F32(0);\n+//     (_0.1: f32) = const 0f32;\n //     (_0.2: bool) = const false;\n //     return;\n // }"}]}