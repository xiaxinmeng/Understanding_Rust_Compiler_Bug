{"sha": "fd4f15ea6b04fcacc8c8446c5d725c25daab0624", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkNGYxNWVhNmIwNGZjYWNjOGM4NDQ2YzVkNzI1YzI1ZGFhYjA2MjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-28T18:21:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-28T18:21:47Z"}, "message": "auto merge of #13131 : alexcrichton/rust/issue-13124, r=brson\n\nIt turns out that on linux, and possibly other platforms, child processes will\r\ncontinue to accept signals until they have been *reaped*. This means that once\r\nthe child has exited, it will succeed to receive signals until waitpid() has\r\nbeen invoked on it.\r\n\r\nThis is unfortunate behavior, and differs from what is seen on OSX and windows.\r\nThis commit changes the behavior of Process::signal() to be the same across\r\nplatforms, and updates the documentation of Process::kill() to note that when\r\nsignaling a foreign process it may accept signals until reaped.\r\n\r\nImplementation-wise, this invokes waitpid() with WNOHANG before each signal to\r\nthe child to ensure that if the child has exited that we will reap it. Other\r\npossibilities include installing a SIGCHLD signal handler, but at this time I\r\nbelieve that that's too complicated.\r\n\r\nCloses #13124", "tree": {"sha": "c77eb7ce115419a982d6f32f692b26f080b68ee9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c77eb7ce115419a982d6f32f692b26f080b68ee9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd4f15ea6b04fcacc8c8446c5d725c25daab0624", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd4f15ea6b04fcacc8c8446c5d725c25daab0624", "html_url": "https://github.com/rust-lang/rust/commit/fd4f15ea6b04fcacc8c8446c5d725c25daab0624", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd4f15ea6b04fcacc8c8446c5d725c25daab0624/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8601a3d8b91ad3b653d143307611f2f5c75617e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8601a3d8b91ad3b653d143307611f2f5c75617e", "html_url": "https://github.com/rust-lang/rust/commit/b8601a3d8b91ad3b653d143307611f2f5c75617e"}, {"sha": "0e190b9a4ad92645e8f63c72c66cc89a596f1971", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e190b9a4ad92645e8f63c72c66cc89a596f1971", "html_url": "https://github.com/rust-lang/rust/commit/0e190b9a4ad92645e8f63c72c66cc89a596f1971"}], "stats": {"total": 161, "additions": 116, "deletions": 45}, "files": [{"sha": "463f9f8bedded3e1063e68319a63377860118d19", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 58, "deletions": 23, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/fd4f15ea6b04fcacc8c8446c5d725c25daab0624/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd4f15ea6b04fcacc8c8446c5d725c25daab0624/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=fd4f15ea6b04fcacc8c8446c5d725c25daab0624", "patch": "@@ -134,6 +134,18 @@ impl rtio::RtioProcess for Process {\n     }\n \n     fn kill(&mut self, signum: int) -> Result<(), io::IoError> {\n+        // On linux (and possibly other unices), a process that has exited will\n+        // continue to accept signals because it is \"defunct\". The delivery of\n+        // signals will only fail once the child has been reaped. For this\n+        // reason, if the process hasn't exited yet, then we attempt to collect\n+        // their status with WNOHANG.\n+        if self.exit_code.is_none() {\n+            match waitpid_nowait(self.pid) {\n+                Some(code) => { self.exit_code = Some(code); }\n+                None => {}\n+            }\n+        }\n+\n         // if the process has finished, and therefore had waitpid called,\n         // and we kill it, then on unix we might ending up killing a\n         // newer process that happens to have the same (re-used) id\n@@ -662,6 +674,31 @@ fn free_handle(_handle: *()) {\n     // unix has no process handle object, just a pid\n }\n \n+#[cfg(unix)]\n+fn translate_status(status: c_int) -> p::ProcessExit {\n+    #[cfg(target_os = \"linux\")]\n+    #[cfg(target_os = \"android\")]\n+    mod imp {\n+        pub fn WIFEXITED(status: i32) -> bool { (status & 0xff) == 0 }\n+        pub fn WEXITSTATUS(status: i32) -> i32 { (status >> 8) & 0xff }\n+        pub fn WTERMSIG(status: i32) -> i32 { status & 0x7f }\n+    }\n+\n+    #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n+    mod imp {\n+        pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }\n+        pub fn WEXITSTATUS(status: i32) -> i32 { status >> 8 }\n+        pub fn WTERMSIG(status: i32) -> i32 { status & 0o177 }\n+    }\n+\n+    if imp::WIFEXITED(status) {\n+        p::ExitStatus(imp::WEXITSTATUS(status) as int)\n+    } else {\n+        p::ExitSignal(imp::WTERMSIG(status) as int)\n+    }\n+}\n+\n /**\n  * Waits for a process to exit and returns the exit code, failing\n  * if there is no process with the specified id.\n@@ -723,33 +760,31 @@ fn waitpid(pid: pid_t) -> p::ProcessExit {\n     #[cfg(unix)]\n     fn waitpid_os(pid: pid_t) -> p::ProcessExit {\n         use std::libc::funcs::posix01::wait;\n-\n-        #[cfg(target_os = \"linux\")]\n-        #[cfg(target_os = \"android\")]\n-        mod imp {\n-            pub fn WIFEXITED(status: i32) -> bool { (status & 0xff) == 0 }\n-            pub fn WEXITSTATUS(status: i32) -> i32 { (status >> 8) & 0xff }\n-            pub fn WTERMSIG(status: i32) -> i32 { status & 0x7f }\n+        let mut status = 0 as c_int;\n+        match retry(|| unsafe { wait::waitpid(pid, &mut status, 0) }) {\n+            -1 => fail!(\"unknown waitpid error: {}\", super::last_error()),\n+            _ => translate_status(status),\n         }\n+    }\n+}\n \n-        #[cfg(target_os = \"macos\")]\n-        #[cfg(target_os = \"freebsd\")]\n-        mod imp {\n-            pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }\n-            pub fn WEXITSTATUS(status: i32) -> i32 { status >> 8 }\n-            pub fn WTERMSIG(status: i32) -> i32 { status & 0o177 }\n-        }\n+fn waitpid_nowait(pid: pid_t) -> Option<p::ProcessExit> {\n+    return waitpid_os(pid);\n \n+    // This code path isn't necessary on windows\n+    #[cfg(windows)]\n+    fn waitpid_os(_pid: pid_t) -> Option<p::ProcessExit> { None }\n+\n+    #[cfg(unix)]\n+    fn waitpid_os(pid: pid_t) -> Option<p::ProcessExit> {\n+        use std::libc::funcs::posix01::wait;\n         let mut status = 0 as c_int;\n-        match retry(|| unsafe { wait::waitpid(pid, &mut status, 0) }) {\n-            -1 => fail!(\"unknown waitpid error: {}\", super::last_error()),\n-            _ => {\n-                if imp::WIFEXITED(status) {\n-                    p::ExitStatus(imp::WEXITSTATUS(status) as int)\n-                } else {\n-                    p::ExitSignal(imp::WTERMSIG(status) as int)\n-                }\n-            }\n+        match retry(|| unsafe {\n+            wait::waitpid(pid, &mut status, libc::WNOHANG)\n+        }) {\n+            n if n == pid => Some(translate_status(status)),\n+            0 => None,\n+            n => fail!(\"unknown waitpid error `{}`: {}\", n, super::last_error()),\n         }\n     }\n }"}, {"sha": "4f4d2d793f6b0321ba4e28e68b6d6512610a17bd", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fd4f15ea6b04fcacc8c8446c5d725c25daab0624/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd4f15ea6b04fcacc8c8446c5d725c25daab0624/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=fd4f15ea6b04fcacc8c8446c5d725c25daab0624", "patch": "@@ -331,7 +331,9 @@ impl Process {\n     /// signals (SIGTERM/SIGKILL/SIGINT) are translated to `TerminateProcess`.\n     ///\n     /// Additionally, a signal number of 0 can check for existence of the target\n-    /// process.\n+    /// process. Note, though, that on some platforms signals will continue to\n+    /// be successfully delivered if the child has exited, but not yet been\n+    /// reaped.\n     pub fn kill(id: libc::pid_t, signal: int) -> IoResult<()> {\n         LocalIo::maybe_raise(|io| io.kill(id, signal))\n     }\n@@ -342,8 +344,16 @@ impl Process {\n     /// Sends the specified signal to the child process, returning whether the\n     /// signal could be delivered or not.\n     ///\n-    /// Note that this is purely a wrapper around libuv's `uv_process_kill`\n-    /// function.\n+    /// Note that signal 0 is interpreted as a poll to check whether the child\n+    /// process is still alive or not. If an error is returned, then the child\n+    /// process has exited.\n+    ///\n+    /// On some unix platforms signals will continue to be received after a\n+    /// child has exited but not yet been reaped. In order to report the status\n+    /// of signal delivery correctly, unix implementations may invoke\n+    /// `waitpid()` with `WNOHANG` in order to reap the child as necessary.\n+    ///\n+    /// # Errors\n     ///\n     /// If the signal delivery fails, the corresponding error is returned.\n     pub fn signal(&mut self, signal: int) -> IoResult<()> {\n@@ -833,4 +843,17 @@ mod tests {\n         p.signal_kill().unwrap();\n         assert!(!p.wait().success());\n     })\n+\n+    iotest!(fn test_zero() {\n+        let mut p = sleeper();\n+        p.signal_kill().unwrap();\n+        for _ in range(0, 20) {\n+            if p.signal(0).is_err() {\n+                assert!(!p.wait().success());\n+                return\n+            }\n+            timer::sleep(100);\n+        }\n+        fail!(\"never saw the child go away\");\n+    })\n }"}, {"sha": "972002fe34e231b229891bfd08929bf1ed56fc9a", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd4f15ea6b04fcacc8c8446c5d725c25daab0624/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd4f15ea6b04fcacc8c8446c5d725c25daab0624/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=fd4f15ea6b04fcacc8c8446c5d725c25daab0624", "patch": "@@ -2356,6 +2356,8 @@ pub mod consts {\n \n             pub static CLOCK_REALTIME: c_int = 0;\n             pub static CLOCK_MONOTONIC: c_int = 1;\n+\n+            pub static WNOHANG: c_int = 1;\n         }\n         pub mod posix08 {\n         }\n@@ -2802,6 +2804,8 @@ pub mod consts {\n \n             pub static CLOCK_REALTIME: c_int = 0;\n             pub static CLOCK_MONOTONIC: c_int = 4;\n+\n+            pub static WNOHANG: c_int = 1;\n         }\n         pub mod posix08 {\n         }\n@@ -3187,6 +3191,8 @@ pub mod consts {\n             pub static PTHREAD_CREATE_JOINABLE: c_int = 1;\n             pub static PTHREAD_CREATE_DETACHED: c_int = 2;\n             pub static PTHREAD_STACK_MIN: size_t = 8192;\n+\n+            pub static WNOHANG: c_int = 1;\n         }\n         pub mod posix08 {\n         }"}, {"sha": "83232b408731d514c62d11c56af59e823ceb20f9", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fd4f15ea6b04fcacc8c8446c5d725c25daab0624/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd4f15ea6b04fcacc8c8446c5d725c25daab0624/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=fd4f15ea6b04fcacc8c8446c5d725c25daab0624", "patch": "@@ -22,6 +22,12 @@ extern crate native;\n extern crate green;\n extern crate rustuv;\n \n+use std::io::Process;\n+\n+macro_rules! succeed( ($e:expr) => (\n+    match $e { Ok(..) => {}, Err(e) => fail!(\"failure: {}\", e) }\n+) )\n+\n macro_rules! iotest (\n     { fn $name:ident() $b:block $($a:attr)* } => (\n         mod $name {\n@@ -53,28 +59,29 @@ fn start(argc: int, argv: **u8) -> int {\n }\n \n iotest!(fn test_destroy_once() {\n-    #[cfg(not(target_os=\"android\"))]\n-    static mut PROG: &'static str = \"echo\";\n-\n-    #[cfg(target_os=\"android\")]\n-    static mut PROG: &'static str = \"ls\"; // android don't have echo binary\n-\n-    let mut p = unsafe {Process::new(PROG, []).unwrap()};\n-    p.signal_exit().unwrap(); // this shouldn't crash (and nor should the destructor)\n+    let mut p = sleeper();\n+    match p.signal_exit() {\n+        Ok(()) => {}\n+        Err(e) => fail!(\"error: {}\", e),\n+    }\n })\n \n+#[cfg(unix)]\n+pub fn sleeper() -> Process {\n+    Process::new(\"sleep\", [~\"1000\"]).unwrap()\n+}\n+#[cfg(windows)]\n+pub fn sleeper() -> Process {\n+    // There's a `timeout` command on windows, but it doesn't like having\n+    // its output piped, so instead just ping ourselves a few times with\n+    // gaps inbetweeen so we're sure this process is alive for awhile\n+    Process::new(\"ping\", [~\"127.0.0.1\", ~\"-n\", ~\"1000\"]).unwrap()\n+}\n+\n iotest!(fn test_destroy_twice() {\n-    #[cfg(not(target_os=\"android\"))]\n-    static mut PROG: &'static str = \"echo\";\n-    #[cfg(target_os=\"android\")]\n-    static mut PROG: &'static str = \"ls\"; // android don't have echo binary\n-\n-    let mut p = match unsafe{Process::new(PROG, [])} {\n-        Ok(p) => p,\n-        Err(e) => fail!(\"wut: {}\", e),\n-    };\n-    p.signal_exit().unwrap(); // this shouldnt crash...\n-    p.signal_exit().unwrap(); // ...and nor should this (and nor should the destructor)\n+    let mut p = sleeper();\n+    succeed!(p.signal_exit()); // this shouldnt crash...\n+    let _ = p.signal_exit(); // ...and nor should this (and nor should the destructor)\n })\n \n pub fn test_destroy_actually_kills(force: bool) {"}]}