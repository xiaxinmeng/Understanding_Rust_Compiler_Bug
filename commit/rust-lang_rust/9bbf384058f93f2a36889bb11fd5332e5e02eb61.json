{"sha": "9bbf384058f93f2a36889bb11fd5332e5e02eb61", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliYmYzODQwNThmOTNmMmEzNjg4OWJiMTFmZDUzMzJlNWUwMmViNjE=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-03-30T18:08:57Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-03-30T18:08:57Z"}, "message": "std: clean up the json pretty printer tests", "tree": {"sha": "4983409487f901f840f616facebb6f3e156ed041", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4983409487f901f840f616facebb6f3e156ed041"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bbf384058f93f2a36889bb11fd5332e5e02eb61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bbf384058f93f2a36889bb11fd5332e5e02eb61", "html_url": "https://github.com/rust-lang/rust/commit/9bbf384058f93f2a36889bb11fd5332e5e02eb61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bbf384058f93f2a36889bb11fd5332e5e02eb61/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "909d8f0eacf38ce11949365c75fae6e5a159a4e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/909d8f0eacf38ce11949365c75fae6e5a159a4e1", "html_url": "https://github.com/rust-lang/rust/commit/909d8f0eacf38ce11949365c75fae6e5a159a4e1"}], "stats": {"total": 159, "additions": 71, "deletions": 88}, "files": [{"sha": "d6606981b1b6adf5fc517be29f81d8f027218566", "filename": "src/libstd/json.rs", "status": "modified", "additions": 71, "deletions": 88, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/9bbf384058f93f2a36889bb11fd5332e5e02eb61/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bbf384058f93f2a36889bb11fd5332e5e02eb61/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=9bbf384058f93f2a36889bb11fd5332e5e02eb61", "patch": "@@ -1165,6 +1165,14 @@ mod tests {\n \n     use std::serialize::Decodable;\n \n+    #[auto_encode]\n+    #[auto_decode]\n+    #[deriving(Eq)]\n+    enum Animal {\n+        Dog,\n+        Frog(~str, int)\n+    }\n+\n     fn mk_object(items: &[(~str, Json)]) -> Json {\n         let mut d = ~LinearMap::new();\n \n@@ -1180,49 +1188,62 @@ mod tests {\n     #[test]\n     fn test_write_null() {\n         assert_eq!(to_str(&Null), ~\"null\");\n+        assert_eq!(to_pretty_str(&Null), ~\"null\");\n     }\n \n+\n     #[test]\n     fn test_write_number() {\n         assert_eq!(to_str(&Number(3f)), ~\"3\");\n+        assert_eq!(to_pretty_str(&Number(3f)), ~\"3\");\n+\n         assert_eq!(to_str(&Number(3.1f)), ~\"3.1\");\n+        assert_eq!(to_pretty_str(&Number(3.1f)), ~\"3.1\");\n+\n         assert_eq!(to_str(&Number(-1.5f)), ~\"-1.5\");\n+        assert_eq!(to_pretty_str(&Number(-1.5f)), ~\"-1.5\");\n+\n         assert_eq!(to_str(&Number(0.5f)), ~\"0.5\");\n+        assert_eq!(to_pretty_str(&Number(0.5f)), ~\"0.5\");\n     }\n \n     #[test]\n     fn test_write_str() {\n         assert_eq!(to_str(&String(~\"\")), ~\"\\\"\\\"\");\n+        assert_eq!(to_pretty_str(&String(~\"\")), ~\"\\\"\\\"\");\n+\n         assert_eq!(to_str(&String(~\"foo\")), ~\"\\\"foo\\\"\");\n+        assert_eq!(to_pretty_str(&String(~\"foo\")), ~\"\\\"foo\\\"\");\n     }\n \n     #[test]\n     fn test_write_bool() {\n         assert_eq!(to_str(&Boolean(true)), ~\"true\");\n+        assert_eq!(to_pretty_str(&Boolean(true)), ~\"true\");\n+\n         assert_eq!(to_str(&Boolean(false)), ~\"false\");\n+        assert_eq!(to_pretty_str(&Boolean(false)), ~\"false\");\n     }\n \n     #[test]\n     fn test_write_list() {\n         assert_eq!(to_str(&List(~[])), ~\"[]\");\n-        assert_eq!(to_str(&List(~[Boolean(true)])), ~\"[true]\");\n-        assert_eq!(to_str(&List(~[\n-            Boolean(false),\n-            Null,\n-            List(~[String(~\"foo\\nbar\"), Number(3.5f)])\n-        ])), ~\"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n-    }\n-\n-    #[test]\n-    fn test_write_list_pretty() {\n         assert_eq!(to_pretty_str(&List(~[])), ~\"[]\");\n+\n+        assert_eq!(to_str(&List(~[Boolean(true)])), ~\"[true]\");\n         assert_eq!(\n             to_pretty_str(&List(~[Boolean(true)])),\n             ~\"\\\n             [\\n  \\\n                 true\\n\\\n             ]\"\n         );\n+\n+        assert_eq!(to_str(&List(~[\n+            Boolean(false),\n+            Null,\n+            List(~[String(~\"foo\\nbar\"), Number(3.5f)])\n+        ])), ~\"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n         assert_eq!(\n             to_pretty_str(&List(~[\n                 Boolean(false),\n@@ -1244,10 +1265,20 @@ mod tests {\n     #[test]\n     fn test_write_object() {\n         assert_eq!(to_str(&mk_object(~[])), ~\"{}\");\n+        assert_eq!(to_pretty_str(&mk_object(~[])), ~\"{}\");\n+\n         assert_eq!(\n             to_str(&mk_object(~[(~\"a\", Boolean(true))])),\n             ~\"{\\\"a\\\":true}\"\n         );\n+        assert_eq!(\n+            to_pretty_str(&mk_object(~[(~\"a\", Boolean(true))])),\n+            ~\"\\\n+            {\\n  \\\n+                \\\"a\\\": true\\n\\\n+            }\"\n+        );\n+\n         assert_eq!(\n             to_str(&mk_object(~[\n                 (~\"b\", List(~[\n@@ -1262,29 +1293,6 @@ mod tests {\n                 ]\\\n             }\"\n         );\n-        let a = mk_object(~[\n-            (~\"a\", Boolean(true)),\n-            (~\"b\", List(~[\n-                mk_object(~[(~\"c\", String(~\"\\x0c\\r\"))]),\n-                mk_object(~[(~\"d\", String(~\"\"))])\n-            ]))\n-        ]);\n-        // We can't compare the strings directly because the object fields be\n-        // printed in a different order.\n-        let b = from_str(to_str(&a)).unwrap();\n-        assert_eq!(a, b);\n-    }\n-\n-    #[test]\n-    fn test_write_object_pretty() {\n-        assert_eq!(to_pretty_str(&mk_object(~[])), ~\"{}\");\n-        assert_eq!(\n-            to_pretty_str(&mk_object(~[(~\"a\", Boolean(true))])),\n-            ~\"\\\n-            {\\n  \\\n-                \\\"a\\\": true\\n\\\n-            }\"\n-        );\n         assert_eq!(\n             to_pretty_str(&mk_object(~[\n                 (~\"b\", List(~[\n@@ -1304,70 +1312,52 @@ mod tests {\n                 ]\\n\\\n             }\"\n         );\n+\n         let a = mk_object(~[\n             (~\"a\", Boolean(true)),\n             (~\"b\", List(~[\n                 mk_object(~[(~\"c\", String(~\"\\x0c\\r\"))]),\n                 mk_object(~[(~\"d\", String(~\"\"))])\n             ]))\n         ]);\n+\n         // We can't compare the strings directly because the object fields be\n         // printed in a different order.\n-        let b = from_str(to_str(&a)).unwrap();\n-        assert_eq!(a, b);\n-    }\n-\n-    #[auto_encode]\n-    #[auto_decode]\n-    #[deriving(Eq)]\n-    enum Animal {\n-        Dog,\n-        Frog(~str, int)\n-    }\n-\n-    #[test]\n-    fn test_write_enum_no_args() {\n-        let animal = Dog;\n-\n-        let s = do io::with_str_writer |wr| {\n-            let encoder = Encoder(wr);\n-            animal.encode(&encoder);\n-        };\n-        assert_eq!(s, ~\"\\\"Dog\\\"\");\n+        assert_eq!(copy a, from_str(to_str(&a)).unwrap());\n+        assert_eq!(copy a, from_str(to_pretty_str(&a)).unwrap());\n     }\n \n     #[test]\n-    fn test_write_enum_no_args_pretty() {\n+    fn test_write_enum() {\n         let animal = Dog;\n+        assert_eq!(\n+            do io::with_str_writer |wr| {\n+                let encoder = Encoder(wr);\n+                animal.encode(&encoder);\n+            },\n+            ~\"\\\"Dog\\\"\"\n+        );\n+        assert_eq!(\n+            do io::with_str_writer |wr| {\n+                let encoder = PrettyEncoder(wr);\n+                animal.encode(&encoder);\n+            },\n+            ~\"\\\"Dog\\\"\"\n+        );\n \n-        let s = do io::with_str_writer |wr| {\n-            let encoder = PrettyEncoder(wr);\n-            animal.encode(&encoder);\n-        };\n-        assert_eq!(s, ~\"\\\"Dog\\\"\");\n-    }\n-\n-    #[test]\n-    fn test_write_enum_multiple_args() {\n-        let animal = Frog(~\"Henry\", 349);\n-\n-        let s = do io::with_str_writer |wr| {\n-            let encoder = Encoder(wr);\n-            animal.encode(&encoder);\n-        };\n-        assert_eq!(s, ~\"[\\\"Frog\\\",\\\"Henry\\\",349]\");\n-    }\n-\n-    #[test]\n-    fn test_write_enum_multiple_args_pretty() {\n         let animal = Frog(~\"Henry\", 349);\n-\n-        let s = do io::with_str_writer |wr| {\n-            let encoder = PrettyEncoder(wr);\n-            animal.encode(&encoder);\n-        };\n         assert_eq!(\n-            s,\n+            do io::with_str_writer |wr| {\n+                let encoder = Encoder(wr);\n+                animal.encode(&encoder);\n+            },\n+            ~\"[\\\"Frog\\\",\\\"Henry\\\",349]\"\n+        );\n+        assert_eq!(\n+            do io::with_str_writer |wr| {\n+                let encoder = PrettyEncoder(wr);\n+                animal.encode(&encoder);\n+            },\n             ~\"\\\n             [\\n  \\\n                 \\\"Frog\\\",\\n  \\\n@@ -1385,10 +1375,7 @@ mod tests {\n             value.encode(&encoder);\n         };\n         assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n-    }\n \n-    #[test]\n-    fn test_write_some_pretty() {\n         let value = Some(~\"jodhpurs\");\n         let s = do io::with_str_writer |wr| {\n             let encoder = PrettyEncoder(wr);\n@@ -1405,11 +1392,7 @@ mod tests {\n             value.encode(&encoder);\n         };\n         assert_eq!(s, ~\"null\");\n-    }\n \n-    #[test]\n-    fn test_write_none_pretty() {\n-        let value: Option<~str> = None;\n         let s = do io::with_str_writer |wr| {\n             let encoder = Encoder(wr);\n             value.encode(&encoder);"}]}