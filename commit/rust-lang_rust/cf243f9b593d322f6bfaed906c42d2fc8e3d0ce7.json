{"sha": "cf243f9b593d322f6bfaed906c42d2fc8e3d0ce7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMjQzZjliNTkzZDMyMmY2YmZhZWQ5MDZjNDJkMmZjOGUzZDBjZTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-10T01:31:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-10T01:31:31Z"}, "message": "auto merge of #12060 : chromatic/rust/enum_tutorial_improvement, r=alexcrichton\n\nThis version starts with the simplest case and builds on it. I believe it flows better.", "tree": {"sha": "dd9f6fafcdf319267f415ab58a1e2a32a5f83438", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd9f6fafcdf319267f415ab58a1e2a32a5f83438"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf243f9b593d322f6bfaed906c42d2fc8e3d0ce7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf243f9b593d322f6bfaed906c42d2fc8e3d0ce7", "html_url": "https://github.com/rust-lang/rust/commit/cf243f9b593d322f6bfaed906c42d2fc8e3d0ce7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf243f9b593d322f6bfaed906c42d2fc8e3d0ce7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35b4115ef8dc4d78559c492d7251235c17cdb4e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/35b4115ef8dc4d78559c492d7251235c17cdb4e7", "html_url": "https://github.com/rust-lang/rust/commit/35b4115ef8dc4d78559c492d7251235c17cdb4e7"}, {"sha": "e30fd3067ee03e8bbd776895b738792fcdac25fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/e30fd3067ee03e8bbd776895b738792fcdac25fc", "html_url": "https://github.com/rust-lang/rust/commit/e30fd3067ee03e8bbd776895b738792fcdac25fc"}], "stats": {"total": 83, "additions": 40, "deletions": 43}, "files": [{"sha": "73fec54fbcb605458a3594749d3900a0f2406423", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 40, "deletions": 43, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/cf243f9b593d322f6bfaed906c42d2fc8e3d0ce7/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/cf243f9b593d322f6bfaed906c42d2fc8e3d0ce7/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=cf243f9b593d322f6bfaed906c42d2fc8e3d0ce7", "patch": "@@ -647,31 +647,8 @@ match mypoint {\n \n ## Enums\n \n-Enums are datatypes that have several alternate representations. For\n-example, consider the following type:\n-\n-~~~~\n-# struct Point { x: f64, y: f64 }\n-enum Shape {\n-    Circle(Point, f64),\n-    Rectangle(Point, Point)\n-}\n-~~~~\n-\n-A value of this type is either a `Circle`, in which case it contains a\n-`Point` struct and a f64, or a `Rectangle`, in which case it contains\n-two `Point` structs. The run-time representation of such a value\n-includes an identifier of the actual form that it holds, much like the\n-\"tagged union\" pattern in C, but with better static guarantees.\n-\n-The above declaration will define a type `Shape` that can refer to\n-such shapes, and two functions, `Circle` and `Rectangle`, which can be\n-used to construct values of the type (taking arguments of the\n-specified types). So `Circle(Point { x: 0.0, y: 0.0 }, 10.0)` is the way to\n-create a new circle.\n-\n-Enum variants need not have parameters. This `enum` declaration,\n-for example, is equivalent to a C enum:\n+Enums are datatypes with several alternate representations. A simple `enum`\n+defines one or more constants, all of which have the same type:\n \n ~~~~\n enum Direction {\n@@ -682,12 +659,21 @@ enum Direction {\n }\n ~~~~\n \n-This declaration defines `North`, `East`, `South`, and `West` as constants,\n-all of which have type `Direction`.\n+Each variant of this enum has a unique and constant integral discriminator\n+value. If no explicit discriminator is specified for a variant, the value\n+defaults to the value of the previous variant plus one. If the first variant\n+does not have a discriminator, it defaults to 0. For example, the value of\n+`North` is 0, `East` is 1, `South` is 2, and `West` is 3.\n \n-When an enum is C-like (that is, when none of the variants have\n-parameters), it is possible to explicitly set the discriminator values\n-to a constant value:\n+When an enum has simple integer discriminators, you can apply the `as` cast\n+operator to convert a variant to its discriminator value as an `int`:\n+\n+~~~~\n+# enum Direction { North }\n+println!( \"{:?} => {}\", North, North as int );\n+~~~~\n+\n+It is possible to set the discriminator values to chosen constant values:\n \n ~~~~\n enum Color {\n@@ -697,17 +683,30 @@ enum Color {\n }\n ~~~~\n \n-If an explicit discriminator is not specified for a variant, the value\n-defaults to the value of the previous variant plus one. If the first\n-variant does not have a discriminator, it defaults to 0. For example,\n-the value of `North` is 0, `East` is 1, `South` is 2, and `West` is 3.\n+Variants do not have to be simple values; they may be more complex:\n \n-When an enum is C-like, you can apply the `as` cast operator to\n-convert it to its discriminator value as an `int`.\n+~~~~\n+# struct Point { x: f64, y: f64 }\n+enum Shape {\n+    Circle(Point, f64),\n+    Rectangle(Point, Point)\n+}\n+~~~~\n \n-For enum types with multiple variants, destructuring is the only way to\n-get at their contents. All variant constructors can be used as\n-patterns, as in this definition of `area`:\n+A value of this type is either a `Circle`, in which case it contains a\n+`Point` struct and a f64, or a `Rectangle`, in which case it contains\n+two `Point` structs. The run-time representation of such a value\n+includes an identifier of the actual form that it holds, much like the\n+\"tagged union\" pattern in C, but with better static guarantees.\n+\n+This declaration defines a type `Shape` that can refer to such shapes, and two\n+functions, `Circle` and `Rectangle`, which can be used to construct values of\n+the type. To create a new Circle, write `Circle(Point { x: 0.0, y: 0.0 },\n+10.0)`.\n+\n+All of these variant constructors may be used as patterns. The only way to\n+access the contents of an enum instance is the destructuring of a match. For\n+example:\n \n ~~~~\n use std::f64;\n@@ -721,10 +720,8 @@ fn area(sh: Shape) -> f64 {\n }\n ~~~~\n \n-You can write a lone `_` to ignore an individual field, and can\n-ignore all fields of a variant like: `Circle(..)`. As in their\n-introduction form, nullary enum patterns are written without\n-parentheses.\n+Use a lone `_` to ignore an individual field. Ignore all fields of a variant\n+like: `Circle(..)`. Nullary enum patterns are written without parentheses:\n \n ~~~~\n # struct Point { x: f64, y: f64 }"}]}