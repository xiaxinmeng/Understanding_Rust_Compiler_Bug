{"sha": "c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0OTI2ZDAxYWRhNjYxZDRmYmZmYjBlNWIxNzA4YWU1NDYzZDQ3YjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-01T07:00:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-01T07:00:41Z"}, "message": "Auto merge of #78725 - sexxi-goose:fix-78720, r=nikomatsakis\n\nRemove extra call to upvar_tys\n\nWe already visit the tuple of upvar_tys, we don't need to visit each individual type.\n\nFixes #78720\n\nr? `@ghost`", "tree": {"sha": "dedda250178e25359830d9b113a4e67526df24ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dedda250178e25359830d9b113a4e67526df24ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "html_url": "https://github.com/rust-lang/rust/commit/c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29c4358c189fbb3bd3fd7ac3d7a95fac7b97814c", "url": "https://api.github.com/repos/rust-lang/rust/commits/29c4358c189fbb3bd3fd7ac3d7a95fac7b97814c", "html_url": "https://github.com/rust-lang/rust/commit/29c4358c189fbb3bd3fd7ac3d7a95fac7b97814c"}, {"sha": "e35e46c1139d292ca0b352416d01b38bcf96fd69", "url": "https://api.github.com/repos/rust-lang/rust/commits/e35e46c1139d292ca0b352416d01b38bcf96fd69", "html_url": "https://github.com/rust-lang/rust/commit/e35e46c1139d292ca0b352416d01b38bcf96fd69"}], "stats": {"total": 320, "additions": 205, "deletions": 115}, "files": [{"sha": "00fea91fdfcb81d342042cf7d656b761e7efcd9d", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 129, "deletions": 99, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -2105,118 +2105,148 @@ where\n     }\n \n     fn field(this: TyAndLayout<'tcx>, cx: &C, i: usize) -> C::TyAndLayout {\n-        let tcx = cx.tcx();\n-        let tag_layout = |tag: &Scalar| -> C::TyAndLayout {\n-            let layout = Layout::scalar(cx, tag.clone());\n-            MaybeResult::from(Ok(TyAndLayout {\n-                layout: tcx.intern_layout(layout),\n-                ty: tag.value.to_ty(tcx),\n-            }))\n-        };\n+        enum TyMaybeWithLayout<C: LayoutOf> {\n+            Ty(C::Ty),\n+            TyAndLayout(C::TyAndLayout),\n+        }\n \n-        cx.layout_of(match *this.ty.kind() {\n-            ty::Bool\n-            | ty::Char\n-            | ty::Int(_)\n-            | ty::Uint(_)\n-            | ty::Float(_)\n-            | ty::FnPtr(_)\n-            | ty::Never\n-            | ty::FnDef(..)\n-            | ty::GeneratorWitness(..)\n-            | ty::Foreign(..)\n-            | ty::Dynamic(..) => bug!(\"TyAndLayout::field_type({:?}): not applicable\", this),\n-\n-            // Potentially-fat pointers.\n-            ty::Ref(_, pointee, _) | ty::RawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n-                assert!(i < this.fields.count());\n-\n-                // Reuse the fat `*T` type as its own thin pointer data field.\n-                // This provides information about, e.g., DST struct pointees\n-                // (which may have no non-DST form), and will work as long\n-                // as the `Abi` or `FieldsShape` is checked by users.\n-                if i == 0 {\n-                    let nil = tcx.mk_unit();\n-                    let ptr_ty = if this.ty.is_unsafe_ptr() {\n-                        tcx.mk_mut_ptr(nil)\n-                    } else {\n-                        tcx.mk_mut_ref(tcx.lifetimes.re_static, nil)\n-                    };\n-                    return MaybeResult::from(cx.layout_of(ptr_ty).to_result().map(\n-                        |mut ptr_layout| {\n-                            ptr_layout.ty = this.ty;\n-                            ptr_layout\n-                        },\n-                    ));\n-                }\n+        fn ty_and_layout_kind<\n+            C: LayoutOf<Ty = Ty<'tcx>, TyAndLayout: MaybeResult<TyAndLayout<'tcx>>>\n+                + HasTyCtxt<'tcx>\n+                + HasParamEnv<'tcx>,\n+        >(\n+            this: TyAndLayout<'tcx>,\n+            cx: &C,\n+            i: usize,\n+            ty: C::Ty,\n+        ) -> TyMaybeWithLayout<C> {\n+            let tcx = cx.tcx();\n+            let tag_layout = |tag: &Scalar| -> C::TyAndLayout {\n+                let layout = Layout::scalar(cx, tag.clone());\n+                MaybeResult::from(Ok(TyAndLayout {\n+                    layout: tcx.intern_layout(layout),\n+                    ty: tag.value.to_ty(tcx),\n+                }))\n+            };\n \n-                match tcx.struct_tail_erasing_lifetimes(pointee, cx.param_env()).kind() {\n-                    ty::Slice(_) | ty::Str => tcx.types.usize,\n-                    ty::Dynamic(_, _) => {\n-                        tcx.mk_imm_ref(tcx.lifetimes.re_static, tcx.mk_array(tcx.types.usize, 3))\n-                        /* FIXME: use actual fn pointers\n-                        Warning: naively computing the number of entries in the\n-                        vtable by counting the methods on the trait + methods on\n-                        all parent traits does not work, because some methods can\n-                        be not object safe and thus excluded from the vtable.\n-                        Increase this counter if you tried to implement this but\n-                        failed to do it without duplicating a lot of code from\n-                        other places in the compiler: 2\n-                        tcx.mk_tup(&[\n-                            tcx.mk_array(tcx.types.usize, 3),\n-                            tcx.mk_array(Option<fn()>),\n-                        ])\n-                        */\n+            match *ty.kind() {\n+                ty::Bool\n+                | ty::Char\n+                | ty::Int(_)\n+                | ty::Uint(_)\n+                | ty::Float(_)\n+                | ty::FnPtr(_)\n+                | ty::Never\n+                | ty::FnDef(..)\n+                | ty::GeneratorWitness(..)\n+                | ty::Foreign(..)\n+                | ty::Dynamic(..) => bug!(\"TyAndLayout::field_type({:?}): not applicable\", this),\n+\n+                // Potentially-fat pointers.\n+                ty::Ref(_, pointee, _) | ty::RawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n+                    assert!(i < this.fields.count());\n+\n+                    // Reuse the fat `*T` type as its own thin pointer data field.\n+                    // This provides information about, e.g., DST struct pointees\n+                    // (which may have no non-DST form), and will work as long\n+                    // as the `Abi` or `FieldsShape` is checked by users.\n+                    if i == 0 {\n+                        let nil = tcx.mk_unit();\n+                        let ptr_ty = if ty.is_unsafe_ptr() {\n+                            tcx.mk_mut_ptr(nil)\n+                        } else {\n+                            tcx.mk_mut_ref(tcx.lifetimes.re_static, nil)\n+                        };\n+                        return TyMaybeWithLayout::TyAndLayout(MaybeResult::from(\n+                            cx.layout_of(ptr_ty).to_result().map(|mut ptr_layout| {\n+                                ptr_layout.ty = ty;\n+                                ptr_layout\n+                            }),\n+                        ));\n                     }\n-                    _ => bug!(\"TyAndLayout::field_type({:?}): not applicable\", this),\n-                }\n-            }\n \n-            // Arrays and slices.\n-            ty::Array(element, _) | ty::Slice(element) => element,\n-            ty::Str => tcx.types.u8,\n-\n-            // Tuples, generators and closures.\n-            ty::Closure(_, ref substs) => substs.as_closure().upvar_tys().nth(i).unwrap(),\n-\n-            ty::Generator(def_id, ref substs, _) => match this.variants {\n-                Variants::Single { index } => substs\n-                    .as_generator()\n-                    .state_tys(def_id, tcx)\n-                    .nth(index.as_usize())\n-                    .unwrap()\n-                    .nth(i)\n-                    .unwrap(),\n-                Variants::Multiple { ref tag, tag_field, .. } => {\n-                    if i == tag_field {\n-                        return tag_layout(tag);\n+                    match tcx.struct_tail_erasing_lifetimes(pointee, cx.param_env()).kind() {\n+                        ty::Slice(_) | ty::Str => TyMaybeWithLayout::Ty(tcx.types.usize),\n+                        ty::Dynamic(_, _) => {\n+                            TyMaybeWithLayout::Ty(tcx.mk_imm_ref(\n+                                tcx.lifetimes.re_static,\n+                                tcx.mk_array(tcx.types.usize, 3),\n+                            ))\n+                            /* FIXME: use actual fn pointers\n+                            Warning: naively computing the number of entries in the\n+                            vtable by counting the methods on the trait + methods on\n+                            all parent traits does not work, because some methods can\n+                            be not object safe and thus excluded from the vtable.\n+                            Increase this counter if you tried to implement this but\n+                            failed to do it without duplicating a lot of code from\n+                            other places in the compiler: 2\n+                            tcx.mk_tup(&[\n+                                tcx.mk_array(tcx.types.usize, 3),\n+                                tcx.mk_array(Option<fn()>),\n+                            ])\n+                            */\n+                        }\n+                        _ => bug!(\"TyAndLayout::field_type({:?}): not applicable\", this),\n                     }\n-                    substs.as_generator().prefix_tys().nth(i).unwrap()\n                 }\n-            },\n \n-            ty::Tuple(tys) => tys[i].expect_ty(),\n+                // Arrays and slices.\n+                ty::Array(element, _) | ty::Slice(element) => TyMaybeWithLayout::Ty(element),\n+                ty::Str => TyMaybeWithLayout::Ty(tcx.types.u8),\n \n-            // ADTs.\n-            ty::Adt(def, substs) => {\n-                match this.variants {\n-                    Variants::Single { index } => def.variants[index].fields[i].ty(tcx, substs),\n+                // Tuples, generators and closures.\n+                ty::Closure(_, ref substs) => {\n+                    ty_and_layout_kind(this, cx, i, substs.as_closure().tupled_upvars_ty())\n+                }\n+\n+                ty::Generator(def_id, ref substs, _) => match this.variants {\n+                    Variants::Single { index } => TyMaybeWithLayout::Ty(\n+                        substs\n+                            .as_generator()\n+                            .state_tys(def_id, tcx)\n+                            .nth(index.as_usize())\n+                            .unwrap()\n+                            .nth(i)\n+                            .unwrap(),\n+                    ),\n+                    Variants::Multiple { ref tag, tag_field, .. } => {\n+                        if i == tag_field {\n+                            return TyMaybeWithLayout::TyAndLayout(tag_layout(tag));\n+                        }\n+                        TyMaybeWithLayout::Ty(substs.as_generator().prefix_tys().nth(i).unwrap())\n+                    }\n+                },\n+\n+                ty::Tuple(tys) => TyMaybeWithLayout::Ty(tys[i].expect_ty()),\n+\n+                // ADTs.\n+                ty::Adt(def, substs) => {\n+                    match this.variants {\n+                        Variants::Single { index } => {\n+                            TyMaybeWithLayout::Ty(def.variants[index].fields[i].ty(tcx, substs))\n+                        }\n \n-                    // Discriminant field for enums (where applicable).\n-                    Variants::Multiple { ref tag, .. } => {\n-                        assert_eq!(i, 0);\n-                        return tag_layout(tag);\n+                        // Discriminant field for enums (where applicable).\n+                        Variants::Multiple { ref tag, .. } => {\n+                            assert_eq!(i, 0);\n+                            return TyMaybeWithLayout::TyAndLayout(tag_layout(tag));\n+                        }\n                     }\n                 }\n+\n+                ty::Projection(_)\n+                | ty::Bound(..)\n+                | ty::Placeholder(..)\n+                | ty::Opaque(..)\n+                | ty::Param(_)\n+                | ty::Infer(_)\n+                | ty::Error(_) => bug!(\"TyAndLayout::field_type: unexpected type `{}`\", this.ty),\n             }\n+        }\n \n-            ty::Projection(_)\n-            | ty::Bound(..)\n-            | ty::Placeholder(..)\n-            | ty::Opaque(..)\n-            | ty::Param(_)\n-            | ty::Infer(_)\n-            | ty::Error(_) => bug!(\"TyAndLayout::field_type: unexpected type `{}`\", this.ty),\n+        cx.layout_of(match ty_and_layout_kind(this, cx, i, this.ty) {\n+            TyMaybeWithLayout::Ty(result) => result,\n+            TyMaybeWithLayout::TyAndLayout(result) => return result,\n         })\n     }\n "}, {"sha": "f5bc90e6f962102e5b790c8394cdcfc691574793", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -722,11 +722,6 @@ where\n                 // Skip lifetime parameters of the enclosing item(s)\n \n                 substs.as_closure().tupled_upvars_ty().visit_with(self);\n-\n-                for upvar_ty in substs.as_closure().upvar_tys() {\n-                    upvar_ty.visit_with(self);\n-                }\n-\n                 substs.as_closure().sig_as_fn_ptr_ty().visit_with(self);\n             }\n \n@@ -735,11 +730,6 @@ where\n                 // Also skip the witness type, because that has no free regions.\n \n                 substs.as_generator().tupled_upvars_ty().visit_with(self);\n-\n-                for upvar_ty in substs.as_generator().upvar_tys() {\n-                    upvar_ty.visit_with(self);\n-                }\n-\n                 substs.as_generator().return_ty().visit_with(self);\n                 substs.as_generator().yield_ty().visit_with(self);\n                 substs.as_generator().resume_ty().visit_with(self);"}, {"sha": "64f82817d3944e4636237b96c744f4d9d38e3bd3", "filename": "compiler/rustc_ty_utils/src/needs_drop.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -94,16 +94,12 @@ where\n                     _ if component.is_copy_modulo_regions(tcx.at(DUMMY_SP), self.param_env) => (),\n \n                     ty::Closure(_, substs) => {\n-                        for upvar_ty in substs.as_closure().upvar_tys() {\n-                            queue_type(self, upvar_ty);\n-                        }\n+                        queue_type(self, substs.as_closure().tupled_upvars_ty());\n                     }\n \n                     ty::Generator(def_id, substs, _) => {\n                         let substs = substs.as_generator();\n-                        for upvar_ty in substs.upvar_tys() {\n-                            queue_type(self, upvar_ty);\n-                        }\n+                        queue_type(self, substs.tupled_upvars_ty());\n \n                         let witness = substs.witness();\n                         let interior_tys = match witness.kind() {"}, {"sha": "57615d1a207fdc516e76d9a498053be0a49b42e3", "filename": "src/test/ui/issues/issue-78720.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fissues%2Fissue-78720.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fissues%2Fissue-78720.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-78720.rs?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -0,0 +1,19 @@\n+fn server() -> impl {\n+//~^ ERROR at least one trait must be specified\n+    ().map2(|| \"\")\n+}\n+\n+trait FilterBase2 {\n+    fn map2<F>(self, F) -> Map2<F> {}\n+    //~^ ERROR mismatched types\n+    //~^^ ERROR the size for values of type `Self` cannot be known at compilation time\n+}\n+\n+struct Map2<Segment2> {\n+    _func: F,\n+    //~^ ERROR cannot find type `F` in this scope\n+}\n+\n+impl<F> FilterBase2 for F {}\n+\n+fn main() {}"}, {"sha": "a3a14e34acbc146e220a1cbeac0052ee9bc50613", "filename": "src/test/ui/issues/issue-78720.stderr", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fissues%2Fissue-78720.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4926d01ada661d4fbffb0e5b1708ae5463d47b3/src%2Ftest%2Fui%2Fissues%2Fissue-78720.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-78720.stderr?ref=c4926d01ada661d4fbffb0e5b1708ae5463d47b3", "patch": "@@ -0,0 +1,55 @@\n+error: at least one trait must be specified\n+  --> $DIR/issue-78720.rs:1:16\n+   |\n+LL | fn server() -> impl {\n+   |                ^^^^\n+\n+error[E0412]: cannot find type `F` in this scope\n+  --> $DIR/issue-78720.rs:13:12\n+   |\n+LL |     _func: F,\n+   |            ^\n+   | \n+  ::: $SRC_DIR/core/src/ops/function.rs:LL:COL\n+   |\n+LL | pub trait Fn<Args>: FnMut<Args> {\n+   | ------------------------------- similarly named trait `Fn` defined here\n+   |\n+help: a trait with a similar name exists\n+   |\n+LL |     _func: Fn,\n+   |            ^^\n+help: you might be missing a type parameter\n+   |\n+LL | struct Map2<Segment2, F> {\n+   |                     ^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-78720.rs:7:36\n+   |\n+LL |     fn map2<F>(self, F) -> Map2<F> {}\n+   |                                    ^^ expected struct `Map2`, found `()`\n+   |\n+   = note: expected struct `Map2<F>`\n+           found unit type `()`\n+\n+error[E0277]: the size for values of type `Self` cannot be known at compilation time\n+  --> $DIR/issue-78720.rs:7:16\n+   |\n+LL |     fn map2<F>(self, F) -> Map2<F> {}\n+   |                ^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: unsized fn params are gated as an unstable feature\n+help: consider further restricting `Self`\n+   |\n+LL |     fn map2<F>(self, F) -> Map2<F> where Self: Sized {}\n+   |                                    ^^^^^^^^^^^^^^^^^\n+help: function arguments must have a statically known size, borrowed types always have a known size\n+   |\n+LL |     fn map2<F>(&self, F) -> Map2<F> {}\n+   |                ^\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors have detailed explanations: E0277, E0308, E0412.\n+For more information about an error, try `rustc --explain E0277`."}]}