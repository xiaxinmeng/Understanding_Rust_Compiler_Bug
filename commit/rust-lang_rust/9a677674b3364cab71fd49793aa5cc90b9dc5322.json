{"sha": "9a677674b3364cab71fd49793aa5cc90b9dc5322", "node_id": "C_kwDOAAsO6NoAKDlhNjc3Njc0YjMzNjRjYWI3MWZkNDk3OTNhYTVjYzkwYjlkYzUzMjI", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-08-31T13:24:45Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-08-31T13:24:45Z"}, "message": "Merge commit 'f51aade56f93175dde89177a92e3669ebd8e7592' into clippyup", "tree": {"sha": "a47ca23458bfe4685f8c0f175f7cb0eae4401768", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a47ca23458bfe4685f8c0f175f7cb0eae4401768"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a677674b3364cab71fd49793aa5cc90b9dc5322", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a677674b3364cab71fd49793aa5cc90b9dc5322", "html_url": "https://github.com/rust-lang/rust/commit/9a677674b3364cab71fd49793aa5cc90b9dc5322", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a677674b3364cab71fd49793aa5cc90b9dc5322/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12e4fd0755d7d976d4ee0f2004dc938290752ff7", "url": "https://api.github.com/repos/rust-lang/rust/commits/12e4fd0755d7d976d4ee0f2004dc938290752ff7", "html_url": "https://github.com/rust-lang/rust/commit/12e4fd0755d7d976d4ee0f2004dc938290752ff7"}, {"sha": "f51aade56f93175dde89177a92e3669ebd8e7592", "url": "https://api.github.com/repos/rust-lang/rust/commits/f51aade56f93175dde89177a92e3669ebd8e7592", "html_url": "https://github.com/rust-lang/rust/commit/f51aade56f93175dde89177a92e3669ebd8e7592"}], "stats": {"total": 13228, "additions": 9255, "deletions": 3973}, "files": [{"sha": "5f2c56b10a9f77f5dd6afcd25dbe52a1548646e4", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -727,6 +727,7 @@ version = \"0.1.65\"\n dependencies = [\n  \"arrayvec\",\n  \"if_chain\",\n+ \"itertools\",\n  \"rustc-semver\",\n ]\n "}, {"sha": "fac2c99714d9bf808d6a13f6bae1b6a82af59356", "filename": "src/tools/clippy/.github/workflows/clippy.yml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy.yml", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy.yml?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -24,6 +24,7 @@ env:\n   RUST_BACKTRACE: 1\n   CARGO_TARGET_DIR: '${{ github.workspace }}/target'\n   NO_FMT_TEST: 1\n+  CARGO_INCREMENTAL: 0\n \n jobs:\n   base:"}, {"sha": "30607af490124589f44ce0cf831ca57ab8edad98", "filename": "src/tools/clippy/.github/workflows/clippy_bors.yml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -10,6 +10,7 @@ env:\n   RUST_BACKTRACE: 1\n   CARGO_TARGET_DIR: '${{ github.workspace }}/target'\n   NO_FMT_TEST: 1\n+  CARGO_INCREMENTAL: 0\n \n defaults:\n   run:"}, {"sha": "c488c142e46fc2847fe41d7c3c3582508a705eac", "filename": "src/tools/clippy/CHANGELOG.md", "status": "modified", "additions": 158, "deletions": 2, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCHANGELOG.md?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -6,11 +6,157 @@ document.\n \n ## Unreleased / In Rust Nightly\n \n-[7c21f91b...master](https://github.com/rust-lang/rust-clippy/compare/7c21f91b...master)\n+[d7b5cbf0...master](https://github.com/rust-lang/rust-clippy/compare/d7b5cbf0...master)\n+\n+## Rust 1.63\n+\n+Current stable, released 2022-08-11\n+\n+[7c21f91b...d7b5cbf0](https://github.com/rust-lang/rust-clippy/compare/7c21f91b...d7b5cbf0)\n+\n+### New Lints\n+\n+* [`borrow_deref_ref`]\n+  [#7930](https://github.com/rust-lang/rust-clippy/pull/7930)\n+* [`doc_link_with_quotes`]\n+  [#8385](https://github.com/rust-lang/rust-clippy/pull/8385)\n+* [`no_effect_replace`]\n+  [#8754](https://github.com/rust-lang/rust-clippy/pull/8754)\n+* [`rc_clone_in_vec_init`]\n+  [#8769](https://github.com/rust-lang/rust-clippy/pull/8769)\n+* [`derive_partial_eq_without_eq`]\n+  [#8796](https://github.com/rust-lang/rust-clippy/pull/8796)\n+* [`mismatching_type_param_order`]\n+  [#8831](https://github.com/rust-lang/rust-clippy/pull/8831)\n+* [`duplicate_mod`] [#8832](https://github.com/rust-lang/rust-clippy/pull/8832)\n+* [`unused_rounding`]\n+  [#8866](https://github.com/rust-lang/rust-clippy/pull/8866)\n+* [`get_first`] [#8882](https://github.com/rust-lang/rust-clippy/pull/8882)\n+* [`swap_ptr_to_ref`]\n+  [#8916](https://github.com/rust-lang/rust-clippy/pull/8916)\n+* [`almost_complete_letter_range`]\n+  [#8918](https://github.com/rust-lang/rust-clippy/pull/8918)\n+* [`needless_parens_on_range_literals`]\n+  [#8933](https://github.com/rust-lang/rust-clippy/pull/8933)\n+* [`as_underscore`] [#8934](https://github.com/rust-lang/rust-clippy/pull/8934)\n+\n+### Moves and Deprecations\n+\n+* Rename `eval_order_dependence` to [`mixed_read_write_in_expression`], move to\n+  `nursery` [#8621](https://github.com/rust-lang/rust-clippy/pull/8621)\n+\n+### Enhancements\n+\n+* [`undocumented_unsafe_blocks`]: Now also lints on unsafe trait implementations\n+  [#8761](https://github.com/rust-lang/rust-clippy/pull/8761)\n+* [`empty_line_after_outer_attr`]: Now also lints on argumentless macros\n+  [#8790](https://github.com/rust-lang/rust-clippy/pull/8790)\n+* [`expect_used`]: Now can be disabled in tests with the `allow-expect-in-tests`\n+  option [#8802](https://github.com/rust-lang/rust-clippy/pull/8802)\n+* [`unwrap_used`]: Now can be disabled in tests with the `allow-unwrap-in-tests`\n+  option [#8802](https://github.com/rust-lang/rust-clippy/pull/8802)\n+* [`disallowed_methods`]: Now also lints indirect usages\n+  [#8852](https://github.com/rust-lang/rust-clippy/pull/8852)\n+* [`get_last_with_len`]: Now also lints `VecDeque` and any deref to slice\n+  [#8862](https://github.com/rust-lang/rust-clippy/pull/8862)\n+* [`manual_range_contains`]: Now also lints on chains of `&&` and `||`\n+  [#8884](https://github.com/rust-lang/rust-clippy/pull/8884)\n+* [`rc_clone_in_vec_init`]: Now also lints on `Weak`\n+  [#8885](https://github.com/rust-lang/rust-clippy/pull/8885)\n+* [`dbg_macro`]: Introduce `allow-dbg-in-tests` config option\n+  [#8897](https://github.com/rust-lang/rust-clippy/pull/8897)\n+* [`use_self`]: Now also lints on `TupleStruct` and `Struct` patterns\n+  [#8899](https://github.com/rust-lang/rust-clippy/pull/8899)\n+* [`manual_find_map`] and [`manual_filter_map`]: Now also lints on more complex\n+  method chains inside `map`\n+  [#8930](https://github.com/rust-lang/rust-clippy/pull/8930)\n+* [`needless_return`]: Now also lints on macro expressions in return statements\n+  [#8932](https://github.com/rust-lang/rust-clippy/pull/8932)\n+* [`doc_markdown`]: Users can now indicate, that the `doc-valid-idents` config\n+  should extend the default and not replace it\n+  [#8944](https://github.com/rust-lang/rust-clippy/pull/8944)\n+* [`disallowed_names`]: Users can now indicate, that the `disallowed-names`\n+  config should extend the default and not replace it\n+  [#8944](https://github.com/rust-lang/rust-clippy/pull/8944)\n+* [`never_loop`]: Now checks for `continue` in struct expression\n+  [#9002](https://github.com/rust-lang/rust-clippy/pull/9002)\n+\n+### False Positive Fixes\n+\n+* [`useless_transmute`]: No longer lints on types with erased regions\n+  [#8564](https://github.com/rust-lang/rust-clippy/pull/8564)\n+* [`vec_init_then_push`]: No longer lints when further extended\n+  [#8699](https://github.com/rust-lang/rust-clippy/pull/8699)\n+* [`cmp_owned`]: No longer lints on `From::from` for `Copy` types\n+  [#8807](https://github.com/rust-lang/rust-clippy/pull/8807)\n+* [`redundant_allocation`]: No longer lints on fat pointers that would become\n+  thin pointers [#8813](https://github.com/rust-lang/rust-clippy/pull/8813)\n+* [`derive_partial_eq_without_eq`]:\n+    * Handle differing predicates applied by `#[derive(PartialEq)]` and\n+      `#[derive(Eq)]`\n+      [#8869](https://github.com/rust-lang/rust-clippy/pull/8869)\n+    * No longer lints on non-public types and better handles generics\n+      [#8950](https://github.com/rust-lang/rust-clippy/pull/8950)\n+* [`empty_line_after_outer_attr`]: No longer lints empty lines in inner\n+  string values [#8892](https://github.com/rust-lang/rust-clippy/pull/8892)\n+* [`branches_sharing_code`]: No longer lints when using different binding names\n+  [#8901](https://github.com/rust-lang/rust-clippy/pull/8901)\n+* [`significant_drop_in_scrutinee`]: No longer lints on Try `?` and `await`\n+  desugared expressions [#8902](https://github.com/rust-lang/rust-clippy/pull/8902)\n+* [`checked_conversions`]: No longer lints in `const` contexts\n+  [#8907](https://github.com/rust-lang/rust-clippy/pull/8907)\n+* [`iter_overeager_cloned`]: No longer lints on `.cloned().flatten()` when\n+  `T::Item` doesn't implement `IntoIterator`\n+  [#8960](https://github.com/rust-lang/rust-clippy/pull/8960)\n+\n+### Suggestion Fixes/Improvements\n+\n+* [`vec_init_then_push`]: Suggest to remove `mut` binding when possible\n+  [#8699](https://github.com/rust-lang/rust-clippy/pull/8699)\n+* [`manual_range_contains`]: Fix suggestion for integers with different signs\n+  [#8763](https://github.com/rust-lang/rust-clippy/pull/8763)\n+* [`identity_op`]: Add parenthesis to suggestions where required\n+  [#8786](https://github.com/rust-lang/rust-clippy/pull/8786)\n+* [`cast_lossless`]: No longer gives wrong suggestion on `usize`/`isize`->`f64`\n+  [#8778](https://github.com/rust-lang/rust-clippy/pull/8778)\n+* [`rc_clone_in_vec_init`]: Add suggestion\n+  [#8814](https://github.com/rust-lang/rust-clippy/pull/8814)\n+* The \"unknown field\" error messages for config files now wraps the field names\n+  [#8823](https://github.com/rust-lang/rust-clippy/pull/8823)\n+* [`cast_abs_to_unsigned`]: Do not remove cast if it's required\n+  [#8876](https://github.com/rust-lang/rust-clippy/pull/8876)\n+* [`significant_drop_in_scrutinee`]: Improve lint message for types that are not\n+  references and not trivially clone-able\n+  [#8902](https://github.com/rust-lang/rust-clippy/pull/8902)\n+* [`for_loops_over_fallibles`]: Now suggests the correct variant of `iter()`,\n+  `iter_mut()` or `into_iter()`\n+  [#8941](https://github.com/rust-lang/rust-clippy/pull/8941)\n+\n+### ICE Fixes\n+\n+* Fix ICE in [`let_unit_value`] when calling a `static`/`const` callable type\n+  [#8835](https://github.com/rust-lang/rust-clippy/pull/8835)\n+* Fix ICEs on callable `static`/`const`s\n+  [#8896](https://github.com/rust-lang/rust-clippy/pull/8896)\n+* [`needless_late_init`]\n+  [#8912](https://github.com/rust-lang/rust-clippy/pull/8912)\n+* Fix ICE in shadow lints\n+  [#8913](https://github.com/rust-lang/rust-clippy/pull/8913)\n+\n+### Documentation Improvements\n+\n+* Clippy has a [Book](https://doc.rust-lang.org/nightly/clippy/) now!\n+  [#7359](https://github.com/rust-lang/rust-clippy/pull/7359)\n+* Add a *copy lint name*-button to Clippy's lint list\n+  [#8839](https://github.com/rust-lang/rust-clippy/pull/8839)\n+* Display past names of renamed lints on Clippy's lint list\n+  [#8843](https://github.com/rust-lang/rust-clippy/pull/8843)\n+* Add the ability to show the lint output in the lint list\n+  [#8947](https://github.com/rust-lang/rust-clippy/pull/8947)\n \n ## Rust 1.62\n \n-Current stable, released 2022-06-30\n+Released 2022-06-30\n \n [d0cf3481...7c21f91b](https://github.com/rust-lang/rust-clippy/compare/d0cf3481...7c21f91b)\n \n@@ -3481,6 +3627,7 @@ Released 2018-09-13\n [`cast_ref_to_mut`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_ref_to_mut\n [`cast_sign_loss`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_sign_loss\n [`cast_slice_different_sizes`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_slice_different_sizes\n+[`cast_slice_from_raw_parts`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_slice_from_raw_parts\n [`char_lit_as_u8`]: https://rust-lang.github.io/rust-clippy/master/index.html#char_lit_as_u8\n [`chars_last_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#chars_last_cmp\n [`chars_next_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#chars_next_cmp\n@@ -3496,6 +3643,7 @@ Released 2018-09-13\n [`collapsible_else_if`]: https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\n [`collapsible_if`]: https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\n [`collapsible_match`]: https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_match\n+[`collapsible_str_replace`]: https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_str_replace\n [`comparison_chain`]: https://rust-lang.github.io/rust-clippy/master/index.html#comparison_chain\n [`comparison_to_empty`]: https://rust-lang.github.io/rust-clippy/master/index.html#comparison_to_empty\n [`const_static_lifetime`]: https://rust-lang.github.io/rust-clippy/master/index.html#const_static_lifetime\n@@ -3656,6 +3804,8 @@ Released 2018-09-13\n [`iter_not_returning_iterator`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_not_returning_iterator\n [`iter_nth`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_nth\n [`iter_nth_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_nth_zero\n+[`iter_on_empty_collections`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_on_empty_collections\n+[`iter_on_single_items`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_on_single_items\n [`iter_overeager_cloned`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_overeager_cloned\n [`iter_skip_next`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_skip_next\n [`iter_with_drain`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_with_drain\n@@ -3697,6 +3847,7 @@ Released 2018-09-13\n [`manual_saturating_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_saturating_arithmetic\n [`manual_split_once`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_split_once\n [`manual_str_repeat`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_str_repeat\n+[`manual_string_new`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_string_new\n [`manual_strip`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_strip\n [`manual_swap`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_swap\n [`manual_unwrap_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_unwrap_or\n@@ -3747,6 +3898,7 @@ Released 2018-09-13\n [`module_name_repetitions`]: https://rust-lang.github.io/rust-clippy/master/index.html#module_name_repetitions\n [`modulo_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#modulo_arithmetic\n [`modulo_one`]: https://rust-lang.github.io/rust-clippy/master/index.html#modulo_one\n+[`multi_assignments`]: https://rust-lang.github.io/rust-clippy/master/index.html#multi_assignments\n [`multiple_crate_versions`]: https://rust-lang.github.io/rust-clippy/master/index.html#multiple_crate_versions\n [`multiple_inherent_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#multiple_inherent_impl\n [`must_use_candidate`]: https://rust-lang.github.io/rust-clippy/master/index.html#must_use_candidate\n@@ -3827,6 +3979,7 @@ Released 2018-09-13\n [`partialeq_to_none`]: https://rust-lang.github.io/rust-clippy/master/index.html#partialeq_to_none\n [`path_buf_push_overwrite`]: https://rust-lang.github.io/rust-clippy/master/index.html#path_buf_push_overwrite\n [`pattern_type_mismatch`]: https://rust-lang.github.io/rust-clippy/master/index.html#pattern_type_mismatch\n+[`positional_named_format_parameters`]: https://rust-lang.github.io/rust-clippy/master/index.html#positional_named_format_parameters\n [`possible_missing_comma`]: https://rust-lang.github.io/rust-clippy/master/index.html#possible_missing_comma\n [`precedence`]: https://rust-lang.github.io/rust-clippy/master/index.html#precedence\n [`print_in_format_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#print_in_format_impl\n@@ -3872,6 +4025,7 @@ Released 2018-09-13\n [`replace_consts`]: https://rust-lang.github.io/rust-clippy/master/index.html#replace_consts\n [`rest_pat_in_fully_bound_structs`]: https://rust-lang.github.io/rust-clippy/master/index.html#rest_pat_in_fully_bound_structs\n [`result_expect_used`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_expect_used\n+[`result_large_err`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_large_err\n [`result_map_or_into_option`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_map_or_into_option\n [`result_map_unit_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_map_unit_fn\n [`result_map_unwrap_or_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_map_unwrap_or_else\n@@ -3930,6 +4084,7 @@ Released 2018-09-13\n [`suspicious_op_assign_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_op_assign_impl\n [`suspicious_operation_groupings`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_operation_groupings\n [`suspicious_splitn`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_splitn\n+[`suspicious_to_owned`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_to_owned\n [`suspicious_unary_op_formatting`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_unary_op_formatting\n [`swap_ptr_to_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#swap_ptr_to_ref\n [`tabs_in_doc_comments`]: https://rust-lang.github.io/rust-clippy/master/index.html#tabs_in_doc_comments\n@@ -4002,6 +4157,7 @@ Released 2018-09-13\n [`unused_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_collect\n [`unused_io_amount`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_io_amount\n [`unused_label`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_label\n+[`unused_peekable`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_peekable\n [`unused_rounding`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_rounding\n [`unused_self`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_self\n [`unused_unit`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_unit"}, {"sha": "92b2771f3fe73aeccc27b51c1edd243108f0e35d", "filename": "src/tools/clippy/clippy_dev/src/bless.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fbless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fbless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fbless.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -37,7 +37,7 @@ fn update_reference_file(test_output_entry: &DirEntry, ignore_timestamp: bool) {\n         return;\n     }\n \n-    let test_output_file = fs::read(&test_output_path).expect(\"Unable to read test output file\");\n+    let test_output_file = fs::read(test_output_path).expect(\"Unable to read test output file\");\n     let reference_file = fs::read(&reference_file_path).unwrap_or_default();\n \n     if test_output_file != reference_file {"}, {"sha": "357cf6fc43aadada9baabbce3ac08cd70c5d0f93", "filename": "src/tools/clippy/clippy_dev/src/fmt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Ffmt.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -46,7 +46,7 @@ pub fn run(check: bool, verbose: bool) {\n         // dependency\n         if fs::read_to_string(project_root.join(\"Cargo.toml\"))\n             .expect(\"Failed to read clippy Cargo.toml\")\n-            .contains(&\"[target.'cfg(NOT_A_PLATFORM)'.dependencies]\")\n+            .contains(\"[target.'cfg(NOT_A_PLATFORM)'.dependencies]\")\n         {\n             return Err(CliError::IntellijSetupActive);\n         }\n@@ -193,10 +193,10 @@ fn rustfmt_test(context: &FmtContext) -> Result<(), CliError> {\n     let args = &[\"--version\"];\n \n     if context.verbose {\n-        println!(\"{}\", format_command(&program, &dir, args));\n+        println!(\"{}\", format_command(program, &dir, args));\n     }\n \n-    let output = Command::new(&program).current_dir(&dir).args(args.iter()).output()?;\n+    let output = Command::new(program).current_dir(&dir).args(args.iter()).output()?;\n \n     if output.status.success() {\n         Ok(())\n@@ -207,7 +207,7 @@ fn rustfmt_test(context: &FmtContext) -> Result<(), CliError> {\n         Err(CliError::RustfmtNotInstalled)\n     } else {\n         Err(CliError::CommandFailed(\n-            format_command(&program, &dir, args),\n+            format_command(program, &dir, args),\n             std::str::from_utf8(&output.stderr).unwrap_or(\"\").to_string(),\n         ))\n     }"}, {"sha": "be05e67d724dfc120acfec0d1385dda0cd3df741", "filename": "src/tools/clippy/clippy_dev/src/new_lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -155,7 +155,7 @@ fn to_camel_case(name: &str) -> String {\n     name.split('_')\n         .map(|s| {\n             if s.is_empty() {\n-                String::from(\"\")\n+                String::new()\n             } else {\n                 [&s[0..1].to_uppercase(), &s[1..]].concat()\n             }"}, {"sha": "c503142e5e4552b1cdc28877dca9ab3734ba2083", "filename": "src/tools/clippy/clippy_dev/src/update_lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -418,7 +418,7 @@ fn remove_lint_declaration(name: &str, path: &Path, lints: &mut Vec<Lint>) -> io\n             .expect(\"failed to find `impl_lint_pass` terminator\");\n \n         impl_lint_pass_end += impl_lint_pass_start;\n-        if let Some(lint_name_pos) = content[impl_lint_pass_start..impl_lint_pass_end].find(&lint_name_upper) {\n+        if let Some(lint_name_pos) = content[impl_lint_pass_start..impl_lint_pass_end].find(lint_name_upper) {\n             let mut lint_name_end = impl_lint_pass_start + (lint_name_pos + lint_name_upper.len());\n             for c in content[lint_name_end..impl_lint_pass_end].chars() {\n                 // Remove trailing whitespace\n@@ -451,7 +451,7 @@ fn remove_lint_declaration(name: &str, path: &Path, lints: &mut Vec<Lint>) -> io\n                 }\n \n                 let mut content =\n-                    fs::read_to_string(&path).unwrap_or_else(|_| panic!(\"failed to read `{}`\", path.to_string_lossy()));\n+                    fs::read_to_string(path).unwrap_or_else(|_| panic!(\"failed to read `{}`\", path.to_string_lossy()));\n \n                 eprintln!(\n                     \"warn: you will have to manually remove any code related to `{}` from `{}`\","}, {"sha": "0bdef9d0a7e8e5bc8ab4c5308afa65a011dcc946", "filename": "src/tools/clippy/clippy_lints/src/as_underscore.rs", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fas_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fas_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fas_underscore.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,74 +0,0 @@\n-use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n-use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, TyKind};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Check for the usage of `as _` conversion using inferred type.\n-    ///\n-    /// ### Why is this bad?\n-    /// The conversion might include lossy conversion and dangerous cast that might go\n-    /// undetected du to the type being inferred.\n-    ///\n-    /// The lint is allowed by default as using `_` is less wordy than always specifying the type.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// fn foo(n: usize) {}\n-    /// let n: u16 = 256;\n-    /// foo(n as _);\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// fn foo(n: usize) {}\n-    /// let n: u16 = 256;\n-    /// foo(n as usize);\n-    /// ```\n-    #[clippy::version = \"1.63.0\"]\n-    pub AS_UNDERSCORE,\n-    restriction,\n-    \"detects `as _` conversion\"\n-}\n-declare_lint_pass!(AsUnderscore => [AS_UNDERSCORE]);\n-\n-impl<'tcx> LateLintPass<'tcx> for AsUnderscore {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'tcx>) {\n-        if in_external_macro(cx.sess(), expr.span) {\n-            return;\n-        }\n-\n-        if let ExprKind::Cast(_, ty) = expr.kind && let TyKind::Infer = ty.kind {\n-\n-            let ty_resolved = cx.typeck_results().expr_ty(expr);\n-            if let ty::Error(_) = ty_resolved.kind() {\n-                span_lint_and_help(\n-                    cx,\n-                AS_UNDERSCORE,\n-                expr.span,\n-                \"using `as _` conversion\",\n-                None,\n-                \"consider giving the type explicitly\",\n-                );\n-            } else {\n-            span_lint_and_then(\n-                cx,\n-                AS_UNDERSCORE,\n-                expr.span,\n-                \"using `as _` conversion\",\n-                |diag| {\n-                    diag.span_suggestion(\n-                        ty.span,\n-                        \"consider giving the type explicitly\",\n-                        ty_resolved,\n-                        Applicability::MachineApplicable,\n-                    );\n-            }\n-            );\n-        }\n-        }\n-    }\n-}"}, {"sha": "0993adbae2e6bfdb37c27b85335549c83c773dc9", "filename": "src/tools/clippy/clippy_lints/src/borrow_as_ptr.rs", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fborrow_as_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fborrow_as_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fborrow_as_ptr.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,99 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::is_no_std_crate;\n-use clippy_utils::source::snippet_opt;\n-use clippy_utils::{meets_msrv, msrvs};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability, TyKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_semver::RustcVersion;\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for the usage of `&expr as *const T` or\n-    /// `&mut expr as *mut T`, and suggest using `ptr::addr_of` or\n-    /// `ptr::addr_of_mut` instead.\n-    ///\n-    /// ### Why is this bad?\n-    /// This would improve readability and avoid creating a reference\n-    /// that points to an uninitialized value or unaligned place.\n-    /// Read the `ptr::addr_of` docs for more information.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let val = 1;\n-    /// let p = &val as *const i32;\n-    ///\n-    /// let mut val_mut = 1;\n-    /// let p_mut = &mut val_mut as *mut i32;\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// let val = 1;\n-    /// let p = std::ptr::addr_of!(val);\n-    ///\n-    /// let mut val_mut = 1;\n-    /// let p_mut = std::ptr::addr_of_mut!(val_mut);\n-    /// ```\n-    #[clippy::version = \"1.60.0\"]\n-    pub BORROW_AS_PTR,\n-    pedantic,\n-    \"borrowing just to cast to a raw pointer\"\n-}\n-\n-impl_lint_pass!(BorrowAsPtr => [BORROW_AS_PTR]);\n-\n-pub struct BorrowAsPtr {\n-    msrv: Option<RustcVersion>,\n-}\n-\n-impl BorrowAsPtr {\n-    #[must_use]\n-    pub fn new(msrv: Option<RustcVersion>) -> Self {\n-        Self { msrv }\n-    }\n-}\n-\n-impl<'tcx> LateLintPass<'tcx> for BorrowAsPtr {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if !meets_msrv(self.msrv, msrvs::BORROW_AS_PTR) {\n-            return;\n-        }\n-\n-        if expr.span.from_expansion() {\n-            return;\n-        }\n-\n-        if_chain! {\n-            if let ExprKind::Cast(left_expr, ty) = &expr.kind;\n-            if let TyKind::Ptr(_) = ty.kind;\n-            if let ExprKind::AddrOf(BorrowKind::Ref, mutability, e) = &left_expr.kind;\n-\n-            then {\n-                let core_or_std = if is_no_std_crate(cx) { \"core\" } else { \"std\" };\n-                let macro_name = match mutability {\n-                    Mutability::Not => \"addr_of\",\n-                    Mutability::Mut => \"addr_of_mut\",\n-                };\n-\n-                span_lint_and_sugg(\n-                    cx,\n-                    BORROW_AS_PTR,\n-                    expr.span,\n-                    \"borrow as raw pointer\",\n-                    \"try\",\n-                    format!(\n-                        \"{}::ptr::{}!({})\",\n-                        core_or_std,\n-                        macro_name,\n-                        snippet_opt(cx, e.span).unwrap()\n-                    ),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-    }\n-\n-    extract_msrv_attr!(LateContext);\n-}"}, {"sha": "c4520d003928e3832053fe749045c643407ed2c1", "filename": "src/tools/clippy/clippy_lints/src/borrow_deref_ref.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fborrow_deref_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fborrow_deref_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fborrow_deref_ref.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -29,22 +29,17 @@ declare_clippy_lint! {\n     ///\n     /// ### Example\n     /// ```rust\n-    /// fn foo(_x: &str) {}\n-    ///\n     /// let s = &String::new();\n     ///\n     /// let a: &String = &* s;\n-    /// foo(&*s);\n     /// ```\n     ///\n     /// Use instead:\n     /// ```rust\n-    /// # fn foo(_x: &str) {}\n     /// # let s = &String::new();\n     /// let a: &String = s;\n-    /// foo(&**s);\n     /// ```\n-    #[clippy::version = \"1.59.0\"]\n+    #[clippy::version = \"1.63.0\"]\n     pub BORROW_DEREF_REF,\n     complexity,\n     \"deref on an immutable reference returns the same type as itself\""}, {"sha": "326ce34082af7c233b8f2d1dc44cc185a81fdb08", "filename": "src/tools/clippy/clippy_lints/src/bytecount.rs", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,103 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::ty::match_type;\n-use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{path_to_local_id, paths, peel_blocks, peel_ref_operators, strip_pat_refs};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Closure, Expr, ExprKind, PatKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, UintTy};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for naive byte counts\n-    ///\n-    /// ### Why is this bad?\n-    /// The [`bytecount`](https://crates.io/crates/bytecount)\n-    /// crate has methods to count your bytes faster, especially for large slices.\n-    ///\n-    /// ### Known problems\n-    /// If you have predominantly small slices, the\n-    /// `bytecount::count(..)` method may actually be slower. However, if you can\n-    /// ensure that less than 2\u00b3\u00b2-1 matches arise, the `naive_count_32(..)` can be\n-    /// faster in those cases.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let vec = vec![1_u8];\n-    /// let count = vec.iter().filter(|x| **x == 0u8).count();\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// # let vec = vec![1_u8];\n-    /// let count = bytecount::count(&vec, 0u8);\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub NAIVE_BYTECOUNT,\n-    pedantic,\n-    \"use of naive `<slice>.filter(|&x| x == y).count()` to count byte values\"\n-}\n-\n-declare_lint_pass!(ByteCount => [NAIVE_BYTECOUNT]);\n-\n-impl<'tcx> LateLintPass<'tcx> for ByteCount {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::MethodCall(count, [count_recv], _) = expr.kind;\n-            if count.ident.name == sym::count;\n-            if let ExprKind::MethodCall(filter, [filter_recv, filter_arg], _) = count_recv.kind;\n-            if filter.ident.name == sym!(filter);\n-            if let ExprKind::Closure(&Closure { body, .. }) = filter_arg.kind;\n-            let body = cx.tcx.hir().body(body);\n-            if let [param] = body.params;\n-            if let PatKind::Binding(_, arg_id, _, _) = strip_pat_refs(param.pat).kind;\n-            if let ExprKind::Binary(ref op, l, r) = body.value.kind;\n-            if op.node == BinOpKind::Eq;\n-            if match_type(cx,\n-                       cx.typeck_results().expr_ty(filter_recv).peel_refs(),\n-                       &paths::SLICE_ITER);\n-            let operand_is_arg = |expr| {\n-                let expr = peel_ref_operators(cx, peel_blocks(expr));\n-                path_to_local_id(expr, arg_id)\n-            };\n-            let needle = if operand_is_arg(l) {\n-                r\n-            } else if operand_is_arg(r) {\n-                l\n-            } else {\n-                return;\n-            };\n-            if ty::Uint(UintTy::U8) == *cx.typeck_results().expr_ty(needle).peel_refs().kind();\n-            if !is_local_used(cx, needle, arg_id);\n-            then {\n-                let haystack = if let ExprKind::MethodCall(path, args, _) =\n-                        filter_recv.kind {\n-                    let p = path.ident.name;\n-                    if (p == sym::iter || p == sym!(iter_mut)) && args.len() == 1 {\n-                        &args[0]\n-                    } else {\n-                        filter_recv\n-                    }\n-                } else {\n-                    filter_recv\n-                };\n-                let mut applicability = Applicability::MaybeIncorrect;\n-                span_lint_and_sugg(\n-                    cx,\n-                    NAIVE_BYTECOUNT,\n-                    expr.span,\n-                    \"you appear to be counting bytes the naive way\",\n-                    \"consider using the bytecount crate\",\n-                    format!(\"bytecount::count({}, {})\",\n-                            snippet_with_applicability(cx, haystack.span, \"..\", &mut applicability),\n-                            snippet_with_applicability(cx, needle.span, \"..\", &mut applicability)),\n-                    applicability,\n-                );\n-            }\n-        };\n-    }\n-}"}, {"sha": "d70dbf5b23904aa282d7be16b3c025add46f1781", "filename": "src/tools/clippy/clippy_lints/src/bytes_count_to_len.rs", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytes_count_to_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytes_count_to_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytes_count_to_len.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,70 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{match_def_path, paths};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir as hir;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// It checks for `str::bytes().count()` and suggests replacing it with\n-    /// `str::len()`.\n-    ///\n-    /// ### Why is this bad?\n-    /// `str::bytes().count()` is longer and may not be as performant as using\n-    /// `str::len()`.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// \"hello\".bytes().count();\n-    /// String::from(\"hello\").bytes().count();\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// \"hello\".len();\n-    /// String::from(\"hello\").len();\n-    /// ```\n-    #[clippy::version = \"1.62.0\"]\n-    pub BYTES_COUNT_TO_LEN,\n-    complexity,\n-    \"Using `bytes().count()` when `len()` performs the same functionality\"\n-}\n-\n-declare_lint_pass!(BytesCountToLen => [BYTES_COUNT_TO_LEN]);\n-\n-impl<'tcx> LateLintPass<'tcx> for BytesCountToLen {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if_chain! {\n-            if let hir::ExprKind::MethodCall(_, expr_args, _) = &expr.kind;\n-            if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n-            if match_def_path(cx, expr_def_id, &paths::ITER_COUNT);\n-\n-            if let [bytes_expr] = &**expr_args;\n-            if let hir::ExprKind::MethodCall(_, bytes_args, _) = &bytes_expr.kind;\n-            if let Some(bytes_def_id) = cx.typeck_results().type_dependent_def_id(bytes_expr.hir_id);\n-            if match_def_path(cx, bytes_def_id, &paths::STR_BYTES);\n-\n-            if let [str_expr] = &**bytes_args;\n-            let ty = cx.typeck_results().expr_ty(str_expr).peel_refs();\n-\n-            if is_type_diagnostic_item(cx, ty, sym::String) || ty.kind() == &ty::Str;\n-            then {\n-                let mut applicability = Applicability::MachineApplicable;\n-                span_lint_and_sugg(\n-                    cx,\n-                    BYTES_COUNT_TO_LEN,\n-                    expr.span,\n-                    \"using long and hard to read `.bytes().count()`\",\n-                    \"consider calling `.len()` instead\",\n-                    format!(\"{}.len()\", snippet_with_applicability(cx, str_expr.span, \"..\", &mut applicability)),\n-                    applicability\n-                );\n-            }\n-        };\n-    }\n-}"}, {"sha": "7eff71d5007432772486ee84553434ae641eecd4", "filename": "src/tools/clippy/clippy_lints/src/case_sensitive_file_extension_comparisons.rs", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,86 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n-use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n-use rustc_hir::{Expr, ExprKind, PathSegment};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{source_map::Spanned, symbol::sym, Span};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for calls to `ends_with` with possible file extensions\n-    /// and suggests to use a case-insensitive approach instead.\n-    ///\n-    /// ### Why is this bad?\n-    /// `ends_with` is case-sensitive and may not detect files with a valid extension.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// fn is_rust_file(filename: &str) -> bool {\n-    ///     filename.ends_with(\".rs\")\n-    /// }\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// fn is_rust_file(filename: &str) -> bool {\n-    ///     let filename = std::path::Path::new(filename);\n-    ///     filename.extension()\n-    ///         .map(|ext| ext.eq_ignore_ascii_case(\"rs\"))\n-    ///         .unwrap_or(false)\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.51.0\"]\n-    pub CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n-    pedantic,\n-    \"Checks for calls to ends_with with case-sensitive file extensions\"\n-}\n-\n-declare_lint_pass!(CaseSensitiveFileExtensionComparisons => [CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS]);\n-\n-fn check_case_sensitive_file_extension_comparison(ctx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Span> {\n-    if_chain! {\n-        if let ExprKind::MethodCall(PathSegment { ident, .. }, [obj, extension, ..], span) = expr.kind;\n-        if ident.as_str() == \"ends_with\";\n-        if let ExprKind::Lit(Spanned { node: LitKind::Str(ext_literal, ..), ..}) = extension.kind;\n-        if (2..=6).contains(&ext_literal.as_str().len());\n-        if ext_literal.as_str().starts_with('.');\n-        if ext_literal.as_str().chars().skip(1).all(|c| c.is_uppercase() || c.is_ascii_digit())\n-            || ext_literal.as_str().chars().skip(1).all(|c| c.is_lowercase() || c.is_ascii_digit());\n-        then {\n-            let mut ty = ctx.typeck_results().expr_ty(obj);\n-            ty = match ty.kind() {\n-                ty::Ref(_, ty, ..) => *ty,\n-                _ => ty\n-            };\n-\n-            match ty.kind() {\n-                ty::Str => {\n-                    return Some(span);\n-                },\n-                ty::Adt(def, _) => {\n-                    if ctx.tcx.is_diagnostic_item(sym::String, def.did()) {\n-                        return Some(span);\n-                    }\n-                },\n-                _ => { return None; }\n-            }\n-        }\n-    }\n-    None\n-}\n-\n-impl<'tcx> LateLintPass<'tcx> for CaseSensitiveFileExtensionComparisons {\n-    fn check_expr(&mut self, ctx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if let Some(span) = check_case_sensitive_file_extension_comparison(ctx, expr) {\n-            span_lint_and_help(\n-                ctx,\n-                CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n-                span,\n-                \"case-sensitive file extension comparison\",\n-                None,\n-                \"consider using a case-insensitive comparison instead\",\n-            );\n-        }\n-    }\n-}"}, {"sha": "56e894c6261eeb27884db1f098eea1e145aca589", "filename": "src/tools/clippy/clippy_lints/src/casts/as_underscore.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fas_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fas_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fas_underscore.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,25 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, Ty, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+\n+use super::AS_UNDERSCORE;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, ty: &'tcx Ty<'_>) {\n+    if matches!(ty.kind, TyKind::Infer) {\n+        span_lint_and_then(cx, AS_UNDERSCORE, expr.span, \"using `as _` conversion\", |diag| {\n+            let ty_resolved = cx.typeck_results().expr_ty(expr);\n+            if let ty::Error(_) = ty_resolved.kind() {\n+                diag.help(\"consider giving the type explicitly\");\n+            } else {\n+                diag.span_suggestion(\n+                    ty.span,\n+                    \"consider giving the type explicitly\",\n+                    ty_resolved,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        });\n+    }\n+}"}, {"sha": "6e1f8cd64f077936122944ef2fa61792a356cbf2", "filename": "src/tools/clippy/clippy_lints/src/casts/borrow_as_ptr.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fborrow_as_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fborrow_as_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fborrow_as_ptr.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,37 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_no_std_crate;\n+use clippy_utils::source::snippet_with_context;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability, Ty, TyKind};\n+use rustc_lint::LateContext;\n+\n+use super::BORROW_AS_PTR;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    cast_expr: &'tcx Expr<'_>,\n+    cast_to: &'tcx Ty<'_>,\n+) {\n+    if matches!(cast_to.kind, TyKind::Ptr(_))\n+        && let ExprKind::AddrOf(BorrowKind::Ref, mutability, e) = cast_expr.kind\n+    {\n+        let core_or_std = if is_no_std_crate(cx) { \"core\" } else { \"std\" };\n+        let macro_name = match mutability {\n+            Mutability::Not => \"addr_of\",\n+            Mutability::Mut => \"addr_of_mut\",\n+        };\n+        let mut app = Applicability::MachineApplicable;\n+        let snip = snippet_with_context(cx, e.span, cast_expr.span.ctxt(), \"..\", &mut app).0;\n+\n+        span_lint_and_sugg(\n+            cx,\n+            BORROW_AS_PTR,\n+            expr.span,\n+            \"borrow as raw pointer\",\n+            \"try\",\n+            format!(\"{}::ptr::{}!({})\", core_or_std, macro_name, snip),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}"}, {"sha": "284ef165998a7f46cbfaa7b9060cb81dc42fe9a7", "filename": "src/tools/clippy/clippy_lints/src/casts/cast_slice_from_raw_parts.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_slice_from_raw_parts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_slice_from_raw_parts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_slice_from_raw_parts.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,63 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{match_def_path, meets_msrv, msrvs, paths};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{def_id::DefId, Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_semver::RustcVersion;\n+\n+use super::CAST_SLICE_FROM_RAW_PARTS;\n+\n+enum RawPartsKind {\n+    Immutable,\n+    Mutable,\n+}\n+\n+fn raw_parts_kind(cx: &LateContext<'_>, did: DefId) -> Option<RawPartsKind> {\n+    if match_def_path(cx, did, &paths::SLICE_FROM_RAW_PARTS) {\n+        Some(RawPartsKind::Immutable)\n+    } else if match_def_path(cx, did, &paths::SLICE_FROM_RAW_PARTS_MUT) {\n+        Some(RawPartsKind::Mutable)\n+    } else {\n+        None\n+    }\n+}\n+\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    cast_expr: &Expr<'_>,\n+    cast_to: Ty<'_>,\n+    msrv: Option<RustcVersion>,\n+) {\n+    if_chain! {\n+        if meets_msrv(msrv, msrvs::PTR_SLICE_RAW_PARTS);\n+        if let ty::RawPtr(ptrty) = cast_to.kind();\n+        if let ty::Slice(_) = ptrty.ty.kind();\n+        if let ExprKind::Call(fun, [ptr_arg, len_arg]) = cast_expr.peel_blocks().kind;\n+        if let ExprKind::Path(ref qpath) = fun.kind;\n+        if let Some(fun_def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n+        if let Some(rpk) = raw_parts_kind(cx, fun_def_id);\n+        then {\n+            let func = match rpk {\n+                RawPartsKind::Immutable => \"from_raw_parts\",\n+                RawPartsKind::Mutable => \"from_raw_parts_mut\"\n+            };\n+            let span = expr.span;\n+            let mut applicability = Applicability::MachineApplicable;\n+            let ptr = snippet_with_applicability(cx, ptr_arg.span, \"ptr\", &mut applicability);\n+            let len = snippet_with_applicability(cx, len_arg.span, \"len\", &mut applicability);\n+            span_lint_and_sugg(\n+                cx,\n+                CAST_SLICE_FROM_RAW_PARTS,\n+                span,\n+                &format!(\"casting the result of `{func}` to {cast_to}\"),\n+                \"replace with\",\n+                format!(\"core::ptr::slice_{func}({ptr}, {len})\"),\n+                applicability\n+            );\n+        }\n+    }\n+}"}, {"sha": "cc5d346b954e3d393e71fa6090c4bcc0839bafa7", "filename": "src/tools/clippy/clippy_lints/src/casts/mod.rs", "status": "modified", "additions": 104, "deletions": 5, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fmod.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,3 +1,5 @@\n+mod as_underscore;\n+mod borrow_as_ptr;\n mod cast_abs_to_unsigned;\n mod cast_enum_constructor;\n mod cast_lossless;\n@@ -8,6 +10,7 @@ mod cast_ptr_alignment;\n mod cast_ref_to_mut;\n mod cast_sign_loss;\n mod cast_slice_different_sizes;\n+mod cast_slice_from_raw_parts;\n mod char_lit_as_u8;\n mod fn_to_numeric_cast;\n mod fn_to_numeric_cast_any;\n@@ -16,7 +19,7 @@ mod ptr_as_ptr;\n mod unnecessary_cast;\n mod utils;\n \n-use clippy_utils::is_hir_ty_cfg_dependant;\n+use clippy_utils::{is_hir_ty_cfg_dependant, meets_msrv, msrvs};\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -506,6 +509,93 @@ declare_clippy_lint! {\n     \"casting the result of `abs()` to an unsigned integer can panic\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Check for the usage of `as _` conversion using inferred type.\n+    ///\n+    /// ### Why is this bad?\n+    /// The conversion might include lossy conversion and dangerous cast that might go\n+    /// undetected due to the type being inferred.\n+    ///\n+    /// The lint is allowed by default as using `_` is less wordy than always specifying the type.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// fn foo(n: usize) {}\n+    /// let n: u16 = 256;\n+    /// foo(n as _);\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn foo(n: usize) {}\n+    /// let n: u16 = 256;\n+    /// foo(n as usize);\n+    /// ```\n+    #[clippy::version = \"1.63.0\"]\n+    pub AS_UNDERSCORE,\n+    restriction,\n+    \"detects `as _` conversion\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for the usage of `&expr as *const T` or\n+    /// `&mut expr as *mut T`, and suggest using `ptr::addr_of` or\n+    /// `ptr::addr_of_mut` instead.\n+    ///\n+    /// ### Why is this bad?\n+    /// This would improve readability and avoid creating a reference\n+    /// that points to an uninitialized value or unaligned place.\n+    /// Read the `ptr::addr_of` docs for more information.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let val = 1;\n+    /// let p = &val as *const i32;\n+    ///\n+    /// let mut val_mut = 1;\n+    /// let p_mut = &mut val_mut as *mut i32;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let val = 1;\n+    /// let p = std::ptr::addr_of!(val);\n+    ///\n+    /// let mut val_mut = 1;\n+    /// let p_mut = std::ptr::addr_of_mut!(val_mut);\n+    /// ```\n+    #[clippy::version = \"1.60.0\"]\n+    pub BORROW_AS_PTR,\n+    pedantic,\n+    \"borrowing just to cast to a raw pointer\"\n+}\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for a raw slice being cast to a slice pointer\n+    ///\n+    /// ### Why is this bad?\n+    /// This can result in multiple `&mut` references to the same location when only a pointer is\n+    /// required.\n+    /// `ptr::slice_from_raw_parts` is a safe alternative that doesn't require\n+    /// the same [safety requirements] to be upheld.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// let _: *const [u8] = std::slice::from_raw_parts(ptr, len) as *const _;\n+    /// let _: *mut [u8] = std::slice::from_raw_parts_mut(ptr, len) as *mut _;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// let _: *const [u8] = std::ptr::slice_from_raw_parts(ptr, len);\n+    /// let _: *mut [u8] = std::ptr::slice_from_raw_parts_mut(ptr, len);\n+    /// ```\n+    /// [safety requirements]: https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html#safety\n+    #[clippy::version = \"1.64.0\"]\n+    pub CAST_SLICE_FROM_RAW_PARTS,\n+    suspicious,\n+    \"casting a slice created from a pointer and length to a slice pointer\"\n+}\n+\n pub struct Casts {\n     msrv: Option<RustcVersion>,\n }\n@@ -534,7 +624,10 @@ impl_lint_pass!(Casts => [\n     PTR_AS_PTR,\n     CAST_ENUM_TRUNCATION,\n     CAST_ENUM_CONSTRUCTOR,\n-    CAST_ABS_TO_UNSIGNED\n+    CAST_ABS_TO_UNSIGNED,\n+    AS_UNDERSCORE,\n+    BORROW_AS_PTR,\n+    CAST_SLICE_FROM_RAW_PARTS\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Casts {\n@@ -547,8 +640,8 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n             return;\n         }\n \n-        if let ExprKind::Cast(cast_expr, cast_to) = expr.kind {\n-            if is_hir_ty_cfg_dependant(cx, cast_to) {\n+        if let ExprKind::Cast(cast_expr, cast_to_hir) = expr.kind {\n+            if is_hir_ty_cfg_dependant(cx, cast_to_hir) {\n                 return;\n             }\n             let (cast_from, cast_to) = (\n@@ -559,7 +652,7 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n             if unnecessary_cast::check(cx, expr, cast_expr, cast_from, cast_to) {\n                 return;\n             }\n-\n+            cast_slice_from_raw_parts::check(cx, expr, cast_expr, cast_to, self.msrv);\n             fn_to_numeric_cast_any::check(cx, expr, cast_expr, cast_from, cast_to);\n             fn_to_numeric_cast::check(cx, expr, cast_expr, cast_from, cast_to);\n             fn_to_numeric_cast_with_truncation::check(cx, expr, cast_expr, cast_from, cast_to);\n@@ -575,6 +668,12 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n                 cast_lossless::check(cx, expr, cast_expr, cast_from, cast_to, self.msrv);\n                 cast_enum_constructor::check(cx, expr, cast_expr, cast_from);\n             }\n+\n+            as_underscore::check(cx, expr, cast_to_hir);\n+\n+            if meets_msrv(self.msrv, msrvs::BORROW_AS_PTR) {\n+                borrow_as_ptr::check(cx, expr, cast_expr, cast_to_hir);\n+            }\n         }\n \n         cast_ref_to_mut::check(cx, expr);"}, {"sha": "19d2e6e1d1298e448619d608056a591ba13d88eb", "filename": "src/tools/clippy/clippy_lints/src/casts/unnecessary_cast.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -90,13 +90,20 @@ pub(super) fn check<'tcx>(\n \n fn lint_unnecessary_cast(cx: &LateContext<'_>, expr: &Expr<'_>, literal_str: &str, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n     let literal_kind_name = if cast_from.is_integral() { \"integer\" } else { \"float\" };\n+    let replaced_literal;\n+    let matchless = if literal_str.contains(['(', ')']) {\n+        replaced_literal = literal_str.replace(['(', ')'], \"\");\n+        &replaced_literal\n+    } else {\n+        literal_str\n+    };\n     span_lint_and_sugg(\n         cx,\n         UNNECESSARY_CAST,\n         expr.span,\n         &format!(\"casting {} literal to `{}` is unnecessary\", literal_kind_name, cast_to),\n         \"try\",\n-        format!(\"{}_{}\", literal_str.trim_end_matches('.'), cast_to),\n+        format!(\"{}_{}\", matchless.trim_end_matches('.'), cast_to),\n         Applicability::MachineApplicable,\n     );\n }"}, {"sha": "1506ea604f0dd21ab827db4062d57bd9a2939532", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 280, "deletions": 32, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,24 +1,34 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::sugg::has_enclosing_paren;\n-use clippy_utils::ty::{expr_sig, peel_mid_ty_refs, ty_sig, variant_of_res};\n-use clippy_utils::{get_parent_expr, get_parent_expr_for_hir, is_lint_allowed, path_to_local, walk_to_expr_usage};\n+use clippy_utils::ty::{expr_sig, is_copy, peel_mid_ty_refs, ty_sig, variant_of_res};\n+use clippy_utils::{\n+    fn_def_id, get_parent_expr, get_parent_expr_for_hir, is_lint_allowed, meets_msrv, msrvs, path_to_local,\n+    walk_to_expr_usage,\n+};\n use rustc_ast::util::parser::{PREC_POSTFIX, PREC_PREFIX};\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_ty, Visitor};\n use rustc_hir::{\n-    self as hir, BindingAnnotation, Body, BodyId, BorrowKind, Closure, Expr, ExprKind, FnRetTy, GenericArg, HirId,\n-    ImplItem, ImplItemKind, Item, ItemKind, Local, MatchSource, Mutability, Node, Pat, PatKind, Path, QPath, TraitItem,\n-    TraitItemKind, TyKind, UnOp,\n+    self as hir, def_id::DefId, BindingAnnotation, Body, BodyId, BorrowKind, Closure, Expr, ExprKind, FnRetTy,\n+    GenericArg, HirId, ImplItem, ImplItemKind, Item, ItemKind, Local, MatchSource, Mutability, Node, Pat, PatKind,\n+    Path, QPath, TraitItem, TraitItemKind, TyKind, UnOp,\n };\n+use rustc_index::bit_set::BitSet;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n-use rustc_middle::ty::{self, Binder, BoundVariableKind, List, Ty, TyCtxt, TypeVisitable, TypeckResults};\n+use rustc_middle::ty::{\n+    self, subst::Subst, Binder, BoundVariableKind, EarlyBinder, FnSig, GenericArgKind, List, ParamTy, PredicateKind,\n+    ProjectionPredicate, Ty, TyCtxt, TypeVisitable, TypeckResults,\n+};\n+use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{symbol::sym, Span, Symbol, DUMMY_SP};\n-use rustc_trait_selection::infer::InferCtxtExt;\n+use rustc_trait_selection::infer::InferCtxtExt as _;\n+use rustc_trait_selection::traits::{query::evaluate_obligation::InferCtxtExt as _, Obligation, ObligationCause};\n+use std::collections::VecDeque;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -151,13 +161,27 @@ pub struct Dereferencing {\n     /// been finished. Note we can't lint at the end of every body as they can be nested within each\n     /// other.\n     current_body: Option<BodyId>,\n+\n     /// The list of locals currently being checked by the lint.\n     /// If the value is `None`, then the binding has been seen as a ref pattern, but is not linted.\n     /// This is needed for or patterns where one of the branches can be linted, but another can not\n     /// be.\n     ///\n     /// e.g. `m!(x) | Foo::Bar(ref x)`\n     ref_locals: FxIndexMap<HirId, Option<RefPat>>,\n+\n+    // `IntoIterator` for arrays requires Rust 1.53.\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl Dereferencing {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self {\n+            msrv,\n+            ..Dereferencing::default()\n+        }\n+    }\n }\n \n struct StateData {\n@@ -170,6 +194,7 @@ struct StateData {\n struct DerefedBorrow {\n     count: usize,\n     msg: &'static str,\n+    snip_expr: Option<HirId>,\n }\n \n enum State {\n@@ -250,7 +275,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n         match (self.state.take(), kind) {\n             (None, kind) => {\n                 let expr_ty = typeck.expr_ty(expr);\n-                let (position, adjustments) = walk_parents(cx, expr);\n+                let (position, adjustments) = walk_parents(cx, expr, self.msrv);\n \n                 match kind {\n                     RefOp::Deref => {\n@@ -331,20 +356,23 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                         let deref_msg =\n                             \"this expression creates a reference which is immediately dereferenced by the compiler\";\n                         let borrow_msg = \"this expression borrows a value the compiler would automatically borrow\";\n+                        let impl_msg = \"the borrowed expression implements the required traits\";\n \n-                        let (required_refs, msg) = if position.can_auto_borrow() {\n-                            (1, if deref_count == 1 { borrow_msg } else { deref_msg })\n+                        let (required_refs, msg, snip_expr) = if position.can_auto_borrow() {\n+                            (1, if deref_count == 1 { borrow_msg } else { deref_msg }, None)\n+                        } else if let Position::ImplArg(hir_id) = position {\n+                            (0, impl_msg, Some(hir_id))\n                         } else if let Some(&Adjust::Borrow(AutoBorrow::Ref(_, mutability))) =\n                             next_adjust.map(|a| &a.kind)\n                         {\n                             if matches!(mutability, AutoBorrowMutability::Mut { .. }) && !position.is_reborrow_stable()\n                             {\n-                                (3, deref_msg)\n+                                (3, deref_msg, None)\n                             } else {\n-                                (2, deref_msg)\n+                                (2, deref_msg, None)\n                             }\n                         } else {\n-                            (2, deref_msg)\n+                            (2, deref_msg, None)\n                         };\n \n                         if deref_count >= required_refs {\n@@ -354,6 +382,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                                     // can't be removed without breaking the code. See earlier comment.\n                                     count: deref_count - required_refs,\n                                     msg,\n+                                    snip_expr,\n                                 }),\n                                 StateData { span: expr.span, hir_id: expr.hir_id, position },\n                             ));\n@@ -510,7 +539,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                             spans: vec![pat.span],\n                             app,\n                             replacements: vec![(pat.span, snip.into())],\n-                            hir_id: pat.hir_id\n+                            hir_id: pat.hir_id,\n                         }),\n                     );\n                 }\n@@ -542,6 +571,8 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n             self.current_body = None;\n         }\n     }\n+\n+    extract_msrv_attr!(LateContext);\n }\n \n fn try_parse_ref_op<'tcx>(\n@@ -594,6 +625,7 @@ enum Position {\n     /// The method is defined on a reference type. e.g. `impl Foo for &T`\n     MethodReceiverRefImpl,\n     Callee,\n+    ImplArg(HirId),\n     FieldAccess(Symbol),\n     Postfix,\n     Deref,\n@@ -630,7 +662,7 @@ impl Position {\n             | Self::Callee\n             | Self::FieldAccess(_)\n             | Self::Postfix => PREC_POSTFIX,\n-            Self::Deref => PREC_PREFIX,\n+            Self::ImplArg(_) | Self::Deref => PREC_PREFIX,\n             Self::DerefStable(p, _) | Self::ReborrowStable(p) | Self::Other(p) => p,\n         }\n     }\n@@ -639,8 +671,12 @@ impl Position {\n /// Walks up the parent expressions attempting to determine both how stable the auto-deref result\n /// is, and which adjustments will be applied to it. Note this will not consider auto-borrow\n /// locations as those follow different rules.\n-#[allow(clippy::too_many_lines)]\n-fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &'tcx [Adjustment<'tcx>]) {\n+#[expect(clippy::too_many_lines)]\n+fn walk_parents<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    msrv: Option<RustcVersion>,\n+) -> (Position, &'tcx [Adjustment<'tcx>]) {\n     let mut adjustments = [].as_slice();\n     let mut precedence = 0i8;\n     let ctxt = e.span.ctxt();\n@@ -745,13 +781,20 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                     .iter()\n                     .position(|arg| arg.hir_id == child_id)\n                     .zip(expr_sig(cx, func))\n-                    .and_then(|(i, sig)| sig.input_with_hir(i))\n-                    .map(|(hir_ty, ty)| match hir_ty {\n-                        // Type inference for closures can depend on how they're called. Only go by the explicit\n-                        // types here.\n-                        Some(hir_ty) => binding_ty_auto_deref_stability(cx, hir_ty, precedence, ty.bound_vars()),\n-                        None => ty_auto_deref_stability(cx, cx.tcx.erase_late_bound_regions(ty), precedence)\n-                            .position_for_arg(),\n+                    .and_then(|(i, sig)| {\n+                        sig.input_with_hir(i).map(|(hir_ty, ty)| match hir_ty {\n+                            // Type inference for closures can depend on how they're called. Only go by the explicit\n+                            // types here.\n+                            Some(hir_ty) => binding_ty_auto_deref_stability(cx, hir_ty, precedence, ty.bound_vars()),\n+                            None => {\n+                                if let ty::Param(param_ty) = ty.skip_binder().kind() {\n+                                    needless_borrow_impl_arg_position(cx, parent, i, *param_ty, e, precedence, msrv)\n+                                } else {\n+                                    ty_auto_deref_stability(cx, cx.tcx.erase_late_bound_regions(ty), precedence)\n+                                        .position_for_arg()\n+                                }\n+                            },\n+                        })\n                     }),\n                 ExprKind::MethodCall(_, args, _) => {\n                     let id = cx.typeck_results().type_dependent_def_id(parent.hir_id).unwrap();\n@@ -773,7 +816,7 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                                     .and_then(|subs| subs.get(1..))\n                                 {\n                                     Some(subs) => cx.tcx.mk_substs(subs.iter().copied()),\n-                                    None => cx.tcx.mk_substs([].iter()),\n+                                    None => cx.tcx.mk_substs(std::iter::empty::<ty::subst::GenericArg<'_>>()),\n                                 } && let impl_ty = if cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref() {\n                                     // Trait methods taking `&self`\n                                     sub_ty\n@@ -792,12 +835,17 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                                 Position::MethodReceiver\n                             }\n                         } else {\n-                            ty_auto_deref_stability(\n-                                cx,\n-                                cx.tcx.erase_late_bound_regions(cx.tcx.fn_sig(id).input(i)),\n-                                precedence,\n-                            )\n-                            .position_for_arg()\n+                            let ty = cx.tcx.fn_sig(id).skip_binder().inputs()[i];\n+                            if let ty::Param(param_ty) = ty.kind() {\n+                                needless_borrow_impl_arg_position(cx, parent, i, *param_ty, e, precedence, msrv)\n+                            } else {\n+                                ty_auto_deref_stability(\n+                                    cx,\n+                                    cx.tcx.erase_late_bound_regions(cx.tcx.fn_sig(id).input(i)),\n+                                    precedence,\n+                                )\n+                                .position_for_arg()\n+                            }\n                         }\n                     })\n                 },\n@@ -948,6 +996,205 @@ fn ty_contains_infer(ty: &hir::Ty<'_>) -> bool {\n     v.0\n }\n \n+// Checks whether:\n+// * child is an expression of the form `&e` in an argument position requiring an `impl Trait`\n+// * `e`'s type implements `Trait` and is copyable\n+// If the conditions are met, returns `Some(Position::ImplArg(..))`; otherwise, returns `None`.\n+//   The \"is copyable\" condition is to avoid the case where removing the `&` means `e` would have to\n+// be moved, but it cannot be.\n+fn needless_borrow_impl_arg_position<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    parent: &Expr<'tcx>,\n+    arg_index: usize,\n+    param_ty: ParamTy,\n+    mut expr: &Expr<'tcx>,\n+    precedence: i8,\n+    msrv: Option<RustcVersion>,\n+) -> Position {\n+    let destruct_trait_def_id = cx.tcx.lang_items().destruct_trait();\n+    let sized_trait_def_id = cx.tcx.lang_items().sized_trait();\n+\n+    let Some(callee_def_id) = fn_def_id(cx, parent) else { return Position::Other(precedence) };\n+    let fn_sig = cx.tcx.fn_sig(callee_def_id).skip_binder();\n+    let substs_with_expr_ty = cx\n+        .typeck_results()\n+        .node_substs(if let ExprKind::Call(callee, _) = parent.kind {\n+            callee.hir_id\n+        } else {\n+            parent.hir_id\n+        });\n+\n+    let predicates = cx.tcx.param_env(callee_def_id).caller_bounds();\n+    let projection_predicates = predicates\n+        .iter()\n+        .filter_map(|predicate| {\n+            if let PredicateKind::Projection(projection_predicate) = predicate.kind().skip_binder() {\n+                Some(projection_predicate)\n+            } else {\n+                None\n+            }\n+        })\n+        .collect::<Vec<_>>();\n+\n+    let mut trait_with_ref_mut_self_method = false;\n+\n+    // If no traits were found, or only the `Destruct`, `Sized`, or `Any` traits were found, return.\n+    if predicates\n+        .iter()\n+        .filter_map(|predicate| {\n+            if let PredicateKind::Trait(trait_predicate) = predicate.kind().skip_binder()\n+                && trait_predicate.trait_ref.self_ty() == param_ty.to_ty(cx.tcx)\n+            {\n+                Some(trait_predicate.trait_ref.def_id)\n+            } else {\n+                None\n+            }\n+        })\n+        .inspect(|trait_def_id| {\n+            trait_with_ref_mut_self_method |= has_ref_mut_self_method(cx, *trait_def_id);\n+        })\n+        .all(|trait_def_id| {\n+            Some(trait_def_id) == destruct_trait_def_id\n+                || Some(trait_def_id) == sized_trait_def_id\n+                || cx.tcx.is_diagnostic_item(sym::Any, trait_def_id)\n+        })\n+    {\n+        return Position::Other(precedence);\n+    }\n+\n+    // `substs_with_referent_ty` can be constructed outside of `check_referent` because the same\n+    // elements are modified each time `check_referent` is called.\n+    let mut substs_with_referent_ty = substs_with_expr_ty.to_vec();\n+\n+    let mut check_referent = |referent| {\n+        let referent_ty = cx.typeck_results().expr_ty(referent);\n+\n+        if !is_copy(cx, referent_ty) {\n+            return false;\n+        }\n+\n+        // https://github.com/rust-lang/rust-clippy/pull/9136#pullrequestreview-1037379321\n+        if trait_with_ref_mut_self_method && !matches!(referent_ty.kind(), ty::Ref(_, _, Mutability::Mut)) {\n+            return false;\n+        }\n+\n+        if !replace_types(\n+            cx,\n+            param_ty,\n+            referent_ty,\n+            fn_sig,\n+            arg_index,\n+            &projection_predicates,\n+            &mut substs_with_referent_ty,\n+        ) {\n+            return false;\n+        }\n+\n+        predicates.iter().all(|predicate| {\n+            if let PredicateKind::Trait(trait_predicate) = predicate.kind().skip_binder()\n+                && cx.tcx.is_diagnostic_item(sym::IntoIterator, trait_predicate.trait_ref.def_id)\n+                && let ty::Param(param_ty) = trait_predicate.self_ty().kind()\n+                && let GenericArgKind::Type(ty) = substs_with_referent_ty[param_ty.index as usize].unpack()\n+                && ty.is_array()\n+                && !meets_msrv(msrv, msrvs::ARRAY_INTO_ITERATOR)\n+            {\n+                return false;\n+            }\n+\n+            let predicate = EarlyBinder(predicate).subst(cx.tcx, &substs_with_referent_ty);\n+            let obligation = Obligation::new(ObligationCause::dummy(), cx.param_env, predicate);\n+            cx.tcx\n+                .infer_ctxt()\n+                .enter(|infcx| infcx.predicate_must_hold_modulo_regions(&obligation))\n+        })\n+    };\n+\n+    let mut needless_borrow = false;\n+    while let ExprKind::AddrOf(_, _, referent) = expr.kind {\n+        if !check_referent(referent) {\n+            break;\n+        }\n+        expr = referent;\n+        needless_borrow = true;\n+    }\n+\n+    if needless_borrow {\n+        Position::ImplArg(expr.hir_id)\n+    } else {\n+        Position::Other(precedence)\n+    }\n+}\n+\n+fn has_ref_mut_self_method(cx: &LateContext<'_>, trait_def_id: DefId) -> bool {\n+    cx.tcx\n+        .associated_items(trait_def_id)\n+        .in_definition_order()\n+        .any(|assoc_item| {\n+            if assoc_item.fn_has_self_parameter {\n+                let self_ty = cx.tcx.fn_sig(assoc_item.def_id).skip_binder().inputs()[0];\n+                matches!(self_ty.kind(), ty::Ref(_, _, Mutability::Mut))\n+            } else {\n+                false\n+            }\n+        })\n+}\n+\n+// Iteratively replaces `param_ty` with `new_ty` in `substs`, and similarly for each resulting\n+// projected type that is a type parameter. Returns `false` if replacing the types would have an\n+// effect on the function signature beyond substituting `new_ty` for `param_ty`.\n+// See: https://github.com/rust-lang/rust-clippy/pull/9136#discussion_r927212757\n+fn replace_types<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    param_ty: ParamTy,\n+    new_ty: Ty<'tcx>,\n+    fn_sig: FnSig<'tcx>,\n+    arg_index: usize,\n+    projection_predicates: &[ProjectionPredicate<'tcx>],\n+    substs: &mut [ty::GenericArg<'tcx>],\n+) -> bool {\n+    let mut replaced = BitSet::new_empty(substs.len());\n+\n+    let mut deque = VecDeque::with_capacity(substs.len());\n+    deque.push_back((param_ty, new_ty));\n+\n+    while let Some((param_ty, new_ty)) = deque.pop_front() {\n+        // If `replaced.is_empty()`, then `param_ty` and `new_ty` are those initially passed in.\n+        if !fn_sig\n+            .inputs_and_output\n+            .iter()\n+            .enumerate()\n+            .all(|(i, ty)| (replaced.is_empty() && i == arg_index) || !ty.contains(param_ty.to_ty(cx.tcx)))\n+        {\n+            return false;\n+        }\n+\n+        substs[param_ty.index as usize] = ty::GenericArg::from(new_ty);\n+\n+        // The `replaced.insert(...)` check provides some protection against infinite loops.\n+        if replaced.insert(param_ty.index) {\n+            for projection_predicate in projection_predicates {\n+                if projection_predicate.projection_ty.self_ty() == param_ty.to_ty(cx.tcx)\n+                    && let ty::Term::Ty(term_ty) = projection_predicate.term\n+                    && let ty::Param(term_param_ty) = term_ty.kind()\n+                {\n+                    let item_def_id = projection_predicate.projection_ty.item_def_id;\n+                    let assoc_item = cx.tcx.associated_item(item_def_id);\n+                    let projection = cx.tcx\n+                        .mk_projection(assoc_item.def_id, cx.tcx.mk_substs_trait(new_ty, &[]));\n+\n+                    if let Ok(projected_ty) = cx.tcx.try_normalize_erasing_regions(cx.param_env, projection)\n+                        && substs[term_param_ty.index as usize] != ty::GenericArg::from(projected_ty)\n+                    {\n+                        deque.push_back((*term_param_ty, projected_ty));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    true\n+}\n+\n struct TyPosition<'tcx> {\n     position: Position,\n     ty: Option<Ty<'tcx>>,\n@@ -1086,7 +1333,8 @@ fn report<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data\n         },\n         State::DerefedBorrow(state) => {\n             let mut app = Applicability::MachineApplicable;\n-            let (snip, snip_is_macro) = snippet_with_context(cx, expr.span, data.span.ctxt(), \"..\", &mut app);\n+            let snip_expr = state.snip_expr.map_or(expr, |hir_id| cx.tcx.hir().expect_expr(hir_id));\n+            let (snip, snip_is_macro) = snippet_with_context(cx, snip_expr.span, data.span.ctxt(), \"..\", &mut app);\n             span_lint_hir_and_then(cx, NEEDLESS_BORROW, data.hir_id, data.span, state.msg, |diag| {\n                 let calls_field = matches!(expr.kind, ExprKind::Field(..)) && matches!(data.position, Position::Callee);\n                 let sugg = if !snip_is_macro"}, {"sha": "9ca443b7dff6cbe67a24c5008dee96d2d09be293", "filename": "src/tools/clippy/clippy_lints/src/derive.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -516,7 +516,10 @@ fn param_env_for_derived_eq(tcx: TyCtxt<'_>, did: DefId, eq_trait_id: DefId) ->\n         tcx.mk_predicates(ty_predicates.iter().map(|&(p, _)| p).chain(\n             params.iter().filter(|&&(_, needs_eq)| needs_eq).map(|&(param, _)| {\n                 tcx.mk_predicate(Binder::dummy(PredicateKind::Trait(TraitPredicate {\n-                    trait_ref: TraitRef::new(eq_trait_id, tcx.mk_substs([tcx.mk_param_from_def(param)].into_iter())),\n+                    trait_ref: TraitRef::new(\n+                        eq_trait_id,\n+                        tcx.mk_substs(std::iter::once(tcx.mk_param_from_def(param))),\n+                    ),\n                     constness: BoundConstness::NotConst,\n                     polarity: ImplPolarity::Positive,\n                 })))"}, {"sha": "0ff1d2755daf6284c5babcdc77a6989e05497f61", "filename": "src/tools/clippy/clippy_lints/src/doc_link_with_quotes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc_link_with_quotes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc_link_with_quotes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc_link_with_quotes.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -21,7 +21,7 @@ declare_clippy_lint! {\n     /// /// See also: [`foo`]\n     /// fn bar() {}\n     /// ```\n-    #[clippy::version = \"1.60.0\"]\n+    #[clippy::version = \"1.63.0\"]\n     pub DOC_LINK_WITH_QUOTES,\n     pedantic,\n     \"possible typo for an intra-doc link\""}, {"sha": "7ff7068f0b05e56aec583ec5dd066ab280109193", "filename": "src/tools/clippy/clippy_lints/src/duplicate_mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduplicate_mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduplicate_mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduplicate_mod.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -39,7 +39,7 @@ declare_clippy_lint! {\n     /// // a.rs\n     /// use crate::b;\n     /// ```\n-    #[clippy::version = \"1.62.0\"]\n+    #[clippy::version = \"1.63.0\"]\n     pub DUPLICATE_MOD,\n     suspicious,\n     \"file loaded as module multiple times\""}, {"sha": "327865e4c858ab36e8166c5773aa505804a44cce", "filename": "src/tools/clippy/clippy_lints/src/escape.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::span_lint_hir;\n-use clippy_utils::ty::contains_ty;\n use rustc_hir::intravisit;\n use rustc_hir::{self, AssocItemKind, Body, FnDecl, HirId, HirIdSet, Impl, ItemKind, Node, Pat, PatKind};\n use rustc_infer::infer::TyCtxtInferExt;\n@@ -30,18 +29,12 @@ declare_clippy_lint! {\n     ///\n     /// ### Example\n     /// ```rust\n-    /// # fn foo(bar: usize) {}\n-    /// let x = Box::new(1);\n-    /// foo(*x);\n-    /// println!(\"{}\", *x);\n+    /// fn foo(x: Box<u32>) {}\n     /// ```\n     ///\n     /// Use instead:\n     /// ```rust\n-    /// # fn foo(bar: usize) {}\n-    /// let x = 1;\n-    /// foo(x);\n-    /// println!(\"{}\", x);\n+    /// fn foo(x: u32) {}\n     /// ```\n     #[clippy::version = \"pre 1.29.0\"]\n     pub BOXED_LOCAL,\n@@ -172,7 +165,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n                 // skip if there is a `self` parameter binding to a type\n                 // that contains `Self` (i.e.: `self: Box<Self>`), see #4804\n                 if let Some(trait_self_ty) = self.trait_self_ty {\n-                    if map.name(cmt.hir_id) == kw::SelfLower && contains_ty(cmt.place.ty(), trait_self_ty) {\n+                    if map.name(cmt.hir_id) == kw::SelfLower && cmt.place.ty().contains(trait_self_ty) {\n                         return;\n                     }\n                 }"}, {"sha": "bb50e8fcabbb712c15c4dd0cdae52368fbb8ae23", "filename": "src/tools/clippy/clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -172,7 +172,7 @@ fn check_log_base(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n             expr.span,\n             \"logarithm for bases 2, 10 and e can be computed more accurately\",\n             \"consider using\",\n-            format!(\"{}.{}()\", Sugg::hir(cx, &args[0], \"..\"), method),\n+            format!(\"{}.{}()\", Sugg::hir(cx, &args[0], \"..\").maybe_par(), method),\n             Applicability::MachineApplicable,\n         );\n     }\n@@ -263,21 +263,21 @@ fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n             (\n                 SUBOPTIMAL_FLOPS,\n                 \"square-root of a number can be computed more efficiently and accurately\",\n-                format!(\"{}.sqrt()\", Sugg::hir(cx, &args[0], \"..\")),\n+                format!(\"{}.sqrt()\", Sugg::hir(cx, &args[0], \"..\").maybe_par()),\n             )\n         } else if F32(1.0 / 3.0) == value || F64(1.0 / 3.0) == value {\n             (\n                 IMPRECISE_FLOPS,\n                 \"cube-root of a number can be computed more accurately\",\n-                format!(\"{}.cbrt()\", Sugg::hir(cx, &args[0], \"..\")),\n+                format!(\"{}.cbrt()\", Sugg::hir(cx, &args[0], \"..\").maybe_par()),\n             )\n         } else if let Some(exponent) = get_integer_from_float_constant(&value) {\n             (\n                 SUBOPTIMAL_FLOPS,\n                 \"exponentiation with integer powers can be computed more efficiently\",\n                 format!(\n                     \"{}.powi({})\",\n-                    Sugg::hir(cx, &args[0], \"..\"),\n+                    Sugg::hir(cx, &args[0], \"..\").maybe_par(),\n                     numeric_literal::format(&exponent.to_string(), None, false)\n                 ),\n             )\n@@ -327,7 +327,7 @@ fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n                         \"consider using\",\n                         format!(\n                             \"{}.mul_add({}, {})\",\n-                            Sugg::hir(cx, &args[0], \"..\"),\n+                            Sugg::hir(cx, &args[0], \"..\").maybe_par(),\n                             Sugg::hir(cx, &args[0], \"..\"),\n                             Sugg::hir(cx, other_addend, \"..\"),\n                         ),\n@@ -418,7 +418,7 @@ fn check_expm1(cx: &LateContext<'_>, expr: &Expr<'_>) {\n                 \"consider using\",\n                 format!(\n                     \"{}.exp_m1()\",\n-                    Sugg::hir(cx, self_arg, \"..\")\n+                    Sugg::hir(cx, self_arg, \"..\").maybe_par()\n                 ),\n                 Applicability::MachineApplicable,\n             );\n@@ -550,11 +550,11 @@ fn check_custom_abs(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         then {\n             let positive_abs_sugg = (\n                 \"manual implementation of `abs` method\",\n-                format!(\"{}.abs()\", Sugg::hir(cx, body, \"..\")),\n+                format!(\"{}.abs()\", Sugg::hir(cx, body, \"..\").maybe_par()),\n             );\n             let negative_abs_sugg = (\n                 \"manual implementation of negation of `abs` method\",\n-                format!(\"-{}.abs()\", Sugg::hir(cx, body, \"..\")),\n+                format!(\"-{}.abs()\", Sugg::hir(cx, body, \"..\").maybe_par()),\n             );\n             let sugg = if is_testing_positive(cx, cond, body) {\n                 if if_expr_positive {\n@@ -621,7 +621,7 @@ fn check_log_division(cx: &LateContext<'_>, expr: &Expr<'_>) {\n                 expr.span,\n                 \"log base can be expressed more clearly\",\n                 \"consider using\",\n-                format!(\"{}.log({})\", Sugg::hir(cx, largs_self, \"..\"), Sugg::hir(cx, rargs_self, \"..\"),),\n+                format!(\"{}.log({})\", Sugg::hir(cx, largs_self, \"..\").maybe_par(), Sugg::hir(cx, rargs_self, \"..\"),),\n                 Applicability::MachineApplicable,\n             );\n         }\n@@ -651,7 +651,7 @@ fn check_radians(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             if (F32(f32_consts::PI) == rvalue || F64(f64_consts::PI) == rvalue) &&\n                (F32(180_f32) == lvalue || F64(180_f64) == lvalue)\n             {\n-                let mut proposal = format!(\"{}.to_degrees()\", Sugg::hir(cx, mul_lhs, \"..\"));\n+                let mut proposal = format!(\"{}.to_degrees()\", Sugg::hir(cx, mul_lhs, \"..\").maybe_par());\n                 if_chain! {\n                     if let ExprKind::Lit(ref literal) = mul_lhs.kind;\n                     if let ast::LitKind::Float(ref value, float_type) = literal.node;\n@@ -677,7 +677,7 @@ fn check_radians(cx: &LateContext<'_>, expr: &Expr<'_>) {\n                 (F32(180_f32) == rvalue || F64(180_f64) == rvalue) &&\n                 (F32(f32_consts::PI) == lvalue || F64(f64_consts::PI) == lvalue)\n             {\n-                let mut proposal = format!(\"{}.to_radians()\", Sugg::hir(cx, mul_lhs, \"..\"));\n+                let mut proposal = format!(\"{}.to_radians()\", Sugg::hir(cx, mul_lhs, \"..\").maybe_par());\n                 if_chain! {\n                     if let ExprKind::Lit(ref literal) = mul_lhs.kind;\n                     if let ast::LitKind::Float(ref value, float_type) = literal.node;"}, {"sha": "0c5851cdbed2a4241e0a3f2d35901f311dd732ec", "filename": "src/tools/clippy/clippy_lints/src/format.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::macros::{root_macro_call_first_node, FormatArgsExpn};\n-use clippy_utils::source::{snippet_opt, snippet_with_applicability};\n+use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -56,29 +56,27 @@ impl<'tcx> LateLintPass<'tcx> for UselessFormat {\n         };\n \n         let mut applicability = Applicability::MachineApplicable;\n-        if format_args.value_args.is_empty() {\n-            match *format_args.format_string_parts {\n+        if format_args.args.is_empty() {\n+            match *format_args.format_string.parts {\n                 [] => span_useless_format_empty(cx, call_site, \"String::new()\".to_owned(), applicability),\n                 [_] => {\n-                    if let Some(s_src) = snippet_opt(cx, format_args.format_string_span) {\n-                        // Simulate macro expansion, converting {{ and }} to { and }.\n-                        let s_expand = s_src.replace(\"{{\", \"{\").replace(\"}}\", \"}\");\n-                        let sugg = format!(\"{}.to_string()\", s_expand);\n-                        span_useless_format(cx, call_site, sugg, applicability);\n-                    }\n+                    // Simulate macro expansion, converting {{ and }} to { and }.\n+                    let s_expand = format_args.format_string.snippet.replace(\"{{\", \"{\").replace(\"}}\", \"}\");\n+                    let sugg = format!(\"{}.to_string()\", s_expand);\n+                    span_useless_format(cx, call_site, sugg, applicability);\n                 },\n                 [..] => {},\n             }\n-        } else if let [value] = *format_args.value_args {\n+        } else if let [arg] = &*format_args.args {\n+            let value = arg.param.value;\n             if_chain! {\n-                if format_args.format_string_parts == [kw::Empty];\n+                if format_args.format_string.parts == [kw::Empty];\n                 if match cx.typeck_results().expr_ty(value).peel_refs().kind() {\n                     ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(sym::String, adt.did()),\n                     ty::Str => true,\n                     _ => false,\n                 };\n-                if let Some(args) = format_args.args();\n-                if args.iter().all(|arg| arg.format_trait == sym::Display && !arg.has_string_formatting());\n+                if !arg.format.has_string_formatting();\n                 then {\n                     let is_new_string = match value.kind {\n                         ExprKind::Binary(..) => true,"}, {"sha": "9fb9fd99748b4b63eabb571073dcba3306d938fb", "filename": "src/tools/clippy/clippy_lints/src/format_args.rs", "status": "modified", "additions": 51, "deletions": 43, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,11 +1,12 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::is_diag_trait_item;\n-use clippy_utils::macros::{is_format_macro, FormatArgsArg, FormatArgsExpn};\n+use clippy_utils::macros::{is_format_macro, FormatArgsExpn};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::implements_trait;\n use if_chain::if_chain;\n+use itertools::Itertools;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind};\n+use rustc_hir::{Expr, ExprKind, HirId};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n use rustc_middle::ty::Ty;\n@@ -74,20 +75,16 @@ impl<'tcx> LateLintPass<'tcx> for FormatArgs {\n             if let Some(macro_def_id) = outermost_expn_data.macro_def_id;\n             if is_format_macro(cx, macro_def_id);\n             if let ExpnKind::Macro(_, name) = outermost_expn_data.kind;\n-            if let Some(args) = format_args.args();\n             then {\n-                for (i, arg) in args.iter().enumerate() {\n-                    if arg.format_trait != sym::Display {\n+                for arg in &format_args.args {\n+                    if arg.format.has_string_formatting() {\n                         continue;\n                     }\n-                    if arg.has_string_formatting() {\n+                    if is_aliased(&format_args, arg.param.value.hir_id) {\n                         continue;\n                     }\n-                    if is_aliased(&args, i) {\n-                        continue;\n-                    }\n-                    check_format_in_format_args(cx, outermost_expn_data.call_site, name, arg.value);\n-                    check_to_string_in_format_args(cx, name, arg.value);\n+                    check_format_in_format_args(cx, outermost_expn_data.call_site, name, arg.param.value);\n+                    check_to_string_in_format_args(cx, name, arg.param.value);\n                 }\n             }\n         }\n@@ -134,45 +131,56 @@ fn check_to_string_in_format_args(cx: &LateContext<'_>, name: Symbol, value: &Ex\n         if is_diag_trait_item(cx, method_def_id, sym::ToString);\n         let receiver_ty = cx.typeck_results().expr_ty(receiver);\n         if let Some(display_trait_id) = cx.tcx.get_diagnostic_item(sym::Display);\n+        let (n_needed_derefs, target) =\n+            count_needed_derefs(receiver_ty, cx.typeck_results().expr_adjustments(receiver).iter());\n+        if implements_trait(cx, target, display_trait_id, &[]);\n+        if let Some(sized_trait_id) = cx.tcx.lang_items().sized_trait();\n         if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n         then {\n-            let (n_needed_derefs, target) = count_needed_derefs(\n-                receiver_ty,\n-                cx.typeck_results().expr_adjustments(receiver).iter(),\n-            );\n-            if implements_trait(cx, target, display_trait_id, &[]) {\n-                if n_needed_derefs == 0 {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        TO_STRING_IN_FORMAT_ARGS,\n-                        value.span.with_lo(receiver.span.hi()),\n-                        &format!(\"`to_string` applied to a type that implements `Display` in `{}!` args\", name),\n-                        \"remove this\",\n-                        String::new(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                } else {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        TO_STRING_IN_FORMAT_ARGS,\n-                        value.span,\n-                        &format!(\"`to_string` applied to a type that implements `Display` in `{}!` args\", name),\n-                        \"use this\",\n-                        format!(\"{:*>width$}{}\", \"\", receiver_snippet, width = n_needed_derefs),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n+            let needs_ref = !implements_trait(cx, receiver_ty, sized_trait_id, &[]);\n+            if n_needed_derefs == 0 && !needs_ref {\n+                span_lint_and_sugg(\n+                    cx,\n+                    TO_STRING_IN_FORMAT_ARGS,\n+                    value.span.with_lo(receiver.span.hi()),\n+                    &format!(\n+                        \"`to_string` applied to a type that implements `Display` in `{}!` args\",\n+                        name\n+                    ),\n+                    \"remove this\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else {\n+                span_lint_and_sugg(\n+                    cx,\n+                    TO_STRING_IN_FORMAT_ARGS,\n+                    value.span,\n+                    &format!(\n+                        \"`to_string` applied to a type that implements `Display` in `{}!` args\",\n+                        name\n+                    ),\n+                    \"use this\",\n+                    format!(\n+                        \"{}{:*>width$}{}\",\n+                        if needs_ref { \"&\" } else { \"\" },\n+                        \"\",\n+                        receiver_snippet,\n+                        width = n_needed_derefs\n+                    ),\n+                    Applicability::MachineApplicable,\n+                );\n             }\n         }\n     }\n }\n \n-// Returns true if `args[i]` \"refers to\" or \"is referred to by\" another argument.\n-fn is_aliased(args: &[FormatArgsArg<'_>], i: usize) -> bool {\n-    let value = args[i].value;\n-    args.iter()\n-        .enumerate()\n-        .any(|(j, arg)| i != j && std::ptr::eq(value, arg.value))\n+// Returns true if `hir_id` is referred to by multiple format params\n+fn is_aliased(args: &FormatArgsExpn<'_>, hir_id: HirId) -> bool {\n+    args.params()\n+        .filter(|param| param.value.hir_id == hir_id)\n+        .at_most_one()\n+        .is_err()\n }\n \n fn count_needed_derefs<'tcx, I>(mut ty: Ty<'tcx>, mut iter: I) -> (usize, Ty<'tcx>)"}, {"sha": "d8bc0bf08f2b314b8513902d14f6da434e229d74", "filename": "src/tools/clippy/clippy_lints/src/format_impl.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_impl.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n-use clippy_utils::macros::{is_format_macro, root_macro_call_first_node, FormatArgsArg, FormatArgsExpn};\n+use clippy_utils::macros::{is_format_macro, root_macro_call_first_node, FormatArg, FormatArgsExpn};\n use clippy_utils::{get_parent_as_impl, is_diag_trait_item, path_to_local, peel_ref_operators};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -168,10 +168,9 @@ fn check_self_in_format_args<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>,\n         if let macro_def_id = outer_macro.def_id;\n         if let Some(format_args) = FormatArgsExpn::find_nested(cx, expr, outer_macro.expn);\n         if is_format_macro(cx, macro_def_id);\n-        if let Some(args) = format_args.args();\n         then {\n-            for arg in args {\n-                if arg.format_trait != impl_trait.name {\n+            for arg in format_args.args {\n+                if arg.format.r#trait != impl_trait.name {\n                     continue;\n                 }\n                 check_format_arg_self(cx, expr, &arg, impl_trait);\n@@ -180,11 +179,11 @@ fn check_self_in_format_args<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>,\n     }\n }\n \n-fn check_format_arg_self(cx: &LateContext<'_>, expr: &Expr<'_>, arg: &FormatArgsArg<'_>, impl_trait: FormatTrait) {\n+fn check_format_arg_self(cx: &LateContext<'_>, expr: &Expr<'_>, arg: &FormatArg<'_>, impl_trait: FormatTrait) {\n     // Handle multiple dereferencing of references e.g. &&self\n     // Handle dereference of &self -> self that is equivalent (i.e. via *self in fmt() impl)\n     // Since the argument to fmt is itself a reference: &self\n-    let reference = peel_ref_operators(cx, arg.value);\n+    let reference = peel_ref_operators(cx, arg.param.value);\n     let map = cx.tcx.hir();\n     // Is the reference self?\n     if path_to_local(reference).map(|x| map.name(x)) == Some(kw::SelfLower) {"}, {"sha": "90911e0bf2595ca667b9b3f14b0a755c0e4290f6", "filename": "src/tools/clippy/clippy_lints/src/functions/mod.rs", "status": "modified", "additions": 51, "deletions": 5, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmod.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,6 +1,6 @@\n mod must_use;\n mod not_unsafe_ptr_arg_deref;\n-mod result_unit_err;\n+mod result;\n mod too_many_arguments;\n mod too_many_lines;\n \n@@ -217,17 +217,62 @@ declare_clippy_lint! {\n     \"public function returning `Result` with an `Err` type of `()`\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for functions that return `Result` with an unusually large\n+    /// `Err`-variant.\n+    ///\n+    /// ### Why is this bad?\n+    /// A `Result` is at least as large as the `Err`-variant. While we\n+    /// expect that variant to be seldomly used, the compiler needs to reserve\n+    /// and move that much memory every single time.\n+    ///\n+    /// ### Known problems\n+    /// The size determined by Clippy is platform-dependent.\n+    ///\n+    /// ### Examples\n+    /// ```rust\n+    /// pub enum ParseError {\n+    ///     UnparsedBytes([u8; 512]),\n+    ///     UnexpectedEof,\n+    /// }\n+    ///\n+    /// // The `Result` has at least 512 bytes, even in the `Ok`-case\n+    /// pub fn parse() -> Result<(), ParseError> {\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    /// should be\n+    /// ```\n+    /// pub enum ParseError {\n+    ///     UnparsedBytes(Box<[u8; 512]>),\n+    ///     UnexpectedEof,\n+    /// }\n+    ///\n+    /// // The `Result` is slightly larger than a pointer\n+    /// pub fn parse() -> Result<(), ParseError> {\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.64.0\"]\n+    pub RESULT_LARGE_ERR,\n+    perf,\n+    \"function returning `Result` with large `Err` type\"\n+}\n+\n #[derive(Copy, Clone)]\n pub struct Functions {\n     too_many_arguments_threshold: u64,\n     too_many_lines_threshold: u64,\n+    large_error_threshold: u64,\n }\n \n impl Functions {\n-    pub fn new(too_many_arguments_threshold: u64, too_many_lines_threshold: u64) -> Self {\n+    pub fn new(too_many_arguments_threshold: u64, too_many_lines_threshold: u64, large_error_threshold: u64) -> Self {\n         Self {\n             too_many_arguments_threshold,\n             too_many_lines_threshold,\n+            large_error_threshold,\n         }\n     }\n }\n@@ -240,6 +285,7 @@ impl_lint_pass!(Functions => [\n     DOUBLE_MUST_USE,\n     MUST_USE_CANDIDATE,\n     RESULT_UNIT_ERR,\n+    RESULT_LARGE_ERR,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Functions {\n@@ -259,18 +305,18 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n \n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n         must_use::check_item(cx, item);\n-        result_unit_err::check_item(cx, item);\n+        result::check_item(cx, item, self.large_error_threshold);\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n         must_use::check_impl_item(cx, item);\n-        result_unit_err::check_impl_item(cx, item);\n+        result::check_impl_item(cx, item, self.large_error_threshold);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n         too_many_arguments::check_trait_item(cx, item, self.too_many_arguments_threshold);\n         not_unsafe_ptr_arg_deref::check_trait_item(cx, item);\n         must_use::check_trait_item(cx, item);\n-        result_unit_err::check_trait_item(cx, item);\n+        result::check_trait_item(cx, item, self.large_error_threshold);\n     }\n }"}, {"sha": "af520a493eda168b649d8bc9de9ce742de1b9169", "filename": "src/tools/clippy/clippy_lints/src/functions/result.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,100 @@\n+use rustc_errors::Diagnostic;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::{sym, Span};\n+use rustc_typeck::hir_ty_to_ty;\n+\n+use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n+use clippy_utils::trait_ref_of_method;\n+use clippy_utils::ty::{approx_ty_size, is_type_diagnostic_item};\n+\n+use super::{RESULT_LARGE_ERR, RESULT_UNIT_ERR};\n+\n+/// The type of the `Err`-variant in a `std::result::Result` returned by the\n+/// given `FnDecl`\n+fn result_err_ty<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    decl: &hir::FnDecl<'tcx>,\n+    item_span: Span,\n+) -> Option<(&'tcx hir::Ty<'tcx>, Ty<'tcx>)> {\n+    if !in_external_macro(cx.sess(), item_span)\n+        && let hir::FnRetTy::Return(hir_ty) = decl.output\n+        && let ty = hir_ty_to_ty(cx.tcx, hir_ty)\n+        && is_type_diagnostic_item(cx, ty, sym::Result)\n+        && let ty::Adt(_, substs) = ty.kind()\n+    {\n+        let err_ty = substs.type_at(1);\n+        Some((hir_ty, err_ty))\n+    } else {\n+        None\n+    }\n+}\n+\n+pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::Item<'tcx>, large_err_threshold: u64) {\n+    if let hir::ItemKind::Fn(ref sig, _generics, _) = item.kind\n+        && let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.span)\n+    {\n+        if cx.access_levels.is_exported(item.def_id) {\n+            let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+            check_result_unit_err(cx, err_ty, fn_header_span);\n+        }\n+        check_result_large_err(cx, err_ty, hir_ty.span, large_err_threshold);\n+    }\n+}\n+\n+pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::ImplItem<'tcx>, large_err_threshold: u64) {\n+    // Don't lint if method is a trait's implementation, we can't do anything about those\n+    if let hir::ImplItemKind::Fn(ref sig, _) = item.kind\n+        && let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.span)\n+        && trait_ref_of_method(cx, item.def_id).is_none()\n+    {\n+        if cx.access_levels.is_exported(item.def_id) {\n+            let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+            check_result_unit_err(cx, err_ty, fn_header_span);\n+        }\n+        check_result_large_err(cx, err_ty, hir_ty.span, large_err_threshold);\n+    }\n+}\n+\n+pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::TraitItem<'tcx>, large_err_threshold: u64) {\n+    if let hir::TraitItemKind::Fn(ref sig, _) = item.kind {\n+        let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+        if let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.span) {\n+            if cx.access_levels.is_exported(item.def_id) {\n+                check_result_unit_err(cx, err_ty, fn_header_span);\n+            }\n+            check_result_large_err(cx, err_ty, hir_ty.span, large_err_threshold);\n+        }\n+    }\n+}\n+\n+fn check_result_unit_err(cx: &LateContext<'_>, err_ty: Ty<'_>, fn_header_span: Span) {\n+    if err_ty.is_unit() {\n+        span_lint_and_help(\n+            cx,\n+            RESULT_UNIT_ERR,\n+            fn_header_span,\n+            \"this returns a `Result<_, ()>`\",\n+            None,\n+            \"use a custom `Error` type instead\",\n+        );\n+    }\n+}\n+\n+fn check_result_large_err<'tcx>(cx: &LateContext<'tcx>, err_ty: Ty<'tcx>, hir_ty_span: Span, large_err_threshold: u64) {\n+    let ty_size = approx_ty_size(cx, err_ty);\n+    if ty_size >= large_err_threshold {\n+        span_lint_and_then(\n+            cx,\n+            RESULT_LARGE_ERR,\n+            hir_ty_span,\n+            \"the `Err`-variant returned from this function is very large\",\n+            |diag: &mut Diagnostic| {\n+                diag.span_label(hir_ty_span, format!(\"the `Err`-variant is at least {ty_size} bytes\"));\n+                diag.help(format!(\"try reducing the size of `{err_ty}`, for example by boxing large elements or replacing it with `Box<{err_ty}>`\"));\n+            },\n+        );\n+    }\n+}"}, {"sha": "2e63a1f920d64b39a69ad214ecd4cb6e03ada3a2", "filename": "src/tools/clippy/clippy_lints/src/functions/result_unit_err.rs", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,66 +0,0 @@\n-use rustc_hir as hir;\n-use rustc_lint::{LateContext, LintContext};\n-use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty;\n-use rustc_span::{sym, Span};\n-use rustc_typeck::hir_ty_to_ty;\n-\n-use if_chain::if_chain;\n-\n-use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::trait_ref_of_method;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-\n-use super::RESULT_UNIT_ERR;\n-\n-pub(super) fn check_item(cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-    if let hir::ItemKind::Fn(ref sig, _generics, _) = item.kind {\n-        let is_public = cx.access_levels.is_exported(item.def_id);\n-        let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n-        if is_public {\n-            check_result_unit_err(cx, sig.decl, item.span, fn_header_span);\n-        }\n-    }\n-}\n-\n-pub(super) fn check_impl_item(cx: &LateContext<'_>, item: &hir::ImplItem<'_>) {\n-    if let hir::ImplItemKind::Fn(ref sig, _) = item.kind {\n-        let is_public = cx.access_levels.is_exported(item.def_id);\n-        let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n-        if is_public && trait_ref_of_method(cx, item.def_id).is_none() {\n-            check_result_unit_err(cx, sig.decl, item.span, fn_header_span);\n-        }\n-    }\n-}\n-\n-pub(super) fn check_trait_item(cx: &LateContext<'_>, item: &hir::TraitItem<'_>) {\n-    if let hir::TraitItemKind::Fn(ref sig, _) = item.kind {\n-        let is_public = cx.access_levels.is_exported(item.def_id);\n-        let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n-        if is_public {\n-            check_result_unit_err(cx, sig.decl, item.span, fn_header_span);\n-        }\n-    }\n-}\n-\n-fn check_result_unit_err(cx: &LateContext<'_>, decl: &hir::FnDecl<'_>, item_span: Span, fn_header_span: Span) {\n-    if_chain! {\n-        if !in_external_macro(cx.sess(), item_span);\n-        if let hir::FnRetTy::Return(ty) = decl.output;\n-        let ty = hir_ty_to_ty(cx.tcx, ty);\n-        if is_type_diagnostic_item(cx, ty, sym::Result);\n-        if let ty::Adt(_, substs) = ty.kind();\n-        let err_ty = substs.type_at(1);\n-        if err_ty.is_unit();\n-        then {\n-            span_lint_and_help(\n-                cx,\n-                RESULT_UNIT_ERR,\n-                fn_header_span,\n-                \"this returns a `Result<_, ()>`\",\n-                None,\n-                \"use a custom `Error` type instead\",\n-            );\n-        }\n-    }\n-}"}, {"sha": "529f7babaa5eab516e5f2a7744f4d31cef4afd4a", "filename": "src/tools/clippy/clippy_lints/src/get_first.rs", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fget_first.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fget_first.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fget_first.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,68 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{is_slice_of_primitives, match_def_path, paths};\n-use if_chain::if_chain;\n-use rustc_ast::LitKind;\n-use rustc_errors::Applicability;\n-use rustc_hir as hir;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Spanned;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for using `x.get(0)` instead of\n-    /// `x.first()`.\n-    ///\n-    /// ### Why is this bad?\n-    /// Using `x.first()` is easier to read and has the same\n-    /// result.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x = vec![2, 3, 5];\n-    /// let first_element = x.get(0);\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// let x = vec![2, 3, 5];\n-    /// let first_element = x.first();\n-    /// ```\n-    #[clippy::version = \"1.63.0\"]\n-    pub GET_FIRST,\n-    style,\n-    \"Using `x.get(0)` when `x.first()` is simpler\"\n-}\n-declare_lint_pass!(GetFirst => [GET_FIRST]);\n-\n-impl<'tcx> LateLintPass<'tcx> for GetFirst {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if_chain! {\n-            if let hir::ExprKind::MethodCall(_, [struct_calling_on, method_arg], _) = &expr.kind;\n-            if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n-            if match_def_path(cx, expr_def_id, &paths::SLICE_GET);\n-\n-            if let Some(_) = is_slice_of_primitives(cx, struct_calling_on);\n-            if let hir::ExprKind::Lit(Spanned { node: LitKind::Int(0, _), .. }) = method_arg.kind;\n-\n-            then {\n-                let mut applicability = Applicability::MachineApplicable;\n-                let slice_name = snippet_with_applicability(\n-                    cx,\n-                    struct_calling_on.span, \"..\",\n-                    &mut applicability,\n-                );\n-                span_lint_and_sugg(\n-                    cx,\n-                    GET_FIRST,\n-                    expr.span,\n-                    &format!(\"accessing first element with `{0}.get(0)`\", slice_name),\n-                    \"try\",\n-                    format!(\"{}.first()\", slice_name),\n-                    applicability,\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "4d703d691acc2f81e57296256027072221c27214", "filename": "src/tools/clippy/clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,8 +1,9 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::SpanlessEq;\n use if_chain::if_chain;\n+use rustc_errors::Diagnostic;\n use rustc_hir::intravisit::{self as visit, Visitor};\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -45,16 +46,8 @@ declare_lint_pass!(IfLetMutex => [IF_LET_MUTEX]);\n \n impl<'tcx> LateLintPass<'tcx> for IfLetMutex {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        let mut arm_visit = ArmVisitor {\n-            mutex_lock_called: false,\n-            found_mutex: None,\n-            cx,\n-        };\n-        let mut op_visit = OppVisitor {\n-            mutex_lock_called: false,\n-            found_mutex: None,\n-            cx,\n-        };\n+        let mut arm_visit = ArmVisitor { found_mutex: None, cx };\n+        let mut op_visit = OppVisitor { found_mutex: None, cx };\n         if let Some(higher::IfLet {\n             let_expr,\n             if_then,\n@@ -63,18 +56,28 @@ impl<'tcx> LateLintPass<'tcx> for IfLetMutex {\n         }) = higher::IfLet::hir(cx, expr)\n         {\n             op_visit.visit_expr(let_expr);\n-            if op_visit.mutex_lock_called {\n+            if let Some(op_mutex) = op_visit.found_mutex {\n                 arm_visit.visit_expr(if_then);\n                 arm_visit.visit_expr(if_else);\n \n-                if arm_visit.mutex_lock_called && arm_visit.same_mutex(cx, op_visit.found_mutex.unwrap()) {\n-                    span_lint_and_help(\n+                if let Some(arm_mutex) = arm_visit.found_mutex_if_same_as(op_mutex) {\n+                    let diag = |diag: &mut Diagnostic| {\n+                        diag.span_label(\n+                            op_mutex.span,\n+                            \"this Mutex will remain locked for the entire `if let`-block...\",\n+                        );\n+                        diag.span_label(\n+                            arm_mutex.span,\n+                            \"... and is tried to lock again here, which will always deadlock.\",\n+                        );\n+                        diag.help(\"move the lock call outside of the `if let ...` expression\");\n+                    };\n+                    span_lint_and_then(\n                         cx,\n                         IF_LET_MUTEX,\n                         expr.span,\n                         \"calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock\",\n-                        None,\n-                        \"move the lock call outside of the `if let ...` expression\",\n+                        diag,\n                     );\n                 }\n             }\n@@ -84,7 +87,6 @@ impl<'tcx> LateLintPass<'tcx> for IfLetMutex {\n \n /// Checks if `Mutex::lock` is called in the `if let` expr.\n pub struct OppVisitor<'a, 'tcx> {\n-    mutex_lock_called: bool,\n     found_mutex: Option<&'tcx Expr<'tcx>>,\n     cx: &'a LateContext<'tcx>,\n }\n@@ -93,7 +95,6 @@ impl<'tcx> Visitor<'tcx> for OppVisitor<'_, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if let Some(mutex) = is_mutex_lock_call(self.cx, expr) {\n             self.found_mutex = Some(mutex);\n-            self.mutex_lock_called = true;\n             return;\n         }\n         visit::walk_expr(self, expr);\n@@ -102,7 +103,6 @@ impl<'tcx> Visitor<'tcx> for OppVisitor<'_, 'tcx> {\n \n /// Checks if `Mutex::lock` is called in any of the branches.\n pub struct ArmVisitor<'a, 'tcx> {\n-    mutex_lock_called: bool,\n     found_mutex: Option<&'tcx Expr<'tcx>>,\n     cx: &'a LateContext<'tcx>,\n }\n@@ -111,25 +111,27 @@ impl<'tcx> Visitor<'tcx> for ArmVisitor<'_, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         if let Some(mutex) = is_mutex_lock_call(self.cx, expr) {\n             self.found_mutex = Some(mutex);\n-            self.mutex_lock_called = true;\n             return;\n         }\n         visit::walk_expr(self, expr);\n     }\n }\n \n impl<'tcx, 'l> ArmVisitor<'tcx, 'l> {\n-    fn same_mutex(&self, cx: &LateContext<'_>, op_mutex: &Expr<'_>) -> bool {\n-        self.found_mutex\n-            .map_or(false, |arm_mutex| SpanlessEq::new(cx).eq_expr(op_mutex, arm_mutex))\n+    fn found_mutex_if_same_as(&self, op_mutex: &Expr<'_>) -> Option<&Expr<'_>> {\n+        self.found_mutex.and_then(|arm_mutex| {\n+            SpanlessEq::new(self.cx)\n+                .eq_expr(op_mutex, arm_mutex)\n+                .then_some(arm_mutex)\n+        })\n     }\n }\n \n fn is_mutex_lock_call<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     if_chain! {\n         if let ExprKind::MethodCall(path, [self_arg, ..], _) = &expr.kind;\n         if path.ident.as_str() == \"lock\";\n-        let ty = cx.typeck_results().expr_ty(self_arg);\n+        let ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n         if is_type_diagnostic_item(cx, ty, sym::Mutex);\n         then {\n             Some(self_arg)"}, {"sha": "11c43247868ca46b817e01f60b13efe562a531b3", "filename": "src/tools/clippy/clippy_lints/src/if_then_some_else_none.rs", "status": "modified", "additions": 48, "deletions": 42, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_then_some_else_none.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::eager_or_lazy::switch_to_eager_eval;\n use clippy_utils::source::snippet_with_macro_callsite;\n use clippy_utils::{contains_return, higher, is_else_clause, is_lang_ctor, meets_msrv, msrvs, peel_blocks};\n-use if_chain::if_chain;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{Expr, ExprKind, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -11,10 +11,12 @@ use rustc_session::{declare_tool_lint, impl_lint_pass};\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for if-else that could be written to `bool::then`.\n+    /// Checks for if-else that could be written using either `bool::then` or `bool::then_some`.\n     ///\n     /// ### Why is this bad?\n-    /// Looks a little redundant. Using `bool::then` helps it have less lines of code.\n+    /// Looks a little redundant. Using `bool::then` is more concise and incurs no loss of clarity.\n+    /// For simple calculations and known values, use `bool::then_some`, which is eagerly evaluated\n+    /// in comparison to `bool::then`.\n     ///\n     /// ### Example\n     /// ```rust\n@@ -39,7 +41,7 @@ declare_clippy_lint! {\n     #[clippy::version = \"1.53.0\"]\n     pub IF_THEN_SOME_ELSE_NONE,\n     restriction,\n-    \"Finds if-else that could be written using `bool::then`\"\n+    \"Finds if-else that could be written using either `bool::then` or `bool::then_some`\"\n }\n \n pub struct IfThenSomeElseNone {\n@@ -56,7 +58,7 @@ impl IfThenSomeElseNone {\n impl_lint_pass!(IfThenSomeElseNone => [IF_THEN_SOME_ELSE_NONE]);\n \n impl<'tcx> LateLintPass<'tcx> for IfThenSomeElseNone {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &'tcx Expr<'_>) {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         if !meets_msrv(self.msrv, msrvs::BOOL_THEN) {\n             return;\n         }\n@@ -70,43 +72,47 @@ impl<'tcx> LateLintPass<'tcx> for IfThenSomeElseNone {\n             return;\n         }\n \n-        if_chain! {\n-            if let Some(higher::If { cond, then, r#else: Some(els) }) = higher::If::hir(expr);\n-            if let ExprKind::Block(then_block, _) = then.kind;\n-            if let Some(then_expr) = then_block.expr;\n-            if let ExprKind::Call(then_call, [then_arg]) = then_expr.kind;\n-            if let ExprKind::Path(ref then_call_qpath) = then_call.kind;\n-            if is_lang_ctor(cx, then_call_qpath, OptionSome);\n-            if let ExprKind::Path(ref qpath) = peel_blocks(els).kind;\n-            if is_lang_ctor(cx, qpath, OptionNone);\n-            if !stmts_contains_early_return(then_block.stmts);\n-            then {\n-                let cond_snip = snippet_with_macro_callsite(cx, cond.span, \"[condition]\");\n-                let cond_snip = if matches!(cond.kind, ExprKind::Unary(_, _) | ExprKind::Binary(_, _, _)) {\n-                    format!(\"({})\", cond_snip)\n-                } else {\n-                    cond_snip.into_owned()\n-                };\n-                let arg_snip = snippet_with_macro_callsite(cx, then_arg.span, \"\");\n-                let closure_body = if then_block.stmts.is_empty() {\n-                    arg_snip.into_owned()\n-                } else {\n-                    format!(\"{{ /* snippet */ {} }}\", arg_snip)\n-                };\n-                let help = format!(\n-                    \"consider using `bool::then` like: `{}.then(|| {})`\",\n-                    cond_snip,\n-                    closure_body,\n-                );\n-                span_lint_and_help(\n-                    cx,\n-                    IF_THEN_SOME_ELSE_NONE,\n-                    expr.span,\n-                    \"this could be simplified with `bool::then`\",\n-                    None,\n-                    &help,\n-                );\n-            }\n+        if let Some(higher::If { cond, then, r#else: Some(els) }) = higher::If::hir(expr)\n+            && let ExprKind::Block(then_block, _) = then.kind\n+            && let Some(then_expr) = then_block.expr\n+            && let ExprKind::Call(then_call, [then_arg]) = then_expr.kind\n+            && let ExprKind::Path(ref then_call_qpath) = then_call.kind\n+            && is_lang_ctor(cx, then_call_qpath, OptionSome)\n+            && let ExprKind::Path(ref qpath) = peel_blocks(els).kind\n+            && is_lang_ctor(cx, qpath, OptionNone)\n+            && !stmts_contains_early_return(then_block.stmts)\n+        {\n+            let cond_snip = snippet_with_macro_callsite(cx, cond.span, \"[condition]\");\n+            let cond_snip = if matches!(cond.kind, ExprKind::Unary(_, _) | ExprKind::Binary(_, _, _)) {\n+                format!(\"({})\", cond_snip)\n+            } else {\n+                cond_snip.into_owned()\n+            };\n+            let arg_snip = snippet_with_macro_callsite(cx, then_arg.span, \"\");\n+            let mut method_body = if then_block.stmts.is_empty() {\n+                arg_snip.into_owned()\n+            } else {\n+                format!(\"{{ /* snippet */ {} }}\", arg_snip)\n+            };\n+            let method_name = if switch_to_eager_eval(cx, expr) && meets_msrv(self.msrv, msrvs::BOOL_THEN_SOME) {\n+                \"then_some\"\n+            } else {\n+                method_body.insert_str(0, \"|| \");\n+                \"then\"\n+            };\n+\n+            let help = format!(\n+                \"consider using `bool::{}` like: `{}.{}({})`\",\n+                method_name, cond_snip, method_name, method_body,\n+            );\n+            span_lint_and_help(\n+                cx,\n+                IF_THEN_SOME_ELSE_NONE,\n+                expr.span,\n+                &format!(\"this could be simplified with `bool::{}`\", method_name),\n+                None,\n+                &help,\n+            );\n         }\n     }\n "}, {"sha": "134cbbf7b5c66ad5f218173022533dc55b19c77b", "filename": "src/tools/clippy/clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -20,12 +20,12 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(booleans::NONMINIMAL_BOOL),\n     LintId::of(booleans::OVERLY_COMPLEX_BOOL_EXPR),\n     LintId::of(borrow_deref_ref::BORROW_DEREF_REF),\n-    LintId::of(bytes_count_to_len::BYTES_COUNT_TO_LEN),\n     LintId::of(casts::CAST_ABS_TO_UNSIGNED),\n     LintId::of(casts::CAST_ENUM_CONSTRUCTOR),\n     LintId::of(casts::CAST_ENUM_TRUNCATION),\n     LintId::of(casts::CAST_REF_TO_MUT),\n     LintId::of(casts::CAST_SLICE_DIFFERENT_SIZES),\n+    LintId::of(casts::CAST_SLICE_FROM_RAW_PARTS),\n     LintId::of(casts::CHAR_LIT_AS_U8),\n     LintId::of(casts::FN_TO_NUMERIC_CAST),\n     LintId::of(casts::FN_TO_NUMERIC_CAST_WITH_TRUNCATION),\n@@ -80,9 +80,9 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(functions::DOUBLE_MUST_USE),\n     LintId::of(functions::MUST_USE_UNIT),\n     LintId::of(functions::NOT_UNSAFE_PTR_ARG_DEREF),\n+    LintId::of(functions::RESULT_LARGE_ERR),\n     LintId::of(functions::RESULT_UNIT_ERR),\n     LintId::of(functions::TOO_MANY_ARGUMENTS),\n-    LintId::of(get_first::GET_FIRST),\n     LintId::of(if_let_mutex::IF_LET_MUTEX),\n     LintId::of(indexing_slicing::OUT_OF_BOUNDS_INDEXING),\n     LintId::of(infinite_iter::INFINITE_ITER),\n@@ -128,7 +128,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(manual_rem_euclid::MANUAL_REM_EUCLID),\n     LintId::of(manual_retain::MANUAL_RETAIN),\n     LintId::of(manual_strip::MANUAL_STRIP),\n-    LintId::of(map_clone::MAP_CLONE),\n     LintId::of(map_unit_fn::OPTION_MAP_UNIT_FN),\n     LintId::of(map_unit_fn::RESULT_MAP_UNIT_FN),\n     LintId::of(match_result_ok::MATCH_RESULT_OK),\n@@ -150,17 +149,20 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(mem_replace::MEM_REPLACE_WITH_DEFAULT),\n     LintId::of(mem_replace::MEM_REPLACE_WITH_UNINIT),\n     LintId::of(methods::BIND_INSTEAD_OF_MAP),\n+    LintId::of(methods::BYTES_COUNT_TO_LEN),\n     LintId::of(methods::BYTES_NTH),\n     LintId::of(methods::CHARS_LAST_CMP),\n     LintId::of(methods::CHARS_NEXT_CMP),\n     LintId::of(methods::CLONE_DOUBLE_REF),\n     LintId::of(methods::CLONE_ON_COPY),\n+    LintId::of(methods::COLLAPSIBLE_STR_REPLACE),\n     LintId::of(methods::ERR_EXPECT),\n     LintId::of(methods::EXPECT_FUN_CALL),\n     LintId::of(methods::EXTEND_WITH_DRAIN),\n     LintId::of(methods::FILTER_MAP_IDENTITY),\n     LintId::of(methods::FILTER_NEXT),\n     LintId::of(methods::FLAT_MAP_IDENTITY),\n+    LintId::of(methods::GET_FIRST),\n     LintId::of(methods::GET_LAST_WITH_LEN),\n     LintId::of(methods::INSPECT_FOR_EACH),\n     LintId::of(methods::INTO_ITER_ON_REF),\n@@ -178,13 +180,16 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::MANUAL_SATURATING_ARITHMETIC),\n     LintId::of(methods::MANUAL_SPLIT_ONCE),\n     LintId::of(methods::MANUAL_STR_REPEAT),\n+    LintId::of(methods::MAP_CLONE),\n     LintId::of(methods::MAP_COLLECT_RESULT_UNIT),\n     LintId::of(methods::MAP_FLATTEN),\n     LintId::of(methods::MAP_IDENTITY),\n+    LintId::of(methods::MUT_MUTEX_LOCK),\n     LintId::of(methods::NEEDLESS_OPTION_AS_DEREF),\n     LintId::of(methods::NEEDLESS_OPTION_TAKE),\n     LintId::of(methods::NEEDLESS_SPLITN),\n     LintId::of(methods::NEW_RET_NO_SELF),\n+    LintId::of(methods::NONSENSICAL_OPEN_OPTIONS),\n     LintId::of(methods::NO_EFFECT_REPLACE),\n     LintId::of(methods::OBFUSCATED_IF_ELSE),\n     LintId::of(methods::OK_EXPECT),\n@@ -193,6 +198,8 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::OPTION_MAP_OR_NONE),\n     LintId::of(methods::OR_FUN_CALL),\n     LintId::of(methods::OR_THEN_UNWRAP),\n+    LintId::of(methods::RANGE_ZIP_WITH_LEN),\n+    LintId::of(methods::REPEAT_ONCE),\n     LintId::of(methods::RESULT_MAP_OR_INTO_OPTION),\n     LintId::of(methods::SEARCH_IS_SOME),\n     LintId::of(methods::SHOULD_IMPLEMENT_TRAIT),\n@@ -202,14 +209,18 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::STRING_EXTEND_CHARS),\n     LintId::of(methods::SUSPICIOUS_MAP),\n     LintId::of(methods::SUSPICIOUS_SPLITN),\n+    LintId::of(methods::SUSPICIOUS_TO_OWNED),\n     LintId::of(methods::UNINIT_ASSUMED_INIT),\n+    LintId::of(methods::UNIT_HASH),\n     LintId::of(methods::UNNECESSARY_FILTER_MAP),\n     LintId::of(methods::UNNECESSARY_FIND_MAP),\n     LintId::of(methods::UNNECESSARY_FOLD),\n     LintId::of(methods::UNNECESSARY_LAZY_EVALUATIONS),\n+    LintId::of(methods::UNNECESSARY_SORT_BY),\n     LintId::of(methods::UNNECESSARY_TO_OWNED),\n     LintId::of(methods::UNWRAP_OR_ELSE_DEFAULT),\n     LintId::of(methods::USELESS_ASREF),\n+    LintId::of(methods::VEC_RESIZE_TO_ZERO),\n     LintId::of(methods::WRONG_SELF_CONVENTION),\n     LintId::of(methods::ZST_OFFSET),\n     LintId::of(minmax::MIN_MAX),\n@@ -224,8 +235,8 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(misc_early::UNNEEDED_WILDCARD_PATTERN),\n     LintId::of(misc_early::ZERO_PREFIXED_LITERAL),\n     LintId::of(mixed_read_write_in_expression::DIVERGING_SUB_EXPRESSION),\n+    LintId::of(multi_assignments::MULTI_ASSIGNMENTS),\n     LintId::of(mut_key::MUTABLE_KEY_TYPE),\n-    LintId::of(mut_mutex_lock::MUT_MUTEX_LOCK),\n     LintId::of(mut_reference::UNNECESSARY_MUT_PASSED),\n     LintId::of(needless_arbitrary_self_type::NEEDLESS_ARBITRARY_SELF_TYPE),\n     LintId::of(needless_bool::BOOL_COMPARISON),\n@@ -245,7 +256,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(non_expressive_names::JUST_UNDERSCORES_AND_DIGITS),\n     LintId::of(non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS),\n     LintId::of(octal_escapes::OCTAL_ESCAPES),\n-    LintId::of(open_options::NONSENSICAL_OPEN_OPTIONS),\n+    LintId::of(only_used_in_recursion::ONLY_USED_IN_RECURSION),\n     LintId::of(operators::ABSURD_EXTREME_COMPARISONS),\n     LintId::of(operators::ASSIGN_OP_PATTERN),\n     LintId::of(operators::BAD_BIT_MASK),\n@@ -275,7 +286,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(ptr_offset_with_cast::PTR_OFFSET_WITH_CAST),\n     LintId::of(question_mark::QUESTION_MARK),\n     LintId::of(ranges::MANUAL_RANGE_CONTAINS),\n-    LintId::of(ranges::RANGE_ZIP_WITH_LEN),\n     LintId::of(ranges::REVERSED_EMPTY_RANGES),\n     LintId::of(rc_clone_in_vec_init::RC_CLONE_IN_VEC_INIT),\n     LintId::of(read_zero_byte_vec::READ_ZERO_BYTE_VEC),\n@@ -286,7 +296,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES),\n     LintId::of(reference::DEREF_ADDROF),\n     LintId::of(regex::INVALID_REGEX),\n-    LintId::of(repeat_once::REPEAT_ONCE),\n     LintId::of(returns::LET_AND_RETURN),\n     LintId::of(returns::NEEDLESS_RETURN),\n     LintId::of(self_named_constructors::SELF_NAMED_CONSTRUCTORS),\n@@ -314,36 +323,35 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(transmute::TRANSMUTE_INT_TO_FLOAT),\n     LintId::of(transmute::TRANSMUTE_NUM_TO_BYTES),\n     LintId::of(transmute::TRANSMUTE_PTR_TO_REF),\n+    LintId::of(transmute::TRANSMUTING_NULL),\n     LintId::of(transmute::UNSOUND_COLLECTION_TRANSMUTE),\n     LintId::of(transmute::USELESS_TRANSMUTE),\n     LintId::of(transmute::WRONG_TRANSMUTE),\n-    LintId::of(transmuting_null::TRANSMUTING_NULL),\n     LintId::of(types::BORROWED_BOX),\n     LintId::of(types::BOX_COLLECTION),\n     LintId::of(types::REDUNDANT_ALLOCATION),\n     LintId::of(types::TYPE_COMPLEXITY),\n     LintId::of(types::VEC_BOX),\n     LintId::of(unicode::INVISIBLE_CHARACTERS),\n     LintId::of(uninit_vec::UNINIT_VEC),\n-    LintId::of(unit_hash::UNIT_HASH),\n     LintId::of(unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD),\n     LintId::of(unit_types::LET_UNIT_VALUE),\n     LintId::of(unit_types::UNIT_ARG),\n     LintId::of(unit_types::UNIT_CMP),\n     LintId::of(unnamed_address::FN_ADDRESS_COMPARISONS),\n     LintId::of(unnamed_address::VTABLE_ADDRESS_COMPARISONS),\n     LintId::of(unnecessary_owned_empty_strings::UNNECESSARY_OWNED_EMPTY_STRINGS),\n-    LintId::of(unnecessary_sort_by::UNNECESSARY_SORT_BY),\n     LintId::of(unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME),\n     LintId::of(unused_io_amount::UNUSED_IO_AMOUNT),\n+    LintId::of(unused_peekable::UNUSED_PEEKABLE),\n     LintId::of(unused_unit::UNUSED_UNIT),\n     LintId::of(unwrap::PANICKING_UNWRAP),\n     LintId::of(unwrap::UNNECESSARY_UNWRAP),\n     LintId::of(upper_case_acronyms::UPPER_CASE_ACRONYMS),\n     LintId::of(useless_conversion::USELESS_CONVERSION),\n     LintId::of(vec::USELESS_VEC),\n     LintId::of(vec_init_then_push::VEC_INIT_THEN_PUSH),\n-    LintId::of(vec_resize_to_zero::VEC_RESIZE_TO_ZERO),\n+    LintId::of(write::POSITIONAL_NAMED_FORMAT_PARAMETERS),\n     LintId::of(write::PRINTLN_EMPTY_STRING),\n     LintId::of(write::PRINT_LITERAL),\n     LintId::of(write::PRINT_WITH_NEWLINE),"}, {"sha": "aa247352f88fb653ccbc6572c45bb74caedc63c7", "filename": "src/tools/clippy/clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -6,7 +6,6 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(attrs::DEPRECATED_CFG_ATTR),\n     LintId::of(booleans::NONMINIMAL_BOOL),\n     LintId::of(borrow_deref_ref::BORROW_DEREF_REF),\n-    LintId::of(bytes_count_to_len::BYTES_COUNT_TO_LEN),\n     LintId::of(casts::CHAR_LIT_AS_U8),\n     LintId::of(casts::UNNECESSARY_CAST),\n     LintId::of(dereference::EXPLICIT_AUTO_DEREF),\n@@ -33,6 +32,7 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(matches::NEEDLESS_MATCH),\n     LintId::of(matches::WILDCARD_IN_OR_PATTERNS),\n     LintId::of(methods::BIND_INSTEAD_OF_MAP),\n+    LintId::of(methods::BYTES_COUNT_TO_LEN),\n     LintId::of(methods::CLONE_ON_COPY),\n     LintId::of(methods::FILTER_MAP_IDENTITY),\n     LintId::of(methods::FILTER_NEXT),\n@@ -51,10 +51,13 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(methods::OPTION_AS_REF_DEREF),\n     LintId::of(methods::OPTION_FILTER_MAP),\n     LintId::of(methods::OR_THEN_UNWRAP),\n+    LintId::of(methods::RANGE_ZIP_WITH_LEN),\n+    LintId::of(methods::REPEAT_ONCE),\n     LintId::of(methods::SEARCH_IS_SOME),\n     LintId::of(methods::SKIP_WHILE_NEXT),\n     LintId::of(methods::UNNECESSARY_FILTER_MAP),\n     LintId::of(methods::UNNECESSARY_FIND_MAP),\n+    LintId::of(methods::UNNECESSARY_SORT_BY),\n     LintId::of(methods::USELESS_ASREF),\n     LintId::of(misc::SHORT_CIRCUIT_STATEMENT),\n     LintId::of(misc_early::UNNEEDED_WILDCARD_PATTERN),\n@@ -69,18 +72,17 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD),\n     LintId::of(no_effect::NO_EFFECT),\n     LintId::of(no_effect::UNNECESSARY_OPERATION),\n+    LintId::of(only_used_in_recursion::ONLY_USED_IN_RECURSION),\n     LintId::of(operators::DOUBLE_COMPARISONS),\n     LintId::of(operators::DURATION_SUBSEC),\n     LintId::of(operators::IDENTITY_OP),\n     LintId::of(overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL),\n     LintId::of(partialeq_ne_impl::PARTIALEQ_NE_IMPL),\n     LintId::of(precedence::PRECEDENCE),\n     LintId::of(ptr_offset_with_cast::PTR_OFFSET_WITH_CAST),\n-    LintId::of(ranges::RANGE_ZIP_WITH_LEN),\n     LintId::of(redundant_closure_call::REDUNDANT_CLOSURE_CALL),\n     LintId::of(redundant_slicing::REDUNDANT_SLICING),\n     LintId::of(reference::DEREF_ADDROF),\n-    LintId::of(repeat_once::REPEAT_ONCE),\n     LintId::of(strings::STRING_FROM_UTF8_AS_BYTES),\n     LintId::of(strlen_on_c_strings::STRLEN_ON_C_STRINGS),\n     LintId::of(swap::MANUAL_SWAP),\n@@ -99,7 +101,6 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(types::TYPE_COMPLEXITY),\n     LintId::of(types::VEC_BOX),\n     LintId::of(unit_types::UNIT_ARG),\n-    LintId::of(unnecessary_sort_by::UNNECESSARY_SORT_BY),\n     LintId::of(unwrap::UNNECESSARY_UNWRAP),\n     LintId::of(useless_conversion::USELESS_CONVERSION),\n     LintId::of(zero_div_zero::ZERO_DIVIDED_BY_ZERO),"}, {"sha": "bb94037ec2e7949ba52a2b25ba0bd89ae6794e89", "filename": "src/tools/clippy/clippy_lints/src/lib.register_correctness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_correctness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_correctness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_correctness.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -39,12 +39,14 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(mem_replace::MEM_REPLACE_WITH_UNINIT),\n     LintId::of(methods::CLONE_DOUBLE_REF),\n     LintId::of(methods::ITERATOR_STEP_BY_ZERO),\n+    LintId::of(methods::NONSENSICAL_OPEN_OPTIONS),\n     LintId::of(methods::SUSPICIOUS_SPLITN),\n     LintId::of(methods::UNINIT_ASSUMED_INIT),\n+    LintId::of(methods::UNIT_HASH),\n+    LintId::of(methods::VEC_RESIZE_TO_ZERO),\n     LintId::of(methods::ZST_OFFSET),\n     LintId::of(minmax::MIN_MAX),\n     LintId::of(non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS),\n-    LintId::of(open_options::NONSENSICAL_OPEN_OPTIONS),\n     LintId::of(operators::ABSURD_EXTREME_COMPARISONS),\n     LintId::of(operators::BAD_BIT_MASK),\n     LintId::of(operators::CMP_NAN),\n@@ -62,17 +64,15 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(serde_api::SERDE_API_MISUSE),\n     LintId::of(size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT),\n     LintId::of(swap::ALMOST_SWAPPED),\n+    LintId::of(transmute::TRANSMUTING_NULL),\n     LintId::of(transmute::UNSOUND_COLLECTION_TRANSMUTE),\n     LintId::of(transmute::WRONG_TRANSMUTE),\n-    LintId::of(transmuting_null::TRANSMUTING_NULL),\n     LintId::of(unicode::INVISIBLE_CHARACTERS),\n     LintId::of(uninit_vec::UNINIT_VEC),\n-    LintId::of(unit_hash::UNIT_HASH),\n     LintId::of(unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD),\n     LintId::of(unit_types::UNIT_CMP),\n     LintId::of(unnamed_address::FN_ADDRESS_COMPARISONS),\n     LintId::of(unnamed_address::VTABLE_ADDRESS_COMPARISONS),\n     LintId::of(unused_io_amount::UNUSED_IO_AMOUNT),\n     LintId::of(unwrap::PANICKING_UNWRAP),\n-    LintId::of(vec_resize_to_zero::VEC_RESIZE_TO_ZERO),\n ])"}, {"sha": "fd20e016578a1bad268088cfe5dac73f0182b881", "filename": "src/tools/clippy/clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 30, "deletions": 20, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -38,7 +38,6 @@ store.register_lints(&[\n     almost_complete_letter_range::ALMOST_COMPLETE_LETTER_RANGE,\n     approx_const::APPROX_CONSTANT,\n     as_conversions::AS_CONVERSIONS,\n-    as_underscore::AS_UNDERSCORE,\n     asm_syntax::INLINE_ASM_X86_ATT_SYNTAX,\n     asm_syntax::INLINE_ASM_X86_INTEL_SYNTAX,\n     assertions_on_constants::ASSERTIONS_ON_CONSTANTS,\n@@ -59,16 +58,14 @@ store.register_lints(&[\n     bool_assert_comparison::BOOL_ASSERT_COMPARISON,\n     booleans::NONMINIMAL_BOOL,\n     booleans::OVERLY_COMPLEX_BOOL_EXPR,\n-    borrow_as_ptr::BORROW_AS_PTR,\n     borrow_deref_ref::BORROW_DEREF_REF,\n-    bytecount::NAIVE_BYTECOUNT,\n-    bytes_count_to_len::BYTES_COUNT_TO_LEN,\n     cargo::CARGO_COMMON_METADATA,\n     cargo::MULTIPLE_CRATE_VERSIONS,\n     cargo::NEGATIVE_FEATURE_NAMES,\n     cargo::REDUNDANT_FEATURE_NAMES,\n     cargo::WILDCARD_DEPENDENCIES,\n-    case_sensitive_file_extension_comparisons::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n+    casts::AS_UNDERSCORE,\n+    casts::BORROW_AS_PTR,\n     casts::CAST_ABS_TO_UNSIGNED,\n     casts::CAST_ENUM_CONSTRUCTOR,\n     casts::CAST_ENUM_TRUNCATION,\n@@ -80,6 +77,7 @@ store.register_lints(&[\n     casts::CAST_REF_TO_MUT,\n     casts::CAST_SIGN_LOSS,\n     casts::CAST_SLICE_DIFFERENT_SIZES,\n+    casts::CAST_SLICE_FROM_RAW_PARTS,\n     casts::CHAR_LIT_AS_U8,\n     casts::FN_TO_NUMERIC_CAST,\n     casts::FN_TO_NUMERIC_CAST_ANY,\n@@ -173,11 +171,11 @@ store.register_lints(&[\n     functions::MUST_USE_CANDIDATE,\n     functions::MUST_USE_UNIT,\n     functions::NOT_UNSAFE_PTR_ARG_DEREF,\n+    functions::RESULT_LARGE_ERR,\n     functions::RESULT_UNIT_ERR,\n     functions::TOO_MANY_ARGUMENTS,\n     functions::TOO_MANY_LINES,\n     future_not_send::FUTURE_NOT_SEND,\n-    get_first::GET_FIRST,\n     if_let_mutex::IF_LET_MUTEX,\n     if_not_else::IF_NOT_ELSE,\n     if_then_some_else_none::IF_THEN_SOME_ELSE_NONE,\n@@ -246,12 +244,10 @@ store.register_lints(&[\n     manual_bits::MANUAL_BITS,\n     manual_instant_elapsed::MANUAL_INSTANT_ELAPSED,\n     manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n-    manual_ok_or::MANUAL_OK_OR,\n     manual_rem_euclid::MANUAL_REM_EUCLID,\n     manual_retain::MANUAL_RETAIN,\n+    manual_string_new::MANUAL_STRING_NEW,\n     manual_strip::MANUAL_STRIP,\n-    map_clone::MAP_CLONE,\n-    map_err_ignore::MAP_ERR_IGNORE,\n     map_unit_fn::OPTION_MAP_UNIT_FN,\n     map_unit_fn::RESULT_MAP_UNIT_FN,\n     match_result_ok::MATCH_RESULT_OK,\n@@ -284,13 +280,16 @@ store.register_lints(&[\n     mem_replace::MEM_REPLACE_WITH_DEFAULT,\n     mem_replace::MEM_REPLACE_WITH_UNINIT,\n     methods::BIND_INSTEAD_OF_MAP,\n+    methods::BYTES_COUNT_TO_LEN,\n     methods::BYTES_NTH,\n+    methods::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n     methods::CHARS_LAST_CMP,\n     methods::CHARS_NEXT_CMP,\n     methods::CLONED_INSTEAD_OF_COPIED,\n     methods::CLONE_DOUBLE_REF,\n     methods::CLONE_ON_COPY,\n     methods::CLONE_ON_REF_PTR,\n+    methods::COLLAPSIBLE_STR_REPLACE,\n     methods::ERR_EXPECT,\n     methods::EXPECT_FUN_CALL,\n     methods::EXPECT_USED,\n@@ -302,6 +301,7 @@ store.register_lints(&[\n     methods::FLAT_MAP_IDENTITY,\n     methods::FLAT_MAP_OPTION,\n     methods::FROM_ITER_INSTEAD_OF_COLLECT,\n+    methods::GET_FIRST,\n     methods::GET_LAST_WITH_LEN,\n     methods::GET_UNWRAP,\n     methods::IMPLICIT_CLONE,\n@@ -315,22 +315,30 @@ store.register_lints(&[\n     methods::ITER_NEXT_SLICE,\n     methods::ITER_NTH,\n     methods::ITER_NTH_ZERO,\n+    methods::ITER_ON_EMPTY_COLLECTIONS,\n+    methods::ITER_ON_SINGLE_ITEMS,\n     methods::ITER_OVEREAGER_CLONED,\n     methods::ITER_SKIP_NEXT,\n     methods::ITER_WITH_DRAIN,\n     methods::MANUAL_FILTER_MAP,\n     methods::MANUAL_FIND_MAP,\n+    methods::MANUAL_OK_OR,\n     methods::MANUAL_SATURATING_ARITHMETIC,\n     methods::MANUAL_SPLIT_ONCE,\n     methods::MANUAL_STR_REPEAT,\n+    methods::MAP_CLONE,\n     methods::MAP_COLLECT_RESULT_UNIT,\n+    methods::MAP_ERR_IGNORE,\n     methods::MAP_FLATTEN,\n     methods::MAP_IDENTITY,\n     methods::MAP_UNWRAP_OR,\n+    methods::MUT_MUTEX_LOCK,\n+    methods::NAIVE_BYTECOUNT,\n     methods::NEEDLESS_OPTION_AS_DEREF,\n     methods::NEEDLESS_OPTION_TAKE,\n     methods::NEEDLESS_SPLITN,\n     methods::NEW_RET_NO_SELF,\n+    methods::NONSENSICAL_OPEN_OPTIONS,\n     methods::NO_EFFECT_REPLACE,\n     methods::OBFUSCATED_IF_ELSE,\n     methods::OK_EXPECT,\n@@ -339,25 +347,34 @@ store.register_lints(&[\n     methods::OPTION_MAP_OR_NONE,\n     methods::OR_FUN_CALL,\n     methods::OR_THEN_UNWRAP,\n+    methods::PATH_BUF_PUSH_OVERWRITE,\n+    methods::RANGE_ZIP_WITH_LEN,\n+    methods::REPEAT_ONCE,\n     methods::RESULT_MAP_OR_INTO_OPTION,\n     methods::SEARCH_IS_SOME,\n     methods::SHOULD_IMPLEMENT_TRAIT,\n     methods::SINGLE_CHAR_ADD_STR,\n     methods::SINGLE_CHAR_PATTERN,\n     methods::SKIP_WHILE_NEXT,\n+    methods::STABLE_SORT_PRIMITIVE,\n     methods::STRING_EXTEND_CHARS,\n     methods::SUSPICIOUS_MAP,\n     methods::SUSPICIOUS_SPLITN,\n+    methods::SUSPICIOUS_TO_OWNED,\n     methods::UNINIT_ASSUMED_INIT,\n+    methods::UNIT_HASH,\n     methods::UNNECESSARY_FILTER_MAP,\n     methods::UNNECESSARY_FIND_MAP,\n     methods::UNNECESSARY_FOLD,\n     methods::UNNECESSARY_JOIN,\n     methods::UNNECESSARY_LAZY_EVALUATIONS,\n+    methods::UNNECESSARY_SORT_BY,\n     methods::UNNECESSARY_TO_OWNED,\n     methods::UNWRAP_OR_ELSE_DEFAULT,\n     methods::UNWRAP_USED,\n     methods::USELESS_ASREF,\n+    methods::VEC_RESIZE_TO_ZERO,\n+    methods::VERBOSE_FILE_READS,\n     methods::WRONG_SELF_CONVENTION,\n     methods::ZST_OFFSET,\n     minmax::MIN_MAX,\n@@ -384,9 +401,9 @@ store.register_lints(&[\n     mixed_read_write_in_expression::MIXED_READ_WRITE_IN_EXPRESSION,\n     module_style::MOD_MODULE_FILES,\n     module_style::SELF_NAMED_MODULE_FILES,\n+    multi_assignments::MULTI_ASSIGNMENTS,\n     mut_key::MUTABLE_KEY_TYPE,\n     mut_mut::MUT_MUT,\n-    mut_mutex_lock::MUT_MUTEX_LOCK,\n     mut_reference::UNNECESSARY_MUT_PASSED,\n     mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL,\n     mutex_atomic::MUTEX_ATOMIC,\n@@ -418,7 +435,6 @@ store.register_lints(&[\n     nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES,\n     octal_escapes::OCTAL_ESCAPES,\n     only_used_in_recursion::ONLY_USED_IN_RECURSION,\n-    open_options::NONSENSICAL_OPEN_OPTIONS,\n     operators::ABSURD_EXTREME_COMPARISONS,\n     operators::ARITHMETIC,\n     operators::ASSIGN_OP_PATTERN,\n@@ -457,7 +473,6 @@ store.register_lints(&[\n     partialeq_to_none::PARTIALEQ_TO_NONE,\n     pass_by_ref_or_value::LARGE_TYPES_PASSED_BY_VALUE,\n     pass_by_ref_or_value::TRIVIALLY_COPY_PASS_BY_REF,\n-    path_buf_push_overwrite::PATH_BUF_PUSH_OVERWRITE,\n     pattern_type_mismatch::PATTERN_TYPE_MISMATCH,\n     precedence::PRECEDENCE,\n     ptr::CMP_NULL,\n@@ -470,7 +485,6 @@ store.register_lints(&[\n     ranges::MANUAL_RANGE_CONTAINS,\n     ranges::RANGE_MINUS_ONE,\n     ranges::RANGE_PLUS_ONE,\n-    ranges::RANGE_ZIP_WITH_LEN,\n     ranges::REVERSED_EMPTY_RANGES,\n     rc_clone_in_vec_init::RC_CLONE_IN_VEC_INIT,\n     read_zero_byte_vec::READ_ZERO_BYTE_VEC,\n@@ -486,7 +500,6 @@ store.register_lints(&[\n     reference::DEREF_ADDROF,\n     regex::INVALID_REGEX,\n     regex::TRIVIAL_REGEX,\n-    repeat_once::REPEAT_ONCE,\n     return_self_not_must_use::RETURN_SELF_NOT_MUST_USE,\n     returns::LET_AND_RETURN,\n     returns::NEEDLESS_RETURN,\n@@ -501,7 +514,6 @@ store.register_lints(&[\n     single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS,\n     size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT,\n     slow_vector_initialization::SLOW_VECTOR_INITIALIZATION,\n-    stable_sort_primitive::STABLE_SORT_PRIMITIVE,\n     std_instead_of_core::ALLOC_INSTEAD_OF_CORE,\n     std_instead_of_core::STD_INSTEAD_OF_ALLOC,\n     std_instead_of_core::STD_INSTEAD_OF_CORE,\n@@ -537,10 +549,10 @@ store.register_lints(&[\n     transmute::TRANSMUTE_PTR_TO_PTR,\n     transmute::TRANSMUTE_PTR_TO_REF,\n     transmute::TRANSMUTE_UNDEFINED_REPR,\n+    transmute::TRANSMUTING_NULL,\n     transmute::UNSOUND_COLLECTION_TRANSMUTE,\n     transmute::USELESS_TRANSMUTE,\n     transmute::WRONG_TRANSMUTE,\n-    transmuting_null::TRANSMUTING_NULL,\n     types::BORROWED_BOX,\n     types::BOX_COLLECTION,\n     types::LINKEDLIST,\n@@ -555,7 +567,6 @@ store.register_lints(&[\n     unicode::NON_ASCII_LITERAL,\n     unicode::UNICODE_NOT_NFC,\n     uninit_vec::UNINIT_VEC,\n-    unit_hash::UNIT_HASH,\n     unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD,\n     unit_types::LET_UNIT_VALUE,\n     unit_types::UNIT_ARG,\n@@ -564,12 +575,12 @@ store.register_lints(&[\n     unnamed_address::VTABLE_ADDRESS_COMPARISONS,\n     unnecessary_owned_empty_strings::UNNECESSARY_OWNED_EMPTY_STRINGS,\n     unnecessary_self_imports::UNNECESSARY_SELF_IMPORTS,\n-    unnecessary_sort_by::UNNECESSARY_SORT_BY,\n     unnecessary_wraps::UNNECESSARY_WRAPS,\n     unnested_or_patterns::UNNESTED_OR_PATTERNS,\n     unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME,\n     unused_async::UNUSED_ASYNC,\n     unused_io_amount::UNUSED_IO_AMOUNT,\n+    unused_peekable::UNUSED_PEEKABLE,\n     unused_rounding::UNUSED_ROUNDING,\n     unused_self::UNUSED_SELF,\n     unused_unit::UNUSED_UNIT,\n@@ -581,10 +592,9 @@ store.register_lints(&[\n     useless_conversion::USELESS_CONVERSION,\n     vec::USELESS_VEC,\n     vec_init_then_push::VEC_INIT_THEN_PUSH,\n-    vec_resize_to_zero::VEC_RESIZE_TO_ZERO,\n-    verbose_file_reads::VERBOSE_FILE_READS,\n     wildcard_imports::ENUM_GLOB_USE,\n     wildcard_imports::WILDCARD_IMPORTS,\n+    write::POSITIONAL_NAMED_FORMAT_PARAMETERS,\n     write::PRINTLN_EMPTY_STRING,\n     write::PRINT_LITERAL,\n     write::PRINT_STDERR,"}, {"sha": "e319e7ee72c57ac656a77dbe35cd248795788d41", "filename": "src/tools/clippy/clippy_lints/src/lib.register_nursery.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -14,16 +14,17 @@ store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n     LintId::of(index_refutable_slice::INDEX_REFUTABLE_SLICE),\n     LintId::of(let_if_seq::USELESS_LET_IF_SEQ),\n     LintId::of(matches::SIGNIFICANT_DROP_IN_SCRUTINEE),\n+    LintId::of(methods::ITER_ON_EMPTY_COLLECTIONS),\n+    LintId::of(methods::ITER_ON_SINGLE_ITEMS),\n     LintId::of(methods::ITER_WITH_DRAIN),\n+    LintId::of(methods::PATH_BUF_PUSH_OVERWRITE),\n     LintId::of(missing_const_for_fn::MISSING_CONST_FOR_FN),\n     LintId::of(mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL),\n     LintId::of(mutex_atomic::MUTEX_ATOMIC),\n     LintId::of(mutex_atomic::MUTEX_INTEGER),\n     LintId::of(non_send_fields_in_send_ty::NON_SEND_FIELDS_IN_SEND_TY),\n     LintId::of(nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES),\n-    LintId::of(only_used_in_recursion::ONLY_USED_IN_RECURSION),\n     LintId::of(option_if_let_else::OPTION_IF_LET_ELSE),\n-    LintId::of(path_buf_push_overwrite::PATH_BUF_PUSH_OVERWRITE),\n     LintId::of(redundant_pub_crate::REDUNDANT_PUB_CRATE),\n     LintId::of(regex::TRIVIAL_REGEX),\n     LintId::of(strings::STRING_LIT_AS_BYTES),"}, {"sha": "584ccf55e5114fc8f008eb57a4c14bb1de4b85be", "filename": "src/tools/clippy/clippy_lints/src/lib.register_pedantic.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_pedantic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_pedantic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_pedantic.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -4,9 +4,7 @@\n \n store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(attrs::INLINE_ALWAYS),\n-    LintId::of(borrow_as_ptr::BORROW_AS_PTR),\n-    LintId::of(bytecount::NAIVE_BYTECOUNT),\n-    LintId::of(case_sensitive_file_extension_comparisons::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS),\n+    LintId::of(casts::BORROW_AS_PTR),\n     LintId::of(casts::CAST_LOSSLESS),\n     LintId::of(casts::CAST_POSSIBLE_TRUNCATION),\n     LintId::of(casts::CAST_POSSIBLE_WRAP),\n@@ -50,20 +48,24 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(macro_use::MACRO_USE_IMPORTS),\n     LintId::of(manual_assert::MANUAL_ASSERT),\n     LintId::of(manual_instant_elapsed::MANUAL_INSTANT_ELAPSED),\n-    LintId::of(manual_ok_or::MANUAL_OK_OR),\n+    LintId::of(manual_string_new::MANUAL_STRING_NEW),\n     LintId::of(matches::MATCH_BOOL),\n     LintId::of(matches::MATCH_ON_VEC_ITEMS),\n     LintId::of(matches::MATCH_SAME_ARMS),\n     LintId::of(matches::MATCH_WILDCARD_FOR_SINGLE_VARIANTS),\n     LintId::of(matches::MATCH_WILD_ERR_ARM),\n     LintId::of(matches::SINGLE_MATCH_ELSE),\n+    LintId::of(methods::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS),\n     LintId::of(methods::CLONED_INSTEAD_OF_COPIED),\n     LintId::of(methods::FILTER_MAP_NEXT),\n     LintId::of(methods::FLAT_MAP_OPTION),\n     LintId::of(methods::FROM_ITER_INSTEAD_OF_COLLECT),\n     LintId::of(methods::IMPLICIT_CLONE),\n     LintId::of(methods::INEFFICIENT_TO_STRING),\n+    LintId::of(methods::MANUAL_OK_OR),\n     LintId::of(methods::MAP_UNWRAP_OR),\n+    LintId::of(methods::NAIVE_BYTECOUNT),\n+    LintId::of(methods::STABLE_SORT_PRIMITIVE),\n     LintId::of(methods::UNNECESSARY_JOIN),\n     LintId::of(misc::USED_UNDERSCORE_BINDING),\n     LintId::of(mismatching_type_param_order::MISMATCHING_TYPE_PARAM_ORDER),\n@@ -85,7 +87,6 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(ref_option_ref::REF_OPTION_REF),\n     LintId::of(return_self_not_must_use::RETURN_SELF_NOT_MUST_USE),\n     LintId::of(semicolon_if_nothing_returned::SEMICOLON_IF_NOTHING_RETURNED),\n-    LintId::of(stable_sort_primitive::STABLE_SORT_PRIMITIVE),\n     LintId::of(strings::STRING_ADD_ASSIGN),\n     LintId::of(trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS),\n     LintId::of(trait_bounds::TYPE_REPETITION_IN_BOUNDS),"}, {"sha": "195ce41e31e9f6b4687633830b35d974eca6ef3c", "filename": "src/tools/clippy/clippy_lints/src/lib.register_perf.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_perf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_perf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_perf.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -7,12 +7,14 @@ store.register_group(true, \"clippy::perf\", Some(\"clippy_perf\"), vec![\n     LintId::of(escape::BOXED_LOCAL),\n     LintId::of(format_args::FORMAT_IN_FORMAT_ARGS),\n     LintId::of(format_args::TO_STRING_IN_FORMAT_ARGS),\n+    LintId::of(functions::RESULT_LARGE_ERR),\n     LintId::of(large_const_arrays::LARGE_CONST_ARRAYS),\n     LintId::of(large_enum_variant::LARGE_ENUM_VARIANT),\n     LintId::of(loops::MANUAL_MEMCPY),\n     LintId::of(loops::MISSING_SPIN_LOOP),\n     LintId::of(loops::NEEDLESS_COLLECT),\n     LintId::of(manual_retain::MANUAL_RETAIN),\n+    LintId::of(methods::COLLAPSIBLE_STR_REPLACE),\n     LintId::of(methods::EXPECT_FUN_CALL),\n     LintId::of(methods::EXTEND_WITH_DRAIN),\n     LintId::of(methods::ITER_NTH),"}, {"sha": "dd1e1e1a8e33d82088578a75adcaa49cf7db7128", "filename": "src/tools/clippy/clippy_lints/src/lib.register_restriction.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_restriction.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -4,11 +4,11 @@\n \n store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n     LintId::of(as_conversions::AS_CONVERSIONS),\n-    LintId::of(as_underscore::AS_UNDERSCORE),\n     LintId::of(asm_syntax::INLINE_ASM_X86_ATT_SYNTAX),\n     LintId::of(asm_syntax::INLINE_ASM_X86_INTEL_SYNTAX),\n     LintId::of(assertions_on_result_states::ASSERTIONS_ON_RESULT_STATES),\n     LintId::of(attrs::ALLOW_ATTRIBUTES_WITHOUT_REASON),\n+    LintId::of(casts::AS_UNDERSCORE),\n     LintId::of(casts::FN_TO_NUMERIC_CAST_ANY),\n     LintId::of(create_dir::CREATE_DIR),\n     LintId::of(dbg_macro::DBG_MACRO),\n@@ -30,7 +30,6 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(large_include_file::LARGE_INCLUDE_FILE),\n     LintId::of(let_underscore::LET_UNDERSCORE_MUST_USE),\n     LintId::of(literal_representation::DECIMAL_LITERAL_REPRESENTATION),\n-    LintId::of(map_err_ignore::MAP_ERR_IGNORE),\n     LintId::of(matches::REST_PAT_IN_FULLY_BOUND_STRUCTS),\n     LintId::of(matches::TRY_ERR),\n     LintId::of(matches::WILDCARD_ENUM_MATCH_ARM),\n@@ -39,7 +38,9 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(methods::EXPECT_USED),\n     LintId::of(methods::FILETYPE_IS_FILE),\n     LintId::of(methods::GET_UNWRAP),\n+    LintId::of(methods::MAP_ERR_IGNORE),\n     LintId::of(methods::UNWRAP_USED),\n+    LintId::of(methods::VERBOSE_FILE_READS),\n     LintId::of(misc_early::SEPARATED_LITERAL_SUFFIX),\n     LintId::of(misc_early::UNNEEDED_FIELD_PATTERN),\n     LintId::of(misc_early::UNSEPARATED_LITERAL_SUFFIX),\n@@ -81,7 +82,6 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(unicode::NON_ASCII_LITERAL),\n     LintId::of(unnecessary_self_imports::UNNECESSARY_SELF_IMPORTS),\n     LintId::of(unwrap_in_result::UNWRAP_IN_RESULT),\n-    LintId::of(verbose_file_reads::VERBOSE_FILE_READS),\n     LintId::of(write::PRINT_STDERR),\n     LintId::of(write::PRINT_STDOUT),\n     LintId::of(write::USE_DEBUG),"}, {"sha": "b5cb078e7a3ccce2fc5a8f0b7ed93b68cca24585", "filename": "src/tools/clippy/clippy_lints/src/lib.register_style.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_style.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -29,7 +29,6 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(functions::DOUBLE_MUST_USE),\n     LintId::of(functions::MUST_USE_UNIT),\n     LintId::of(functions::RESULT_UNIT_ERR),\n-    LintId::of(get_first::GET_FIRST),\n     LintId::of(inherent_to_string::INHERENT_TO_STRING),\n     LintId::of(init_numbered_fields::INIT_NUMBERED_FIELDS),\n     LintId::of(len_zero::COMPARISON_TO_EMPTY),\n@@ -45,7 +44,6 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(manual_async_fn::MANUAL_ASYNC_FN),\n     LintId::of(manual_bits::MANUAL_BITS),\n     LintId::of(manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n-    LintId::of(map_clone::MAP_CLONE),\n     LintId::of(match_result_ok::MATCH_RESULT_OK),\n     LintId::of(matches::COLLAPSIBLE_MATCH),\n     LintId::of(matches::INFALLIBLE_DESTRUCTURING_MATCH),\n@@ -61,14 +59,17 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(methods::CHARS_LAST_CMP),\n     LintId::of(methods::CHARS_NEXT_CMP),\n     LintId::of(methods::ERR_EXPECT),\n+    LintId::of(methods::GET_FIRST),\n     LintId::of(methods::INTO_ITER_ON_REF),\n     LintId::of(methods::IS_DIGIT_ASCII_RADIX),\n     LintId::of(methods::ITER_CLONED_COLLECT),\n     LintId::of(methods::ITER_NEXT_SLICE),\n     LintId::of(methods::ITER_NTH_ZERO),\n     LintId::of(methods::ITER_SKIP_NEXT),\n     LintId::of(methods::MANUAL_SATURATING_ARITHMETIC),\n+    LintId::of(methods::MAP_CLONE),\n     LintId::of(methods::MAP_COLLECT_RESULT_UNIT),\n+    LintId::of(methods::MUT_MUTEX_LOCK),\n     LintId::of(methods::NEW_RET_NO_SELF),\n     LintId::of(methods::OBFUSCATED_IF_ELSE),\n     LintId::of(methods::OK_EXPECT),\n@@ -88,7 +89,6 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(misc_early::DUPLICATE_UNDERSCORE_ARGUMENT),\n     LintId::of(misc_early::MIXED_CASE_HEX_LITERALS),\n     LintId::of(misc_early::REDUNDANT_PATTERN),\n-    LintId::of(mut_mutex_lock::MUT_MUTEX_LOCK),\n     LintId::of(mut_reference::UNNECESSARY_MUT_PASSED),\n     LintId::of(needless_late_init::NEEDLESS_LATE_INIT),\n     LintId::of(needless_parens_on_range_literals::NEEDLESS_PARENS_ON_RANGE_LITERALS),"}, {"sha": "8f131bbf98be3fecab313b2ae904e982620fd88d", "filename": "src/tools/clippy/clippy_lints/src/lib.register_suspicious.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_suspicious.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_suspicious.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_suspicious.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -11,6 +11,7 @@ store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec!\n     LintId::of(casts::CAST_ABS_TO_UNSIGNED),\n     LintId::of(casts::CAST_ENUM_CONSTRUCTOR),\n     LintId::of(casts::CAST_ENUM_TRUNCATION),\n+    LintId::of(casts::CAST_SLICE_FROM_RAW_PARTS),\n     LintId::of(crate_in_macro_def::CRATE_IN_MACRO_DEF),\n     LintId::of(drop_forget_ref::DROP_NON_DROP),\n     LintId::of(drop_forget_ref::FORGET_NON_DROP),\n@@ -24,6 +25,8 @@ store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec!\n     LintId::of(loops::MUT_RANGE_BOUND),\n     LintId::of(methods::NO_EFFECT_REPLACE),\n     LintId::of(methods::SUSPICIOUS_MAP),\n+    LintId::of(methods::SUSPICIOUS_TO_OWNED),\n+    LintId::of(multi_assignments::MULTI_ASSIGNMENTS),\n     LintId::of(mut_key::MUTABLE_KEY_TYPE),\n     LintId::of(octal_escapes::OCTAL_ESCAPES),\n     LintId::of(operators::FLOAT_EQUALITY_WITHOUT_ABS),\n@@ -32,4 +35,6 @@ store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec!\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n     LintId::of(swap_ptr_to_ref::SWAP_PTR_TO_REF),\n+    LintId::of(unused_peekable::UNUSED_PEEKABLE),\n+    LintId::of(write::POSITIONAL_NAMED_FORMAT_PARAMETERS),\n ])"}, {"sha": "dfdaf90f09f48151eda7964dd3d2a02cba705271", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 10, "deletions": 43, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -171,7 +171,6 @@ mod renamed_lints;\n mod almost_complete_letter_range;\n mod approx_const;\n mod as_conversions;\n-mod as_underscore;\n mod asm_syntax;\n mod assertions_on_constants;\n mod assertions_on_result_states;\n@@ -181,12 +180,8 @@ mod await_holding_invalid;\n mod blocks_in_if_conditions;\n mod bool_assert_comparison;\n mod booleans;\n-mod borrow_as_ptr;\n mod borrow_deref_ref;\n-mod bytecount;\n-mod bytes_count_to_len;\n mod cargo;\n-mod case_sensitive_file_extension_comparisons;\n mod casts;\n mod checked_conversions;\n mod cognitive_complexity;\n@@ -239,7 +234,6 @@ mod from_over_into;\n mod from_str_radix_10;\n mod functions;\n mod future_not_send;\n-mod get_first;\n mod if_let_mutex;\n mod if_not_else;\n mod if_then_some_else_none;\n@@ -276,12 +270,10 @@ mod manual_async_fn;\n mod manual_bits;\n mod manual_instant_elapsed;\n mod manual_non_exhaustive;\n-mod manual_ok_or;\n mod manual_rem_euclid;\n mod manual_retain;\n+mod manual_string_new;\n mod manual_strip;\n-mod map_clone;\n-mod map_err_ignore;\n mod map_unit_fn;\n mod match_result_ok;\n mod matches;\n@@ -298,9 +290,9 @@ mod missing_enforced_import_rename;\n mod missing_inline;\n mod mixed_read_write_in_expression;\n mod module_style;\n+mod multi_assignments;\n mod mut_key;\n mod mut_mut;\n-mod mut_mutex_lock;\n mod mut_reference;\n mod mutable_debug_assertion;\n mod mutex_atomic;\n@@ -325,7 +317,6 @@ mod non_send_fields_in_send_ty;\n mod nonstandard_macro_braces;\n mod octal_escapes;\n mod only_used_in_recursion;\n-mod open_options;\n mod operators;\n mod option_env_unwrap;\n mod option_if_let_else;\n@@ -335,7 +326,6 @@ mod panic_unimplemented;\n mod partialeq_ne_impl;\n mod partialeq_to_none;\n mod pass_by_ref_or_value;\n-mod path_buf_push_overwrite;\n mod pattern_type_mismatch;\n mod precedence;\n mod ptr;\n@@ -355,7 +345,6 @@ mod redundant_static_lifetimes;\n mod ref_option_ref;\n mod reference;\n mod regex;\n-mod repeat_once;\n mod return_self_not_must_use;\n mod returns;\n mod same_name_method;\n@@ -367,7 +356,6 @@ mod single_char_lifetime_names;\n mod single_component_path_imports;\n mod size_of_in_element_count;\n mod slow_vector_initialization;\n-mod stable_sort_primitive;\n mod std_instead_of_core;\n mod strings;\n mod strlen_on_c_strings;\n@@ -381,23 +369,21 @@ mod to_digit_is_some;\n mod trailing_empty_array;\n mod trait_bounds;\n mod transmute;\n-mod transmuting_null;\n mod types;\n mod undocumented_unsafe_blocks;\n mod unicode;\n mod uninit_vec;\n-mod unit_hash;\n mod unit_return_expecting_ord;\n mod unit_types;\n mod unnamed_address;\n mod unnecessary_owned_empty_strings;\n mod unnecessary_self_imports;\n-mod unnecessary_sort_by;\n mod unnecessary_wraps;\n mod unnested_or_patterns;\n mod unsafe_removed_from_name;\n mod unused_async;\n mod unused_io_amount;\n+mod unused_peekable;\n mod unused_rounding;\n mod unused_self;\n mod unused_unit;\n@@ -408,8 +394,6 @@ mod use_self;\n mod useless_conversion;\n mod vec;\n mod vec_init_then_push;\n-mod vec_resize_to_zero;\n-mod verbose_file_reads;\n mod wildcard_imports;\n mod write;\n mod zero_div_zero;\n@@ -597,7 +581,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(blocks_in_if_conditions::BlocksInIfConditions));\n     store.register_late_pass(|| Box::new(unicode::Unicode));\n     store.register_late_pass(|| Box::new(uninit_vec::UninitVec));\n-    store.register_late_pass(|| Box::new(unit_hash::UnitHash));\n     store.register_late_pass(|| Box::new(unit_return_expecting_ord::UnitReturnExpectingOrd));\n     store.register_late_pass(|| Box::new(strings::StringAdd));\n     store.register_late_pass(|| Box::new(implicit_return::ImplicitReturn));\n@@ -635,8 +618,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(needless_question_mark::NeedlessQuestionMark));\n     store.register_late_pass(move || Box::new(casts::Casts::new(msrv)));\n     store.register_early_pass(move || Box::new(unnested_or_patterns::UnnestedOrPatterns::new(msrv)));\n-    store.register_late_pass(move || Box::new(map_clone::MapClone::new(msrv)));\n-\n     store.register_late_pass(|| Box::new(size_of_in_element_count::SizeOfInElementCount));\n     store.register_late_pass(|| Box::new(same_name_method::SameNameMethod));\n     let max_suggested_slice_pattern_length = conf.max_suggested_slice_pattern_length;\n@@ -646,15 +627,13 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n             msrv,\n         ))\n     });\n-    store.register_late_pass(|| Box::new(map_err_ignore::MapErrIgnore));\n     store.register_late_pass(|| Box::new(shadow::Shadow::default()));\n     store.register_late_pass(|| Box::new(unit_types::UnitTypes));\n     store.register_late_pass(|| Box::new(loops::Loops));\n     store.register_late_pass(|| Box::new(main_recursion::MainRecursion::default()));\n     store.register_late_pass(|| Box::new(lifetimes::Lifetimes));\n     store.register_late_pass(|| Box::new(entry::HashMapPass));\n     store.register_late_pass(|| Box::new(minmax::MinMaxPass));\n-    store.register_late_pass(|| Box::new(open_options::OpenOptions));\n     store.register_late_pass(|| Box::new(zero_div_zero::ZeroDiv));\n     store.register_late_pass(|| Box::new(mutex_atomic::Mutex));\n     store.register_late_pass(|| Box::new(needless_update::NeedlessUpdate));\n@@ -690,10 +669,12 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(disallowed_names::DisallowedNames::new(disallowed_names.clone())));\n     let too_many_arguments_threshold = conf.too_many_arguments_threshold;\n     let too_many_lines_threshold = conf.too_many_lines_threshold;\n+    let large_error_threshold = conf.large_error_threshold;\n     store.register_late_pass(move || {\n         Box::new(functions::Functions::new(\n             too_many_arguments_threshold,\n             too_many_lines_threshold,\n+            large_error_threshold,\n         ))\n     });\n     let doc_valid_idents = conf.doc_valid_idents.iter().cloned().collect::<FxHashSet<_>>();\n@@ -720,7 +701,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     );\n     store.register_late_pass(move || Box::new(pass_by_ref_or_value));\n     store.register_late_pass(|| Box::new(ref_option_ref::RefOptionRef));\n-    store.register_late_pass(|| Box::new(bytecount::ByteCount));\n     store.register_late_pass(|| Box::new(infinite_iter::InfiniteIter));\n     store.register_late_pass(|| Box::new(inline_fn_without_body::InlineFnWithoutBody));\n     store.register_late_pass(|| Box::new(useless_conversion::UselessConversion::default()));\n@@ -738,12 +718,9 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(ptr_offset_with_cast::PtrOffsetWithCast));\n     store.register_late_pass(|| Box::new(redundant_clone::RedundantClone));\n     store.register_late_pass(|| Box::new(slow_vector_initialization::SlowVectorInit));\n-    store.register_late_pass(|| Box::new(unnecessary_sort_by::UnnecessarySortBy));\n     store.register_late_pass(move || Box::new(unnecessary_wraps::UnnecessaryWraps::new(avoid_breaking_exported_api)));\n     store.register_late_pass(|| Box::new(assertions_on_constants::AssertionsOnConstants));\n     store.register_late_pass(|| Box::new(assertions_on_result_states::AssertionsOnResultStates));\n-    store.register_late_pass(|| Box::new(transmuting_null::TransmutingNull));\n-    store.register_late_pass(|| Box::new(path_buf_push_overwrite::PathBufPushOverwrite));\n     store.register_late_pass(|| Box::new(inherent_to_string::InherentToString));\n     let max_trait_bounds = conf.max_trait_bounds;\n     store.register_late_pass(move || Box::new(trait_bounds::TraitBounds::new(max_trait_bounds)));\n@@ -819,18 +796,15 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| Box::new(option_env_unwrap::OptionEnvUnwrap));\n     let warn_on_all_wildcard_imports = conf.warn_on_all_wildcard_imports;\n     store.register_late_pass(move || Box::new(wildcard_imports::WildcardImports::new(warn_on_all_wildcard_imports)));\n-    store.register_late_pass(|| Box::new(verbose_file_reads::VerboseFileReads));\n     store.register_late_pass(|| Box::new(redundant_pub_crate::RedundantPubCrate::default()));\n     store.register_late_pass(|| Box::new(unnamed_address::UnnamedAddress));\n-    store.register_late_pass(|| Box::new(dereference::Dereferencing::default()));\n+    store.register_late_pass(move || Box::new(dereference::Dereferencing::new(msrv)));\n     store.register_late_pass(|| Box::new(option_if_let_else::OptionIfLetElse));\n     store.register_late_pass(|| Box::new(future_not_send::FutureNotSend));\n     store.register_late_pass(|| Box::new(if_let_mutex::IfLetMutex));\n     store.register_late_pass(|| Box::new(if_not_else::IfNotElse));\n     store.register_late_pass(|| Box::new(equatable_if_let::PatternEquality));\n-    store.register_late_pass(|| Box::new(mut_mutex_lock::MutMutexLock));\n     store.register_late_pass(|| Box::new(manual_async_fn::ManualAsyncFn));\n-    store.register_late_pass(|| Box::new(vec_resize_to_zero::VecResizeToZero));\n     store.register_late_pass(|| Box::new(panic_in_result_fn::PanicInResultFn));\n     let single_char_binding_names_threshold = conf.single_char_binding_names_threshold;\n     store.register_early_pass(move || {\n@@ -842,10 +816,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(move || Box::new(nonstandard_macro_braces::MacroBraces::new(&macro_matcher)));\n     store.register_late_pass(|| Box::new(macro_use::MacroUseImports::default()));\n     store.register_late_pass(|| Box::new(pattern_type_mismatch::PatternTypeMismatch));\n-    store.register_late_pass(|| Box::new(stable_sort_primitive::StableSortPrimitive));\n-    store.register_late_pass(|| Box::new(repeat_once::RepeatOnce));\n     store.register_late_pass(|| Box::new(unwrap_in_result::UnwrapInResult));\n-    store.register_late_pass(|| Box::new(manual_ok_or::ManualOkOr));\n     store.register_late_pass(|| Box::new(semicolon_if_nothing_returned::SemicolonIfNothingReturned));\n     store.register_late_pass(|| Box::new(async_yields_async::AsyncYieldsAsync));\n     let disallowed_methods = conf.disallowed_methods.clone();\n@@ -857,9 +828,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(strings::StringToString));\n     store.register_late_pass(|| Box::new(zero_sized_map_values::ZeroSizedMapValues));\n     store.register_late_pass(|| Box::new(vec_init_then_push::VecInitThenPush::default()));\n-    store.register_late_pass(|| {\n-        Box::new(case_sensitive_file_extension_comparisons::CaseSensitiveFileExtensionComparisons)\n-    });\n     store.register_late_pass(|| Box::new(redundant_slicing::RedundantSlicing));\n     store.register_late_pass(|| Box::new(from_str_radix_10::FromStrRadix10));\n     store.register_late_pass(move || Box::new(if_then_some_else_none::IfThenSomeElseNone::new(msrv)));\n@@ -894,11 +862,10 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(return_self_not_must_use::ReturnSelfNotMustUse));\n     store.register_late_pass(|| Box::new(init_numbered_fields::NumberedFields));\n     store.register_early_pass(|| Box::new(single_char_lifetime_names::SingleCharLifetimeNames));\n-    store.register_late_pass(move || Box::new(borrow_as_ptr::BorrowAsPtr::new(msrv)));\n     store.register_late_pass(move || Box::new(manual_bits::ManualBits::new(msrv)));\n     store.register_late_pass(|| Box::new(default_union_representation::DefaultUnionRepresentation));\n     store.register_early_pass(|| Box::new(doc_link_with_quotes::DocLinkWithQuotes));\n-    store.register_late_pass(|| Box::new(only_used_in_recursion::OnlyUsedInRecursion));\n+    store.register_late_pass(|| Box::new(only_used_in_recursion::OnlyUsedInRecursion::default()));\n     let allow_dbg_in_tests = conf.allow_dbg_in_tests;\n     store.register_late_pass(move || Box::new(dbg_macro::DbgMacro::new(allow_dbg_in_tests)));\n     let cargo_ignore_publish = conf.cargo_ignore_publish;\n@@ -912,18 +879,15 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(unnecessary_owned_empty_strings::UnnecessaryOwnedEmptyStrings));\n     store.register_early_pass(|| Box::new(pub_use::PubUse));\n     store.register_late_pass(|| Box::new(format_push_string::FormatPushString));\n-    store.register_late_pass(|| Box::new(bytes_count_to_len::BytesCountToLen));\n     let max_include_file_size = conf.max_include_file_size;\n     store.register_late_pass(move || Box::new(large_include_file::LargeIncludeFile::new(max_include_file_size)));\n     store.register_late_pass(|| Box::new(strings::TrimSplitWhitespace));\n     store.register_late_pass(|| Box::new(rc_clone_in_vec_init::RcCloneInVecInit));\n     store.register_early_pass(|| Box::new(duplicate_mod::DuplicateMod::default()));\n-    store.register_late_pass(|| Box::new(get_first::GetFirst));\n     store.register_early_pass(|| Box::new(unused_rounding::UnusedRounding));\n     store.register_early_pass(move || Box::new(almost_complete_letter_range::AlmostCompleteLetterRange::new(msrv)));\n     store.register_late_pass(|| Box::new(swap_ptr_to_ref::SwapPtrToRef));\n     store.register_late_pass(|| Box::new(mismatching_type_param_order::TypeParamMismatch));\n-    store.register_late_pass(|| Box::new(as_underscore::AsUnderscore));\n     store.register_late_pass(|| Box::new(read_zero_byte_vec::ReadZeroByteVec));\n     store.register_late_pass(|| Box::new(default_instead_of_iter_empty::DefaultIterEmpty));\n     store.register_late_pass(move || Box::new(manual_rem_euclid::ManualRemEuclid::new(msrv)));\n@@ -934,6 +898,9 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(std_instead_of_core::StdReexports::default()));\n     store.register_late_pass(|| Box::new(manual_instant_elapsed::ManualInstantElapsed));\n     store.register_late_pass(|| Box::new(partialeq_to_none::PartialeqToNone));\n+    store.register_late_pass(|| Box::new(manual_string_new::ManualStringNew));\n+    store.register_late_pass(|| Box::new(unused_peekable::UnusedPeekable));\n+    store.register_early_pass(|| Box::new(multi_assignments::MultiAssignments));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "6d987f393fa5ce353c2d38dae517e5cdf18f1a6d", "filename": "src/tools/clippy/clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,5 +1,6 @@\n use super::NEEDLESS_COLLECT;\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n+use clippy_utils::higher;\n use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n@@ -184,10 +185,19 @@ struct IterFunctionVisitor<'a, 'tcx> {\n impl<'tcx> Visitor<'tcx> for IterFunctionVisitor<'_, 'tcx> {\n     fn visit_block(&mut self, block: &'tcx Block<'tcx>) {\n         for (expr, hir_id) in block.stmts.iter().filter_map(get_expr_and_hir_id_from_stmt) {\n+            if check_loop_kind(expr).is_some() {\n+                continue;\n+            }\n             self.visit_block_expr(expr, hir_id);\n         }\n         if let Some(expr) = block.expr {\n-            self.visit_block_expr(expr, None);\n+            if let Some(loop_kind) = check_loop_kind(expr) {\n+                if let LoopKind::Conditional(block_expr) = loop_kind {\n+                    self.visit_block_expr(block_expr, None);\n+                }\n+            } else {\n+                self.visit_block_expr(expr, None);\n+            }\n         }\n     }\n \n@@ -264,6 +274,28 @@ impl<'tcx> Visitor<'tcx> for IterFunctionVisitor<'_, 'tcx> {\n     }\n }\n \n+enum LoopKind<'tcx> {\n+    Conditional(&'tcx Expr<'tcx>),\n+    Loop,\n+}\n+\n+fn check_loop_kind<'tcx>(expr: &Expr<'tcx>) -> Option<LoopKind<'tcx>> {\n+    if let Some(higher::WhileLet { let_expr, .. }) = higher::WhileLet::hir(expr) {\n+        return Some(LoopKind::Conditional(let_expr));\n+    }\n+    if let Some(higher::While { condition, .. }) = higher::While::hir(expr) {\n+        return Some(LoopKind::Conditional(condition));\n+    }\n+    if let Some(higher::ForLoop { arg, .. }) = higher::ForLoop::hir(expr) {\n+        return Some(LoopKind::Conditional(arg));\n+    }\n+    if let ExprKind::Loop { .. } = expr.kind {\n+        return Some(LoopKind::Loop);\n+    }\n+\n+    None\n+}\n+\n impl<'tcx> IterFunctionVisitor<'_, 'tcx> {\n     fn visit_block_expr(&mut self, expr: &'tcx Expr<'tcx>, hir_id: Option<HirId>) {\n         self.current_statement_hir_id = hir_id;"}, {"sha": "2502c8f880ddce76aa1045cfcdc815aaa315209d", "filename": "src/tools/clippy/clippy_lints/src/manual_async_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -192,7 +192,7 @@ fn suggested_ret(cx: &LateContext<'_>, output: &Ty<'_>) -> Option<(&'static str,\n     match output.kind {\n         TyKind::Tup(tys) if tys.is_empty() => {\n             let sugg = \"remove the return type\";\n-            Some((sugg, \"\".into()))\n+            Some((sugg, String::new()))\n         },\n         _ => {\n             let sugg = \"return the output of the future directly\";"}, {"sha": "cf5004399b884cb67e8e1553e4d7aaa9ab9eba5f", "filename": "src/tools/clippy/clippy_lints/src/manual_ok_or.rs", "status": "removed", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_ok_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_ok_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_ok_or.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,95 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::{indent_of, reindent_multiline, snippet_opt};\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_lang_ctor, path_to_local_id};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{ResultErr, ResultOk};\n-use rustc_hir::{Closure, Expr, ExprKind, PatKind};\n-use rustc_lint::LintContext;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::lint::in_external_macro;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::symbol::sym;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    ///\n-    /// Finds patterns that reimplement `Option::ok_or`.\n-    ///\n-    /// ### Why is this bad?\n-    ///\n-    /// Concise code helps focusing on behavior instead of boilerplate.\n-    ///\n-    /// ### Examples\n-    /// ```rust\n-    /// let foo: Option<i32> = None;\n-    /// foo.map_or(Err(\"error\"), |v| Ok(v));\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// let foo: Option<i32> = None;\n-    /// foo.ok_or(\"error\");\n-    /// ```\n-    #[clippy::version = \"1.49.0\"]\n-    pub MANUAL_OK_OR,\n-    pedantic,\n-    \"finds patterns that can be encoded more concisely with `Option::ok_or`\"\n-}\n-\n-declare_lint_pass!(ManualOkOr => [MANUAL_OK_OR]);\n-\n-impl<'tcx> LateLintPass<'tcx> for ManualOkOr {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, scrutinee: &'tcx Expr<'tcx>) {\n-        if in_external_macro(cx.sess(), scrutinee.span) {\n-            return;\n-        }\n-\n-        if_chain! {\n-            if let ExprKind::MethodCall(method_segment, [receiver, or_expr, map_expr], _) = scrutinee.kind;\n-            if method_segment.ident.name == sym!(map_or);\n-            let ty = cx.typeck_results().expr_ty(receiver);\n-            if is_type_diagnostic_item(cx, ty, sym::Option);\n-            if is_ok_wrapping(cx, map_expr);\n-            if let ExprKind::Call(Expr { kind: ExprKind::Path(err_path), .. }, &[ref err_arg]) = or_expr.kind;\n-            if is_lang_ctor(cx, err_path, ResultErr);\n-            if let Some(method_receiver_snippet) = snippet_opt(cx, receiver.span);\n-            if let Some(err_arg_snippet) = snippet_opt(cx, err_arg.span);\n-            if let Some(indent) = indent_of(cx, scrutinee.span);\n-            then {\n-                let reindented_err_arg_snippet =\n-                    reindent_multiline(err_arg_snippet.into(), true, Some(indent + 4));\n-                span_lint_and_sugg(\n-                    cx,\n-                    MANUAL_OK_OR,\n-                    scrutinee.span,\n-                    \"this pattern reimplements `Option::ok_or`\",\n-                    \"replace with\",\n-                    format!(\n-                        \"{}.ok_or({})\",\n-                        method_receiver_snippet,\n-                        reindented_err_arg_snippet\n-                    ),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn is_ok_wrapping(cx: &LateContext<'_>, map_expr: &Expr<'_>) -> bool {\n-    if let ExprKind::Path(ref qpath) = map_expr.kind {\n-        if is_lang_ctor(cx, qpath, ResultOk) {\n-            return true;\n-        }\n-    }\n-    if_chain! {\n-        if let ExprKind::Closure(&Closure { body, .. }) = map_expr.kind;\n-        let body = cx.tcx.hir().body(body);\n-        if let PatKind::Binding(_, param_id, ..) = body.params[0].pat.kind;\n-        if let ExprKind::Call(Expr { kind: ExprKind::Path(ok_path), .. }, &[ref ok_arg]) = body.value.kind;\n-        if is_lang_ctor(cx, ok_path, ResultOk);\n-        then { path_to_local_id(ok_arg, param_id) } else { false }\n-    }\n-}"}, {"sha": "a90eaa8fdcbe35b200216f180c5675be3d5ff6d0", "filename": "src/tools/clippy/clippy_lints/src/manual_string_new.rs", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_string_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_string_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_string_new.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,140 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use rustc_ast::LitKind;\n+use rustc_errors::Applicability::MachineApplicable;\n+use rustc_hir::{Expr, ExprKind, PathSegment, QPath, TyKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{sym, symbol, Span};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    ///\n+    /// Checks for usage of `\"\"` to create a `String`, such as `\"\".to_string()`, `\"\".to_owned()`,\n+    /// `String::from(\"\")` and others.\n+    ///\n+    /// ### Why is this bad?\n+    ///\n+    /// Different ways of creating an empty string makes your code less standardized, which can\n+    /// be confusing.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let a = \"\".to_string();\n+    /// let b: String = \"\".into();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let a = String::new();\n+    /// let b = String::new();\n+    /// ```\n+    #[clippy::version = \"1.65.0\"]\n+    pub MANUAL_STRING_NEW,\n+    pedantic,\n+    \"empty String is being created manually\"\n+}\n+declare_lint_pass!(ManualStringNew => [MANUAL_STRING_NEW]);\n+\n+impl LateLintPass<'_> for ManualStringNew {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        if expr.span.from_expansion() {\n+            return;\n+        }\n+\n+        let ty = cx.typeck_results().expr_ty(expr);\n+        match ty.kind() {\n+            ty::Adt(adt_def, _) if adt_def.is_struct() => {\n+                if !cx.tcx.is_diagnostic_item(sym::String, adt_def.did()) {\n+                    return;\n+                }\n+            },\n+            _ => return,\n+        }\n+\n+        match expr.kind {\n+            ExprKind::Call(func, args) => {\n+                parse_call(cx, expr.span, func, args);\n+            },\n+            ExprKind::MethodCall(path_segment, args, _) => {\n+                parse_method_call(cx, expr.span, path_segment, args);\n+            },\n+            _ => (),\n+        }\n+    }\n+}\n+\n+/// Checks if an expression's kind corresponds to an empty &str.\n+fn is_expr_kind_empty_str(expr_kind: &ExprKind<'_>) -> bool {\n+    if  let ExprKind::Lit(lit) = expr_kind &&\n+        let LitKind::Str(value, _) = lit.node &&\n+        value == symbol::kw::Empty\n+    {\n+        return true;\n+    }\n+\n+    false\n+}\n+\n+fn warn_then_suggest(cx: &LateContext<'_>, span: Span) {\n+    span_lint_and_sugg(\n+        cx,\n+        MANUAL_STRING_NEW,\n+        span,\n+        \"empty String is being created manually\",\n+        \"consider using\",\n+        \"String::new()\".into(),\n+        MachineApplicable,\n+    );\n+}\n+\n+/// Tries to parse an expression as a method call, emitting the warning if necessary.\n+fn parse_method_call(cx: &LateContext<'_>, span: Span, path_segment: &PathSegment<'_>, args: &[Expr<'_>]) {\n+    if args.is_empty() {\n+        // When parsing TryFrom::try_from(...).expect(...), we will have more than 1 arg.\n+        return;\n+    }\n+\n+    let ident = path_segment.ident.as_str();\n+    let method_arg_kind = &args[0].kind;\n+    if [\"to_string\", \"to_owned\", \"into\"].contains(&ident) && is_expr_kind_empty_str(method_arg_kind) {\n+        warn_then_suggest(cx, span);\n+    } else if let ExprKind::Call(func, args) = method_arg_kind {\n+        // If our first argument is a function call itself, it could be an `unwrap`-like function.\n+        // E.g. String::try_from(\"hello\").unwrap(), TryFrom::try_from(\"\").expect(\"hello\"), etc.\n+        parse_call(cx, span, func, args);\n+    }\n+}\n+\n+/// Tries to parse an expression as a function call, emitting the warning if necessary.\n+fn parse_call(cx: &LateContext<'_>, span: Span, func: &Expr<'_>, args: &[Expr<'_>]) {\n+    if args.len() != 1 {\n+        return;\n+    }\n+\n+    let arg_kind = &args[0].kind;\n+    if let ExprKind::Path(qpath) = &func.kind {\n+        if let QPath::TypeRelative(_, _) = qpath {\n+            // String::from(...) or String::try_from(...)\n+            if  let QPath::TypeRelative(ty, path_seg) = qpath &&\n+                [sym::from, sym::try_from].contains(&path_seg.ident.name) &&\n+                let TyKind::Path(qpath) = &ty.kind &&\n+                let QPath::Resolved(_, path) = qpath &&\n+                let [path_seg] = path.segments &&\n+                path_seg.ident.name == sym::String &&\n+                is_expr_kind_empty_str(arg_kind)\n+            {\n+                warn_then_suggest(cx, span);\n+            }\n+        } else if let QPath::Resolved(_, path) = qpath {\n+            // From::from(...) or TryFrom::try_from(...)\n+            if  let [path_seg1, path_seg2] = path.segments &&\n+                is_expr_kind_empty_str(arg_kind) && (\n+                    (path_seg1.ident.name == sym::From && path_seg2.ident.name == sym::from) ||\n+                    (path_seg1.ident.name == sym::TryFrom && path_seg2.ident.name == sym::try_from)\n+                )\n+            {\n+                warn_then_suggest(cx, span);\n+            }\n+        }\n+    }\n+}"}, {"sha": "95c312f1fe26b19216c0573697d3ca5cca040920", "filename": "src/tools/clippy/clippy_lints/src/map_clone.rs", "status": "removed", "additions": 0, "deletions": 167, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,167 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::ty::{is_copy, is_type_diagnostic_item};\n-use clippy_utils::{is_trait_method, meets_msrv, msrvs, peel_blocks};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir as hir;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::mir::Mutability;\n-use rustc_middle::ty;\n-use rustc_middle::ty::adjustment::Adjust;\n-use rustc_semver::RustcVersion;\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::symbol::Ident;\n-use rustc_span::{sym, Span};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for usage of `map(|x| x.clone())` or\n-    /// dereferencing closures for `Copy` types, on `Iterator` or `Option`,\n-    /// and suggests `cloned()` or `copied()` instead\n-    ///\n-    /// ### Why is this bad?\n-    /// Readability, this can be written more concisely\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x = vec![42, 43];\n-    /// let y = x.iter();\n-    /// let z = y.map(|i| *i);\n-    /// ```\n-    ///\n-    /// The correct use would be:\n-    ///\n-    /// ```rust\n-    /// let x = vec![42, 43];\n-    /// let y = x.iter();\n-    /// let z = y.cloned();\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MAP_CLONE,\n-    style,\n-    \"using `iterator.map(|x| x.clone())`, or dereferencing closures for `Copy` types\"\n-}\n-\n-pub struct MapClone {\n-    msrv: Option<RustcVersion>,\n-}\n-\n-impl_lint_pass!(MapClone => [MAP_CLONE]);\n-\n-impl MapClone {\n-    pub fn new(msrv: Option<RustcVersion>) -> Self {\n-        Self { msrv }\n-    }\n-}\n-\n-impl<'tcx> LateLintPass<'tcx> for MapClone {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, e: &hir::Expr<'_>) {\n-        if e.span.from_expansion() {\n-            return;\n-        }\n-\n-        if_chain! {\n-            if let hir::ExprKind::MethodCall(method, args, _) = e.kind;\n-            if args.len() == 2;\n-            if method.ident.name == sym::map;\n-            let ty = cx.typeck_results().expr_ty(&args[0]);\n-            if is_type_diagnostic_item(cx, ty, sym::Option) || is_trait_method(cx, e, sym::Iterator);\n-            if let hir::ExprKind::Closure(&hir::Closure { body, .. }) = args[1].kind;\n-            then {\n-                let closure_body = cx.tcx.hir().body(body);\n-                let closure_expr = peel_blocks(&closure_body.value);\n-                match closure_body.params[0].pat.kind {\n-                    hir::PatKind::Ref(inner, hir::Mutability::Not) => if let hir::PatKind::Binding(\n-                        hir::BindingAnnotation::Unannotated, .., name, None\n-                    ) = inner.kind {\n-                        if ident_eq(name, closure_expr) {\n-                            self.lint_explicit_closure(cx, e.span, args[0].span, true);\n-                        }\n-                    },\n-                    hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, .., name, None) => {\n-                        match closure_expr.kind {\n-                            hir::ExprKind::Unary(hir::UnOp::Deref, inner) => {\n-                                if ident_eq(name, inner) {\n-                                    if let ty::Ref(.., Mutability::Not) = cx.typeck_results().expr_ty(inner).kind() {\n-                                        self.lint_explicit_closure(cx, e.span, args[0].span, true);\n-                                    }\n-                                }\n-                            },\n-                            hir::ExprKind::MethodCall(method, [obj], _) => if_chain! {\n-                                if ident_eq(name, obj) && method.ident.name == sym::clone;\n-                                if let Some(fn_id) = cx.typeck_results().type_dependent_def_id(closure_expr.hir_id);\n-                                if let Some(trait_id) = cx.tcx.trait_of_item(fn_id);\n-                                if cx.tcx.lang_items().clone_trait().map_or(false, |id| id == trait_id);\n-                                // no autoderefs\n-                                if !cx.typeck_results().expr_adjustments(obj).iter()\n-                                    .any(|a| matches!(a.kind, Adjust::Deref(Some(..))));\n-                                then {\n-                                    let obj_ty = cx.typeck_results().expr_ty(obj);\n-                                    if let ty::Ref(_, ty, mutability) = obj_ty.kind() {\n-                                        if matches!(mutability, Mutability::Not) {\n-                                            let copy = is_copy(cx, *ty);\n-                                            self.lint_explicit_closure(cx, e.span, args[0].span, copy);\n-                                        }\n-                                    } else {\n-                                        lint_needless_cloning(cx, e.span, args[0].span);\n-                                    }\n-                                }\n-                            },\n-                            _ => {},\n-                        }\n-                    },\n-                    _ => {},\n-                }\n-            }\n-        }\n-    }\n-\n-    extract_msrv_attr!(LateContext);\n-}\n-\n-fn ident_eq(name: Ident, path: &hir::Expr<'_>) -> bool {\n-    if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = path.kind {\n-        path.segments.len() == 1 && path.segments[0].ident == name\n-    } else {\n-        false\n-    }\n-}\n-\n-fn lint_needless_cloning(cx: &LateContext<'_>, root: Span, receiver: Span) {\n-    span_lint_and_sugg(\n-        cx,\n-        MAP_CLONE,\n-        root.trim_start(receiver).unwrap(),\n-        \"you are needlessly cloning iterator elements\",\n-        \"remove the `map` call\",\n-        String::new(),\n-        Applicability::MachineApplicable,\n-    );\n-}\n-\n-impl MapClone {\n-    fn lint_explicit_closure(&self, cx: &LateContext<'_>, replace: Span, root: Span, is_copy: bool) {\n-        let mut applicability = Applicability::MachineApplicable;\n-\n-        let (message, sugg_method) = if is_copy && meets_msrv(self.msrv, msrvs::ITERATOR_COPIED) {\n-            (\"you are using an explicit closure for copying elements\", \"copied\")\n-        } else {\n-            (\"you are using an explicit closure for cloning elements\", \"cloned\")\n-        };\n-\n-        span_lint_and_sugg(\n-            cx,\n-            MAP_CLONE,\n-            replace,\n-            message,\n-            &format!(\"consider calling the dedicated `{}` method\", sugg_method),\n-            format!(\n-                \"{}.{}()\",\n-                snippet_with_applicability(cx, root, \"..\", &mut applicability),\n-                sugg_method,\n-            ),\n-            applicability,\n-        );\n-    }\n-}"}, {"sha": "1e542447c96eca92b3668e723c5bef92393abb68", "filename": "src/tools/clippy/clippy_lints/src/map_err_ignore.rs", "status": "removed", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_err_ignore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_err_ignore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_err_ignore.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,154 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n-use rustc_hir::{CaptureBy, Closure, Expr, ExprKind, PatKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for instances of `map_err(|_| Some::Enum)`\n-    ///\n-    /// ### Why is this bad?\n-    /// This `map_err` throws away the original error rather than allowing the enum to contain and report the cause of the error\n-    ///\n-    /// ### Example\n-    /// Before:\n-    /// ```rust\n-    /// use std::fmt;\n-    ///\n-    /// #[derive(Debug)]\n-    /// enum Error {\n-    ///     Indivisible,\n-    ///     Remainder(u8),\n-    /// }\n-    ///\n-    /// impl fmt::Display for Error {\n-    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-    ///         match self {\n-    ///             Error::Indivisible => write!(f, \"could not divide input by three\"),\n-    ///             Error::Remainder(remainder) => write!(\n-    ///                 f,\n-    ///                 \"input is not divisible by three, remainder = {}\",\n-    ///                 remainder\n-    ///             ),\n-    ///         }\n-    ///     }\n-    /// }\n-    ///\n-    /// impl std::error::Error for Error {}\n-    ///\n-    /// fn divisible_by_3(input: &str) -> Result<(), Error> {\n-    ///     input\n-    ///         .parse::<i32>()\n-    ///         .map_err(|_| Error::Indivisible)\n-    ///         .map(|v| v % 3)\n-    ///         .and_then(|remainder| {\n-    ///             if remainder == 0 {\n-    ///                 Ok(())\n-    ///             } else {\n-    ///                 Err(Error::Remainder(remainder as u8))\n-    ///             }\n-    ///         })\n-    /// }\n-    ///  ```\n-    ///\n-    ///  After:\n-    ///  ```rust\n-    /// use std::{fmt, num::ParseIntError};\n-    ///\n-    /// #[derive(Debug)]\n-    /// enum Error {\n-    ///     Indivisible(ParseIntError),\n-    ///     Remainder(u8),\n-    /// }\n-    ///\n-    /// impl fmt::Display for Error {\n-    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-    ///         match self {\n-    ///             Error::Indivisible(_) => write!(f, \"could not divide input by three\"),\n-    ///             Error::Remainder(remainder) => write!(\n-    ///                 f,\n-    ///                 \"input is not divisible by three, remainder = {}\",\n-    ///                 remainder\n-    ///             ),\n-    ///         }\n-    ///     }\n-    /// }\n-    ///\n-    /// impl std::error::Error for Error {\n-    ///     fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n-    ///         match self {\n-    ///             Error::Indivisible(source) => Some(source),\n-    ///             _ => None,\n-    ///         }\n-    ///     }\n-    /// }\n-    ///\n-    /// fn divisible_by_3(input: &str) -> Result<(), Error> {\n-    ///     input\n-    ///         .parse::<i32>()\n-    ///         .map_err(Error::Indivisible)\n-    ///         .map(|v| v % 3)\n-    ///         .and_then(|remainder| {\n-    ///             if remainder == 0 {\n-    ///                 Ok(())\n-    ///             } else {\n-    ///                 Err(Error::Remainder(remainder as u8))\n-    ///             }\n-    ///         })\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.48.0\"]\n-    pub MAP_ERR_IGNORE,\n-    restriction,\n-    \"`map_err` should not ignore the original error\"\n-}\n-\n-declare_lint_pass!(MapErrIgnore => [MAP_ERR_IGNORE]);\n-\n-impl<'tcx> LateLintPass<'tcx> for MapErrIgnore {\n-    // do not try to lint if this is from a macro or desugaring\n-    fn check_expr(&mut self, cx: &LateContext<'_>, e: &Expr<'_>) {\n-        if e.span.from_expansion() {\n-            return;\n-        }\n-\n-        // check if this is a method call (e.g. x.foo())\n-        if let ExprKind::MethodCall(method, [_, arg], _) = e.kind {\n-            // only work if the method name is `map_err` and there are only 2 arguments (e.g. x.map_err(|_|[1]\n-            // Enum::Variant[2]))\n-            if method.ident.name == sym!(map_err) {\n-                // make sure the first argument is a closure, and grab the CaptureRef, BodyId, and fn_decl_span\n-                // fields\n-                if let ExprKind::Closure(&Closure {\n-                    capture_clause,\n-                    body,\n-                    fn_decl_span,\n-                    ..\n-                }) = arg.kind\n-                {\n-                    // check if this is by Reference (meaning there's no move statement)\n-                    if capture_clause == CaptureBy::Ref {\n-                        // Get the closure body to check the parameters and values\n-                        let closure_body = cx.tcx.hir().body(body);\n-                        // make sure there's only one parameter (`|_|`)\n-                        if closure_body.params.len() == 1 {\n-                            // make sure that parameter is the wild token (`_`)\n-                            if let PatKind::Wild = closure_body.params[0].pat.kind {\n-                                // span the area of the closure capture and warn that the\n-                                // original error will be thrown away\n-                                span_lint_and_help(\n-                                    cx,\n-                                    MAP_ERR_IGNORE,\n-                                    fn_decl_span,\n-                                    \"`map_err(|_|...` wildcard pattern discards the original error\",\n-                                    None,\n-                                    \"consider storing the original error as a source in the new error, or silence this warning using an ignored identifier (`.map_err(|_foo| ...`)\",\n-                                );\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "34cc082687ec20426d6f36ae4c1aa11a4530458a", "filename": "src/tools/clippy/clippy_lints/src/matches/match_like_matches.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,10 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::is_wild;\n use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::span_contains_comment;\n use rustc_ast::{Attribute, LitKind};\n use rustc_errors::Applicability;\n use rustc_hir::{Arm, BorrowKind, Expr, ExprKind, Guard, Pat};\n-use rustc_lint::LateContext;\n+use rustc_lint::{LateContext, LintContext};\n use rustc_middle::ty;\n use rustc_span::source_map::Spanned;\n \n@@ -76,6 +77,7 @@ where\n         >,\n {\n     if_chain! {\n+        if !span_contains_comment(cx.sess().source_map(), expr.span);\n         if iter.len() >= 2;\n         if cx.typeck_results().expr_ty(expr).is_bool();\n         if let Some((_, last_pat_opt, last_expr, _)) = iter.next_back();"}, {"sha": "6f037339ec75870552a3d2867f447a012364d143", "filename": "src/tools/clippy/clippy_lints/src/matches/needless_match.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -8,7 +8,7 @@ use clippy_utils::{\n };\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionNone;\n-use rustc_hir::{Arm, BindingAnnotation, Expr, ExprKind, FnRetTy, Node, Pat, PatKind, Path, QPath};\n+use rustc_hir::{Arm, BindingAnnotation, Expr, ExprKind, FnRetTy, Guard, Node, Pat, PatKind, Path, QPath};\n use rustc_lint::LateContext;\n use rustc_span::sym;\n use rustc_typeck::hir_ty_to_ty;\n@@ -65,8 +65,26 @@ pub(crate) fn check_if_let<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'_>, if_let:\n fn check_all_arms(cx: &LateContext<'_>, match_expr: &Expr<'_>, arms: &[Arm<'_>]) -> bool {\n     for arm in arms {\n         let arm_expr = peel_blocks_with_stmt(arm.body);\n+\n+        if let Some(guard_expr) = &arm.guard {\n+            match guard_expr {\n+                // gives up if `pat if expr` can have side effects\n+                Guard::If(if_cond) => {\n+                    if if_cond.can_have_side_effects() {\n+                        return false;\n+                    }\n+                },\n+                // gives up `pat if let ...` arm\n+                Guard::IfLet(_) => {\n+                    return false;\n+                },\n+            };\n+        }\n+\n         if let PatKind::Wild = arm.pat.kind {\n-            return eq_expr_value(cx, match_expr, strip_return(arm_expr));\n+            if !eq_expr_value(cx, match_expr, strip_return(arm_expr)) {\n+                return false;\n+            }\n         } else if !pat_same_as_expr(arm.pat, arm_expr) {\n             return false;\n         }"}, {"sha": "6a7c63d76f72c8afee58a465bec5ba33a21e5436", "filename": "src/tools/clippy/clippy_lints/src/methods/bytecount.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbytecount.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,70 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::match_type;\n+use clippy_utils::visitors::is_local_used;\n+use clippy_utils::{path_to_local_id, paths, peel_blocks, peel_ref_operators, strip_pat_refs};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Closure, Expr, ExprKind, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, UintTy};\n+use rustc_span::sym;\n+\n+use super::NAIVE_BYTECOUNT;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    filter_recv: &'tcx Expr<'_>,\n+    filter_arg: &'tcx Expr<'_>,\n+) {\n+    if_chain! {\n+        if let ExprKind::Closure(&Closure { body, .. }) = filter_arg.kind;\n+        let body = cx.tcx.hir().body(body);\n+        if let [param] = body.params;\n+        if let PatKind::Binding(_, arg_id, _, _) = strip_pat_refs(param.pat).kind;\n+        if let ExprKind::Binary(ref op, l, r) = body.value.kind;\n+        if op.node == BinOpKind::Eq;\n+        if match_type(cx,\n+                    cx.typeck_results().expr_ty(filter_recv).peel_refs(),\n+                    &paths::SLICE_ITER);\n+        let operand_is_arg = |expr| {\n+            let expr = peel_ref_operators(cx, peel_blocks(expr));\n+            path_to_local_id(expr, arg_id)\n+        };\n+        let needle = if operand_is_arg(l) {\n+            r\n+        } else if operand_is_arg(r) {\n+            l\n+        } else {\n+            return;\n+        };\n+        if ty::Uint(UintTy::U8) == *cx.typeck_results().expr_ty(needle).peel_refs().kind();\n+        if !is_local_used(cx, needle, arg_id);\n+        then {\n+            let haystack = if let ExprKind::MethodCall(path, args, _) =\n+                    filter_recv.kind {\n+                let p = path.ident.name;\n+                if (p == sym::iter || p == sym!(iter_mut)) && args.len() == 1 {\n+                    &args[0]\n+                } else {\n+                    filter_recv\n+                }\n+            } else {\n+                filter_recv\n+            };\n+            let mut applicability = Applicability::MaybeIncorrect;\n+            span_lint_and_sugg(\n+                cx,\n+                NAIVE_BYTECOUNT,\n+                expr.span,\n+                \"you appear to be counting bytes the naive way\",\n+                \"consider using the bytecount crate\",\n+                format!(\"bytecount::count({}, {})\",\n+                        snippet_with_applicability(cx, haystack.span, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, needle.span, \"..\", &mut applicability)),\n+                applicability,\n+            );\n+        }\n+    };\n+}"}, {"sha": "fcfc25b523dac4d6dc16ff284fea4fe55e4d2e2f", "filename": "src/tools/clippy/clippy_lints/src/methods/bytes_count_to_len.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbytes_count_to_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbytes_count_to_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbytes_count_to_len.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,37 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::BYTES_COUNT_TO_LEN;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    count_recv: &'tcx hir::Expr<'_>,\n+    bytes_recv: &'tcx hir::Expr<'_>,\n+) {\n+    if_chain! {\n+        if let Some(bytes_id) = cx.typeck_results().type_dependent_def_id(count_recv.hir_id);\n+        if let Some(impl_id) = cx.tcx.impl_of_method(bytes_id);\n+        if cx.tcx.type_of(impl_id).is_str();\n+        let ty = cx.typeck_results().expr_ty(bytes_recv).peel_refs();\n+        if ty.is_str() || is_type_diagnostic_item(cx, ty, sym::String);\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                BYTES_COUNT_TO_LEN,\n+                expr.span,\n+                \"using long and hard to read `.bytes().count()`\",\n+                \"consider calling `.len()` instead\",\n+                format!(\"{}.len()\", snippet_with_applicability(cx, bytes_recv.span, \"..\", &mut applicability)),\n+                applicability\n+            );\n+        }\n+    };\n+}"}, {"sha": "b3c2c7c9a2dcc3a70cac63fe2363ecf238a1d514", "filename": "src/tools/clippy/clippy_lints/src/methods/case_sensitive_file_extension_comparisons.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fcase_sensitive_file_extension_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fcase_sensitive_file_extension_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fcase_sensitive_file_extension_comparisons.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,41 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_span::{source_map::Spanned, symbol::sym, Span};\n+\n+use super::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    call_span: Span,\n+    recv: &'tcx Expr<'_>,\n+    arg: &'tcx Expr<'_>,\n+) {\n+    if_chain! {\n+        if let Some(method_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        if let Some(impl_id) = cx.tcx.impl_of_method(method_id);\n+        if cx.tcx.type_of(impl_id).is_str();\n+        if let ExprKind::Lit(Spanned { node: LitKind::Str(ext_literal, ..), ..}) = arg.kind;\n+        if (2..=6).contains(&ext_literal.as_str().len());\n+        let ext_str = ext_literal.as_str();\n+        if ext_str.starts_with('.');\n+        if ext_str.chars().skip(1).all(|c| c.is_uppercase() || c.is_ascii_digit())\n+            || ext_str.chars().skip(1).all(|c| c.is_lowercase() || c.is_ascii_digit());\n+        let recv_ty = cx.typeck_results().expr_ty(recv).peel_refs();\n+        if recv_ty.is_str() || is_type_diagnostic_item(cx, recv_ty, sym::String);\n+        then {\n+            span_lint_and_help(\n+                cx,\n+                CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n+                call_span,\n+                \"case-sensitive file extension comparison\",\n+                None,\n+                \"consider using a case-insensitive comparison instead\",\n+            );\n+        }\n+    }\n+}"}, {"sha": "561033be5b6af3945bfadf83c6903a56b7f486c9", "filename": "src/tools/clippy/clippy_lints/src/methods/collapsible_str_replace.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,96 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet;\n+use clippy_utils::visitors::for_each_expr;\n+use clippy_utils::{eq_expr_value, get_parent_expr};\n+use core::ops::ControlFlow;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use std::collections::VecDeque;\n+\n+use super::method_call;\n+use super::COLLAPSIBLE_STR_REPLACE;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'tcx>,\n+    from: &'tcx hir::Expr<'tcx>,\n+    to: &'tcx hir::Expr<'tcx>,\n+) {\n+    let replace_methods = collect_replace_calls(cx, expr, to);\n+    if replace_methods.methods.len() > 1 {\n+        let from_kind = cx.typeck_results().expr_ty(from).peel_refs().kind();\n+        // If the parent node's `to` argument is the same as the `to` argument\n+        // of the last replace call in the current chain, don't lint as it was already linted\n+        if let Some(parent) = get_parent_expr(cx, expr)\n+            && let Some((\"replace\", [_, current_from, current_to], _)) = method_call(parent)\n+            && eq_expr_value(cx, to, current_to)\n+            && from_kind == cx.typeck_results().expr_ty(current_from).peel_refs().kind()\n+        {\n+            return;\n+        }\n+\n+        check_consecutive_replace_calls(cx, expr, &replace_methods, to);\n+    }\n+}\n+\n+struct ReplaceMethods<'tcx> {\n+    methods: VecDeque<&'tcx hir::Expr<'tcx>>,\n+    from_args: VecDeque<&'tcx hir::Expr<'tcx>>,\n+}\n+\n+fn collect_replace_calls<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'tcx>,\n+    to_arg: &'tcx hir::Expr<'tcx>,\n+) -> ReplaceMethods<'tcx> {\n+    let mut methods = VecDeque::new();\n+    let mut from_args = VecDeque::new();\n+\n+    let _: Option<()> = for_each_expr(expr, |e| {\n+        if let Some((\"replace\", [_, from, to], _)) = method_call(e) {\n+            if eq_expr_value(cx, to_arg, to) && cx.typeck_results().expr_ty(from).peel_refs().is_char() {\n+                methods.push_front(e);\n+                from_args.push_front(from);\n+                ControlFlow::Continue(())\n+            } else {\n+                ControlFlow::BREAK\n+            }\n+        } else {\n+            ControlFlow::Continue(())\n+        }\n+    });\n+\n+    ReplaceMethods { methods, from_args }\n+}\n+\n+/// Check a chain of `str::replace` calls for `collapsible_str_replace` lint.\n+fn check_consecutive_replace_calls<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'tcx>,\n+    replace_methods: &ReplaceMethods<'tcx>,\n+    to_arg: &'tcx hir::Expr<'tcx>,\n+) {\n+    let from_args = &replace_methods.from_args;\n+    let from_arg_reprs: Vec<String> = from_args\n+        .iter()\n+        .map(|from_arg| snippet(cx, from_arg.span, \"..\").to_string())\n+        .collect();\n+    let app = Applicability::MachineApplicable;\n+    let earliest_replace_call = replace_methods.methods.front().unwrap();\n+    if let Some((_, [..], span_lo)) = method_call(earliest_replace_call) {\n+        span_lint_and_sugg(\n+            cx,\n+            COLLAPSIBLE_STR_REPLACE,\n+            expr.span.with_lo(span_lo.lo()),\n+            \"used consecutive `str::replace` call\",\n+            \"replace with\",\n+            format!(\n+                \"replace([{}], {})\",\n+                from_arg_reprs.join(\", \"),\n+                snippet(cx, to_arg.span, \"..\"),\n+            ),\n+            app,\n+        );\n+    }\n+}"}, {"sha": "d59fefa1ddc0ebf68104498532f8da1f1c8c0e26", "filename": "src/tools/clippy/clippy_lints/src/methods/expect_used.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -7,18 +7,26 @@ use rustc_span::sym;\n \n use super::EXPECT_USED;\n \n-/// lint use of `expect()` for `Option`s and `Result`s\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>, allow_expect_in_tests: bool) {\n+/// lint use of `expect()` or `expect_err` for `Result` and `expect()` for `Option`.\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    expr: &hir::Expr<'_>,\n+    recv: &hir::Expr<'_>,\n+    is_err: bool,\n+    allow_expect_in_tests: bool,\n+) {\n     let obj_ty = cx.typeck_results().expr_ty(recv).peel_refs();\n \n-    let mess = if is_type_diagnostic_item(cx, obj_ty, sym::Option) {\n+    let mess = if is_type_diagnostic_item(cx, obj_ty, sym::Option) && !is_err {\n         Some((EXPECT_USED, \"an Option\", \"None\", \"\"))\n     } else if is_type_diagnostic_item(cx, obj_ty, sym::Result) {\n-        Some((EXPECT_USED, \"a Result\", \"Err\", \"an \"))\n+        Some((EXPECT_USED, \"a Result\", if is_err { \"Ok\" } else { \"Err\" }, \"an \"))\n     } else {\n         None\n     };\n \n+    let method = if is_err { \"expect_err\" } else { \"expect\" };\n+\n     if allow_expect_in_tests && is_in_test_function(cx.tcx, expr.hir_id) {\n         return;\n     }\n@@ -28,7 +36,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n             cx,\n             lint,\n             expr.span,\n-            &format!(\"used `expect()` on `{kind}` value\"),\n+            &format!(\"used `{method}()` on `{kind}` value\"),\n             None,\n             &format!(\"if this value is {none_prefix}`{none_value}`, it will panic\"),\n         );"}, {"sha": "4de77de74042171a65e7092def7c30cad1895558", "filename": "src/tools/clippy/clippy_lints/src/methods/get_first.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fget_first.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fget_first.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fget_first.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,39 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_slice_of_primitives;\n+use clippy_utils::source::snippet_with_applicability;\n+use if_chain::if_chain;\n+use rustc_ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::Spanned;\n+\n+use super::GET_FIRST;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    recv: &'tcx hir::Expr<'_>,\n+    arg: &'tcx hir::Expr<'_>,\n+) {\n+    if_chain! {\n+        if let Some(method_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        if let Some(impl_id) = cx.tcx.impl_of_method(method_id);\n+        if cx.tcx.type_of(impl_id).is_slice();\n+        if let Some(_) = is_slice_of_primitives(cx, recv);\n+        if let hir::ExprKind::Lit(Spanned { node: LitKind::Int(0, _), .. }) = arg.kind;\n+        then {\n+            let mut app = Applicability::MachineApplicable;\n+            let slice_name = snippet_with_applicability(cx, recv.span, \"..\", &mut app);\n+            span_lint_and_sugg(\n+                cx,\n+                GET_FIRST,\n+                expr.span,\n+                &format!(\"accessing first element with `{0}.get(0)`\", slice_name),\n+                \"try\",\n+                format!(\"{}.first()\", slice_name),\n+                app,\n+            );\n+        }\n+    }\n+}"}, {"sha": "cea7b0d82ff3f0f071161c94bacd1af86e51a59c", "filename": "src/tools/clippy/clippy_lints/src/methods/iter_on_single_or_empty_collections.rs", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_on_single_or_empty_collections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_on_single_or_empty_collections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_on_single_or_empty_collections.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,107 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet;\n+use clippy_utils::{get_expr_use_or_unification_node, is_lang_ctor, is_no_std_crate};\n+\n+use rustc_errors::Applicability;\n+use rustc_hir::LangItem::{OptionNone, OptionSome};\n+use rustc_hir::{Expr, ExprKind, Node};\n+use rustc_lint::LateContext;\n+\n+use super::{ITER_ON_EMPTY_COLLECTIONS, ITER_ON_SINGLE_ITEMS};\n+\n+enum IterType {\n+    Iter,\n+    IterMut,\n+    IntoIter,\n+}\n+\n+impl IterType {\n+    fn ref_prefix(&self) -> &'static str {\n+        match self {\n+            Self::Iter => \"&\",\n+            Self::IterMut => \"&mut \",\n+            Self::IntoIter => \"\",\n+        }\n+    }\n+}\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, method_name: &str, recv: &Expr<'_>) {\n+    let item = match &recv.kind {\n+        ExprKind::Array(v) if v.len() <= 1 => v.first(),\n+        ExprKind::Path(p) => {\n+            if is_lang_ctor(cx, p, OptionNone) {\n+                None\n+            } else {\n+                return;\n+            }\n+        },\n+        ExprKind::Call(f, some_args) if some_args.len() == 1 => {\n+            if let ExprKind::Path(p) = &f.kind {\n+                if is_lang_ctor(cx, p, OptionSome) {\n+                    Some(&some_args[0])\n+                } else {\n+                    return;\n+                }\n+            } else {\n+                return;\n+            }\n+        },\n+        _ => return,\n+    };\n+    let iter_type = match method_name {\n+        \"iter\" => IterType::Iter,\n+        \"iter_mut\" => IterType::IterMut,\n+        \"into_iter\" => IterType::IntoIter,\n+        _ => return,\n+    };\n+\n+    let is_unified = match get_expr_use_or_unification_node(cx.tcx, expr) {\n+        Some((Node::Expr(parent), child_id)) => match parent.kind {\n+            ExprKind::If(e, _, _) | ExprKind::Match(e, _, _) if e.hir_id == child_id => false,\n+            ExprKind::If(_, _, _)\n+            | ExprKind::Match(_, _, _)\n+            | ExprKind::Closure(_)\n+            | ExprKind::Ret(_)\n+            | ExprKind::Break(_, _) => true,\n+            _ => false,\n+        },\n+        Some((Node::Stmt(_) | Node::Local(_), _)) => false,\n+        _ => true,\n+    };\n+\n+    if is_unified {\n+        return;\n+    }\n+\n+    if let Some(i) = item {\n+        let sugg = format!(\n+            \"{}::iter::once({}{})\",\n+            if is_no_std_crate(cx) { \"core\" } else { \"std\" },\n+            iter_type.ref_prefix(),\n+            snippet(cx, i.span, \"...\")\n+        );\n+        span_lint_and_sugg(\n+            cx,\n+            ITER_ON_SINGLE_ITEMS,\n+            expr.span,\n+            &format!(\"`{method_name}` call on a collection with only one item\"),\n+            \"try\",\n+            sugg,\n+            Applicability::MaybeIncorrect,\n+        );\n+    } else {\n+        span_lint_and_sugg(\n+            cx,\n+            ITER_ON_EMPTY_COLLECTIONS,\n+            expr.span,\n+            &format!(\"`{method_name}` call on an empty collection\"),\n+            \"try\",\n+            if is_no_std_crate(cx) {\n+                \"core::iter::empty()\".to_string()\n+            } else {\n+                \"std::iter::empty()\".to_string()\n+            },\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+}"}, {"sha": "ffd2f4a38b8ac1ac92ec391abca7716e811ebe7b", "filename": "src/tools/clippy/clippy_lints/src/methods/manual_ok_or.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_ok_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_ok_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_ok_or.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,64 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::{indent_of, reindent_multiline, snippet_opt};\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{is_lang_ctor, path_to_local_id};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::LangItem::{ResultErr, ResultOk};\n+use rustc_hir::{Closure, Expr, ExprKind, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+\n+use super::MANUAL_OK_OR;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+    recv: &'tcx Expr<'_>,\n+    or_expr: &'tcx Expr<'_>,\n+    map_expr: &'tcx Expr<'_>,\n+) {\n+    if_chain! {\n+        if let Some(method_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        if let Some(impl_id) = cx.tcx.impl_of_method(method_id);\n+        if is_type_diagnostic_item(cx, cx.tcx.type_of(impl_id), sym::Option);\n+        if let ExprKind::Call(Expr { kind: ExprKind::Path(err_path), .. }, [err_arg]) = or_expr.kind;\n+        if is_lang_ctor(cx, err_path, ResultErr);\n+        if is_ok_wrapping(cx, map_expr);\n+        if let Some(recv_snippet) = snippet_opt(cx, recv.span);\n+        if let Some(err_arg_snippet) = snippet_opt(cx, err_arg.span);\n+        if let Some(indent) = indent_of(cx, expr.span);\n+        then {\n+            let reindented_err_arg_snippet = reindent_multiline(err_arg_snippet.into(), true, Some(indent + 4));\n+            span_lint_and_sugg(\n+                cx,\n+                MANUAL_OK_OR,\n+                expr.span,\n+                \"this pattern reimplements `Option::ok_or`\",\n+                \"replace with\",\n+                format!(\n+                    \"{}.ok_or({})\",\n+                    recv_snippet,\n+                    reindented_err_arg_snippet\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}\n+\n+fn is_ok_wrapping(cx: &LateContext<'_>, map_expr: &Expr<'_>) -> bool {\n+    if let ExprKind::Path(ref qpath) = map_expr.kind {\n+        if is_lang_ctor(cx, qpath, ResultOk) {\n+            return true;\n+        }\n+    }\n+    if_chain! {\n+        if let ExprKind::Closure(&Closure { body, .. }) = map_expr.kind;\n+        let body = cx.tcx.hir().body(body);\n+        if let PatKind::Binding(_, param_id, ..) = body.params[0].pat.kind;\n+        if let ExprKind::Call(Expr { kind: ExprKind::Path(ok_path), .. }, &[ref ok_arg]) = body.value.kind;\n+        if is_lang_ctor(cx, ok_path, ResultOk);\n+        then { path_to_local_id(ok_arg, param_id) } else { false }\n+    }\n+}"}, {"sha": "ffedda95ff8e57870170c940bebf4933f107e3e4", "filename": "src/tools/clippy/clippy_lints/src/methods/map_clone.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,122 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::{is_copy, is_type_diagnostic_item};\n+use clippy_utils::{is_diag_trait_item, meets_msrv, msrvs, peel_blocks};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::mir::Mutability;\n+use rustc_middle::ty;\n+use rustc_middle::ty::adjustment::Adjust;\n+use rustc_semver::RustcVersion;\n+use rustc_span::symbol::Ident;\n+use rustc_span::{sym, Span};\n+\n+use super::MAP_CLONE;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'_>,\n+    e: &hir::Expr<'_>,\n+    recv: &hir::Expr<'_>,\n+    arg: &'tcx hir::Expr<'_>,\n+    msrv: Option<RustcVersion>,\n+) {\n+    if_chain! {\n+        if let Some(method_id) = cx.typeck_results().type_dependent_def_id(e.hir_id);\n+        if cx.tcx.impl_of_method(method_id)\n+            .map_or(false, |id| is_type_diagnostic_item(cx, cx.tcx.type_of(id), sym::Option))\n+            || is_diag_trait_item(cx, method_id, sym::Iterator);\n+        if let hir::ExprKind::Closure(&hir::Closure{ body, .. }) = arg.kind;\n+        then {\n+            let closure_body = cx.tcx.hir().body(body);\n+            let closure_expr = peel_blocks(&closure_body.value);\n+            match closure_body.params[0].pat.kind {\n+                hir::PatKind::Ref(inner, hir::Mutability::Not) => if let hir::PatKind::Binding(\n+                    hir::BindingAnnotation::Unannotated, .., name, None\n+                ) = inner.kind {\n+                    if ident_eq(name, closure_expr) {\n+                        lint_explicit_closure(cx, e.span, recv.span, true, msrv);\n+                    }\n+                },\n+                hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, .., name, None) => {\n+                    match closure_expr.kind {\n+                        hir::ExprKind::Unary(hir::UnOp::Deref, inner) => {\n+                            if ident_eq(name, inner) {\n+                                if let ty::Ref(.., Mutability::Not) = cx.typeck_results().expr_ty(inner).kind() {\n+                                    lint_explicit_closure(cx, e.span, recv.span, true, msrv);\n+                                }\n+                            }\n+                        },\n+                        hir::ExprKind::MethodCall(method, [obj], _) => if_chain! {\n+                            if ident_eq(name, obj) && method.ident.name == sym::clone;\n+                            if let Some(fn_id) = cx.typeck_results().type_dependent_def_id(closure_expr.hir_id);\n+                            if let Some(trait_id) = cx.tcx.trait_of_item(fn_id);\n+                            if cx.tcx.lang_items().clone_trait().map_or(false, |id| id == trait_id);\n+                            // no autoderefs\n+                            if !cx.typeck_results().expr_adjustments(obj).iter()\n+                                .any(|a| matches!(a.kind, Adjust::Deref(Some(..))));\n+                            then {\n+                                let obj_ty = cx.typeck_results().expr_ty(obj);\n+                                if let ty::Ref(_, ty, mutability) = obj_ty.kind() {\n+                                    if matches!(mutability, Mutability::Not) {\n+                                        let copy = is_copy(cx, *ty);\n+                                        lint_explicit_closure(cx, e.span, recv.span, copy, msrv);\n+                                    }\n+                                } else {\n+                                    lint_needless_cloning(cx, e.span, recv.span);\n+                                }\n+                            }\n+                        },\n+                        _ => {},\n+                    }\n+                },\n+                _ => {},\n+            }\n+        }\n+    }\n+}\n+\n+fn ident_eq(name: Ident, path: &hir::Expr<'_>) -> bool {\n+    if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = path.kind {\n+        path.segments.len() == 1 && path.segments[0].ident == name\n+    } else {\n+        false\n+    }\n+}\n+\n+fn lint_needless_cloning(cx: &LateContext<'_>, root: Span, receiver: Span) {\n+    span_lint_and_sugg(\n+        cx,\n+        MAP_CLONE,\n+        root.trim_start(receiver).unwrap(),\n+        \"you are needlessly cloning iterator elements\",\n+        \"remove the `map` call\",\n+        String::new(),\n+        Applicability::MachineApplicable,\n+    );\n+}\n+\n+fn lint_explicit_closure(cx: &LateContext<'_>, replace: Span, root: Span, is_copy: bool, msrv: Option<RustcVersion>) {\n+    let mut applicability = Applicability::MachineApplicable;\n+\n+    let (message, sugg_method) = if is_copy && meets_msrv(msrv, msrvs::ITERATOR_COPIED) {\n+        (\"you are using an explicit closure for copying elements\", \"copied\")\n+    } else {\n+        (\"you are using an explicit closure for cloning elements\", \"cloned\")\n+    };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        MAP_CLONE,\n+        replace,\n+        message,\n+        &format!(\"consider calling the dedicated `{}` method\", sugg_method),\n+        format!(\n+            \"{}.{}()\",\n+            snippet_with_applicability(cx, root, \"..\", &mut applicability),\n+            sugg_method,\n+        ),\n+        applicability,\n+    );\n+}"}, {"sha": "1fb6617145e718bb0a9f116f955a3c5a73a30f09", "filename": "src/tools/clippy/clippy_lints/src/methods/map_err_ignore.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_err_ignore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_err_ignore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_err_ignore.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,34 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use rustc_hir::{CaptureBy, Closure, Expr, ExprKind, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::MAP_ERR_IGNORE;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'_>, e: &Expr<'_>, arg: &'tcx Expr<'_>) {\n+    if let Some(method_id) = cx.typeck_results().type_dependent_def_id(e.hir_id)\n+        && let Some(impl_id) = cx.tcx.impl_of_method(method_id)\n+        && is_type_diagnostic_item(cx, cx.tcx.type_of(impl_id), sym::Result)\n+        && let ExprKind::Closure(&Closure {\n+            capture_clause: CaptureBy::Ref,\n+            body,\n+            fn_decl_span,\n+            ..\n+        }) = arg.kind\n+        && let closure_body = cx.tcx.hir().body(body)\n+        && let [param] = closure_body.params\n+        && let PatKind::Wild = param.pat.kind\n+    {\n+        // span the area of the closure capture and warn that the\n+        // original error will be thrown away\n+        span_lint_and_help(\n+            cx,\n+            MAP_ERR_IGNORE,\n+            fn_decl_span,\n+            \"`map_err(|_|...` wildcard pattern discards the original error\",\n+            None,\n+            \"consider storing the original error as a source in the new error, or silence this warning using an ignored identifier (`.map_err(|_foo| ...`)\",\n+        );\n+    }\n+}"}, {"sha": "a0d190a58aff9a7f10478600f0d8ddab1b3b2840", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 841, "deletions": 16, "changes": 857, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,5 +1,8 @@\n mod bind_instead_of_map;\n+mod bytecount;\n+mod bytes_count_to_len;\n mod bytes_nth;\n+mod case_sensitive_file_extension_comparisons;\n mod chars_cmp;\n mod chars_cmp_with_unwrap;\n mod chars_last_cmp;\n@@ -9,6 +12,7 @@ mod chars_next_cmp_with_unwrap;\n mod clone_on_copy;\n mod clone_on_ref_ptr;\n mod cloned_instead_of_copied;\n+mod collapsible_str_replace;\n mod err_expect;\n mod expect_fun_call;\n mod expect_used;\n@@ -21,6 +25,7 @@ mod filter_next;\n mod flat_map_identity;\n mod flat_map_option;\n mod from_iter_instead_of_collect;\n+mod get_first;\n mod get_last_with_len;\n mod get_unwrap;\n mod implicit_clone;\n@@ -33,55 +38,72 @@ mod iter_count;\n mod iter_next_slice;\n mod iter_nth;\n mod iter_nth_zero;\n+mod iter_on_single_or_empty_collections;\n mod iter_overeager_cloned;\n mod iter_skip_next;\n mod iter_with_drain;\n mod iterator_step_by_zero;\n+mod manual_ok_or;\n mod manual_saturating_arithmetic;\n mod manual_str_repeat;\n+mod map_clone;\n mod map_collect_result_unit;\n+mod map_err_ignore;\n mod map_flatten;\n mod map_identity;\n mod map_unwrap_or;\n+mod mut_mutex_lock;\n mod needless_option_as_deref;\n mod needless_option_take;\n mod no_effect_replace;\n mod obfuscated_if_else;\n mod ok_expect;\n+mod open_options;\n mod option_as_ref_deref;\n mod option_map_or_none;\n mod option_map_unwrap_or;\n mod or_fun_call;\n mod or_then_unwrap;\n+mod path_buf_push_overwrite;\n+mod range_zip_with_len;\n+mod repeat_once;\n mod search_is_some;\n mod single_char_add_str;\n mod single_char_insert_string;\n mod single_char_pattern;\n mod single_char_push_string;\n mod skip_while_next;\n+mod stable_sort_primitive;\n mod str_splitn;\n mod string_extend_chars;\n mod suspicious_map;\n mod suspicious_splitn;\n+mod suspicious_to_owned;\n mod uninit_assumed_init;\n+mod unit_hash;\n mod unnecessary_filter_map;\n mod unnecessary_fold;\n mod unnecessary_iter_cloned;\n mod unnecessary_join;\n mod unnecessary_lazy_eval;\n+mod unnecessary_sort_by;\n mod unnecessary_to_owned;\n mod unwrap_or_else_default;\n mod unwrap_used;\n mod useless_asref;\n mod utils;\n+mod vec_resize_to_zero;\n+mod verbose_file_reads;\n mod wrong_self_convention;\n mod zst_offset;\n \n use bind_instead_of_map::BindInsteadOfMap;\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n-use clippy_utils::ty::{contains_adt_constructor, contains_ty, implements_trait, is_copy, is_type_diagnostic_item};\n-use clippy_utils::{contains_return, get_trait_def_id, iter_input_pats, meets_msrv, msrvs, paths, return_ty};\n+use clippy_utils::ty::{contains_adt_constructor, implements_trait, is_copy, is_type_diagnostic_item};\n+use clippy_utils::{\n+    contains_return, get_trait_def_id, is_trait_method, iter_input_pats, meets_msrv, msrvs, paths, return_ty,\n+};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n@@ -117,6 +139,32 @@ declare_clippy_lint! {\n     \"used `cloned` where `copied` could be used instead\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for consecutive calls to `str::replace` (2 or more)\n+    /// that can be collapsed into a single call.\n+    ///\n+    /// ### Why is this bad?\n+    /// Consecutive `str::replace` calls scan the string multiple times\n+    /// with repetitive code.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let hello = \"hesuo worpd\"\n+    ///     .replace('s', \"l\")\n+    ///     .replace(\"u\", \"l\")\n+    ///     .replace('p', \"l\");\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let hello = \"hesuo worpd\".replace(&['s', 'u', 'p'], \"l\");\n+    /// ```\n+    #[clippy::version = \"1.64.0\"]\n+    pub COLLAPSIBLE_STR_REPLACE,\n+    perf,\n+    \"collapse consecutive calls to str::replace (2 or more) into a single call\"\n+}\n+\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for usage of `_.cloned().<func>()` where call to `.cloned()` can be postponed.\n@@ -173,7 +221,7 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for `.unwrap()` calls on `Option`s and on `Result`s.\n+    /// Checks for `.unwrap()` or `.unwrap_err()` calls on `Result`s and `.unwrap()` call on `Option`s.\n     ///\n     /// ### Why is this bad?\n     /// It is better to handle the `None` or `Err` case,\n@@ -223,7 +271,7 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for `.expect()` calls on `Option`s and `Result`s.\n+    /// Checks for `.expect()` or `.expect_err()` calls on `Result`s and `.expect()` call on `Option`s.\n     ///\n     /// ### Why is this bad?\n     /// Usually it is better to handle the `None` or `Err` case.\n@@ -2006,6 +2054,55 @@ declare_clippy_lint! {\n     \"replace `.iter().count()` with `.len()`\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for the usage of `_.to_owned()`, on a `Cow<'_, _>`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Calling `to_owned()` on a `Cow` creates a clone of the `Cow`\n+    /// itself, without taking ownership of the `Cow` contents (i.e.\n+    /// it's equivalent to calling `Cow::clone`).\n+    /// The similarly named `into_owned` method, on the other hand,\n+    /// clones the `Cow` contents, effectively turning any `Cow::Borrowed`\n+    /// into a `Cow::Owned`.\n+    ///\n+    /// Given the potential ambiguity, consider replacing `to_owned`\n+    /// with `clone` for better readability or, if getting a `Cow::Owned`\n+    /// was the original intent, using `into_owned` instead.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # use std::borrow::Cow;\n+    /// let s = \"Hello world!\";\n+    /// let cow = Cow::Borrowed(s);\n+    ///\n+    /// let data = cow.to_owned();\n+    /// assert!(matches!(data, Cow::Borrowed(_)))\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # use std::borrow::Cow;\n+    /// let s = \"Hello world!\";\n+    /// let cow = Cow::Borrowed(s);\n+    ///\n+    /// let data = cow.clone();\n+    /// assert!(matches!(data, Cow::Borrowed(_)))\n+    /// ```\n+    /// or\n+    /// ```rust\n+    /// # use std::borrow::Cow;\n+    /// let s = \"Hello world!\";\n+    /// let cow = Cow::Borrowed(s);\n+    ///\n+    /// let data = cow.into_owned();\n+    /// assert!(matches!(data, String))\n+    /// ```\n+    #[clippy::version = \"1.65.0\"]\n+    pub SUSPICIOUS_TO_OWNED,\n+    suspicious,\n+    \"calls to `to_owned` on a `Cow<'_, _>` might not do what they are expected\"\n+}\n+\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for calls to [`splitn`]\n@@ -2269,7 +2366,7 @@ declare_clippy_lint! {\n     /// \"1234\".replace(\"12\", \"12\");\n     /// \"1234\".replacen(\"12\", \"12\", 1);\n     /// ```\n-    #[clippy::version = \"1.62.0\"]\n+    #[clippy::version = \"1.63.0\"]\n     pub NO_EFFECT_REPLACE,\n     suspicious,\n     \"replace with no effect\"\n@@ -2304,6 +2401,640 @@ declare_clippy_lint! {\n     more clearly with `if .. else ..`\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    ///\n+    /// Checks for calls to `iter`, `iter_mut` or `into_iter` on collections containing a single item\n+    ///\n+    /// ### Why is this bad?\n+    ///\n+    /// It is simpler to use the once function from the standard library:\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// let a = [123].iter();\n+    /// let b = Some(123).into_iter();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::iter;\n+    /// let a = iter::once(&123);\n+    /// let b = iter::once(123);\n+    /// ```\n+    ///\n+    /// ### Known problems\n+    ///\n+    /// The type of the resulting iterator might become incompatible with its usage\n+    #[clippy::version = \"1.64.0\"]\n+    pub ITER_ON_SINGLE_ITEMS,\n+    nursery,\n+    \"Iterator for array of length 1\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    ///\n+    /// Checks for calls to `iter`, `iter_mut` or `into_iter` on empty collections\n+    ///\n+    /// ### Why is this bad?\n+    ///\n+    /// It is simpler to use the empty function from the standard library:\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// use std::{slice, option};\n+    /// let a: slice::Iter<i32> = [].iter();\n+    /// let f: option::IntoIter<i32> = None.into_iter();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::iter;\n+    /// let a: iter::Empty<i32> = iter::empty();\n+    /// let b: iter::Empty<i32> = iter::empty();\n+    /// ```\n+    ///\n+    /// ### Known problems\n+    ///\n+    /// The type of the resulting iterator might become incompatible with its usage\n+    #[clippy::version = \"1.64.0\"]\n+    pub ITER_ON_EMPTY_COLLECTIONS,\n+    nursery,\n+    \"Iterator for empty array\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for naive byte counts\n+    ///\n+    /// ### Why is this bad?\n+    /// The [`bytecount`](https://crates.io/crates/bytecount)\n+    /// crate has methods to count your bytes faster, especially for large slices.\n+    ///\n+    /// ### Known problems\n+    /// If you have predominantly small slices, the\n+    /// `bytecount::count(..)` method may actually be slower. However, if you can\n+    /// ensure that less than 2\u00b3\u00b2-1 matches arise, the `naive_count_32(..)` can be\n+    /// faster in those cases.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let vec = vec![1_u8];\n+    /// let count = vec.iter().filter(|x| **x == 0u8).count();\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// # let vec = vec![1_u8];\n+    /// let count = bytecount::count(&vec, 0u8);\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub NAIVE_BYTECOUNT,\n+    pedantic,\n+    \"use of naive `<slice>.filter(|&x| x == y).count()` to count byte values\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// It checks for `str::bytes().count()` and suggests replacing it with\n+    /// `str::len()`.\n+    ///\n+    /// ### Why is this bad?\n+    /// `str::bytes().count()` is longer and may not be as performant as using\n+    /// `str::len()`.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// \"hello\".bytes().count();\n+    /// String::from(\"hello\").bytes().count();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// \"hello\".len();\n+    /// String::from(\"hello\").len();\n+    /// ```\n+    #[clippy::version = \"1.62.0\"]\n+    pub BYTES_COUNT_TO_LEN,\n+    complexity,\n+    \"Using `bytes().count()` when `len()` performs the same functionality\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for calls to `ends_with` with possible file extensions\n+    /// and suggests to use a case-insensitive approach instead.\n+    ///\n+    /// ### Why is this bad?\n+    /// `ends_with` is case-sensitive and may not detect files with a valid extension.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// fn is_rust_file(filename: &str) -> bool {\n+    ///     filename.ends_with(\".rs\")\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn is_rust_file(filename: &str) -> bool {\n+    ///     let filename = std::path::Path::new(filename);\n+    ///     filename.extension()\n+    ///         .map_or(false, |ext| ext.eq_ignore_ascii_case(\"rs\"))\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.51.0\"]\n+    pub CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n+    pedantic,\n+    \"Checks for calls to ends_with with case-sensitive file extensions\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for using `x.get(0)` instead of\n+    /// `x.first()`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Using `x.first()` is easier to read and has the same\n+    /// result.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x = vec![2, 3, 5];\n+    /// let first_element = x.get(0);\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// let x = vec![2, 3, 5];\n+    /// let first_element = x.first();\n+    /// ```\n+    #[clippy::version = \"1.63.0\"]\n+    pub GET_FIRST,\n+    style,\n+    \"Using `x.get(0)` when `x.first()` is simpler\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    ///\n+    /// Finds patterns that reimplement `Option::ok_or`.\n+    ///\n+    /// ### Why is this bad?\n+    ///\n+    /// Concise code helps focusing on behavior instead of boilerplate.\n+    ///\n+    /// ### Examples\n+    /// ```rust\n+    /// let foo: Option<i32> = None;\n+    /// foo.map_or(Err(\"error\"), |v| Ok(v));\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// let foo: Option<i32> = None;\n+    /// foo.ok_or(\"error\");\n+    /// ```\n+    #[clippy::version = \"1.49.0\"]\n+    pub MANUAL_OK_OR,\n+    pedantic,\n+    \"finds patterns that can be encoded more concisely with `Option::ok_or`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for usage of `map(|x| x.clone())` or\n+    /// dereferencing closures for `Copy` types, on `Iterator` or `Option`,\n+    /// and suggests `cloned()` or `copied()` instead\n+    ///\n+    /// ### Why is this bad?\n+    /// Readability, this can be written more concisely\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x = vec![42, 43];\n+    /// let y = x.iter();\n+    /// let z = y.map(|i| *i);\n+    /// ```\n+    ///\n+    /// The correct use would be:\n+    ///\n+    /// ```rust\n+    /// let x = vec![42, 43];\n+    /// let y = x.iter();\n+    /// let z = y.cloned();\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MAP_CLONE,\n+    style,\n+    \"using `iterator.map(|x| x.clone())`, or dereferencing closures for `Copy` types\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for instances of `map_err(|_| Some::Enum)`\n+    ///\n+    /// ### Why is this bad?\n+    /// This `map_err` throws away the original error rather than allowing the enum to contain and report the cause of the error\n+    ///\n+    /// ### Example\n+    /// Before:\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// #[derive(Debug)]\n+    /// enum Error {\n+    ///     Indivisible,\n+    ///     Remainder(u8),\n+    /// }\n+    ///\n+    /// impl fmt::Display for Error {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         match self {\n+    ///             Error::Indivisible => write!(f, \"could not divide input by three\"),\n+    ///             Error::Remainder(remainder) => write!(\n+    ///                 f,\n+    ///                 \"input is not divisible by three, remainder = {}\",\n+    ///                 remainder\n+    ///             ),\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// impl std::error::Error for Error {}\n+    ///\n+    /// fn divisible_by_3(input: &str) -> Result<(), Error> {\n+    ///     input\n+    ///         .parse::<i32>()\n+    ///         .map_err(|_| Error::Indivisible)\n+    ///         .map(|v| v % 3)\n+    ///         .and_then(|remainder| {\n+    ///             if remainder == 0 {\n+    ///                 Ok(())\n+    ///             } else {\n+    ///                 Err(Error::Remainder(remainder as u8))\n+    ///             }\n+    ///         })\n+    /// }\n+    ///  ```\n+    ///\n+    ///  After:\n+    ///  ```rust\n+    /// use std::{fmt, num::ParseIntError};\n+    ///\n+    /// #[derive(Debug)]\n+    /// enum Error {\n+    ///     Indivisible(ParseIntError),\n+    ///     Remainder(u8),\n+    /// }\n+    ///\n+    /// impl fmt::Display for Error {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         match self {\n+    ///             Error::Indivisible(_) => write!(f, \"could not divide input by three\"),\n+    ///             Error::Remainder(remainder) => write!(\n+    ///                 f,\n+    ///                 \"input is not divisible by three, remainder = {}\",\n+    ///                 remainder\n+    ///             ),\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// impl std::error::Error for Error {\n+    ///     fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n+    ///         match self {\n+    ///             Error::Indivisible(source) => Some(source),\n+    ///             _ => None,\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// fn divisible_by_3(input: &str) -> Result<(), Error> {\n+    ///     input\n+    ///         .parse::<i32>()\n+    ///         .map_err(Error::Indivisible)\n+    ///         .map(|v| v % 3)\n+    ///         .and_then(|remainder| {\n+    ///             if remainder == 0 {\n+    ///                 Ok(())\n+    ///             } else {\n+    ///                 Err(Error::Remainder(remainder as u8))\n+    ///             }\n+    ///         })\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.48.0\"]\n+    pub MAP_ERR_IGNORE,\n+    restriction,\n+    \"`map_err` should not ignore the original error\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `&mut Mutex::lock` calls\n+    ///\n+    /// ### Why is this bad?\n+    /// `Mutex::lock` is less efficient than\n+    /// calling `Mutex::get_mut`. In addition you also have a statically\n+    /// guarantee that the mutex isn't locked, instead of just a runtime\n+    /// guarantee.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// use std::sync::{Arc, Mutex};\n+    ///\n+    /// let mut value_rc = Arc::new(Mutex::new(42_u8));\n+    /// let value_mutex = Arc::get_mut(&mut value_rc).unwrap();\n+    ///\n+    /// let mut value = value_mutex.lock().unwrap();\n+    /// *value += 1;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::sync::{Arc, Mutex};\n+    ///\n+    /// let mut value_rc = Arc::new(Mutex::new(42_u8));\n+    /// let value_mutex = Arc::get_mut(&mut value_rc).unwrap();\n+    ///\n+    /// let value = value_mutex.get_mut().unwrap();\n+    /// *value += 1;\n+    /// ```\n+    #[clippy::version = \"1.49.0\"]\n+    pub MUT_MUTEX_LOCK,\n+    style,\n+    \"`&mut Mutex::lock` does unnecessary locking\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for duplicate open options as well as combinations\n+    /// that make no sense.\n+    ///\n+    /// ### Why is this bad?\n+    /// In the best case, the code will be harder to read than\n+    /// necessary. I don't know the worst case.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// use std::fs::OpenOptions;\n+    ///\n+    /// OpenOptions::new().read(true).truncate(true);\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub NONSENSICAL_OPEN_OPTIONS,\n+    correctness,\n+    \"nonsensical combination of options for opening a file\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    ///* Checks for [push](https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.push)\n+    /// calls on `PathBuf` that can cause overwrites.\n+    ///\n+    /// ### Why is this bad?\n+    /// Calling `push` with a root path at the start can overwrite the\n+    /// previous defined path.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// use std::path::PathBuf;\n+    ///\n+    /// let mut x = PathBuf::from(\"/foo\");\n+    /// x.push(\"/bar\");\n+    /// assert_eq!(x, PathBuf::from(\"/bar\"));\n+    /// ```\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// use std::path::PathBuf;\n+    ///\n+    /// let mut x = PathBuf::from(\"/foo\");\n+    /// x.push(\"bar\");\n+    /// assert_eq!(x, PathBuf::from(\"/foo/bar\"));\n+    /// ```\n+    #[clippy::version = \"1.36.0\"]\n+    pub PATH_BUF_PUSH_OVERWRITE,\n+    nursery,\n+    \"calling `push` with file system root on `PathBuf` can overwrite it\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for zipping a collection with the range of\n+    /// `0.._.len()`.\n+    ///\n+    /// ### Why is this bad?\n+    /// The code is better expressed with `.enumerate()`.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let x = vec![1];\n+    /// let _ = x.iter().zip(0..x.len());\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// # let x = vec![1];\n+    /// let _ = x.iter().enumerate();\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub RANGE_ZIP_WITH_LEN,\n+    complexity,\n+    \"zipping iterator with a range when `enumerate()` would do\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for usage of `.repeat(1)` and suggest the following method for each types.\n+    /// - `.to_string()` for `str`\n+    /// - `.clone()` for `String`\n+    /// - `.to_vec()` for `slice`\n+    ///\n+    /// The lint will evaluate constant expressions and values as arguments of `.repeat(..)` and emit a message if\n+    /// they are equivalent to `1`. (Related discussion in [rust-clippy#7306](https://github.com/rust-lang/rust-clippy/issues/7306))\n+    ///\n+    /// ### Why is this bad?\n+    /// For example, `String.repeat(1)` is equivalent to `.clone()`. If cloning\n+    /// the string is the intention behind this, `clone()` should be used.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// fn main() {\n+    ///     let x = String::from(\"hello world\").repeat(1);\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn main() {\n+    ///     let x = String::from(\"hello world\").clone();\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.47.0\"]\n+    pub REPEAT_ONCE,\n+    complexity,\n+    \"using `.repeat(1)` instead of `String.clone()`, `str.to_string()` or `slice.to_vec()` \"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// When sorting primitive values (integers, bools, chars, as well\n+    /// as arrays, slices, and tuples of such items), it is typically better to\n+    /// use an unstable sort than a stable sort.\n+    ///\n+    /// ### Why is this bad?\n+    /// Typically, using a stable sort consumes more memory and cpu cycles.\n+    /// Because values which compare equal are identical, preserving their\n+    /// relative order (the guarantee that a stable sort provides) means\n+    /// nothing, while the extra costs still apply.\n+    ///\n+    /// ### Known problems\n+    ///\n+    /// As pointed out in\n+    /// [issue #8241](https://github.com/rust-lang/rust-clippy/issues/8241),\n+    /// a stable sort can instead be significantly faster for certain scenarios\n+    /// (eg. when a sorted vector is extended with new data and resorted).\n+    ///\n+    /// For more information and benchmarking results, please refer to the\n+    /// issue linked above.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let mut vec = vec![2, 1, 3];\n+    /// vec.sort();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let mut vec = vec![2, 1, 3];\n+    /// vec.sort_unstable();\n+    /// ```\n+    #[clippy::version = \"1.47.0\"]\n+    pub STABLE_SORT_PRIMITIVE,\n+    pedantic,\n+    \"use of sort() when sort_unstable() is equivalent\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Detects `().hash(_)`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Hashing a unit value doesn't do anything as the implementation of `Hash` for `()` is a no-op.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # use std::hash::Hash;\n+    /// # use std::collections::hash_map::DefaultHasher;\n+    /// # enum Foo { Empty, WithValue(u8) }\n+    /// # use Foo::*;\n+    /// # let mut state = DefaultHasher::new();\n+    /// # let my_enum = Foo::Empty;\n+    /// match my_enum {\n+    /// \tEmpty => ().hash(&mut state),\n+    /// \tWithValue(x) => x.hash(&mut state),\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # use std::hash::Hash;\n+    /// # use std::collections::hash_map::DefaultHasher;\n+    /// # enum Foo { Empty, WithValue(u8) }\n+    /// # use Foo::*;\n+    /// # let mut state = DefaultHasher::new();\n+    /// # let my_enum = Foo::Empty;\n+    /// match my_enum {\n+    /// \tEmpty => 0_u8.hash(&mut state),\n+    /// \tWithValue(x) => x.hash(&mut state),\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.58.0\"]\n+    pub UNIT_HASH,\n+    correctness,\n+    \"hashing a unit value, which does nothing\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Detects uses of `Vec::sort_by` passing in a closure\n+    /// which compares the two arguments, either directly or indirectly.\n+    ///\n+    /// ### Why is this bad?\n+    /// It is more clear to use `Vec::sort_by_key` (or `Vec::sort` if\n+    /// possible) than to use `Vec::sort_by` and a more complicated\n+    /// closure.\n+    ///\n+    /// ### Known problems\n+    /// If the suggested `Vec::sort_by_key` uses Reverse and it isn't already\n+    /// imported by a use statement, then it will need to be added manually.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # struct A;\n+    /// # impl A { fn foo(&self) {} }\n+    /// # let mut vec: Vec<A> = Vec::new();\n+    /// vec.sort_by(|a, b| a.foo().cmp(&b.foo()));\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # struct A;\n+    /// # impl A { fn foo(&self) {} }\n+    /// # let mut vec: Vec<A> = Vec::new();\n+    /// vec.sort_by_key(|a| a.foo());\n+    /// ```\n+    #[clippy::version = \"1.46.0\"]\n+    pub UNNECESSARY_SORT_BY,\n+    complexity,\n+    \"Use of `Vec::sort_by` when `Vec::sort_by_key` or `Vec::sort` would be clearer\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Finds occurrences of `Vec::resize(0, an_int)`\n+    ///\n+    /// ### Why is this bad?\n+    /// This is probably an argument inversion mistake.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// vec!(1, 2, 3, 4, 5).resize(0, 5)\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// vec!(1, 2, 3, 4, 5).clear()\n+    /// ```\n+    #[clippy::version = \"1.46.0\"]\n+    pub VEC_RESIZE_TO_ZERO,\n+    correctness,\n+    \"emptying a vector with `resize(0, an_int)` instead of `clear()` is probably an argument inversion mistake\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for use of File::read_to_end and File::read_to_string.\n+    ///\n+    /// ### Why is this bad?\n+    /// `fs::{read, read_to_string}` provide the same functionality when `buf` is empty with fewer imports and no intermediate values.\n+    /// See also: [fs::read docs](https://doc.rust-lang.org/std/fs/fn.read.html), [fs::read_to_string docs](https://doc.rust-lang.org/std/fs/fn.read_to_string.html)\n+    ///\n+    /// ### Example\n+    /// ```rust,no_run\n+    /// # use std::io::Read;\n+    /// # use std::fs::File;\n+    /// let mut f = File::open(\"foo.txt\").unwrap();\n+    /// let mut bytes = Vec::new();\n+    /// f.read_to_end(&mut bytes).unwrap();\n+    /// ```\n+    /// Can be written more concisely as\n+    /// ```rust,no_run\n+    /// # use std::fs;\n+    /// let mut bytes = fs::read(\"foo.txt\").unwrap();\n+    /// ```\n+    #[clippy::version = \"1.44.0\"]\n+    pub VERBOSE_FILE_READS,\n+    restriction,\n+    \"use of `File::read_to_end` or `File::read_to_string`\"\n+}\n+\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Option<RustcVersion>,\n@@ -2347,6 +3078,7 @@ impl_lint_pass!(Methods => [\n     CLONE_ON_COPY,\n     CLONE_ON_REF_PTR,\n     CLONE_DOUBLE_REF,\n+    COLLAPSIBLE_STR_REPLACE,\n     ITER_OVEREAGER_CLONED,\n     CLONED_INSTEAD_OF_COPIED,\n     FLAT_MAP_OPTION,\n@@ -2393,6 +3125,7 @@ impl_lint_pass!(Methods => [\n     FROM_ITER_INSTEAD_OF_COLLECT,\n     INSPECT_FOR_EACH,\n     IMPLICIT_CLONE,\n+    SUSPICIOUS_TO_OWNED,\n     SUSPICIOUS_SPLITN,\n     MANUAL_STR_REPEAT,\n     EXTEND_WITH_DRAIN,\n@@ -2406,6 +3139,25 @@ impl_lint_pass!(Methods => [\n     NEEDLESS_OPTION_TAKE,\n     NO_EFFECT_REPLACE,\n     OBFUSCATED_IF_ELSE,\n+    ITER_ON_SINGLE_ITEMS,\n+    ITER_ON_EMPTY_COLLECTIONS,\n+    NAIVE_BYTECOUNT,\n+    BYTES_COUNT_TO_LEN,\n+    CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n+    GET_FIRST,\n+    MANUAL_OK_OR,\n+    MAP_CLONE,\n+    MAP_ERR_IGNORE,\n+    MUT_MUTEX_LOCK,\n+    NONSENSICAL_OPEN_OPTIONS,\n+    PATH_BUF_PUSH_OVERWRITE,\n+    RANGE_ZIP_WITH_LEN,\n+    REPEAT_ONCE,\n+    STABLE_SORT_PRIMITIVE,\n+    UNIT_HASH,\n+    UNNECESSARY_SORT_BY,\n+    VEC_RESIZE_TO_ZERO,\n+    VERBOSE_FILE_READS,\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -2541,7 +3293,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                 if contains_adt_constructor(ret_ty, self_adt) {\n                     return;\n                 }\n-            } else if contains_ty(ret_ty, self_ty) {\n+            } else if ret_ty.contains(self_ty) {\n                 return;\n             }\n \n@@ -2559,7 +3311,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                             if contains_adt_constructor(assoc_ty, self_adt) {\n                                 return;\n                             }\n-                        } else if contains_ty(assoc_ty, self_ty) {\n+                        } else if assoc_ty.contains(self_ty) {\n                             return;\n                         }\n                     }\n@@ -2608,7 +3360,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             if let TraitItemKind::Fn(_, _) = item.kind;\n             let ret_ty = return_ty(cx, item.hir_id());\n             let self_ty = TraitRef::identity(cx.tcx, item.def_id.to_def_id()).self_ty().skip_binder();\n-            if !contains_ty(ret_ty, self_ty);\n+            if !ret_ty.contains(self_ty);\n \n             then {\n                 span_lint(\n@@ -2660,22 +3412,30 @@ impl Methods {\n                     },\n                     _ => {},\n                 },\n-                (\"count\", []) => match method_call(recv) {\n+                (\"count\", []) if is_trait_method(cx, expr, sym::Iterator) => match method_call(recv) {\n                     Some((\"cloned\", [recv2], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, true, false),\n                     Some((name2 @ (\"into_iter\" | \"iter\" | \"iter_mut\"), [recv2], _)) => {\n                         iter_count::check(cx, expr, recv2, name2);\n                     },\n                     Some((\"map\", [_, arg], _)) => suspicious_map::check(cx, expr, recv, arg),\n+                    Some((\"filter\", [recv2, arg], _)) => bytecount::check(cx, expr, recv2, arg),\n+                    Some((\"bytes\", [recv2], _)) => bytes_count_to_len::check(cx, expr, recv, recv2),\n                     _ => {},\n                 },\n                 (\"drain\", [arg]) => {\n                     iter_with_drain::check(cx, expr, recv, span, arg);\n                 },\n+                (\"ends_with\", [arg]) => {\n+                    if let ExprKind::MethodCall(_, _, span) = expr.kind {\n+                        case_sensitive_file_extension_comparisons::check(cx, expr, span, recv, arg);\n+                    }\n+                },\n                 (\"expect\", [_]) => match method_call(recv) {\n                     Some((\"ok\", [recv], _)) => ok_expect::check(cx, expr, recv),\n                     Some((\"err\", [recv], err_span)) => err_expect::check(cx, expr, recv, self.msrv, span, err_span),\n-                    _ => expect_used::check(cx, expr, recv, self.allow_expect_in_tests),\n+                    _ => expect_used::check(cx, expr, recv, false, self.allow_expect_in_tests),\n                 },\n+                (\"expect_err\", [_]) => expect_used::check(cx, expr, recv, true, self.allow_expect_in_tests),\n                 (\"extend\", [arg]) => {\n                     string_extend_chars::check(cx, expr, recv, arg);\n                     extend_with_drain::check(cx, expr, recv, arg);\n@@ -2702,12 +3462,21 @@ impl Methods {\n                         inspect_for_each::check(cx, expr, span2);\n                     }\n                 },\n-                (\"get\", [arg]) => get_last_with_len::check(cx, expr, recv, arg),\n+                (\"get\", [arg]) => {\n+                    get_first::check(cx, expr, recv, arg);\n+                    get_last_with_len::check(cx, expr, recv, arg);\n+                },\n                 (\"get_or_insert_with\", [arg]) => unnecessary_lazy_eval::check(cx, expr, recv, arg, \"get_or_insert\"),\n+                (\"hash\", [arg]) => {\n+                    unit_hash::check(cx, expr, recv, arg);\n+                },\n                 (\"is_file\", []) => filetype_is_file::check(cx, expr, recv),\n                 (\"is_digit\", [radix]) => is_digit_ascii_radix::check(cx, expr, recv, radix, self.msrv),\n                 (\"is_none\", []) => check_is_some_is_none(cx, expr, recv, false),\n                 (\"is_some\", []) => check_is_some_is_none(cx, expr, recv, true),\n+                (\"iter\" | \"iter_mut\" | \"into_iter\", []) => {\n+                    iter_on_single_or_empty_collections::check(cx, expr, name, recv);\n+                },\n                 (\"join\", [join_arg]) => {\n                     if let Some((\"collect\", _, span)) = method_call(recv) {\n                         unnecessary_join::check(cx, expr, recv, join_arg, span);\n@@ -2720,7 +3489,15 @@ impl Methods {\n                         }\n                     }\n                 },\n+                (\"lock\", []) => {\n+                    mut_mutex_lock::check(cx, expr, recv, span);\n+                },\n                 (name @ (\"map\" | \"map_err\"), [m_arg]) => {\n+                    if name == \"map\" {\n+                        map_clone::check(cx, expr, recv, m_arg, self.msrv);\n+                    } else {\n+                        map_err_ignore::check(cx, expr, m_arg);\n+                    }\n                     if let Some((name, [recv2, args @ ..], span2)) = method_call(recv) {\n                         match (name, args) {\n                             (\"as_mut\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, true, self.msrv),\n@@ -2736,7 +3513,10 @@ impl Methods {\n                     }\n                     map_identity::check(cx, expr, recv, m_arg, name, span);\n                 },\n-                (\"map_or\", [def, map]) => option_map_or_none::check(cx, expr, recv, def, map),\n+                (\"map_or\", [def, map]) => {\n+                    option_map_or_none::check(cx, expr, recv, def, map);\n+                    manual_ok_or::check(cx, expr, recv, def, map);\n+                },\n                 (\"next\", []) => {\n                     if let Some((name2, [recv2, args2 @ ..], _)) = method_call(recv) {\n                         match (name2, args2) {\n@@ -2758,11 +3538,46 @@ impl Methods {\n                     _ => iter_nth_zero::check(cx, expr, recv, n_arg),\n                 },\n                 (\"ok_or_else\", [arg]) => unnecessary_lazy_eval::check(cx, expr, recv, arg, \"ok_or\"),\n+                (\"open\", [_]) => {\n+                    open_options::check(cx, expr, recv);\n+                },\n                 (\"or_else\", [arg]) => {\n                     if !bind_instead_of_map::ResultOrElseErrInfo::check(cx, expr, recv, arg) {\n                         unnecessary_lazy_eval::check(cx, expr, recv, arg, \"or\");\n                     }\n                 },\n+                (\"push\", [arg]) => {\n+                    path_buf_push_overwrite::check(cx, expr, arg);\n+                },\n+                (\"read_to_end\", [_]) => {\n+                    verbose_file_reads::check(cx, expr, recv, verbose_file_reads::READ_TO_END_MSG);\n+                },\n+                (\"read_to_string\", [_]) => {\n+                    verbose_file_reads::check(cx, expr, recv, verbose_file_reads::READ_TO_STRING_MSG);\n+                },\n+                (\"repeat\", [arg]) => {\n+                    repeat_once::check(cx, expr, recv, arg);\n+                },\n+                (name @ (\"replace\" | \"replacen\"), [arg1, arg2] | [arg1, arg2, _]) => {\n+                    no_effect_replace::check(cx, expr, arg1, arg2);\n+\n+                    // Check for repeated `str::replace` calls to perform `collapsible_str_replace` lint\n+                    if name == \"replace\" && let Some((\"replace\", ..)) = method_call(recv) {\n+                        collapsible_str_replace::check(cx, expr, arg1, arg2);\n+                    }\n+                },\n+                (\"resize\", [count_arg, default_arg]) => {\n+                    vec_resize_to_zero::check(cx, expr, count_arg, default_arg, span);\n+                },\n+                (\"sort\", []) => {\n+                    stable_sort_primitive::check(cx, expr, recv);\n+                },\n+                (\"sort_by\", [arg]) => {\n+                    unnecessary_sort_by::check(cx, expr, recv, arg, false);\n+                },\n+                (\"sort_unstable_by\", [arg]) => {\n+                    unnecessary_sort_by::check(cx, expr, recv, arg, true);\n+                },\n                 (\"splitn\" | \"rsplitn\", [count_arg, pat_arg]) => {\n                     if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n                         suspicious_splitn::check(cx, name, expr, recv, count);\n@@ -2789,7 +3604,12 @@ impl Methods {\n                     }\n                     unnecessary_lazy_eval::check(cx, expr, recv, arg, \"then_some\");\n                 },\n-                (\"to_os_string\" | \"to_owned\" | \"to_path_buf\" | \"to_vec\", []) => {\n+                (\"to_owned\", []) => {\n+                    if !suspicious_to_owned::check(cx, expr, recv) {\n+                        implicit_clone::check(cx, name, expr, recv);\n+                    }\n+                },\n+                (\"to_os_string\" | \"to_path_buf\" | \"to_vec\", []) => {\n                     implicit_clone::check(cx, name, expr, recv);\n                 },\n                 (\"unwrap\", []) => {\n@@ -2805,8 +3625,9 @@ impl Methods {\n                         },\n                         _ => {},\n                     }\n-                    unwrap_used::check(cx, expr, recv, self.allow_unwrap_in_tests);\n+                    unwrap_used::check(cx, expr, recv, false, self.allow_unwrap_in_tests);\n                 },\n+                (\"unwrap_err\", []) => unwrap_used::check(cx, expr, recv, true, self.allow_unwrap_in_tests),\n                 (\"unwrap_or\", [u_arg]) => match method_call(recv) {\n                     Some((arith @ (\"checked_add\" | \"checked_sub\" | \"checked_mul\"), [lhs, rhs], _)) => {\n                         manual_saturating_arithmetic::check(cx, expr, lhs, rhs, u_arg, &arith[\"checked_\".len()..]);\n@@ -2827,8 +3648,12 @@ impl Methods {\n                         unnecessary_lazy_eval::check(cx, expr, recv, u_arg, \"unwrap_or\");\n                     },\n                 },\n-                (\"replace\" | \"replacen\", [arg1, arg2] | [arg1, arg2, _]) => {\n-                    no_effect_replace::check(cx, expr, arg1, arg2);\n+                (\"zip\", [arg]) => {\n+                    if let ExprKind::MethodCall(name, [iter_recv], _) = recv.kind\n+                        && name.ident.name == sym::iter\n+                    {\n+                        range_zip_with_len::check(cx, expr, iter_recv, arg);\n+                    }\n                 },\n                 _ => {},\n             }"}, {"sha": "bd8458a222e2922e1d68c3d26e9b37fc0f084d20", "filename": "src/tools/clippy/clippy_lints/src/methods/mut_mutex_lock.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmut_mutex_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmut_mutex_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmut_mutex_lock.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,30 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, Mutability};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::{sym, Span};\n+\n+use super::MUT_MUTEX_LOCK;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, ex: &'tcx Expr<'tcx>, recv: &'tcx Expr<'tcx>, name_span: Span) {\n+    if_chain! {\n+        if let ty::Ref(_, _, Mutability::Mut) = cx.typeck_results().expr_ty(recv).kind();\n+        if let Some(method_id) = cx.typeck_results().type_dependent_def_id(ex.hir_id);\n+        if let Some(impl_id) = cx.tcx.impl_of_method(method_id);\n+        if is_type_diagnostic_item(cx, cx.tcx.type_of(impl_id), sym::Mutex);\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                MUT_MUTEX_LOCK,\n+                name_span,\n+                \"calling `&mut Mutex::lock` unnecessarily locks an exclusive (mutable) reference\",\n+                \"change this to\",\n+                \"get_mut\".to_owned(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+    }\n+}"}, {"sha": "c3112823e3469eeb576f601f8ed71f31a19b5dd9", "filename": "src/tools/clippy/clippy_lints/src/methods/open_options.rs", "status": "renamed", "additions": 10, "deletions": 34, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fopen_options.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -3,43 +3,19 @@ use clippy_utils::paths;\n use clippy_utils::ty::match_type;\n use rustc_ast::ast::LitKind;\n use rustc_hir::{Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_lint::LateContext;\n use rustc_span::source_map::{Span, Spanned};\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for duplicate open options as well as combinations\n-    /// that make no sense.\n-    ///\n-    /// ### Why is this bad?\n-    /// In the best case, the code will be harder to read than\n-    /// necessary. I don't know the worst case.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// use std::fs::OpenOptions;\n-    ///\n-    /// OpenOptions::new().read(true).truncate(true);\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub NONSENSICAL_OPEN_OPTIONS,\n-    correctness,\n-    \"nonsensical combination of options for opening a file\"\n-}\n-\n-declare_lint_pass!(OpenOptions => [NONSENSICAL_OPEN_OPTIONS]);\n+use super::NONSENSICAL_OPEN_OPTIONS;\n \n-impl<'tcx> LateLintPass<'tcx> for OpenOptions {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if let ExprKind::MethodCall(path, [self_arg, ..], _) = &e.kind {\n-            let obj_ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n-            if path.ident.name == sym!(open) && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n-                let mut options = Vec::new();\n-                get_open_options(cx, self_arg, &mut options);\n-                check_open_options(cx, &options, e.span);\n-            }\n-        }\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, recv: &'tcx Expr<'_>) {\n+    if let Some(method_id) = cx.typeck_results().type_dependent_def_id(e.hir_id)\n+        && let Some(impl_id) = cx.tcx.impl_of_method(method_id)\n+        && match_type(cx, cx.tcx.type_of(impl_id), &paths::OPEN_OPTIONS)\n+    {\n+        let mut options = Vec::new();\n+        get_open_options(cx, recv, &mut options);\n+        check_open_options(cx, &options, e.span);\n     }\n }\n ", "previous_filename": "src/tools/clippy/clippy_lints/src/open_options.rs"}, {"sha": "3c4002a3aef99b86fc175c86b343c9530cfac29e", "filename": "src/tools/clippy/clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -78,7 +78,7 @@ pub(super) fn check<'tcx>(\n                     map_span,\n                     String::from(if unwrap_snippet_none { \"and_then\" } else { \"map_or\" }),\n                 ),\n-                (expr.span.with_lo(unwrap_recv.span.hi()), String::from(\"\")),\n+                (expr.span.with_lo(unwrap_recv.span.hi()), String::new()),\n             ];\n \n             if !unwrap_snippet_none {"}, {"sha": "0cc28c0dcb3d044c7b8a0d0ca86cf637fabbe306", "filename": "src/tools/clippy/clippy_lints/src/methods/path_buf_push_overwrite.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fpath_buf_push_overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fpath_buf_push_overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fpath_buf_push_overwrite.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,37 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+use std::path::{Component, Path};\n+\n+use super::PATH_BUF_PUSH_OVERWRITE;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arg: &'tcx Expr<'_>) {\n+    if_chain! {\n+        if let Some(method_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        if let Some(impl_id) = cx.tcx.impl_of_method(method_id);\n+        if is_type_diagnostic_item(cx, cx.tcx.type_of(impl_id), sym::PathBuf);\n+        if let ExprKind::Lit(ref lit) = arg.kind;\n+        if let LitKind::Str(ref path_lit, _) = lit.node;\n+        if let pushed_path = Path::new(path_lit.as_str());\n+        if let Some(pushed_path_lit) = pushed_path.to_str();\n+        if pushed_path.has_root();\n+        if let Some(root) = pushed_path.components().next();\n+        if root == Component::RootDir;\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                PATH_BUF_PUSH_OVERWRITE,\n+                lit.span,\n+                \"calling `push` with '/' or '\\\\' (file system root) will overwrite the previous path definition\",\n+                \"try\",\n+                format!(\"\\\"{}\\\"\", pushed_path_lit.trim_start_matches(|c| c == '/' || c == '\\\\')),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}"}, {"sha": "00a2a0d14d1132946ef80749581d3e0e12644ea8", "filename": "src/tools/clippy/clippy_lints/src/methods/range_zip_with_len.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Frange_zip_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Frange_zip_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Frange_zip_with_len.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,34 @@\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::source::snippet;\n+use clippy_utils::{higher, SpanlessEq};\n+use clippy_utils::{is_integer_const, is_trait_method};\n+use if_chain::if_chain;\n+use rustc_hir::{Expr, ExprKind, QPath};\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::RANGE_ZIP_WITH_LEN;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, recv: &'tcx Expr<'_>, zip_arg: &'tcx Expr<'_>) {\n+    if_chain! {\n+        if is_trait_method(cx, expr, sym::Iterator);\n+        // range expression in `.zip()` call: `0..x.len()`\n+        if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::Range::hir(zip_arg);\n+        if is_integer_const(cx, start, 0);\n+        // `.len()` call\n+        if let ExprKind::MethodCall(len_path, [len_recv], _) = end.kind;\n+        if len_path.ident.name == sym::len;\n+        // `.iter()` and `.len()` called on same `Path`\n+        if let ExprKind::Path(QPath::Resolved(_, iter_path)) = recv.kind;\n+        if let ExprKind::Path(QPath::Resolved(_, len_path)) = len_recv.kind;\n+        if SpanlessEq::new(cx).eq_path_segments(iter_path.segments, len_path.segments);\n+        then {\n+            span_lint(cx,\n+                RANGE_ZIP_WITH_LEN,\n+                expr.span,\n+                &format!(\"it is more idiomatic to use `{}.iter().enumerate()`\",\n+                    snippet(cx, recv.span, \"_\"))\n+            );\n+        }\n+    }\n+}"}, {"sha": "0a14f9216ab383f44f197a25820471a84c09f29f", "filename": "src/tools/clippy/clippy_lints/src/methods/repeat_once.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Frepeat_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Frepeat_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Frepeat_once.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,52 @@\n+use clippy_utils::consts::{constant_context, Constant};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::REPEAT_ONCE;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    recv: &'tcx Expr<'_>,\n+    repeat_arg: &'tcx Expr<'_>,\n+) {\n+    if constant_context(cx, cx.typeck_results()).expr(repeat_arg) == Some(Constant::Int(1)) {\n+        let ty = cx.typeck_results().expr_ty(recv).peel_refs();\n+        if ty.is_str() {\n+            span_lint_and_sugg(\n+                cx,\n+                REPEAT_ONCE,\n+                expr.span,\n+                \"calling `repeat(1)` on str\",\n+                \"consider using `.to_string()` instead\",\n+                format!(\"{}.to_string()\", snippet(cx, recv.span, r#\"\"...\"\"#)),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if ty.builtin_index().is_some() {\n+            span_lint_and_sugg(\n+                cx,\n+                REPEAT_ONCE,\n+                expr.span,\n+                \"calling `repeat(1)` on slice\",\n+                \"consider using `.to_vec()` instead\",\n+                format!(\"{}.to_vec()\", snippet(cx, recv.span, r#\"\"...\"\"#)),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if is_type_diagnostic_item(cx, ty, sym::String) {\n+            span_lint_and_sugg(\n+                cx,\n+                REPEAT_ONCE,\n+                expr.span,\n+                \"calling `repeat(1)` on a string literal\",\n+                \"consider using `.clone()` instead\",\n+                format!(\"{}.clone()\", snippet(cx, recv.span, r#\"\"...\"\"#)),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}"}, {"sha": "91951c65bb3095aebbeefb7fb105b35f53c05047", "filename": "src/tools/clippy/clippy_lints/src/methods/stable_sort_primitive.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstable_sort_primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstable_sort_primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstable_sort_primitive.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,31 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::is_slice_of_primitives;\n+use clippy_utils::source::snippet_with_context;\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+\n+use super::STABLE_SORT_PRIMITIVE;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, recv: &'tcx Expr<'_>) {\n+    if let Some(method_id) = cx.typeck_results().type_dependent_def_id(e.hir_id)\n+        && let Some(impl_id) = cx.tcx.impl_of_method(method_id)\n+        && cx.tcx.type_of(impl_id).is_slice()\n+        && let Some(slice_type) = is_slice_of_primitives(cx, recv)\n+    {\n+        span_lint_and_then(\n+            cx,\n+            STABLE_SORT_PRIMITIVE,\n+            e.span,\n+            &format!(\"used `sort` on primitive type `{}`\", slice_type),\n+            |diag| {\n+                let mut app = Applicability::MachineApplicable;\n+                let recv_snip = snippet_with_context(cx, recv.span, e.span.ctxt(), \"..\", &mut app).0;\n+                diag.span_suggestion(e.span, \"try\", format!(\"{}.sort_unstable()\", recv_snip), app);\n+                diag.note(\n+                    \"an unstable sort typically performs faster without any observable difference for this data type\",\n+                );\n+            },\n+        );\n+    }\n+}"}, {"sha": "6b306fbf0085541a3bad26b1ecab72a036a65be1", "filename": "src/tools/clippy/clippy_lints/src/methods/suspicious_to_owned.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsuspicious_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsuspicious_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsuspicious_to_owned.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,36 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_diag_trait_item;\n+use clippy_utils::source::snippet_with_context;\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::sym;\n+\n+use super::SUSPICIOUS_TO_OWNED;\n+\n+pub fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) -> bool {\n+    if_chain! {\n+        if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        if is_diag_trait_item(cx, method_def_id, sym::ToOwned);\n+        let input_type = cx.typeck_results().expr_ty(expr);\n+        if let ty::Adt(adt, _) = cx.typeck_results().expr_ty(expr).kind();\n+        if cx.tcx.is_diagnostic_item(sym::Cow, adt.did());\n+        then {\n+            let mut app = Applicability::MaybeIncorrect;\n+            let recv_snip = snippet_with_context(cx, recv.span, expr.span.ctxt(), \"..\", &mut app).0;\n+            span_lint_and_sugg(\n+                cx,\n+                SUSPICIOUS_TO_OWNED,\n+                expr.span,\n+                &format!(\"this `to_owned` call clones the {0} itself and does not cause the {0} contents to become owned\", input_type),\n+                \"consider using, depending on intent\",\n+                format!(\"{0}.clone()` or `{0}.into_owned()\", recv_snip),\n+                app,\n+            );\n+            return true;\n+        }\n+    }\n+    false\n+}"}, {"sha": "a1c6294737cf87225631efca472c0ed5f03e93cf", "filename": "src/tools/clippy/clippy_lints/src/methods/uninit_assumed_init.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{is_expr_diagnostic_item, ty::is_uninit_value_valid_for_ty};\n+use clippy_utils::{is_path_diagnostic_item, ty::is_uninit_value_valid_for_ty};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n@@ -12,7 +12,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n     if_chain! {\n         if let hir::ExprKind::Call(callee, args) = recv.kind;\n         if args.is_empty();\n-        if is_expr_diagnostic_item(cx, callee, sym::maybe_uninit_uninit);\n+        if is_path_diagnostic_item(cx, callee, sym::maybe_uninit_uninit);\n         if !is_uninit_value_valid_for_ty(cx, cx.typeck_results().expr_ty_adjusted(expr));\n         then {\n             span_lint("}, {"sha": "3c7955bc46981bae4c0d989d3d9c5cbbf5c715ea", "filename": "src/tools/clippy/clippy_lints/src/methods/unit_hash.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funit_hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funit_hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funit_hash.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,29 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::is_trait_method;\n+use clippy_utils::source::snippet;\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::UNIT_HASH;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, recv: &'tcx Expr<'_>, arg: &'tcx Expr<'_>) {\n+    if is_trait_method(cx, expr, sym::Hash) && cx.typeck_results().expr_ty(recv).is_unit() {\n+        span_lint_and_then(\n+            cx,\n+            UNIT_HASH,\n+            expr.span,\n+            \"this call to `hash` on the unit type will do nothing\",\n+            |diag| {\n+                diag.span_suggestion(\n+                    expr.span,\n+                    \"remove the call to `hash` or consider using\",\n+                    format!(\"0_u8.hash({})\", snippet(cx, arg.span, \"..\"),),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                diag.note(\"the implementation of `Hash` for `()` is a no-op\");\n+            },\n+        );\n+    }\n+}"}, {"sha": "1966990bd774f929a37551329aff18832c326c17", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_sort_by.rs", "status": "renamed", "additions": 61, "deletions": 95, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_sort_by.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,51 +1,17 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_trait_method;\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n+use clippy_utils::ty::implements_trait;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Closure, Expr, ExprKind, Mutability, Param, Pat, PatKind, Path, PathSegment, QPath};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_lint::LateContext;\n use rustc_middle::ty::{self, subst::GenericArgKind};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n use rustc_span::symbol::Ident;\n use std::iter;\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Detects uses of `Vec::sort_by` passing in a closure\n-    /// which compares the two arguments, either directly or indirectly.\n-    ///\n-    /// ### Why is this bad?\n-    /// It is more clear to use `Vec::sort_by_key` (or `Vec::sort` if\n-    /// possible) than to use `Vec::sort_by` and a more complicated\n-    /// closure.\n-    ///\n-    /// ### Known problems\n-    /// If the suggested `Vec::sort_by_key` uses Reverse and it isn't already\n-    /// imported by a use statement, then it will need to be added manually.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # struct A;\n-    /// # impl A { fn foo(&self) {} }\n-    /// # let mut vec: Vec<A> = Vec::new();\n-    /// vec.sort_by(|a, b| a.foo().cmp(&b.foo()));\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// # struct A;\n-    /// # impl A { fn foo(&self) {} }\n-    /// # let mut vec: Vec<A> = Vec::new();\n-    /// vec.sort_by_key(|a| a.foo());\n-    /// ```\n-    #[clippy::version = \"1.46.0\"]\n-    pub UNNECESSARY_SORT_BY,\n-    complexity,\n-    \"Use of `Vec::sort_by` when `Vec::sort_by_key` or `Vec::sort` would be clearer\"\n-}\n-\n-declare_lint_pass!(UnnecessarySortBy => [UNNECESSARY_SORT_BY]);\n+use super::UNNECESSARY_SORT_BY;\n \n enum LintTrigger {\n     Sort(SortDetection),\n@@ -54,15 +20,13 @@ enum LintTrigger {\n \n struct SortDetection {\n     vec_name: String,\n-    unstable: bool,\n }\n \n struct SortByKeyDetection {\n     vec_name: String,\n     closure_arg: String,\n     closure_body: String,\n     reverse: bool,\n-    unstable: bool,\n }\n \n /// Detect if the two expressions are mirrored (identical, except one\n@@ -150,20 +114,20 @@ fn mirrored_exprs(a_expr: &Expr<'_>, a_ident: &Ident, b_expr: &Expr<'_>, b_ident\n     }\n }\n \n-fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n+fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, arg: &Expr<'_>) -> Option<LintTrigger> {\n     if_chain! {\n-        if let ExprKind::MethodCall(name_ident, args, _) = &expr.kind;\n-        if let name = name_ident.ident.name.to_ident_string();\n-        if name == \"sort_by\" || name == \"sort_unstable_by\";\n-        if let [vec, Expr { kind: ExprKind::Closure(Closure { body: closure_body_id, .. }), .. }] = args;\n-        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(vec), sym::Vec);\n-        if let closure_body = cx.tcx.hir().body(*closure_body_id);\n+        if let Some(method_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        if let Some(impl_id) = cx.tcx.impl_of_method(method_id);\n+        if cx.tcx.type_of(impl_id).is_slice();\n+        if let ExprKind::Closure(&Closure { body, .. }) = arg.kind;\n+        if let closure_body = cx.tcx.hir().body(body);\n         if let &[\n             Param { pat: Pat { kind: PatKind::Binding(_, _, left_ident, _), .. }, ..},\n             Param { pat: Pat { kind: PatKind::Binding(_, _, right_ident, _), .. }, .. }\n         ] = &closure_body.params;\n-        if let ExprKind::MethodCall(method_path, [ref left_expr, ref right_expr], _) = &closure_body.value.kind;\n+        if let ExprKind::MethodCall(method_path, [left_expr, right_expr], _) = closure_body.value.kind;\n         if method_path.ident.name == sym::cmp;\n+        if is_trait_method(cx, &closure_body.value, sym::Ord);\n         then {\n             let (closure_body, closure_arg, reverse) = if mirrored_exprs(\n                 left_expr,\n@@ -177,19 +141,18 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n             } else {\n                 return None;\n             };\n-            let vec_name = Sugg::hir(cx, &args[0], \"..\").to_string();\n-            let unstable = name == \"sort_unstable_by\";\n+            let vec_name = Sugg::hir(cx, recv, \"..\").to_string();\n \n             if_chain! {\n-            if let ExprKind::Path(QPath::Resolved(_, Path {\n-                segments: [PathSegment { ident: left_name, .. }], ..\n-            })) = &left_expr.kind;\n-            if left_name == left_ident;\n-            if cx.tcx.get_diagnostic_item(sym::Ord).map_or(false, |id| {\n-                implements_trait(cx, cx.typeck_results().expr_ty(left_expr), id, &[])\n-            });\n+                if let ExprKind::Path(QPath::Resolved(_, Path {\n+                    segments: [PathSegment { ident: left_name, .. }], ..\n+                })) = &left_expr.kind;\n+                if left_name == left_ident;\n+                if cx.tcx.get_diagnostic_item(sym::Ord).map_or(false, |id| {\n+                    implements_trait(cx, cx.typeck_results().expr_ty(left_expr), id, &[])\n+                });\n                 then {\n-                    return Some(LintTrigger::Sort(SortDetection { vec_name, unstable }));\n+                    return Some(LintTrigger::Sort(SortDetection { vec_name }));\n                 }\n             }\n \n@@ -199,7 +162,6 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n                     closure_arg,\n                     closure_body,\n                     reverse,\n-                    unstable,\n                 }));\n             }\n         }\n@@ -213,46 +175,50 @@ fn expr_borrows(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     matches!(ty.kind(), ty::Ref(..)) || ty.walk().any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)))\n }\n \n-impl LateLintPass<'_> for UnnecessarySortBy {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        match detect_lint(cx, expr) {\n-            Some(LintTrigger::SortByKey(trigger)) => span_lint_and_sugg(\n-                cx,\n-                UNNECESSARY_SORT_BY,\n-                expr.span,\n-                \"use Vec::sort_by_key here instead\",\n-                \"try\",\n-                format!(\n-                    \"{}.sort{}_by_key(|{}| {})\",\n-                    trigger.vec_name,\n-                    if trigger.unstable { \"_unstable\" } else { \"\" },\n-                    trigger.closure_arg,\n-                    if trigger.reverse {\n-                        format!(\"std::cmp::Reverse({})\", trigger.closure_body)\n-                    } else {\n-                        trigger.closure_body.to_string()\n-                    },\n-                ),\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    recv: &'tcx Expr<'_>,\n+    arg: &'tcx Expr<'_>,\n+    is_unstable: bool,\n+) {\n+    match detect_lint(cx, expr, recv, arg) {\n+        Some(LintTrigger::SortByKey(trigger)) => span_lint_and_sugg(\n+            cx,\n+            UNNECESSARY_SORT_BY,\n+            expr.span,\n+            \"use Vec::sort_by_key here instead\",\n+            \"try\",\n+            format!(\n+                \"{}.sort{}_by_key(|{}| {})\",\n+                trigger.vec_name,\n+                if is_unstable { \"_unstable\" } else { \"\" },\n+                trigger.closure_arg,\n                 if trigger.reverse {\n-                    Applicability::MaybeIncorrect\n+                    format!(\"std::cmp::Reverse({})\", trigger.closure_body)\n                 } else {\n-                    Applicability::MachineApplicable\n+                    trigger.closure_body.to_string()\n                 },\n             ),\n-            Some(LintTrigger::Sort(trigger)) => span_lint_and_sugg(\n-                cx,\n-                UNNECESSARY_SORT_BY,\n-                expr.span,\n-                \"use Vec::sort here instead\",\n-                \"try\",\n-                format!(\n-                    \"{}.sort{}()\",\n-                    trigger.vec_name,\n-                    if trigger.unstable { \"_unstable\" } else { \"\" },\n-                ),\n-                Applicability::MachineApplicable,\n+            if trigger.reverse {\n+                Applicability::MaybeIncorrect\n+            } else {\n+                Applicability::MachineApplicable\n+            },\n+        ),\n+        Some(LintTrigger::Sort(trigger)) => span_lint_and_sugg(\n+            cx,\n+            UNNECESSARY_SORT_BY,\n+            expr.span,\n+            \"use Vec::sort here instead\",\n+            \"try\",\n+            format!(\n+                \"{}.sort{}()\",\n+                trigger.vec_name,\n+                if is_unstable { \"_unstable\" } else { \"\" },\n             ),\n-            None => {},\n-        }\n+            Applicability::MachineApplicable,\n+        ),\n+        None => {},\n     }\n }", "previous_filename": "src/tools/clippy/clippy_lints/src/unnecessary_sort_by.rs"}, {"sha": "44bf84352943853bddfa26628e7515617a93e14f", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -3,11 +3,10 @@ use super::unnecessary_iter_cloned::{self, is_into_iter};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::{\n-    contains_ty, get_associated_type, get_iterator_item_ty, implements_trait, is_copy, peel_mid_ty_refs,\n+    get_associated_type, get_iterator_item_ty, implements_trait, is_copy, is_type_diagnostic_item, peel_mid_ty_refs,\n };\n-use clippy_utils::{meets_msrv, msrvs};\n-\n use clippy_utils::{fn_def_id, get_parent_expr, is_diag_item_method, is_diag_trait_item};\n+use clippy_utils::{meets_msrv, msrvs};\n use rustc_errors::Applicability;\n use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind};\n use rustc_lint::LateContext;\n@@ -279,7 +278,19 @@ fn check_other_call_arg<'tcx>(\n                 &trait_predicate.trait_ref.substs.iter().skip(1).collect::<Vec<_>>()[..],\n                 call_substs,\n             );\n-            implements_trait(cx, receiver_ty, as_ref_trait_id, &composed_substs)\n+            // if `expr` is a `String` and generic target is [u8], skip\n+            // (https://github.com/rust-lang/rust-clippy/issues/9317).\n+            if let [subst] = composed_substs[..]\n+                && let GenericArgKind::Type(arg_ty) = subst.unpack()\n+                && arg_ty.is_slice()\n+                && let inner_ty = arg_ty.builtin_index().unwrap()\n+                && let ty::Uint(ty::UintTy::U8) = inner_ty.kind()\n+                && let self_ty = cx.typeck_results().expr_ty(expr).peel_refs()\n+                && is_type_diagnostic_item(cx, self_ty, sym::String) {\n+                false\n+            } else {\n+                implements_trait(cx, receiver_ty, as_ref_trait_id, &composed_substs)\n+            }\n         } else {\n             false\n         };\n@@ -292,7 +303,7 @@ fn check_other_call_arg<'tcx>(\n         // (https://github.com/rust-lang/rust-clippy/issues/8507).\n         if (n_refs == 0 && !receiver_ty.is_ref())\n             || trait_predicate.def_id() != as_ref_trait_id\n-            || !contains_ty(fn_sig.output(), input);\n+            || !fn_sig.output().contains(input);\n         if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n         then {\n             span_lint_and_sugg(\n@@ -360,25 +371,15 @@ fn get_input_traits_and_projections<'tcx>(\n ) -> (Vec<TraitPredicate<'tcx>>, Vec<ProjectionPredicate<'tcx>>) {\n     let mut trait_predicates = Vec::new();\n     let mut projection_predicates = Vec::new();\n-    for (predicate, _) in cx.tcx.predicates_of(callee_def_id).predicates.iter() {\n-        // `substs` should have 1 + n elements. The first is the type on the left hand side of an\n-        // `as`. The remaining n are trait parameters.\n-        let is_input_substs = |substs: SubstsRef<'tcx>| {\n-            if_chain! {\n-                if let Some(arg) = substs.iter().next();\n-                if let GenericArgKind::Type(arg_ty) = arg.unpack();\n-                if arg_ty == input;\n-                then { true } else { false }\n-            }\n-        };\n+    for predicate in cx.tcx.param_env(callee_def_id).caller_bounds() {\n         match predicate.kind().skip_binder() {\n             PredicateKind::Trait(trait_predicate) => {\n-                if is_input_substs(trait_predicate.trait_ref.substs) {\n+                if trait_predicate.trait_ref.self_ty() == input {\n                     trait_predicates.push(trait_predicate);\n                 }\n             },\n             PredicateKind::Projection(projection_predicate) => {\n-                if is_input_substs(projection_predicate.projection_ty.substs) {\n+                if projection_predicate.projection_ty.self_ty() == input {\n                     projection_predicates.push(projection_predicate);\n                 }\n             },"}, {"sha": "ee17f2d7889ee9f93b6f619bf0100d982a62ec3e", "filename": "src/tools/clippy/clippy_lints/src/methods/unwrap_used.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -7,18 +7,26 @@ use rustc_span::sym;\n \n use super::{EXPECT_USED, UNWRAP_USED};\n \n-/// lint use of `unwrap()` for `Option`s and `Result`s\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>, allow_unwrap_in_tests: bool) {\n+/// lint use of `unwrap()` or `unwrap_err` for `Result` and `unwrap()` for `Option`.\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    expr: &hir::Expr<'_>,\n+    recv: &hir::Expr<'_>,\n+    is_err: bool,\n+    allow_unwrap_in_tests: bool,\n+) {\n     let obj_ty = cx.typeck_results().expr_ty(recv).peel_refs();\n \n-    let mess = if is_type_diagnostic_item(cx, obj_ty, sym::Option) {\n+    let mess = if is_type_diagnostic_item(cx, obj_ty, sym::Option) && !is_err {\n         Some((UNWRAP_USED, \"an Option\", \"None\", \"\"))\n     } else if is_type_diagnostic_item(cx, obj_ty, sym::Result) {\n-        Some((UNWRAP_USED, \"a Result\", \"Err\", \"an \"))\n+        Some((UNWRAP_USED, \"a Result\", if is_err { \"Ok\" } else { \"Err\" }, \"an \"))\n     } else {\n         None\n     };\n \n+    let method_suffix = if is_err { \"_err\" } else { \"\" };\n+\n     if allow_unwrap_in_tests && is_in_test_function(cx.tcx, expr.hir_id) {\n         return;\n     }\n@@ -27,7 +35,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n         let help = if is_lint_allowed(cx, EXPECT_USED, expr.hir_id) {\n             format!(\n                 \"if you don't want to handle the `{none_value}` case gracefully, consider \\\n-                using `expect()` to provide a better panic message\"\n+                using `expect{method_suffix}()` to provide a better panic message\"\n             )\n         } else {\n             format!(\"if this value is {none_prefix}`{none_value}`, it will panic\")\n@@ -37,7 +45,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n             cx,\n             lint,\n             expr.span,\n-            &format!(\"used `unwrap()` on `{kind}` value\"),\n+            &format!(\"used `unwrap{method_suffix}()` on `{kind}` value\"),\n             None,\n             &help,\n         );"}, {"sha": "02d8364cb2959c17d1471a6c3479e6c26b7c7c4e", "filename": "src/tools/clippy/clippy_lints/src/methods/vec_resize_to_zero.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fvec_resize_to_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fvec_resize_to_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fvec_resize_to_zero.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,45 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use if_chain::if_chain;\n+use rustc_ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::Spanned;\n+use rustc_span::{sym, Span};\n+\n+use super::VEC_RESIZE_TO_ZERO;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    count_arg: &'tcx Expr<'_>,\n+    default_arg: &'tcx Expr<'_>,\n+    name_span: Span,\n+) {\n+    if_chain! {\n+        if let Some(method_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        if let Some(impl_id) = cx.tcx.impl_of_method(method_id);\n+        if is_type_diagnostic_item(cx, cx.tcx.type_of(impl_id), sym::Vec);\n+        if let ExprKind::Lit(Spanned { node: LitKind::Int(0, _), .. }) = count_arg.kind;\n+        if let ExprKind::Lit(Spanned { node: LitKind::Int(..), .. }) = default_arg.kind;\n+        then {\n+            let method_call_span = expr.span.with_lo(name_span.lo());\n+            span_lint_and_then(\n+                cx,\n+                VEC_RESIZE_TO_ZERO,\n+                expr.span,\n+                \"emptying a vector with `resize`\",\n+                |db| {\n+                    db.help(\"the arguments may be inverted...\");\n+                    db.span_suggestion(\n+                        method_call_span,\n+                        \"...or you can empty the vector with\",\n+                        \"clear()\".to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                },\n+            );\n+        }\n+    }\n+}"}, {"sha": "2fe5ae9a9ad8fda3a9c80f8143ac603764d1ad8b", "filename": "src/tools/clippy/clippy_lints/src/methods/verbose_file_reads.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fverbose_file_reads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fverbose_file_reads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fverbose_file_reads.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,28 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::is_trait_method;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use rustc_hir::{Expr, ExprKind, QPath};\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::VERBOSE_FILE_READS;\n+\n+pub(super) const READ_TO_END_MSG: (&str, &str) = (\"use of `File::read_to_end`\", \"consider using `fs::read` instead\");\n+pub(super) const READ_TO_STRING_MSG: (&str, &str) = (\n+    \"use of `File::read_to_string`\",\n+    \"consider using `fs::read_to_string` instead\",\n+);\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    recv: &'tcx Expr<'_>,\n+    (msg, help): (&str, &str),\n+) {\n+    if is_trait_method(cx, expr, sym::IoRead)\n+        && matches!(recv.kind, ExprKind::Path(QPath::Resolved(None, _)))\n+        && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty_adjusted(recv).peel_refs(), sym::File)\n+    {\n+        span_lint_and_help(cx, VERBOSE_FILE_READS, expr.span, msg, None, help);\n+    }\n+}"}, {"sha": "7c4ae746e90e91894f9c604dadc53254cb48fb52", "filename": "src/tools/clippy/clippy_lints/src/misc_early/unneeded_wildcard_pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Funneeded_wildcard_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Funneeded_wildcard_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Funneeded_wildcard_pattern.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -46,7 +46,7 @@ fn span_lint(cx: &EarlyContext<'_>, span: Span, only_one: bool) {\n             \"these patterns are unneeded as the `..` pattern can match those elements\"\n         },\n         if only_one { \"remove it\" } else { \"remove them\" },\n-        \"\".to_string(),\n+        String::new(),\n         Applicability::MachineApplicable,\n     );\n }"}, {"sha": "020efeaebf02905dd46bb0b0a7ef0c5fa7f91853", "filename": "src/tools/clippy/clippy_lints/src/mismatching_type_param_order.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmismatching_type_param_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmismatching_type_param_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmismatching_type_param_order.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -40,7 +40,7 @@ declare_clippy_lint! {\n     /// }\n     /// impl<A, B> Foo<A, B> {}\n     /// ```\n-    #[clippy::version = \"1.62.0\"]\n+    #[clippy::version = \"1.63.0\"]\n     pub MISMATCHING_TYPE_PARAM_ORDER,\n     pedantic,\n     \"type parameter positioned inconsistently between type def and impl block\""}, {"sha": "81eb1a085aea9163eca1c0029766d95f99d9d280", "filename": "src/tools/clippy/clippy_lints/src/multi_assignments.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmulti_assignments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmulti_assignments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmulti_assignments.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,65 @@\n+use clippy_utils::diagnostics::span_lint;\n+use rustc_ast::ast::{Expr, ExprKind, Stmt, StmtKind};\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for nested assignments.\n+    ///\n+    /// ### Why is this bad?\n+    /// While this is in most cases already a type mismatch,\n+    /// the result of an assignment being `()` can throw off people coming from languages like python or C,\n+    /// where such assignments return a copy of the assigned value.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    ///# let (a, b);\n+    /// a = b = 42;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    ///# let (a, b);\n+    /// b = 42;\n+    /// a = b;\n+    /// ```\n+    #[clippy::version = \"1.65.0\"]\n+    pub MULTI_ASSIGNMENTS,\n+    suspicious,\n+    \"instead of using `a = b = c;` use `a = c; b = c;`\"\n+}\n+\n+declare_lint_pass!(MultiAssignments => [MULTI_ASSIGNMENTS]);\n+\n+fn strip_paren_blocks(expr: &Expr) -> &Expr {\n+    match &expr.kind {\n+        ExprKind::Paren(e) => strip_paren_blocks(e),\n+        ExprKind::Block(b, _) => {\n+            if let [\n+                Stmt {\n+                    kind: StmtKind::Expr(e),\n+                    ..\n+                },\n+            ] = &b.stmts[..]\n+            {\n+                strip_paren_blocks(e)\n+            } else {\n+                expr\n+            }\n+        },\n+        _ => expr,\n+    }\n+}\n+\n+impl EarlyLintPass for MultiAssignments {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n+        if let ExprKind::Assign(target, source, _) = &expr.kind {\n+            if let ExprKind::Assign(_target, _source, _) = &strip_paren_blocks(target).kind {\n+                span_lint(cx, MULTI_ASSIGNMENTS, expr.span, \"assignments don't nest intuitively\");\n+            };\n+            if let ExprKind::Assign(_target, _source, _) = &strip_paren_blocks(source).kind {\n+                span_lint(cx, MULTI_ASSIGNMENTS, expr.span, \"assignments don't nest intuitively\");\n+            }\n+        };\n+    }\n+}"}, {"sha": "b7f981faa2d42c6491d8745fc9b76168bd4a2fe6", "filename": "src/tools/clippy/clippy_lints/src/mut_mutex_lock.rs", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mutex_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mutex_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mutex_lock.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,70 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, Mutability};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for `&mut Mutex::lock` calls\n-    ///\n-    /// ### Why is this bad?\n-    /// `Mutex::lock` is less efficient than\n-    /// calling `Mutex::get_mut`. In addition you also have a statically\n-    /// guarantee that the mutex isn't locked, instead of just a runtime\n-    /// guarantee.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// use std::sync::{Arc, Mutex};\n-    ///\n-    /// let mut value_rc = Arc::new(Mutex::new(42_u8));\n-    /// let value_mutex = Arc::get_mut(&mut value_rc).unwrap();\n-    ///\n-    /// let mut value = value_mutex.lock().unwrap();\n-    /// *value += 1;\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// use std::sync::{Arc, Mutex};\n-    ///\n-    /// let mut value_rc = Arc::new(Mutex::new(42_u8));\n-    /// let value_mutex = Arc::get_mut(&mut value_rc).unwrap();\n-    ///\n-    /// let value = value_mutex.get_mut().unwrap();\n-    /// *value += 1;\n-    /// ```\n-    #[clippy::version = \"1.49.0\"]\n-    pub MUT_MUTEX_LOCK,\n-    style,\n-    \"`&mut Mutex::lock` does unnecessary locking\"\n-}\n-\n-declare_lint_pass!(MutMutexLock => [MUT_MUTEX_LOCK]);\n-\n-impl<'tcx> LateLintPass<'tcx> for MutMutexLock {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, ex: &'tcx Expr<'tcx>) {\n-        if_chain! {\n-            if let ExprKind::MethodCall(path, [self_arg, ..], _) = &ex.kind;\n-            if path.ident.name == sym!(lock);\n-            let ty = cx.typeck_results().expr_ty(self_arg);\n-            if let ty::Ref(_, inner_ty, Mutability::Mut) = ty.kind();\n-            if is_type_diagnostic_item(cx, *inner_ty, sym::Mutex);\n-            then {\n-                span_lint_and_sugg(\n-                    cx,\n-                    MUT_MUTEX_LOCK,\n-                    path.ident.span,\n-                    \"calling `&mut Mutex::lock` unnecessarily locks an exclusive (mutable) reference\",\n-                    \"change this to\",\n-                    \"get_mut\".to_owned(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "774a3540d1e0c41bef19b00f44b955664de5c743", "filename": "src/tools/clippy/clippy_lints/src/only_used_in_recursion.rs", "status": "modified", "additions": 286, "deletions": 544, "changes": 830, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fonly_used_in_recursion.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,25 +1,16 @@\n-use std::collections::VecDeque;\n-\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::is_lint_allowed;\n-use itertools::{izip, Itertools};\n-use rustc_ast::{walk_list, Label, Mutability};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::{get_expr_use_or_unification_node, get_parent_node, path_def_id, path_to_local, path_to_local_id};\n+use core::cell::Cell;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n-use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n-use rustc_hir::intravisit::{walk_expr, walk_stmt, FnKind, Visitor};\n-use rustc_hir::{\n-    Arm, Block, Body, Closure, Expr, ExprKind, Guard, HirId, ImplicitSelfKind, Let, Local, Pat, PatKind, Path,\n-    PathSegment, QPath, Stmt, StmtKind, TyKind, UnOp,\n-};\n+use rustc_hir::hir_id::HirIdMap;\n+use rustc_hir::{Body, Expr, ExprKind, HirId, ImplItem, ImplItemKind, Node, PatKind, TraitItem, TraitItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_middle::ty::{Ty, TyCtxt, TypeckResults};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::symbol::kw;\n-use rustc_span::symbol::Ident;\n+use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n+use rustc_middle::ty::{self, ConstKind};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::symbol::{kw, Ident};\n use rustc_span::Span;\n \n declare_clippy_lint! {\n@@ -89,572 +80,323 @@ declare_clippy_lint! {\n     /// ```\n     #[clippy::version = \"1.61.0\"]\n     pub ONLY_USED_IN_RECURSION,\n-    nursery,\n+    complexity,\n     \"arguments that is only used in recursion can be removed\"\n }\n-declare_lint_pass!(OnlyUsedInRecursion => [ONLY_USED_IN_RECURSION]);\n-\n-impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n-    fn check_fn(\n-        &mut self,\n-        cx: &LateContext<'tcx>,\n-        kind: FnKind<'tcx>,\n-        decl: &'tcx rustc_hir::FnDecl<'tcx>,\n-        body: &'tcx Body<'tcx>,\n-        _: Span,\n-        id: HirId,\n-    ) {\n-        if is_lint_allowed(cx, ONLY_USED_IN_RECURSION, id) {\n-            return;\n-        }\n-        if let FnKind::ItemFn(ident, ..) | FnKind::Method(ident, ..) = kind {\n-            let def_id = id.owner.to_def_id();\n-            let data = cx.tcx.def_path(def_id).data;\n-\n-            if data.len() > 1 {\n-                match data.get(data.len() - 2) {\n-                    Some(DisambiguatedDefPathData {\n-                        data: DefPathData::Impl,\n-                        disambiguator,\n-                    }) if *disambiguator != 0 => return,\n-                    _ => {},\n-                }\n-            }\n-\n-            let has_self = !matches!(decl.implicit_self, ImplicitSelfKind::None);\n-\n-            let ty_res = cx.typeck_results();\n-            let param_span = body\n-                .params\n-                .iter()\n-                .flat_map(|param| {\n-                    let mut v = Vec::new();\n-                    param.pat.each_binding(|_, hir_id, span, ident| {\n-                        v.push((hir_id, span, ident));\n-                    });\n-                    v\n-                })\n-                .skip(if has_self { 1 } else { 0 })\n-                .filter(|(_, _, ident)| !ident.name.as_str().starts_with('_'))\n-                .collect_vec();\n-\n-            let params = body.params.iter().map(|param| param.pat).collect();\n-\n-            let mut visitor = SideEffectVisit {\n-                graph: FxHashMap::default(),\n-                has_side_effect: FxHashSet::default(),\n-                ret_vars: Vec::new(),\n-                contains_side_effect: false,\n-                break_vars: FxHashMap::default(),\n-                params,\n-                fn_ident: ident,\n-                fn_def_id: def_id,\n-                is_method: matches!(kind, FnKind::Method(..)),\n-                has_self,\n-                ty_res,\n-                tcx: cx.tcx,\n-                visited_exprs: FxHashSet::default(),\n-            };\n-\n-            visitor.visit_expr(&body.value);\n-            let vars = std::mem::take(&mut visitor.ret_vars);\n-            // this would set the return variables to side effect\n-            visitor.add_side_effect(vars);\n-\n-            let mut queue = visitor.has_side_effect.iter().copied().collect::<VecDeque<_>>();\n-\n-            // a simple BFS to check all the variables that have side effect\n-            while let Some(id) = queue.pop_front() {\n-                if let Some(next) = visitor.graph.get(&id) {\n-                    for i in next {\n-                        if !visitor.has_side_effect.contains(i) {\n-                            visitor.has_side_effect.insert(*i);\n-                            queue.push_back(*i);\n-                        }\n-                    }\n-                }\n-            }\n-\n-            for (id, span, ident) in param_span {\n-                // if the variable is not used in recursion, it would be marked as unused\n-                if !visitor.has_side_effect.contains(&id) {\n-                    let mut queue = VecDeque::new();\n-                    let mut visited = FxHashSet::default();\n-\n-                    queue.push_back(id);\n-\n-                    // a simple BFS to check the graph can reach to itself\n-                    // if it can't, it means the variable is never used in recursion\n-                    while let Some(id) = queue.pop_front() {\n-                        if let Some(next) = visitor.graph.get(&id) {\n-                            for i in next {\n-                                if !visited.contains(i) {\n-                                    visited.insert(id);\n-                                    queue.push_back(*i);\n-                                }\n-                            }\n-                        }\n-                    }\n+impl_lint_pass!(OnlyUsedInRecursion => [ONLY_USED_IN_RECURSION]);\n+\n+#[derive(Clone, Copy)]\n+enum FnKind {\n+    Fn,\n+    TraitFn,\n+    // This is a hack. Ideally we would store a `SubstsRef<'tcx>` type here, but a lint pass must be `'static`.\n+    // Substitutions are, however, interned. This allows us to store the pointer as a `usize` when comparing for\n+    // equality.\n+    ImplTraitFn(usize),\n+}\n \n-                    if visited.contains(&id) {\n-                        span_lint_and_sugg(\n-                            cx,\n-                            ONLY_USED_IN_RECURSION,\n-                            span,\n-                            \"parameter is only used in recursion\",\n-                            \"if this is intentional, prefix with an underscore\",\n-                            format!(\"_{}\", ident.name.as_str()),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                }\n-            }\n+struct Param {\n+    /// The function this is a parameter for.\n+    fn_id: DefId,\n+    fn_kind: FnKind,\n+    /// The index of this parameter.\n+    idx: usize,\n+    ident: Ident,\n+    /// Whether this parameter should be linted. Set by `Params::flag_for_linting`.\n+    apply_lint: Cell<bool>,\n+    /// All the uses of this parameter.\n+    uses: Vec<Usage>,\n+}\n+impl Param {\n+    fn new(fn_id: DefId, fn_kind: FnKind, idx: usize, ident: Ident) -> Self {\n+        Self {\n+            fn_id,\n+            fn_kind,\n+            idx,\n+            ident,\n+            apply_lint: Cell::new(true),\n+            uses: Vec::new(),\n         }\n     }\n }\n \n-pub fn is_primitive(ty: Ty<'_>) -> bool {\n-    let ty = ty.peel_refs();\n-    ty.is_primitive() || ty.is_str()\n+#[derive(Debug)]\n+struct Usage {\n+    span: Span,\n+    idx: usize,\n }\n-\n-pub fn is_array(ty: Ty<'_>) -> bool {\n-    let ty = ty.peel_refs();\n-    ty.is_array() || ty.is_array_slice()\n+impl Usage {\n+    fn new(span: Span, idx: usize) -> Self {\n+        Self { span, idx }\n+    }\n }\n \n-/// This builds the graph of side effect.\n-/// The edge `a -> b` means if `a` has side effect, `b` will have side effect.\n-///\n-/// There are some example in following code:\n-/// ```rust, ignore\n-/// let b = 1;\n-/// let a = b; // a -> b\n-/// let (c, d) = (a, b); // c -> b, d -> b\n-///\n-/// let e = if a == 0 { // e -> a\n-///     c // e -> c\n-/// } else {\n-///     d // e -> d\n-/// };\n-/// ```\n-pub struct SideEffectVisit<'tcx> {\n-    graph: FxHashMap<HirId, FxHashSet<HirId>>,\n-    has_side_effect: FxHashSet<HirId>,\n-    // bool for if the variable was dereferenced from mutable reference\n-    ret_vars: Vec<(HirId, bool)>,\n-    contains_side_effect: bool,\n-    // break label\n-    break_vars: FxHashMap<Ident, Vec<(HirId, bool)>>,\n-    params: Vec<&'tcx Pat<'tcx>>,\n-    fn_ident: Ident,\n-    fn_def_id: DefId,\n-    is_method: bool,\n-    has_self: bool,\n-    ty_res: &'tcx TypeckResults<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n-    visited_exprs: FxHashSet<HirId>,\n+/// The parameters being checked by the lint, indexed by both the parameter's `HirId` and the\n+/// `DefId` of the function paired with the parameter's index.\n+#[derive(Default)]\n+struct Params {\n+    params: Vec<Param>,\n+    by_id: HirIdMap<usize>,\n+    by_fn: FxHashMap<(DefId, usize), usize>,\n }\n-\n-impl<'tcx> Visitor<'tcx> for SideEffectVisit<'tcx> {\n-    fn visit_stmt(&mut self, s: &'tcx Stmt<'tcx>) {\n-        match s.kind {\n-            StmtKind::Local(Local {\n-                pat, init: Some(init), ..\n-            }) => {\n-                self.visit_pat_expr(pat, init, false);\n-            },\n-            StmtKind::Item(_) | StmtKind::Expr(_) | StmtKind::Semi(_) => {\n-                walk_stmt(self, s);\n-            },\n-            StmtKind::Local(_) => {},\n-        }\n-        self.ret_vars.clear();\n+impl Params {\n+    fn insert(&mut self, param: Param, id: HirId) {\n+        let idx = self.params.len();\n+        self.by_id.insert(id, idx);\n+        self.by_fn.insert((param.fn_id, param.idx), idx);\n+        self.params.push(param);\n     }\n \n-    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n-        if !self.visited_exprs.insert(ex.hir_id) {\n-            return;\n-        }\n-        match ex.kind {\n-            ExprKind::Array(exprs) | ExprKind::Tup(exprs) => {\n-                self.ret_vars = exprs\n-                    .iter()\n-                    .flat_map(|expr| {\n-                        self.visit_expr(expr);\n-                        std::mem::take(&mut self.ret_vars)\n-                    })\n-                    .collect();\n-            },\n-            ExprKind::Call(callee, args) => self.visit_fn(callee, args),\n-            ExprKind::MethodCall(path, args, _) => self.visit_method_call(path, args),\n-            ExprKind::Binary(_, lhs, rhs) => {\n-                self.visit_bin_op(lhs, rhs);\n-            },\n-            ExprKind::Unary(op, expr) => self.visit_un_op(op, expr),\n-            ExprKind::Let(Let { pat, init, .. }) => self.visit_pat_expr(pat, init, false),\n-            ExprKind::If(bind, then_expr, else_expr) => {\n-                self.visit_if(bind, then_expr, else_expr);\n-            },\n-            ExprKind::Match(expr, arms, _) => self.visit_match(expr, arms),\n-            // since analysing the closure is not easy, just set all variables in it to side-effect\n-            ExprKind::Closure(&Closure { body, .. }) => {\n-                let body = self.tcx.hir().body(body);\n-                self.visit_body(body);\n-                let vars = std::mem::take(&mut self.ret_vars);\n-                self.add_side_effect(vars);\n-            },\n-            ExprKind::Loop(block, label, _, _) | ExprKind::Block(block, label) => {\n-                self.visit_block_label(block, label);\n-            },\n-            ExprKind::Assign(bind, expr, _) => {\n-                self.visit_assign(bind, expr);\n-            },\n-            ExprKind::AssignOp(_, bind, expr) => {\n-                self.visit_assign(bind, expr);\n-                self.visit_bin_op(bind, expr);\n-            },\n-            ExprKind::Field(expr, _) => {\n-                self.visit_expr(expr);\n-                if matches!(self.ty_res.expr_ty(expr).kind(), ty::Ref(_, _, Mutability::Mut)) {\n-                    self.ret_vars.iter_mut().for_each(|(_, b)| *b = true);\n-                }\n-            },\n-            ExprKind::Index(expr, index) => {\n-                self.visit_expr(expr);\n-                let mut vars = std::mem::take(&mut self.ret_vars);\n-                self.visit_expr(index);\n-                self.ret_vars.append(&mut vars);\n-\n-                if !is_array(self.ty_res.expr_ty(expr)) {\n-                    self.add_side_effect(self.ret_vars.clone());\n-                } else if matches!(self.ty_res.expr_ty(expr).kind(), ty::Ref(_, _, Mutability::Mut)) {\n-                    self.ret_vars.iter_mut().for_each(|(_, b)| *b = true);\n-                }\n-            },\n-            ExprKind::Break(dest, Some(expr)) => {\n-                self.visit_expr(expr);\n-                if let Some(label) = dest.label {\n-                    self.break_vars\n-                        .entry(label.ident)\n-                        .or_insert(Vec::new())\n-                        .append(&mut self.ret_vars);\n-                }\n-                self.contains_side_effect = true;\n-            },\n-            ExprKind::Ret(Some(expr)) => {\n-                self.visit_expr(expr);\n-                let vars = std::mem::take(&mut self.ret_vars);\n-                self.add_side_effect(vars);\n-                self.contains_side_effect = true;\n-            },\n-            ExprKind::Break(_, None) | ExprKind::Continue(_) | ExprKind::Ret(None) => {\n-                self.contains_side_effect = true;\n-            },\n-            ExprKind::Struct(_, exprs, expr) => {\n-                let mut ret_vars = exprs\n-                    .iter()\n-                    .flat_map(|field| {\n-                        self.visit_expr(field.expr);\n-                        std::mem::take(&mut self.ret_vars)\n-                    })\n-                    .collect();\n-\n-                walk_list!(self, visit_expr, expr);\n-                self.ret_vars.append(&mut ret_vars);\n-            },\n-            _ => walk_expr(self, ex),\n+    fn remove_by_id(&mut self, id: HirId) {\n+        if let Some(param) = self.get_by_id_mut(id) {\n+            param.uses = Vec::new();\n+            let key = (param.fn_id, param.idx);\n+            self.by_fn.remove(&key);\n+            self.by_id.remove(&id);\n         }\n     }\n \n-    fn visit_path(&mut self, path: &'tcx Path<'tcx>, _id: HirId) {\n-        if let Res::Local(id) = path.res {\n-            self.ret_vars.push((id, false));\n-        }\n+    fn get_by_id_mut(&mut self, id: HirId) -> Option<&mut Param> {\n+        self.params.get_mut(*self.by_id.get(&id)?)\n     }\n-}\n \n-impl<'tcx> SideEffectVisit<'tcx> {\n-    fn visit_assign(&mut self, lhs: &'tcx Expr<'tcx>, rhs: &'tcx Expr<'tcx>) {\n-        // Just support array and tuple unwrapping for now.\n-        //\n-        // ex) `(a, b) = (c, d);`\n-        // The graph would look like this:\n-        //   a -> c\n-        //   b -> d\n-        //\n-        // This would minimize the connection of the side-effect graph.\n-        match (&lhs.kind, &rhs.kind) {\n-            (ExprKind::Array(lhs), ExprKind::Array(rhs)) | (ExprKind::Tup(lhs), ExprKind::Tup(rhs)) => {\n-                // if not, it is a compile error\n-                debug_assert!(lhs.len() == rhs.len());\n-                izip!(*lhs, *rhs).for_each(|(lhs, rhs)| self.visit_assign(lhs, rhs));\n-            },\n-            // in other assigns, we have to connect all each other\n-            // because they can be connected somehow\n-            _ => {\n-                self.visit_expr(lhs);\n-                let lhs_vars = std::mem::take(&mut self.ret_vars);\n-                self.visit_expr(rhs);\n-                let rhs_vars = std::mem::take(&mut self.ret_vars);\n-                self.connect_assign(&lhs_vars, &rhs_vars, false);\n-            },\n-        }\n+    fn get_by_fn(&self, id: DefId, idx: usize) -> Option<&Param> {\n+        self.params.get(*self.by_fn.get(&(id, idx))?)\n     }\n \n-    fn visit_block_label(&mut self, block: &'tcx Block<'tcx>, label: Option<Label>) {\n-        self.visit_block(block);\n-        let _ = label.and_then(|label| {\n-            self.break_vars\n-                .remove(&label.ident)\n-                .map(|mut break_vars| self.ret_vars.append(&mut break_vars))\n-        });\n-    }\n-\n-    fn visit_bin_op(&mut self, lhs: &'tcx Expr<'tcx>, rhs: &'tcx Expr<'tcx>) {\n-        self.visit_expr(lhs);\n-        let mut ret_vars = std::mem::take(&mut self.ret_vars);\n-        self.visit_expr(rhs);\n-        self.ret_vars.append(&mut ret_vars);\n-\n-        // the binary operation between non primitive values are overloaded operators\n-        // so they can have side-effects\n-        if !is_primitive(self.ty_res.expr_ty(lhs)) || !is_primitive(self.ty_res.expr_ty(rhs)) {\n-            self.ret_vars.iter().for_each(|id| {\n-                self.has_side_effect.insert(id.0);\n-            });\n-            self.contains_side_effect = true;\n-        }\n+    fn clear(&mut self) {\n+        self.params.clear();\n+        self.by_id.clear();\n+        self.by_fn.clear();\n     }\n \n-    fn visit_un_op(&mut self, op: UnOp, expr: &'tcx Expr<'tcx>) {\n-        self.visit_expr(expr);\n-        let ty = self.ty_res.expr_ty(expr);\n-        // dereferencing a reference has no side-effect\n-        if !is_primitive(ty) && !matches!((op, ty.kind()), (UnOp::Deref, ty::Ref(..))) {\n-            self.add_side_effect(self.ret_vars.clone());\n-        }\n-\n-        if matches!((op, ty.kind()), (UnOp::Deref, ty::Ref(_, _, Mutability::Mut))) {\n-            self.ret_vars.iter_mut().for_each(|(_, b)| *b = true);\n+    /// Sets the `apply_lint` flag on each parameter.\n+    fn flag_for_linting(&mut self) {\n+        // Stores the list of parameters currently being resolved. Needed to avoid cycles.\n+        let mut eval_stack = Vec::new();\n+        for param in &self.params {\n+            self.try_disable_lint_for_param(param, &mut eval_stack);\n         }\n     }\n \n-    fn visit_pat_expr(&mut self, pat: &'tcx Pat<'tcx>, expr: &'tcx Expr<'tcx>, connect_self: bool) {\n-        match (&pat.kind, &expr.kind) {\n-            (PatKind::Tuple(pats, _), ExprKind::Tup(exprs)) => {\n-                self.ret_vars = izip!(*pats, *exprs)\n-                    .flat_map(|(pat, expr)| {\n-                        self.visit_pat_expr(pat, expr, connect_self);\n-                        std::mem::take(&mut self.ret_vars)\n-                    })\n-                    .collect();\n-            },\n-            (PatKind::Slice(front_exprs, _, back_exprs), ExprKind::Array(exprs)) => {\n-                let mut vars = izip!(*front_exprs, *exprs)\n-                    .flat_map(|(pat, expr)| {\n-                        self.visit_pat_expr(pat, expr, connect_self);\n-                        std::mem::take(&mut self.ret_vars)\n-                    })\n-                    .collect();\n-                self.ret_vars = izip!(back_exprs.iter().rev(), exprs.iter().rev())\n-                    .flat_map(|(pat, expr)| {\n-                        self.visit_pat_expr(pat, expr, connect_self);\n-                        std::mem::take(&mut self.ret_vars)\n-                    })\n-                    .collect();\n-                self.ret_vars.append(&mut vars);\n-            },\n-            _ => {\n-                let mut lhs_vars = Vec::new();\n-                pat.each_binding(|_, id, _, _| lhs_vars.push((id, false)));\n-                self.visit_expr(expr);\n-                let rhs_vars = std::mem::take(&mut self.ret_vars);\n-                self.connect_assign(&lhs_vars, &rhs_vars, connect_self);\n-                self.ret_vars = rhs_vars;\n-            },\n+    // Use by calling `flag_for_linting`.\n+    fn try_disable_lint_for_param(&self, param: &Param, eval_stack: &mut Vec<usize>) -> bool {\n+        if !param.apply_lint.get() {\n+            true\n+        } else if param.uses.is_empty() {\n+            // Don't lint on unused parameters.\n+            param.apply_lint.set(false);\n+            true\n+        } else if eval_stack.contains(&param.idx) {\n+            // Already on the evaluation stack. Returning false will continue to evaluate other dependencies.\n+            false\n+        } else {\n+            eval_stack.push(param.idx);\n+            // Check all cases when used at a different parameter index.\n+            // Needed to catch cases like: `fn f(x: u32, y: u32) { f(y, x) }`\n+            for usage in param.uses.iter().filter(|u| u.idx != param.idx) {\n+                if self\n+                    .get_by_fn(param.fn_id, usage.idx)\n+                    // If the parameter can't be found, then it's used for more than just recursion.\n+                    .map_or(true, |p| self.try_disable_lint_for_param(p, eval_stack))\n+                {\n+                    param.apply_lint.set(false);\n+                    eval_stack.pop();\n+                    return true;\n+                }\n+            }\n+            eval_stack.pop();\n+            false\n         }\n     }\n+}\n \n-    fn visit_fn(&mut self, callee: &'tcx Expr<'tcx>, args: &'tcx [Expr<'tcx>]) {\n-        self.visit_expr(callee);\n-        let mut ret_vars = std::mem::take(&mut self.ret_vars);\n-        self.add_side_effect(ret_vars.clone());\n-\n-        let mut is_recursive = false;\n-\n-        if_chain! {\n-            if !self.has_self;\n-            if let ExprKind::Path(QPath::Resolved(_, path)) = callee.kind;\n-            if let Res::Def(DefKind::Fn, def_id) = path.res;\n-            if self.fn_def_id == def_id;\n-            then {\n-                is_recursive = true;\n-            }\n-        }\n+#[derive(Default)]\n+pub struct OnlyUsedInRecursion {\n+    /// Track the top-level body entered. Needed to delay reporting when entering nested bodies.\n+    entered_body: Option<HirId>,\n+    params: Params,\n+}\n \n-        if_chain! {\n-            if !self.has_self && self.is_method;\n-            if let ExprKind::Path(QPath::TypeRelative(ty, segment)) = callee.kind;\n-            if segment.ident == self.fn_ident;\n-            if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind;\n-            if let Res::SelfTy{ .. } = path.res;\n-            then {\n-                is_recursive = true;\n-            }\n+impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n+    fn check_body(&mut self, cx: &LateContext<'tcx>, body: &'tcx Body<'tcx>) {\n+        if body.value.span.from_expansion() {\n+            return;\n         }\n-\n-        if is_recursive {\n-            izip!(self.params.clone(), args).for_each(|(pat, expr)| {\n-                self.visit_pat_expr(pat, expr, true);\n-                self.ret_vars.clear();\n-            });\n-        } else {\n-            // This would set arguments used in closure that does not have side-effect.\n-            // Closure itself can be detected whether there is a side-effect, but the\n-            // value of variable that is holding closure can change.\n-            // So, we just check the variables.\n-            self.ret_vars = args\n-                .iter()\n-                .flat_map(|expr| {\n-                    self.visit_expr(expr);\n-                    std::mem::take(&mut self.ret_vars)\n-                })\n-                .collect_vec()\n-                .into_iter()\n-                .map(|id| {\n-                    self.has_side_effect.insert(id.0);\n-                    id\n-                })\n-                .collect();\n-            self.contains_side_effect = true;\n+        // `skip_params` is either `0` or `1` to skip the `self` parameter in trait functions.\n+        // It can't be renamed, and it can't be removed without removing it from multiple functions.\n+        let (fn_id, fn_kind, skip_params) = match get_parent_node(cx.tcx, body.value.hir_id) {\n+            Some(Node::Item(i)) => (i.def_id.to_def_id(), FnKind::Fn, 0),\n+            Some(Node::TraitItem(&TraitItem {\n+                kind: TraitItemKind::Fn(ref sig, _),\n+                def_id,\n+                ..\n+            })) => (\n+                def_id.to_def_id(),\n+                FnKind::TraitFn,\n+                if sig.decl.implicit_self.has_implicit_self() {\n+                    1\n+                } else {\n+                    0\n+                },\n+            ),\n+            Some(Node::ImplItem(&ImplItem {\n+                kind: ImplItemKind::Fn(ref sig, _),\n+                def_id,\n+                ..\n+            })) => {\n+                #[allow(trivial_casts)]\n+                if let Some(Node::Item(item)) = get_parent_node(cx.tcx, cx.tcx.hir().local_def_id_to_hir_id(def_id))\n+                    && let Some(trait_ref) = cx.tcx.impl_trait_ref(item.def_id)\n+                    && let Some(trait_item_id) = cx.tcx.associated_item(def_id).trait_item_def_id\n+                {\n+                    (\n+                        trait_item_id,\n+                        FnKind::ImplTraitFn(cx.tcx.erase_regions(trait_ref.substs) as *const _ as usize),\n+                        if sig.decl.implicit_self.has_implicit_self() {\n+                            1\n+                        } else {\n+                            0\n+                        },\n+                    )\n+                } else {\n+                    (def_id.to_def_id(), FnKind::Fn, 0)\n+                }\n+            },\n+            _ => return,\n+        };\n+        body.params\n+            .iter()\n+            .enumerate()\n+            .skip(skip_params)\n+            .filter_map(|(idx, p)| match p.pat.kind {\n+                PatKind::Binding(_, id, ident, None) if !ident.as_str().starts_with('_') => {\n+                    Some((id, Param::new(fn_id, fn_kind, idx, ident)))\n+                },\n+                _ => None,\n+            })\n+            .for_each(|(id, param)| self.params.insert(param, id));\n+        if self.entered_body.is_none() {\n+            self.entered_body = Some(body.value.hir_id);\n         }\n-\n-        self.ret_vars.append(&mut ret_vars);\n     }\n \n-    fn visit_method_call(&mut self, path: &'tcx PathSegment<'tcx>, args: &'tcx [Expr<'tcx>]) {\n-        if_chain! {\n-            if self.is_method;\n-            if path.ident == self.fn_ident;\n-            if let ExprKind::Path(QPath::Resolved(_, path)) = args.first().unwrap().kind;\n-            if let Res::Local(..) = path.res;\n-            let ident = path.segments.last().unwrap().ident;\n-            if ident.name == kw::SelfLower;\n-            then {\n-                izip!(self.params.clone(), args.iter())\n-                    .for_each(|(pat, expr)| {\n-                        self.visit_pat_expr(pat, expr, true);\n-                        self.ret_vars.clear();\n-                    });\n-            } else {\n-                self.ret_vars = args\n-                    .iter()\n-                    .flat_map(|expr| {\n-                        self.visit_expr(expr);\n-                        std::mem::take(&mut self.ret_vars)\n-                    })\n-                    .collect_vec()\n-                    .into_iter()\n-                    .map(|a| {\n-                        self.has_side_effect.insert(a.0);\n-                        a\n-                    })\n-                    .collect();\n-                self.contains_side_effect = true;\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'tcx>) {\n+        if let Some(id) = path_to_local(e)\n+            && let Some(param) = self.params.get_by_id_mut(id)\n+        {\n+            let typeck = cx.typeck_results();\n+            let span = e.span;\n+            let mut e = e;\n+            loop {\n+                match get_expr_use_or_unification_node(cx.tcx, e) {\n+                    None | Some((Node::Stmt(_), _)) => return,\n+                    Some((Node::Expr(parent), child_id)) => match parent.kind {\n+                        // Recursive call. Track which index the parameter is used in.\n+                        ExprKind::Call(callee, args)\n+                            if path_def_id(cx, callee).map_or(false, |id| {\n+                                id == param.fn_id\n+                                    && has_matching_substs(param.fn_kind, typeck.node_substs(callee.hir_id))\n+                            }) =>\n+                        {\n+                            if let Some(idx) = args.iter().position(|arg| arg.hir_id == child_id) {\n+                                param.uses.push(Usage::new(span, idx));\n+                            }\n+                            return;\n+                        },\n+                        ExprKind::MethodCall(_, args, _)\n+                            if typeck.type_dependent_def_id(parent.hir_id).map_or(false, |id| {\n+                                id == param.fn_id\n+                                    && has_matching_substs(param.fn_kind, typeck.node_substs(parent.hir_id))\n+                            }) =>\n+                        {\n+                            if let Some(idx) = args.iter().position(|arg| arg.hir_id == child_id) {\n+                                param.uses.push(Usage::new(span, idx));\n+                            }\n+                            return;\n+                        },\n+                        // Assignment to a parameter is fine.\n+                        ExprKind::Assign(lhs, _, _) | ExprKind::AssignOp(_, lhs, _) if lhs.hir_id == child_id => {\n+                            return;\n+                        },\n+                        // Parameter update e.g. `x = x + 1`\n+                        ExprKind::Assign(lhs, rhs, _) | ExprKind::AssignOp(_, lhs, rhs)\n+                            if rhs.hir_id == child_id && path_to_local_id(lhs, id) =>\n+                        {\n+                            return;\n+                        },\n+                        // Side-effect free expressions. Walk to the parent expression.\n+                        ExprKind::Binary(_, lhs, rhs)\n+                            if typeck.expr_ty(lhs).is_primitive() && typeck.expr_ty(rhs).is_primitive() =>\n+                        {\n+                            e = parent;\n+                            continue;\n+                        },\n+                        ExprKind::Unary(_, arg) if typeck.expr_ty(arg).is_primitive() => {\n+                            e = parent;\n+                            continue;\n+                        },\n+                        ExprKind::AddrOf(..) | ExprKind::Cast(..) => {\n+                            e = parent;\n+                            continue;\n+                        },\n+                        // Only allow field accesses without auto-deref\n+                        ExprKind::Field(..) if typeck.adjustments().get(child_id).is_none() => {\n+                            e = parent;\n+                            continue\n+                        }\n+                        _ => (),\n+                    },\n+                    _ => (),\n+                }\n+                self.params.remove_by_id(id);\n+                return;\n             }\n         }\n     }\n \n-    fn visit_if(&mut self, bind: &'tcx Expr<'tcx>, then_expr: &'tcx Expr<'tcx>, else_expr: Option<&'tcx Expr<'tcx>>) {\n-        let contains_side_effect = self.contains_side_effect;\n-        self.contains_side_effect = false;\n-        self.visit_expr(bind);\n-        let mut vars = std::mem::take(&mut self.ret_vars);\n-        self.visit_expr(then_expr);\n-        let mut then_vars = std::mem::take(&mut self.ret_vars);\n-        walk_list!(self, visit_expr, else_expr);\n-        if self.contains_side_effect {\n-            self.add_side_effect(vars.clone());\n-        }\n-        self.contains_side_effect |= contains_side_effect;\n-        self.ret_vars.append(&mut vars);\n-        self.ret_vars.append(&mut then_vars);\n-    }\n-\n-    fn visit_match(&mut self, expr: &'tcx Expr<'tcx>, arms: &'tcx [Arm<'tcx>]) {\n-        self.visit_expr(expr);\n-        let mut expr_vars = std::mem::take(&mut self.ret_vars);\n-        self.ret_vars = arms\n-            .iter()\n-            .flat_map(|arm| {\n-                let contains_side_effect = self.contains_side_effect;\n-                self.contains_side_effect = false;\n-                // this would visit `expr` multiple times\n-                // but couldn't think of a better way\n-                self.visit_pat_expr(arm.pat, expr, false);\n-                let mut vars = std::mem::take(&mut self.ret_vars);\n-                let _ = arm.guard.as_ref().map(|guard| {\n-                    self.visit_expr(match guard {\n-                        Guard::If(expr) | Guard::IfLet(Let { init: expr, .. }) => expr,\n-                    });\n-                    vars.append(&mut self.ret_vars);\n-                });\n-                self.visit_expr(arm.body);\n-                if self.contains_side_effect {\n-                    self.add_side_effect(vars.clone());\n-                    self.add_side_effect(expr_vars.clone());\n+    fn check_body_post(&mut self, cx: &LateContext<'tcx>, body: &'tcx Body<'tcx>) {\n+        if self.entered_body == Some(body.value.hir_id) {\n+            self.entered_body = None;\n+            self.params.flag_for_linting();\n+            for param in &self.params.params {\n+                if param.apply_lint.get() {\n+                    span_lint_and_then(\n+                        cx,\n+                        ONLY_USED_IN_RECURSION,\n+                        param.ident.span,\n+                        \"parameter is only used in recursion\",\n+                        |diag| {\n+                            if param.ident.name != kw::SelfLower {\n+                                diag.span_suggestion(\n+                                    param.ident.span,\n+                                    \"if this is intentional, prefix it with an underscore\",\n+                                    format!(\"_{}\", param.ident.name),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n+                            diag.span_note(\n+                                param.uses.iter().map(|x| x.span).collect::<Vec<_>>(),\n+                                \"parameter used here\",\n+                            );\n+                        },\n+                    );\n                 }\n-                self.contains_side_effect |= contains_side_effect;\n-                vars.append(&mut self.ret_vars);\n-                vars\n-            })\n-            .collect();\n-        self.ret_vars.append(&mut expr_vars);\n-    }\n-\n-    fn connect_assign(&mut self, lhs: &[(HirId, bool)], rhs: &[(HirId, bool)], connect_self: bool) {\n-        // if mutable dereference is on assignment it can have side-effect\n-        // (this can lead to parameter mutable dereference and change the original value)\n-        // too hard to detect whether this value is from parameter, so this would all\n-        // check mutable dereference assignment to side effect\n-        lhs.iter().filter(|(_, b)| *b).for_each(|(id, _)| {\n-            self.has_side_effect.insert(*id);\n-            self.contains_side_effect = true;\n-        });\n-\n-        // there is no connection\n-        if lhs.is_empty() || rhs.is_empty() {\n-            return;\n-        }\n-\n-        // by connected rhs in cycle, the connections would decrease\n-        // from `n * m` to `n + m`\n-        // where `n` and `m` are length of `lhs` and `rhs`.\n-\n-        // unwrap is possible since rhs is not empty\n-        let rhs_first = rhs.first().unwrap();\n-        for (id, _) in lhs.iter() {\n-            if connect_self || *id != rhs_first.0 {\n-                self.graph\n-                    .entry(*id)\n-                    .or_insert_with(FxHashSet::default)\n-                    .insert(rhs_first.0);\n             }\n+            self.params.clear();\n         }\n-\n-        let rhs = rhs.iter();\n-        izip!(rhs.clone().cycle().skip(1), rhs).for_each(|(from, to)| {\n-            if connect_self || from.0 != to.0 {\n-                self.graph.entry(from.0).or_insert_with(FxHashSet::default).insert(to.0);\n-            }\n-        });\n     }\n+}\n \n-    fn add_side_effect(&mut self, v: Vec<(HirId, bool)>) {\n-        for (id, _) in v {\n-            self.has_side_effect.insert(id);\n-            self.contains_side_effect = true;\n-        }\n+fn has_matching_substs(kind: FnKind, substs: SubstsRef<'_>) -> bool {\n+    match kind {\n+        FnKind::Fn => true,\n+        FnKind::TraitFn => substs.iter().enumerate().all(|(idx, subst)| match subst.unpack() {\n+            GenericArgKind::Lifetime(_) => true,\n+            GenericArgKind::Type(ty) => matches!(*ty.kind(), ty::Param(ty) if ty.index as usize == idx),\n+            GenericArgKind::Const(c) => matches!(c.kind(), ConstKind::Param(c) if c.index as usize == idx),\n+        }),\n+        #[allow(trivial_casts)]\n+        FnKind::ImplTraitFn(expected_substs) => substs as *const _ as usize == expected_substs,\n     }\n }"}, {"sha": "9602d0d1d2ea1a725963b38f8762a4744c2c4328", "filename": "src/tools/clippy/clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 121, "deletions": 46, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,21 +1,22 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{\n     can_move_expr_to_closure, eager_or_lazy, higher, in_constant, is_else_clause, is_lang_ctor, peel_blocks,\n     peel_hir_expr_while, CaptureKind,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::LangItem::OptionSome;\n-use rustc_hir::{def::Res, BindingAnnotation, Expr, ExprKind, Mutability, PatKind, Path, QPath, UnOp};\n+use rustc_hir::LangItem::{OptionNone, OptionSome, ResultErr, ResultOk};\n+use rustc_hir::{\n+    def::Res, Arm, BindingAnnotation, Expr, ExprKind, MatchSource, Mutability, Pat, PatKind, Path, QPath, UnOp,\n+};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Lints usage of `if let Some(v) = ... { y } else { x }` which is more\n+    /// Lints usage of `if let Some(v) = ... { y } else { x }` and\n+    /// `match .. { Some(v) => y, None/_ => x }` which are more\n     /// idiomatically done with `Option::map_or` (if the else bit is a pure\n     /// expression) or `Option::map_or_else` (if the else bit is an impure\n     /// expression).\n@@ -39,6 +40,10 @@ declare_clippy_lint! {\n     /// } else {\n     ///     5\n     /// };\n+    /// let _ = match optional {\n+    ///     Some(val) => val + 1,\n+    ///     None => 5\n+    /// };\n     /// let _ = if let Some(foo) = optional {\n     ///     foo\n     /// } else {\n@@ -53,11 +58,14 @@ declare_clippy_lint! {\n     /// # let optional: Option<u32> = Some(0);\n     /// # fn do_complicated_function() -> u32 { 5 };\n     /// let _ = optional.map_or(5, |foo| foo);\n+    /// let _ = optional.map_or(5, |val| val + 1);\n     /// let _ = optional.map_or_else(||{\n     ///     let y = do_complicated_function();\n     ///     y*y\n     /// }, |foo| foo);\n     /// ```\n+    // FIXME: Before moving this lint out of nursery, the lint name needs to be updated. It now also\n+    // covers matches and `Result`.\n     #[clippy::version = \"1.47.0\"]\n     pub OPTION_IF_LET_ELSE,\n     nursery,\n@@ -66,19 +74,21 @@ declare_clippy_lint! {\n \n declare_lint_pass!(OptionIfLetElse => [OPTION_IF_LET_ELSE]);\n \n-/// Returns true iff the given expression is the result of calling `Result::ok`\n-fn is_result_ok(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n-    if let ExprKind::MethodCall(path, &[ref receiver], _) = &expr.kind {\n-        path.ident.name.as_str() == \"ok\"\n-            && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(receiver), sym::Result)\n-    } else {\n-        false\n-    }\n-}\n-\n-/// A struct containing information about occurrences of the\n-/// `if let Some(..) = .. else` construct that this lint detects.\n-struct OptionIfLetElseOccurrence {\n+/// A struct containing information about occurrences of construct that this lint detects\n+///\n+/// Such as:\n+///\n+/// ```ignore\n+/// if let Some(..) = {..} else {..}\n+/// ```\n+/// or\n+/// ```ignore\n+/// match x {\n+///     Some(..) => {..},\n+///     None/_ => {..}\n+/// }\n+/// ```\n+struct OptionOccurence {\n     option: String,\n     method_sugg: String,\n     some_expr: String,\n@@ -99,43 +109,38 @@ fn format_option_in_sugg(cx: &LateContext<'_>, cond_expr: &Expr<'_>, as_ref: boo\n     )\n }\n \n-/// If this expression is the option if let/else construct we're detecting, then\n-/// this function returns an `OptionIfLetElseOccurrence` struct with details if\n-/// this construct is found, or None if this construct is not found.\n-fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<OptionIfLetElseOccurrence> {\n+fn try_get_option_occurence<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &Pat<'tcx>,\n+    expr: &Expr<'_>,\n+    if_then: &'tcx Expr<'_>,\n+    if_else: &'tcx Expr<'_>,\n+) -> Option<OptionOccurence> {\n+    let cond_expr = match expr.kind {\n+        ExprKind::Unary(UnOp::Deref, inner_expr) | ExprKind::AddrOf(_, _, inner_expr) => inner_expr,\n+        _ => expr,\n+    };\n+    let inner_pat = try_get_inner_pat(cx, pat)?;\n     if_chain! {\n-        if !expr.span.from_expansion(); // Don't lint macros, because it behaves weirdly\n-        if !in_constant(cx, expr.hir_id);\n-        if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) })\n-            = higher::IfLet::hir(cx, expr);\n-        if !is_else_clause(cx.tcx, expr);\n-        if !is_result_ok(cx, let_expr); // Don't lint on Result::ok because a different lint does it already\n-        if let PatKind::TupleStruct(struct_qpath, [inner_pat], _) = &let_pat.kind;\n-        if is_lang_ctor(cx, struct_qpath, OptionSome);\n-        if let PatKind::Binding(bind_annotation, _, id, None) = &inner_pat.kind;\n+        if let PatKind::Binding(bind_annotation, _, id, None) = inner_pat.kind;\n         if let Some(some_captures) = can_move_expr_to_closure(cx, if_then);\n         if let Some(none_captures) = can_move_expr_to_closure(cx, if_else);\n         if some_captures\n             .iter()\n             .filter_map(|(id, &c)| none_captures.get(id).map(|&c2| (c, c2)))\n             .all(|(x, y)| x.is_imm_ref() && y.is_imm_ref());\n-\n         then {\n-            let capture_mut = if bind_annotation == &BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n+            let capture_mut = if bind_annotation == BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n             let some_body = peel_blocks(if_then);\n             let none_body = peel_blocks(if_else);\n             let method_sugg = if eager_or_lazy::switch_to_eager_eval(cx, none_body) { \"map_or\" } else { \"map_or_else\" };\n             let capture_name = id.name.to_ident_string();\n-            let (as_ref, as_mut) = match &let_expr.kind {\n+            let (as_ref, as_mut) = match &expr.kind {\n                 ExprKind::AddrOf(_, Mutability::Not, _) => (true, false),\n                 ExprKind::AddrOf(_, Mutability::Mut, _) => (false, true),\n-                _ => (bind_annotation == &BindingAnnotation::Ref, bind_annotation == &BindingAnnotation::RefMut),\n-            };\n-            let cond_expr = match let_expr.kind {\n-                // Pointer dereferencing happens automatically, so we can omit it in the suggestion\n-                ExprKind::Unary(UnOp::Deref, expr) | ExprKind::AddrOf(_, _, expr) => expr,\n-                _ => let_expr,\n+                _ => (bind_annotation == BindingAnnotation::Ref, bind_annotation == BindingAnnotation::RefMut),\n             };\n+\n             // Check if captures the closure will need conflict with borrows made in the scrutinee.\n             // TODO: check all the references made in the scrutinee expression. This will require interacting\n             // with the borrow checker. Currently only `<local>[.<field>]*` is checked for.\n@@ -154,30 +159,100 @@ fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) ->\n                     }\n                 }\n             }\n-            Some(OptionIfLetElseOccurrence {\n+\n+            return Some(OptionOccurence {\n                 option: format_option_in_sugg(cx, cond_expr, as_ref, as_mut),\n                 method_sugg: method_sugg.to_string(),\n                 some_expr: format!(\"|{}{}| {}\", capture_mut, capture_name, Sugg::hir_with_macro_callsite(cx, some_body, \"..\")),\n                 none_expr: format!(\"{}{}\", if method_sugg == \"map_or\" { \"\" } else { \"|| \" }, Sugg::hir_with_macro_callsite(cx, none_body, \"..\")),\n-            })\n+            });\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn try_get_inner_pat<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'tcx>) -> Option<&'tcx Pat<'tcx>> {\n+    if let PatKind::TupleStruct(ref qpath, [inner_pat], ..) = pat.kind {\n+        if is_lang_ctor(cx, qpath, OptionSome) || is_lang_ctor(cx, qpath, ResultOk) {\n+            return Some(inner_pat);\n+        }\n+    }\n+    None\n+}\n+\n+/// If this expression is the option if let/else construct we're detecting, then\n+/// this function returns an `OptionOccurence` struct with details if\n+/// this construct is found, or None if this construct is not found.\n+fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<OptionOccurence> {\n+    if let Some(higher::IfLet {\n+        let_pat,\n+        let_expr,\n+        if_then,\n+        if_else: Some(if_else),\n+    }) = higher::IfLet::hir(cx, expr)\n+    {\n+        if !is_else_clause(cx.tcx, expr) {\n+            return try_get_option_occurence(cx, let_pat, let_expr, if_then, if_else);\n+        }\n+    }\n+    None\n+}\n+\n+fn detect_option_match<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<OptionOccurence> {\n+    if let ExprKind::Match(ex, arms, MatchSource::Normal) = expr.kind {\n+        if let Some((let_pat, if_then, if_else)) = try_convert_match(cx, arms) {\n+            return try_get_option_occurence(cx, let_pat, ex, if_then, if_else);\n+        }\n+    }\n+    None\n+}\n+\n+fn try_convert_match<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    arms: &[Arm<'tcx>],\n+) -> Option<(&'tcx Pat<'tcx>, &'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n+    if arms.len() == 2 {\n+        return if is_none_or_err_arm(cx, &arms[1]) {\n+            Some((arms[0].pat, arms[0].body, arms[1].body))\n+        } else if is_none_or_err_arm(cx, &arms[0]) {\n+            Some((arms[1].pat, arms[1].body, arms[0].body))\n         } else {\n             None\n-        }\n+        };\n+    }\n+    None\n+}\n+\n+fn is_none_or_err_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n+    match arm.pat.kind {\n+        PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n+        PatKind::TupleStruct(ref qpath, [first_pat], _) => {\n+            is_lang_ctor(cx, qpath, ResultErr) && matches!(first_pat.kind, PatKind::Wild)\n+        },\n+        PatKind::Wild => true,\n+        _ => false,\n     }\n }\n \n impl<'tcx> LateLintPass<'tcx> for OptionIfLetElse {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'tcx>) {\n-        if let Some(detection) = detect_option_if_let_else(cx, expr) {\n+        // Don't lint macros and constants\n+        if expr.span.from_expansion() || in_constant(cx, expr.hir_id) {\n+            return;\n+        }\n+\n+        let detection = detect_option_if_let_else(cx, expr).or_else(|| detect_option_match(cx, expr));\n+        if let Some(det) = detection {\n             span_lint_and_sugg(\n                 cx,\n                 OPTION_IF_LET_ELSE,\n                 expr.span,\n-                format!(\"use Option::{} instead of an if let/else\", detection.method_sugg).as_str(),\n+                format!(\"use Option::{} instead of an if let/else\", det.method_sugg).as_str(),\n                 \"try\",\n                 format!(\n                     \"{}.{}({}, {})\",\n-                    detection.option, detection.method_sugg, detection.none_expr, detection.some_expr,\n+                    det.option, det.method_sugg, det.none_expr, det.some_expr\n                 ),\n                 Applicability::MaybeIncorrect,\n             );"}, {"sha": "000b0ba7a148e75e503dd9f73ca2061ead430189", "filename": "src/tools/clippy/clippy_lints/src/partialeq_to_none.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_to_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_to_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_to_none.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -53,7 +53,8 @@ impl<'tcx> LateLintPass<'tcx> for PartialeqToNone {\n \n         // If the expression is a literal `Option::None`\n         let is_none_ctor = |expr: &Expr<'_>| {\n-            matches!(&peel_hir_expr_refs(expr).0.kind,\n+            !expr.span.from_expansion()\n+                && matches!(&peel_hir_expr_refs(expr).0.kind,\n             ExprKind::Path(p) if is_lang_ctor(cx, p, LangItem::OptionNone))\n         };\n "}, {"sha": "bc6a918f7035544ace250e7516c78731b1edd98e", "filename": "src/tools/clippy/clippy_lints/src/path_buf_push_overwrite.rs", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,72 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n-use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::symbol::sym;\n-use std::path::{Component, Path};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    ///* Checks for [push](https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.push)\n-    /// calls on `PathBuf` that can cause overwrites.\n-    ///\n-    /// ### Why is this bad?\n-    /// Calling `push` with a root path at the start can overwrite the\n-    /// previous defined path.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// use std::path::PathBuf;\n-    ///\n-    /// let mut x = PathBuf::from(\"/foo\");\n-    /// x.push(\"/bar\");\n-    /// assert_eq!(x, PathBuf::from(\"/bar\"));\n-    /// ```\n-    /// Could be written:\n-    ///\n-    /// ```rust\n-    /// use std::path::PathBuf;\n-    ///\n-    /// let mut x = PathBuf::from(\"/foo\");\n-    /// x.push(\"bar\");\n-    /// assert_eq!(x, PathBuf::from(\"/foo/bar\"));\n-    /// ```\n-    #[clippy::version = \"1.36.0\"]\n-    pub PATH_BUF_PUSH_OVERWRITE,\n-    nursery,\n-    \"calling `push` with file system root on `PathBuf` can overwrite it\"\n-}\n-\n-declare_lint_pass!(PathBufPushOverwrite => [PATH_BUF_PUSH_OVERWRITE]);\n-\n-impl<'tcx> LateLintPass<'tcx> for PathBufPushOverwrite {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::MethodCall(path, [recv, get_index_arg], _) = expr.kind;\n-            if path.ident.name == sym!(push);\n-            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv).peel_refs(), sym::PathBuf);\n-            if let ExprKind::Lit(ref lit) = get_index_arg.kind;\n-            if let LitKind::Str(ref path_lit, _) = lit.node;\n-            if let pushed_path = Path::new(path_lit.as_str());\n-            if let Some(pushed_path_lit) = pushed_path.to_str();\n-            if pushed_path.has_root();\n-            if let Some(root) = pushed_path.components().next();\n-            if root == Component::RootDir;\n-            then {\n-                span_lint_and_sugg(\n-                    cx,\n-                    PATH_BUF_PUSH_OVERWRITE,\n-                    lit.span,\n-                    \"calling `push` with '/' or '\\\\' (file system root) will overwrite the previous path definition\",\n-                    \"try\",\n-                    format!(\"\\\"{}\\\"\", pushed_path_lit.trim_start_matches(|c| c == '/' || c == '\\\\')),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "b432ccb1ee32dd675d054de109fd3ec690fe80f8", "filename": "src/tools/clippy/clippy_lints/src/question_mark.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -123,7 +123,7 @@ fn check_if_let_some_or_err_and_early_return<'tcx>(cx: &LateContext<'tcx>, expr:\n         if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else }) = higher::IfLet::hir(cx, expr);\n         if !is_else_clause(cx.tcx, expr);\n         if let PatKind::TupleStruct(ref path1, [field], None) = let_pat.kind;\n-        if let PatKind::Binding(annot, bind_id, ident, _) = field.kind;\n+        if let PatKind::Binding(annot, bind_id, ident, None) = field.kind;\n         let caller_ty = cx.typeck_results().expr_ty(let_expr);\n         let if_block = IfBlockType::IfLet(path1, caller_ty, ident.name, let_expr, if_then, if_else);\n         if (is_early_return(sym::Option, cx, &if_block) && path_to_local_id(peel_blocks(if_then), bind_id))"}, {"sha": "490f345d2970777634c6554ec54cbb5fd5c040cb", "filename": "src/tools/clippy/clippy_lints/src/ranges.rs", "status": "modified", "additions": 6, "deletions": 67, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,46 +1,20 @@\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_then};\n+use clippy_utils::higher;\n use clippy_utils::source::{snippet, snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::{get_parent_expr, in_constant, is_integer_const, meets_msrv, msrvs, path_to_local};\n-use clippy_utils::{higher, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast::RangeLimits;\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Expr, ExprKind, HirId, PathSegment, QPath};\n+use rustc_hir::{BinOpKind, Expr, ExprKind, HirId};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{Span, Spanned};\n-use rustc_span::sym;\n use std::cmp::Ordering;\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for zipping a collection with the range of\n-    /// `0.._.len()`.\n-    ///\n-    /// ### Why is this bad?\n-    /// The code is better expressed with `.enumerate()`.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let x = vec![1];\n-    /// let _ = x.iter().zip(0..x.len());\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// # let x = vec![1];\n-    /// let _ = x.iter().enumerate();\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub RANGE_ZIP_WITH_LEN,\n-    complexity,\n-    \"zipping iterator with a range when `enumerate()` would do\"\n-}\n-\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for exclusive ranges where 1 is added to the\n@@ -198,7 +172,6 @@ impl Ranges {\n }\n \n impl_lint_pass!(Ranges => [\n-    RANGE_ZIP_WITH_LEN,\n     RANGE_PLUS_ONE,\n     RANGE_MINUS_ONE,\n     REVERSED_EMPTY_RANGES,\n@@ -207,16 +180,10 @@ impl_lint_pass!(Ranges => [\n \n impl<'tcx> LateLintPass<'tcx> for Ranges {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        match expr.kind {\n-            ExprKind::MethodCall(path, args, _) => {\n-                check_range_zip_with_len(cx, path, args, expr.span);\n-            },\n-            ExprKind::Binary(ref op, l, r) => {\n-                if meets_msrv(self.msrv, msrvs::RANGE_CONTAINS) {\n-                    check_possible_range_contains(cx, op.node, l, r, expr, expr.span);\n-                }\n-            },\n-            _ => {},\n+        if let ExprKind::Binary(ref op, l, r) = expr.kind {\n+            if meets_msrv(self.msrv, msrvs::RANGE_CONTAINS) {\n+                check_possible_range_contains(cx, op.node, l, r, expr, expr.span);\n+            }\n         }\n \n         check_exclusive_range_plus_one(cx, expr);\n@@ -380,34 +347,6 @@ fn check_range_bounds<'a>(cx: &'a LateContext<'_>, ex: &'a Expr<'_>) -> Option<R\n     None\n }\n \n-fn check_range_zip_with_len(cx: &LateContext<'_>, path: &PathSegment<'_>, args: &[Expr<'_>], span: Span) {\n-    if_chain! {\n-        if path.ident.as_str() == \"zip\";\n-        if let [iter, zip_arg] = args;\n-        // `.iter()` call\n-        if let ExprKind::MethodCall(iter_path, [iter_caller, ..], _) = iter.kind;\n-        if iter_path.ident.name == sym::iter;\n-        // range expression in `.zip()` call: `0..x.len()`\n-        if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::Range::hir(zip_arg);\n-        if is_integer_const(cx, start, 0);\n-        // `.len()` call\n-        if let ExprKind::MethodCall(len_path, [len_caller], _) = end.kind;\n-        if len_path.ident.name == sym::len;\n-        // `.iter()` and `.len()` called on same `Path`\n-        if let ExprKind::Path(QPath::Resolved(_, iter_path)) = iter_caller.kind;\n-        if let ExprKind::Path(QPath::Resolved(_, len_path)) = len_caller.kind;\n-        if SpanlessEq::new(cx).eq_path_segments(iter_path.segments, len_path.segments);\n-        then {\n-            span_lint(cx,\n-                RANGE_ZIP_WITH_LEN,\n-                span,\n-                &format!(\"it is more idiomatic to use `{}.iter().enumerate()`\",\n-                    snippet(cx, iter_caller.span, \"_\"))\n-            );\n-        }\n-    }\n-}\n-\n // exclusive range plus one: `x..(y+1)`\n fn check_exclusive_range_plus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {"}, {"sha": "e82aa3a7b9897dd751a40aa5c8a4f59e4de247b6", "filename": "src/tools/clippy/clippy_lints/src/rc_clone_in_vec_init.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frc_clone_in_vec_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frc_clone_in_vec_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frc_clone_in_vec_init.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -41,7 +41,7 @@ declare_clippy_lint! {\n     /// let data = std::rc::Rc::new(\"some data\".to_string());\n     /// let v = vec![data; 100];\n     /// ```\n-    #[clippy::version = \"1.62.0\"]\n+    #[clippy::version = \"1.63.0\"]\n     pub RC_CLONE_IN_VEC_INIT,\n     suspicious,\n     \"initializing reference-counted pointer in `vec![elem; len]`\""}, {"sha": "8693ca9af83003f2492158e481fae972649e5276", "filename": "src/tools/clippy/clippy_lints/src/redundant_slicing.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_slicing.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -11,6 +11,8 @@ use rustc_middle::ty::adjustment::{Adjust, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::subst::GenericArg;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n+use std::iter;\n+\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for redundant slicing expressions which use the full range, and\n@@ -134,7 +136,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantSlicing {\n                 } else if let Some(target_id) = cx.tcx.lang_items().deref_target() {\n                     if let Ok(deref_ty) = cx.tcx.try_normalize_erasing_regions(\n                         cx.param_env,\n-                        cx.tcx.mk_projection(target_id, cx.tcx.mk_substs([GenericArg::from(indexed_ty)].into_iter())),\n+                        cx.tcx.mk_projection(target_id, cx.tcx.mk_substs(iter::once(GenericArg::from(indexed_ty)))),\n                     ) {\n                         if deref_ty == expr_ty {\n                             let snip = snippet_with_context(cx, indexed.span, ctxt, \"..\", &mut app).0;"}, {"sha": "2d751c274679f9b64eef70d1b8af54d45bd7aad6", "filename": "src/tools/clippy/clippy_lints/src/redundant_static_lifetimes.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -48,15 +48,15 @@ impl_lint_pass!(RedundantStaticLifetimes => [REDUNDANT_STATIC_LIFETIMES]);\n \n impl RedundantStaticLifetimes {\n     // Recursively visit types\n-    fn visit_type(&mut self, ty: &Ty, cx: &EarlyContext<'_>, reason: &str) {\n+    fn visit_type(ty: &Ty, cx: &EarlyContext<'_>, reason: &str) {\n         match ty.kind {\n             // Be careful of nested structures (arrays and tuples)\n             TyKind::Array(ref ty, _) | TyKind::Slice(ref ty) => {\n-                self.visit_type(ty, cx, reason);\n+                Self::visit_type(ty, cx, reason);\n             },\n             TyKind::Tup(ref tup) => {\n                 for tup_ty in tup {\n-                    self.visit_type(tup_ty, cx, reason);\n+                    Self::visit_type(tup_ty, cx, reason);\n                 }\n             },\n             // This is what we are looking for !\n@@ -87,7 +87,7 @@ impl RedundantStaticLifetimes {\n                         _ => {},\n                     }\n                 }\n-                self.visit_type(&borrow_type.ty, cx, reason);\n+                Self::visit_type(&borrow_type.ty, cx, reason);\n             },\n             _ => {},\n         }\n@@ -102,13 +102,13 @@ impl EarlyLintPass for RedundantStaticLifetimes {\n \n         if !item.span.from_expansion() {\n             if let ItemKind::Const(_, ref var_type, _) = item.kind {\n-                self.visit_type(var_type, cx, \"constants have by default a `'static` lifetime\");\n+                Self::visit_type(var_type, cx, \"constants have by default a `'static` lifetime\");\n                 // Don't check associated consts because `'static` cannot be elided on those (issue\n                 // #2438)\n             }\n \n             if let ItemKind::Static(ref var_type, _, _) = item.kind {\n-                self.visit_type(var_type, cx, \"statics have by default a `'static` lifetime\");\n+                Self::visit_type(var_type, cx, \"statics have by default a `'static` lifetime\");\n             }\n         }\n     }"}, {"sha": "898c70ace66f35776c42c3b6a866022af81c7751", "filename": "src/tools/clippy/clippy_lints/src/repeat_once.rs", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frepeat_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frepeat_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frepeat_once.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,89 +0,0 @@\n-use clippy_utils::consts::{constant_context, Constant};\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for usage of `.repeat(1)` and suggest the following method for each types.\n-    /// - `.to_string()` for `str`\n-    /// - `.clone()` for `String`\n-    /// - `.to_vec()` for `slice`\n-    ///\n-    /// The lint will evaluate constant expressions and values as arguments of `.repeat(..)` and emit a message if\n-    /// they are equivalent to `1`. (Related discussion in [rust-clippy#7306](https://github.com/rust-lang/rust-clippy/issues/7306))\n-    ///\n-    /// ### Why is this bad?\n-    /// For example, `String.repeat(1)` is equivalent to `.clone()`. If cloning\n-    /// the string is the intention behind this, `clone()` should be used.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// fn main() {\n-    ///     let x = String::from(\"hello world\").repeat(1);\n-    /// }\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// fn main() {\n-    ///     let x = String::from(\"hello world\").clone();\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.47.0\"]\n-    pub REPEAT_ONCE,\n-    complexity,\n-    \"using `.repeat(1)` instead of `String.clone()`, `str.to_string()` or `slice.to_vec()` \"\n-}\n-\n-declare_lint_pass!(RepeatOnce => [REPEAT_ONCE]);\n-\n-impl<'tcx> LateLintPass<'tcx> for RepeatOnce {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::MethodCall(path, [receiver, count], _) = &expr.kind;\n-            if path.ident.name == sym!(repeat);\n-            if constant_context(cx, cx.typeck_results()).expr(count) == Some(Constant::Int(1));\n-            if !receiver.span.from_expansion();\n-            then {\n-                let ty = cx.typeck_results().expr_ty(receiver).peel_refs();\n-                if ty.is_str() {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        REPEAT_ONCE,\n-                        expr.span,\n-                        \"calling `repeat(1)` on str\",\n-                        \"consider using `.to_string()` instead\",\n-                        format!(\"{}.to_string()\", snippet(cx, receiver.span, r#\"\"...\"\"#)),\n-                        Applicability::MachineApplicable,\n-                    );\n-                } else if ty.builtin_index().is_some() {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        REPEAT_ONCE,\n-                        expr.span,\n-                        \"calling `repeat(1)` on slice\",\n-                        \"consider using `.to_vec()` instead\",\n-                        format!(\"{}.to_vec()\", snippet(cx, receiver.span, r#\"\"...\"\"#)),\n-                        Applicability::MachineApplicable,\n-                    );\n-                } else if is_type_diagnostic_item(cx, ty, sym::String) {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        REPEAT_ONCE,\n-                        expr.span,\n-                        \"calling `repeat(1)` on a string literal\",\n-                        \"consider using `.clone()` instead\",\n-                        format!(\"{}.clone()\", snippet(cx, receiver.span, r#\"\"...\"\"#)),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "1926661c59603a886b5bfe369532d42df86a497e", "filename": "src/tools/clippy/clippy_lints/src/returns.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -2,7 +2,6 @@ use clippy_utils::diagnostics::span_lint_hir_and_then;\n use clippy_utils::source::{snippet_opt, snippet_with_context};\n use clippy_utils::{fn_def_id, path_to_local_id};\n use if_chain::if_chain;\n-use rustc_ast::ast::Attribute;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, FnKind, Visitor};\n use rustc_hir::{Block, Body, Expr, ExprKind, FnDecl, HirId, MatchSource, PatKind, StmtKind};\n@@ -11,7 +10,6 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -152,10 +150,6 @@ impl<'tcx> LateLintPass<'tcx> for Return {\n     }\n }\n \n-fn attr_is_cfg(attr: &Attribute) -> bool {\n-    attr.meta_item_list().is_some() && attr.has_name(sym::cfg)\n-}\n-\n fn check_block_return<'tcx>(cx: &LateContext<'tcx>, block: &Block<'tcx>) {\n     if let Some(expr) = block.expr {\n         check_final_expr(cx, expr, Some(expr.span), RetReplacement::Empty);\n@@ -178,9 +172,7 @@ fn check_final_expr<'tcx>(\n     match expr.kind {\n         // simple return is always \"bad\"\n         ExprKind::Ret(ref inner) => {\n-            // allow `#[cfg(a)] return a; #[cfg(b)] return b;`\n-            let attrs = cx.tcx.hir().attrs(expr.hir_id);\n-            if !attrs.iter().any(attr_is_cfg) {\n+            if cx.tcx.hir().attrs(expr.hir_id).is_empty() {\n                 let borrows = inner.map_or(false, |inner| last_statement_borrows(cx, inner));\n                 if !borrows {\n                     emit_return_lint("}, {"sha": "9cea4d8806710a84b9f1980361f0c2e407a64321", "filename": "src/tools/clippy/clippy_lints/src/self_named_constructors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_named_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_named_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_named_constructors.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::return_ty;\n-use clippy_utils::ty::{contains_adt_constructor, contains_ty};\n+use clippy_utils::ty::contains_adt_constructor;\n use rustc_hir::{Impl, ImplItem, ImplItemKind, ItemKind, Node};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -66,7 +66,7 @@ impl<'tcx> LateLintPass<'tcx> for SelfNamedConstructors {\n             if !contains_adt_constructor(ret_ty, self_adt) {\n                 return;\n             }\n-        } else if !contains_ty(ret_ty, self_ty) {\n+        } else if !ret_ty.contains(self_ty) {\n             return;\n         }\n "}, {"sha": "6d54935f81ab26e29d03b3eac6e1fc33e2c88ea9", "filename": "src/tools/clippy/clippy_lints/src/stable_sort_primitive.rs", "status": "removed", "additions": 0, "deletions": 144, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstable_sort_primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstable_sort_primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstable_sort_primitive.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,144 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::{is_slice_of_primitives, sugg::Sugg};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// When sorting primitive values (integers, bools, chars, as well\n-    /// as arrays, slices, and tuples of such items), it is typically better to\n-    /// use an unstable sort than a stable sort.\n-    ///\n-    /// ### Why is this bad?\n-    /// Typically, using a stable sort consumes more memory and cpu cycles.\n-    /// Because values which compare equal are identical, preserving their\n-    /// relative order (the guarantee that a stable sort provides) means\n-    /// nothing, while the extra costs still apply.\n-    ///\n-    /// ### Known problems\n-    ///\n-    /// As pointed out in\n-    /// [issue #8241](https://github.com/rust-lang/rust-clippy/issues/8241),\n-    /// a stable sort can instead be significantly faster for certain scenarios\n-    /// (eg. when a sorted vector is extended with new data and resorted).\n-    ///\n-    /// For more information and benchmarking results, please refer to the\n-    /// issue linked above.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let mut vec = vec![2, 1, 3];\n-    /// vec.sort();\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// let mut vec = vec![2, 1, 3];\n-    /// vec.sort_unstable();\n-    /// ```\n-    #[clippy::version = \"1.47.0\"]\n-    pub STABLE_SORT_PRIMITIVE,\n-    pedantic,\n-    \"use of sort() when sort_unstable() is equivalent\"\n-}\n-\n-declare_lint_pass!(StableSortPrimitive => [STABLE_SORT_PRIMITIVE]);\n-\n-/// The three \"kinds\" of sorts\n-enum SortingKind {\n-    Vanilla,\n-    /* The other kinds of lint are currently commented out because they\n-     * can map distinct values to equal ones. If the key function is\n-     * provably one-to-one, or if the Cmp function conserves equality,\n-     * then they could be linted on, but I don't know if we can check\n-     * for that. */\n-\n-    /* ByKey,\n-     * ByCmp, */\n-}\n-impl SortingKind {\n-    /// The name of the stable version of this kind of sort\n-    fn stable_name(&self) -> &str {\n-        match self {\n-            SortingKind::Vanilla => \"sort\",\n-            /* SortingKind::ByKey => \"sort_by_key\",\n-             * SortingKind::ByCmp => \"sort_by\", */\n-        }\n-    }\n-    /// The name of the unstable version of this kind of sort\n-    fn unstable_name(&self) -> &str {\n-        match self {\n-            SortingKind::Vanilla => \"sort_unstable\",\n-            /* SortingKind::ByKey => \"sort_unstable_by_key\",\n-             * SortingKind::ByCmp => \"sort_unstable_by\", */\n-        }\n-    }\n-    /// Takes the name of a function call and returns the kind of sort\n-    /// that corresponds to that function name (or None if it isn't)\n-    fn from_stable_name(name: &str) -> Option<SortingKind> {\n-        match name {\n-            \"sort\" => Some(SortingKind::Vanilla),\n-            // \"sort_by\" => Some(SortingKind::ByCmp),\n-            // \"sort_by_key\" => Some(SortingKind::ByKey),\n-            _ => None,\n-        }\n-    }\n-}\n-\n-/// A detected instance of this lint\n-struct LintDetection {\n-    slice_name: String,\n-    method: SortingKind,\n-    method_args: String,\n-    slice_type: String,\n-}\n-\n-fn detect_stable_sort_primitive(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintDetection> {\n-    if_chain! {\n-        if let ExprKind::MethodCall(method_name, [slice, args @ ..], _) = &expr.kind;\n-        if let Some(method) = SortingKind::from_stable_name(method_name.ident.name.as_str());\n-        if let Some(slice_type) = is_slice_of_primitives(cx, slice);\n-        then {\n-            let args_str = args.iter().map(|arg| Sugg::hir(cx, arg, \"..\").to_string()).collect::<Vec<String>>().join(\", \");\n-            Some(LintDetection { slice_name: Sugg::hir(cx, slice, \"..\").to_string(), method, method_args: args_str, slice_type })\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl LateLintPass<'_> for StableSortPrimitive {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        if let Some(detection) = detect_stable_sort_primitive(cx, expr) {\n-            span_lint_and_then(\n-                cx,\n-                STABLE_SORT_PRIMITIVE,\n-                expr.span,\n-                format!(\n-                    \"used `{}` on primitive type `{}`\",\n-                    detection.method.stable_name(),\n-                    detection.slice_type,\n-                )\n-                .as_str(),\n-                |diag| {\n-                    diag.span_suggestion(\n-                        expr.span,\n-                        \"try\",\n-                        format!(\n-                            \"{}.{}({})\",\n-                            detection.slice_name,\n-                            detection.method.unstable_name(),\n-                            detection.method_args,\n-                        ),\n-                        Applicability::MachineApplicable,\n-                    );\n-                    diag.note(\n-                        \"an unstable sort typically performs faster without any observable difference for this data type\",\n-                    );\n-                },\n-            );\n-        }\n-    }\n-}"}, {"sha": "2ffa022b04f7a4b870e32717c5cd45aa189d23cf", "filename": "src/tools/clippy/clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 66, "deletions": 40, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -4,7 +4,7 @@ use clippy_utils::{SpanlessEq, SpanlessHash};\n use core::hash::{Hash, Hasher};\n use if_chain::if_chain;\n use itertools::Itertools;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_errors::Applicability;\n use rustc_hir::def::Res;\n@@ -15,6 +15,7 @@ use rustc_hir::{\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{BytePos, Span};\n+use std::collections::hash_map::Entry;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -103,7 +104,6 @@ impl<'tcx> LateLintPass<'tcx> for TraitBounds {\n     fn check_generics(&mut self, cx: &LateContext<'tcx>, gen: &'tcx Generics<'_>) {\n         self.check_type_repetition(cx, gen);\n         check_trait_bound_duplication(cx, gen);\n-        check_bounds_or_where_duplication(cx, gen);\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n@@ -234,59 +234,73 @@ impl TraitBounds {\n }\n \n fn check_trait_bound_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n-    if gen.span.from_expansion() || gen.params.is_empty() || gen.predicates.is_empty() {\n+    if gen.span.from_expansion() {\n         return;\n     }\n \n-    let mut map = FxHashMap::<_, Vec<_>>::default();\n-    for predicate in gen.predicates {\n+    // Explanation:\n+    // fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n+    // where T: Clone + Default, { unimplemented!(); }\n+    //       ^^^^^^^^^^^^^^^^^^\n+    //       |\n+    // collects each of these where clauses into a set keyed by generic name and comparable trait\n+    // eg. (T, Clone)\n+    let where_predicates = gen\n+        .predicates\n+        .iter()\n+        .filter_map(|pred| {\n+            if_chain! {\n+                if pred.in_where_clause();\n+                if let WherePredicate::BoundPredicate(bound_predicate) = pred;\n+                if let TyKind::Path(QPath::Resolved(_, path)) =  bound_predicate.bounded_ty.kind;\n+                then {\n+                    return Some(\n+                        rollup_traits(cx, bound_predicate.bounds, \"these where clauses contain repeated elements\")\n+                        .into_iter().map(|(trait_ref, _)| (path.res, trait_ref)))\n+                }\n+            }\n+            None\n+        })\n+        .flatten()\n+        .collect::<FxHashSet<_>>();\n+\n+    // Explanation:\n+    // fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z) ...\n+    //            ^^^^^^^^^^^^^^^^^^  ^^^^^^^\n+    //            |\n+    // compare trait bounds keyed by generic name and comparable trait to collected where\n+    // predicates eg. (T, Clone)\n+    for predicate in gen.predicates.iter().filter(|pred| !pred.in_where_clause()) {\n         if_chain! {\n-            if let WherePredicate::BoundPredicate(ref bound_predicate) = predicate;\n+            if let WherePredicate::BoundPredicate(bound_predicate) = predicate;\n             if bound_predicate.origin != PredicateOrigin::ImplTrait;\n             if !bound_predicate.span.from_expansion();\n-            if let TyKind::Path(QPath::Resolved(_, Path { segments, .. })) = bound_predicate.bounded_ty.kind;\n-            if let Some(segment) = segments.first();\n+            if let TyKind::Path(QPath::Resolved(_, path)) =  bound_predicate.bounded_ty.kind;\n             then {\n-                for (res_where, _, span_where) in bound_predicate.bounds.iter().filter_map(get_trait_info_from_bound) {\n-                    let trait_resolutions_direct = map.entry(segment.ident).or_default();\n-                    if let Some((_, span_direct)) = trait_resolutions_direct\n-                                                .iter()\n-                                                .find(|(res_direct, _)| *res_direct == res_where) {\n+                let traits = rollup_traits(cx, bound_predicate.bounds, \"these bounds contain repeated elements\");\n+                for (trait_ref, span) in traits {\n+                    let key = (path.res, trait_ref);\n+                    if where_predicates.contains(&key) {\n                         span_lint_and_help(\n                             cx,\n                             TRAIT_DUPLICATION_IN_BOUNDS,\n-                            *span_direct,\n+                            span,\n                             \"this trait bound is already specified in the where clause\",\n                             None,\n                             \"consider removing this trait bound\",\n-                        );\n-                    }\n-                    else {\n-                        trait_resolutions_direct.push((res_where, span_where));\n+                            );\n                     }\n                 }\n             }\n         }\n     }\n }\n \n-#[derive(PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n struct ComparableTraitRef(Res, Vec<Res>);\n-\n-fn check_bounds_or_where_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n-    if gen.span.from_expansion() {\n-        return;\n-    }\n-\n-    for predicate in gen.predicates {\n-        if let WherePredicate::BoundPredicate(ref bound_predicate) = predicate {\n-            let msg = if predicate.in_where_clause() {\n-                \"these where clauses contain repeated elements\"\n-            } else {\n-                \"these bounds contain repeated elements\"\n-            };\n-            rollup_traits(cx, bound_predicate.bounds, msg);\n-        }\n+impl Default for ComparableTraitRef {\n+    fn default() -> Self {\n+        Self(Res::Err, Vec::new())\n     }\n }\n \n@@ -331,7 +345,7 @@ fn into_comparable_trait_ref(trait_ref: &TraitRef<'_>) -> ComparableTraitRef {\n     )\n }\n \n-fn rollup_traits(cx: &LateContext<'_>, bounds: &[GenericBound<'_>], msg: &str) {\n+fn rollup_traits(cx: &LateContext<'_>, bounds: &[GenericBound<'_>], msg: &str) -> Vec<(ComparableTraitRef, Span)> {\n     let mut map = FxHashMap::default();\n     let mut repeated_res = false;\n \n@@ -343,23 +357,33 @@ fn rollup_traits(cx: &LateContext<'_>, bounds: &[GenericBound<'_>], msg: &str) {\n         }\n     };\n \n+    let mut i = 0usize;\n     for bound in bounds.iter().filter_map(only_comparable_trait_refs) {\n         let (comparable_bound, span_direct) = bound;\n-        if map.insert(comparable_bound, span_direct).is_some() {\n-            repeated_res = true;\n+        match map.entry(comparable_bound) {\n+            Entry::Occupied(_) => repeated_res = true,\n+            Entry::Vacant(e) => {\n+                e.insert((span_direct, i));\n+                i += 1;\n+            },\n         }\n     }\n \n+    // Put bounds in source order\n+    let mut comparable_bounds = vec![Default::default(); map.len()];\n+    for (k, (v, i)) in map {\n+        comparable_bounds[i] = (k, v);\n+    }\n+\n     if_chain! {\n         if repeated_res;\n         if let [first_trait, .., last_trait] = bounds;\n         then {\n             let all_trait_span = first_trait.span().to(last_trait.span());\n \n-            let mut traits = map.values()\n-                .filter_map(|span| snippet_opt(cx, *span))\n+            let traits = comparable_bounds.iter()\n+                .filter_map(|&(_, span)| snippet_opt(cx, span))\n                 .collect::<Vec<_>>();\n-            traits.sort_unstable();\n             let traits = traits.join(\" + \");\n \n             span_lint_and_sugg(\n@@ -373,4 +397,6 @@ fn rollup_traits(cx: &LateContext<'_>, bounds: &[GenericBound<'_>], msg: &str) {\n             );\n         }\n     }\n+\n+    comparable_bounds\n }"}, {"sha": "424a6e9264e4b96680b6e4a09cfab81e2a36083f", "filename": "src/tools/clippy/clippy_lints/src/transmute/mod.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fmod.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -9,6 +9,7 @@ mod transmute_ptr_to_ref;\n mod transmute_ref_to_ref;\n mod transmute_undefined_repr;\n mod transmutes_expressible_as_ptr_casts;\n+mod transmuting_null;\n mod unsound_collection_transmute;\n mod useless_transmute;\n mod utils;\n@@ -386,6 +387,28 @@ declare_clippy_lint! {\n     \"transmute to or from a type with an undefined representation\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for transmute calls which would receive a null pointer.\n+    ///\n+    /// ### Why is this bad?\n+    /// Transmuting a null pointer is undefined behavior.\n+    ///\n+    /// ### Known problems\n+    /// Not all cases can be detected at the moment of this writing.\n+    /// For example, variables which hold a null pointer and are then fed to a `transmute`\n+    /// call, aren't detectable yet.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let null_ref: &u64 = unsafe { std::mem::transmute(0 as *const u64) };\n+    /// ```\n+    #[clippy::version = \"1.35.0\"]\n+    pub TRANSMUTING_NULL,\n+    correctness,\n+    \"transmutes from a null pointer to a reference, which is undefined behavior\"\n+}\n+\n pub struct Transmute {\n     msrv: Option<RustcVersion>,\n }\n@@ -404,6 +427,7 @@ impl_lint_pass!(Transmute => [\n     UNSOUND_COLLECTION_TRANSMUTE,\n     TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n     TRANSMUTE_UNDEFINED_REPR,\n+    TRANSMUTING_NULL,\n ]);\n impl Transmute {\n     #[must_use]\n@@ -436,6 +460,7 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n \n                 let linted = wrong_transmute::check(cx, e, from_ty, to_ty)\n                     | crosspointer_transmute::check(cx, e, from_ty, to_ty)\n+                    | transmuting_null::check(cx, e, arg, to_ty)\n                     | transmute_ptr_to_ref::check(cx, e, from_ty, to_ty, arg, path, self.msrv)\n                     | transmute_int_to_char::check(cx, e, from_ty, to_ty, arg, const_context)\n                     | transmute_ref_to_ref::check(cx, e, from_ty, to_ty, arg, const_context)"}, {"sha": "b6d7d9f5b42ec2a7c5138163a738ced1b4cb8271", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_undefined_repr.rs", "status": "modified", "additions": 183, "deletions": 217, "changes": 400, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -5,9 +5,9 @@ use rustc_hir::Expr;\n use rustc_lint::LateContext;\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n use rustc_middle::ty::{self, IntTy, Ty, TypeAndMut, UintTy};\n-use rustc_span::Span;\n+use rustc_span::DUMMY_SP;\n \n-#[allow(clippy::too_many_lines)]\n+#[expect(clippy::too_many_lines)]\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     e: &'tcx Expr<'_>,\n@@ -18,116 +18,89 @@ pub(super) fn check<'tcx>(\n     let mut to_ty = cx.tcx.erase_regions(to_ty_orig);\n \n     while from_ty != to_ty {\n-        match reduce_refs(cx, e.span, from_ty, to_ty) {\n-            ReducedTys::FromFatPtr {\n-                unsized_ty,\n-                to_ty: to_sub_ty,\n-            } => match reduce_ty(cx, to_sub_ty) {\n-                ReducedTy::TypeErasure => break,\n-                ReducedTy::UnorderedFields(ty) if is_size_pair(ty) => break,\n-                ReducedTy::Ref(to_sub_ty) => {\n-                    from_ty = unsized_ty;\n-                    to_ty = to_sub_ty;\n-                    continue;\n-                },\n-                _ => {\n-                    span_lint_and_then(\n-                        cx,\n-                        TRANSMUTE_UNDEFINED_REPR,\n-                        e.span,\n-                        &format!(\"transmute from `{}` which has an undefined layout\", from_ty_orig),\n-                        |diag| {\n-                            if from_ty_orig.peel_refs() != unsized_ty {\n-                                diag.note(&format!(\"the contained type `&{}` has an undefined layout\", unsized_ty));\n-                            }\n-                        },\n-                    );\n-                    return true;\n-                },\n+        let reduced_tys = reduce_refs(cx, from_ty, to_ty);\n+        match (reduce_ty(cx, reduced_tys.from_ty), reduce_ty(cx, reduced_tys.to_ty)) {\n+            // Various forms of type erasure.\n+            (ReducedTy::TypeErasure { raw_ptr_only: false }, _)\n+            | (_, ReducedTy::TypeErasure { raw_ptr_only: false }) => return false,\n+            (ReducedTy::TypeErasure { .. }, _) if reduced_tys.from_raw_ptr => return false,\n+            (_, ReducedTy::TypeErasure { .. }) if reduced_tys.to_raw_ptr => return false,\n+\n+            // `Repr(C)` <-> unordered type.\n+            // If the first field of the `Repr(C)` type matches then the transmute is ok\n+            (ReducedTy::OrderedFields(_, Some(from_sub_ty)), ReducedTy::UnorderedFields(to_sub_ty))\n+            | (ReducedTy::UnorderedFields(from_sub_ty), ReducedTy::OrderedFields(_, Some(to_sub_ty))) => {\n+                from_ty = from_sub_ty;\n+                to_ty = to_sub_ty;\n+                continue;\n             },\n-            ReducedTys::ToFatPtr {\n-                unsized_ty,\n-                from_ty: from_sub_ty,\n-            } => match reduce_ty(cx, from_sub_ty) {\n-                ReducedTy::TypeErasure => break,\n-                ReducedTy::UnorderedFields(ty) if is_size_pair(ty) => break,\n-                ReducedTy::Ref(from_sub_ty) => {\n-                    from_ty = from_sub_ty;\n-                    to_ty = unsized_ty;\n-                    continue;\n-                },\n-                _ => {\n-                    span_lint_and_then(\n-                        cx,\n-                        TRANSMUTE_UNDEFINED_REPR,\n-                        e.span,\n-                        &format!(\"transmute to `{}` which has an undefined layout\", to_ty_orig),\n-                        |diag| {\n-                            if to_ty_orig.peel_refs() != unsized_ty {\n-                                diag.note(&format!(\"the contained type `&{}` has an undefined layout\", unsized_ty));\n-                            }\n-                        },\n-                    );\n-                    return true;\n-                },\n+            (ReducedTy::OrderedFields(_, Some(from_sub_ty)), ReducedTy::Other(to_sub_ty)) if reduced_tys.to_fat_ptr => {\n+                from_ty = from_sub_ty;\n+                to_ty = to_sub_ty;\n+                continue;\n             },\n-            ReducedTys::ToPtr {\n-                from_ty: from_sub_ty,\n-                to_ty: to_sub_ty,\n-            } => match reduce_ty(cx, from_sub_ty) {\n-                ReducedTy::UnorderedFields(from_ty) => {\n-                    span_lint_and_then(\n-                        cx,\n-                        TRANSMUTE_UNDEFINED_REPR,\n-                        e.span,\n-                        &format!(\"transmute from `{}` which has an undefined layout\", from_ty_orig),\n-                        |diag| {\n-                            if from_ty_orig.peel_refs() != from_ty {\n-                                diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n-                            }\n-                        },\n-                    );\n-                    return true;\n-                },\n-                ReducedTy::Ref(from_sub_ty) => {\n-                    from_ty = from_sub_ty;\n-                    to_ty = to_sub_ty;\n-                    continue;\n-                },\n-                _ => break,\n+            (ReducedTy::Other(from_sub_ty), ReducedTy::OrderedFields(_, Some(to_sub_ty)))\n+                if reduced_tys.from_fat_ptr =>\n+            {\n+                from_ty = from_sub_ty;\n+                to_ty = to_sub_ty;\n+                continue;\n             },\n-            ReducedTys::FromPtr {\n-                from_ty: from_sub_ty,\n-                to_ty: to_sub_ty,\n-            } => match reduce_ty(cx, to_sub_ty) {\n-                ReducedTy::UnorderedFields(to_ty) => {\n-                    span_lint_and_then(\n-                        cx,\n-                        TRANSMUTE_UNDEFINED_REPR,\n-                        e.span,\n-                        &format!(\"transmute to `{}` which has an undefined layout\", to_ty_orig),\n-                        |diag| {\n-                            if to_ty_orig.peel_refs() != to_ty {\n-                                diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n-                            }\n-                        },\n-                    );\n-                    return true;\n-                },\n-                ReducedTy::Ref(to_sub_ty) => {\n-                    from_ty = from_sub_ty;\n-                    to_ty = to_sub_ty;\n-                    continue;\n-                },\n-                _ => break,\n+\n+            // ptr <-> ptr\n+            (ReducedTy::Other(from_sub_ty), ReducedTy::Other(to_sub_ty))\n+                if matches!(from_sub_ty.kind(), ty::Ref(..) | ty::RawPtr(_))\n+                    && matches!(to_sub_ty.kind(), ty::Ref(..) | ty::RawPtr(_)) =>\n+            {\n+                from_ty = from_sub_ty;\n+                to_ty = to_sub_ty;\n+                continue;\n             },\n-            ReducedTys::Other {\n-                from_ty: from_sub_ty,\n-                to_ty: to_sub_ty,\n-            } => match (reduce_ty(cx, from_sub_ty), reduce_ty(cx, to_sub_ty)) {\n-                (ReducedTy::TypeErasure, _) | (_, ReducedTy::TypeErasure) => return false,\n-                (ReducedTy::UnorderedFields(from_ty), ReducedTy::UnorderedFields(to_ty)) if from_ty != to_ty => {\n-                    let same_adt_did = if let (ty::Adt(from_def, from_subs), ty::Adt(to_def, to_subs))\n+\n+            // fat ptr <-> (*size, *size)\n+            (ReducedTy::Other(_), ReducedTy::UnorderedFields(to_ty))\n+                if reduced_tys.from_fat_ptr && is_size_pair(to_ty) =>\n+            {\n+                return false;\n+            },\n+            (ReducedTy::UnorderedFields(from_ty), ReducedTy::Other(_))\n+                if reduced_tys.to_fat_ptr && is_size_pair(from_ty) =>\n+            {\n+                return false;\n+            },\n+\n+            // fat ptr -> some struct | some struct -> fat ptr\n+            (ReducedTy::Other(_), _) if reduced_tys.from_fat_ptr => {\n+                span_lint_and_then(\n+                    cx,\n+                    TRANSMUTE_UNDEFINED_REPR,\n+                    e.span,\n+                    &format!(\"transmute from `{}` which has an undefined layout\", from_ty_orig),\n+                    |diag| {\n+                        if from_ty_orig.peel_refs() != from_ty.peel_refs() {\n+                            diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n+                        }\n+                    },\n+                );\n+                return true;\n+            },\n+            (_, ReducedTy::Other(_)) if reduced_tys.to_fat_ptr => {\n+                span_lint_and_then(\n+                    cx,\n+                    TRANSMUTE_UNDEFINED_REPR,\n+                    e.span,\n+                    &format!(\"transmute to `{}` which has an undefined layout\", to_ty_orig),\n+                    |diag| {\n+                        if to_ty_orig.peel_refs() != to_ty.peel_refs() {\n+                            diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n+                        }\n+                    },\n+                );\n+                return true;\n+            },\n+\n+            (ReducedTy::UnorderedFields(from_ty), ReducedTy::UnorderedFields(to_ty)) if from_ty != to_ty => {\n+                let same_adt_did = if let (ty::Adt(from_def, from_subs), ty::Adt(to_def, to_subs))\n                         = (from_ty.kind(), to_ty.kind())\n                         && from_def == to_def\n                     {\n@@ -138,144 +111,137 @@ pub(super) fn check<'tcx>(\n                     } else {\n                         None\n                     };\n-                    span_lint_and_then(\n-                        cx,\n-                        TRANSMUTE_UNDEFINED_REPR,\n-                        e.span,\n-                        &format!(\n-                            \"transmute from `{}` to `{}`, both of which have an undefined layout\",\n-                            from_ty_orig, to_ty_orig\n-                        ),\n-                        |diag| {\n-                            if let Some(same_adt_did) = same_adt_did {\n-                                diag.note(&format!(\n-                                    \"two instances of the same generic type (`{}`) may have different layouts\",\n-                                    cx.tcx.item_name(same_adt_did)\n-                                ));\n-                            } else {\n-                                if from_ty_orig.peel_refs() != from_ty {\n-                                    diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n-                                }\n-                                if to_ty_orig.peel_refs() != to_ty {\n-                                    diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n-                                }\n-                            }\n-                        },\n-                    );\n-                    return true;\n-                },\n-                (\n-                    ReducedTy::UnorderedFields(from_ty),\n-                    ReducedTy::Other(_) | ReducedTy::OrderedFields(_) | ReducedTy::Ref(_),\n-                ) => {\n-                    span_lint_and_then(\n-                        cx,\n-                        TRANSMUTE_UNDEFINED_REPR,\n-                        e.span,\n-                        &format!(\"transmute from `{}` which has an undefined layout\", from_ty_orig),\n-                        |diag| {\n+                span_lint_and_then(\n+                    cx,\n+                    TRANSMUTE_UNDEFINED_REPR,\n+                    e.span,\n+                    &format!(\n+                        \"transmute from `{}` to `{}`, both of which have an undefined layout\",\n+                        from_ty_orig, to_ty_orig\n+                    ),\n+                    |diag| {\n+                        if let Some(same_adt_did) = same_adt_did {\n+                            diag.note(&format!(\n+                                \"two instances of the same generic type (`{}`) may have different layouts\",\n+                                cx.tcx.item_name(same_adt_did)\n+                            ));\n+                        } else {\n                             if from_ty_orig.peel_refs() != from_ty {\n                                 diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n                             }\n-                        },\n-                    );\n-                    return true;\n-                },\n-                (\n-                    ReducedTy::Other(_) | ReducedTy::OrderedFields(_) | ReducedTy::Ref(_),\n-                    ReducedTy::UnorderedFields(to_ty),\n-                ) => {\n-                    span_lint_and_then(\n-                        cx,\n-                        TRANSMUTE_UNDEFINED_REPR,\n-                        e.span,\n-                        &format!(\"transmute into `{}` which has an undefined layout\", to_ty_orig),\n-                        |diag| {\n                             if to_ty_orig.peel_refs() != to_ty {\n                                 diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n                             }\n-                        },\n-                    );\n-                    return true;\n-                },\n-                (ReducedTy::Ref(from_sub_ty), ReducedTy::Ref(to_sub_ty)) => {\n-                    from_ty = from_sub_ty;\n-                    to_ty = to_sub_ty;\n-                    continue;\n-                },\n-                (\n-                    ReducedTy::OrderedFields(_) | ReducedTy::Ref(_) | ReducedTy::Other(_) | ReducedTy::Param,\n-                    ReducedTy::OrderedFields(_) | ReducedTy::Ref(_) | ReducedTy::Other(_) | ReducedTy::Param,\n-                )\n-                | (\n-                    ReducedTy::UnorderedFields(_) | ReducedTy::Param,\n-                    ReducedTy::UnorderedFields(_) | ReducedTy::Param,\n-                ) => break,\n+                        }\n+                    },\n+                );\n+                return true;\n+            },\n+            (\n+                ReducedTy::UnorderedFields(from_ty),\n+                ReducedTy::Other(_) | ReducedTy::OrderedFields(..) | ReducedTy::TypeErasure { raw_ptr_only: true },\n+            ) => {\n+                span_lint_and_then(\n+                    cx,\n+                    TRANSMUTE_UNDEFINED_REPR,\n+                    e.span,\n+                    &format!(\"transmute from `{}` which has an undefined layout\", from_ty_orig),\n+                    |diag| {\n+                        if from_ty_orig.peel_refs() != from_ty {\n+                            diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n+                        }\n+                    },\n+                );\n+                return true;\n+            },\n+            (\n+                ReducedTy::Other(_) | ReducedTy::OrderedFields(..) | ReducedTy::TypeErasure { raw_ptr_only: true },\n+                ReducedTy::UnorderedFields(to_ty),\n+            ) => {\n+                span_lint_and_then(\n+                    cx,\n+                    TRANSMUTE_UNDEFINED_REPR,\n+                    e.span,\n+                    &format!(\"transmute into `{}` which has an undefined layout\", to_ty_orig),\n+                    |diag| {\n+                        if to_ty_orig.peel_refs() != to_ty {\n+                            diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n+                        }\n+                    },\n+                );\n+                return true;\n+            },\n+            (\n+                ReducedTy::OrderedFields(..) | ReducedTy::Other(_) | ReducedTy::TypeErasure { raw_ptr_only: true },\n+                ReducedTy::OrderedFields(..) | ReducedTy::Other(_) | ReducedTy::TypeErasure { raw_ptr_only: true },\n+            )\n+            | (ReducedTy::UnorderedFields(_), ReducedTy::UnorderedFields(_)) => {\n+                break;\n             },\n         }\n     }\n \n     false\n }\n \n-enum ReducedTys<'tcx> {\n-    FromFatPtr { unsized_ty: Ty<'tcx>, to_ty: Ty<'tcx> },\n-    ToFatPtr { unsized_ty: Ty<'tcx>, from_ty: Ty<'tcx> },\n-    ToPtr { from_ty: Ty<'tcx>, to_ty: Ty<'tcx> },\n-    FromPtr { from_ty: Ty<'tcx>, to_ty: Ty<'tcx> },\n-    Other { from_ty: Ty<'tcx>, to_ty: Ty<'tcx> },\n+#[expect(clippy::struct_excessive_bools)]\n+struct ReducedTys<'tcx> {\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+    from_raw_ptr: bool,\n+    to_raw_ptr: bool,\n+    from_fat_ptr: bool,\n+    to_fat_ptr: bool,\n }\n \n /// Remove references so long as both types are references.\n-fn reduce_refs<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    span: Span,\n-    mut from_ty: Ty<'tcx>,\n-    mut to_ty: Ty<'tcx>,\n-) -> ReducedTys<'tcx> {\n-    loop {\n-        return match (from_ty.kind(), to_ty.kind()) {\n+fn reduce_refs<'tcx>(cx: &LateContext<'tcx>, mut from_ty: Ty<'tcx>, mut to_ty: Ty<'tcx>) -> ReducedTys<'tcx> {\n+    let mut from_raw_ptr = false;\n+    let mut to_raw_ptr = false;\n+    let (from_fat_ptr, to_fat_ptr) = loop {\n+        break match (from_ty.kind(), to_ty.kind()) {\n             (\n                 &(ty::Ref(_, from_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: from_sub_ty, .. })),\n                 &(ty::Ref(_, to_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: to_sub_ty, .. })),\n             ) => {\n+                from_raw_ptr = matches!(*from_ty.kind(), ty::RawPtr(_));\n                 from_ty = from_sub_ty;\n+                to_raw_ptr = matches!(*to_ty.kind(), ty::RawPtr(_));\n                 to_ty = to_sub_ty;\n                 continue;\n             },\n             (&(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })), _)\n-                if !unsized_ty.is_sized(cx.tcx.at(span), cx.param_env) =>\n+                if !unsized_ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env) =>\n             {\n-                ReducedTys::FromFatPtr { unsized_ty, to_ty }\n+                (true, false)\n             },\n             (_, &(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })))\n-                if !unsized_ty.is_sized(cx.tcx.at(span), cx.param_env) =>\n+                if !unsized_ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env) =>\n             {\n-                ReducedTys::ToFatPtr { unsized_ty, from_ty }\n+                (false, true)\n             },\n-            (&(ty::Ref(_, from_ty, _) | ty::RawPtr(TypeAndMut { ty: from_ty, .. })), _) => {\n-                ReducedTys::FromPtr { from_ty, to_ty }\n-            },\n-            (_, &(ty::Ref(_, to_ty, _) | ty::RawPtr(TypeAndMut { ty: to_ty, .. }))) => {\n-                ReducedTys::ToPtr { from_ty, to_ty }\n-            },\n-            _ => ReducedTys::Other { from_ty, to_ty },\n+            _ => (false, false),\n         };\n+    };\n+    ReducedTys {\n+        from_ty,\n+        to_ty,\n+        from_raw_ptr,\n+        to_raw_ptr,\n+        from_fat_ptr,\n+        to_fat_ptr,\n     }\n }\n \n enum ReducedTy<'tcx> {\n     /// The type can be used for type erasure.\n-    TypeErasure,\n+    TypeErasure { raw_ptr_only: bool },\n     /// The type is a struct containing either zero non-zero sized fields, or multiple non-zero\n     /// sized fields with a defined order.\n-    OrderedFields(Ty<'tcx>),\n+    /// The second value is the first non-zero sized type.\n+    OrderedFields(Ty<'tcx>, Option<Ty<'tcx>>),\n     /// The type is a struct containing multiple non-zero sized fields with no defined order.\n     UnorderedFields(Ty<'tcx>),\n-    /// The type is a reference to the contained type.\n-    Ref(Ty<'tcx>),\n-    /// The type is a generic parameter.\n-    Param,\n     /// Any other type.\n     Other(Ty<'tcx>),\n }\n@@ -285,16 +251,18 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n     loop {\n         ty = cx.tcx.try_normalize_erasing_regions(cx.param_env, ty).unwrap_or(ty);\n         return match *ty.kind() {\n-            ty::Array(sub_ty, _) if matches!(sub_ty.kind(), ty::Int(_) | ty::Uint(_)) => ReducedTy::TypeErasure,\n+            ty::Array(sub_ty, _) if matches!(sub_ty.kind(), ty::Int(_) | ty::Uint(_)) => {\n+                ReducedTy::TypeErasure { raw_ptr_only: false }\n+            },\n             ty::Array(sub_ty, _) | ty::Slice(sub_ty) => {\n                 ty = sub_ty;\n                 continue;\n             },\n-            ty::Tuple(args) if args.is_empty() => ReducedTy::TypeErasure,\n+            ty::Tuple(args) if args.is_empty() => ReducedTy::TypeErasure { raw_ptr_only: false },\n             ty::Tuple(args) => {\n                 let mut iter = args.iter();\n                 let Some(sized_ty) = iter.find(|&ty| !is_zero_sized_ty(cx, ty)) else {\n-                    return ReducedTy::OrderedFields(ty);\n+                    return ReducedTy::OrderedFields(ty, None);\n                 };\n                 if iter.all(|ty| is_zero_sized_ty(cx, ty)) {\n                     ty = sized_ty;\n@@ -309,27 +277,25 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n                     .iter()\n                     .map(|f| cx.tcx.bound_type_of(f.did).subst(cx.tcx, substs));\n                 let Some(sized_ty) = iter.find(|&ty| !is_zero_sized_ty(cx, ty)) else {\n-                    return ReducedTy::TypeErasure;\n+                    return ReducedTy::TypeErasure { raw_ptr_only: false };\n                 };\n                 if iter.all(|ty| is_zero_sized_ty(cx, ty)) {\n                     ty = sized_ty;\n                     continue;\n                 }\n                 if def.repr().inhibit_struct_field_reordering_opt() {\n-                    ReducedTy::OrderedFields(ty)\n+                    ReducedTy::OrderedFields(ty, Some(sized_ty))\n                 } else {\n                     ReducedTy::UnorderedFields(ty)\n                 }\n             },\n             ty::Adt(def, _) if def.is_enum() && (def.variants().is_empty() || is_c_void(cx, ty)) => {\n-                ReducedTy::TypeErasure\n+                ReducedTy::TypeErasure { raw_ptr_only: false }\n             },\n             // TODO: Check if the conversion to or from at least one of a union's fields is valid.\n-            ty::Adt(def, _) if def.is_union() => ReducedTy::TypeErasure,\n-            ty::Foreign(_) => ReducedTy::TypeErasure,\n-            ty::Ref(_, ty, _) => ReducedTy::Ref(ty),\n-            ty::RawPtr(ty) => ReducedTy::Ref(ty.ty),\n-            ty::Param(_) => ReducedTy::Param,\n+            ty::Adt(def, _) if def.is_union() => ReducedTy::TypeErasure { raw_ptr_only: false },\n+            ty::Foreign(_) | ty::Param(_) => ReducedTy::TypeErasure { raw_ptr_only: false },\n+            ty::Int(_) | ty::Uint(_) => ReducedTy::TypeErasure { raw_ptr_only: true },\n             _ => ReducedTy::Other(ty),\n         };\n     }"}, {"sha": "d8e349af7af8e46ecbcb64897054ddbade8f7cca", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmuting_null.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmuting_null.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,61 @@\n+use clippy_utils::consts::{constant_context, Constant};\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::is_path_diagnostic_item;\n+use if_chain::if_chain;\n+use rustc_ast::LitKind;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::Ty;\n+use rustc_span::symbol::sym;\n+\n+use super::TRANSMUTING_NULL;\n+\n+const LINT_MSG: &str = \"transmuting a known null pointer into a reference\";\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arg: &'tcx Expr<'_>, to_ty: Ty<'tcx>) -> bool {\n+    if !to_ty.is_ref() {\n+        return false;\n+    }\n+\n+    // Catching transmute over constants that resolve to `null`.\n+    let mut const_eval_context = constant_context(cx, cx.typeck_results());\n+    if_chain! {\n+        if let ExprKind::Path(ref _qpath) = arg.kind;\n+        if let Some(Constant::RawPtr(x)) = const_eval_context.expr(arg);\n+        if x == 0;\n+        then {\n+            span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG);\n+            return true;\n+        }\n+    }\n+\n+    // Catching:\n+    // `std::mem::transmute(0 as *const i32)`\n+    if_chain! {\n+        if let ExprKind::Cast(inner_expr, _cast_ty) = arg.kind;\n+        if let ExprKind::Lit(ref lit) = inner_expr.kind;\n+        if let LitKind::Int(0, _) = lit.node;\n+        then {\n+            span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG);\n+            return true;\n+        }\n+    }\n+\n+    // Catching:\n+    // `std::mem::transmute(std::ptr::null::<i32>())`\n+    if_chain! {\n+        if let ExprKind::Call(func1, []) = arg.kind;\n+        if is_path_diagnostic_item(cx, func1, sym::ptr_null);\n+        then {\n+            span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG);\n+            return true;\n+        }\n+    }\n+\n+    // FIXME:\n+    // Also catch transmutations of variables which are known nulls.\n+    // To do this, MIR const propagation seems to be the better tool.\n+    // Whenever MIR const prop routines are more developed, this will\n+    // become available. As of this writing (25/03/19) it is not yet.\n+    false\n+}"}, {"sha": "7939dfedc3a2b4fb6d39555f29a3596828895861", "filename": "src/tools/clippy/clippy_lints/src/transmuting_null.rs", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmuting_null.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,89 +0,0 @@\n-use clippy_utils::consts::{constant_context, Constant};\n-use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::is_expr_diagnostic_item;\n-use if_chain::if_chain;\n-use rustc_ast::LitKind;\n-use rustc_hir::{Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::lint::in_external_macro;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::symbol::sym;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for transmute calls which would receive a null pointer.\n-    ///\n-    /// ### Why is this bad?\n-    /// Transmuting a null pointer is undefined behavior.\n-    ///\n-    /// ### Known problems\n-    /// Not all cases can be detected at the moment of this writing.\n-    /// For example, variables which hold a null pointer and are then fed to a `transmute`\n-    /// call, aren't detectable yet.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let null_ref: &u64 = unsafe { std::mem::transmute(0 as *const u64) };\n-    /// ```\n-    #[clippy::version = \"1.35.0\"]\n-    pub TRANSMUTING_NULL,\n-    correctness,\n-    \"transmutes from a null pointer to a reference, which is undefined behavior\"\n-}\n-\n-declare_lint_pass!(TransmutingNull => [TRANSMUTING_NULL]);\n-\n-const LINT_MSG: &str = \"transmuting a known null pointer into a reference\";\n-\n-impl<'tcx> LateLintPass<'tcx> for TransmutingNull {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if in_external_macro(cx.sess(), expr.span) {\n-            return;\n-        }\n-\n-        if_chain! {\n-            if let ExprKind::Call(func, [arg]) = expr.kind;\n-            if is_expr_diagnostic_item(cx, func, sym::transmute);\n-\n-            then {\n-                // Catching transmute over constants that resolve to `null`.\n-                let mut const_eval_context = constant_context(cx, cx.typeck_results());\n-                if_chain! {\n-                    if let ExprKind::Path(ref _qpath) = arg.kind;\n-                    if let Some(Constant::RawPtr(x)) = const_eval_context.expr(arg);\n-                    if x == 0;\n-                    then {\n-                        span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG)\n-                    }\n-                }\n-\n-                // Catching:\n-                // `std::mem::transmute(0 as *const i32)`\n-                if_chain! {\n-                    if let ExprKind::Cast(inner_expr, _cast_ty) = arg.kind;\n-                    if let ExprKind::Lit(ref lit) = inner_expr.kind;\n-                    if let LitKind::Int(0, _) = lit.node;\n-                    then {\n-                        span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG)\n-                    }\n-                }\n-\n-                // Catching:\n-                // `std::mem::transmute(std::ptr::null::<i32>())`\n-                if_chain! {\n-                    if let ExprKind::Call(func1, []) = arg.kind;\n-                    if is_expr_diagnostic_item(cx, func1, sym::ptr_null);\n-                    then {\n-                        span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG)\n-                    }\n-                }\n-\n-                // FIXME:\n-                // Also catch transmutations of variables which are known nulls.\n-                // To do this, MIR const propagation seems to be the better tool.\n-                // Whenever MIR const prop routines are more developed, this will\n-                // become available. As of this writing (25/03/19) it is not yet.\n-            }\n-        }\n-    }\n-}"}, {"sha": "8980283e5c82634ca1ded1a0a0be6db8672b3094", "filename": "src/tools/clippy/clippy_lints/src/unicode.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funicode.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,5 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::is_lint_allowed;\n+use clippy_utils::macros::span_is_local;\n use clippy_utils::source::snippet;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n@@ -98,6 +99,10 @@ fn escape<T: Iterator<Item = char>>(s: T) -> String {\n }\n \n fn check_str(cx: &LateContext<'_>, span: Span, id: HirId) {\n+    if !span_is_local(span) {\n+        return;\n+    }\n+\n     let string = snippet(cx, span, \"\");\n     if string.chars().any(|c| ['\\u{200B}', '\\u{ad}', '\\u{2060}'].contains(&c)) {\n         span_lint_and_sugg(\n@@ -113,6 +118,7 @@ fn check_str(cx: &LateContext<'_>, span: Span, id: HirId) {\n             Applicability::MachineApplicable,\n         );\n     }\n+\n     if string.chars().any(|c| c as u32 > 0x7F) {\n         span_lint_and_sugg(\n             cx,\n@@ -128,6 +134,7 @@ fn check_str(cx: &LateContext<'_>, span: Span, id: HirId) {\n             Applicability::MachineApplicable,\n         );\n     }\n+\n     if is_lint_allowed(cx, NON_ASCII_LITERAL, id) && string.chars().zip(string.nfc()).any(|(a, b)| a != b) {\n         span_lint_and_sugg(\n             cx,"}, {"sha": "9a41603f2f4ce1068d6dccbc2e61de037b7d3653", "filename": "src/tools/clippy/clippy_lints/src/uninit_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funinit_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funinit_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funinit_vec.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -45,7 +45,7 @@ declare_clippy_lint! {\n     ///    let mut vec: Vec<MaybeUninit<T>> = Vec::with_capacity(1000);\n     ///    vec.set_len(1000);  // `MaybeUninit` can be uninitialized\n     ///    ```\n-    /// 3. If you are on nightly, `Vec::spare_capacity_mut()` is available:\n+    /// 3. If you are on 1.60.0 or later, `Vec::spare_capacity_mut()` is available:\n     ///    ```rust,ignore\n     ///    let mut vec: Vec<u8> = Vec::with_capacity(1000);\n     ///    let remaining = vec.spare_capacity_mut();  // `&mut [MaybeUninit<u8>]`"}, {"sha": "88ca0cb20a12c59dc66bf903e31dd9962932f8c5", "filename": "src/tools/clippy/clippy_lints/src/unit_hash.rs", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_hash.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,78 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::source::snippet;\n-use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Detects `().hash(_)`.\n-    ///\n-    /// ### Why is this bad?\n-    /// Hashing a unit value doesn't do anything as the implementation of `Hash` for `()` is a no-op.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # use std::hash::Hash;\n-    /// # use std::collections::hash_map::DefaultHasher;\n-    /// # enum Foo { Empty, WithValue(u8) }\n-    /// # use Foo::*;\n-    /// # let mut state = DefaultHasher::new();\n-    /// # let my_enum = Foo::Empty;\n-    /// match my_enum {\n-    /// \tEmpty => ().hash(&mut state),\n-    /// \tWithValue(x) => x.hash(&mut state),\n-    /// }\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// # use std::hash::Hash;\n-    /// # use std::collections::hash_map::DefaultHasher;\n-    /// # enum Foo { Empty, WithValue(u8) }\n-    /// # use Foo::*;\n-    /// # let mut state = DefaultHasher::new();\n-    /// # let my_enum = Foo::Empty;\n-    /// match my_enum {\n-    /// \tEmpty => 0_u8.hash(&mut state),\n-    /// \tWithValue(x) => x.hash(&mut state),\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.58.0\"]\n-    pub UNIT_HASH,\n-    correctness,\n-    \"hashing a unit value, which does nothing\"\n-}\n-declare_lint_pass!(UnitHash => [UNIT_HASH]);\n-\n-impl<'tcx> LateLintPass<'tcx> for UnitHash {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if_chain! {\n-            if let ExprKind::MethodCall(name_ident, args, _) = &expr.kind;\n-            if name_ident.ident.name == sym::hash;\n-            if let [recv, state_param] = args;\n-            if cx.typeck_results().expr_ty(recv).is_unit();\n-            then {\n-                span_lint_and_then(\n-                    cx,\n-                    UNIT_HASH,\n-                    expr.span,\n-                    \"this call to `hash` on the unit type will do nothing\",\n-                    |diag| {\n-                        diag.span_suggestion(\n-                            expr.span,\n-                            \"remove the call to `hash` or consider using\",\n-                            format!(\n-                                \"0_u8.hash({})\",\n-                                snippet(cx, state_param.span, \"..\"),\n-                            ),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        diag.note(\"the implementation of `Hash` for `()` is a no-op\");\n-                    }\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "a5afbb8ff9da49272efd9887b20732ed221c0049", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_wraps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -130,7 +130,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n                         (\n                             ret_expr.span,\n                             if inner_type.is_unit() {\n-                                \"\".to_string()\n+                                String::new()\n                             } else {\n                                 snippet(cx, arg.span.source_callsite(), \"..\").to_string()\n                             }"}, {"sha": "ac73173697e8596bcc5b013f1b7d57e38fc28ab2", "filename": "src/tools/clippy/clippy_lints/src/unused_peekable.rs", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_peekable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_peekable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_peekable.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,225 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::ty::{match_type, peel_mid_ty_refs_is_mutable};\n+use clippy_utils::{fn_def_id, is_trait_method, path_to_local_id, paths, peel_ref_operators};\n+use rustc_ast::Mutability;\n+use rustc_hir::intravisit::{walk_expr, Visitor};\n+use rustc_hir::lang_items::LangItem;\n+use rustc_hir::{Block, Expr, ExprKind, HirId, Local, Node, PatKind, PathSegment, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for the creation of a `peekable` iterator that is never `.peek()`ed\n+    ///\n+    /// ### Why is this bad?\n+    /// Creating a peekable iterator without using any of its methods is likely a mistake,\n+    /// or just a leftover after a refactor.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let collection = vec![1, 2, 3];\n+    /// let iter = collection.iter().peekable();\n+    ///\n+    /// for item in iter {\n+    ///     // ...\n+    /// }\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// let collection = vec![1, 2, 3];\n+    /// let iter = collection.iter();\n+    ///\n+    /// for item in iter {\n+    ///     // ...\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.64.0\"]\n+    pub UNUSED_PEEKABLE,\n+    suspicious,\n+    \"creating a peekable iterator without using any of its methods\"\n+}\n+\n+declare_lint_pass!(UnusedPeekable => [UNUSED_PEEKABLE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for UnusedPeekable {\n+    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &Block<'tcx>) {\n+        // Don't lint `Peekable`s returned from a block\n+        if let Some(expr) = block.expr\n+            && let Some(ty) = cx.typeck_results().expr_ty_opt(peel_ref_operators(cx, expr))\n+            && match_type(cx, ty, &paths::PEEKABLE)\n+        {\n+            return;\n+        }\n+\n+        for (idx, stmt) in block.stmts.iter().enumerate() {\n+            if !stmt.span.from_expansion()\n+                && let StmtKind::Local(local) = stmt.kind\n+                && let PatKind::Binding(_, binding, ident, _) = local.pat.kind\n+                && let Some(init) = local.init\n+                && !init.span.from_expansion()\n+                && let Some(ty) = cx.typeck_results().expr_ty_opt(init)\n+                && let (ty, _, Mutability::Mut) = peel_mid_ty_refs_is_mutable(ty)\n+                && match_type(cx, ty, &paths::PEEKABLE)\n+            {\n+                let mut vis = PeekableVisitor::new(cx, binding);\n+\n+                if idx + 1 == block.stmts.len() && block.expr.is_none() {\n+                    return;\n+                }\n+\n+                for stmt in &block.stmts[idx..] {\n+                    vis.visit_stmt(stmt);\n+                }\n+\n+                if let Some(expr) = block.expr {\n+                    vis.visit_expr(expr);\n+                }\n+\n+                if !vis.found_peek_call {\n+                    span_lint_and_help(\n+                        cx,\n+                        UNUSED_PEEKABLE,\n+                        ident.span,\n+                        \"`peek` never called on `Peekable` iterator\",\n+                        None,\n+                        \"consider removing the call to `peekable`\"\n+                   );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct PeekableVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    expected_hir_id: HirId,\n+    found_peek_call: bool,\n+}\n+\n+impl<'a, 'tcx> PeekableVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>, expected_hir_id: HirId) -> Self {\n+        Self {\n+            cx,\n+            expected_hir_id,\n+            found_peek_call: false,\n+        }\n+    }\n+}\n+\n+impl<'tcx> Visitor<'_> for PeekableVisitor<'_, 'tcx> {\n+    fn visit_expr(&mut self, ex: &'_ Expr<'_>) {\n+        if self.found_peek_call {\n+            return;\n+        }\n+\n+        if path_to_local_id(ex, self.expected_hir_id) {\n+            for (_, node) in self.cx.tcx.hir().parent_iter(ex.hir_id) {\n+                match node {\n+                    Node::Expr(expr) => {\n+                        match expr.kind {\n+                            // some_function(peekable)\n+                            //\n+                            // If the Peekable is passed to a function, stop\n+                            ExprKind::Call(_, args) => {\n+                                if let Some(func_did) = fn_def_id(self.cx, expr)\n+                                    && let Ok(into_iter_did) = self\n+                                        .cx\n+                                        .tcx\n+                                        .lang_items()\n+                                        .require(LangItem::IntoIterIntoIter)\n+                                    && func_did == into_iter_did\n+                                {\n+                                    // Probably a for loop desugar, stop searching\n+                                    return;\n+                                }\n+\n+                                if args.iter().any(|arg| {\n+                                    matches!(arg.kind, ExprKind::Path(_)) && arg_is_mut_peekable(self.cx, arg)\n+                                }) {\n+                                    self.found_peek_call = true;\n+                                    return;\n+                                }\n+                            },\n+                            // Catch anything taking a Peekable mutably\n+                            ExprKind::MethodCall(\n+                                PathSegment {\n+                                    ident: method_name_ident,\n+                                    ..\n+                                },\n+                                [self_arg, remaining_args @ ..],\n+                                _,\n+                            ) => {\n+                                let method_name = method_name_ident.name.as_str();\n+\n+                                // `Peekable` methods\n+                                if matches!(method_name, \"peek\" | \"peek_mut\" | \"next_if\" | \"next_if_eq\")\n+                                    && arg_is_mut_peekable(self.cx, self_arg)\n+                                {\n+                                    self.found_peek_call = true;\n+                                    return;\n+                                }\n+\n+                                // foo.some_method() excluding Iterator methods\n+                                if remaining_args.iter().any(|arg| arg_is_mut_peekable(self.cx, arg))\n+                                    && !is_trait_method(self.cx, expr, sym::Iterator)\n+                                {\n+                                    self.found_peek_call = true;\n+                                    return;\n+                                }\n+\n+                                // foo.by_ref(), keep checking for `peek`\n+                                if method_name == \"by_ref\" {\n+                                    continue;\n+                                }\n+\n+                                return;\n+                            },\n+                            ExprKind::AddrOf(_, Mutability::Mut, _) | ExprKind::Unary(..) | ExprKind::DropTemps(_) => {\n+                            },\n+                            ExprKind::AddrOf(_, Mutability::Not, _) => return,\n+                            _ => {\n+                                self.found_peek_call = true;\n+                                return;\n+                            },\n+                        }\n+                    },\n+                    Node::Local(Local { init: Some(init), .. }) => {\n+                        if arg_is_mut_peekable(self.cx, init) {\n+                            self.found_peek_call = true;\n+                            return;\n+                        }\n+\n+                        break;\n+                    },\n+                    Node::Stmt(stmt) => match stmt.kind {\n+                        StmtKind::Expr(_) | StmtKind::Semi(_) => {},\n+                        _ => {\n+                            self.found_peek_call = true;\n+                            return;\n+                        },\n+                    },\n+                    Node::Block(_) | Node::ExprField(_) => {},\n+                    _ => {\n+                        break;\n+                    },\n+                }\n+            }\n+        }\n+\n+        walk_expr(self, ex);\n+    }\n+}\n+\n+fn arg_is_mut_peekable(cx: &LateContext<'_>, arg: &Expr<'_>) -> bool {\n+    if let Some(ty) = cx.typeck_results().expr_ty_opt(arg)\n+        && let (ty, _, Mutability::Mut) = peel_mid_ty_refs_is_mutable(ty)\n+        && match_type(cx, ty, &paths::PEEKABLE)\n+    {\n+        true\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "b8a5d4ea8c9fbe177429781c403313046f752194", "filename": "src/tools/clippy/clippy_lints/src/unused_rounding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_rounding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_rounding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_rounding.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -22,7 +22,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// let x = 1f32;\n     /// ```\n-    #[clippy::version = \"1.62.0\"]\n+    #[clippy::version = \"1.63.0\"]\n     pub UNUSED_ROUNDING,\n     nursery,\n     \"Uselessly rounding a whole number floating-point literal\""}, {"sha": "84e65d5fa0b719044d3d43705141e5656aa9f63e", "filename": "src/tools/clippy/clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -350,7 +350,7 @@ define_Conf! {\n     /// Lint: DISALLOWED_SCRIPT_IDENTS.\n     ///\n     /// The list of unicode scripts allowed to be used in the scope.\n-    (allowed_scripts: Vec<String> = [\"Latin\"].iter().map(ToString::to_string).collect()),\n+    (allowed_scripts: Vec<String> = vec![\"Latin\".to_string()]),\n     /// Lint: NON_SEND_FIELDS_IN_SEND_TY.\n     ///\n     /// Whether to apply the raw pointer heuristic to determine if a type is `Send`.\n@@ -379,6 +379,10 @@ define_Conf! {\n     ///\n     /// Whether `dbg!` should be allowed in test functions\n     (allow_dbg_in_tests: bool = false),\n+    /// Lint: RESULT_LARGE_ERR\n+    ///\n+    /// The maximum size of the `Err`-variant in a `Result` returned from a function\n+    (large_error_threshold: u64 = 128),\n }\n \n /// Search for the configuration file."}, {"sha": "eb34085a2abf3a5e5631bf182173a33cb14abb9c", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -593,8 +593,8 @@ fn extract_clippy_version_value(cx: &LateContext<'_>, item: &'_ Item<'_>) -> Opt\n     attrs.iter().find_map(|attr| {\n         if_chain! {\n             // Identify attribute\n-            if let ast::AttrKind::Normal(ref attr_kind, _) = &attr.kind;\n-            if let [tool_name, attr_name] = &attr_kind.path.segments[..];\n+            if let ast::AttrKind::Normal(ref attr_kind) = &attr.kind;\n+            if let [tool_name, attr_name] = &attr_kind.item.path.segments[..];\n             if tool_name.ident.name == sym::clippy;\n             if attr_name.ident.name == sym::version;\n             if let Some(version) = attr.value_str();"}, {"sha": "b1148bccc2a283d025cb530f18197437bfbe9079", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -797,7 +797,7 @@ fn get_lint_group_and_level_or_lint(\n     let result = cx.lint_store.check_lint_name(\n         lint_name,\n         Some(sym::clippy),\n-        &[Ident::with_dummy_span(sym::clippy)].into_iter().collect(),\n+        &std::iter::once(Ident::with_dummy_span(sym::clippy)).collect(),\n     );\n     if let CheckLintNameResult::Tool(Ok(lint_lst)) = result {\n         if let Some(group) = get_lint_group(cx, lint_lst[0]) {"}, {"sha": "0fee3e812d286db1a143c583455b8e12a8e00062", "filename": "src/tools/clippy/clippy_lints/src/vec_resize_to_zero.rs", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_resize_to_zero.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,64 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::{match_def_path, paths};\n-use if_chain::if_chain;\n-use rustc_ast::LitKind;\n-use rustc_errors::Applicability;\n-use rustc_hir as hir;\n-use rustc_hir::{Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Spanned;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Finds occurrences of `Vec::resize(0, an_int)`\n-    ///\n-    /// ### Why is this bad?\n-    /// This is probably an argument inversion mistake.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// vec!(1, 2, 3, 4, 5).resize(0, 5)\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// vec!(1, 2, 3, 4, 5).clear()\n-    /// ```\n-    #[clippy::version = \"1.46.0\"]\n-    pub VEC_RESIZE_TO_ZERO,\n-    correctness,\n-    \"emptying a vector with `resize(0, an_int)` instead of `clear()` is probably an argument inversion mistake\"\n-}\n-\n-declare_lint_pass!(VecResizeToZero => [VEC_RESIZE_TO_ZERO]);\n-\n-impl<'tcx> LateLintPass<'tcx> for VecResizeToZero {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let hir::ExprKind::MethodCall(path_segment, args, _) = expr.kind;\n-            if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n-            if match_def_path(cx, method_def_id, &paths::VEC_RESIZE) && args.len() == 3;\n-            if let ExprKind::Lit(Spanned { node: LitKind::Int(0, _), .. }) = args[1].kind;\n-            if let ExprKind::Lit(Spanned { node: LitKind::Int(..), .. }) = args[2].kind;\n-            then {\n-                let method_call_span = expr.span.with_lo(path_segment.ident.span.lo());\n-                span_lint_and_then(\n-                    cx,\n-                    VEC_RESIZE_TO_ZERO,\n-                    expr.span,\n-                    \"emptying a vector with `resize`\",\n-                    |db| {\n-                        db.help(\"the arguments may be inverted...\");\n-                        db.span_suggestion(\n-                            method_call_span,\n-                            \"...or you can empty the vector with\",\n-                            \"clear()\".to_string(),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    },\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "afd0077a658049160feb972d23c7a0391769602c", "filename": "src/tools/clippy/clippy_lints/src/verbose_file_reads.rs", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fverbose_file_reads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fverbose_file_reads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fverbose_file_reads.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,88 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::paths;\n-use clippy_utils::ty::match_type;\n-use if_chain::if_chain;\n-use rustc_hir::{Expr, ExprKind, QPath};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for use of File::read_to_end and File::read_to_string.\n-    ///\n-    /// ### Why is this bad?\n-    /// `fs::{read, read_to_string}` provide the same functionality when `buf` is empty with fewer imports and no intermediate values.\n-    /// See also: [fs::read docs](https://doc.rust-lang.org/std/fs/fn.read.html), [fs::read_to_string docs](https://doc.rust-lang.org/std/fs/fn.read_to_string.html)\n-    ///\n-    /// ### Example\n-    /// ```rust,no_run\n-    /// # use std::io::Read;\n-    /// # use std::fs::File;\n-    /// let mut f = File::open(\"foo.txt\").unwrap();\n-    /// let mut bytes = Vec::new();\n-    /// f.read_to_end(&mut bytes).unwrap();\n-    /// ```\n-    /// Can be written more concisely as\n-    /// ```rust,no_run\n-    /// # use std::fs;\n-    /// let mut bytes = fs::read(\"foo.txt\").unwrap();\n-    /// ```\n-    #[clippy::version = \"1.44.0\"]\n-    pub VERBOSE_FILE_READS,\n-    restriction,\n-    \"use of `File::read_to_end` or `File::read_to_string`\"\n-}\n-\n-declare_lint_pass!(VerboseFileReads => [VERBOSE_FILE_READS]);\n-\n-impl<'tcx> LateLintPass<'tcx> for VerboseFileReads {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if is_file_read_to_end(cx, expr) {\n-            span_lint_and_help(\n-                cx,\n-                VERBOSE_FILE_READS,\n-                expr.span,\n-                \"use of `File::read_to_end`\",\n-                None,\n-                \"consider using `fs::read` instead\",\n-            );\n-        } else if is_file_read_to_string(cx, expr) {\n-            span_lint_and_help(\n-                cx,\n-                VERBOSE_FILE_READS,\n-                expr.span,\n-                \"use of `File::read_to_string`\",\n-                None,\n-                \"consider using `fs::read_to_string` instead\",\n-            );\n-        }\n-    }\n-}\n-\n-fn is_file_read_to_end<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    if_chain! {\n-        if let ExprKind::MethodCall(method_name, [recv, ..], _) = expr.kind;\n-        if method_name.ident.as_str() == \"read_to_end\";\n-        if let ExprKind::Path(QPath::Resolved(None, _)) = &recv.kind;\n-        let ty = cx.typeck_results().expr_ty(recv);\n-        if match_type(cx, ty, &paths::FILE);\n-        then {\n-            return true\n-        }\n-    }\n-    false\n-}\n-\n-fn is_file_read_to_string<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    if_chain! {\n-        if let ExprKind::MethodCall(method_name, exprs, _) = expr.kind;\n-        if method_name.ident.as_str() == \"read_to_string\";\n-        if let ExprKind::Path(QPath::Resolved(None, _)) = &exprs[0].kind;\n-        let ty = cx.typeck_results().expr_ty(&exprs[0]);\n-        if match_type(cx, ty, &paths::FILE);\n-        then {\n-            return true\n-        }\n-    }\n-    false\n-}"}, {"sha": "5533840b166f8c783c94e076b25d670bf26fbe71", "filename": "src/tools/clippy/clippy_lints/src/write.rs", "status": "modified", "additions": 123, "deletions": 6, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -3,8 +3,9 @@ use std::iter;\n use std::ops::{Deref, Range};\n \n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::source::{snippet_opt, snippet_with_applicability};\n+use clippy_utils::source::{snippet, snippet_opt, snippet_with_applicability};\n use rustc_ast::ast::{Expr, ExprKind, Impl, Item, ItemKind, MacCall, Path, StrLit, StrStyle};\n+use rustc_ast::ptr::P;\n use rustc_ast::token::{self, LitKind};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n@@ -256,6 +257,28 @@ declare_clippy_lint! {\n     \"writing a literal with a format string\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// This lint warns when a named parameter in a format string is used as a positional one.\n+    ///\n+    /// ### Why is this bad?\n+    /// It may be confused for an assignment and obfuscates which parameter is being used.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// println!(\"{}\", x = 10);\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// println!(\"{x}\", x = 10);\n+    /// ```\n+    #[clippy::version = \"1.63.0\"]\n+    pub POSITIONAL_NAMED_FORMAT_PARAMETERS,\n+    suspicious,\n+    \"named parameter in a format string is used positionally\"\n+}\n+\n #[derive(Default)]\n pub struct Write {\n     in_debug_impl: bool,\n@@ -270,7 +293,8 @@ impl_lint_pass!(Write => [\n     PRINT_LITERAL,\n     WRITE_WITH_NEWLINE,\n     WRITELN_EMPTY_STRING,\n-    WRITE_LITERAL\n+    WRITE_LITERAL,\n+    POSITIONAL_NAMED_FORMAT_PARAMETERS,\n ]);\n \n impl EarlyLintPass for Write {\n@@ -408,6 +432,7 @@ fn newline_span(fmtstr: &StrLit) -> (Span, bool) {\n #[derive(Default)]\n struct SimpleFormatArgs {\n     unnamed: Vec<Vec<Span>>,\n+    complex_unnamed: Vec<Vec<Span>>,\n     named: Vec<(Symbol, Vec<Span>)>,\n }\n impl SimpleFormatArgs {\n@@ -419,6 +444,10 @@ impl SimpleFormatArgs {\n         })\n     }\n \n+    fn get_complex_unnamed(&self) -> impl Iterator<Item = &[Span]> {\n+        self.complex_unnamed.iter().map(Vec::as_slice)\n+    }\n+\n     fn get_named(&self, n: &Path) -> &[Span] {\n         self.named.iter().find(|x| *n == x.0).map_or(&[], |x| x.1.as_slice())\n     }\n@@ -479,6 +508,61 @@ impl SimpleFormatArgs {\n             },\n         };\n     }\n+\n+    fn push_to_complex(&mut self, span: Span, position: usize) {\n+        if self.complex_unnamed.len() <= position {\n+            self.complex_unnamed.resize_with(position, Vec::new);\n+            self.complex_unnamed.push(vec![span]);\n+        } else {\n+            let args: &mut Vec<Span> = &mut self.complex_unnamed[position];\n+            args.push(span);\n+        }\n+    }\n+\n+    fn push_complex(\n+        &mut self,\n+        cx: &EarlyContext<'_>,\n+        arg: rustc_parse_format::Argument<'_>,\n+        str_lit_span: Span,\n+        fmt_span: Span,\n+    ) {\n+        use rustc_parse_format::{ArgumentImplicitlyIs, ArgumentIs, CountIsParam};\n+\n+        let snippet = snippet_opt(cx, fmt_span);\n+\n+        let end = snippet\n+            .as_ref()\n+            .and_then(|s| s.find(':'))\n+            .or_else(|| fmt_span.hi().0.checked_sub(fmt_span.lo().0 + 1).map(|u| u as usize));\n+\n+        if let (ArgumentIs(n) | ArgumentImplicitlyIs(n), Some(end)) = (arg.position, end) {\n+            let span = fmt_span.from_inner(InnerSpan::new(1, end));\n+            self.push_to_complex(span, n);\n+        };\n+\n+        if let (CountIsParam(n), Some(span)) = (arg.format.precision, arg.format.precision_span) {\n+            // We need to do this hack as precision spans should be converted from .* to .foo$\n+            let hack = if snippet.as_ref().and_then(|s| s.find('*')).is_some() {\n+                0\n+            } else {\n+                1\n+            };\n+\n+            let span = str_lit_span.from_inner(InnerSpan {\n+                start: span.start + 1,\n+                end: span.end - hack,\n+            });\n+            self.push_to_complex(span, n);\n+        };\n+\n+        if let (CountIsParam(n), Some(span)) = (arg.format.width, arg.format.width_span) {\n+            let span = str_lit_span.from_inner(InnerSpan {\n+                start: span.start,\n+                end: span.end - 1,\n+            });\n+            self.push_to_complex(span, n);\n+        };\n+    }\n }\n \n impl Write {\n@@ -511,8 +595,8 @@ impl Write {\n                 // FIXME: modify rustc's fmt string parser to give us the current span\n                 span_lint(cx, USE_DEBUG, span, \"use of `Debug`-based formatting\");\n             }\n-\n             args.push(arg, span);\n+            args.push_complex(cx, arg, str_lit.span, span);\n         }\n \n         parser.errors.is_empty().then_some(args)\n@@ -566,6 +650,7 @@ impl Write {\n \n         let lint = if is_write { WRITE_LITERAL } else { PRINT_LITERAL };\n         let mut unnamed_args = args.get_unnamed();\n+        let mut complex_unnamed_args = args.get_complex_unnamed();\n         loop {\n             if !parser.eat(&token::Comma) {\n                 return (Some(fmtstr), expr);\n@@ -577,11 +662,20 @@ impl Write {\n             } else {\n                 return (Some(fmtstr), None);\n             };\n+            let complex_unnamed_arg = complex_unnamed_args.next();\n+\n             let (fmt_spans, lit) = match &token_expr.kind {\n                 ExprKind::Lit(lit) => (unnamed_args.next().unwrap_or(&[]), lit),\n-                ExprKind::Assign(lhs, rhs, _) => match (&lhs.kind, &rhs.kind) {\n-                    (ExprKind::Path(_, p), ExprKind::Lit(lit)) => (args.get_named(p), lit),\n-                    _ => continue,\n+                ExprKind::Assign(lhs, rhs, _) => {\n+                    if let Some(span) = complex_unnamed_arg {\n+                        for x in span {\n+                            Self::report_positional_named_param(cx, *x, lhs, rhs);\n+                        }\n+                    }\n+                    match (&lhs.kind, &rhs.kind) {\n+                        (ExprKind::Path(_, p), ExprKind::Lit(lit)) => (args.get_named(p), lit),\n+                        _ => continue,\n+                    }\n                 },\n                 _ => {\n                     unnamed_args.next();\n@@ -637,6 +731,29 @@ impl Write {\n         }\n     }\n \n+    fn report_positional_named_param(cx: &EarlyContext<'_>, span: Span, lhs: &P<Expr>, _rhs: &P<Expr>) {\n+        if let ExprKind::Path(_, _p) = &lhs.kind {\n+            let mut applicability = Applicability::MachineApplicable;\n+            let name = snippet_with_applicability(cx, lhs.span, \"name\", &mut applicability);\n+            // We need to do this hack as precision spans should be converted from .* to .foo$\n+            let hack = snippet(cx, span, \"\").contains('*');\n+\n+            span_lint_and_sugg(\n+                cx,\n+                POSITIONAL_NAMED_FORMAT_PARAMETERS,\n+                span,\n+                &format!(\"named parameter {} is used as a positional parameter\", name),\n+                \"replace it with\",\n+                if hack {\n+                    format!(\"{}$\", name)\n+                } else {\n+                    format!(\"{}\", name)\n+                },\n+                applicability,\n+            );\n+        };\n+    }\n+\n     fn lint_println_empty_string(&self, cx: &EarlyContext<'_>, mac: &MacCall) {\n         if let (Some(fmt_str), _) = self.check_tts(cx, mac.args.inner_tokens(), false) {\n             if fmt_str.symbol == kw::Empty {"}, {"sha": "c36bca06507d67b8544dd51850235166b9cf0015", "filename": "src/tools/clippy/clippy_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -7,6 +7,7 @@ publish = false\n [dependencies]\n arrayvec = { version = \"0.7\", default-features = false }\n if_chain = \"1.0\"\n+itertools = \"0.10.1\"\n rustc-semver = \"1.1\"\n \n [features]"}, {"sha": "997e773b5da4eecc3cf2ea61ae2dc0a1f131c552", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -28,6 +28,7 @@ extern crate rustc_infer;\n extern crate rustc_lexer;\n extern crate rustc_lint;\n extern crate rustc_middle;\n+extern crate rustc_parse_format;\n extern crate rustc_session;\n extern crate rustc_span;\n extern crate rustc_target;\n@@ -87,6 +88,7 @@ use rustc_hir::{\n     Mutability, Node, Param, Pat, PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind, TraitItem, TraitItemKind,\n     TraitRef, TyKind, UnOp,\n };\n+use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::place::PlaceBase;\n use rustc_middle::ty as rustc_ty;\n@@ -104,6 +106,7 @@ use rustc_semver::RustcVersion;\n use rustc_session::Session;\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::source_map::original_sp;\n+use rustc_span::source_map::SourceMap;\n use rustc_span::sym;\n use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n@@ -372,15 +375,19 @@ pub fn match_qpath(path: &QPath<'_>, segments: &[&str]) -> bool {\n \n /// If the expression is a path, resolves it to a `DefId` and checks if it matches the given path.\n ///\n-/// Please use `is_expr_diagnostic_item` if the target is a diagnostic item.\n+/// Please use `is_path_diagnostic_item` if the target is a diagnostic item.\n pub fn is_expr_path_def_path(cx: &LateContext<'_>, expr: &Expr<'_>, segments: &[&str]) -> bool {\n     path_def_id(cx, expr).map_or(false, |id| match_def_path(cx, id, segments))\n }\n \n-/// If the expression is a path, resolves it to a `DefId` and checks if it matches the given\n-/// diagnostic item.\n-pub fn is_expr_diagnostic_item(cx: &LateContext<'_>, expr: &Expr<'_>, diag_item: Symbol) -> bool {\n-    path_def_id(cx, expr).map_or(false, |id| cx.tcx.is_diagnostic_item(diag_item, id))\n+/// If `maybe_path` is a path node which resolves to an item, resolves it to a `DefId` and checks if\n+/// it matches the given diagnostic item.\n+pub fn is_path_diagnostic_item<'tcx>(\n+    cx: &LateContext<'_>,\n+    maybe_path: &impl MaybePath<'tcx>,\n+    diag_item: Symbol,\n+) -> bool {\n+    path_def_id(cx, maybe_path).map_or(false, |id| cx.tcx.is_diagnostic_item(diag_item, id))\n }\n \n /// THIS METHOD IS DEPRECATED and will eventually be removed since it does not match against the\n@@ -2274,6 +2281,18 @@ pub fn walk_to_expr_usage<'tcx, T>(\n     None\n }\n \n+/// Checks whether a given span has any comment token\n+/// This checks for all types of comment: line \"//\", block \"/**\", doc \"///\" \"//!\"\n+pub fn span_contains_comment(sm: &SourceMap, span: Span) -> bool {\n+    let Ok(snippet) = sm.span_to_snippet(span) else { return false };\n+    return tokenize(&snippet).any(|token| {\n+        matches!(\n+            token.kind,\n+            TokenKind::BlockComment { .. } | TokenKind::LineComment { .. }\n+        )\n+    });\n+}\n+\n macro_rules! op_utils {\n     ($($name:ident $assign:ident)*) => {\n         /// Binary operation traits like `LangItem::Add`"}, {"sha": "e5ca35455404885139db2c6e5a7f27d8276a83e7", "filename": "src/tools/clippy/clippy_utils/src/macros.rs", "status": "modified", "additions": 494, "deletions": 180, "changes": 674, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmacros.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,16 +1,21 @@\n #![allow(clippy::similar_names)] // `expr` and `expn`\n \n+use crate::is_path_diagnostic_item;\n+use crate::source::snippet_opt;\n use crate::visitors::expr_visitor_no_bodies;\n \n use arrayvec::ArrayVec;\n-use if_chain::if_chain;\n+use itertools::{izip, Either, Itertools};\n use rustc_ast::ast::LitKind;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::{self as hir, Expr, ExprKind, HirId, Node, QPath};\n+use rustc_lexer::unescape::unescape_literal;\n+use rustc_lexer::{tokenize, unescape, LiteralKind, TokenKind};\n use rustc_lint::LateContext;\n+use rustc_parse_format::{self as rpf, Alignment};\n use rustc_span::def_id::DefId;\n use rustc_span::hygiene::{self, MacroKind, SyntaxContext};\n-use rustc_span::{sym, ExpnData, ExpnId, ExpnKind, Span, Symbol};\n+use rustc_span::{sym, BytePos, ExpnData, ExpnId, ExpnKind, Pos, Span, SpanData, Symbol};\n use std::ops::ControlFlow;\n \n const FORMAT_MACRO_DIAG_ITEMS: &[Symbol] = &[\n@@ -332,121 +337,495 @@ fn is_assert_arg(cx: &LateContext<'_>, expr: &Expr<'_>, assert_expn: ExpnId) ->\n     }\n }\n \n-/// A parsed `format_args!` expansion\n+/// The format string doesn't exist in the HIR, so we reassemble it from source code\n #[derive(Debug)]\n-pub struct FormatArgsExpn<'tcx> {\n-    /// Span of the first argument, the format string\n-    pub format_string_span: Span,\n-    /// The format string split by formatted args like `{..}`\n-    pub format_string_parts: Vec<Symbol>,\n-    /// Values passed after the format string\n-    pub value_args: Vec<&'tcx Expr<'tcx>>,\n-    /// Each element is a `value_args` index and a formatting trait (e.g. `sym::Debug`)\n-    pub formatters: Vec<(usize, Symbol)>,\n-    /// List of `fmt::v1::Argument { .. }` expressions. If this is empty,\n-    /// then `formatters` represents the format args (`{..}`).\n-    /// If this is non-empty, it represents the format args, and the `position`\n-    /// parameters within the struct expressions are indexes of `formatters`.\n-    pub specs: Vec<&'tcx Expr<'tcx>>,\n+pub struct FormatString {\n+    /// Span of the whole format string literal, including `[r#]\"`.\n+    pub span: Span,\n+    /// Snippet of the whole format string literal, including `[r#]\"`.\n+    pub snippet: String,\n+    /// If the string is raw `r\"...\"`/`r#\"\"#`, how many `#`s does it have on each side.\n+    pub style: Option<usize>,\n+    /// The unescaped value of the format string, e.g. `\"val \u2013 {}\"` for the literal\n+    /// `\"val \\u{2013} {}\"`.\n+    pub unescaped: String,\n+    /// The format string split by format args like `{..}`.\n+    pub parts: Vec<Symbol>,\n }\n \n-impl<'tcx> FormatArgsExpn<'tcx> {\n-    /// Parses an expanded `format_args!` or `format_args_nl!` invocation\n-    pub fn parse(cx: &LateContext<'_>, expr: &'tcx Expr<'tcx>) -> Option<Self> {\n-        macro_backtrace(expr.span).find(|macro_call| {\n-            matches!(\n-                cx.tcx.item_name(macro_call.def_id),\n-                sym::const_format_args | sym::format_args | sym::format_args_nl\n-            )\n-        })?;\n-        let mut format_string_span: Option<Span> = None;\n-        let mut format_string_parts: Vec<Symbol> = Vec::new();\n-        let mut value_args: Vec<&Expr<'_>> = Vec::new();\n-        let mut formatters: Vec<(usize, Symbol)> = Vec::new();\n-        let mut specs: Vec<&Expr<'_>> = Vec::new();\n-        expr_visitor_no_bodies(|e| {\n-            // if we're still inside of the macro definition...\n-            if e.span.ctxt() == expr.span.ctxt() {\n-                // ArgumentV1::new_<format_trait>(<value>)\n-                if_chain! {\n-                    if let ExprKind::Call(callee, [val]) = e.kind;\n-                    if let ExprKind::Path(QPath::TypeRelative(ty, seg)) = callee.kind;\n-                    if let hir::TyKind::Path(QPath::Resolved(_, path)) = ty.kind;\n-                    if path.segments.last().unwrap().ident.name == sym::ArgumentV1;\n-                    if seg.ident.name.as_str().starts_with(\"new_\");\n-                    then {\n-                        let val_idx = if_chain! {\n-                            if val.span.ctxt() == expr.span.ctxt();\n-                            if let ExprKind::Field(_, field) = val.kind;\n-                            if let Ok(idx) = field.name.as_str().parse();\n-                            then {\n-                                // tuple index\n-                                idx\n-                            } else {\n-                                // assume the value expression is passed directly\n-                                formatters.len()\n-                            }\n-                        };\n-                        let fmt_trait = match seg.ident.name.as_str() {\n-                            \"new_display\" => \"Display\",\n-                            \"new_debug\" => \"Debug\",\n-                            \"new_lower_exp\" => \"LowerExp\",\n-                            \"new_upper_exp\" => \"UpperExp\",\n-                            \"new_octal\" => \"Octal\",\n-                            \"new_pointer\" => \"Pointer\",\n-                            \"new_binary\" => \"Binary\",\n-                            \"new_lower_hex\" => \"LowerHex\",\n-                            \"new_upper_hex\" => \"UpperHex\",\n-                            _ => unreachable!(),\n-                        };\n-                        formatters.push((val_idx, Symbol::intern(fmt_trait)));\n-                    }\n-                }\n-                if let ExprKind::Struct(QPath::Resolved(_, path), ..) = e.kind {\n-                    if path.segments.last().unwrap().ident.name == sym::Argument {\n-                        specs.push(e);\n-                    }\n+impl FormatString {\n+    fn new(cx: &LateContext<'_>, pieces: &Expr<'_>) -> Option<Self> {\n+        // format_args!(r\"a {} b \\\", 1);\n+        //\n+        // expands to\n+        //\n+        // ::core::fmt::Arguments::new_v1(&[\"a \", \" b \\\\\"],\n+        //      &[::core::fmt::ArgumentV1::new_display(&1)]);\n+        //\n+        // where `pieces` is the expression `&[\"a \", \" b \\\\\"]`. It has the span of `r\"a {} b \\\"`\n+        let span = pieces.span;\n+        let snippet = snippet_opt(cx, span)?;\n+\n+        let (inner, style) = match tokenize(&snippet).next()?.kind {\n+            TokenKind::Literal { kind, .. } => {\n+                let style = match kind {\n+                    LiteralKind::Str { .. } => None,\n+                    LiteralKind::RawStr { n_hashes: Some(n), .. } => Some(n.into()),\n+                    _ => return None,\n+                };\n+\n+                let start = style.map_or(1, |n| 2 + n);\n+                let end = snippet.len() - style.map_or(1, |n| 1 + n);\n+\n+                (&snippet[start..end], style)\n+            },\n+            _ => return None,\n+        };\n+\n+        let mode = if style.is_some() {\n+            unescape::Mode::RawStr\n+        } else {\n+            unescape::Mode::Str\n+        };\n+\n+        let mut unescaped = String::with_capacity(inner.len());\n+        unescape_literal(inner, mode, &mut |_, ch| {\n+            unescaped.push(ch.unwrap());\n+        });\n+\n+        let mut parts = Vec::new();\n+        expr_visitor_no_bodies(|expr| {\n+            if let ExprKind::Lit(lit) = &expr.kind {\n+                if let LitKind::Str(symbol, _) = lit.node {\n+                    parts.push(symbol);\n                 }\n-                // walk through the macro expansion\n-                return true;\n             }\n-            // assume that the first expr with a differing context represents\n-            // (and has the span of) the format string\n-            if format_string_span.is_none() {\n-                format_string_span = Some(e.span);\n-                let span = e.span;\n-                // walk the expr and collect string literals which are format string parts\n-                expr_visitor_no_bodies(|e| {\n-                    if e.span.ctxt() != span.ctxt() {\n-                        // defensive check, probably doesn't happen\n-                        return false;\n-                    }\n-                    if let ExprKind::Lit(lit) = &e.kind {\n-                        if let LitKind::Str(symbol, _s) = lit.node {\n-                            format_string_parts.push(symbol);\n-                        }\n-                    }\n-                    true\n-                })\n-                .visit_expr(e);\n+\n+            true\n+        })\n+        .visit_expr(pieces);\n+\n+        Some(Self {\n+            span,\n+            snippet,\n+            style,\n+            unescaped,\n+            parts,\n+        })\n+    }\n+}\n+\n+struct FormatArgsValues<'tcx> {\n+    /// See `FormatArgsExpn::value_args`\n+    value_args: Vec<&'tcx Expr<'tcx>>,\n+    /// Maps an `rt::v1::Argument::position` or an `rt::v1::Count::Param` to its index in\n+    /// `value_args`\n+    pos_to_value_index: Vec<usize>,\n+    /// Used to check if a value is declared inline & to resolve `InnerSpan`s.\n+    format_string_span: SpanData,\n+}\n+\n+impl<'tcx> FormatArgsValues<'tcx> {\n+    fn new(args: &'tcx Expr<'tcx>, format_string_span: SpanData) -> Self {\n+        let mut pos_to_value_index = Vec::new();\n+        let mut value_args = Vec::new();\n+        expr_visitor_no_bodies(|expr| {\n+            if expr.span.ctxt() == args.span.ctxt() {\n+                // ArgumentV1::new_<format_trait>(<val>)\n+                // ArgumentV1::from_usize(<val>)\n+                if let ExprKind::Call(callee, [val]) = expr.kind\n+                    && let ExprKind::Path(QPath::TypeRelative(ty, _)) = callee.kind\n+                    && let hir::TyKind::Path(QPath::Resolved(_, path)) = ty.kind\n+                    && path.segments.last().unwrap().ident.name == sym::ArgumentV1\n+                {\n+                    let val_idx = if val.span.ctxt() == expr.span.ctxt()\n+                        && let ExprKind::Field(_, field) = val.kind\n+                        && let Ok(idx) = field.name.as_str().parse()\n+                    {\n+                        // tuple index\n+                        idx\n+                    } else {\n+                        // assume the value expression is passed directly\n+                        pos_to_value_index.len()\n+                    };\n+\n+                    pos_to_value_index.push(val_idx);\n+                }\n+\n+                true\n             } else {\n-                // assume that any further exprs with a differing context are value args\n-                value_args.push(e);\n+                // assume that any expr with a differing span is a value\n+                value_args.push(expr);\n+\n+                false\n             }\n-            // don't walk anything not from the macro expansion (e.a. inputs)\n-            false\n         })\n-        .visit_expr(expr);\n-        Some(FormatArgsExpn {\n-            format_string_span: format_string_span?,\n-            format_string_parts,\n+        .visit_expr(args);\n+\n+        Self {\n             value_args,\n-            formatters,\n-            specs,\n+            pos_to_value_index,\n+            format_string_span,\n+        }\n+    }\n+}\n+\n+/// The positions of a format argument's value, precision and width\n+///\n+/// A position is an index into the second argument of `Arguments::new_v1[_formatted]`\n+#[derive(Debug, Default, Copy, Clone)]\n+struct ParamPosition {\n+    /// The position stored in `rt::v1::Argument::position`.\n+    value: usize,\n+    /// The position stored in `rt::v1::FormatSpec::width` if it is a `Count::Param`.\n+    width: Option<usize>,\n+    /// The position stored in `rt::v1::FormatSpec::precision` if it is a `Count::Param`.\n+    precision: Option<usize>,\n+}\n+\n+/// Parses the `fmt` arg of `Arguments::new_v1_formatted(pieces, args, fmt, _)`\n+fn parse_rt_fmt<'tcx>(fmt_arg: &'tcx Expr<'tcx>) -> Option<impl Iterator<Item = ParamPosition> + 'tcx> {\n+    fn parse_count(expr: &Expr<'_>) -> Option<usize> {\n+        // ::core::fmt::rt::v1::Count::Param(1usize),\n+        if let ExprKind::Call(ctor, [val]) = expr.kind\n+            && let ExprKind::Path(QPath::Resolved(_, path)) = ctor.kind\n+            && path.segments.last()?.ident.name == sym::Param\n+            && let ExprKind::Lit(lit) = &val.kind\n+            && let LitKind::Int(pos, _) = lit.node\n+        {\n+            Some(pos as usize)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    if let ExprKind::AddrOf(.., array) = fmt_arg.kind\n+        && let ExprKind::Array(specs) = array.kind\n+    {\n+        Some(specs.iter().map(|spec| {\n+            let mut position = ParamPosition::default();\n+\n+            // ::core::fmt::rt::v1::Argument {\n+            //     position: 0usize,\n+            //     format: ::core::fmt::rt::v1::FormatSpec {\n+            //         ..\n+            //         precision: ::core::fmt::rt::v1::Count::Implied,\n+            //         width: ::core::fmt::rt::v1::Count::Implied,\n+            //     },\n+            // }\n+\n+            // TODO: this can be made much nicer next sync with `Visitor::visit_expr_field`\n+            if let ExprKind::Struct(_, fields, _) = spec.kind {\n+                for field in fields {\n+                    match (field.ident.name, &field.expr.kind) {\n+                        (sym::position, ExprKind::Lit(lit)) => {\n+                            if let LitKind::Int(pos, _) = lit.node {\n+                                position.value = pos as usize;\n+                            }\n+                        },\n+                        (sym::format, &ExprKind::Struct(_, spec_fields, _)) => {\n+                            for spec_field in spec_fields {\n+                                match spec_field.ident.name {\n+                                    sym::precision => {\n+                                        position.precision = parse_count(spec_field.expr);\n+                                    },\n+                                    sym::width => {\n+                                        position.width = parse_count(spec_field.expr);\n+                                    },\n+                                    _ => {},\n+                                }\n+                            }\n+                        },\n+                        _ => {},\n+                    }\n+                }\n+            }\n+\n+            position\n+        }))\n+    } else {\n+        None\n+    }\n+}\n+\n+/// `Span::from_inner`, but for `rustc_parse_format`'s `InnerSpan`\n+fn span_from_inner(base: SpanData, inner: rpf::InnerSpan) -> Span {\n+    Span::new(\n+        base.lo + BytePos::from_usize(inner.start),\n+        base.lo + BytePos::from_usize(inner.end),\n+        base.ctxt,\n+        base.parent,\n+    )\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub enum FormatParamKind {\n+    /// An implicit parameter , such as `{}` or `{:?}`.\n+    Implicit,\n+    /// A parameter with an explicit number, or an asterisk precision. e.g. `{1}`, `{0:?}`,\n+    /// `{:.0$}` or `{:.*}`.\n+    Numbered,\n+    /// A named parameter with a named `value_arg`, such as the `x` in `format!(\"{x}\", x = 1)`.\n+    Named(Symbol),\n+    /// An implicit named parameter, such as the `y` in `format!(\"{y}\")`.\n+    NamedInline(Symbol),\n+}\n+\n+/// A `FormatParam` is any place in a `FormatArgument` that refers to a supplied value, e.g.\n+///\n+/// ```\n+/// let precision = 2;\n+/// format!(\"{:.precision$}\", 0.1234);\n+/// ```\n+///\n+/// has two `FormatParam`s, a [`FormatParamKind::Implicit`] `.kind` with a `.value` of `0.1234`\n+/// and a [`FormatParamKind::NamedInline(\"precision\")`] `.kind` with a `.value` of `2`\n+#[derive(Debug, Copy, Clone)]\n+pub struct FormatParam<'tcx> {\n+    /// The expression this parameter refers to.\n+    pub value: &'tcx Expr<'tcx>,\n+    /// How this parameter refers to its `value`.\n+    pub kind: FormatParamKind,\n+    /// Span of the parameter, may be zero width. Includes the whitespace of implicit parameters.\n+    ///\n+    /// ```text\n+    /// format!(\"{}, {  }, {0}, {name}\", ...);\n+    ///          ^    ~~    ~    ~~~~\n+    /// ```\n+    pub span: Span,\n+}\n+\n+impl<'tcx> FormatParam<'tcx> {\n+    fn new(\n+        mut kind: FormatParamKind,\n+        position: usize,\n+        inner: rpf::InnerSpan,\n+        values: &FormatArgsValues<'tcx>,\n+    ) -> Option<Self> {\n+        let value_index = *values.pos_to_value_index.get(position)?;\n+        let value = *values.value_args.get(value_index)?;\n+        let span = span_from_inner(values.format_string_span, inner);\n+\n+        // if a param is declared inline, e.g. `format!(\"{x}\")`, the generated expr's span points\n+        // into the format string\n+        if let FormatParamKind::Named(name) = kind && values.format_string_span.contains(value.span.data()) {\n+            kind = FormatParamKind::NamedInline(name);\n+        }\n+\n+        Some(Self { value, kind, span })\n+    }\n+}\n+\n+/// Used by [width](https://doc.rust-lang.org/std/fmt/#width) and\n+/// [precision](https://doc.rust-lang.org/std/fmt/#precision) specifiers.\n+#[derive(Debug, Copy, Clone)]\n+pub enum Count<'tcx> {\n+    /// Specified with a literal number, stores the value.\n+    Is(usize, Span),\n+    /// Specified using `$` and `*` syntaxes. The `*` format is still considered to be\n+    /// `FormatParamKind::Numbered`.\n+    Param(FormatParam<'tcx>),\n+    /// Not specified.\n+    Implied,\n+}\n+\n+impl<'tcx> Count<'tcx> {\n+    fn new(\n+        count: rpf::Count<'_>,\n+        position: Option<usize>,\n+        inner: Option<rpf::InnerSpan>,\n+        values: &FormatArgsValues<'tcx>,\n+    ) -> Option<Self> {\n+        Some(match count {\n+            rpf::Count::CountIs(val) => Self::Is(val, span_from_inner(values.format_string_span, inner?)),\n+            rpf::Count::CountIsName(name, span) => Self::Param(FormatParam::new(\n+                FormatParamKind::Named(Symbol::intern(name)),\n+                position?,\n+                span,\n+                values,\n+            )?),\n+            rpf::Count::CountIsParam(_) => {\n+                Self::Param(FormatParam::new(FormatParamKind::Numbered, position?, inner?, values)?)\n+            },\n+            rpf::Count::CountImplied => Self::Implied,\n+        })\n+    }\n+\n+    pub fn is_implied(self) -> bool {\n+        matches!(self, Count::Implied)\n+    }\n+\n+    pub fn param(self) -> Option<FormatParam<'tcx>> {\n+        match self {\n+            Count::Param(param) => Some(param),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+/// Specification for the formatting of an argument in the format string. See\n+/// <https://doc.rust-lang.org/std/fmt/index.html#formatting-parameters> for the precise meanings.\n+#[derive(Debug)]\n+pub struct FormatSpec<'tcx> {\n+    /// Optionally specified character to fill alignment with.\n+    pub fill: Option<char>,\n+    /// Optionally specified alignment.\n+    pub align: Alignment,\n+    /// Packed version of various flags provided, see [`rustc_parse_format::Flag`].\n+    pub flags: u32,\n+    /// Represents either the maximum width or the integer precision.\n+    pub precision: Count<'tcx>,\n+    /// The minimum width, will be padded according to `width`/`align`\n+    pub width: Count<'tcx>,\n+    /// The formatting trait used by the argument, e.g. `sym::Display` for `{}`, `sym::Debug` for\n+    /// `{:?}`.\n+    pub r#trait: Symbol,\n+    pub trait_span: Option<Span>,\n+}\n+\n+impl<'tcx> FormatSpec<'tcx> {\n+    fn new(spec: rpf::FormatSpec<'_>, positions: ParamPosition, values: &FormatArgsValues<'tcx>) -> Option<Self> {\n+        Some(Self {\n+            fill: spec.fill,\n+            align: spec.align,\n+            flags: spec.flags,\n+            precision: Count::new(spec.precision, positions.precision, spec.precision_span, values)?,\n+            width: Count::new(spec.width, positions.width, spec.width_span, values)?,\n+            r#trait: match spec.ty {\n+                \"\" => sym::Display,\n+                \"?\" => sym::Debug,\n+                \"o\" => sym!(Octal),\n+                \"x\" => sym!(LowerHex),\n+                \"X\" => sym!(UpperHex),\n+                \"p\" => sym::Pointer,\n+                \"b\" => sym!(Binary),\n+                \"e\" => sym!(LowerExp),\n+                \"E\" => sym!(UpperExp),\n+                _ => return None,\n+            },\n+            trait_span: spec\n+                .ty_span\n+                .map(|span| span_from_inner(values.format_string_span, span)),\n         })\n     }\n \n-    /// Finds a nested call to `format_args!` within a `format!`-like macro call\n+    /// Returns true if this format spec would change the contents of a string when formatted\n+    pub fn has_string_formatting(&self) -> bool {\n+        self.r#trait != sym::Display || !self.width.is_implied() || !self.precision.is_implied()\n+    }\n+}\n+\n+/// A format argument, such as `{}`, `{foo:?}`.\n+#[derive(Debug)]\n+pub struct FormatArg<'tcx> {\n+    /// The parameter the argument refers to.\n+    pub param: FormatParam<'tcx>,\n+    /// How to format `param`.\n+    pub format: FormatSpec<'tcx>,\n+    /// span of the whole argument, `{..}`.\n+    pub span: Span,\n+}\n+\n+/// A parsed `format_args!` expansion.\n+#[derive(Debug)]\n+pub struct FormatArgsExpn<'tcx> {\n+    /// The format string literal.\n+    pub format_string: FormatString,\n+    // The format arguments, such as `{:?}`.\n+    pub args: Vec<FormatArg<'tcx>>,\n+    /// Has an added newline due to `println!()`/`writeln!()`/etc. The last format string part will\n+    /// include this added newline.\n+    pub newline: bool,\n+    /// Values passed after the format string and implicit captures. `[1, z + 2, x]` for\n+    /// `format!(\"{x} {} {y}\", 1, z + 2)`.\n+    value_args: Vec<&'tcx Expr<'tcx>>,\n+}\n+\n+impl<'tcx> FormatArgsExpn<'tcx> {\n+    pub fn parse(cx: &LateContext<'_>, expr: &'tcx Expr<'tcx>) -> Option<Self> {\n+        let macro_name = macro_backtrace(expr.span)\n+            .map(|macro_call| cx.tcx.item_name(macro_call.def_id))\n+            .find(|&name| matches!(name, sym::const_format_args | sym::format_args | sym::format_args_nl))?;\n+        let newline = macro_name == sym::format_args_nl;\n+\n+        // ::core::fmt::Arguments::new_v1(pieces, args)\n+        // ::core::fmt::Arguments::new_v1_formatted(pieces, args, fmt, _unsafe_arg)\n+        if let ExprKind::Call(callee, [pieces, args, rest @ ..]) = expr.kind\n+            && let ExprKind::Path(QPath::TypeRelative(ty, seg)) = callee.kind\n+            && is_path_diagnostic_item(cx, ty, sym::Arguments)\n+            && matches!(seg.ident.as_str(), \"new_v1\" | \"new_v1_formatted\")\n+        {\n+            let format_string = FormatString::new(cx, pieces)?;\n+\n+            let mut parser = rpf::Parser::new(\n+                &format_string.unescaped,\n+                format_string.style,\n+                Some(format_string.snippet.clone()),\n+                // `format_string.unescaped` does not contain the appended newline\n+                false,\n+                rpf::ParseMode::Format,\n+            );\n+\n+            let parsed_args = parser\n+                .by_ref()\n+                .filter_map(|piece| match piece {\n+                    rpf::Piece::NextArgument(a) => Some(a),\n+                    rpf::Piece::String(_) => None,\n+                })\n+                .collect_vec();\n+            if !parser.errors.is_empty() {\n+                return None;\n+            }\n+\n+            let positions = if let Some(fmt_arg) = rest.first() {\n+                // If the argument contains format specs, `new_v1_formatted(_, _, fmt, _)`, parse\n+                // them.\n+\n+                Either::Left(parse_rt_fmt(fmt_arg)?)\n+            } else {\n+                // If no format specs are given, the positions are in the given order and there are\n+                // no `precision`/`width`s to consider.\n+\n+                Either::Right((0..).map(|n| ParamPosition {\n+                    value: n,\n+                    width: None,\n+                    precision: None,\n+                }))\n+            };\n+\n+            let values = FormatArgsValues::new(args, format_string.span.data());\n+\n+            let args = izip!(positions, parsed_args, parser.arg_places)\n+                .map(|(position, parsed_arg, arg_span)| {\n+                    Some(FormatArg {\n+                        param: FormatParam::new(\n+                            match parsed_arg.position {\n+                                rpf::Position::ArgumentImplicitlyIs(_) => FormatParamKind::Implicit,\n+                                rpf::Position::ArgumentIs(_) => FormatParamKind::Numbered,\n+                                // NamedInline is handled by `FormatParam::new()`\n+                                rpf::Position::ArgumentNamed(name) => FormatParamKind::Named(Symbol::intern(name)),\n+                            },\n+                            position.value,\n+                            parsed_arg.position_span,\n+                            &values,\n+                        )?,\n+                        format: FormatSpec::new(parsed_arg.format, position, &values)?,\n+                        span: span_from_inner(values.format_string_span, arg_span),\n+                    })\n+                })\n+                .collect::<Option<Vec<_>>>()?;\n+\n+            Some(Self {\n+                format_string,\n+                args,\n+                value_args: values.value_args,\n+                newline,\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+\n     pub fn find_nested(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, expn_id: ExpnId) -> Option<Self> {\n         let mut format_args = None;\n         expr_visitor_no_bodies(|e| {\n@@ -466,88 +845,23 @@ impl<'tcx> FormatArgsExpn<'tcx> {\n         format_args\n     }\n \n-    /// Returns a vector of `FormatArgsArg`.\n-    pub fn args(&self) -> Option<Vec<FormatArgsArg<'tcx>>> {\n-        if self.specs.is_empty() {\n-            let args = std::iter::zip(&self.value_args, &self.formatters)\n-                .map(|(value, &(_, format_trait))| FormatArgsArg {\n-                    value,\n-                    format_trait,\n-                    spec: None,\n-                })\n-                .collect();\n-            return Some(args);\n-        }\n-        self.specs\n-            .iter()\n-            .map(|spec| {\n-                if_chain! {\n-                    // struct `core::fmt::rt::v1::Argument`\n-                    if let ExprKind::Struct(_, fields, _) = spec.kind;\n-                    if let Some(position_field) = fields.iter().find(|f| f.ident.name == sym::position);\n-                    if let ExprKind::Lit(lit) = &position_field.expr.kind;\n-                    if let LitKind::Int(position, _) = lit.node;\n-                    if let Ok(i) = usize::try_from(position);\n-                    if let Some(&(j, format_trait)) = self.formatters.get(i);\n-                    then {\n-                        Some(FormatArgsArg {\n-                            value: self.value_args[j],\n-                            format_trait,\n-                            spec: Some(spec),\n-                        })\n-                    } else {\n-                        None\n-                    }\n-                }\n-            })\n-            .collect()\n-    }\n-\n     /// Source callsite span of all inputs\n     pub fn inputs_span(&self) -> Span {\n         match *self.value_args {\n-            [] => self.format_string_span,\n+            [] => self.format_string.span,\n             [.., last] => self\n-                .format_string_span\n-                .to(hygiene::walk_chain(last.span, self.format_string_span.ctxt())),\n+                .format_string\n+                .span\n+                .to(hygiene::walk_chain(last.span, self.format_string.span.ctxt())),\n         }\n     }\n-}\n \n-/// Type representing a `FormatArgsExpn`'s format arguments\n-pub struct FormatArgsArg<'tcx> {\n-    /// An element of `value_args` according to `position`\n-    pub value: &'tcx Expr<'tcx>,\n-    /// An element of `args` according to `position`\n-    pub format_trait: Symbol,\n-    /// An element of `specs`\n-    pub spec: Option<&'tcx Expr<'tcx>>,\n-}\n-\n-impl<'tcx> FormatArgsArg<'tcx> {\n-    /// Returns true if any formatting parameters are used that would have an effect on strings,\n-    /// like `{:+2}` instead of just `{}`.\n-    pub fn has_string_formatting(&self) -> bool {\n-        self.spec.map_or(false, |spec| {\n-            // `!` because these conditions check that `self` is unformatted.\n-            !if_chain! {\n-                // struct `core::fmt::rt::v1::Argument`\n-                if let ExprKind::Struct(_, fields, _) = spec.kind;\n-                if let Some(format_field) = fields.iter().find(|f| f.ident.name == sym::format);\n-                // struct `core::fmt::rt::v1::FormatSpec`\n-                if let ExprKind::Struct(_, subfields, _) = format_field.expr.kind;\n-                if subfields.iter().all(|field| match field.ident.name {\n-                    sym::precision | sym::width => match field.expr.kind {\n-                        ExprKind::Path(QPath::Resolved(_, path)) => {\n-                            path.segments.last().unwrap().ident.name == sym::Implied\n-                        }\n-                        _ => false,\n-                    }\n-                    _ => true,\n-                });\n-                then { true } else { false }\n-            }\n-        })\n+    /// Iterator of all format params, both values and those referenced by `width`/`precision`s.\n+    pub fn params(&'tcx self) -> impl Iterator<Item = FormatParam<'tcx>> {\n+        self.args\n+            .iter()\n+            .flat_map(|arg| [Some(arg.param), arg.format.precision.param(), arg.format.width.param()])\n+            .flatten()\n     }\n }\n "}, {"sha": "62020e21c81552a98e28c431396cdb18cde6c85d", "filename": "src/tools/clippy/clippy_utils/src/msrvs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmsrvs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmsrvs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmsrvs.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -13,7 +13,7 @@ macro_rules! msrv_aliases {\n // names may refer to stabilized feature flags or library items\n msrv_aliases! {\n     1,62,0 { BOOL_THEN_SOME }\n-    1,53,0 { OR_PATTERNS, MANUAL_BITS, BTREE_MAP_RETAIN, BTREE_SET_RETAIN }\n+    1,53,0 { OR_PATTERNS, MANUAL_BITS, BTREE_MAP_RETAIN, BTREE_SET_RETAIN, ARRAY_INTO_ITERATOR }\n     1,52,0 { STR_SPLIT_ONCE, REM_EUCLID_CONST }\n     1,51,0 { BORROW_AS_PTR, UNSIGNED_ABS }\n     1,50,0 { BOOL_THEN }\n@@ -32,8 +32,8 @@ msrv_aliases! {\n     1,30,0 { ITERATOR_FIND_MAP, TOOL_ATTRIBUTES }\n     1,28,0 { FROM_BOOL }\n     1,26,0 { RANGE_INCLUSIVE, STRING_RETAIN }\n+    1,24,0 { IS_ASCII_DIGIT }\n     1,18,0 { HASH_MAP_RETAIN, HASH_SET_RETAIN }\n     1,17,0 { FIELD_INIT_SHORTHAND, STATIC_IN_CONST, EXPECT_ERR }\n     1,16,0 { STR_REPEAT }\n-    1,24,0 { IS_ASCII_DIGIT }\n }"}, {"sha": "fb0d34e02eece6b1d67c0ff67f498c36ee137d74", "filename": "src/tools/clippy/clippy_utils/src/paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -71,7 +71,6 @@ pub const IPADDR_V6: [&str; 5] = [\"std\", \"net\", \"ip\", \"IpAddr\", \"V6\"];\n pub const ITER_COUNT: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"count\"];\n pub const ITER_EMPTY: [&str; 5] = [\"core\", \"iter\", \"sources\", \"empty\", \"Empty\"];\n pub const ITER_REPEAT: [&str; 5] = [\"core\", \"iter\", \"sources\", \"repeat\", \"repeat\"];\n-#[expect(clippy::invalid_paths)] // internal lints do not know about all external crates\n pub const ITERTOOLS_NEXT_TUPLE: [&str; 3] = [\"itertools\", \"Itertools\", \"next_tuple\"];\n #[cfg(feature = \"internal\")]\n pub const KW_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"kw\"];\n@@ -96,6 +95,7 @@ pub const PARKING_LOT_RWLOCK_READ_GUARD: [&str; 3] = [\"lock_api\", \"rwlock\", \"RwL\n pub const PARKING_LOT_RWLOCK_WRITE_GUARD: [&str; 3] = [\"lock_api\", \"rwlock\", \"RwLockWriteGuard\"];\n pub const PATH_BUF_AS_PATH: [&str; 4] = [\"std\", \"path\", \"PathBuf\", \"as_path\"];\n pub const PATH_TO_PATH_BUF: [&str; 4] = [\"std\", \"path\", \"Path\", \"to_path_buf\"];\n+pub const PEEKABLE: [&str; 5] = [\"core\", \"iter\", \"adapters\", \"peekable\", \"Peekable\"];\n pub const PERMISSIONS: [&str; 3] = [\"std\", \"fs\", \"Permissions\"];\n #[cfg_attr(not(unix), allow(clippy::invalid_paths))]\n pub const PERMISSIONS_FROM_MODE: [&str; 6] = [\"std\", \"os\", \"unix\", \"fs\", \"PermissionsExt\", \"from_mode\"];"}, {"sha": "5a7f9568441c90acb857177748168c1f763772ca", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 51, "deletions": 9, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -43,14 +43,6 @@ pub fn can_partially_move_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool\n     }\n }\n \n-/// Walks into `ty` and returns `true` if any inner type is the same as `other_ty`\n-pub fn contains_ty<'tcx>(ty: Ty<'tcx>, other_ty: Ty<'tcx>) -> bool {\n-    ty.walk().any(|inner| match inner.unpack() {\n-        GenericArgKind::Type(inner_ty) => other_ty == inner_ty,\n-        GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n-    })\n-}\n-\n /// Walks into `ty` and returns `true` if any inner type is an instance of the given adt\n /// constructor.\n pub fn contains_adt_constructor<'tcx>(ty: Ty<'tcx>, adt: AdtDef<'tcx>) -> bool {\n@@ -410,7 +402,7 @@ pub fn peel_mid_ty_refs(ty: Ty<'_>) -> (Ty<'_>, usize) {\n     peel(ty, 0)\n }\n \n-/// Peels off all references on the type.Returns the underlying type, the number of references\n+/// Peels off all references on the type. Returns the underlying type, the number of references\n /// removed, and whether the pointer is ultimately mutable or not.\n pub fn peel_mid_ty_refs_is_mutable(ty: Ty<'_>) -> (Ty<'_>, usize, Mutability) {\n     fn f(ty: Ty<'_>, count: usize, mutability: Mutability) -> (Ty<'_>, usize, Mutability) {\n@@ -839,3 +831,53 @@ pub fn ty_is_fn_once_param<'tcx>(tcx: TyCtxt<'_>, ty: Ty<'tcx>, predicates: &'tc\n         })\n         .unwrap_or(false)\n }\n+\n+/// Comes up with an \"at least\" guesstimate for the type's size, not taking into\n+/// account the layout of type parameters.\n+pub fn approx_ty_size<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> u64 {\n+    use rustc_middle::ty::layout::LayoutOf;\n+    if !is_normalizable(cx, cx.param_env, ty) {\n+        return 0;\n+    }\n+    match (cx.layout_of(ty).map(|layout| layout.size.bytes()), ty.kind()) {\n+        (Ok(size), _) => size,\n+        (Err(_), ty::Tuple(list)) => list.as_substs().types().map(|t| approx_ty_size(cx, t)).sum(),\n+        (Err(_), ty::Array(t, n)) => {\n+            n.try_eval_usize(cx.tcx, cx.param_env).unwrap_or_default() * approx_ty_size(cx, *t)\n+        },\n+        (Err(_), ty::Adt(def, subst)) if def.is_struct() => def\n+            .variants()\n+            .iter()\n+            .map(|v| {\n+                v.fields\n+                    .iter()\n+                    .map(|field| approx_ty_size(cx, field.ty(cx.tcx, subst)))\n+                    .sum::<u64>()\n+            })\n+            .sum(),\n+        (Err(_), ty::Adt(def, subst)) if def.is_enum() => def\n+            .variants()\n+            .iter()\n+            .map(|v| {\n+                v.fields\n+                    .iter()\n+                    .map(|field| approx_ty_size(cx, field.ty(cx.tcx, subst)))\n+                    .sum::<u64>()\n+            })\n+            .max()\n+            .unwrap_or_default(),\n+        (Err(_), ty::Adt(def, subst)) if def.is_union() => def\n+            .variants()\n+            .iter()\n+            .map(|v| {\n+                v.fields\n+                    .iter()\n+                    .map(|field| approx_ty_size(cx, field.ty(cx.tcx, subst)))\n+                    .max()\n+                    .unwrap_or_default()\n+            })\n+            .max()\n+            .unwrap_or_default(),\n+        (Err(_), _) => 0,\n+    }\n+}"}, {"sha": "85b60fefd60fc4ab84a271c50ebc510bd7449221", "filename": "src/tools/clippy/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Frust-toolchain?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-08-11\"\n+channel = \"nightly-2022-08-27\"\n components = [\"cargo\", \"llvm-tools-preview\", \"rust-src\", \"rust-std\", \"rustc\", \"rustc-dev\", \"rustfmt\"]"}, {"sha": "429dddc42ea9157f6830be6792489b3ab3d08f95", "filename": "src/tools/clippy/rustc_tools_util/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Frustc_tools_util%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Frustc_tools_util%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Frustc_tools_util%2Fsrc%2Flib.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -84,7 +84,7 @@ impl std::fmt::Debug for VersionInfo {\n #[must_use]\n pub fn get_commit_hash() -> Option<String> {\n     std::process::Command::new(\"git\")\n-        .args(&[\"rev-parse\", \"--short\", \"HEAD\"])\n+        .args([\"rev-parse\", \"--short\", \"HEAD\"])\n         .output()\n         .ok()\n         .and_then(|r| String::from_utf8(r.stdout).ok())\n@@ -93,7 +93,7 @@ pub fn get_commit_hash() -> Option<String> {\n #[must_use]\n pub fn get_commit_date() -> Option<String> {\n     std::process::Command::new(\"git\")\n-        .args(&[\"log\", \"-1\", \"--date=short\", \"--pretty=format:%cd\"])\n+        .args([\"log\", \"-1\", \"--date=short\", \"--pretty=format:%cd\"])\n         .output()\n         .ok()\n         .and_then(|r| String::from_utf8(r.stdout).ok())"}, {"sha": "e106583de4a2eb0a099d145cafe71b60453c2ef2", "filename": "src/tools/clippy/tests/check-fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fcheck-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fcheck-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fcheck-fmt.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -13,7 +13,7 @@ fn fmt() {\n     let root_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n     let output = Command::new(\"cargo\")\n         .current_dir(root_dir)\n-        .args(&[\"dev\", \"fmt\", \"--check\"])\n+        .args([\"dev\", \"fmt\", \"--check\"])\n         .output()\n         .unwrap();\n "}, {"sha": "ba6186e599e9637f0481df911ab18085ee3a441f", "filename": "src/tools/clippy/tests/compile-test.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -393,8 +393,8 @@ const RUSTFIX_COVERAGE_KNOWN_EXCEPTIONS: &[&str] = &[\n     \"search_is_some.rs\",\n     \"single_component_path_imports_nested_first.rs\",\n     \"string_add.rs\",\n+    \"suspicious_to_owned.rs\",\n     \"toplevel_ref_arg_non_rustfix.rs\",\n-    \"trait_duplication_in_bounds.rs\",\n     \"unit_arg.rs\",\n     \"unnecessary_clone.rs\",\n     \"unnecessary_lazy_eval_unfixable.rs\",\n@@ -404,24 +404,31 @@ const RUSTFIX_COVERAGE_KNOWN_EXCEPTIONS: &[&str] = &[\n ];\n \n fn check_rustfix_coverage() {\n-    let missing_coverage_path = Path::new(\"target/debug/test/ui/rustfix_missing_coverage.txt\");\n+    let missing_coverage_path = Path::new(\"debug/test/ui/rustfix_missing_coverage.txt\");\n+    let missing_coverage_path = if let Ok(target_dir) = std::env::var(\"CARGO_TARGET_DIR\") {\n+        PathBuf::from(target_dir).join(missing_coverage_path)\n+    } else {\n+        missing_coverage_path.to_path_buf()\n+    };\n \n     if let Ok(missing_coverage_contents) = std::fs::read_to_string(missing_coverage_path) {\n         assert!(RUSTFIX_COVERAGE_KNOWN_EXCEPTIONS.iter().is_sorted_by_key(Path::new));\n \n-        for rs_path in missing_coverage_contents.lines() {\n-            if Path::new(rs_path).starts_with(\"tests/ui/crashes\") {\n+        for rs_file in missing_coverage_contents.lines() {\n+            let rs_path = Path::new(rs_file);\n+            if rs_path.starts_with(\"tests/ui/crashes\") {\n                 continue;\n             }\n-            let filename = Path::new(rs_path).strip_prefix(\"tests/ui/\").unwrap();\n+            assert!(rs_path.starts_with(\"tests/ui/\"), \"{:?}\", rs_file);\n+            let filename = rs_path.strip_prefix(\"tests/ui/\").unwrap();\n             assert!(\n                 RUSTFIX_COVERAGE_KNOWN_EXCEPTIONS\n                     .binary_search_by_key(&filename, Path::new)\n                     .is_ok(),\n                 \"`{}` runs `MachineApplicable` diagnostics but is missing a `run-rustfix` annotation. \\\n                 Please either add `// run-rustfix` at the top of the file or add the file to \\\n                 `RUSTFIX_COVERAGE_KNOWN_EXCEPTIONS` in `tests/compile-test.rs`.\",\n-                rs_path,\n+                rs_file,\n             );\n         }\n     }"}, {"sha": "961525bbd9101dfbc6759f69ba3f05d7aa94e170", "filename": "src/tools/clippy/tests/dogfood.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fdogfood.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -87,11 +87,11 @@ fn run_clippy_for_package(project: &str, args: &[&str]) {\n \n     if cfg!(feature = \"internal\") {\n         // internal lints only exist if we build with the internal feature\n-        command.args(&[\"-D\", \"clippy::internal\"]);\n+        command.args([\"-D\", \"clippy::internal\"]);\n     } else {\n         // running a clippy built without internal lints on the clippy source\n         // that contains e.g. `allow(clippy::invalid_paths)`\n-        command.args(&[\"-A\", \"unknown_lints\"]);\n+        command.args([\"-A\", \"unknown_lints\"]);\n     }\n \n     let output = command.output().unwrap();"}, {"sha": "23a9bef3ccceaee4b9df52ecb40afb848e8f1873", "filename": "src/tools/clippy/tests/integration.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fintegration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fintegration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fintegration.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -19,7 +19,7 @@ fn integration_test() {\n     repo_dir.push(crate_name);\n \n     let st = Command::new(\"git\")\n-        .args(&[\n+        .args([\n             OsStr::new(\"clone\"),\n             OsStr::new(\"--depth=1\"),\n             OsStr::new(&repo_url),\n@@ -37,7 +37,7 @@ fn integration_test() {\n         .current_dir(repo_dir)\n         .env(\"RUST_BACKTRACE\", \"full\")\n         .env(\"CARGO_TARGET_DIR\", target_dir)\n-        .args(&[\n+        .args([\n             \"clippy\",\n             \"--all-targets\",\n             \"--all-features\","}, {"sha": "2e0f4e76075b38a1eaec8e6380001dcd5109886a", "filename": "src/tools/clippy/tests/lint_message_convention.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Flint_message_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Flint_message_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Flint_message_convention.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -19,7 +19,7 @@ impl Message {\n         // we don't want the first letter after \"error: \", \"help: \" ... to be capitalized\n         // also no punctuation (except for \"?\" ?) at the end of a line\n         static REGEX_SET: LazyLock<RegexSet> = LazyLock::new(|| {\n-            RegexSet::new(&[\n+            RegexSet::new([\n                 r\"error: [A-Z]\",\n                 r\"help: [A-Z]\",\n                 r\"warning: [A-Z]\",\n@@ -37,7 +37,7 @@ impl Message {\n         // sometimes the first character is capitalized and it is legal (like in \"C-like enum variants\") or\n         // we want to ask a question ending in \"?\"\n         static EXCEPTIONS_SET: LazyLock<RegexSet> = LazyLock::new(|| {\n-            RegexSet::new(&[\n+            RegexSet::new([\n                 r\"\\.\\.\\.$\",\n                 r\".*C-like enum variant discriminant is not portable to 32-bit targets\",\n                 r\".*Intel x86 assembly syntax used\","}, {"sha": "a52a0b5289fe4839f22bc68f9ec1bbfb206fc6e2", "filename": "src/tools/clippy/tests/ui-toml/toml_unknown_key/conf_unknown_key.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -19,6 +19,7 @@ error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown fie\n            enforced-import-renames\n            enum-variant-name-threshold\n            enum-variant-size-threshold\n+           large-error-threshold\n            literal-representation-threshold\n            max-fn-params-bools\n            max-include-file-size"}, {"sha": "6f0485b5279b1112c173c8a5d07cfcbb872bd0d3", "filename": "src/tools/clippy/tests/ui/case_sensitive_file_extension_comparisons.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcase_sensitive_file_extension_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcase_sensitive_file_extension_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcase_sensitive_file_extension_comparisons.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -14,31 +14,31 @@ fn is_rust_file(filename: &str) -> bool {\n \n fn main() {\n     // std::string::String and &str should trigger the lint failure with .ext12\n-    let _ = String::from(\"\").ends_with(\".ext12\");\n+    let _ = String::new().ends_with(\".ext12\");\n     let _ = \"str\".ends_with(\".ext12\");\n \n     // The test struct should not trigger the lint failure with .ext12\n     TestStruct {}.ends_with(\".ext12\");\n \n     // std::string::String and &str should trigger the lint failure with .EXT12\n-    let _ = String::from(\"\").ends_with(\".EXT12\");\n+    let _ = String::new().ends_with(\".EXT12\");\n     let _ = \"str\".ends_with(\".EXT12\");\n \n     // The test struct should not trigger the lint failure with .EXT12\n     TestStruct {}.ends_with(\".EXT12\");\n \n     // Should not trigger the lint failure with .eXT12\n-    let _ = String::from(\"\").ends_with(\".eXT12\");\n+    let _ = String::new().ends_with(\".eXT12\");\n     let _ = \"str\".ends_with(\".eXT12\");\n     TestStruct {}.ends_with(\".eXT12\");\n \n     // Should not trigger the lint failure with .EXT123 (too long)\n-    let _ = String::from(\"\").ends_with(\".EXT123\");\n+    let _ = String::new().ends_with(\".EXT123\");\n     let _ = \"str\".ends_with(\".EXT123\");\n     TestStruct {}.ends_with(\".EXT123\");\n \n     // Shouldn't fail if it doesn't start with a dot\n-    let _ = String::from(\"\").ends_with(\"a.ext\");\n+    let _ = String::new().ends_with(\"a.ext\");\n     let _ = \"str\".ends_with(\"a.extA\");\n     TestStruct {}.ends_with(\"a.ext\");\n }"}, {"sha": "5d9a043edb9a5357dbce51e67c236a5f838901a2", "filename": "src/tools/clippy/tests/ui/case_sensitive_file_extension_comparisons.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcase_sensitive_file_extension_comparisons.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcase_sensitive_file_extension_comparisons.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcase_sensitive_file_extension_comparisons.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -8,10 +8,10 @@ LL |     filename.ends_with(\".rs\")\n    = help: consider using a case-insensitive comparison instead\n \n error: case-sensitive file extension comparison\n-  --> $DIR/case_sensitive_file_extension_comparisons.rs:17:30\n+  --> $DIR/case_sensitive_file_extension_comparisons.rs:17:27\n    |\n-LL |     let _ = String::from(\"\").ends_with(\".ext12\");\n-   |                              ^^^^^^^^^^^^^^^^^^^\n+LL |     let _ = String::new().ends_with(\".ext12\");\n+   |                           ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider using a case-insensitive comparison instead\n \n@@ -24,10 +24,10 @@ LL |     let _ = \"str\".ends_with(\".ext12\");\n    = help: consider using a case-insensitive comparison instead\n \n error: case-sensitive file extension comparison\n-  --> $DIR/case_sensitive_file_extension_comparisons.rs:24:30\n+  --> $DIR/case_sensitive_file_extension_comparisons.rs:24:27\n    |\n-LL |     let _ = String::from(\"\").ends_with(\".EXT12\");\n-   |                              ^^^^^^^^^^^^^^^^^^^\n+LL |     let _ = String::new().ends_with(\".EXT12\");\n+   |                           ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider using a case-insensitive comparison instead\n "}, {"sha": "b70c1912951164cd911d6896ceedd2a9c2cd9cff", "filename": "src/tools/clippy/tests/ui/cast_raw_slice_pointer_cast.fixed", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_raw_slice_pointer_cast.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_raw_slice_pointer_cast.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_raw_slice_pointer_cast.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,24 @@\n+// run-rustfix\n+#![warn(clippy::cast_slice_from_raw_parts)]\n+\n+#[allow(unused_imports, unused_unsafe)]\n+fn main() {\n+    let mut vec = vec![0u8; 1];\n+    let ptr: *const u8 = vec.as_ptr();\n+    let mptr = vec.as_mut_ptr();\n+    let _: *const [u8] = unsafe { core::ptr::slice_from_raw_parts(ptr, 1) };\n+    let _: *const [u8] = unsafe { core::ptr::slice_from_raw_parts_mut(mptr, 1) };\n+    let _: *const [u8] = core::ptr::slice_from_raw_parts(ptr, 1);\n+    {\n+        use core::slice;\n+        let _: *const [u8] = core::ptr::slice_from_raw_parts(ptr, 1);\n+        use slice as one;\n+        let _: *const [u8] = core::ptr::slice_from_raw_parts(ptr, 1);\n+    }\n+    {\n+        use std::slice;\n+        let _: *const [u8] = core::ptr::slice_from_raw_parts(ptr, 1);\n+        use slice as one;\n+        let _: *const [u8] = core::ptr::slice_from_raw_parts(ptr, 1);\n+    }\n+}"}, {"sha": "c1b316765c967748ab163213d492e5c1d12a47f1", "filename": "src/tools/clippy/tests/ui/cast_raw_slice_pointer_cast.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_raw_slice_pointer_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_raw_slice_pointer_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_raw_slice_pointer_cast.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,24 @@\n+// run-rustfix\n+#![warn(clippy::cast_slice_from_raw_parts)]\n+\n+#[allow(unused_imports, unused_unsafe)]\n+fn main() {\n+    let mut vec = vec![0u8; 1];\n+    let ptr: *const u8 = vec.as_ptr();\n+    let mptr = vec.as_mut_ptr();\n+    let _: *const [u8] = unsafe { std::slice::from_raw_parts(ptr, 1) as *const [u8] };\n+    let _: *const [u8] = unsafe { std::slice::from_raw_parts_mut(mptr, 1) as *mut [u8] };\n+    let _: *const [u8] = unsafe { std::slice::from_raw_parts(ptr, 1) } as *const [u8];\n+    {\n+        use core::slice;\n+        let _: *const [u8] = unsafe { slice::from_raw_parts(ptr, 1) } as *const [u8];\n+        use slice as one;\n+        let _: *const [u8] = unsafe { one::from_raw_parts(ptr, 1) } as *const [u8];\n+    }\n+    {\n+        use std::slice;\n+        let _: *const [u8] = unsafe { slice::from_raw_parts(ptr, 1) } as *const [u8];\n+        use slice as one;\n+        let _: *const [u8] = unsafe { one::from_raw_parts(ptr, 1) } as *const [u8];\n+    }\n+}"}, {"sha": "f07801c197cccfe73f1dd4727b2bd15770b11f2c", "filename": "src/tools/clippy/tests/ui/cast_raw_slice_pointer_cast.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_raw_slice_pointer_cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_raw_slice_pointer_cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_raw_slice_pointer_cast.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,46 @@\n+error: casting the result of `from_raw_parts` to *const [u8]\n+  --> $DIR/cast_raw_slice_pointer_cast.rs:9:35\n+   |\n+LL |     let _: *const [u8] = unsafe { std::slice::from_raw_parts(ptr, 1) as *const [u8] };\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `core::ptr::slice_from_raw_parts(ptr, 1)`\n+   |\n+   = note: `-D clippy::cast-slice-from-raw-parts` implied by `-D warnings`\n+\n+error: casting the result of `from_raw_parts_mut` to *mut [u8]\n+  --> $DIR/cast_raw_slice_pointer_cast.rs:10:35\n+   |\n+LL |     let _: *const [u8] = unsafe { std::slice::from_raw_parts_mut(mptr, 1) as *mut [u8] };\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `core::ptr::slice_from_raw_parts_mut(mptr, 1)`\n+\n+error: casting the result of `from_raw_parts` to *const [u8]\n+  --> $DIR/cast_raw_slice_pointer_cast.rs:11:26\n+   |\n+LL |     let _: *const [u8] = unsafe { std::slice::from_raw_parts(ptr, 1) } as *const [u8];\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `core::ptr::slice_from_raw_parts(ptr, 1)`\n+\n+error: casting the result of `from_raw_parts` to *const [u8]\n+  --> $DIR/cast_raw_slice_pointer_cast.rs:14:30\n+   |\n+LL |         let _: *const [u8] = unsafe { slice::from_raw_parts(ptr, 1) } as *const [u8];\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `core::ptr::slice_from_raw_parts(ptr, 1)`\n+\n+error: casting the result of `from_raw_parts` to *const [u8]\n+  --> $DIR/cast_raw_slice_pointer_cast.rs:16:30\n+   |\n+LL |         let _: *const [u8] = unsafe { one::from_raw_parts(ptr, 1) } as *const [u8];\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `core::ptr::slice_from_raw_parts(ptr, 1)`\n+\n+error: casting the result of `from_raw_parts` to *const [u8]\n+  --> $DIR/cast_raw_slice_pointer_cast.rs:20:30\n+   |\n+LL |         let _: *const [u8] = unsafe { slice::from_raw_parts(ptr, 1) } as *const [u8];\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `core::ptr::slice_from_raw_parts(ptr, 1)`\n+\n+error: casting the result of `from_raw_parts` to *const [u8]\n+  --> $DIR/cast_raw_slice_pointer_cast.rs:22:30\n+   |\n+LL |         let _: *const [u8] = unsafe { one::from_raw_parts(ptr, 1) } as *const [u8];\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `core::ptr::slice_from_raw_parts(ptr, 1)`\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "49fc9a9629e25415a714b6e3616602c77367f239", "filename": "src/tools/clippy/tests/ui/collapsible_str_replace.fixed", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_str_replace.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_str_replace.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_str_replace.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,73 @@\n+// run-rustfix\n+\n+#![warn(clippy::collapsible_str_replace)]\n+\n+fn get_filter() -> char {\n+    'u'\n+}\n+\n+fn main() {\n+    let d = 'd';\n+    let p = 'p';\n+    let s = 's';\n+    let u = 'u';\n+    let l = \"l\";\n+\n+    let mut iter = [\"l\", \"z\"].iter();\n+\n+    // LINT CASES\n+    let _ = \"hesuo worpd\".replace(['s', 'u'], \"l\");\n+\n+    let _ = \"hesuo worpd\".replace(['s', 'u'], l);\n+\n+    let _ = \"hesuo worpd\".replace(['s', 'u', 'p'], \"l\");\n+\n+    let _ = \"hesuo worpd\"\n+        .replace(['s', 'u', 'p', 'd'], \"l\");\n+\n+    let _ = \"hesuo world\".replace([s, 'u'], \"l\");\n+\n+    let _ = \"hesuo worpd\".replace([s, 'u', 'p'], \"l\");\n+\n+    let _ = \"hesuo worpd\".replace([s, u, 'p'], \"l\");\n+\n+    let _ = \"hesuo worpd\".replace([s, u, p], \"l\");\n+\n+    let _ = \"hesuo worlp\".replace(['s', 'u'], \"l\").replace('p', \"d\");\n+\n+    let _ = \"hesuo worpd\".replace('s', \"x\").replace(['u', 'p'], \"l\");\n+\n+    // Note: Future iterations could lint `replace(|c| matches!(c, \"su\" | 'd' | 'p'), \"l\")`\n+    let _ = \"hesudo worpd\".replace(\"su\", \"l\").replace(['d', 'p'], \"l\");\n+\n+    let _ = \"hesudo worpd\".replace([d, 'p'], \"l\").replace(\"su\", \"l\");\n+\n+    let _ = \"hesuo world\".replace([get_filter(), 's'], \"l\");\n+\n+    // NO LINT CASES\n+    let _ = \"hesuo world\".replace('s', \"l\").replace('u', \"p\");\n+\n+    let _ = \"hesuo worpd\".replace('s', \"l\").replace('p', l);\n+\n+    let _ = \"hesudo worpd\".replace('d', \"l\").replace(\"su\", \"l\").replace('p', \"l\");\n+\n+    // Note: Future iterations of `collapsible_str_replace` might lint this and combine to `[s, u, p]`\n+    let _ = \"hesuo worpd\".replace([s, u], \"l\").replace([u, p], \"l\");\n+\n+    let _ = \"hesuo worpd\".replace(['s', 'u'], \"l\").replace(['u', 'p'], \"l\");\n+\n+    let _ = \"hesuo worpd\".replace('s', \"l\").replace(['u', 'p'], \"l\");\n+\n+    let _ = \"hesuo worpd\".replace(['s', 'u', 'p'], \"l\").replace('r', \"l\");\n+\n+    let _ = \"hesuo worpd\".replace(['s', 'u', 'p'], l).replace('r', l);\n+\n+    let _ = \"hesuo worpd\".replace(['s', u, 'p'], \"l\").replace('r', \"l\");\n+\n+    let _ = \"hesuo worpd\".replace([s, u], \"l\").replace(p, \"l\");\n+\n+    // Regression test\n+    let _ = \"hesuo worpd\"\n+        .replace('u', iter.next().unwrap())\n+        .replace('s', iter.next().unwrap());\n+}"}, {"sha": "e3e25c4146ffa6bdd7a71bcd2067ba9a6ec6b68e", "filename": "src/tools/clippy/tests/ui/collapsible_str_replace.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_str_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_str_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_str_replace.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,76 @@\n+// run-rustfix\n+\n+#![warn(clippy::collapsible_str_replace)]\n+\n+fn get_filter() -> char {\n+    'u'\n+}\n+\n+fn main() {\n+    let d = 'd';\n+    let p = 'p';\n+    let s = 's';\n+    let u = 'u';\n+    let l = \"l\";\n+\n+    let mut iter = [\"l\", \"z\"].iter();\n+\n+    // LINT CASES\n+    let _ = \"hesuo worpd\".replace('s', \"l\").replace('u', \"l\");\n+\n+    let _ = \"hesuo worpd\".replace('s', l).replace('u', l);\n+\n+    let _ = \"hesuo worpd\".replace('s', \"l\").replace('u', \"l\").replace('p', \"l\");\n+\n+    let _ = \"hesuo worpd\"\n+        .replace('s', \"l\")\n+        .replace('u', \"l\")\n+        .replace('p', \"l\")\n+        .replace('d', \"l\");\n+\n+    let _ = \"hesuo world\".replace(s, \"l\").replace('u', \"l\");\n+\n+    let _ = \"hesuo worpd\".replace(s, \"l\").replace('u', \"l\").replace('p', \"l\");\n+\n+    let _ = \"hesuo worpd\".replace(s, \"l\").replace(u, \"l\").replace('p', \"l\");\n+\n+    let _ = \"hesuo worpd\".replace(s, \"l\").replace(u, \"l\").replace(p, \"l\");\n+\n+    let _ = \"hesuo worlp\".replace('s', \"l\").replace('u', \"l\").replace('p', \"d\");\n+\n+    let _ = \"hesuo worpd\".replace('s', \"x\").replace('u', \"l\").replace('p', \"l\");\n+\n+    // Note: Future iterations could lint `replace(|c| matches!(c, \"su\" | 'd' | 'p'), \"l\")`\n+    let _ = \"hesudo worpd\".replace(\"su\", \"l\").replace('d', \"l\").replace('p', \"l\");\n+\n+    let _ = \"hesudo worpd\".replace(d, \"l\").replace('p', \"l\").replace(\"su\", \"l\");\n+\n+    let _ = \"hesuo world\".replace(get_filter(), \"l\").replace('s', \"l\");\n+\n+    // NO LINT CASES\n+    let _ = \"hesuo world\".replace('s', \"l\").replace('u', \"p\");\n+\n+    let _ = \"hesuo worpd\".replace('s', \"l\").replace('p', l);\n+\n+    let _ = \"hesudo worpd\".replace('d', \"l\").replace(\"su\", \"l\").replace('p', \"l\");\n+\n+    // Note: Future iterations of `collapsible_str_replace` might lint this and combine to `[s, u, p]`\n+    let _ = \"hesuo worpd\".replace([s, u], \"l\").replace([u, p], \"l\");\n+\n+    let _ = \"hesuo worpd\".replace(['s', 'u'], \"l\").replace(['u', 'p'], \"l\");\n+\n+    let _ = \"hesuo worpd\".replace('s', \"l\").replace(['u', 'p'], \"l\");\n+\n+    let _ = \"hesuo worpd\".replace(['s', 'u', 'p'], \"l\").replace('r', \"l\");\n+\n+    let _ = \"hesuo worpd\".replace(['s', 'u', 'p'], l).replace('r', l);\n+\n+    let _ = \"hesuo worpd\".replace(['s', u, 'p'], \"l\").replace('r', \"l\");\n+\n+    let _ = \"hesuo worpd\".replace([s, u], \"l\").replace(p, \"l\");\n+\n+    // Regression test\n+    let _ = \"hesuo worpd\"\n+        .replace('u', iter.next().unwrap())\n+        .replace('s', iter.next().unwrap());\n+}"}, {"sha": "8e3daf3b898a3328e6f5f9de77f42e24f2729b79", "filename": "src/tools/clippy/tests/ui/collapsible_str_replace.stderr", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_str_replace.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_str_replace.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_str_replace.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,86 @@\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:19:27\n+   |\n+LL |     let _ = \"hesuo worpd\".replace('s', \"l\").replace('u', \"l\");\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(['s', 'u'], \"l\")`\n+   |\n+   = note: `-D clippy::collapsible-str-replace` implied by `-D warnings`\n+\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:21:27\n+   |\n+LL |     let _ = \"hesuo worpd\".replace('s', l).replace('u', l);\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(['s', 'u'], l)`\n+\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:23:27\n+   |\n+LL |     let _ = \"hesuo worpd\".replace('s', \"l\").replace('u', \"l\").replace('p', \"l\");\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(['s', 'u', 'p'], \"l\")`\n+\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:26:10\n+   |\n+LL |           .replace('s', \"l\")\n+   |  __________^\n+LL | |         .replace('u', \"l\")\n+LL | |         .replace('p', \"l\")\n+LL | |         .replace('d', \"l\");\n+   | |__________________________^ help: replace with: `replace(['s', 'u', 'p', 'd'], \"l\")`\n+\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:31:27\n+   |\n+LL |     let _ = \"hesuo world\".replace(s, \"l\").replace('u', \"l\");\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace([s, 'u'], \"l\")`\n+\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:33:27\n+   |\n+LL |     let _ = \"hesuo worpd\".replace(s, \"l\").replace('u', \"l\").replace('p', \"l\");\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace([s, 'u', 'p'], \"l\")`\n+\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:35:27\n+   |\n+LL |     let _ = \"hesuo worpd\".replace(s, \"l\").replace(u, \"l\").replace('p', \"l\");\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace([s, u, 'p'], \"l\")`\n+\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:37:27\n+   |\n+LL |     let _ = \"hesuo worpd\".replace(s, \"l\").replace(u, \"l\").replace(p, \"l\");\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace([s, u, p], \"l\")`\n+\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:39:27\n+   |\n+LL |     let _ = \"hesuo worlp\".replace('s', \"l\").replace('u', \"l\").replace('p', \"d\");\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(['s', 'u'], \"l\")`\n+\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:41:45\n+   |\n+LL |     let _ = \"hesuo worpd\".replace('s', \"x\").replace('u', \"l\").replace('p', \"l\");\n+   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(['u', 'p'], \"l\")`\n+\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:44:47\n+   |\n+LL |     let _ = \"hesudo worpd\".replace(\"su\", \"l\").replace('d', \"l\").replace('p', \"l\");\n+   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(['d', 'p'], \"l\")`\n+\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:46:28\n+   |\n+LL |     let _ = \"hesudo worpd\".replace(d, \"l\").replace('p', \"l\").replace(\"su\", \"l\");\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace([d, 'p'], \"l\")`\n+\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:48:27\n+   |\n+LL |     let _ = \"hesuo world\".replace(get_filter(), \"l\").replace('s', \"l\");\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace([get_filter(), 's'], \"l\")`\n+\n+error: aborting due to 13 previous errors\n+"}, {"sha": "d742595e14d4c17dfd987a6dbaab4aca98916da5", "filename": "src/tools/clippy/tests/ui/expect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexpect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexpect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexpect.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -6,8 +6,9 @@ fn expect_option() {\n }\n \n fn expect_result() {\n-    let res: Result<u8, ()> = Ok(0);\n+    let res: Result<u8, u8> = Ok(0);\n     let _ = res.expect(\"\");\n+    let _ = res.expect_err(\"\");\n }\n \n fn main() {"}, {"sha": "904c090464523c17dce9196547b56f306115afdb", "filename": "src/tools/clippy/tests/ui/expect.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexpect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexpect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexpect.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -15,5 +15,13 @@ LL |     let _ = res.expect(\"\");\n    |\n    = help: if this value is an `Err`, it will panic\n \n-error: aborting due to 2 previous errors\n+error: used `expect_err()` on `a Result` value\n+  --> $DIR/expect.rs:11:13\n+   |\n+LL |     let _ = res.expect_err(\"\");\n+   |             ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if this value is an `Ok`, it will panic\n+\n+error: aborting due to 3 previous errors\n "}, {"sha": "c86a502d15f0967fcf2e448d62f35f0886bdeff9", "filename": "src/tools/clippy/tests/ui/floating_point_exp.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_exp.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_exp.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_exp.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -5,6 +5,7 @@ fn main() {\n     let x = 2f32;\n     let _ = x.exp_m1();\n     let _ = x.exp_m1() + 2.0;\n+    let _ = (x as f32).exp_m1() + 2.0;\n     // Cases where the lint shouldn't be applied\n     let _ = x.exp() - 2.0;\n     let _ = x.exp() - 1.0 * 2.0;"}, {"sha": "e59589f912a21accd00d9d9306a70b5df937197a", "filename": "src/tools/clippy/tests/ui/floating_point_exp.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_exp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_exp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_exp.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -5,6 +5,7 @@ fn main() {\n     let x = 2f32;\n     let _ = x.exp() - 1.0;\n     let _ = x.exp() - 1.0 + 2.0;\n+    let _ = (x as f32).exp() - 1.0 + 2.0;\n     // Cases where the lint shouldn't be applied\n     let _ = x.exp() - 2.0;\n     let _ = x.exp() - 1.0 * 2.0;"}, {"sha": "f84eede19872a2923b409a5d32c3fddb5f03e8b7", "filename": "src/tools/clippy/tests/ui/floating_point_exp.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_exp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_exp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_exp.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -13,16 +13,22 @@ LL |     let _ = x.exp() - 1.0 + 2.0;\n    |             ^^^^^^^^^^^^^ help: consider using: `x.exp_m1()`\n \n error: (e.pow(x) - 1) can be computed more accurately\n-  --> $DIR/floating_point_exp.rs:13:13\n+  --> $DIR/floating_point_exp.rs:8:13\n+   |\n+LL |     let _ = (x as f32).exp() - 1.0 + 2.0;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x as f32).exp_m1()`\n+\n+error: (e.pow(x) - 1) can be computed more accurately\n+  --> $DIR/floating_point_exp.rs:14:13\n    |\n LL |     let _ = x.exp() - 1.0;\n    |             ^^^^^^^^^^^^^ help: consider using: `x.exp_m1()`\n \n error: (e.pow(x) - 1) can be computed more accurately\n-  --> $DIR/floating_point_exp.rs:14:13\n+  --> $DIR/floating_point_exp.rs:15:13\n    |\n LL |     let _ = x.exp() - 1.0 + 2.0;\n    |             ^^^^^^^^^^^^^ help: consider using: `x.exp_m1()`\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 5 previous errors\n "}, {"sha": "4def9300bb7d2f70dae72beb47af6be5586fd03c", "filename": "src/tools/clippy/tests/ui/floating_point_log.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -12,6 +12,7 @@ fn check_log_base() {\n     let _ = x.ln();\n     let _ = x.log2();\n     let _ = x.ln();\n+    let _ = (x as f32).log2();\n \n     let x = 1f64;\n     let _ = x.log2();"}, {"sha": "1e04caa7d2a865070f83c44e465dfe672ea1514a", "filename": "src/tools/clippy/tests/ui/floating_point_log.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -12,6 +12,7 @@ fn check_log_base() {\n     let _ = x.log(std::f32::consts::E);\n     let _ = x.log(TWO);\n     let _ = x.log(E);\n+    let _ = (x as f32).log(2f32);\n \n     let x = 1f64;\n     let _ = x.log(2f64);"}, {"sha": "89800a13a6ecc75ed966bc41d57b090427b0fc50", "filename": "src/tools/clippy/tests/ui/floating_point_log.stderr", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -31,144 +31,150 @@ LL |     let _ = x.log(E);\n    |             ^^^^^^^^ help: consider using: `x.ln()`\n \n error: logarithm for bases 2, 10 and e can be computed more accurately\n-  --> $DIR/floating_point_log.rs:17:13\n+  --> $DIR/floating_point_log.rs:15:13\n+   |\n+LL |     let _ = (x as f32).log(2f32);\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x as f32).log2()`\n+\n+error: logarithm for bases 2, 10 and e can be computed more accurately\n+  --> $DIR/floating_point_log.rs:18:13\n    |\n LL |     let _ = x.log(2f64);\n    |             ^^^^^^^^^^^ help: consider using: `x.log2()`\n \n error: logarithm for bases 2, 10 and e can be computed more accurately\n-  --> $DIR/floating_point_log.rs:18:13\n+  --> $DIR/floating_point_log.rs:19:13\n    |\n LL |     let _ = x.log(10f64);\n    |             ^^^^^^^^^^^^ help: consider using: `x.log10()`\n \n error: logarithm for bases 2, 10 and e can be computed more accurately\n-  --> $DIR/floating_point_log.rs:19:13\n+  --> $DIR/floating_point_log.rs:20:13\n    |\n LL |     let _ = x.log(std::f64::consts::E);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.ln()`\n \n error: ln(1 + x) can be computed more accurately\n-  --> $DIR/floating_point_log.rs:24:13\n+  --> $DIR/floating_point_log.rs:25:13\n    |\n LL |     let _ = (1f32 + 2.).ln();\n    |             ^^^^^^^^^^^^^^^^ help: consider using: `2.0f32.ln_1p()`\n    |\n    = note: `-D clippy::imprecise-flops` implied by `-D warnings`\n \n error: ln(1 + x) can be computed more accurately\n-  --> $DIR/floating_point_log.rs:25:13\n+  --> $DIR/floating_point_log.rs:26:13\n    |\n LL |     let _ = (1f32 + 2.0).ln();\n    |             ^^^^^^^^^^^^^^^^^ help: consider using: `2.0f32.ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n-  --> $DIR/floating_point_log.rs:26:13\n+  --> $DIR/floating_point_log.rs:27:13\n    |\n LL |     let _ = (1.0 + x).ln();\n    |             ^^^^^^^^^^^^^^ help: consider using: `x.ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n-  --> $DIR/floating_point_log.rs:27:13\n+  --> $DIR/floating_point_log.rs:28:13\n    |\n LL |     let _ = (1.0 + x / 2.0).ln();\n    |             ^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x / 2.0).ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n-  --> $DIR/floating_point_log.rs:28:13\n+  --> $DIR/floating_point_log.rs:29:13\n    |\n LL |     let _ = (1.0 + x.powi(3)).ln();\n    |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(3).ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n-  --> $DIR/floating_point_log.rs:29:13\n+  --> $DIR/floating_point_log.rs:30:13\n    |\n LL |     let _ = (1.0 + x.powi(3) / 2.0).ln();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x.powi(3) / 2.0).ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n-  --> $DIR/floating_point_log.rs:30:13\n+  --> $DIR/floating_point_log.rs:31:13\n    |\n LL |     let _ = (1.0 + (std::f32::consts::E - 1.0)).ln();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(std::f32::consts::E - 1.0).ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n-  --> $DIR/floating_point_log.rs:31:13\n+  --> $DIR/floating_point_log.rs:32:13\n    |\n LL |     let _ = (x + 1.0).ln();\n    |             ^^^^^^^^^^^^^^ help: consider using: `x.ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n-  --> $DIR/floating_point_log.rs:32:13\n+  --> $DIR/floating_point_log.rs:33:13\n    |\n LL |     let _ = (x.powi(3) + 1.0).ln();\n    |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(3).ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n-  --> $DIR/floating_point_log.rs:33:13\n+  --> $DIR/floating_point_log.rs:34:13\n    |\n LL |     let _ = (x + 2.0 + 1.0).ln();\n    |             ^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x + 2.0).ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n-  --> $DIR/floating_point_log.rs:34:13\n+  --> $DIR/floating_point_log.rs:35:13\n    |\n LL |     let _ = (x / 2.0 + 1.0).ln();\n    |             ^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x / 2.0).ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n-  --> $DIR/floating_point_log.rs:42:13\n+  --> $DIR/floating_point_log.rs:43:13\n    |\n LL |     let _ = (1f64 + 2.).ln();\n    |             ^^^^^^^^^^^^^^^^ help: consider using: `2.0f64.ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n-  --> $DIR/floating_point_log.rs:43:13\n+  --> $DIR/floating_point_log.rs:44:13\n    |\n LL |     let _ = (1f64 + 2.0).ln();\n    |             ^^^^^^^^^^^^^^^^^ help: consider using: `2.0f64.ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n-  --> $DIR/floating_point_log.rs:44:13\n+  --> $DIR/floating_point_log.rs:45:13\n    |\n LL |     let _ = (1.0 + x).ln();\n    |             ^^^^^^^^^^^^^^ help: consider using: `x.ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n-  --> $DIR/floating_point_log.rs:45:13\n+  --> $DIR/floating_point_log.rs:46:13\n    |\n LL |     let _ = (1.0 + x / 2.0).ln();\n    |             ^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x / 2.0).ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n-  --> $DIR/floating_point_log.rs:46:13\n+  --> $DIR/floating_point_log.rs:47:13\n    |\n LL |     let _ = (1.0 + x.powi(3)).ln();\n    |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(3).ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n-  --> $DIR/floating_point_log.rs:47:13\n+  --> $DIR/floating_point_log.rs:48:13\n    |\n LL |     let _ = (x + 1.0).ln();\n    |             ^^^^^^^^^^^^^^ help: consider using: `x.ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n-  --> $DIR/floating_point_log.rs:48:13\n+  --> $DIR/floating_point_log.rs:49:13\n    |\n LL |     let _ = (x.powi(3) + 1.0).ln();\n    |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(3).ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n-  --> $DIR/floating_point_log.rs:49:13\n+  --> $DIR/floating_point_log.rs:50:13\n    |\n LL |     let _ = (x + 2.0 + 1.0).ln();\n    |             ^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x + 2.0).ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n-  --> $DIR/floating_point_log.rs:50:13\n+  --> $DIR/floating_point_log.rs:51:13\n    |\n LL |     let _ = (x / 2.0 + 1.0).ln();\n    |             ^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x / 2.0).ln_1p()`\n \n-error: aborting due to 28 previous errors\n+error: aborting due to 29 previous errors\n "}, {"sha": "936462f94066f681284506f22daacd4a6706dc84", "filename": "src/tools/clippy/tests/ui/floating_point_logbase.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -5,6 +5,7 @@ fn main() {\n     let x = 3f32;\n     let y = 5f32;\n     let _ = x.log(y);\n+    let _ = (x as f32).log(y);\n     let _ = x.log(y);\n     let _ = x.log(y);\n     let _ = x.log(y);"}, {"sha": "0b56fa8fa41fa3112f63adfeac48176a2909c79e", "filename": "src/tools/clippy/tests/ui/floating_point_logbase.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -5,6 +5,7 @@ fn main() {\n     let x = 3f32;\n     let y = 5f32;\n     let _ = x.ln() / y.ln();\n+    let _ = (x as f32).ln() / y.ln();\n     let _ = x.log2() / y.log2();\n     let _ = x.log10() / y.log10();\n     let _ = x.log(5f32) / y.log(5f32);"}, {"sha": "384e3554cbbe1335f3707ebc03eb52b1015bbdee", "filename": "src/tools/clippy/tests/ui/floating_point_logbase.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -9,20 +9,26 @@ LL |     let _ = x.ln() / y.ln();\n error: log base can be expressed more clearly\n   --> $DIR/floating_point_logbase.rs:8:13\n    |\n+LL |     let _ = (x as f32).ln() / y.ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x as f32).log(y)`\n+\n+error: log base can be expressed more clearly\n+  --> $DIR/floating_point_logbase.rs:9:13\n+   |\n LL |     let _ = x.log2() / y.log2();\n    |             ^^^^^^^^^^^^^^^^^^^ help: consider using: `x.log(y)`\n \n error: log base can be expressed more clearly\n-  --> $DIR/floating_point_logbase.rs:9:13\n+  --> $DIR/floating_point_logbase.rs:10:13\n    |\n LL |     let _ = x.log10() / y.log10();\n    |             ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.log(y)`\n \n error: log base can be expressed more clearly\n-  --> $DIR/floating_point_logbase.rs:10:13\n+  --> $DIR/floating_point_logbase.rs:11:13\n    |\n LL |     let _ = x.log(5f32) / y.log(5f32);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.log(y)`\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 5 previous errors\n "}, {"sha": "7efe10a10f9e9809db283ef8bf73378a16bbe31a", "filename": "src/tools/clippy/tests/ui/floating_point_powf.fixed", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -11,10 +11,13 @@ fn main() {\n     let _ = (-3.1f32).exp();\n     let _ = x.sqrt();\n     let _ = x.cbrt();\n+    let _ = (x as f32).cbrt();\n     let _ = x.powi(3);\n     let _ = x.powi(-2);\n     let _ = x.powi(16_777_215);\n     let _ = x.powi(-16_777_215);\n+    let _ = (x as f32).powi(-16_777_215);\n+    let _ = (x as f32).powi(3);\n     // Cases where the lint shouldn't be applied\n     let _ = x.powf(2.1);\n     let _ = x.powf(-2.1);"}, {"sha": "445080417f2ed8c2a0e5b7f1f1a799286077c2f8", "filename": "src/tools/clippy/tests/ui/floating_point_powf.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -11,10 +11,13 @@ fn main() {\n     let _ = std::f32::consts::E.powf(-3.1);\n     let _ = x.powf(1.0 / 2.0);\n     let _ = x.powf(1.0 / 3.0);\n+    let _ = (x as f32).powf(1.0 / 3.0);\n     let _ = x.powf(3.0);\n     let _ = x.powf(-2.0);\n     let _ = x.powf(16_777_215.0);\n     let _ = x.powf(-16_777_215.0);\n+    let _ = (x as f32).powf(-16_777_215.0);\n+    let _ = (x as f32).powf(3.0);\n     // Cases where the lint shouldn't be applied\n     let _ = x.powf(2.1);\n     let _ = x.powf(-2.1);"}, {"sha": "6ee696e6ada5ffda8d5580258d2ec7074bcfee3a", "filename": "src/tools/clippy/tests/ui/floating_point_powf.stderr", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -50,101 +50,119 @@ LL |     let _ = x.powf(1.0 / 3.0);\n    |\n    = note: `-D clippy::imprecise-flops` implied by `-D warnings`\n \n-error: exponentiation with integer powers can be computed more efficiently\n+error: cube-root of a number can be computed more accurately\n   --> $DIR/floating_point_powf.rs:14:13\n    |\n+LL |     let _ = (x as f32).powf(1.0 / 3.0);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x as f32).cbrt()`\n+\n+error: exponentiation with integer powers can be computed more efficiently\n+  --> $DIR/floating_point_powf.rs:15:13\n+   |\n LL |     let _ = x.powf(3.0);\n    |             ^^^^^^^^^^^ help: consider using: `x.powi(3)`\n \n error: exponentiation with integer powers can be computed more efficiently\n-  --> $DIR/floating_point_powf.rs:15:13\n+  --> $DIR/floating_point_powf.rs:16:13\n    |\n LL |     let _ = x.powf(-2.0);\n    |             ^^^^^^^^^^^^ help: consider using: `x.powi(-2)`\n \n error: exponentiation with integer powers can be computed more efficiently\n-  --> $DIR/floating_point_powf.rs:16:13\n+  --> $DIR/floating_point_powf.rs:17:13\n    |\n LL |     let _ = x.powf(16_777_215.0);\n    |             ^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(16_777_215)`\n \n error: exponentiation with integer powers can be computed more efficiently\n-  --> $DIR/floating_point_powf.rs:17:13\n+  --> $DIR/floating_point_powf.rs:18:13\n    |\n LL |     let _ = x.powf(-16_777_215.0);\n    |             ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(-16_777_215)`\n \n+error: exponentiation with integer powers can be computed more efficiently\n+  --> $DIR/floating_point_powf.rs:19:13\n+   |\n+LL |     let _ = (x as f32).powf(-16_777_215.0);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x as f32).powi(-16_777_215)`\n+\n+error: exponentiation with integer powers can be computed more efficiently\n+  --> $DIR/floating_point_powf.rs:20:13\n+   |\n+LL |     let _ = (x as f32).powf(3.0);\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x as f32).powi(3)`\n+\n error: exponent for bases 2 and e can be computed more accurately\n-  --> $DIR/floating_point_powf.rs:25:13\n+  --> $DIR/floating_point_powf.rs:28:13\n    |\n LL |     let _ = 2f64.powf(x);\n    |             ^^^^^^^^^^^^ help: consider using: `x.exp2()`\n \n error: exponent for bases 2 and e can be computed more accurately\n-  --> $DIR/floating_point_powf.rs:26:13\n+  --> $DIR/floating_point_powf.rs:29:13\n    |\n LL |     let _ = 2f64.powf(3.1);\n    |             ^^^^^^^^^^^^^^ help: consider using: `3.1f64.exp2()`\n \n error: exponent for bases 2 and e can be computed more accurately\n-  --> $DIR/floating_point_powf.rs:27:13\n+  --> $DIR/floating_point_powf.rs:30:13\n    |\n LL |     let _ = 2f64.powf(-3.1);\n    |             ^^^^^^^^^^^^^^^ help: consider using: `(-3.1f64).exp2()`\n \n error: exponent for bases 2 and e can be computed more accurately\n-  --> $DIR/floating_point_powf.rs:28:13\n+  --> $DIR/floating_point_powf.rs:31:13\n    |\n LL |     let _ = std::f64::consts::E.powf(x);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.exp()`\n \n error: exponent for bases 2 and e can be computed more accurately\n-  --> $DIR/floating_point_powf.rs:29:13\n+  --> $DIR/floating_point_powf.rs:32:13\n    |\n LL |     let _ = std::f64::consts::E.powf(3.1);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `3.1f64.exp()`\n \n error: exponent for bases 2 and e can be computed more accurately\n-  --> $DIR/floating_point_powf.rs:30:13\n+  --> $DIR/floating_point_powf.rs:33:13\n    |\n LL |     let _ = std::f64::consts::E.powf(-3.1);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(-3.1f64).exp()`\n \n error: square-root of a number can be computed more efficiently and accurately\n-  --> $DIR/floating_point_powf.rs:31:13\n+  --> $DIR/floating_point_powf.rs:34:13\n    |\n LL |     let _ = x.powf(1.0 / 2.0);\n    |             ^^^^^^^^^^^^^^^^^ help: consider using: `x.sqrt()`\n \n error: cube-root of a number can be computed more accurately\n-  --> $DIR/floating_point_powf.rs:32:13\n+  --> $DIR/floating_point_powf.rs:35:13\n    |\n LL |     let _ = x.powf(1.0 / 3.0);\n    |             ^^^^^^^^^^^^^^^^^ help: consider using: `x.cbrt()`\n \n error: exponentiation with integer powers can be computed more efficiently\n-  --> $DIR/floating_point_powf.rs:33:13\n+  --> $DIR/floating_point_powf.rs:36:13\n    |\n LL |     let _ = x.powf(3.0);\n    |             ^^^^^^^^^^^ help: consider using: `x.powi(3)`\n \n error: exponentiation with integer powers can be computed more efficiently\n-  --> $DIR/floating_point_powf.rs:34:13\n+  --> $DIR/floating_point_powf.rs:37:13\n    |\n LL |     let _ = x.powf(-2.0);\n    |             ^^^^^^^^^^^^ help: consider using: `x.powi(-2)`\n \n error: exponentiation with integer powers can be computed more efficiently\n-  --> $DIR/floating_point_powf.rs:35:13\n+  --> $DIR/floating_point_powf.rs:38:13\n    |\n LL |     let _ = x.powf(-2_147_483_648.0);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(-2_147_483_648)`\n \n error: exponentiation with integer powers can be computed more efficiently\n-  --> $DIR/floating_point_powf.rs:36:13\n+  --> $DIR/floating_point_powf.rs:39:13\n    |\n LL |     let _ = x.powf(2_147_483_647.0);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(2_147_483_647)`\n \n-error: aborting due to 24 previous errors\n+error: aborting due to 27 previous errors\n "}, {"sha": "5758db7c6c82d90506cc76a561f5d3ac18dfe021", "filename": "src/tools/clippy/tests/ui/floating_point_powi.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -8,6 +8,7 @@ fn main() {\n     let y = 4f32;\n     let _ = x.mul_add(x, y);\n     let _ = y.mul_add(y, x);\n+    let _ = (y as f32).mul_add(y as f32, x);\n     let _ = x.mul_add(x, y).sqrt();\n     let _ = y.mul_add(y, x).sqrt();\n     // Cases where the lint shouldn't be applied"}, {"sha": "5926bf1b0004265c96a82b53a9e8abaefcdedcc2", "filename": "src/tools/clippy/tests/ui/floating_point_powi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -8,6 +8,7 @@ fn main() {\n     let y = 4f32;\n     let _ = x.powi(2) + y;\n     let _ = x + y.powi(2);\n+    let _ = x + (y as f32).powi(2);\n     let _ = (x.powi(2) + y).sqrt();\n     let _ = (x + y.powi(2)).sqrt();\n     // Cases where the lint shouldn't be applied"}, {"sha": "a3c74544212b22e1f082e7d4938b14c60775f062", "filename": "src/tools/clippy/tests/ui/floating_point_powi.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -15,14 +15,20 @@ LL |     let _ = x + y.powi(2);\n error: multiply and add expressions can be calculated more efficiently and accurately\n   --> $DIR/floating_point_powi.rs:11:13\n    |\n+LL |     let _ = x + (y as f32).powi(2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(y as f32).mul_add(y as f32, x)`\n+\n+error: multiply and add expressions can be calculated more efficiently and accurately\n+  --> $DIR/floating_point_powi.rs:12:13\n+   |\n LL |     let _ = (x.powi(2) + y).sqrt();\n    |             ^^^^^^^^^^^^^^^ help: consider using: `x.mul_add(x, y)`\n \n error: multiply and add expressions can be calculated more efficiently and accurately\n-  --> $DIR/floating_point_powi.rs:12:13\n+  --> $DIR/floating_point_powi.rs:13:13\n    |\n LL |     let _ = (x + y.powi(2)).sqrt();\n    |             ^^^^^^^^^^^^^^^ help: consider using: `y.mul_add(y, x)`\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 5 previous errors\n "}, {"sha": "27674b8a455b099a30d9f7be60cceb729628e077", "filename": "src/tools/clippy/tests/ui/floating_point_rad.fixed", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -8,6 +8,11 @@ pub const fn const_context() {\n     let _ = x * 180f32 / std::f32::consts::PI;\n }\n \n+pub fn issue9391(degrees: i64) {\n+    let _ = (degrees as f64).to_radians();\n+    let _ = (degrees as f64).to_degrees();\n+}\n+\n fn main() {\n     let x = 3f32;\n     let _ = x.to_degrees();"}, {"sha": "f1ea73df39845d988b5437125ee05a82057eb8bc", "filename": "src/tools/clippy/tests/ui/floating_point_rad.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -8,6 +8,11 @@ pub const fn const_context() {\n     let _ = x * 180f32 / std::f32::consts::PI;\n }\n \n+pub fn issue9391(degrees: i64) {\n+    let _ = degrees as f64 * std::f64::consts::PI / 180.0;\n+    let _ = degrees as f64 * 180.0 / std::f64::consts::PI;\n+}\n+\n fn main() {\n     let x = 3f32;\n     let _ = x * 180f32 / std::f32::consts::PI;"}, {"sha": "979442f2c24a371d57d38aa7546e790ef7b5c638", "filename": "src/tools/clippy/tests/ui/floating_point_rad.stderr", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,40 +1,52 @@\n+error: conversion to radians can be done more accurately\n+  --> $DIR/floating_point_rad.rs:12:13\n+   |\n+LL |     let _ = degrees as f64 * std::f64::consts::PI / 180.0;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(degrees as f64).to_radians()`\n+   |\n+   = note: `-D clippy::suboptimal-flops` implied by `-D warnings`\n+\n error: conversion to degrees can be done more accurately\n   --> $DIR/floating_point_rad.rs:13:13\n    |\n+LL |     let _ = degrees as f64 * 180.0 / std::f64::consts::PI;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(degrees as f64).to_degrees()`\n+\n+error: conversion to degrees can be done more accurately\n+  --> $DIR/floating_point_rad.rs:18:13\n+   |\n LL |     let _ = x * 180f32 / std::f32::consts::PI;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.to_degrees()`\n-   |\n-   = note: `-D clippy::suboptimal-flops` implied by `-D warnings`\n \n error: conversion to degrees can be done more accurately\n-  --> $DIR/floating_point_rad.rs:14:13\n+  --> $DIR/floating_point_rad.rs:19:13\n    |\n LL |     let _ = 90. * 180f64 / std::f64::consts::PI;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `90.0_f64.to_degrees()`\n \n error: conversion to degrees can be done more accurately\n-  --> $DIR/floating_point_rad.rs:15:13\n+  --> $DIR/floating_point_rad.rs:20:13\n    |\n LL |     let _ = 90.5 * 180f64 / std::f64::consts::PI;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `90.5_f64.to_degrees()`\n \n error: conversion to radians can be done more accurately\n-  --> $DIR/floating_point_rad.rs:16:13\n+  --> $DIR/floating_point_rad.rs:21:13\n    |\n LL |     let _ = x * std::f32::consts::PI / 180f32;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.to_radians()`\n \n error: conversion to radians can be done more accurately\n-  --> $DIR/floating_point_rad.rs:17:13\n+  --> $DIR/floating_point_rad.rs:22:13\n    |\n LL |     let _ = 90. * std::f32::consts::PI / 180f32;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `90.0_f64.to_radians()`\n \n error: conversion to radians can be done more accurately\n-  --> $DIR/floating_point_rad.rs:18:13\n+  --> $DIR/floating_point_rad.rs:23:13\n    |\n LL |     let _ = 90.5 * std::f32::consts::PI / 180f32;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `90.5_f64.to_radians()`\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 8 previous errors\n "}, {"sha": "b56d6aec508d38bda3189d67fd5610f971166d4e", "filename": "src/tools/clippy/tests/ui/format.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -33,7 +33,7 @@ fn main() {\n     format!(\"foo {}\", \"bar\");\n     format!(\"{} bar\", \"foo\");\n \n-    let arg: String = \"\".to_owned();\n+    let arg = String::new();\n     arg.to_string();\n     format!(\"{:?}\", arg); // Don't warn about debug.\n     format!(\"{:8}\", arg);"}, {"sha": "4c1a3a840ed96721f5cd87d7496c3e1edec99f94", "filename": "src/tools/clippy/tests/ui/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -35,7 +35,7 @@ fn main() {\n     format!(\"foo {}\", \"bar\");\n     format!(\"{} bar\", \"foo\");\n \n-    let arg: String = \"\".to_owned();\n+    let arg = String::new();\n     format!(\"{}\", arg);\n     format!(\"{:?}\", arg); // Don't warn about debug.\n     format!(\"{:8}\", arg);"}, {"sha": "e1c2d4d70be4f65effd89e0d84edfa3b77fcf3bd", "filename": "src/tools/clippy/tests/ui/format_args.fixed", "status": "modified", "additions": 48, "deletions": 3, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat_args.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat_args.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat_args.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,8 +1,6 @@\n // run-rustfix\n \n-#![allow(unreachable_code)]\n-#![allow(unused_macros)]\n-#![allow(unused_variables)]\n+#![allow(unused)]\n #![allow(clippy::assertions_on_constants)]\n #![allow(clippy::eq_op)]\n #![allow(clippy::print_literal)]\n@@ -115,3 +113,50 @@ fn main() {\n     // https://github.com/rust-lang/rust-clippy/issues/7903\n     println!(\"{foo}{foo:?}\", foo = \"foo\".to_string());\n }\n+\n+fn issue8643(vendor_id: usize, product_id: usize, name: &str) {\n+    println!(\n+        \"{:<9}  {:<10}  {}\",\n+        format!(\"0x{:x}\", vendor_id),\n+        format!(\"0x{:x}\", product_id),\n+        name\n+    );\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/issues/8855\n+mod issue_8855 {\n+    #![allow(dead_code)]\n+\n+    struct A {}\n+\n+    impl std::fmt::Display for A {\n+        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+            write!(f, \"test\")\n+        }\n+    }\n+\n+    fn main() {\n+        let a = A {};\n+        let b = A {};\n+\n+        let x = format!(\"{} {}\", a, b);\n+        dbg!(x);\n+\n+        let x = format!(\"{:>6} {:>6}\", a, b.to_string());\n+        dbg!(x);\n+    }\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/issues/9256\n+mod issue_9256 {\n+    #![allow(dead_code)]\n+\n+    fn print_substring(original: &str) {\n+        assert!(original.len() > 10);\n+        println!(\"{}\", &original[..10]);\n+    }\n+\n+    fn main() {\n+        print_substring(\"Hello, world!\");\n+    }\n+}"}, {"sha": "b9a4d66c28ad9f4f85390dc427dca8d08e66bcdc", "filename": "src/tools/clippy/tests/ui/format_args.rs", "status": "modified", "additions": 48, "deletions": 3, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat_args.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,8 +1,6 @@\n // run-rustfix\n \n-#![allow(unreachable_code)]\n-#![allow(unused_macros)]\n-#![allow(unused_variables)]\n+#![allow(unused)]\n #![allow(clippy::assertions_on_constants)]\n #![allow(clippy::eq_op)]\n #![allow(clippy::print_literal)]\n@@ -115,3 +113,50 @@ fn main() {\n     // https://github.com/rust-lang/rust-clippy/issues/7903\n     println!(\"{foo}{foo:?}\", foo = \"foo\".to_string());\n }\n+\n+fn issue8643(vendor_id: usize, product_id: usize, name: &str) {\n+    println!(\n+        \"{:<9}  {:<10}  {}\",\n+        format!(\"0x{:x}\", vendor_id),\n+        format!(\"0x{:x}\", product_id),\n+        name\n+    );\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/issues/8855\n+mod issue_8855 {\n+    #![allow(dead_code)]\n+\n+    struct A {}\n+\n+    impl std::fmt::Display for A {\n+        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+            write!(f, \"test\")\n+        }\n+    }\n+\n+    fn main() {\n+        let a = A {};\n+        let b = A {};\n+\n+        let x = format!(\"{} {}\", a, b.to_string());\n+        dbg!(x);\n+\n+        let x = format!(\"{:>6} {:>6}\", a, b.to_string());\n+        dbg!(x);\n+    }\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/issues/9256\n+mod issue_9256 {\n+    #![allow(dead_code)]\n+\n+    fn print_substring(original: &str) {\n+        assert!(original.len() > 10);\n+        println!(\"{}\", original[..10].to_string());\n+    }\n+\n+    fn main() {\n+        print_substring(\"Hello, world!\");\n+    }\n+}"}, {"sha": "aa6e3659b43b519d19f14fa7ecd395a7d7763bda", "filename": "src/tools/clippy/tests/ui/format_args.stderr", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat_args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat_args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat_args.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,130 +1,142 @@\n error: `to_string` applied to a type that implements `Display` in `format!` args\n-  --> $DIR/format_args.rs:76:72\n+  --> $DIR/format_args.rs:74:72\n    |\n LL |     let _ = format!(\"error: something failed at {}\", Location::caller().to_string());\n    |                                                                        ^^^^^^^^^^^^ help: remove this\n    |\n    = note: `-D clippy::to-string-in-format-args` implied by `-D warnings`\n \n error: `to_string` applied to a type that implements `Display` in `write!` args\n-  --> $DIR/format_args.rs:80:27\n+  --> $DIR/format_args.rs:78:27\n    |\n LL |         Location::caller().to_string()\n    |                           ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `writeln!` args\n-  --> $DIR/format_args.rs:85:27\n+  --> $DIR/format_args.rs:83:27\n    |\n LL |         Location::caller().to_string()\n    |                           ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `print!` args\n-  --> $DIR/format_args.rs:87:63\n+  --> $DIR/format_args.rs:85:63\n    |\n LL |     print!(\"error: something failed at {}\", Location::caller().to_string());\n    |                                                               ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:88:65\n+  --> $DIR/format_args.rs:86:65\n    |\n LL |     println!(\"error: something failed at {}\", Location::caller().to_string());\n    |                                                                 ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `eprint!` args\n-  --> $DIR/format_args.rs:89:64\n+  --> $DIR/format_args.rs:87:64\n    |\n LL |     eprint!(\"error: something failed at {}\", Location::caller().to_string());\n    |                                                                ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `eprintln!` args\n-  --> $DIR/format_args.rs:90:66\n+  --> $DIR/format_args.rs:88:66\n    |\n LL |     eprintln!(\"error: something failed at {}\", Location::caller().to_string());\n    |                                                                  ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `format_args!` args\n-  --> $DIR/format_args.rs:91:77\n+  --> $DIR/format_args.rs:89:77\n    |\n LL |     let _ = format_args!(\"error: something failed at {}\", Location::caller().to_string());\n    |                                                                             ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `assert!` args\n-  --> $DIR/format_args.rs:92:70\n+  --> $DIR/format_args.rs:90:70\n    |\n LL |     assert!(true, \"error: something failed at {}\", Location::caller().to_string());\n    |                                                                      ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `assert_eq!` args\n-  --> $DIR/format_args.rs:93:73\n+  --> $DIR/format_args.rs:91:73\n    |\n LL |     assert_eq!(0, 0, \"error: something failed at {}\", Location::caller().to_string());\n    |                                                                         ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `assert_ne!` args\n-  --> $DIR/format_args.rs:94:73\n+  --> $DIR/format_args.rs:92:73\n    |\n LL |     assert_ne!(0, 0, \"error: something failed at {}\", Location::caller().to_string());\n    |                                                                         ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `panic!` args\n-  --> $DIR/format_args.rs:95:63\n+  --> $DIR/format_args.rs:93:63\n    |\n LL |     panic!(\"error: something failed at {}\", Location::caller().to_string());\n    |                                                               ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:96:20\n+  --> $DIR/format_args.rs:94:20\n    |\n LL |     println!(\"{}\", X(1).to_string());\n    |                    ^^^^^^^^^^^^^^^^ help: use this: `*X(1)`\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:97:20\n+  --> $DIR/format_args.rs:95:20\n    |\n LL |     println!(\"{}\", Y(&X(1)).to_string());\n    |                    ^^^^^^^^^^^^^^^^^^^^ help: use this: `***Y(&X(1))`\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:98:24\n+  --> $DIR/format_args.rs:96:24\n    |\n LL |     println!(\"{}\", Z(1).to_string());\n    |                        ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:99:20\n+  --> $DIR/format_args.rs:97:20\n    |\n LL |     println!(\"{}\", x.to_string());\n    |                    ^^^^^^^^^^^^^ help: use this: `**x`\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:100:20\n+  --> $DIR/format_args.rs:98:20\n    |\n LL |     println!(\"{}\", x_ref.to_string());\n    |                    ^^^^^^^^^^^^^^^^^ help: use this: `***x_ref`\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:102:39\n+  --> $DIR/format_args.rs:100:39\n    |\n LL |     println!(\"{foo}{bar}\", foo = \"foo\".to_string(), bar = \"bar\");\n    |                                       ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:103:52\n+  --> $DIR/format_args.rs:101:52\n    |\n LL |     println!(\"{foo}{bar}\", foo = \"foo\", bar = \"bar\".to_string());\n    |                                                    ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:104:39\n+  --> $DIR/format_args.rs:102:39\n    |\n LL |     println!(\"{foo}{bar}\", bar = \"bar\".to_string(), foo = \"foo\");\n    |                                       ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:105:52\n+  --> $DIR/format_args.rs:103:52\n    |\n LL |     println!(\"{foo}{bar}\", bar = \"bar\", foo = \"foo\".to_string());\n    |                                                    ^^^^^^^^^^^^ help: remove this\n \n-error: aborting due to 21 previous errors\n+error: `to_string` applied to a type that implements `Display` in `format!` args\n+  --> $DIR/format_args.rs:142:38\n+   |\n+LL |         let x = format!(\"{} {}\", a, b.to_string());\n+   |                                      ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `println!` args\n+  --> $DIR/format_args.rs:156:24\n+   |\n+LL |         println!(\"{}\", original[..10].to_string());\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use this: `&original[..10]`\n+\n+error: aborting due to 23 previous errors\n "}, {"sha": "fa564e23cd275cb270a64ae9510504e91c81657d", "filename": "src/tools/clippy/tests/ui/identity_op.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fidentity_op.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fidentity_op.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fidentity_op.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -68,7 +68,7 @@ fn main() {\n     &x;\n     x;\n \n-    let mut a = A(\"\".into());\n+    let mut a = A(String::new());\n     let b = a << 0; // no error: non-integer\n \n     1 * Meter; // no error: non-integer"}, {"sha": "3d06d2a73b628d7b760d3a8c3684c8d15c4ebde7", "filename": "src/tools/clippy/tests/ui/identity_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fidentity_op.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -68,7 +68,7 @@ fn main() {\n     &x >> 0;\n     x >> &0;\n \n-    let mut a = A(\"\".into());\n+    let mut a = A(String::new());\n     let b = a << 0; // no error: non-integer\n \n     1 * Meter; // no error: non-integer"}, {"sha": "321feb0224ed11a97d111f645b8c77b7af073b89", "filename": "src/tools/clippy/tests/ui/if_let_mutex.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_let_mutex.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -39,4 +39,12 @@ fn if_let_different_mutex() {\n     };\n }\n \n+fn mutex_ref(mutex: &Mutex<i32>) {\n+    if let Ok(i) = mutex.lock() {\n+        do_stuff(i);\n+    } else {\n+        let _x = mutex.lock();\n+    };\n+}\n+\n fn main() {}"}, {"sha": "8a4d5dbac592b33d12a0d3b0061413a719e17248", "filename": "src/tools/clippy/tests/ui/if_let_mutex.stderr", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_let_mutex.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_let_mutex.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_let_mutex.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,10 +1,14 @@\n error: calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock\n   --> $DIR/if_let_mutex.rs:10:5\n    |\n-LL | /     if let Err(locked) = m.lock() {\n+LL |       if let Err(locked) = m.lock() {\n+   |       ^                    - this Mutex will remain locked for the entire `if let`-block...\n+   |  _____|\n+   | |\n LL | |         do_stuff(locked);\n LL | |     } else {\n LL | |         let lock = m.lock().unwrap();\n+   | |                    - ... and is tried to lock again here, which will always deadlock.\n LL | |         do_stuff(lock);\n LL | |     };\n    | |_____^\n@@ -15,15 +19,35 @@ LL | |     };\n error: calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock\n   --> $DIR/if_let_mutex.rs:22:5\n    |\n-LL | /     if let Some(locked) = m.lock().unwrap().deref() {\n+LL |       if let Some(locked) = m.lock().unwrap().deref() {\n+   |       ^                     - this Mutex will remain locked for the entire `if let`-block...\n+   |  _____|\n+   | |\n LL | |         do_stuff(locked);\n LL | |     } else {\n LL | |         let lock = m.lock().unwrap();\n+   | |                    - ... and is tried to lock again here, which will always deadlock.\n LL | |         do_stuff(lock);\n LL | |     };\n    | |_____^\n    |\n    = help: move the lock call outside of the `if let ...` expression\n \n-error: aborting due to 2 previous errors\n+error: calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock\n+  --> $DIR/if_let_mutex.rs:43:5\n+   |\n+LL |       if let Ok(i) = mutex.lock() {\n+   |       ^              ----- this Mutex will remain locked for the entire `if let`-block...\n+   |  _____|\n+   | |\n+LL | |         do_stuff(i);\n+LL | |     } else {\n+LL | |         let _x = mutex.lock();\n+   | |                  ----- ... and is tried to lock again here, which will always deadlock.\n+LL | |     };\n+   | |_____^\n+   |\n+   = help: move the lock call outside of the `if let ...` expression\n+\n+error: aborting due to 3 previous errors\n "}, {"sha": "c22ace30d2dc21defe9cefa3108599f228860f27", "filename": "src/tools/clippy/tests/ui/if_then_some_else_none.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_then_some_else_none.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_then_some_else_none.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_then_some_else_none.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -27,21 +27,21 @@ LL | |     };\n    |\n    = help: consider using `bool::then` like: `matches!(true, true).then(|| { /* snippet */ matches!(true, false) })`\n \n-error: this could be simplified with `bool::then`\n+error: this could be simplified with `bool::then_some`\n   --> $DIR/if_then_some_else_none.rs:23:28\n    |\n LL |     let _ = x.and_then(|o| if o < 32 { Some(o) } else { None });\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: consider using `bool::then` like: `(o < 32).then(|| o)`\n+   = help: consider using `bool::then_some` like: `(o < 32).then_some(o)`\n \n-error: this could be simplified with `bool::then`\n+error: this could be simplified with `bool::then_some`\n   --> $DIR/if_then_some_else_none.rs:27:13\n    |\n LL |     let _ = if !x { Some(0) } else { None };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: consider using `bool::then` like: `(!x).then(|| 0)`\n+   = help: consider using `bool::then_some` like: `(!x).then_some(0)`\n \n error: this could be simplified with `bool::then`\n   --> $DIR/if_then_some_else_none.rs:82:13"}, {"sha": "bd9b07aefbfb85afd0a64ea4d96f1436a7f9d87b", "filename": "src/tools/clippy/tests/ui/iter_on_empty_collections.fixed", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_on_empty_collections.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_on_empty_collections.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_on_empty_collections.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,63 @@\n+// run-rustfix\n+#![warn(clippy::iter_on_empty_collections)]\n+#![allow(clippy::iter_next_slice, clippy::redundant_clone)]\n+\n+fn array() {\n+    assert_eq!(std::iter::empty().next(), Option::<i32>::None);\n+    assert_eq!(std::iter::empty().next(), Option::<&mut i32>::None);\n+    assert_eq!(std::iter::empty().next(), Option::<&i32>::None);\n+    assert_eq!(std::iter::empty().next(), Option::<i32>::None);\n+    assert_eq!(std::iter::empty().next(), Option::<&mut i32>::None);\n+    assert_eq!(std::iter::empty().next(), Option::<&i32>::None);\n+\n+    // Don't trigger on non-iter methods\n+    let _: Option<String> = None.clone();\n+    let _: [String; 0] = [].clone();\n+\n+    // Don't trigger on match or if branches\n+    let _ = match 123 {\n+        123 => [].iter(),\n+        _ => [\"test\"].iter(),\n+    };\n+\n+    let _ = if false { [\"test\"].iter() } else { [].iter() };\n+}\n+\n+macro_rules! in_macros {\n+    () => {\n+        assert_eq!([].into_iter().next(), Option::<i32>::None);\n+        assert_eq!([].iter_mut().next(), Option::<&mut i32>::None);\n+        assert_eq!([].iter().next(), Option::<&i32>::None);\n+        assert_eq!(None.into_iter().next(), Option::<i32>::None);\n+        assert_eq!(None.iter_mut().next(), Option::<&mut i32>::None);\n+        assert_eq!(None.iter().next(), Option::<&i32>::None);\n+    };\n+}\n+\n+// Don't trigger on a `None` that isn't std's option\n+mod custom_option {\n+    #[allow(unused)]\n+    enum CustomOption {\n+        Some(i32),\n+        None,\n+    }\n+\n+    impl CustomOption {\n+        fn iter(&self) {}\n+        fn iter_mut(&mut self) {}\n+        fn into_iter(self) {}\n+    }\n+    use CustomOption::*;\n+\n+    pub fn custom_option() {\n+        None.iter();\n+        None.iter_mut();\n+        None.into_iter();\n+    }\n+}\n+\n+fn main() {\n+    array();\n+    custom_option::custom_option();\n+    in_macros!();\n+}"}, {"sha": "e15ba94bd465528d9147ef1f83a66f0b2bf9d6b3", "filename": "src/tools/clippy/tests/ui/iter_on_empty_collections.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_on_empty_collections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_on_empty_collections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_on_empty_collections.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,63 @@\n+// run-rustfix\n+#![warn(clippy::iter_on_empty_collections)]\n+#![allow(clippy::iter_next_slice, clippy::redundant_clone)]\n+\n+fn array() {\n+    assert_eq!([].into_iter().next(), Option::<i32>::None);\n+    assert_eq!([].iter_mut().next(), Option::<&mut i32>::None);\n+    assert_eq!([].iter().next(), Option::<&i32>::None);\n+    assert_eq!(None.into_iter().next(), Option::<i32>::None);\n+    assert_eq!(None.iter_mut().next(), Option::<&mut i32>::None);\n+    assert_eq!(None.iter().next(), Option::<&i32>::None);\n+\n+    // Don't trigger on non-iter methods\n+    let _: Option<String> = None.clone();\n+    let _: [String; 0] = [].clone();\n+\n+    // Don't trigger on match or if branches\n+    let _ = match 123 {\n+        123 => [].iter(),\n+        _ => [\"test\"].iter(),\n+    };\n+\n+    let _ = if false { [\"test\"].iter() } else { [].iter() };\n+}\n+\n+macro_rules! in_macros {\n+    () => {\n+        assert_eq!([].into_iter().next(), Option::<i32>::None);\n+        assert_eq!([].iter_mut().next(), Option::<&mut i32>::None);\n+        assert_eq!([].iter().next(), Option::<&i32>::None);\n+        assert_eq!(None.into_iter().next(), Option::<i32>::None);\n+        assert_eq!(None.iter_mut().next(), Option::<&mut i32>::None);\n+        assert_eq!(None.iter().next(), Option::<&i32>::None);\n+    };\n+}\n+\n+// Don't trigger on a `None` that isn't std's option\n+mod custom_option {\n+    #[allow(unused)]\n+    enum CustomOption {\n+        Some(i32),\n+        None,\n+    }\n+\n+    impl CustomOption {\n+        fn iter(&self) {}\n+        fn iter_mut(&mut self) {}\n+        fn into_iter(self) {}\n+    }\n+    use CustomOption::*;\n+\n+    pub fn custom_option() {\n+        None.iter();\n+        None.iter_mut();\n+        None.into_iter();\n+    }\n+}\n+\n+fn main() {\n+    array();\n+    custom_option::custom_option();\n+    in_macros!();\n+}"}, {"sha": "cbd611769569670ab06ce18c3fbde8bba2308ddb", "filename": "src/tools/clippy/tests/ui/iter_on_empty_collections.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_on_empty_collections.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_on_empty_collections.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_on_empty_collections.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,40 @@\n+error: `into_iter` call on an empty collection\n+  --> $DIR/iter_on_empty_collections.rs:6:16\n+   |\n+LL |     assert_eq!([].into_iter().next(), Option::<i32>::None);\n+   |                ^^^^^^^^^^^^^^ help: try: `std::iter::empty()`\n+   |\n+   = note: `-D clippy::iter-on-empty-collections` implied by `-D warnings`\n+\n+error: `iter_mut` call on an empty collection\n+  --> $DIR/iter_on_empty_collections.rs:7:16\n+   |\n+LL |     assert_eq!([].iter_mut().next(), Option::<&mut i32>::None);\n+   |                ^^^^^^^^^^^^^ help: try: `std::iter::empty()`\n+\n+error: `iter` call on an empty collection\n+  --> $DIR/iter_on_empty_collections.rs:8:16\n+   |\n+LL |     assert_eq!([].iter().next(), Option::<&i32>::None);\n+   |                ^^^^^^^^^ help: try: `std::iter::empty()`\n+\n+error: `into_iter` call on an empty collection\n+  --> $DIR/iter_on_empty_collections.rs:9:16\n+   |\n+LL |     assert_eq!(None.into_iter().next(), Option::<i32>::None);\n+   |                ^^^^^^^^^^^^^^^^ help: try: `std::iter::empty()`\n+\n+error: `iter_mut` call on an empty collection\n+  --> $DIR/iter_on_empty_collections.rs:10:16\n+   |\n+LL |     assert_eq!(None.iter_mut().next(), Option::<&mut i32>::None);\n+   |                ^^^^^^^^^^^^^^^ help: try: `std::iter::empty()`\n+\n+error: `iter` call on an empty collection\n+  --> $DIR/iter_on_empty_collections.rs:11:16\n+   |\n+LL |     assert_eq!(None.iter().next(), Option::<&i32>::None);\n+   |                ^^^^^^^^^^^ help: try: `std::iter::empty()`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "1fa4b03641bc73334438a452644037a410b6cbcc", "filename": "src/tools/clippy/tests/ui/iter_on_single_items.fixed", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_on_single_items.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_on_single_items.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_on_single_items.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,63 @@\n+// run-rustfix\n+#![warn(clippy::iter_on_single_items)]\n+#![allow(clippy::iter_next_slice, clippy::redundant_clone)]\n+\n+fn array() {\n+    assert_eq!(std::iter::once(123).next(), Some(123));\n+    assert_eq!(std::iter::once(&mut 123).next(), Some(&mut 123));\n+    assert_eq!(std::iter::once(&123).next(), Some(&123));\n+    assert_eq!(std::iter::once(123).next(), Some(123));\n+    assert_eq!(std::iter::once(&mut 123).next(), Some(&mut 123));\n+    assert_eq!(std::iter::once(&123).next(), Some(&123));\n+\n+    // Don't trigger on non-iter methods\n+    let _: Option<String> = Some(\"test\".to_string()).clone();\n+    let _: [String; 1] = [\"test\".to_string()].clone();\n+\n+    // Don't trigger on match or if branches\n+    let _ = match 123 {\n+        123 => [].iter(),\n+        _ => [\"test\"].iter(),\n+    };\n+\n+    let _ = if false { [\"test\"].iter() } else { [].iter() };\n+}\n+\n+macro_rules! in_macros {\n+    () => {\n+        assert_eq!([123].into_iter().next(), Some(123));\n+        assert_eq!([123].iter_mut().next(), Some(&mut 123));\n+        assert_eq!([123].iter().next(), Some(&123));\n+        assert_eq!(Some(123).into_iter().next(), Some(123));\n+        assert_eq!(Some(123).iter_mut().next(), Some(&mut 123));\n+        assert_eq!(Some(123).iter().next(), Some(&123));\n+    };\n+}\n+\n+// Don't trigger on a `Some` that isn't std's option\n+mod custom_option {\n+    #[allow(unused)]\n+    enum CustomOption {\n+        Some(i32),\n+        None,\n+    }\n+\n+    impl CustomOption {\n+        fn iter(&self) {}\n+        fn iter_mut(&mut self) {}\n+        fn into_iter(self) {}\n+    }\n+    use CustomOption::*;\n+\n+    pub fn custom_option() {\n+        Some(3).iter();\n+        Some(3).iter_mut();\n+        Some(3).into_iter();\n+    }\n+}\n+\n+fn main() {\n+    array();\n+    custom_option::custom_option();\n+    in_macros!();\n+}"}, {"sha": "ea96d8066c568588ce493bb1394705e5b313a4dd", "filename": "src/tools/clippy/tests/ui/iter_on_single_items.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_on_single_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_on_single_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_on_single_items.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,63 @@\n+// run-rustfix\n+#![warn(clippy::iter_on_single_items)]\n+#![allow(clippy::iter_next_slice, clippy::redundant_clone)]\n+\n+fn array() {\n+    assert_eq!([123].into_iter().next(), Some(123));\n+    assert_eq!([123].iter_mut().next(), Some(&mut 123));\n+    assert_eq!([123].iter().next(), Some(&123));\n+    assert_eq!(Some(123).into_iter().next(), Some(123));\n+    assert_eq!(Some(123).iter_mut().next(), Some(&mut 123));\n+    assert_eq!(Some(123).iter().next(), Some(&123));\n+\n+    // Don't trigger on non-iter methods\n+    let _: Option<String> = Some(\"test\".to_string()).clone();\n+    let _: [String; 1] = [\"test\".to_string()].clone();\n+\n+    // Don't trigger on match or if branches\n+    let _ = match 123 {\n+        123 => [].iter(),\n+        _ => [\"test\"].iter(),\n+    };\n+\n+    let _ = if false { [\"test\"].iter() } else { [].iter() };\n+}\n+\n+macro_rules! in_macros {\n+    () => {\n+        assert_eq!([123].into_iter().next(), Some(123));\n+        assert_eq!([123].iter_mut().next(), Some(&mut 123));\n+        assert_eq!([123].iter().next(), Some(&123));\n+        assert_eq!(Some(123).into_iter().next(), Some(123));\n+        assert_eq!(Some(123).iter_mut().next(), Some(&mut 123));\n+        assert_eq!(Some(123).iter().next(), Some(&123));\n+    };\n+}\n+\n+// Don't trigger on a `Some` that isn't std's option\n+mod custom_option {\n+    #[allow(unused)]\n+    enum CustomOption {\n+        Some(i32),\n+        None,\n+    }\n+\n+    impl CustomOption {\n+        fn iter(&self) {}\n+        fn iter_mut(&mut self) {}\n+        fn into_iter(self) {}\n+    }\n+    use CustomOption::*;\n+\n+    pub fn custom_option() {\n+        Some(3).iter();\n+        Some(3).iter_mut();\n+        Some(3).into_iter();\n+    }\n+}\n+\n+fn main() {\n+    array();\n+    custom_option::custom_option();\n+    in_macros!();\n+}"}, {"sha": "d6c547116363af8d77aee5d37feda615d0ac2541", "filename": "src/tools/clippy/tests/ui/iter_on_single_items.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_on_single_items.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_on_single_items.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_on_single_items.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,40 @@\n+error: `into_iter` call on a collection with only one item\n+  --> $DIR/iter_on_single_items.rs:6:16\n+   |\n+LL |     assert_eq!([123].into_iter().next(), Some(123));\n+   |                ^^^^^^^^^^^^^^^^^ help: try: `std::iter::once(123)`\n+   |\n+   = note: `-D clippy::iter-on-single-items` implied by `-D warnings`\n+\n+error: `iter_mut` call on a collection with only one item\n+  --> $DIR/iter_on_single_items.rs:7:16\n+   |\n+LL |     assert_eq!([123].iter_mut().next(), Some(&mut 123));\n+   |                ^^^^^^^^^^^^^^^^ help: try: `std::iter::once(&mut 123)`\n+\n+error: `iter` call on a collection with only one item\n+  --> $DIR/iter_on_single_items.rs:8:16\n+   |\n+LL |     assert_eq!([123].iter().next(), Some(&123));\n+   |                ^^^^^^^^^^^^ help: try: `std::iter::once(&123)`\n+\n+error: `into_iter` call on a collection with only one item\n+  --> $DIR/iter_on_single_items.rs:9:16\n+   |\n+LL |     assert_eq!(Some(123).into_iter().next(), Some(123));\n+   |                ^^^^^^^^^^^^^^^^^^^^^ help: try: `std::iter::once(123)`\n+\n+error: `iter_mut` call on a collection with only one item\n+  --> $DIR/iter_on_single_items.rs:10:16\n+   |\n+LL |     assert_eq!(Some(123).iter_mut().next(), Some(&mut 123));\n+   |                ^^^^^^^^^^^^^^^^^^^^ help: try: `std::iter::once(&mut 123)`\n+\n+error: `iter` call on a collection with only one item\n+  --> $DIR/iter_on_single_items.rs:11:16\n+   |\n+LL |     assert_eq!(Some(123).iter().next(), Some(&123));\n+   |                ^^^^^^^^^^^^^^^^ help: try: `std::iter::once(&123)`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "a376411bfbc804e3019f409f80c57050ff1fb4f6", "filename": "src/tools/clippy/tests/ui/manual_string_new.fixed", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_string_new.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_string_new.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_string_new.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,63 @@\n+// run-rustfix\n+\n+#![warn(clippy::manual_string_new)]\n+\n+macro_rules! create_strings_from_macro {\n+    // When inside a macro, nothing should warn to prevent false positives.\n+    ($some_str:expr) => {\n+        let _: String = $some_str.into();\n+        let _ = $some_str.to_string();\n+    };\n+}\n+\n+fn main() {\n+    // Method calls\n+    let _ = String::new();\n+    let _ = \"no warning\".to_string();\n+\n+    let _ = String::new();\n+    let _ = \"no warning\".to_owned();\n+\n+    let _: String = String::new();\n+    let _: String = \"no warning\".into();\n+\n+    let _: SomeOtherStruct = \"no warning\".into();\n+    let _: SomeOtherStruct = \"\".into(); // No warning too. We are not converting into String.\n+\n+    // Calls\n+    let _ = String::new();\n+    let _ = String::new();\n+    let _ = String::from(\"no warning\");\n+    let _ = SomeOtherStruct::from(\"no warning\");\n+    let _ = SomeOtherStruct::from(\"\"); // Again: no warning.\n+\n+    let _ = String::new();\n+    let _ = String::try_from(\"no warning\").unwrap();\n+    let _ = String::try_from(\"no warning\").expect(\"this should not warn\");\n+    let _ = SomeOtherStruct::try_from(\"no warning\").unwrap();\n+    let _ = SomeOtherStruct::try_from(\"\").unwrap(); // Again: no warning.\n+\n+    let _: String = String::new();\n+    let _: String = From::from(\"no warning\");\n+    let _: SomeOtherStruct = From::from(\"no warning\");\n+    let _: SomeOtherStruct = From::from(\"\"); // Again: no warning.\n+\n+    let _: String = String::new();\n+    let _: String = TryFrom::try_from(\"no warning\").unwrap();\n+    let _: String = TryFrom::try_from(\"no warning\").expect(\"this should not warn\");\n+    let _: String = String::new();\n+    let _: SomeOtherStruct = TryFrom::try_from(\"no_warning\").unwrap();\n+    let _: SomeOtherStruct = TryFrom::try_from(\"\").unwrap(); // Again: no warning.\n+\n+    // Macros (never warn)\n+    create_strings_from_macro!(\"\");\n+    create_strings_from_macro!(\"Hey\");\n+}\n+\n+struct SomeOtherStruct {}\n+\n+impl From<&str> for SomeOtherStruct {\n+    fn from(_value: &str) -> Self {\n+        Self {}\n+    }\n+}"}, {"sha": "6bfc52fb1bce3ef6ecb8b0804af955d1fdd1b2f8", "filename": "src/tools/clippy/tests/ui/manual_string_new.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_string_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_string_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_string_new.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,63 @@\n+// run-rustfix\n+\n+#![warn(clippy::manual_string_new)]\n+\n+macro_rules! create_strings_from_macro {\n+    // When inside a macro, nothing should warn to prevent false positives.\n+    ($some_str:expr) => {\n+        let _: String = $some_str.into();\n+        let _ = $some_str.to_string();\n+    };\n+}\n+\n+fn main() {\n+    // Method calls\n+    let _ = \"\".to_string();\n+    let _ = \"no warning\".to_string();\n+\n+    let _ = \"\".to_owned();\n+    let _ = \"no warning\".to_owned();\n+\n+    let _: String = \"\".into();\n+    let _: String = \"no warning\".into();\n+\n+    let _: SomeOtherStruct = \"no warning\".into();\n+    let _: SomeOtherStruct = \"\".into(); // No warning too. We are not converting into String.\n+\n+    // Calls\n+    let _ = String::from(\"\");\n+    let _ = <String>::from(\"\");\n+    let _ = String::from(\"no warning\");\n+    let _ = SomeOtherStruct::from(\"no warning\");\n+    let _ = SomeOtherStruct::from(\"\"); // Again: no warning.\n+\n+    let _ = String::try_from(\"\").unwrap();\n+    let _ = String::try_from(\"no warning\").unwrap();\n+    let _ = String::try_from(\"no warning\").expect(\"this should not warn\");\n+    let _ = SomeOtherStruct::try_from(\"no warning\").unwrap();\n+    let _ = SomeOtherStruct::try_from(\"\").unwrap(); // Again: no warning.\n+\n+    let _: String = From::from(\"\");\n+    let _: String = From::from(\"no warning\");\n+    let _: SomeOtherStruct = From::from(\"no warning\");\n+    let _: SomeOtherStruct = From::from(\"\"); // Again: no warning.\n+\n+    let _: String = TryFrom::try_from(\"\").unwrap();\n+    let _: String = TryFrom::try_from(\"no warning\").unwrap();\n+    let _: String = TryFrom::try_from(\"no warning\").expect(\"this should not warn\");\n+    let _: String = TryFrom::try_from(\"\").expect(\"this should warn\");\n+    let _: SomeOtherStruct = TryFrom::try_from(\"no_warning\").unwrap();\n+    let _: SomeOtherStruct = TryFrom::try_from(\"\").unwrap(); // Again: no warning.\n+\n+    // Macros (never warn)\n+    create_strings_from_macro!(\"\");\n+    create_strings_from_macro!(\"Hey\");\n+}\n+\n+struct SomeOtherStruct {}\n+\n+impl From<&str> for SomeOtherStruct {\n+    fn from(_value: &str) -> Self {\n+        Self {}\n+    }\n+}"}, {"sha": "e5ecfc61947a35f357e236eddf9f1bdf44914f3e", "filename": "src/tools/clippy/tests/ui/manual_string_new.stderr", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_string_new.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_string_new.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_string_new.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,58 @@\n+error: empty String is being created manually\n+  --> $DIR/manual_string_new.rs:15:13\n+   |\n+LL |     let _ = \"\".to_string();\n+   |             ^^^^^^^^^^^^^^ help: consider using: `String::new()`\n+   |\n+   = note: `-D clippy::manual-string-new` implied by `-D warnings`\n+\n+error: empty String is being created manually\n+  --> $DIR/manual_string_new.rs:18:13\n+   |\n+LL |     let _ = \"\".to_owned();\n+   |             ^^^^^^^^^^^^^ help: consider using: `String::new()`\n+\n+error: empty String is being created manually\n+  --> $DIR/manual_string_new.rs:21:21\n+   |\n+LL |     let _: String = \"\".into();\n+   |                     ^^^^^^^^^ help: consider using: `String::new()`\n+\n+error: empty String is being created manually\n+  --> $DIR/manual_string_new.rs:28:13\n+   |\n+LL |     let _ = String::from(\"\");\n+   |             ^^^^^^^^^^^^^^^^ help: consider using: `String::new()`\n+\n+error: empty String is being created manually\n+  --> $DIR/manual_string_new.rs:29:13\n+   |\n+LL |     let _ = <String>::from(\"\");\n+   |             ^^^^^^^^^^^^^^^^^^ help: consider using: `String::new()`\n+\n+error: empty String is being created manually\n+  --> $DIR/manual_string_new.rs:34:13\n+   |\n+LL |     let _ = String::try_from(\"\").unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `String::new()`\n+\n+error: empty String is being created manually\n+  --> $DIR/manual_string_new.rs:40:21\n+   |\n+LL |     let _: String = From::from(\"\");\n+   |                     ^^^^^^^^^^^^^^ help: consider using: `String::new()`\n+\n+error: empty String is being created manually\n+  --> $DIR/manual_string_new.rs:45:21\n+   |\n+LL |     let _: String = TryFrom::try_from(\"\").unwrap();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `String::new()`\n+\n+error: empty String is being created manually\n+  --> $DIR/manual_string_new.rs:48:21\n+   |\n+LL |     let _: String = TryFrom::try_from(\"\").expect(\"this should warn\");\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `String::new()`\n+\n+error: aborting due to 9 previous errors\n+"}, {"sha": "95ca571d07bfbf88fcce5d626814d6f210156ee2", "filename": "src/tools/clippy/tests/ui/match_expr_like_matches_macro.fixed", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -167,4 +167,29 @@ fn main() {\n             _ => false,\n         };\n     }\n+\n+    let x = ' ';\n+    // ignore if match block contains comment\n+    let _line_comments = match x {\n+        // numbers are bad!\n+        '1' | '2' | '3' => true,\n+        // spaces are very important to be true.\n+        ' ' => true,\n+        // as are dots\n+        '.' => true,\n+        _ => false,\n+    };\n+\n+    let _block_comments = match x {\n+        /* numbers are bad!\n+         */\n+        '1' | '2' | '3' => true,\n+        /* spaces are very important to be true.\n+         */\n+        ' ' => true,\n+        /* as are dots\n+         */\n+        '.' => true,\n+        _ => false,\n+    };\n }"}, {"sha": "3b9c8cadadcc417ebbe731a3735dd98580837e46", "filename": "src/tools/clippy/tests/ui/match_expr_like_matches_macro.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -208,4 +208,29 @@ fn main() {\n             _ => false,\n         };\n     }\n+\n+    let x = ' ';\n+    // ignore if match block contains comment\n+    let _line_comments = match x {\n+        // numbers are bad!\n+        '1' | '2' | '3' => true,\n+        // spaces are very important to be true.\n+        ' ' => true,\n+        // as are dots\n+        '.' => true,\n+        _ => false,\n+    };\n+\n+    let _block_comments = match x {\n+        /* numbers are bad!\n+         */\n+        '1' | '2' | '3' => true,\n+        /* spaces are very important to be true.\n+         */\n+        ' ' => true,\n+        /* as are dots\n+         */\n+        '.' => true,\n+        _ => false,\n+    };\n }"}, {"sha": "b186bf8bbdb424874495f06e80a9a1ddd6cedef3", "filename": "src/tools/clippy/tests/ui/multi_assignments.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmulti_assignments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmulti_assignments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmulti_assignments.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,9 @@\n+#![warn(clippy::multi_assignments)]\n+fn main() {\n+    let (mut a, mut b, mut c, mut d) = ((), (), (), ());\n+    a = b = c;\n+    a = b = c = d;\n+    a = b = { c };\n+    a = { b = c };\n+    a = (b = c);\n+}"}, {"sha": "d6c42bb698cf97f34c5c02e30f9fd9e456bf6551", "filename": "src/tools/clippy/tests/ui/multi_assignments.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmulti_assignments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmulti_assignments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmulti_assignments.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,40 @@\n+error: assignments don't nest intuitively\n+  --> $DIR/multi_assignments.rs:4:5\n+   |\n+LL |     a = b = c;\n+   |     ^^^^^^^^^\n+   |\n+   = note: `-D clippy::multi-assignments` implied by `-D warnings`\n+\n+error: assignments don't nest intuitively\n+  --> $DIR/multi_assignments.rs:5:5\n+   |\n+LL |     a = b = c = d;\n+   |     ^^^^^^^^^^^^^\n+\n+error: assignments don't nest intuitively\n+  --> $DIR/multi_assignments.rs:5:9\n+   |\n+LL |     a = b = c = d;\n+   |         ^^^^^^^^^\n+\n+error: assignments don't nest intuitively\n+  --> $DIR/multi_assignments.rs:6:5\n+   |\n+LL |     a = b = { c };\n+   |     ^^^^^^^^^^^^^\n+\n+error: assignments don't nest intuitively\n+  --> $DIR/multi_assignments.rs:7:5\n+   |\n+LL |     a = { b = c };\n+   |     ^^^^^^^^^^^^^\n+\n+error: assignments don't nest intuitively\n+  --> $DIR/multi_assignments.rs:8:5\n+   |\n+LL |     a = (b = c);\n+   |     ^^^^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "8cf93bd248173ee93cef0b0ec5e87815e11f370b", "filename": "src/tools/clippy/tests/ui/needless_borrow.fixed", "status": "modified", "additions": 116, "deletions": 1, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![feature(lint_reasons)]\n+#![feature(custom_inner_attributes, lint_reasons)]\n \n #[warn(clippy::all, clippy::needless_borrow)]\n #[allow(unused_variables, clippy::unnecessary_mut_passed)]\n@@ -127,6 +127,20 @@ fn main() {\n             0\n         }\n     }\n+\n+    let _ = std::process::Command::new(\"ls\").args([\"-a\", \"-l\"]).status().unwrap();\n+    let _ = std::path::Path::new(\".\").join(\".\");\n+    deref_target_is_x(X);\n+    multiple_constraints([[\"\"]]);\n+    multiple_constraints_normalizes_to_same(X, X);\n+    let _ = Some(\"\").unwrap_or(\"\");\n+\n+    only_sized(&\"\"); // Don't lint. `Sized` is only bound\n+    let _ = std::any::Any::type_id(&\"\"); // Don't lint. `Any` is only bound\n+    let _ = Box::new(&\"\"); // Don't lint. Type parameter appears in return type\n+    ref_as_ref_path(&\"\"); // Don't lint. Argument type is not a type parameter\n+    refs_only(&()); // Don't lint. `&T` implements trait, but `T` doesn't\n+    multiple_constraints_normalizes_to_different(&[[\"\"]], &[\"\"]); // Don't lint. Projected type appears in arguments\n }\n \n #[allow(clippy::needless_borrowed_reference)]\n@@ -183,3 +197,104 @@ mod issue9160 {\n         }\n     }\n }\n+\n+#[derive(Clone, Copy)]\n+struct X;\n+\n+impl std::ops::Deref for X {\n+    type Target = X;\n+    fn deref(&self) -> &Self::Target {\n+        self\n+    }\n+}\n+\n+fn deref_target_is_x<T>(_: T)\n+where\n+    T: std::ops::Deref<Target = X>,\n+{\n+}\n+\n+fn multiple_constraints<T, U, V, X, Y>(_: T)\n+where\n+    T: IntoIterator<Item = U> + IntoIterator<Item = X>,\n+    U: IntoIterator<Item = V>,\n+    V: AsRef<str>,\n+    X: IntoIterator<Item = Y>,\n+    Y: AsRef<std::ffi::OsStr>,\n+{\n+}\n+\n+fn multiple_constraints_normalizes_to_same<T, U, V>(_: T, _: V)\n+where\n+    T: std::ops::Deref<Target = U>,\n+    U: std::ops::Deref<Target = V>,\n+{\n+}\n+\n+fn only_sized<T>(_: T) {}\n+\n+fn ref_as_ref_path<T: 'static>(_: &'static T)\n+where\n+    &'static T: AsRef<std::path::Path>,\n+{\n+}\n+\n+trait RefsOnly {\n+    type Referent;\n+}\n+\n+impl<T> RefsOnly for &T {\n+    type Referent = T;\n+}\n+\n+fn refs_only<T, U>(_: T)\n+where\n+    T: RefsOnly<Referent = U>,\n+{\n+}\n+\n+fn multiple_constraints_normalizes_to_different<T, U, V>(_: T, _: U)\n+where\n+    T: IntoIterator<Item = U>,\n+    U: IntoIterator<Item = V>,\n+    V: AsRef<str>,\n+{\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/pull/9136#pullrequestreview-1037379321\n+#[allow(dead_code)]\n+mod copyable_iterator {\n+    #[derive(Clone, Copy)]\n+    struct Iter;\n+    impl Iterator for Iter {\n+        type Item = ();\n+        fn next(&mut self) -> Option<Self::Item> {\n+            None\n+        }\n+    }\n+    fn takes_iter(_: impl Iterator) {}\n+    fn dont_warn(mut x: Iter) {\n+        takes_iter(&mut x);\n+    }\n+    fn warn(mut x: &mut Iter) {\n+        takes_iter(&mut x)\n+    }\n+}\n+\n+mod under_msrv {\n+    #![allow(dead_code)]\n+    #![clippy::msrv = \"1.52.0\"]\n+\n+    fn foo() {\n+        let _ = std::process::Command::new(\"ls\").args(&[\"-a\", \"-l\"]).status().unwrap();\n+    }\n+}\n+\n+mod meets_msrv {\n+    #![allow(dead_code)]\n+    #![clippy::msrv = \"1.53.0\"]\n+\n+    fn foo() {\n+        let _ = std::process::Command::new(\"ls\").args([\"-a\", \"-l\"]).status().unwrap();\n+    }\n+}"}, {"sha": "fd9b2a11df96f1cba7dcd147dd7d6ca96774435d", "filename": "src/tools/clippy/tests/ui/needless_borrow.rs", "status": "modified", "additions": 116, "deletions": 1, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![feature(lint_reasons)]\n+#![feature(custom_inner_attributes, lint_reasons)]\n \n #[warn(clippy::all, clippy::needless_borrow)]\n #[allow(unused_variables, clippy::unnecessary_mut_passed)]\n@@ -127,6 +127,20 @@ fn main() {\n             0\n         }\n     }\n+\n+    let _ = std::process::Command::new(\"ls\").args(&[\"-a\", \"-l\"]).status().unwrap();\n+    let _ = std::path::Path::new(\".\").join(&&\".\");\n+    deref_target_is_x(&X);\n+    multiple_constraints(&[[\"\"]]);\n+    multiple_constraints_normalizes_to_same(&X, X);\n+    let _ = Some(\"\").unwrap_or(&\"\");\n+\n+    only_sized(&\"\"); // Don't lint. `Sized` is only bound\n+    let _ = std::any::Any::type_id(&\"\"); // Don't lint. `Any` is only bound\n+    let _ = Box::new(&\"\"); // Don't lint. Type parameter appears in return type\n+    ref_as_ref_path(&\"\"); // Don't lint. Argument type is not a type parameter\n+    refs_only(&()); // Don't lint. `&T` implements trait, but `T` doesn't\n+    multiple_constraints_normalizes_to_different(&[[\"\"]], &[\"\"]); // Don't lint. Projected type appears in arguments\n }\n \n #[allow(clippy::needless_borrowed_reference)]\n@@ -183,3 +197,104 @@ mod issue9160 {\n         }\n     }\n }\n+\n+#[derive(Clone, Copy)]\n+struct X;\n+\n+impl std::ops::Deref for X {\n+    type Target = X;\n+    fn deref(&self) -> &Self::Target {\n+        self\n+    }\n+}\n+\n+fn deref_target_is_x<T>(_: T)\n+where\n+    T: std::ops::Deref<Target = X>,\n+{\n+}\n+\n+fn multiple_constraints<T, U, V, X, Y>(_: T)\n+where\n+    T: IntoIterator<Item = U> + IntoIterator<Item = X>,\n+    U: IntoIterator<Item = V>,\n+    V: AsRef<str>,\n+    X: IntoIterator<Item = Y>,\n+    Y: AsRef<std::ffi::OsStr>,\n+{\n+}\n+\n+fn multiple_constraints_normalizes_to_same<T, U, V>(_: T, _: V)\n+where\n+    T: std::ops::Deref<Target = U>,\n+    U: std::ops::Deref<Target = V>,\n+{\n+}\n+\n+fn only_sized<T>(_: T) {}\n+\n+fn ref_as_ref_path<T: 'static>(_: &'static T)\n+where\n+    &'static T: AsRef<std::path::Path>,\n+{\n+}\n+\n+trait RefsOnly {\n+    type Referent;\n+}\n+\n+impl<T> RefsOnly for &T {\n+    type Referent = T;\n+}\n+\n+fn refs_only<T, U>(_: T)\n+where\n+    T: RefsOnly<Referent = U>,\n+{\n+}\n+\n+fn multiple_constraints_normalizes_to_different<T, U, V>(_: T, _: U)\n+where\n+    T: IntoIterator<Item = U>,\n+    U: IntoIterator<Item = V>,\n+    V: AsRef<str>,\n+{\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/pull/9136#pullrequestreview-1037379321\n+#[allow(dead_code)]\n+mod copyable_iterator {\n+    #[derive(Clone, Copy)]\n+    struct Iter;\n+    impl Iterator for Iter {\n+        type Item = ();\n+        fn next(&mut self) -> Option<Self::Item> {\n+            None\n+        }\n+    }\n+    fn takes_iter(_: impl Iterator) {}\n+    fn dont_warn(mut x: Iter) {\n+        takes_iter(&mut x);\n+    }\n+    fn warn(mut x: &mut Iter) {\n+        takes_iter(&mut x)\n+    }\n+}\n+\n+mod under_msrv {\n+    #![allow(dead_code)]\n+    #![clippy::msrv = \"1.52.0\"]\n+\n+    fn foo() {\n+        let _ = std::process::Command::new(\"ls\").args(&[\"-a\", \"-l\"]).status().unwrap();\n+    }\n+}\n+\n+mod meets_msrv {\n+    #![allow(dead_code)]\n+    #![clippy::msrv = \"1.53.0\"]\n+\n+    fn foo() {\n+        let _ = std::process::Command::new(\"ls\").args(&[\"-a\", \"-l\"]).status().unwrap();\n+    }\n+}"}, {"sha": "5af68706d4ba579311308199b560dbfcad016ad2", "filename": "src/tools/clippy/tests/ui/needless_borrow.stderr", "status": "modified", "additions": 45, "deletions": 3, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -120,17 +120,59 @@ error: this expression creates a reference which is immediately dereferenced by\n LL |     (&&5).foo();\n    |     ^^^^^ help: change this to: `(&5)`\n \n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:131:51\n+   |\n+LL |     let _ = std::process::Command::new(\"ls\").args(&[\"-a\", \"-l\"]).status().unwrap();\n+   |                                                   ^^^^^^^^^^^^^ help: change this to: `[\"-a\", \"-l\"]`\n+\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:132:44\n+   |\n+LL |     let _ = std::path::Path::new(\".\").join(&&\".\");\n+   |                                            ^^^^^ help: change this to: `\".\"`\n+\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:133:23\n+   |\n+LL |     deref_target_is_x(&X);\n+   |                       ^^ help: change this to: `X`\n+\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:134:26\n+   |\n+LL |     multiple_constraints(&[[\"\"]]);\n+   |                          ^^^^^^^ help: change this to: `[[\"\"]]`\n+\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:135:45\n+   |\n+LL |     multiple_constraints_normalizes_to_same(&X, X);\n+   |                                             ^^ help: change this to: `X`\n+\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:136:32\n+   |\n+LL |     let _ = Some(\"\").unwrap_or(&\"\");\n+   |                                ^^^ help: change this to: `\"\"`\n+\n error: this expression borrows a value the compiler would automatically borrow\n-  --> $DIR/needless_borrow.rs:173:13\n+  --> $DIR/needless_borrow.rs:187:13\n    |\n LL |             (&self.f)()\n    |             ^^^^^^^^^ help: change this to: `(self.f)`\n \n error: this expression borrows a value the compiler would automatically borrow\n-  --> $DIR/needless_borrow.rs:182:13\n+  --> $DIR/needless_borrow.rs:196:13\n    |\n LL |             (&mut self.f)()\n    |             ^^^^^^^^^^^^^ help: change this to: `(self.f)`\n \n-error: aborting due to 22 previous errors\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:298:55\n+   |\n+LL |         let _ = std::process::Command::new(\"ls\").args(&[\"-a\", \"-l\"]).status().unwrap();\n+   |                                                       ^^^^^^^^^^^^^ help: change this to: `[\"-a\", \"-l\"]`\n+\n+error: aborting due to 29 previous errors\n "}, {"sha": "12a9ace1ee688679a5745698e314990480eda9f7", "filename": "src/tools/clippy/tests/ui/needless_collect_indirect.rs", "status": "modified", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect_indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect_indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect_indirect.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -112,3 +112,192 @@ fn allow_test() {\n     let v = [1].iter().collect::<Vec<_>>();\n     v.into_iter().collect::<HashSet<_>>();\n }\n+\n+mod issue_8553 {\n+    fn test_for() {\n+        let vec = vec![1, 2];\n+        let w: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+\n+        for i in 0..2 {\n+            // Do not lint, because this method call is in the loop\n+            w.contains(&i);\n+        }\n+\n+        for i in 0..2 {\n+            let y: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+            let z: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+            // Do lint\n+            y.contains(&i);\n+            for j in 0..2 {\n+                // Do not lint, because this method call is in the loop\n+                z.contains(&j);\n+            }\n+        }\n+\n+        // Do not lint, because this variable is used.\n+        w.contains(&0);\n+    }\n+\n+    fn test_while() {\n+        let vec = vec![1, 2];\n+        let x: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let mut n = 0;\n+        while n > 1 {\n+            // Do not lint, because this method call is in the loop\n+            x.contains(&n);\n+            n += 1;\n+        }\n+\n+        while n > 2 {\n+            let y: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+            let z: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+            // Do lint\n+            y.contains(&n);\n+            n += 1;\n+            while n > 4 {\n+                // Do not lint, because this method call is in the loop\n+                z.contains(&n);\n+                n += 1;\n+            }\n+        }\n+    }\n+\n+    fn test_loop() {\n+        let vec = vec![1, 2];\n+        let x: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let mut n = 0;\n+        loop {\n+            if n < 1 {\n+                // Do not lint, because this method call is in the loop\n+                x.contains(&n);\n+                n += 1;\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        loop {\n+            if n < 2 {\n+                let y: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+                let z: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+                // Do lint\n+                y.contains(&n);\n+                n += 1;\n+                loop {\n+                    if n < 4 {\n+                        // Do not lint, because this method call is in the loop\n+                        z.contains(&n);\n+                        n += 1;\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+    fn test_while_let() {\n+        let vec = vec![1, 2];\n+        let x: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let optional = Some(0);\n+        let mut n = 0;\n+        while let Some(value) = optional {\n+            if n < 1 {\n+                // Do not lint, because this method call is in the loop\n+                x.contains(&n);\n+                n += 1;\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while let Some(value) = optional {\n+            let y: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+            let z: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+            if n < 2 {\n+                // Do lint\n+                y.contains(&n);\n+                n += 1;\n+            } else {\n+                break;\n+            }\n+\n+            while let Some(value) = optional {\n+                if n < 4 {\n+                    // Do not lint, because this method call is in the loop\n+                    z.contains(&n);\n+                    n += 1;\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    fn test_if_cond() {\n+        let vec = vec![1, 2];\n+        let v: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let w = v.iter().collect::<Vec<_>>();\n+        // Do lint\n+        for _ in 0..w.len() {\n+            todo!();\n+        }\n+    }\n+\n+    fn test_if_cond_false_case() {\n+        let vec = vec![1, 2];\n+        let v: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let w = v.iter().collect::<Vec<_>>();\n+        // Do not lint, because w is used.\n+        for _ in 0..w.len() {\n+            todo!();\n+        }\n+\n+        w.len();\n+    }\n+\n+    fn test_while_cond() {\n+        let mut vec = vec![1, 2];\n+        let mut v: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let mut w = v.iter().collect::<Vec<_>>();\n+        // Do lint\n+        while 1 == w.len() {\n+            todo!();\n+        }\n+    }\n+\n+    fn test_while_cond_false_case() {\n+        let mut vec = vec![1, 2];\n+        let mut v: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let mut w = v.iter().collect::<Vec<_>>();\n+        // Do not lint, because w is used.\n+        while 1 == w.len() {\n+            todo!();\n+        }\n+\n+        w.len();\n+    }\n+\n+    fn test_while_let_cond() {\n+        let mut vec = vec![1, 2];\n+        let mut v: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let mut w = v.iter().collect::<Vec<_>>();\n+        // Do lint\n+        while let Some(i) = Some(w.len()) {\n+            todo!();\n+        }\n+    }\n+\n+    fn test_while_let_cond_false_case() {\n+        let mut vec = vec![1, 2];\n+        let mut v: Vec<usize> = vec.iter().map(|i| i * i).collect();\n+        let mut w = v.iter().collect::<Vec<_>>();\n+        // Do not lint, because w is used.\n+        while let Some(i) = Some(w.len()) {\n+            todo!();\n+        }\n+        w.len();\n+    }\n+}"}, {"sha": "9f0880cc6069d1449c7ec43d6386387deddcc5b7", "filename": "src/tools/clippy/tests/ui/needless_collect_indirect.stderr", "status": "modified", "additions": 118, "deletions": 1, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect_indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect_indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect_indirect.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -125,5 +125,122 @@ LL ~\n LL ~         sample.iter().count()\n    |\n \n-error: aborting due to 9 previous errors\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:127:59\n+   |\n+LL |             let y: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+   |                                                           ^^^^^^^\n+...\n+LL |             y.contains(&i);\n+   |             -------------- the iterator could be used here instead\n+   |\n+help: check if the original Iterator contains an element instead of collecting then checking\n+   |\n+LL ~             \n+LL |             let z: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+LL |             // Do lint\n+LL ~             vec.iter().map(|k| k * k).any(|x| x == i);\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:152:59\n+   |\n+LL |             let y: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+   |                                                           ^^^^^^^\n+...\n+LL |             y.contains(&n);\n+   |             -------------- the iterator could be used here instead\n+   |\n+help: check if the original Iterator contains an element instead of collecting then checking\n+   |\n+LL ~             \n+LL |             let z: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+LL |             // Do lint\n+LL ~             vec.iter().map(|k| k * k).any(|x| x == n);\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:181:63\n+   |\n+LL |                 let y: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+   |                                                               ^^^^^^^\n+...\n+LL |                 y.contains(&n);\n+   |                 -------------- the iterator could be used here instead\n+   |\n+help: check if the original Iterator contains an element instead of collecting then checking\n+   |\n+LL ~                 \n+LL |                 let z: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+LL |                 // Do lint\n+LL ~                 vec.iter().map(|k| k * k).any(|x| x == n);\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:217:59\n+   |\n+LL |             let y: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+   |                                                           ^^^^^^^\n+...\n+LL |                 y.contains(&n);\n+   |                 -------------- the iterator could be used here instead\n+   |\n+help: check if the original Iterator contains an element instead of collecting then checking\n+   |\n+LL ~             \n+LL |             let z: Vec<usize> = vec.iter().map(|k| k * k).collect();\n+LL |             if n < 2 {\n+LL |                 // Do lint\n+LL ~                 vec.iter().map(|k| k * k).any(|x| x == n);\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:242:26\n+   |\n+LL |         let w = v.iter().collect::<Vec<_>>();\n+   |                          ^^^^^^^\n+LL |         // Do lint\n+LL |         for _ in 0..w.len() {\n+   |                     ------- the iterator could be used here instead\n+   |\n+help: take the original Iterator's count instead of collecting it and finding the length\n+   |\n+LL ~         \n+LL |         // Do lint\n+LL ~         for _ in 0..v.iter().count() {\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:264:30\n+   |\n+LL |         let mut w = v.iter().collect::<Vec<_>>();\n+   |                              ^^^^^^^\n+LL |         // Do lint\n+LL |         while 1 == w.len() {\n+   |                    ------- the iterator could be used here instead\n+   |\n+help: take the original Iterator's count instead of collecting it and finding the length\n+   |\n+LL ~         \n+LL |         // Do lint\n+LL ~         while 1 == v.iter().count() {\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:286:30\n+   |\n+LL |         let mut w = v.iter().collect::<Vec<_>>();\n+   |                              ^^^^^^^\n+LL |         // Do lint\n+LL |         while let Some(i) = Some(w.len()) {\n+   |                                  ------- the iterator could be used here instead\n+   |\n+help: take the original Iterator's count instead of collecting it and finding the length\n+   |\n+LL ~         \n+LL |         // Do lint\n+LL ~         while let Some(i) = Some(v.iter().count()) {\n+   |\n+\n+error: aborting due to 16 previous errors\n "}, {"sha": "7e47406798cf9b90d96e98893ed8c66c89109406", "filename": "src/tools/clippy/tests/ui/needless_match.fixed", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_match.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_match.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_match.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -207,4 +207,43 @@ impl Tr for Result<i32, i32> {\n     }\n }\n \n+mod issue9084 {\n+    fn wildcard_if() {\n+        let mut some_bool = true;\n+        let e = Some(1);\n+\n+        // should lint\n+        let _ = e;\n+\n+        // should lint\n+        let _ = e;\n+\n+        // should not lint\n+        let _ = match e {\n+            _ if some_bool => e,\n+            _ => Some(2),\n+        };\n+\n+        // should not lint\n+        let _ = match e {\n+            Some(i) => Some(i + 1),\n+            _ if some_bool => e,\n+            _ => e,\n+        };\n+\n+        // should not lint (guard has side effects)\n+        let _ = match e {\n+            Some(i) => Some(i),\n+            _ if {\n+                some_bool = false;\n+                some_bool\n+            } =>\n+            {\n+                e\n+            },\n+            _ => e,\n+        };\n+    }\n+}\n+\n fn main() {}"}, {"sha": "809c694bf400464bb4685b115010b04c63ce6147", "filename": "src/tools/clippy/tests/ui/needless_match.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_match.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -244,4 +244,50 @@ impl Tr for Result<i32, i32> {\n     }\n }\n \n+mod issue9084 {\n+    fn wildcard_if() {\n+        let mut some_bool = true;\n+        let e = Some(1);\n+\n+        // should lint\n+        let _ = match e {\n+            _ if some_bool => e,\n+            _ => e,\n+        };\n+\n+        // should lint\n+        let _ = match e {\n+            Some(i) => Some(i),\n+            _ if some_bool => e,\n+            _ => e,\n+        };\n+\n+        // should not lint\n+        let _ = match e {\n+            _ if some_bool => e,\n+            _ => Some(2),\n+        };\n+\n+        // should not lint\n+        let _ = match e {\n+            Some(i) => Some(i + 1),\n+            _ if some_bool => e,\n+            _ => e,\n+        };\n+\n+        // should not lint (guard has side effects)\n+        let _ = match e {\n+            Some(i) => Some(i),\n+            _ if {\n+                some_bool = false;\n+                some_bool\n+            } =>\n+            {\n+                e\n+            },\n+            _ => e,\n+        };\n+    }\n+}\n+\n fn main() {}"}, {"sha": "28e78441c2522fcd65528069876fc567cf071b5b", "filename": "src/tools/clippy/tests/ui/needless_match.stderr", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_match.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -109,5 +109,26 @@ LL | |             Complex::D(E::VariantB(ea, eb), b) => Complex::D(E::VariantB(\n LL | |         };\n    | |_________^ help: replace it with: `ce`\n \n-error: aborting due to 11 previous errors\n+error: this match expression is unnecessary\n+  --> $DIR/needless_match.rs:253:17\n+   |\n+LL |           let _ = match e {\n+   |  _________________^\n+LL | |             _ if some_bool => e,\n+LL | |             _ => e,\n+LL | |         };\n+   | |_________^ help: replace it with: `e`\n+\n+error: this match expression is unnecessary\n+  --> $DIR/needless_match.rs:259:17\n+   |\n+LL |           let _ = match e {\n+   |  _________________^\n+LL | |             Some(i) => Some(i),\n+LL | |             _ if some_bool => e,\n+LL | |             _ => e,\n+LL | |         };\n+   | |_________^ help: replace it with: `e`\n+\n+error: aborting due to 13 previous errors\n "}, {"sha": "87c8fc03b3c3627766edaaf6d965f5afdc6ced2c", "filename": "src/tools/clippy/tests/ui/needless_return.fixed", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -228,13 +228,9 @@ fn needless_return_macro() -> String {\n     format!(\"Hello {}\", \"world!\")\n }\n \n-fn check_expect() -> bool {\n-    if true {\n-        // no error!\n-        return true;\n-    }\n-    #[expect(clippy::needless_return)]\n-    return true;\n+fn issue_9361() -> i32 {\n+    #[allow(clippy::integer_arithmetic)]\n+    return 1 + 2;\n }\n \n fn main() {}"}, {"sha": "5a86e656255dd1413d7ca1e3dd2d543846cf7350", "filename": "src/tools/clippy/tests/ui/needless_return.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -228,13 +228,9 @@ fn needless_return_macro() -> String {\n     return format!(\"Hello {}\", \"world!\");\n }\n \n-fn check_expect() -> bool {\n-    if true {\n-        // no error!\n-        return true;\n-    }\n-    #[expect(clippy::needless_return)]\n-    return true;\n+fn issue_9361() -> i32 {\n+    #[allow(clippy::integer_arithmetic)]\n+    return 1 + 2;\n }\n \n fn main() {}"}, {"sha": "f71e8ead5195ea27653bbfd7f24869490ffcc41b", "filename": "src/tools/clippy/tests/ui/only_used_in_recursion.rs", "status": "modified", "additions": 62, "deletions": 71, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fonly_used_in_recursion.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,122 +1,113 @@\n #![warn(clippy::only_used_in_recursion)]\n \n-fn simple(a: usize, b: usize) -> usize {\n-    if a == 0 { 1 } else { simple(a - 1, b) }\n+fn _simple(x: u32) -> u32 {\n+    x\n }\n \n-fn with_calc(a: usize, b: isize) -> usize {\n-    if a == 0 { 1 } else { with_calc(a - 1, -b + 1) }\n+fn _simple2(x: u32) -> u32 {\n+    _simple(x)\n }\n \n-fn tuple((a, b): (usize, usize)) -> usize {\n-    if a == 0 { 1 } else { tuple((a - 1, b + 1)) }\n+fn _one_unused(flag: u32, a: usize) -> usize {\n+    if flag == 0 { 0 } else { _one_unused(flag - 1, a) }\n }\n \n-fn let_tuple(a: usize, b: usize) -> usize {\n-    let (c, d) = (a, b);\n-    if c == 0 { 1 } else { let_tuple(c - 1, d + 1) }\n+fn _two_unused(flag: u32, a: u32, b: i32) -> usize {\n+    if flag == 0 { 0 } else { _two_unused(flag - 1, a, b) }\n }\n \n-fn array([a, b]: [usize; 2]) -> usize {\n-    if a == 0 { 1 } else { array([a - 1, b + 1]) }\n-}\n-\n-fn index(a: usize, mut b: &[usize], c: usize) -> usize {\n-    if a == 0 { 1 } else { index(a - 1, b, c + b[0]) }\n-}\n-\n-fn break_(a: usize, mut b: usize, mut c: usize) -> usize {\n-    let c = loop {\n-        b += 1;\n-        c += 1;\n-        if c == 10 {\n-            break b;\n-        }\n-    };\n-\n-    if a == 0 { 1 } else { break_(a - 1, c, c) }\n+fn _with_calc(flag: u32, a: i64) -> usize {\n+    if flag == 0 {\n+        0\n+    } else {\n+        _with_calc(flag - 1, (-a + 10) * 5)\n+    }\n }\n \n-// this has a side effect\n-fn mut_ref(a: usize, b: &mut usize) -> usize {\n-    *b = 1;\n-    if a == 0 { 1 } else { mut_ref(a - 1, b) }\n+// Don't lint\n+fn _used_with_flag(flag: u32, a: u32) -> usize {\n+    if flag == 0 { 0 } else { _used_with_flag(flag ^ a, a - 1) }\n }\n \n-fn mut_ref2(a: usize, b: &mut usize) -> usize {\n-    let mut c = *b;\n-    if a == 0 { 1 } else { mut_ref2(a - 1, &mut c) }\n+fn _used_with_unused(flag: u32, a: i32, b: i32) -> usize {\n+    if flag == 0 {\n+        0\n+    } else {\n+        _used_with_unused(flag - 1, -a, a + b)\n+    }\n }\n \n-fn not_primitive(a: usize, b: String) -> usize {\n-    if a == 0 { 1 } else { not_primitive(a - 1, b) }\n+fn _codependent_unused(flag: u32, a: i32, b: i32) -> usize {\n+    if flag == 0 {\n+        0\n+    } else {\n+        _codependent_unused(flag - 1, a * b, a + b)\n+    }\n }\n \n-// this doesn't have a side effect,\n-// but `String` is not primitive.\n-fn not_primitive_op(a: usize, b: String, c: &str) -> usize {\n-    if a == 1 { 1 } else { not_primitive_op(a, b + c, c) }\n+fn _not_primitive(flag: u32, b: String) -> usize {\n+    if flag == 0 { 0 } else { _not_primitive(flag - 1, b) }\n }\n \n struct A;\n \n impl A {\n-    fn method(a: usize, b: usize) -> usize {\n-        if a == 0 { 1 } else { A::method(a - 1, b - 1) }\n+    fn _method(flag: usize, a: usize) -> usize {\n+        if flag == 0 { 0 } else { Self::_method(flag - 1, a) }\n     }\n \n-    fn method2(&self, a: usize, b: usize) -> usize {\n-        if a == 0 { 1 } else { self.method2(a - 1, b + 1) }\n+    fn _method_self(&self, flag: usize, a: usize) -> usize {\n+        if flag == 0 { 0 } else { self._method_self(flag - 1, a) }\n     }\n }\n \n trait B {\n-    fn hello(a: usize, b: usize) -> usize;\n-\n-    fn hello2(&self, a: usize, b: usize) -> usize;\n+    fn method(flag: u32, a: usize) -> usize;\n+    fn method_self(&self, flag: u32, a: usize) -> usize;\n }\n \n impl B for A {\n-    fn hello(a: usize, b: usize) -> usize {\n-        if a == 0 { 1 } else { A::hello(a - 1, b + 1) }\n+    fn method(flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { Self::method(flag - 1, a) }\n     }\n \n-    fn hello2(&self, a: usize, b: usize) -> usize {\n-        if a == 0 { 1 } else { self.hello2(a - 1, b + 1) }\n+    fn method_self(&self, flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { self.method_self(flag - 1, a) }\n     }\n }\n \n-trait C {\n-    fn hello(a: usize, b: usize) -> usize {\n-        if a == 0 { 1 } else { Self::hello(a - 1, b + 1) }\n+impl B for () {\n+    fn method(flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { a }\n     }\n \n-    fn hello2(&self, a: usize, b: usize) -> usize {\n-        if a == 0 { 1 } else { self.hello2(a - 1, b + 1) }\n+    fn method_self(&self, flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { a }\n     }\n }\n \n-fn ignore(a: usize, _: usize) -> usize {\n-    if a == 1 { 1 } else { ignore(a - 1, 0) }\n-}\n+impl B for u32 {\n+    fn method(flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { <() as B>::method(flag, a) }\n+    }\n \n-fn ignore2(a: usize, _b: usize) -> usize {\n-    if a == 1 { 1 } else { ignore2(a - 1, _b) }\n+    fn method_self(&self, flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { ().method_self(flag, a) }\n+    }\n }\n \n-fn f1(a: u32) -> u32 {\n-    a\n-}\n+trait C {\n+    fn method(flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { Self::method(flag - 1, a) }\n+    }\n \n-fn f2(a: u32) -> u32 {\n-    f1(a)\n+    fn method_self(&self, flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { self.method_self(flag - 1, a) }\n+    }\n }\n \n-fn inner_fn(a: u32) -> u32 {\n-    fn inner_fn(a: u32) -> u32 {\n-        a\n-    }\n-    inner_fn(a)\n+fn _ignore(flag: usize, _a: usize) -> usize {\n+    if flag == 0 { 0 } else { _ignore(flag - 1, _a) }\n }\n \n fn main() {}"}, {"sha": "74057ddcfda4c2cca6e77a64c43313539fe5066c", "filename": "src/tools/clippy/tests/ui/only_used_in_recursion.stderr", "status": "modified", "additions": 153, "deletions": 40, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fonly_used_in_recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fonly_used_in_recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fonly_used_in_recursion.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,82 +1,195 @@\n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:3:21\n+  --> $DIR/only_used_in_recursion.rs:11:27\n    |\n-LL | fn simple(a: usize, b: usize) -> usize {\n-   |                     ^ help: if this is intentional, prefix with an underscore: `_b`\n+LL | fn _one_unused(flag: u32, a: usize) -> usize {\n+   |                           ^ help: if this is intentional, prefix it with an underscore: `_a`\n    |\n    = note: `-D clippy::only-used-in-recursion` implied by `-D warnings`\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:12:53\n+   |\n+LL |     if flag == 0 { 0 } else { _one_unused(flag - 1, a) }\n+   |                                                     ^\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:15:27\n+   |\n+LL | fn _two_unused(flag: u32, a: u32, b: i32) -> usize {\n+   |                           ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:16:53\n+   |\n+LL |     if flag == 0 { 0 } else { _two_unused(flag - 1, a, b) }\n+   |                                                     ^\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:15:35\n+   |\n+LL | fn _two_unused(flag: u32, a: u32, b: i32) -> usize {\n+   |                                   ^ help: if this is intentional, prefix it with an underscore: `_b`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:16:56\n+   |\n+LL |     if flag == 0 { 0 } else { _two_unused(flag - 1, a, b) }\n+   |                                                        ^\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:19:26\n+   |\n+LL | fn _with_calc(flag: u32, a: i64) -> usize {\n+   |                          ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:23:32\n+   |\n+LL |         _with_calc(flag - 1, (-a + 10) * 5)\n+   |                                ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:7:24\n+  --> $DIR/only_used_in_recursion.rs:32:33\n+   |\n+LL | fn _used_with_unused(flag: u32, a: i32, b: i32) -> usize {\n+   |                                 ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:36:38\n    |\n-LL | fn with_calc(a: usize, b: isize) -> usize {\n-   |                        ^ help: if this is intentional, prefix with an underscore: `_b`\n+LL |         _used_with_unused(flag - 1, -a, a + b)\n+   |                                      ^  ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:11:14\n+  --> $DIR/only_used_in_recursion.rs:32:41\n+   |\n+LL | fn _used_with_unused(flag: u32, a: i32, b: i32) -> usize {\n+   |                                         ^ help: if this is intentional, prefix it with an underscore: `_b`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:36:45\n    |\n-LL | fn tuple((a, b): (usize, usize)) -> usize {\n-   |              ^ help: if this is intentional, prefix with an underscore: `_b`\n+LL |         _used_with_unused(flag - 1, -a, a + b)\n+   |                                             ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:15:24\n+  --> $DIR/only_used_in_recursion.rs:40:35\n    |\n-LL | fn let_tuple(a: usize, b: usize) -> usize {\n-   |                        ^ help: if this is intentional, prefix with an underscore: `_b`\n+LL | fn _codependent_unused(flag: u32, a: i32, b: i32) -> usize {\n+   |                                   ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:44:39\n+   |\n+LL |         _codependent_unused(flag - 1, a * b, a + b)\n+   |                                       ^      ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:20:14\n+  --> $DIR/only_used_in_recursion.rs:40:43\n+   |\n+LL | fn _codependent_unused(flag: u32, a: i32, b: i32) -> usize {\n+   |                                           ^ help: if this is intentional, prefix it with an underscore: `_b`\n    |\n-LL | fn array([a, b]: [usize; 2]) -> usize {\n-   |              ^ help: if this is intentional, prefix with an underscore: `_b`\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:44:43\n+   |\n+LL |         _codependent_unused(flag - 1, a * b, a + b)\n+   |                                           ^      ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:24:20\n+  --> $DIR/only_used_in_recursion.rs:48:30\n+   |\n+LL | fn _not_primitive(flag: u32, b: String) -> usize {\n+   |                              ^ help: if this is intentional, prefix it with an underscore: `_b`\n    |\n-LL | fn index(a: usize, mut b: &[usize], c: usize) -> usize {\n-   |                    ^^^^^ help: if this is intentional, prefix with an underscore: `_b`\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:49:56\n+   |\n+LL |     if flag == 0 { 0 } else { _not_primitive(flag - 1, b) }\n+   |                                                        ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:24:37\n+  --> $DIR/only_used_in_recursion.rs:55:29\n+   |\n+LL |     fn _method(flag: usize, a: usize) -> usize {\n+   |                             ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:56:59\n    |\n-LL | fn index(a: usize, mut b: &[usize], c: usize) -> usize {\n-   |                                     ^ help: if this is intentional, prefix with an underscore: `_c`\n+LL |         if flag == 0 { 0 } else { Self::_method(flag - 1, a) }\n+   |                                                           ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:28:21\n+  --> $DIR/only_used_in_recursion.rs:59:22\n+   |\n+LL |     fn _method_self(&self, flag: usize, a: usize) -> usize {\n+   |                      ^^^^\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:60:35\n    |\n-LL | fn break_(a: usize, mut b: usize, mut c: usize) -> usize {\n-   |                     ^^^^^ help: if this is intentional, prefix with an underscore: `_b`\n+LL |         if flag == 0 { 0 } else { self._method_self(flag - 1, a) }\n+   |                                   ^^^^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:46:23\n+  --> $DIR/only_used_in_recursion.rs:59:41\n    |\n-LL | fn mut_ref2(a: usize, b: &mut usize) -> usize {\n-   |                       ^ help: if this is intentional, prefix with an underscore: `_b`\n+LL |     fn _method_self(&self, flag: usize, a: usize) -> usize {\n+   |                                         ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:60:63\n+   |\n+LL |         if flag == 0 { 0 } else { self._method_self(flag - 1, a) }\n+   |                                                               ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:51:28\n+  --> $DIR/only_used_in_recursion.rs:70:26\n+   |\n+LL |     fn method(flag: u32, a: usize) -> usize {\n+   |                          ^ help: if this is intentional, prefix it with an underscore: `_a`\n    |\n-LL | fn not_primitive(a: usize, b: String) -> usize {\n-   |                            ^ help: if this is intentional, prefix with an underscore: `_b`\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:71:58\n+   |\n+LL |         if flag == 0 { 0 } else { Self::method(flag - 1, a) }\n+   |                                                          ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:68:33\n+  --> $DIR/only_used_in_recursion.rs:74:38\n+   |\n+LL |     fn method_self(&self, flag: u32, a: usize) -> usize {\n+   |                                      ^ help: if this is intentional, prefix it with an underscore: `_a`\n    |\n-LL |     fn method2(&self, a: usize, b: usize) -> usize {\n-   |                                 ^ help: if this is intentional, prefix with an underscore: `_b`\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:75:62\n+   |\n+LL |         if flag == 0 { 0 } else { self.method_self(flag - 1, a) }\n+   |                                                              ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:90:24\n+  --> $DIR/only_used_in_recursion.rs:100:26\n+   |\n+LL |     fn method(flag: u32, a: usize) -> usize {\n+   |                          ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:101:58\n    |\n-LL |     fn hello(a: usize, b: usize) -> usize {\n-   |                        ^ help: if this is intentional, prefix with an underscore: `_b`\n+LL |         if flag == 0 { 0 } else { Self::method(flag - 1, a) }\n+   |                                                          ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:94:32\n+  --> $DIR/only_used_in_recursion.rs:104:38\n+   |\n+LL |     fn method_self(&self, flag: u32, a: usize) -> usize {\n+   |                                      ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:105:62\n    |\n-LL |     fn hello2(&self, a: usize, b: usize) -> usize {\n-   |                                ^ help: if this is intentional, prefix with an underscore: `_b`\n+LL |         if flag == 0 { 0 } else { self.method_self(flag - 1, a) }\n+   |                                                              ^\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 16 previous errors\n "}, {"sha": "45dd0553f58acb31b9c15119db4e4f2d066564a2", "filename": "src/tools/clippy/tests/ui/only_used_in_recursion2.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fonly_used_in_recursion2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fonly_used_in_recursion2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fonly_used_in_recursion2.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,91 @@\n+#![warn(clippy::only_used_in_recursion)]\n+\n+fn _with_inner(flag: u32, a: u32, b: u32) -> usize {\n+    fn inner(flag: u32, a: u32) -> u32 {\n+        if flag == 0 { 0 } else { inner(flag, a) }\n+    }\n+\n+    let x = inner(flag, a);\n+    if flag == 0 { 0 } else { _with_inner(flag, a, b + x) }\n+}\n+\n+fn _with_closure(a: Option<u32>, b: u32, f: impl Fn(u32, u32) -> Option<u32>) -> u32 {\n+    if let Some(x) = a.and_then(|x| f(x, x)) {\n+        _with_closure(Some(x), b, f)\n+    } else {\n+        0\n+    }\n+}\n+\n+// Issue #8560\n+trait D {\n+    fn foo(&mut self, arg: u32) -> u32;\n+}\n+\n+mod m {\n+    pub struct S(u32);\n+    impl S {\n+        pub fn foo(&mut self, arg: u32) -> u32 {\n+            arg + self.0\n+        }\n+    }\n+}\n+\n+impl D for m::S {\n+    fn foo(&mut self, arg: u32) -> u32 {\n+        self.foo(arg)\n+    }\n+}\n+\n+// Issue #8782\n+fn only_let(x: u32) {\n+    let y = 10u32;\n+    let _z = x * y;\n+}\n+\n+trait E<T: E<()>> {\n+    fn method(flag: u32, a: usize) -> usize {\n+        if flag == 0 {\n+            0\n+        } else {\n+            <T as E<()>>::method(flag - 1, a)\n+        }\n+    }\n+}\n+\n+impl E<()> for () {\n+    fn method(flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { a }\n+    }\n+}\n+\n+fn overwritten_param(flag: u32, mut a: usize) -> usize {\n+    if flag == 0 {\n+        return 0;\n+    } else if flag > 5 {\n+        a += flag as usize;\n+    } else {\n+        a = 5;\n+    }\n+    overwritten_param(flag, a)\n+}\n+\n+fn field_direct(flag: u32, mut a: (usize,)) -> usize {\n+    if flag == 0 {\n+        0\n+    } else {\n+        a.0 += 5;\n+        field_direct(flag - 1, a)\n+    }\n+}\n+\n+fn field_deref(flag: u32, a: &mut Box<(usize,)>) -> usize {\n+    if flag == 0 {\n+        0\n+    } else {\n+        a.0 += 5;\n+        field_deref(flag - 1, a)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "23f6ffd30c9763de2033510ee3083f84f808874b", "filename": "src/tools/clippy/tests/ui/only_used_in_recursion2.stderr", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fonly_used_in_recursion2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fonly_used_in_recursion2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fonly_used_in_recursion2.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,63 @@\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion2.rs:3:35\n+   |\n+LL | fn _with_inner(flag: u32, a: u32, b: u32) -> usize {\n+   |                                   ^ help: if this is intentional, prefix it with an underscore: `_b`\n+   |\n+   = note: `-D clippy::only-used-in-recursion` implied by `-D warnings`\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion2.rs:9:52\n+   |\n+LL |     if flag == 0 { 0 } else { _with_inner(flag, a, b + x) }\n+   |                                                    ^\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion2.rs:4:25\n+   |\n+LL |     fn inner(flag: u32, a: u32) -> u32 {\n+   |                         ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion2.rs:5:47\n+   |\n+LL |         if flag == 0 { 0 } else { inner(flag, a) }\n+   |                                               ^\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion2.rs:12:34\n+   |\n+LL | fn _with_closure(a: Option<u32>, b: u32, f: impl Fn(u32, u32) -> Option<u32>) -> u32 {\n+   |                                  ^ help: if this is intentional, prefix it with an underscore: `_b`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion2.rs:14:32\n+   |\n+LL |         _with_closure(Some(x), b, f)\n+   |                                ^\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion2.rs:62:37\n+   |\n+LL | fn overwritten_param(flag: u32, mut a: usize) -> usize {\n+   |                                     ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion2.rs:70:29\n+   |\n+LL |     overwritten_param(flag, a)\n+   |                             ^\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion2.rs:73:32\n+   |\n+LL | fn field_direct(flag: u32, mut a: (usize,)) -> usize {\n+   |                                ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion2.rs:78:32\n+   |\n+LL |         field_direct(flag - 1, a)\n+   |                                ^\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "f15ac551bb3ccfeefa774ae183e91f98a66f6ce0", "filename": "src/tools/clippy/tests/ui/option_if_let_else.fixed", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -179,4 +179,13 @@ fn main() {\n \n     let _ = pattern_to_vec(\"hello world\");\n     let _ = complex_subpat();\n+\n+    // issue #8492\n+    let _ = s.map_or(1, |string| string.len());\n+    let _ = Some(10).map_or(5, |a| a + 1);\n+\n+    let res: Result<i32, i32> = Ok(5);\n+    let _ = res.map_or(1, |a| a + 1);\n+    let _ = res.map_or(1, |a| a + 1);\n+    let _ = res.map_or(5, |a| a + 1);\n }"}, {"sha": "9eeaea12d3bc91e615cb2fac5f3d3b10c0ffd0c9", "filename": "src/tools/clippy/tests/ui/option_if_let_else.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -208,4 +208,25 @@ fn main() {\n \n     let _ = pattern_to_vec(\"hello world\");\n     let _ = complex_subpat();\n+\n+    // issue #8492\n+    let _ = match s {\n+        Some(string) => string.len(),\n+        None => 1,\n+    };\n+    let _ = match Some(10) {\n+        Some(a) => a + 1,\n+        None => 5,\n+    };\n+\n+    let res: Result<i32, i32> = Ok(5);\n+    let _ = match res {\n+        Ok(a) => a + 1,\n+        _ => 1,\n+    };\n+    let _ = match res {\n+        Err(_) => 1,\n+        Ok(a) => a + 1,\n+    };\n+    let _ = if let Ok(a) = res { a + 1 } else { 5 };\n }"}, {"sha": "a5dbf6e1f2218020a7439059f9a59f5dba493fde", "filename": "src/tools/clippy/tests/ui/option_if_let_else.stderr", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -206,5 +206,51 @@ LL +         s.len() + x\n LL ~     });\n    |\n \n-error: aborting due to 15 previous errors\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:213:13\n+   |\n+LL |       let _ = match s {\n+   |  _____________^\n+LL | |         Some(string) => string.len(),\n+LL | |         None => 1,\n+LL | |     };\n+   | |_____^ help: try: `s.map_or(1, |string| string.len())`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:217:13\n+   |\n+LL |       let _ = match Some(10) {\n+   |  _____________^\n+LL | |         Some(a) => a + 1,\n+LL | |         None => 5,\n+LL | |     };\n+   | |_____^ help: try: `Some(10).map_or(5, |a| a + 1)`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:223:13\n+   |\n+LL |       let _ = match res {\n+   |  _____________^\n+LL | |         Ok(a) => a + 1,\n+LL | |         _ => 1,\n+LL | |     };\n+   | |_____^ help: try: `res.map_or(1, |a| a + 1)`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:227:13\n+   |\n+LL |       let _ = match res {\n+   |  _____________^\n+LL | |         Err(_) => 1,\n+LL | |         Ok(a) => a + 1,\n+LL | |     };\n+   | |_____^ help: try: `res.map_or(1, |a| a + 1)`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:231:13\n+   |\n+LL |     let _ = if let Ok(a) = res { a + 1 } else { 5 };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `res.map_or(5, |a| a + 1)`\n+\n+error: aborting due to 20 previous errors\n "}, {"sha": "18ea4e550292a4b3ddd5a729f4ba946afe2f4d13", "filename": "src/tools/clippy/tests/ui/or_fun_call.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -90,8 +90,8 @@ fn or_fun_call() {\n     let mut btree_vec = BTreeMap::<u64, Vec<i32>>::new();\n     btree_vec.entry(42).or_insert(vec![]);\n \n-    let stringy = Some(String::from(\"\"));\n-    let _ = stringy.unwrap_or_else(|| \"\".to_owned());\n+    let stringy = Some(String::new());\n+    let _ = stringy.unwrap_or_default();\n \n     let opt = Some(1);\n     let hello = \"Hello\";"}, {"sha": "c353b41e4495d96feee4525b5f1d20634d8bc694", "filename": "src/tools/clippy/tests/ui/or_fun_call.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -90,8 +90,8 @@ fn or_fun_call() {\n     let mut btree_vec = BTreeMap::<u64, Vec<i32>>::new();\n     btree_vec.entry(42).or_insert(vec![]);\n \n-    let stringy = Some(String::from(\"\"));\n-    let _ = stringy.unwrap_or(\"\".to_owned());\n+    let stringy = Some(String::new());\n+    let _ = stringy.unwrap_or(String::new());\n \n     let opt = Some(1);\n     let hello = \"Hello\";"}, {"sha": "887f23ac9761dfd7167f44f269d3224cb6d75e75", "filename": "src/tools/clippy/tests/ui/or_fun_call.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -66,11 +66,11 @@ error: use of `unwrap_or` followed by a function call\n LL |     without_default.unwrap_or(Foo::new());\n    |                     ^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(Foo::new)`\n \n-error: use of `unwrap_or` followed by a function call\n+error: use of `unwrap_or` followed by a call to `new`\n   --> $DIR/or_fun_call.rs:94:21\n    |\n-LL |     let _ = stringy.unwrap_or(\"\".to_owned());\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| \"\".to_owned())`\n+LL |     let _ = stringy.unwrap_or(String::new());\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a function call\n   --> $DIR/or_fun_call.rs:102:21"}, {"sha": "4644ea8f51da1ecd6def7c067aff736cdcebfd8a", "filename": "src/tools/clippy/tests/ui/partialeq_to_none.fixed", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpartialeq_to_none.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpartialeq_to_none.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpartialeq_to_none.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -26,6 +26,18 @@ fn optref() -> &'static &'static Option<()> {\n     &&None\n }\n \n+pub fn macro_expansion() {\n+    macro_rules! foo {\n+        () => {\n+            None::<()>\n+        };\n+    }\n+\n+    let _ = foobar() == foo!();\n+    let _ = foo!() == foobar();\n+    let _ = foo!() == foo!();\n+}\n+\n fn main() {\n     let x = Some(0);\n "}, {"sha": "61011b3a8c553cdb4a70704a1f46aaeea838494a", "filename": "src/tools/clippy/tests/ui/partialeq_to_none.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpartialeq_to_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpartialeq_to_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpartialeq_to_none.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -26,6 +26,18 @@ fn optref() -> &'static &'static Option<()> {\n     &&None\n }\n \n+pub fn macro_expansion() {\n+    macro_rules! foo {\n+        () => {\n+            None::<()>\n+        };\n+    }\n+\n+    let _ = foobar() == foo!();\n+    let _ = foo!() == foobar();\n+    let _ = foo!() == foo!();\n+}\n+\n fn main() {\n     let x = Some(0);\n "}, {"sha": "d06ab7aee558b3e04b59948413d022199a980956", "filename": "src/tools/clippy/tests/ui/partialeq_to_none.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpartialeq_to_none.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpartialeq_to_none.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpartialeq_to_none.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -7,55 +7,55 @@ LL |     if f != None { \"yay\" } else { \"nay\" }\n    = note: `-D clippy::partialeq-to-none` implied by `-D warnings`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:32:13\n+  --> $DIR/partialeq_to_none.rs:44:13\n    |\n LL |     let _ = x == None;\n    |             ^^^^^^^^^ help: use `Option::is_none()` instead: `x.is_none()`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:33:13\n+  --> $DIR/partialeq_to_none.rs:45:13\n    |\n LL |     let _ = x != None;\n    |             ^^^^^^^^^ help: use `Option::is_some()` instead: `x.is_some()`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:34:13\n+  --> $DIR/partialeq_to_none.rs:46:13\n    |\n LL |     let _ = None == x;\n    |             ^^^^^^^^^ help: use `Option::is_none()` instead: `x.is_none()`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:35:13\n+  --> $DIR/partialeq_to_none.rs:47:13\n    |\n LL |     let _ = None != x;\n    |             ^^^^^^^^^ help: use `Option::is_some()` instead: `x.is_some()`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:37:8\n+  --> $DIR/partialeq_to_none.rs:49:8\n    |\n LL |     if foobar() == None {}\n    |        ^^^^^^^^^^^^^^^^ help: use `Option::is_none()` instead: `foobar().is_none()`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:39:8\n+  --> $DIR/partialeq_to_none.rs:51:8\n    |\n LL |     if bar().ok() != None {}\n    |        ^^^^^^^^^^^^^^^^^^ help: use `Option::is_some()` instead: `bar().ok().is_some()`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:41:13\n+  --> $DIR/partialeq_to_none.rs:53:13\n    |\n LL |     let _ = Some(1 + 2) != None;\n    |             ^^^^^^^^^^^^^^^^^^^ help: use `Option::is_some()` instead: `Some(1 + 2).is_some()`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:43:13\n+  --> $DIR/partialeq_to_none.rs:55:13\n    |\n LL |     let _ = { Some(0) } == None;\n    |             ^^^^^^^^^^^^^^^^^^^ help: use `Option::is_none()` instead: `{ Some(0) }.is_none()`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:45:13\n+  --> $DIR/partialeq_to_none.rs:57:13\n    |\n LL |       let _ = {\n    |  _____________^\n@@ -77,31 +77,31 @@ LL ~     }.is_some();\n    |\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:55:13\n+  --> $DIR/partialeq_to_none.rs:67:13\n    |\n LL |     let _ = optref() == &&None;\n    |             ^^^^^^^^^^^^^^^^^^ help: use `Option::is_none()` instead: `optref().is_none()`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:56:13\n+  --> $DIR/partialeq_to_none.rs:68:13\n    |\n LL |     let _ = &&None != optref();\n    |             ^^^^^^^^^^^^^^^^^^ help: use `Option::is_some()` instead: `optref().is_some()`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:57:13\n+  --> $DIR/partialeq_to_none.rs:69:13\n    |\n LL |     let _ = **optref() == None;\n    |             ^^^^^^^^^^^^^^^^^^ help: use `Option::is_none()` instead: `optref().is_none()`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:58:13\n+  --> $DIR/partialeq_to_none.rs:70:13\n    |\n LL |     let _ = &None != *optref();\n    |             ^^^^^^^^^^^^^^^^^^ help: use `Option::is_some()` instead: `optref().is_some()`\n \n error: binary comparison to literal `Option::None`\n-  --> $DIR/partialeq_to_none.rs:61:13\n+  --> $DIR/partialeq_to_none.rs:73:13\n    |\n LL |     let _ = None != *x;\n    |             ^^^^^^^^^^ help: use `Option::is_some()` instead: `(*x).is_some()`"}, {"sha": "4170e109820457a5d4c667cc00941e9be3fc1fc0", "filename": "src/tools/clippy/tests/ui/positional_named_format_parameters.fixed", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpositional_named_format_parameters.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpositional_named_format_parameters.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpositional_named_format_parameters.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,56 @@\n+// run-rustfix\n+#![allow(unused_must_use)]\n+#![allow(named_arguments_used_positionally)] // Unstable at time of writing.\n+#![warn(clippy::positional_named_format_parameters)]\n+\n+use std::io::Write;\n+\n+fn main() {\n+    let mut v = Vec::new();\n+    let hello = \"Hello\";\n+\n+    println!(\"{hello:.foo$}\", foo = 2);\n+    writeln!(v, \"{hello:.foo$}\", foo = 2);\n+\n+    // Warnings\n+    println!(\"{zero} {one:?}\", zero = 0, one = 1);\n+    println!(\"This is a test {zero} {one:?}\", zero = 0, one = 1);\n+    println!(\"Hello {one} is {two:.zero$}\", zero = 5, one = hello, two = 0.01);\n+    println!(\"Hello {one:zero$}!\", zero = 5, one = 1);\n+    println!(\"Hello {zero:one$}!\", zero = 4, one = 1);\n+    println!(\"Hello {zero:0one$}!\", zero = 4, one = 1);\n+    println!(\"Hello is {one:.zero$}\", zero = 5, one = 0.01);\n+    println!(\"Hello is {one:<6.zero$}\", zero = 5, one = 0.01);\n+    println!(\"{zero}, `{two:>8.one$}` has 3\", zero = hello, one = 3, two = hello);\n+    println!(\"Hello {one} is {two:.zero$}\", zero = 5, one = hello, two = 0.01);\n+    println!(\"Hello {world} {world}!\", world = 5);\n+\n+    writeln!(v, \"{zero} {one:?}\", zero = 0, one = 1);\n+    writeln!(v, \"This is a test {zero} {one:?}\", zero = 0, one = 1);\n+    writeln!(v, \"Hello {one} is {two:.zero$}\", zero = 5, one = hello, two = 0.01);\n+    writeln!(v, \"Hello {one:zero$}!\", zero = 4, one = 1);\n+    writeln!(v, \"Hello {zero:one$}!\", zero = 4, one = 1);\n+    writeln!(v, \"Hello {zero:0one$}!\", zero = 4, one = 1);\n+    writeln!(v, \"Hello is {one:.zero$}\", zero = 3, one = 0.01);\n+    writeln!(v, \"Hello is {one:<6.zero$}\", zero = 2, one = 0.01);\n+    writeln!(v, \"{zero}, `{two:>8.one$}` has 3\", zero = hello, one = 3, two = hello);\n+    writeln!(v, \"Hello {one} is {two:.zero$}\", zero = 1, one = hello, two = 0.01);\n+    writeln!(v, \"Hello {world} {world}!\", world = 0);\n+\n+    // Tests from other files\n+    println!(\"{w:w$}\", w = 1);\n+    println!(\"{p:.p$}\", p = 1);\n+    println!(\"{v}\", v = 1);\n+    println!(\"{v:v$}\", v = 1);\n+    println!(\"{v:v$}\", v = 1);\n+    println!(\"{v:v$.v$}\", v = 1);\n+    println!(\"{v:v$.v$}\", v = 1);\n+    println!(\"{v:v$.v$}\", v = 1);\n+    println!(\"{v:v$.v$}\", v = 1);\n+    println!(\"{v:v$.v$}\", v = 1);\n+    println!(\"{v:v$.v$}\", v = 1);\n+    println!(\"{v:v$.v$}\", v = 1);\n+    println!(\"{w:w$}\", w = 1);\n+    println!(\"{p:.p$}\", p = 1);\n+    println!(\"{:p$.w$}\", 1, w = 1, p = 1);\n+}"}, {"sha": "553d8494ecc04303778cb9aa184faef5178e996a", "filename": "src/tools/clippy/tests/ui/positional_named_format_parameters.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpositional_named_format_parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpositional_named_format_parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpositional_named_format_parameters.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,56 @@\n+// run-rustfix\n+#![allow(unused_must_use)]\n+#![allow(named_arguments_used_positionally)] // Unstable at time of writing.\n+#![warn(clippy::positional_named_format_parameters)]\n+\n+use std::io::Write;\n+\n+fn main() {\n+    let mut v = Vec::new();\n+    let hello = \"Hello\";\n+\n+    println!(\"{hello:.foo$}\", foo = 2);\n+    writeln!(v, \"{hello:.foo$}\", foo = 2);\n+\n+    // Warnings\n+    println!(\"{} {1:?}\", zero = 0, one = 1);\n+    println!(\"This is a test { } {000001:?}\", zero = 0, one = 1);\n+    println!(\"Hello {1} is {2:.0$}\", zero = 5, one = hello, two = 0.01);\n+    println!(\"Hello {1:0$}!\", zero = 5, one = 1);\n+    println!(\"Hello {0:1$}!\", zero = 4, one = 1);\n+    println!(\"Hello {0:01$}!\", zero = 4, one = 1);\n+    println!(\"Hello is {1:.*}\", zero = 5, one = 0.01);\n+    println!(\"Hello is {:<6.*}\", zero = 5, one = 0.01);\n+    println!(\"{}, `{two:>8.*}` has 3\", zero = hello, one = 3, two = hello);\n+    println!(\"Hello {1} is {2:.0$}\", zero = 5, one = hello, two = 0.01);\n+    println!(\"Hello {world} {}!\", world = 5);\n+\n+    writeln!(v, \"{} {1:?}\", zero = 0, one = 1);\n+    writeln!(v, \"This is a test { } {000001:?}\", zero = 0, one = 1);\n+    writeln!(v, \"Hello {1} is {2:.0$}\", zero = 5, one = hello, two = 0.01);\n+    writeln!(v, \"Hello {1:0$}!\", zero = 4, one = 1);\n+    writeln!(v, \"Hello {0:1$}!\", zero = 4, one = 1);\n+    writeln!(v, \"Hello {0:01$}!\", zero = 4, one = 1);\n+    writeln!(v, \"Hello is {1:.*}\", zero = 3, one = 0.01);\n+    writeln!(v, \"Hello is {:<6.*}\", zero = 2, one = 0.01);\n+    writeln!(v, \"{}, `{two:>8.*}` has 3\", zero = hello, one = 3, two = hello);\n+    writeln!(v, \"Hello {1} is {2:.0$}\", zero = 1, one = hello, two = 0.01);\n+    writeln!(v, \"Hello {world} {}!\", world = 0);\n+\n+    // Tests from other files\n+    println!(\"{:w$}\", w = 1);\n+    println!(\"{:.p$}\", p = 1);\n+    println!(\"{}\", v = 1);\n+    println!(\"{:0$}\", v = 1);\n+    println!(\"{0:0$}\", v = 1);\n+    println!(\"{:0$.0$}\", v = 1);\n+    println!(\"{0:0$.0$}\", v = 1);\n+    println!(\"{0:0$.v$}\", v = 1);\n+    println!(\"{0:v$.0$}\", v = 1);\n+    println!(\"{v:0$.0$}\", v = 1);\n+    println!(\"{v:v$.0$}\", v = 1);\n+    println!(\"{v:0$.v$}\", v = 1);\n+    println!(\"{:w$}\", w = 1);\n+    println!(\"{:.p$}\", p = 1);\n+    println!(\"{:p$.w$}\", 1, w = 1, p = 1);\n+}"}, {"sha": "48ddb6d67ad246084bdbb951887d8759969c297d", "filename": "src/tools/clippy/tests/ui/positional_named_format_parameters.stderr", "status": "added", "additions": 418, "deletions": 0, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpositional_named_format_parameters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpositional_named_format_parameters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpositional_named_format_parameters.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,418 @@\n+error: named parameter zero is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:16:16\n+   |\n+LL |     println!(\"{} {1:?}\", zero = 0, one = 1);\n+   |                ^ help: replace it with: `zero`\n+   |\n+   = note: `-D clippy::positional-named-format-parameters` implied by `-D warnings`\n+\n+error: named parameter one is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:16:19\n+   |\n+LL |     println!(\"{} {1:?}\", zero = 0, one = 1);\n+   |                   ^ help: replace it with: `one`\n+\n+error: named parameter zero is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:17:31\n+   |\n+LL |     println!(\"This is a test { } {000001:?}\", zero = 0, one = 1);\n+   |                               ^ help: replace it with: `zero`\n+\n+error: named parameter one is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:17:35\n+   |\n+LL |     println!(\"This is a test { } {000001:?}\", zero = 0, one = 1);\n+   |                                   ^^^^^^ help: replace it with: `one`\n+\n+error: named parameter zero is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:18:32\n+   |\n+LL |     println!(\"Hello {1} is {2:.0$}\", zero = 5, one = hello, two = 0.01);\n+   |                                ^ help: replace it with: `zero`\n+\n+error: named parameter one is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:18:22\n+   |\n+LL |     println!(\"Hello {1} is {2:.0$}\", zero = 5, one = hello, two = 0.01);\n+   |                      ^ help: replace it with: `one`\n+\n+error: named parameter two is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:18:29\n+   |\n+LL |     println!(\"Hello {1} is {2:.0$}\", zero = 5, one = hello, two = 0.01);\n+   |                             ^ help: replace it with: `two`\n+\n+error: named parameter zero is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:19:24\n+   |\n+LL |     println!(\"Hello {1:0$}!\", zero = 5, one = 1);\n+   |                        ^ help: replace it with: `zero`\n+\n+error: named parameter one is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:19:22\n+   |\n+LL |     println!(\"Hello {1:0$}!\", zero = 5, one = 1);\n+   |                      ^ help: replace it with: `one`\n+\n+error: named parameter zero is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:20:22\n+   |\n+LL |     println!(\"Hello {0:1$}!\", zero = 4, one = 1);\n+   |                      ^ help: replace it with: `zero`\n+\n+error: named parameter one is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:20:24\n+   |\n+LL |     println!(\"Hello {0:1$}!\", zero = 4, one = 1);\n+   |                        ^ help: replace it with: `one`\n+\n+error: named parameter zero is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:21:22\n+   |\n+LL |     println!(\"Hello {0:01$}!\", zero = 4, one = 1);\n+   |                      ^ help: replace it with: `zero`\n+\n+error: named parameter one is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:21:25\n+   |\n+LL |     println!(\"Hello {0:01$}!\", zero = 4, one = 1);\n+   |                         ^ help: replace it with: `one`\n+\n+error: named parameter zero is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:22:28\n+   |\n+LL |     println!(\"Hello is {1:.*}\", zero = 5, one = 0.01);\n+   |                            ^ help: replace it with: `zero$`\n+\n+error: named parameter one is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:22:25\n+   |\n+LL |     println!(\"Hello is {1:.*}\", zero = 5, one = 0.01);\n+   |                         ^ help: replace it with: `one`\n+\n+error: named parameter zero is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:23:29\n+   |\n+LL |     println!(\"Hello is {:<6.*}\", zero = 5, one = 0.01);\n+   |                             ^ help: replace it with: `zero$`\n+\n+error: named parameter one is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:23:25\n+   |\n+LL |     println!(\"Hello is {:<6.*}\", zero = 5, one = 0.01);\n+   |                         ^ help: replace it with: `one`\n+\n+error: named parameter zero is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:24:16\n+   |\n+LL |     println!(\"{}, `{two:>8.*}` has 3\", zero = hello, one = 3, two = hello);\n+   |                ^ help: replace it with: `zero`\n+\n+error: named parameter one is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:24:28\n+   |\n+LL |     println!(\"{}, `{two:>8.*}` has 3\", zero = hello, one = 3, two = hello);\n+   |                            ^ help: replace it with: `one$`\n+\n+error: named parameter zero is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:25:32\n+   |\n+LL |     println!(\"Hello {1} is {2:.0$}\", zero = 5, one = hello, two = 0.01);\n+   |                                ^ help: replace it with: `zero`\n+\n+error: named parameter one is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:25:22\n+   |\n+LL |     println!(\"Hello {1} is {2:.0$}\", zero = 5, one = hello, two = 0.01);\n+   |                      ^ help: replace it with: `one`\n+\n+error: named parameter two is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:25:29\n+   |\n+LL |     println!(\"Hello {1} is {2:.0$}\", zero = 5, one = hello, two = 0.01);\n+   |                             ^ help: replace it with: `two`\n+\n+error: named parameter world is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:26:30\n+   |\n+LL |     println!(\"Hello {world} {}!\", world = 5);\n+   |                              ^ help: replace it with: `world`\n+\n+error: named parameter zero is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:28:19\n+   |\n+LL |     writeln!(v, \"{} {1:?}\", zero = 0, one = 1);\n+   |                   ^ help: replace it with: `zero`\n+\n+error: named parameter one is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:28:22\n+   |\n+LL |     writeln!(v, \"{} {1:?}\", zero = 0, one = 1);\n+   |                      ^ help: replace it with: `one`\n+\n+error: named parameter zero is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:29:34\n+   |\n+LL |     writeln!(v, \"This is a test { } {000001:?}\", zero = 0, one = 1);\n+   |                                  ^ help: replace it with: `zero`\n+\n+error: named parameter one is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:29:38\n+   |\n+LL |     writeln!(v, \"This is a test { } {000001:?}\", zero = 0, one = 1);\n+   |                                      ^^^^^^ help: replace it with: `one`\n+\n+error: named parameter zero is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:30:35\n+   |\n+LL |     writeln!(v, \"Hello {1} is {2:.0$}\", zero = 5, one = hello, two = 0.01);\n+   |                                   ^ help: replace it with: `zero`\n+\n+error: named parameter one is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:30:25\n+   |\n+LL |     writeln!(v, \"Hello {1} is {2:.0$}\", zero = 5, one = hello, two = 0.01);\n+   |                         ^ help: replace it with: `one`\n+\n+error: named parameter two is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:30:32\n+   |\n+LL |     writeln!(v, \"Hello {1} is {2:.0$}\", zero = 5, one = hello, two = 0.01);\n+   |                                ^ help: replace it with: `two`\n+\n+error: named parameter zero is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:31:27\n+   |\n+LL |     writeln!(v, \"Hello {1:0$}!\", zero = 4, one = 1);\n+   |                           ^ help: replace it with: `zero`\n+\n+error: named parameter one is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:31:25\n+   |\n+LL |     writeln!(v, \"Hello {1:0$}!\", zero = 4, one = 1);\n+   |                         ^ help: replace it with: `one`\n+\n+error: named parameter zero is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:32:25\n+   |\n+LL |     writeln!(v, \"Hello {0:1$}!\", zero = 4, one = 1);\n+   |                         ^ help: replace it with: `zero`\n+\n+error: named parameter one is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:32:27\n+   |\n+LL |     writeln!(v, \"Hello {0:1$}!\", zero = 4, one = 1);\n+   |                           ^ help: replace it with: `one`\n+\n+error: named parameter zero is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:33:25\n+   |\n+LL |     writeln!(v, \"Hello {0:01$}!\", zero = 4, one = 1);\n+   |                         ^ help: replace it with: `zero`\n+\n+error: named parameter one is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:33:28\n+   |\n+LL |     writeln!(v, \"Hello {0:01$}!\", zero = 4, one = 1);\n+   |                            ^ help: replace it with: `one`\n+\n+error: named parameter zero is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:34:31\n+   |\n+LL |     writeln!(v, \"Hello is {1:.*}\", zero = 3, one = 0.01);\n+   |                               ^ help: replace it with: `zero$`\n+\n+error: named parameter one is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:34:28\n+   |\n+LL |     writeln!(v, \"Hello is {1:.*}\", zero = 3, one = 0.01);\n+   |                            ^ help: replace it with: `one`\n+\n+error: named parameter zero is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:35:32\n+   |\n+LL |     writeln!(v, \"Hello is {:<6.*}\", zero = 2, one = 0.01);\n+   |                                ^ help: replace it with: `zero$`\n+\n+error: named parameter one is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:35:28\n+   |\n+LL |     writeln!(v, \"Hello is {:<6.*}\", zero = 2, one = 0.01);\n+   |                            ^ help: replace it with: `one`\n+\n+error: named parameter zero is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:36:19\n+   |\n+LL |     writeln!(v, \"{}, `{two:>8.*}` has 3\", zero = hello, one = 3, two = hello);\n+   |                   ^ help: replace it with: `zero`\n+\n+error: named parameter one is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:36:31\n+   |\n+LL |     writeln!(v, \"{}, `{two:>8.*}` has 3\", zero = hello, one = 3, two = hello);\n+   |                               ^ help: replace it with: `one$`\n+\n+error: named parameter zero is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:37:35\n+   |\n+LL |     writeln!(v, \"Hello {1} is {2:.0$}\", zero = 1, one = hello, two = 0.01);\n+   |                                   ^ help: replace it with: `zero`\n+\n+error: named parameter one is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:37:25\n+   |\n+LL |     writeln!(v, \"Hello {1} is {2:.0$}\", zero = 1, one = hello, two = 0.01);\n+   |                         ^ help: replace it with: `one`\n+\n+error: named parameter two is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:37:32\n+   |\n+LL |     writeln!(v, \"Hello {1} is {2:.0$}\", zero = 1, one = hello, two = 0.01);\n+   |                                ^ help: replace it with: `two`\n+\n+error: named parameter world is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:38:33\n+   |\n+LL |     writeln!(v, \"Hello {world} {}!\", world = 0);\n+   |                                 ^ help: replace it with: `world`\n+\n+error: named parameter w is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:41:16\n+   |\n+LL |     println!(\"{:w$}\", w = 1);\n+   |                ^ help: replace it with: `w`\n+\n+error: named parameter p is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:42:16\n+   |\n+LL |     println!(\"{:.p$}\", p = 1);\n+   |                ^ help: replace it with: `p`\n+\n+error: named parameter v is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:43:16\n+   |\n+LL |     println!(\"{}\", v = 1);\n+   |                ^ help: replace it with: `v`\n+\n+error: named parameter v is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:44:16\n+   |\n+LL |     println!(\"{:0$}\", v = 1);\n+   |                ^ help: replace it with: `v`\n+\n+error: named parameter v is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:44:17\n+   |\n+LL |     println!(\"{:0$}\", v = 1);\n+   |                 ^ help: replace it with: `v`\n+\n+error: named parameter v is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:45:16\n+   |\n+LL |     println!(\"{0:0$}\", v = 1);\n+   |                ^ help: replace it with: `v`\n+\n+error: named parameter v is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:45:18\n+   |\n+LL |     println!(\"{0:0$}\", v = 1);\n+   |                  ^ help: replace it with: `v`\n+\n+error: named parameter v is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:46:16\n+   |\n+LL |     println!(\"{:0$.0$}\", v = 1);\n+   |                ^ help: replace it with: `v`\n+\n+error: named parameter v is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:46:20\n+   |\n+LL |     println!(\"{:0$.0$}\", v = 1);\n+   |                    ^ help: replace it with: `v`\n+\n+error: named parameter v is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:46:17\n+   |\n+LL |     println!(\"{:0$.0$}\", v = 1);\n+   |                 ^ help: replace it with: `v`\n+\n+error: named parameter v is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:47:16\n+   |\n+LL |     println!(\"{0:0$.0$}\", v = 1);\n+   |                ^ help: replace it with: `v`\n+\n+error: named parameter v is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:47:21\n+   |\n+LL |     println!(\"{0:0$.0$}\", v = 1);\n+   |                     ^ help: replace it with: `v`\n+\n+error: named parameter v is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:47:18\n+   |\n+LL |     println!(\"{0:0$.0$}\", v = 1);\n+   |                  ^ help: replace it with: `v`\n+\n+error: named parameter v is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:48:16\n+   |\n+LL |     println!(\"{0:0$.v$}\", v = 1);\n+   |                ^ help: replace it with: `v`\n+\n+error: named parameter v is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:48:18\n+   |\n+LL |     println!(\"{0:0$.v$}\", v = 1);\n+   |                  ^ help: replace it with: `v`\n+\n+error: named parameter v is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:49:16\n+   |\n+LL |     println!(\"{0:v$.0$}\", v = 1);\n+   |                ^ help: replace it with: `v`\n+\n+error: named parameter v is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:49:21\n+   |\n+LL |     println!(\"{0:v$.0$}\", v = 1);\n+   |                     ^ help: replace it with: `v`\n+\n+error: named parameter v is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:50:21\n+   |\n+LL |     println!(\"{v:0$.0$}\", v = 1);\n+   |                     ^ help: replace it with: `v`\n+\n+error: named parameter v is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:50:18\n+   |\n+LL |     println!(\"{v:0$.0$}\", v = 1);\n+   |                  ^ help: replace it with: `v`\n+\n+error: named parameter v is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:51:21\n+   |\n+LL |     println!(\"{v:v$.0$}\", v = 1);\n+   |                     ^ help: replace it with: `v`\n+\n+error: named parameter v is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:52:18\n+   |\n+LL |     println!(\"{v:0$.v$}\", v = 1);\n+   |                  ^ help: replace it with: `v`\n+\n+error: named parameter w is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:53:16\n+   |\n+LL |     println!(\"{:w$}\", w = 1);\n+   |                ^ help: replace it with: `w`\n+\n+error: named parameter p is used as a positional parameter\n+  --> $DIR/positional_named_format_parameters.rs:54:16\n+   |\n+LL |     println!(\"{:.p$}\", p = 1);\n+   |                ^ help: replace it with: `p`\n+\n+error: aborting due to 69 previous errors\n+"}, {"sha": "57f23bd1916ffaa46272f152ebc52f5d79c1f8e3", "filename": "src/tools/clippy/tests/ui/question_mark.fixed", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fquestion_mark.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fquestion_mark.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fquestion_mark.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -207,4 +207,19 @@ fn option_map() -> Option<bool> {\n     }\n }\n \n+pub struct PatternedError {\n+    flag: bool,\n+}\n+\n+// No warning\n+fn pattern() -> Result<(), PatternedError> {\n+    let res = Ok(());\n+\n+    if let Err(err @ PatternedError { flag: true }) = res {\n+        return Err(err);\n+    }\n+\n+    res\n+}\n+\n fn main() {}"}, {"sha": "436f027c215d54f459d244628acd9b358899c51c", "filename": "src/tools/clippy/tests/ui/question_mark.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fquestion_mark.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -243,4 +243,19 @@ fn option_map() -> Option<bool> {\n     }\n }\n \n+pub struct PatternedError {\n+    flag: bool,\n+}\n+\n+// No warning\n+fn pattern() -> Result<(), PatternedError> {\n+    let res = Ok(());\n+\n+    if let Err(err @ PatternedError { flag: true }) = res {\n+        return Err(err);\n+    }\n+\n+    res\n+}\n+\n fn main() {}"}, {"sha": "f0e1a8128d7c36b5bc44d3d77c7ee270988780d7", "filename": "src/tools/clippy/tests/ui/regex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fregex.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,4 +1,4 @@\n-#![allow(unused)]\n+#![allow(unused, clippy::needless_borrow)]\n #![warn(clippy::invalid_regex, clippy::trivial_regex)]\n \n extern crate regex;"}, {"sha": "78d8f76fe669fb32926d4459252735166997062d", "filename": "src/tools/clippy/tests/ui/result_large_err.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fresult_large_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fresult_large_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fresult_large_err.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,98 @@\n+#![warn(clippy::result_large_err)]\n+\n+pub fn small_err() -> Result<(), u128> {\n+    Ok(())\n+}\n+\n+pub fn large_err() -> Result<(), [u8; 512]> {\n+    Ok(())\n+}\n+\n+pub struct FullyDefinedLargeError {\n+    _foo: u128,\n+    _bar: [u8; 100],\n+    _foobar: [u8; 120],\n+}\n+\n+impl FullyDefinedLargeError {\n+    pub fn ret() -> Result<(), Self> {\n+        Ok(())\n+    }\n+}\n+\n+pub fn struct_error() -> Result<(), FullyDefinedLargeError> {\n+    Ok(())\n+}\n+\n+type Fdlr<T> = std::result::Result<T, FullyDefinedLargeError>;\n+pub fn large_err_via_type_alias<T>(x: T) -> Fdlr<T> {\n+    Ok(x)\n+}\n+\n+pub fn param_small_error<R>() -> Result<(), (R, u128)> {\n+    Ok(())\n+}\n+\n+pub fn param_large_error<R>() -> Result<(), (u128, R, FullyDefinedLargeError)> {\n+    Ok(())\n+}\n+\n+pub enum LargeErrorVariants<T> {\n+    _Small(u8),\n+    _Omg([u8; 512]),\n+    _Param(T),\n+}\n+\n+impl LargeErrorVariants<()> {\n+    pub fn large_enum_error() -> Result<(), Self> {\n+        Ok(())\n+    }\n+}\n+\n+trait TraitForcesLargeError {\n+    fn large_error() -> Result<(), [u8; 512]> {\n+        Ok(())\n+    }\n+}\n+\n+struct TraitImpl;\n+\n+impl TraitForcesLargeError for TraitImpl {\n+    // Should not lint\n+    fn large_error() -> Result<(), [u8; 512]> {\n+        Ok(())\n+    }\n+}\n+\n+pub union FullyDefinedUnionError {\n+    _maybe: u8,\n+    _or_even: [[u8; 16]; 32],\n+}\n+\n+pub fn large_union_err() -> Result<(), FullyDefinedUnionError> {\n+    Ok(())\n+}\n+\n+pub union UnionError<T: Copy> {\n+    _maybe: T,\n+    _or_perhaps_even: (T, [u8; 512]),\n+}\n+\n+pub fn param_large_union<T: Copy>() -> Result<(), UnionError<T>> {\n+    Ok(())\n+}\n+\n+pub struct ArrayError<T, U> {\n+    _large_array: [T; 32],\n+    _other_stuff: U,\n+}\n+\n+pub fn array_error_subst<U>() -> Result<(), ArrayError<i32, U>> {\n+    Ok(())\n+}\n+\n+pub fn array_error<T, U>() -> Result<(), ArrayError<(i32, T), U>> {\n+    Ok(())\n+}\n+\n+fn main() {}"}, {"sha": "0f1f39d72cba187cff97f89762840cc32023c90c", "filename": "src/tools/clippy/tests/ui/result_large_err.stderr", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fresult_large_err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fresult_large_err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fresult_large_err.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,91 @@\n+error: the `Err`-variant returned from this function is very large\n+  --> $DIR/result_large_err.rs:7:23\n+   |\n+LL | pub fn large_err() -> Result<(), [u8; 512]> {\n+   |                       ^^^^^^^^^^^^^^^^^^^^^ the `Err`-variant is at least 512 bytes\n+   |\n+   = note: `-D clippy::result-large-err` implied by `-D warnings`\n+   = help: try reducing the size of `[u8; 512]`, for example by boxing large elements or replacing it with `Box<[u8; 512]>`\n+\n+error: the `Err`-variant returned from this function is very large\n+  --> $DIR/result_large_err.rs:18:21\n+   |\n+LL |     pub fn ret() -> Result<(), Self> {\n+   |                     ^^^^^^^^^^^^^^^^ the `Err`-variant is at least 240 bytes\n+   |\n+   = help: try reducing the size of `FullyDefinedLargeError`, for example by boxing large elements or replacing it with `Box<FullyDefinedLargeError>`\n+\n+error: the `Err`-variant returned from this function is very large\n+  --> $DIR/result_large_err.rs:23:26\n+   |\n+LL | pub fn struct_error() -> Result<(), FullyDefinedLargeError> {\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the `Err`-variant is at least 240 bytes\n+   |\n+   = help: try reducing the size of `FullyDefinedLargeError`, for example by boxing large elements or replacing it with `Box<FullyDefinedLargeError>`\n+\n+error: the `Err`-variant returned from this function is very large\n+  --> $DIR/result_large_err.rs:28:45\n+   |\n+LL | pub fn large_err_via_type_alias<T>(x: T) -> Fdlr<T> {\n+   |                                             ^^^^^^^ the `Err`-variant is at least 240 bytes\n+   |\n+   = help: try reducing the size of `FullyDefinedLargeError`, for example by boxing large elements or replacing it with `Box<FullyDefinedLargeError>`\n+\n+error: the `Err`-variant returned from this function is very large\n+  --> $DIR/result_large_err.rs:36:34\n+   |\n+LL | pub fn param_large_error<R>() -> Result<(), (u128, R, FullyDefinedLargeError)> {\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the `Err`-variant is at least 256 bytes\n+   |\n+   = help: try reducing the size of `(u128, R, FullyDefinedLargeError)`, for example by boxing large elements or replacing it with `Box<(u128, R, FullyDefinedLargeError)>`\n+\n+error: the `Err`-variant returned from this function is very large\n+  --> $DIR/result_large_err.rs:47:34\n+   |\n+LL |     pub fn large_enum_error() -> Result<(), Self> {\n+   |                                  ^^^^^^^^^^^^^^^^ the `Err`-variant is at least 513 bytes\n+   |\n+   = help: try reducing the size of `LargeErrorVariants<()>`, for example by boxing large elements or replacing it with `Box<LargeErrorVariants<()>>`\n+\n+error: the `Err`-variant returned from this function is very large\n+  --> $DIR/result_large_err.rs:53:25\n+   |\n+LL |     fn large_error() -> Result<(), [u8; 512]> {\n+   |                         ^^^^^^^^^^^^^^^^^^^^^ the `Err`-variant is at least 512 bytes\n+   |\n+   = help: try reducing the size of `[u8; 512]`, for example by boxing large elements or replacing it with `Box<[u8; 512]>`\n+\n+error: the `Err`-variant returned from this function is very large\n+  --> $DIR/result_large_err.rs:72:29\n+   |\n+LL | pub fn large_union_err() -> Result<(), FullyDefinedUnionError> {\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the `Err`-variant is at least 512 bytes\n+   |\n+   = help: try reducing the size of `FullyDefinedUnionError`, for example by boxing large elements or replacing it with `Box<FullyDefinedUnionError>`\n+\n+error: the `Err`-variant returned from this function is very large\n+  --> $DIR/result_large_err.rs:81:40\n+   |\n+LL | pub fn param_large_union<T: Copy>() -> Result<(), UnionError<T>> {\n+   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^ the `Err`-variant is at least 512 bytes\n+   |\n+   = help: try reducing the size of `UnionError<T>`, for example by boxing large elements or replacing it with `Box<UnionError<T>>`\n+\n+error: the `Err`-variant returned from this function is very large\n+  --> $DIR/result_large_err.rs:90:34\n+   |\n+LL | pub fn array_error_subst<U>() -> Result<(), ArrayError<i32, U>> {\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the `Err`-variant is at least 128 bytes\n+   |\n+   = help: try reducing the size of `ArrayError<i32, U>`, for example by boxing large elements or replacing it with `Box<ArrayError<i32, U>>`\n+\n+error: the `Err`-variant returned from this function is very large\n+  --> $DIR/result_large_err.rs:94:31\n+   |\n+LL | pub fn array_error<T, U>() -> Result<(), ArrayError<(i32, T), U>> {\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the `Err`-variant is at least 128 bytes\n+   |\n+   = help: try reducing the size of `ArrayError<(i32, T), U>`, for example by boxing large elements or replacing it with `Box<ArrayError<(i32, T), U>>`\n+\n+error: aborting due to 11 previous errors\n+"}, {"sha": "af01a8df71b015cff39987006088878f8a4db000", "filename": "src/tools/clippy/tests/ui/same_item_push.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsame_item_push.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -151,6 +151,7 @@ fn main() {\n \n     // Fix #6987\n     let mut vec = Vec::new();\n+    #[allow(clippy::needless_borrow)]\n     for _ in 0..10 {\n         vec.push(1);\n         vec.extend(&[2]);"}, {"sha": "16673c01e63017da5769a39ea8085cf9f348dc76", "filename": "src/tools/clippy/tests/ui/string_add.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_add.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -7,13 +7,13 @@ extern crate macro_rules;\n #[allow(clippy::string_add_assign, unused)]\n fn main() {\n     // ignores assignment distinction\n-    let mut x = \"\".to_owned();\n+    let mut x = String::new();\n \n     for _ in 1..3 {\n         x = x + \".\";\n     }\n \n-    let y = \"\".to_owned();\n+    let y = String::new();\n     let z = y + \"...\";\n \n     assert_eq!(&x, &z);"}, {"sha": "b687f43b2541a016af4cb3abe8a07ce865b5de2c", "filename": "src/tools/clippy/tests/ui/string_add_assign.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_add_assign.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_add_assign.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_add_assign.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -4,13 +4,13 @@\n #[warn(clippy::string_add_assign)]\n fn main() {\n     // ignores assignment distinction\n-    let mut x = \"\".to_owned();\n+    let mut x = String::new();\n \n     for _ in 1..3 {\n         x += \".\";\n     }\n \n-    let y = \"\".to_owned();\n+    let y = String::new();\n     let z = y + \"...\";\n \n     assert_eq!(&x, &z);"}, {"sha": "e5dbde108fbdbebd46df2e51583b9f18f34603c8", "filename": "src/tools/clippy/tests/ui/string_add_assign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_add_assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_add_assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_add_assign.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -4,13 +4,13 @@\n #[warn(clippy::string_add_assign)]\n fn main() {\n     // ignores assignment distinction\n-    let mut x = \"\".to_owned();\n+    let mut x = String::new();\n \n     for _ in 1..3 {\n         x = x + \".\";\n     }\n \n-    let y = \"\".to_owned();\n+    let y = String::new();\n     let z = y + \"...\";\n \n     assert_eq!(&x, &z);"}, {"sha": "cba21bf4a93a1b4260b0c30490a3468091bb116e", "filename": "src/tools/clippy/tests/ui/suspicious_to_owned.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsuspicious_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsuspicious_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsuspicious_to_owned.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,62 @@\n+#![warn(clippy::suspicious_to_owned)]\n+#![warn(clippy::implicit_clone)]\n+#![allow(clippy::redundant_clone)]\n+use std::borrow::Cow;\n+use std::ffi::{c_char, CStr};\n+\n+fn main() {\n+    let moo = \"Moooo\";\n+    let c_moo = b\"Moooo\\0\";\n+    let c_moo_ptr = c_moo.as_ptr() as *const c_char;\n+    let moos = ['M', 'o', 'o'];\n+    let moos_vec = moos.to_vec();\n+\n+    // we expect this to be linted\n+    let cow = Cow::Borrowed(moo);\n+    let _ = cow.to_owned();\n+    // we expect no lints for this\n+    let cow = Cow::Borrowed(moo);\n+    let _ = cow.into_owned();\n+    // we expect no lints for this\n+    let cow = Cow::Borrowed(moo);\n+    let _ = cow.clone();\n+\n+    // we expect this to be linted\n+    let cow = Cow::Borrowed(&moos);\n+    let _ = cow.to_owned();\n+    // we expect no lints for this\n+    let cow = Cow::Borrowed(&moos);\n+    let _ = cow.into_owned();\n+    // we expect no lints for this\n+    let cow = Cow::Borrowed(&moos);\n+    let _ = cow.clone();\n+\n+    // we expect this to be linted\n+    let cow = Cow::Borrowed(&moos_vec);\n+    let _ = cow.to_owned();\n+    // we expect no lints for this\n+    let cow = Cow::Borrowed(&moos_vec);\n+    let _ = cow.into_owned();\n+    // we expect no lints for this\n+    let cow = Cow::Borrowed(&moos_vec);\n+    let _ = cow.clone();\n+\n+    // we expect this to be linted\n+    let cow = unsafe { CStr::from_ptr(c_moo_ptr) }.to_string_lossy();\n+    let _ = cow.to_owned();\n+    // we expect no lints for this\n+    let cow = unsafe { CStr::from_ptr(c_moo_ptr) }.to_string_lossy();\n+    let _ = cow.into_owned();\n+    // we expect no lints for this\n+    let cow = unsafe { CStr::from_ptr(c_moo_ptr) }.to_string_lossy();\n+    let _ = cow.clone();\n+\n+    // we expect no lints for these\n+    let _ = moo.to_owned();\n+    let _ = c_moo.to_owned();\n+    let _ = moos.to_owned();\n+\n+    // we expect implicit_clone lints for these\n+    let _ = String::from(moo).to_owned();\n+    let _ = moos_vec.to_owned();\n+}"}, {"sha": "92e1024bf1f4ecd212275549e05dd323296bb49a", "filename": "src/tools/clippy/tests/ui/suspicious_to_owned.stderr", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsuspicious_to_owned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsuspicious_to_owned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsuspicious_to_owned.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,42 @@\n+error: this `to_owned` call clones the std::borrow::Cow<str> itself and does not cause the std::borrow::Cow<str> contents to become owned\n+  --> $DIR/suspicious_to_owned.rs:16:13\n+   |\n+LL |     let _ = cow.to_owned();\n+   |             ^^^^^^^^^^^^^^ help: consider using, depending on intent: `cow.clone()` or `cow.into_owned()`\n+   |\n+   = note: `-D clippy::suspicious-to-owned` implied by `-D warnings`\n+\n+error: this `to_owned` call clones the std::borrow::Cow<[char; 3]> itself and does not cause the std::borrow::Cow<[char; 3]> contents to become owned\n+  --> $DIR/suspicious_to_owned.rs:26:13\n+   |\n+LL |     let _ = cow.to_owned();\n+   |             ^^^^^^^^^^^^^^ help: consider using, depending on intent: `cow.clone()` or `cow.into_owned()`\n+\n+error: this `to_owned` call clones the std::borrow::Cow<std::vec::Vec<char>> itself and does not cause the std::borrow::Cow<std::vec::Vec<char>> contents to become owned\n+  --> $DIR/suspicious_to_owned.rs:36:13\n+   |\n+LL |     let _ = cow.to_owned();\n+   |             ^^^^^^^^^^^^^^ help: consider using, depending on intent: `cow.clone()` or `cow.into_owned()`\n+\n+error: this `to_owned` call clones the std::borrow::Cow<str> itself and does not cause the std::borrow::Cow<str> contents to become owned\n+  --> $DIR/suspicious_to_owned.rs:46:13\n+   |\n+LL |     let _ = cow.to_owned();\n+   |             ^^^^^^^^^^^^^^ help: consider using, depending on intent: `cow.clone()` or `cow.into_owned()`\n+\n+error: implicitly cloning a `String` by calling `to_owned` on its dereferenced type\n+  --> $DIR/suspicious_to_owned.rs:60:13\n+   |\n+LL |     let _ = String::from(moo).to_owned();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `String::from(moo).clone()`\n+   |\n+   = note: `-D clippy::implicit-clone` implied by `-D warnings`\n+\n+error: implicitly cloning a `Vec` by calling `to_owned` on its dereferenced type\n+  --> $DIR/suspicious_to_owned.rs:61:13\n+   |\n+LL |     let _ = moos_vec.to_owned();\n+   |             ^^^^^^^^^^^^^^^^^^^ help: consider using: `moos_vec.clone()`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "4ce5d421782250987f5efcbaab50ba825f2a9c2b", "filename": "src/tools/clippy/tests/ui/trait_duplication_in_bounds.fixed", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,112 @@\n+// run-rustfix\n+#![deny(clippy::trait_duplication_in_bounds)]\n+#![allow(unused)]\n+\n+fn bad_foo<T: Clone + Copy, U: Clone + Copy>(arg0: T, argo1: U) {\n+    unimplemented!();\n+}\n+\n+fn bad_bar<T, U>(arg0: T, arg1: U)\n+where\n+    T: Clone + Copy,\n+    U: Clone + Copy,\n+{\n+    unimplemented!();\n+}\n+\n+fn good_bar<T: Clone + Copy, U: Clone + Copy>(arg0: T, arg1: U) {\n+    unimplemented!();\n+}\n+\n+fn good_foo<T, U>(arg0: T, arg1: U)\n+where\n+    T: Clone + Copy,\n+    U: Clone + Copy,\n+{\n+    unimplemented!();\n+}\n+\n+trait GoodSelfTraitBound: Clone + Copy {\n+    fn f();\n+}\n+\n+trait GoodSelfWhereClause {\n+    fn f()\n+    where\n+        Self: Clone + Copy;\n+}\n+\n+trait BadSelfTraitBound: Clone {\n+    fn f();\n+}\n+\n+trait BadSelfWhereClause {\n+    fn f()\n+    where\n+        Self: Clone;\n+}\n+\n+trait GoodTraitBound<T: Clone + Copy, U: Clone + Copy> {\n+    fn f();\n+}\n+\n+trait GoodWhereClause<T, U> {\n+    fn f()\n+    where\n+        T: Clone + Copy,\n+        U: Clone + Copy;\n+}\n+\n+trait BadTraitBound<T: Clone + Copy, U: Clone + Copy> {\n+    fn f();\n+}\n+\n+trait BadWhereClause<T, U> {\n+    fn f()\n+    where\n+        T: Clone + Copy,\n+        U: Clone + Copy;\n+}\n+\n+struct GoodStructBound<T: Clone + Copy, U: Clone + Copy> {\n+    t: T,\n+    u: U,\n+}\n+\n+impl<T: Clone + Copy, U: Clone + Copy> GoodTraitBound<T, U> for GoodStructBound<T, U> {\n+    // this should not warn\n+    fn f() {}\n+}\n+\n+struct GoodStructWhereClause;\n+\n+impl<T, U> GoodTraitBound<T, U> for GoodStructWhereClause\n+where\n+    T: Clone + Copy,\n+    U: Clone + Copy,\n+{\n+    // this should not warn\n+    fn f() {}\n+}\n+\n+fn no_error_separate_arg_bounds(program: impl AsRef<()>, dir: impl AsRef<()>, args: &[impl AsRef<()>]) {}\n+\n+trait GenericTrait<T> {}\n+\n+fn good_generic<T: GenericTrait<u64> + GenericTrait<u32>>(arg0: T) {\n+    unimplemented!();\n+}\n+\n+fn bad_generic<T: GenericTrait<u64> + GenericTrait<u32>>(arg0: T) {\n+    unimplemented!();\n+}\n+\n+mod foo {\n+    pub trait Clone {}\n+}\n+\n+fn qualified_path<T: std::clone::Clone + foo::Clone>(arg0: T) {\n+    unimplemented!();\n+}\n+\n+fn main() {}"}, {"sha": "7f2e96a22e6648eb27aaf1178eec55ff2c86cab5", "filename": "src/tools/clippy/tests/ui/trait_duplication_in_bounds.rs", "status": "modified", "additions": 59, "deletions": 159, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,212 +1,112 @@\n+// run-rustfix\n #![deny(clippy::trait_duplication_in_bounds)]\n #![allow(unused)]\n \n-use std::collections::BTreeMap;\n-use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n+fn bad_foo<T: Clone + Clone + Clone + Copy, U: Clone + Copy>(arg0: T, argo1: U) {\n+    unimplemented!();\n+}\n \n-fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n+fn bad_bar<T, U>(arg0: T, arg1: U)\n where\n-    T: Clone,\n-    T: Default,\n+    T: Clone + Clone + Clone + Copy,\n+    U: Clone + Copy,\n {\n     unimplemented!();\n }\n \n-fn good_bar<T: Clone + Default>(arg: T) {\n+fn good_bar<T: Clone + Copy, U: Clone + Copy>(arg0: T, arg1: U) {\n     unimplemented!();\n }\n \n-fn good_foo<T>(arg: T)\n+fn good_foo<T, U>(arg0: T, arg1: U)\n where\n-    T: Clone + Default,\n+    T: Clone + Copy,\n+    U: Clone + Copy,\n {\n     unimplemented!();\n }\n \n-fn good_foobar<T: Default>(arg: T)\n-where\n-    T: Clone,\n-{\n-    unimplemented!();\n+trait GoodSelfTraitBound: Clone + Copy {\n+    fn f();\n }\n \n-trait T: Default {\n+trait GoodSelfWhereClause {\n     fn f()\n     where\n-        Self: Default;\n+        Self: Clone + Copy;\n }\n \n-trait U: Default {\n+trait BadSelfTraitBound: Clone + Clone + Clone {\n+    fn f();\n+}\n+\n+trait BadSelfWhereClause {\n     fn f()\n     where\n-        Self: Clone;\n+        Self: Clone + Clone + Clone;\n+}\n+\n+trait GoodTraitBound<T: Clone + Copy, U: Clone + Copy> {\n+    fn f();\n }\n \n-trait ZZ: Default {\n-    fn g();\n-    fn h();\n+trait GoodWhereClause<T, U> {\n     fn f()\n     where\n-        Self: Default + Clone;\n+        T: Clone + Copy,\n+        U: Clone + Copy;\n }\n \n-trait BadTrait: Default + Clone {\n+trait BadTraitBound<T: Clone + Clone + Clone + Copy, U: Clone + Copy> {\n+    fn f();\n+}\n+\n+trait BadWhereClause<T, U> {\n     fn f()\n     where\n-        Self: Default + Clone;\n-    fn g()\n-    where\n-        Self: Default;\n-    fn h()\n-    where\n-        Self: Copy;\n+        T: Clone + Clone + Clone + Copy,\n+        U: Clone + Copy;\n }\n \n-#[derive(Default, Clone)]\n-struct Life;\n+struct GoodStructBound<T: Clone + Copy, U: Clone + Copy> {\n+    t: T,\n+    u: U,\n+}\n \n-impl T for Life {\n+impl<T: Clone + Copy, U: Clone + Copy> GoodTraitBound<T, U> for GoodStructBound<T, U> {\n     // this should not warn\n     fn f() {}\n }\n \n-impl U for Life {\n+struct GoodStructWhereClause;\n+\n+impl<T, U> GoodTraitBound<T, U> for GoodStructWhereClause\n+where\n+    T: Clone + Copy,\n+    U: Clone + Copy,\n+{\n     // this should not warn\n     fn f() {}\n }\n \n-// should not warn\n-trait Iter: Iterator {\n-    fn into_group_btreemap<K, V>(self) -> BTreeMap<K, Vec<V>>\n-    where\n-        Self: Iterator<Item = (K, V)> + Sized,\n-        K: Ord + Eq,\n-    {\n-        unimplemented!();\n-    }\n-}\n+fn no_error_separate_arg_bounds(program: impl AsRef<()>, dir: impl AsRef<()>, args: &[impl AsRef<()>]) {}\n \n-struct Foo;\n+trait GenericTrait<T> {}\n \n-trait FooIter: Iterator<Item = Foo> {\n-    fn bar()\n-    where\n-        Self: Iterator<Item = Foo>,\n-    {\n-    }\n+fn good_generic<T: GenericTrait<u64> + GenericTrait<u32>>(arg0: T) {\n+    unimplemented!();\n }\n \n-// This should not lint\n-fn impl_trait(_: impl AsRef<str>, _: impl AsRef<str>) {}\n-\n-mod repeated_where_clauses_or_trait_bounds {\n-    fn bad_foo<T: Clone + Clone + Clone + Copy, U: Clone + Copy>(arg0: T, argo1: U) {\n-        unimplemented!();\n-    }\n-\n-    fn bad_bar<T, U>(arg0: T, arg1: U)\n-    where\n-        T: Clone + Clone + Clone + Copy,\n-        U: Clone + Copy,\n-    {\n-        unimplemented!();\n-    }\n-\n-    fn good_bar<T: Clone + Copy, U: Clone + Copy>(arg0: T, arg1: U) {\n-        unimplemented!();\n-    }\n-\n-    fn good_foo<T, U>(arg0: T, arg1: U)\n-    where\n-        T: Clone + Copy,\n-        U: Clone + Copy,\n-    {\n-        unimplemented!();\n-    }\n-\n-    trait GoodSelfTraitBound: Clone + Copy {\n-        fn f();\n-    }\n-\n-    trait GoodSelfWhereClause {\n-        fn f()\n-        where\n-            Self: Clone + Copy;\n-    }\n-\n-    trait BadSelfTraitBound: Clone + Clone + Clone {\n-        fn f();\n-    }\n-\n-    trait BadSelfWhereClause {\n-        fn f()\n-        where\n-            Self: Clone + Clone + Clone;\n-    }\n-\n-    trait GoodTraitBound<T: Clone + Copy, U: Clone + Copy> {\n-        fn f();\n-    }\n-\n-    trait GoodWhereClause<T, U> {\n-        fn f()\n-        where\n-            T: Clone + Copy,\n-            U: Clone + Copy;\n-    }\n-\n-    trait BadTraitBound<T: Clone + Clone + Clone + Copy, U: Clone + Copy> {\n-        fn f();\n-    }\n-\n-    trait BadWhereClause<T, U> {\n-        fn f()\n-        where\n-            T: Clone + Clone + Clone + Copy,\n-            U: Clone + Copy;\n-    }\n-\n-    struct GoodStructBound<T: Clone + Copy, U: Clone + Copy> {\n-        t: T,\n-        u: U,\n-    }\n-\n-    impl<T: Clone + Copy, U: Clone + Copy> GoodTraitBound<T, U> for GoodStructBound<T, U> {\n-        // this should not warn\n-        fn f() {}\n-    }\n-\n-    struct GoodStructWhereClause;\n-\n-    impl<T, U> GoodTraitBound<T, U> for GoodStructWhereClause\n-    where\n-        T: Clone + Copy,\n-        U: Clone + Copy,\n-    {\n-        // this should not warn\n-        fn f() {}\n-    }\n-\n-    fn no_error_separate_arg_bounds(program: impl AsRef<()>, dir: impl AsRef<()>, args: &[impl AsRef<()>]) {}\n-\n-    trait GenericTrait<T> {}\n-\n-    // This should not warn but currently does see #8757\n-    fn good_generic<T: GenericTrait<u64> + GenericTrait<u32>>(arg0: T) {\n-        unimplemented!();\n-    }\n-\n-    fn bad_generic<T: GenericTrait<u64> + GenericTrait<u32> + GenericTrait<u64>>(arg0: T) {\n-        unimplemented!();\n-    }\n+fn bad_generic<T: GenericTrait<u64> + GenericTrait<u32> + GenericTrait<u64>>(arg0: T) {\n+    unimplemented!();\n+}\n \n-    mod foo {\n-        pub trait Clone {}\n-    }\n+mod foo {\n+    pub trait Clone {}\n+}\n \n-    fn qualified_path<T: std::clone::Clone + Clone + foo::Clone>(arg0: T) {\n-        unimplemented!();\n-    }\n+fn qualified_path<T: std::clone::Clone + Clone + foo::Clone>(arg0: T) {\n+    unimplemented!();\n }\n \n fn main() {}"}, {"sha": "af800ba78880c39ed5e5b936c850e5138f993c59", "filename": "src/tools/clippy/tests/ui/trait_duplication_in_bounds.stderr", "status": "modified", "additions": 27, "deletions": 138, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,167 +1,56 @@\n-error: this trait bound is already specified in the where clause\n-  --> $DIR/trait_duplication_in_bounds.rs:7:15\n+error: these bounds contain repeated elements\n+  --> $DIR/trait_duplication_in_bounds.rs:5:15\n    |\n-LL | fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n-   |               ^^^^^\n+LL | fn bad_foo<T: Clone + Clone + Clone + Copy, U: Clone + Copy>(arg0: T, argo1: U) {\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone + Copy`\n    |\n note: the lint level is defined here\n-  --> $DIR/trait_duplication_in_bounds.rs:1:9\n+  --> $DIR/trait_duplication_in_bounds.rs:2:9\n    |\n LL | #![deny(clippy::trait_duplication_in_bounds)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = help: consider removing this trait bound\n-\n-error: this trait bound is already specified in the where clause\n-  --> $DIR/trait_duplication_in_bounds.rs:7:23\n-   |\n-LL | fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n-   |                       ^^^^^^^\n-   |\n-   = help: consider removing this trait bound\n-\n-error: this trait bound is already specified in trait declaration\n-  --> $DIR/trait_duplication_in_bounds.rs:36:15\n-   |\n-LL |         Self: Default;\n-   |               ^^^^^^^\n-   |\n-   = help: consider removing this trait bound\n-\n-error: this trait bound is already specified in trait declaration\n-  --> $DIR/trait_duplication_in_bounds.rs:50:15\n-   |\n-LL |         Self: Default + Clone;\n-   |               ^^^^^^^\n-   |\n-   = help: consider removing this trait bound\n-\n-error: this trait bound is already specified in trait declaration\n-  --> $DIR/trait_duplication_in_bounds.rs:56:15\n-   |\n-LL |         Self: Default + Clone;\n-   |               ^^^^^^^\n-   |\n-   = help: consider removing this trait bound\n-\n-error: this trait bound is already specified in trait declaration\n-  --> $DIR/trait_duplication_in_bounds.rs:56:25\n-   |\n-LL |         Self: Default + Clone;\n-   |                         ^^^^^\n-   |\n-   = help: consider removing this trait bound\n-\n-error: this trait bound is already specified in trait declaration\n-  --> $DIR/trait_duplication_in_bounds.rs:59:15\n-   |\n-LL |         Self: Default;\n-   |               ^^^^^^^\n-   |\n-   = help: consider removing this trait bound\n-\n-error: this trait bound is already specified in trait declaration\n-  --> $DIR/trait_duplication_in_bounds.rs:94:15\n-   |\n-LL |         Self: Iterator<Item = Foo>,\n-   |               ^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider removing this trait bound\n-\n-error: this trait bound is already specified in the where clause\n-  --> $DIR/trait_duplication_in_bounds.rs:103:19\n-   |\n-LL |     fn bad_foo<T: Clone + Clone + Clone + Copy, U: Clone + Copy>(arg0: T, argo1: U) {\n-   |                   ^^^^^\n-   |\n-   = help: consider removing this trait bound\n-\n-error: these bounds contain repeated elements\n-  --> $DIR/trait_duplication_in_bounds.rs:103:19\n-   |\n-LL |     fn bad_foo<T: Clone + Clone + Clone + Copy, U: Clone + Copy>(arg0: T, argo1: U) {\n-   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone + Copy`\n-\n-error: this trait bound is already specified in the where clause\n-  --> $DIR/trait_duplication_in_bounds.rs:109:12\n-   |\n-LL |         T: Clone + Clone + Clone + Copy,\n-   |            ^^^^^\n-   |\n-   = help: consider removing this trait bound\n \n error: these where clauses contain repeated elements\n-  --> $DIR/trait_duplication_in_bounds.rs:109:12\n+  --> $DIR/trait_duplication_in_bounds.rs:11:8\n    |\n-LL |         T: Clone + Clone + Clone + Copy,\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone + Copy`\n+LL |     T: Clone + Clone + Clone + Copy,\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone + Copy`\n \n error: these bounds contain repeated elements\n-  --> $DIR/trait_duplication_in_bounds.rs:137:30\n+  --> $DIR/trait_duplication_in_bounds.rs:39:26\n    |\n-LL |     trait BadSelfTraitBound: Clone + Clone + Clone {\n-   |                              ^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone`\n+LL | trait BadSelfTraitBound: Clone + Clone + Clone {\n+   |                          ^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone`\n \n error: these where clauses contain repeated elements\n-  --> $DIR/trait_duplication_in_bounds.rs:144:19\n-   |\n-LL |             Self: Clone + Clone + Clone;\n-   |                   ^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone`\n-\n-error: this trait bound is already specified in the where clause\n-  --> $DIR/trait_duplication_in_bounds.rs:158:28\n+  --> $DIR/trait_duplication_in_bounds.rs:46:15\n    |\n-LL |     trait BadTraitBound<T: Clone + Clone + Clone + Copy, U: Clone + Copy> {\n-   |                            ^^^^^\n-   |\n-   = help: consider removing this trait bound\n+LL |         Self: Clone + Clone + Clone;\n+   |               ^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone`\n \n error: these bounds contain repeated elements\n-  --> $DIR/trait_duplication_in_bounds.rs:158:28\n+  --> $DIR/trait_duplication_in_bounds.rs:60:24\n    |\n-LL |     trait BadTraitBound<T: Clone + Clone + Clone + Copy, U: Clone + Copy> {\n-   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone + Copy`\n+LL | trait BadTraitBound<T: Clone + Clone + Clone + Copy, U: Clone + Copy> {\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone + Copy`\n \n error: these where clauses contain repeated elements\n-  --> $DIR/trait_duplication_in_bounds.rs:165:16\n-   |\n-LL |             T: Clone + Clone + Clone + Copy,\n-   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone + Copy`\n-\n-error: this trait bound is already specified in the where clause\n-  --> $DIR/trait_duplication_in_bounds.rs:195:24\n-   |\n-LL |     fn good_generic<T: GenericTrait<u64> + GenericTrait<u32>>(arg0: T) {\n-   |                        ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider removing this trait bound\n-\n-error: this trait bound is already specified in the where clause\n-  --> $DIR/trait_duplication_in_bounds.rs:199:23\n+  --> $DIR/trait_duplication_in_bounds.rs:67:12\n    |\n-LL |     fn bad_generic<T: GenericTrait<u64> + GenericTrait<u32> + GenericTrait<u64>>(arg0: T) {\n-   |                       ^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider removing this trait bound\n+LL |         T: Clone + Clone + Clone + Copy,\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone + Copy`\n \n error: these bounds contain repeated elements\n-  --> $DIR/trait_duplication_in_bounds.rs:199:23\n-   |\n-LL |     fn bad_generic<T: GenericTrait<u64> + GenericTrait<u32> + GenericTrait<u64>>(arg0: T) {\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `GenericTrait<u32> + GenericTrait<u64>`\n-\n-error: this trait bound is already specified in the where clause\n-  --> $DIR/trait_duplication_in_bounds.rs:207:26\n-   |\n-LL |     fn qualified_path<T: std::clone::Clone + Clone + foo::Clone>(arg0: T) {\n-   |                          ^^^^^^^^^^^^^^^^^\n+  --> $DIR/trait_duplication_in_bounds.rs:100:19\n    |\n-   = help: consider removing this trait bound\n+LL | fn bad_generic<T: GenericTrait<u64> + GenericTrait<u32> + GenericTrait<u64>>(arg0: T) {\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `GenericTrait<u64> + GenericTrait<u32>`\n \n error: these bounds contain repeated elements\n-  --> $DIR/trait_duplication_in_bounds.rs:207:26\n+  --> $DIR/trait_duplication_in_bounds.rs:108:22\n    |\n-LL |     fn qualified_path<T: std::clone::Clone + Clone + foo::Clone>(arg0: T) {\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone + foo::Clone`\n+LL | fn qualified_path<T: std::clone::Clone + Clone + foo::Clone>(arg0: T) {\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `std::clone::Clone + foo::Clone`\n \n-error: aborting due to 22 previous errors\n+error: aborting due to 8 previous errors\n "}, {"sha": "5630a0345adb1278492d6f44e2c3b8923df9fbaa", "filename": "src/tools/clippy/tests/ui/trait_duplication_in_bounds_unfixable.rs", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds_unfixable.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,166 @@\n+#![deny(clippy::trait_duplication_in_bounds)]\n+\n+use std::collections::BTreeMap;\n+use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n+\n+fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n+where\n+    T: Clone,\n+    T: Default,\n+{\n+    unimplemented!();\n+}\n+\n+fn good_bar<T: Clone + Default>(arg: T) {\n+    unimplemented!();\n+}\n+\n+fn good_foo<T>(arg: T)\n+where\n+    T: Clone + Default,\n+{\n+    unimplemented!();\n+}\n+\n+fn good_foobar<T: Default>(arg: T)\n+where\n+    T: Clone,\n+{\n+    unimplemented!();\n+}\n+\n+trait T: Default {\n+    fn f()\n+    where\n+        Self: Default;\n+}\n+\n+trait U: Default {\n+    fn f()\n+    where\n+        Self: Clone;\n+}\n+\n+trait ZZ: Default {\n+    fn g();\n+    fn h();\n+    fn f()\n+    where\n+        Self: Default + Clone;\n+}\n+\n+trait BadTrait: Default + Clone {\n+    fn f()\n+    where\n+        Self: Default + Clone;\n+    fn g()\n+    where\n+        Self: Default;\n+    fn h()\n+    where\n+        Self: Copy;\n+}\n+\n+#[derive(Default, Clone)]\n+struct Life;\n+\n+impl T for Life {\n+    // this should not warn\n+    fn f() {}\n+}\n+\n+impl U for Life {\n+    // this should not warn\n+    fn f() {}\n+}\n+\n+// should not warn\n+trait Iter: Iterator {\n+    fn into_group_btreemap<K, V>(self) -> BTreeMap<K, Vec<V>>\n+    where\n+        Self: Iterator<Item = (K, V)> + Sized,\n+        K: Ord + Eq,\n+    {\n+        unimplemented!();\n+    }\n+}\n+\n+struct Foo;\n+\n+trait FooIter: Iterator<Item = Foo> {\n+    fn bar()\n+    where\n+        Self: Iterator<Item = Foo>,\n+    {\n+    }\n+}\n+\n+// The below should not lint and exist to guard against false positives\n+fn impl_trait(_: impl AsRef<str>, _: impl AsRef<str>) {}\n+\n+pub mod one {\n+    #[derive(Clone, Debug)]\n+    struct MultiProductIter<I>\n+    where\n+        I: Iterator + Clone,\n+        I::Item: Clone,\n+    {\n+        _marker: I,\n+    }\n+\n+    pub struct MultiProduct<I>(Vec<MultiProductIter<I>>)\n+    where\n+        I: Iterator + Clone,\n+        I::Item: Clone;\n+\n+    pub fn multi_cartesian_product<H>(_: H) -> MultiProduct<<H::Item as IntoIterator>::IntoIter>\n+    where\n+        H: Iterator,\n+        H::Item: IntoIterator,\n+        <H::Item as IntoIterator>::IntoIter: Clone,\n+        <H::Item as IntoIterator>::Item: Clone,\n+    {\n+        todo!()\n+    }\n+}\n+\n+pub mod two {\n+    use std::iter::Peekable;\n+\n+    pub struct MergeBy<I, J, F>\n+    where\n+        I: Iterator,\n+        J: Iterator<Item = I::Item>,\n+    {\n+        _i: Peekable<I>,\n+        _j: Peekable<J>,\n+        _f: F,\n+    }\n+\n+    impl<I, J, F> Clone for MergeBy<I, J, F>\n+    where\n+        I: Iterator,\n+        J: Iterator<Item = I::Item>,\n+        std::iter::Peekable<I>: Clone,\n+        std::iter::Peekable<J>: Clone,\n+        F: Clone,\n+    {\n+        fn clone(&self) -> Self {\n+            Self {\n+                _i: self._i.clone(),\n+                _j: self._j.clone(),\n+                _f: self._f.clone(),\n+            }\n+        }\n+    }\n+}\n+\n+pub trait Trait {}\n+\n+pub fn f(_a: impl Trait, _b: impl Trait) {}\n+\n+pub trait ImplTrait<T> {}\n+\n+impl<A, B> ImplTrait<(A, B)> for Foo where Foo: ImplTrait<A> + ImplTrait<B> {}\n+\n+fn main() {}"}, {"sha": "fbd9abb005f1f1fdf069c3c96691c12964ff5d24", "filename": "src/tools/clippy/tests/ui/trait_duplication_in_bounds_unfixable.stderr", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds_unfixable.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,71 @@\n+error: this trait bound is already specified in the where clause\n+  --> $DIR/trait_duplication_in_bounds_unfixable.rs:6:15\n+   |\n+LL | fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n+   |               ^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/trait_duplication_in_bounds_unfixable.rs:1:9\n+   |\n+LL | #![deny(clippy::trait_duplication_in_bounds)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: consider removing this trait bound\n+\n+error: this trait bound is already specified in the where clause\n+  --> $DIR/trait_duplication_in_bounds_unfixable.rs:6:23\n+   |\n+LL | fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n+   |                       ^^^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: this trait bound is already specified in trait declaration\n+  --> $DIR/trait_duplication_in_bounds_unfixable.rs:35:15\n+   |\n+LL |         Self: Default;\n+   |               ^^^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: this trait bound is already specified in trait declaration\n+  --> $DIR/trait_duplication_in_bounds_unfixable.rs:49:15\n+   |\n+LL |         Self: Default + Clone;\n+   |               ^^^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: this trait bound is already specified in trait declaration\n+  --> $DIR/trait_duplication_in_bounds_unfixable.rs:55:15\n+   |\n+LL |         Self: Default + Clone;\n+   |               ^^^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: this trait bound is already specified in trait declaration\n+  --> $DIR/trait_duplication_in_bounds_unfixable.rs:55:25\n+   |\n+LL |         Self: Default + Clone;\n+   |                         ^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: this trait bound is already specified in trait declaration\n+  --> $DIR/trait_duplication_in_bounds_unfixable.rs:58:15\n+   |\n+LL |         Self: Default;\n+   |               ^^^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: this trait bound is already specified in trait declaration\n+  --> $DIR/trait_duplication_in_bounds_unfixable.rs:93:15\n+   |\n+LL |         Self: Iterator<Item = Foo>,\n+   |               ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "5aad0b44270a3cc5b9e72a5dd1405e9d52fee5e7", "filename": "src/tools/clippy/tests/ui/transmute_undefined_repr.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_undefined_repr.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -4,6 +4,7 @@\n use core::any::TypeId;\n use core::ffi::c_void;\n use core::mem::{size_of, transmute, MaybeUninit};\n+use core::ptr::NonNull;\n \n fn value<T>() -> T {\n     unimplemented!()\n@@ -109,6 +110,17 @@ fn main() {\n         let _: Ty2<u32, u32> = transmute(value::<MaybeUninit<Ty2<u32, u32>>>()); // Ok\n \n         let _: Ty<&[u32]> = transmute::<&[u32], _>(value::<&Vec<u32>>()); // Ok\n+\n+        let _: *const Ty2<u32, u32> = transmute(value::<*const Ty2C<Ty2<u32, u32>, u32>>()); // Ok\n+        let _: *const Ty2C<Ty2<u32, u32>, u32> = transmute(value::<*const Ty2<u32, u32>>()); // Ok\n+        let _: *const Ty2<u32, u32> = transmute(value::<*const Ty2C<(), Ty2<u32, u32>>>()); // Ok\n+        let _: *const Ty2C<(), Ty2<u32, u32>> = transmute(value::<*const Ty2<u32, u32>>()); // Ok\n+\n+        let _: *const Ty2<u32, u32> = transmute(value::<*const Ty2C<u32, Ty2<u32, u32>>>()); // Err\n+        let _: *const Ty2C<u32, Ty2<u32, u32>> = transmute(value::<*const Ty2<u32, u32>>()); // Err\n+\n+        let _: NonNull<u8> = transmute(value::<NonNull<(String, String)>>()); // Ok\n+        let _: NonNull<(String, String)> = transmute(value::<NonNull<u8>>()); // Ok\n     }\n }\n "}, {"sha": "e50a773290e17c60fe6a5bc839e0d009fe821650", "filename": "src/tools/clippy/tests/ui/transmute_undefined_repr.stderr", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_undefined_repr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_undefined_repr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_undefined_repr.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,80 +1,96 @@\n error: transmute from `Ty2<u32, i32>` which has an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:27:33\n+  --> $DIR/transmute_undefined_repr.rs:28:33\n    |\n LL |         let _: Ty2C<u32, i32> = transmute(value::<Ty2<u32, i32>>()); // Lint, Ty2 is unordered\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::transmute-undefined-repr` implied by `-D warnings`\n \n error: transmute into `Ty2<u32, i32>` which has an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:28:32\n+  --> $DIR/transmute_undefined_repr.rs:29:32\n    |\n LL |         let _: Ty2<u32, i32> = transmute(value::<Ty2C<u32, i32>>()); // Lint, Ty2 is unordered\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from `Ty<Ty2<u32, i32>>` to `Ty2<u32, f32>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:33:32\n+  --> $DIR/transmute_undefined_repr.rs:34:32\n    |\n LL |         let _: Ty2<u32, f32> = transmute(value::<Ty<Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n error: transmute from `Ty2<u32, f32>` to `Ty<Ty2<u32, i32>>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:34:36\n+  --> $DIR/transmute_undefined_repr.rs:35:36\n    |\n LL |         let _: Ty<Ty2<u32, i32>> = transmute(value::<Ty2<u32, f32>>()); // Lint, different Ty2 instances\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n error: transmute from `Ty<&Ty2<u32, i32>>` to `&Ty2<u32, f32>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:39:33\n+  --> $DIR/transmute_undefined_repr.rs:40:33\n    |\n LL |         let _: &Ty2<u32, f32> = transmute(value::<Ty<&Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n error: transmute from `&Ty2<u32, f32>` to `Ty<&Ty2<u32, i32>>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:40:37\n+  --> $DIR/transmute_undefined_repr.rs:41:37\n    |\n LL |         let _: Ty<&Ty2<u32, i32>> = transmute(value::<&Ty2<u32, f32>>()); // Lint, different Ty2 instances\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n error: transmute from `std::boxed::Box<Ty2<u32, u32>>` to `&mut Ty2<u32, f32>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:57:45\n+  --> $DIR/transmute_undefined_repr.rs:58:45\n    |\n LL |         let _: &'static mut Ty2<u32, f32> = transmute(value::<Box<Ty2<u32, u32>>>()); // Lint, different Ty2 instances\n    |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n error: transmute from `&mut Ty2<u32, f32>` to `std::boxed::Box<Ty2<u32, u32>>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:58:37\n+  --> $DIR/transmute_undefined_repr.rs:59:37\n    |\n LL |         let _: Box<Ty2<u32, u32>> = transmute(value::<&'static mut Ty2<u32, f32>>()); // Lint, different Ty2 instances\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n+error: transmute into `*const Ty2<u32, u32>` which has an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:119:39\n+   |\n+LL |         let _: *const Ty2<u32, u32> = transmute(value::<*const Ty2C<u32, Ty2<u32, u32>>>()); // Err\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the contained type `Ty2<u32, u32>` has an undefined layout\n+\n+error: transmute from `*const Ty2<u32, u32>` which has an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:120:50\n+   |\n+LL |         let _: *const Ty2C<u32, Ty2<u32, u32>> = transmute(value::<*const Ty2<u32, u32>>()); // Err\n+   |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the contained type `Ty2<u32, u32>` has an undefined layout\n+\n error: transmute from `std::vec::Vec<Ty2<U, i32>>` to `std::vec::Vec<Ty2<T, u32>>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:138:35\n+  --> $DIR/transmute_undefined_repr.rs:150:35\n    |\n LL |         let _: Vec<Ty2<T, u32>> = transmute(value::<Vec<Ty2<U, i32>>>()); // Err\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Vec`) may have different layouts\n \n error: transmute from `std::vec::Vec<Ty2<T, u32>>` to `std::vec::Vec<Ty2<U, i32>>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:139:35\n+  --> $DIR/transmute_undefined_repr.rs:151:35\n    |\n LL |         let _: Vec<Ty2<U, i32>> = transmute(value::<Vec<Ty2<T, u32>>>()); // Err\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Vec`) may have different layouts\n \n-error: aborting due to 10 previous errors\n+error: aborting due to 12 previous errors\n "}, {"sha": "94b4723452fada45a142dcd5dc7992e028ae8b60", "filename": "src/tools/clippy/tests/ui/unicode.fixed", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funicode.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funicode.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funicode.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,4 +1,7 @@\n // run-rustfix\n+// compile-flags: --test\n+#![allow(dead_code)]\n+\n #[warn(clippy::invisible_characters)]\n fn zero() {\n     print!(\"Here >\\u{200B}< is a ZWS, and \\u{200B}another\");\n@@ -15,22 +18,43 @@ fn canon() {\n     print!(\"a\\u{0300}h?\"); // also ok\n }\n \n-#[warn(clippy::non_ascii_literal)]\n-fn uni() {\n-    print!(\"\\u{dc}ben!\");\n-    print!(\"\\u{DC}ben!\"); // this is ok\n-}\n+mod non_ascii_literal {\n+    #![deny(clippy::non_ascii_literal)]\n+\n+    fn uni() {\n+        print!(\"\\u{dc}ben!\");\n+        print!(\"\\u{DC}ben!\"); // this is ok\n+    }\n+\n+    // issue 8013\n+    fn single_quote() {\n+        const _EMPTY_BLOCK: char = '\\u{25b1}';\n+        const _FULL_BLOCK: char = '\\u{25b0}';\n+    }\n+\n+    #[test]\n+    pub fn issue_7739() {\n+        // Ry\u016b crate: https://github.com/dtolnay/ryu\n+    }\n+\n+    mod issue_8263 {\n+        #![deny(clippy::non_ascii_literal)]\n+\n+        // Re-allow for a single test\n+        #[test]\n+        #[allow(clippy::non_ascii_literal)]\n+        fn allowed() {\n+            let _ = \"\u60b2\u3057\u3044\u304b\u306a\u3001\u3053\u3053\u306b\u65e5\u672c\u8a9e\u3092\u66f8\u304f\u3053\u3068\u306f\u3067\u304d\u306a\u3044\u3002\";\n+        }\n \n-// issue 8013\n-#[warn(clippy::non_ascii_literal)]\n-fn single_quote() {\n-    const _EMPTY_BLOCK: char = '\\u{25b1}';\n-    const _FULL_BLOCK: char = '\\u{25b0}';\n+        #[test]\n+        fn denied() {\n+            let _ = \"\\u{60b2}\\u{3057}\\u{3044}\\u{304b}\\u{306a}\\u{3001}\\u{3053}\\u{3053}\\u{306b}\\u{65e5}\\u{672c}\\u{8a9e}\\u{3092}\\u{66f8}\\u{304f}\\u{3053}\\u{3068}\\u{306f}\\u{3067}\\u{304d}\\u{306a}\\u{3044}\\u{3002}\";\n+        }\n+    }\n }\n \n fn main() {\n     zero();\n-    uni();\n     canon();\n-    single_quote();\n }"}, {"sha": "6ad0b255b94856c96943f0af5d329db3f7d46f8e", "filename": "src/tools/clippy/tests/ui/unicode.rs", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funicode.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,4 +1,7 @@\n // run-rustfix\n+// compile-flags: --test\n+#![allow(dead_code)]\n+\n #[warn(clippy::invisible_characters)]\n fn zero() {\n     print!(\"Here >\u200b< is a ZWS, and \u200banother\");\n@@ -15,22 +18,43 @@ fn canon() {\n     print!(\"a\\u{0300}h?\"); // also ok\n }\n \n-#[warn(clippy::non_ascii_literal)]\n-fn uni() {\n-    print!(\"\u00dcben!\");\n-    print!(\"\\u{DC}ben!\"); // this is ok\n-}\n+mod non_ascii_literal {\n+    #![deny(clippy::non_ascii_literal)]\n+\n+    fn uni() {\n+        print!(\"\u00dcben!\");\n+        print!(\"\\u{DC}ben!\"); // this is ok\n+    }\n+\n+    // issue 8013\n+    fn single_quote() {\n+        const _EMPTY_BLOCK: char = '\u25b1';\n+        const _FULL_BLOCK: char = '\u25b0';\n+    }\n+\n+    #[test]\n+    pub fn issue_7739() {\n+        // Ry\u016b crate: https://github.com/dtolnay/ryu\n+    }\n+\n+    mod issue_8263 {\n+        #![deny(clippy::non_ascii_literal)]\n+\n+        // Re-allow for a single test\n+        #[test]\n+        #[allow(clippy::non_ascii_literal)]\n+        fn allowed() {\n+            let _ = \"\u60b2\u3057\u3044\u304b\u306a\u3001\u3053\u3053\u306b\u65e5\u672c\u8a9e\u3092\u66f8\u304f\u3053\u3068\u306f\u3067\u304d\u306a\u3044\u3002\";\n+        }\n \n-// issue 8013\n-#[warn(clippy::non_ascii_literal)]\n-fn single_quote() {\n-    const _EMPTY_BLOCK: char = '\u25b1';\n-    const _FULL_BLOCK: char = '\u25b0';\n+        #[test]\n+        fn denied() {\n+            let _ = \"\u60b2\u3057\u3044\u304b\u306a\u3001\u3053\u3053\u306b\u65e5\u672c\u8a9e\u3092\u66f8\u304f\u3053\u3068\u306f\u3067\u304d\u306a\u3044\u3002\";\n+        }\n+    }\n }\n \n fn main() {\n     zero();\n-    uni();\n     canon();\n-    single_quote();\n }"}, {"sha": "ea74a81451e3a9c3157bd99d3819c1690d602266", "filename": "src/tools/clippy/tests/ui/unicode.stderr", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funicode.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funicode.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funicode.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,50 +1,66 @@\n error: invisible character detected\n-  --> $DIR/unicode.rs:4:12\n+  --> $DIR/unicode.rs:7:12\n    |\n LL |     print!(\"Here >\u200b< is a ZWS, and \u200banother\");\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider replacing the string with: `\"Here >/u{200B}< is a ZWS, and /u{200B}another\"`\n    |\n    = note: `-D clippy::invisible-characters` implied by `-D warnings`\n \n error: invisible character detected\n-  --> $DIR/unicode.rs:6:12\n+  --> $DIR/unicode.rs:9:12\n    |\n LL |     print!(\"Here >\u00ad< is a SHY, and \u00adanother\");\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider replacing the string with: `\"Here >/u{AD}< is a SHY, and /u{AD}another\"`\n \n error: invisible character detected\n-  --> $DIR/unicode.rs:8:12\n+  --> $DIR/unicode.rs:11:12\n    |\n LL |     print!(\"Here >\u2060< is a WJ, and \u2060another\");\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider replacing the string with: `\"Here >/u{2060}< is a WJ, and /u{2060}another\"`\n \n error: non-NFC Unicode sequence detected\n-  --> $DIR/unicode.rs:14:12\n+  --> $DIR/unicode.rs:17:12\n    |\n LL |     print!(\"\u0300a\u0300h?\");\n    |            ^^^^^ help: consider replacing the string with: `\"\u0300\u00e0h?\"`\n    |\n    = note: `-D clippy::unicode-not-nfc` implied by `-D warnings`\n \n error: literal non-ASCII character detected\n-  --> $DIR/unicode.rs:20:12\n+  --> $DIR/unicode.rs:25:16\n    |\n-LL |     print!(\"\u00dcben!\");\n-   |            ^^^^^^^ help: consider replacing the string with: `\"/u{dc}ben!\"`\n+LL |         print!(\"\u00dcben!\");\n+   |                ^^^^^^^ help: consider replacing the string with: `\"/u{dc}ben!\"`\n    |\n-   = note: `-D clippy::non-ascii-literal` implied by `-D warnings`\n+note: the lint level is defined here\n+  --> $DIR/unicode.rs:22:13\n+   |\n+LL |     #![deny(clippy::non_ascii_literal)]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: literal non-ASCII character detected\n+  --> $DIR/unicode.rs:31:36\n+   |\n+LL |         const _EMPTY_BLOCK: char = '\u25b1';\n+   |                                    ^^^ help: consider replacing the string with: `'/u{25b1}'`\n \n error: literal non-ASCII character detected\n-  --> $DIR/unicode.rs:27:32\n+  --> $DIR/unicode.rs:32:35\n    |\n-LL |     const _EMPTY_BLOCK: char = '\u25b1';\n-   |                                ^^^ help: consider replacing the string with: `'/u{25b1}'`\n+LL |         const _FULL_BLOCK: char = '\u25b0';\n+   |                                   ^^^ help: consider replacing the string with: `'/u{25b0}'`\n \n error: literal non-ASCII character detected\n-  --> $DIR/unicode.rs:28:31\n+  --> $DIR/unicode.rs:52:21\n+   |\n+LL |             let _ = \"\u60b2\u3057\u3044\u304b\u306a\u3001\u3053\u3053\u306b\u65e5\u672c\u8a9e\u3092\u66f8\u304f\u3053\u3068\u306f\u3067\u304d\u306a\u3044\u3002\";\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider replacing the string with: `\"/u{60b2}/u{3057}/u{3044}/u{304b}/u{306a}/u{3001}/u{3053}/u{3053}/u{306b}/u{65e5}/u{672c}/u{8a9e}/u{3092}/u{66f8}/u{304f}/u{3053}/u{3068}/u{306f}/u{3067}/u{304d}/u{306a}/u{3044}/u{3002}\"`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unicode.rs:41:17\n    |\n-LL |     const _FULL_BLOCK: char = '\u25b0';\n-   |                               ^^^ help: consider replacing the string with: `'/u{25b0}'`\n+LL |         #![deny(clippy::non_ascii_literal)]\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 8 previous errors\n "}, {"sha": "ee9f157342d48f835a39883ffa3736e9f9a30885", "filename": "src/tools/clippy/tests/ui/unnecessary_cast.fixed", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -88,4 +88,13 @@ mod fixable {\n     }\n \n     type I32Alias = i32;\n+\n+    fn issue_9380() {\n+        let _: i32 = -1_i32;\n+        let _: f32 = -(1) as f32;\n+        let _: i64 = -1_i64;\n+        let _: i64 = -(1.0) as i64;\n+\n+        let _ = -(1 + 1) as i64;\n+    }\n }"}, {"sha": "5b70412424c06f602e02d3ecf02025f5f7b59dc7", "filename": "src/tools/clippy/tests/ui/unnecessary_cast.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -88,4 +88,13 @@ mod fixable {\n     }\n \n     type I32Alias = i32;\n+\n+    fn issue_9380() {\n+        let _: i32 = -(1) as i32;\n+        let _: f32 = -(1) as f32;\n+        let _: i64 = -(1) as i64;\n+        let _: i64 = -(1.0) as i64;\n+\n+        let _ = -(1 + 1) as i64;\n+    }\n }"}, {"sha": "f7829ff3b0efd049d72f7619bcdeb6e7708b1d8d", "filename": "src/tools/clippy/tests/ui/unnecessary_cast.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -150,5 +150,17 @@ error: casting float literal to `f32` is unnecessary\n LL |         let _ = -1.0 as f32;\n    |                 ^^^^^^^^^^^ help: try: `-1.0_f32`\n \n-error: aborting due to 25 previous errors\n+error: casting integer literal to `i32` is unnecessary\n+  --> $DIR/unnecessary_cast.rs:93:22\n+   |\n+LL |         let _: i32 = -(1) as i32;\n+   |                      ^^^^^^^^^^^ help: try: `-1_i32`\n+\n+error: casting integer literal to `i64` is unnecessary\n+  --> $DIR/unnecessary_cast.rs:95:22\n+   |\n+LL |         let _: i64 = -(1) as i64;\n+   |                      ^^^^^^^^^^^ help: try: `-1_i64`\n+\n+error: aborting due to 27 previous errors\n "}, {"sha": "40052c41039e5d01c320f34743fe48331fc9e81a", "filename": "src/tools/clippy/tests/ui/unnecessary_owned_empty_strings.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_owned_empty_strings.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_owned_empty_strings.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_owned_empty_strings.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -12,6 +12,7 @@ fn main() {\n     ref_str_argument(\"\");\n \n     // should be linted\n+    #[allow(clippy::manual_string_new)]\n     ref_str_argument(\"\");\n \n     // should not be linted"}, {"sha": "2304dff5192b9ee66c34805feab80ab2d55bd62c", "filename": "src/tools/clippy/tests/ui/unnecessary_owned_empty_strings.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_owned_empty_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_owned_empty_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_owned_empty_strings.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -12,6 +12,7 @@ fn main() {\n     ref_str_argument(&String::new());\n \n     // should be linted\n+    #[allow(clippy::manual_string_new)]\n     ref_str_argument(&String::from(\"\"));\n \n     // should not be linted"}, {"sha": "1eb198a8675ea1b2f172667f6f8807d2f624d0fa", "filename": "src/tools/clippy/tests/ui/unnecessary_owned_empty_strings.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_owned_empty_strings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_owned_empty_strings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_owned_empty_strings.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -7,7 +7,7 @@ LL |     ref_str_argument(&String::new());\n    = note: `-D clippy::unnecessary-owned-empty-strings` implied by `-D warnings`\n \n error: usage of `&String::from(\"\")` for a function expecting a `&str` argument\n-  --> $DIR/unnecessary_owned_empty_strings.rs:15:22\n+  --> $DIR/unnecessary_owned_empty_strings.rs:16:22\n    |\n LL |     ref_str_argument(&String::from(\"\"));\n    |                      ^^^^^^^^^^^^^^^^^ help: try: `\"\"`"}, {"sha": "9cd5bc73b1ec51852af3c2bbeae84cb5ddf05594", "filename": "src/tools/clippy/tests/ui/unnecessary_to_owned.fixed", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_to_owned.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_to_owned.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_to_owned.fixed?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -329,3 +329,31 @@ mod issue_8759_variant {\n         rw.set_view(&rw.default_view().to_owned());\n     }\n }\n+\n+mod issue_9317 {\n+    #![allow(dead_code)]\n+\n+    struct Bytes {}\n+\n+    impl ToString for Bytes {\n+        fn to_string(&self) -> String {\n+            \"123\".to_string()\n+        }\n+    }\n+\n+    impl AsRef<[u8]> for Bytes {\n+        fn as_ref(&self) -> &[u8] {\n+            &[1, 2, 3]\n+        }\n+    }\n+\n+    fn consume<C: AsRef<[u8]>>(c: C) {\n+        let _ = c;\n+    }\n+\n+    pub fn main() {\n+        let b = Bytes {};\n+        // Should not lint.\n+        consume(b.to_string());\n+    }\n+}"}, {"sha": "7f62ba3ab5d559ea0d8a60da23f977389044f054", "filename": "src/tools/clippy/tests/ui/unnecessary_to_owned.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_to_owned.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -329,3 +329,31 @@ mod issue_8759_variant {\n         rw.set_view(&rw.default_view().to_owned());\n     }\n }\n+\n+mod issue_9317 {\n+    #![allow(dead_code)]\n+\n+    struct Bytes {}\n+\n+    impl ToString for Bytes {\n+        fn to_string(&self) -> String {\n+            \"123\".to_string()\n+        }\n+    }\n+\n+    impl AsRef<[u8]> for Bytes {\n+        fn as_ref(&self) -> &[u8] {\n+            &[1, 2, 3]\n+        }\n+    }\n+\n+    fn consume<C: AsRef<[u8]>>(c: C) {\n+        let _ = c;\n+    }\n+\n+    pub fn main() {\n+        let b = Bytes {};\n+        // Should not lint.\n+        consume(b.to_string());\n+    }\n+}"}, {"sha": "153457e367165c6ce2fa6d3370a4c81a2645d265", "filename": "src/tools/clippy/tests/ui/unused_peekable.rs", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_peekable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_peekable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_peekable.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,144 @@\n+#![warn(clippy::unused_peekable)]\n+#![allow(clippy::no_effect)]\n+\n+use std::iter::Empty;\n+use std::iter::Peekable;\n+\n+fn main() {\n+    invalid();\n+    valid();\n+}\n+\n+#[allow(clippy::unused_unit)]\n+fn invalid() {\n+    let peekable = std::iter::empty::<u32>().peekable();\n+\n+    // Only lint `new_local`\n+    let old_local = std::iter::empty::<u32>().peekable();\n+    let new_local = old_local;\n+\n+    // Behind mut ref\n+    let mut by_mut_ref_test = std::iter::empty::<u32>().peekable();\n+    let by_mut_ref = &mut by_mut_ref_test;\n+\n+    // Explicitly returns `Peekable`\n+    fn returns_peekable() -> Peekable<Empty<u32>> {\n+        std::iter::empty().peekable()\n+    }\n+\n+    let peekable_from_fn = returns_peekable();\n+\n+    // Using a method not exclusive to `Peekable`\n+    let mut peekable_using_iterator_method = std::iter::empty::<u32>().peekable();\n+    peekable_using_iterator_method.next();\n+\n+    // Passed by ref to another function\n+    fn takes_ref(_peek: &Peekable<Empty<u32>>) {}\n+    let passed_along_ref = std::iter::empty::<u32>().peekable();\n+    takes_ref(&passed_along_ref);\n+\n+    // `by_ref` without `peek`\n+    let mut by_ref_test = std::iter::empty::<u32>().peekable();\n+    let _by_ref = by_ref_test.by_ref();\n+\n+    let mut peekable_in_for_loop = std::iter::empty::<u32>().peekable();\n+    for x in peekable_in_for_loop {}\n+}\n+\n+fn valid() {\n+    fn takes_peekable(_peek: Peekable<Empty<u32>>) {}\n+\n+    // Passed to another function\n+    let passed_along = std::iter::empty::<u32>().peekable();\n+    takes_peekable(passed_along);\n+\n+    // Passed to another method\n+    struct PeekableConsumer;\n+    impl PeekableConsumer {\n+        fn consume(&self, _: Peekable<Empty<u32>>) {}\n+        fn consume_mut_ref(&self, _: &mut Peekable<Empty<u32>>) {}\n+    }\n+\n+    let peekable_consumer = PeekableConsumer;\n+    let mut passed_along_to_method = std::iter::empty::<u32>().peekable();\n+    peekable_consumer.consume_mut_ref(&mut passed_along_to_method);\n+    peekable_consumer.consume(passed_along_to_method);\n+\n+    // `peek` called in another block\n+    let mut peekable_in_block = std::iter::empty::<u32>().peekable();\n+    {\n+        peekable_in_block.peek();\n+    }\n+\n+    // Check the other `Peekable` methods :)\n+    {\n+        let mut peekable_with_peek_mut = std::iter::empty::<u32>().peekable();\n+        peekable_with_peek_mut.peek_mut();\n+\n+        let mut peekable_with_next_if = std::iter::empty::<u32>().peekable();\n+        peekable_with_next_if.next_if(|_| true);\n+\n+        let mut peekable_with_next_if_eq = std::iter::empty::<u32>().peekable();\n+        peekable_with_next_if_eq.next_if_eq(&3);\n+    }\n+\n+    let mut peekable_in_closure = std::iter::empty::<u32>().peekable();\n+    let call_peek = |p: &mut Peekable<Empty<u32>>| {\n+        p.peek();\n+    };\n+    call_peek(&mut peekable_in_closure);\n+\n+    // From a macro\n+    macro_rules! make_me_a_peekable_please {\n+        () => {\n+            std::iter::empty::<u32>().peekable()\n+        };\n+    }\n+\n+    let _unsuspecting_macro_user = make_me_a_peekable_please!();\n+\n+    // Generic Iterator returned\n+    fn return_an_iter() -> impl Iterator<Item = u32> {\n+        std::iter::empty::<u32>().peekable()\n+    }\n+\n+    let _unsuspecting_user = return_an_iter();\n+\n+    // Call `peek` in a macro\n+    macro_rules! peek_iter {\n+        ($iter:ident) => {\n+            $iter.peek();\n+        };\n+    }\n+\n+    let mut peek_in_macro = std::iter::empty::<u32>().peekable();\n+    peek_iter!(peek_in_macro);\n+\n+    // Behind mut ref\n+    let mut by_mut_ref_test = std::iter::empty::<u32>().peekable();\n+    let by_mut_ref = &mut by_mut_ref_test;\n+    by_mut_ref.peek();\n+\n+    // Behind ref\n+    let mut by_ref_test = std::iter::empty::<u32>().peekable();\n+    let by_ref = &by_ref_test;\n+    by_ref_test.peek();\n+\n+    // In struct\n+    struct PeekableWrapper {\n+        f: Peekable<Empty<u32>>,\n+    }\n+\n+    let struct_test = std::iter::empty::<u32>().peekable();\n+    PeekableWrapper { f: struct_test };\n+\n+    // `by_ref` before `peek`\n+    let mut by_ref_test = std::iter::empty::<u32>().peekable();\n+    let peeked_val = by_ref_test.by_ref().peek();\n+\n+    // `peek` called in another block as the last expression\n+    let mut peekable_last_expr = std::iter::empty::<u32>().peekable();\n+    {\n+        peekable_last_expr.peek();\n+    }\n+}"}, {"sha": "d557f54179dbaf680ccf899b14e9e3b242393935", "filename": "src/tools/clippy/tests/ui/unused_peekable.stderr", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_peekable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_peekable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_peekable.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -0,0 +1,67 @@\n+error: `peek` never called on `Peekable` iterator\n+  --> $DIR/unused_peekable.rs:14:9\n+   |\n+LL |     let peekable = std::iter::empty::<u32>().peekable();\n+   |         ^^^^^^^^\n+   |\n+   = note: `-D clippy::unused-peekable` implied by `-D warnings`\n+   = help: consider removing the call to `peekable`\n+\n+error: `peek` never called on `Peekable` iterator\n+  --> $DIR/unused_peekable.rs:18:9\n+   |\n+LL |     let new_local = old_local;\n+   |         ^^^^^^^^^\n+   |\n+   = help: consider removing the call to `peekable`\n+\n+error: `peek` never called on `Peekable` iterator\n+  --> $DIR/unused_peekable.rs:22:9\n+   |\n+LL |     let by_mut_ref = &mut by_mut_ref_test;\n+   |         ^^^^^^^^^^\n+   |\n+   = help: consider removing the call to `peekable`\n+\n+error: `peek` never called on `Peekable` iterator\n+  --> $DIR/unused_peekable.rs:29:9\n+   |\n+LL |     let peekable_from_fn = returns_peekable();\n+   |         ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing the call to `peekable`\n+\n+error: `peek` never called on `Peekable` iterator\n+  --> $DIR/unused_peekable.rs:32:13\n+   |\n+LL |     let mut peekable_using_iterator_method = std::iter::empty::<u32>().peekable();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing the call to `peekable`\n+\n+error: `peek` never called on `Peekable` iterator\n+  --> $DIR/unused_peekable.rs:37:9\n+   |\n+LL |     let passed_along_ref = std::iter::empty::<u32>().peekable();\n+   |         ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing the call to `peekable`\n+\n+error: `peek` never called on `Peekable` iterator\n+  --> $DIR/unused_peekable.rs:42:9\n+   |\n+LL |     let _by_ref = by_ref_test.by_ref();\n+   |         ^^^^^^^\n+   |\n+   = help: consider removing the call to `peekable`\n+\n+error: `peek` never called on `Peekable` iterator\n+  --> $DIR/unused_peekable.rs:44:13\n+   |\n+LL |     let mut peekable_in_for_loop = std::iter::empty::<u32>().peekable();\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing the call to `peekable`\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "d9fd402e7cfb9d200cc79f794e9b4b41c9c94c82", "filename": "src/tools/clippy/tests/ui/unwrap.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funwrap.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -6,8 +6,9 @@ fn unwrap_option() {\n }\n \n fn unwrap_result() {\n-    let res: Result<u8, ()> = Ok(0);\n+    let res: Result<u8, u8> = Ok(0);\n     let _ = res.unwrap();\n+    let _ = res.unwrap_err();\n }\n \n fn main() {"}, {"sha": "78422757819d502d3ba231fdc6b803e2a5407205", "filename": "src/tools/clippy/tests/ui/unwrap.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funwrap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funwrap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funwrap.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -15,5 +15,13 @@ LL |     let _ = res.unwrap();\n    |\n    = help: if you don't want to handle the `Err` case gracefully, consider using `expect()` to provide a better panic message\n \n-error: aborting due to 2 previous errors\n+error: used `unwrap_err()` on `a Result` value\n+  --> $DIR/unwrap.rs:11:13\n+   |\n+LL |     let _ = res.unwrap_err();\n+   |             ^^^^^^^^^^^^^^^^\n+   |\n+   = help: if you don't want to handle the `Ok` case gracefully, consider using `expect_err()` to provide a better panic message\n+\n+error: aborting due to 3 previous errors\n "}, {"sha": "9f27fef82494b8207437530017889d3bd523455d", "filename": "src/tools/clippy/tests/ui/unwrap_expect_used.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funwrap_expect_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funwrap_expect_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funwrap_expect_used.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,10 +1,35 @@\n #![warn(clippy::unwrap_used, clippy::expect_used)]\n \n+trait OptionExt {\n+    type Item;\n+\n+    fn unwrap_err(self) -> Self::Item;\n+\n+    fn expect_err(self, msg: &str) -> Self::Item;\n+}\n+\n+impl<T> OptionExt for Option<T> {\n+    type Item = T;\n+    fn unwrap_err(self) -> T {\n+        panic!();\n+    }\n+\n+    fn expect_err(self, msg: &str) -> T {\n+        panic!();\n+    }\n+}\n+\n fn main() {\n     Some(3).unwrap();\n     Some(3).expect(\"Hello world!\");\n \n+    // Don't trigger on unwrap_err on an option\n+    Some(3).unwrap_err();\n+    Some(3).expect_err(\"Hellow none!\");\n+\n     let a: Result<i32, i32> = Ok(3);\n     a.unwrap();\n     a.expect(\"Hello world!\");\n+    a.unwrap_err();\n+    a.expect_err(\"Hello error!\");\n }"}, {"sha": "1a19459b2c174c0ca8dfaee96d6148effd554094", "filename": "src/tools/clippy/tests/ui/unwrap_expect_used.stderr", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funwrap_expect_used.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funwrap_expect_used.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funwrap_expect_used.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,5 +1,5 @@\n error: used `unwrap()` on `an Option` value\n-  --> $DIR/unwrap_expect_used.rs:4:5\n+  --> $DIR/unwrap_expect_used.rs:23:5\n    |\n LL |     Some(3).unwrap();\n    |     ^^^^^^^^^^^^^^^^\n@@ -8,7 +8,7 @@ LL |     Some(3).unwrap();\n    = help: if this value is `None`, it will panic\n \n error: used `expect()` on `an Option` value\n-  --> $DIR/unwrap_expect_used.rs:5:5\n+  --> $DIR/unwrap_expect_used.rs:24:5\n    |\n LL |     Some(3).expect(\"Hello world!\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -17,20 +17,36 @@ LL |     Some(3).expect(\"Hello world!\");\n    = help: if this value is `None`, it will panic\n \n error: used `unwrap()` on `a Result` value\n-  --> $DIR/unwrap_expect_used.rs:8:5\n+  --> $DIR/unwrap_expect_used.rs:31:5\n    |\n LL |     a.unwrap();\n    |     ^^^^^^^^^^\n    |\n    = help: if this value is an `Err`, it will panic\n \n error: used `expect()` on `a Result` value\n-  --> $DIR/unwrap_expect_used.rs:9:5\n+  --> $DIR/unwrap_expect_used.rs:32:5\n    |\n LL |     a.expect(\"Hello world!\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: if this value is an `Err`, it will panic\n \n-error: aborting due to 4 previous errors\n+error: used `unwrap_err()` on `a Result` value\n+  --> $DIR/unwrap_expect_used.rs:33:5\n+   |\n+LL |     a.unwrap_err();\n+   |     ^^^^^^^^^^^^^^\n+   |\n+   = help: if this value is an `Ok`, it will panic\n+\n+error: used `expect_err()` on `a Result` value\n+  --> $DIR/unwrap_expect_used.rs:34:5\n+   |\n+LL |     a.expect_err(\"Hello error!\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if this value is an `Ok`, it will panic\n+\n+error: aborting due to 6 previous errors\n "}, {"sha": "4acf5b5fa2d1ba8ab717631f61210aa301ff90c5", "filename": "src/tools/clippy/tests/ui/useless_conversion_try.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_conversion_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_conversion_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_conversion_try.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -29,10 +29,10 @@ fn main() {\n     let _ = String::try_from(\"foo\".to_string()).unwrap();\n     let _ = String::try_from(format!(\"A: {:04}\", 123)).unwrap();\n     let _: String = format!(\"Hello {}\", \"world\").try_into().unwrap();\n-    let _: String = \"\".to_owned().try_into().unwrap();\n+    let _: String = String::new().try_into().unwrap();\n     let _: String = match String::from(\"_\").try_into() {\n         Ok(a) => a,\n-        Err(_) => \"\".into(),\n+        Err(_) => String::new(),\n     };\n     // FIXME this is a false negative\n     #[allow(clippy::cmp_owned)]"}, {"sha": "12e74d614717db6ee5c6d8068f894958d53e7dad", "filename": "src/tools/clippy/tests/ui/useless_conversion_try.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_conversion_try.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_conversion_try.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_conversion_try.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -62,7 +62,7 @@ LL |     let _: String = format!(\"Hello {}\", \"world\").try_into().unwrap();\n error: useless conversion to the same type: `std::string::String`\n   --> $DIR/useless_conversion_try.rs:32:21\n    |\n-LL |     let _: String = \"\".to_owned().try_into().unwrap();\n+LL |     let _: String = String::new().try_into().unwrap();\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider removing `.try_into()`"}, {"sha": "a8307e741cf17b0c8ff64fd53cf2096b22c7f068", "filename": "src/tools/clippy/tests/ui/vec_resize_to_zero.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvec_resize_to_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvec_resize_to_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvec_resize_to_zero.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,15 +1,19 @@\n #![warn(clippy::vec_resize_to_zero)]\n \n fn main() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+\n     // applicable here\n-    vec![1, 2, 3, 4, 5].resize(0, 5);\n+    v.resize(0, 5);\n \n     // not applicable\n-    vec![1, 2, 3, 4, 5].resize(2, 5);\n+    v.resize(2, 5);\n+\n+    let mut v = vec![\"foo\", \"bar\", \"baz\"];\n \n     // applicable here, but only implemented for integer literals for now\n-    vec![\"foo\", \"bar\", \"baz\"].resize(0, \"bar\");\n+    v.resize(0, \"bar\");\n \n     // not applicable\n-    vec![\"foo\", \"bar\", \"baz\"].resize(2, \"bar\")\n+    v.resize(2, \"bar\")\n }"}, {"sha": "7428cf62d6c429554d8a54e37cc641dfb93f8536", "filename": "src/tools/clippy/tests/ui/vec_resize_to_zero.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvec_resize_to_zero.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvec_resize_to_zero.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvec_resize_to_zero.stderr?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -1,10 +1,10 @@\n error: emptying a vector with `resize`\n-  --> $DIR/vec_resize_to_zero.rs:5:5\n+  --> $DIR/vec_resize_to_zero.rs:7:5\n    |\n-LL |     vec![1, 2, 3, 4, 5].resize(0, 5);\n-   |     ^^^^^^^^^^^^^^^^^^^^------------\n-   |                         |\n-   |                         help: ...or you can empty the vector with: `clear()`\n+LL |     v.resize(0, 5);\n+   |     ^^------------\n+   |       |\n+   |       help: ...or you can empty the vector with: `clear()`\n    |\n    = note: `-D clippy::vec-resize-to-zero` implied by `-D warnings`\n    = help: the arguments may be inverted..."}, {"sha": "df267e9872a0a0a6bdd6984c7aeca3e77c4e4d88", "filename": "src/tools/clippy/tests/ui/verbose_file_reads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fverbose_file_reads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fverbose_file_reads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fverbose_file_reads.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -18,7 +18,7 @@ fn main() -> std::io::Result<()> {\n     s.read_to_end();\n     s.read_to_string();\n     // Should catch this\n-    let mut f = File::open(&path)?;\n+    let mut f = File::open(path)?;\n     let mut buffer = Vec::new();\n     f.read_to_end(&mut buffer)?;\n     // ...and this"}, {"sha": "95325e06037829c2fb9a519f5b3a50e10ddee1e1", "filename": "src/tools/clippy/tests/workspace.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a677674b3364cab71fd49793aa5cc90b9dc5322/src%2Ftools%2Fclippy%2Ftests%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fworkspace.rs?ref=9a677674b3364cab71fd49793aa5cc90b9dc5322", "patch": "@@ -20,8 +20,8 @@ fn test_no_deps_ignores_path_deps_in_workspaces() {\n         .current_dir(&cwd)\n         .env(\"CARGO_TARGET_DIR\", &target_dir)\n         .arg(\"clean\")\n-        .args(&[\"-p\", \"subcrate\"])\n-        .args(&[\"-p\", \"path_dep\"])\n+        .args([\"-p\", \"subcrate\"])\n+        .args([\"-p\", \"path_dep\"])\n         .output()\n         .unwrap();\n \n@@ -32,11 +32,11 @@ fn test_no_deps_ignores_path_deps_in_workspaces() {\n         .env(\"CARGO_INCREMENTAL\", \"0\")\n         .env(\"CARGO_TARGET_DIR\", &target_dir)\n         .arg(\"clippy\")\n-        .args(&[\"-p\", \"subcrate\"])\n+        .args([\"-p\", \"subcrate\"])\n         .arg(\"--no-deps\")\n         .arg(\"--\")\n         .arg(\"-Cdebuginfo=0\") // disable debuginfo to generate less data in the target dir\n-        .args(&[\"--cfg\", r#\"feature=\"primary_package_test\"\"#])\n+        .args([\"--cfg\", r#\"feature=\"primary_package_test\"\"#])\n         .output()\n         .unwrap();\n     println!(\"status: {}\", output.status);\n@@ -52,10 +52,10 @@ fn test_no_deps_ignores_path_deps_in_workspaces() {\n             .env(\"CARGO_INCREMENTAL\", \"0\")\n             .env(\"CARGO_TARGET_DIR\", &target_dir)\n             .arg(\"clippy\")\n-            .args(&[\"-p\", \"subcrate\"])\n+            .args([\"-p\", \"subcrate\"])\n             .arg(\"--\")\n             .arg(\"-Cdebuginfo=0\") // disable debuginfo to generate less data in the target dir\n-            .args(&[\"--cfg\", r#\"feature=\"primary_package_test\"\"#])\n+            .args([\"--cfg\", r#\"feature=\"primary_package_test\"\"#])\n             .output()\n             .unwrap();\n         println!(\"status: {}\", output.status);\n@@ -79,7 +79,7 @@ fn test_no_deps_ignores_path_deps_in_workspaces() {\n             .env(\"CARGO_INCREMENTAL\", \"0\")\n             .env(\"CARGO_TARGET_DIR\", &target_dir)\n             .arg(\"clippy\")\n-            .args(&[\"-p\", \"subcrate\"])\n+            .args([\"-p\", \"subcrate\"])\n             .arg(\"--\")\n             .arg(\"-Cdebuginfo=0\") // disable debuginfo to generate less data in the target dir\n             .output()"}]}