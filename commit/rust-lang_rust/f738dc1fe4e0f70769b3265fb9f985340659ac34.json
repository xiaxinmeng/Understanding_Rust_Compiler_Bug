{"sha": "f738dc1fe4e0f70769b3265fb9f985340659ac34", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3MzhkYzFmZTRlMGY3MDc2OWIzMjY1ZmI5Zjk4NTM0MDY1OWFjMzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-27T23:34:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-27T23:34:10Z"}, "message": "Auto merge of #32529 - Manishearth:concurrency-fx, r=steveklabnik\n\nImprove concurrency chapter\n\nIncorporate feedback from HN\n\nr? @steveklabnik", "tree": {"sha": "1429e501333c80b46696345c98130c07ecae6030", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1429e501333c80b46696345c98130c07ecae6030"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f738dc1fe4e0f70769b3265fb9f985340659ac34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f738dc1fe4e0f70769b3265fb9f985340659ac34", "html_url": "https://github.com/rust-lang/rust/commit/f738dc1fe4e0f70769b3265fb9f985340659ac34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f738dc1fe4e0f70769b3265fb9f985340659ac34/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1080dca01affec0e9633ca79e7bafff52578ac9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1080dca01affec0e9633ca79e7bafff52578ac9", "html_url": "https://github.com/rust-lang/rust/commit/e1080dca01affec0e9633ca79e7bafff52578ac9"}, {"sha": "5954fce848a0105cdf2009278cd1b50daffb7c61", "url": "https://api.github.com/repos/rust-lang/rust/commits/5954fce848a0105cdf2009278cd1b50daffb7c61", "html_url": "https://github.com/rust-lang/rust/commit/5954fce848a0105cdf2009278cd1b50daffb7c61"}], "stats": {"total": 142, "additions": 124, "deletions": 18}, "files": [{"sha": "991654b2b8d43bf8ef8410a7c8f1e74c481072ce", "filename": "src/doc/book/concurrency.md", "status": "modified", "additions": 124, "deletions": 18, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/f738dc1fe4e0f70769b3265fb9f985340659ac34/src%2Fdoc%2Fbook%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/f738dc1fe4e0f70769b3265fb9f985340659ac34/src%2Fdoc%2Fbook%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fconcurrency.md?ref=f738dc1fe4e0f70769b3265fb9f985340659ac34", "patch": "@@ -94,6 +94,54 @@ fn main() {\n }\n ```\n \n+As closures can capture variables from their environment, we can also try to\n+bring some data into the other thread:\n+\n+```rust,ignore\n+use std::thread;\n+\n+fn main() {\n+    let x = 1;\n+    thread::spawn(|| {\n+        println!(\"x is {}\", x);\n+    });\n+}\n+```\n+\n+However, this gives us an error:\n+\n+```text\n+5:19: 7:6 error: closure may outlive the current function, but it\n+                 borrows `x`, which is owned by the current function\n+...\n+5:19: 7:6 help: to force the closure to take ownership of `x` (and any other referenced variables),\n+          use the `move` keyword, as shown:\n+      thread::spawn(move || {\n+          println!(\"x is {}\", x);\n+      });\n+```\n+\n+This is because by default closures capture variables by reference, and thus the\n+closure only captures a _reference to `x`_. This is a problem, because the\n+thread may outlive the scope of `x`, leading to a dangling pointer.\n+\n+To fix this, we use a `move` closure as mentioned in the error message. `move`\n+closures are explained in depth [here](closures.html#move-closures); basically\n+they move variables from their environment into themselves. This means that `x`\n+is now owned by the closure, and cannot be used in `main()` after the call to\n+`spawn()`.\n+\n+```rust\n+use std::thread;\n+\n+fn main() {\n+    let x = 1;\n+    thread::spawn(move || {\n+        println!(\"x is {}\", x);\n+    });\n+}\n+```\n+\n Many languages have the ability to execute threads, but it's wildly unsafe.\n There are entire books about how to prevent errors that occur from shared\n mutable state. Rust helps out with its type system here as well, by preventing\n@@ -145,23 +193,64 @@ This gives us an error:\n ```\n \n Rust knows this wouldn't be safe! If we had a reference to `data` in each\n-thread, and the thread takes ownership of the reference, we'd have three\n-owners!\n+thread, and the thread takes ownership of the reference, we'd have three owners!\n+`data` gets moved out of `main` in the first call to `spawn()`, so subsequent\n+calls in the loop cannot use this variable.\n+\n+So, we need some type that lets us have more than one owning reference to a\n+value. Usually, we'd use `Rc<T>` for this, which is a reference counted type\n+that provides shared ownership. It has some runtime bookkeeping that keeps track\n+of the number of references to it, hence the \"reference count\" part of its name.\n+\n+Calling `clone()` on an `Rc<T>` will return a new owned reference and bump the\n+internal reference count. We create one of these for each thread:\n \n-So, we need some type that lets us have more than one reference to a value and\n-that we can share between threads, that is it must implement `Sync`.\n \n-We'll use `Arc<T>`, Rust's standard atomic reference count type, which\n-wraps a value up with some extra runtime bookkeeping which allows us to\n-share the ownership of the value between multiple references at the same time.\n+```ignore\n+use std::thread;\n+use std::time::Duration;\n+use std::rc::Rc;\n \n-The bookkeeping consists of a count of how many of these references exist to\n-the value, hence the reference count part of the name.\n+fn main() {\n+    let mut data = Rc::new(vec![1, 2, 3]);\n+\n+    for i in 0..3 {\n+        // create a new owned reference\n+        let data_ref = data.clone();\n+\n+        // use it in a thread\n+        thread::spawn(move || {\n+            data_ref[i] += 1;\n+        });\n+    }\n+\n+    thread::sleep(Duration::from_millis(50));\n+}\n+```\n+\n+This won't work, however, and will give us the error:\n+\n+```text\n+13:9: 13:22 error: the trait `core::marker::Send` is not\n+            implemented for the type `alloc::rc::Rc<collections::vec::Vec<i32>>`\n+...\n+13:9: 13:22 note: `alloc::rc::Rc<collections::vec::Vec<i32>>`\n+            cannot be sent between threads safely\n+```\n+\n+As the error message mentions, `Rc` cannot be sent between threads safely. This\n+is because the internal reference count is not maintained in a thread safe\n+matter and can have a data race.\n+\n+To solve this, we'll use `Arc<T>`, Rust's standard atomic reference count type.\n \n The Atomic part means `Arc<T>` can safely be accessed from multiple threads.\n To do this the compiler guarantees that mutations of the internal count use\n indivisible operations which can't have data races.\n \n+In essence, `Arc<T>` is a type that lets us share ownership of data _across\n+threads_.\n+\n \n ```ignore\n use std::thread;\n@@ -182,7 +271,7 @@ fn main() {\n }\n ```\n \n-We now call `clone()` on our `Arc<T>`, which increases the internal count.\n+Similarly to las time, we use `clone()` to create a new owned handle.\n This handle is then moved into the new thread.\n \n And... still gives us an error.\n@@ -193,14 +282,21 @@ And... still gives us an error.\n                              ^~~~\n ```\n \n-`Arc<T>` assumes one more property about its contents to ensure that it is safe\n-to share across threads: it assumes its contents are `Sync`. This is true for\n-our value if it's immutable, but we want to be able to mutate it, so we need\n-something else to persuade the borrow checker we know what we're doing.\n+`Arc<T> by default has immutable contents. It allows the _sharing_ of data\n+between threads, but shared mutable data is unsafe and when threads are\n+involved can cause data races!\n+\n \n-It looks like we need some type that allows us to safely mutate a shared value,\n-for example a type that can ensure only one thread at a time is able to\n-mutate the value inside it at any one time.\n+Usually when we wish to make something in an immutable position mutable, we use\n+`Cell<T>` or `RefCell<T>` which allow safe mutation via runtime checks or\n+otherwise (see also: [Choosing Your Guarantees](choosing-your-guarantees.html)).\n+However, similar to `Rc`, these are not thread safe. If we try using these, we\n+will get an error about these types not being `Sync`, and the code will fail to\n+compile.\n+\n+It looks like we need some type that allows us to safely mutate a shared value\n+across threads, for example a type that can ensure only one thread at a time is\n+able to mutate the value inside it at any one time.\n \n For that, we can use the `Mutex<T>` type!\n \n@@ -229,7 +325,17 @@ fn main() {\n Note that the value of `i` is bound (copied) to the closure and not shared\n among the threads.\n \n-Also note that [`lock`](../std/sync/struct.Mutex.html#method.lock) method of\n+We're \"locking\" the mutex here. A mutex (short for \"mutual exclusion\"), as\n+mentioned, only allows one thread at a time to access a value. When we wish to\n+access the value, we use `lock()` on it. This will \"lock\" the mutex, and no\n+other thread will be able to lock it (and hence, do anything with the value)\n+until we're done with it. If a thread attempts to lock a mutex which is already\n+locked, it will wait until the other thread releases the lock.\n+\n+The lock \"release\" here is implicit; when the result of the lock (in this case,\n+`data`) goes out of scope, the lock is automatically released.\n+\n+Note that [`lock`](../std/sync/struct.Mutex.html#method.lock) method of\n [`Mutex`](../std/sync/struct.Mutex.html) has this signature:\n \n ```ignore"}]}