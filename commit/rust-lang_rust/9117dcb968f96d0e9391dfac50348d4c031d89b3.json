{"sha": "9117dcb968f96d0e9391dfac50348d4c031d89b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxMTdkY2I5NjhmOTZkMGU5MzkxZGZhYzUwMzQ4ZDRjMDMxZDg5YjM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-20T01:00:26Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-20T16:48:05Z"}, "message": "rustc: De-mode all overloaded operators", "tree": {"sha": "a571f0c2ef1f91370cae51527f0e0761212a82e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a571f0c2ef1f91370cae51527f0e0761212a82e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9117dcb968f96d0e9391dfac50348d4c031d89b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9117dcb968f96d0e9391dfac50348d4c031d89b3", "html_url": "https://github.com/rust-lang/rust/commit/9117dcb968f96d0e9391dfac50348d4c031d89b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9117dcb968f96d0e9391dfac50348d4c031d89b3/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b670c306b8de545afcbcea81bcd592c644409d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b670c306b8de545afcbcea81bcd592c644409d7", "html_url": "https://github.com/rust-lang/rust/commit/6b670c306b8de545afcbcea81bcd592c644409d7"}], "stats": {"total": 4214, "additions": 3967, "deletions": 247}, "files": [{"sha": "e648e6120ce74a54b08048d2b96293e937146576", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -26,6 +26,7 @@ type package = {\n     versions: ~[(~str, ~str)]\n };\n \n+#[cfg(stage0)]\n impl package : cmp::Ord {\n     pure fn lt(&&other: package) -> bool {\n         if self.name.lt(other.name) { return true; }\n@@ -47,6 +48,29 @@ impl package : cmp::Ord {\n     pure fn ge(&&other: package) -> bool { !self.lt(other) }\n     pure fn gt(&&other: package) -> bool { other.lt(self)  }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl package : cmp::Ord {\n+    pure fn lt(other: &package) -> bool {\n+        if self.name.lt(&(*other).name) { return true; }\n+        if (*other).name.lt(&self.name) { return false; }\n+        if self.uuid.lt(&(*other).uuid) { return true; }\n+        if (*other).uuid.lt(&self.uuid) { return false; }\n+        if self.url.lt(&(*other).url) { return true; }\n+        if (*other).url.lt(&self.url) { return false; }\n+        if self.method.lt(&(*other).method) { return true; }\n+        if (*other).method.lt(&self.method) { return false; }\n+        if self.description.lt(&(*other).description) { return true; }\n+        if (*other).description.lt(&self.description) { return false; }\n+        if self.tags.lt(&(*other).tags) { return true; }\n+        if (*other).tags.lt(&self.tags) { return false; }\n+        if self.versions.lt(&(*other).versions) { return true; }\n+        return false;\n+    }\n+    pure fn le(other: &package) -> bool { !(*other).lt(&self) }\n+    pure fn ge(other: &package) -> bool { !self.lt(other)     }\n+    pure fn gt(other: &package) -> bool { (*other).lt(&self)  }\n+}\n \n type local_package = {\n     name: ~str,\n@@ -97,12 +121,21 @@ type options = {\n \n enum mode { system_mode, user_mode, local_mode }\n \n+#[cfg(stage0)]\n impl mode : cmp::Eq {\n     pure fn eq(&&other: mode) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: mode) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl mode : cmp::Eq {\n+    pure fn eq(other: &mode) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &mode) -> bool { !self.eq(other) }\n+}\n \n fn opts() -> ~[getopts::Opt] {\n     ~[optflag(~\"g\"), optflag(~\"G\"), optflag(~\"test\"),"}, {"sha": "01b657c9c2d791ba022283ff0c7de5915e8fe588", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -1,11 +1,20 @@\n enum mode { mode_compile_fail, mode_run_fail, mode_run_pass, mode_pretty, }\n \n+#[cfg(stage0)]\n impl mode : cmp::Eq {\n     pure fn eq(&&other: mode) -> bool {\n         other as int == self as int\n     }\n     pure fn ne(&&other: mode) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl mode : cmp::Eq {\n+    pure fn eq(other: &mode) -> bool {\n+        (*other) as int == self as int\n+    }\n+    pure fn ne(other: &mode) -> bool { !self.eq(other) }\n+}\n \n type config = {\n     // The library paths required for running the compiler"}, {"sha": "cb7e16df6dc446898666d4f7d38c61d911e3d39a", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -8,12 +8,21 @@ use syntax::diagnostic;\n enum test_mode { tm_converge, tm_run, }\n type context = { mode: test_mode }; // + rng\n \n+#[cfg(stage0)]\n impl test_mode : cmp::Eq {\n     pure fn eq(&&other: test_mode) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: test_mode) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl test_mode : cmp::Eq {\n+    pure fn eq(other: &test_mode) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &test_mode) -> bool { !self.eq(other) }\n+}\n \n fn write_file(filename: &Path, content: ~str) {\n     result::get("}, {"sha": "19003568354b1a31f8465981bde75a10038af5f4", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -8,6 +8,7 @@ export build_sized, build, build_sized_opt;\n export map;\n export from_fn, from_elem;\n export raw;\n+export traits;\n \n /// Code for dealing with @-vectors. This is pretty incomplete, and\n /// contains a bunch of duplication from the code for ~-vectors.\n@@ -133,13 +134,26 @@ pure fn from_elem<T: Copy>(n_elts: uint, t: T) -> @[T] {\n }\n \n #[cfg(notest)]\n-impl<T: Copy> @[T]: Add<&[const T],@[T]> {\n-    #[inline(always)]\n-    pure fn add(rhs: &[const T]) -> @[T] {\n-        append(self, rhs)\n+mod traits {\n+    #[cfg(stage0)]\n+    impl<T: Copy> @[T]: Add<&[const T],@[T]> {\n+        #[inline(always)]\n+        pure fn add(rhs: &[const T]) -> @[T] {\n+            append(self, rhs)\n+        }\n+    }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    impl<T: Copy> @[T] : Add<&[const T],@[T]> {\n+        #[inline(always)]\n+        pure fn add(rhs: & &[const T]) -> @[T] {\n+            append(self, (*rhs))\n+        }\n     }\n }\n \n+#[cfg(test)]\n+mod traits {}\n \n mod raw {\n     type VecRepr = vec::raw::VecRepr;"}, {"sha": "a80519e82ee5a5237d933153566dce882c14d9e5", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -69,10 +69,17 @@ fn all_values(blk: fn(v: bool)) {\n /// converts truth value to an 8 bit byte\n pure fn to_bit(v: bool) -> u8 { if v { 1u8 } else { 0u8 } }\n \n+#[cfg(stage0)]\n impl bool : cmp::Eq {\n     pure fn eq(&&other: bool) -> bool { self == other }\n     pure fn ne(&&other: bool) -> bool { self != other }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl bool : cmp::Eq {\n+    pure fn eq(other: &bool) -> bool { self == (*other) }\n+    pure fn ne(other: &bool) -> bool { self != (*other) }\n+}\n \n #[test]\n fn test_bool_from_str() {"}, {"sha": "294b307f0d6d52a1cdf0457ee255ee7d13488e10", "filename": "src/libcore/box.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbox.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -30,17 +30,33 @@ pure fn ptr_eq<T>(a: @T, b: @T) -> bool {\n     unsafe { ptr::addr_of(*a) == ptr::addr_of(*b) }\n }\n \n+#[cfg(stage0)]\n impl<T:Eq> @const T : Eq {\n     pure fn eq(&&other: @const T) -> bool { *self == *other }\n     pure fn ne(&&other: @const T) -> bool { *self != *other }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<T:Eq> @const T : Eq {\n+    pure fn eq(other: &@const T) -> bool { *self == *(*other) }\n+    pure fn ne(other: &@const T) -> bool { *self != *(*other) }\n+}\n \n+#[cfg(stage0)]\n impl<T:Ord> @const T : Ord {\n     pure fn lt(&&other: @const T) -> bool { *self < *other }\n     pure fn le(&&other: @const T) -> bool { *self <= *other }\n     pure fn ge(&&other: @const T) -> bool { *self >= *other }\n     pure fn gt(&&other: @const T) -> bool { *self > *other }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<T:Ord> @const T : Ord {\n+    pure fn lt(other: &@const T) -> bool { *self < *(*other) }\n+    pure fn le(other: &@const T) -> bool { *self <= *(*other) }\n+    pure fn ge(other: &@const T) -> bool { *self >= *(*other) }\n+    pure fn gt(other: &@const T) -> bool { *self > *(*other) }\n+}\n \n #[test]\n fn test() {"}, {"sha": "6732e157cb82ae797375eff6f730cd63aab5a0cc", "filename": "src/libcore/char.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -189,10 +189,17 @@ pure fn cmp(a: char, b: char) -> int {\n     else { 0 }\n }\n \n+#[cfg(stage0)]\n impl char: Eq {\n     pure fn eq(&&other: char) -> bool { self == other }\n     pure fn ne(&&other: char) -> bool { self != other }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl char : Eq {\n+    pure fn eq(other: &char) -> bool { self == (*other) }\n+    pure fn ne(other: &char) -> bool { self != (*other) }\n+}\n \n #[test]\n fn test_is_lowercase() {"}, {"sha": "35c3dcc71abbaafc57d9cf25226d0e3c239851d0", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 130, "deletions": 38, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -14,76 +14,168 @@ and `Eq` to overload the `==` and `!=` operators.\n #[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n+use nounittest::*;\n+use unittest::*;\n+export Ord;\n+export Eq;\n+\n /// Interfaces used for comparison.\n \n // Awful hack to work around duplicate lang items in core test.\n-\n-/**\n- * Trait for values that can be compared for a sort-order.\n- *\n- * Eventually this may be simplified to only require\n- * an `le` method, with the others generated from\n- * default implementations.\n- */\n #[cfg(notest)]\n-#[lang=\"ord\"]\n-trait Ord {\n-    pure fn lt(&&other: self) -> bool;\n-    pure fn le(&&other: self) -> bool;\n-    pure fn ge(&&other: self) -> bool;\n-    pure fn gt(&&other: self) -> bool;\n+mod nounittest {\n+    /**\n+     * Trait for values that can be compared for a sort-order.\n+     *\n+     * Eventually this may be simplified to only require\n+     * an `le` method, with the others generated from\n+     * default implementations.\n+     */\n+    #[cfg(stage0)]\n+    #[lang=\"ord\"]\n+    trait Ord {\n+        pure fn lt(&&other: self) -> bool;\n+        pure fn le(&&other: self) -> bool;\n+        pure fn ge(&&other: self) -> bool;\n+        pure fn gt(&&other: self) -> bool;\n+    }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[lang=\"ord\"]\n+    trait Ord {\n+        pure fn lt(other: &self) -> bool;\n+        pure fn le(other: &self) -> bool;\n+        pure fn ge(other: &self) -> bool;\n+        pure fn gt(other: &self) -> bool;\n+    }\n+\n+    #[cfg(stage0)]\n+    #[lang=\"eq\"]\n+    /**\n+     * Trait for values that can be compared for equality\n+     * and inequality.\n+     *\n+     * Eventually this may be simplified to only require\n+     * an `eq` method, with the other generated from\n+     * a default implementation.\n+     */\n+    trait Eq {\n+        pure fn eq(&&other: self) -> bool;\n+        pure fn ne(&&other: self) -> bool;\n+    }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[lang=\"eq\"]\n+    trait Eq {\n+        pure fn eq(other: &self) -> bool;\n+        pure fn ne(other: &self) -> bool;\n+    }\n }\n \n #[cfg(test)]\n-trait Ord {\n-    pure fn lt(&&other: self) -> bool;\n-    pure fn le(&&other: self) -> bool;\n-    pure fn ge(&&other: self) -> bool;\n-    pure fn gt(&&other: self) -> bool;\n-}\n-\n-/**\n- * Trait for values that can be compared for equality\n- * and inequality.\n- *\n- * Eventually this may be simplified to only require\n- * an `eq` method, with the other generated from\n- * a default implementation.\n- */\n-#[cfg(notest)]\n-#[lang=\"eq\"]\n-trait Eq {\n-    pure fn eq(&&other: self) -> bool;\n-    pure fn ne(&&other: self) -> bool;\n-}\n+mod nounittest {}\n \n #[cfg(test)]\n-trait Eq {\n-    pure fn eq(&&other: self) -> bool;\n-    pure fn ne(&&other: self) -> bool;\n+mod unittest {\n+    #[cfg(stage0)]\n+    trait Ord {\n+        pure fn lt(&&other: self) -> bool;\n+        pure fn le(&&other: self) -> bool;\n+        pure fn ge(&&other: self) -> bool;\n+        pure fn gt(&&other: self) -> bool;\n+    }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    trait Ord {\n+        pure fn lt(other: &self) -> bool;\n+        pure fn le(other: &self) -> bool;\n+        pure fn ge(other: &self) -> bool;\n+        pure fn gt(other: &self) -> bool;\n+    }\n+\n+    #[cfg(stage0)]\n+    trait Eq {\n+        pure fn eq(&&other: self) -> bool;\n+        pure fn ne(&&other: self) -> bool;\n+    }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    trait Eq {\n+        pure fn eq(other: &self) -> bool;\n+        pure fn ne(other: &self) -> bool;\n+    }\n }\n \n+#[cfg(notest)]\n+mod unittest {}\n+\n+#[cfg(stage0)]\n pure fn lt<T: Ord>(v1: &T, v2: &T) -> bool {\n     v1.lt(v2)\n }\n \n+#[cfg(stage0)]\n pure fn le<T: Ord Eq>(v1: &T, v2: &T) -> bool {\n     v1.lt(v2) || v1.eq(v2)\n }\n \n+#[cfg(stage0)]\n pure fn eq<T: Eq>(v1: &T, v2: &T) -> bool {\n     v1.eq(v2)\n }\n \n+#[cfg(stage0)]\n pure fn ne<T: Eq>(v1: &T, v2: &T) -> bool {\n     v1.ne(v2)\n }\n \n+#[cfg(stage0)]\n pure fn ge<T: Ord>(v1: &T, v2: &T) -> bool {\n     v1.ge(v2)\n }\n \n+#[cfg(stage0)]\n pure fn gt<T: Ord>(v1: &T, v2: &T) -> bool {\n     v1.gt(v2)\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pure fn lt<T: Ord>(v1: &T, v2: &T) -> bool {\n+    (*v1).lt(v2)\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pure fn le<T: Ord Eq>(v1: &T, v2: &T) -> bool {\n+    (*v1).lt(v2) || (*v1).eq(v2)\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pure fn eq<T: Eq>(v1: &T, v2: &T) -> bool {\n+    (*v1).eq(v2)\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pure fn ne<T: Eq>(v1: &T, v2: &T) -> bool {\n+    (*v1).ne(v2)\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pure fn ge<T: Ord>(v1: &T, v2: &T) -> bool {\n+    (*v1).ge(v2)\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pure fn gt<T: Ord>(v1: &T, v2: &T) -> bool {\n+    (*v1).gt(v2)\n+}\n+"}, {"sha": "d566cd7e6dcf410b21be3c5fefda17a0bccdd336", "filename": "src/libcore/either.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -126,6 +126,7 @@ pure fn unwrap_right<T,U>(+eith: Either<T,U>) -> U {\n     }\n }\n \n+#[cfg(stage0)]\n impl<T:Eq,U:Eq> Either<T,U> : Eq {\n     pure fn eq(&&other: Either<T,U>) -> bool {\n         match self {\n@@ -145,6 +146,27 @@ impl<T:Eq,U:Eq> Either<T,U> : Eq {\n     }\n     pure fn ne(&&other: Either<T,U>) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<T:Eq,U:Eq> Either<T,U> : Eq {\n+    pure fn eq(other: &Either<T,U>) -> bool {\n+        match self {\n+            Left(a) => {\n+                match (*other) {\n+                    Left(ref b) => a.eq(b),\n+                    Right(_) => false\n+                }\n+            }\n+            Right(a) => {\n+                match (*other) {\n+                    Left(_) => false,\n+                    Right(ref b) => a.eq(b)\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &Either<T,U>) -> bool { !self.eq(other) }\n+}\n \n #[test]\n fn test_either_left() {"}, {"sha": "f9059c59d7d40fc25462a8b737d56147601c36ba", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -386,6 +386,7 @@ mod rt {\n \n     enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n \n+#[cfg(stage0)]\n     impl PadMode: Eq {\n         pure fn eq(&&other: PadMode) -> bool {\n             match (self, other) {\n@@ -401,6 +402,23 @@ mod rt {\n         }\n         pure fn ne(&&other: PadMode) -> bool { !self.eq(other) }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    impl PadMode : Eq {\n+        pure fn eq(other: &PadMode) -> bool {\n+            match (self, (*other)) {\n+                (PadSigned, PadSigned) => true,\n+                (PadUnsigned, PadUnsigned) => true,\n+                (PadNozero, PadNozero) => true,\n+                (PadFloat, PadFloat) => true,\n+                (PadSigned, _) => false,\n+                (PadUnsigned, _) => false,\n+                (PadNozero, _) => false,\n+                (PadFloat, _) => false\n+            }\n+        }\n+        pure fn ne(other: &PadMode) -> bool { !self.eq(other) }\n+    }\n \n     fn pad(cv: Conv, &s: ~str, mode: PadMode) -> ~str {\n         let uwidth : uint = match cv.width {\n@@ -574,6 +592,7 @@ mod rt2 {\n \n     enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n \n+#[cfg(stage0)]\n     impl PadMode: Eq {\n         pure fn eq(&&other: PadMode) -> bool {\n             match (self, other) {\n@@ -589,6 +608,23 @@ mod rt2 {\n         }\n         pure fn ne(&&other: PadMode) -> bool { !self.eq(other) }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    impl PadMode : Eq {\n+        pure fn eq(other: &PadMode) -> bool {\n+            match (self, (*other)) {\n+                (PadSigned, PadSigned) => true,\n+                (PadUnsigned, PadUnsigned) => true,\n+                (PadNozero, PadNozero) => true,\n+                (PadFloat, PadFloat) => true,\n+                (PadSigned, _) => false,\n+                (PadUnsigned, _) => false,\n+                (PadNozero, _) => false,\n+                (PadFloat, _) => false\n+            }\n+        }\n+        pure fn ne(other: &PadMode) -> bool { !self.eq(other) }\n+    }\n \n     fn pad(cv: Conv, &s: ~str, mode: PadMode) -> ~str {\n         let uwidth : uint = match cv.width {"}, {"sha": "4877e12204a05663b353131d111d0d30bca76a5e", "filename": "src/libcore/float.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -414,17 +414,33 @@ pure fn sin(x: float) -> float { f64::sin(x as f64) as float }\n pure fn cos(x: float) -> float { f64::cos(x as f64) as float }\n pure fn tan(x: float) -> float { f64::tan(x as f64) as float }\n \n+#[cfg(stage0)]\n impl float: Eq {\n     pure fn eq(&&other: float) -> bool { self == other }\n     pure fn ne(&&other: float) -> bool { self != other }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl float : Eq {\n+    pure fn eq(other: &float) -> bool { self == (*other) }\n+    pure fn ne(other: &float) -> bool { self != (*other) }\n+}\n \n+#[cfg(stage0)]\n impl float: Ord {\n     pure fn lt(&&other: float) -> bool { self < other }\n     pure fn le(&&other: float) -> bool { self <= other }\n     pure fn ge(&&other: float) -> bool { self >= other }\n     pure fn gt(&&other: float) -> bool { self > other }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl float : Ord {\n+    pure fn lt(other: &float) -> bool { self < (*other) }\n+    pure fn le(other: &float) -> bool { self <= (*other) }\n+    pure fn ge(other: &float) -> bool { self >= (*other) }\n+    pure fn gt(other: &float) -> bool { self > (*other) }\n+}\n \n impl float: num::Num {\n     pure fn add(&&other: float)    -> float { return self + other; }"}, {"sha": "c9dd21252a3ac53b4b2eb73b1ab5b1176b3be89a", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -68,17 +68,33 @@ pure fn abs(i: T) -> T {\n     if is_negative(i) { -i } else { i }\n }\n \n+#[cfg(stage0)]\n impl T: Ord {\n     pure fn lt(&&other: T) -> bool { return self < other; }\n     pure fn le(&&other: T) -> bool { return self <= other; }\n     pure fn ge(&&other: T) -> bool { return self >= other; }\n     pure fn gt(&&other: T) -> bool { return self > other; }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl T : Ord {\n+    pure fn lt(other: &T) -> bool { return self < (*other); }\n+    pure fn le(other: &T) -> bool { return self <= (*other); }\n+    pure fn ge(other: &T) -> bool { return self >= (*other); }\n+    pure fn gt(other: &T) -> bool { return self > (*other); }\n+}\n \n+#[cfg(stage0)]\n impl T: Eq {\n     pure fn eq(&&other: T) -> bool { return self == other; }\n     pure fn ne(&&other: T) -> bool { return self != other; }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl T : Eq {\n+    pure fn eq(other: &T) -> bool { return self == (*other); }\n+    pure fn ne(other: &T) -> bool { return self != (*other); }\n+}\n \n impl T: num::Num {\n     pure fn add(&&other: T)    -> T { return self + other; }"}, {"sha": "e5a20909b7f78962d2b108feb0b6a9eaba78c0b5", "filename": "src/libcore/io.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -329,6 +329,7 @@ enum FileFlag { Append, Create, Truncate, NoFlag, }\n // What type of writer are we?\n enum WriterType { Screen, File }\n \n+#[cfg(stage0)]\n impl WriterType: Eq {\n     pure fn eq(&&other: WriterType) -> bool {\n         match (self, other) {\n@@ -338,6 +339,17 @@ impl WriterType: Eq {\n     }\n     pure fn ne(&&other: WriterType) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl WriterType : Eq {\n+    pure fn eq(other: &WriterType) -> bool {\n+        match (self, (*other)) {\n+            (Screen, Screen) | (File, File) => true,\n+            (Screen, _) | (File, _) => false\n+        }\n+    }\n+    pure fn ne(other: &WriterType) -> bool { !self.eq(other) }\n+}\n \n // FIXME (#2004): Seekable really should be orthogonal.\n // FIXME (#2004): eventually u64"}, {"sha": "bf67fe04ea021d6589bf05047c4a19447ba3b516", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 80, "deletions": 16, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -1,96 +1,160 @@\n // Core operators and kinds.\n \n-#[cfg(notest)]\n #[lang=\"const\"]\n trait Const {\n     // Empty.\n }\n \n-#[cfg(notest)]\n #[lang=\"copy\"]\n trait Copy {\n     // Empty.\n }\n \n-#[cfg(notest)]\n #[lang=\"send\"]\n trait Send {\n     // Empty.\n }\n \n-#[cfg(notest)]\n #[lang=\"owned\"]\n trait Owned {\n     // Empty.\n }\n \n-#[cfg(notest)]\n+#[cfg(stage0)]\n #[lang=\"add\"]\n trait Add<RHS,Result> {\n     pure fn add(rhs: RHS) -> Result;\n }\n \n-#[cfg(notest)]\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[lang=\"add\"]\n+trait Add<RHS,Result> {\n+    pure fn add(rhs: &RHS) -> Result;\n+}\n+\n+#[cfg(stage0)]\n #[lang=\"sub\"]\n trait Sub<RHS,Result> {\n     pure fn sub(rhs: RHS) -> Result;\n }\n \n-#[cfg(notest)]\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[lang=\"sub\"]\n+trait Sub<RHS,Result> {\n+    pure fn sub(rhs: &RHS) -> Result;\n+}\n+\n+#[cfg(stage0)]\n #[lang=\"mul\"]\n trait Mul<RHS,Result> {\n     pure fn mul(rhs: RHS) -> Result;\n }\n \n-#[cfg(notest)]\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[lang=\"mul\"]\n+trait Mul<RHS,Result> {\n+    pure fn mul(rhs: &RHS) -> Result;\n+}\n+\n+#[cfg(stage0)]\n #[lang=\"div\"]\n trait Div<RHS,Result> {\n     pure fn div(rhs: RHS) -> Result;\n }\n \n-#[cfg(notest)]\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[lang=\"div\"]\n+trait Div<RHS,Result> {\n+    pure fn div(rhs: &RHS) -> Result;\n+}\n+\n+#[cfg(stage0)]\n #[lang=\"modulo\"]\n trait Modulo<RHS,Result> {\n     pure fn modulo(rhs: RHS) -> Result;\n }\n \n-#[cfg(notest)]\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[lang=\"modulo\"]\n+trait Modulo<RHS,Result> {\n+    pure fn modulo(rhs: &RHS) -> Result;\n+}\n+\n #[lang=\"neg\"]\n trait Neg<Result> {\n     pure fn neg() -> Result;\n }\n \n-#[cfg(notest)]\n+#[cfg(stage0)]\n #[lang=\"bitand\"]\n trait BitAnd<RHS,Result> {\n     pure fn bitand(rhs: RHS) -> Result;\n }\n \n-#[cfg(notest)]\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[lang=\"bitand\"]\n+trait BitAnd<RHS,Result> {\n+    pure fn bitand(rhs: &RHS) -> Result;\n+}\n+\n+#[cfg(stage0)]\n #[lang=\"bitor\"]\n trait BitOr<RHS,Result> {\n     pure fn bitor(rhs: RHS) -> Result;\n }\n \n-#[cfg(notest)]\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[lang=\"bitor\"]\n+trait BitOr<RHS,Result> {\n+    pure fn bitor(rhs: &RHS) -> Result;\n+}\n+\n+#[cfg(stage0)]\n #[lang=\"bitxor\"]\n trait BitXor<RHS,Result> {\n     pure fn bitxor(rhs: RHS) -> Result;\n }\n \n-#[cfg(notest)]\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[lang=\"bitxor\"]\n+trait BitXor<RHS,Result> {\n+    pure fn bitxor(rhs: &RHS) -> Result;\n+}\n+\n+#[cfg(stage0)]\n #[lang=\"shl\"]\n trait Shl<RHS,Result> {\n     pure fn shl(rhs: RHS) -> Result;\n }\n \n-#[cfg(notest)]\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[lang=\"shl\"]\n+trait Shl<RHS,Result> {\n+    pure fn shl(rhs: &RHS) -> Result;\n+}\n+\n+#[cfg(stage0)]\n #[lang=\"shr\"]\n trait Shr<RHS,Result> {\n     pure fn shr(rhs: RHS) -> Result;\n }\n \n-#[cfg(notest)]\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[lang=\"shr\"]\n+trait Shr<RHS,Result> {\n+    pure fn shr(rhs: &RHS) -> Result;\n+}\n+\n #[lang=\"index\"]\n trait Index<Index,Result> {\n     pure fn index(index: Index) -> Result;"}, {"sha": "0844332672a6eb9dc633b511d8a8628a5d3a67db", "filename": "src/libcore/option.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -251,6 +251,7 @@ impl<T: Copy> Option<T> {\n     pure fn while_some(blk: fn(+T) -> Option<T>) { while_some(self, blk) }\n }\n \n+#[cfg(stage0)]\n impl<T: Eq> Option<T> : Eq {\n     pure fn eq(&&other: Option<T>) -> bool {\n         match self {\n@@ -270,6 +271,28 @@ impl<T: Eq> Option<T> : Eq {\n     }\n     pure fn ne(&&other: Option<T>) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<T: Eq> Option<T> : Eq {\n+    pure fn eq(other: &Option<T>) -> bool {\n+        match self {\n+            None => {\n+                match (*other) {\n+                    None => true,\n+                    Some(_) => false\n+                }\n+            }\n+            Some(self_contents) => {\n+                match (*other) {\n+                    None => false,\n+                    Some(ref other_contents) =>\n+                        self_contents.eq(other_contents)\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &Option<T>) -> bool { !self.eq(other) }\n+}\n \n #[test]\n fn test_unwrap_ptr() {"}, {"sha": "331ff57116a262b6aba4415dcebb998dfa30e5f2", "filename": "src/libcore/path.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -70,14 +70,25 @@ impl PosixPath : ToStr {\n     }\n }\n \n+#[cfg(stage0)]\n impl PosixPath : Eq {\n     pure fn eq(&&other: PosixPath) -> bool {\n         return self.is_absolute == other.is_absolute &&\n             self.components == other.components;\n     }\n     pure fn ne(&&other: PosixPath) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl PosixPath : Eq {\n+    pure fn eq(other: &PosixPath) -> bool {\n+        return self.is_absolute == (*other).is_absolute &&\n+            self.components == (*other).components;\n+    }\n+    pure fn ne(other: &PosixPath) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl WindowsPath : Eq {\n     pure fn eq(&&other: WindowsPath) -> bool {\n         return self.host == other.host &&\n@@ -87,6 +98,17 @@ impl WindowsPath : Eq {\n     }\n     pure fn ne(&&other: WindowsPath) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl WindowsPath : Eq {\n+    pure fn eq(other: &WindowsPath) -> bool {\n+        return self.host == (*other).host &&\n+            self.device == (*other).device &&\n+            self.is_absolute == (*other).is_absolute &&\n+            self.components == (*other).components;\n+    }\n+    pure fn ne(other: &WindowsPath) -> bool { !self.eq(other) }\n+}\n \n // FIXME (#3227): when default methods in traits are working, de-duplicate\n // PosixPath and WindowsPath, most of their methods are common."}, {"sha": "3d40358dcc13fd7f6ff4023a345a6806d5e5cb56", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -116,12 +116,21 @@ enum State {\n     Terminated\n }\n \n+#[cfg(stage0)]\n impl State: Eq {\n     pure fn eq(&&other: State) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: State) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl State : Eq {\n+    pure fn eq(other: &State) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &State) -> bool { !self.eq(other) }\n+}\n \n struct BufferHeader {\n     // Tracks whether this buffer needs to be freed. We can probably"}, {"sha": "65cf61ab2bdc6a4d3e7c79efad08c2ab478003b3", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -203,6 +203,7 @@ impl<T> *T: Ptr {\n }\n \n // Equality for pointers\n+#[cfg(stage0)]\n impl<T> *const T : Eq {\n     pure fn eq(&&other: *const T) -> bool unsafe {\n         let a: uint = cast::reinterpret_cast(&self);\n@@ -211,8 +212,19 @@ impl<T> *const T : Eq {\n     }\n     pure fn ne(&&other: *const T) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<T> *const T : Eq {\n+    pure fn eq(other: &*const T) -> bool unsafe {\n+        let a: uint = cast::reinterpret_cast(&self);\n+        let b: uint = cast::reinterpret_cast(&(*other));\n+        return a == b;\n+    }\n+    pure fn ne(other: &*const T) -> bool { !self.eq(other) }\n+}\n \n // Comparison for pointers\n+#[cfg(stage0)]\n impl<T> *const T : Ord {\n     pure fn lt(&&other: *const T) -> bool unsafe {\n         let a: uint = cast::reinterpret_cast(&self);\n@@ -235,20 +247,60 @@ impl<T> *const T : Ord {\n         return a > b;\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<T> *const T : Ord {\n+    pure fn lt(other: &*const T) -> bool unsafe {\n+        let a: uint = cast::reinterpret_cast(&self);\n+        let b: uint = cast::reinterpret_cast(&(*other));\n+        return a < b;\n+    }\n+    pure fn le(other: &*const T) -> bool unsafe {\n+        let a: uint = cast::reinterpret_cast(&self);\n+        let b: uint = cast::reinterpret_cast(&(*other));\n+        return a <= b;\n+    }\n+    pure fn ge(other: &*const T) -> bool unsafe {\n+        let a: uint = cast::reinterpret_cast(&self);\n+        let b: uint = cast::reinterpret_cast(&(*other));\n+        return a >= b;\n+    }\n+    pure fn gt(other: &*const T) -> bool unsafe {\n+        let a: uint = cast::reinterpret_cast(&self);\n+        let b: uint = cast::reinterpret_cast(&(*other));\n+        return a > b;\n+    }\n+}\n \n // Equality for region pointers\n+#[cfg(stage0)]\n impl<T:Eq> &const T : Eq {\n     pure fn eq(&&other: &const T) -> bool { return *self == *other; }\n     pure fn ne(&&other: &const T) -> bool { return *self != *other; }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<T:Eq> &const T : Eq {\n+    pure fn eq(other: & &const T) -> bool { return *self == *(*other); }\n+    pure fn ne(other: & &const T) -> bool { return *self != *(*other); }\n+}\n \n // Comparison for region pointers\n+#[cfg(stage0)]\n impl<T:Ord> &const T : Ord {\n     pure fn lt(&&other: &const T) -> bool { *self < *other }\n     pure fn le(&&other: &const T) -> bool { *self <= *other }\n     pure fn ge(&&other: &const T) -> bool { *self >= *other }\n     pure fn gt(&&other: &const T) -> bool { *self > *other }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<T:Ord> &const T : Ord {\n+    pure fn lt(other: & &const T) -> bool { *self < *(*other) }\n+    pure fn le(other: & &const T) -> bool { *self <= *(*other) }\n+    pure fn ge(other: & &const T) -> bool { *self >= *(*other) }\n+    pure fn gt(other: & &const T) -> bool { *self > *(*other) }\n+}\n \n #[test]\n fn test() {"}, {"sha": "38825c4cb0f8b2ed97fb06b510db2b063bce5d2d", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -510,12 +510,21 @@ enum EnumVisitState {\n     Degenerate      // This is a degenerate enum (exactly 1 variant)\n }\n \n+#[cfg(stage0)]\n impl EnumVisitState : cmp::Eq {\n     pure fn eq(&&other: EnumVisitState) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: EnumVisitState) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl EnumVisitState : cmp::Eq {\n+    pure fn eq(other: &EnumVisitState) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &EnumVisitState) -> bool { !self.eq(other) }\n+}\n \n struct EnumState {\n     end_ptr: *c_void,"}, {"sha": "1b41c37273ebc14e671da06b9ab6a7069b00cc2b", "filename": "src/libcore/result.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -356,6 +356,7 @@ fn unwrap_err<T, U>(+res: Result<T, U>) -> U {\n     }\n }\n \n+#[cfg(stage0)]\n impl<T:Eq,U:Eq> Result<T,U> : Eq {\n     pure fn eq(&&other: Result<T,U>) -> bool {\n         match self {\n@@ -375,6 +376,27 @@ impl<T:Eq,U:Eq> Result<T,U> : Eq {\n     }\n     pure fn ne(&&other: Result<T,U>) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<T:Eq,U:Eq> Result<T,U> : Eq {\n+    pure fn eq(other: &Result<T,U>) -> bool {\n+        match self {\n+            Ok(e0a) => {\n+                match (*other) {\n+                    Ok(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            Err(e0a) => {\n+                match (*other) {\n+                    Err(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &Result<T,U>) -> bool { !self.eq(other) }\n+}\n \n #[cfg(test)]\n #[allow(non_implicitly_copyable_typarams)]"}, {"sha": "6890ef74a6cfaa1eb0cf7a44e6de1d7d5e18301a", "filename": "src/libcore/str.rs", "status": "modified", "additions": 92, "deletions": 5, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -117,7 +117,8 @@ export\n    raw,\n    extensions,\n    StrSlice,\n-   UniqueStr;\n+   UniqueStr,\n+   traits;\n \n /*\n Section: Creating a string\n@@ -793,6 +794,7 @@ pure fn gt(a: &str, b: &str) -> bool {\n     !le(a, b)\n }\n \n+#[cfg(stage0)]\n impl &str: Eq {\n     #[inline(always)]\n     pure fn eq(&&other: &str) -> bool {\n@@ -801,7 +803,18 @@ impl &str: Eq {\n     #[inline(always)]\n     pure fn ne(&&other: &str) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl &str : Eq {\n+    #[inline(always)]\n+    pure fn eq(other: & &str) -> bool {\n+        eq_slice(self, (*other))\n+    }\n+    #[inline(always)]\n+    pure fn ne(other: & &str) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl ~str: Eq {\n     #[inline(always)]\n     pure fn eq(&&other: ~str) -> bool {\n@@ -810,7 +823,18 @@ impl ~str: Eq {\n     #[inline(always)]\n     pure fn ne(&&other: ~str) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl ~str : Eq {\n+    #[inline(always)]\n+    pure fn eq(other: &~str) -> bool {\n+        eq_slice(self, (*other))\n+    }\n+    #[inline(always)]\n+    pure fn ne(other: &~str) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl @str: Eq {\n     #[inline(always)]\n     pure fn eq(&&other: @str) -> bool {\n@@ -819,7 +843,18 @@ impl @str: Eq {\n     #[inline(always)]\n     pure fn ne(&&other: @str) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl @str : Eq {\n+    #[inline(always)]\n+    pure fn eq(other: &@str) -> bool {\n+        eq_slice(self, (*other))\n+    }\n+    #[inline(always)]\n+    pure fn ne(other: &@str) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl ~str : Ord {\n     #[inline(always)]\n     pure fn lt(&&other: ~str) -> bool { lt(self, other) }\n@@ -830,7 +865,20 @@ impl ~str : Ord {\n     #[inline(always)]\n     pure fn gt(&&other: ~str) -> bool { gt(self, other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl ~str : Ord {\n+    #[inline(always)]\n+    pure fn lt(other: &~str) -> bool { lt(self, (*other)) }\n+    #[inline(always)]\n+    pure fn le(other: &~str) -> bool { le(self, (*other)) }\n+    #[inline(always)]\n+    pure fn ge(other: &~str) -> bool { ge(self, (*other)) }\n+    #[inline(always)]\n+    pure fn gt(other: &~str) -> bool { gt(self, (*other)) }\n+}\n \n+#[cfg(stage0)]\n impl &str : Ord {\n     #[inline(always)]\n     pure fn lt(&&other: &str) -> bool { lt(self, other) }\n@@ -841,7 +889,20 @@ impl &str : Ord {\n     #[inline(always)]\n     pure fn gt(&&other: &str) -> bool { gt(self, other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl &str : Ord {\n+    #[inline(always)]\n+    pure fn lt(other: & &str) -> bool { lt(self, (*other)) }\n+    #[inline(always)]\n+    pure fn le(other: & &str) -> bool { le(self, (*other)) }\n+    #[inline(always)]\n+    pure fn ge(other: & &str) -> bool { ge(self, (*other)) }\n+    #[inline(always)]\n+    pure fn gt(other: & &str) -> bool { gt(self, (*other)) }\n+}\n \n+#[cfg(stage0)]\n impl @str : Ord {\n     #[inline(always)]\n     pure fn lt(&&other: @str) -> bool { lt(self, other) }\n@@ -852,6 +913,18 @@ impl @str : Ord {\n     #[inline(always)]\n     pure fn gt(&&other: @str) -> bool { gt(self, other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl @str : Ord {\n+    #[inline(always)]\n+    pure fn lt(other: &@str) -> bool { lt(self, (*other)) }\n+    #[inline(always)]\n+    pure fn le(other: &@str) -> bool { le(self, (*other)) }\n+    #[inline(always)]\n+    pure fn ge(other: &@str) -> bool { ge(self, (*other)) }\n+    #[inline(always)]\n+    pure fn gt(other: &@str) -> bool { gt(self, (*other)) }\n+}\n \n /*\n Section: Iterating through strings\n@@ -2159,13 +2232,27 @@ impl ~str: UniqueStr {\n }\n \n #[cfg(notest)]\n-impl ~str: Add<&str,~str> {\n-    #[inline(always)]\n-    pure fn add(rhs: &str) -> ~str {\n-        append(copy self, rhs)\n+mod traits {\n+    #[cfg(stage0)]\n+    impl ~str: Add<&str,~str> {\n+        #[inline(always)]\n+        pure fn add(rhs: &str) -> ~str {\n+            append(copy self, rhs)\n+        }\n+    }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    impl ~str : Add<&str,~str> {\n+        #[inline(always)]\n+        pure fn add(rhs: & &str) -> ~str {\n+            append(copy self, (*rhs))\n+        }\n     }\n }\n \n+#[cfg(test)]\n+mod traits {}\n+\n trait StrSlice {\n     fn all(it: fn(char) -> bool) -> bool;\n     fn any(it: fn(char) -> bool) -> bool;"}, {"sha": "52775456d10b22a2e92904a666ff9c62de2729d3", "filename": "src/libcore/task.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -83,10 +83,17 @@ enum Task {\n     TaskHandle(task_id)\n }\n \n+#[cfg(stage0)]\n impl Task : cmp::Eq {\n     pure fn eq(&&other: Task) -> bool { *self == *other }\n     pure fn ne(&&other: Task) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Task : cmp::Eq {\n+    pure fn eq(other: &Task) -> bool { *self == *(*other) }\n+    pure fn ne(other: &Task) -> bool { !self.eq(other) }\n+}\n \n /**\n  * Indicates the manner in which a task exited.\n@@ -104,6 +111,7 @@ enum TaskResult {\n     Failure,\n }\n \n+#[cfg(stage0)]\n impl TaskResult: Eq {\n     pure fn eq(&&other: TaskResult) -> bool {\n         match (self, other) {\n@@ -113,13 +121,25 @@ impl TaskResult: Eq {\n     }\n     pure fn ne(&&other: TaskResult) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl TaskResult : Eq {\n+    pure fn eq(other: &TaskResult) -> bool {\n+        match (self, (*other)) {\n+            (Success, Success) | (Failure, Failure) => true,\n+            (Success, _) | (Failure, _) => false\n+        }\n+    }\n+    pure fn ne(other: &TaskResult) -> bool { !self.eq(other) }\n+}\n \n /// A message type for notifying of task lifecycle events\n enum Notification {\n     /// Sent when a task exits with the task handle and result\n     Exit(Task, TaskResult)\n }\n \n+#[cfg(stage0)]\n impl Notification : cmp::Eq {\n     pure fn eq(&&other: Notification) -> bool {\n         match self {\n@@ -132,6 +152,20 @@ impl Notification : cmp::Eq {\n     }\n     pure fn ne(&&other: Notification) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Notification : cmp::Eq {\n+    pure fn eq(other: &Notification) -> bool {\n+        match self {\n+            Exit(e0a, e1a) => {\n+                match (*other) {\n+                    Exit(e0b, e1b) => e0a == e0b && e1a == e1b\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &Notification) -> bool { !self.eq(other) }\n+}\n \n /// Scheduler modes\n enum SchedMode {\n@@ -152,6 +186,7 @@ enum SchedMode {\n     PlatformThread\n }\n \n+#[cfg(stage0)]\n impl SchedMode : cmp::Eq {\n     pure fn eq(&&other: SchedMode) -> bool {\n         match self {\n@@ -191,6 +226,47 @@ impl SchedMode : cmp::Eq {\n         !self.eq(other)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl SchedMode : cmp::Eq {\n+    pure fn eq(other: &SchedMode) -> bool {\n+        match self {\n+            SingleThreaded => {\n+                match (*other) {\n+                    SingleThreaded => true,\n+                    _ => false\n+                }\n+            }\n+            ThreadPerCore => {\n+                match (*other) {\n+                    ThreadPerCore => true,\n+                    _ => false\n+                }\n+            }\n+            ThreadPerTask => {\n+                match (*other) {\n+                    ThreadPerTask => true,\n+                    _ => false\n+                }\n+            }\n+            ManualThreads(e0a) => {\n+                match (*other) {\n+                    ManualThreads(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            PlatformThread => {\n+                match (*other) {\n+                    PlatformThread => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &SchedMode) -> bool {\n+        !self.eq(other)\n+    }\n+}\n \n /**\n  * Scheduler configuration options"}, {"sha": "b4a9301ca0b0488fde9fe98d161c6f9e1edc1fab", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -6,6 +6,7 @@ use rt::rust_task;\n trait LocalData { }\n impl<T: Owned> @T: LocalData { }\n \n+#[cfg(stage0)]\n impl LocalData: Eq {\n     pure fn eq(&&other: LocalData) -> bool unsafe {\n         let ptr_a: (uint, uint) = cast::reinterpret_cast(&self);\n@@ -14,6 +15,16 @@ impl LocalData: Eq {\n     }\n     pure fn ne(&&other: LocalData) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl LocalData: Eq {\n+    pure fn eq(other: &@LocalData) -> bool unsafe {\n+        let ptr_a: (uint, uint) = cast::reinterpret_cast(&self);\n+        let ptr_b: (uint, uint) = cast::reinterpret_cast(other);\n+        return ptr_a == ptr_b;\n+    }\n+    pure fn ne(other: &@LocalData) -> bool { !self.eq(other) }\n+}\n \n // We use dvec because it's the best data structure in core. If TLS is used\n // heavily in future, this could be made more efficient with a proper map."}, {"sha": "0159a0fd615b13761cb3c5fa54ea955d8e0469d8", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -67,6 +67,7 @@ impl<A: Copy, B: Copy> (~[A], ~[B]): ExtendedTupleOps<A,B> {\n     }\n }\n \n+#[cfg(stage0)]\n impl<A: Eq, B: Eq> (A, B): Eq {\n     pure fn eq(&&other: (A, B)) -> bool {\n         // XXX: This would be a lot less wordy with ref bindings, but I don't\n@@ -83,7 +84,26 @@ impl<A: Eq, B: Eq> (A, B): Eq {\n     }\n     pure fn ne(&&other: (A, B)) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<A: Eq, B: Eq> (A, B) : Eq {\n+    pure fn eq(other: &(A, B)) -> bool {\n+        // XXX: This would be a lot less wordy with ref bindings, but I don't\n+        // trust that they work yet.\n+        match self {\n+            (self_a, self_b) => {\n+                match (*other) {\n+                    (ref other_a, ref other_b) => {\n+                        self_a.eq(other_a) && self_b.eq(other_b)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &(A, B)) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl<A: Ord, B: Ord> (A, B): Ord {\n     pure fn lt(&&other: (A, B)) -> bool {\n         match self {\n@@ -103,7 +123,29 @@ impl<A: Ord, B: Ord> (A, B): Ord {\n     pure fn ge(&&other: (A, B)) -> bool { !self.lt(other) }\n     pure fn gt(&&other: (A, B)) -> bool { other.lt(self)  }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<A: Ord, B: Ord> (A, B) : Ord {\n+    pure fn lt(other: &(A, B)) -> bool {\n+        match self {\n+            (ref self_a, ref self_b) => {\n+                match (*other) {\n+                    (ref other_a, ref other_b) => {\n+                        if (*self_a).lt(other_a) { return true; }\n+                        if (*other_a).lt(self_a) { return false; }\n+                        if (*self_b).lt(other_b) { return true; }\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    pure fn le(other: &(A, B)) -> bool { !(*other).lt(&self) }\n+    pure fn ge(other: &(A, B)) -> bool { !self.lt(other) }\n+    pure fn gt(other: &(A, B)) -> bool { (*other).lt(&self)  }\n+}\n \n+#[cfg(stage0)]\n impl<A: Eq, B: Eq, C: Eq> (A, B, C): Eq {\n     pure fn eq(&&other: (A, B, C)) -> bool {\n         // XXX: This would be a lot less wordy with ref bindings, but I don't\n@@ -122,7 +164,28 @@ impl<A: Eq, B: Eq, C: Eq> (A, B, C): Eq {\n     }\n     pure fn ne(&&other: (A, B, C)) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<A: Eq, B: Eq, C: Eq> (A, B, C) : Eq {\n+    pure fn eq(other: &(A, B, C)) -> bool {\n+        // XXX: This would be a lot less wordy with ref bindings, but I don't\n+        // trust that they work yet.\n+        match self {\n+            (self_a, self_b, self_c) => {\n+                match (*other) {\n+                    (ref other_a, ref other_b, ref other_c) => {\n+                        self_a.eq(other_a) &&\n+                        self_b.eq(other_b) &&\n+                        self_c.eq(other_c)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &(A, B, C)) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl<A: Ord, B: Ord, C: Ord> (A, B, C): Ord {\n     pure fn lt(&&other: (A, B, C)) -> bool {\n         match self {\n@@ -144,6 +207,29 @@ impl<A: Ord, B: Ord, C: Ord> (A, B, C): Ord {\n     pure fn ge(&&other: (A, B, C)) -> bool { !self.lt(other) }\n     pure fn gt(&&other: (A, B, C)) -> bool { other.lt(self)  }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<A: Ord, B: Ord, C: Ord> (A, B, C) : Ord {\n+    pure fn lt(other: &(A, B, C)) -> bool {\n+        match self {\n+            (ref self_a, ref self_b, ref self_c) => {\n+                match (*other) {\n+                    (ref other_a, ref other_b, ref other_c) => {\n+                        if (*self_a).lt(other_a) { return true; }\n+                        if (*other_a).lt(self_a) { return false; }\n+                        if (*self_b).lt(other_b) { return true; }\n+                        if (*other_b).lt(self_b) { return false; }\n+                        if (*self_c).lt(other_c) { return true; }\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    pure fn le(other: &(A, B, C)) -> bool { !(*other).lt(&self) }\n+    pure fn ge(other: &(A, B, C)) -> bool { !self.lt(other) }\n+    pure fn gt(other: &(A, B, C)) -> bool { (*other).lt(&self)  }\n+}\n \n #[test]\n #[allow(non_implicitly_copyable_typarams)]"}, {"sha": "a0fd5f58a19fdc3e81d18eb45a7b7a44bfeff3d5", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -61,17 +61,33 @@ pure fn compl(i: T) -> T {\n     max_value ^ i\n }\n \n+#[cfg(stage0)]\n impl T: Ord {\n     pure fn lt(&&other: T) -> bool { self < other }\n     pure fn le(&&other: T) -> bool { self <= other }\n     pure fn ge(&&other: T) -> bool { self >= other }\n     pure fn gt(&&other: T) -> bool { self > other }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl T : Ord {\n+    pure fn lt(other: &T) -> bool { self < (*other) }\n+    pure fn le(other: &T) -> bool { self <= (*other) }\n+    pure fn ge(other: &T) -> bool { self >= (*other) }\n+    pure fn gt(other: &T) -> bool { self > (*other) }\n+}\n \n+#[cfg(stage0)]\n impl T: Eq {\n     pure fn eq(&&other: T) -> bool { return self == other; }\n     pure fn ne(&&other: T) -> bool { return self != other; }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl T : Eq {\n+    pure fn eq(other: &T) -> bool { return self == (*other); }\n+    pure fn ne(other: &T) -> bool { return self != (*other); }\n+}\n \n impl T: num::Num {\n     pure fn add(&&other: T)    -> T { return self + other; }"}, {"sha": "f1842686ae15e3a177c9264e872d3fc53cde3da3", "filename": "src/libcore/uniq.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funiq.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -2,15 +2,31 @@\n \n use cmp::{Eq, Ord};\n \n+#[cfg(stage0)]\n impl<T:Eq> ~const T : Eq {\n     pure fn eq(&&other: ~const T) -> bool { *self == *other }\n     pure fn ne(&&other: ~const T) -> bool { *self != *other }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<T:Eq> ~const T : Eq {\n+    pure fn eq(other: &~const T) -> bool { *self == *(*other) }\n+    pure fn ne(other: &~const T) -> bool { *self != *(*other) }\n+}\n \n+#[cfg(stage0)]\n impl<T:Ord> ~const T : Ord {\n     pure fn lt(&&other: ~const T) -> bool { *self < *other }\n     pure fn le(&&other: ~const T) -> bool { *self <= *other }\n     pure fn ge(&&other: ~const T) -> bool { *self >= *other }\n     pure fn gt(&&other: ~const T) -> bool { *self > *other }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<T:Ord> ~const T : Ord {\n+    pure fn lt(other: &~const T) -> bool { *self < *(*other) }\n+    pure fn le(other: &~const T) -> bool { *self <= *(*other) }\n+    pure fn ge(other: &~const T) -> bool { *self >= *(*other) }\n+    pure fn gt(other: &~const T) -> bool { *self > *(*other) }\n+}\n "}, {"sha": "30f1f5ab99c22e5db16d4fa4e76198dcc800d1fc", "filename": "src/libcore/unit.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Funit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Funit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funit.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -6,15 +6,31 @@ Functions for the unit type.\n \n use cmp::{Eq, Ord};\n \n+#[cfg(stage0)]\n impl () : Eq {\n     pure fn eq(&&_other: ()) -> bool { true }\n     pure fn ne(&&_other: ()) -> bool { false }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl () : Eq {\n+    pure fn eq(_other: &()) -> bool { true }\n+    pure fn ne(_other: &()) -> bool { false }\n+}\n \n+#[cfg(stage0)]\n impl () : Ord {\n     pure fn lt(&&_other: ()) -> bool { false }\n     pure fn le(&&_other: ()) -> bool { true }\n     pure fn ge(&&_other: ()) -> bool { true }\n     pure fn gt(&&_other: ()) -> bool { false }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl () : Ord {\n+    pure fn lt(_other: &()) -> bool { false }\n+    pure fn le(_other: &()) -> bool { true }\n+    pure fn ge(_other: &()) -> bool { true }\n+    pure fn gt(_other: &()) -> bool { false }\n+}\n "}, {"sha": "679ed13d1db75cc589a9e8d9c7628817b5c79800", "filename": "src/libcore/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -71,7 +71,7 @@ mod tests {\n         let x = ~[(5, false)];\n         //FIXME #3387 assert x.eq(id(copy x));\n         let y = copy x;\n-        assert x.eq(id(y));\n+        assert x.eq(&id(y));\n     }\n     #[test]\n     fn test_swap() {"}, {"sha": "c9f69e6b21f9dccf6df03badfd32f91b4a844978", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 100, "deletions": 9, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -93,6 +93,7 @@ export ImmutableEqVector;\n export ImmutableCopyableVector;\n export IterTraitExtensions;\n export vec_concat;\n+export traits;\n \n #[abi = \"cdecl\"]\n extern mod rustrt {\n@@ -1391,26 +1392,53 @@ pure fn eq<T: Eq>(a: &[T], b: &[T]) -> bool {\n     return true;\n }\n \n+#[cfg(stage0)]\n impl<T: Eq> &[T]: Eq {\n     #[inline(always)]\n     pure fn eq(&&other: &[T]) -> bool { eq(self, other) }\n     #[inline(always)]\n     pure fn ne(&&other: &[T]) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<T: Eq> &[T] : Eq {\n+    #[inline(always)]\n+    pure fn eq(other: & &[T]) -> bool { eq(self, (*other)) }\n+    #[inline(always)]\n+    pure fn ne(other: & &[T]) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl<T: Eq> ~[T]: Eq {\n     #[inline(always)]\n     pure fn eq(&&other: ~[T]) -> bool { eq(self, other) }\n     #[inline(always)]\n     pure fn ne(&&other: ~[T]) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<T: Eq> ~[T] : Eq {\n+    #[inline(always)]\n+    pure fn eq(other: &~[T]) -> bool { eq(self, (*other)) }\n+    #[inline(always)]\n+    pure fn ne(other: &~[T]) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl<T: Eq> @[T]: Eq {\n     #[inline(always)]\n     pure fn eq(&&other: @[T]) -> bool { eq(self, other) }\n     #[inline(always)]\n     pure fn ne(&&other: @[T]) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<T: Eq> @[T] : Eq {\n+    #[inline(always)]\n+    pure fn eq(other: &@[T]) -> bool { eq(self, (*other)) }\n+    #[inline(always)]\n+    pure fn ne(other: &@[T]) -> bool { !self.eq(other) }\n+}\n \n // Lexicographical comparison\n \n@@ -1433,6 +1461,7 @@ pure fn le<T: Ord>(a: &[T], b: &[T]) -> bool { !lt(b, a) }\n pure fn ge<T: Ord>(a: &[T], b: &[T]) -> bool { !lt(a, b) }\n pure fn gt<T: Ord>(a: &[T], b: &[T]) -> bool { lt(b, a)  }\n \n+#[cfg(stage0)]\n impl<T: Ord> &[T]: Ord {\n     #[inline(always)]\n     pure fn lt(&&other: &[T]) -> bool { lt(self, other) }\n@@ -1443,7 +1472,20 @@ impl<T: Ord> &[T]: Ord {\n     #[inline(always)]\n     pure fn gt(&&other: &[T]) -> bool { gt(self, other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<T: Ord> &[T] : Ord {\n+    #[inline(always)]\n+    pure fn lt(other: & &[T]) -> bool { lt(self, (*other)) }\n+    #[inline(always)]\n+    pure fn le(other: & &[T]) -> bool { le(self, (*other)) }\n+    #[inline(always)]\n+    pure fn ge(other: & &[T]) -> bool { ge(self, (*other)) }\n+    #[inline(always)]\n+    pure fn gt(other: & &[T]) -> bool { gt(self, (*other)) }\n+}\n \n+#[cfg(stage0)]\n impl<T: Ord> ~[T]: Ord {\n     #[inline(always)]\n     pure fn lt(&&other: ~[T]) -> bool { lt(self, other) }\n@@ -1454,7 +1496,20 @@ impl<T: Ord> ~[T]: Ord {\n     #[inline(always)]\n     pure fn gt(&&other: ~[T]) -> bool { gt(self, other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<T: Ord> ~[T] : Ord {\n+    #[inline(always)]\n+    pure fn lt(other: &~[T]) -> bool { lt(self, (*other)) }\n+    #[inline(always)]\n+    pure fn le(other: &~[T]) -> bool { le(self, (*other)) }\n+    #[inline(always)]\n+    pure fn ge(other: &~[T]) -> bool { ge(self, (*other)) }\n+    #[inline(always)]\n+    pure fn gt(other: &~[T]) -> bool { gt(self, (*other)) }\n+}\n \n+#[cfg(stage0)]\n impl<T: Ord> @[T]: Ord {\n     #[inline(always)]\n     pure fn lt(&&other: @[T]) -> bool { lt(self, other) }\n@@ -1465,22 +1520,58 @@ impl<T: Ord> @[T]: Ord {\n     #[inline(always)]\n     pure fn gt(&&other: @[T]) -> bool { gt(self, other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<T: Ord> @[T] : Ord {\n+    #[inline(always)]\n+    pure fn lt(other: &@[T]) -> bool { lt(self, (*other)) }\n+    #[inline(always)]\n+    pure fn le(other: &@[T]) -> bool { le(self, (*other)) }\n+    #[inline(always)]\n+    pure fn ge(other: &@[T]) -> bool { ge(self, (*other)) }\n+    #[inline(always)]\n+    pure fn gt(other: &@[T]) -> bool { gt(self, (*other)) }\n+}\n \n #[cfg(notest)]\n-impl<T: Copy> ~[T]: Add<&[const T],~[T]> {\n-    #[inline(always)]\n-    pure fn add(rhs: &[const T]) -> ~[T] {\n-        append(copy self, rhs)\n+mod traits {\n+    #[cfg(stage0)]\n+    impl<T: Copy> ~[T]: Add<&[const T],~[T]> {\n+        #[inline(always)]\n+        pure fn add(rhs: &[const T]) -> ~[T] {\n+            append(copy self, rhs)\n+        }\n     }\n-}\n \n-impl<T: Copy> ~[mut T]: Add<&[const T],~[mut T]> {\n-    #[inline(always)]\n-    pure fn add(rhs: &[const T]) -> ~[mut T] {\n-        append_mut(self, rhs)\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    impl<T: Copy> ~[T] : Add<&[const T],~[T]> {\n+        #[inline(always)]\n+        pure fn add(rhs: & &[const T]) -> ~[T] {\n+            append(copy self, (*rhs))\n+        }\n+    }\n+\n+    #[cfg(stage0)]\n+    impl<T: Copy> ~[mut T]: Add<&[const T],~[mut T]> {\n+        #[inline(always)]\n+        pure fn add(rhs: &[const T]) -> ~[mut T] {\n+            append_mut(self, rhs)\n+        }\n+    }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    impl<T: Copy> ~[mut T] : Add<&[const T],~[mut T]> {\n+        #[inline(always)]\n+        pure fn add(rhs: & &[const T]) -> ~[mut T] {\n+            append_mut(self, (*rhs))\n+        }\n     }\n }\n \n+#[cfg(test)]\n+mod traits {}\n+\n trait ConstVector {\n     pure fn is_empty() -> bool;\n     pure fn is_not_empty() -> bool;"}, {"sha": "35b147e1940117fc9d97807f1879ea3edc8d4d55", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -239,6 +239,7 @@ mod tests {\n \n     type RecCy = {x: int, y: int, t: Taggy};\n \n+#[cfg(stage0)]\n     impl Taggy : Eq {\n         pure fn eq(other: Taggy) -> bool {\n             match self {\n@@ -258,7 +259,29 @@ mod tests {\n         }\n         pure fn ne(other: Taggy) -> bool { !self.eq(other) }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    impl Taggy : Eq {\n+        pure fn eq(other: &Taggy) -> bool {\n+            match self {\n+              One(a1) => match (*other) {\n+                One(b1) => return a1 == b1,\n+                _ => return false\n+              },\n+              Two(a1, a2) => match (*other) {\n+                Two(b1, b2) => return a1 == b1 && a2 == b2,\n+                _ => return false\n+              },\n+              Three(a1, a2, a3) => match (*other) {\n+                Three(b1, b2, b3) => return a1 == b1 && a2 == b2 && a3 == b3,\n+                _ => return false\n+              }\n+            }\n+        }\n+        pure fn ne(other: &Taggy) -> bool { !self.eq(other) }\n+    }\n \n+#[cfg(stage0)]\n     impl Taggypar<int> : Eq {\n         //let eq4: EqFn<Taggypar<int>> = |x,y| taggypareq::<int>(x, y);\n         pure fn eq(other: Taggypar<int>) -> bool {\n@@ -281,13 +304,47 @@ mod tests {\n         }\n         pure fn ne(other: Taggypar<int>) -> bool { !self.eq(other) }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    impl Taggypar<int> : Eq {\n+        //let eq4: EqFn<Taggypar<int>> = |x,y| taggypareq::<int>(x, y);\n+        pure fn eq(other: &Taggypar<int>) -> bool {\n+                  match self {\n+                    Onepar::<int>(a1) => match (*other) {\n+                      Onepar::<int>(b1) => return a1 == b1,\n+                      _ => return false\n+                    },\n+                    Twopar::<int>(a1, a2) => match (*other) {\n+                      Twopar::<int>(b1, b2) => return a1 == b1 && a2 == b2,\n+                      _ => return false\n+                    },\n+                    Threepar::<int>(a1, a2, a3) => match (*other) {\n+                      Threepar::<int>(b1, b2, b3) => {\n+                          return a1 == b1 && a2 == b2 && a3 == b3\n+                      }\n+                      _ => return false\n+                    }\n+                  }\n+        }\n+        pure fn ne(other: &Taggypar<int>) -> bool { !self.eq(other) }\n+    }\n \n+#[cfg(stage0)]\n     impl RecCy : Eq {\n         pure fn eq(other: RecCy) -> bool {\n           return self.x == other.x && self.y == other.y && self.t == other.t;\n         }\n         pure fn ne(other: RecCy) -> bool { !self.eq(other) }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    impl RecCy : Eq {\n+        pure fn eq(other: &RecCy) -> bool {\n+          return self.x == (*other).x && self.y == (*other).y &&\n+                 self.t == (*other).t;\n+        }\n+        pure fn ne(other: &RecCy) -> bool { !self.eq(other) }\n+    }\n \n     #[test]\n     fn test_param_int() {"}, {"sha": "4a071dea8798854078a95f0b1c4d38c9eb55a5a1", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -107,6 +107,7 @@ fn mkname(nm: &str) -> Name {\n         } else { Long(unm) };\n }\n \n+#[cfg(stage0)]\n impl Name : Eq {\n     pure fn eq(&&other: Name) -> bool {\n         match self {\n@@ -126,13 +127,43 @@ impl Name : Eq {\n     }\n     pure fn ne(&&other: Name) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Name : Eq {\n+    pure fn eq(other: &Name) -> bool {\n+        match self {\n+            Long(e0a) => {\n+                match (*other) {\n+                    Long(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            Short(e0a) => {\n+                match (*other) {\n+                    Short(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &Name) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl Occur : Eq {\n     pure fn eq(&&other: Occur) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: Occur) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Occur : Eq {\n+    pure fn eq(other: &Occur) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &Occur) -> bool { !self.eq(other) }\n+}\n \n /// Create an option that is required and takes an argument\n fn reqopt(name: &str) -> Opt {\n@@ -447,12 +478,21 @@ enum FailType {\n     UnexpectedArgument_,\n }\n \n+#[cfg(stage0)]\n impl FailType : Eq {\n     pure fn eq(&&other: FailType) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: FailType) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl FailType : Eq {\n+    pure fn eq(other: &FailType) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &FailType) -> bool { !self.eq(other) }\n+}\n \n #[cfg(test)]\n mod tests {"}, {"sha": "79fee39a702598f9de2ba2834a2d21a556bc3e7b", "filename": "src/libstd/json.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -676,6 +676,7 @@ pure fn lt(value0: Json, value1: Json) -> bool {\n     }\n }\n \n+#[cfg(stage0)]\n impl Error : Eq {\n     pure fn eq(&&other: Error) -> bool {\n         self.line == other.line &&\n@@ -684,18 +685,44 @@ impl Error : Eq {\n     }\n     pure fn ne(&&other: Error) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Error : Eq {\n+    pure fn eq(other: &Error) -> bool {\n+        self.line == (*other).line &&\n+        self.col == (*other).col &&\n+        self.msg == (*other).msg\n+    }\n+    pure fn ne(other: &Error) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl Json : Eq {\n     pure fn eq(&&other: Json) -> bool { eq(self, other) }\n     pure fn ne(&&other: Json) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Json : Eq {\n+    pure fn eq(other: &Json) -> bool { eq(self, (*other)) }\n+    pure fn ne(other: &Json) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl Json : Ord {\n     pure fn lt(&&other: Json) -> bool { lt(self, other) }\n     pure fn le(&&other: Json) -> bool { !other.lt(self) }\n     pure fn ge(&&other: Json) -> bool { !self.lt(other) }\n     pure fn gt(&&other: Json) -> bool { other.lt(self)  }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Json : Ord {\n+    pure fn lt(other: &Json) -> bool { lt(self, (*other))  }\n+    pure fn le(other: &Json) -> bool { !(*other).lt(&self) }\n+    pure fn ge(other: &Json) -> bool { !self.lt(other)     }\n+    pure fn gt(other: &Json) -> bool { (*other).lt(&self)  }\n+}\n \n trait ToJson { fn to_json() -> Json; }\n "}, {"sha": "a9c5e1b0e771e6f31fcfdaab8f82078d44921f4a", "filename": "src/libstd/list.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -148,6 +148,7 @@ fn each<T>(l: @List<T>, f: fn(T) -> bool) {\n     }\n }\n \n+#[cfg(stage0)]\n impl<T:Eq> List<T> : Eq {\n     pure fn eq(&&other: List<T>) -> bool {\n         match self {\n@@ -167,6 +168,27 @@ impl<T:Eq> List<T> : Eq {\n     }\n     pure fn ne(&&other: List<T>) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<T:Eq> List<T> : Eq {\n+    pure fn eq(other: &List<T>) -> bool {\n+        match self {\n+            Cons(e0a, e1a) => {\n+                match (*other) {\n+                    Cons(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            Nil => {\n+                match (*other) {\n+                    Nil => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &List<T>) -> bool { !self.eq(other) }\n+}\n \n #[cfg(test)]\n mod tests {"}, {"sha": "b56d8471fbf695d1bdfa5b93d9bc9424bf7297db", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -317,12 +317,21 @@ fn userinfo_to_str(+userinfo: UserInfo) -> ~str {\n     }\n }\n \n+#[cfg(stage0)]\n impl UserInfo : Eq {\n     pure fn eq(&&other: UserInfo) -> bool {\n         self.user == other.user && self.pass == other.pass\n     }\n     pure fn ne(&&other: UserInfo) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl UserInfo : Eq {\n+    pure fn eq(other: &UserInfo) -> bool {\n+        self.user == (*other).user && self.pass == (*other).pass\n+    }\n+    pure fn ne(other: &UserInfo) -> bool { !self.eq(other) }\n+}\n \n fn query_from_str(rawquery: &str) -> Query {\n     let mut query: Query = ~[];\n@@ -377,6 +386,7 @@ enum Input {\n     Unreserved // all other legal characters\n }\n \n+#[cfg(stage0)]\n impl Input: Eq {\n     pure fn eq(&&other: Input) -> bool {\n         match (self, other) {\n@@ -390,6 +400,21 @@ impl Input: Eq {\n     }\n     pure fn ne(&&other: Input) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Input : Eq {\n+    pure fn eq(other: &Input) -> bool {\n+        match (self, (*other)) {\n+            (Digit, Digit) => true,\n+            (Hex, Hex) => true,\n+            (Unreserved, Unreserved) => true,\n+            (Digit, _) => false,\n+            (Hex, _) => false,\n+            (Unreserved, _) => false\n+        }\n+    }\n+    pure fn ne(other: &Input) -> bool { !self.eq(other) }\n+}\n \n // returns userinfo, host, port, and unparsed part, or an error\n fn get_authority(rawurl: &str) ->\n@@ -719,6 +744,7 @@ impl Url: to_str::ToStr {\n     }\n }\n \n+#[cfg(stage0)]\n impl Url: Eq {\n     pure fn eq(&&other: Url) -> bool {\n         self.scheme == other.scheme\n@@ -734,6 +760,23 @@ impl Url: Eq {\n         !self.eq(other)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Url : Eq {\n+    pure fn eq(other: &Url) -> bool {\n+        self.scheme == (*other).scheme\n+            && self.user == (*other).user\n+            && self.host == (*other).host\n+            && self.port == (*other).port\n+            && self.path == (*other).path\n+            && self.query == (*other).query\n+            && self.fragment == (*other).fragment\n+    }\n+\n+    pure fn ne(other: &Url) -> bool {\n+        !self.eq(other)\n+    }\n+}\n \n impl Url: IterBytes {\n     pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {"}, {"sha": "29d97a8918dee01876aa631676547f12e3aa36a0", "filename": "src/libstd/test.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -95,12 +95,21 @@ fn parse_opts(args: &[~str]) -> OptRes {\n \n enum TestResult { TrOk, TrFailed, TrIgnored, }\n \n+#[cfg(stage0)]\n impl TestResult : Eq {\n     pure fn eq(&&other: TestResult) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: TestResult) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl TestResult : Eq {\n+    pure fn eq(other: &TestResult) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &TestResult) -> bool { !self.eq(other) }\n+}\n \n type ConsoleTestState =\n     @{out: io::Writer,"}, {"sha": "f984f1b733f1466631b7bb99bae88d5ada30c021", "filename": "src/libstd/time.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -36,12 +36,21 @@ extern mod rustrt {\n /// A record specifying a time value in seconds and nanoseconds.\n type Timespec = {sec: i64, nsec: i32};\n \n+#[cfg(stage0)]\n impl Timespec : Eq {\n     pure fn eq(&&other: Timespec) -> bool {\n         self.sec == other.sec && self.nsec == other.nsec\n     }\n     pure fn ne(&&other: Timespec) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Timespec : Eq {\n+    pure fn eq(other: &Timespec) -> bool {\n+        self.sec == (*other).sec && self.nsec == (*other).nsec\n+    }\n+    pure fn ne(other: &Timespec) -> bool { !self.eq(other) }\n+}\n \n /**\n  * Returns the current time as a `timespec` containing the seconds and\n@@ -91,6 +100,7 @@ type Tm_ = {\n     tm_nsec: i32, // nanoseconds\n };\n \n+#[cfg(stage0)]\n impl Tm_ : Eq {\n     pure fn eq(&&other: Tm_) -> bool {\n         self.tm_sec == other.tm_sec &&\n@@ -108,15 +118,41 @@ impl Tm_ : Eq {\n     }\n     pure fn ne(&&other: Tm_) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Tm_ : Eq {\n+    pure fn eq(other: &Tm_) -> bool {\n+        self.tm_sec == (*other).tm_sec &&\n+        self.tm_min == (*other).tm_min &&\n+        self.tm_hour == (*other).tm_hour &&\n+        self.tm_mday == (*other).tm_mday &&\n+        self.tm_mon == (*other).tm_mon &&\n+        self.tm_year == (*other).tm_year &&\n+        self.tm_wday == (*other).tm_wday &&\n+        self.tm_yday == (*other).tm_yday &&\n+        self.tm_isdst == (*other).tm_isdst &&\n+        self.tm_gmtoff == (*other).tm_gmtoff &&\n+        self.tm_zone == (*other).tm_zone &&\n+        self.tm_nsec == (*other).tm_nsec\n+    }\n+    pure fn ne(other: &Tm_) -> bool { !self.eq(other) }\n+}\n \n enum Tm {\n     Tm_(Tm_)\n }\n \n+#[cfg(stage0)]\n impl Tm : Eq {\n     pure fn eq(&&other: Tm) -> bool { *self == *other }\n     pure fn ne(&&other: Tm) -> bool { *self != *other }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Tm : Eq {\n+    pure fn eq(other: &Tm) -> bool { *self == *(*other) }\n+    pure fn ne(other: &Tm) -> bool { *self != *(*other) }\n+}\n \n fn empty_tm() -> Tm {\n     Tm_({"}, {"sha": "3f41c03b927d1cb025d269f69fa07f95f1b54ab2", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 581, "deletions": 0, "changes": 581, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -81,12 +81,21 @@ type node_id = int;\n #[auto_serialize]\n type def_id = {crate: crate_num, node: node_id};\n \n+#[cfg(stage0)]\n impl def_id: cmp::Eq {\n     pure fn eq(&&other: def_id) -> bool {\n         self.crate == other.crate && self.node == other.node\n     }\n     pure fn ne(&&other: def_id) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl def_id : cmp::Eq {\n+    pure fn eq(other: &def_id) -> bool {\n+        self.crate == (*other).crate && self.node == (*other).node\n+    }\n+    pure fn ne(other: &def_id) -> bool { !self.eq(other) }\n+}\n \n const local_crate: crate_num = 0;\n const crate_node_id: node_id = 0;\n@@ -129,6 +138,7 @@ enum def {\n     def_label(node_id)\n }\n \n+#[cfg(stage0)]\n impl def : cmp::Eq {\n     pure fn eq(&&other: def) -> bool {\n         match self {\n@@ -251,6 +261,130 @@ impl def : cmp::Eq {\n     }\n     pure fn ne(&&other: def) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl def : cmp::Eq {\n+    pure fn eq(other: &def) -> bool {\n+        match self {\n+            def_fn(e0a, e1a) => {\n+                match (*other) {\n+                    def_fn(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            def_static_method(e0a, e1a) => {\n+                match (*other) {\n+                    def_static_method(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            def_self(e0a) => {\n+                match (*other) {\n+                    def_self(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            def_mod(e0a) => {\n+                match (*other) {\n+                    def_mod(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            def_foreign_mod(e0a) => {\n+                match (*other) {\n+                    def_foreign_mod(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            def_const(e0a) => {\n+                match (*other) {\n+                    def_const(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            def_arg(e0a, e1a) => {\n+                match (*other) {\n+                    def_arg(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            def_local(e0a, e1a) => {\n+                match (*other) {\n+                    def_local(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            def_variant(e0a, e1a) => {\n+                match (*other) {\n+                    def_variant(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            def_ty(e0a) => {\n+                match (*other) {\n+                    def_ty(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            def_prim_ty(e0a) => {\n+                match (*other) {\n+                    def_prim_ty(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            def_ty_param(e0a, e1a) => {\n+                match (*other) {\n+                    def_ty_param(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            def_binding(e0a, e1a) => {\n+                match (*other) {\n+                    def_binding(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            def_use(e0a) => {\n+                match (*other) {\n+                    def_use(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            def_upvar(e0a, e1a, e2a, e3a) => {\n+                match (*other) {\n+                    def_upvar(e0b, e1b, e2b, e3b) =>\n+                        e0a == e0b && e1a == e1b && e2a == e2b && e3a == e3b,\n+                    _ => false\n+                }\n+            }\n+            def_class(e0a, e1a) => {\n+                match (*other) {\n+                    def_class(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            def_typaram_binder(e0a) => {\n+                match (*other) {\n+                    def_typaram_binder(e1a) => e0a == e1a,\n+                    _ => false\n+                }\n+            }\n+            def_region(e0a) => {\n+                match (*other) {\n+                    def_region(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            def_label(e0a) => {\n+                match (*other) {\n+                    def_label(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &def) -> bool { !self.eq(other) }\n+}\n \n // The set of meta_items that define the compilation environment of the crate,\n // used to drive conditional compilation\n@@ -330,6 +464,7 @@ impl binding_mode : to_bytes::IterBytes {\n     }\n }\n \n+#[cfg(stage0)]\n impl binding_mode : cmp::Eq {\n     pure fn eq(&&other: binding_mode) -> bool {\n         match self {\n@@ -361,6 +496,39 @@ impl binding_mode : cmp::Eq {\n     }\n     pure fn ne(&&other: binding_mode) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl binding_mode : cmp::Eq {\n+    pure fn eq(other: &binding_mode) -> bool {\n+        match self {\n+            bind_by_value => {\n+                match (*other) {\n+                    bind_by_value => true,\n+                    _ => false\n+                }\n+            }\n+            bind_by_move => {\n+                match (*other) {\n+                    bind_by_move => true,\n+                    _ => false\n+                }\n+            }\n+            bind_by_ref(e0a) => {\n+                match (*other) {\n+                    bind_by_ref(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            bind_by_implicit_ref => {\n+                match (*other) {\n+                    bind_by_implicit_ref => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &binding_mode) -> bool { !self.eq(other) }\n+}\n \n #[auto_serialize]\n enum pat_ {\n@@ -394,12 +562,21 @@ impl mutability : to_bytes::IterBytes {\n     }\n }\n \n+#[cfg(stage0)]\n impl mutability: cmp::Eq {\n     pure fn eq(&&other: mutability) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: mutability) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl mutability : cmp::Eq {\n+    pure fn eq(other: &mutability) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &mutability) -> bool { !self.eq(other) }\n+}\n \n #[auto_serialize]\n enum proto {\n@@ -409,12 +586,21 @@ enum proto {\n     proto_block,   // fn&\n }\n \n+#[cfg(stage0)]\n impl proto : cmp::Eq {\n     pure fn eq(&&other: proto) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: proto) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl proto : cmp::Eq {\n+    pure fn eq(other: &proto) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &proto) -> bool { !self.eq(other) }\n+}\n \n #[auto_serialize]\n enum vstore {\n@@ -463,12 +649,21 @@ enum binop {\n     gt,\n }\n \n+#[cfg(stage0)]\n impl binop : cmp::Eq {\n     pure fn eq(&&other: binop) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: binop) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl binop : cmp::Eq {\n+    pure fn eq(other: &binop) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &binop) -> bool { !self.eq(other) }\n+}\n \n #[auto_serialize]\n enum unop {\n@@ -479,6 +674,7 @@ enum unop {\n     neg\n }\n \n+#[cfg(stage0)]\n impl unop : cmp::Eq {\n     pure fn eq(&&other: unop) -> bool {\n         match self {\n@@ -518,6 +714,47 @@ impl unop : cmp::Eq {\n         !self.eq(other)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl unop : cmp::Eq {\n+    pure fn eq(other: &unop) -> bool {\n+        match self {\n+            box(e0a) => {\n+                match (*other) {\n+                    box(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            uniq(e0a) => {\n+                match (*other) {\n+                    uniq(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            deref => {\n+                match (*other) {\n+                    deref => true,\n+                    _ => false\n+                }\n+            }\n+            not => {\n+                match (*other) {\n+                    not => true,\n+                    _ => false\n+                }\n+            }\n+            neg => {\n+                match (*other) {\n+                    neg => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &unop) -> bool {\n+        !self.eq(other)\n+    }\n+}\n \n // Generally, after typeck you can get the inferred value\n // using ty::resolved_T(...).\n@@ -539,6 +776,7 @@ impl<T: to_bytes::IterBytes> inferable<T> : to_bytes::IterBytes {\n     }\n }\n \n+#[cfg(stage0)]\n impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n     pure fn eq(&&other: inferable<T>) -> bool {\n         match self {\n@@ -558,6 +796,27 @@ impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n     }\n     pure fn ne(&&other: inferable<T>) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n+    pure fn eq(other: &inferable<T>) -> bool {\n+        match self {\n+            expl(e0a) => {\n+                match (*other) {\n+                    expl(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            infer(e0a) => {\n+                match (*other) {\n+                    infer(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &inferable<T>) -> bool { !self.eq(other) }\n+}\n \n // \"resolved\" mode: the real modes.\n #[auto_serialize]\n@@ -570,12 +829,21 @@ impl rmode : to_bytes::IterBytes {\n }\n \n \n+#[cfg(stage0)]\n impl rmode : cmp::Eq {\n     pure fn eq(&&other: rmode) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: rmode) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl rmode : cmp::Eq {\n+    pure fn eq(other: &rmode) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &rmode) -> bool { !self.eq(other) }\n+}\n \n // inferable mode.\n #[auto_serialize]\n@@ -598,6 +866,7 @@ enum stmt_ {\n #[auto_serialize]\n enum init_op { init_assign, init_move, }\n \n+#[cfg(stage0)]\n impl init_op : cmp::Eq {\n     pure fn eq(&&other: init_op) -> bool {\n         match self {\n@@ -617,6 +886,27 @@ impl init_op : cmp::Eq {\n     }\n     pure fn ne(&&other: init_op) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl init_op : cmp::Eq {\n+    pure fn eq(other: &init_op) -> bool {\n+        match self {\n+            init_assign => {\n+                match (*other) {\n+                    init_assign => true,\n+                    _ => false\n+                }\n+            }\n+            init_move => {\n+                match (*other) {\n+                    init_move => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &init_op) -> bool { !self.eq(other) }\n+}\n \n #[auto_serialize]\n type initializer = {op: init_op, expr: @expr};\n@@ -648,6 +938,7 @@ type field = spanned<field_>;\n #[auto_serialize]\n enum blk_check_mode { default_blk, unsafe_blk, }\n \n+#[cfg(stage0)]\n impl blk_check_mode : cmp::Eq {\n     pure fn eq(&&other: blk_check_mode) -> bool {\n         match (self, other) {\n@@ -659,6 +950,19 @@ impl blk_check_mode : cmp::Eq {\n     }\n     pure fn ne(&&other: blk_check_mode) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl blk_check_mode : cmp::Eq {\n+    pure fn eq(other: &blk_check_mode) -> bool {\n+        match (self, (*other)) {\n+            (default_blk, default_blk) => true,\n+            (unsafe_blk, unsafe_blk) => true,\n+            (default_blk, _) => false,\n+            (unsafe_blk, _) => false,\n+        }\n+    }\n+    pure fn ne(other: &blk_check_mode) -> bool { !self.eq(other) }\n+}\n \n #[auto_serialize]\n type expr = {id: node_id, callee_id: node_id, node: expr_, span: span};\n@@ -867,6 +1171,7 @@ enum lit_ {\n     lit_bool(bool),\n }\n \n+#[cfg(stage0)]\n impl ast::lit_: cmp::Eq {\n     pure fn eq(&&other: ast::lit_) -> bool {\n         match (self, other) {\n@@ -894,6 +1199,35 @@ impl ast::lit_: cmp::Eq {\n     }\n     pure fn ne(&&other: ast::lit_) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl ast::lit_: cmp::Eq {\n+    pure fn eq(other: &ast::lit_) -> bool {\n+        match (self, *other) {\n+            (lit_str(a), lit_str(b)) => a == b,\n+            (lit_int(val_a, ty_a), lit_int(val_b, ty_b)) => {\n+                val_a == val_b && ty_a == ty_b\n+            }\n+            (lit_uint(val_a, ty_a), lit_uint(val_b, ty_b)) => {\n+                val_a == val_b && ty_a == ty_b\n+            }\n+            (lit_int_unsuffixed(a), lit_int_unsuffixed(b)) => a == b,\n+            (lit_float(val_a, ty_a), lit_float(val_b, ty_b)) => {\n+                val_a == val_b && ty_a == ty_b\n+            }\n+            (lit_nil, lit_nil) => true,\n+            (lit_bool(a), lit_bool(b)) => a == b,\n+            (lit_str(_), _) => false,\n+            (lit_int(*), _) => false,\n+            (lit_uint(*), _) => false,\n+            (lit_int_unsuffixed(*), _) => false,\n+            (lit_float(*), _) => false,\n+            (lit_nil, _) => false,\n+            (lit_bool(_), _) => false\n+        }\n+    }\n+    pure fn ne(other: &ast::lit_) -> bool { !self.eq(other) }\n+}\n \n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n@@ -929,6 +1263,7 @@ impl int_ty : to_bytes::IterBytes {\n     }\n }\n \n+#[cfg(stage0)]\n impl int_ty: cmp::Eq {\n     pure fn eq(&&other: int_ty) -> bool {\n         match (self, other) {\n@@ -948,6 +1283,27 @@ impl int_ty: cmp::Eq {\n     }\n     pure fn ne(&&other: int_ty) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl int_ty : cmp::Eq {\n+    pure fn eq(other: &int_ty) -> bool {\n+        match (self, (*other)) {\n+            (ty_i, ty_i) => true,\n+            (ty_char, ty_char) => true,\n+            (ty_i8, ty_i8) => true,\n+            (ty_i16, ty_i16) => true,\n+            (ty_i32, ty_i32) => true,\n+            (ty_i64, ty_i64) => true,\n+            (ty_i, _) => false,\n+            (ty_char, _) => false,\n+            (ty_i8, _) => false,\n+            (ty_i16, _) => false,\n+            (ty_i32, _) => false,\n+            (ty_i64, _) => false,\n+        }\n+    }\n+    pure fn ne(other: &int_ty) -> bool { !self.eq(other) }\n+}\n \n #[auto_serialize]\n enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n@@ -958,6 +1314,7 @@ impl uint_ty : to_bytes::IterBytes {\n     }\n }\n \n+#[cfg(stage0)]\n impl uint_ty: cmp::Eq {\n     pure fn eq(&&other: uint_ty) -> bool {\n         match (self, other) {\n@@ -975,6 +1332,25 @@ impl uint_ty: cmp::Eq {\n     }\n     pure fn ne(&&other: uint_ty) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl uint_ty : cmp::Eq {\n+    pure fn eq(other: &uint_ty) -> bool {\n+        match (self, (*other)) {\n+            (ty_u, ty_u) => true,\n+            (ty_u8, ty_u8) => true,\n+            (ty_u16, ty_u16) => true,\n+            (ty_u32, ty_u32) => true,\n+            (ty_u64, ty_u64) => true,\n+            (ty_u, _) => false,\n+            (ty_u8, _) => false,\n+            (ty_u16, _) => false,\n+            (ty_u32, _) => false,\n+            (ty_u64, _) => false\n+        }\n+    }\n+    pure fn ne(other: &uint_ty) -> bool { !self.eq(other) }\n+}\n \n #[auto_serialize]\n enum float_ty { ty_f, ty_f32, ty_f64, }\n@@ -984,6 +1360,7 @@ impl float_ty : to_bytes::IterBytes {\n         (self as u8).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(stage0)]\n impl float_ty: cmp::Eq {\n     pure fn eq(&&other: float_ty) -> bool {\n         match (self, other) {\n@@ -993,6 +1370,17 @@ impl float_ty: cmp::Eq {\n     }\n     pure fn ne(&&other: float_ty) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl float_ty : cmp::Eq {\n+    pure fn eq(other: &float_ty) -> bool {\n+        match (self, (*other)) {\n+            (ty_f, ty_f) | (ty_f32, ty_f32) | (ty_f64, ty_f64) => true,\n+            (ty_f, _) | (ty_f32, _) | (ty_f64, _) => false\n+        }\n+    }\n+    pure fn ne(other: &float_ty) -> bool { !self.eq(other) }\n+}\n \n #[auto_serialize]\n type ty = {id: node_id, node: ty_, span: span};\n@@ -1007,6 +1395,7 @@ enum prim_ty {\n     ty_bool,\n }\n \n+#[cfg(stage0)]\n impl prim_ty : cmp::Eq {\n     pure fn eq(&&other: prim_ty) -> bool {\n         match self {\n@@ -1044,6 +1433,45 @@ impl prim_ty : cmp::Eq {\n     }\n     pure fn ne(&&other: prim_ty) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl prim_ty : cmp::Eq {\n+    pure fn eq(other: &prim_ty) -> bool {\n+        match self {\n+            ty_int(e0a) => {\n+                match (*other) {\n+                    ty_int(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_uint(e0a) => {\n+                match (*other) {\n+                    ty_uint(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_float(e0a) => {\n+                match (*other) {\n+                    ty_float(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_str => {\n+                match (*other) {\n+                    ty_str => true,\n+                    _ => false\n+                }\n+            }\n+            ty_bool => {\n+                match (*other) {\n+                    ty_bool => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &prim_ty) -> bool { !self.eq(other) }\n+}\n \n #[auto_serialize]\n type region = {id: node_id, node: region_};\n@@ -1079,6 +1507,7 @@ enum ty_ {\n \n // Equality and byte-iter (hashing) can be quite approximate for AST types.\n // since we only care about this for normalizing them to \"real\" types.\n+#[cfg(stage0)]\n impl ty : cmp::Eq {\n     pure fn eq(&&other: ty) -> bool {\n         ptr::addr_of(self) == ptr::addr_of(other)\n@@ -1087,6 +1516,16 @@ impl ty : cmp::Eq {\n         ptr::addr_of(self) != ptr::addr_of(other)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl ty : cmp::Eq {\n+    pure fn eq(other: &ty) -> bool {\n+        ptr::addr_of(self) == ptr::addr_of((*other))\n+    }\n+    pure fn ne(other: &ty) -> bool {\n+        ptr::addr_of(self) != ptr::addr_of((*other))\n+    }\n+}\n \n impl ty : to_bytes::IterBytes {\n     pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n@@ -1118,12 +1557,21 @@ impl purity : to_bytes::IterBytes {\n     }\n }\n \n+#[cfg(stage0)]\n impl purity : cmp::Eq {\n     pure fn eq(&&other: purity) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: purity) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl purity : cmp::Eq {\n+    pure fn eq(other: &purity) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &purity) -> bool { !self.eq(other) }\n+}\n \n #[auto_serialize]\n enum ret_style {\n@@ -1138,6 +1586,7 @@ impl ret_style : to_bytes::IterBytes {\n     }\n }\n \n+#[cfg(stage0)]\n impl ret_style : cmp::Eq {\n     pure fn eq(&&other: ret_style) -> bool {\n         match (self, other) {\n@@ -1149,6 +1598,19 @@ impl ret_style : cmp::Eq {\n     }\n     pure fn ne(&&other: ret_style) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl ret_style : cmp::Eq {\n+    pure fn eq(other: &ret_style) -> bool {\n+        match (self, (*other)) {\n+            (noreturn, noreturn) => true,\n+            (return_val, return_val) => true,\n+            (noreturn, _) => false,\n+            (return_val, _) => false,\n+        }\n+    }\n+    pure fn ne(other: &ret_style) -> bool { !self.eq(other) }\n+}\n \n #[auto_serialize]\n enum self_ty_ {\n@@ -1160,6 +1622,7 @@ enum self_ty_ {\n     sty_uniq(mutability)                // by-unique-pointer self: `~self`\n }\n \n+#[cfg(stage0)]\n impl self_ty_ : cmp::Eq {\n     pure fn eq(&&other: self_ty_) -> bool {\n         match self {\n@@ -1203,6 +1666,51 @@ impl self_ty_ : cmp::Eq {\n     }\n     pure fn ne(&&other: self_ty_) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl self_ty_ : cmp::Eq {\n+    pure fn eq(other: &self_ty_) -> bool {\n+        match self {\n+            sty_static => {\n+                match (*other) {\n+                    sty_static => true,\n+                    _ => false\n+                }\n+            }\n+            sty_by_ref => {\n+                match (*other) {\n+                    sty_by_ref => true,\n+                    _ => false\n+                }\n+            }\n+            sty_value => {\n+                match (*other) {\n+                    sty_value => true,\n+                    _ => false\n+                }\n+            }\n+            sty_region(e0a) => {\n+                match (*other) {\n+                    sty_region(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            sty_box(e0a) => {\n+                match (*other) {\n+                    sty_box(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            sty_uniq(e0a) => {\n+                match (*other) {\n+                    sty_uniq(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &self_ty_) -> bool { !self.eq(other) }\n+}\n \n #[auto_serialize]\n type self_ty = spanned<self_ty_>;\n@@ -1228,13 +1736,23 @@ enum foreign_abi {\n #[auto_serialize]\n enum foreign_mod_sort { named, anonymous }\n \n+#[cfg(stage0)]\n impl foreign_mod_sort : cmp::Eq {\n     pure fn eq(&&other: foreign_mod_sort) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: foreign_mod_sort) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl foreign_mod_sort : cmp::Eq {\n+    pure fn eq(other: &foreign_mod_sort) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &foreign_mod_sort) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl foreign_abi : cmp::Eq {\n     pure fn eq(&&other: foreign_abi) -> bool {\n         match (self, other) {\n@@ -1248,6 +1766,21 @@ impl foreign_abi : cmp::Eq {\n     }\n     pure fn ne(&&other: foreign_abi) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl foreign_abi : cmp::Eq {\n+    pure fn eq(other: &foreign_abi) -> bool {\n+        match (self, (*other)) {\n+            (foreign_abi_rust_intrinsic, foreign_abi_rust_intrinsic) => true,\n+            (foreign_abi_cdecl, foreign_abi_cdecl) => true,\n+            (foreign_abi_stdcall, foreign_abi_stdcall) => true,\n+            (foreign_abi_rust_intrinsic, _) => false,\n+            (foreign_abi_cdecl, _) => false,\n+            (foreign_abi_stdcall, _) => false,\n+        }\n+    }\n+    pure fn ne(other: &foreign_abi) -> bool { !self.eq(other) }\n+}\n \n #[auto_serialize]\n type foreign_mod =\n@@ -1284,12 +1817,21 @@ type path_list_ident = spanned<path_list_ident_>;\n #[auto_serialize]\n enum namespace { module_ns, type_value_ns }\n \n+#[cfg(stage0)]\n impl namespace : cmp::Eq {\n     pure fn eq(&&other: namespace) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: namespace) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl namespace : cmp::Eq {\n+    pure fn eq(other: &namespace) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &namespace) -> bool { !self.eq(other) }\n+}\n \n #[auto_serialize]\n type view_path = spanned<view_path_>;\n@@ -1332,12 +1874,21 @@ type attribute = spanned<attribute_>;\n #[auto_serialize]\n enum attr_style { attr_outer, attr_inner, }\n \n+#[cfg(stage0)]\n impl attr_style : cmp::Eq {\n     pure fn eq(&&other: attr_style) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: attr_style) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl attr_style : cmp::Eq {\n+    pure fn eq(other: &attr_style) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &attr_style) -> bool { !self.eq(other) }\n+}\n \n // doc-comments are promoted to attributes that have is_sugared_doc = true\n #[auto_serialize]\n@@ -1358,6 +1909,7 @@ type trait_ref = {path: @path, ref_id: node_id, impl_id: node_id};\n #[auto_serialize]\n enum visibility { public, private, inherited }\n \n+#[cfg(stage0)]\n impl visibility : cmp::Eq {\n     pure fn eq(&&other: visibility) -> bool {\n         match (self, other) {\n@@ -1371,6 +1923,21 @@ impl visibility : cmp::Eq {\n     }\n     pure fn ne(&&other: visibility) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl visibility : cmp::Eq {\n+    pure fn eq(other: &visibility) -> bool {\n+        match (self, (*other)) {\n+            (public, public) => true,\n+            (private, private) => true,\n+            (inherited, inherited) => true,\n+            (public, _) => false,\n+            (private, _) => false,\n+            (inherited, _) => false,\n+        }\n+    }\n+    pure fn ne(other: &visibility) -> bool { !self.eq(other) }\n+}\n \n #[auto_serialize]\n type struct_field_ = {\n@@ -1435,6 +2002,7 @@ impl class_mutability : to_bytes::IterBytes {\n     }\n }\n \n+#[cfg(stage0)]\n impl class_mutability : cmp::Eq {\n     pure fn eq(&&other: class_mutability) -> bool {\n         match (self, other) {\n@@ -1446,6 +2014,19 @@ impl class_mutability : cmp::Eq {\n     }\n     pure fn ne(&&other: class_mutability) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl class_mutability : cmp::Eq {\n+    pure fn eq(other: &class_mutability) -> bool {\n+        match (self, (*other)) {\n+            (class_mutable, class_mutable) => true,\n+            (class_immutable, class_immutable) => true,\n+            (class_mutable, _) => false,\n+            (class_immutable, _) => false,\n+        }\n+    }\n+    pure fn ne(other: &class_mutability) -> bool { !self.eq(other) }\n+}\n \n #[auto_serialize]\n type class_ctor = spanned<class_ctor_>;"}, {"sha": "3257e54626bdae31d76c5fd0e0e401d771da050c", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -11,6 +11,7 @@ enum path_elt {\n     path_name(ident)\n }\n \n+#[cfg(stage0)]\n impl path_elt : cmp::Eq {\n     pure fn eq(&&other: path_elt) -> bool {\n         match self {\n@@ -30,6 +31,27 @@ impl path_elt : cmp::Eq {\n     }\n     pure fn ne(&&other: path_elt) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl path_elt : cmp::Eq {\n+    pure fn eq(other: &path_elt) -> bool {\n+        match self {\n+            path_mod(e0a) => {\n+                match (*other) {\n+                    path_mod(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            path_name(e0a) => {\n+                match (*other) {\n+                    path_name(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &path_elt) -> bool { !self.eq(other) }\n+}\n \n type path = ~[path_elt];\n "}, {"sha": "1a8096484c2afa74e366b2c6120a372f0e1f8e6e", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -337,12 +337,21 @@ enum inline_attr {\n     ia_never,\n }\n \n+#[cfg(stage0)]\n impl inline_attr : cmp::Eq {\n     pure fn eq(&&other: inline_attr) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: inline_attr) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl inline_attr : cmp::Eq {\n+    pure fn eq(other: &inline_attr) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &inline_attr) -> bool { !self.eq(other) }\n+}\n \n /// True if something like #[inline] is found in the list of attrs.\n fn find_inline_attr(attrs: ~[ast::attribute]) -> inline_attr {"}, {"sha": "6340e10429dfb04d52befd86c903fbca426bc36b", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -32,12 +32,21 @@ type filename = ~str;\n \n type file_pos = {ch: uint, byte: uint};\n \n+#[cfg(stage0)]\n impl file_pos: cmp::Eq {\n     pure fn eq(&&other: file_pos) -> bool {\n         self.ch == other.ch && self.byte == other.byte\n     }\n     pure fn ne(&&other: file_pos) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl file_pos : cmp::Eq {\n+    pure fn eq(other: &file_pos) -> bool {\n+        self.ch == (*other).ch && self.byte == (*other).byte\n+    }\n+    pure fn ne(other: &file_pos) -> bool { !self.eq(other) }\n+}\n \n /* A codemap is a thing that maps uints to file/line/column positions\n  * in a crate. This to make it possible to represent the positions\n@@ -171,12 +180,21 @@ type expn_info = Option<@expn_info_>;\n \n type span = {lo: uint, hi: uint, expn_info: expn_info};\n \n+#[cfg(stage0)]\n impl span : cmp::Eq {\n     pure fn eq(&&other: span) -> bool {\n         return self.lo == other.lo && self.hi == other.hi;\n     }\n     pure fn ne(&&other: span) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl span : cmp::Eq {\n+    pure fn eq(other: &span) -> bool {\n+        return self.lo == (*other).lo && self.hi == (*other).hi;\n+    }\n+    pure fn ne(other: &span) -> bool { !self.eq(other) }\n+}\n \n fn span_to_str_no_adj(sp: span, cm: codemap) -> ~str {\n     let lo = lookup_char_pos(cm, sp.lo);"}, {"sha": "cbe9097bd7dbb261993827a0c955cc29dadd92f6", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -146,12 +146,21 @@ enum level {\n     note,\n }\n \n+#[cfg(stage0)]\n impl level : cmp::Eq {\n     pure fn eq(&&other: level) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: level) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl level : cmp::Eq {\n+    pure fn eq(other: &level) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &level) -> bool { !self.eq(other) }\n+}\n \n fn diagnosticstr(lvl: level) -> ~str {\n     match lvl {"}, {"sha": "9656a63cb0b3d14d62f3fb0bc9d1ff35edf3b669", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -5,6 +5,7 @@ use ast_builder::{path, append_types};\n \n enum direction { send, recv }\n \n+#[cfg(stage0)]\n impl direction : cmp::Eq {\n     pure fn eq(&&other: direction) -> bool {\n         match (self, other) {\n@@ -16,6 +17,19 @@ impl direction : cmp::Eq {\n     }\n     pure fn ne(&&other: direction) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl direction : cmp::Eq {\n+    pure fn eq(other: &direction) -> bool {\n+        match (self, (*other)) {\n+            (send, send) => true,\n+            (recv, recv) => true,\n+            (send, _) => false,\n+            (recv, _) => false,\n+        }\n+    }\n+    pure fn ne(other: &direction) -> bool { !self.eq(other) }\n+}\n \n impl direction: ToStr {\n     fn to_str() -> ~str {"}, {"sha": "214b9e3fbbd60c8a7fe836a888a1f85c01ec6084", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -17,6 +17,7 @@ enum cmnt_style {\n     blank_line, // Just a manual blank line \"\\n\\n\", for layout\n }\n \n+#[cfg(stage0)]\n impl cmnt_style : cmp::Eq {\n     pure fn eq(&&other: cmnt_style) -> bool {\n         (self as uint) == (other as uint)\n@@ -25,6 +26,16 @@ impl cmnt_style : cmp::Eq {\n         (self as uint) != (other as uint)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl cmnt_style : cmp::Eq {\n+    pure fn eq(other: &cmnt_style) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &cmnt_style) -> bool {\n+        (self as uint) != ((*other) as uint)\n+    }\n+}\n \n type cmnt = {style: cmnt_style, lines: ~[~str], pos: uint};\n "}, {"sha": "3891e7b6d177b7af74c3cd4bc8d389ec9f491a10", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -24,6 +24,7 @@ pub enum ObsoleteSyntax {\n     ObsoletePrivSection\n }\n \n+#[cfg(stage0)]\n impl ObsoleteSyntax : cmp::Eq {\n     pure fn eq(&&other: ObsoleteSyntax) -> bool {\n         self as uint == other as uint\n@@ -32,6 +33,16 @@ impl ObsoleteSyntax : cmp::Eq {\n         !self.eq(other)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl ObsoleteSyntax : cmp::Eq {\n+    pure fn eq(other: &ObsoleteSyntax) -> bool {\n+        self as uint == (*other) as uint\n+    }\n+    pure fn ne(other: &ObsoleteSyntax) -> bool {\n+        !self.eq(other)\n+    }\n+}\n \n impl ObsoleteSyntax: to_bytes::IterBytes {\n     #[inline(always)]"}, {"sha": "a6ad5b354843df422cb17da594d446829f2bcdf5", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -3647,12 +3647,21 @@ impl parser {\n     }\n }\n \n+#[cfg(stage0)]\n impl restriction : cmp::Eq {\n     pure fn eq(&&other: restriction) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: restriction) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl restriction : cmp::Eq {\n+    pure fn eq(other: &restriction) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &restriction) -> bool { !self.eq(other) }\n+}\n \n //\n // Local Variables:"}, {"sha": "d04a65fd2db76b014fe3ec74aba2d3ac36d1564b", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -435,13 +435,23 @@ fn reserved_keyword_table() -> HashMap<~str, ()> {\n     words\n }\n \n+#[cfg(stage0)]\n impl binop : cmp::Eq {\n     pure fn eq(&&other: binop) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: binop) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl binop : cmp::Eq {\n+    pure fn eq(other: &binop) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &binop) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl token : cmp::Eq {\n     pure fn eq(&&other: token) -> bool {\n         match self {\n@@ -707,6 +717,273 @@ impl token : cmp::Eq {\n     }\n     pure fn ne(&&other: token) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl token : cmp::Eq {\n+    pure fn eq(other: &token) -> bool {\n+        match self {\n+            EQ => {\n+                match (*other) {\n+                    EQ => true,\n+                    _ => false\n+                }\n+            }\n+            LT => {\n+                match (*other) {\n+                    LT => true,\n+                    _ => false\n+                }\n+            }\n+            LE => {\n+                match (*other) {\n+                    LE => true,\n+                    _ => false\n+                }\n+            }\n+            EQEQ => {\n+                match (*other) {\n+                    EQEQ => true,\n+                    _ => false\n+                }\n+            }\n+            NE => {\n+                match (*other) {\n+                    NE => true,\n+                    _ => false\n+                }\n+            }\n+            GE => {\n+                match (*other) {\n+                    GE => true,\n+                    _ => false\n+                }\n+            }\n+            GT => {\n+                match (*other) {\n+                    GT => true,\n+                    _ => false\n+                }\n+            }\n+            ANDAND => {\n+                match (*other) {\n+                    ANDAND => true,\n+                    _ => false\n+                }\n+            }\n+            OROR => {\n+                match (*other) {\n+                    OROR => true,\n+                    _ => false\n+                }\n+            }\n+            NOT => {\n+                match (*other) {\n+                    NOT => true,\n+                    _ => false\n+                }\n+            }\n+            TILDE => {\n+                match (*other) {\n+                    TILDE => true,\n+                    _ => false\n+                }\n+            }\n+            BINOP(e0a) => {\n+                match (*other) {\n+                    BINOP(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            BINOPEQ(e0a) => {\n+                match (*other) {\n+                    BINOPEQ(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            AT => {\n+                match (*other) {\n+                    AT => true,\n+                    _ => false\n+                }\n+            }\n+            DOT => {\n+                match (*other) {\n+                    DOT => true,\n+                    _ => false\n+                }\n+            }\n+            DOTDOT => {\n+                match (*other) {\n+                    DOTDOT => true,\n+                    _ => false\n+                }\n+            }\n+            ELLIPSIS => {\n+                match (*other) {\n+                    ELLIPSIS => true,\n+                    _ => false\n+                }\n+            }\n+            COMMA => {\n+                match (*other) {\n+                    COMMA => true,\n+                    _ => false\n+                }\n+            }\n+            SEMI => {\n+                match (*other) {\n+                    SEMI => true,\n+                    _ => false\n+                }\n+            }\n+            COLON => {\n+                match (*other) {\n+                    COLON => true,\n+                    _ => false\n+                }\n+            }\n+            MOD_SEP => {\n+                match (*other) {\n+                    MOD_SEP => true,\n+                    _ => false\n+                }\n+            }\n+            RARROW => {\n+                match (*other) {\n+                    RARROW => true,\n+                    _ => false\n+                }\n+            }\n+            LARROW => {\n+                match (*other) {\n+                    LARROW => true,\n+                    _ => false\n+                }\n+            }\n+            DARROW => {\n+                match (*other) {\n+                    DARROW => true,\n+                    _ => false\n+                }\n+            }\n+            FAT_ARROW => {\n+                match (*other) {\n+                    FAT_ARROW => true,\n+                    _ => false\n+                }\n+            }\n+            LPAREN => {\n+                match (*other) {\n+                    LPAREN => true,\n+                    _ => false\n+                }\n+            }\n+            RPAREN => {\n+                match (*other) {\n+                    RPAREN => true,\n+                    _ => false\n+                }\n+            }\n+            LBRACKET => {\n+                match (*other) {\n+                    LBRACKET => true,\n+                    _ => false\n+                }\n+            }\n+            RBRACKET => {\n+                match (*other) {\n+                    RBRACKET => true,\n+                    _ => false\n+                }\n+            }\n+            LBRACE => {\n+                match (*other) {\n+                    LBRACE => true,\n+                    _ => false\n+                }\n+            }\n+            RBRACE => {\n+                match (*other) {\n+                    RBRACE => true,\n+                    _ => false\n+                }\n+            }\n+            POUND => {\n+                match (*other) {\n+                    POUND => true,\n+                    _ => false\n+                }\n+            }\n+            DOLLAR => {\n+                match (*other) {\n+                    DOLLAR => true,\n+                    _ => false\n+                }\n+            }\n+            LIT_INT(e0a, e1a) => {\n+                match (*other) {\n+                    LIT_INT(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            LIT_UINT(e0a, e1a) => {\n+                match (*other) {\n+                    LIT_UINT(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            LIT_INT_UNSUFFIXED(e0a) => {\n+                match (*other) {\n+                    LIT_INT_UNSUFFIXED(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            LIT_FLOAT(e0a, e1a) => {\n+                match (*other) {\n+                    LIT_FLOAT(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            LIT_STR(e0a) => {\n+                match (*other) {\n+                    LIT_STR(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            IDENT(e0a, e1a) => {\n+                match (*other) {\n+                    IDENT(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            UNDERSCORE => {\n+                match (*other) {\n+                    UNDERSCORE => true,\n+                    _ => false\n+                }\n+            }\n+            INTERPOLATED(_) => {\n+                match (*other) {\n+                    INTERPOLATED(_) => true,\n+                    _ => false\n+                }\n+            }\n+            DOC_COMMENT(e0a) => {\n+                match (*other) {\n+                    DOC_COMMENT(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            EOF => {\n+                match (*other) {\n+                    EOF => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &token) -> bool { !self.eq(other) }\n+}\n \n // Local Variables:\n // fill-column: 78;"}, {"sha": "c69739e4cf6d41abccf114243ed3810ebfe4cf93", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -55,6 +55,7 @@ use dvec::DVec;\n  */\n enum breaks { consistent, inconsistent, }\n \n+#[cfg(stage0)]\n impl breaks : cmp::Eq {\n     pure fn eq(&&other: breaks) -> bool {\n         match (self, other) {\n@@ -66,6 +67,19 @@ impl breaks : cmp::Eq {\n     }\n     pure fn ne(&&other: breaks) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl breaks : cmp::Eq {\n+    pure fn eq(other: &breaks) -> bool {\n+        match (self, (*other)) {\n+            (consistent, consistent) => true,\n+            (inconsistent, inconsistent) => true,\n+            (consistent, _) => false,\n+            (inconsistent, _) => false,\n+        }\n+    }\n+    pure fn ne(other: &breaks) -> bool { !self.eq(other) }\n+}\n \n type break_t = {offset: int, blank_space: int};\n "}, {"sha": "c52b2c661abfc4b245cd88f49e7a218b8011644e", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -26,12 +26,21 @@ enum output_type {\n     output_type_exe,\n }\n \n+#[cfg(stage0)]\n impl output_type : cmp::Eq {\n     pure fn eq(&&other: output_type) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: output_type) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl output_type : cmp::Eq {\n+    pure fn eq(other: &output_type) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &output_type) -> bool { !self.eq(other) }\n+}\n \n fn llvm_err(sess: session, msg: ~str) -> ! unsafe {\n     let cstr = llvm::LLVMRustGetLastError();"}, {"sha": "a2e65656cc09079cccfec58a29e296398f7ba7e2", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -138,12 +138,21 @@ enum compile_upto {\n     cu_everything,\n }\n \n+#[cfg(stage0)]\n impl compile_upto : cmp::Eq {\n     pure fn eq(&&other: compile_upto) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: compile_upto) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl compile_upto : cmp::Eq {\n+    pure fn eq(other: &compile_upto) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &compile_upto) -> bool { !self.eq(other) }\n+}\n \n fn compile_upto(sess: session, cfg: ast::crate_cfg,\n                 input: input, upto: compile_upto,"}, {"sha": "dff272ee9be553a17531ec1978bc5ef72c42adf8", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -207,12 +207,21 @@ enum monitor_msg {\n     done,\n }\n \n+#[cfg(stage0)]\n impl monitor_msg : cmp::Eq {\n     pure fn eq(&&other: monitor_msg) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: monitor_msg) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl monitor_msg : cmp::Eq {\n+    pure fn eq(other: &monitor_msg) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &monitor_msg) -> bool { !self.eq(other) }\n+}\n \n /*\n This is a sanity check that any failure of the compiler is performed"}, {"sha": "01dcd6930b369b604d6e381d109cbaf90ec0daa3", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -12,21 +12,39 @@ use middle::lint;\n \n enum os { os_win32, os_macos, os_linux, os_freebsd, }\n \n+#[cfg(stage0)]\n impl os : cmp::Eq {\n     pure fn eq(&&other: os) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: os) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl os : cmp::Eq {\n+    pure fn eq(other: &os) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &os) -> bool { !self.eq(other) }\n+}\n \n enum arch { arch_x86, arch_x86_64, arch_arm, }\n \n+#[cfg(stage0)]\n impl arch: cmp::Eq {\n     pure fn eq(&&other: arch) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: arch) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl arch : cmp::Eq {\n+    pure fn eq(other: &arch) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &arch) -> bool { !self.eq(other) }\n+}\n \n enum crate_type { bin_crate, lib_crate, unknown_crate, }\n \n@@ -94,12 +112,21 @@ enum OptLevel {\n     Aggressive // -O3\n }\n \n+#[cfg(stage0)]\n impl OptLevel : cmp::Eq {\n     pure fn eq(&&other: OptLevel) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: OptLevel) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl OptLevel : cmp::Eq {\n+    pure fn eq(other: &OptLevel) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &OptLevel) -> bool { !self.eq(other) }\n+}\n \n type options =\n     // The crate config requested for the session, which may be combined"}, {"sha": "10866a213fee9631144ed5d9313e0afa22e38364", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -128,6 +128,7 @@ enum TypeKind {\n     X86_MMX   = 15\n }\n \n+#[cfg(stage0)]\n impl TypeKind : cmp::Eq {\n     pure fn eq(&&other: TypeKind) -> bool {\n         match (self, other) {\n@@ -167,6 +168,47 @@ impl TypeKind : cmp::Eq {\n     }\n     pure fn ne(&&other: TypeKind) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl TypeKind : cmp::Eq {\n+    pure fn eq(other: &TypeKind) -> bool {\n+        match (self, (*other)) {\n+            (Void, Void) => true,\n+            (Half, Half) => true,\n+            (Float, Float) => true,\n+            (Double, Double) => true,\n+            (X86_FP80, X86_FP80) => true,\n+            (FP128, FP128) => true,\n+            (PPC_FP128, PPC_FP128) => true,\n+            (Label, Label) => true,\n+            (Integer, Integer) => true,\n+            (Function, Function) => true,\n+            (Struct, Struct) => true,\n+            (Array, Array) => true,\n+            (Pointer, Pointer) => true,\n+            (Vector, Vector) => true,\n+            (Metadata, Metadata) => true,\n+            (X86_MMX, X86_MMX) => true,\n+            (Void, _) => false,\n+            (Half, _) => false,\n+            (Float, _) => false,\n+            (Double, _) => false,\n+            (X86_FP80, _) => false,\n+            (FP128, _) => false,\n+            (PPC_FP128, _) => false,\n+            (Label, _) => false,\n+            (Integer, _) => false,\n+            (Function, _) => false,\n+            (Struct, _) => false,\n+            (Array, _) => false,\n+            (Pointer, _) => false,\n+            (Vector, _) => false,\n+            (Metadata, _) => false,\n+            (X86_MMX, _) => false,\n+        }\n+    }\n+    pure fn ne(other: &TypeKind) -> bool { !self.eq(other) }\n+}\n \n enum AtomicBinOp {\n     Xchg = 0,"}, {"sha": "d817993f771e1d47fe6ae74ccc98c93eec18764e", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -129,12 +129,21 @@ enum Family {\n     InheritedField         // N\n }\n \n+#[cfg(stage0)]\n impl Family : cmp::Eq {\n     pure fn eq(&&other: Family) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: Family) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Family : cmp::Eq {\n+    pure fn eq(other: &Family) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &Family) -> bool { !self.eq(other) }\n+}\n \n fn item_family(item: ebml::Doc) -> Family {\n     let fam = ebml::get_doc(item, tag_items_data_item_family);"}, {"sha": "67f3c8405a845128feaa1565c8b17779adc9f680", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -323,6 +323,7 @@ enum bckerr_code {\n     err_out_of_scope(ty::region, ty::region) // superscope, subscope\n }\n \n+#[cfg(stage0)]\n impl bckerr_code : cmp::Eq {\n     pure fn eq(&&other: bckerr_code) -> bool {\n         match self {\n@@ -367,17 +368,72 @@ impl bckerr_code : cmp::Eq {\n     }\n     pure fn ne(&&other: bckerr_code) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl bckerr_code : cmp::Eq {\n+    pure fn eq(other: &bckerr_code) -> bool {\n+        match self {\n+            err_mut_uniq => {\n+                match (*other) {\n+                    err_mut_uniq => true,\n+                    _ => false\n+                }\n+            }\n+            err_mut_variant => {\n+                match (*other) {\n+                    err_mut_variant => true,\n+                    _ => false\n+                }\n+            }\n+            err_root_not_permitted => {\n+                match (*other) {\n+                    err_root_not_permitted => true,\n+                    _ => false\n+                }\n+            }\n+            err_mutbl(e0a) => {\n+                match (*other) {\n+                    err_mutbl(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            err_out_of_root_scope(e0a, e1a) => {\n+                match (*other) {\n+                    err_out_of_root_scope(e0b, e1b) =>\n+                        e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            err_out_of_scope(e0a, e1a) => {\n+                match (*other) {\n+                    err_out_of_scope(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &bckerr_code) -> bool { !self.eq(other) }\n+}\n \n // Combination of an error code and the categorization of the expression\n // that caused it\n type bckerr = {cmt: cmt, code: bckerr_code};\n \n+#[cfg(stage0)]\n impl bckerr : cmp::Eq {\n     pure fn eq(&&other: bckerr) -> bool {\n         self.cmt == other.cmt && self.code == other.code\n     }\n     pure fn ne(&&other: bckerr) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl bckerr : cmp::Eq {\n+    pure fn eq(other: &bckerr) -> bool {\n+        self.cmt == (*other).cmt && self.code == (*other).code\n+    }\n+    pure fn ne(other: &bckerr) -> bool { !self.eq(other) }\n+}\n \n // shorthand for something that fails with `bckerr` or succeeds with `T`\n type bckres<T> = Result<T, bckerr>;\n@@ -405,6 +461,7 @@ fn save_and_restore<T:Copy,U>(&save_and_restore_t: T, f: fn() -> U) -> U {\n \n /// Creates and returns a new root_map\n \n+#[cfg(stage0)]\n impl root_map_key : cmp::Eq {\n     pure fn eq(&&other: root_map_key) -> bool {\n         self.id == other.id && self.derefs == other.derefs\n@@ -413,6 +470,16 @@ impl root_map_key : cmp::Eq {\n         ! (self == other)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl root_map_key : cmp::Eq {\n+    pure fn eq(other: &root_map_key) -> bool {\n+        self.id == (*other).id && self.derefs == (*other).derefs\n+    }\n+    pure fn ne(other: &root_map_key) -> bool {\n+        ! (self == (*other))\n+    }\n+}\n \n impl root_map_key : to_bytes::IterBytes {\n     pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {"}, {"sha": "86fbce8cadae0cd776f5fa61ad2104d3ff504c06", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -36,6 +36,7 @@ enum purity_cause {\n     pc_cmt(bckerr)\n }\n \n+#[cfg(stage0)]\n impl purity_cause : cmp::Eq {\n     pure fn eq(&&other: purity_cause) -> bool {\n         match self {\n@@ -55,6 +56,27 @@ impl purity_cause : cmp::Eq {\n     }\n     pure fn ne(&&other: purity_cause) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl purity_cause : cmp::Eq {\n+    pure fn eq(other: &purity_cause) -> bool {\n+        match self {\n+            pc_pure_fn => {\n+                match (*other) {\n+                    pc_pure_fn => true,\n+                    _ => false\n+                }\n+            }\n+            pc_cmt(e0a) => {\n+                match (*other) {\n+                    pc_cmt(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &purity_cause) -> bool { !self.eq(other) }\n+}\n \n fn check_loans(bccx: borrowck_ctxt,\n                req_maps: req_maps,\n@@ -78,12 +100,21 @@ enum assignment_type {\n     at_swap\n }\n \n+#[cfg(stage0)]\n impl assignment_type : cmp::Eq {\n     pure fn eq(&&other: assignment_type) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: assignment_type) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl assignment_type : cmp::Eq {\n+    pure fn eq(other: &assignment_type) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &assignment_type) -> bool { !self.eq(other) }\n+}\n \n impl assignment_type {\n     fn checked_by_liveness() -> bool {"}, {"sha": "a8551319da2feafd9dc41f5d1f6ad74e17e06098", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -124,6 +124,7 @@ enum ctor {\n     range(const_val, const_val),\n }\n \n+#[cfg(stage0)]\n impl ctor: cmp::Eq {\n     pure fn eq(&&other: ctor) -> bool {\n         match (self, other) {\n@@ -140,6 +141,24 @@ impl ctor: cmp::Eq {\n     }\n     pure fn ne(&&other: ctor) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl ctor : cmp::Eq {\n+    pure fn eq(other: &ctor) -> bool {\n+        match (self, (*other)) {\n+            (single, single) => true,\n+            (variant(did_self), variant(did_other)) => did_self == did_other,\n+            (val(cv_self), val(cv_other)) => cv_self == cv_other,\n+            (range(cv0_self, cv1_self), range(cv0_other, cv1_other)) => {\n+                cv0_self == cv0_other && cv1_self == cv1_other\n+            }\n+            (single, _) | (variant(_), _) | (val(_), _) | (range(*), _) => {\n+                false\n+            }\n+        }\n+    }\n+    pure fn ne(other: &ctor) -> bool { !self.eq(other) }\n+}\n \n // Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html\n //"}, {"sha": "86b7bd8ab8d52f7ab0661e3300f2adab99f3b650", "filename": "src/rustc/middle/const_eval.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fconst_eval.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -189,6 +189,7 @@ enum const_val {\n     const_bool(bool)\n }\n \n+#[cfg(stage0)]\n impl const_val: cmp::Eq {\n     pure fn eq(&&other: const_val) -> bool {\n         match (self, other) {\n@@ -203,6 +204,22 @@ impl const_val: cmp::Eq {\n     }\n     pure fn ne(&&other: const_val) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl const_val : cmp::Eq {\n+    pure fn eq(other: &const_val) -> bool {\n+        match (self, (*other)) {\n+            (const_float(a), const_float(b)) => a == b,\n+            (const_int(a), const_int(b)) => a == b,\n+            (const_uint(a), const_uint(b)) => a == b,\n+            (const_str(a), const_str(b)) => a == b,\n+            (const_bool(a), const_bool(b)) => a == b,\n+            (const_float(_), _) | (const_int(_), _) | (const_uint(_), _) |\n+            (const_str(_), _) | (const_bool(_), _) => false\n+        }\n+    }\n+    pure fn ne(other: &const_val) -> bool { !self.eq(other) }\n+}\n \n // FIXME: issue #1417\n fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {"}, {"sha": "10079338f03424ae0673af5f924c52075c8a00ff", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -66,12 +66,21 @@ enum lint {\n     // dead_assignment\n }\n \n+#[cfg(stage0)]\n impl lint : cmp::Eq {\n     pure fn eq(&&other: lint) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: lint) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl lint : cmp::Eq {\n+    pure fn eq(other: &lint) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &lint) -> bool { !self.eq(other) }\n+}\n \n fn level_to_str(lv: level) -> ~str {\n     match lv {\n@@ -86,12 +95,21 @@ enum level {\n     allow, warn, deny, forbid\n }\n \n+#[cfg(stage0)]\n impl level : cmp::Eq {\n     pure fn eq(&&other: level) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: level) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl level : cmp::Eq {\n+    pure fn eq(other: &level) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &level) -> bool { !self.eq(other) }\n+}\n \n type lint_spec = @{lint: lint,\n                    desc: ~str,"}, {"sha": "d34c38b9f27633159b21e60b393a2e04d7db42b0", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -127,15 +127,29 @@ type last_use_map = HashMap<node_id, @DVec<node_id>>;\n enum Variable = uint;\n enum LiveNode = uint;\n \n+#[cfg(stage0)]\n impl Variable : cmp::Eq {\n     pure fn eq(&&other: Variable) -> bool { *self == *other }\n     pure fn ne(&&other: Variable) -> bool { *self != *other }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Variable : cmp::Eq {\n+    pure fn eq(other: &Variable) -> bool { *self == *(*other) }\n+    pure fn ne(other: &Variable) -> bool { *self != *(*other) }\n+}\n \n+#[cfg(stage0)]\n impl LiveNode : cmp::Eq {\n     pure fn eq(&&other: LiveNode) -> bool { *self == *other }\n     pure fn ne(&&other: LiveNode) -> bool { *self != *other }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl LiveNode : cmp::Eq {\n+    pure fn eq(other: &LiveNode) -> bool { *self == *(*other) }\n+    pure fn ne(other: &LiveNode) -> bool { *self != *(*other) }\n+}\n \n enum LiveNodeKind {\n     FreeVarNode(span),\n@@ -144,6 +158,7 @@ enum LiveNodeKind {\n     ExitNode\n }\n \n+#[cfg(stage0)]\n impl LiveNodeKind : cmp::Eq {\n     pure fn eq(&&other: LiveNodeKind) -> bool {\n         match self {\n@@ -175,6 +190,39 @@ impl LiveNodeKind : cmp::Eq {\n     }\n     pure fn ne(&&other: LiveNodeKind) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl LiveNodeKind : cmp::Eq {\n+    pure fn eq(other: &LiveNodeKind) -> bool {\n+        match self {\n+            FreeVarNode(e0a) => {\n+                match (*other) {\n+                    FreeVarNode(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ExprNode(e0a) => {\n+                match (*other) {\n+                    ExprNode(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            VarDefNode(e0a) => {\n+                match (*other) {\n+                    VarDefNode(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ExitNode => {\n+                match (*other) {\n+                    ExitNode => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &LiveNodeKind) -> bool { !self.eq(other) }\n+}\n \n fn check_crate(tcx: ty::ctxt,\n                method_map: typeck::method_map,"}, {"sha": "077db7f0260ffc460ab5a01b7927bfee3507b625", "filename": "src/rustc/middle/mem_categorization.rs", "status": "modified", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmem_categorization.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -55,6 +55,7 @@ enum categorization {\n     cat_discr(cmt, ast::node_id),   // match discriminant (see preserve())\n }\n \n+#[cfg(stage0)]\n impl categorization : cmp::Eq {\n     pure fn eq(&&other: categorization) -> bool {\n         match self {\n@@ -117,6 +118,70 @@ impl categorization : cmp::Eq {\n     }\n     pure fn ne(&&other: categorization) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl categorization : cmp::Eq {\n+    pure fn eq(other: &categorization) -> bool {\n+        match self {\n+            cat_rvalue => {\n+                match (*other) {\n+                    cat_rvalue => true,\n+                    _ => false\n+                }\n+            }\n+            cat_special(e0a) => {\n+                match (*other) {\n+                    cat_special(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            cat_local(e0a) => {\n+                match (*other) {\n+                    cat_local(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            cat_binding(e0a) => {\n+                match (*other) {\n+                    cat_binding(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            cat_arg(e0a) => {\n+                match (*other) {\n+                    cat_arg(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            cat_stack_upvar(e0a) => {\n+                match (*other) {\n+                    cat_stack_upvar(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            cat_deref(e0a, e1a, e2a) => {\n+                match (*other) {\n+                    cat_deref(e0b, e1b, e2b) =>\n+                        e0a == e0b && e1a == e1b && e2a == e2b,\n+                    _ => false\n+                }\n+            }\n+            cat_comp(e0a, e1a) => {\n+                match (*other) {\n+                    cat_comp(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            cat_discr(e0a, e1a) => {\n+                match (*other) {\n+                    cat_discr(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &categorization) -> bool { !self.eq(other) }\n+}\n \n // different kinds of pointers:\n enum ptr_kind {\n@@ -126,6 +191,7 @@ enum ptr_kind {\n     unsafe_ptr\n }\n \n+#[cfg(stage0)]\n impl ptr_kind : cmp::Eq {\n     pure fn eq(&&other: ptr_kind) -> bool {\n         match self {\n@@ -157,6 +223,39 @@ impl ptr_kind : cmp::Eq {\n     }\n     pure fn ne(&&other: ptr_kind) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl ptr_kind : cmp::Eq {\n+    pure fn eq(other: &ptr_kind) -> bool {\n+        match self {\n+            uniq_ptr => {\n+                match (*other) {\n+                    uniq_ptr => true,\n+                    _ => false\n+                }\n+            }\n+            gc_ptr => {\n+                match (*other) {\n+                    gc_ptr => true,\n+                    _ => false\n+                }\n+            }\n+            region_ptr(e0a) => {\n+                match (*other) {\n+                    region_ptr(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            unsafe_ptr => {\n+                match (*other) {\n+                    unsafe_ptr => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &ptr_kind) -> bool { !self.eq(other) }\n+}\n \n // I am coining the term \"components\" to mean \"pieces of a data\n // structure accessible without a dereference\":\n@@ -169,6 +268,7 @@ enum comp_kind {\n                ast::mutability)  // mutability of vec content\n }\n \n+#[cfg(stage0)]\n impl comp_kind : cmp::Eq {\n     pure fn eq(&&other: comp_kind) -> bool {\n         match self {\n@@ -200,6 +300,39 @@ impl comp_kind : cmp::Eq {\n     }\n     pure fn ne(&&other: comp_kind) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl comp_kind : cmp::Eq {\n+    pure fn eq(other: &comp_kind) -> bool {\n+        match self {\n+            comp_tuple => {\n+                match (*other) {\n+                    comp_tuple => true,\n+                    _ => false\n+                }\n+            }\n+            comp_variant(e0a) => {\n+                match (*other) {\n+                    comp_variant(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            comp_field(e0a, e1a) => {\n+                match (*other) {\n+                    comp_field(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            comp_index(e0a, e1a) => {\n+                match (*other) {\n+                    comp_index(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &comp_kind) -> bool { !self.eq(other) }\n+}\n \n // different kinds of expressions we might evaluate\n enum special_kind {\n@@ -209,12 +342,21 @@ enum special_kind {\n     sk_heap_upvar\n }\n \n+#[cfg(stage0)]\n impl special_kind : cmp::Eq {\n     pure fn eq(&&other: special_kind) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: special_kind) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl special_kind : cmp::Eq {\n+    pure fn eq(other: &special_kind) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &special_kind) -> bool { !self.eq(other) }\n+}\n \n // a complete categorization of a value indicating where it originated\n // and how it is located, as well as the mutability of the memory in\n@@ -228,6 +370,7 @@ type cmt_ = {id: ast::node_id,        // id of expr/pat producing this value\n \n type cmt = @cmt_;\n \n+#[cfg(stage0)]\n impl cmt_ : cmp::Eq {\n     pure fn eq(&&other: cmt_) -> bool {\n         self.id == other.id &&\n@@ -239,6 +382,19 @@ impl cmt_ : cmp::Eq {\n     }\n     pure fn ne(&&other: cmt_) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl cmt_ : cmp::Eq {\n+    pure fn eq(other: &cmt_) -> bool {\n+        self.id == (*other).id &&\n+        self.span == (*other).span &&\n+        self.cat == (*other).cat &&\n+        self.lp == (*other).lp &&\n+        self.mutbl == (*other).mutbl &&\n+        self.ty == (*other).ty\n+    }\n+    pure fn ne(other: &cmt_) -> bool { !self.eq(other) }\n+}\n \n // a loan path is like a category, but it exists only when the data is\n // interior to the stack frame.  loan paths are used as the key to a\n@@ -250,6 +406,7 @@ enum loan_path {\n     lp_comp(@loan_path, comp_kind)\n }\n \n+#[cfg(stage0)]\n impl loan_path : cmp::Eq {\n     pure fn eq(&&other: loan_path) -> bool {\n         match self {\n@@ -281,6 +438,39 @@ impl loan_path : cmp::Eq {\n     }\n     pure fn ne(&&other: loan_path) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl loan_path : cmp::Eq {\n+    pure fn eq(other: &loan_path) -> bool {\n+        match self {\n+            lp_local(e0a) => {\n+                match (*other) {\n+                    lp_local(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            lp_arg(e0a) => {\n+                match (*other) {\n+                    lp_arg(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            lp_deref(e0a, e1a) => {\n+                match (*other) {\n+                    lp_deref(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            lp_comp(e0a, e1a) => {\n+                match (*other) {\n+                    lp_comp(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &loan_path) -> bool { !self.eq(other) }\n+}\n \n // We pun on *T to mean both actual deref of a ptr as well\n // as accessing of components:"}, {"sha": "ab218a4d49f11127b03ef0d662f5c83dbdbc6fda", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -373,12 +373,22 @@ type region_paramd_items = HashMap<ast::node_id, region_variance>;\n type region_dep = {ambient_variance: region_variance, id: ast::node_id};\n type dep_map = HashMap<ast::node_id, @DVec<region_dep>>;\n \n+#[cfg(stage0)]\n impl region_dep: cmp::Eq {\n     pure fn eq(&&other: region_dep) -> bool {\n         self.ambient_variance == other.ambient_variance && self.id == other.id\n     }\n     pure fn ne(&&other: region_dep) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl region_dep : cmp::Eq {\n+    pure fn eq(other: &region_dep) -> bool {\n+        self.ambient_variance == (*other).ambient_variance &&\n+        self.id == (*other).id\n+    }\n+    pure fn ne(other: &region_dep) -> bool { !self.eq(other) }\n+}\n \n type determine_rp_ctxt_ = {\n     sess: session,"}, {"sha": "ab143cca18bdf75f4da4783ef521589949be8950", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -110,12 +110,21 @@ enum PatternBindingMode {\n     IrrefutableMode\n }\n \n+#[cfg(stage0)]\n impl PatternBindingMode : cmp::Eq {\n     pure fn eq(&&other: PatternBindingMode) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: PatternBindingMode) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl PatternBindingMode : cmp::Eq {\n+    pure fn eq(other: &PatternBindingMode) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &PatternBindingMode) -> bool { !self.eq(other) }\n+}\n \n \n enum Namespace {\n@@ -151,12 +160,21 @@ enum Mutability {\n     Immutable\n }\n \n+#[cfg(stage0)]\n impl Mutability : cmp::Eq {\n     pure fn eq(&&other: Mutability) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: Mutability) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Mutability : cmp::Eq {\n+    pure fn eq(other: &Mutability) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &Mutability) -> bool { !self.eq(other) }\n+}\n \n enum SelfBinding {\n     NoSelfBinding,\n@@ -186,12 +204,21 @@ enum ImportDirectiveNS {\n     AnyNS\n }\n \n+#[cfg(stage0)]\n impl ImportDirectiveNS : cmp::Eq {\n     pure fn eq(&&other: ImportDirectiveNS) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: ImportDirectiveNS) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl ImportDirectiveNS : cmp::Eq {\n+    pure fn eq(other: &ImportDirectiveNS) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &ImportDirectiveNS) -> bool { !self.eq(other) }\n+}\n \n /// Contains data for specific types of import directives.\n enum ImportDirectiveSubclass {\n@@ -282,24 +309,42 @@ enum XrayFlag {\n     Xray        //< Private items can be accessed.\n }\n \n+#[cfg(stage0)]\n impl XrayFlag : cmp::Eq {\n     pure fn eq(&&other: XrayFlag) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: XrayFlag) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl XrayFlag : cmp::Eq {\n+    pure fn eq(other: &XrayFlag) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &XrayFlag) -> bool { !self.eq(other) }\n+}\n \n enum AllowCapturingSelfFlag {\n     AllowCapturingSelf,         //< The \"self\" definition can be captured.\n     DontAllowCapturingSelf,     //< The \"self\" definition cannot be captured.\n }\n \n+#[cfg(stage0)]\n impl AllowCapturingSelfFlag : cmp::Eq {\n     pure fn eq(&&other: AllowCapturingSelfFlag) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: AllowCapturingSelfFlag) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl AllowCapturingSelfFlag : cmp::Eq {\n+    pure fn eq(other: &AllowCapturingSelfFlag) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &AllowCapturingSelfFlag) -> bool { !self.eq(other) }\n+}\n \n enum EnumVariantOrConstResolution {\n     FoundEnumVariant(def),\n@@ -497,12 +542,21 @@ enum Privacy {\n     Public\n }\n \n+#[cfg(stage0)]\n impl Privacy : cmp::Eq {\n     pure fn eq(&&other: Privacy) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: Privacy) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Privacy : cmp::Eq {\n+    pure fn eq(other: &Privacy) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &Privacy) -> bool { !self.eq(other) }\n+}\n \n // Records a possibly-private definition.\n struct Definition {"}, {"sha": "dc667d3ae50ca32a91bae4012634f92981385fa9", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -649,12 +649,21 @@ fn pick_col(m: &[@Match]) -> uint {\n \n enum branch_kind { no_branch, single, switch, compare, }\n \n+#[cfg(stage0)]\n impl branch_kind : cmp::Eq {\n     pure fn eq(&&other: branch_kind) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: branch_kind) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl branch_kind : cmp::Eq {\n+    pure fn eq(other: &branch_kind) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &branch_kind) -> bool { !self.eq(other) }\n+}\n \n // Compiles a comparison between two things.\n fn compare_values(cx: block, lhs: ValueRef, rhs: ValueRef, rhs_t: ty::t) ->"}, {"sha": "b4865044961d7ed9568f89c038532e9b10d48e64", "filename": "src/rustc/middle/trans/callee.rs", "status": "modified", "additions": 52, "deletions": 36, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -266,7 +266,7 @@ fn trans_call(in_cx: block,\n     let _icx = in_cx.insn_ctxt(\"trans_call\");\n     trans_call_inner(\n         in_cx, call_ex.info(), expr_ty(in_cx, f), node_id_type(in_cx, id),\n-        |cx| trans(cx, f), args, dest)\n+        |cx| trans(cx, f), args, dest, DontAutorefArg)\n }\n \n fn trans_rtcall(bcx: block, name: ~str, args: ~[ValueRef], dest: expr::Dest)\n@@ -287,7 +287,7 @@ fn trans_rtcall_or_lang_call(bcx: block, did: ast::def_id, args: ~[ValueRef],\n     return callee::trans_call_inner(\n         bcx, None, fty, rty,\n         |bcx| trans_fn_ref_with_vtables_to_callee(bcx, did, 0, ~[], None),\n-        ArgVals(args), dest);\n+        ArgVals(args), dest, DontAutorefArg);\n }\n \n fn body_contains_ret(body: ast::blk) -> bool {\n@@ -315,7 +315,8 @@ fn trans_call_inner(\n     ret_ty: ty::t,\n     get_callee: fn(block) -> Callee,\n     args: CallArgs,\n-    dest: expr::Dest) -> block\n+    dest: expr::Dest,\n+    autoref_arg: AutorefArg) -> block\n {\n     do base::with_scope(in_cx, call_info, ~\"call\") |cx| {\n         let ret_in_loop = match args {\n@@ -363,7 +364,7 @@ fn trans_call_inner(\n         };\n \n         let args_res = trans_args(bcx, llenv, args, fn_expr_ty,\n-                                  dest, ret_flag);\n+                                  dest, ret_flag, autoref_arg);\n         bcx = args_res.bcx;\n         let mut llargs = args_res.args;\n \n@@ -414,7 +415,8 @@ enum CallArgs {\n }\n \n fn trans_args(cx: block, llenv: ValueRef, args: CallArgs, fn_ty: ty::t,\n-              dest: expr::Dest, ret_flag: Option<ValueRef>)\n+              dest: expr::Dest, ret_flag: Option<ValueRef>,\n+              +autoref_arg: AutorefArg)\n     -> {bcx: block, args: ~[ValueRef], retslot: ValueRef}\n {\n     let _icx = cx.insn_ctxt(\"trans_args\");\n@@ -453,7 +455,8 @@ fn trans_args(cx: block, llenv: ValueRef, args: CallArgs, fn_ty: ty::t,\n         for vec::eachi(arg_exprs) |i, arg_expr| {\n             let arg_val = unpack_result!(bcx, {\n                 trans_arg_expr(bcx, arg_tys[i], arg_expr, &mut temp_cleanups,\n-                               if i == last { ret_flag } else { None })\n+                               if i == last { ret_flag } else { None },\n+                               autoref_arg)\n             });\n             vec::push(llargs, arg_val);\n         }\n@@ -473,13 +476,19 @@ fn trans_args(cx: block, llenv: ValueRef, args: CallArgs, fn_ty: ty::t,\n     return {bcx: bcx, args: llargs, retslot: llretslot};\n }\n \n+enum AutorefArg {\n+    DontAutorefArg,\n+    DoAutorefArg\n+}\n+\n // temp_cleanups: cleanups that should run only if failure occurs before the\n // call takes place:\n fn trans_arg_expr(bcx: block,\n                   formal_ty: ty::arg,\n                   arg_expr: @ast::expr,\n                   temp_cleanups: &mut ~[ValueRef],\n-                  ret_flag: Option<ValueRef>)\n+                  ret_flag: Option<ValueRef>,\n+                  +autoref_arg: AutorefArg)\n     -> Result\n {\n     let _icx = bcx.insn_ctxt(\"trans_arg_expr\");\n@@ -539,38 +548,45 @@ fn trans_arg_expr(bcx: block,\n         let llformal_ty = type_of::type_of(ccx, formal_ty.ty);\n         val = llvm::LLVMGetUndef(llformal_ty);\n     } else {\n-        match arg_mode {\n-            ast::by_ref | ast::by_mutbl_ref => {\n-                val = arg_datum.to_ref_llval(bcx);\n-            }\n-\n-            ast::by_val => {\n-                // NB: avoid running the take glue.\n-                val = arg_datum.to_value_llval(bcx);\n-            }\n-\n-            ast::by_copy | ast::by_move => {\n-                let scratch = scratch_datum(bcx, arg_datum.ty, false);\n-\n-                if arg_mode == ast::by_move {\n-                    // NDM---Doesn't seem like this should be necessary\n-                    if !arg_datum.store_will_move() {\n-                        bcx.sess().span_bug(\n-                            arg_expr.span,\n-                            fmt!(\"move mode but datum will not store: %s\",\n-                                 arg_datum.to_str(bcx.ccx())));\n+        match autoref_arg {\n+            DoAutorefArg => { val = arg_datum.to_ref_llval(bcx); }\n+            DontAutorefArg => {\n+                match arg_mode {\n+                    ast::by_ref | ast::by_mutbl_ref => {\n+                        val = arg_datum.to_ref_llval(bcx);\n                     }\n-                }\n \n-                arg_datum.store_to_datum(bcx, INIT, scratch);\n+                    ast::by_val => {\n+                        // NB: avoid running the take glue.\n+                        val = arg_datum.to_value_llval(bcx);\n+                    }\n \n-                // Technically, ownership of val passes to the callee.\n-                // However, we must cleanup should we fail before the\n-                // callee is actually invoked.\n-                scratch.add_clean(bcx);\n-                vec::push(*temp_cleanups, scratch.val);\n-                val = scratch.val;\n-          }\n+                    ast::by_copy | ast::by_move => {\n+                        let scratch = scratch_datum(bcx, arg_datum.ty, false);\n+\n+                        if arg_mode == ast::by_move {\n+                            // NDM---Doesn't seem like this should be\n+                            // necessary\n+                            if !arg_datum.store_will_move() {\n+                                bcx.sess().span_bug(\n+                                    arg_expr.span,\n+                                    fmt!(\"move mode but datum will not \\\n+                                          store: %s\",\n+                                          arg_datum.to_str(bcx.ccx())));\n+                            }\n+                        }\n+\n+                        arg_datum.store_to_datum(bcx, INIT, scratch);\n+\n+                        // Technically, ownership of val passes to the callee.\n+                        // However, we must cleanup should we fail before the\n+                        // callee is actually invoked.\n+                        scratch.add_clean(bcx);\n+                        vec::push(*temp_cleanups, scratch.val);\n+                        val = scratch.val;\n+                  }\n+                }\n+            }\n         }\n \n         if formal_ty.ty != arg_datum.ty {"}, {"sha": "fbf6c7804c4d7dec367320f6135254e4b79808a4", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -282,6 +282,7 @@ enum cleanup {\n     clean_temp(ValueRef, fn@(block) -> block, cleantype),\n }\n \n+#[cfg(stage0)]\n impl cleantype : cmp::Eq {\n     pure fn eq(&&other: cleantype) -> bool {\n         match self {\n@@ -301,6 +302,27 @@ impl cleantype : cmp::Eq {\n     }\n     pure fn ne(&&other: cleantype) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl cleantype : cmp::Eq {\n+    pure fn eq(other: &cleantype) -> bool {\n+        match self {\n+            normal_exit_only => {\n+                match (*other) {\n+                    normal_exit_only => true,\n+                    _ => false\n+                }\n+            }\n+            normal_exit_and_unwind => {\n+                match (*other) {\n+                    normal_exit_and_unwind => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &cleantype) -> bool { !self.eq(other) }\n+}\n \n // Used to remember and reuse existing cleanup paths\n // target: none means the path ends in an resume instruction\n@@ -1111,6 +1133,7 @@ type mono_id_ = {def: ast::def_id, params: ~[mono_param_id]};\n \n type mono_id = @mono_id_;\n \n+#[cfg(stage0)]\n impl mono_param_id: cmp::Eq {\n     pure fn eq(&&other: mono_param_id) -> bool {\n         match (self, other) {\n@@ -1128,13 +1151,41 @@ impl mono_param_id: cmp::Eq {\n     }\n     pure fn ne(&&other: mono_param_id) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl mono_param_id : cmp::Eq {\n+    pure fn eq(other: &mono_param_id) -> bool {\n+        match (self, (*other)) {\n+            (mono_precise(ty_a, ids_a), mono_precise(ty_b, ids_b)) => {\n+                ty_a == ty_b && ids_a == ids_b\n+            }\n+            (mono_any, mono_any) => true,\n+            (mono_repr(size_a, align_a), mono_repr(size_b, align_b)) => {\n+                size_a == size_b && align_a == align_b\n+            }\n+            (mono_precise(*), _) => false,\n+            (mono_any, _) => false,\n+            (mono_repr(*), _) => false\n+        }\n+    }\n+    pure fn ne(other: &mono_param_id) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl mono_id_: cmp::Eq {\n     pure fn eq(&&other: mono_id_) -> bool {\n         return self.def == other.def && self.params == other.params;\n     }\n     pure fn ne(&&other: mono_id_) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl mono_id_ : cmp::Eq {\n+    pure fn eq(other: &mono_id_) -> bool {\n+        return self.def == (*other).def && self.params == (*other).params;\n+    }\n+    pure fn ne(other: &mono_id_) -> bool { !self.eq(other) }\n+}\n \n impl mono_param_id : to_bytes::IterBytes {\n     pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {"}, {"sha": "a95fed84bafe7fecbe7e2d8627f7a6deab4300bd", "filename": "src/rustc/middle/trans/datum.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -747,6 +747,7 @@ impl DatumBlock {\n     }\n }\n \n+#[cfg(stage0)]\n impl CopyAction : cmp::Eq {\n     pure fn eq(&&other: CopyAction) -> bool {\n         match (self, other) {\n@@ -758,3 +759,16 @@ impl CopyAction : cmp::Eq {\n     }\n     pure fn ne(&&other: CopyAction) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl CopyAction : cmp::Eq {\n+    pure fn eq(other: &CopyAction) -> bool {\n+        match (self, (*other)) {\n+            (INIT, INIT) => true,\n+            (DROP_EXISTING, DROP_EXISTING) => true,\n+            (INIT, _) => false,\n+            (DROP_EXISTING, _) => false,\n+        }\n+    }\n+    pure fn ne(other: &CopyAction) -> bool { !self.eq(other) }\n+}"}, {"sha": "27a2ad50223e8462fc807d72ed3fc18ad557a8c1", "filename": "src/rustc/middle/trans/expr.rs", "status": "modified", "additions": 45, "deletions": 6, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -110,6 +110,7 @@ use syntax::print::pprust::{expr_to_str};\n use util::ppaux::ty_to_str;\n use util::common::indenter;\n use ty::{AutoPtr, AutoSlice};\n+use callee::{AutorefArg, DoAutorefArg, DontAutorefArg};\n \n // The primary two functions for translating expressions:\n export trans_to_datum, trans_into;\n@@ -146,6 +147,7 @@ impl Dest {\n     }\n }\n \n+#[cfg(stage0)]\n impl Dest : cmp::Eq {\n     pure fn eq(&&other: Dest) -> bool {\n         match (self, other) {\n@@ -157,6 +159,19 @@ impl Dest : cmp::Eq {\n     }\n     pure fn ne(&&other: Dest) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Dest : cmp::Eq {\n+    pure fn eq(other: &Dest) -> bool {\n+        match (self, (*other)) {\n+            (SaveIn(e0a), SaveIn(e0b)) => e0a == e0b,\n+            (Ignore, Ignore) => true,\n+            (SaveIn(*), _) => false,\n+            (Ignore, _) => false,\n+        }\n+    }\n+    pure fn ne(other: &Dest) -> bool { !self.eq(other) }\n+}\n \n fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n     debug!(\"trans_to_datum(expr=%s)\", bcx.expr_to_str(expr));\n@@ -596,15 +611,18 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         }\n         ast::expr_binary(_, lhs, rhs) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            return trans_overloaded_op(bcx, expr, lhs, ~[rhs], dest);\n+            return trans_overloaded_op(bcx, expr, lhs, ~[rhs], dest,\n+                                       DoAutorefArg);\n         }\n         ast::expr_unary(_, subexpr) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            return trans_overloaded_op(bcx, expr, subexpr, ~[], dest);\n+            return trans_overloaded_op(bcx, expr, subexpr, ~[], dest,\n+                                       DontAutorefArg);\n         }\n         ast::expr_index(base, idx) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            return trans_overloaded_op(bcx, expr, base, ~[idx], dest);\n+            return trans_overloaded_op(bcx, expr, base, ~[idx], dest,\n+                                       DontAutorefArg);\n         }\n         ast::expr_cast(val, _) => {\n             return meth::trans_trait_cast(bcx, val, expr.id, dest);\n@@ -1302,15 +1320,16 @@ fn trans_overloaded_op(bcx: block,\n                        expr: @ast::expr,\n                        rcvr: @ast::expr,\n                        +args: ~[@ast::expr],\n-                       dest: Dest) -> block\n+                       dest: Dest,\n+                       +autoref_arg: AutorefArg) -> block\n {\n     let origin = bcx.ccx().maps.method_map.get(expr.id);\n     let fty = node_id_type(bcx, expr.callee_id);\n     return callee::trans_call_inner(\n         bcx, expr.info(), fty,\n         expr_ty(bcx, expr),\n         |bcx| meth::trans_method_callee(bcx, expr.callee_id, rcvr, origin),\n-        callee::ArgExprs(args), dest);\n+        callee::ArgExprs(args), dest, autoref_arg);\n }\n \n fn int_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n@@ -1347,6 +1366,7 @@ enum cast_kind {\n     cast_other,\n }\n \n+#[cfg(stage0)]\n impl cast_kind : cmp::Eq {\n     pure fn eq(&&other: cast_kind) -> bool {\n         match (self, other) {\n@@ -1364,6 +1384,25 @@ impl cast_kind : cmp::Eq {\n     }\n     pure fn ne(&&other: cast_kind) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl cast_kind : cmp::Eq {\n+    pure fn eq(other: &cast_kind) -> bool {\n+        match (self, (*other)) {\n+            (cast_pointer, cast_pointer) => true,\n+            (cast_integral, cast_integral) => true,\n+            (cast_float, cast_float) => true,\n+            (cast_enum, cast_enum) => true,\n+            (cast_other, cast_other) => true,\n+            (cast_pointer, _) => false,\n+            (cast_integral, _) => false,\n+            (cast_float, _) => false,\n+            (cast_enum, _) => false,\n+            (cast_other, _) => false,\n+        }\n+    }\n+    pure fn ne(other: &cast_kind) -> bool { !self.eq(other) }\n+}\n \n fn cast_type_kind(t: ty::t) -> cast_kind {\n     match ty::get(t).sty {\n@@ -1461,7 +1500,7 @@ fn trans_assign_op(bcx: block,\n         // FIXME(#2582) evaluates the receiver twice!!\n         let scratch = scratch_datum(bcx, dst_datum.ty, false);\n         let bcx = trans_overloaded_op(bcx, expr, dst, ~[src],\n-                                      SaveIn(scratch.val));\n+                                      SaveIn(scratch.val), DoAutorefArg);\n         return scratch.move_to_datum(bcx, DROP_EXISTING, dst_datum);\n     }\n "}, {"sha": "71c342101d0d63116739c945227bbaae225d579a", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -40,12 +40,21 @@ enum x86_64_reg_class {\n     memory_class\n }\n \n+#[cfg(stage0)]\n impl x86_64_reg_class: cmp::Eq {\n     pure fn eq(&&other: x86_64_reg_class) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: x86_64_reg_class) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl x86_64_reg_class : cmp::Eq {\n+    pure fn eq(other: &x86_64_reg_class) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &x86_64_reg_class) -> bool { !self.eq(other) }\n+}\n \n fn is_sse(++c: x86_64_reg_class) -> bool {\n     return match c {\n@@ -974,7 +983,7 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n             bcx = trans_call_inner(\n                 bcx, None, fty, ty::mk_nil(bcx.tcx()),\n                 |bcx| Callee {bcx: bcx, data: Closure(datum)},\n-                ArgVals(~[frameaddress_val]), Ignore);\n+                ArgVals(~[frameaddress_val]), Ignore, DontAutorefArg);\n         }\n         ~\"morestack_addr\" => {\n             // XXX This is a hack to grab the address of this particular"}, {"sha": "82843d431a4e2f12356b3363ae95086a2ec88c60", "filename": "src/rustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -99,7 +99,7 @@ fn trans_self_arg(bcx: block, base: @ast::expr,\n     let self_arg = {mode: mentry.self_arg.mode,\n                     ty: monomorphize_type(bcx, mentry.self_arg.ty)};\n     let result = trans_arg_expr(bcx, self_arg, base,\n-                                &mut temp_cleanups, None);\n+                                &mut temp_cleanups, None, DontAutorefArg);\n \n     // FIXME(#3446)---this is wrong, actually.  The temp_cleanups\n     // should be revoked only after all arguments have been passed."}, {"sha": "8ef9cad4964151ebae424a65251b8382872fa897", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -10,7 +10,7 @@ use type_of::*;\n use ast::def_id;\n use util::ppaux::ty_to_str;\n use datum::*;\n-use callee::ArgVals;\n+use callee::{ArgVals, DontAutorefArg};\n use expr::SaveIn;\n \n enum reflector = {\n@@ -74,7 +74,7 @@ impl reflector {\n             self.bcx, None, mth_ty, bool_ty,\n             |bcx| meth::trans_trait_callee_from_llval(bcx, mth_ty,\n                                                       mth_idx, v),\n-            ArgVals(args), SaveIn(scratch.val));\n+            ArgVals(args), SaveIn(scratch.val), DontAutorefArg);\n         let result = scratch.to_value_llval(bcx);\n         let next_bcx = sub_block(bcx, ~\"next\");\n         CondBr(bcx, result, next_bcx.llbb, self.final_bcx.llbb);"}, {"sha": "54cc640cebf83f13175338174bb46acd97972cca", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -26,6 +26,7 @@ type nominal_id_ = {did: ast::def_id, parent_id: Option<ast::def_id>,\n                     tps: ~[ty::t]};\n type nominal_id = @nominal_id_;\n \n+#[cfg(stage0)]\n impl nominal_id_ : core::cmp::Eq {\n     pure fn eq(&&other: nominal_id_) -> bool {\n         if self.did != other.did ||\n@@ -41,6 +42,23 @@ impl nominal_id_ : core::cmp::Eq {\n         ! (self == other)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl nominal_id_ : core::cmp::Eq {\n+    pure fn eq(other: &nominal_id_) -> bool {\n+        if self.did != other.did ||\n+            self.parent_id != other.parent_id {\n+            false\n+        } else {\n+            do vec::all2(self.tps, other.tps) |m_tp, n_tp| {\n+                ty::type_id(m_tp) == ty::type_id(n_tp)\n+            }\n+        }\n+    }\n+    pure fn ne(other: &nominal_id_) -> bool {\n+        ! (self == *other)\n+    }\n+}\n \n impl nominal_id_ : to_bytes::IterBytes {\n     pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {"}, {"sha": "ca8680fd8d5404cfa0d8600b9e62032dc75c402b", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 530, "deletions": 0, "changes": 530, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -235,6 +235,7 @@ type field_ty = {\n type creader_cache_key = {cnum: int, pos: uint, len: uint};\n type creader_cache = HashMap<creader_cache_key, t>;\n \n+#[cfg(stage0)]\n impl creader_cache_key : cmp::Eq {\n     pure fn eq(&&other: creader_cache_key) -> bool {\n         self.cnum == other.cnum &&\n@@ -245,6 +246,18 @@ impl creader_cache_key : cmp::Eq {\n         !(self == other)\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl creader_cache_key : cmp::Eq {\n+    pure fn eq(other: &creader_cache_key) -> bool {\n+        self.cnum == (*other).cnum &&\n+            self.pos == (*other).pos &&\n+            self.len == (*other).len\n+    }\n+    pure fn ne(other: &creader_cache_key) -> bool {\n+        !(self == (*other))\n+    }\n+}\n \n impl creader_cache_key : to_bytes::IterBytes {\n     pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n@@ -254,12 +267,21 @@ impl creader_cache_key : to_bytes::IterBytes {\n \n type intern_key = {sty: sty, o_def_id: Option<ast::def_id>};\n \n+#[cfg(stage0)]\n impl intern_key: cmp::Eq {\n     pure fn eq(&&other: intern_key) -> bool {\n         self.sty == other.sty && self.o_def_id == other.o_def_id\n     }\n     pure fn ne(&&other: intern_key) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl intern_key : cmp::Eq {\n+    pure fn eq(other: &intern_key) -> bool {\n+        self.sty == (*other).sty && self.o_def_id == (*other).o_def_id\n+    }\n+    pure fn ne(other: &intern_key) -> bool { !self.eq(other) }\n+}\n \n impl intern_key : to_bytes::IterBytes {\n     pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n@@ -278,6 +300,7 @@ type opt_region_variance = Option<region_variance>;\n #[auto_serialize]\n enum region_variance { rv_covariant, rv_invariant, rv_contravariant }\n \n+#[cfg(stage0)]\n impl region_variance: cmp::Eq {\n     pure fn eq(&&other: region_variance) -> bool {\n         match (self, other) {\n@@ -291,6 +314,21 @@ impl region_variance: cmp::Eq {\n     }\n     pure fn ne(&&other: region_variance) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl region_variance : cmp::Eq {\n+    pure fn eq(other: &region_variance) -> bool {\n+        match (self, (*other)) {\n+            (rv_covariant, rv_covariant) => true,\n+            (rv_invariant, rv_invariant) => true,\n+            (rv_contravariant, rv_contravariant) => true,\n+            (rv_covariant, _) => false,\n+            (rv_invariant, _) => false,\n+            (rv_contravariant, _) => false\n+        }\n+    }\n+    pure fn ne(other: &region_variance) -> bool { !self.eq(other) }\n+}\n \n #[auto_serialize]\n type AutoAdjustment = {\n@@ -410,12 +448,21 @@ impl closure_kind : to_bytes::IterBytes {\n     }\n }\n \n+#[cfg(stage0)]\n impl closure_kind : cmp::Eq {\n     pure fn eq(&&other: closure_kind) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: closure_kind) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl closure_kind : cmp::Eq {\n+    pure fn eq(other: &closure_kind) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &closure_kind) -> bool { !self.eq(other) }\n+}\n \n enum fn_proto {\n     proto_bare,             // supertype of all other protocols\n@@ -434,6 +481,7 @@ impl fn_proto : to_bytes::IterBytes {\n     }\n }\n \n+#[cfg(stage0)]\n impl fn_proto : cmp::Eq {\n     pure fn eq(&&other: fn_proto) -> bool {\n         match self {\n@@ -453,6 +501,27 @@ impl fn_proto : cmp::Eq {\n     }\n     pure fn ne(&&other: fn_proto) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl fn_proto : cmp::Eq {\n+    pure fn eq(other: &fn_proto) -> bool {\n+        match self {\n+            proto_bare => {\n+                match (*other) {\n+                    proto_bare => true,\n+                    _ => false\n+                }\n+            }\n+            proto_vstore(e0a) => {\n+                match (*other) {\n+                    proto_vstore(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &fn_proto) -> bool { !self.eq(other) }\n+}\n \n /**\n  * Meta information about a closure.\n@@ -493,12 +562,21 @@ type FnTy = FnTyBase<FnMeta>;\n \n type param_ty = {idx: uint, def_id: def_id};\n \n+#[cfg(stage0)]\n impl param_ty: cmp::Eq {\n     pure fn eq(&&other: param_ty) -> bool {\n         self.idx == other.idx && self.def_id == other.def_id\n     }\n     pure fn ne(&&other: param_ty) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl param_ty : cmp::Eq {\n+    pure fn eq(other: &param_ty) -> bool {\n+        self.idx == (*other).idx && self.def_id == (*other).def_id\n+    }\n+    pure fn ne(other: &param_ty) -> bool { !self.eq(other) }\n+}\n \n impl param_ty : to_bytes::IterBytes {\n     pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n@@ -1816,29 +1894,59 @@ fn remove_copyable(k: kind) -> kind {\n     k - kind_(KIND_MASK_COPY | KIND_MASK_DEFAULT_MODE)\n }\n \n+#[cfg(stage0)]\n impl kind: ops::BitAnd<kind,kind> {\n     pure fn bitand(other: kind) -> kind {\n         unsafe {\n             lower_kind(self, other)\n         }\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl kind : ops::BitAnd<kind,kind> {\n+    pure fn bitand(other: &kind) -> kind {\n+        unsafe {\n+            lower_kind(self, (*other))\n+        }\n+    }\n+}\n \n+#[cfg(stage0)]\n impl kind: ops::BitOr<kind,kind> {\n     pure fn bitor(other: kind) -> kind {\n         unsafe {\n             raise_kind(self, other)\n         }\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl kind : ops::BitOr<kind,kind> {\n+    pure fn bitor(other: &kind) -> kind {\n+        unsafe {\n+            raise_kind(self, (*other))\n+        }\n+    }\n+}\n \n+#[cfg(stage0)]\n impl kind: ops::Sub<kind,kind> {\n     pure fn sub(other: kind) -> kind {\n         unsafe {\n             kind_(*self & !*other)\n         }\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl kind : ops::Sub<kind,kind> {\n+    pure fn sub(other: &kind) -> kind {\n+        unsafe {\n+            kind_(*self & !*(*other))\n+        }\n+    }\n+}\n \n // Using these query functions is preferable to direct comparison or matching\n // against the kind constants, as we may modify the kind hierarchy in the\n@@ -3932,27 +4040,55 @@ pure fn determine_inherited_purity(parent_purity: ast::purity,\n     } else { child_purity }\n }\n \n+#[cfg(stage0)]\n impl mt : cmp::Eq {\n     pure fn eq(&&other: mt) -> bool {\n         self.ty == other.ty && self.mutbl == other.mutbl\n     }\n     pure fn ne(&&other: mt) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl mt : cmp::Eq {\n+    pure fn eq(other: &mt) -> bool {\n+        self.ty == (*other).ty && self.mutbl == (*other).mutbl\n+    }\n+    pure fn ne(other: &mt) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl arg : cmp::Eq {\n     pure fn eq(&&other: arg) -> bool {\n         self.mode == other.mode && self.ty == other.ty\n     }\n     pure fn ne(&&other: arg) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl arg : cmp::Eq {\n+    pure fn eq(other: &arg) -> bool {\n+        self.mode == (*other).mode && self.ty == (*other).ty\n+    }\n+    pure fn ne(other: &arg) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl field : cmp::Eq {\n     pure fn eq(&&other: field) -> bool {\n         self.ident == other.ident && self.mt == other.mt\n     }\n     pure fn ne(&&other: field) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl field : cmp::Eq {\n+    pure fn eq(other: &field) -> bool {\n+        self.ident == (*other).ident && self.mt == (*other).mt\n+    }\n+    pure fn ne(other: &field) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl vstore : cmp::Eq {\n     pure fn eq(&&other: vstore) -> bool {\n         match self {\n@@ -3984,7 +4120,41 @@ impl vstore : cmp::Eq {\n     }\n     pure fn ne(&&other: vstore) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl vstore : cmp::Eq {\n+    pure fn eq(other: &vstore) -> bool {\n+        match self {\n+            vstore_fixed(e0a) => {\n+                match (*other) {\n+                    vstore_fixed(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            vstore_uniq => {\n+                match (*other) {\n+                    vstore_uniq => true,\n+                    _ => false\n+                }\n+            }\n+            vstore_box => {\n+                match (*other) {\n+                    vstore_box => true,\n+                    _ => false\n+                }\n+            }\n+            vstore_slice(e0a) => {\n+                match (*other) {\n+                    vstore_slice(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &vstore) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl FnMeta : cmp::Eq {\n     pure fn eq(&&other: FnMeta) -> bool {\n         self.purity == other.purity &&\n@@ -3994,42 +4164,101 @@ impl FnMeta : cmp::Eq {\n     }\n     pure fn ne(&&other: FnMeta) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl FnMeta : cmp::Eq {\n+    pure fn eq(other: &FnMeta) -> bool {\n+        self.purity == (*other).purity &&\n+        self.proto == (*other).proto &&\n+        self.bounds == (*other).bounds &&\n+        self.ret_style == (*other).ret_style\n+    }\n+    pure fn ne(other: &FnMeta) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl FnSig : cmp::Eq {\n     pure fn eq(&&other: FnSig) -> bool {\n         self.inputs == other.inputs &&\n         self.output == other.output\n     }\n     pure fn ne(&&other: FnSig) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl FnSig : cmp::Eq {\n+    pure fn eq(other: &FnSig) -> bool {\n+        self.inputs == (*other).inputs &&\n+        self.output == (*other).output\n+    }\n+    pure fn ne(other: &FnSig) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl<M: cmp::Eq> FnTyBase<M> : cmp::Eq {\n     pure fn eq(&&other: FnTyBase<M>) -> bool {\n         self.meta == other.meta && self.sig == other.sig\n     }\n     pure fn ne(&&other: FnTyBase<M>) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<M: cmp::Eq> FnTyBase<M> : cmp::Eq {\n+    pure fn eq(other: &FnTyBase<M>) -> bool {\n+        self.meta == (*other).meta && self.sig == (*other).sig\n+    }\n+    pure fn ne(other: &FnTyBase<M>) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl TyVid: cmp::Eq {\n     pure fn eq(&&other: TyVid) -> bool { *self == *other }\n     pure fn ne(&&other: TyVid) -> bool { *self != *other }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl TyVid : cmp::Eq {\n+    pure fn eq(other: &TyVid) -> bool { *self == *(*other) }\n+    pure fn ne(other: &TyVid) -> bool { *self != *(*other) }\n+}\n \n+#[cfg(stage0)]\n impl IntVid: cmp::Eq {\n     pure fn eq(&&other: IntVid) -> bool { *self == *other }\n     pure fn ne(&&other: IntVid) -> bool { *self != *other }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl IntVid : cmp::Eq {\n+    pure fn eq(other: &IntVid) -> bool { *self == *(*other) }\n+    pure fn ne(other: &IntVid) -> bool { *self != *(*other) }\n+}\n \n+#[cfg(stage0)]\n impl FnVid: cmp::Eq {\n     pure fn eq(&&other: FnVid) -> bool { *self == *other }\n     pure fn ne(&&other: FnVid) -> bool { *self != *other }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl FnVid : cmp::Eq {\n+    pure fn eq(other: &FnVid) -> bool { *self == *(*other) }\n+    pure fn ne(other: &FnVid) -> bool { *self != *(*other) }\n+}\n \n+#[cfg(stage0)]\n impl RegionVid: cmp::Eq {\n     pure fn eq(&&other: RegionVid) -> bool { *self == *other }\n     pure fn ne(&&other: RegionVid) -> bool { *self != *other }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl RegionVid : cmp::Eq {\n+    pure fn eq(other: &RegionVid) -> bool { *self == *(*other) }\n+    pure fn ne(other: &RegionVid) -> bool { *self != *(*other) }\n+}\n \n+#[cfg(stage0)]\n impl region : cmp::Eq {\n     pure fn eq(&&other: region) -> bool {\n         match self {\n@@ -4067,7 +4296,47 @@ impl region : cmp::Eq {\n     }\n     pure fn ne(&&other: region) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl region : cmp::Eq {\n+    pure fn eq(other: &region) -> bool {\n+        match self {\n+            re_bound(e0a) => {\n+                match (*other) {\n+                    re_bound(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            re_free(e0a, e1a) => {\n+                match (*other) {\n+                    re_free(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            re_scope(e0a) => {\n+                match (*other) {\n+                    re_scope(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            re_static => {\n+                match (*other) {\n+                    re_static => true,\n+                    _ => false\n+                }\n+            }\n+            re_var(e0a) => {\n+                match (*other) {\n+                    re_var(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &region) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl bound_region : cmp::Eq {\n     pure fn eq(&&other: bound_region) -> bool {\n         match self {\n@@ -4099,7 +4368,41 @@ impl bound_region : cmp::Eq {\n     }\n     pure fn ne(&&other: bound_region) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl bound_region : cmp::Eq {\n+    pure fn eq(other: &bound_region) -> bool {\n+        match self {\n+            br_self => {\n+                match (*other) {\n+                    br_self => true,\n+                    _ => false\n+                }\n+            }\n+            br_anon(e0a) => {\n+                match (*other) {\n+                    br_anon(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            br_named(e0a) => {\n+                match (*other) {\n+                    br_named(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            br_cap_avoid(e0a, e1a) => {\n+                match (*other) {\n+                    br_cap_avoid(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &bound_region) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl substs : cmp::Eq {\n     pure fn eq(&&other: substs) -> bool {\n         self.self_r == other.self_r &&\n@@ -4108,14 +4411,34 @@ impl substs : cmp::Eq {\n     }\n     pure fn ne(&&other: substs) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl substs : cmp::Eq {\n+    pure fn eq(other: &substs) -> bool {\n+        self.self_r == (*other).self_r &&\n+        self.self_ty == (*other).self_ty &&\n+        self.tps == (*other).tps\n+    }\n+    pure fn ne(other: &substs) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl InferTy : cmp::Eq {\n     pure fn eq(&&other: InferTy) -> bool {\n         self.to_hash() == other.to_hash()\n     }\n     pure fn ne(&&other: InferTy) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl InferTy : cmp::Eq {\n+    pure fn eq(other: &InferTy) -> bool {\n+        self.to_hash() == (*other).to_hash()\n+    }\n+    pure fn ne(other: &InferTy) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl sty : cmp::Eq {\n     pure fn eq(&&other: sty) -> bool {\n         match self {\n@@ -4274,7 +4597,168 @@ impl sty : cmp::Eq {\n     }\n     pure fn ne(&&other: sty) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl sty : cmp::Eq {\n+    pure fn eq(other: &sty) -> bool {\n+        match self {\n+            ty_nil => {\n+                match (*other) {\n+                    ty_nil => true,\n+                    _ => false\n+                }\n+            }\n+            ty_bot => {\n+                match (*other) {\n+                    ty_bot => true,\n+                    _ => false\n+                }\n+            }\n+            ty_bool => {\n+                match (*other) {\n+                    ty_bool => true,\n+                    _ => false\n+                }\n+            }\n+            ty_int(e0a) => {\n+                match (*other) {\n+                    ty_int(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_uint(e0a) => {\n+                match (*other) {\n+                    ty_uint(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_float(e0a) => {\n+                match (*other) {\n+                    ty_float(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_estr(e0a) => {\n+                match (*other) {\n+                    ty_estr(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_enum(e0a, e1a) => {\n+                match (*other) {\n+                    ty_enum(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            ty_box(e0a) => {\n+                match (*other) {\n+                    ty_box(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_uniq(e0a) => {\n+                match (*other) {\n+                    ty_uniq(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_evec(e0a, e1a) => {\n+                match (*other) {\n+                    ty_evec(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            ty_ptr(e0a) => {\n+                match (*other) {\n+                    ty_ptr(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_rptr(e0a, e1a) => {\n+                match (*other) {\n+                    ty_rptr(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            ty_rec(e0a) => {\n+                match (*other) {\n+                    ty_rec(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_fn(e0a) => {\n+                match (*other) {\n+                    ty_fn(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_trait(e0a, e1a, e2a) => {\n+                match (*other) {\n+                    ty_trait(e0b, e1b, e2b) =>\n+                        e0a == e0b && e1a == e1b && e2a == e2b,\n+                    _ => false\n+                }\n+            }\n+            ty_class(e0a, e1a) => {\n+                match (*other) {\n+                    ty_class(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            ty_tup(e0a) => {\n+                match (*other) {\n+                    ty_tup(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_infer(e0a) => {\n+                match (*other) {\n+                    ty_infer(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_param(e0a) => {\n+                match (*other) {\n+                    ty_param(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_self => {\n+                match (*other) {\n+                    ty_self => true,\n+                    _ => false\n+                }\n+            }\n+            ty_type => {\n+                match (*other) {\n+                    ty_type => true,\n+                    _ => false\n+                }\n+            }\n+            ty_opaque_box => {\n+                match (*other) {\n+                    ty_opaque_box => true,\n+                    _ => false\n+                }\n+            }\n+            ty_opaque_closure_ptr(e0a) => {\n+                match (*other) {\n+                    ty_opaque_closure_ptr(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_unboxed_vec(e0a) => {\n+                match (*other) {\n+                    ty_unboxed_vec(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &sty) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl param_bound : cmp::Eq {\n     pure fn eq(&&other: param_bound) -> bool {\n         match self {\n@@ -4312,11 +4796,57 @@ impl param_bound : cmp::Eq {\n     }\n     pure fn ne(&&other: param_bound) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl param_bound : cmp::Eq {\n+    pure fn eq(other: &param_bound) -> bool {\n+        match self {\n+            bound_copy => {\n+                match (*other) {\n+                    bound_copy => true,\n+                    _ => false\n+                }\n+            }\n+            bound_owned => {\n+                match (*other) {\n+                    bound_owned => true,\n+                    _ => false\n+                }\n+            }\n+            bound_send => {\n+                match (*other) {\n+                    bound_send => true,\n+                    _ => false\n+                }\n+            }\n+            bound_const => {\n+                match (*other) {\n+                    bound_const => true,\n+                    _ => false\n+                }\n+            }\n+            bound_trait(e0a) => {\n+                match (*other) {\n+                    bound_trait(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &param_bound) -> bool { !self.eq(other) }\n+}\n \n+#[cfg(stage0)]\n impl kind : cmp::Eq {\n     pure fn eq(&&other: kind) -> bool { *self == *other }\n     pure fn ne(&&other: kind) -> bool { *self != *other }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl kind : cmp::Eq {\n+    pure fn eq(other: &kind) -> bool { *self == *(*other) }\n+    pure fn ne(other: &kind) -> bool { *self != *(*other) }\n+}\n \n \n // Local Variables:"}, {"sha": "932e32762a6e8f4b9e5576b65f80b0723e43e090", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -940,6 +940,13 @@ fn lookup_field_ty(tcx: ty::ctxt,\n     }\n }\n \n+// Controls whether the arguments are automatically referenced. This is useful\n+// for overloaded binary and unary operators.\n+enum DerefArgs {\n+    DontDerefArgs,\n+    DoDerefArgs\n+}\n+\n fn check_expr_with_unifier(fcx: @fn_ctxt,\n                            expr: @ast::expr,\n                            expected: Option<ty::t>,\n@@ -955,7 +962,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         call_expr_id: ast::node_id,\n         in_fty: ty::t,\n         callee_expr: @ast::expr,\n-        args: ~[@ast::expr]) -> {fty: ty::t, bot: bool} {\n+        args: ~[@ast::expr],\n+        deref_args: DerefArgs) -> {fty: ty::t, bot: bool} {\n \n         let mut bot = false;\n \n@@ -1043,7 +1051,20 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n                 if is_block == check_blocks {\n                     debug!(\"checking the argument\");\n-                    let formal_ty = formal_tys[i];\n+                    let mut formal_ty = formal_tys[i];\n+\n+                    match deref_args {\n+                        DoDerefArgs => {\n+                            match ty::get(formal_ty).sty {\n+                                ty::ty_rptr(_, mt) => formal_ty = mt.ty,\n+                                _ => {\n+                                    fcx.ccx.tcx.sess.span_bug(arg.span,\n+                                                              ~\"no ref\");\n+                                }\n+                            }\n+                        }\n+                        DontDerefArgs => {}\n+                    }\n \n                     bot |= check_expr_with_unifier(\n                         fcx, arg, Some(formal_ty),\n@@ -1082,7 +1103,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // Call the generic checker.\n         let fty = {\n             let r = check_call_inner(fcx, sp, call_expr_id,\n-                                     fn_ty, f, args);\n+                                     fn_ty, f, args, DontDerefArgs);\n             bot |= r.bot;\n             r.fty\n         };\n@@ -1138,7 +1159,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n     fn lookup_op_method(fcx: @fn_ctxt, op_ex: @ast::expr,\n                         self_ex: @ast::expr, self_t: ty::t,\n-                        opname: ast::ident, args: ~[@ast::expr])\n+                        opname: ast::ident, args: ~[@ast::expr],\n+                        +deref_args: DerefArgs)\n         -> Option<(ty::t, bool)>\n     {\n         match method::lookup(fcx, op_ex, self_ex,\n@@ -1147,7 +1169,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             let {fty: method_ty, bot: bot} = {\n                 let method_ty = fcx.node_ty(op_ex.callee_id);\n                 check_call_inner(fcx, op_ex.span, op_ex.id,\n-                                 method_ty, op_ex, args)\n+                                 method_ty, op_ex, args, deref_args)\n             };\n             fcx.ccx.method_map.insert(op_ex.id, origin);\n             Some((ty::ty_fn_ret(method_ty), bot))\n@@ -1182,7 +1204,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             let rhs_bot = check_expr_with(fcx, rhs, tvar);\n \n             let result_t = match op {\n-                ast::eq | ast::ne | ast::lt | ast::le | ast::ge | ast::gt => {\n+                ast::eq | ast::ne | ast::lt | ast::le | ast::ge |\n+                ast::gt => {\n                     ty::mk_bool(tcx)\n                 }\n                 _ => {\n@@ -1212,7 +1235,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           Some(name) => {\n             match lookup_op_method(fcx, ex, lhs_expr, lhs_resolved_t,\n                                    fcx.tcx().sess.ident_of(name),\n-                                   ~[rhs]) {\n+                                   ~[rhs], DoDerefArgs) {\n               Some(pair) => return pair,\n               _ => ()\n             }\n@@ -1246,7 +1269,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                        ex: @ast::expr,\n                        rhs_expr: @ast::expr, rhs_t: ty::t) -> ty::t {\n         match lookup_op_method(fcx, ex, rhs_expr, rhs_t,\n-                               fcx.tcx().sess.ident_of(mname), ~[]) {\n+                               fcx.tcx().sess.ident_of(mname), ~[],\n+                               DontDerefArgs) {\n           Some((ret_ty, _)) => ret_ty,\n           _ => {\n             fcx.ccx.tcx.sess.span_err(\n@@ -2054,7 +2078,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                                                             raw_base_t);\n                   match lookup_op_method(fcx, expr, base, resolved,\n                                          tcx.sess.ident_of(~\"index\"),\n-                                         ~[idx]) {\n+                                         ~[idx], DontDerefArgs) {\n                       Some((ret_ty, _)) => fcx.write_ty(id, ret_ty),\n                       _ => {\n                           tcx.sess.span_fatal("}, {"sha": "de99046412535fb2bd3314b18d2ac79e41d45b34", "filename": "src/rustc/middle/typeck/infer/region_var_bindings.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -329,6 +329,7 @@ enum Constraint {\n     ConstrainVarSubReg(RegionVid, region)\n }\n \n+#[cfg(stage0)]\n impl Constraint: cmp::Eq {\n     pure fn eq(&&other: Constraint) -> bool {\n         match (self, other) {\n@@ -348,6 +349,27 @@ impl Constraint: cmp::Eq {\n     }\n     pure fn ne(&&other: Constraint) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Constraint : cmp::Eq {\n+    pure fn eq(other: &Constraint) -> bool {\n+        match (self, (*other)) {\n+            (ConstrainVarSubVar(v0a, v1a), ConstrainVarSubVar(v0b, v1b)) => {\n+                v0a == v0b && v1a == v1b\n+            }\n+            (ConstrainRegSubVar(ra, va), ConstrainRegSubVar(rb, vb)) => {\n+                ra == rb && va == vb\n+            }\n+            (ConstrainVarSubReg(va, ra), ConstrainVarSubReg(vb, rb)) => {\n+                va == vb && ra == rb\n+            }\n+            (ConstrainVarSubVar(*), _) => false,\n+            (ConstrainRegSubVar(*), _) => false,\n+            (ConstrainVarSubReg(*), _) => false\n+        }\n+    }\n+    pure fn ne(other: &Constraint) -> bool { !self.eq(other) }\n+}\n \n impl Constraint : to_bytes::IterBytes {\n    pure  fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n@@ -369,12 +391,21 @@ struct TwoRegions {\n     b: region,\n }\n \n+#[cfg(stage0)]\n impl TwoRegions: cmp::Eq {\n     pure fn eq(&&other: TwoRegions) -> bool {\n         self.a == other.a && self.b == other.b\n     }\n     pure fn ne(&&other: TwoRegions) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl TwoRegions : cmp::Eq {\n+    pure fn eq(other: &TwoRegions) -> bool {\n+        self.a == (*other).a && self.b == (*other).b\n+    }\n+    pure fn ne(other: &TwoRegions) -> bool { !self.eq(other) }\n+}\n \n impl TwoRegions : to_bytes::IterBytes {\n     pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n@@ -755,21 +786,39 @@ priv impl RegionVarBindings {\n \n enum Direction { Incoming = 0, Outgoing = 1 }\n \n+#[cfg(stage0)]\n impl Direction : cmp::Eq {\n     pure fn eq(&&other: Direction) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: Direction) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Direction : cmp::Eq {\n+    pure fn eq(other: &Direction) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &Direction) -> bool { !self.eq(other) }\n+}\n \n enum Classification { Expanding, Contracting }\n \n+#[cfg(stage0)]\n impl Classification : cmp::Eq {\n     pure fn eq(&&other: Classification) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: Classification) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Classification : cmp::Eq {\n+    pure fn eq(other: &Classification) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &Classification) -> bool { !self.eq(other) }\n+}\n \n enum GraphNodeValue { NoValue, Value(region), ErrorValue }\n "}, {"sha": "2dddc42b50c5a108f2f110d21d8ce94d125da0cf", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -18,12 +18,21 @@ enum OutputFormat {\n     PandocHtml\n }\n \n+#[cfg(stage0)]\n impl OutputFormat : cmp::Eq {\n     pure fn eq(&&other: OutputFormat) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: OutputFormat) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl OutputFormat : cmp::Eq {\n+    pure fn eq(other: &OutputFormat) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &OutputFormat) -> bool { !self.eq(other) }\n+}\n \n /// How to organize the output\n enum OutputStyle {\n@@ -33,12 +42,21 @@ enum OutputStyle {\n     DocPerMod\n }\n \n+#[cfg(stage0)]\n impl OutputStyle : cmp::Eq {\n     pure fn eq(&&other: OutputStyle) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: OutputStyle) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl OutputStyle : cmp::Eq {\n+    pure fn eq(other: &OutputStyle) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &OutputStyle) -> bool { !self.eq(other) }\n+}\n \n /// The configuration for a rustdoc session\n type Config = {"}, {"sha": "126ea10c30108b96355a86d9ce848dea1b25a0ce", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 260, "deletions": 2, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -6,27 +6,44 @@ type Doc_ = {\n     pages: ~[Page]\n };\n \n+#[cfg(stage0)]\n impl Doc_ : cmp::Eq {\n     pure fn eq(&&other: Doc_) -> bool {\n         self.pages == other.pages\n     }\n     pure fn ne(&&other: Doc_) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Doc_ : cmp::Eq {\n+    pure fn eq(other: &Doc_) -> bool {\n+        self.pages == (*other).pages\n+    }\n+    pure fn ne(other: &Doc_) -> bool { !self.eq(other) }\n+}\n \n enum Doc {\n     Doc_(Doc_)\n }\n \n+#[cfg(stage0)]\n impl Doc : cmp::Eq {\n     pure fn eq(&&other: Doc) -> bool { *self == *other }\n     pure fn ne(&&other: Doc) -> bool { *self != *other }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Doc : cmp::Eq {\n+    pure fn eq(other: &Doc) -> bool { *self == *(*other) }\n+    pure fn ne(other: &Doc) -> bool { *self != *(*other) }\n+}\n \n enum Page {\n     CratePage(CrateDoc),\n     ItemPage(ItemTag)\n }\n \n+#[cfg(stage0)]\n impl Page : cmp::Eq {\n     pure fn eq(&&other: Page) -> bool {\n         match self {\n@@ -46,18 +63,48 @@ impl Page : cmp::Eq {\n     }\n     pure fn ne(&&other: Page) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Page : cmp::Eq {\n+    pure fn eq(other: &Page) -> bool {\n+        match self {\n+            CratePage(e0a) => {\n+                match (*other) {\n+                    CratePage(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ItemPage(e0a) => {\n+                match (*other) {\n+                    ItemPage(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &Page) -> bool { !self.eq(other) }\n+}\n \n enum Implementation {\n     Required,\n     Provided,\n }\n \n+#[cfg(stage0)]\n impl Implementation : cmp::Eq {\n     pure fn eq(&&other: Implementation) -> bool {\n         (self as uint) == (other as uint)\n     }\n     pure fn ne(&&other: Implementation) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Implementation : cmp::Eq {\n+    pure fn eq(other: &Implementation) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &Implementation) -> bool { !self.eq(other) }\n+}\n \n \n /**\n@@ -69,12 +116,21 @@ type Section = {\n     body: ~str\n };\n \n+#[cfg(stage0)]\n impl Section : cmp::Eq {\n     pure fn eq(&&other: Section) -> bool {\n         self.header == other.header && self.body == other.body\n     }\n     pure fn ne(&&other: Section) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Section : cmp::Eq {\n+    pure fn eq(other: &Section) -> bool {\n+        self.header == (*other).header && self.body == (*other).body\n+    }\n+    pure fn ne(other: &Section) -> bool { !self.eq(other) }\n+}\n \n // FIXME (#2596): We currently give topmod the name of the crate.  There\n // would probably be fewer special cases if the crate had its own name\n@@ -83,12 +139,21 @@ type CrateDoc = {\n     topmod: ModDoc,\n };\n \n+#[cfg(stage0)]\n impl CrateDoc : cmp::Eq {\n     pure fn eq(&&other: CrateDoc) -> bool {\n         self.topmod == other.topmod\n     }\n     pure fn ne(&&other: CrateDoc) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl CrateDoc : cmp::Eq {\n+    pure fn eq(other: &CrateDoc) -> bool {\n+        self.topmod == (*other).topmod\n+    }\n+    pure fn ne(other: &CrateDoc) -> bool { !self.eq(other) }\n+}\n \n enum ItemTag {\n     ModTag(ModDoc),\n@@ -102,6 +167,7 @@ enum ItemTag {\n     StructTag(StructDoc)\n }\n \n+#[cfg(stage0)]\n impl ItemTag : cmp::Eq {\n     pure fn eq(&&other: ItemTag) -> bool {\n         match self {\n@@ -163,6 +229,69 @@ impl ItemTag : cmp::Eq {\n     }\n     pure fn ne(&&other: ItemTag) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl ItemTag : cmp::Eq {\n+    pure fn eq(other: &ItemTag) -> bool {\n+        match self {\n+            ModTag(e0a) => {\n+                match (*other) {\n+                    ModTag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            NmodTag(e0a) => {\n+                match (*other) {\n+                    NmodTag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ConstTag(e0a) => {\n+                match (*other) {\n+                    ConstTag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            FnTag(e0a) => {\n+                match (*other) {\n+                    FnTag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            EnumTag(e0a) => {\n+                match (*other) {\n+                    EnumTag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            TraitTag(e0a) => {\n+                match (*other) {\n+                    TraitTag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ImplTag(e0a) => {\n+                match (*other) {\n+                    ImplTag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            TyTag(e0a) => {\n+                match (*other) {\n+                    TyTag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            StructTag(e0a) => {\n+                match (*other) {\n+                    StructTag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &ItemTag) -> bool { !self.eq(other) }\n+}\n \n type ItemDoc = {\n     id: AstId,\n@@ -175,6 +304,7 @@ type ItemDoc = {\n     reexport: bool\n };\n \n+#[cfg(stage0)]\n impl ItemDoc : cmp::Eq {\n     pure fn eq(&&other: ItemDoc) -> bool {\n         self.id == other.id &&\n@@ -187,25 +317,49 @@ impl ItemDoc : cmp::Eq {\n     }\n     pure fn ne(&&other: ItemDoc) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl ItemDoc : cmp::Eq {\n+    pure fn eq(other: &ItemDoc) -> bool {\n+        self.id == (*other).id &&\n+        self.name == (*other).name &&\n+        self.path == (*other).path &&\n+        self.brief == (*other).brief &&\n+        self.desc == (*other).desc &&\n+        self.sections == (*other).sections &&\n+        self.reexport == (*other).reexport\n+    }\n+    pure fn ne(other: &ItemDoc) -> bool { !self.eq(other) }\n+}\n \n type SimpleItemDoc = {\n     item: ItemDoc,\n     sig: Option<~str>\n };\n \n+#[cfg(stage0)]\n impl SimpleItemDoc : cmp::Eq {\n     pure fn eq(&&other: SimpleItemDoc) -> bool {\n         self.item == other.item && self.sig == other.sig\n     }\n     pure fn ne(&&other: SimpleItemDoc) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl SimpleItemDoc : cmp::Eq {\n+    pure fn eq(other: &SimpleItemDoc) -> bool {\n+        self.item == (*other).item && self.sig == (*other).sig\n+    }\n+    pure fn ne(other: &SimpleItemDoc) -> bool { !self.eq(other) }\n+}\n \n type ModDoc_ = {\n     item: ItemDoc,\n     items: ~[ItemTag],\n     index: Option<Index>\n };\n \n+#[cfg(stage0)]\n impl ModDoc_ : cmp::Eq {\n     pure fn eq(&&other: ModDoc_) -> bool {\n         self.item == other.item &&\n@@ -214,22 +368,40 @@ impl ModDoc_ : cmp::Eq {\n     }\n     pure fn ne(&&other: ModDoc_) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl ModDoc_ : cmp::Eq {\n+    pure fn eq(other: &ModDoc_) -> bool {\n+        self.item == (*other).item &&\n+        self.items == (*other).items &&\n+        self.index == (*other).index\n+    }\n+    pure fn ne(other: &ModDoc_) -> bool { !self.eq(other) }\n+}\n \n enum ModDoc {\n     ModDoc_(ModDoc_)\n }\n \n+#[cfg(stage0)]\n impl ModDoc : cmp::Eq {\n     pure fn eq(&&other: ModDoc) -> bool { *self == *other }\n     pure fn ne(&&other: ModDoc) -> bool { *self != *other }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl ModDoc : cmp::Eq {\n+    pure fn eq(other: &ModDoc) -> bool { *self == *(*other) }\n+    pure fn ne(other: &ModDoc) -> bool { *self != *(*other) }\n+}\n \n type NmodDoc = {\n     item: ItemDoc,\n     fns: ~[FnDoc],\n     index: Option<Index>\n };\n \n+#[cfg(stage0)]\n impl NmodDoc : cmp::Eq {\n     pure fn eq(&&other: NmodDoc) -> bool {\n         self.item == other.item &&\n@@ -238,6 +410,16 @@ impl NmodDoc : cmp::Eq {\n     }\n     pure fn ne(&&other: NmodDoc) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl NmodDoc : cmp::Eq {\n+    pure fn eq(other: &NmodDoc) -> bool {\n+        self.item == (*other).item &&\n+        self.fns == (*other).fns &&\n+        self.index == (*other).index\n+    }\n+    pure fn ne(other: &NmodDoc) -> bool { !self.eq(other) }\n+}\n \n type ConstDoc = SimpleItemDoc;\n \n@@ -248,19 +430,29 @@ type EnumDoc = {\n     variants: ~[VariantDoc]\n };\n \n+#[cfg(stage0)]\n impl EnumDoc : cmp::Eq {\n     pure fn eq(&&other: EnumDoc) -> bool {\n         self.item == other.item && self.variants == other.variants\n     }\n     pure fn ne(&&other: EnumDoc) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl EnumDoc : cmp::Eq {\n+    pure fn eq(other: &EnumDoc) -> bool {\n+        self.item == (*other).item && self.variants == (*other).variants\n+    }\n+    pure fn ne(other: &EnumDoc) -> bool { !self.eq(other) }\n+}\n \n type VariantDoc = {\n     name: ~str,\n     desc: Option<~str>,\n     sig: Option<~str>\n };\n \n+#[cfg(stage0)]\n impl VariantDoc : cmp::Eq {\n     pure fn eq(&&other: VariantDoc) -> bool {\n         self.name == other.name &&\n@@ -269,18 +461,37 @@ impl VariantDoc : cmp::Eq {\n     }\n     pure fn ne(&&other: VariantDoc) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl VariantDoc : cmp::Eq {\n+    pure fn eq(other: &VariantDoc) -> bool {\n+        self.name == (*other).name &&\n+        self.desc == (*other).desc &&\n+        self.sig == (*other).sig\n+    }\n+    pure fn ne(other: &VariantDoc) -> bool { !self.eq(other) }\n+}\n \n type TraitDoc = {\n     item: ItemDoc,\n     methods: ~[MethodDoc]\n };\n \n+#[cfg(stage0)]\n impl TraitDoc : cmp::Eq {\n     pure fn eq(&&other: TraitDoc) -> bool {\n         self.item == other.item && self.methods == other.methods\n     }\n     pure fn ne(&&other: TraitDoc) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl TraitDoc : cmp::Eq {\n+    pure fn eq(other: &TraitDoc) -> bool {\n+        self.item == (*other).item && self.methods == (*other).methods\n+    }\n+    pure fn ne(other: &TraitDoc) -> bool { !self.eq(other) }\n+}\n \n type MethodDoc = {\n     name: ~str,\n@@ -291,6 +502,7 @@ type MethodDoc = {\n     implementation: Implementation,\n };\n \n+#[cfg(stage0)]\n impl MethodDoc : cmp::Eq {\n     pure fn eq(&&other: MethodDoc) -> bool {\n         self.name == other.name &&\n@@ -302,6 +514,19 @@ impl MethodDoc : cmp::Eq {\n     }\n     pure fn ne(&&other: MethodDoc) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl MethodDoc : cmp::Eq {\n+    pure fn eq(other: &MethodDoc) -> bool {\n+        self.name == (*other).name &&\n+        self.brief == (*other).brief &&\n+        self.desc == (*other).desc &&\n+        self.sections == (*other).sections &&\n+        self.sig == (*other).sig &&\n+        self.implementation == (*other).implementation\n+    }\n+    pure fn ne(other: &MethodDoc) -> bool { !self.eq(other) }\n+}\n \n type ImplDoc = {\n     item: ItemDoc,\n@@ -310,6 +535,7 @@ type ImplDoc = {\n     methods: ~[MethodDoc]\n };\n \n+#[cfg(stage0)]\n impl ImplDoc : cmp::Eq {\n     pure fn eq(&&other: ImplDoc) -> bool {\n         self.item == other.item &&\n@@ -319,6 +545,17 @@ impl ImplDoc : cmp::Eq {\n     }\n     pure fn ne(&&other: ImplDoc) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl ImplDoc : cmp::Eq {\n+    pure fn eq(other: &ImplDoc) -> bool {\n+        self.item == (*other).item &&\n+        self.trait_types == (*other).trait_types &&\n+        self.self_ty == (*other).self_ty &&\n+        self.methods == (*other).methods\n+    }\n+    pure fn ne(other: &ImplDoc) -> bool { !self.eq(other) }\n+}\n \n type TyDoc = SimpleItemDoc;\n \n@@ -329,24 +566,33 @@ type StructDoc = {\n };\n \n impl StructDoc : cmp::Eq {\n-    pure fn eq(&&other: StructDoc) -> bool {\n+    pure fn eq(other: &StructDoc) -> bool {\n         return self.item == other.item\n             && self.fields == other.fields\n             && self.sig == other.sig;\n     }\n-    pure fn ne(&&other: StructDoc) -> bool { !self.eq(other) }\n+    pure fn ne(other: &StructDoc) -> bool { !self.eq(other) }\n }\n \n type Index = {\n     entries: ~[IndexEntry]\n };\n \n+#[cfg(stage0)]\n impl Index : cmp::Eq {\n     pure fn eq(&&other: Index) -> bool {\n         self.entries == other.entries\n     }\n     pure fn ne(&&other: Index) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Index : cmp::Eq {\n+    pure fn eq(other: &Index) -> bool {\n+        self.entries == (*other).entries\n+    }\n+    pure fn ne(other: &Index) -> bool { !self.eq(other) }\n+}\n \n /**\n  * A single entry in an index\n@@ -365,6 +611,7 @@ type IndexEntry = {\n     link: ~str\n };\n \n+#[cfg(stage0)]\n impl IndexEntry : cmp::Eq {\n     pure fn eq(&&other: IndexEntry) -> bool {\n         self.kind == other.kind &&\n@@ -374,6 +621,17 @@ impl IndexEntry : cmp::Eq {\n     }\n     pure fn ne(&&other: IndexEntry) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl IndexEntry : cmp::Eq {\n+    pure fn eq(other: &IndexEntry) -> bool {\n+        self.kind == (*other).kind &&\n+        self.name == (*other).name &&\n+        self.brief == (*other).brief &&\n+        self.link == (*other).link\n+    }\n+    pure fn ne(other: &IndexEntry) -> bool { !self.eq(other) }\n+}\n \n impl Doc {\n     fn CrateDoc() -> CrateDoc {"}, {"sha": "b0a4b6469d8d4f8be0490f5962c3beecf572396f", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -23,6 +23,7 @@ struct cmplx {\n     im: f64\n }\n \n+#[cfg(stage0)]\n impl cmplx : ops::Mul<cmplx,cmplx> {\n     pure fn mul(x: cmplx) -> cmplx {\n         cmplx {\n@@ -31,7 +32,18 @@ impl cmplx : ops::Mul<cmplx,cmplx> {\n         }\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl cmplx : ops::Mul<cmplx,cmplx> {\n+    pure fn mul(x: &cmplx) -> cmplx {\n+        cmplx {\n+            re: self.re*(*x).re - self.im*(*x).im,\n+            im: self.re*(*x).im + self.im*(*x).re\n+        }\n+    }\n+}\n \n+#[cfg(stage0)]\n impl cmplx : ops::Add<cmplx,cmplx> {\n     pure fn add(x: cmplx) -> cmplx {\n         cmplx {\n@@ -40,6 +52,16 @@ impl cmplx : ops::Add<cmplx,cmplx> {\n         }\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl cmplx : ops::Add<cmplx,cmplx> {\n+    pure fn add(x: &cmplx) -> cmplx {\n+        cmplx {\n+            re: self.re + (*x).re,\n+            im: self.im + (*x).im\n+        }\n+    }\n+}\n \n type line = {i: uint, b: ~[u8]};\n "}, {"sha": "7bba80d2a9eac8b921369d6c1cc28a899fade418", "filename": "src/test/compile-fail/borrowck-loan-in-overloaded-op.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -2,11 +2,19 @@\n \n enum foo = ~uint;\n \n+#[cfg(stage0)]\n impl foo: Add<foo, foo> {\n     pure fn add(f: foo) -> foo {\n         foo(~(**self + **f))\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl foo : Add<foo, foo> {\n+    pure fn add(f: &foo) -> foo {\n+        foo(~(**self + **(*f)))\n+    }\n+}\n \n fn main() {\n     let x = foo(~3);"}, {"sha": "cc555dce476e7dfc14dc1a5fec456e906024ab6a", "filename": "src/test/compile-fail/borrowck-loan-rcvr-overloaded-op.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -1,13 +1,26 @@\n+// xfail-test\n+// xfail-fast\n+\n+// XFAIL'd because of error message problems with demoded Add.\n+\n struct Point { \n     x: int,\n     y: int,\n }\n \n+#[cfg(stage0)]\n impl Point : ops::Add<int,int> {\n     pure fn add(&&z: int) -> int {\n         self.x + self.y + z\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Point : ops::Add<int,int> {\n+    pure fn add(z: &int) -> int {\n+        self.x + self.y + (*z)\n+    }\n+}\n \n impl Point {\n     fn times(z: int) -> int {"}, {"sha": "0f6eaee0d46ae62a7779f75344f63135b1fe93a7", "filename": "src/test/compile-fail/issue-2587-2.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Fcompile-fail%2Fissue-2587-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Fcompile-fail%2Fissue-2587-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2587-2.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -1,3 +1,8 @@\n+// xfail-fast\n+// xfail-test\n+\n+// XFAIL'd due to problems with error messages on demoded Add.\n+\n #[legacy_modes];\n \n fn foo<T: Copy>(+_t: T) { fail; }\n@@ -11,11 +16,19 @@ struct S {\n \n fn S(x: int) -> S { S { x: x } }\n \n+#[cfg(stage0)]\n impl S: Add<S, S> {\n     pure fn add(rhs: S) -> S {\n         S { x: self.x + rhs.x }\n     }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl S : Add<S, S> {\n+    pure fn add(rhs: &S) -> S {\n+        S { x: self.x + (*rhs).x }\n+    }\n+}\n \n fn main() {\n    let v = S(5);"}, {"sha": "227f589397e92a80a499cf7ee34e3f2b90ba7fd5", "filename": "src/test/compile-fail/issue-3344.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -1,7 +1,7 @@\n enum thing = uint;\n impl thing : cmp::Ord { //~ ERROR missing method `gt`\n-    pure fn lt(&&other: thing) -> bool { *self < *other }\n-    pure fn le(&&other: thing) -> bool { *self < *other }\n-    pure fn ge(&&other: thing) -> bool { *self < *other }\n+    pure fn lt(other: &thing) -> bool { *self < *other }\n+    pure fn le(other: &thing) -> bool { *self < *other }\n+    pure fn ge(other: &thing) -> bool { *self < *other }\n }\n fn main() {}"}, {"sha": "3a07faa75c5e591b7eb6fbf90ede7b64d55a1709", "filename": "src/test/run-pass/auto_serialize.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -47,77 +47,78 @@ enum expr {\n }\n \n impl an_enum : cmp::Eq {\n-    pure fn eq(&&other: an_enum) -> bool {\n-        self.v == other.v\n+    pure fn eq(other: &an_enum) -> bool {\n+        self.v == (*other).v\n     }\n-    pure fn ne(&&other: an_enum) -> bool { !self.eq(other) }\n+    pure fn ne(other: &an_enum) -> bool { !self.eq(other) }\n }\n \n impl point : cmp::Eq {\n-    pure fn eq(&&other: point) -> bool {\n-        self.x == other.x && self.y == other.y\n+    pure fn eq(other: &point) -> bool {\n+        self.x == (*other).x && self.y == (*other).y\n     }\n-    pure fn ne(&&other: point) -> bool { !self.eq(other) }\n+    pure fn ne(other: &point) -> bool { !self.eq(other) }\n }\n \n impl<T:cmp::Eq> quark<T> : cmp::Eq {\n-    pure fn eq(&&other: quark<T>) -> bool {\n+    pure fn eq(other: &quark<T>) -> bool {\n         match self {\n-          top(ref q) => match other {\n+          top(ref q) => match (*other) {\n             top(ref r) => q == r,\n             bottom(_) => false\n           },\n-          bottom(ref q) => match other {\n+          bottom(ref q) => match (*other) {\n             top(_) => false,\n             bottom(ref r) => q == r\n           }\n         }\n     }\n-    pure fn ne(&&other: quark<T>) -> bool { !self.eq(other) }\n+    pure fn ne(other: &quark<T>) -> bool { !self.eq(other) }\n }\n \n \n impl c_like : cmp::Eq {\n-    pure fn eq(&&other: c_like) -> bool {\n-        self as int == other as int\n+    pure fn eq(other: &c_like) -> bool {\n+        self as int == (*other) as int\n     }\n-    pure fn ne(&&other: c_like) -> bool { !self.eq(other) }\n+    pure fn ne(other: &c_like) -> bool { !self.eq(other) }\n }\n \n impl expr : cmp::Eq {\n-    pure fn eq(&&other: expr) -> bool {\n+    pure fn eq(other: &expr) -> bool {\n         match self {\n             val(e0a) => {\n-                match other {\n+                match (*other) {\n                     val(e0b) => e0a == e0b,\n                     _ => false\n                 }\n             }\n             plus(e0a, e1a) => {\n-                match other {\n+                match (*other) {\n                     plus(e0b, e1b) => e0a == e0b && e1a == e1b,\n                     _ => false\n                 }\n             }\n             minus(e0a, e1a) => {\n-                match other {\n+                match (*other) {\n                     minus(e0b, e1b) => e0a == e0b && e1a == e1b,\n                     _ => false\n                 }\n             }\n         }\n     }\n-    pure fn ne(&&other: expr) -> bool { !self.eq(other) }\n+    pure fn ne(other: &expr) -> bool { !self.eq(other) }\n }\n \n #[auto_serialize]\n type spanned<T> = {lo: uint, hi: uint, node: T};\n \n impl<T:cmp::Eq> spanned<T> : cmp::Eq {\n-    pure fn eq(&&other: spanned<T>) -> bool {\n-        self.lo == other.lo && self.hi == other.hi && self.node.eq(other.node)\n+    pure fn eq(other: &spanned<T>) -> bool {\n+        self.lo == (*other).lo && self.hi == (*other).hi &&\n+        self.node.eq(&(*other).node)\n     }\n-    pure fn ne(&&other: spanned<T>) -> bool { !self.eq(other) }\n+    pure fn ne(other: &spanned<T>) -> bool { !self.eq(other) }\n }\n \n #[auto_serialize]"}, {"sha": "bd541e818ad832e070784c9bab7eec9367b11009", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -90,10 +90,10 @@ fn p(x: int, y: int) -> p {\n }\n \n impl p : cmp::Eq {\n-    pure fn eq(&&other: p) -> bool {\n-        self.x == other.x && self.y == other.y\n+    pure fn eq(other: &p) -> bool {\n+        self.x == (*other).x && self.y == (*other).y\n     }\n-    pure fn ne(&&other: p) -> bool { !self.eq(other) }\n+    pure fn ne(other: &p) -> bool { !self.eq(other) }\n }\n \n fn test_class() {"}, {"sha": "95abfc6cb016f01ca62b3481aef6dca8bc590e6e", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -7,10 +7,10 @@ use std::map::*;\n enum cat_type { tuxedo, tabby, tortoiseshell }\n \n impl cat_type : cmp::Eq {\n-    pure fn eq(&&other: cat_type) -> bool {\n-        (self as uint) == (other as uint)\n+    pure fn eq(other: &cat_type) -> bool {\n+        (self as uint) == ((*other) as uint)\n     }\n-    pure fn ne(&&other: cat_type) -> bool { !self.eq(other) }\n+    pure fn ne(other: &cat_type) -> bool { !self.eq(other) }\n }\n \n // Very silly -- this just returns the value of the name field"}, {"sha": "a911bc77d98423137aa66f1cb3b3e46b22f0ac55", "filename": "src/test/run-pass/coherence-impl-in-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fcoherence-impl-in-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fcoherence-impl-in-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoherence-impl-in-fn.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -1,7 +1,7 @@\n fn main() {\n     enum x { foo }\n     impl x : core::cmp::Eq {\n-        pure fn eq(&&other: x) -> bool { self as int == other as int }\n-        pure fn ne(&&other: x) -> bool { !self.eq(other) }\n+        pure fn eq(other: &x) -> bool { self as int == (*other) as int }\n+        pure fn ne(other: &x) -> bool { !self.eq(other) }\n     }\n }"}, {"sha": "dd6adadf98559f78f05cf95bfeb2b43a117de5e5", "filename": "src/test/run-pass/const-struct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fconst-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fconst-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-struct.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -2,10 +2,10 @@\n struct foo { a: int, b: int, c: int }\n \n impl foo : cmp::Eq {\n-    pure fn eq(&&other: foo) -> bool {\n-        self.a == other.a && self.b == other.b && self.c == other.c\n+    pure fn eq(other: &foo) -> bool {\n+        self.a == (*other).a && self.b == (*other).b && self.c == (*other).c\n     }\n-    pure fn ne(&&other: foo) -> bool { !self.eq(other) }\n+    pure fn ne(other: &foo) -> bool { !self.eq(other) }\n }\n \n const x : foo = foo { a:1, b:2, c: 3 };"}, {"sha": "d715cf2adbc7e44bc5662726a3cf950a9133aee9", "filename": "src/test/run-pass/empty-tag.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fempty-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fempty-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-tag.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -1,10 +1,10 @@\n enum chan { chan_t, }\n \n impl chan : cmp::Eq {\n-    pure fn eq(&&other: chan) -> bool {\n-        (self as uint) == (other as uint)\n+    pure fn eq(other: &chan) -> bool {\n+        (self as uint) == ((*other) as uint)\n     }\n-    pure fn ne(&&other: chan) -> bool { !self.eq(other) }\n+    pure fn ne(other: &chan) -> bool { !self.eq(other) }\n }\n \n fn wrapper3(i: chan) {"}, {"sha": "1dc99b082cd338a3c45762589f8eb21b90af4908", "filename": "src/test/run-pass/estr-internal.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6b670c306b8de545afcbcea81bcd592c644409d7/src%2Ftest%2Frun-pass%2Festr-internal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b670c306b8de545afcbcea81bcd592c644409d7/src%2Ftest%2Frun-pass%2Festr-internal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Festr-internal.rs?ref=6b670c306b8de545afcbcea81bcd592c644409d7", "patch": "@@ -1,36 +0,0 @@\n-fn main() {\n-    let x : str/5 = \"hello\"/5;\n-    let _y : str/5 = \"there\"/_;\n-    let mut z = \"thing\"/_;\n-    z = x;\n-    assert z[0] == ('h' as u8);\n-    assert z[4] == ('o' as u8);\n-\n-    let a = \"aaaa\"/_;\n-    let b = \"bbbb\"/_;\n-    let c = \"cccc\"/_;\n-\n-    log(debug, a);\n-\n-    assert a < b;\n-    assert a <= b;\n-    assert a != b;\n-    assert b >= a;\n-    assert b > a;\n-\n-    log(debug, b);\n-\n-    assert b < c;\n-    assert b <= c;\n-    assert b != c;\n-    assert c >= b;\n-    assert c > b;\n-\n-    assert a < c;\n-    assert a <= c;\n-    assert a != c;\n-    assert c >= a;\n-    assert c > a;\n-\n-    log(debug, c);\n-}"}, {"sha": "789660c11f0f9568777b06df922aeb997b2b51eb", "filename": "src/test/run-pass/evec-internal.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fevec-internal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fevec-internal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fevec-internal.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -1,3 +1,8 @@\n+// xfail-test\n+// xfail-fast\n+\n+// Doesn't work; needs a design decision.\n+\n fn main() {\n     let x : [int]/5 = [1,2,3,4,5]/5;\n     let _y : [int]/5 = [1,2,3,4,5]/_;"}, {"sha": "1d0e64dc366c61537fc35bd22472293047b70e31", "filename": "src/test/run-pass/export-unexported-dep.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -9,10 +9,10 @@ mod foo {\n     enum t { t1, t2, }\n \n     impl t : cmp::Eq {\n-        pure fn eq(&&other: t) -> bool {\n-            (self as uint) == (other as uint)\n+        pure fn eq(other: &t) -> bool {\n+            (self as uint) == ((*other) as uint)\n         }\n-        pure fn ne(&&other: t) -> bool { !self.eq(other) }\n+        pure fn ne(other: &t) -> bool { !self.eq(other) }\n     }\n \n     fn f() -> t { return t1; }"}, {"sha": "3daf400054ff44ec98bf01f8c7968cce83bbe0c0", "filename": "src/test/run-pass/expr-alt-struct.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -10,11 +10,12 @@ fn test_rec() {\n }\n \n enum mood { happy, sad, }\n+\n impl mood : cmp::Eq {\n-    pure fn eq(&&other: mood) -> bool {\n-        (self as uint) == (other as uint)\n+    pure fn eq(other: &mood) -> bool {\n+        (self as uint) == ((*other) as uint)\n     }\n-    pure fn ne(&&other: mood) -> bool { !self.eq(other) }\n+    pure fn ne(other: &mood) -> bool { !self.eq(other) }\n }\n \n fn test_tag() {"}, {"sha": "a1fb87f7d9e4538eafa24afc0d2ca59543b48a37", "filename": "src/test/run-pass/expr-if-struct.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -10,11 +10,12 @@ fn test_rec() {\n }\n \n enum mood { happy, sad, }\n+\n impl mood : cmp::Eq {\n-    pure fn eq(&&other: mood) -> bool {\n-        (self as uint) == (other as uint)\n+    pure fn eq(other: &mood) -> bool {\n+        (self as uint) == ((*other) as uint)\n     }\n-    pure fn ne(&&other: mood) -> bool { !self.eq(other) }\n+    pure fn ne(other: &mood) -> bool { !self.eq(other) }\n }\n \n fn test_tag() {"}, {"sha": "3122985d6b5e55d80f097bb728a841fe73ca8dc0", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -9,10 +9,10 @@ mod pipes {\n     }\n \n     impl state : cmp::Eq {\n-        pure fn eq(&&other: state) -> bool {\n-            (self as uint) == (other as uint)\n+        pure fn eq(other: &state) -> bool {\n+            (self as uint) == ((*other) as uint)\n         }\n-        pure fn ne(&&other: state) -> bool { !self.eq(other) }\n+        pure fn ne(other: &state) -> bool { !self.eq(other) }\n     }\n \n     type packet<T: Send> = {"}, {"sha": "d5af5a54377def2ece71d83e4b55e7fc1c2e9930", "filename": "src/test/run-pass/operator-overloading.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-overloading.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -7,14 +7,14 @@ struct Point {\n }\n \n impl Point : ops::Add<Point,Point> {\n-    pure fn add(other: Point) -> Point {\n-        Point {x: self.x + other.x, y: self.y + other.y}\n+    pure fn add(other: &Point) -> Point {\n+        Point {x: self.x + (*other).x, y: self.y + (*other).y}\n     }\n }\n \n impl Point : ops::Sub<Point,Point> {\n-    pure fn sub(other: Point) -> Point {\n-        Point {x: self.x - other.x, y: self.y - other.y}\n+    pure fn sub(other: &Point) -> Point {\n+        Point {x: self.x - (*other).x, y: self.y - (*other).y}\n     }\n }\n \n@@ -31,10 +31,10 @@ impl Point : ops::Index<bool,int> {\n }\n \n impl Point : cmp::Eq {\n-    pure fn eq(&&other: Point) -> bool {\n-        self.x == other.x && self.y == other.y\n+    pure fn eq(other: &Point) -> bool {\n+        self.x == (*other).x && self.y == (*other).y\n     }\n-    pure fn ne(&&other: Point) -> bool { !self.eq(other) }\n+    pure fn ne(other: &Point) -> bool { !self.eq(other) }\n }\n \n fn main() {"}, {"sha": "5688dc5178a1aca888dd29675c33ffe5d31d4f02", "filename": "src/test/run-pass/structured-compare.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fstructured-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fstructured-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructured-compare.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -3,10 +3,10 @@\n enum foo { large, small, }\n \n impl foo : cmp::Eq {\n-    pure fn eq(&&other: foo) -> bool {\n-        (self as uint) == (other as uint)\n+    pure fn eq(other: &foo) -> bool {\n+        (self as uint) == ((*other) as uint)\n     }\n-    pure fn ne(&&other: foo) -> bool { !self.eq(other) }\n+    pure fn ne(other: &foo) -> bool { !self.eq(other) }\n }\n \n fn main() {"}, {"sha": "6e5cce33e21f264688f80077e80f7b764845855e", "filename": "src/test/run-pass/tag-variant-disr-val.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -10,10 +10,10 @@ enum color {\n }\n \n impl color : cmp::Eq {\n-    pure fn eq(&&other: color) -> bool {\n-        (self as uint) == (other as uint)\n+    pure fn eq(other: &color) -> bool {\n+        (self as uint) == ((*other) as uint)\n     }\n-    pure fn ne(&&other: color) -> bool { !self.eq(other) }\n+    pure fn ne(other: &color) -> bool { !self.eq(other) }\n }\n \n fn main() {"}, {"sha": "4167afee35c438fb80d051c44376ce3d4a370188", "filename": "src/test/run-pass/tag.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Ftag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Ftag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -5,23 +5,23 @@\n enum colour { red(int, int), green, }\n \n impl colour : cmp::Eq {\n-    pure fn eq(&&other: colour) -> bool {\n+    pure fn eq(other: &colour) -> bool {\n         match self {\n             red(a0, b0) => {\n-                match other {\n+                match (*other) {\n                     red(a1, b1) => a0 == a1 && b0 == b1,\n                     green => false,\n                 }\n             }\n             green => {\n-                match other {\n+                match (*other) {\n                     red(*) => false,\n                     green => true\n                 }\n             }\n         }\n     }\n-    pure fn ne(&&other: colour) -> bool { !self.eq(other) }\n+    pure fn ne(other: &colour) -> bool { !self.eq(other) }\n }\n \n fn f() { let x = red(1, 2); let y = green; assert (x != y); }"}, {"sha": "a69b7b0c15bc8004b7ad64f7c925c5e160595ee2", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -48,30 +48,30 @@ enum t {\n }\n \n impl t : cmp::Eq {\n-    pure fn eq(&&other: t) -> bool {\n+    pure fn eq(other: &t) -> bool {\n         match self {\n             tag1 => {\n-                match other {\n+                match (*other) {\n                     tag1 => true,\n                     _ => false\n                 }\n             }\n             tag2(e0a) => {\n-                match other {\n+                match (*other) {\n                     tag2(e0b) => e0a == e0b,\n                     _ => false\n                 }\n             }\n             tag3(e0a, e1a, e2a) => {\n-                match other {\n+                match (*other) {\n                     tag3(e0b, e1b, e2b) =>\n                         e0a == e0b && e1a == e1b && e2a == e2b,\n                     _ => false\n                 }\n             }\n         }\n     }\n-    pure fn ne(&&other: t) -> bool { !self.eq(other) }\n+    pure fn ne(other: &t) -> bool { !self.eq(other) }\n }\n \n fn test_tag() {"}, {"sha": "8990c21656799195a365dfee3650a8e9c6274295", "filename": "src/test/run-pass/traits.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -33,14 +33,14 @@ trait Ord < Eq {\n }\n \n // pronounced \"impl of Ord for int\" -- not sold on this yet\n-impl int: Ord {\n-    fn lt(a: int) -> bool {\n-        self < a\n+impl int : Ord {\n+    fn lt(a: &int) -> bool {\n+        self < (*a)\n     }\n \n     // is this the place to put this?\n-    fn eq(a: int) -> bool {\n-        self == a\n+    fn eq(a: &int) -> bool {\n+        self == (*a)\n     }\n }\n "}, {"sha": "a4a685caff6da59e2a1f055ba861ad7cf82606ff", "filename": "src/test/run-pass/while-prelude-drop.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fwhile-prelude-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9117dcb968f96d0e9391dfac50348d4c031d89b3/src%2Ftest%2Frun-pass%2Fwhile-prelude-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhile-prelude-drop.rs?ref=9117dcb968f96d0e9391dfac50348d4c031d89b3", "patch": "@@ -2,23 +2,23 @@\n enum t { a, b(~str), }\n \n impl t : cmp::Eq {\n-    pure fn eq(&&other: t) -> bool {\n+    pure fn eq(other: &t) -> bool {\n         match self {\n             a => {\n-                match other {\n+                match (*other) {\n                     a => true,\n                     b(_) => false\n                 }\n             }\n             b(s0) => {\n-                match other {\n+                match (*other) {\n                     a => false,\n                     b(s1) => s0 == s1\n                 }\n             }\n         }\n     }\n-    pure fn ne(&&other: t) -> bool { !self.eq(other) }\n+    pure fn ne(other: &t) -> bool { !self.eq(other) }\n }\n \n fn make(i: int) -> t {"}]}