{"sha": "e333e6a0dc60ac200e3e4c61dc0e536bee6b98af", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzMzNlNmEwZGM2MGFjMjAwZTNlNGM2MWRjMGU1MzZiZWU2Yjk4YWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-25T14:50:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-25T14:50:13Z"}, "message": "Auto merge of #26630 - eefriedman:recursive-static, r=pnkfelix\n\n***Edit: Fixed now.*** I'm pretty sure the way I'm using LLVMReplaceAllUsesWith here is\r\nunsafe... but before I figure out how to fix that, I'd like a\r\nreality-check: is this actually useful?", "tree": {"sha": "3e3260de94ecb2fa1e12fd351fab7bb3408c128a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e3260de94ecb2fa1e12fd351fab7bb3408c128a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af", "html_url": "https://github.com/rust-lang/rust/commit/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04badd6a973d2499731b49365a121dbc4c9c468e", "url": "https://api.github.com/repos/rust-lang/rust/commits/04badd6a973d2499731b49365a121dbc4c9c468e", "html_url": "https://github.com/rust-lang/rust/commit/04badd6a973d2499731b49365a121dbc4c9c468e"}, {"sha": "0eea0f6e907ff8c8a25a10004bede7b4621b50aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/0eea0f6e907ff8c8a25a10004bede7b4621b50aa", "html_url": "https://github.com/rust-lang/rust/commit/0eea0f6e907ff8c8a25a10004bede7b4621b50aa"}], "stats": {"total": 319, "additions": 214, "deletions": 105}, "files": [{"sha": "55a9a91930045fc8109b7cd8a164188f47411945", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=e333e6a0dc60ac200e3e4c61dc0e536bee6b98af", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This compiler pass detects static items that refer to themselves\n+// This compiler pass detects constants that refer to themselves\n // recursively.\n \n use ast_map;\n@@ -18,6 +18,7 @@ use util::nodemap::NodeMap;\n \n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n+use syntax::feature_gate::emit_feature_err;\n use syntax::visit::Visitor;\n use syntax::visit;\n \n@@ -125,8 +126,27 @@ impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n     }\n     fn with_item_id_pushed<F>(&mut self, id: ast::NodeId, f: F)\n           where F: Fn(&mut Self) {\n-        if self.idstack.iter().any(|x| *x == id) {\n-            span_err!(self.sess, *self.root_span, E0265, \"recursive constant\");\n+        if self.idstack.iter().any(|&x| x == id) {\n+            let any_static = self.idstack.iter().any(|&x| {\n+                if let ast_map::NodeItem(item) = self.ast_map.get(x) {\n+                    if let ast::ItemStatic(..) = item.node {\n+                        true\n+                    } else {\n+                        false\n+                    }\n+                } else {\n+                    false\n+                }\n+            });\n+            if any_static {\n+                if !self.sess.features.borrow().static_recursion {\n+                    emit_feature_err(&self.sess.parse_sess.span_diagnostic,\n+                                     \"static_recursion\",\n+                                     *self.root_span, \"recursive static\");\n+                }\n+            } else {\n+                span_err!(self.sess, *self.root_span, E0265, \"recursive constant\");\n+            }\n             return;\n         }\n         self.idstack.push(id);"}, {"sha": "c331bf8d4610132f5254db20faedcd13ec699325", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=e333e6a0dc60ac200e3e4c61dc0e536bee6b98af", "patch": "@@ -2090,7 +2090,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n           let mut v = TransItemVisitor{ ccx: ccx };\n           v.visit_expr(&**expr);\n \n-          let g = consts::trans_static(ccx, m, item.id);\n+          let g = consts::trans_static(ccx, m, expr, item.id, &item.attrs);\n           update_linkage(ccx, g, Some(item.id), OriginalTranslation);\n       },\n       ast::ItemForeignMod(ref foreign_mod) => {\n@@ -2334,44 +2334,25 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             let sym = || exported_name(ccx, id, ty, &i.attrs);\n \n             let v = match i.node {\n-                ast::ItemStatic(_, _, ref expr) => {\n+                ast::ItemStatic(..) => {\n                     // If this static came from an external crate, then\n                     // we need to get the symbol from csearch instead of\n                     // using the current crate's name/version\n                     // information in the hash of the symbol\n                     let sym = sym();\n                     debug!(\"making {}\", sym);\n \n-                    // We need the translated value here, because for enums the\n-                    // LLVM type is not fully determined by the Rust type.\n-                    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n-                    let (v, ty) = consts::const_expr(ccx, &**expr, empty_substs, None);\n-                    ccx.static_values().borrow_mut().insert(id, v);\n-                    unsafe {\n-                        // boolean SSA values are i1, but they have to be stored in i8 slots,\n-                        // otherwise some LLVM optimization passes don't work as expected\n-                        let llty = if ty.is_bool() {\n-                            llvm::LLVMInt8TypeInContext(ccx.llcx())\n-                        } else {\n-                            llvm::LLVMTypeOf(v)\n-                        };\n-\n-                        // FIXME(nagisa): probably should be declare_global, because no definition\n-                        // is happening here, but we depend on it being defined here from\n-                        // const::trans_static. This all logic should be replaced.\n-                        let g = declare::define_global(ccx, &sym[..],\n-                                                       Type::from_ref(llty)).unwrap_or_else(||{\n-                            ccx.sess().span_fatal(i.span, &format!(\"symbol `{}` is already defined\",\n-                                                                   sym))\n-                        });\n-\n-                        if attr::contains_name(&i.attrs,\n-                                               \"thread_local\") {\n-                            llvm::set_thread_local(g, true);\n-                        }\n-                        ccx.item_symbols().borrow_mut().insert(i.id, sym);\n-                        g\n-                    }\n+                    // Create the global before evaluating the initializer;\n+                    // this is necessary to allow recursive statics.\n+                    let llty = type_of(ccx, ty);\n+                    let g = declare::define_global(ccx, &sym[..],\n+                                                   llty).unwrap_or_else(|| {\n+                        ccx.sess().span_fatal(i.span, &format!(\"symbol `{}` is already defined\",\n+                                                                sym))\n+                    });\n+\n+                    ccx.item_symbols().borrow_mut().insert(i.id, sym);\n+                    g\n                 }\n \n                 ast::ItemFn(_, _, _, abi, _, _) => {\n@@ -2738,6 +2719,13 @@ pub fn trans_crate(tcx: &ty::ctxt, analysis: ty::CrateAnalysis) -> CrateTranslat\n         if ccx.sess().opts.debuginfo != NoDebugInfo {\n             debuginfo::finalize(&ccx);\n         }\n+        for &(old_g, new_g) in ccx.statics_to_rauw().borrow().iter() {\n+            unsafe {\n+                let bitcast = llvm::LLVMConstPointerCast(new_g, llvm::LLVMTypeOf(old_g));\n+                llvm::LLVMReplaceAllUsesWith(old_g, bitcast);\n+                llvm::LLVMDeleteGlobal(old_g);\n+            }\n+        }\n     }\n \n     // Translate the metadata."}, {"sha": "bd9c4a171773c68cb975387da113953a8bb85c7f", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=e333e6a0dc60ac200e3e4c61dc0e536bee6b98af", "patch": "@@ -37,8 +37,9 @@ use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use util::nodemap::NodeMap;\n \n+use std::ffi::{CStr, CString};\n use libc::c_uint;\n-use syntax::{ast, ast_util};\n+use syntax::{ast, ast_util, attr};\n use syntax::parse::token;\n use syntax::ptr::P;\n \n@@ -898,37 +899,70 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                 \"bad constant expression type in consts::const_expr\"),\n     }\n }\n-\n-pub fn trans_static(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) -> ValueRef {\n+pub fn trans_static(ccx: &CrateContext,\n+                    m: ast::Mutability,\n+                    expr: &ast::Expr,\n+                    id: ast::NodeId,\n+                    attrs: &Vec<ast::Attribute>)\n+                    -> ValueRef {\n     unsafe {\n         let _icx = push_ctxt(\"trans_static\");\n         let g = base::get_item_val(ccx, id);\n-        // At this point, get_item_val has already translated the\n-        // constant's initializer to determine its LLVM type.\n-        let v = ccx.static_values().borrow().get(&id).unwrap().clone();\n+\n+        let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n+        let (v, _) = const_expr(ccx, expr, empty_substs, None);\n+\n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n         // otherwise some LLVM optimization passes don't work as expected\n-        let v = if llvm::LLVMTypeOf(v) == Type::i1(ccx).to_ref() {\n-            llvm::LLVMConstZExt(v, Type::i8(ccx).to_ref())\n+        let mut val_llty = llvm::LLVMTypeOf(v);\n+        let v = if val_llty == Type::i1(ccx).to_ref() {\n+            val_llty = Type::i8(ccx).to_ref();\n+            llvm::LLVMConstZExt(v, val_llty)\n         } else {\n             v\n         };\n+\n+        let ty = ccx.tcx().node_id_to_type(id);\n+        let llty = type_of::type_of(ccx, ty);\n+        let g = if val_llty == llty.to_ref() {\n+            g\n+        } else {\n+            // If we created the global with the wrong type,\n+            // correct the type.\n+            let empty_string = CString::new(\"\").unwrap();\n+            let name_str_ref = CStr::from_ptr(llvm::LLVMGetValueName(g));\n+            let name_string = CString::new(name_str_ref.to_bytes()).unwrap();\n+            llvm::LLVMSetValueName(g, empty_string.as_ptr());\n+            let new_g = llvm::LLVMGetOrInsertGlobal(\n+                ccx.llmod(), name_string.as_ptr(), val_llty);\n+            // To avoid breaking any invariants, we leave around the old\n+            // global for the moment; we'll replace all references to it\n+            // with the new global later. (See base::trans_crate.)\n+            ccx.statics_to_rauw().borrow_mut().push((g, new_g));\n+            new_g\n+        };\n         llvm::LLVMSetInitializer(g, v);\n \n         // As an optimization, all shared statics which do not have interior\n         // mutability are placed into read-only memory.\n         if m != ast::MutMutable {\n-            let node_ty = ccx.tcx().node_id_to_type(id);\n-            let tcontents = node_ty.type_contents(ccx.tcx());\n+            let tcontents = ty.type_contents(ccx.tcx());\n             if !tcontents.interior_unsafe() {\n-                llvm::LLVMSetGlobalConstant(g, True);\n+                llvm::LLVMSetGlobalConstant(g, llvm::True);\n             }\n         }\n+\n         debuginfo::create_global_var_metadata(ccx, id, g);\n+\n+        if attr::contains_name(attrs,\n+                               \"thread_local\") {\n+            llvm::set_thread_local(g, true);\n+        }\n         g\n     }\n }\n \n+\n fn get_static_val<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,\n                             ty: Ty<'tcx>) -> ValueRef {\n     if ast_util::is_local(did) { return base::get_item_val(ccx, did.node) }"}, {"sha": "1b6307f28bfdf91bdb62a7c5ed59947f48d76f82", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=e333e6a0dc60ac200e3e4c61dc0e536bee6b98af", "patch": "@@ -118,9 +118,6 @@ pub struct LocalCrateContext<'tcx> {\n     /// Cache of emitted const values\n     const_values: RefCell<FnvHashMap<(ast::NodeId, &'tcx Substs<'tcx>), ValueRef>>,\n \n-    /// Cache of emitted static values\n-    static_values: RefCell<NodeMap<ValueRef>>,\n-\n     /// Cache of external const values\n     extern_const_values: RefCell<DefIdMap<ValueRef>>,\n \n@@ -129,6 +126,12 @@ pub struct LocalCrateContext<'tcx> {\n     /// Cache of closure wrappers for bare fn's.\n     closure_bare_wrapper_cache: RefCell<FnvHashMap<ValueRef, ValueRef>>,\n \n+    /// List of globals for static variables which need to be passed to the\n+    /// LLVM function ReplaceAllUsesWith (RAUW) when translation is complete.\n+    /// (We have to make sure we don't invalidate any ValueRefs referring\n+    /// to constants.)\n+    statics_to_rauw: RefCell<Vec<(ValueRef, ValueRef)>>,\n+\n     lltypes: RefCell<FnvHashMap<Ty<'tcx>, Type>>,\n     llsizingtypes: RefCell<FnvHashMap<Ty<'tcx>, Type>>,\n     adt_reprs: RefCell<FnvHashMap<Ty<'tcx>, Rc<adt::Repr<'tcx>>>>,\n@@ -449,10 +452,10 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 const_unsized: RefCell::new(FnvHashMap()),\n                 const_globals: RefCell::new(FnvHashMap()),\n                 const_values: RefCell::new(FnvHashMap()),\n-                static_values: RefCell::new(NodeMap()),\n                 extern_const_values: RefCell::new(DefIdMap()),\n                 impl_method_cache: RefCell::new(FnvHashMap()),\n                 closure_bare_wrapper_cache: RefCell::new(FnvHashMap()),\n+                statics_to_rauw: RefCell::new(Vec::new()),\n                 lltypes: RefCell::new(FnvHashMap()),\n                 llsizingtypes: RefCell::new(FnvHashMap()),\n                 adt_reprs: RefCell::new(FnvHashMap()),\n@@ -660,10 +663,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.const_values\n     }\n \n-    pub fn static_values<'a>(&'a self) -> &'a RefCell<NodeMap<ValueRef>> {\n-        &self.local.static_values\n-    }\n-\n     pub fn extern_const_values<'a>(&'a self) -> &'a RefCell<DefIdMap<ValueRef>> {\n         &self.local.extern_const_values\n     }\n@@ -677,6 +676,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.closure_bare_wrapper_cache\n     }\n \n+    pub fn statics_to_rauw<'a>(&'a self) -> &'a RefCell<Vec<(ValueRef, ValueRef)>> {\n+        &self.local.statics_to_rauw\n+    }\n+\n     pub fn lltypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, Type>> {\n         &self.local.lltypes\n     }"}, {"sha": "082dafc72bc6ffb8cf6a9752846c78ca268ca177", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 30, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e333e6a0dc60ac200e3e4c61dc0e536bee6b98af", "patch": "@@ -115,6 +115,7 @@ use syntax::attr::AttrMetaMethods;\n use syntax::ast::{self, DefId, Visibility};\n use syntax::ast_util::{self, local_def};\n use syntax::codemap::{self, Span};\n+use syntax::feature_gate::emit_feature_err;\n use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token;\n use syntax::print::pprust;\n@@ -4009,9 +4010,7 @@ fn check_const_with_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n /// Checks whether a type can be represented in memory. In particular, it\n /// identifies types that contain themselves without indirection through a\n-/// pointer, which would mean their size is unbounded. This is different from\n-/// the question of whether a type can be instantiated. See the definition of\n-/// `check_instantiable`.\n+/// pointer, which would mean their size is unbounded.\n pub fn check_representable(tcx: &ty::ctxt,\n                            sp: Span,\n                            item_id: ast::NodeId,\n@@ -4036,31 +4035,19 @@ pub fn check_representable(tcx: &ty::ctxt,\n     return true\n }\n \n-/// Checks whether a type can be created without an instance of itself.\n-/// This is similar but different from the question of whether a type\n-/// can be represented.  For example, the following type:\n-///\n-///     enum foo { None, Some(foo) }\n-///\n-/// is instantiable but is not representable.  Similarly, the type\n-///\n-///     enum foo { Some(@foo) }\n-///\n-/// is representable, but not instantiable.\n+/// Checks whether a type can be constructed at runtime without\n+/// an existing instance of that type.\n pub fn check_instantiable(tcx: &ty::ctxt,\n                           sp: Span,\n-                          item_id: ast::NodeId)\n-                          -> bool {\n+                          item_id: ast::NodeId) {\n     let item_ty = tcx.node_id_to_type(item_id);\n-    if !item_ty.is_instantiable(tcx) {\n-        span_err!(tcx.sess, sp, E0073,\n-            \"this type cannot be instantiated without an \\\n-             instance of itself\");\n-        fileline_help!(tcx.sess, sp, \"consider using `Option<{:?}>`\",\n-             item_ty);\n-        false\n-    } else {\n-        true\n+    if !item_ty.is_instantiable(tcx) &&\n+            !tcx.sess.features.borrow().static_recursion {\n+        emit_feature_err(&tcx.sess.parse_sess.span_diagnostic,\n+                         \"static_recursion\",\n+                         sp,\n+                         \"this type cannot be instantiated at runtime \\\n+                          without an instance of itself\");\n     }\n }\n \n@@ -4199,11 +4186,6 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     do_check(ccx, vs, id, hint);\n \n     check_representable(ccx.tcx, sp, id, \"enum\");\n-\n-    // Check that it is possible to instantiate this enum:\n-    //\n-    // This *sounds* like the same that as representable, but it's\n-    // not.  See def'n of `check_instantiable()` for details.\n     check_instantiable(ccx.tcx, sp, id);\n }\n "}, {"sha": "ee895fb1a96ebbc91006e7cda485d7e090cb28c8", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=e333e6a0dc60ac200e3e4c61dc0e536bee6b98af", "patch": "@@ -160,6 +160,9 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Status)] = &[\n \n     // Allows using #[prelude_import] on glob `use` items.\n     (\"prelude_import\", \"1.2.0\", Active),\n+\n+    // Allows the definition recursive static items.\n+    (\"static_recursion\", \"1.3.0\", Active),\n ];\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n@@ -338,6 +341,7 @@ pub struct Features {\n     /// #![feature] attrs for non-language (library) features\n     pub declared_lib_features: Vec<(InternedString, Span)>,\n     pub const_fn: bool,\n+    pub static_recursion: bool\n }\n \n impl Features {\n@@ -362,6 +366,7 @@ impl Features {\n             declared_stable_lang_features: Vec::new(),\n             declared_lib_features: Vec::new(),\n             const_fn: false,\n+            static_recursion: false\n         }\n     }\n }\n@@ -859,6 +864,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler,\n         declared_stable_lang_features: accepted_features,\n         declared_lib_features: unknown_features,\n         const_fn: cx.has_feature(\"const_fn\"),\n+        static_recursion: cx.has_feature(\"static_recursion\")\n     }\n }\n "}, {"sha": "7c05a817243b498b20d0f1c0fa03947f350595c8", "filename": "src/test/compile-fail/const-recursive.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Ftest%2Fcompile-fail%2Fconst-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Ftest%2Fcompile-fail%2Fconst-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-recursive.rs?ref=e333e6a0dc60ac200e3e4c61dc0e536bee6b98af", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: recursive constant\n-static a: isize = b;\n-static b: isize = a;\n+const a: isize = b; //~ ERROR recursive constant\n+const b: isize = a; //~ ERROR recursive constant\n \n fn main() {\n }"}, {"sha": "0c04e295e1458cb24738f68a7c186e846ba30150", "filename": "src/test/compile-fail/issue-17252.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Ftest%2Fcompile-fail%2Fissue-17252.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Ftest%2Fcompile-fail%2Fissue-17252.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17252.rs?ref=e333e6a0dc60ac200e3e4c61dc0e536bee6b98af", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static FOO: usize = FOO; //~ ERROR recursive constant\n+const FOO: usize = FOO; //~ ERROR recursive constant\n \n fn main() {\n     let _x: [u8; FOO]; // caused stack overflow prior to fix\n     let _y: usize = 1 + {\n-        static BAR: usize = BAR; //~ ERROR recursive constant\n+        const BAR: usize = BAR; //~ ERROR recursive constant\n         let _z: [u8; BAR]; // caused stack overflow prior to fix\n         1\n     };"}, {"sha": "2f1fa6780ab0c969a3ff8dd5acd4a7f23f383f3d", "filename": "src/test/compile-fail/issue-3008-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs?ref=e333e6a0dc60ac200e3e4c61dc0e536bee6b98af", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(static_recursion)]\n+\n enum foo { foo_(bar) }\n struct bar { x: bar }\n //~^ ERROR illegal recursive struct type; wrap the inner value in a box to make it representable\n-//~^^ ERROR this type cannot be instantiated without an instance of itself\n \n fn main() {\n }"}, {"sha": "de0389248408e4cc7b57bf359a98077dc9ace4ae", "filename": "src/test/compile-fail/static-recursion-gate-2.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Ftest%2Fcompile-fail%2Fstatic-recursion-gate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Ftest%2Fcompile-fail%2Fstatic-recursion-gate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-recursion-gate-2.rs?ref=e333e6a0dc60ac200e3e4c61dc0e536bee6b98af", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Z(&'static Z);\n+//~^ ERROR this type cannot be instantiated\n+\n+pub fn main() {}"}, {"sha": "29b5689fa93fdcf12d51dd553fc4e7ab7fcedc6e", "filename": "src/test/compile-fail/static-recursion-gate.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Ftest%2Fcompile-fail%2Fstatic-recursion-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Ftest%2Fcompile-fail%2Fstatic-recursion-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-recursion-gate.rs?ref=e333e6a0dc60ac200e3e4c61dc0e536bee6b98af", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static mut S: *const u8 = unsafe { &S as *const *const u8 as *const u8 };\n+//~^ ERROR recursive static\n+\n+pub fn main() {\n+    unsafe { assert_eq!(S, *(S as *const *const u8)); }\n+}"}, {"sha": "b972934d0604cde3980302472e87e05f4f01ea60", "filename": "src/test/compile-fail/type-recursive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs?ref=e333e6a0dc60ac200e3e4c61dc0e536bee6b98af", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:this type cannot be instantiated\n+// error-pattern:illegal recursive struct type\n struct t1 {\n     foo: isize,\n     foolish: t1"}, {"sha": "aa9a7afc37f8a05e8ffda790256b8b72b2e58890", "filename": "src/test/run-pass/issue-2063-resource.rs", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Ftest%2Frun-pass%2Fissue-2063-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Ftest%2Frun-pass%2Fissue-2063-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2063-resource.rs?ref=e333e6a0dc60ac200e3e4c61dc0e536bee6b98af", "patch": "@@ -8,15 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(static_recursion)]\n \n // test that autoderef of a type like this does not\n // cause compiler to loop.  Note that no instances\n // of such a type could ever be constructed.\n-struct S { //~ ERROR this type cannot be instantiated\n+\n+struct S {\n   x: X,\n   to_str: (),\n }\n \n-struct X(Box<S>); //~ ERROR this type cannot be instantiated\n+struct X(Box<S>);\n \n fn main() {}", "previous_filename": "src/test/compile-fail/issue-2063-resource.rs"}, {"sha": "48da7ecc5089dd8b98949c3f0ad6d9c0d5bdeb45", "filename": "src/test/run-pass/issue-2063.rs", "status": "renamed", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Ftest%2Frun-pass%2Fissue-2063.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Ftest%2Frun-pass%2Fissue-2063.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2063.rs?ref=e333e6a0dc60ac200e3e4c61dc0e536bee6b98af", "patch": "@@ -8,28 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(static_recursion)]\n+\n // test that autoderef of a type like this does not\n // cause compiler to loop.  Note that no instances\n // of such a type could ever be constructed.\n \n-struct t(Box<t>); //~ ERROR this type cannot be instantiated\n+struct T(Box<T>);\n \n-trait to_str_2 {\n-    fn my_to_string() -> String;\n+trait ToStr2 {\n+    fn my_to_string(&self) -> String;\n }\n \n-// I use an impl here because it will cause\n-// the compiler to attempt autoderef and then\n-// try to resolve the method.\n-impl to_str_2 for t {\n-    fn my_to_string() -> String { \"t\".to_string() }\n+impl ToStr2 for T {\n+    fn my_to_string(&self) -> String { \"t\".to_string() }\n }\n \n-fn new_t(x: t) {\n+#[allow(dead_code)]\n+fn new_t(x: T) {\n     x.my_to_string();\n-    // (there used to be an error emitted right here as well. It was\n-    // spurious, at best; if `t` did exist as a type, it clearly would\n-    // have an impl of the `to_str_2` trait.)\n }\n \n fn main() {", "previous_filename": "src/test/compile-fail/issue-2063.rs"}, {"sha": "f3db102ea5a49ae7579c18671e5772a263217621", "filename": "src/test/run-pass/static-recursive.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Ftest%2Frun-pass%2Fstatic-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e333e6a0dc60ac200e3e4c61dc0e536bee6b98af/src%2Ftest%2Frun-pass%2Fstatic-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-recursive.rs?ref=e333e6a0dc60ac200e3e4c61dc0e536bee6b98af", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(static_recursion)]\n+\n+static mut S: *const u8 = unsafe { &S as *const *const u8 as *const u8 };\n+\n+struct StaticDoubleLinked {\n+    prev: &'static StaticDoubleLinked,\n+    next: &'static StaticDoubleLinked,\n+    data: i32,\n+    head: bool\n+}\n+\n+static L1: StaticDoubleLinked = StaticDoubleLinked{prev: &L3, next: &L2, data: 1, head: true};\n+static L2: StaticDoubleLinked = StaticDoubleLinked{prev: &L1, next: &L3, data: 2, head: false};\n+static L3: StaticDoubleLinked = StaticDoubleLinked{prev: &L2, next: &L1, data: 3, head: false};\n+\n+\n+pub fn main() {\n+    unsafe { assert_eq!(S, *(S as *const *const u8)); }\n+\n+    let mut test_vec = Vec::new();\n+    let mut cur = &L1;\n+    loop {\n+        test_vec.push(cur.data);\n+        cur = cur.next;\n+        if cur.head { break }\n+    }\n+    assert_eq!(&test_vec, &[1,2,3]);\n+\n+    let mut test_vec = Vec::new();\n+    let mut cur = &L1;\n+    loop {\n+        cur = cur.prev;\n+        test_vec.push(cur.data);\n+        if cur.head { break }\n+    }\n+    assert_eq!(&test_vec, &[3,2,1]);\n+}"}]}