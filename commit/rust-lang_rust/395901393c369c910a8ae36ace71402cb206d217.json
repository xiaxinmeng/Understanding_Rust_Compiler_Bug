{"sha": "395901393c369c910a8ae36ace71402cb206d217", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5NTkwMTM5M2MzNjljOTEwYThhZTM2YWNlNzE0MDJjYjIwNmQyMTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-24T00:46:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-24T00:46:30Z"}, "message": "auto merge of #19192 : nodakai/rust/generalize-strvector, r=alexcrichton\n\nA single impl supports all of `[T]`, `Vec<T>` and `CVec<T>`.\r\n\r\nOnce `Iterable` is implemented, we will prefer it to `SlicePrelude`.\r\nBut the `with_capacity()` part might become tricky.", "tree": {"sha": "c4b74b6cc36a4b2f369b93ddbfdca21a0ea038e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4b74b6cc36a4b2f369b93ddbfdca21a0ea038e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/395901393c369c910a8ae36ace71402cb206d217", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/395901393c369c910a8ae36ace71402cb206d217", "html_url": "https://github.com/rust-lang/rust/commit/395901393c369c910a8ae36ace71402cb206d217", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/395901393c369c910a8ae36ace71402cb206d217/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2eed1ddbeac4b39364d9c7ee32d5637fbec2d0fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/2eed1ddbeac4b39364d9c7ee32d5637fbec2d0fa", "html_url": "https://github.com/rust-lang/rust/commit/2eed1ddbeac4b39364d9c7ee32d5637fbec2d0fa"}, {"sha": "ef3b88c5f936921fc3ba7968af3dcf1724a17551", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef3b88c5f936921fc3ba7968af3dcf1724a17551", "html_url": "https://github.com/rust-lang/rust/commit/ef3b88c5f936921fc3ba7968af3dcf1724a17551"}], "stats": {"total": 111, "additions": 75, "deletions": 36}, "files": [{"sha": "9982eaefff8f8c6b09027859c9eb45dba44b13aa", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 75, "deletions": 36, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/395901393c369c910a8ae36ace71402cb206d217/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395901393c369c910a8ae36ace71402cb206d217/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=395901393c369c910a8ae36ace71402cb206d217", "patch": "@@ -163,7 +163,7 @@ impl<S: Str> StrVector for [S] {\n     }\n }\n \n-impl<S: Str> StrVector for Vec<S> {\n+impl<S: Str, T: AsSlice<S>> StrVector for T {\n     #[inline]\n     fn concat(&self) -> String {\n         self.as_slice().concat()\n@@ -929,54 +929,93 @@ mod tests {\n         assert_eq!(\"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\", \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".slice_chars(2, 8));\n     }\n \n-    #[test]\n-    fn test_concat() {\n-        fn t(v: &[String], s: &str) {\n-            assert_eq!(v.concat().as_slice(), s);\n+    struct S {\n+        x: [String, .. 2]\n+    }\n+\n+    impl AsSlice<String> for S {\n+        fn as_slice<'a> (&'a self) -> &'a [String] {\n+            &self.x\n+        }\n+    }\n+\n+    fn s(x: &str) -> String { x.into_string() }\n+\n+    macro_rules! test_concat {\n+        ($expected: expr, $string: expr) => {\n+            {\n+                let s = $string.concat();\n+                assert_eq!($expected, s.as_slice());\n+            }\n         }\n-        t(&[String::from_str(\"you\"), String::from_str(\"know\"),\n-            String::from_str(\"I'm\"),\n-            String::from_str(\"no\"), String::from_str(\"good\")],\n-          \"youknowI'mnogood\");\n-        let v: &[String] = &[];\n-        t(v, \"\");\n-        t(&[String::from_str(\"hi\")], \"hi\");\n     }\n \n     #[test]\n-    fn test_connect() {\n-        fn t(v: &[String], sep: &str, s: &str) {\n-            assert_eq!(v.connect(sep).as_slice(), s);\n+    fn test_concat_for_different_types() {\n+        test_concat!(\"ab\", [\"a\", \"b\"]);\n+        test_concat!(\"ab\", [s(\"a\"), s(\"b\")]);\n+        test_concat!(\"ab\", vec![\"a\", \"b\"]);\n+        test_concat!(\"ab\", vec![\"a\", \"b\"].as_slice());\n+        test_concat!(\"ab\", vec![s(\"a\"), s(\"b\")]);\n+\n+        let mut v0 = [\"a\", \"b\"];\n+        let mut v1 = [s(\"a\"), s(\"b\")];\n+        unsafe {\n+            use std::c_vec::CVec;\n+\n+            test_concat!(\"ab\", CVec::new(v0.as_mut_ptr(), v0.len()));\n+            test_concat!(\"ab\", CVec::new(v1.as_mut_ptr(), v1.len()));\n         }\n-        t(&[String::from_str(\"you\"), String::from_str(\"know\"),\n-            String::from_str(\"I'm\"),\n-            String::from_str(\"no\"), String::from_str(\"good\")],\n-          \" \", \"you know I'm no good\");\n-        let v: &[String] = &[];\n-        t(v, \" \", \"\");\n-        t(&[String::from_str(\"hi\")], \" \", \"hi\");\n+\n+        test_concat!(\"ab\", S { x: [s(\"a\"), s(\"b\")] });\n     }\n \n     #[test]\n-    fn test_concat_slices() {\n-        fn t(v: &[&str], s: &str) {\n-            assert_eq!(v.concat().as_slice(), s);\n+    fn test_concat_for_different_lengths() {\n+        let empty: &[&str] = &[];\n+        test_concat!(\"\", empty);\n+        test_concat!(\"a\", [\"a\"]);\n+        test_concat!(\"ab\", [\"a\", \"b\"]);\n+        test_concat!(\"abc\", [\"\", \"a\", \"bc\"]);\n+    }\n+\n+    macro_rules! test_connect {\n+        ($expected: expr, $string: expr, $delim: expr) => {\n+            {\n+                let s = $string.connect($delim);\n+                assert_eq!($expected, s.as_slice());\n+            }\n         }\n-        t(&[\"you\", \"know\", \"I'm\", \"no\", \"good\"], \"youknowI'mnogood\");\n-        let v: &[&str] = &[];\n-        t(v, \"\");\n-        t(&[\"hi\"], \"hi\");\n     }\n \n     #[test]\n-    fn test_connect_slices() {\n-        fn t(v: &[&str], sep: &str, s: &str) {\n-            assert_eq!(v.connect(sep).as_slice(), s);\n+    fn test_connect_for_different_types() {\n+        test_connect!(\"a-b\", [\"a\", \"b\"], \"-\");\n+        let hyphen = \"-\".into_string();\n+        test_connect!(\"a-b\", [s(\"a\"), s(\"b\")], hyphen.as_slice());\n+        test_connect!(\"a-b\", vec![\"a\", \"b\"], hyphen.as_slice());\n+        test_connect!(\"a-b\", vec![\"a\", \"b\"].as_slice(), \"-\");\n+        test_connect!(\"a-b\", vec![s(\"a\"), s(\"b\")], \"-\");\n+\n+        let mut v0 = [\"a\", \"b\"];\n+        let mut v1 = [s(\"a\"), s(\"b\")];\n+        unsafe {\n+            use std::c_vec::CVec;\n+\n+            test_connect!(\"a-b\", CVec::new(v0.as_mut_ptr(), v0.len()), \"-\");\n+            test_connect!(\"a-b\", CVec::new(v1.as_mut_ptr(), v1.len()), hyphen.as_slice());\n         }\n-        t(&[\"you\", \"know\", \"I'm\", \"no\", \"good\"],\n-          \" \", \"you know I'm no good\");\n-        t(&[], \" \", \"\");\n-        t(&[\"hi\"], \" \", \"hi\");\n+\n+        test_connect!(\"a-b\", S { x: [s(\"a\"), s(\"b\")] }, \"-\");\n+    }\n+\n+    #[test]\n+    fn test_connect_for_different_lengths() {\n+        let empty: &[&str] = &[];\n+        test_connect!(\"\", empty, \"-\");\n+        test_connect!(\"a\", [\"a\"], \"-\");\n+        test_connect!(\"a-b\", [\"a\", \"b\"], \"-\");\n+        test_connect!(\"-a-bc\", [\"\", \"a\", \"bc\"], \"-\");\n     }\n \n     #[test]"}]}