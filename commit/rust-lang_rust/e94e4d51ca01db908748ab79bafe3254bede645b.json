{"sha": "e94e4d51ca01db908748ab79bafe3254bede645b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5NGU0ZDUxY2EwMWRiOTA4NzQ4YWI3OWJhZmUzMjU0YmVkZTY0NWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-30T02:04:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-30T02:04:22Z"}, "message": "auto merge of #8120 : blake2-ppc/rust/iterator-fixes, r=thestinger\n\nImplement RandomAccessIterator (RAI) where possible, for Iterator adaptors such as Map, Enumerate, Peek, Skip, Take, Cycle, where the adapted iterator is already RAI, and for collections where it is relevant (ringbuf and bitv).\r\n\r\nAfter discussion with thestinger, remove the RAI impl for VecMutIterator, we cannot soundly provide mutable access with this trait.\r\n\r\nImplement Extendable everywhere FromIterator is already implemented.\r\n\r\nFixes issue #8108.", "tree": {"sha": "304e61473a12f05f2def76160068ba68b579442e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/304e61473a12f05f2def76160068ba68b579442e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e94e4d51ca01db908748ab79bafe3254bede645b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e94e4d51ca01db908748ab79bafe3254bede645b", "html_url": "https://github.com/rust-lang/rust/commit/e94e4d51ca01db908748ab79bafe3254bede645b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e94e4d51ca01db908748ab79bafe3254bede645b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb996bf92edc5c9a34275bae6143f1ada73e6c7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb996bf92edc5c9a34275bae6143f1ada73e6c7f", "html_url": "https://github.com/rust-lang/rust/commit/bb996bf92edc5c9a34275bae6143f1ada73e6c7f"}, {"sha": "99490ad5ba61b2ee69c2cdd70c70857eaf0b895f", "url": "https://api.github.com/repos/rust-lang/rust/commits/99490ad5ba61b2ee69c2cdd70c70857eaf0b895f", "html_url": "https://github.com/rust-lang/rust/commit/99490ad5ba61b2ee69c2cdd70c70857eaf0b895f"}], "stats": {"total": 573, "additions": 471, "deletions": 102}, "files": [{"sha": "90824a653faad2d82315554d7d3c48f8a94491e9", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e94e4d51ca01db908748ab79bafe3254bede645b/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94e4d51ca01db908748ab79bafe3254bede645b/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=e94e4d51ca01db908748ab79bafe3254bede645b", "patch": "@@ -12,11 +12,13 @@\n \n \n use std::cmp;\n+use std::iterator::{DoubleEndedIterator, RandomAccessIterator, Invert};\n use std::num;\n use std::ops;\n use std::uint;\n use std::vec;\n \n+\n #[deriving(Clone)]\n struct SmallBitv {\n     /// only the lowest nbits of this value are used. the rest is undefined.\n@@ -404,7 +406,12 @@ impl Bitv {\n \n     #[inline]\n     pub fn iter<'a>(&'a self) -> BitvIterator<'a> {\n-        BitvIterator {bitv: self, next_idx: 0}\n+        BitvIterator {bitv: self, next_idx: 0, end_idx: self.nbits}\n+    }\n+\n+    #[inline]\n+    pub fn rev_liter<'a>(&'a self) -> Invert<BitvIterator<'a>> {\n+        self.iter().invert()\n     }\n \n     /// Returns true if all bits are 0\n@@ -564,13 +571,14 @@ fn iterate_bits(base: uint, bits: uint, f: &fn(uint) -> bool) -> bool {\n /// An iterator for Bitv\n pub struct BitvIterator<'self> {\n     priv bitv: &'self Bitv,\n-    priv next_idx: uint\n+    priv next_idx: uint,\n+    priv end_idx: uint,\n }\n \n impl<'self> Iterator<bool> for BitvIterator<'self> {\n     #[inline]\n     fn next(&mut self) -> Option<bool> {\n-        if self.next_idx < self.bitv.nbits {\n+        if self.next_idx != self.end_idx {\n             let idx = self.next_idx;\n             self.next_idx += 1;\n             Some(self.bitv.get(idx))\n@@ -580,11 +588,39 @@ impl<'self> Iterator<bool> for BitvIterator<'self> {\n     }\n \n     fn size_hint(&self) -> (uint, Option<uint>) {\n-        let rem = self.bitv.nbits - self.next_idx;\n+        let rem = self.end_idx - self.next_idx;\n         (rem, Some(rem))\n     }\n }\n \n+impl<'self> DoubleEndedIterator<bool> for BitvIterator<'self> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<bool> {\n+        if self.next_idx != self.end_idx {\n+            self.end_idx -= 1;\n+            Some(self.bitv.get(self.end_idx))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<'self> RandomAccessIterator<bool> for BitvIterator<'self> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        self.end_idx - self.next_idx\n+    }\n+\n+    #[inline]\n+    fn idx(&self, index: uint) -> Option<bool> {\n+        if index >= self.indexable() {\n+            None\n+        } else {\n+            Some(self.bitv.get(index))\n+        }\n+    }\n+}\n+\n /// An implementation of a set using a bit vector as an underlying\n /// representation for holding numerical elements.\n ///"}, {"sha": "88159ce55525687a084e9707ca07aea8cf880973", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e94e4d51ca01db908748ab79bafe3254bede645b/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94e4d51ca01db908748ab79bafe3254bede645b/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=e94e4d51ca01db908748ab79bafe3254bede645b", "patch": "@@ -25,7 +25,7 @@\n use std::cast;\n use std::ptr;\n use std::util;\n-use std::iterator::{FromIterator, Invert};\n+use std::iterator::{FromIterator, Extendable, Invert};\n \n use container::Deque;\n \n@@ -541,11 +541,17 @@ impl<A> DoubleEndedIterator<A> for ConsumeIterator<A> {\n impl<A, T: Iterator<A>> FromIterator<A, T> for DList<A> {\n     fn from_iterator(iterator: &mut T) -> DList<A> {\n         let mut ret = DList::new();\n-        for iterator.advance |elt| { ret.push_back(elt); }\n+        ret.extend(iterator);\n         ret\n     }\n }\n \n+impl<A, T: Iterator<A>> Extendable<A, T> for DList<A> {\n+    fn extend(&mut self, iterator: &mut T) {\n+        for iterator.advance |elt| { self.push_back(elt); }\n+    }\n+}\n+\n impl<A: Eq> Eq for DList<A> {\n     fn eq(&self, other: &DList<A>) -> bool {\n         self.len() == other.len() &&"}, {"sha": "1c92a4f34e524503da3759c48c1537e7a346946e", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e94e4d51ca01db908748ab79bafe3254bede645b/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94e4d51ca01db908748ab79bafe3254bede645b/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=e94e4d51ca01db908748ab79bafe3254bede645b", "patch": "@@ -16,7 +16,7 @@ use std::clone::Clone;\n use std::unstable::intrinsics::{move_val_init, init};\n use std::util::{replace, swap};\n use std::vec;\n-use std::iterator::FromIterator;\n+use std::iterator::{FromIterator, Extendable};\n \n /// A priority queue implemented with a binary heap\n #[deriving(Clone)]\n@@ -191,17 +191,24 @@ impl<'self, T> Iterator<&'self T> for PriorityQueueIterator<'self, T> {\n }\n \n impl<T: Ord, Iter: Iterator<T>> FromIterator<T, Iter> for PriorityQueue<T> {\n-    pub fn from_iterator(iter: &mut Iter) -> PriorityQueue<T> {\n+    fn from_iterator(iter: &mut Iter) -> PriorityQueue<T> {\n+        let mut q = PriorityQueue::new();\n+        q.extend(iter);\n+\n+        q\n+    }\n+}\n+\n+impl<T: Ord, Iter: Iterator<T>> Extendable<T, Iter> for PriorityQueue<T> {\n+    fn extend(&mut self, iter: &mut Iter) {\n         let (lower, _) = iter.size_hint();\n \n-        let mut q = PriorityQueue::new();\n-        q.reserve_at_least(lower);\n+        let len = self.capacity();\n+        self.reserve_at_least(len + lower);\n \n         for iter.advance |elem| {\n-            q.push(elem);\n+            self.push(elem);\n         }\n-\n-        q\n     }\n }\n "}, {"sha": "92183f22d3b27df96695e602ee4a9910478e2621", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e94e4d51ca01db908748ab79bafe3254bede645b/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94e4d51ca01db908748ab79bafe3254bede645b/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=e94e4d51ca01db908748ab79bafe3254bede645b", "patch": "@@ -16,7 +16,7 @@\n use std::num;\n use std::uint;\n use std::vec;\n-use std::iterator::{FromIterator, Invert};\n+use std::iterator::{FromIterator, Invert, RandomAccessIterator, Extendable};\n \n use container::Deque;\n \n@@ -176,8 +176,7 @@ impl<T> RingBuf<T> {\n \n     /// Front-to-back iterator.\n     pub fn iter<'a>(&'a self) -> RingBufIterator<'a, T> {\n-        RingBufIterator{index: 0, rindex: self.nelts - 1,\n-                        nelts: self.nelts, elts: self.elts, lo: self.lo}\n+        RingBufIterator{index: 0, rindex: self.nelts, lo: self.lo, elts: self.elts}\n     }\n \n     /// Back-to-front iterator.\n@@ -187,8 +186,7 @@ impl<T> RingBuf<T> {\n \n     /// Front-to-back iterator which returns mutable values.\n     pub fn mut_iter<'a>(&'a mut self) -> RingBufMutIterator<'a, T> {\n-        RingBufMutIterator{index: 0, rindex: self.nelts - 1,\n-                           nelts: self.nelts, elts: self.elts, lo: self.lo}\n+        RingBufMutIterator{index: 0, rindex: self.nelts, lo: self.lo, elts: self.elts}\n     }\n \n     /// Back-to-front iterator which returns mutable values.\n@@ -202,18 +200,18 @@ macro_rules! iterator {\n         impl<'self, T> Iterator<$elem> for $name<'self, T> {\n             #[inline]\n             fn next(&mut self) -> Option<$elem> {\n-                if self.nelts == 0 {\n+                if self.index == self.rindex {\n                     return None;\n                 }\n                 let raw_index = raw_index(self.lo, self.elts.len(), self.index);\n                 self.index += 1;\n-                self.nelts -= 1;\n-                Some(self.elts[raw_index]. $getter ())\n+                Some(self.elts[raw_index] . $getter ())\n             }\n \n             #[inline]\n             fn size_hint(&self) -> (uint, Option<uint>) {\n-                (self.nelts, Some(self.nelts))\n+                let len = self.rindex - self.index;\n+                (len, Some(len))\n             }\n         }\n     }\n@@ -224,33 +222,46 @@ macro_rules! iterator_rev {\n         impl<'self, T> DoubleEndedIterator<$elem> for $name<'self, T> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n-                if self.nelts == 0 {\n+                if self.index == self.rindex {\n                     return None;\n                 }\n-                let raw_index = raw_index(self.lo, self.elts.len(), self.rindex);\n                 self.rindex -= 1;\n-                self.nelts -= 1;\n-                Some(self.elts[raw_index]. $getter ())\n+                let raw_index = raw_index(self.lo, self.elts.len(), self.rindex);\n+                Some(self.elts[raw_index] . $getter ())\n             }\n         }\n     }\n }\n \n+\n /// RingBuf iterator\n pub struct RingBufIterator<'self, T> {\n     priv lo: uint,\n-    priv nelts: uint,\n     priv index: uint,\n     priv rindex: uint,\n     priv elts: &'self [Option<T>],\n }\n iterator!{impl RingBufIterator -> &'self T, get_ref}\n iterator_rev!{impl RingBufIterator -> &'self T, get_ref}\n \n+impl<'self, T> RandomAccessIterator<&'self T> for RingBufIterator<'self, T> {\n+    #[inline]\n+    fn indexable(&self) -> uint { self.rindex - self.index }\n+\n+    #[inline]\n+    fn idx(&self, j: uint) -> Option<&'self T> {\n+        if j >= self.indexable() {\n+            None\n+        } else {\n+            let raw_index = raw_index(self.lo, self.elts.len(), self.index + j);\n+            Some(self.elts[raw_index].get_ref())\n+        }\n+    }\n+}\n+\n /// RingBuf mutable iterator\n pub struct RingBufMutIterator<'self, T> {\n     priv lo: uint,\n-    priv nelts: uint,\n     priv index: uint,\n     priv rindex: uint,\n     priv elts: &'self mut [Option<T>],\n@@ -314,11 +325,18 @@ impl<A: Eq> Eq for RingBuf<A> {\n \n impl<A, T: Iterator<A>> FromIterator<A, T> for RingBuf<A> {\n     fn from_iterator(iterator: &mut T) -> RingBuf<A> {\n-        let mut deq = RingBuf::new();\n+        let (lower, _) = iterator.size_hint();\n+        let mut deq = RingBuf::with_capacity(lower);\n+        deq.extend(iterator);\n+        deq\n+    }\n+}\n+\n+impl<A, T: Iterator<A>> Extendable<A, T> for RingBuf<A> {\n+    fn extend(&mut self, iterator: &mut T) {\n         for iterator.advance |elt| {\n-            deq.push_back(elt);\n+            self.push_back(elt);\n         }\n-        deq\n     }\n }\n "}, {"sha": "6148e14b79f3fe9e627d1ce1d060e827db0b8637", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e94e4d51ca01db908748ab79bafe3254bede645b/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94e4d51ca01db908748ab79bafe3254bede645b/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=e94e4d51ca01db908748ab79bafe3254bede645b", "patch": "@@ -15,7 +15,7 @@\n \n use std::num;\n use std::util::{swap, replace};\n-use std::iterator::FromIterator;\n+use std::iterator::{FromIterator, Extendable};\n \n // This is implemented as an AA tree, which is a simplified variation of\n // a red-black tree where red (horizontal) nodes can only be added\n@@ -753,26 +753,36 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n }\n \n impl<K: TotalOrd, V, T: Iterator<(K, V)>> FromIterator<(K, V), T> for TreeMap<K, V> {\n-    pub fn from_iterator(iter: &mut T) -> TreeMap<K, V> {\n+    fn from_iterator(iter: &mut T) -> TreeMap<K, V> {\n         let mut map = TreeMap::new();\n+        map.extend(iter);\n+        map\n+    }\n+}\n \n+impl<K: TotalOrd, V, T: Iterator<(K, V)>> Extendable<(K, V), T> for TreeMap<K, V> {\n+    #[inline]\n+    fn extend(&mut self, iter: &mut T) {\n         for iter.advance |(k, v)| {\n-            map.insert(k, v);\n+            self.insert(k, v);\n         }\n-\n-        map\n     }\n }\n \n impl<T: TotalOrd, Iter: Iterator<T>> FromIterator<T, Iter> for TreeSet<T> {\n     pub fn from_iterator(iter: &mut Iter) -> TreeSet<T> {\n         let mut set = TreeSet::new();\n+        set.extend(iter);\n+        set\n+    }\n+}\n \n+impl<T: TotalOrd, Iter: Iterator<T>> Extendable<T, Iter> for TreeSet<T> {\n+    #[inline]\n+    fn extend(&mut self, iter: &mut Iter) {\n         for iter.advance |elem| {\n-            set.insert(elem);\n+            self.insert(elem);\n         }\n-\n-        set\n     }\n }\n "}, {"sha": "e43293f32122a4edd2576b718a20735f9b716bab", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e94e4d51ca01db908748ab79bafe3254bede645b/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94e4d51ca01db908748ab79bafe3254bede645b/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=e94e4d51ca01db908748ab79bafe3254bede645b", "patch": "@@ -19,7 +19,7 @@ use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n use clone::Clone;\n use cmp::{Eq, Equiv};\n use hash::Hash;\n-use iterator::{Iterator, IteratorUtil, FromIterator, Chain};\n+use iterator::{Iterator, IteratorUtil, FromIterator, Extendable, Chain};\n use num;\n use option::{None, Option, Some};\n use rand::RngUtil;\n@@ -618,15 +618,19 @@ impl<K> Iterator<K> for HashSetConsumeIterator<K> {\n }\n \n impl<K: Eq + Hash, V, T: Iterator<(K, V)>> FromIterator<(K, V), T> for HashMap<K, V> {\n-    pub fn from_iterator(iter: &mut T) -> HashMap<K, V> {\n+    fn from_iterator(iter: &mut T) -> HashMap<K, V> {\n         let (lower, _) = iter.size_hint();\n         let mut map = HashMap::with_capacity(lower);\n+        map.extend(iter);\n+        map\n+    }\n+}\n \n+impl<K: Eq + Hash, V, T: Iterator<(K, V)>> Extendable<(K, V), T> for HashMap<K, V> {\n+    fn extend(&mut self, iter: &mut T) {\n         for iter.advance |(k, v)| {\n-            map.insert(k, v);\n+            self.insert(k, v);\n         }\n-\n-        map\n     }\n }\n \n@@ -771,15 +775,19 @@ impl<T:Hash + Eq> HashSet<T> {\n }\n \n impl<K: Eq + Hash, T: Iterator<K>> FromIterator<K, T> for HashSet<K> {\n-    pub fn from_iterator(iter: &mut T) -> HashSet<K> {\n+    fn from_iterator(iter: &mut T) -> HashSet<K> {\n         let (lower, _) = iter.size_hint();\n         let mut set = HashSet::with_capacity(lower);\n+        set.extend(iter);\n+        set\n+    }\n+}\n \n+impl<K: Eq + Hash, T: Iterator<K>> Extendable<K, T> for HashSet<K> {\n+    fn extend(&mut self, iter: &mut T) {\n         for iter.advance |k| {\n-            set.insert(k);\n+            self.insert(k);\n         }\n-\n-        set\n     }\n }\n "}, {"sha": "9fe865333a2157c68ce9ed174e86ad6ee8478522", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 283, "deletions": 23, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/e94e4d51ca01db908748ab79bafe3254bede645b/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94e4d51ca01db908748ab79bafe3254bede645b/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=e94e4d51ca01db908748ab79bafe3254bede645b", "patch": "@@ -529,7 +529,7 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     #[inline]\n     fn flat_map_<'r, B, U: Iterator<B>>(self, f: &'r fn(A) -> U)\n         -> FlatMap<'r, A, T, U> {\n-        FlatMap{iter: self, f: f, subiter: None }\n+        FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n     }\n \n     // FIXME: #5898: should be called `peek`\n@@ -811,6 +811,30 @@ impl<A, T: Clone + Iterator<A>> Iterator<A> for Cycle<T> {\n     }\n }\n \n+impl<A, T: Clone + RandomAccessIterator<A>> RandomAccessIterator<A> for Cycle<T> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        if self.orig.indexable() > 0 {\n+            uint::max_value\n+        } else {\n+            0\n+        }\n+    }\n+\n+    #[inline]\n+    fn idx(&self, index: uint) -> Option<A> {\n+        let liter = self.iter.indexable();\n+        let lorig = self.orig.indexable();\n+        if lorig == 0 {\n+            None\n+        } else if index < liter {\n+            self.iter.idx(index)\n+        } else {\n+            self.orig.idx((index - liter) % lorig)\n+        }\n+    }\n+}\n+\n /// An iterator which strings two iterators together\n #[deriving(Clone)]\n pub struct Chain<T, U> {\n@@ -924,20 +948,44 @@ impl<A, B, T: Iterator<A>, U: Iterator<B>> Iterator<(A, B)> for Zip<T, U> {\n     }\n }\n \n+impl<A, B, T: RandomAccessIterator<A>, U: RandomAccessIterator<B>>\n+RandomAccessIterator<(A, B)> for Zip<T, U> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        cmp::min(self.a.indexable(), self.b.indexable())\n+    }\n+\n+    #[inline]\n+    fn idx(&self, index: uint) -> Option<(A, B)> {\n+        match (self.a.idx(index), self.b.idx(index)) {\n+            (Some(x), Some(y)) => Some((x, y)),\n+            _ => None\n+        }\n+    }\n+}\n+\n /// An iterator which maps the values of `iter` with `f`\n pub struct Map<'self, A, B, T> {\n     priv iter: T,\n     priv f: &'self fn(A) -> B\n }\n \n-impl<'self, A, B, T: Iterator<A>> Iterator<B> for Map<'self, A, B, T> {\n+impl<'self, A, B, T> Map<'self, A, B, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<B> {\n-        match self.iter.next() {\n+    fn do_map(&self, elt: Option<A>) -> Option<B> {\n+        match elt {\n             Some(a) => Some((self.f)(a)),\n             _ => None\n         }\n     }\n+}\n+\n+impl<'self, A, B, T: Iterator<A>> Iterator<B> for Map<'self, A, B, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        let next = self.iter.next();\n+        self.do_map(next)\n+    }\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n@@ -949,10 +997,21 @@ impl<'self, A, B, T: DoubleEndedIterator<A>> DoubleEndedIterator<B>\n for Map<'self, A, B, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n-        match self.iter.next_back() {\n-            Some(a) => Some((self.f)(a)),\n-            _ => None\n-        }\n+        let next = self.iter.next_back();\n+        self.do_map(next)\n+    }\n+}\n+\n+impl<'self, A, B, T: RandomAccessIterator<A>> RandomAccessIterator<B>\n+for Map<'self, A, B, T> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        self.iter.indexable()\n+    }\n+\n+    #[inline]\n+    fn idx(&self, index: uint) -> Option<B> {\n+        self.do_map(self.iter.idx(index))\n     }\n }\n \n@@ -1069,6 +1128,21 @@ impl<A, T: Iterator<A>> Iterator<(uint, A)> for Enumerate<T> {\n     }\n }\n \n+impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<(uint, A)> for Enumerate<T> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        self.iter.indexable()\n+    }\n+\n+    #[inline]\n+    fn idx(&self, index: uint) -> Option<(uint, A)> {\n+        match self.iter.idx(index) {\n+            Some(a) => Some((self.count + index, a)),\n+            _ => None,\n+        }\n+    }\n+}\n+\n /// An iterator which rejects elements while `predicate` is true\n pub struct SkipWhile<'self, A, T> {\n     priv iter: T,\n@@ -1189,6 +1263,27 @@ impl<A, T: Iterator<A>> Iterator<A> for Skip<T> {\n     }\n }\n \n+impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Skip<T> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        let N = self.iter.indexable();\n+        if N < self.n {\n+            0\n+        } else {\n+            N - self.n\n+        }\n+    }\n+\n+    #[inline]\n+    fn idx(&self, index: uint) -> Option<A> {\n+        if index >= self.indexable() {\n+            None\n+        } else {\n+            self.iter.idx(index + self.n)\n+        }\n+    }\n+}\n+\n /// An iterator which only iterates over the first `n` iterations of `iter`.\n #[deriving(Clone)]\n pub struct Take<T> {\n@@ -1223,6 +1318,23 @@ impl<A, T: Iterator<A>> Iterator<A> for Take<T> {\n     }\n }\n \n+impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Take<T> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        cmp::min(self.iter.indexable(), self.n)\n+    }\n+\n+    #[inline]\n+    fn idx(&self, index: uint) -> Option<A> {\n+        if index >= self.n {\n+            None\n+        } else {\n+            self.iter.idx(index)\n+        }\n+    }\n+}\n+\n+\n /// An iterator to maintain state while iterating another iterator\n pub struct Scan<'self, A, B, T, St> {\n     priv iter: T,\n@@ -1251,22 +1363,54 @@ impl<'self, A, B, T: Iterator<A>, St> Iterator<B> for Scan<'self, A, B, T, St> {\n pub struct FlatMap<'self, A, T, U> {\n     priv iter: T,\n     priv f: &'self fn(A) -> U,\n-    priv subiter: Option<U>,\n+    priv frontiter: Option<U>,\n+    priv backiter: Option<U>,\n }\n \n impl<'self, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for\n     FlatMap<'self, A, T, U> {\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n         loop {\n-            for self.subiter.mut_iter().advance |inner| {\n+            for self.frontiter.mut_iter().advance |inner| {\n                 for inner.advance |x| {\n                     return Some(x)\n                 }\n             }\n             match self.iter.next().map_consume(|x| (self.f)(x)) {\n-                None => return None,\n-                next => self.subiter = next,\n+                None => return self.backiter.chain_mut_ref(|it| it.next()),\n+                next => self.frontiter = next,\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (flo, fhi) = self.frontiter.map_default((0, Some(0)), |it| it.size_hint());\n+        let (blo, bhi) = self.backiter.map_default((0, Some(0)), |it| it.size_hint());\n+        match (self.iter.size_hint(), fhi, bhi) {\n+            ((0, Some(0)), Some(a), Some(b)) => (flo + blo, Some(a + b)),\n+            _ => (flo + blo, None)\n+        }\n+    }\n+}\n+\n+impl<'self,\n+     A, T: DoubleEndedIterator<A>,\n+     B, U: DoubleEndedIterator<B>> DoubleEndedIterator<B>\n+     for FlatMap<'self, A, T, U> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<B> {\n+        loop {\n+            for self.backiter.mut_iter().advance |inner| {\n+                match inner.next_back() {\n+                    None => (),\n+                    y => return y\n+                }\n+            }\n+            match self.iter.next_back().map_consume(|x| (self.f)(x)) {\n+                None => return self.frontiter.chain_mut_ref(|it| it.next_back()),\n+                next => self.backiter = next,\n             }\n         }\n     }\n@@ -1279,17 +1423,23 @@ pub struct Peek<'self, A, T> {\n     priv f: &'self fn(&A)\n }\n \n-impl<'self, A, T: Iterator<A>> Iterator<A> for Peek<'self, A, T> {\n+impl<'self, A, T> Peek<'self, A, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n-        let next = self.iter.next();\n-\n-        match next {\n+    fn do_peek(&self, elt: Option<A>) -> Option<A> {\n+        match elt {\n             Some(ref a) => (self.f)(a),\n             None => ()\n         }\n \n-        next\n+        elt\n+    }\n+}\n+\n+impl<'self, A, T: Iterator<A>> Iterator<A> for Peek<'self, A, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        let next = self.iter.next();\n+        self.do_peek(next)\n     }\n \n     #[inline]\n@@ -1302,13 +1452,19 @@ impl<'self, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Peek<'self,\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         let next = self.iter.next_back();\n+        self.do_peek(next)\n+    }\n+}\n \n-        match next {\n-            Some(ref a) => (self.f)(a),\n-            None => ()\n-        }\n+impl<'self, A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Peek<'self, A, T> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        self.iter.indexable()\n+    }\n \n-        next\n+    #[inline]\n+    fn idx(&self, index: uint) -> Option<A> {\n+        self.do_peek(self.iter.idx(index))\n     }\n }\n \n@@ -1376,6 +1532,7 @@ mod tests {\n     use super::*;\n     use prelude::*;\n \n+    use cmp;\n     use uint;\n \n     #[test]\n@@ -1768,6 +1925,43 @@ mod tests {\n         assert_eq!(it.next_back(), None)\n     }\n \n+    #[cfg(test)]\n+    fn check_randacc_iter<A: Eq, T: Clone + RandomAccessIterator<A>>(a: T, len: uint)\n+    {\n+        let mut b = a.clone();\n+        assert_eq!(len, b.indexable());\n+        let mut n = 0;\n+        for a.enumerate().advance |(i, elt)| {\n+            assert_eq!(Some(elt), b.idx(i));\n+            n += 1;\n+        }\n+        assert_eq!(n, len);\n+        assert_eq!(None, b.idx(n));\n+        // call recursively to check after picking off an element\n+        if len > 0 {\n+            b.next();\n+            check_randacc_iter(b, len-1);\n+        }\n+    }\n+\n+\n+    #[test]\n+    fn test_double_ended_flat_map() {\n+        let u = [0u,1];\n+        let v = [5,6,7,8];\n+        let mut it = u.iter().flat_map_(|x| v.slice(*x, v.len()).iter());\n+        assert_eq!(it.next_back().unwrap(), &8);\n+        assert_eq!(it.next().unwrap(),      &5);\n+        assert_eq!(it.next_back().unwrap(), &7);\n+        assert_eq!(it.next_back().unwrap(), &6);\n+        assert_eq!(it.next_back().unwrap(), &8);\n+        assert_eq!(it.next().unwrap(),      &6);\n+        assert_eq!(it.next_back().unwrap(), &7);\n+        assert_eq!(it.next_back(), None);\n+        assert_eq!(it.next(),      None);\n+        assert_eq!(it.next_back(), None);\n+    }\n+\n     #[test]\n     fn test_random_access_chain() {\n         let xs = [1, 2, 3, 4, 5];\n@@ -1785,5 +1979,71 @@ mod tests {\n         assert_eq!(it.idx(0).unwrap(), &3);\n         assert_eq!(it.idx(4).unwrap(), &9);\n         assert!(it.idx(6).is_none());\n+\n+        check_randacc_iter(it, xs.len() + ys.len() - 3);\n+    }\n+\n+    #[test]\n+    fn test_random_access_enumerate() {\n+        let xs = [1, 2, 3, 4, 5];\n+        check_randacc_iter(xs.iter().enumerate(), xs.len());\n+    }\n+\n+    #[test]\n+    fn test_random_access_zip() {\n+        let xs = [1, 2, 3, 4, 5];\n+        let ys = [7, 9, 11];\n+        check_randacc_iter(xs.iter().zip(ys.iter()), cmp::min(xs.len(), ys.len()));\n+    }\n+\n+    #[test]\n+    fn test_random_access_take() {\n+        let xs = [1, 2, 3, 4, 5];\n+        let empty: &[int] = [];\n+        check_randacc_iter(xs.iter().take_(3), 3);\n+        check_randacc_iter(xs.iter().take_(20), xs.len());\n+        check_randacc_iter(xs.iter().take_(0), 0);\n+        check_randacc_iter(empty.iter().take_(2), 0);\n+    }\n+\n+    #[test]\n+    fn test_random_access_skip() {\n+        let xs = [1, 2, 3, 4, 5];\n+        let empty: &[int] = [];\n+        check_randacc_iter(xs.iter().skip(2), xs.len() - 2);\n+        check_randacc_iter(empty.iter().skip(2), 0);\n+    }\n+\n+    #[test]\n+    fn test_random_access_peek() {\n+        let xs = [1, 2, 3, 4, 5];\n+\n+        // test .transform and .peek_ that don't implement Clone\n+        let it = xs.iter().peek_(|_| {});\n+        assert_eq!(xs.len(), it.indexable());\n+        for xs.iter().enumerate().advance |(i, elt)| {\n+            assert_eq!(Some(elt), it.idx(i));\n+        }\n+\n+    }\n+\n+    #[test]\n+    fn test_random_access_transform() {\n+        let xs = [1, 2, 3, 4, 5];\n+\n+        // test .transform and .peek_ that don't implement Clone\n+        let it = xs.iter().transform(|x| *x);\n+        assert_eq!(xs.len(), it.indexable());\n+        for xs.iter().enumerate().advance |(i, elt)| {\n+            assert_eq!(Some(*elt), it.idx(i));\n+        }\n+    }\n+\n+    #[test]\n+    fn test_random_access_cycle() {\n+        let xs = [1, 2, 3, 4, 5];\n+        let empty: &[int] = [];\n+        check_randacc_iter(xs.iter().cycle().take_(27), 27);\n+        check_randacc_iter(empty.iter().cycle(), 0);\n     }\n }"}, {"sha": "fff859321fbe6c1c6fa7035df830a2f5e49e42f5", "filename": "src/libstd/str.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e94e4d51ca01db908748ab79bafe3254bede645b/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94e4d51ca01db908748ab79bafe3254bede645b/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=e94e4d51ca01db908748ab79bafe3254bede645b", "patch": "@@ -23,7 +23,8 @@ use char::Char;\n use clone::Clone;\n use container::{Container, Mutable};\n use iter::Times;\n-use iterator::{Iterator, FromIterator, IteratorUtil, Filter, AdditiveIterator, Map};\n+use iterator::{Iterator, FromIterator, Extendable, IteratorUtil};\n+use iterator::{Filter, AdditiveIterator, Map};\n use libc;\n use num::Zero;\n use option::{None, Option, Some};\n@@ -2323,10 +2324,20 @@ impl<T: Iterator<char>> FromIterator<char, T> for ~str {\n     fn from_iterator(iterator: &mut T) -> ~str {\n         let (lower, _) = iterator.size_hint();\n         let mut buf = with_capacity(lower);\n+        buf.extend(iterator);\n+        buf\n+    }\n+}\n+\n+impl<T: Iterator<char>> Extendable<char, T> for ~str {\n+    #[inline]\n+    fn extend(&mut self, iterator: &mut T) {\n+        let (lower, _) = iterator.size_hint();\n+        let reserve = lower + self.len();\n+        self.reserve_at_least(reserve);\n         for iterator.advance |ch| {\n-            buf.push_char(ch)\n+            self.push_char(ch)\n         }\n-        buf\n     }\n }\n \n@@ -2503,6 +2514,16 @@ mod tests {\n         assert_eq!(data, s.as_slice());\n     }\n \n+    #[test]\n+    fn test_extend() {\n+        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n+        let mut cpy = data.clone();\n+        let other = \"abc\";\n+        let mut it = other.iter();\n+        cpy.extend(&mut it);\n+        assert_eq!(cpy, data + other);\n+    }\n+\n     #[test]\n     fn test_clear() {\n         let mut empty = ~\"\";"}, {"sha": "6a0554a8c8d4324be5e76f19437e8b63fe08b18f", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e94e4d51ca01db908748ab79bafe3254bede645b/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94e4d51ca01db908748ab79bafe3254bede645b/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=e94e4d51ca01db908748ab79bafe3254bede645b", "patch": "@@ -11,7 +11,7 @@\n //! An ordered map and set for integer keys implemented as a radix trie\n \n use prelude::*;\n-use iterator::{IteratorUtil, FromIterator};\n+use iterator::{IteratorUtil, FromIterator, Extendable};\n use uint;\n use util::{swap, replace};\n \n@@ -155,14 +155,18 @@ impl<T> TrieMap<T> {\n }\n \n impl<T, Iter: Iterator<(uint, T)>> FromIterator<(uint, T), Iter> for TrieMap<T> {\n-    pub fn from_iterator(iter: &mut Iter) -> TrieMap<T> {\n+    fn from_iterator(iter: &mut Iter) -> TrieMap<T> {\n         let mut map = TrieMap::new();\n+        map.extend(iter);\n+        map\n+    }\n+}\n \n+impl<T, Iter: Iterator<(uint, T)>> Extendable<(uint, T), Iter> for TrieMap<T> {\n+    fn extend(&mut self, iter: &mut Iter) {\n         for iter.advance |(k, v)| {\n-            map.insert(k, v);\n+            self.insert(k, v);\n         }\n-\n-        map\n     }\n }\n \n@@ -222,14 +226,18 @@ impl TrieSet {\n }\n \n impl<Iter: Iterator<uint>> FromIterator<uint, Iter> for TrieSet {\n-    pub fn from_iterator(iter: &mut Iter) -> TrieSet {\n+    fn from_iterator(iter: &mut Iter) -> TrieSet {\n         let mut set = TrieSet::new();\n+        set.extend(iter);\n+        set\n+    }\n+}\n \n+impl<Iter: Iterator<uint>> Extendable<uint, Iter> for TrieSet {\n+    fn extend(&mut self, iter: &mut Iter) {\n         for iter.advance |elem| {\n-            set.insert(elem);\n+            self.insert(elem);\n         }\n-\n-        set\n     }\n }\n "}, {"sha": "cfd28fcfc5eaa14c5c0156976cfa37aa8facb64c", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e94e4d51ca01db908748ab79bafe3254bede645b/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94e4d51ca01db908748ab79bafe3254bede645b/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=e94e4d51ca01db908748ab79bafe3254bede645b", "patch": "@@ -2106,7 +2106,8 @@ macro_rules! iterator {\n \n             #[inline]\n             fn size_hint(&self) -> (uint, Option<uint>) {\n-                let exact = self.indexable();\n+                let diff = (self.end as uint) - (self.ptr as uint);\n+                let exact = diff / sys::nonzero_size_of::<T>();\n                 (exact, Some(exact))\n             }\n         }\n@@ -2134,23 +2135,19 @@ macro_rules! double_ended_iterator {\n     }\n }\n \n-macro_rules! random_access_iterator {\n-    (impl $name:ident -> $elem:ty) => {\n-        impl<'self, T> RandomAccessIterator<$elem> for $name<'self, T> {\n-            #[inline]\n-            fn indexable(&self) -> uint {\n-                let diff = (self.end as uint) - (self.ptr as uint);\n-                diff / sys::nonzero_size_of::<T>()\n-            }\n+impl<'self, T> RandomAccessIterator<&'self T> for VecIterator<'self, T> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        let (exact, _) = self.size_hint();\n+        exact\n+    }\n \n-            fn idx(&self, index: uint) -> Option<$elem> {\n-                unsafe {\n-                    if index < self.indexable() {\n-                        cast::transmute(self.ptr.offset(index))\n-                    } else {\n-                        None\n-                    }\n-                }\n+    fn idx(&self, index: uint) -> Option<&'self T> {\n+        unsafe {\n+            if index < self.indexable() {\n+                cast::transmute(self.ptr.offset(index))\n+            } else {\n+                None\n             }\n         }\n     }\n@@ -2165,7 +2162,6 @@ pub struct VecIterator<'self, T> {\n }\n iterator!{impl VecIterator -> &'self T}\n double_ended_iterator!{impl VecIterator -> &'self T}\n-random_access_iterator!{impl VecIterator -> &'self T}\n pub type RevIterator<'self, T> = Invert<VecIterator<'self, T>>;\n \n impl<'self, T> Clone for VecIterator<'self, T> {\n@@ -2181,7 +2177,6 @@ pub struct VecMutIterator<'self, T> {\n }\n iterator!{impl VecMutIterator -> &'self mut T}\n double_ended_iterator!{impl VecMutIterator -> &'self mut T}\n-random_access_iterator!{impl VecMutIterator -> &'self mut T}\n pub type MutRevIterator<'self, T> = Invert<VecMutIterator<'self, T>>;\n \n /// An iterator that moves out of a vector."}]}