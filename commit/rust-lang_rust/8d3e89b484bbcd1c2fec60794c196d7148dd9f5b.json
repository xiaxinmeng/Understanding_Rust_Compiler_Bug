{"sha": "8d3e89b484bbcd1c2fec60794c196d7148dd9f5b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkM2U4OWI0ODRiYmNkMWMyZmVjNjA3OTRjMTk2ZDcxNDhkZDlmNWI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-10-26T19:38:22Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-10-26T20:10:30Z"}, "message": "handle mixed byte literal and byte array patterns\n\nConvert byte literal pattern to byte array patterns when they are both\nused together. so matching them is properly handled. I could've done the\nconversion eagerly, but that could have caused a bad worst-case for\nmassive byte-array matches.\n\nFixes #18027.\nFixes #25051.\nFixes #26510.", "tree": {"sha": "184f6b4c9720acf8ea0316b3c9ec86f8cbccfc55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/184f6b4c9720acf8ea0316b3c9ec86f8cbccfc55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d3e89b484bbcd1c2fec60794c196d7148dd9f5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d3e89b484bbcd1c2fec60794c196d7148dd9f5b", "html_url": "https://github.com/rust-lang/rust/commit/8d3e89b484bbcd1c2fec60794c196d7148dd9f5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d3e89b484bbcd1c2fec60794c196d7148dd9f5b/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76fb7d90ecde3659021341779fea598a6daab013", "url": "https://api.github.com/repos/rust-lang/rust/commits/76fb7d90ecde3659021341779fea598a6daab013", "html_url": "https://github.com/rust-lang/rust/commit/76fb7d90ecde3659021341779fea598a6daab013"}], "stats": {"total": 322, "additions": 272, "deletions": 50}, "files": [{"sha": "7f5eb31612cb394f002a5e1cdfa68d99f562ed77", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 140, "deletions": 45, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e89b484bbcd1c2fec60794c196d7148dd9f5b/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e89b484bbcd1c2fec60794c196d7148dd9f5b/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=8d3e89b484bbcd1c2fec60794c196d7148dd9f5b", "patch": "@@ -15,6 +15,9 @@ use self::WitnessPreference::*;\n use rustc::middle::const_val::ConstVal;\n use eval::{compare_const_vals};\n \n+use rustc_const_math::ConstInt;\n+\n+use rustc_data_structures::fnv::FnvHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n \n use pattern::{FieldPattern, Pattern, PatternKind};\n@@ -157,6 +160,7 @@ pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n     /// associated types to get field types.\n     pub wild_pattern: &'a Pattern<'tcx>,\n     pub pattern_arena: &'a TypedArena<Pattern<'tcx>>,\n+    pub byte_array_map: FnvHashMap<*const Pattern<'tcx>, Vec<&'a Pattern<'tcx>>>,\n }\n \n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n@@ -177,8 +181,31 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n             tcx: tcx,\n             wild_pattern: &wild_pattern,\n             pattern_arena: &pattern_arena,\n+            byte_array_map: FnvHashMap(),\n         })\n     }\n+\n+    // convert a byte-string pattern to a list of u8 patterns.\n+    fn lower_byte_str_pattern(&mut self, pat: &'a Pattern<'tcx>) -> Vec<&'a Pattern<'tcx>> {\n+        let pattern_arena = &*self.pattern_arena;\n+        let tcx = self.tcx;\n+        self.byte_array_map.entry(pat).or_insert_with(|| {\n+            match pat.kind {\n+                box PatternKind::Constant {\n+                    value: ConstVal::ByteStr(ref data)\n+                } => {\n+                    data.iter().map(|c| &*pattern_arena.alloc(Pattern {\n+                        ty: tcx.types.u8,\n+                        span: pat.span,\n+                        kind: box PatternKind::Constant {\n+                            value: ConstVal::Integral(ConstInt::U8(*c))\n+                        }\n+                    })).collect()\n+                }\n+                _ => span_bug!(pat.span, \"unexpected byte array pattern {:?}\", pat)\n+            }\n+        }).clone()\n+    }\n }\n \n #[derive(Clone, Debug, PartialEq)]\n@@ -357,7 +384,8 @@ impl Witness {\n /// Therefore, if there is some pattern that is unmatched by `matrix`, it will\n /// still be unmatched if the first constructor is replaced by any of the constructors\n /// in the return value.\n-fn missing_constructors(cx: &MatchCheckCtxt, matrix: &Matrix,\n+fn missing_constructors(cx: &mut MatchCheckCtxt,\n+                        matrix: &Matrix,\n                         pcx: PatternContext) -> Vec<Constructor> {\n     let used_constructors: Vec<Constructor> =\n         matrix.0.iter()\n@@ -371,14 +399,20 @@ fn missing_constructors(cx: &MatchCheckCtxt, matrix: &Matrix,\n \n /// This determines the set of all possible constructors of a pattern matching\n /// values of type `left_ty`. For vectors, this would normally be an infinite set\n+///\n+/// This intentionally does not list ConstantValue specializations for\n+/// non-booleans, because we currently assume that there is always a\n+/// \"non-standard constant\" that matches. See issue #12483.\n+///\n /// but is instead bounded by the maximum fixed length of slice patterns in\n /// the column of patterns being analyzed.\n-fn all_constructors(_cx: &MatchCheckCtxt, pcx: PatternContext) -> Vec<Constructor> {\n+fn all_constructors(_cx: &mut MatchCheckCtxt, pcx: PatternContext) -> Vec<Constructor> {\n     match pcx.ty.sty {\n         ty::TyBool =>\n             [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n         ty::TySlice(_) =>\n             (0..pcx.max_slice_length+1).map(|length| Slice(length)).collect(),\n+        ty::TyArray(_, length) => vec![Slice(length)],\n         ty::TyAdt(def, _) if def.is_enum() && def.variants.len() > 1 =>\n             def.variants.iter().map(|v| Variant(v.did)).collect(),\n         _ => vec![Single]\n@@ -398,7 +432,7 @@ fn all_constructors(_cx: &MatchCheckCtxt, pcx: PatternContext) -> Vec<Constructo\n ///\n /// Note: is_useful doesn't work on empty types, as the paper notes.\n /// So it assumes that v is non-empty.\n-pub fn is_useful<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n+pub fn is_useful<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                            matrix: &Matrix<'a, 'tcx>,\n                            v: &[&'a Pattern<'tcx>],\n                            witness: WitnessPreference)\n@@ -416,19 +450,22 @@ pub fn is_useful<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n     if rows[0].is_empty() {\n         return NotUseful;\n     }\n-    assert!(rows.iter().all(|r| r.len() == v.len()));\n \n+    let &Matrix(ref rows) = matrix;\n+    assert!(rows.iter().all(|r| r.len() == v.len()));\n     let pcx = PatternContext {\n         ty: rows.iter().map(|r| r[0].ty).find(|ty| !ty.references_error())\n             .unwrap_or(v[0].ty),\n         max_slice_length: rows.iter().filter_map(|row| match *row[0].kind {\n             PatternKind::Slice { ref prefix, slice: _, ref suffix } =>\n                 Some(prefix.len() + suffix.len()),\n+            PatternKind::Constant { value: ConstVal::ByteStr(ref data) } =>\n+                Some(data.len()),\n             _ => None\n         }).max().map_or(0, |v| v + 1)\n     };\n \n-    debug!(\"is_useful: pcx={:?}, expanding {:?}\", pcx, v[0]);\n+    debug!(\"is_useful_expand_first_col: pcx={:?}, expanding {:?}\", pcx, v[0]);\n \n     if let Some(constructors) = pat_constructors(cx, v[0], pcx) {\n         debug!(\"is_useful - expanding constructors: {:?}\", constructors);\n@@ -453,6 +490,7 @@ pub fn is_useful<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n             }).collect();\n             match is_useful(cx, &matrix, &v[1..], witness) {\n                 UsefulWithWitness(pats) => {\n+                    let cx = &*cx;\n                     UsefulWithWitness(pats.into_iter().flat_map(|witness| {\n                         constructors.iter().map(move |ctor| {\n                             witness.clone().push_wild_constructor(cx, ctor, pcx.ty)\n@@ -466,15 +504,15 @@ pub fn is_useful<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n }\n \n fn is_useful_specialized<'a, 'tcx>(\n-    cx: &MatchCheckCtxt<'a, 'tcx>,\n+    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     &Matrix(ref m): &Matrix<'a, 'tcx>,\n     v: &[&'a Pattern<'tcx>],\n     ctor: Constructor,\n     lty: Ty<'tcx>,\n     witness: WitnessPreference) -> Usefulness\n {\n     let arity = constructor_arity(cx, &ctor, lty);\n-    let matrix = Matrix(m.iter().filter_map(|r| {\n+    let matrix = Matrix(m.iter().flat_map(|r| {\n         specialize(cx, &r[..], &ctor, 0, arity)\n     }).collect());\n     match specialize(cx, v, &ctor, 0, arity) {\n@@ -498,22 +536,26 @@ fn is_useful_specialized<'a, 'tcx>(\n /// `[a, b, ..tail]` can match a slice of length 2, 3, 4 and so on.\n ///\n /// Returns None in case of a catch-all, which can't be specialized.\n-fn pat_constructors(_cx: &MatchCheckCtxt,\n+fn pat_constructors(_cx: &mut MatchCheckCtxt,\n                     pat: &Pattern,\n                     pcx: PatternContext)\n                     -> Option<Vec<Constructor>>\n {\n     match *pat.kind {\n         PatternKind::Binding { .. } | PatternKind::Wild =>\n             None,\n-        PatternKind::Leaf { .. } | PatternKind::Deref { .. } | PatternKind::Array { .. } =>\n+        PatternKind::Leaf { .. } | PatternKind::Deref { .. } =>\n             Some(vec![Single]),\n         PatternKind::Variant { adt_def, variant_index, .. } =>\n             Some(vec![Variant(adt_def.variants[variant_index].did)]),\n         PatternKind::Constant { ref value } =>\n             Some(vec![ConstantValue(value.clone())]),\n         PatternKind::Range { ref lo, ref hi } =>\n             Some(vec![ConstantRange(lo.clone(), hi.clone())]),\n+        PatternKind::Array { .. } => match pcx.ty.sty {\n+            ty::TyArray(_, length) => Some(vec![Slice(length)]),\n+            _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pcx.ty)\n+        },\n         PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n             let pat_len = prefix.len() + suffix.len();\n             if slice.is_some() {\n@@ -535,23 +577,55 @@ fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize\n     match ty.sty {\n         ty::TyTuple(ref fs) => fs.len(),\n         ty::TyBox(_) => 1,\n-        ty::TySlice(_) => match *ctor {\n+        ty::TySlice(..) | ty::TyArray(..) => match *ctor {\n             Slice(length) => length,\n-            ConstantValue(_) => {\n-                // TODO: this is utterly wrong, but required for byte arrays\n-                0\n-            }\n+            ConstantValue(_) => 0,\n             _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n         },\n         ty::TyRef(..) => 1,\n         ty::TyAdt(adt, _) => {\n             ctor.variant_for_adt(adt).fields.len()\n         }\n-        ty::TyArray(_, n) => n,\n         _ => 0\n     }\n }\n \n+fn slice_pat_covered_by_constructor(_tcx: TyCtxt, _span: Span,\n+                                    ctor: &Constructor,\n+                                    prefix: &[Pattern],\n+                                    slice: &Option<Pattern>,\n+                                    suffix: &[Pattern])\n+                                    -> Result<bool, ErrorReported> {\n+    let data = match *ctor {\n+        ConstantValue(ConstVal::ByteStr(ref data)) => data,\n+        _ => bug!()\n+    };\n+\n+    let pat_len = prefix.len() + suffix.len();\n+    if data.len() < pat_len || (slice.is_none() && data.len() > pat_len) {\n+        return Ok(false);\n+    }\n+\n+    for (ch, pat) in\n+        data[..prefix.len()].iter().zip(prefix).chain(\n+            data[data.len()-suffix.len()..].iter().zip(suffix))\n+    {\n+        match pat.kind {\n+            box PatternKind::Constant { ref value } => match *value {\n+                ConstVal::Integral(ConstInt::U8(u)) => {\n+                    if u != *ch {\n+                        return Ok(false);\n+                    }\n+                },\n+                _ => span_bug!(pat.span, \"bad const u8 {:?}\", value)\n+            },\n+            _ => {}\n+        }\n+    }\n+\n+    Ok(true)\n+}\n+\n fn range_covered_by_constructor(tcx: TyCtxt, span: Span,\n                                 ctor: &Constructor,\n                                 from: &ConstVal, to: &ConstVal)\n@@ -568,7 +642,7 @@ fn range_covered_by_constructor(tcx: TyCtxt, span: Span,\n }\n \n fn patterns_for_variant<'a, 'tcx>(\n-    cx: &MatchCheckCtxt<'a, 'tcx>,\n+    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     subpatterns: &'a [FieldPattern<'tcx>],\n     arity: usize)\n     -> Vec<&'a Pattern<'tcx>>\n@@ -592,7 +666,7 @@ fn patterns_for_variant<'a, 'tcx>(\n /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n /// fields filled with wild patterns.\n fn specialize<'a, 'tcx>(\n-    cx: &MatchCheckCtxt<'a, 'tcx>,\n+    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     r: &[&'a Pattern<'tcx>],\n     constructor: &Constructor, col: usize, arity: usize)\n     -> Option<Vec<&'a Pattern<'tcx>>>\n@@ -616,13 +690,27 @@ fn specialize<'a, 'tcx>(\n         PatternKind::Deref { ref subpattern } => Some(vec![subpattern]),\n \n         PatternKind::Constant { ref value } => {\n-            assert_eq!(constructor_arity(cx, constructor, pat.ty), 0);\n-            match range_covered_by_constructor(\n-                cx.tcx, pat.span, constructor, value, value\n-            ) {\n-                Ok(true) => Some(vec![]),\n-                Ok(false) => None,\n-                Err(ErrorReported) => None,\n+            match *constructor {\n+                Slice(..) => match *value {\n+                    ConstVal::ByteStr(ref data) => {\n+                        if arity == data.len() {\n+                            Some(cx.lower_byte_str_pattern(pat))\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    _ => span_bug!(pat.span,\n+                        \"unexpected const-val {:?} with ctor {:?}\", value, constructor)\n+                },\n+                _ => {\n+                    match range_covered_by_constructor(\n+                        cx.tcx, pat.span, constructor, value, value\n+                            ) {\n+                        Ok(true) => Some(vec![]),\n+                        Ok(false) => None,\n+                        Err(ErrorReported) => None,\n+                    }\n+                }\n             }\n         }\n \n@@ -636,29 +724,36 @@ fn specialize<'a, 'tcx>(\n             }\n         }\n \n-        PatternKind::Array { ref prefix, slice: _, ref suffix } => {\n-            let pat_len = prefix.len() + suffix.len();\n-            Some(\n-                prefix.iter().chain(\n-                repeat(cx.wild_pattern).take(arity - pat_len).chain(\n-                suffix.iter()\n-            )).collect())\n-        }\n-\n+        PatternKind::Array { ref prefix, ref slice, ref suffix } |\n         PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n-            let pat_len = prefix.len() + suffix.len();\n-            if let Some(slice_count) = arity.checked_sub(pat_len) {\n-                if slice_count == 0 || slice.is_some() {\n-                    Some(\n-                        prefix.iter().chain(\n-                        repeat(cx.wild_pattern).take(slice_count).chain(\n-                        suffix.iter()\n-                    )).collect())\n-                } else {\n-                    None\n+            match *constructor {\n+                Slice(..) => {\n+                    let pat_len = prefix.len() + suffix.len();\n+                    if let Some(slice_count) = arity.checked_sub(pat_len) {\n+                        if slice_count == 0 || slice.is_some() {\n+                            Some(\n+                                prefix.iter().chain(\n+                                repeat(cx.wild_pattern).take(slice_count).chain(\n+                                suffix.iter()\n+                            )).collect())\n+                        } else {\n+                            None\n+                        }\n+                    } else {\n+                        None\n+                    }\n                 }\n-            } else {\n-                None\n+                ConstantValue(..) => {\n+                    match slice_pat_covered_by_constructor(\n+                        cx.tcx, pat.span, constructor, prefix, slice, suffix\n+                            ) {\n+                        Ok(true) => Some(vec![]),\n+                        Ok(false) => None,\n+                        Err(ErrorReported) => None\n+                    }\n+                }\n+                _ => span_bug!(pat.span,\n+                    \"unexpected ctor {:?} for slice pat\", constructor)\n             }\n         }\n     };"}, {"sha": "9aa1ac62f5523abf6b42d7ab4f143fc16ee6686c", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e89b484bbcd1c2fec60794c196d7148dd9f5b/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e89b484bbcd1c2fec60794c196d7148dd9f5b/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=8d3e89b484bbcd1c2fec60794c196d7148dd9f5b", "patch": "@@ -175,7 +175,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             }\n         }\n \n-        MatchCheckCtxt::create_and_enter(self.tcx, |ref cx| {\n+        MatchCheckCtxt::create_and_enter(self.tcx, |ref mut cx| {\n             let mut have_errors = false;\n \n             let inlined_arms : Vec<(Vec<_>, _)> = arms.iter().map(|arm| (\n@@ -235,7 +235,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             \"local binding\"\n         };\n \n-        MatchCheckCtxt::create_and_enter(self.tcx, |ref cx| {\n+        MatchCheckCtxt::create_and_enter(self.tcx, |ref mut cx| {\n             let mut patcx = PatternContext::new(self.tcx);\n             let pats : Matrix = vec![vec![\n                 expand_pattern(cx, patcx.lower_pattern(pat))\n@@ -302,8 +302,8 @@ fn pat_is_catchall(dm: &DefMap, pat: &Pat) -> bool {\n }\n \n // Check for unreachable patterns\n-fn check_arms<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n-                        arms: &[(Vec<(&Pattern<'tcx>, &'a hir::Pat)>, Option<&hir::Expr>)],\n+fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+                        arms: &[(Vec<(&'a Pattern<'tcx>, &hir::Pat)>, Option<&hir::Expr>)],\n                         source: hir::MatchSource)\n {\n     let mut seen = Matrix::empty();\n@@ -381,7 +381,7 @@ fn check_arms<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n     }\n }\n \n-fn check_exhaustive<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n+fn check_exhaustive<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                               sp: Span,\n                               matrix: &Matrix<'a, 'tcx>,\n                               source: hir::MatchSource) {"}, {"sha": "86323656b873e0db44604c1d95bf5556b3be60fc", "filename": "src/test/compile-fail/match-byte-array-patterns.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e89b484bbcd1c2fec60794c196d7148dd9f5b/src%2Ftest%2Fcompile-fail%2Fmatch-byte-array-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e89b484bbcd1c2fec60794c196d7148dd9f5b/src%2Ftest%2Fcompile-fail%2Fmatch-byte-array-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-byte-array-patterns.rs?ref=8d3e89b484bbcd1c2fec60794c196d7148dd9f5b", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(advanced_slice_patterns, slice_patterns)]\n+\n+fn main() {\n+    let buf = &[0, 1, 2, 3];\n+\n+    match buf {\n+        b\"AAAA\" => {},\n+        &[0x41, 0x41, 0x41, 0x41] => {} //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+\n+    match buf {\n+        &[0x41, 0x41, 0x41, 0x41] => {}\n+        b\"AAAA\" => {}, //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+\n+    match buf {\n+        &[_, 0x41, 0x41, 0x41] => {},\n+        b\"AAAA\" => {}, //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+\n+    match buf {\n+        &[0x41, .., 0x41] => {}\n+        b\"AAAA\" => {}, //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+\n+    match buf { //~ ERROR non-exhaustive\n+        b\"AAAA\" => {}\n+    }\n+\n+    let buf: &[u8] = buf;\n+\n+    match buf {\n+        b\"AAAA\" => {},\n+        &[0x41, 0x41, 0x41, 0x41] => {} //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+\n+    match buf {\n+        &[0x41, 0x41, 0x41, 0x41] => {}\n+        b\"AAAA\" => {}, //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+\n+    match buf {\n+        &[_, 0x41, 0x41, 0x41] => {},\n+        b\"AAAA\" => {}, //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+\n+    match buf {\n+        &[0x41, .., 0x41] => {}\n+        b\"AAAA\" => {}, //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+\n+    match buf { //~ ERROR non-exhaustive\n+        b\"AAAA\" => {}\n+    }\n+}"}, {"sha": "dbfe588fb0c6a3788c2e0221bbad538e72c2b475", "filename": "src/test/run-pass/match-byte-array-patterns.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8d3e89b484bbcd1c2fec60794c196d7148dd9f5b/src%2Ftest%2Frun-pass%2Fmatch-byte-array-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3e89b484bbcd1c2fec60794c196d7148dd9f5b/src%2Ftest%2Frun-pass%2Fmatch-byte-array-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-byte-array-patterns.rs?ref=8d3e89b484bbcd1c2fec60794c196d7148dd9f5b", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(slice_patterns)]\n+\n+fn main() {\n+    let buf = &[0u8; 4];\n+    match buf {\n+        &[0, 1, 0, 0] => unimplemented!(),\n+        b\"true\" => unimplemented!(),\n+        _ => {}\n+    }\n+\n+    match buf {\n+        b\"true\" => unimplemented!(),\n+        &[0, 1, 0, 0] => unimplemented!(),\n+        _ => {}\n+    }\n+\n+    match buf {\n+        b\"true\" => unimplemented!(),\n+        &[0, x, 0, 0] => assert_eq!(x, 0),\n+        _ => unimplemented!(),\n+    }\n+\n+    let buf: &[u8] = buf;\n+\n+    match buf {\n+        &[0, 1, 0, 0] => unimplemented!(),\n+        &[_] => unimplemented!(),\n+        &[_, _, _, _, _, ..] => unimplemented!(),\n+        b\"true\" => unimplemented!(),\n+        _ => {}\n+    }\n+\n+    match buf {\n+        b\"true\" => unimplemented!(),\n+        &[0, 1, 0, 0] => unimplemented!(),\n+        _ => {}\n+    }\n+\n+    match buf {\n+        b\"true\" => unimplemented!(),\n+        &[0, x, 0, 0] => assert_eq!(x, 0),\n+        _ => unimplemented!(),\n+    }\n+}"}]}