{"sha": "9bb3543885c37c81b8b1dab516242ea74cfe12dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliYjM1NDM4ODVjMzdjODFiOGIxZGFiNTE2MjQyZWE3NGNmZTEyZGM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-12-30T01:26:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-12-30T01:26:25Z"}, "message": "Rollup merge of #38631 - alexcrichton:supafast, r=brson\n\nrustbuild: Compile rustc twice, not thrice\n\nThis commit switches the rustbuild build system to compiling the\ncompiler twice for a normal bootstrap rather than the historical three\ntimes.\n\nRust is a bootstrapped language which means that a previous version of\nthe compiler is used to build the next version of the compiler. Over\ntime, however, we change many parts of compiler artifacts such as the\nmetadata format, symbol names, etc. These changes make artifacts from\none compiler incompatible from another compiler. Consequently if a\ncompiler wants to be able to use some artifacts then it itself must have\ncompiled the artifacts.\n\nHistorically the rustc build system has achieved this by compiling the\ncompiler three times:\n\n* An older compiler (stage0) is downloaded to kick off the chain.\n* This compiler now compiles a new compiler (stage1)\n* The stage1 compiler then compiles another compiler (stage2)\n* Finally, the stage2 compiler needs libraries to link against, so it\n  compiles all the libraries again.\n\nThis entire process amounts in compiling the compiler three times.\nAdditionally, this process always guarantees that the Rust source tree\ncan compile itself because the stage2 compiler (created by a freshly\ncreated compiler) would successfully compile itself again. This\nproperty, ensuring Rust can compile itself, is quite important!\n\nIn general, though, this third compilation is not required for general\npurpose development on the compiler. The third compiler (stage2) can\nreuse the libraries that were created during the second compile. In\nother words, the second compilation can produce both a compiler and the\nlibraries that compiler will use. These artifacts *must* be compatible\ndue to the way plugins work today anyway, and they were created by the\nsame source code so they *should* be compatible as well.\n\nSo given all that, this commit switches the default build process to\nonly compile the compiler two times, avoiding this third compilation\nby copying artifacts from the previous one. Along the way a new entry in\nthe Travis matrix was also added to ensure that our full bootstrap can\nsucceed. This entry does not run tests, though, as it should not be\nnecessary.\n\nTo restore the old behavior of a full bootstrap (three compiles) you can\neither pass:\n\n    ./configure --enable-full-bootstrap\n\nor if you're using config.toml:\n\n    [build]\n    full-bootstrap = true\n\nOverall this will hopefully be an easy 33% win in build times of the\ncompiler. If we do 33% less work we should be 33% faster! This in turn\nshould affect cycle times and such on Travis and AppVeyor positively as\nwell as making it easier to work on the compiler itself.", "tree": {"sha": "d75dc47dc5de78a85166b8a8a73e56ed97d29f83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d75dc47dc5de78a85166b8a8a73e56ed97d29f83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bb3543885c37c81b8b1dab516242ea74cfe12dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bb3543885c37c81b8b1dab516242ea74cfe12dc", "html_url": "https://github.com/rust-lang/rust/commit/9bb3543885c37c81b8b1dab516242ea74cfe12dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bb3543885c37c81b8b1dab516242ea74cfe12dc/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c2a6f9e9d8e8e3a3027724ba4332e04d48bf9e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c2a6f9e9d8e8e3a3027724ba4332e04d48bf9e5", "html_url": "https://github.com/rust-lang/rust/commit/1c2a6f9e9d8e8e3a3027724ba4332e04d48bf9e5"}, {"sha": "7046fea5be39110f4d4354b7fe5466903f606d8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7046fea5be39110f4d4354b7fe5466903f606d8e", "html_url": "https://github.com/rust-lang/rust/commit/7046fea5be39110f4d4354b7fe5466903f606d8e"}], "stats": {"total": 375, "additions": 262, "deletions": 113}, "files": [{"sha": "915d0bb535b6d239a88f5a91f896810308372a18", "filename": ".travis.yml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3543885c37c81b8b1dab516242ea74cfe12dc/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3543885c37c81b8b1dab516242ea74cfe12dc/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=9bb3543885c37c81b8b1dab516242ea74cfe12dc", "patch": "@@ -19,6 +19,7 @@ matrix:\n     - env: IMAGE=i686-gnu-nopt\n     - env: IMAGE=x86_64-freebsd\n     - env: IMAGE=x86_64-gnu\n+    - env: IMAGE=x86_64-gnu-full-bootstrap\n     - env: IMAGE=x86_64-gnu-cargotest\n     - env: IMAGE=x86_64-gnu-debug\n     - env: IMAGE=x86_64-gnu-nopt"}, {"sha": "5094e5a764bdfcae3a1624e95a7a19d7ff1c564d", "filename": "configure", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3543885c37c81b8b1dab516242ea74cfe12dc/configure", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3543885c37c81b8b1dab516242ea74cfe12dc/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=9bb3543885c37c81b8b1dab516242ea74cfe12dc", "patch": "@@ -693,6 +693,7 @@ opt_nosave manage-submodules 1 \"let the build manage the git submodules\"\n opt_nosave clang 0 \"prefer clang to gcc for building the runtime\"\n opt_nosave jemalloc 1 \"build liballoc with jemalloc\"\n opt elf-tls 1 \"elf thread local storage on platforms where supported\"\n+opt full-bootstrap 0 \"build three compilers instead of two\"\n \n valopt_nosave prefix \"/usr/local\" \"set installation prefix\"\n valopt_nosave local-rust-root \"/usr/local\" \"set prefix for local rust binary\""}, {"sha": "ec0243908edab1bc1b4eb131ff6d04972eb02d83", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3543885c37c81b8b1dab516242ea74cfe12dc/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3543885c37c81b8b1dab516242ea74cfe12dc/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=9bb3543885c37c81b8b1dab516242ea74cfe12dc", "patch": "@@ -341,12 +341,22 @@ pub fn krate(build: &Build,\n     println!(\"{} {} stage{} ({} -> {})\", test_kind, name, compiler.stage,\n              compiler.host, target);\n \n+    // If we're not doing a full bootstrap but we're testing a stage2 version of\n+    // libstd, then what we're actually testing is the libstd produced in\n+    // stage1. Reflect that here by updating the compiler that we're working\n+    // with automatically.\n+    let compiler = if build.force_use_stage1(compiler, target) {\n+        Compiler::new(1, compiler.host)\n+    } else {\n+        compiler.clone()\n+    };\n+\n     // Build up the base `cargo test` command.\n     //\n     // Pass in some standard flags then iterate over the graph we've discovered\n     // in `cargo metadata` with the maps above and figure out what `-p`\n     // arguments need to get passed.\n-    let mut cargo = build.cargo(compiler, mode, target, test_kind.subcommand());\n+    let mut cargo = build.cargo(&compiler, mode, target, test_kind.subcommand());\n     cargo.arg(\"--manifest-path\")\n          .arg(build.src.join(path).join(\"Cargo.toml\"))\n          .arg(\"--features\").arg(features);\n@@ -380,7 +390,7 @@ pub fn krate(build: &Build,\n     // Note that to run the compiler we need to run with the *host* libraries,\n     // but our wrapper scripts arrange for that to be the case anyway.\n     let mut dylib_path = dylib_path();\n-    dylib_path.insert(0, build.sysroot_libdir(compiler, target));\n+    dylib_path.insert(0, build.sysroot_libdir(&compiler, target));\n     cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n \n     if target.contains(\"android\") {\n@@ -399,10 +409,10 @@ pub fn krate(build: &Build,\n \n     if target.contains(\"android\") {\n         build.run(&mut cargo);\n-        krate_android(build, compiler, target, mode);\n+        krate_android(build, &compiler, target, mode);\n     } else if target.contains(\"emscripten\") {\n         build.run(&mut cargo);\n-        krate_emscripten(build, compiler, target, mode);\n+        krate_emscripten(build, &compiler, target, mode);\n     } else {\n         cargo.args(&build.flags.cmd.test_args());\n         build.run(&mut cargo);"}, {"sha": "24e29225c6e02d3708e557721990aa2d369ed662", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 45, "deletions": 47, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3543885c37c81b8b1dab516242ea74cfe12dc/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3543885c37c81b8b1dab516242ea74cfe12dc/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=9bb3543885c37c81b8b1dab516242ea74cfe12dc", "patch": "@@ -33,14 +33,14 @@ use {Build, Compiler, Mode};\n /// This will build the standard library for a particular stage of the build\n /// using the `compiler` targeting the `target` architecture. The artifacts\n /// created will also be linked into the sysroot directory.\n-pub fn std<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n-    println!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n-             compiler.host, target);\n-\n+pub fn std(build: &Build, target: &str, compiler: &Compiler) {\n     let libdir = build.sysroot_libdir(compiler, target);\n     let _ = fs::remove_dir_all(&libdir);\n     t!(fs::create_dir_all(&libdir));\n \n+    println!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n+             compiler.host, target);\n+\n     // Some platforms have startup objects that may be required to produce the\n     // libstd dynamic library, for example.\n     build_startup_objects(build, target, &libdir);\n@@ -65,29 +65,30 @@ pub fn std<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n \n     build.run(&mut cargo);\n     update_mtime(&libstd_stamp(build, &compiler, target));\n-    std_link(build, target, compiler.stage, compiler.host);\n }\n \n /// Link all libstd rlibs/dylibs into the sysroot location.\n ///\n-/// Links those artifacts generated in the given `stage` for `target` produced\n-/// by `compiler` into `host`'s sysroot.\n+/// Links those artifacts generated by `compiler` to a the `stage` compiler's\n+/// sysroot for the specified `host` and `target`.\n+///\n+/// Note that this assumes that `compiler` has already generated the libstd\n+/// libraries for `target`, and this method will find them in the relevant\n+/// output directory.\n pub fn std_link(build: &Build,\n-                target: &str,\n-                stage: u32,\n-                host: &str) {\n-    let compiler = Compiler::new(stage, &build.config.build);\n-    let target_compiler = Compiler::new(compiler.stage, host);\n+                compiler: &Compiler,\n+                target_compiler: &Compiler,\n+                target: &str) {\n+    println!(\"Copying stage{} std from stage{} ({} -> {} / {})\",\n+             target_compiler.stage,\n+             compiler.stage,\n+             compiler.host,\n+             target_compiler.host,\n+             target);\n     let libdir = build.sysroot_libdir(&target_compiler, target);\n     let out_dir = build.cargo_out(&compiler, Mode::Libstd, target);\n \n-    // If we're linking one compiler host's output into another, then we weren't\n-    // called from the `std` method above. In that case we clean out what's\n-    // already there.\n-    if host != compiler.host {\n-        let _ = fs::remove_dir_all(&libdir);\n-        t!(fs::create_dir_all(&libdir));\n-    }\n+    t!(fs::create_dir_all(&libdir));\n     add_to_sysroot(&out_dir, &libdir);\n \n     if target.contains(\"musl\") && !target.contains(\"mips\") {\n@@ -137,7 +138,7 @@ fn build_startup_objects(build: &Build, target: &str, into: &Path) {\n /// This will build libtest and supporting libraries for a particular stage of\n /// the build using the `compiler` targeting the `target` architecture. The\n /// artifacts created will also be linked into the sysroot directory.\n-pub fn test<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n+pub fn test(build: &Build, target: &str, compiler: &Compiler) {\n     println!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n              compiler.host, target);\n     let out_dir = build.cargo_out(compiler, Mode::Libtest, target);\n@@ -147,19 +148,13 @@ pub fn test<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n          .arg(build.src.join(\"src/rustc/test_shim/Cargo.toml\"));\n     build.run(&mut cargo);\n     update_mtime(&libtest_stamp(build, compiler, target));\n-    test_link(build, target, compiler.stage, compiler.host);\n }\n \n-/// Link all libtest rlibs/dylibs into the sysroot location.\n-///\n-/// Links those artifacts generated in the given `stage` for `target` produced\n-/// by `compiler` into `host`'s sysroot.\n+/// Same as `std_link`, only for libtest\n pub fn test_link(build: &Build,\n-                 target: &str,\n-                 stage: u32,\n-                 host: &str) {\n-    let compiler = Compiler::new(stage, &build.config.build);\n-    let target_compiler = Compiler::new(compiler.stage, host);\n+                 compiler: &Compiler,\n+                 target_compiler: &Compiler,\n+                 target: &str) {\n     let libdir = build.sysroot_libdir(&target_compiler, target);\n     let out_dir = build.cargo_out(&compiler, Mode::Libtest, target);\n     add_to_sysroot(&out_dir, &libdir);\n@@ -170,7 +165,7 @@ pub fn test_link(build: &Build,\n /// This will build the compiler for a particular stage of the build using\n /// the `compiler` targeting the `target` architecture. The artifacts\n /// created will also be linked into the sysroot directory.\n-pub fn rustc<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n+pub fn rustc(build: &Build, target: &str, compiler: &Compiler) {\n     println!(\"Building stage{} compiler artifacts ({} -> {})\",\n              compiler.stage, compiler.host, target);\n \n@@ -222,20 +217,13 @@ pub fn rustc<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n         cargo.env(\"CFG_DEFAULT_AR\", s);\n     }\n     build.run(&mut cargo);\n-\n-    rustc_link(build, target, compiler.stage, compiler.host);\n }\n \n-/// Link all librustc rlibs/dylibs into the sysroot location.\n-///\n-/// Links those artifacts generated in the given `stage` for `target` produced\n-/// by `compiler` into `host`'s sysroot.\n+/// Same as `std_link`, only for librustc\n pub fn rustc_link(build: &Build,\n-                  target: &str,\n-                  stage: u32,\n-                  host: &str) {\n-    let compiler = Compiler::new(stage, &build.config.build);\n-    let target_compiler = Compiler::new(compiler.stage, host);\n+                  compiler: &Compiler,\n+                  target_compiler: &Compiler,\n+                  target: &str) {\n     let libdir = build.sysroot_libdir(&target_compiler, target);\n     let out_dir = build.cargo_out(&compiler, Mode::Librustc, target);\n     add_to_sysroot(&out_dir, &libdir);\n@@ -259,6 +247,17 @@ fn compiler_file(compiler: &Path, file: &str) -> PathBuf {\n     PathBuf::from(out.trim())\n }\n \n+pub fn create_sysroot(build: &Build, compiler: &Compiler) {\n+    // nothing to do in stage0\n+    if compiler.stage == 0 {\n+        return\n+    }\n+\n+    let sysroot = build.sysroot(compiler);\n+    let _ = fs::remove_dir_all(&sysroot);\n+    t!(fs::create_dir_all(&sysroot));\n+}\n+\n /// Prepare a new compiler from the artifacts in `stage`\n ///\n /// This will assemble a compiler in `build/$host/stage$stage`. The compiler\n@@ -269,18 +268,17 @@ pub fn assemble_rustc(build: &Build, stage: u32, host: &str) {\n     if stage == 0 {\n         return\n     }\n+\n+    println!(\"Copying stage{} compiler ({})\", stage, host);\n+\n     // The compiler that we're assembling\n     let target_compiler = Compiler::new(stage, host);\n \n     // The compiler that compiled the compiler we're assembling\n     let build_compiler = Compiler::new(stage - 1, &build.config.build);\n \n-    // Clear out old files\n-    let sysroot = build.sysroot(&target_compiler);\n-    let _ = fs::remove_dir_all(&sysroot);\n-    t!(fs::create_dir_all(&sysroot));\n-\n     // Link in all dylibs to the libdir\n+    let sysroot = build.sysroot(&target_compiler);\n     let sysroot_libdir = sysroot.join(libdir(host));\n     t!(fs::create_dir_all(&sysroot_libdir));\n     let src_libdir = build.sysroot_libdir(&build_compiler, host);"}, {"sha": "93fe39ab41b57aa43c5e1d3f1534462ffa227273", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3543885c37c81b8b1dab516242ea74cfe12dc/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3543885c37c81b8b1dab516242ea74cfe12dc/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=9bb3543885c37c81b8b1dab516242ea74cfe12dc", "patch": "@@ -46,6 +46,7 @@ pub struct Config {\n     pub docs: bool,\n     pub vendor: bool,\n     pub target_config: HashMap<String, Target>,\n+    pub full_bootstrap: bool,\n \n     // llvm codegen options\n     pub llvm_assertions: bool,\n@@ -134,6 +135,7 @@ struct Build {\n     vendor: Option<bool>,\n     nodejs: Option<String>,\n     python: Option<String>,\n+    full_bootstrap: Option<bool>,\n }\n \n /// TOML representation of various global install decisions.\n@@ -264,6 +266,7 @@ impl Config {\n         set(&mut config.docs, build.docs);\n         set(&mut config.submodules, build.submodules);\n         set(&mut config.vendor, build.vendor);\n+        set(&mut config.full_bootstrap, build.full_bootstrap);\n \n         if let Some(ref install) = toml.install {\n             config.prefix = install.prefix.clone();\n@@ -393,6 +396,7 @@ impl Config {\n                 (\"NINJA\", self.ninja),\n                 (\"CODEGEN_TESTS\", self.codegen_tests),\n                 (\"VENDOR\", self.vendor),\n+                (\"FULL_BOOTSTRAP\", self.full_bootstrap),\n             }\n \n             match key {"}, {"sha": "7c8d3870e923b12c0147f0411216e45ff52e52b3", "filename": "src/bootstrap/config.toml.example", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3543885c37c81b8b1dab516242ea74cfe12dc/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3543885c37c81b8b1dab516242ea74cfe12dc/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=9bb3543885c37c81b8b1dab516242ea74cfe12dc", "patch": "@@ -100,6 +100,13 @@\n # Indicate whether the vendored sources are used for Rust dependencies or not\n #vendor = false\n \n+# Typically the build system will build the rust compiler twice. The second\n+# compiler, however, will simply use its own libraries to link against. If you\n+# would rather to perform a full bootstrap, compiling the compiler three times,\n+# then you can set this option to true. You shouldn't ever need to set this\n+# option to true.\n+#full-bootstrap = false\n+\n # =============================================================================\n # General install configuration options\n # ============================================================================="}, {"sha": "4c4462bf1220dd68261bd4a74f517e4b560699a5", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3543885c37c81b8b1dab516242ea74cfe12dc/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3543885c37c81b8b1dab516242ea74cfe12dc/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=9bb3543885c37c81b8b1dab516242ea74cfe12dc", "patch": "@@ -137,6 +137,11 @@ pub fn std(build: &Build, stage: u32, target: &str) {\n     let out = build.doc_out(target);\n     t!(fs::create_dir_all(&out));\n     let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = if build.force_use_stage1(&compiler, target) {\n+        Compiler::new(1, compiler.host)\n+    } else {\n+        compiler\n+    };\n     let out_dir = build.stage_out(&compiler, Mode::Libstd)\n                        .join(target).join(\"doc\");\n     let rustdoc = build.rustdoc(&compiler);\n@@ -160,6 +165,11 @@ pub fn test(build: &Build, stage: u32, target: &str) {\n     let out = build.doc_out(target);\n     t!(fs::create_dir_all(&out));\n     let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = if build.force_use_stage1(&compiler, target) {\n+        Compiler::new(1, compiler.host)\n+    } else {\n+        compiler\n+    };\n     let out_dir = build.stage_out(&compiler, Mode::Libtest)\n                        .join(target).join(\"doc\");\n     let rustdoc = build.rustdoc(&compiler);\n@@ -182,6 +192,11 @@ pub fn rustc(build: &Build, stage: u32, target: &str) {\n     let out = build.doc_out(target);\n     t!(fs::create_dir_all(&out));\n     let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = if build.force_use_stage1(&compiler, target) {\n+        Compiler::new(1, compiler.host)\n+    } else {\n+        compiler\n+    };\n     let out_dir = build.stage_out(&compiler, Mode::Librustc)\n                        .join(target).join(\"doc\");\n     let rustdoc = build.rustdoc(&compiler);"}, {"sha": "49eaed4c67acd23658b3177a1126df13bf61db8c", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3543885c37c81b8b1dab516242ea74cfe12dc/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3543885c37c81b8b1dab516242ea74cfe12dc/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=9bb3543885c37c81b8b1dab516242ea74cfe12dc", "patch": "@@ -572,9 +572,7 @@ impl Build {\n         let mut cmd = Command::new(self.tool(&compiler, tool));\n         let host = compiler.host;\n         let mut paths = vec![\n-            self.cargo_out(compiler, Mode::Libstd, host).join(\"deps\"),\n-            self.cargo_out(compiler, Mode::Libtest, host).join(\"deps\"),\n-            self.cargo_out(compiler, Mode::Librustc, host).join(\"deps\"),\n+            self.sysroot_libdir(compiler, compiler.host),\n             self.cargo_out(compiler, Mode::Tool, host).join(\"deps\"),\n         ];\n \n@@ -880,6 +878,30 @@ impl Build {\n     fn python(&self) -> &Path {\n         self.config.python.as_ref().unwrap()\n     }\n+\n+    /// Tests whether the `compiler` compiling for `target` should be forced to\n+    /// use a stage1 compiler instead.\n+    ///\n+    /// Currently, by default, the build system does not perform a \"full\n+    /// bootstrap\" by default where we compile the compiler three times.\n+    /// Instead, we compile the compiler two times. The final stage (stage2)\n+    /// just copies the libraries from the previous stage, which is what this\n+    /// method detects.\n+    ///\n+    /// Here we return `true` if:\n+    ///\n+    /// * The build isn't performing a full bootstrap\n+    /// * The `compiler` is in the final stage, 2\n+    /// * We're not cross-compiling, so the artifacts are already available in\n+    ///   stage1\n+    ///\n+    /// When all of these conditions are met the build will lift artifacts from\n+    /// the previous stage forward.\n+    fn force_use_stage1(&self, compiler: &Compiler, target: &str) -> bool {\n+        !self.config.full_bootstrap &&\n+            compiler.stage >= 2 &&\n+            self.config.host.iter().any(|h| h == target)\n+    }\n }\n \n impl<'a> Compiler<'a> {"}, {"sha": "424a891f324e96494827d767d746df264aa9d146", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 122, "deletions": 59, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3543885c37c81b8b1dab516242ea74cfe12dc/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3543885c37c81b8b1dab516242ea74cfe12dc/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=9bb3543885c37c81b8b1dab516242ea74cfe12dc", "patch": "@@ -44,7 +44,7 @@ pub fn run(build: &Build) {\n     rules.run(&steps);\n }\n \n-pub fn build_rules(build: &Build) -> Rules {\n+pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     let mut rules = Rules::new(build);\n \n     // This is the first rule that we're going to define for rustbuild, which is\n@@ -117,6 +117,7 @@ pub fn build_rules(build: &Build) -> Rules {\n \n     // the compiler with no target libraries ready to go\n     rules.build(\"rustc\", \"src/rustc\")\n+         .dep(|s| s.name(\"create-sysroot\").target(s.host))\n          .dep(move |s| {\n              if s.stage == 0 {\n                  Step::noop()\n@@ -151,69 +152,131 @@ pub fn build_rules(build: &Build) -> Rules {\n     // Crate compilations\n     //\n     // Tools used during the build system but not shipped\n+    rules.build(\"create-sysroot\", \"path/to/nowhere\")\n+         .run(move |s| compile::create_sysroot(build, &s.compiler()));\n+\n+    // These rules are \"pseudo rules\" that don't actually do any work\n+    // themselves, but represent a complete sysroot with the relevant compiler\n+    // linked into place.\n+    //\n+    // That is, depending on \"libstd\" means that when the rule is completed then\n+    // the `stage` sysroot for the compiler `host` will be available with a\n+    // standard library built for `target` linked in place. Not all rules need\n+    // the compiler itself to be available, just the standard library, so\n+    // there's a distinction between the two.\n     rules.build(\"libstd\", \"src/libstd\")\n-         .dep(|s| s.name(\"build-crate-std_shim\"));\n+         .dep(|s| s.name(\"rustc\").target(s.host))\n+         .dep(|s| s.name(\"libstd-link\"));\n     rules.build(\"libtest\", \"src/libtest\")\n-         .dep(|s| s.name(\"build-crate-test_shim\"));\n+         .dep(|s| s.name(\"libstd\"))\n+         .dep(|s| s.name(\"libtest-link\"))\n+         .default(true);\n     rules.build(\"librustc\", \"src/librustc\")\n-         .dep(|s| s.name(\"build-crate-rustc-main\"));\n+         .dep(|s| s.name(\"libtest\"))\n+         .dep(|s| s.name(\"librustc-link\"))\n+         .host(true)\n+         .default(true);\n+\n+    // Helper method to define the rules to link a crate into its place in the\n+    // sysroot.\n+    //\n+    // The logic here is a little subtle as there's a few cases to consider.\n+    // Not all combinations of (stage, host, target) actually require something\n+    // to be compiled, but rather libraries could get propagated from a\n+    // different location. For example:\n+    //\n+    // * Any crate with a `host` that's not the build triple will not actually\n+    //   compile something. A different `host` means that the build triple will\n+    //   actually compile the libraries, and then we'll copy them over from the\n+    //   build triple to the `host` directory.\n+    //\n+    // * Some crates aren't even compiled by the build triple, but may be copied\n+    //   from previous stages. For example if we're not doing a full bootstrap\n+    //   then we may just depend on the stage1 versions of libraries to be\n+    //   available to get linked forward.\n+    //\n+    // * Finally, there are some cases, however, which do indeed comiple crates\n+    //   and link them into place afterwards.\n+    //\n+    // The rule definition below mirrors these three cases. The `dep` method\n+    // calculates the correct dependency which either comes from stage1, a\n+    // different compiler, or from actually building the crate itself (the `dep`\n+    // rule). The `run` rule then mirrors these three cases and links the cases\n+    // forward into the compiler sysroot specified from the correct location.\n+    fn crate_rule<'a, 'b>(build: &'a Build,\n+                          rules: &'b mut Rules<'a>,\n+                          krate: &'a str,\n+                          dep: &'a str,\n+                          link: fn(&Build, &Compiler, &Compiler, &str))\n+                          -> RuleBuilder<'a, 'b> {\n+        let mut rule = rules.build(&krate, \"path/to/nowhere\");\n+        rule.dep(move |s| {\n+                if build.force_use_stage1(&s.compiler(), s.target) {\n+                    s.host(&build.config.build).stage(1)\n+                } else if s.host == build.config.build {\n+                    s.name(dep)\n+                } else {\n+                    s.host(&build.config.build)\n+                }\n+            })\n+            .run(move |s| {\n+                if build.force_use_stage1(&s.compiler(), s.target) {\n+                    link(build,\n+                         &s.stage(1).host(&build.config.build).compiler(),\n+                         &s.compiler(),\n+                         s.target)\n+                } else if s.host == build.config.build {\n+                    link(build, &s.compiler(), &s.compiler(), s.target)\n+                } else {\n+                    link(build,\n+                         &s.host(&build.config.build).compiler(),\n+                         &s.compiler(),\n+                         s.target)\n+                }\n+            });\n+            return rule\n+    }\n+\n+    // Similar to the `libstd`, `libtest`, and `librustc` rules above, except\n+    // these rules only represent the libraries being available in the sysroot,\n+    // not the compiler itself. This is done as not all rules need a compiler in\n+    // the sysroot, but may just need the libraries.\n+    //\n+    // All of these rules use the helper definition above.\n+    crate_rule(build,\n+               &mut rules,\n+               \"libstd-link\",\n+               \"build-crate-std_shim\",\n+               compile::std_link)\n+        .dep(|s| s.name(\"create-sysroot\").target(s.host));\n+    crate_rule(build,\n+               &mut rules,\n+               \"libtest-link\",\n+               \"build-crate-test_shim\",\n+               compile::test_link)\n+        .dep(|s| s.name(\"libstd-link\"));\n+    crate_rule(build,\n+               &mut rules,\n+               \"librustc-link\",\n+               \"build-crate-rustc-main\",\n+               compile::rustc_link)\n+        .dep(|s| s.name(\"libtest-link\"));\n+\n     for (krate, path, _default) in krates(\"std_shim\") {\n         rules.build(&krate.build_step, path)\n              .dep(move |s| s.name(\"rustc\").host(&build.config.build).target(s.host))\n-             .dep(move |s| {\n-                 if s.host == build.config.build {\n-                     Step::noop()\n-                 } else {\n-                    s.host(&build.config.build)\n-                 }\n-             })\n-             .run(move |s| {\n-                 if s.host == build.config.build {\n-                    compile::std(build, s.target, &s.compiler())\n-                 } else {\n-                    compile::std_link(build, s.target, s.stage, s.host)\n-                 }\n-             });\n+             .run(move |s| compile::std(build, s.target, &s.compiler()));\n     }\n-    for (krate, path, default) in krates(\"test_shim\") {\n+    for (krate, path, _default) in krates(\"test_shim\") {\n         rules.build(&krate.build_step, path)\n-             .dep(|s| s.name(\"libstd\"))\n-             .dep(move |s| {\n-                 if s.host == build.config.build {\n-                    Step::noop()\n-                 } else {\n-                    s.host(&build.config.build)\n-                 }\n-             })\n-             .default(default)\n-             .run(move |s| {\n-                 if s.host == build.config.build {\n-                    compile::test(build, s.target, &s.compiler())\n-                 } else {\n-                    compile::test_link(build, s.target, s.stage, s.host)\n-                 }\n-             });\n+             .dep(|s| s.name(\"libstd-link\"))\n+             .run(move |s| compile::test(build, s.target, &s.compiler()));\n     }\n-    for (krate, path, default) in krates(\"rustc-main\") {\n+    for (krate, path, _default) in krates(\"rustc-main\") {\n         rules.build(&krate.build_step, path)\n-             .dep(|s| s.name(\"libtest\"))\n+             .dep(|s| s.name(\"libtest-link\"))\n              .dep(move |s| s.name(\"llvm\").host(&build.config.build).stage(0))\n-             .dep(move |s| {\n-                 if s.host == build.config.build {\n-                    Step::noop()\n-                 } else {\n-                    s.host(&build.config.build)\n-                 }\n-             })\n-             .host(true)\n-             .default(default)\n-             .run(move |s| {\n-                 if s.host == build.config.build {\n-                    compile::rustc(build, s.target, &s.compiler())\n-                 } else {\n-                    compile::rustc_link(build, s.target, s.stage, s.host)\n-                 }\n-             });\n+             .run(move |s| compile::rustc(build, s.target, &s.compiler()));\n     }\n \n     // ========================================================================\n@@ -444,25 +507,25 @@ pub fn build_rules(build: &Build) -> Rules {\n          .run(move |s| doc::standalone(build, s.stage, s.target));\n     rules.doc(\"doc-error-index\", \"src/tools/error_index_generator\")\n          .dep(move |s| s.name(\"tool-error-index\").target(&build.config.build))\n-         .dep(move |s| s.name(\"librustc\"))\n+         .dep(move |s| s.name(\"librustc-link\"))\n          .default(build.config.docs)\n          .host(true)\n          .run(move |s| doc::error_index(build, s.stage, s.target));\n     for (krate, path, default) in krates(\"std_shim\") {\n         rules.doc(&krate.doc_step, path)\n-             .dep(|s| s.name(\"libstd\"))\n+             .dep(|s| s.name(\"libstd-link\"))\n              .default(default && build.config.docs)\n              .run(move |s| doc::std(build, s.stage, s.target));\n     }\n     for (krate, path, default) in krates(\"test_shim\") {\n         rules.doc(&krate.doc_step, path)\n-             .dep(|s| s.name(\"libtest\"))\n+             .dep(|s| s.name(\"libtest-link\"))\n              .default(default && build.config.compiler_docs)\n              .run(move |s| doc::test(build, s.stage, s.target));\n     }\n     for (krate, path, default) in krates(\"rustc-main\") {\n         rules.doc(&krate.doc_step, path)\n-             .dep(|s| s.name(\"librustc\"))\n+             .dep(|s| s.name(\"librustc-link\"))\n              .host(true)\n              .default(default && build.config.compiler_docs)\n              .run(move |s| doc::rustc(build, s.stage, s.target));\n@@ -481,9 +544,9 @@ pub fn build_rules(build: &Build) -> Rules {\n              // for the `rust-std` package, so if this is a host target we\n              // depend on librustc and otherwise we just depend on libtest.\n              if build.config.host.iter().any(|t| t == s.target) {\n-                 s.name(\"librustc\")\n+                 s.name(\"librustc-link\")\n              } else {\n-                 s.name(\"libtest\")\n+                 s.name(\"libtest-link\")\n              }\n          })\n          .default(true)"}, {"sha": "7c079e45751c1acbdf878693be048e8418656fc8", "filename": "src/ci/docker/x86_64-gnu-full-bootstrap/Dockerfile", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3543885c37c81b8b1dab516242ea74cfe12dc/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3543885c37c81b8b1dab516242ea74cfe12dc/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile?ref=9bb3543885c37c81b8b1dab516242ea74cfe12dc", "patch": "@@ -0,0 +1,28 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  xz-utils\n+\n+ENV SCCACHE_DIGEST=7237e38e029342fa27b7ac25412cb9d52554008b12389727320bd533fd7f05b6a96d55485f305caf95e5c8f5f97c3313e10012ccad3e752aba2518f3522ba783\n+RUN curl -L https://api.pub.build.mozilla.org/tooltool/sha512/$SCCACHE_DIGEST | \\\n+      tar xJf - -C /usr/local/bin --strip-components=1\n+\n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n+ENV RUST_CONFIGURE_ARGS \\\n+      --build=x86_64-unknown-linux-gnu \\\n+      --enable-full-bootstrap\n+ENV RUST_CHECK_TARGET \"\""}]}