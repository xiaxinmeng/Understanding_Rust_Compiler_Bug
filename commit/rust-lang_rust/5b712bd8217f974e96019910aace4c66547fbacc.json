{"sha": "5b712bd8217f974e96019910aace4c66547fbacc", "node_id": "C_kwDOAAsO6NoAKDViNzEyYmQ4MjE3Zjk3NGU5NjAxOTkxMGFhY2U0YzY2NTQ3ZmJhY2M", "commit": {"author": {"name": "Steven Joruk", "email": "steven@joruk.com", "date": "2022-03-01T13:03:51Z"}, "committer": {"name": "Steven Joruk", "email": "steven@joruk.com", "date": "2022-03-12T13:42:24Z"}, "message": "feat: Add an assist for inlining type aliases\n\nThis intends to lead to a more useful assist to replace all users of an\nalias with its definition.", "tree": {"sha": "e3686a9ed11e4db7842ea8ccff29533b6f90c122", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3686a9ed11e4db7842ea8ccff29533b6f90c122"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b712bd8217f974e96019910aace4c66547fbacc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b712bd8217f974e96019910aace4c66547fbacc", "html_url": "https://github.com/rust-lang/rust/commit/5b712bd8217f974e96019910aace4c66547fbacc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b712bd8217f974e96019910aace4c66547fbacc/comments", "author": {"login": "steven-joruk", "id": 1277939, "node_id": "MDQ6VXNlcjEyNzc5Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1277939?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steven-joruk", "html_url": "https://github.com/steven-joruk", "followers_url": "https://api.github.com/users/steven-joruk/followers", "following_url": "https://api.github.com/users/steven-joruk/following{/other_user}", "gists_url": "https://api.github.com/users/steven-joruk/gists{/gist_id}", "starred_url": "https://api.github.com/users/steven-joruk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steven-joruk/subscriptions", "organizations_url": "https://api.github.com/users/steven-joruk/orgs", "repos_url": "https://api.github.com/users/steven-joruk/repos", "events_url": "https://api.github.com/users/steven-joruk/events{/privacy}", "received_events_url": "https://api.github.com/users/steven-joruk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steven-joruk", "id": 1277939, "node_id": "MDQ6VXNlcjEyNzc5Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1277939?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steven-joruk", "html_url": "https://github.com/steven-joruk", "followers_url": "https://api.github.com/users/steven-joruk/followers", "following_url": "https://api.github.com/users/steven-joruk/following{/other_user}", "gists_url": "https://api.github.com/users/steven-joruk/gists{/gist_id}", "starred_url": "https://api.github.com/users/steven-joruk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steven-joruk/subscriptions", "organizations_url": "https://api.github.com/users/steven-joruk/orgs", "repos_url": "https://api.github.com/users/steven-joruk/repos", "events_url": "https://api.github.com/users/steven-joruk/events{/privacy}", "received_events_url": "https://api.github.com/users/steven-joruk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdeb1b2c78e07d326871bf5ee2bcebdf01806750", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdeb1b2c78e07d326871bf5ee2bcebdf01806750", "html_url": "https://github.com/rust-lang/rust/commit/cdeb1b2c78e07d326871bf5ee2bcebdf01806750"}], "stats": {"total": 746, "additions": 746, "deletions": 0}, "files": [{"sha": "f6c5762d0d6ae5e736d94cf970123268a8d8bf91", "filename": "crates/ide_assists/src/handlers/inline_type_alias.rs", "status": "added", "additions": 714, "deletions": 0, "changes": 714, "blob_url": "https://github.com/rust-lang/rust/blob/5b712bd8217f974e96019910aace4c66547fbacc/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_type_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b712bd8217f974e96019910aace4c66547fbacc/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_type_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_type_alias.rs?ref=5b712bd8217f974e96019910aace4c66547fbacc", "patch": "@@ -0,0 +1,714 @@\n+// Some ideas for future improvements:\n+// - Support replacing aliases which are used in expressions, e.g. `A::new()`.\n+// - \"inline_alias_to_users\" assist #10881.\n+// - Remove unused aliases if there are no longer any users, see inline_call.rs.\n+\n+use hir::PathResolution;\n+use itertools::Itertools;\n+use std::collections::HashMap;\n+use syntax::{\n+    ast::{\n+        self,\n+        make::{self},\n+        HasGenericParams, HasName,\n+    },\n+    ted::{self},\n+    AstNode, NodeOrToken, SyntaxKind, SyntaxNode,\n+};\n+\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    AssistId, AssistKind,\n+};\n+\n+// Assist: inline_type_alias\n+//\n+// Replace a type alias with its concrete type.\n+//\n+// ```\n+// type A<T = u32> = Vec<T>;\n+//\n+// fn main() {\n+//     let a: $0A;\n+// }\n+// ```\n+// ->\n+// ```\n+// type A<T = u32> = Vec<T>;\n+//\n+// fn main() {\n+//     let a: Vec<u32>;\n+// }\n+// ```\n+pub(crate) fn inline_type_alias(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let alias_instance = ctx.find_node_at_offset::<ast::PathType>()?;\n+    let alias = get_type_alias(&ctx, &alias_instance)?;\n+    let concrete_type = alias.ty()?;\n+\n+    let replacement = if let Some(alias_generics) = alias.generic_param_list() {\n+        get_replacement_for_generic_alias(\n+            alias_instance.syntax().descendants().find_map(ast::GenericArgList::cast),\n+            alias_generics,\n+            &concrete_type,\n+        )?\n+    } else {\n+        concrete_type.to_string()\n+    };\n+\n+    let target = alias_instance.syntax().text_range();\n+\n+    acc.add(\n+        AssistId(\"inline_type_alias\", AssistKind::RefactorInline),\n+        \"Inline type alias\",\n+        target,\n+        |builder| {\n+            builder.replace(target, replacement);\n+        },\n+    )\n+}\n+\n+/// This doesn't attempt to ensure specified generics are compatible with those\n+/// required by the type alias, other than lifetimes which must either all be\n+/// specified or all omitted. It will replace TypeArgs with ConstArgs and vice\n+/// versa if they're in the wrong position. It supports partially specified\n+/// generics.\n+///\n+/// 1. Map the provided instance's generic args to the type alias's generic\n+///    params:\n+///\n+///    ```\n+///    type A<'a, const N: usize, T = u64> = &'a [T; N];\n+///          ^ alias generic params\n+///    let a: A<100>;\n+///            ^ instance generic args\n+///    ```\n+///\n+///    generic['a] = '_ due to omission\n+///    generic[N] = 100 due to the instance arg\n+///    generic[T] = u64 due to the default param\n+///\n+/// 2. Copy the concrete type and substitute in each found mapping:\n+///\n+///    &'_ [u64; 100]\n+///\n+/// 3. Remove wildcard lifetimes entirely:\n+///\n+///    &[u64; 100]\n+fn get_replacement_for_generic_alias(\n+    instance_generic_args_list: Option<ast::GenericArgList>,\n+    alias_generics: ast::GenericParamList,\n+    concrete_type: &ast::Type,\n+) -> Option<String> {\n+    if alias_generics.generic_params().count() == 0 {\n+        cov_mark::hit!(no_generics_params);\n+        return None;\n+    }\n+\n+    let mut lifetime_mappings = HashMap::<&str, ast::Lifetime>::new();\n+    let mut other_mappings = HashMap::<String, SyntaxNode>::new();\n+\n+    let wildcard_lifetime = make::lifetime(\"'_\");\n+    let alias_lifetimes = alias_generics.lifetime_params().map(|l| l.to_string()).collect_vec();\n+    for lifetime in &alias_lifetimes {\n+        lifetime_mappings.insert(lifetime, wildcard_lifetime.clone());\n+    }\n+\n+    if let Some(ref instance_generic_args_list) = instance_generic_args_list {\n+        for (index, lifetime) in instance_generic_args_list\n+            .lifetime_args()\n+            .map(|arg| arg.lifetime().expect(\"LifetimeArg has a Lifetime\"))\n+            .enumerate()\n+        {\n+            if index >= alias_lifetimes.len() {\n+                cov_mark::hit!(too_many_lifetimes);\n+                return None;\n+            }\n+\n+            let key = &alias_lifetimes[index];\n+\n+            lifetime_mappings.insert(key, lifetime);\n+        }\n+    }\n+\n+    let instance_generics = generic_args_to_other_generics(instance_generic_args_list);\n+    let alias_generics = generic_param_list_to_other_generics(&alias_generics);\n+\n+    if instance_generics.len() > alias_generics.len() {\n+        cov_mark::hit!(too_many_generic_args);\n+        return None;\n+    }\n+\n+    // Any declaration generics that don't have a default value must have one\n+    // provided by the instance.\n+    for (i, declaration_generic) in alias_generics.iter().enumerate() {\n+        let key = declaration_generic.replacement_key();\n+\n+        if let Some(instance_generic) = instance_generics.get(i) {\n+            other_mappings.insert(key, instance_generic.replacement_value()?);\n+        } else if let Some(value) = declaration_generic.replacement_value() {\n+            other_mappings.insert(key, value);\n+        } else {\n+            cov_mark::hit!(missing_replacement_param);\n+            return None;\n+        }\n+    }\n+\n+    let updated_concrete_type = concrete_type.clone_for_update();\n+    let mut replacements = Vec::new();\n+    let mut removals = Vec::new();\n+\n+    for syntax in updated_concrete_type.syntax().descendants() {\n+        let syntax_string = syntax.to_string();\n+        let syntax_str = syntax_string.as_str();\n+\n+        if syntax.kind() == SyntaxKind::LIFETIME {\n+            let new = lifetime_mappings.get(syntax_str).expect(\"lifetime is mapped\");\n+            if new.text() == \"'_\" {\n+                removals.push(NodeOrToken::Node(syntax.clone()));\n+\n+                if let Some(ws) = syntax.next_sibling_or_token() {\n+                    removals.push(ws.clone());\n+                }\n+\n+                continue;\n+            }\n+\n+            replacements.push((syntax.clone(), new.syntax().clone_for_update()));\n+        } else if let Some(replacement_syntax) = other_mappings.get(syntax_str) {\n+            let new_string = replacement_syntax.to_string();\n+            let new = if new_string == \"_\" {\n+                make::wildcard_pat().syntax().clone_for_update()\n+            } else {\n+                replacement_syntax.clone_for_update()\n+            };\n+\n+            replacements.push((syntax.clone(), new));\n+        }\n+    }\n+\n+    for (old, new) in replacements {\n+        ted::replace(old, new);\n+    }\n+\n+    for syntax in removals {\n+        ted::remove(syntax);\n+    }\n+\n+    Some(updated_concrete_type.to_string())\n+}\n+\n+fn get_type_alias(ctx: &AssistContext, path: &ast::PathType) -> Option<ast::TypeAlias> {\n+    let resolved_path = ctx.sema.resolve_path(&path.path()?)?;\n+\n+    // We need the generics in the correct order to be able to map any provided\n+    // instance generics to declaration generics. The `hir::TypeAlias` doesn't\n+    // keep the order, so we must get the `ast::TypeAlias` from the hir\n+    // definition.\n+    if let PathResolution::Def(hir::ModuleDef::TypeAlias(ta)) = resolved_path {\n+        ast::TypeAlias::cast(ctx.sema.source(ta)?.syntax().value.clone())\n+    } else {\n+        None\n+    }\n+}\n+\n+enum OtherGeneric {\n+    ConstArg(ast::ConstArg),\n+    TypeArg(ast::TypeArg),\n+    ConstParam(ast::ConstParam),\n+    TypeParam(ast::TypeParam),\n+}\n+\n+impl OtherGeneric {\n+    fn replacement_key(&self) -> String {\n+        // Only params are used as replacement keys.\n+        match self {\n+            OtherGeneric::ConstArg(_) => unreachable!(),\n+            OtherGeneric::TypeArg(_) => unreachable!(),\n+            OtherGeneric::ConstParam(cp) => cp.name().expect(\"ConstParam has a name\").to_string(),\n+            OtherGeneric::TypeParam(tp) => tp.name().expect(\"TypeParam has a name\").to_string(),\n+        }\n+    }\n+\n+    fn replacement_value(&self) -> Option<SyntaxNode> {\n+        Some(match self {\n+            OtherGeneric::ConstArg(ca) => ca.expr()?.syntax().clone(),\n+            OtherGeneric::TypeArg(ta) => ta.syntax().clone(),\n+            OtherGeneric::ConstParam(cp) => cp.default_val()?.syntax().clone(),\n+            OtherGeneric::TypeParam(tp) => tp.default_type()?.syntax().clone(),\n+        })\n+    }\n+}\n+\n+fn generic_param_list_to_other_generics(generics: &ast::GenericParamList) -> Vec<OtherGeneric> {\n+    let mut others = Vec::new();\n+\n+    for param in generics.generic_params() {\n+        match param {\n+            ast::GenericParam::LifetimeParam(_) => {}\n+            ast::GenericParam::ConstParam(cp) => {\n+                others.push(OtherGeneric::ConstParam(cp));\n+            }\n+            ast::GenericParam::TypeParam(tp) => others.push(OtherGeneric::TypeParam(tp)),\n+        }\n+    }\n+\n+    others\n+}\n+\n+fn generic_args_to_other_generics(generics: Option<ast::GenericArgList>) -> Vec<OtherGeneric> {\n+    let mut others = Vec::new();\n+\n+    // It's fine for there to be no instance generics because the declaration\n+    // might have default values or they might be inferred.\n+    if let Some(generics) = generics {\n+        for arg in generics.generic_args() {\n+            match arg {\n+                ast::GenericArg::TypeArg(ta) => {\n+                    others.push(OtherGeneric::TypeArg(ta));\n+                }\n+                ast::GenericArg::ConstArg(ca) => {\n+                    others.push(OtherGeneric::ConstArg(ca));\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+\n+    others\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    #[test]\n+    fn empty_generic_params() {\n+        cov_mark::check!(no_generics_params);\n+        check_assist_not_applicable(\n+            inline_type_alias,\n+            r#\"\n+type A<> = T;\n+fn main() {\n+    let a: $0A<u32>;\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn too_many_generic_args() {\n+        cov_mark::check!(too_many_generic_args);\n+        check_assist_not_applicable(\n+            inline_type_alias,\n+            r#\"\n+type A<T> = T;\n+fn main() {\n+    let a: $0A<u32, u64>;\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn too_many_lifetimes() {\n+        cov_mark::check!(too_many_lifetimes);\n+        check_assist_not_applicable(\n+            inline_type_alias,\n+            r#\"\n+type A<'a> = &'a &'b u32;\n+fn f<'a>() {\n+    let a: $0A<'a, 'b> = 0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    // This must be supported in order to support \"inline_alias_to_users\" or\n+    // whatever it will be called.\n+    #[test]\n+    fn alias_as_expression_ignored() {\n+        check_assist_not_applicable(\n+            inline_type_alias,\n+            r#\"\n+type A = Vec<u32>;\n+fn main() {\n+    let a: A = $0A::new();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn primitive_arg() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A<T> = T;\n+fn main() {\n+    let a: $0A<u32> = 0;\n+}\n+\"#,\n+            r#\"\n+type A<T> = T;\n+fn main() {\n+    let a: u32 = 0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_generic_replacements() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A = Vec<u32>;\n+fn main() {\n+    let a: $0A;\n+}\n+\"#,\n+            r#\"\n+type A = Vec<u32>;\n+fn main() {\n+    let a: Vec<u32>;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn param_expression() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A<const N: usize = { 1 }> = [u32; N];\n+fn main() {\n+    let a: $0A;\n+}\n+\"#,\n+            r#\"\n+type A<const N: usize = { 1 }> = [u32; N];\n+fn main() {\n+    let a: [u32; { 1 }];\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn param_default_value() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A<const N: usize = 1> = [u32; N];\n+fn main() {\n+    let a: $0A;\n+}\n+\"#,\n+            r#\"\n+type A<const N: usize = 1> = [u32; N];\n+fn main() {\n+    let a: [u32; 1];\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn all_param_types() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+struct Struct<const C: usize>;\n+type A<'inner1, 'outer1, Outer1, const INNER1: usize, Inner1: Clone, const OUTER1: usize> = (Struct<INNER1>, Struct<OUTER1>, Outer1, &'inner1 (), Inner1, &'outer1 ());\n+fn foo<'inner2, 'outer2, Outer2, const INNER2: usize, Inner2, const OUTER2: usize>() {\n+    let a: $0A<'inner2, 'outer2, Outer2, INNER2, Inner2, OUTER2>;\n+}\n+\"#,\n+            r#\"\n+struct Struct<const C: usize>;\n+type A<'inner1, 'outer1, Outer1, const INNER1: usize, Inner1: Clone, const OUTER1: usize> = (Struct<INNER1>, Struct<OUTER1>, Outer1, &'inner1 (), Inner1, &'outer1 ());\n+fn foo<'inner2, 'outer2, Outer2, const INNER2: usize, Inner2, const OUTER2: usize>() {\n+    let a: (Struct<INNER2>, Struct<OUTER2>, Outer2, &'inner2 (), Inner2, &'outer2 ());\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn omitted_lifetimes() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A<'l, 'r> = &'l &'r u32;\n+fn main() {\n+    let a: $0A;\n+}\n+\"#,\n+            r#\"\n+type A<'l, 'r> = &'l &'r u32;\n+fn main() {\n+    let a: &&u32;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn omitted_type() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A<'r, 'l, T = u32> = &'l std::collections::HashMap<&'r str, T>;\n+fn main() {\n+    let a: $0A<'_, '_>;\n+}\n+\"#,\n+            r#\"\n+type A<'r, 'l, T = u32> = &'l std::collections::HashMap<&'r str, T>;\n+fn main() {\n+    let a: &std::collections::HashMap<&str, u32>;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn omitted_everything() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A<'r, 'l, T = u32> = &'l std::collections::HashMap<&'r str, T>;\n+fn main() {\n+    let v = std::collections::HashMap<&str, u32>;\n+    let a: $0A = &v;\n+}\n+\"#,\n+            r#\"\n+type A<'r, 'l, T = u32> = &'l std::collections::HashMap<&'r str, T>;\n+fn main() {\n+    let v = std::collections::HashMap<&str, u32>;\n+    let a: &std::collections::HashMap<&str, u32> = &v;\n+}\n+\"#,\n+        );\n+    }\n+\n+    // This doesn't actually cause the GenericArgsList to contain a AssocTypeArg.\n+    #[test]\n+    fn arg_associated_type() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+trait Tra { type Assoc; fn a(); }\n+struct Str {}\n+impl Tra for Str {\n+    type Assoc = u32;\n+    fn a() {\n+        type A<T> = Vec<T>;\n+        let a: $0A<Self::Assoc>;\n+    }\n+}\n+\"#,\n+            r#\"\n+trait Tra { type Assoc; fn a(); }\n+struct Str {}\n+impl Tra for Str {\n+    type Assoc = u32;\n+    fn a() {\n+        type A<T> = Vec<T>;\n+        let a: Vec<Self::Assoc>;\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn param_default_associated_type() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+trait Tra { type Assoc; fn a() }\n+struct Str {}\n+impl Tra for Str {\n+    type Assoc = u32;\n+    fn a() {\n+        type A<T = Self::Assoc> = Vec<T>;\n+        let a: $0A;\n+    }\n+}\n+\"#,\n+            r#\"\n+trait Tra { type Assoc; fn a() }\n+struct Str {}\n+impl Tra for Str {\n+    type Assoc = u32;\n+    fn a() {\n+        type A<T = Self::Assoc> = Vec<T>;\n+        let a: Vec<Self::Assoc>;\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn function_pointer() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A = fn(u32);\n+fn foo(a: u32) {}\n+fn main() {\n+    let a: $0A = foo;\n+}\n+\"#,\n+            r#\"\n+type A = fn(u32);\n+fn foo(a: u32) {}\n+fn main() {\n+    let a: fn(u32) = foo;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn closure() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A = Box<dyn FnOnce(u32) -> u32>;\n+fn main() {\n+    let a: $0A = Box::new(|_| 0);\n+}\n+\"#,\n+            r#\"\n+type A = Box<dyn FnOnce(u32) -> u32>;\n+fn main() {\n+    let a: Box<dyn FnOnce(u32) -> u32> = Box::new(|_| 0);\n+}\n+\"#,\n+        );\n+    }\n+\n+    // Type aliases can't be used in traits, but someone might use the assist to\n+    // fix the error.\n+    #[test]\n+    fn bounds() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"type A = std::io::Write; fn f<T>() where T: $0A {}\"#,\n+            r#\"type A = std::io::Write; fn f<T>() where T: std::io::Write {}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn function_parameter() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A = std::io::Write;\n+fn f(a: impl $0A) {}\n+\"#,\n+            r#\"\n+type A = std::io::Write;\n+fn f(a: impl std::io::Write) {}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn arg_expression() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A<const N: usize> = [u32; N];\n+fn main() {\n+    let a: $0A<{ 1 + 1 }>;\n+}\n+\"#,\n+            r#\"\n+type A<const N: usize> = [u32; N];\n+fn main() {\n+    let a: [u32; { 1 + 1 }];\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn alias_instance_generic_path() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A<const N: usize> = [u32; N];\n+fn main() {\n+    let a: $0A<u32::MAX>;\n+}\n+\"#,\n+            r#\"\n+type A<const N: usize> = [u32; N];\n+fn main() {\n+    let a: [u32; u32::MAX];\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn generic_type() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A = String;\n+fn f(a: Vec<$0A>) {}\n+\"#,\n+            r#\"\n+type A = String;\n+fn f(a: Vec<String>) {}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn missing_replacement_param() {\n+        cov_mark::check!(missing_replacement_param);\n+        check_assist_not_applicable(\n+            inline_type_alias,\n+            r#\"\n+type A<U> = Vec<T>;\n+fn main() {\n+    let a: $0A;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn imported_external() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+mod foo {\n+    type A = String;\n+}\n+fn main() {\n+    use foo::A;\n+    let a: $0A;\n+}\n+\"#,\n+            r#\"\n+mod foo {\n+    type A = String;\n+}\n+fn main() {\n+    use foo::A;\n+    let a: String;\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "6eff8871e8ae6827d8975afa55fec96c5c62a001", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b712bd8217f974e96019910aace4c66547fbacc/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b712bd8217f974e96019910aace4c66547fbacc/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=5b712bd8217f974e96019910aace4c66547fbacc", "patch": "@@ -150,6 +150,7 @@ mod handlers {\n     mod add_return_type;\n     mod inline_call;\n     mod inline_local_variable;\n+    mod inline_type_alias;\n     mod introduce_named_lifetime;\n     mod invert_if;\n     mod merge_imports;\n@@ -231,6 +232,7 @@ mod handlers {\n             inline_call::inline_call,\n             inline_call::inline_into_callers,\n             inline_local_variable::inline_local_variable,\n+            inline_type_alias::inline_type_alias,\n             introduce_named_generic::introduce_named_generic,\n             introduce_named_lifetime::introduce_named_lifetime,\n             invert_if::invert_if,"}, {"sha": "84343daa6af4756e548555784af1fef8b289340e", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5b712bd8217f974e96019910aace4c66547fbacc/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b712bd8217f974e96019910aace4c66547fbacc/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=5b712bd8217f974e96019910aace4c66547fbacc", "patch": "@@ -1239,6 +1239,27 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_inline_type_alias() {\n+    check_doc_test(\n+        \"inline_type_alias\",\n+        r#####\"\n+type A<T = u32> = Vec<T>;\n+\n+fn main() {\n+    let a: $0A;\n+}\n+\"#####,\n+        r#####\"\n+type A<T = u32> = Vec<T>;\n+\n+fn main() {\n+    let a: Vec<u32>;\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_introduce_named_generic() {\n     check_doc_test("}, {"sha": "e1d4addb52f68aefaf74f139b5da70413386b666", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5b712bd8217f974e96019910aace4c66547fbacc/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b712bd8217f974e96019910aace4c66547fbacc/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=5b712bd8217f974e96019910aace4c66547fbacc", "patch": "@@ -764,6 +764,15 @@ impl ast::Meta {\n     }\n }\n \n+impl ast::GenericArgList {\n+    pub fn lifetime_args(&self) -> impl Iterator<Item = ast::LifetimeArg> {\n+        self.generic_args().filter_map(|arg| match arg {\n+            ast::GenericArg::LifetimeArg(it) => Some(it),\n+            _ => None,\n+        })\n+    }\n+}\n+\n impl ast::GenericParamList {\n     pub fn lifetime_params(&self) -> impl Iterator<Item = ast::LifetimeParam> {\n         self.generic_params().filter_map(|param| match param {"}]}