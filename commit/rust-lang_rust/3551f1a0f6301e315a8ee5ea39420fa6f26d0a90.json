{"sha": "3551f1a0f6301e315a8ee5ea39420fa6f26d0a90", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1NTFmMWEwZjYzMDFlMzE1YThlZTVlYTM5NDIwZmE2ZjI2ZDBhOTA=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-05-09T11:00:34Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-05-17T16:38:20Z"}, "message": "Use Fields as output to specialize_one_pattern", "tree": {"sha": "2dfc0c207e4069d3869f26e853ad4dc02c40d84e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dfc0c207e4069d3869f26e853ad4dc02c40d84e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3551f1a0f6301e315a8ee5ea39420fa6f26d0a90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3551f1a0f6301e315a8ee5ea39420fa6f26d0a90", "html_url": "https://github.com/rust-lang/rust/commit/3551f1a0f6301e315a8ee5ea39420fa6f26d0a90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3551f1a0f6301e315a8ee5ea39420fa6f26d0a90/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76dea86df44c172ba315f2938693f4ca1bd03b7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/76dea86df44c172ba315f2938693f4ca1bd03b7c", "html_url": "https://github.com/rust-lang/rust/commit/76dea86df44c172ba315f2938693f4ca1bd03b7c"}], "stats": {"total": 74, "additions": 51, "deletions": 23}, "files": [{"sha": "1d08d8d21daa1e8ee9c5774058b32ce8079b4ff5", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 51, "deletions": 23, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/3551f1a0f6301e315a8ee5ea39420fa6f26d0a90/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3551f1a0f6301e315a8ee5ea39420fa6f26d0a90/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=3551f1a0f6301e315a8ee5ea39420fa6f26d0a90", "patch": "@@ -443,11 +443,9 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n         constructor: &Constructor<'tcx>,\n         ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     ) -> Option<PatStack<'p, 'tcx>> {\n-        let new_heads = specialize_one_pattern(cx, self.head(), constructor, ctor_wild_subpatterns);\n-        new_heads.map(|mut new_head| {\n-            new_head.0.extend_from_slice(&self.0[1..]);\n-            new_head\n-        })\n+        let new_fields =\n+            specialize_one_pattern(cx, self.head(), constructor, ctor_wild_subpatterns)?;\n+        Some(new_fields.push_on_patstack(&self.0[1..]))\n     }\n }\n \n@@ -1034,9 +1032,24 @@ impl<'tcx> Constructor<'tcx> {\n #[derive(Debug, Clone)]\n enum Fields<'p, 'tcx> {\n     Slice(&'p [Pat<'tcx>]),\n+    Vec(SmallVec<[&'p Pat<'tcx>; 2]>),\n }\n \n impl<'p, 'tcx> Fields<'p, 'tcx> {\n+    fn empty() -> Self {\n+        Fields::Slice(&[])\n+    }\n+\n+    /// Construct a new `Fields` from the given pattern. Must not be used if the pattern is a field\n+    /// of a struct/tuple/variant.\n+    fn from_single_pattern(pat: &'p Pat<'tcx>) -> Self {\n+        Fields::Slice(std::slice::from_ref(pat))\n+    }\n+\n+    fn from_vec(pats: SmallVec<[&'p Pat<'tcx>; 2]>) -> Self {\n+        Fields::Vec(pats)\n+    }\n+\n     /// Creates a new list of wildcard fields for a given constructor.\n     fn wildcards(\n         cx: &MatchCheckCtxt<'p, 'tcx>,\n@@ -1051,13 +1064,27 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n     fn len(&self) -> usize {\n         match self {\n             Fields::Slice(pats) => pats.len(),\n+            Fields::Vec(pats) => pats.len(),\n         }\n     }\n \n-    fn iter<'a>(&'a self) -> impl Iterator<Item = &'p Pat<'tcx>> + Captures<'a> {\n-        match self {\n-            Fields::Slice(pats) => pats.iter(),\n-        }\n+    fn iter(&self) -> impl Iterator<Item = &'p Pat<'tcx>> {\n+        let pats: SmallVec<_> = match self {\n+            Fields::Slice(pats) => pats.iter().collect(),\n+            Fields::Vec(pats) => pats.clone(),\n+        };\n+        pats.into_iter()\n+    }\n+\n+    fn push_on_patstack(self, stack: &[&'p Pat<'tcx>]) -> PatStack<'p, 'tcx> {\n+        let pats: SmallVec<_> = match self {\n+            Fields::Slice(pats) => pats.iter().chain(stack.iter().copied()).collect(),\n+            Fields::Vec(mut pats) => {\n+                pats.extend_from_slice(stack);\n+                pats\n+            }\n+        };\n+        PatStack::from_vec(pats)\n     }\n }\n \n@@ -2330,7 +2357,7 @@ fn patterns_for_variant<'p, 'tcx>(\n     subpatterns: &'p [FieldPat<'tcx>],\n     ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     is_non_exhaustive: bool,\n-) -> PatStack<'p, 'tcx> {\n+) -> Fields<'p, 'tcx> {\n     let mut result: SmallVec<_> = ctor_wild_subpatterns.iter().collect();\n \n     for subpat in subpatterns {\n@@ -2343,7 +2370,7 @@ fn patterns_for_variant<'p, 'tcx>(\n         \"patterns_for_variant({:#?}, {:#?}) = {:#?}\",\n         subpatterns, ctor_wild_subpatterns, result\n     );\n-    PatStack::from_vec(result)\n+    Fields::from_vec(result)\n }\n \n /// This is the main specialization step. It expands the pattern\n@@ -2360,16 +2387,16 @@ fn specialize_one_pattern<'p, 'tcx>(\n     pat: &'p Pat<'tcx>,\n     constructor: &Constructor<'tcx>,\n     ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n-) -> Option<PatStack<'p, 'tcx>> {\n+) -> Option<Fields<'p, 'tcx>> {\n     if let NonExhaustive = constructor {\n         // Only a wildcard pattern can match the special extra constructor\n-        return if pat.is_wildcard() { Some(PatStack::default()) } else { None };\n+        return if pat.is_wildcard() { Some(Fields::empty()) } else { None };\n     }\n \n     let result = match *pat.kind {\n         PatKind::AscribeUserType { .. } => bug!(), // Handled by `expand_pattern`\n \n-        PatKind::Binding { .. } | PatKind::Wild => Some(ctor_wild_subpatterns.iter().collect()),\n+        PatKind::Binding { .. } | PatKind::Wild => Some(ctor_wild_subpatterns.clone()),\n \n         PatKind::Variant { adt_def, variant_index, ref subpatterns, .. } => {\n             let variant = &adt_def.variants[variant_index];\n@@ -2385,7 +2412,7 @@ fn specialize_one_pattern<'p, 'tcx>(\n             Some(patterns_for_variant(cx, subpatterns, ctor_wild_subpatterns, false))\n         }\n \n-        PatKind::Deref { ref subpattern } => Some(PatStack::from_pattern(subpattern)),\n+        PatKind::Deref { ref subpattern } => Some(Fields::from_single_pattern(subpattern)),\n \n         PatKind::Constant { value } if constructor.is_slice() => {\n             // We extract an `Option` for the pointer because slices of zero\n@@ -2399,7 +2426,7 @@ fn specialize_one_pattern<'p, 'tcx>(\n                     // the result would be exactly what we early return here.\n                     if n == 0 {\n                         if ctor_wild_subpatterns.len() as u64 == 0 {\n-                            return Some(PatStack::from_slice(&[]));\n+                            return Some(Fields::empty());\n                         } else {\n                             return None;\n                         }\n@@ -2440,7 +2467,7 @@ fn specialize_one_pattern<'p, 'tcx>(\n                 // convert a constant slice/array pattern to a list of patterns.\n                 let layout = cx.tcx.layout_of(cx.param_env.and(ty)).ok()?;\n                 let ptr = Pointer::new(AllocId(0), offset);\n-                (0..n)\n+                let pats = (0..n)\n                     .map(|i| {\n                         let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;\n                         let scalar = alloc.read_scalar(&cx.tcx, ptr, layout.size).ok()?;\n@@ -2450,7 +2477,8 @@ fn specialize_one_pattern<'p, 'tcx>(\n                             Pat { ty, span: pat.span, kind: box PatKind::Constant { value } };\n                         Some(&*cx.pattern_arena.alloc(pattern))\n                     })\n-                    .collect()\n+                    .collect::<Option<_>>()?;\n+                Some(Fields::from_vec(pats))\n             } else {\n                 None\n             }\n@@ -2466,7 +2494,7 @@ fn specialize_one_pattern<'p, 'tcx>(\n                         // Constructor splitting should ensure that all intersections we encounter\n                         // are actually inclusions.\n                         assert!(ctor.is_subrange(&pat));\n-                        PatStack::default()\n+                        Fields::empty()\n                     }),\n                     _ => None,\n                 }\n@@ -2477,7 +2505,7 @@ fn specialize_one_pattern<'p, 'tcx>(\n                 // range so intersection actually devolves into being covered\n                 // by the pattern.\n                 constructor_covered_by_range(cx.tcx, cx.param_env, constructor, pat)\n-                    .map(|()| PatStack::default())\n+                    .map(|()| Fields::empty())\n             }\n         }\n \n@@ -2487,7 +2515,7 @@ fn specialize_one_pattern<'p, 'tcx>(\n                 let pat_len = prefix.len() + suffix.len();\n                 if let Some(slice_count) = ctor_wild_subpatterns.len().checked_sub(pat_len) {\n                     if slice_count == 0 || slice.is_some() {\n-                        Some(\n+                        Some(Fields::from_vec(\n                             prefix\n                                 .iter()\n                                 .chain(\n@@ -2498,7 +2526,7 @@ fn specialize_one_pattern<'p, 'tcx>(\n                                         .chain(suffix.iter()),\n                                 )\n                                 .collect(),\n-                        )\n+                        ))\n                     } else {\n                         None\n                     }\n@@ -2516,7 +2544,7 @@ fn specialize_one_pattern<'p, 'tcx>(\n                     suffix,\n                     cx.param_env,\n                 ) {\n-                    Ok(true) => Some(PatStack::default()),\n+                    Ok(true) => Some(Fields::empty()),\n                     Ok(false) => None,\n                     Err(ErrorReported) => None,\n                 }"}]}