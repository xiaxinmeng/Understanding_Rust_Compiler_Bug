{"sha": "8420f8c52e5946f64d93c721d0f673b49ad966f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0MjBmOGM1MmU1OTQ2ZjY0ZDkzYzcyMWQwZjY3M2I0OWFkOTY2Zjc=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-25T13:10:33Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-25T13:10:33Z"}, "message": "Repair zero-variant tags\n\nThe parser no longer parsed them.", "tree": {"sha": "5751c19bc3a00fefcb6999713237cc787c89958f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5751c19bc3a00fefcb6999713237cc787c89958f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8420f8c52e5946f64d93c721d0f673b49ad966f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8420f8c52e5946f64d93c721d0f673b49ad966f7", "html_url": "https://github.com/rust-lang/rust/commit/8420f8c52e5946f64d93c721d0f673b49ad966f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8420f8c52e5946f64d93c721d0f673b49ad966f7/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f0f6c782a881b19a183b368c11a0b74ef10566c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f0f6c782a881b19a183b368c11a0b74ef10566c", "html_url": "https://github.com/rust-lang/rust/commit/2f0f6c782a881b19a183b368c11a0b74ef10566c"}], "stats": {"total": 75, "additions": 24, "deletions": 51}, "files": [{"sha": "8d95a6704211298a17c16c932ad940fb844addc7", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 24, "deletions": 51, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/8420f8c52e5946f64d93c721d0f673b49ad966f7/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8420f8c52e5946f64d93c721d0f673b49ad966f7/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=8420f8c52e5946f64d93c721d0f673b49ad966f7", "patch": "@@ -2047,64 +2047,37 @@ fn parse_item_tag(p: parser, attrs: [ast::attribute]) -> @ast::item {\n                     ast::item_tag([variant], ty_params), attrs);\n     }\n     expect(p, token::LBRACE);\n-    let all_nullary = true;\n-    let have_disr = false;\n-    let done = false;\n-    while !done {\n-        let tok = p.token;\n-        alt tok {\n-          token::IDENT(name, _) {\n-            check_bad_word(p);\n-            let vlo = p.span.lo;\n-            p.bump();\n-            let args: [ast::variant_arg] = [];\n-            let vhi = p.span.hi;\n-            let disr_expr = none;\n-            alt p.token {\n-              token::LPAREN {\n-                all_nullary = false;\n-                let arg_tys = parse_seq(token::LPAREN, token::RPAREN,\n-                                        seq_sep(token::COMMA),\n-                                        {|p| parse_ty(p, false)}, p);\n-                for ty: @ast::ty in arg_tys.node {\n-                    args += [{ty: ty, id: p.get_id()}];\n-                }\n-                vhi = arg_tys.span.hi;\n-              }\n-              token::EQ {\n-                have_disr = true;\n-                p.bump();\n-                disr_expr = some(parse_expr(p));\n-              }\n-              _ {/* empty */ }\n-            }\n+    let all_nullary = true, have_disr = false;\n \n-            alt p.token {\n-              token::COMMA {\n-                p.bump();\n-                if p.token == token::RBRACE { done = true; }\n-              }\n-              token::RBRACE { done = true; }\n-              _ { /* fall through */ }\n+    while p.token != token::RBRACE {\n+        let vlo = p.span.lo;\n+        let ident = parse_value_ident(p);\n+        let args = [], disr_expr = none;\n+        if p.token == token::LPAREN {\n+            all_nullary = false;\n+            let arg_tys = parse_seq(token::LPAREN, token::RPAREN,\n+                                    seq_sep(token::COMMA),\n+                                    {|p| parse_ty(p, false)}, p);\n+            for ty in arg_tys.node {\n+                args += [{ty: ty, id: p.get_id()}];\n             }\n-\n-            p.get_id();\n-            let vr = {name: p.get_str(name), args: args, id: p.get_id(),\n-                      disr_expr: disr_expr};\n-            variants += [spanned(vlo, vhi, vr)];\n-          }\n-          _ {\n-            p.fatal(\"expected name of variant or '}' but found '\" +\n-                        token::to_str(p.reader, tok) + \"'\");\n-          }\n+        } else if eat(p, token::EQ) {\n+            have_disr = true;\n+            disr_expr = some(parse_expr(p));\n         }\n+\n+        let vr = {name: ident, args: args, id: p.get_id(),\n+                  disr_expr: disr_expr};\n+        variants += [spanned(vlo, p.last_span.hi, vr)];\n+\n+        if !eat(p, token::COMMA) { break; }\n     }\n-    let hi = p.span.hi;\n+    expect(p, token::RBRACE);\n     if (have_disr && !all_nullary) {\n         p.fatal(\"discriminator values can only be used with a c-like enum\");\n     }\n-    p.bump();\n-    ret mk_item(p, lo, hi, id, ast::item_tag(variants, ty_params), attrs);\n+    ret mk_item(p, lo, p.last_span.hi, id,\n+                ast::item_tag(variants, ty_params), attrs);\n }\n \n fn parse_fn_ty_proto(p: parser) -> ast::proto {"}]}