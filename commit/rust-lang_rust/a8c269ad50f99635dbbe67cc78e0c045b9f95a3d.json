{"sha": "a8c269ad50f99635dbbe67cc78e0c045b9f95a3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4YzI2OWFkNTBmOTk2MzVkYmJlNjdjYzc4ZTBjMDQ1YjlmOTVhM2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-04T21:40:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-04T21:40:04Z"}, "message": "Auto merge of #7570 - HKalbasi:derivable-impls, r=camsteffen\n\nAdd the `derivable_impls` lint\n\nFix #7550\n\nchangelog: Add new derivable_impls lint. mem_replace_with_default now covers non constructor cases.", "tree": {"sha": "9195b67030d393a1cea7b5fee8d778d5682f9f3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9195b67030d393a1cea7b5fee8d778d5682f9f3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d", "html_url": "https://github.com/rust-lang/rust/commit/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7719279db4ba98ccd5bd2213a173bbf60340ff0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7719279db4ba98ccd5bd2213a173bbf60340ff0", "html_url": "https://github.com/rust-lang/rust/commit/f7719279db4ba98ccd5bd2213a173bbf60340ff0"}, {"sha": "8221f9e7950120c940511ca914c9724cc89b56d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/8221f9e7950120c940511ca914c9724cc89b56d5", "html_url": "https://github.com/rust-lang/rust/commit/8221f9e7950120c940511ca914c9724cc89b56d5"}], "stats": {"total": 574, "additions": 516, "deletions": 58}, "files": [{"sha": "57df49a2723b59a37f5055d0dca9a47eacf69c0b", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=a8c269ad50f99635dbbe67cc78e0c045b9f95a3d", "patch": "@@ -2613,6 +2613,7 @@ Released 2018-09-13\n [`deprecated_cfg_attr`]: https://rust-lang.github.io/rust-clippy/master/index.html#deprecated_cfg_attr\n [`deprecated_semver`]: https://rust-lang.github.io/rust-clippy/master/index.html#deprecated_semver\n [`deref_addrof`]: https://rust-lang.github.io/rust-clippy/master/index.html#deref_addrof\n+[`derivable_impls`]: https://rust-lang.github.io/rust-clippy/master/index.html#derivable_impls\n [`derive_hash_xor_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_hash_xor_eq\n [`derive_ord_xor_partial_ord`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_ord_xor_partial_ord\n [`disallowed_method`]: https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_method"}, {"sha": "b4c4ca016aace000f6e8d9ed438e83f5325b7b51", "filename": "clippy_lints/src/derivable_impls.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d/clippy_lints%2Fsrc%2Fderivable_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d/clippy_lints%2Fsrc%2Fderivable_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderivable_impls.rs?ref=a8c269ad50f99635dbbe67cc78e0c045b9f95a3d", "patch": "@@ -0,0 +1,108 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::{in_macro, is_automatically_derived, is_default_equivalent, remove_blocks};\n+use rustc_hir::{\n+    def::{DefKind, Res},\n+    Body, Expr, ExprKind, Impl, ImplItemKind, Item, ItemKind, Node, QPath,\n+};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::TypeFoldable;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Detects manual `std::default::Default` implementations that are identical to a derived implementation.\n+    ///\n+    /// ### Why is this bad?\n+    /// It is less concise.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// struct Foo {\n+    ///     bar: bool\n+    /// }\n+    ///\n+    /// impl std::default::Default for Foo {\n+    ///     fn default() -> Self {\n+    ///         Self {\n+    ///             bar: false\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be written as:\n+    ///\n+    /// ```rust\n+    /// #[derive(Default)]\n+    /// struct Foo {\n+    ///     bar: bool\n+    /// }\n+    /// ```\n+    ///\n+    /// ### Known problems\n+    /// Derive macros [sometimes use incorrect bounds](https://github.com/rust-lang/rust/issues/26925)\n+    /// in generic types and the user defined `impl` maybe is more generalized or\n+    /// specialized than what derive will produce. This lint can't detect the manual `impl`\n+    /// has exactly equal bounds, and therefore this lint is disabled for types with\n+    /// generic parameters.\n+    ///\n+    pub DERIVABLE_IMPLS,\n+    complexity,\n+    \"manual implementation of the `Default` trait which is equal to a derive\"\n+}\n+\n+declare_lint_pass!(DerivableImpls => [DERIVABLE_IMPLS]);\n+\n+fn is_path_self(e: &Expr<'_>) -> bool {\n+    if let ExprKind::Path(QPath::Resolved(_, p)) = e.kind {\n+        matches!(p.res, Res::SelfCtor(..) | Res::Def(DefKind::Ctor(..), _))\n+    } else {\n+        false\n+    }\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for DerivableImpls {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n+        if_chain! {\n+            if let ItemKind::Impl(Impl {\n+                of_trait: Some(ref trait_ref),\n+                items: [child],\n+                ..\n+            }) = item.kind;\n+            if let attrs = cx.tcx.hir().attrs(item.hir_id());\n+            if !is_automatically_derived(attrs);\n+            if !in_macro(item.span);\n+            if let Some(def_id) = trait_ref.trait_def_id();\n+            if cx.tcx.is_diagnostic_item(sym::Default, def_id);\n+            if let impl_item_hir = child.id.hir_id();\n+            if let Some(Node::ImplItem(impl_item)) = cx.tcx.hir().find(impl_item_hir);\n+            if let ImplItemKind::Fn(_, b) = &impl_item.kind;\n+            if let Body { value: func_expr, .. } = cx.tcx.hir().body(*b);\n+            if let Some(adt_def) = cx.tcx.type_of(item.def_id).ty_adt_def();\n+            then {\n+                if cx.tcx.type_of(item.def_id).definitely_has_param_types_or_consts(cx.tcx) {\n+                    return;\n+                }\n+                let should_emit = match remove_blocks(func_expr).kind {\n+                    ExprKind::Tup(fields) => fields.iter().all(|e| is_default_equivalent(cx, e)),\n+                    ExprKind::Call(callee, args)\n+                        if is_path_self(callee) => args.iter().all(|e| is_default_equivalent(cx, e)),\n+                    ExprKind::Struct(_, fields, _) => fields.iter().all(|ef| is_default_equivalent(cx, ef.expr)),\n+                    _ => false,\n+                };\n+                if should_emit {\n+                    let path_string = cx.tcx.def_path_str(adt_def.did);\n+                    span_lint_and_help(\n+                        cx,\n+                        DERIVABLE_IMPLS,\n+                        item.span,\n+                        \"this `impl` can be derived\",\n+                        None,\n+                        &format!(\"try annotating `{}` with `#[derive(Default)]`\", path_string),\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "88c1ee1ba0e36a500677bec524d4874ebf6fbb73", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=a8c269ad50f99635dbbe67cc78e0c045b9f95a3d", "patch": "@@ -187,6 +187,7 @@ mod dbg_macro;\n mod default;\n mod default_numeric_fallback;\n mod dereference;\n+mod derivable_impls;\n mod derive;\n mod disallowed_method;\n mod disallowed_script_idents;\n@@ -586,6 +587,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         default::FIELD_REASSIGN_WITH_DEFAULT,\n         default_numeric_fallback::DEFAULT_NUMERIC_FALLBACK,\n         dereference::EXPLICIT_DEREF_METHODS,\n+        derivable_impls::DERIVABLE_IMPLS,\n         derive::DERIVE_HASH_XOR_EQ,\n         derive::DERIVE_ORD_XOR_PARTIAL_ORD,\n         derive::EXPL_IMPL_CLONE_ON_COPY,\n@@ -1204,6 +1206,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(copies::IFS_SAME_COND),\n         LintId::of(copies::IF_SAME_THEN_ELSE),\n         LintId::of(default::FIELD_REASSIGN_WITH_DEFAULT),\n+        LintId::of(derivable_impls::DERIVABLE_IMPLS),\n         LintId::of(derive::DERIVE_HASH_XOR_EQ),\n         LintId::of(derive::DERIVE_ORD_XOR_PARTIAL_ORD),\n         LintId::of(doc::MISSING_SAFETY_DOC),\n@@ -1589,6 +1592,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(booleans::NONMINIMAL_BOOL),\n         LintId::of(casts::CHAR_LIT_AS_U8),\n         LintId::of(casts::UNNECESSARY_CAST),\n+        LintId::of(derivable_impls::DERIVABLE_IMPLS),\n         LintId::of(double_comparison::DOUBLE_COMPARISONS),\n         LintId::of(double_parens::DOUBLE_PARENS),\n         LintId::of(duration_subsec::DURATION_SUBSEC),\n@@ -1937,6 +1941,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(panic_unimplemented::PanicUnimplemented));\n     store.register_late_pass(|| Box::new(strings::StringLitAsBytes));\n     store.register_late_pass(|| Box::new(derive::Derive));\n+    store.register_late_pass(|| Box::new(derivable_impls::DerivableImpls));\n     store.register_late_pass(|| Box::new(get_last_with_len::GetLastWithLen));\n     store.register_late_pass(|| Box::new(drop_forget_ref::DropForgetRef));\n     store.register_late_pass(|| Box::new(empty_enum::EmptyEnum));"}, {"sha": "1e6057a8fe969eb177c0d3252175799bf3ba8b73", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 29, "deletions": 56, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=a8c269ad50f99635dbbe67cc78e0c045b9f95a3d", "patch": "@@ -1,9 +1,9 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::{snippet, snippet_with_applicability};\n-use clippy_utils::{in_macro, is_diag_trait_item, is_lang_ctor, match_def_path, meets_msrv, msrvs, paths};\n+use clippy_utils::ty::is_non_aggregate_primitive_type;\n+use clippy_utils::{in_macro, is_default_equivalent, is_lang_ctor, match_def_path, meets_msrv, msrvs, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::def_id::DefId;\n use rustc_hir::LangItem::OptionNone;\n use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability, QPath};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -194,64 +194,37 @@ fn check_replace_with_uninit(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'\n     }\n }\n \n-/// Returns true if the `def_id` associated with the `path` is recognized as a \"default-equivalent\"\n-/// constructor from the std library\n-fn is_default_equivalent_ctor(cx: &LateContext<'_>, def_id: DefId, path: &QPath<'_>) -> bool {\n-    let std_types_symbols = &[\n-        sym::string_type,\n-        sym::vec_type,\n-        sym::vecdeque_type,\n-        sym::LinkedList,\n-        sym::hashmap_type,\n-        sym::BTreeMap,\n-        sym::hashset_type,\n-        sym::BTreeSet,\n-        sym::BinaryHeap,\n-    ];\n-\n-    if let QPath::TypeRelative(_, method) = path {\n-        if method.ident.name == sym::new {\n-            if let Some(impl_did) = cx.tcx.impl_of_method(def_id) {\n-                if let Some(adt) = cx.tcx.type_of(impl_did).ty_adt_def() {\n-                    return std_types_symbols\n-                        .iter()\n-                        .any(|&symbol| cx.tcx.is_diagnostic_item(symbol, adt.did));\n-                }\n-            }\n+fn check_replace_with_default(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n+    // disable lint for primitives\n+    let expr_type = cx.typeck_results().expr_ty_adjusted(src);\n+    if is_non_aggregate_primitive_type(expr_type) {\n+        return;\n+    }\n+    // disable lint for Option since it is covered in another lint\n+    if let ExprKind::Path(q) = &src.kind {\n+        if is_lang_ctor(cx, q, OptionNone) {\n+            return;\n         }\n     }\n-    false\n-}\n+    if is_default_equivalent(cx, src) && !in_external_macro(cx.tcx.sess, expr_span) {\n+        span_lint_and_then(\n+            cx,\n+            MEM_REPLACE_WITH_DEFAULT,\n+            expr_span,\n+            \"replacing a value of type `T` with `T::default()` is better expressed using `std::mem::take`\",\n+            |diag| {\n+                if !in_macro(expr_span) {\n+                    let suggestion = format!(\"std::mem::take({})\", snippet(cx, dest.span, \"\"));\n \n-fn check_replace_with_default(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n-    if_chain! {\n-        if let ExprKind::Call(repl_func, _) = src.kind;\n-        if !in_external_macro(cx.tcx.sess, expr_span);\n-        if let ExprKind::Path(ref repl_func_qpath) = repl_func.kind;\n-        if let Some(repl_def_id) = cx.qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n-        if is_diag_trait_item(cx, repl_def_id, sym::Default)\n-            || is_default_equivalent_ctor(cx, repl_def_id, repl_func_qpath);\n-\n-        then {\n-            span_lint_and_then(\n-                cx,\n-                MEM_REPLACE_WITH_DEFAULT,\n-                expr_span,\n-                \"replacing a value of type `T` with `T::default()` is better expressed using `std::mem::take`\",\n-                |diag| {\n-                    if !in_macro(expr_span) {\n-                        let suggestion = format!(\"std::mem::take({})\", snippet(cx, dest.span, \"\"));\n-\n-                        diag.span_suggestion(\n-                            expr_span,\n-                            \"consider using\",\n-                            suggestion,\n-                            Applicability::MachineApplicable\n-                        );\n-                    }\n+                    diag.span_suggestion(\n+                        expr_span,\n+                        \"consider using\",\n+                        suggestion,\n+                        Applicability::MachineApplicable,\n+                    );\n                 }\n-            );\n-        }\n+            },\n+        );\n     }\n }\n "}, {"sha": "757485d19d25ad6c01fa9cc9b93e80d129cf54de", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=a8c269ad50f99635dbbe67cc78e0c045b9f95a3d", "patch": "@@ -70,7 +70,7 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::{HirIdMap, HirIdSet};\n use rustc_hir::intravisit::{self, walk_expr, ErasedMap, FnKind, NestedVisitorMap, Visitor};\n-use rustc_hir::LangItem::{ResultErr, ResultOk};\n+use rustc_hir::LangItem::{OptionNone, ResultErr, ResultOk};\n use rustc_hir::{\n     def, Arm, BindingAnnotation, Block, Body, Constness, Destination, Expr, ExprKind, FnDecl, GenericArgs, HirId, Impl,\n     ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local, MatchSource, Mutability, Node, Param, Pat,\n@@ -644,6 +644,65 @@ pub fn can_mut_borrow_both(cx: &LateContext<'_>, e1: &Expr<'_>, e2: &Expr<'_>) -\n     false\n }\n \n+/// Returns true if the `def_id` associated with the `path` is recognized as a \"default-equivalent\"\n+/// constructor from the std library\n+fn is_default_equivalent_ctor(cx: &LateContext<'_>, def_id: DefId, path: &QPath<'_>) -> bool {\n+    let std_types_symbols = &[\n+        sym::string_type,\n+        sym::vec_type,\n+        sym::vecdeque_type,\n+        sym::LinkedList,\n+        sym::hashmap_type,\n+        sym::BTreeMap,\n+        sym::hashset_type,\n+        sym::BTreeSet,\n+        sym::BinaryHeap,\n+    ];\n+\n+    if let QPath::TypeRelative(_, method) = path {\n+        if method.ident.name == sym::new {\n+            if let Some(impl_did) = cx.tcx.impl_of_method(def_id) {\n+                if let Some(adt) = cx.tcx.type_of(impl_did).ty_adt_def() {\n+                    return std_types_symbols\n+                        .iter()\n+                        .any(|&symbol| cx.tcx.is_diagnostic_item(symbol, adt.did));\n+                }\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+/// Returns true if the expr is equal to `Default::default()` of it's type when evaluated.\n+/// It doesn't cover all cases, for example indirect function calls (some of std\n+/// functions are supported) but it is the best we have.\n+pub fn is_default_equivalent(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n+    match &e.kind {\n+        ExprKind::Lit(lit) => match lit.node {\n+            LitKind::Bool(false) | LitKind::Int(0, _) => true,\n+            LitKind::Str(s, _) => s.is_empty(),\n+            _ => false,\n+        },\n+        ExprKind::Tup(items) | ExprKind::Array(items) => items.iter().all(|x| is_default_equivalent(cx, x)),\n+        ExprKind::Repeat(x, _) => is_default_equivalent(cx, x),\n+        ExprKind::Call(repl_func, _) => if_chain! {\n+            if let ExprKind::Path(ref repl_func_qpath) = repl_func.kind;\n+            if let Some(repl_def_id) = cx.qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n+            if is_diag_trait_item(cx, repl_def_id, sym::Default)\n+                || is_default_equivalent_ctor(cx, repl_def_id, repl_func_qpath);\n+            then {\n+                true\n+            }\n+            else {\n+                false\n+            }\n+        },\n+        ExprKind::Path(qpath) => is_lang_ctor(cx, qpath, OptionNone),\n+        ExprKind::AddrOf(rustc_hir::BorrowKind::Ref, _, expr) => matches!(expr.kind, ExprKind::Array([])),\n+        _ => false,\n+    }\n+}\n+\n /// Checks if the top level expression can be moved into a closure as is.\n /// Currently checks for:\n /// * Break/Continue outside the given loop HIR ids."}, {"sha": "d6f9ebe89bc7fe44136d09231399edcde1f9b73a", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=a8c269ad50f99635dbbe67cc78e0c045b9f95a3d", "patch": "@@ -224,6 +224,13 @@ fn is_normalizable_helper<'tcx>(\n     result\n }\n \n+/// Returns true iff the given type is a non aggregate primitive (a bool or char, any integer or\n+/// floating-point number type). For checking aggregation of primitive types (e.g. tuples and slices\n+/// of primitive type) see `is_recursively_primitive_type`\n+pub fn is_non_aggregate_primitive_type(ty: Ty<'_>) -> bool {\n+    matches!(ty.kind(), ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_))\n+}\n+\n /// Returns true iff the given type is a primitive (a bool or char, any integer or floating-point\n /// number type, a str, or an array, slice, or tuple of those types).\n pub fn is_recursively_primitive_type(ty: Ty<'_>) -> bool {"}, {"sha": "336a743de726bf009387beaf5982b7a5c5a37285", "filename": "tests/ui/derivable_impls.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d/tests%2Fui%2Fderivable_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d/tests%2Fui%2Fderivable_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderivable_impls.rs?ref=a8c269ad50f99635dbbe67cc78e0c045b9f95a3d", "patch": "@@ -0,0 +1,170 @@\n+use std::collections::HashMap;\n+\n+struct FooDefault<'a> {\n+    a: bool,\n+    b: i32,\n+    c: u64,\n+    d: Vec<i32>,\n+    e: FooND1,\n+    f: FooND2,\n+    g: HashMap<i32, i32>,\n+    h: (i32, Vec<i32>),\n+    i: [Vec<i32>; 3],\n+    j: [i32; 5],\n+    k: Option<i32>,\n+    l: &'a [i32],\n+}\n+\n+impl std::default::Default for FooDefault<'_> {\n+    fn default() -> Self {\n+        Self {\n+            a: false,\n+            b: 0,\n+            c: 0u64,\n+            d: vec![],\n+            e: Default::default(),\n+            f: FooND2::default(),\n+            g: HashMap::new(),\n+            h: (0, vec![]),\n+            i: [vec![], vec![], vec![]],\n+            j: [0; 5],\n+            k: None,\n+            l: &[],\n+        }\n+    }\n+}\n+\n+struct TupleDefault(bool, i32, u64);\n+\n+impl std::default::Default for TupleDefault {\n+    fn default() -> Self {\n+        Self(false, 0, 0u64)\n+    }\n+}\n+\n+struct FooND1 {\n+    a: bool,\n+}\n+\n+impl std::default::Default for FooND1 {\n+    fn default() -> Self {\n+        Self { a: true }\n+    }\n+}\n+\n+struct FooND2 {\n+    a: i32,\n+}\n+\n+impl std::default::Default for FooND2 {\n+    fn default() -> Self {\n+        Self { a: 5 }\n+    }\n+}\n+\n+struct FooNDNew {\n+    a: bool,\n+}\n+\n+impl FooNDNew {\n+    fn new() -> Self {\n+        Self { a: true }\n+    }\n+}\n+\n+impl Default for FooNDNew {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+struct FooNDVec(Vec<i32>);\n+\n+impl Default for FooNDVec {\n+    fn default() -> Self {\n+        Self(vec![5, 12])\n+    }\n+}\n+\n+struct StrDefault<'a>(&'a str);\n+\n+impl Default for StrDefault<'_> {\n+    fn default() -> Self {\n+        Self(\"\")\n+    }\n+}\n+\n+#[derive(Default)]\n+struct AlreadyDerived(i32, bool);\n+\n+macro_rules! mac {\n+    () => {\n+        0\n+    };\n+    ($e:expr) => {\n+        struct X(u32);\n+        impl Default for X {\n+            fn default() -> Self {\n+                Self($e)\n+            }\n+        }\n+    };\n+}\n+\n+mac!(0);\n+\n+struct Y(u32);\n+impl Default for Y {\n+    fn default() -> Self {\n+        Self(mac!())\n+    }\n+}\n+\n+struct RustIssue26925<T> {\n+    a: Option<T>,\n+}\n+\n+// We should watch out for cases where a manual impl is needed because a\n+// derive adds different type bounds (https://github.com/rust-lang/rust/issues/26925).\n+// For example, a struct with Option<T> does not require T: Default, but a derive adds\n+// that type bound anyways. So until #26925 get fixed we should disable lint\n+// for the following case\n+impl<T> Default for RustIssue26925<T> {\n+    fn default() -> Self {\n+        Self { a: None }\n+    }\n+}\n+\n+struct SpecializedImpl<A, B> {\n+    a: A,\n+    b: B,\n+}\n+\n+impl<T: Default> Default for SpecializedImpl<T, T> {\n+    fn default() -> Self {\n+        Self {\n+            a: T::default(),\n+            b: T::default(),\n+        }\n+    }\n+}\n+\n+struct WithoutSelfCurly {\n+    a: bool,\n+}\n+\n+impl Default for WithoutSelfCurly {\n+    fn default() -> Self {\n+        WithoutSelfCurly { a: false }\n+    }\n+}\n+\n+struct WithoutSelfParan(bool);\n+\n+impl Default for WithoutSelfParan {\n+    fn default() -> Self {\n+        WithoutSelfParan(false)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "4ed64fade026d1379667ccbff05bb1b7c20038fe", "filename": "tests/ui/derivable_impls.stderr", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d/tests%2Fui%2Fderivable_impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d/tests%2Fui%2Fderivable_impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderivable_impls.stderr?ref=a8c269ad50f99635dbbe67cc78e0c045b9f95a3d", "patch": "@@ -0,0 +1,77 @@\n+error: this `impl` can be derived\n+  --> $DIR/derivable_impls.rs:18:1\n+   |\n+LL | / impl std::default::Default for FooDefault<'_> {\n+LL | |     fn default() -> Self {\n+LL | |         Self {\n+LL | |             a: false,\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+   = note: `-D clippy::derivable-impls` implied by `-D warnings`\n+   = help: try annotating `FooDefault` with `#[derive(Default)]`\n+\n+error: this `impl` can be derived\n+  --> $DIR/derivable_impls.rs:39:1\n+   |\n+LL | / impl std::default::Default for TupleDefault {\n+LL | |     fn default() -> Self {\n+LL | |         Self(false, 0, 0u64)\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+   = help: try annotating `TupleDefault` with `#[derive(Default)]`\n+\n+error: this `impl` can be derived\n+  --> $DIR/derivable_impls.rs:91:1\n+   |\n+LL | / impl Default for StrDefault<'_> {\n+LL | |     fn default() -> Self {\n+LL | |         Self(\"\")\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+   = help: try annotating `StrDefault` with `#[derive(Default)]`\n+\n+error: this `impl` can be derived\n+  --> $DIR/derivable_impls.rs:117:1\n+   |\n+LL | / impl Default for Y {\n+LL | |     fn default() -> Self {\n+LL | |         Self(mac!())\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+   = help: try annotating `Y` with `#[derive(Default)]`\n+\n+error: this `impl` can be derived\n+  --> $DIR/derivable_impls.rs:156:1\n+   |\n+LL | / impl Default for WithoutSelfCurly {\n+LL | |     fn default() -> Self {\n+LL | |         WithoutSelfCurly { a: false }\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+   = help: try annotating `WithoutSelfCurly` with `#[derive(Default)]`\n+\n+error: this `impl` can be derived\n+  --> $DIR/derivable_impls.rs:164:1\n+   |\n+LL | / impl Default for WithoutSelfParan {\n+LL | |     fn default() -> Self {\n+LL | |         WithoutSelfParan(false)\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+   = help: try annotating `WithoutSelfParan` with `#[derive(Default)]`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "b609ba659467f527f4bcc0b54120c75d5bf66791", "filename": "tests/ui/mem_replace.fixed", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d/tests%2Fui%2Fmem_replace.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d/tests%2Fui%2Fmem_replace.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmem_replace.fixed?ref=a8c269ad50f99635dbbe67cc78e0c045b9f95a3d", "patch": "@@ -51,9 +51,29 @@ fn replace_with_default() {\n \n     let mut binary_heap: BinaryHeap<i32> = BinaryHeap::new();\n     let _ = std::mem::take(&mut binary_heap);\n+\n+    let mut tuple = (vec![1, 2], BinaryHeap::<i32>::new());\n+    let _ = std::mem::take(&mut tuple);\n+\n+    let mut refstr = \"hello\";\n+    let _ = std::mem::take(&mut refstr);\n+\n+    let mut slice: &[i32] = &[1, 2, 3];\n+    let _ = std::mem::take(&mut slice);\n+}\n+\n+// lint is disabled for primitives because in this case `take`\n+// has no clear benefit over `replace` and sometimes is harder to read\n+fn dont_lint_primitive() {\n+    let mut pbool = true;\n+    let _ = std::mem::replace(&mut pbool, false);\n+\n+    let mut pint = 5;\n+    let _ = std::mem::replace(&mut pint, 0);\n }\n \n fn main() {\n     replace_option_with_none();\n     replace_with_default();\n+    dont_lint_primitive();\n }"}, {"sha": "93f6dcdec83b96b3a8ad49ce9d8c043e24bb71e6", "filename": "tests/ui/mem_replace.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d/tests%2Fui%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d/tests%2Fui%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmem_replace.rs?ref=a8c269ad50f99635dbbe67cc78e0c045b9f95a3d", "patch": "@@ -51,9 +51,29 @@ fn replace_with_default() {\n \n     let mut binary_heap: BinaryHeap<i32> = BinaryHeap::new();\n     let _ = std::mem::replace(&mut binary_heap, BinaryHeap::new());\n+\n+    let mut tuple = (vec![1, 2], BinaryHeap::<i32>::new());\n+    let _ = std::mem::replace(&mut tuple, (vec![], BinaryHeap::new()));\n+\n+    let mut refstr = \"hello\";\n+    let _ = std::mem::replace(&mut refstr, \"\");\n+\n+    let mut slice: &[i32] = &[1, 2, 3];\n+    let _ = std::mem::replace(&mut slice, &[]);\n+}\n+\n+// lint is disabled for primitives because in this case `take`\n+// has no clear benefit over `replace` and sometimes is harder to read\n+fn dont_lint_primitive() {\n+    let mut pbool = true;\n+    let _ = std::mem::replace(&mut pbool, false);\n+\n+    let mut pint = 5;\n+    let _ = std::mem::replace(&mut pint, 0);\n }\n \n fn main() {\n     replace_option_with_none();\n     replace_with_default();\n+    dont_lint_primitive();\n }"}, {"sha": "90dc6c95f858295cef40d0fc6f27fa6b60fa7e85", "filename": "tests/ui/mem_replace.stderr", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d/tests%2Fui%2Fmem_replace.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8c269ad50f99635dbbe67cc78e0c045b9f95a3d/tests%2Fui%2Fmem_replace.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmem_replace.stderr?ref=a8c269ad50f99635dbbe67cc78e0c045b9f95a3d", "patch": "@@ -98,5 +98,23 @@ error: replacing a value of type `T` with `T::default()` is better expressed usi\n LL |     let _ = std::mem::replace(&mut binary_heap, BinaryHeap::new());\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `std::mem::take(&mut binary_heap)`\n \n-error: aborting due to 16 previous errors\n+error: replacing a value of type `T` with `T::default()` is better expressed using `std::mem::take`\n+  --> $DIR/mem_replace.rs:56:13\n+   |\n+LL |     let _ = std::mem::replace(&mut tuple, (vec![], BinaryHeap::new()));\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `std::mem::take(&mut tuple)`\n+\n+error: replacing a value of type `T` with `T::default()` is better expressed using `std::mem::take`\n+  --> $DIR/mem_replace.rs:59:13\n+   |\n+LL |     let _ = std::mem::replace(&mut refstr, \"\");\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `std::mem::take(&mut refstr)`\n+\n+error: replacing a value of type `T` with `T::default()` is better expressed using `std::mem::take`\n+  --> $DIR/mem_replace.rs:62:13\n+   |\n+LL |     let _ = std::mem::replace(&mut slice, &[]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `std::mem::take(&mut slice)`\n+\n+error: aborting due to 19 previous errors\n "}]}