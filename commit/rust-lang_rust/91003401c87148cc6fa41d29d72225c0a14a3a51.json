{"sha": "91003401c87148cc6fa41d29d72225c0a14a3a51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxMDAzNDAxYzg3MTQ4Y2M2ZmE0MWQyOWQ3MjIyNWMwYTE0YTNhNTE=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-04-10T18:13:31Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-05-03T18:36:11Z"}, "message": "Use new liveness analysis during generator transform", "tree": {"sha": "03f4154a217b5019d329d94064ba36f99493c369", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03f4154a217b5019d329d94064ba36f99493c369"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91003401c87148cc6fa41d29d72225c0a14a3a51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91003401c87148cc6fa41d29d72225c0a14a3a51", "html_url": "https://github.com/rust-lang/rust/commit/91003401c87148cc6fa41d29d72225c0a14a3a51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91003401c87148cc6fa41d29d72225c0a14a3a51/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c34ec6848b1e09624a521255d1ce69f9d62555e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c34ec6848b1e09624a521255d1ce69f9d62555e", "html_url": "https://github.com/rust-lang/rust/commit/4c34ec6848b1e09624a521255d1ce69f9d62555e"}], "stats": {"total": 46, "additions": 24, "deletions": 22}, "files": [{"sha": "25804c2a62cfed7cdb9b8af7065584dc26a451aa", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/91003401c87148cc6fa41d29d72225c0a14a3a51/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91003401c87148cc6fa41d29d72225c0a14a3a51/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=91003401c87148cc6fa41d29d72225c0a14a3a51", "patch": "@@ -50,12 +50,13 @@\n //! Otherwise it drops all the values in scope at the last suspension point.\n \n use crate::dataflow::{self, Analysis};\n-use crate::dataflow::{MaybeBorrowedLocals, MaybeRequiresStorage, MaybeStorageLive};\n+use crate::dataflow::{\n+    MaybeBorrowedLocals, MaybeLiveLocals, MaybeRequiresStorage, MaybeStorageLive,\n+};\n use crate::transform::no_landing_pads::no_landing_pads;\n use crate::transform::simplify;\n use crate::transform::{MirPass, MirSource};\n use crate::util::dump_mir;\n-use crate::util::liveness;\n use crate::util::storage;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n@@ -195,7 +196,7 @@ struct SuspensionPoint<'tcx> {\n     /// Which block to jump to if the generator is dropped in this state.\n     drop: Option<BasicBlock>,\n     /// Set of locals that have live storage while at this suspension point.\n-    storage_liveness: liveness::LiveVarSet,\n+    storage_liveness: BitSet<Local>,\n }\n \n struct TransformVisitor<'tcx> {\n@@ -211,7 +212,7 @@ struct TransformVisitor<'tcx> {\n     remap: FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n \n     // A map from a suspension point in a block to the locals which have live storage at that point\n-    storage_liveness: IndexVec<BasicBlock, Option<liveness::LiveVarSet>>,\n+    storage_liveness: IndexVec<BasicBlock, Option<BitSet<Local>>>,\n \n     // A list of suspension points, generated during the transform\n     suspension_points: Vec<SuspensionPoint<'tcx>>,\n@@ -418,7 +419,7 @@ struct LivenessInfo {\n     /// GeneratorSavedLocal is indexed in terms of the elements in this set;\n     /// i.e. GeneratorSavedLocal::new(1) corresponds to the second local\n     /// included in this set.\n-    live_locals: liveness::LiveVarSet,\n+    live_locals: BitSet<Local>,\n \n     /// The set of saved locals live at each suspension point.\n     live_locals_at_suspension_points: Vec<BitSet<GeneratorSavedLocal>>,\n@@ -430,7 +431,7 @@ struct LivenessInfo {\n \n     /// For every suspending block, the locals which are storage-live across\n     /// that suspension point.\n-    storage_liveness: IndexVec<BasicBlock, Option<liveness::LiveVarSet>>,\n+    storage_liveness: IndexVec<BasicBlock, Option<BitSet<Local>>>,\n }\n \n fn locals_live_across_suspend_points(\n@@ -467,18 +468,22 @@ fn locals_live_across_suspend_points(\n         dataflow::ResultsCursor::new(body_ref, &requires_storage_results);\n \n     // Calculate the liveness of MIR locals ignoring borrows.\n-    let mut liveness = liveness::liveness_of_locals(body);\n-    liveness::dump_mir(tcx, \"generator_liveness\", source, body_ref, &liveness);\n+    let mut liveness = MaybeLiveLocals\n+        .into_engine(tcx, body_ref, def_id)\n+        .iterate_to_fixpoint()\n+        .into_results_cursor(body_ref);\n \n     let mut storage_liveness_map = IndexVec::from_elem(None, body.basic_blocks());\n     let mut live_locals_at_suspension_points = Vec::new();\n-    let mut live_locals_at_any_suspension_point =\n-        liveness::LiveVarSet::new_empty(body.local_decls.len());\n+    let mut live_locals_at_any_suspension_point = BitSet::new_empty(body.local_decls.len());\n \n     for (block, data) in body.basic_blocks().iter_enumerated() {\n         if let TerminatorKind::Yield { .. } = data.terminator().kind {\n             let loc = Location { block, statement_index: data.statements.len() };\n \n+            liveness.seek_to_block_end(block);\n+            let mut live_locals = liveness.get().clone();\n+\n             if !movable {\n                 // The `liveness` variable contains the liveness of MIR locals ignoring borrows.\n                 // This is correct for movable generators since borrows cannot live across\n@@ -491,22 +496,19 @@ fn locals_live_across_suspend_points(\n                 // forever. Note that the final liveness is still bounded by the storage liveness\n                 // of the local, which happens using the `intersect` operation below.\n                 borrowed_locals_cursor.seek_before_primary_effect(loc);\n-                liveness.outs[block].union(borrowed_locals_cursor.get());\n+                live_locals.union(borrowed_locals_cursor.get());\n             }\n \n             // Store the storage liveness for later use so we can restore the state\n             // after a suspension point\n             storage_live.seek_before_primary_effect(loc);\n             storage_liveness_map[block] = Some(storage_live.get().clone());\n \n-            requires_storage_cursor.seek_before_primary_effect(loc);\n-            let storage_required = requires_storage_cursor.get().clone();\n-\n             // Locals live are live at this point only if they are used across\n             // suspension points (the `liveness` variable)\n             // and their storage is required (the `storage_required` variable)\n-            let mut live_locals = storage_required;\n-            live_locals.intersect(&liveness.outs[block]);\n+            requires_storage_cursor.seek_before_primary_effect(loc);\n+            live_locals.intersect(requires_storage_cursor.get());\n \n             // The generator argument is ignored.\n             live_locals.remove(SELF_ARG);\n@@ -551,7 +553,7 @@ fn locals_live_across_suspend_points(\n /// `[0, 1, 2]`. Thus, if `input = [3, 5]` we would return `[1, 2]`.\n fn renumber_bitset(\n     input: &BitSet<Local>,\n-    stored_locals: &liveness::LiveVarSet,\n+    stored_locals: &BitSet<Local>,\n ) -> BitSet<GeneratorSavedLocal> {\n     assert!(stored_locals.superset(&input), \"{:?} not a superset of {:?}\", stored_locals, input);\n     let mut out = BitSet::new_empty(stored_locals.count());\n@@ -571,7 +573,7 @@ fn renumber_bitset(\n /// computation; see `GeneratorLayout` for more.\n fn compute_storage_conflicts(\n     body: &'mir Body<'tcx>,\n-    stored_locals: &liveness::LiveVarSet,\n+    stored_locals: &BitSet<Local>,\n     always_live_locals: storage::AlwaysLiveLocals,\n     requires_storage: dataflow::Results<'tcx, MaybeRequiresStorage<'mir, 'tcx>>,\n ) -> BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal> {\n@@ -626,7 +628,7 @@ fn compute_storage_conflicts(\n \n struct StorageConflictVisitor<'mir, 'tcx, 's> {\n     body: &'mir Body<'tcx>,\n-    stored_locals: &'s liveness::LiveVarSet,\n+    stored_locals: &'s BitSet<Local>,\n     // FIXME(tmandry): Consider using sparse bitsets here once we have good\n     // benchmarks for generators.\n     local_conflicts: BitMatrix<Local, Local>,\n@@ -635,7 +637,7 @@ struct StorageConflictVisitor<'mir, 'tcx, 's> {\n impl dataflow::ResultsVisitor<'mir, 'tcx> for StorageConflictVisitor<'mir, 'tcx, '_> {\n     type FlowState = BitSet<Local>;\n \n-    fn visit_statement(\n+    fn visit_statement_before_primary_effect(\n         &mut self,\n         state: &Self::FlowState,\n         _statement: &'mir Statement<'tcx>,\n@@ -644,7 +646,7 @@ impl dataflow::ResultsVisitor<'mir, 'tcx> for StorageConflictVisitor<'mir, 'tcx,\n         self.apply_state(state, loc);\n     }\n \n-    fn visit_terminator(\n+    fn visit_terminator_before_primary_effect(\n         &mut self,\n         state: &Self::FlowState,\n         _terminator: &'mir Terminator<'tcx>,\n@@ -685,7 +687,7 @@ fn compute_layout<'tcx>(\n ) -> (\n     FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n     GeneratorLayout<'tcx>,\n-    IndexVec<BasicBlock, Option<liveness::LiveVarSet>>,\n+    IndexVec<BasicBlock, Option<BitSet<Local>>>,\n ) {\n     // Use a liveness analysis to compute locals which are live across a suspension point\n     let LivenessInfo {"}]}