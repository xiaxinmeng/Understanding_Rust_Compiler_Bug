{"sha": "498eeb72f590e518e19746b346be53713689e207", "node_id": "C_kwDOAAsO6NoAKDQ5OGVlYjcyZjU5MGU1MThlMTk3NDZiMzQ2YmU1MzcxMzY4OWUyMDc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-31T17:36:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-31T17:36:11Z"}, "message": "Auto merge of #93348 - spastorino:fix-perf-overlap-mode2, r=nikomatsakis\n\n Move overlap_mode into trait level attribute\n\nr? `@nikomatsakis`\n\nShould fix some performance regressions noted on https://github.com/rust-lang/rust/pull/93175", "tree": {"sha": "2c2e49bd9abfcfa662cfb75ea9cd2428885657d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c2e49bd9abfcfa662cfb75ea9cd2428885657d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/498eeb72f590e518e19746b346be53713689e207", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/498eeb72f590e518e19746b346be53713689e207", "html_url": "https://github.com/rust-lang/rust/commit/498eeb72f590e518e19746b346be53713689e207", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/498eeb72f590e518e19746b346be53713689e207/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24b8bb13bff98bb747cd403b86596af43aceee78", "url": "https://api.github.com/repos/rust-lang/rust/commits/24b8bb13bff98bb747cd403b86596af43aceee78", "html_url": "https://github.com/rust-lang/rust/commit/24b8bb13bff98bb747cd403b86596af43aceee78"}, {"sha": "0decf14ef1e63e7e7b70805cdf3d03b42d2f457c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0decf14ef1e63e7e7b70805cdf3d03b42d2f457c", "html_url": "https://github.com/rust-lang/rust/commit/0decf14ef1e63e7e7b70805cdf3d03b42d2f457c"}], "stats": {"total": 186, "additions": 111, "deletions": 75}, "files": [{"sha": "bfe2459dc8dc1cf259b2fd72243cbd5112adc7ca", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/498eeb72f590e518e19746b346be53713689e207/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498eeb72f590e518e19746b346be53713689e207/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=498eeb72f590e518e19746b346be53713689e207", "patch": "@@ -161,6 +161,9 @@ declare_features! (\n     (active, staged_api, \"1.0.0\", None, None),\n     /// Added for testing E0705; perma-unstable.\n     (active, test_2018_feature, \"1.31.0\", None, Some(Edition::Edition2018)),\n+    /// Use for stable + negative coherence and strict coherence depending on trait's\n+    /// rustc_strict_coherence value.\n+    (active, with_negative_coherence, \"1.60.0\", None, None),\n     // !!!!    !!!!    !!!!    !!!!   !!!!    !!!!    !!!!    !!!!    !!!!    !!!!    !!!!\n     // Features are listed in alphabetical order. Tidy will fail if you don't keep it this way.\n     // !!!!    !!!!    !!!!    !!!!   !!!!    !!!!    !!!!    !!!!    !!!!    !!!!    !!!!"}, {"sha": "25601ffb37d4cf162df23be52383ce6831a9ba00", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/498eeb72f590e518e19746b346be53713689e207/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498eeb72f590e518e19746b346be53713689e207/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=498eeb72f590e518e19746b346be53713689e207", "patch": "@@ -697,7 +697,6 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     rustc_attr!(TEST, rustc_capture_analysis, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_insignificant_dtor, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_strict_coherence, Normal, template!(Word), WarnFollowing),\n-    rustc_attr!(TEST, rustc_with_negative_coherence, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_variance, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_layout, Normal, template!(List: \"field1, field2, ...\"), WarnFollowing),\n     rustc_attr!(TEST, rustc_regions, Normal, template!(Word), WarnFollowing),"}, {"sha": "03a6daaf8aa4f6996c76e5f819b233ddada98e8e", "filename": "compiler/rustc_middle/src/traits/specialization_graph.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/498eeb72f590e518e19746b346be53713689e207/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498eeb72f590e518e19746b346be53713689e207/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs?ref=498eeb72f590e518e19746b346be53713689e207", "patch": "@@ -4,6 +4,7 @@ use crate::ty::{self, TyCtxt};\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::ErrorReported;\n use rustc_hir::def_id::{DefId, DefIdMap};\n+use rustc_span::symbol::sym;\n \n /// A per-trait graph of impls in specialization order. At the moment, this\n /// graph forms a tree rooted with the trait itself, with all other nodes\n@@ -45,6 +46,41 @@ impl Graph {\n     }\n }\n \n+/// What kind of overlap check are we doing -- this exists just for testing and feature-gating\n+/// purposes.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, HashStable, Debug, TyEncodable, TyDecodable)]\n+pub enum OverlapMode {\n+    /// The 1.0 rules (either types fail to unify, or where clauses are not implemented for crate-local types)\n+    Stable,\n+    /// Feature-gated test: Stable, *or* there is an explicit negative impl that rules out one of the where-clauses.\n+    WithNegative,\n+    /// Just check for negative impls, not for \"where clause not implemented\": used for testing.\n+    Strict,\n+}\n+\n+impl OverlapMode {\n+    pub fn get<'tcx>(tcx: TyCtxt<'tcx>, trait_id: DefId) -> OverlapMode {\n+        let with_negative_coherence = tcx.features().with_negative_coherence;\n+        let strict_coherence = tcx.has_attr(trait_id, sym::rustc_strict_coherence);\n+\n+        if with_negative_coherence {\n+            if strict_coherence { OverlapMode::Strict } else { OverlapMode::WithNegative }\n+        } else if strict_coherence {\n+            bug!(\"To use strict_coherence you need to set with_negative_coherence feature flag\");\n+        } else {\n+            OverlapMode::Stable\n+        }\n+    }\n+\n+    pub fn use_negative_impl(&self) -> bool {\n+        *self == OverlapMode::Strict || *self == OverlapMode::WithNegative\n+    }\n+\n+    pub fn use_implicit_negative(&self) -> bool {\n+        *self == OverlapMode::Stable || *self == OverlapMode::WithNegative\n+    }\n+}\n+\n /// Children of a given impl, grouped into blanket/non-blanket varieties as is\n /// done in `TraitDef`.\n #[derive(Default, TyEncodable, TyDecodable, Debug, HashStable)]"}, {"sha": "198391cbe9cf7969f830597679f82d2014bdb9cc", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/498eeb72f590e518e19746b346be53713689e207/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498eeb72f590e518e19746b346be53713689e207/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=498eeb72f590e518e19746b346be53713689e207", "patch": "@@ -1206,7 +1206,6 @@ symbols! {\n         rustc_trivial_field_reads,\n         rustc_unsafe_specialization_marker,\n         rustc_variance,\n-        rustc_with_negative_coherence,\n         rustdoc,\n         rustdoc_internals,\n         rustfmt,\n@@ -1490,6 +1489,7 @@ symbols! {\n         width,\n         windows,\n         windows_subsystem,\n+        with_negative_coherence,\n         wrapping_add,\n         wrapping_mul,\n         wrapping_sub,"}, {"sha": "21775a5c49f09da7690485fd36354d833db9b51d", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 16, "deletions": 57, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/498eeb72f590e518e19746b346be53713689e207/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498eeb72f590e518e19746b346be53713689e207/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=498eeb72f590e518e19746b346be53713689e207", "patch": "@@ -13,8 +13,8 @@ use crate::traits::{\n     self, FulfillmentContext, Normalized, Obligation, ObligationCause, PredicateObligation,\n     PredicateObligations, SelectionContext,\n };\n-use rustc_ast::Attribute;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_middle::traits::specialization_graph::OverlapMode;\n use rustc_middle::ty::fast_reject::{self, SimplifyParams, StripReferences};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::Subst;\n@@ -62,6 +62,7 @@ pub fn overlapping_impls<F1, F2, R>(\n     impl1_def_id: DefId,\n     impl2_def_id: DefId,\n     skip_leak_check: SkipLeakCheck,\n+    overlap_mode: OverlapMode,\n     on_overlap: F1,\n     no_overlap: F2,\n ) -> R\n@@ -99,7 +100,7 @@ where\n \n     let overlaps = tcx.infer_ctxt().enter(|infcx| {\n         let selcx = &mut SelectionContext::intercrate(&infcx);\n-        overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id).is_some()\n+        overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).is_some()\n     });\n \n     if !overlaps {\n@@ -112,7 +113,9 @@ where\n     tcx.infer_ctxt().enter(|infcx| {\n         let selcx = &mut SelectionContext::intercrate(&infcx);\n         selcx.enable_tracking_intercrate_ambiguity_causes();\n-        on_overlap(overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id).unwrap())\n+        on_overlap(\n+            overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).unwrap(),\n+        )\n     })\n }\n \n@@ -138,68 +141,26 @@ fn with_fresh_ty_vars<'cx, 'tcx>(\n     header\n }\n \n-/// What kind of overlap check are we doing -- this exists just for testing and feature-gating\n-/// purposes.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-enum OverlapMode {\n-    /// The 1.0 rules (either types fail to unify, or where clauses are not implemented for crate-local types)\n-    Stable,\n-    /// Feature-gated test: Stable, *or* there is an explicit negative impl that rules out one of the where-clauses.\n-    WithNegative,\n-    /// Just check for negative impls, not for \"where clause not implemented\": used for testing.\n-    Strict,\n-}\n-\n-impl OverlapMode {\n-    fn use_negative_impl(&self) -> bool {\n-        *self == OverlapMode::Strict || *self == OverlapMode::WithNegative\n-    }\n-\n-    fn use_implicit_negative(&self) -> bool {\n-        *self == OverlapMode::Stable || *self == OverlapMode::WithNegative\n-    }\n-}\n-\n-fn overlap_mode<'tcx>(tcx: TyCtxt<'tcx>, impl1_def_id: DefId, impl2_def_id: DefId) -> OverlapMode {\n-    // Find the possible coherence mode override opt-in attributes for each `DefId`\n-    let find_coherence_attr = |attr: &Attribute| {\n-        let name = attr.name_or_empty();\n-        match name {\n-            sym::rustc_with_negative_coherence | sym::rustc_strict_coherence => Some(name),\n-            _ => None,\n-        }\n-    };\n-    let impl1_coherence_mode = tcx.get_attrs(impl1_def_id).iter().find_map(find_coherence_attr);\n-    let impl2_coherence_mode = tcx.get_attrs(impl2_def_id).iter().find_map(find_coherence_attr);\n-\n-    // If there are any (that currently happens in tests), they need to match. Otherwise, the\n-    // default 1.0 rules are used.\n-    match (impl1_coherence_mode, impl2_coherence_mode) {\n-        (None, None) => OverlapMode::Stable,\n-        (Some(sym::rustc_with_negative_coherence), Some(sym::rustc_with_negative_coherence)) => {\n-            OverlapMode::WithNegative\n-        }\n-        (Some(sym::rustc_strict_coherence), Some(sym::rustc_strict_coherence)) => {\n-            OverlapMode::Strict\n-        }\n-        (Some(mode), _) | (_, Some(mode)) => {\n-            bug!(\"Use the same coherence mode on both impls: {}\", mode)\n-        }\n-    }\n-}\n-\n /// Can both impl `a` and impl `b` be satisfied by a common type (including\n /// where-clauses)? If so, returns an `ImplHeader` that unifies the two impls.\n fn overlap<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     skip_leak_check: SkipLeakCheck,\n     impl1_def_id: DefId,\n     impl2_def_id: DefId,\n+    overlap_mode: OverlapMode,\n ) -> Option<OverlapResult<'tcx>> {\n     debug!(\"overlap(impl1_def_id={:?}, impl2_def_id={:?})\", impl1_def_id, impl2_def_id);\n \n     selcx.infcx().probe_maybe_skip_leak_check(skip_leak_check.is_yes(), |snapshot| {\n-        overlap_within_probe(selcx, skip_leak_check, impl1_def_id, impl2_def_id, snapshot)\n+        overlap_within_probe(\n+            selcx,\n+            skip_leak_check,\n+            impl1_def_id,\n+            impl2_def_id,\n+            overlap_mode,\n+            snapshot,\n+        )\n     })\n }\n \n@@ -208,12 +169,10 @@ fn overlap_within_probe<'cx, 'tcx>(\n     skip_leak_check: SkipLeakCheck,\n     impl1_def_id: DefId,\n     impl2_def_id: DefId,\n+    overlap_mode: OverlapMode,\n     snapshot: &CombinedSnapshot<'_, 'tcx>,\n ) -> Option<OverlapResult<'tcx>> {\n     let infcx = selcx.infcx();\n-    let tcx = infcx.tcx;\n-\n-    let overlap_mode = overlap_mode(tcx, impl1_def_id, impl2_def_id);\n \n     if overlap_mode.use_negative_impl() {\n         if negative_impl(selcx, impl1_def_id, impl2_def_id)"}, {"sha": "b098e8590da01e19f50afa446e817de4691578ee", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/498eeb72f590e518e19746b346be53713689e207/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498eeb72f590e518e19746b346be53713689e207/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=498eeb72f590e518e19746b346be53713689e207", "patch": "@@ -257,6 +257,7 @@ pub(super) fn specialization_graph_provider(\n     trait_id: DefId,\n ) -> specialization_graph::Graph {\n     let mut sg = specialization_graph::Graph::new();\n+    let overlap_mode = specialization_graph::OverlapMode::get(tcx, trait_id);\n \n     let mut trait_impls: Vec<_> = tcx.all_impls(trait_id).collect();\n \n@@ -270,7 +271,7 @@ pub(super) fn specialization_graph_provider(\n     for impl_def_id in trait_impls {\n         if let Some(impl_def_id) = impl_def_id.as_local() {\n             // This is where impl overlap checking happens:\n-            let insert_result = sg.insert(tcx, impl_def_id.to_def_id());\n+            let insert_result = sg.insert(tcx, impl_def_id.to_def_id(), overlap_mode);\n             // Report error if there was one.\n             let (overlap, used_to_be_allowed) = match insert_result {\n                 Err(overlap) => (Some(overlap), None),"}, {"sha": "5ee8b45e66b5c07934d95fca6668c7b571680659", "filename": "compiler/rustc_trait_selection/src/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/498eeb72f590e518e19746b346be53713689e207/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498eeb72f590e518e19746b346be53713689e207/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=498eeb72f590e518e19746b346be53713689e207", "patch": "@@ -41,6 +41,7 @@ trait ChildrenExt<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         impl_def_id: DefId,\n         simplified_self: Option<SimplifiedType>,\n+        overlap_mode: OverlapMode,\n     ) -> Result<Inserted, OverlapError>;\n }\n \n@@ -92,6 +93,7 @@ impl ChildrenExt<'_> for Children {\n         tcx: TyCtxt<'_>,\n         impl_def_id: DefId,\n         simplified_self: Option<SimplifiedType>,\n+        overlap_mode: OverlapMode,\n     ) -> Result<Inserted, OverlapError> {\n         let mut last_lint = None;\n         let mut replace_children = Vec::new();\n@@ -142,6 +144,7 @@ impl ChildrenExt<'_> for Children {\n                     possible_sibling,\n                     impl_def_id,\n                     traits::SkipLeakCheck::default(),\n+                    overlap_mode,\n                     |_| true,\n                     || false,\n                 );\n@@ -166,6 +169,7 @@ impl ChildrenExt<'_> for Children {\n                 possible_sibling,\n                 impl_def_id,\n                 traits::SkipLeakCheck::Yes,\n+                overlap_mode,\n                 |overlap| {\n                     if let Some(overlap_kind) =\n                         tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling)\n@@ -273,6 +277,7 @@ pub trait GraphExt {\n         &mut self,\n         tcx: TyCtxt<'_>,\n         impl_def_id: DefId,\n+        overlap_mode: OverlapMode,\n     ) -> Result<Option<FutureCompatOverlapError>, OverlapError>;\n \n     /// Insert cached metadata mapping from a child impl back to its parent.\n@@ -287,6 +292,7 @@ impl GraphExt for Graph {\n         &mut self,\n         tcx: TyCtxt<'_>,\n         impl_def_id: DefId,\n+        overlap_mode: OverlapMode,\n     ) -> Result<Option<FutureCompatOverlapError>, OverlapError> {\n         assert!(impl_def_id.is_local());\n \n@@ -327,8 +333,12 @@ impl GraphExt for Graph {\n         loop {\n             use self::Inserted::*;\n \n-            let insert_result =\n-                self.children.entry(parent).or_default().insert(tcx, impl_def_id, simplified)?;\n+            let insert_result = self.children.entry(parent).or_default().insert(\n+                tcx,\n+                impl_def_id,\n+                simplified,\n+                overlap_mode,\n+            )?;\n \n             match insert_result {\n                 BecameNewSibling(opt_lint) => {"}, {"sha": "cf71e0f300c4181c5ba28ddf35c441522c7fe838", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/498eeb72f590e518e19746b346be53713689e207/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498eeb72f590e518e19746b346be53713689e207/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs?ref=498eeb72f590e518e19746b346be53713689e207", "patch": "@@ -4,6 +4,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_index::vec::IndexVec;\n+use rustc_middle::traits::specialization_graph::OverlapMode;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::Symbol;\n use rustc_trait_selection::traits::{self, SkipLeakCheck};\n@@ -99,14 +100,20 @@ impl<'tcx> InherentOverlapChecker<'tcx> {\n         }\n     }\n \n-    fn check_for_overlapping_inherent_impls(&self, impl1_def_id: DefId, impl2_def_id: DefId) {\n+    fn check_for_overlapping_inherent_impls(\n+        &self,\n+        overlap_mode: OverlapMode,\n+        impl1_def_id: DefId,\n+        impl2_def_id: DefId,\n+    ) {\n         traits::overlapping_impls(\n             self.tcx,\n             impl1_def_id,\n             impl2_def_id,\n             // We go ahead and just skip the leak check for\n             // inherent impls without warning.\n             SkipLeakCheck::Yes,\n+            overlap_mode,\n             |overlap| {\n                 self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id, overlap);\n                 false\n@@ -131,6 +138,8 @@ impl<'tcx> ItemLikeVisitor<'_> for InherentOverlapChecker<'tcx> {\n                     return;\n                 }\n \n+                let overlap_mode = OverlapMode::get(self.tcx, item.def_id.to_def_id());\n+\n                 let impls_items = impls\n                     .iter()\n                     .map(|impl_def_id| (impl_def_id, self.tcx.associated_items(*impl_def_id)))\n@@ -145,6 +154,7 @@ impl<'tcx> ItemLikeVisitor<'_> for InherentOverlapChecker<'tcx> {\n                         for &(&impl2_def_id, impl_items2) in &impls_items[(i + 1)..] {\n                             if self.impls_have_common_items(impl_items1, impl_items2) {\n                                 self.check_for_overlapping_inherent_impls(\n+                                    overlap_mode,\n                                     impl1_def_id,\n                                     impl2_def_id,\n                                 );\n@@ -288,6 +298,7 @@ impl<'tcx> ItemLikeVisitor<'_> for InherentOverlapChecker<'tcx> {\n                                 let &(&impl2_def_id, impl_items2) = &impls_items[impl2_items_idx];\n                                 if self.impls_have_common_items(impl_items1, impl_items2) {\n                                     self.check_for_overlapping_inherent_impls(\n+                                        overlap_mode,\n                                         impl1_def_id,\n                                         impl2_def_id,\n                                     );"}, {"sha": "067de1cd867d9d55ec87a5425db63355d1d0924d", "filename": "src/test/ui/coherence/auxiliary/option_future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/498eeb72f590e518e19746b346be53713689e207/src%2Ftest%2Fui%2Fcoherence%2Fauxiliary%2Foption_future.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498eeb72f590e518e19746b346be53713689e207/src%2Ftest%2Fui%2Fcoherence%2Fauxiliary%2Foption_future.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fauxiliary%2Foption_future.rs?ref=498eeb72f590e518e19746b346be53713689e207", "patch": "@@ -1,8 +1,8 @@\n #![crate_type = \"lib\"]\n #![feature(negative_impls)]\n #![feature(rustc_attrs)]\n+#![feature(with_negative_coherence)]\n \n pub trait Future {}\n \n-#[rustc_with_negative_coherence]\n impl<E> !Future for Option<E> where E: Sized {}"}, {"sha": "c240a1839827827609eb1d11a10551852dc7c009", "filename": "src/test/ui/coherence/coherence-overlap-negate-alias-strict.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/498eeb72f590e518e19746b346be53713689e207/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-alias-strict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498eeb72f590e518e19746b346be53713689e207/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-alias-strict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-alias-strict.rs?ref=498eeb72f590e518e19746b346be53713689e207", "patch": "@@ -1,17 +1,17 @@\n #![feature(negative_impls)]\n #![feature(rustc_attrs)]\n #![feature(trait_alias)]\n+#![feature(with_negative_coherence)]\n \n trait A {}\n trait B {}\n trait AB = A + B;\n \n impl !A for u32 {}\n \n-trait C {}\n #[rustc_strict_coherence]\n+trait C {}\n impl<T: AB> C for T {}\n-#[rustc_strict_coherence]\n impl C for u32 {}\n //~^ ERROR: conflicting implementations of trait `C` for type `u32` [E0119]\n // FIXME this should work, we should implement an `assemble_neg_candidates` fn"}, {"sha": "30d837a5c5019d28dd3af83857354089f5be01d2", "filename": "src/test/ui/coherence/coherence-overlap-negate-alias-strict.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/498eeb72f590e518e19746b346be53713689e207/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-alias-strict.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/498eeb72f590e518e19746b346be53713689e207/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-alias-strict.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-alias-strict.stderr?ref=498eeb72f590e518e19746b346be53713689e207", "patch": "@@ -3,7 +3,6 @@ error[E0119]: conflicting implementations of trait `C` for type `u32`\n    |\n LL | impl<T: AB> C for T {}\n    | ------------------- first implementation here\n-LL | #[rustc_strict_coherence]\n LL | impl C for u32 {}\n    | ^^^^^^^^^^^^^^ conflicting implementation for `u32`\n "}, {"sha": "1021d87ca1b0b2231c66286d3086764ac3e78e79", "filename": "src/test/ui/coherence/coherence-overlap-negate-strict.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/498eeb72f590e518e19746b346be53713689e207/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-strict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498eeb72f590e518e19746b346be53713689e207/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-strict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-strict.rs?ref=498eeb72f590e518e19746b346be53713689e207", "patch": "@@ -3,16 +3,16 @@\n #![feature(negative_impls)]\n #![feature(rustc_attrs)]\n #![feature(trait_alias)]\n+#![feature(with_negative_coherence)]\n \n trait A {}\n trait B {}\n \n impl !A for u32 {}\n \n-trait C {}\n #[rustc_strict_coherence]\n+trait C {}\n impl<T: A + B> C for T {}\n-#[rustc_strict_coherence]\n impl C for u32 {}\n \n fn main() {}"}, {"sha": "cc8c463b8223e51642a29e56d5d3cd856ef38836", "filename": "src/test/ui/coherence/coherence-overlap-negative-trait2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/498eeb72f590e518e19746b346be53713689e207/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negative-trait2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498eeb72f590e518e19746b346be53713689e207/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negative-trait2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negative-trait2.rs?ref=498eeb72f590e518e19746b346be53713689e207", "patch": "@@ -4,15 +4,14 @@\n // Check that if we promise to not impl what would overlap it doesn't actually overlap\n \n #![feature(rustc_attrs)]\n+#![feature(with_negative_coherence)]\n \n extern crate option_future as lib;\n use lib::Future;\n \n trait Termination {}\n \n-#[rustc_with_negative_coherence]\n impl<E> Termination for Option<E> where E: Sized {}\n-#[rustc_with_negative_coherence]\n impl<F> Termination for F where F: Future + Sized {}\n \n fn main() {}"}, {"sha": "9d9c76af91daf68739b38081b9daa97d86c2253a", "filename": "src/test/ui/coherence/coherence-overlap-trait-alias.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/498eeb72f590e518e19746b346be53713689e207/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-trait-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498eeb72f590e518e19746b346be53713689e207/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-trait-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-trait-alias.rs?ref=498eeb72f590e518e19746b346be53713689e207", "patch": "@@ -1,5 +1,6 @@\n #![feature(rustc_attrs)]\n #![feature(trait_alias)]\n+#![feature(with_negative_coherence)]\n \n trait A {}\n trait B {}\n@@ -8,10 +9,9 @@ trait AB = A + B;\n impl A for u32 {}\n impl B for u32 {}\n \n-trait C {}\n #[rustc_strict_coherence]\n+trait C {}\n impl<T: AB> C for T {}\n-#[rustc_strict_coherence]\n impl C for u32 {}\n //~^ ERROR\n // FIXME it's giving an ungreat error but unsure if we care given that it's using an internal rustc"}, {"sha": "421c86ee51a528241a491b18d002a86028ce3199", "filename": "src/test/ui/coherence/coherence-overlap-trait-alias.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/498eeb72f590e518e19746b346be53713689e207/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-trait-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/498eeb72f590e518e19746b346be53713689e207/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-trait-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-trait-alias.stderr?ref=498eeb72f590e518e19746b346be53713689e207", "patch": "@@ -5,11 +5,10 @@ LL | impl C for u32 {}\n    |      ^ cannot infer type for type `u32`\n    |\n note: multiple `impl`s satisfying `u32: C` found\n-  --> $DIR/coherence-overlap-trait-alias.rs:13:1\n+  --> $DIR/coherence-overlap-trait-alias.rs:14:1\n    |\n LL | impl<T: AB> C for T {}\n    | ^^^^^^^^^^^^^^^^^^^\n-LL | #[rustc_strict_coherence]\n LL | impl C for u32 {}\n    | ^^^^^^^^^^^^^^\n "}, {"sha": "d1d0a6a90b830ba97d381fca5e6a2ad846b68083", "filename": "src/test/ui/feature-gates/feature-gate-with_negative_coherence.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/498eeb72f590e518e19746b346be53713689e207/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-with_negative_coherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/498eeb72f590e518e19746b346be53713689e207/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-with_negative_coherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-with_negative_coherence.rs?ref=498eeb72f590e518e19746b346be53713689e207", "patch": "@@ -0,0 +1,8 @@\n+trait Foo { }\n+\n+impl<T: std::ops::DerefMut> Foo for T { }\n+\n+impl<T> Foo for &T { }\n+//~^ ERROR conflicting implementations of trait `Foo` for type `&_` [E0119]\n+\n+fn main() { }"}, {"sha": "05007dafa37fd3c615f4a8a294d83e15eefff54a", "filename": "src/test/ui/feature-gates/feature-gate-with_negative_coherence.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/498eeb72f590e518e19746b346be53713689e207/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-with_negative_coherence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/498eeb72f590e518e19746b346be53713689e207/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-with_negative_coherence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-with_negative_coherence.stderr?ref=498eeb72f590e518e19746b346be53713689e207", "patch": "@@ -0,0 +1,12 @@\n+error[E0119]: conflicting implementations of trait `Foo` for type `&_`\n+  --> $DIR/feature-gate-with_negative_coherence.rs:5:1\n+   |\n+LL | impl<T: std::ops::DerefMut> Foo for T { }\n+   | ------------------------------------- first implementation here\n+LL | \n+LL | impl<T> Foo for &T { }\n+   | ^^^^^^^^^^^^^^^^^^ conflicting implementation for `&_`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}]}