{"sha": "765fa81a6e8d063db60be20e710e51d8ca995fbd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2NWZhODFhNmU4ZDA2M2RiNjBiZTIwZTcxMGU1MWQ4Y2E5OTVmYmQ=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-01-30T16:51:59Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-01-30T16:51:59Z"}, "message": "Swap the names of `LocalValue` and `LocalState`", "tree": {"sha": "4a56727afc45ee8951b454f0709a9695b3bb2e74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a56727afc45ee8951b454f0709a9695b3bb2e74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/765fa81a6e8d063db60be20e710e51d8ca995fbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/765fa81a6e8d063db60be20e710e51d8ca995fbd", "html_url": "https://github.com/rust-lang/rust/commit/765fa81a6e8d063db60be20e710e51d8ca995fbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/765fa81a6e8d063db60be20e710e51d8ca995fbd/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7a5cb620feab14defb633af4ebf8d0671c22441", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7a5cb620feab14defb633af4ebf8d0671c22441", "html_url": "https://github.com/rust-lang/rust/commit/a7a5cb620feab14defb633af4ebf8d0671c22441"}], "stats": {"total": 66, "additions": 33, "deletions": 33}, "files": [{"sha": "1328a1aeeab962ec0a49597efe216d81e20e53e2", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/765fa81a6e8d063db60be20e710e51d8ca995fbd/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/765fa81a6e8d063db60be20e710e51d8ca995fbd/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=765fa81a6e8d063db60be20e710e51d8ca995fbd", "patch": "@@ -14,7 +14,7 @@ pub struct RawConst<'tcx> {\n }\n \n /// Represents a constant value in Rust. Scalar and ScalarPair are optimizations which\n-/// matches the LocalValue optimizations for easy conversions between Value and ConstValue.\n+/// matches the LocalState optimizations for easy conversions between Value and ConstValue.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n pub enum ConstValue<'tcx> {\n     /// Used only for types with layout::abi::Scalar ABI and ZSTs"}, {"sha": "1b976d822ebff1a6d19a2a36afed9b7cc59471ce", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/765fa81a6e8d063db60be20e710e51d8ca995fbd/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/765fa81a6e8d063db60be20e710e51d8ca995fbd/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=765fa81a6e8d063db60be20e710e51d8ca995fbd", "patch": "@@ -76,7 +76,7 @@ pub struct Frame<'mir, 'tcx: 'mir, Tag=(), Extra=()> {\n     /// The locals are stored as `Option<Value>`s.\n     /// `None` represents a local that is currently dead, while a live local\n     /// can either directly contain `Scalar` or refer to some part of an `Allocation`.\n-    pub locals: IndexVec<mir::Local, LocalValue<'tcx, Tag>>,\n+    pub locals: IndexVec<mir::Local, LocalState<'tcx, Tag>>,\n \n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n@@ -107,15 +107,15 @@ pub enum StackPopCleanup {\n \n /// State of a local variable including a memoized layout\n #[derive(Clone, PartialEq, Eq)]\n-pub struct LocalValue<'tcx, Tag=(), Id=AllocId> {\n-    pub state: LocalState<Tag, Id>,\n+pub struct LocalState<'tcx, Tag=(), Id=AllocId> {\n+    pub state: LocalValue<Tag, Id>,\n     /// Don't modify if `Some`, this is only used to prevent computing the layout twice\n     pub layout: Cell<Option<TyLayout<'tcx>>>,\n }\n \n /// State of a local variable\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub enum LocalState<Tag=(), Id=AllocId> {\n+pub enum LocalValue<Tag=(), Id=AllocId> {\n     Dead,\n     // Mostly for convenience, we re-use the `Operand` type here.\n     // This is an optimization over just always having a pointer here;\n@@ -124,18 +124,18 @@ pub enum LocalState<Tag=(), Id=AllocId> {\n     Live(Operand<Tag, Id>),\n }\n \n-impl<'tcx, Tag> LocalValue<'tcx, Tag> {\n+impl<'tcx, Tag> LocalState<'tcx, Tag> {\n     pub fn access(&self) -> EvalResult<'tcx, &Operand<Tag>> {\n         match self.state {\n-            LocalState::Dead => err!(DeadLocal),\n-            LocalState::Live(ref val) => Ok(val),\n+            LocalValue::Dead => err!(DeadLocal),\n+            LocalValue::Live(ref val) => Ok(val),\n         }\n     }\n \n     pub fn access_mut(&mut self) -> EvalResult<'tcx, &mut Operand<Tag>> {\n         match self.state {\n-            LocalState::Dead => err!(DeadLocal),\n-            LocalState::Live(ref mut val) => Ok(val),\n+            LocalValue::Dead => err!(DeadLocal),\n+            LocalValue::Live(ref mut val) => Ok(val),\n         }\n     }\n }\n@@ -474,18 +474,18 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         // don't allocate at all for trivial constants\n         if mir.local_decls.len() > 1 {\n             // We put some marker immediate into the locals that we later want to initialize.\n-            // This can be anything except for LocalState::Dead -- because *that* is the\n+            // This can be anything except for LocalValue::Dead -- because *that* is the\n             // value we use for things that we know are initially dead.\n-            let dummy = LocalValue {\n-                state: LocalState::Live(Operand::Immediate(Immediate::Scalar(\n+            let dummy = LocalState {\n+                state: LocalValue::Live(Operand::Immediate(Immediate::Scalar(\n                     ScalarMaybeUndef::Undef,\n                 ))),\n                 layout: Cell::new(None),\n             };\n             let mut locals = IndexVec::from_elem(dummy, &mir.local_decls);\n             // Return place is handled specially by the `eval_place` functions, and the\n             // entry in `locals` should never be used. Make it dead, to be sure.\n-            locals[mir::RETURN_PLACE].state = LocalState::Dead;\n+            locals[mir::RETURN_PLACE].state = LocalValue::Dead;\n             // Now mark those locals as dead that we do not want to initialize\n             match self.tcx.describe_def(instance.def_id()) {\n                 // statics and constants don't have `Storage*` statements, no need to look for them\n@@ -498,7 +498,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n                             match stmt.kind {\n                                 StorageLive(local) |\n                                 StorageDead(local) => {\n-                                    locals[local].state = LocalState::Dead;\n+                                    locals[local].state = LocalValue::Dead;\n                                 }\n                                 _ => {}\n                             }\n@@ -509,14 +509,14 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n             // Finally, properly initialize all those that still have the dummy value\n             for (idx, local) in locals.iter_enumerated_mut() {\n                 match local.state {\n-                    LocalState::Live(_) => {\n+                    LocalValue::Live(_) => {\n                         // This needs to be properly initialized.\n                         let ty = self.monomorphize(mir.local_decls[idx].ty)?;\n                         let layout = self.layout_of(ty)?;\n-                        local.state = LocalState::Live(self.uninit_operand(layout)?);\n+                        local.state = LocalValue::Live(self.uninit_operand(layout)?);\n                         local.layout = Cell::new(Some(layout));\n                     }\n-                    LocalState::Dead => {\n+                    LocalValue::Dead => {\n                         // Nothing to do\n                     }\n                 }\n@@ -603,31 +603,31 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n     pub fn storage_live(\n         &mut self,\n         local: mir::Local\n-    ) -> EvalResult<'tcx, LocalState<M::PointerTag>> {\n+    ) -> EvalResult<'tcx, LocalValue<M::PointerTag>> {\n         assert!(local != mir::RETURN_PLACE, \"Cannot make return place live\");\n         trace!(\"{:?} is now live\", local);\n \n         let layout = self.layout_of_local(self.frame(), local, None)?;\n-        let init = LocalState::Live(self.uninit_operand(layout)?);\n+        let init = LocalValue::Live(self.uninit_operand(layout)?);\n         // StorageLive *always* kills the value that's currently stored\n         Ok(mem::replace(&mut self.frame_mut().locals[local].state, init))\n     }\n \n     /// Returns the old value of the local.\n     /// Remember to deallocate that!\n-    pub fn storage_dead(&mut self, local: mir::Local) -> LocalState<M::PointerTag> {\n+    pub fn storage_dead(&mut self, local: mir::Local) -> LocalValue<M::PointerTag> {\n         assert!(local != mir::RETURN_PLACE, \"Cannot make return place dead\");\n         trace!(\"{:?} is now dead\", local);\n \n-        mem::replace(&mut self.frame_mut().locals[local].state, LocalState::Dead)\n+        mem::replace(&mut self.frame_mut().locals[local].state, LocalValue::Dead)\n     }\n \n     pub(super) fn deallocate_local(\n         &mut self,\n-        local: LocalState<M::PointerTag>,\n+        local: LocalValue<M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n         // FIXME: should we tell the user that there was a local which was never written to?\n-        if let LocalState::Live(Operand::Indirect(MemPlace { ptr, .. })) = local {\n+        if let LocalValue::Live(Operand::Indirect(MemPlace { ptr, .. })) = local {\n             trace!(\"deallocating local\");\n             let ptr = ptr.to_ptr()?;\n             self.memory.dump_alloc(ptr.alloc_id);"}, {"sha": "d2ab3fcb7a30a13ea8a402d53858867258d4e337", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/765fa81a6e8d063db60be20e710e51d8ca995fbd/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/765fa81a6e8d063db60be20e710e51d8ca995fbd/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=765fa81a6e8d063db60be20e710e51d8ca995fbd", "patch": "@@ -18,7 +18,7 @@ mod visitor;\n pub use rustc::mir::interpret::*; // have all the `interpret` symbols in one place: here\n \n pub use self::eval_context::{\n-    EvalContext, Frame, StackPopCleanup, LocalValue, LocalState,\n+    EvalContext, Frame, StackPopCleanup, LocalState, LocalValue,\n };\n \n pub use self::place::{Place, PlaceTy, MemPlace, MPlaceTy};"}, {"sha": "c4b56f571db9c0712e5ffd1024777044551c3419", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/765fa81a6e8d063db60be20e710e51d8ca995fbd/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/765fa81a6e8d063db60be20e710e51d8ca995fbd/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=765fa81a6e8d063db60be20e710e51d8ca995fbd", "patch": "@@ -23,8 +23,8 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use syntax::ast::Mutability;\n use syntax::source_map::Span;\n \n-use super::eval_context::{LocalValue, StackPopCleanup};\n-use super::{Frame, Memory, Operand, MemPlace, Place, Immediate, ScalarMaybeUndef, LocalState};\n+use super::eval_context::{LocalState, StackPopCleanup};\n+use super::{Frame, Memory, Operand, MemPlace, Place, Immediate, ScalarMaybeUndef, LocalValue};\n use const_eval::CompileTimeInterpreter;\n \n #[derive(Default)]\n@@ -250,11 +250,11 @@ impl_snapshot_for!(enum Operand {\n     Indirect(m),\n });\n \n-impl_stable_hash_for!(enum ::interpret::LocalState {\n+impl_stable_hash_for!(enum ::interpret::LocalValue {\n     Dead,\n     Live(x),\n });\n-impl_snapshot_for!(enum LocalState {\n+impl_snapshot_for!(enum LocalValue {\n     Live(v),\n     Dead,\n });\n@@ -309,7 +309,7 @@ struct FrameSnapshot<'a, 'tcx: 'a> {\n     span: &'a Span,\n     return_to_block: &'a StackPopCleanup,\n     return_place: Option<Place<(), AllocIdSnapshot<'a>>>,\n-    locals: IndexVec<mir::Local, LocalState<(), AllocIdSnapshot<'a>>>,\n+    locals: IndexVec<mir::Local, LocalValue<(), AllocIdSnapshot<'a>>>,\n     block: &'a mir::BasicBlock,\n     stmt: usize,\n }\n@@ -356,17 +356,17 @@ impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n     }\n }\n \n-impl<'a, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a LocalValue<'tcx>\n+impl<'a, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a LocalState<'tcx>\n     where Ctx: SnapshotContext<'a>,\n {\n-    type Item = LocalState<(), AllocIdSnapshot<'a>>;\n+    type Item = LocalValue<(), AllocIdSnapshot<'a>>;\n \n     fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n         self.state.snapshot(ctx)\n     }\n }\n \n-impl_stable_hash_for!(struct LocalValue<'tcx> {\n+impl_stable_hash_for!(struct LocalState<'tcx> {\n     state,\n     layout -> _,\n });"}]}