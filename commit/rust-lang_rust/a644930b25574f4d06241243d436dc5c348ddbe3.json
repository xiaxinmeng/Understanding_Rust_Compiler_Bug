{"sha": "a644930b25574f4d06241243d436dc5c348ddbe3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2NDQ5MzBiMjU1NzRmNGQwNjI0MTI0M2Q0MzZkYzVjMzQ4ZGRiZTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-28T07:07:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-28T07:07:25Z"}, "message": "Auto merge of #6360 - mlegner:mod_one, r=llogiq\n\nTrigger modulo_one lint also on -1.\n\nFixes #6321.\n\nchangelog: trigger `modulo_one` lint also on `-1`", "tree": {"sha": "6e67f05801d2d2fc866ca482acacbb69cee61f59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e67f05801d2d2fc866ca482acacbb69cee61f59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a644930b25574f4d06241243d436dc5c348ddbe3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a644930b25574f4d06241243d436dc5c348ddbe3", "html_url": "https://github.com/rust-lang/rust/commit/a644930b25574f4d06241243d436dc5c348ddbe3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a644930b25574f4d06241243d436dc5c348ddbe3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84ba08f391508722231566a68edda80d7061ed7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/84ba08f391508722231566a68edda80d7061ed7c", "html_url": "https://github.com/rust-lang/rust/commit/84ba08f391508722231566a68edda80d7061ed7c"}, {"sha": "b8226320735bc8e3f699cc177be638433ed396d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8226320735bc8e3f699cc177be638433ed396d9", "html_url": "https://github.com/rust-lang/rust/commit/b8226320735bc8e3f699cc177be638433ed396d9"}], "stats": {"total": 209, "additions": 142, "deletions": 67}, "files": [{"sha": "0512d74c7b1c8350bd31ca5f039d84578d663b83", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 83, "deletions": 61, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/a644930b25574f4d06241243d436dc5c348ddbe3/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a644930b25574f4d06241243d436dc5c348ddbe3/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=a644930b25574f4d06241243d436dc5c348ddbe3", "patch": "@@ -18,7 +18,7 @@ use crate::utils::sugg::Sugg;\n use crate::utils::{\n     get_item_name, get_parent_expr, higher, implements_trait, in_constant, is_integer_const, iter_input_pats,\n     last_path_segment, match_qpath, match_trait_method, paths, snippet, snippet_opt, span_lint, span_lint_and_sugg,\n-    span_lint_and_then, span_lint_hir_and_then, SpanlessEq,\n+    span_lint_and_then, span_lint_hir_and_then, unsext, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -139,23 +139,26 @@ declare_clippy_lint! {\n }\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for getting the remainder of a division by one.\n+    /// **What it does:** Checks for getting the remainder of a division by one or minus\n+    /// one.\n     ///\n-    /// **Why is this bad?** The result can only ever be zero. No one will write\n-    /// such code deliberately, unless trying to win an Underhanded Rust\n-    /// Contest. Even for that contest, it's probably a bad idea. Use something more\n-    /// underhanded.\n+    /// **Why is this bad?** The result for a divisor of one can only ever be zero; for\n+    /// minus one it can cause panic/overflow (if the left operand is the minimal value of\n+    /// the respective integer type) or results in zero. No one will write such code\n+    /// deliberately, unless trying to win an Underhanded Rust Contest. Even for that\n+    /// contest, it's probably a bad idea. Use something more underhanded.\n     ///\n     /// **Known problems:** None.\n     ///\n     /// **Example:**\n     /// ```rust\n     /// # let x = 1;\n     /// let a = x % 1;\n+    /// let a = x % -1;\n     /// ```\n     pub MODULO_ONE,\n     correctness,\n-    \"taking a number modulo 1, which always returns 0\"\n+    \"taking a number modulo +/-1, which can either panic/overflow or always returns 0\"\n }\n \n declare_clippy_lint! {\n@@ -378,60 +381,8 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n                 return;\n             },\n             ExprKind::Binary(ref cmp, ref left, ref right) => {\n-                let op = cmp.node;\n-                if op.is_comparison() {\n-                    check_nan(cx, left, expr);\n-                    check_nan(cx, right, expr);\n-                    check_to_owned(cx, left, right, true);\n-                    check_to_owned(cx, right, left, false);\n-                }\n-                if (op == BinOpKind::Eq || op == BinOpKind::Ne) && (is_float(cx, left) || is_float(cx, right)) {\n-                    if is_allowed(cx, left) || is_allowed(cx, right) {\n-                        return;\n-                    }\n-\n-                    // Allow comparing the results of signum()\n-                    if is_signum(cx, left) && is_signum(cx, right) {\n-                        return;\n-                    }\n-\n-                    if let Some(name) = get_item_name(cx, expr) {\n-                        let name = name.as_str();\n-                        if name == \"eq\"\n-                            || name == \"ne\"\n-                            || name == \"is_nan\"\n-                            || name.starts_with(\"eq_\")\n-                            || name.ends_with(\"_eq\")\n-                        {\n-                            return;\n-                        }\n-                    }\n-                    let is_comparing_arrays = is_array(cx, left) || is_array(cx, right);\n-                    let (lint, msg) = get_lint_and_message(\n-                        is_named_constant(cx, left) || is_named_constant(cx, right),\n-                        is_comparing_arrays,\n-                    );\n-                    span_lint_and_then(cx, lint, expr.span, msg, |diag| {\n-                        let lhs = Sugg::hir(cx, left, \"..\");\n-                        let rhs = Sugg::hir(cx, right, \"..\");\n-\n-                        if !is_comparing_arrays {\n-                            diag.span_suggestion(\n-                                expr.span,\n-                                \"consider comparing them within some margin of error\",\n-                                format!(\n-                                    \"({}).abs() {} error_margin\",\n-                                    lhs - rhs,\n-                                    if op == BinOpKind::Eq { '<' } else { '>' }\n-                                ),\n-                                Applicability::HasPlaceholders, // snippet\n-                            );\n-                        }\n-                        diag.note(\"`f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\");\n-                    });\n-                } else if op == BinOpKind::Rem && is_integer_const(cx, right, 1) {\n-                    span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n-                }\n+                check_binary(cx, expr, cmp, left, right);\n+                return;\n             },\n             _ => {},\n         }\n@@ -744,3 +695,74 @@ fn check_cast(cx: &LateContext<'_>, span: Span, e: &Expr<'_>, ty: &hir::Ty<'_>)\n         }\n     }\n }\n+\n+fn check_binary(\n+    cx: &LateContext<'a>,\n+    expr: &Expr<'_>,\n+    cmp: &rustc_span::source_map::Spanned<rustc_hir::BinOpKind>,\n+    left: &'a Expr<'_>,\n+    right: &'a Expr<'_>,\n+) {\n+    let op = cmp.node;\n+    if op.is_comparison() {\n+        check_nan(cx, left, expr);\n+        check_nan(cx, right, expr);\n+        check_to_owned(cx, left, right, true);\n+        check_to_owned(cx, right, left, false);\n+    }\n+    if (op == BinOpKind::Eq || op == BinOpKind::Ne) && (is_float(cx, left) || is_float(cx, right)) {\n+        if is_allowed(cx, left) || is_allowed(cx, right) {\n+            return;\n+        }\n+\n+        // Allow comparing the results of signum()\n+        if is_signum(cx, left) && is_signum(cx, right) {\n+            return;\n+        }\n+\n+        if let Some(name) = get_item_name(cx, expr) {\n+            let name = name.as_str();\n+            if name == \"eq\" || name == \"ne\" || name == \"is_nan\" || name.starts_with(\"eq_\") || name.ends_with(\"_eq\") {\n+                return;\n+            }\n+        }\n+        let is_comparing_arrays = is_array(cx, left) || is_array(cx, right);\n+        let (lint, msg) = get_lint_and_message(\n+            is_named_constant(cx, left) || is_named_constant(cx, right),\n+            is_comparing_arrays,\n+        );\n+        span_lint_and_then(cx, lint, expr.span, msg, |diag| {\n+            let lhs = Sugg::hir(cx, left, \"..\");\n+            let rhs = Sugg::hir(cx, right, \"..\");\n+\n+            if !is_comparing_arrays {\n+                diag.span_suggestion(\n+                    expr.span,\n+                    \"consider comparing them within some margin of error\",\n+                    format!(\n+                        \"({}).abs() {} error_margin\",\n+                        lhs - rhs,\n+                        if op == BinOpKind::Eq { '<' } else { '>' }\n+                    ),\n+                    Applicability::HasPlaceholders, // snippet\n+                );\n+            }\n+            diag.note(\"`f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\");\n+        });\n+    } else if op == BinOpKind::Rem {\n+        if is_integer_const(cx, right, 1) {\n+            span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n+        }\n+\n+        if let ty::Int(ity) = cx.typeck_results().expr_ty(right).kind() {\n+            if is_integer_const(cx, right, unsext(cx.tcx, -1, *ity)) {\n+                span_lint(\n+                    cx,\n+                    MODULO_ONE,\n+                    expr.span,\n+                    \"any number modulo -1 will panic/overflow or result in 0\",\n+                );\n+            }\n+        };\n+    }\n+}"}, {"sha": "678a312f66e53af9ed72aeb8765c9db6cbbb53e1", "filename": "tests/ui/modulo_one.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a644930b25574f4d06241243d436dc5c348ddbe3/tests%2Fui%2Fmodulo_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a644930b25574f4d06241243d436dc5c348ddbe3/tests%2Fui%2Fmodulo_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmodulo_one.rs?ref=a644930b25574f4d06241243d436dc5c348ddbe3", "patch": "@@ -2,13 +2,22 @@\n #![allow(clippy::no_effect, clippy::unnecessary_operation)]\n \n static STATIC_ONE: usize = 2 - 1;\n+static STATIC_NEG_ONE: i64 = 1 - 2;\n \n fn main() {\n     10 % 1;\n+    10 % -1;\n     10 % 2;\n+    i32::MIN % (-1); // also caught by rustc\n \n     const ONE: u32 = 1 * 1;\n+    const NEG_ONE: i64 = 1 - 2;\n+    const INT_MIN: i64 = i64::MIN;\n \n     2 % ONE;\n-    5 % STATIC_ONE;\n+    5 % STATIC_ONE; // NOT caught by lint\n+    2 % NEG_ONE;\n+    5 % STATIC_NEG_ONE; // NOT caught by lint\n+    INT_MIN % NEG_ONE; // also caught by rustc\n+    INT_MIN % STATIC_NEG_ONE; // ONLY caught by rustc\n }"}, {"sha": "2b2c699733852dd464507708dc41ad79a15b92eb", "filename": "tests/ui/modulo_one.stderr", "status": "modified", "additions": 49, "deletions": 5, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a644930b25574f4d06241243d436dc5c348ddbe3/tests%2Fui%2Fmodulo_one.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a644930b25574f4d06241243d436dc5c348ddbe3/tests%2Fui%2Fmodulo_one.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmodulo_one.stderr?ref=a644930b25574f4d06241243d436dc5c348ddbe3", "patch": "@@ -1,30 +1,74 @@\n+error: this arithmetic operation will overflow\n+  --> $DIR/modulo_one.rs:11:5\n+   |\n+LL |     i32::MIN % (-1); // also caught by rustc\n+   |     ^^^^^^^^^^^^^^^ attempt to compute the remainder of `i32::MIN % -1_i32`, which would overflow\n+   |\n+   = note: `#[deny(arithmetic_overflow)]` on by default\n+\n+error: this arithmetic operation will overflow\n+  --> $DIR/modulo_one.rs:21:5\n+   |\n+LL |     INT_MIN % NEG_ONE; // also caught by rustc\n+   |     ^^^^^^^^^^^^^^^^^ attempt to compute the remainder of `i64::MIN % -1_i64`, which would overflow\n+\n+error: this arithmetic operation will overflow\n+  --> $DIR/modulo_one.rs:22:5\n+   |\n+LL |     INT_MIN % STATIC_NEG_ONE; // ONLY caught by rustc\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^ attempt to compute the remainder of `i64::MIN % -1_i64`, which would overflow\n+\n error: any number modulo 1 will be 0\n-  --> $DIR/modulo_one.rs:7:5\n+  --> $DIR/modulo_one.rs:8:5\n    |\n LL |     10 % 1;\n    |     ^^^^^^\n    |\n    = note: `-D clippy::modulo-one` implied by `-D warnings`\n \n+error: any number modulo -1 will panic/overflow or result in 0\n+  --> $DIR/modulo_one.rs:9:5\n+   |\n+LL |     10 % -1;\n+   |     ^^^^^^^\n+\n+error: any number modulo -1 will panic/overflow or result in 0\n+  --> $DIR/modulo_one.rs:11:5\n+   |\n+LL |     i32::MIN % (-1); // also caught by rustc\n+   |     ^^^^^^^^^^^^^^^\n+\n error: the operation is ineffective. Consider reducing it to `1`\n-  --> $DIR/modulo_one.rs:10:22\n+  --> $DIR/modulo_one.rs:13:22\n    |\n LL |     const ONE: u32 = 1 * 1;\n    |                      ^^^^^\n    |\n    = note: `-D clippy::identity-op` implied by `-D warnings`\n \n error: the operation is ineffective. Consider reducing it to `1`\n-  --> $DIR/modulo_one.rs:10:22\n+  --> $DIR/modulo_one.rs:13:22\n    |\n LL |     const ONE: u32 = 1 * 1;\n    |                      ^^^^^\n \n error: any number modulo 1 will be 0\n-  --> $DIR/modulo_one.rs:12:5\n+  --> $DIR/modulo_one.rs:17:5\n    |\n LL |     2 % ONE;\n    |     ^^^^^^^\n \n-error: aborting due to 4 previous errors\n+error: any number modulo -1 will panic/overflow or result in 0\n+  --> $DIR/modulo_one.rs:19:5\n+   |\n+LL |     2 % NEG_ONE;\n+   |     ^^^^^^^^^^^\n+\n+error: any number modulo -1 will panic/overflow or result in 0\n+  --> $DIR/modulo_one.rs:21:5\n+   |\n+LL |     INT_MIN % NEG_ONE; // also caught by rustc\n+   |     ^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 11 previous errors\n "}]}