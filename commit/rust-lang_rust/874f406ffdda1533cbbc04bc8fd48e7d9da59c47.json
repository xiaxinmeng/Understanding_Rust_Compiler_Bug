{"sha": "874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3NGY0MDZmZmRkYTE1MzNjYmJjMDRiYzhmZDQ4ZTdkOWRhNTljNDc=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-06-25T20:41:36Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-07-02T21:04:48Z"}, "message": "Use 'tcx for references to AccessLevels wherever possible.", "tree": {"sha": "568c2521ac3216572c69ad7bb361c958e34f3e98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/568c2521ac3216572c69ad7bb361c958e34f3e98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "html_url": "https://github.com/rust-lang/rust/commit/874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3503f565e1fb7296983757d2716346f48a4a262b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3503f565e1fb7296983757d2716346f48a4a262b", "html_url": "https://github.com/rust-lang/rust/commit/3503f565e1fb7296983757d2716346f48a4a262b"}], "stats": {"total": 2410, "additions": 1143, "deletions": 1267}, "files": [{"sha": "31faad3368fdbe93025608b45bd6937e9ab1d867", "filename": "src/librustc_lint/array_into_iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_lint%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_lint%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Farray_into_iter.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -21,8 +21,8 @@ declare_lint_pass!(\n     ArrayIntoIter => [ARRAY_INTO_ITER]\n );\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIntoIter {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'tcx>) {\n+impl<'tcx> LateLintPass<'tcx> for ArrayIntoIter {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'tcx>) {\n         // We only care about method call expressions.\n         if let hir::ExprKind::MethodCall(call, span, args, _) = &expr.kind {\n             if call.ident.name != sym::into_iter {"}, {"sha": "75e8d1cebdb8af12dc7e818151e34e7956b21748", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 53, "deletions": 61, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -104,7 +104,7 @@ declare_lint! {\n declare_lint_pass!(BoxPointers => [BOX_POINTERS]);\n \n impl BoxPointers {\n-    fn check_heap_type(&self, cx: &LateContext<'_, '_>, span: Span, ty: Ty<'_>) {\n+    fn check_heap_type(&self, cx: &LateContext<'_>, span: Span, ty: Ty<'_>) {\n         for leaf in ty.walk() {\n             if let GenericArgKind::Type(leaf_ty) = leaf.unpack() {\n                 if leaf_ty.is_box() {\n@@ -117,8 +117,8 @@ impl BoxPointers {\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for BoxPointers {\n+    fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n         match it.kind {\n             hir::ItemKind::Fn(..)\n             | hir::ItemKind::TyAlias(..)\n@@ -143,7 +143,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, e: &hir::Expr<'_>) {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, e: &hir::Expr<'_>) {\n         let ty = cx.tables().node_type(e.hir_id);\n         self.check_heap_type(cx, e.span, ty);\n     }\n@@ -157,8 +157,8 @@ declare_lint! {\n \n declare_lint_pass!(NonShorthandFieldPatterns => [NON_SHORTHAND_FIELD_PATTERNS]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n-    fn check_pat(&mut self, cx: &LateContext<'_, '_>, pat: &hir::Pat<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for NonShorthandFieldPatterns {\n+    fn check_pat(&mut self, cx: &LateContext<'_>, pat: &hir::Pat<'_>) {\n         if let PatKind::Struct(ref qpath, field_pats, _) = pat.kind {\n             let variant = cx\n                 .tables()\n@@ -348,7 +348,7 @@ impl MissingDoc {\n \n     fn check_missing_docs_attrs(\n         &self,\n-        cx: &LateContext<'_, '_>,\n+        cx: &LateContext<'_>,\n         id: Option<hir::HirId>,\n         attrs: &[ast::Attribute],\n         sp: Span,\n@@ -388,8 +388,8 @@ impl MissingDoc {\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n-    fn enter_lint_attrs(&mut self, _: &LateContext<'_, '_>, attrs: &[ast::Attribute]) {\n+impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n+    fn enter_lint_attrs(&mut self, _: &LateContext<'_>, attrs: &[ast::Attribute]) {\n         let doc_hidden = self.doc_hidden()\n             || attrs.iter().any(|attr| {\n                 attr.check_name(sym::doc)\n@@ -401,11 +401,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         self.doc_hidden_stack.push(doc_hidden);\n     }\n \n-    fn exit_lint_attrs(&mut self, _: &LateContext<'_, '_>, _attrs: &[ast::Attribute]) {\n+    fn exit_lint_attrs(&mut self, _: &LateContext<'_>, _attrs: &[ast::Attribute]) {\n         self.doc_hidden_stack.pop().expect(\"empty doc_hidden_stack\");\n     }\n \n-    fn check_crate(&mut self, cx: &LateContext<'_, '_>, krate: &hir::Crate<'_>) {\n+    fn check_crate(&mut self, cx: &LateContext<'_>, krate: &hir::Crate<'_>) {\n         self.check_missing_docs_attrs(cx, None, &krate.item.attrs, krate.item.span, \"the\", \"crate\");\n \n         for macro_def in krate.exported_macros {\n@@ -420,7 +420,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         }\n     }\n \n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item<'_>) {\n+    fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n         match it.kind {\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n                 // Issue #11592: traits are always considered exported, even when private.\n@@ -467,7 +467,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         self.check_missing_docs_attrs(cx, Some(it.hir_id), &it.attrs, it.span, article, desc);\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext<'_, '_>, trait_item: &hir::TraitItem<'_>) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'_>, trait_item: &hir::TraitItem<'_>) {\n         if self.private_traits.contains(&trait_item.hir_id) {\n             return;\n         }\n@@ -485,7 +485,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         );\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext<'_, '_>, impl_item: &hir::ImplItem<'_>) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n         // If the method is an impl for a trait, don't doc.\n         if method_context(cx, impl_item.hir_id) == MethodLateContext::TraitImpl {\n             return;\n@@ -503,7 +503,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         );\n     }\n \n-    fn check_struct_field(&mut self, cx: &LateContext<'_, '_>, sf: &hir::StructField<'_>) {\n+    fn check_struct_field(&mut self, cx: &LateContext<'_>, sf: &hir::StructField<'_>) {\n         if !sf.is_positional() {\n             self.check_missing_docs_attrs(\n                 cx,\n@@ -516,7 +516,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         }\n     }\n \n-    fn check_variant(&mut self, cx: &LateContext<'_, '_>, v: &hir::Variant<'_>) {\n+    fn check_variant(&mut self, cx: &LateContext<'_>, v: &hir::Variant<'_>) {\n         self.check_missing_docs_attrs(cx, Some(v.id), &v.attrs, v.span, \"a\", \"variant\");\n     }\n }\n@@ -529,8 +529,8 @@ declare_lint! {\n \n declare_lint_pass!(MissingCopyImplementations => [MISSING_COPY_IMPLEMENTATIONS]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n         if !cx.access_levels.is_reachable(item.hir_id) {\n             return;\n         }\n@@ -590,8 +590,8 @@ pub struct MissingDebugImplementations {\n \n impl_lint_pass!(MissingDebugImplementations => [MISSING_DEBUG_IMPLEMENTATIONS]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n         if !cx.access_levels.is_reachable(item.hir_id) {\n             return;\n         }\n@@ -813,8 +813,8 @@ declare_lint! {\n \n declare_lint_pass!(InvalidNoMangleItems => [NO_MANGLE_CONST_ITEMS, NO_MANGLE_GENERIC_ITEMS]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n+    fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n         match it.kind {\n             hir::ItemKind::Fn(.., ref generics, _) => {\n                 if let Some(no_mangle_attr) = attr::find_by_name(&it.attrs, sym::no_mangle) {\n@@ -883,8 +883,8 @@ declare_lint! {\n \n declare_lint_pass!(MutableTransmutes => [MUTABLE_TRANSMUTES]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for MutableTransmutes {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &hir::Expr<'_>) {\n         use rustc_target::spec::abi::Abi::RustIntrinsic;\n         if let Some((&ty::Ref(_, _, from_mt), &ty::Ref(_, _, to_mt))) =\n             get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (&ty1.kind, &ty2.kind))\n@@ -896,8 +896,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n             }\n         }\n \n-        fn get_transmute_from_to<'a, 'tcx>(\n-            cx: &LateContext<'a, 'tcx>,\n+        fn get_transmute_from_to<'tcx>(\n+            cx: &LateContext<'tcx>,\n             expr: &hir::Expr<'_>,\n         ) -> Option<(Ty<'tcx>, Ty<'tcx>)> {\n             let def = if let hir::ExprKind::Path(ref qpath) = expr.kind {\n@@ -917,7 +917,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n             None\n         }\n \n-        fn def_id_is_transmute(cx: &LateContext<'_, '_>, def_id: DefId) -> bool {\n+        fn def_id_is_transmute(cx: &LateContext<'_>, def_id: DefId) -> bool {\n             cx.tcx.fn_sig(def_id).abi() == RustIntrinsic\n                 && cx.tcx.item_name(def_id) == sym::transmute\n         }\n@@ -935,8 +935,8 @@ declare_lint_pass!(\n     UnstableFeatures => [UNSTABLE_FEATURES]\n );\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnstableFeatures {\n-    fn check_attribute(&mut self, ctx: &LateContext<'_, '_>, attr: &ast::Attribute) {\n+impl<'tcx> LateLintPass<'tcx> for UnstableFeatures {\n+    fn check_attribute(&mut self, ctx: &LateContext<'_>, attr: &ast::Attribute) {\n         if attr.check_name(sym::feature) {\n             if let Some(items) = attr.meta_item_list() {\n                 for item in items {\n@@ -963,7 +963,7 @@ declare_lint_pass!(\n impl UnreachablePub {\n     fn perform_lint(\n         &self,\n-        cx: &LateContext<'_, '_>,\n+        cx: &LateContext<'_>,\n         what: &str,\n         id: hir::HirId,\n         vis: &hir::Visibility<'_>,\n@@ -1003,16 +1003,12 @@ impl UnreachablePub {\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnreachablePub {\n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for UnreachablePub {\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n         self.perform_lint(cx, \"item\", item.hir_id, &item.vis, item.span, true);\n     }\n \n-    fn check_foreign_item(\n-        &mut self,\n-        cx: &LateContext<'_, '_>,\n-        foreign_item: &hir::ForeignItem<'tcx>,\n-    ) {\n+    fn check_foreign_item(&mut self, cx: &LateContext<'_>, foreign_item: &hir::ForeignItem<'tcx>) {\n         self.perform_lint(\n             cx,\n             \"item\",\n@@ -1023,11 +1019,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnreachablePub {\n         );\n     }\n \n-    fn check_struct_field(&mut self, cx: &LateContext<'_, '_>, field: &hir::StructField<'_>) {\n+    fn check_struct_field(&mut self, cx: &LateContext<'_>, field: &hir::StructField<'_>) {\n         self.perform_lint(cx, \"field\", field.hir_id, &field.vis, field.span, false);\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext<'_, '_>, impl_item: &hir::ImplItem<'_>) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n         self.perform_lint(cx, \"item\", impl_item.hir_id, &impl_item.vis, impl_item.span, false);\n     }\n }\n@@ -1096,8 +1092,8 @@ impl TypeAliasBounds {\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeAliasBounds {\n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for TypeAliasBounds {\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n         let (ty, type_alias_generics) = match item.kind {\n             hir::ItemKind::TyAlias(ref ty, ref generics) => (&*ty, generics),\n             _ => return,\n@@ -1170,15 +1166,15 @@ declare_lint_pass!(\n     UnusedBrokenConst => []\n );\n \n-fn check_const(cx: &LateContext<'_, '_>, body_id: hir::BodyId) {\n+fn check_const(cx: &LateContext<'_>, body_id: hir::BodyId) {\n     let def_id = cx.tcx.hir().body_owner_def_id(body_id).to_def_id();\n     // trigger the query once for all constants since that will already report the errors\n     // FIXME: Use ensure here\n     let _ = cx.tcx.const_eval_poly(def_id);\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedBrokenConst {\n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for UnusedBrokenConst {\n+    fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n         match it.kind {\n             hir::ItemKind::Const(_, body_id) => {\n                 check_const(cx, body_id);\n@@ -1203,8 +1199,8 @@ declare_lint_pass!(\n     TrivialConstraints => [TRIVIAL_BOUNDS]\n );\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TrivialConstraints {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item<'tcx>) {\n+impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         use rustc_middle::ty::fold::TypeFoldable;\n         use rustc_middle::ty::PredicateKind::*;\n \n@@ -1372,8 +1368,8 @@ impl UnnameableTestItems {\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestItems {\n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for UnnameableTestItems {\n+    fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n         if self.items_nameable {\n             if let hir::ItemKind::Mod(..) = it.kind {\n             } else {\n@@ -1390,7 +1386,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestItems {\n         }\n     }\n \n-    fn check_item_post(&mut self, _cx: &LateContext<'_, '_>, it: &hir::Item<'_>) {\n+    fn check_item_post(&mut self, _cx: &LateContext<'_>, it: &hir::Item<'_>) {\n         if !self.items_nameable && self.boundary == Some(it.hir_id) {\n             self.items_nameable = true;\n         }\n@@ -1639,8 +1635,8 @@ impl ExplicitOutlivesRequirements {\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n         use rustc_middle::middle::resolve_lifetime::Region;\n \n         let infer_static = cx.tcx.features().infer_static_outlives_requirements;\n@@ -1850,8 +1846,8 @@ declare_lint! {\n \n declare_lint_pass!(InvalidValue => [INVALID_VALUE]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &hir::Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &hir::Expr<'_>) {\n         #[derive(Debug, Copy, Clone, PartialEq)]\n         enum InitKind {\n             Zeroed,\n@@ -1880,7 +1876,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n         }\n \n         /// Determine if this expression is a \"dangerous initialization\".\n-        fn is_dangerous_init(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) -> Option<InitKind> {\n+        fn is_dangerous_init(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<InitKind> {\n             // `transmute` is inside an anonymous module (the `extern` block?);\n             // `Invalid` represents the empty string and matches that.\n             // FIXME(#66075): use diagnostic items.  Somehow, that does not seem to work\n@@ -2134,11 +2130,7 @@ impl ClashingExternDeclarations {\n     /// Checks whether two types are structurally the same enough that the declarations shouldn't\n     /// clash. We need this so we don't emit a lint when two modules both declare an extern struct,\n     /// with the same members (as the declarations shouldn't clash).\n-    fn structurally_same_type<'a, 'tcx>(\n-        cx: &LateContext<'a, 'tcx>,\n-        a: Ty<'tcx>,\n-        b: Ty<'tcx>,\n-    ) -> bool {\n+    fn structurally_same_type<'tcx>(cx: &LateContext<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n         let tcx = cx.tcx;\n         if a == b || rustc_middle::ty::TyS::same_type(a, b) {\n             // All nominally-same types are structurally same, too.\n@@ -2212,8 +2204,8 @@ impl ClashingExternDeclarations {\n \n impl_lint_pass!(ClashingExternDeclarations => [CLASHING_EXTERN_DECLARATIONS]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ClashingExternDeclarations {\n-    fn check_foreign_item(&mut self, cx: &LateContext<'a, 'tcx>, this_fi: &hir::ForeignItem<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for ClashingExternDeclarations {\n+    fn check_foreign_item(&mut self, cx: &LateContext<'tcx>, this_fi: &hir::ForeignItem<'_>) {\n         trace!(\"ClashingExternDeclarations: check_foreign_item: {:?}\", this_fi);\n         if let ForeignItemKind::Fn(..) = this_fi.kind {\n             let tcx = *&cx.tcx;"}, {"sha": "edbeea6db41cdbb2b5859bca9735a51203538270", "filename": "src/librustc_lint/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_lint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_lint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fcontext.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -421,7 +421,7 @@ impl LintStore {\n }\n \n /// Context for lint checking after type checking.\n-pub struct LateContext<'a, 'tcx> {\n+pub struct LateContext<'tcx> {\n     /// Type context we're checking in.\n     pub tcx: TyCtxt<'tcx>,\n \n@@ -438,7 +438,7 @@ pub struct LateContext<'a, 'tcx> {\n     pub param_env: ty::ParamEnv<'tcx>,\n \n     /// Items accessible from the crate being checked.\n-    pub access_levels: &'a AccessLevels,\n+    pub access_levels: &'tcx AccessLevels,\n \n     /// The store of registered lints and the lint levels.\n     pub lint_store: &'tcx LintStore,\n@@ -624,7 +624,7 @@ impl<'a> EarlyContext<'a> {\n     }\n }\n \n-impl LintContext for LateContext<'_, '_> {\n+impl LintContext for LateContext<'_> {\n     type PassObject = LateLintPassObject;\n \n     /// Gets the overall compiler `Session` object.\n@@ -673,7 +673,7 @@ impl LintContext for EarlyContext<'_> {\n     }\n }\n \n-impl<'a, 'tcx> LateContext<'a, 'tcx> {\n+impl<'tcx> LateContext<'tcx> {\n     /// Gets the type-checking side-tables for the current body,\n     /// or `None` if outside a body.\n     pub fn maybe_typeck_tables(&self) -> Option<&'tcx ty::TypeckTables<'tcx>> {\n@@ -849,7 +849,7 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> LayoutOf for LateContext<'a, 'tcx> {\n+impl<'tcx> LayoutOf for LateContext<'tcx> {\n     type Ty = Ty<'tcx>;\n     type TyAndLayout = Result<TyAndLayout<'tcx>, LayoutError<'tcx>>;\n "}, {"sha": "30fae32439292fc89048b57a9d1cd6c0cf29104a", "filename": "src/librustc_lint/internal.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_lint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_lint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Finternal.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -84,8 +84,8 @@ declare_lint_pass!(TyTyKind => [\n     USAGE_OF_QUALIFIED_TY,\n ]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n-    fn check_path(&mut self, cx: &LateContext<'_, '_>, path: &'tcx Path<'tcx>, _: HirId) {\n+impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n+    fn check_path(&mut self, cx: &LateContext<'_>, path: &'tcx Path<'tcx>, _: HirId) {\n         let segments = path.segments.iter().rev().skip(1).rev();\n \n         if let Some(last) = segments.last() {\n@@ -105,7 +105,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n         }\n     }\n \n-    fn check_ty(&mut self, cx: &LateContext<'_, '_>, ty: &'tcx Ty<'tcx>) {\n+    fn check_ty(&mut self, cx: &LateContext<'_>, ty: &'tcx Ty<'tcx>) {\n         match &ty.kind {\n             TyKind::Path(qpath) => {\n                 if let QPath::Resolved(_, path) = qpath {\n@@ -164,7 +164,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n     }\n }\n \n-fn lint_ty_kind_usage(cx: &LateContext<'_, '_>, segment: &PathSegment<'_>) -> bool {\n+fn lint_ty_kind_usage(cx: &LateContext<'_>, segment: &PathSegment<'_>) -> bool {\n     if let Some(res) = segment.res {\n         if let Some(did) = res.opt_def_id() {\n             return cx.tcx.is_diagnostic_item(sym::TyKind, did);\n@@ -174,7 +174,7 @@ fn lint_ty_kind_usage(cx: &LateContext<'_, '_>, segment: &PathSegment<'_>) -> bo\n     false\n }\n \n-fn is_ty_or_ty_ctxt(cx: &LateContext<'_, '_>, ty: &Ty<'_>) -> Option<String> {\n+fn is_ty_or_ty_ctxt(cx: &LateContext<'_>, ty: &Ty<'_>) -> Option<String> {\n     if let TyKind::Path(qpath) = &ty.kind {\n         if let QPath::Resolved(_, path) = qpath {\n             let did = path.res.opt_def_id()?;"}, {"sha": "5feb17af24f7cce740c99dacf6cd44a029288c4b", "filename": "src/librustc_lint/late.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_lint%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_lint%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flate.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -44,12 +44,12 @@ macro_rules! lint_callback { ($cx:expr, $f:ident, $($args:expr),*) => ({\n     $cx.pass.$f(&$cx.context, $($args),*);\n }) }\n \n-struct LateContextAndPass<'a, 'tcx, T: LateLintPass<'a, 'tcx>> {\n-    context: LateContext<'a, 'tcx>,\n+struct LateContextAndPass<'tcx, T: LateLintPass<'tcx>> {\n+    context: LateContext<'tcx>,\n     pass: T,\n }\n \n-impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> LateContextAndPass<'a, 'tcx, T> {\n+impl<'tcx, T: LateLintPass<'tcx>> LateContextAndPass<'tcx, T> {\n     /// Merge the lints specified by any lint attributes into the\n     /// current lint context, call the provided function, then reset the\n     /// lints in effect to their previous state.\n@@ -93,9 +93,7 @@ impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> LateContextAndPass<'a, 'tcx, T> {\n     }\n }\n \n-impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n-    for LateContextAndPass<'a, 'tcx, T>\n-{\n+impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPass<'tcx, T> {\n     type Map = Map<'tcx>;\n \n     /// Because lints are scoped lexically, we want to walk nested\n@@ -348,8 +346,8 @@ impl LintPass for LateLintPassObjects<'_> {\n }\n \n macro_rules! expand_late_lint_pass_impl_methods {\n-    ([$a:tt, $hir:tt], [$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n-        $(fn $name(&mut self, context: &LateContext<$a, $hir>, $($param: $arg),*) {\n+    ([$hir:tt], [$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n+        $(fn $name(&mut self, context: &LateContext<$hir>, $($param: $arg),*) {\n             for obj in self.lints.iter_mut() {\n                 obj.$name(context, $($param),*);\n             }\n@@ -358,16 +356,16 @@ macro_rules! expand_late_lint_pass_impl_methods {\n }\n \n macro_rules! late_lint_pass_impl {\n-    ([], [$hir:tt], $methods:tt) => (\n-        impl<'a, $hir> LateLintPass<'a, $hir> for LateLintPassObjects<'_> {\n-            expand_late_lint_pass_impl_methods!(['a, $hir], $methods);\n+    ([], [$hir:tt], $methods:tt) => {\n+        impl<$hir> LateLintPass<$hir> for LateLintPassObjects<'_> {\n+            expand_late_lint_pass_impl_methods!([$hir], $methods);\n         }\n-    )\n+    };\n }\n \n crate::late_lint_methods!(late_lint_pass_impl, [], ['tcx]);\n \n-fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n+fn late_lint_mod_pass<'tcx, T: LateLintPass<'tcx>>(\n     tcx: TyCtxt<'tcx>,\n     module_def_id: LocalDefId,\n     pass: T,\n@@ -397,7 +395,7 @@ fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n     }\n }\n \n-pub fn late_lint_mod<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n+pub fn late_lint_mod<'tcx, T: LateLintPass<'tcx>>(\n     tcx: TyCtxt<'tcx>,\n     module_def_id: LocalDefId,\n     builtin_lints: T,\n@@ -417,7 +415,7 @@ pub fn late_lint_mod<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n     }\n }\n \n-fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, pass: T) {\n+fn late_lint_pass_crate<'tcx, T: LateLintPass<'tcx>>(tcx: TyCtxt<'tcx>, pass: T) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n     let krate = tcx.hir().krate();\n@@ -448,7 +446,7 @@ fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tc\n     })\n }\n \n-fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, builtin_lints: T) {\n+fn late_lint_crate<'tcx, T: LateLintPass<'tcx>>(tcx: TyCtxt<'tcx>, builtin_lints: T) {\n     let mut passes = unerased_lint_store(tcx).late_passes.iter().map(|p| (p)()).collect::<Vec<_>>();\n \n     if !tcx.sess.opts.debugging_opts.no_interleave_lints {\n@@ -478,7 +476,7 @@ fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, b\n }\n \n /// Performs lint checking on a crate.\n-pub fn check_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n+pub fn check_crate<'tcx, T: LateLintPass<'tcx>>(\n     tcx: TyCtxt<'tcx>,\n     builtin_lints: impl FnOnce() -> T + Send,\n ) {"}, {"sha": "dc6b8670498c21079c7f6dae1ed25491f0a09138", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -18,7 +18,7 @@ pub enum MethodLateContext {\n     PlainImpl,\n }\n \n-pub fn method_context(cx: &LateContext<'_, '_>, id: hir::HirId) -> MethodLateContext {\n+pub fn method_context(cx: &LateContext<'_>, id: hir::HirId) -> MethodLateContext {\n     let def_id = cx.tcx.hir().local_def_id(id);\n     let item = cx.tcx.associated_item(def_id);\n     match item.container {\n@@ -200,7 +200,7 @@ impl NonSnakeCase {\n     }\n \n     /// Checks if a given identifier is snake case, and reports a diagnostic if not.\n-    fn check_snake_case(&self, cx: &LateContext<'_, '_>, sort: &str, ident: &Ident) {\n+    fn check_snake_case(&self, cx: &LateContext<'_>, sort: &str, ident: &Ident) {\n         fn is_snake_case(ident: &str) -> bool {\n             if ident.is_empty() {\n                 return true;\n@@ -248,10 +248,10 @@ impl NonSnakeCase {\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n+impl<'tcx> LateLintPass<'tcx> for NonSnakeCase {\n     fn check_mod(\n         &mut self,\n-        cx: &LateContext<'_, '_>,\n+        cx: &LateContext<'_>,\n         _: &'tcx hir::Mod<'tcx>,\n         _: Span,\n         id: hir::HirId,\n@@ -300,15 +300,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         }\n     }\n \n-    fn check_generic_param(&mut self, cx: &LateContext<'_, '_>, param: &hir::GenericParam<'_>) {\n+    fn check_generic_param(&mut self, cx: &LateContext<'_>, param: &hir::GenericParam<'_>) {\n         if let GenericParamKind::Lifetime { .. } = param.kind {\n             self.check_snake_case(cx, \"lifetime\", &param.name.ident());\n         }\n     }\n \n     fn check_fn(\n         &mut self,\n-        cx: &LateContext<'_, '_>,\n+        cx: &LateContext<'_>,\n         fk: FnKind<'_>,\n         _: &hir::FnDecl<'_>,\n         _: &hir::Body<'_>,\n@@ -336,13 +336,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         }\n     }\n \n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item<'_>) {\n+    fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n         if let hir::ItemKind::Mod(_) = it.kind {\n             self.check_snake_case(cx, \"module\", &it.ident);\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::TraitItem<'_>) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'_>, item: &hir::TraitItem<'_>) {\n         if let hir::TraitItemKind::Fn(_, hir::TraitFn::Required(pnames)) = item.kind {\n             self.check_snake_case(cx, \"trait method\", &item.ident);\n             for param_name in pnames {\n@@ -351,7 +351,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         }\n     }\n \n-    fn check_pat(&mut self, cx: &LateContext<'_, '_>, p: &hir::Pat<'_>) {\n+    fn check_pat(&mut self, cx: &LateContext<'_>, p: &hir::Pat<'_>) {\n         if let &PatKind::Binding(_, hid, ident, _) = &p.kind {\n             if let hir::Node::Pat(parent_pat) = cx.tcx.hir().get(cx.tcx.hir().get_parent_node(hid))\n             {\n@@ -370,7 +370,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         }\n     }\n \n-    fn check_struct_def(&mut self, cx: &LateContext<'_, '_>, s: &hir::VariantData<'_>) {\n+    fn check_struct_def(&mut self, cx: &LateContext<'_>, s: &hir::VariantData<'_>) {\n         for sf in s.fields() {\n             self.check_snake_case(cx, \"structure field\", &sf.ident);\n         }\n@@ -386,7 +386,7 @@ declare_lint! {\n declare_lint_pass!(NonUpperCaseGlobals => [NON_UPPER_CASE_GLOBALS]);\n \n impl NonUpperCaseGlobals {\n-    fn check_upper_case(cx: &LateContext<'_, '_>, sort: &str, ident: &Ident) {\n+    fn check_upper_case(cx: &LateContext<'_>, sort: &str, ident: &Ident) {\n         let name = &ident.name.as_str();\n         if name.chars().any(|c| c.is_lowercase()) {\n             cx.struct_span_lint(NON_UPPER_CASE_GLOBALS, ident.span, |lint| {\n@@ -404,8 +404,8 @@ impl NonUpperCaseGlobals {\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for NonUpperCaseGlobals {\n+    fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n         match it.kind {\n             hir::ItemKind::Static(..) if !attr::contains_name(&it.attrs, sym::no_mangle) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"static variable\", &it.ident);\n@@ -417,19 +417,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext<'_, '_>, ti: &hir::TraitItem<'_>) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'_>, ti: &hir::TraitItem<'_>) {\n         if let hir::TraitItemKind::Const(..) = ti.kind {\n             NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\", &ti.ident);\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext<'_, '_>, ii: &hir::ImplItem<'_>) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'_>, ii: &hir::ImplItem<'_>) {\n         if let hir::ImplItemKind::Const(..) = ii.kind {\n             NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\", &ii.ident);\n         }\n     }\n \n-    fn check_pat(&mut self, cx: &LateContext<'_, '_>, p: &hir::Pat<'_>) {\n+    fn check_pat(&mut self, cx: &LateContext<'_>, p: &hir::Pat<'_>) {\n         // Lint for constants that look like binding identifiers (#7526)\n         if let PatKind::Path(hir::QPath::Resolved(None, ref path)) = p.kind {\n             if let Res::Def(DefKind::Const, _) = path.res {\n@@ -444,7 +444,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n         }\n     }\n \n-    fn check_generic_param(&mut self, cx: &LateContext<'_, '_>, param: &hir::GenericParam<'_>) {\n+    fn check_generic_param(&mut self, cx: &LateContext<'_>, param: &hir::GenericParam<'_>) {\n         if let GenericParamKind::Const { .. } = param.kind {\n             NonUpperCaseGlobals::check_upper_case(cx, \"const parameter\", &param.name.ident());\n         }"}, {"sha": "75e50f74a819ae2b75517345c236f2fc651de060", "filename": "src/librustc_lint/passes.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_lint%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_lint%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fpasses.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -90,15 +90,15 @@ macro_rules! expand_lint_pass_methods {\n \n macro_rules! declare_late_lint_pass {\n     ([], [$hir:tt], [$($methods:tt)*]) => (\n-        pub trait LateLintPass<'a, $hir>: LintPass {\n-            expand_lint_pass_methods!(&LateContext<'a, $hir>, [$($methods)*]);\n+        pub trait LateLintPass<$hir>: LintPass {\n+            expand_lint_pass_methods!(&LateContext<$hir>, [$($methods)*]);\n         }\n     )\n }\n \n late_lint_methods!(declare_late_lint_pass, [], ['tcx]);\n \n-impl LateLintPass<'_, '_> for HardwiredLints {}\n+impl LateLintPass<'_> for HardwiredLints {}\n \n #[macro_export]\n macro_rules! expand_combined_late_lint_pass_method {\n@@ -110,7 +110,7 @@ macro_rules! expand_combined_late_lint_pass_method {\n #[macro_export]\n macro_rules! expand_combined_late_lint_pass_methods {\n     ($passes:tt, [$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n-        $(fn $name(&mut self, context: &LateContext<'a, 'tcx>, $($param: $arg),*) {\n+        $(fn $name(&mut self, context: &LateContext<'tcx>, $($param: $arg),*) {\n             expand_combined_late_lint_pass_method!($passes, self, $name, (context, $($param),*));\n         })*\n     )\n@@ -138,7 +138,7 @@ macro_rules! declare_combined_late_lint_pass {\n             }\n         }\n \n-        impl<'a, 'tcx> LateLintPass<'a, 'tcx> for $name {\n+        impl<'tcx> LateLintPass<'tcx> for $name {\n             expand_combined_late_lint_pass_methods!([$($passes),*], $methods);\n         }\n \n@@ -282,4 +282,4 @@ macro_rules! declare_combined_early_lint_pass {\n /// A lint pass boxed up as a trait object.\n pub type EarlyLintPassObject = Box<dyn EarlyLintPass + sync::Send + sync::Sync + 'static>;\n pub type LateLintPassObject =\n-    Box<dyn for<'a, 'tcx> LateLintPass<'a, 'tcx> + sync::Send + sync::Sync + 'static>;\n+    Box<dyn for<'tcx> LateLintPass<'tcx> + sync::Send + sync::Sync + 'static>;"}, {"sha": "b3015dcc2aee87df5e55b178bcfddeb1d7056a87", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -55,8 +55,8 @@ impl TypeLimits {\n \n /// Attempts to special-case the overflowing literal lint when it occurs as a range endpoint.\n /// Returns `true` iff the lint was overridden.\n-fn lint_overflowing_range_endpoint<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn lint_overflowing_range_endpoint<'tcx>(\n+    cx: &LateContext<'tcx>,\n     lit: &hir::Lit,\n     lit_val: u128,\n     max: u128,\n@@ -127,7 +127,7 @@ fn uint_ty_range(uint_ty: ast::UintTy) -> (u128, u128) {\n     }\n }\n \n-fn get_bin_hex_repr(cx: &LateContext<'_, '_>, lit: &hir::Lit) -> Option<String> {\n+fn get_bin_hex_repr(cx: &LateContext<'_>, lit: &hir::Lit) -> Option<String> {\n     let src = cx.sess().source_map().span_to_snippet(lit.span).ok()?;\n     let firstch = src.chars().next()?;\n \n@@ -142,7 +142,7 @@ fn get_bin_hex_repr(cx: &LateContext<'_, '_>, lit: &hir::Lit) -> Option<String>\n }\n \n fn report_bin_hex_error(\n-    cx: &LateContext<'_, '_>,\n+    cx: &LateContext<'_>,\n     expr: &hir::Expr<'_>,\n     ty: attr::IntType,\n     repr_str: String,\n@@ -233,8 +233,8 @@ fn get_type_suggestion(t: Ty<'_>, val: u128, negative: bool) -> Option<&'static\n     }\n }\n \n-fn lint_int_literal<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn lint_int_literal<'tcx>(\n+    cx: &LateContext<'tcx>,\n     type_limits: &TypeLimits,\n     e: &'tcx hir::Expr<'tcx>,\n     lit: &hir::Lit,\n@@ -283,8 +283,8 @@ fn lint_int_literal<'a, 'tcx>(\n     }\n }\n \n-fn lint_uint_literal<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn lint_uint_literal<'tcx>(\n+    cx: &LateContext<'tcx>,\n     e: &'tcx hir::Expr<'tcx>,\n     lit: &hir::Lit,\n     t: ast::UintTy,\n@@ -347,8 +347,8 @@ fn lint_uint_literal<'a, 'tcx>(\n     }\n }\n \n-fn lint_literal<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn lint_literal<'tcx>(\n+    cx: &LateContext<'tcx>,\n     type_limits: &TypeLimits,\n     e: &'tcx hir::Expr<'tcx>,\n     lit: &hir::Lit,\n@@ -391,8 +391,8 @@ fn lint_literal<'a, 'tcx>(\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr<'tcx>) {\n+impl<'tcx> LateLintPass<'tcx> for TypeLimits {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx hir::Expr<'tcx>) {\n         match e.kind {\n             hir::ExprKind::Unary(hir::UnOp::UnNeg, ref expr) => {\n                 // propagate negation, if the negation itself isn't negated\n@@ -436,7 +436,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n         }\n \n         fn check_limits(\n-            cx: &LateContext<'_, '_>,\n+            cx: &LateContext<'_>,\n             binop: hir::BinOp,\n             l: &hir::Expr<'_>,\n             r: &hir::Expr<'_>,\n@@ -515,7 +515,7 @@ enum ImproperCTypesMode {\n }\n \n struct ImproperCTypesVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     mode: ImproperCTypesMode,\n }\n \n@@ -939,7 +939,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n     fn check_for_opaque_ty(&mut self, sp: Span, ty: Ty<'tcx>) -> bool {\n         struct ProhibitOpaqueTypes<'a, 'tcx> {\n-            cx: &'a LateContext<'a, 'tcx>,\n+            cx: &'a LateContext<'tcx>,\n             ty: Option<Ty<'tcx>>,\n         };\n \n@@ -1050,8 +1050,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImproperCTypesDeclarations {\n-    fn check_foreign_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::ForeignItem<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for ImproperCTypesDeclarations {\n+    fn check_foreign_item(&mut self, cx: &LateContext<'_>, it: &hir::ForeignItem<'_>) {\n         let mut vis = ImproperCTypesVisitor { cx, mode: ImproperCTypesMode::Declarations };\n         let abi = cx.tcx.hir().get_foreign_abi(it.hir_id);\n \n@@ -1069,10 +1069,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImproperCTypesDeclarations {\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImproperCTypesDefinitions {\n+impl<'tcx> LateLintPass<'tcx> for ImproperCTypesDefinitions {\n     fn check_fn(\n         &mut self,\n-        cx: &LateContext<'a, 'tcx>,\n+        cx: &LateContext<'tcx>,\n         kind: hir::intravisit::FnKind<'tcx>,\n         decl: &'tcx hir::FnDecl<'_>,\n         _: &'tcx hir::Body<'_>,\n@@ -1096,8 +1096,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImproperCTypesDefinitions {\n \n declare_lint_pass!(VariantSizeDifferences => [VARIANT_SIZE_DIFFERENCES]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for VariantSizeDifferences {\n+    fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n         if let hir::ItemKind::Enum(ref enum_definition, _) = it.kind {\n             let item_def_id = cx.tcx.hir().local_def_id(it.hir_id);\n             let t = cx.tcx.type_of(item_def_id);"}, {"sha": "c407f608a14c566a44b2fa4d45f8e51d4b482efa", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -35,8 +35,8 @@ declare_lint! {\n \n declare_lint_pass!(UnusedResults => [UNUSED_MUST_USE, UNUSED_RESULTS]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n-    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n+    fn check_stmt(&mut self, cx: &LateContext<'_>, s: &hir::Stmt<'_>) {\n         let expr = match s.kind {\n             hir::StmtKind::Semi(ref expr) => &**expr,\n             _ => return,\n@@ -116,7 +116,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n \n         // Returns whether an error has been emitted (and thus another does not need to be later).\n         fn check_must_use_ty<'tcx>(\n-            cx: &LateContext<'_, 'tcx>,\n+            cx: &LateContext<'tcx>,\n             ty: Ty<'tcx>,\n             expr: &hir::Expr<'_>,\n             span: Span,\n@@ -213,7 +213,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n         // this would still require a copy into the format string, which would only be executed\n         // when needed.\n         fn check_must_use_def(\n-            cx: &LateContext<'_, '_>,\n+            cx: &LateContext<'_>,\n             def_id: DefId,\n             span: Span,\n             descr_pre_path: &str,\n@@ -251,8 +251,8 @@ declare_lint! {\n \n declare_lint_pass!(PathStatements => [PATH_STATEMENTS]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PathStatements {\n-    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for PathStatements {\n+    fn check_stmt(&mut self, cx: &LateContext<'_>, s: &hir::Stmt<'_>) {\n         if let hir::StmtKind::Semi(ref expr) = s.kind {\n             if let hir::ExprKind::Path(_) = expr.kind {\n                 cx.struct_span_lint(PATH_STATEMENTS, s.span, |lint| {\n@@ -276,8 +276,8 @@ impl UnusedAttributes {\n \n impl_lint_pass!(UnusedAttributes => [UNUSED_ATTRIBUTES]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n-    fn check_attribute(&mut self, cx: &LateContext<'_, '_>, attr: &ast::Attribute) {\n+impl<'tcx> LateLintPass<'tcx> for UnusedAttributes {\n+    fn check_attribute(&mut self, cx: &LateContext<'_>, attr: &ast::Attribute) {\n         debug!(\"checking attribute: {:?}\", attr);\n \n         if attr.is_doc_comment() {\n@@ -943,8 +943,8 @@ declare_lint! {\n \n declare_lint_pass!(UnusedAllocation => [UNUSED_ALLOCATION]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAllocation {\n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, e: &hir::Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for UnusedAllocation {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, e: &hir::Expr<'_>) {\n         match e.kind {\n             hir::ExprKind::Box(_) => {}\n             _ => return,"}, {"sha": "2e1775ca465343d50bd905fa78ab3cdcdbbbb297", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -331,12 +331,12 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     }\n }\n \n-struct MissingStabilityAnnotations<'a, 'tcx> {\n+struct MissingStabilityAnnotations<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    access_levels: &'a AccessLevels,\n+    access_levels: &'tcx AccessLevels,\n }\n \n-impl<'a, 'tcx> MissingStabilityAnnotations<'a, 'tcx> {\n+impl<'tcx> MissingStabilityAnnotations<'tcx> {\n     fn check_missing_stability(&self, hir_id: HirId, span: Span) {\n         let stab = self.tcx.stability().local_stability(hir_id);\n         let is_error =\n@@ -349,7 +349,7 @@ impl<'a, 'tcx> MissingStabilityAnnotations<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n+impl<'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'tcx> {\n     type Map = Map<'tcx>;\n \n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {"}, {"sha": "bd3724449fabf1dc1ed78be7eecfa6e4bfa9182c", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -72,12 +72,12 @@ macro_rules! access_from_vis {\n     };\n }\n \n-pub struct DumpVisitor<'l, 'tcx> {\n-    pub save_ctxt: SaveContext<'l, 'tcx>,\n+pub struct DumpVisitor<'tcx> {\n+    pub save_ctxt: SaveContext<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     dumper: Dumper,\n \n-    span: SpanUtils<'l>,\n+    span: SpanUtils<'tcx>,\n     // Set of macro definition (callee) spans, and the set\n     // of macro use (callsite) spans. We store these to ensure\n     // we only write one macro def per unique macro definition, and\n@@ -86,8 +86,8 @@ pub struct DumpVisitor<'l, 'tcx> {\n     // macro_calls: FxHashSet<Span>,\n }\n \n-impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n-    pub fn new(save_ctxt: SaveContext<'l, 'tcx>) -> DumpVisitor<'l, 'tcx> {\n+impl<'tcx> DumpVisitor<'tcx> {\n+    pub fn new(save_ctxt: SaveContext<'tcx>) -> DumpVisitor<'tcx> {\n         let span_utils = SpanUtils::new(&save_ctxt.tcx.sess);\n         let dumper = Dumper::new(save_ctxt.config.clone());\n         DumpVisitor {\n@@ -1160,7 +1160,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     }\n }\n \n-impl<'l, 'tcx> Visitor<'tcx> for DumpVisitor<'l, 'tcx> {\n+impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n     type Map = Map<'tcx>;\n \n     fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {"}, {"sha": "5ecb256719f1f6deb0b6cef86b57ef281320994b", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -48,10 +48,10 @@ use rls_data::{\n \n use log::{debug, error, info};\n \n-pub struct SaveContext<'l, 'tcx: 'l> {\n+pub struct SaveContext<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     maybe_typeck_tables: Option<&'tcx ty::TypeckTables<'tcx>>,\n-    access_levels: &'l AccessLevels,\n+    access_levels: &'tcx AccessLevels,\n     span_utils: SpanUtils<'tcx>,\n     config: Config,\n     impl_counter: Cell<u32>,\n@@ -64,7 +64,7 @@ pub enum Data {\n     RelationData(Relation, Impl),\n }\n \n-impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n+impl<'tcx> SaveContext<'tcx> {\n     /// Gets the type-checking side-tables for the current body.\n     /// As this will ICE if called outside bodies, only call when working with\n     /// `Expr` or `Pat` nodes (they are guaranteed to be found only in bodies).\n@@ -917,7 +917,7 @@ impl<'l> Visitor<'l> for PathCollector<'l> {\n \n /// Defines what to do with the results of saving the analysis.\n pub trait SaveHandler {\n-    fn save(&mut self, save_ctxt: &SaveContext<'_, '_>, analysis: &Analysis);\n+    fn save(&mut self, save_ctxt: &SaveContext<'_>, analysis: &Analysis);\n }\n \n /// Dump the save-analysis results to a file.\n@@ -931,7 +931,7 @@ impl<'a> DumpHandler<'a> {\n         DumpHandler { odir, cratename: cratename.to_owned() }\n     }\n \n-    fn output_file(&self, ctx: &SaveContext<'_, '_>) -> (BufWriter<File>, PathBuf) {\n+    fn output_file(&self, ctx: &SaveContext<'_>) -> (BufWriter<File>, PathBuf) {\n         let sess = &ctx.tcx.sess;\n         let file_name = match ctx.config.output_file {\n             Some(ref s) => PathBuf::from(s),\n@@ -967,7 +967,7 @@ impl<'a> DumpHandler<'a> {\n }\n \n impl SaveHandler for DumpHandler<'_> {\n-    fn save(&mut self, save_ctxt: &SaveContext<'_, '_>, analysis: &Analysis) {\n+    fn save(&mut self, save_ctxt: &SaveContext<'_>, analysis: &Analysis) {\n         let sess = &save_ctxt.tcx.sess;\n         let (output, file_name) = self.output_file(&save_ctxt);\n         if let Err(e) = serde_json::to_writer(output, &analysis) {\n@@ -986,7 +986,7 @@ pub struct CallbackHandler<'b> {\n }\n \n impl SaveHandler for CallbackHandler<'_> {\n-    fn save(&mut self, _: &SaveContext<'_, '_>, analysis: &Analysis) {\n+    fn save(&mut self, _: &SaveContext<'_>, analysis: &Analysis) {\n         (self.callback)(analysis)\n     }\n }\n@@ -1065,7 +1065,7 @@ fn id_from_def_id(id: DefId) -> rls_data::Id {\n     rls_data::Id { krate: id.krate.as_u32(), index: id.index.as_u32() }\n }\n \n-fn id_from_hir_id(id: hir::HirId, scx: &SaveContext<'_, '_>) -> rls_data::Id {\n+fn id_from_hir_id(id: hir::HirId, scx: &SaveContext<'_>) -> rls_data::Id {\n     let def_id = scx.tcx.hir().opt_local_def_id(id);\n     def_id.map(|id| id_from_def_id(id.to_def_id())).unwrap_or_else(|| {\n         // Create a *fake* `DefId` out of a `HirId` by combining the owner\n@@ -1083,10 +1083,7 @@ fn null_id() -> rls_data::Id {\n     rls_data::Id { krate: u32::MAX, index: u32::MAX }\n }\n \n-fn lower_attributes(\n-    attrs: Vec<ast::Attribute>,\n-    scx: &SaveContext<'_, '_>,\n-) -> Vec<rls_data::Attribute> {\n+fn lower_attributes(attrs: Vec<ast::Attribute>, scx: &SaveContext<'_>) -> Vec<rls_data::Attribute> {\n     attrs\n         .into_iter()\n         // Only retain real attributes. Doc comments are lowered separately."}, {"sha": "33355c4c558fb68b84437c1fa63712ad1de2ce04", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 19, "deletions": 55, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -36,7 +36,7 @@ use rustc_hir_pretty::id_to_string;\n use rustc_hir_pretty::{bounds_to_string, path_segment_to_string, path_to_string, ty_to_string};\n use rustc_span::symbol::{Ident, Symbol};\n \n-pub fn item_signature(item: &hir::Item<'_>, scx: &SaveContext<'_, '_>) -> Option<Signature> {\n+pub fn item_signature(item: &hir::Item<'_>, scx: &SaveContext<'_>) -> Option<Signature> {\n     if !scx.config.signatures {\n         return None;\n     }\n@@ -45,7 +45,7 @@ pub fn item_signature(item: &hir::Item<'_>, scx: &SaveContext<'_, '_>) -> Option\n \n pub fn foreign_item_signature(\n     item: &hir::ForeignItem<'_>,\n-    scx: &SaveContext<'_, '_>,\n+    scx: &SaveContext<'_>,\n ) -> Option<Signature> {\n     if !scx.config.signatures {\n         return None;\n@@ -55,21 +55,15 @@ pub fn foreign_item_signature(\n \n /// Signature for a struct or tuple field declaration.\n /// Does not include a trailing comma.\n-pub fn field_signature(\n-    field: &hir::StructField<'_>,\n-    scx: &SaveContext<'_, '_>,\n-) -> Option<Signature> {\n+pub fn field_signature(field: &hir::StructField<'_>, scx: &SaveContext<'_>) -> Option<Signature> {\n     if !scx.config.signatures {\n         return None;\n     }\n     field.make(0, None, scx).ok()\n }\n \n /// Does not include a trailing comma.\n-pub fn variant_signature(\n-    variant: &hir::Variant<'_>,\n-    scx: &SaveContext<'_, '_>,\n-) -> Option<Signature> {\n+pub fn variant_signature(variant: &hir::Variant<'_>, scx: &SaveContext<'_>) -> Option<Signature> {\n     if !scx.config.signatures {\n         return None;\n     }\n@@ -81,7 +75,7 @@ pub fn method_signature(\n     ident: Ident,\n     generics: &hir::Generics<'_>,\n     m: &hir::FnSig<'_>,\n-    scx: &SaveContext<'_, '_>,\n+    scx: &SaveContext<'_>,\n ) -> Option<Signature> {\n     if !scx.config.signatures {\n         return None;\n@@ -94,7 +88,7 @@ pub fn assoc_const_signature(\n     ident: Symbol,\n     ty: &hir::Ty<'_>,\n     default: Option<&hir::Expr<'_>>,\n-    scx: &SaveContext<'_, '_>,\n+    scx: &SaveContext<'_>,\n ) -> Option<Signature> {\n     if !scx.config.signatures {\n         return None;\n@@ -107,7 +101,7 @@ pub fn assoc_type_signature(\n     ident: Ident,\n     bounds: Option<hir::GenericBounds<'_>>,\n     default: Option<&hir::Ty<'_>>,\n-    scx: &SaveContext<'_, '_>,\n+    scx: &SaveContext<'_>,\n ) -> Option<Signature> {\n     if !scx.config.signatures {\n         return None;\n@@ -118,7 +112,7 @@ pub fn assoc_type_signature(\n type Result = std::result::Result<Signature, &'static str>;\n \n trait Sig {\n-    fn make(&self, offset: usize, id: Option<hir::HirId>, scx: &SaveContext<'_, '_>) -> Result;\n+    fn make(&self, offset: usize, id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result;\n }\n \n fn extend_sig(\n@@ -154,12 +148,7 @@ fn text_sig(text: String) -> Signature {\n }\n \n impl<'hir> Sig for hir::Ty<'hir> {\n-    fn make(\n-        &self,\n-        offset: usize,\n-        _parent_id: Option<hir::HirId>,\n-        scx: &SaveContext<'_, '_>,\n-    ) -> Result {\n+    fn make(&self, offset: usize, _parent_id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result {\n         let id = Some(self.hir_id);\n         match self.kind {\n             hir::TyKind::Slice(ref ty) => {\n@@ -334,12 +323,7 @@ impl<'hir> Sig for hir::Ty<'hir> {\n }\n \n impl<'hir> Sig for hir::Item<'hir> {\n-    fn make(\n-        &self,\n-        offset: usize,\n-        _parent_id: Option<hir::HirId>,\n-        scx: &SaveContext<'_, '_>,\n-    ) -> Result {\n+    fn make(&self, offset: usize, _parent_id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result {\n         let id = Some(self.hir_id);\n \n         match self.kind {\n@@ -574,7 +558,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n }\n \n impl<'hir> Sig for hir::Path<'hir> {\n-    fn make(&self, offset: usize, id: Option<hir::HirId>, scx: &SaveContext<'_, '_>) -> Result {\n+    fn make(&self, offset: usize, id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result {\n         let res = scx.get_path_res(id.ok_or(\"Missing id for Path\")?);\n \n         let (name, start, end) = match res {\n@@ -608,12 +592,7 @@ impl<'hir> Sig for hir::Path<'hir> {\n \n // This does not cover the where clause, which must be processed separately.\n impl<'hir> Sig for hir::Generics<'hir> {\n-    fn make(\n-        &self,\n-        offset: usize,\n-        _parent_id: Option<hir::HirId>,\n-        scx: &SaveContext<'_, '_>,\n-    ) -> Result {\n+    fn make(&self, offset: usize, _parent_id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result {\n         if self.params.is_empty() {\n             return Ok(text_sig(String::new()));\n         }\n@@ -671,12 +650,7 @@ impl<'hir> Sig for hir::Generics<'hir> {\n }\n \n impl<'hir> Sig for hir::StructField<'hir> {\n-    fn make(\n-        &self,\n-        offset: usize,\n-        _parent_id: Option<hir::HirId>,\n-        scx: &SaveContext<'_, '_>,\n-    ) -> Result {\n+    fn make(&self, offset: usize, _parent_id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result {\n         let mut text = String::new();\n \n         text.push_str(&self.ident.to_string());\n@@ -696,12 +670,7 @@ impl<'hir> Sig for hir::StructField<'hir> {\n }\n \n impl<'hir> Sig for hir::Variant<'hir> {\n-    fn make(\n-        &self,\n-        offset: usize,\n-        parent_id: Option<hir::HirId>,\n-        scx: &SaveContext<'_, '_>,\n-    ) -> Result {\n+    fn make(&self, offset: usize, parent_id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result {\n         let mut text = self.ident.to_string();\n         match self.data {\n             hir::VariantData::Struct(fields, r) => {\n@@ -760,12 +729,7 @@ impl<'hir> Sig for hir::Variant<'hir> {\n }\n \n impl<'hir> Sig for hir::ForeignItem<'hir> {\n-    fn make(\n-        &self,\n-        offset: usize,\n-        _parent_id: Option<hir::HirId>,\n-        scx: &SaveContext<'_, '_>,\n-    ) -> Result {\n+    fn make(&self, offset: usize, _parent_id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result {\n         let id = Some(self.hir_id);\n         match self.kind {\n             hir::ForeignItemKind::Fn(decl, _, ref generics) => {\n@@ -839,7 +803,7 @@ fn name_and_generics(\n     generics: &hir::Generics<'_>,\n     id: hir::HirId,\n     name: Ident,\n-    scx: &SaveContext<'_, '_>,\n+    scx: &SaveContext<'_>,\n ) -> Result {\n     let name = name.to_string();\n     let def = SigElement {\n@@ -859,7 +823,7 @@ fn make_assoc_type_signature(\n     ident: Ident,\n     bounds: Option<hir::GenericBounds<'_>>,\n     default: Option<&hir::Ty<'_>>,\n-    scx: &SaveContext<'_, '_>,\n+    scx: &SaveContext<'_>,\n ) -> Result {\n     let mut text = \"type \".to_owned();\n     let name = ident.to_string();\n@@ -891,7 +855,7 @@ fn make_assoc_const_signature(\n     ident: Symbol,\n     ty: &hir::Ty<'_>,\n     default: Option<&hir::Expr<'_>>,\n-    scx: &SaveContext<'_, '_>,\n+    scx: &SaveContext<'_>,\n ) -> Result {\n     let mut text = \"const \".to_owned();\n     let name = ident.to_string();\n@@ -922,7 +886,7 @@ fn make_method_signature(\n     ident: Ident,\n     generics: &hir::Generics<'_>,\n     m: &hir::FnSig<'_>,\n-    scx: &SaveContext<'_, '_>,\n+    scx: &SaveContext<'_>,\n ) -> Result {\n     // FIXME code dup with function signature\n     let mut text = String::new();"}, {"sha": "9ba2675477878e79c8597001669affd925677ae1", "filename": "src/test/ui-fulldeps/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -33,10 +33,10 @@ declare_lint! {\n \n declare_lint_pass!(MissingWhitelistedAttrPass => [MISSING_WHITELISTED_ATTR]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingWhitelistedAttrPass {\n+impl<'tcx> LateLintPass<'tcx> for MissingWhitelistedAttrPass {\n     fn check_fn(\n         &mut self,\n-        cx: &LateContext<'a, 'tcx>,\n+        cx: &LateContext<'tcx>,\n         _: intravisit::FnKind<'tcx>,\n         _: &'tcx hir::FnDecl,\n         _: &'tcx hir::Body,"}, {"sha": "bfb4da4c8f574e88338bef35ab383ab9bf1bfe04", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate-rpass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -26,7 +26,7 @@ macro_rules! fake_lint_pass {\n             }\n         }\n \n-        impl<'a, 'tcx> LateLintPass<'a, 'tcx> for $struct {\n+        impl LateLintPass<'_> for $struct {\n             fn check_crate(&mut self, cx: &LateContext, krate: &rustc_hir::Crate) {\n                 $(\n                     if !attr::contains_name(&krate.item.attrs, $attr) {"}, {"sha": "e6a6f73bd4755f025e44b1492f01160a9049fb8b", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -25,7 +25,7 @@ declare_lint! {\n \n declare_lint_pass!(Pass => [CRATE_NOT_OKAY]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+impl<'tcx> LateLintPass<'tcx> for Pass {\n     fn check_crate(&mut self, cx: &LateContext, krate: &rustc_hir::Crate) {\n         if !attr::contains_name(&krate.item.attrs, Symbol::intern(\"crate_okay\")) {\n             cx.lint(CRATE_NOT_OKAY, |lint| {"}, {"sha": "02216b33dc3ad1276b15311636254fc6e4c64f78", "filename": "src/test/ui-fulldeps/auxiliary/lint-group-plugin-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -20,7 +20,7 @@ declare_lint!(PLEASE_LINT, Warn, \"Warn about items named 'pleaselintme'\");\n \n declare_lint_pass!(Pass => [TEST_LINT, PLEASE_LINT]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+impl<'tcx> LateLintPass<'tcx> for Pass {\n     fn check_item(&mut self, cx: &LateContext, it: &rustc_hir::Item) {\n         match &*it.ident.as_str() {\n             \"lintme\" => cx.lint(TEST_LINT, |lint| {"}, {"sha": "1d511a86c9099f44c815300ad18920481ca50c1d", "filename": "src/tools/clippy/clippy_lints/src/approx_const.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fapprox_const.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -60,15 +60,15 @@ const KNOWN_CONSTS: [(f64, &str, usize); 18] = [\n \n declare_lint_pass!(ApproxConstant => [APPROX_CONSTANT]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ApproxConstant {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for ApproxConstant {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if let ExprKind::Lit(lit) = &e.kind {\n             check_lit(cx, &lit.node, e);\n         }\n     }\n }\n \n-fn check_lit(cx: &LateContext<'_, '_>, lit: &LitKind, e: &Expr<'_>) {\n+fn check_lit(cx: &LateContext<'_>, lit: &LitKind, e: &Expr<'_>) {\n     match *lit {\n         LitKind::Float(s, LitFloatType::Suffixed(fty)) => match fty {\n             FloatTy::F32 => check_known_consts(cx, e, s, \"f32\"),\n@@ -79,7 +79,7 @@ fn check_lit(cx: &LateContext<'_, '_>, lit: &LitKind, e: &Expr<'_>) {\n     }\n }\n \n-fn check_known_consts(cx: &LateContext<'_, '_>, e: &Expr<'_>, s: symbol::Symbol, module: &str) {\n+fn check_known_consts(cx: &LateContext<'_>, e: &Expr<'_>, s: symbol::Symbol, module: &str) {\n     let s = s.as_str();\n     if s.parse::<f64>().is_ok() {\n         for &(constant, name, min_digits) in &KNOWN_CONSTS {"}, {"sha": "da60856fac932341e63ca5fe8558319b1e4e7667", "filename": "src/tools/clippy/clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Farithmetic.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -58,8 +58,8 @@ pub struct Arithmetic {\n \n impl_lint_pass!(Arithmetic => [INTEGER_ARITHMETIC, FLOAT_ARITHMETIC]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for Arithmetic {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if self.expr_span.is_some() {\n             return;\n         }\n@@ -111,13 +111,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n         }\n     }\n \n-    fn check_expr_post(&mut self, _: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n+    fn check_expr_post(&mut self, _: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if Some(expr.span) == self.expr_span {\n             self.expr_span = None;\n         }\n     }\n \n-    fn check_body(&mut self, cx: &LateContext<'_, '_>, body: &hir::Body<'_>) {\n+    fn check_body(&mut self, cx: &LateContext<'_>, body: &hir::Body<'_>) {\n         let body_owner = cx.tcx.hir().body_owner(body.id());\n \n         match cx.tcx.hir().body_owner_kind(body_owner) {\n@@ -135,7 +135,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n         }\n     }\n \n-    fn check_body_post(&mut self, cx: &LateContext<'_, '_>, body: &hir::Body<'_>) {\n+    fn check_body_post(&mut self, cx: &LateContext<'_>, body: &hir::Body<'_>) {\n         let body_owner = cx.tcx.hir().body_owner(body.id());\n         let body_span = cx.tcx.hir().span(body_owner);\n "}, {"sha": "cffe8d94e27979565e332e3c0df97e1c1549f991", "filename": "src/tools/clippy/clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -29,8 +29,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(AssertionsOnConstants => [ASSERTIONS_ON_CONSTANTS]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssertionsOnConstants {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for AssertionsOnConstants {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         let lint_true = |is_debug: bool| {\n             span_lint_and_help(\n                 cx,\n@@ -114,7 +114,7 @@ enum AssertKind {\n /// ```\n ///\n /// where `message` is any expression and `c` is a constant bool.\n-fn match_assert_with_message<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) -> Option<AssertKind> {\n+fn match_assert_with_message<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<AssertKind> {\n     if_chain! {\n         if let ExprKind::Match(ref expr, ref arms, _) = expr.kind;\n         // matches { let _t = expr; _t }"}, {"sha": "bc6e868823f77c78a158c0d1fdac6a14958069f3", "filename": "src/tools/clippy/clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassign_ops.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -60,9 +60,9 @@ declare_clippy_lint! {\n \n declare_lint_pass!(AssignOps => [ASSIGN_OP_PATTERN, MISREFACTORED_ASSIGN_OP]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n+impl<'tcx> LateLintPass<'tcx> for AssignOps {\n     #[allow(clippy::too_many_lines)]\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         match &expr.kind {\n             hir::ExprKind::AssignOp(op, lhs, rhs) => {\n                 if let hir::ExprKind::Binary(binop, l, r) = &rhs.kind {\n@@ -191,7 +191,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n }\n \n fn lint_misrefactored_assign_op(\n-    cx: &LateContext<'_, '_>,\n+    cx: &LateContext<'_>,\n     expr: &hir::Expr<'_>,\n     op: hir::BinOp,\n     rhs: &hir::Expr<'_>,\n@@ -246,7 +246,7 @@ fn is_commutative(op: hir::BinOpKind) -> bool {\n struct ExprVisitor<'a, 'tcx> {\n     assignee: &'a hir::Expr<'a>,\n     counter: u8,\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {"}, {"sha": "efd3f0f671cddd844770d359e0fcb550c19da98e", "filename": "src/tools/clippy/clippy_lints/src/atomic_ordering.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fatomic_ordering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fatomic_ordering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fatomic_ordering.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -52,7 +52,7 @@ const ATOMIC_TYPES: [&str; 12] = [\n     \"AtomicUsize\",\n ];\n \n-fn type_is_atomic(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+fn type_is_atomic(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     if let ty::Adt(&ty::AdtDef { did, .. }, _) = cx.tables().expr_ty(expr).kind {\n         ATOMIC_TYPES\n             .iter()\n@@ -62,13 +62,13 @@ fn type_is_atomic(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n     }\n }\n \n-fn match_ordering_def_path(cx: &LateContext<'_, '_>, did: DefId, orderings: &[&str]) -> bool {\n+fn match_ordering_def_path(cx: &LateContext<'_>, did: DefId, orderings: &[&str]) -> bool {\n     orderings\n         .iter()\n         .any(|ordering| match_def_path(cx, did, &[\"core\", \"sync\", \"atomic\", \"Ordering\", ordering]))\n }\n \n-fn check_atomic_load_store(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+fn check_atomic_load_store(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n         if let ExprKind::MethodCall(ref method_path, _, args, _) = &expr.kind;\n         let method = method_path.ident.name.as_str();\n@@ -103,7 +103,7 @@ fn check_atomic_load_store(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n     }\n }\n \n-fn check_memory_fence(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+fn check_memory_fence(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n         if let ExprKind::Call(ref func, ref args) = expr.kind;\n         if let ExprKind::Path(ref func_qpath) = func.kind;\n@@ -127,8 +127,8 @@ fn check_memory_fence(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AtomicOrdering {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for AtomicOrdering {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         check_atomic_load_store(cx, expr);\n         check_memory_fence(cx, expr);\n     }"}, {"sha": "2505ff32fe52333d919ceee9b2947c96b11b2e62", "filename": "src/tools/clippy/clippy_lints/src/attrs.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -251,8 +251,8 @@ declare_lint_pass!(Attributes => [\n     UNKNOWN_CLIPPY_LINTS,\n ]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Attributes {\n-    fn check_attribute(&mut self, cx: &LateContext<'a, 'tcx>, attr: &'tcx Attribute) {\n+impl<'tcx> LateLintPass<'tcx> for Attributes {\n+    fn check_attribute(&mut self, cx: &LateContext<'tcx>, attr: &'tcx Attribute) {\n         if let Some(items) = &attr.meta_item_list() {\n             if let Some(ident) = attr.ident() {\n                 match &*ident.as_str() {\n@@ -278,7 +278,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Attributes {\n         }\n     }\n \n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item<'_>) {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if is_relevant_item(cx, item) {\n             check_attrs(cx, item.span, item.ident.name, &item.attrs)\n         }\n@@ -350,21 +350,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Attributes {\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem<'_>) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n         if is_relevant_impl(cx, item) {\n             check_attrs(cx, item.span, item.ident.name, &item.attrs)\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem<'_>) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'_>) {\n         if is_relevant_trait(cx, item) {\n             check_attrs(cx, item.span, item.ident.name, &item.attrs)\n         }\n     }\n }\n \n #[allow(clippy::single_match_else)]\n-fn check_clippy_lint_names(cx: &LateContext<'_, '_>, items: &[NestedMetaItem]) {\n+fn check_clippy_lint_names(cx: &LateContext<'_>, items: &[NestedMetaItem]) {\n     let lint_store = cx.lints();\n     for lint in items {\n         if_chain! {\n@@ -416,22 +416,22 @@ fn check_clippy_lint_names(cx: &LateContext<'_, '_>, items: &[NestedMetaItem]) {\n     }\n }\n \n-fn is_relevant_item(cx: &LateContext<'_, '_>, item: &Item<'_>) -> bool {\n+fn is_relevant_item(cx: &LateContext<'_>, item: &Item<'_>) -> bool {\n     if let ItemKind::Fn(_, _, eid) = item.kind {\n         is_relevant_expr(cx, cx.tcx.body_tables(eid), &cx.tcx.hir().body(eid).value)\n     } else {\n         true\n     }\n }\n \n-fn is_relevant_impl(cx: &LateContext<'_, '_>, item: &ImplItem<'_>) -> bool {\n+fn is_relevant_impl(cx: &LateContext<'_>, item: &ImplItem<'_>) -> bool {\n     match item.kind {\n         ImplItemKind::Fn(_, eid) => is_relevant_expr(cx, cx.tcx.body_tables(eid), &cx.tcx.hir().body(eid).value),\n         _ => false,\n     }\n }\n \n-fn is_relevant_trait(cx: &LateContext<'_, '_>, item: &TraitItem<'_>) -> bool {\n+fn is_relevant_trait(cx: &LateContext<'_>, item: &TraitItem<'_>) -> bool {\n     match item.kind {\n         TraitItemKind::Fn(_, TraitFn::Required(_)) => true,\n         TraitItemKind::Fn(_, TraitFn::Provided(eid)) => {\n@@ -441,7 +441,7 @@ fn is_relevant_trait(cx: &LateContext<'_, '_>, item: &TraitItem<'_>) -> bool {\n     }\n }\n \n-fn is_relevant_block(cx: &LateContext<'_, '_>, tables: &ty::TypeckTables<'_>, block: &Block<'_>) -> bool {\n+fn is_relevant_block(cx: &LateContext<'_>, tables: &ty::TypeckTables<'_>, block: &Block<'_>) -> bool {\n     if let Some(stmt) = block.stmts.first() {\n         match &stmt.kind {\n             StmtKind::Local(_) => true,\n@@ -453,7 +453,7 @@ fn is_relevant_block(cx: &LateContext<'_, '_>, tables: &ty::TypeckTables<'_>, bl\n     }\n }\n \n-fn is_relevant_expr(cx: &LateContext<'_, '_>, tables: &ty::TypeckTables<'_>, expr: &Expr<'_>) -> bool {\n+fn is_relevant_expr(cx: &LateContext<'_>, tables: &ty::TypeckTables<'_>, expr: &Expr<'_>) -> bool {\n     match &expr.kind {\n         ExprKind::Block(block, _) => is_relevant_block(cx, tables, block),\n         ExprKind::Ret(Some(e)) => is_relevant_expr(cx, tables, e),\n@@ -473,7 +473,7 @@ fn is_relevant_expr(cx: &LateContext<'_, '_>, tables: &ty::TypeckTables<'_>, exp\n     }\n }\n \n-fn check_attrs(cx: &LateContext<'_, '_>, span: Span, name: Name, attrs: &[Attribute]) {\n+fn check_attrs(cx: &LateContext<'_>, span: Span, name: Name, attrs: &[Attribute]) {\n     if span.from_expansion() {\n         return;\n     }\n@@ -498,7 +498,7 @@ fn check_attrs(cx: &LateContext<'_, '_>, span: Span, name: Name, attrs: &[Attrib\n     }\n }\n \n-fn check_semver(cx: &LateContext<'_, '_>, span: Span, lit: &Lit) {\n+fn check_semver(cx: &LateContext<'_>, span: Span, lit: &Lit) {\n     if let LitKind::Str(is, _) = lit.kind {\n         if Version::parse(&is.as_str()).is_ok() {\n             return;"}, {"sha": "20b91bc0f1bafcbc4e2b7cf6065262fef1553d07", "filename": "src/tools/clippy/clippy_lints/src/await_holding_lock.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_lock.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -51,8 +51,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(AwaitHoldingLock => [AWAIT_HOLDING_LOCK]);\n \n-impl LateLintPass<'_, '_> for AwaitHoldingLock {\n-    fn check_body(&mut self, cx: &LateContext<'_, '_>, body: &'_ Body<'_>) {\n+impl LateLintPass<'_> for AwaitHoldingLock {\n+    fn check_body(&mut self, cx: &LateContext<'_>, body: &'_ Body<'_>) {\n         use AsyncGeneratorKind::{Block, Closure, Fn};\n         if let Some(GeneratorKind::Async(Block | Closure | Fn)) = body.generator_kind {\n             let body_id = BodyId {\n@@ -65,7 +65,7 @@ impl LateLintPass<'_, '_> for AwaitHoldingLock {\n     }\n }\n \n-fn check_interior_types(cx: &LateContext<'_, '_>, ty_causes: &[GeneratorInteriorTypeCause<'_>], span: Span) {\n+fn check_interior_types(cx: &LateContext<'_>, ty_causes: &[GeneratorInteriorTypeCause<'_>], span: Span) {\n     for ty_cause in ty_causes {\n         if let rustc_middle::ty::Adt(adt, _) = ty_cause.ty.kind {\n             if is_mutex_guard(cx, adt.did) {\n@@ -82,7 +82,7 @@ fn check_interior_types(cx: &LateContext<'_, '_>, ty_causes: &[GeneratorInterior\n     }\n }\n \n-fn is_mutex_guard(cx: &LateContext<'_, '_>, def_id: DefId) -> bool {\n+fn is_mutex_guard(cx: &LateContext<'_>, def_id: DefId) -> bool {\n     match_def_path(cx, def_id, &paths::MUTEX_GUARD)\n         || match_def_path(cx, def_id, &paths::RWLOCK_READ_GUARD)\n         || match_def_path(cx, def_id, &paths::RWLOCK_WRITE_GUARD)"}, {"sha": "d1d177e7a4abb2c0a10820c804920c460688d3ff", "filename": "src/tools/clippy/clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbit_mask.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -110,8 +110,8 @@ impl BitMask {\n \n impl_lint_pass!(BitMask => [BAD_BIT_MASK, INEFFECTIVE_BIT_MASK, VERBOSE_BIT_MASK]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BitMask {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for BitMask {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if let ExprKind::Binary(cmp, left, right) = &e.kind {\n             if cmp.node.is_comparison() {\n                 if let Some(cmp_opt) = fetch_int_literal(cx, right) {\n@@ -164,7 +164,7 @@ fn invert_cmp(cmp: BinOpKind) -> BinOpKind {\n     }\n }\n \n-fn check_compare(cx: &LateContext<'_, '_>, bit_op: &Expr<'_>, cmp_op: BinOpKind, cmp_value: u128, span: Span) {\n+fn check_compare(cx: &LateContext<'_>, bit_op: &Expr<'_>, cmp_op: BinOpKind, cmp_value: u128, span: Span) {\n     if let ExprKind::Binary(op, left, right) = &bit_op.kind {\n         if op.node != BinOpKind::BitAnd && op.node != BinOpKind::BitOr {\n             return;\n@@ -177,7 +177,7 @@ fn check_compare(cx: &LateContext<'_, '_>, bit_op: &Expr<'_>, cmp_op: BinOpKind,\n \n #[allow(clippy::too_many_lines)]\n fn check_bit_mask(\n-    cx: &LateContext<'_, '_>,\n+    cx: &LateContext<'_>,\n     bit_op: BinOpKind,\n     cmp_op: BinOpKind,\n     mask_value: u128,\n@@ -290,7 +290,7 @@ fn check_bit_mask(\n     }\n }\n \n-fn check_ineffective_lt(cx: &LateContext<'_, '_>, span: Span, m: u128, c: u128, op: &str) {\n+fn check_ineffective_lt(cx: &LateContext<'_>, span: Span, m: u128, c: u128, op: &str) {\n     if c.is_power_of_two() && m < c {\n         span_lint(\n             cx,\n@@ -304,7 +304,7 @@ fn check_ineffective_lt(cx: &LateContext<'_, '_>, span: Span, m: u128, c: u128,\n     }\n }\n \n-fn check_ineffective_gt(cx: &LateContext<'_, '_>, span: Span, m: u128, c: u128, op: &str) {\n+fn check_ineffective_gt(cx: &LateContext<'_>, span: Span, m: u128, c: u128, op: &str) {\n     if (c + 1).is_power_of_two() && m <= c {\n         span_lint(\n             cx,\n@@ -318,7 +318,7 @@ fn check_ineffective_gt(cx: &LateContext<'_, '_>, span: Span, m: u128, c: u128,\n     }\n }\n \n-fn fetch_int_literal(cx: &LateContext<'_, '_>, lit: &Expr<'_>) -> Option<u128> {\n+fn fetch_int_literal(cx: &LateContext<'_>, lit: &Expr<'_>) -> Option<u128> {\n     match constant(cx, cx.tables(), lit)?.0 {\n         Constant::Int(n) => Some(n),\n         _ => None,"}, {"sha": "153870fb416583472fe53ea582b8750641829534", "filename": "src/tools/clippy/clippy_lints/src/blacklisted_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblacklisted_name.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -35,8 +35,8 @@ impl BlacklistedName {\n \n impl_lint_pass!(BlacklistedName => [BLACKLISTED_NAME]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlacklistedName {\n-    fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for BlacklistedName {\n+    fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {\n         if let PatKind::Binding(.., ident, _) = pat.kind {\n             if self.blacklist.contains(&ident.name.to_string()) {\n                 span_lint("}, {"sha": "1b73ced89b32bfc8e95e6ca76819c072c0edbe8d", "filename": "src/tools/clippy/clippy_lints/src/blocks_in_if_conditions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -45,7 +45,7 @@ declare_lint_pass!(BlocksInIfConditions => [BLOCKS_IN_IF_CONDITIONS]);\n \n struct ExVisitor<'a, 'tcx> {\n     found_block: Option<&'tcx Expr<'tcx>>,\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n@@ -71,8 +71,8 @@ const BRACED_EXPR_MESSAGE: &str = \"omit braces around single expression conditio\n const COMPLEX_BLOCK_MESSAGE: &str = \"in an `if` condition, avoid complex blocks or closures with blocks; \\\n                                     instead, move the block or closure higher and bind it with a `let`\";\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlocksInIfConditions {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for BlocksInIfConditions {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }"}, {"sha": "32d0979e99b6071801f8de393d53fc14ec429354", "filename": "src/tools/clippy/clippy_lints/src/booleans.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -55,10 +55,10 @@ const METHODS_WITH_NEGATION: [(&str, &str); 2] = [(\"is_some\", \"is_none\"), (\"is_e\n \n declare_lint_pass!(NonminimalBool => [NONMINIMAL_BOOL, LOGIC_BUG]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonminimalBool {\n+impl<'tcx> LateLintPass<'tcx> for NonminimalBool {\n     fn check_fn(\n         &mut self,\n-        cx: &LateContext<'a, 'tcx>,\n+        cx: &LateContext<'tcx>,\n         _: FnKind<'tcx>,\n         _: &'tcx FnDecl<'_>,\n         body: &'tcx Body<'_>,\n@@ -70,13 +70,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonminimalBool {\n }\n \n struct NonminimalBoolVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n }\n \n use quine_mc_cluskey::Bool;\n struct Hir2Qmm<'a, 'tcx, 'v> {\n     terminals: Vec<&'v Expr<'v>>,\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n }\n \n impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n@@ -155,7 +155,7 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n \n struct SuggestContext<'a, 'tcx, 'v> {\n     terminals: &'v [&'v Expr<'v>],\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     output: String,\n }\n \n@@ -222,7 +222,7 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n     }\n }\n \n-fn simplify_not(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Option<String> {\n+fn simplify_not(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n     match &expr.kind {\n         ExprKind::Binary(binop, lhs, rhs) => {\n             if !implements_ord(cx, lhs) {\n@@ -268,7 +268,7 @@ fn simplify_not(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Option<String> {\n     }\n }\n \n-fn suggest(cx: &LateContext<'_, '_>, suggestion: &Bool, terminals: &[&Expr<'_>]) -> String {\n+fn suggest(cx: &LateContext<'_>, suggestion: &Bool, terminals: &[&Expr<'_>]) -> String {\n     let mut suggest_context = SuggestContext {\n         terminals,\n         cx,\n@@ -464,13 +464,13 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n     }\n }\n \n-fn implements_ord<'a, 'tcx>(cx: &'a LateContext<'a, 'tcx>, expr: &Expr<'_>) -> bool {\n+fn implements_ord<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> bool {\n     let ty = cx.tables().expr_ty(expr);\n     get_trait_def_id(cx, &paths::ORD).map_or(false, |id| implements_trait(cx, ty, id, &[]))\n }\n \n struct NotSimplificationVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for NotSimplificationVisitor<'a, 'tcx> {"}, {"sha": "1cdfea1f526555805c303c1124fb839291d77b8c", "filename": "src/tools/clippy/clippy_lints/src/bytecount.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -35,8 +35,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(ByteCount => [NAIVE_BYTECOUNT]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for ByteCount {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n             if let ExprKind::MethodCall(ref count, _, ref count_args, _) = expr.kind;\n             if count.ident.name == sym!(count);"}, {"sha": "76a000157df03dce006669941382b1b2e7af8bfd", "filename": "src/tools/clippy/clippy_lints/src/cargo_common_metadata.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcargo_common_metadata.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -36,7 +36,7 @@ declare_clippy_lint! {\n     \"common metadata is defined in `Cargo.toml`\"\n }\n \n-fn missing_warning(cx: &LateContext<'_, '_>, package: &cargo_metadata::Package, field: &str) {\n+fn missing_warning(cx: &LateContext<'_>, package: &cargo_metadata::Package, field: &str) {\n     let message = format!(\"package `{}` is missing `{}` metadata\", package.name, field);\n     span_lint(cx, CARGO_COMMON_METADATA, DUMMY_SP, &message);\n }\n@@ -56,8 +56,8 @@ fn is_empty_vec(value: &[String]) -> bool {\n \n declare_lint_pass!(CargoCommonMetadata => [CARGO_COMMON_METADATA]);\n \n-impl LateLintPass<'_, '_> for CargoCommonMetadata {\n-    fn check_crate(&mut self, cx: &LateContext<'_, '_>, _: &Crate<'_>) {\n+impl LateLintPass<'_> for CargoCommonMetadata {\n+    fn check_crate(&mut self, cx: &LateContext<'_>, _: &Crate<'_>) {\n         if !run_lints(cx, &[CARGO_COMMON_METADATA], CRATE_HIR_ID) {\n             return;\n         }"}, {"sha": "841902943f00245cdf7b0a706b024bfb379bda2e", "filename": "src/tools/clippy/clippy_lints/src/checked_conversions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -41,8 +41,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(CheckedConversions => [CHECKED_CONVERSIONS]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CheckedConversions {\n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, item: &Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for CheckedConversions {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, item: &Expr<'_>) {\n         let result = if_chain! {\n             if !in_external_macro(cx.sess(), item.span);\n             if let ExprKind::Binary(op, ref left, ref right) = &item.kind;\n@@ -83,7 +83,7 @@ fn single_check<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<Conversion<'tcx>> {\n }\n \n /// Searches for a combination of upper & lower bound checks\n-fn double_check<'a>(cx: &LateContext<'_, '_>, left: &'a Expr<'_>, right: &'a Expr<'_>) -> Option<Conversion<'a>> {\n+fn double_check<'a>(cx: &LateContext<'_>, left: &'a Expr<'_>, right: &'a Expr<'_>) -> Option<Conversion<'a>> {\n     let upper_lower = |l, r| {\n         let upper = check_upper_bound(l);\n         let lower = check_lower_bound(r);\n@@ -112,7 +112,7 @@ enum ConversionType {\n \n impl<'a> Conversion<'a> {\n     /// Combine multiple conversions if the are compatible\n-    pub fn combine(self, other: Self, cx: &LateContext<'_, '_>) -> Option<Conversion<'a>> {\n+    pub fn combine(self, other: Self, cx: &LateContext<'_>) -> Option<Conversion<'a>> {\n         if self.is_compatible(&other, cx) {\n             // Prefer a Conversion that contains a type-constraint\n             Some(if self.to_type.is_some() { self } else { other })\n@@ -123,7 +123,7 @@ impl<'a> Conversion<'a> {\n \n     /// Checks if two conversions are compatible\n     /// same type of conversion, same 'castee' and same 'to type'\n-    pub fn is_compatible(&self, other: &Self, cx: &LateContext<'_, '_>) -> bool {\n+    pub fn is_compatible(&self, other: &Self, cx: &LateContext<'_>) -> bool {\n         (self.cvt == other.cvt)\n             && (SpanlessEq::new(cx).eq_expr(self.expr_to_cast, other.expr_to_cast))\n             && (self.has_compatible_to_type(other))"}, {"sha": "6bbdbe957cc83697841a4ac16117bb1e883c41c4", "filename": "src/tools/clippy/clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -43,9 +43,9 @@ impl_lint_pass!(CognitiveComplexity => [COGNITIVE_COMPLEXITY]);\n \n impl CognitiveComplexity {\n     #[allow(clippy::cast_possible_truncation)]\n-    fn check<'a, 'tcx>(\n+    fn check<'tcx>(\n         &mut self,\n-        cx: &'a LateContext<'a, 'tcx>,\n+        cx: &LateContext<'tcx>,\n         kind: FnKind<'tcx>,\n         decl: &'tcx FnDecl<'_>,\n         body: &'tcx Body<'_>,\n@@ -112,10 +112,10 @@ impl CognitiveComplexity {\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CognitiveComplexity {\n+impl<'tcx> LateLintPass<'tcx> for CognitiveComplexity {\n     fn check_fn(\n         &mut self,\n-        cx: &LateContext<'a, 'tcx>,\n+        cx: &LateContext<'tcx>,\n         kind: FnKind<'tcx>,\n         decl: &'tcx FnDecl<'_>,\n         body: &'tcx Body<'_>,\n@@ -128,10 +128,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CognitiveComplexity {\n         }\n     }\n \n-    fn enter_lint_attrs(&mut self, cx: &LateContext<'a, 'tcx>, attrs: &'tcx [Attribute]) {\n+    fn enter_lint_attrs(&mut self, cx: &LateContext<'tcx>, attrs: &'tcx [Attribute]) {\n         self.limit.push_attrs(cx.sess(), attrs, \"cognitive_complexity\");\n     }\n-    fn exit_lint_attrs(&mut self, cx: &LateContext<'a, 'tcx>, attrs: &'tcx [Attribute]) {\n+    fn exit_lint_attrs(&mut self, cx: &LateContext<'tcx>, attrs: &'tcx [Attribute]) {\n         self.limit.pop_attrs(cx.sess(), attrs, \"cognitive_complexity\");\n     }\n }"}, {"sha": "26476af4cb629c34cf343901488a7ee70e2b7174", "filename": "src/tools/clippy/clippy_lints/src/comparison_chain.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcomparison_chain.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -52,8 +52,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(ComparisonChain => [COMPARISON_CHAIN]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ComparisonChain {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for ComparisonChain {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if expr.span.from_expansion() {\n             return;\n         }"}, {"sha": "2f963dfcf8b186418c60996005b866bf40853dbf", "filename": "src/tools/clippy/clippy_lints/src/consts.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -172,9 +172,9 @@ pub fn lit_to_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n     }\n }\n \n-pub fn constant<'c, 'cc>(\n-    lcx: &LateContext<'c, 'cc>,\n-    tables: &'c ty::TypeckTables<'cc>,\n+pub fn constant<'tcx>(\n+    lcx: &LateContext<'tcx>,\n+    tables: &ty::TypeckTables<'tcx>,\n     e: &Expr<'_>,\n ) -> Option<(Constant, bool)> {\n     let mut cx = ConstEvalLateContext {\n@@ -187,19 +187,19 @@ pub fn constant<'c, 'cc>(\n     cx.expr(e).map(|cst| (cst, cx.needed_resolution))\n }\n \n-pub fn constant_simple<'c, 'cc>(\n-    lcx: &LateContext<'c, 'cc>,\n-    tables: &'c ty::TypeckTables<'cc>,\n+pub fn constant_simple<'tcx>(\n+    lcx: &LateContext<'tcx>,\n+    tables: &ty::TypeckTables<'tcx>,\n     e: &Expr<'_>,\n ) -> Option<Constant> {\n     constant(lcx, tables, e).and_then(|(cst, res)| if res { None } else { Some(cst) })\n }\n \n /// Creates a `ConstEvalLateContext` from the given `LateContext` and `TypeckTables`.\n-pub fn constant_context<'c, 'cc>(\n-    lcx: &'c LateContext<'c, 'cc>,\n-    tables: &'c ty::TypeckTables<'cc>,\n-) -> ConstEvalLateContext<'c, 'cc> {\n+pub fn constant_context<'a, 'tcx>(\n+    lcx: &'a LateContext<'tcx>,\n+    tables: &'a ty::TypeckTables<'tcx>,\n+) -> ConstEvalLateContext<'a, 'tcx> {\n     ConstEvalLateContext {\n         lcx,\n         tables,\n@@ -210,14 +210,14 @@ pub fn constant_context<'c, 'cc>(\n }\n \n pub struct ConstEvalLateContext<'a, 'tcx> {\n-    lcx: &'a LateContext<'a, 'tcx>,\n+    lcx: &'a LateContext<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     needed_resolution: bool,\n     substs: SubstsRef<'tcx>,\n }\n \n-impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n+impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n     /// Simple constant folding: Insert an expression, get a constant or none.\n     pub fn expr(&mut self, e: &Expr<'_>) -> Option<Constant> {\n         if let Some((ref cond, ref then, otherwise)) = higher::if_block(&e) {\n@@ -318,7 +318,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     }\n \n     /// Lookup a possibly constant expression from a `ExprKind::Path`.\n-    fn fetch_path(&mut self, qpath: &QPath<'_>, id: HirId, ty: Ty<'cc>) -> Option<Constant> {\n+    fn fetch_path(&mut self, qpath: &QPath<'_>, id: HirId, ty: Ty<'tcx>) -> Option<Constant> {\n         let res = self.tables.qpath_res(qpath, id);\n         match res {\n             Res::Def(DefKind::Const | DefKind::AssocConst, def_id) => {"}, {"sha": "1257032337acc959f9f170e6c5103f4eb6e7796f", "filename": "src/tools/clippy/clippy_lints/src/copies.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -151,8 +151,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(CopyAndPaste => [IFS_SAME_COND, SAME_FUNCTIONS_IN_IF_CONDITION, IF_SAME_THEN_ELSE, MATCH_SAME_ARMS]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CopyAndPaste {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for CopyAndPaste {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if !expr.span.from_expansion() {\n             // skip ifs directly in else, it will be checked in the parent if\n             if let Some(expr) = get_parent_expr(cx, expr) {\n@@ -173,7 +173,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CopyAndPaste {\n }\n \n /// Implementation of `IF_SAME_THEN_ELSE`.\n-fn lint_same_then_else(cx: &LateContext<'_, '_>, blocks: &[&Block<'_>]) {\n+fn lint_same_then_else(cx: &LateContext<'_>, blocks: &[&Block<'_>]) {\n     let eq: &dyn Fn(&&Block<'_>, &&Block<'_>) -> bool =\n         &|&lhs, &rhs| -> bool { SpanlessEq::new(cx).eq_block(lhs, rhs) };\n \n@@ -190,7 +190,7 @@ fn lint_same_then_else(cx: &LateContext<'_, '_>, blocks: &[&Block<'_>]) {\n }\n \n /// Implementation of `IFS_SAME_COND`.\n-fn lint_same_cond(cx: &LateContext<'_, '_>, conds: &[&Expr<'_>]) {\n+fn lint_same_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>]) {\n     let hash: &dyn Fn(&&Expr<'_>) -> u64 = &|expr| -> u64 {\n         let mut h = SpanlessHash::new(cx);\n         h.hash_expr(expr);\n@@ -213,7 +213,7 @@ fn lint_same_cond(cx: &LateContext<'_, '_>, conds: &[&Expr<'_>]) {\n }\n \n /// Implementation of `SAME_FUNCTIONS_IN_IF_CONDITION`.\n-fn lint_same_fns_in_if_cond(cx: &LateContext<'_, '_>, conds: &[&Expr<'_>]) {\n+fn lint_same_fns_in_if_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>]) {\n     let hash: &dyn Fn(&&Expr<'_>) -> u64 = &|expr| -> u64 {\n         let mut h = SpanlessHash::new(cx);\n         h.hash_expr(expr);\n@@ -241,7 +241,7 @@ fn lint_same_fns_in_if_cond(cx: &LateContext<'_, '_>, conds: &[&Expr<'_>]) {\n }\n \n /// Implementation of `MATCH_SAME_ARMS`.\n-fn lint_match_arms<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &Expr<'_>) {\n+fn lint_match_arms<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n     fn same_bindings<'tcx>(lhs: &FxHashMap<Symbol, Ty<'tcx>>, rhs: &FxHashMap<Symbol, Ty<'tcx>>) -> bool {\n         lhs.len() == rhs.len()\n             && lhs\n@@ -309,8 +309,8 @@ fn lint_match_arms<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &Expr<'_>) {\n }\n \n /// Returns the list of bindings in a pattern.\n-fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat<'_>) -> FxHashMap<Symbol, Ty<'tcx>> {\n-    fn bindings_impl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat<'_>, map: &mut FxHashMap<Symbol, Ty<'tcx>>) {\n+fn bindings<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>) -> FxHashMap<Symbol, Ty<'tcx>> {\n+    fn bindings_impl<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>, map: &mut FxHashMap<Symbol, Ty<'tcx>>) {\n         match pat.kind {\n             PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => bindings_impl(cx, pat, map),\n             PatKind::TupleStruct(_, pats, _) => {"}, {"sha": "349402453226a0d142e1704a17e935e73d8907e2", "filename": "src/tools/clippy/clippy_lints/src/copy_iterator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopy_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopy_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopy_iterator.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -31,8 +31,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(CopyIterator => [COPY_ITERATOR]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CopyIterator {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for CopyIterator {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if let ItemKind::Impl {\n             of_trait: Some(ref trait_ref),\n             .."}, {"sha": "fab95db01960475c85435786223925dcdc756d6d", "filename": "src/tools/clippy/clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -30,8 +30,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(DefaultTraitAccess => [DEFAULT_TRAIT_ACCESS]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DefaultTraitAccess {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for DefaultTraitAccess {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Call(ref path, ..) = expr.kind;\n             if !any_parent_is_automatically_derived(cx.tcx, expr.hir_id);"}, {"sha": "d740d88a77d6cb8b018764c43b54840901066dc8", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -38,8 +38,8 @@ declare_lint_pass!(Dereferencing => [\n     EXPLICIT_DEREF_METHODS\n ]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Dereferencing {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if !expr.span.from_expansion();\n             if let ExprKind::MethodCall(ref method_name, _, ref args, _) = &expr.kind;\n@@ -70,7 +70,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Dereferencing {\n     }\n }\n \n-fn lint_deref(cx: &LateContext<'_, '_>, method_name: &str, call_expr: &Expr<'_>, var_span: Span, expr_span: Span) {\n+fn lint_deref(cx: &LateContext<'_>, method_name: &str, call_expr: &Expr<'_>, var_span: Span, expr_span: Span) {\n     match method_name {\n         \"deref\" => {\n             if cx.tcx.lang_items().deref_trait().map_or(false, |id| {"}, {"sha": "59c62f1ae94400089db996df65de04ac133e2d04", "filename": "src/tools/clippy/clippy_lints/src/derive.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -105,8 +105,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(Derive => [EXPL_IMPL_CLONE_ON_COPY, DERIVE_HASH_XOR_EQ, UNSAFE_DERIVE_DESERIALIZE]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Derive {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for Derive {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if let ItemKind::Impl {\n             of_trait: Some(ref trait_ref),\n             ..\n@@ -127,8 +127,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Derive {\n }\n \n /// Implementation of the `DERIVE_HASH_XOR_EQ` lint.\n-fn check_hash_peq<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn check_hash_peq<'tcx>(\n+    cx: &LateContext<'tcx>,\n     span: Span,\n     trait_ref: &TraitRef<'_>,\n     ty: Ty<'tcx>,\n@@ -181,7 +181,7 @@ fn check_hash_peq<'a, 'tcx>(\n }\n \n /// Implementation of the `EXPL_IMPL_CLONE_ON_COPY` lint.\n-fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item<'_>, trait_ref: &TraitRef<'_>, ty: Ty<'tcx>) {\n+fn check_copy_clone<'tcx>(cx: &LateContext<'tcx>, item: &Item<'_>, trait_ref: &TraitRef<'_>, ty: Ty<'tcx>) {\n     if match_path(&trait_ref.path, &paths::CLONE_TRAIT) {\n         if !is_copy(cx, ty) {\n             return;\n@@ -222,18 +222,18 @@ fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item<'_>, trait\n }\n \n /// Implementation of the `UNSAFE_DERIVE_DESERIALIZE` lint.\n-fn check_unsafe_derive_deserialize<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn check_unsafe_derive_deserialize<'tcx>(\n+    cx: &LateContext<'tcx>,\n     item: &Item<'_>,\n     trait_ref: &TraitRef<'_>,\n     ty: Ty<'tcx>,\n ) {\n-    fn item_from_def_id<'tcx>(cx: &LateContext<'_, 'tcx>, def_id: DefId) -> &'tcx Item<'tcx> {\n+    fn item_from_def_id<'tcx>(cx: &LateContext<'tcx>, def_id: DefId) -> &'tcx Item<'tcx> {\n         let hir_id = cx.tcx.hir().as_local_hir_id(def_id.expect_local());\n         cx.tcx.hir().expect_item(hir_id)\n     }\n \n-    fn has_unsafe<'tcx>(cx: &LateContext<'_, 'tcx>, item: &'tcx Item<'_>) -> bool {\n+    fn has_unsafe<'tcx>(cx: &LateContext<'tcx>, item: &'tcx Item<'_>) -> bool {\n         let mut visitor = UnsafeVisitor { cx, has_unsafe: false };\n         walk_item(&mut visitor, item);\n         visitor.has_unsafe\n@@ -261,7 +261,7 @@ fn check_unsafe_derive_deserialize<'a, 'tcx>(\n }\n \n struct UnsafeVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     has_unsafe: bool,\n }\n "}, {"sha": "d52bb8961fae761193ef0d2fe3c4e41bcfbf37d7", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -146,12 +146,12 @@ impl DocMarkdown {\n \n impl_lint_pass!(DocMarkdown => [DOC_MARKDOWN, MISSING_SAFETY_DOC, MISSING_ERRORS_DOC, NEEDLESS_DOCTEST_MAIN]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DocMarkdown {\n-    fn check_crate(&mut self, cx: &LateContext<'a, 'tcx>, krate: &'tcx hir::Crate<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n+    fn check_crate(&mut self, cx: &LateContext<'tcx>, krate: &'tcx hir::Crate<'_>) {\n         check_attrs(cx, &self.valid_idents, &krate.item.attrs);\n     }\n \n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item<'_>) {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n         let headers = check_attrs(cx, &self.valid_idents, &item.attrs);\n         match item.kind {\n             hir::ItemKind::Fn(ref sig, _, body_id) => {\n@@ -171,13 +171,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DocMarkdown {\n         }\n     }\n \n-    fn check_item_post(&mut self, _cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item<'_>) {\n+    fn check_item_post(&mut self, _cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n         if let hir::ItemKind::Impl { .. } = item.kind {\n             self.in_trait_impl = false;\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem<'_>) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n         let headers = check_attrs(cx, &self.valid_idents, &item.attrs);\n         if let hir::TraitItemKind::Fn(ref sig, ..) = item.kind {\n             if !in_external_macro(cx.tcx.sess, item.span) {\n@@ -186,7 +186,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DocMarkdown {\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ImplItem<'_>) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n         let headers = check_attrs(cx, &self.valid_idents, &item.attrs);\n         if self.in_trait_impl || in_external_macro(cx.tcx.sess, item.span) {\n             return;\n@@ -197,8 +197,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DocMarkdown {\n     }\n }\n \n-fn lint_for_missing_headers<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn lint_for_missing_headers<'tcx>(\n+    cx: &LateContext<'tcx>,\n     hir_id: hir::HirId,\n     span: impl Into<MultiSpan> + Copy,\n     sig: &hir::FnSig<'_>,\n@@ -313,7 +313,7 @@ struct DocHeaders {\n     errors: bool,\n }\n \n-fn check_attrs<'a>(cx: &LateContext<'_, '_>, valid_idents: &FxHashSet<String>, attrs: &'a [Attribute]) -> DocHeaders {\n+fn check_attrs<'a>(cx: &LateContext<'_>, valid_idents: &FxHashSet<String>, attrs: &'a [Attribute]) -> DocHeaders {\n     let mut doc = String::new();\n     let mut spans = vec![];\n \n@@ -370,7 +370,7 @@ fn check_attrs<'a>(cx: &LateContext<'_, '_>, valid_idents: &FxHashSet<String>, a\n const RUST_CODE: &[&str] = &[\"rust\", \"no_run\", \"should_panic\", \"compile_fail\", \"edition2018\"];\n \n fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize>)>>(\n-    cx: &LateContext<'_, '_>,\n+    cx: &LateContext<'_>,\n     valid_idents: &FxHashSet<String>,\n     events: Events,\n     spans: &[(usize, Span)],\n@@ -442,13 +442,13 @@ fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize\n \n static LEAVE_MAIN_PATTERNS: &[&str] = &[\"static\", \"fn main() {}\", \"extern crate\", \"async fn main() {\"];\n \n-fn check_code(cx: &LateContext<'_, '_>, text: &str, span: Span) {\n+fn check_code(cx: &LateContext<'_>, text: &str, span: Span) {\n     if text.contains(\"fn main() {\") && !LEAVE_MAIN_PATTERNS.iter().any(|p| text.contains(p)) {\n         span_lint(cx, NEEDLESS_DOCTEST_MAIN, span, \"needless `fn main` in doctest\");\n     }\n }\n \n-fn check_text(cx: &LateContext<'_, '_>, valid_idents: &FxHashSet<String>, text: &str, span: Span) {\n+fn check_text(cx: &LateContext<'_>, valid_idents: &FxHashSet<String>, text: &str, span: Span) {\n     for word in text.split(|c: char| c.is_whitespace() || c == '\\'') {\n         // Trim punctuation as in `some comment (see foo::bar).`\n         //                                                   ^^\n@@ -471,7 +471,7 @@ fn check_text(cx: &LateContext<'_, '_>, valid_idents: &FxHashSet<String>, text:\n     }\n }\n \n-fn check_word(cx: &LateContext<'_, '_>, word: &str, span: Span) {\n+fn check_word(cx: &LateContext<'_>, word: &str, span: Span) {\n     /// Checks if a string is camel-case, i.e., contains at least two uppercase\n     /// letters (`Clippy` is ok) and one lower-case letter (`NASA` is ok).\n     /// Plurals are also excluded (`IDs` is ok)."}, {"sha": "5d16192b7543bd3ab7a368a050b7e239b7bd80b8", "filename": "src/tools/clippy/clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -37,9 +37,9 @@ declare_clippy_lint! {\n \n declare_lint_pass!(DoubleComparisons => [DOUBLE_COMPARISONS]);\n \n-impl<'a, 'tcx> DoubleComparisons {\n+impl<'tcx> DoubleComparisons {\n     #[allow(clippy::similar_names)]\n-    fn check_binop(cx: &LateContext<'a, 'tcx>, op: BinOpKind, lhs: &'tcx Expr<'_>, rhs: &'tcx Expr<'_>, span: Span) {\n+    fn check_binop(cx: &LateContext<'tcx>, op: BinOpKind, lhs: &'tcx Expr<'_>, rhs: &'tcx Expr<'_>, span: Span) {\n         let (lkind, llhs, lrhs, rkind, rlhs, rrhs) = match (&lhs.kind, &rhs.kind) {\n             (ExprKind::Binary(lb, llhs, lrhs), ExprKind::Binary(rb, rlhs, rrhs)) => {\n                 (lb.node, llhs, lrhs, rb.node, rlhs, rrhs)\n@@ -86,8 +86,8 @@ impl<'a, 'tcx> DoubleComparisons {\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DoubleComparisons {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for DoubleComparisons {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Binary(ref kind, ref lhs, ref rhs) = expr.kind {\n             Self::check_binop(cx, kind.node, lhs, rhs, expr.span);\n         }"}, {"sha": "4afbd1ed0e59b03b43d30ea6d957dd9751f37463", "filename": "src/tools/clippy/clippy_lints/src/drop_bounds.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_bounds.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -1,7 +1,7 @@\n use crate::utils::{match_def_path, paths, span_lint};\n use if_chain::if_chain;\n use rustc_hir::{GenericBound, GenericParam, WhereBoundPredicate, WherePredicate};\n-use rustc_lint::LateLintPass;\n+use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -41,13 +41,13 @@ const DROP_BOUNDS_SUMMARY: &str = \"Bounds of the form `T: Drop` are useless. \\\n \n declare_lint_pass!(DropBounds => [DROP_BOUNDS]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DropBounds {\n-    fn check_generic_param(&mut self, cx: &rustc_lint::LateContext<'a, 'tcx>, p: &'tcx GenericParam<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for DropBounds {\n+    fn check_generic_param(&mut self, cx: &LateContext<'tcx>, p: &'tcx GenericParam<'_>) {\n         for bound in p.bounds.iter() {\n             lint_bound(cx, bound);\n         }\n     }\n-    fn check_where_predicate(&mut self, cx: &rustc_lint::LateContext<'a, 'tcx>, p: &'tcx WherePredicate<'_>) {\n+    fn check_where_predicate(&mut self, cx: &LateContext<'tcx>, p: &'tcx WherePredicate<'_>) {\n         if let WherePredicate::BoundPredicate(WhereBoundPredicate { bounds, .. }) = p {\n             for bound in *bounds {\n                 lint_bound(cx, bound);\n@@ -56,7 +56,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DropBounds {\n     }\n }\n \n-fn lint_bound<'a, 'tcx>(cx: &rustc_lint::LateContext<'a, 'tcx>, bound: &'tcx GenericBound<'_>) {\n+fn lint_bound<'tcx>(cx: &LateContext<'tcx>, bound: &'tcx GenericBound<'_>) {\n     if_chain! {\n         if let GenericBound::Trait(t, _) = bound;\n         if let Some(def_id) = t.trait_ref.path.res.opt_def_id();"}, {"sha": "dcf772572e8cb03bd0b46ee51825bc9110085be1", "filename": "src/tools/clippy/clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -108,8 +108,8 @@ const FORGET_COPY_SUMMARY: &str = \"calls to `std::mem::forget` with a value that\n \n declare_lint_pass!(DropForgetRef => [DROP_REF, FORGET_REF, DROP_COPY, FORGET_COPY]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DropForgetRef {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for DropForgetRef {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Call(ref path, ref args) = expr.kind;\n             if let ExprKind::Path(ref qpath) = path.kind;"}, {"sha": "2ded375091c60f5be1822c2030b018f24b58346e", "filename": "src/tools/clippy/clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduration_subsec.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -38,8 +38,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(DurationSubsec => [DURATION_SUBSEC]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DurationSubsec {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for DurationSubsec {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Binary(Spanned { node: BinOpKind::Div, .. }, ref left, ref right) = expr.kind;\n             if let ExprKind::MethodCall(ref method_path, _ , ref args, _) = left.kind;"}, {"sha": "a249117d182fa360c4156b3e3abeb1d471e008c5", "filename": "src/tools/clippy/clippy_lints/src/empty_enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fempty_enum.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -38,8 +38,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(EmptyEnum => [EMPTY_ENUM]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EmptyEnum {\n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for EmptyEnum {\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n         let did = cx.tcx.hir().local_def_id(item.hir_id);\n         if let ItemKind::Enum(..) = item.kind {\n             let ty = cx.tcx.type_of(did);"}, {"sha": "4d2e17933ed6b55ffebad53cef764e58e80e0ce5", "filename": "src/tools/clippy/clippy_lints/src/entry.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -52,8 +52,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(HashMapPass => [MAP_ENTRY]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for HashMapPass {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let Some((ref check, ref then_block, ref else_block)) = higher::if_block(&expr) {\n             if let ExprKind::Unary(UnOp::UnNot, ref check) = check.kind {\n                 if let Some((ty, map, key)) = check_cond(cx, check) {\n@@ -98,10 +98,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for HashMapPass {\n     }\n }\n \n-fn check_cond<'a, 'tcx, 'b>(\n-    cx: &'a LateContext<'a, 'tcx>,\n-    check: &'b Expr<'b>,\n-) -> Option<(&'static str, &'b Expr<'b>, &'b Expr<'b>)> {\n+fn check_cond<'a>(cx: &LateContext<'_>, check: &'a Expr<'a>) -> Option<(&'static str, &'a Expr<'a>, &'a Expr<'a>)> {\n     if_chain! {\n         if let ExprKind::MethodCall(ref path, _, ref params, _) = check.kind;\n         if params.len() >= 2;\n@@ -127,7 +124,7 @@ fn check_cond<'a, 'tcx, 'b>(\n }\n \n struct InsertVisitor<'a, 'tcx, 'b> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     span: Span,\n     ty: &'static str,\n     map: &'b Expr<'b>,"}, {"sha": "91214f277be695cd6fbf83eb65d18b704509069b", "filename": "src/tools/clippy/clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -36,9 +36,9 @@ declare_clippy_lint! {\n \n declare_lint_pass!(UnportableVariant => [ENUM_CLIKE_UNPORTABLE_VARIANT]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n+impl<'tcx> LateLintPass<'tcx> for UnportableVariant {\n     #[allow(clippy::cast_possible_truncation, clippy::cast_possible_wrap, clippy::cast_sign_loss)]\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item<'_>) {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if cx.tcx.data_layout.pointer_size.bits() != 64 {\n             return;\n         }"}, {"sha": "ca921dcfdfe9288ccee3ce48c5bb68608a835026", "filename": "src/tools/clippy/clippy_lints/src/eq_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -52,9 +52,9 @@ declare_clippy_lint! {\n \n declare_lint_pass!(EqOp => [EQ_OP, OP_REF]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n+impl<'tcx> LateLintPass<'tcx> for EqOp {\n     #[allow(clippy::similar_names, clippy::too_many_lines)]\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if let ExprKind::Binary(op, ref left, ref right) = e.kind {\n             if e.span.from_expansion() {\n                 return;"}, {"sha": "8a2683806182648aee3c7601a2e8c032fe002c83", "filename": "src/tools/clippy/clippy_lints/src/erasing_op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ferasing_op.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -29,8 +29,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(ErasingOp => [ERASING_OP]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ErasingOp {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for ErasingOp {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if e.span.from_expansion() {\n             return;\n         }\n@@ -47,7 +47,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ErasingOp {\n     }\n }\n \n-fn check(cx: &LateContext<'_, '_>, e: &Expr<'_>, span: Span) {\n+fn check(cx: &LateContext<'_>, e: &Expr<'_>, span: Span) {\n     if let Some(Constant::Int(0)) = constant_simple(cx, cx.tables(), e) {\n         span_lint(\n             cx,"}, {"sha": "d40cdfcca9f66f0da9476166913d50b0dc047fdc", "filename": "src/tools/clippy/clippy_lints/src/escape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -49,17 +49,17 @@ fn is_non_trait_box(ty: Ty<'_>) -> bool {\n }\n \n struct EscapeDelegate<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     set: HirIdSet,\n     too_large_for_stack: u64,\n }\n \n impl_lint_pass!(BoxedLocal => [BOXED_LOCAL]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxedLocal {\n+impl<'tcx> LateLintPass<'tcx> for BoxedLocal {\n     fn check_fn(\n         &mut self,\n-        cx: &LateContext<'a, 'tcx>,\n+        cx: &LateContext<'tcx>,\n         _: intravisit::FnKind<'tcx>,\n         _: &'tcx FnDecl<'_>,\n         body: &'tcx Body<'_>,"}, {"sha": "ceed6a74c4fcc3d1ffb4110022b8b7e879296c69", "filename": "src/tools/clippy/clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -64,8 +64,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(EtaReduction => [REDUNDANT_CLOSURE, REDUNDANT_CLOSURE_FOR_METHOD_CALLS]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EtaReduction {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n@@ -81,7 +81,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EtaReduction {\n     }\n }\n \n-fn check_closure(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+fn check_closure(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if let ExprKind::Closure(_, ref decl, eid, _, _) = expr.kind {\n         let body = cx.tcx.hir().body(eid);\n         let ex = &body.value;\n@@ -151,7 +151,7 @@ fn check_closure(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n }\n \n /// Tries to determine the type for universal function call to be used instead of the closure\n-fn get_ufcs_type_name(cx: &LateContext<'_, '_>, method_def_id: def_id::DefId, self_arg: &Expr<'_>) -> Option<String> {\n+fn get_ufcs_type_name(cx: &LateContext<'_>, method_def_id: def_id::DefId, self_arg: &Expr<'_>) -> Option<String> {\n     let expected_type_of_self = &cx.tcx.fn_sig(method_def_id).inputs_and_output().skip_binder()[0];\n     let actual_type_of_self = &cx.tables().node_type(self_arg.hir_id);\n \n@@ -196,7 +196,7 @@ fn match_types(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n     }\n }\n \n-fn get_type_name(cx: &LateContext<'_, '_>, ty: Ty<'_>) -> String {\n+fn get_type_name(cx: &LateContext<'_>, ty: Ty<'_>) -> String {\n     match ty.kind {\n         ty::Adt(t, _) => cx.tcx.def_path_str(t.did),\n         ty::Ref(_, r, _) => get_type_name(cx, &r),"}, {"sha": "01b0d3c5edec22c938853328299f5ccf508ea5f0", "filename": "src/tools/clippy/clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -67,8 +67,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(EvalOrderDependence => [EVAL_ORDER_DEPENDENCE, DIVERGING_SUB_EXPRESSION]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EvalOrderDependence {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for EvalOrderDependence {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // Find a write to a local variable.\n         match expr.kind {\n             ExprKind::Assign(ref lhs, ..) | ExprKind::AssignOp(_, ref lhs, _) => {\n@@ -91,7 +91,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EvalOrderDependence {\n             _ => {},\n         }\n     }\n-    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt<'_>) {\n+    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         match stmt.kind {\n             StmtKind::Local(ref local) => {\n                 if let Local { init: Some(ref e), .. } = **local {\n@@ -105,7 +105,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EvalOrderDependence {\n }\n \n struct DivergenceVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n }\n \n impl<'a, 'tcx> DivergenceVisitor<'a, 'tcx> {\n@@ -285,7 +285,7 @@ fn check_stmt<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, stmt: &'tcx Stmt<'_>) -\n \n /// A visitor that looks for reads from a variable.\n struct ReadVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     /// The ID of the variable we're looking for.\n     var: HirId,\n     /// The expressions where the write to the variable occurred (for reporting\n@@ -354,7 +354,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n }\n \n /// Returns `true` if `expr` is the LHS of an assignment, like `expr = ...`.\n-fn is_in_assignment_position(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+fn is_in_assignment_position(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     if let Some(parent) = get_parent_expr(cx, expr) {\n         if let ExprKind::Assign(ref lhs, ..) = parent.kind {\n             return lhs.hir_id == expr.hir_id;"}, {"sha": "7337d98c8be378f8b01a24302f55a3fb101bd84a", "filename": "src/tools/clippy/clippy_lints/src/exit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexit.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -24,8 +24,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(Exit => [EXIT]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Exit {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for Exit {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Call(ref path_expr, ref _args) = e.kind;\n             if let ExprKind::Path(ref path) = path_expr.kind;"}, {"sha": "0240e80d8141818757a9aee4e853b58f7ea277c0", "filename": "src/tools/clippy/clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -28,8 +28,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(ExplicitWrite => [EXPLICIT_WRITE]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitWrite {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // match call to unwrap\n             if let ExprKind::MethodCall(ref unwrap_fun, _, ref unwrap_args, _) = expr.kind;"}, {"sha": "01ed0c426d436b56f72235a872f0ccab93fb37a1", "filename": "src/tools/clippy/clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -52,8 +52,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(FallibleImplFrom => [FALLIBLE_IMPL_FROM]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FallibleImplFrom {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for FallibleImplFrom {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n         // check for `impl From<???> for ..`\n         let impl_def_id = cx.tcx.hir().local_def_id(item.hir_id);\n         if_chain! {\n@@ -67,12 +67,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FallibleImplFrom {\n     }\n }\n \n-fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_items: &[hir::ImplItemRef<'_>]) {\n+fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[hir::ImplItemRef<'_>]) {\n     use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n     use rustc_hir::{Expr, ExprKind, ImplItemKind, QPath};\n \n     struct FindPanicUnwrap<'a, 'tcx> {\n-        lcx: &'a LateContext<'a, 'tcx>,\n+        lcx: &'a LateContext<'tcx>,\n         tables: &'tcx ty::TypeckTables<'tcx>,\n         result: Vec<Span>,\n     }"}, {"sha": "a3d2a949535a494cbe5687829d21c6da8c82046e", "filename": "src/tools/clippy/clippy_lints/src/float_literal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_literal.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -58,8 +58,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(FloatLiteral => [EXCESSIVE_PRECISION, LOSSY_FLOAT_LITERAL]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FloatLiteral {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for FloatLiteral {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n             let ty = cx.tables().expr_ty(expr);\n             if let ty::Float(fty) = ty.kind;"}, {"sha": "4efd06892679649ca485e4fa45dd3dca4b6efd29", "filename": "src/tools/clippy/clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -111,7 +111,7 @@ declare_lint_pass!(FloatingPointArithmetic => [\n \n // Returns the specialized log method for a given base if base is constant\n // and is one of 2, 10 and e\n-fn get_specialized_log_method(cx: &LateContext<'_, '_>, base: &Expr<'_>) -> Option<&'static str> {\n+fn get_specialized_log_method(cx: &LateContext<'_>, base: &Expr<'_>) -> Option<&'static str> {\n     if let Some((value, _)) = constant(cx, cx.tables(), base) {\n         if F32(2.0) == value || F64(2.0) == value {\n             return Some(\"log2\");\n@@ -126,7 +126,7 @@ fn get_specialized_log_method(cx: &LateContext<'_, '_>, base: &Expr<'_>) -> Opti\n }\n \n // Adds type suffixes and parenthesis to method receivers if necessary\n-fn prepare_receiver_sugg<'a>(cx: &LateContext<'_, '_>, mut expr: &'a Expr<'a>) -> Sugg<'a> {\n+fn prepare_receiver_sugg<'a>(cx: &LateContext<'_>, mut expr: &'a Expr<'a>) -> Sugg<'a> {\n     let mut suggestion = Sugg::hir(cx, expr, \"..\");\n \n     if let ExprKind::Unary(UnOp::UnNeg, inner_expr) = &expr.kind {\n@@ -163,7 +163,7 @@ fn prepare_receiver_sugg<'a>(cx: &LateContext<'_, '_>, mut expr: &'a Expr<'a>) -\n     suggestion.maybe_par()\n }\n \n-fn check_log_base(cx: &LateContext<'_, '_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n+fn check_log_base(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n     if let Some(method) = get_specialized_log_method(cx, &args[1]) {\n         span_lint_and_sugg(\n             cx,\n@@ -179,7 +179,7 @@ fn check_log_base(cx: &LateContext<'_, '_>, expr: &Expr<'_>, args: &[Expr<'_>])\n \n // TODO: Lint expressions of the form `(x + y).ln()` where y > 1 and\n // suggest usage of `(x + (y - 1)).ln_1p()` instead\n-fn check_ln1p(cx: &LateContext<'_, '_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n+fn check_ln1p(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n     if let ExprKind::Binary(\n         Spanned {\n             node: BinOpKind::Add, ..\n@@ -231,7 +231,7 @@ fn get_integer_from_float_constant(value: &Constant) -> Option<i32> {\n     }\n }\n \n-fn check_powf(cx: &LateContext<'_, '_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n+fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n     // Check receiver\n     if let Some((value, _)) = constant(cx, cx.tables(), &args[0]) {\n         let method = if F32(f32_consts::E) == value || F64(f64_consts::E) == value {\n@@ -295,7 +295,7 @@ fn check_powf(cx: &LateContext<'_, '_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n \n // TODO: Lint expressions of the form `x.exp() - y` where y > 1\n // and suggest usage of `x.exp_m1() - (y - 1)` instead\n-fn check_expm1(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+fn check_expm1(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n         if let ExprKind::Binary(Spanned { node: BinOpKind::Sub, .. }, ref lhs, ref rhs) = expr.kind;\n         if cx.tables().expr_ty(lhs).is_floating_point();\n@@ -321,7 +321,7 @@ fn check_expm1(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n     }\n }\n \n-fn is_float_mul_expr<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr<'a>) -> Option<(&'a Expr<'a>, &'a Expr<'a>)> {\n+fn is_float_mul_expr<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(&'a Expr<'a>, &'a Expr<'a>)> {\n     if_chain! {\n         if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref lhs, ref rhs) = &expr.kind;\n         if cx.tables().expr_ty(lhs).is_floating_point();\n@@ -335,7 +335,7 @@ fn is_float_mul_expr<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr<'a>) -> Option\n }\n \n // TODO: Fix rust-lang/rust-clippy#4735\n-fn check_mul_add(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+fn check_mul_add(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if let ExprKind::Binary(\n         Spanned {\n             node: BinOpKind::Add, ..\n@@ -373,7 +373,7 @@ fn check_mul_add(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n /// test is positive or an expression which tests whether or not test\n /// is nonnegative.\n /// Used for check-custom-abs function below\n-fn is_testing_positive(cx: &LateContext<'_, '_>, expr: &Expr<'_>, test: &Expr<'_>) -> bool {\n+fn is_testing_positive(cx: &LateContext<'_>, expr: &Expr<'_>, test: &Expr<'_>) -> bool {\n     if let ExprKind::Binary(Spanned { node: op, .. }, left, right) = expr.kind {\n         match op {\n             BinOpKind::Gt | BinOpKind::Ge => is_zero(cx, right) && are_exprs_equal(cx, left, test),\n@@ -386,7 +386,7 @@ fn is_testing_positive(cx: &LateContext<'_, '_>, expr: &Expr<'_>, test: &Expr<'_\n }\n \n /// See [`is_testing_positive`]\n-fn is_testing_negative(cx: &LateContext<'_, '_>, expr: &Expr<'_>, test: &Expr<'_>) -> bool {\n+fn is_testing_negative(cx: &LateContext<'_>, expr: &Expr<'_>, test: &Expr<'_>) -> bool {\n     if let ExprKind::Binary(Spanned { node: op, .. }, left, right) = expr.kind {\n         match op {\n             BinOpKind::Gt | BinOpKind::Ge => is_zero(cx, left) && are_exprs_equal(cx, right, test),\n@@ -398,12 +398,12 @@ fn is_testing_negative(cx: &LateContext<'_, '_>, expr: &Expr<'_>, test: &Expr<'_\n     }\n }\n \n-fn are_exprs_equal(cx: &LateContext<'_, '_>, expr1: &Expr<'_>, expr2: &Expr<'_>) -> bool {\n+fn are_exprs_equal(cx: &LateContext<'_>, expr1: &Expr<'_>, expr2: &Expr<'_>) -> bool {\n     SpanlessEq::new(cx).ignore_fn().eq_expr(expr1, expr2)\n }\n \n /// Returns true iff expr is some zero literal\n-fn is_zero(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+fn is_zero(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     match constant_simple(cx, cx.tables(), expr) {\n         Some(Constant::Int(i)) => i == 0,\n         Some(Constant::F32(f)) => f == 0.0,\n@@ -418,7 +418,7 @@ fn is_zero(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n /// one of the two expressions\n /// If the two expressions are not negations of each other, then it\n /// returns None.\n-fn are_negated<'a>(cx: &LateContext<'_, '_>, expr1: &'a Expr<'a>, expr2: &'a Expr<'a>) -> Option<(bool, &'a Expr<'a>)> {\n+fn are_negated<'a>(cx: &LateContext<'_>, expr1: &'a Expr<'a>, expr2: &'a Expr<'a>) -> Option<(bool, &'a Expr<'a>)> {\n     if let ExprKind::Unary(UnOp::UnNeg, expr1_negated) = &expr1.kind {\n         if are_exprs_equal(cx, expr1_negated, expr2) {\n             return Some((false, expr2));\n@@ -432,7 +432,7 @@ fn are_negated<'a>(cx: &LateContext<'_, '_>, expr1: &'a Expr<'a>, expr2: &'a Exp\n     None\n }\n \n-fn check_custom_abs(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+fn check_custom_abs(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n         if let Some((cond, body, Some(else_body))) = higher::if_block(&expr);\n         if let ExprKind::Block(block, _) = body.kind;\n@@ -479,8 +479,8 @@ fn check_custom_abs(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FloatingPointArithmetic {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for FloatingPointArithmetic {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::MethodCall(ref path, _, args, _) = &expr.kind {\n             let recv_ty = cx.tables().expr_ty(&args[0]);\n "}, {"sha": "33b6bfc459f9143fff8bcd47899d6aef1f6a183f", "filename": "src/tools/clippy/clippy_lints/src/format.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -40,8 +40,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(UselessFormat => [USELESS_FORMAT]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessFormat {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for UselessFormat {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         let span = match is_expn_of(expr.span, \"format\") {\n             Some(s) if !s.from_expansion() => s,\n             _ => return,\n@@ -75,11 +75,7 @@ fn span_useless_format<T: LintContext>(cx: &T, span: Span, help: &str, mut sugg:\n     });\n }\n \n-fn on_argumentv1_new<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx Expr<'_>,\n-    arms: &'tcx [Arm<'_>],\n-) -> Option<String> {\n+fn on_argumentv1_new<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) -> Option<String> {\n     if_chain! {\n         if let ExprKind::AddrOf(BorrowKind::Ref, _, ref format_args) = expr.kind;\n         if let ExprKind::Array(ref elems) = arms[0].body.kind;\n@@ -118,7 +114,7 @@ fn on_argumentv1_new<'a, 'tcx>(\n     None\n }\n \n-fn on_new_v1<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) -> Option<String> {\n+fn on_new_v1<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<String> {\n     if_chain! {\n         if let Some(args) = match_function_call(cx, expr, &paths::FMT_ARGUMENTS_NEW_V1);\n         if args.len() == 2;\n@@ -145,7 +141,7 @@ fn on_new_v1<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) -> Opti\n     None\n }\n \n-fn on_new_v1_fmt<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) -> Option<String> {\n+fn on_new_v1_fmt<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<String> {\n     if_chain! {\n         if let Some(args) = match_function_call(cx, expr, &paths::FMT_ARGUMENTS_NEW_V1_FORMATTED);\n         if args.len() == 3;"}, {"sha": "3f030dd84225b74cc3f9d0e7b162066029dd0f32", "filename": "src/tools/clippy/clippy_lints/src/functions.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -190,10 +190,10 @@ impl_lint_pass!(Functions => [\n     MUST_USE_CANDIDATE,\n ]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n+impl<'tcx> LateLintPass<'tcx> for Functions {\n     fn check_fn(\n         &mut self,\n-        cx: &LateContext<'a, 'tcx>,\n+        cx: &LateContext<'tcx>,\n         kind: intravisit::FnKind<'tcx>,\n         decl: &'tcx hir::FnDecl<'_>,\n         body: &'tcx hir::Body<'_>,\n@@ -230,7 +230,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n         self.check_line_number(cx, span, body);\n     }\n \n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item<'_>) {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n         let attr = must_use_attr(&item.attrs);\n         if let hir::ItemKind::Fn(ref sig, ref _generics, ref body_id) = item.kind {\n             if let Some(attr) = attr {\n@@ -255,7 +255,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ImplItem<'_>) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n         if let hir::ImplItemKind::Fn(ref sig, ref body_id) = item.kind {\n             let attr = must_use_attr(&item.attrs);\n             if let Some(attr) = attr {\n@@ -278,7 +278,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem<'_>) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n         if let hir::TraitItemKind::Fn(ref sig, ref eid) = item.kind {\n             // don't lint extern functions decls, it's not their fault\n             if sig.header.abi == Abi::Rust {\n@@ -310,8 +310,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n     }\n }\n \n-impl<'a, 'tcx> Functions {\n-    fn check_arg_number(self, cx: &LateContext<'_, '_>, decl: &hir::FnDecl<'_>, fn_span: Span) {\n+impl<'tcx> Functions {\n+    fn check_arg_number(self, cx: &LateContext<'_>, decl: &hir::FnDecl<'_>, fn_span: Span) {\n         let args = decl.inputs.len() as u64;\n         if args > self.threshold {\n             span_lint(\n@@ -323,7 +323,7 @@ impl<'a, 'tcx> Functions {\n         }\n     }\n \n-    fn check_line_number(self, cx: &LateContext<'_, '_>, span: Span, body: &'tcx hir::Body<'_>) {\n+    fn check_line_number(self, cx: &LateContext<'_>, span: Span, body: &'tcx hir::Body<'_>) {\n         if in_external_macro(cx.sess(), span) {\n             return;\n         }\n@@ -378,7 +378,7 @@ impl<'a, 'tcx> Functions {\n     }\n \n     fn check_raw_ptr(\n-        cx: &LateContext<'a, 'tcx>,\n+        cx: &LateContext<'tcx>,\n         unsafety: hir::Unsafety,\n         decl: &'tcx hir::FnDecl<'_>,\n         body: &'tcx hir::Body<'_>,\n@@ -406,7 +406,7 @@ impl<'a, 'tcx> Functions {\n }\n \n fn check_needless_must_use(\n-    cx: &LateContext<'_, '_>,\n+    cx: &LateContext<'_>,\n     decl: &hir::FnDecl<'_>,\n     item_id: hir::HirId,\n     item_span: Span,\n@@ -443,8 +443,8 @@ fn check_needless_must_use(\n     }\n }\n \n-fn check_must_use_candidate<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn check_must_use_candidate<'tcx>(\n+    cx: &LateContext<'tcx>,\n     decl: &'tcx hir::FnDecl<'_>,\n     body: &'tcx hir::Body<'_>,\n     item_span: Span,\n@@ -484,12 +484,12 @@ fn returns_unit(decl: &hir::FnDecl<'_>) -> bool {\n     }\n }\n \n-fn has_mutable_arg(cx: &LateContext<'_, '_>, body: &hir::Body<'_>) -> bool {\n+fn has_mutable_arg(cx: &LateContext<'_>, body: &hir::Body<'_>) -> bool {\n     let mut tys = FxHashSet::default();\n     body.params.iter().any(|param| is_mutable_pat(cx, &param.pat, &mut tys))\n }\n \n-fn is_mutable_pat(cx: &LateContext<'_, '_>, pat: &hir::Pat<'_>, tys: &mut FxHashSet<DefId>) -> bool {\n+fn is_mutable_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, tys: &mut FxHashSet<DefId>) -> bool {\n     if let hir::PatKind::Wild = pat.kind {\n         return false; // ignore `_` patterns\n     }\n@@ -508,7 +508,7 @@ fn is_mutable_pat(cx: &LateContext<'_, '_>, pat: &hir::Pat<'_>, tys: &mut FxHash\n \n static KNOWN_WRAPPER_TYS: &[&[&str]] = &[&[\"alloc\", \"rc\", \"Rc\"], &[\"std\", \"sync\", \"Arc\"]];\n \n-fn is_mutable_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>, span: Span, tys: &mut FxHashSet<DefId>) -> bool {\n+fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &mut FxHashSet<DefId>) -> bool {\n     match ty.kind {\n         // primitive types are never mutable\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => false,\n@@ -537,7 +537,7 @@ fn raw_ptr_arg(arg: &hir::Param<'_>, ty: &hir::Ty<'_>) -> Option<hir::HirId> {\n }\n \n struct DerefVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     ptrs: FxHashSet<hir::HirId>,\n     tables: &'a ty::TypeckTables<'tcx>,\n }\n@@ -596,7 +596,7 @@ impl<'a, 'tcx> DerefVisitor<'a, 'tcx> {\n }\n \n struct StaticMutVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     mutates_static: bool,\n }\n \n@@ -641,7 +641,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n     }\n }\n \n-fn is_mutated_static(cx: &LateContext<'_, '_>, e: &hir::Expr<'_>) -> bool {\n+fn is_mutated_static(cx: &LateContext<'_>, e: &hir::Expr<'_>) -> bool {\n     use hir::ExprKind::{Field, Index, Path};\n \n     match e.kind {\n@@ -657,7 +657,7 @@ fn is_mutated_static(cx: &LateContext<'_, '_>, e: &hir::Expr<'_>) -> bool {\n     }\n }\n \n-fn mutates_static<'a, 'tcx>(cx: &'a LateContext<'a, 'tcx>, body: &'tcx hir::Body<'_>) -> bool {\n+fn mutates_static<'tcx>(cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) -> bool {\n     let mut v = StaticMutVisitor {\n         cx,\n         mutates_static: false,"}, {"sha": "92c7e66a0eb85b7b73408dcff2ddcd3fd985ee8a", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -47,10 +47,10 @@ declare_clippy_lint! {\n \n declare_lint_pass!(FutureNotSend => [FUTURE_NOT_SEND]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FutureNotSend {\n+impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n     fn check_fn(\n         &mut self,\n-        cx: &LateContext<'a, 'tcx>,\n+        cx: &LateContext<'tcx>,\n         kind: FnKind<'tcx>,\n         decl: &'tcx FnDecl<'tcx>,\n         _: &'tcx Body<'tcx>,"}, {"sha": "2d93ecc00a769328d46ca8bf0dc09172ae1510b3", "filename": "src/tools/clippy/clippy_lints/src/get_last_with_len.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fget_last_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fget_last_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fget_last_with_len.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -43,8 +43,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(GetLastWithLen => [GET_LAST_WITH_LEN]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for GetLastWithLen {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for GetLastWithLen {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // Is a method call\n             if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;"}, {"sha": "dc9d636bc6de14d7b1e33349181e233810a7550c", "filename": "src/tools/clippy/clippy_lints/src/identity_op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fidentity_op.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -28,8 +28,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(IdentityOp => [IDENTITY_OP]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for IdentityOp {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if e.span.from_expansion() {\n             return;\n         }\n@@ -58,7 +58,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n     }\n }\n \n-fn is_allowed(cx: &LateContext<'_, '_>, cmp: BinOp, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n+fn is_allowed(cx: &LateContext<'_>, cmp: BinOp, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n     // `1 << 0` is a common pattern in bit manipulation code\n     if_chain! {\n         if let BinOpKind::Shl = cmp.node;\n@@ -73,7 +73,7 @@ fn is_allowed(cx: &LateContext<'_, '_>, cmp: BinOp, left: &Expr<'_>, right: &Exp\n }\n \n #[allow(clippy::cast_possible_wrap)]\n-fn check(cx: &LateContext<'_, '_>, e: &Expr<'_>, m: i8, span: Span, arg: Span) {\n+fn check(cx: &LateContext<'_>, e: &Expr<'_>, m: i8, span: Span, arg: Span) {\n     if let Some(Constant::Int(v)) = constant_simple(cx, cx.tables(), e) {\n         let check = match cx.tables().expr_ty(e).kind {\n             ty::Int(ity) => unsext(cx.tcx, -1_i128, ity),"}, {"sha": "f911cb68ea57946a0769b0e3f575bd8bc6454ead", "filename": "src/tools/clippy/clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -40,8 +40,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(IfLetMutex => [IF_LET_MUTEX]);\n \n-impl LateLintPass<'_, '_> for IfLetMutex {\n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, ex: &'_ Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for IfLetMutex {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, ex: &'tcx Expr<'tcx>) {\n         let mut arm_visit = ArmVisitor {\n             mutex_lock_called: false,\n             found_mutex: None,\n@@ -82,13 +82,13 @@ impl LateLintPass<'_, '_> for IfLetMutex {\n }\n \n /// Checks if `Mutex::lock` is called in the `if let _ = expr.\n-pub struct OppVisitor<'tcx, 'l> {\n+pub struct OppVisitor<'a, 'tcx> {\n     mutex_lock_called: bool,\n     found_mutex: Option<&'tcx Expr<'tcx>>,\n-    cx: &'tcx LateContext<'tcx, 'l>,\n+    cx: &'a LateContext<'tcx>,\n }\n \n-impl<'tcx, 'l> Visitor<'tcx> for OppVisitor<'tcx, 'l> {\n+impl<'tcx> Visitor<'tcx> for OppVisitor<'_, 'tcx> {\n     type Map = Map<'tcx>;\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n@@ -109,13 +109,13 @@ impl<'tcx, 'l> Visitor<'tcx> for OppVisitor<'tcx, 'l> {\n }\n \n /// Checks if `Mutex::lock` is called in any of the branches.\n-pub struct ArmVisitor<'tcx, 'l> {\n+pub struct ArmVisitor<'a, 'tcx> {\n     mutex_lock_called: bool,\n     found_mutex: Option<&'tcx Expr<'tcx>>,\n-    cx: &'tcx LateContext<'tcx, 'l>,\n+    cx: &'a LateContext<'tcx>,\n }\n \n-impl<'tcx, 'l> Visitor<'tcx> for ArmVisitor<'tcx, 'l> {\n+impl<'tcx> Visitor<'tcx> for ArmVisitor<'_, 'tcx> {\n     type Map = Map<'tcx>;\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n@@ -135,8 +135,8 @@ impl<'tcx, 'l> Visitor<'tcx> for ArmVisitor<'tcx, 'l> {\n     }\n }\n \n-impl<'tcx, 'l> ArmVisitor<'tcx, 'l> {\n-    fn same_mutex(&self, cx: &LateContext<'_, '_>, op_mutex: &Expr<'_>) -> bool {\n+impl<'tcx> ArmVisitor<'_, 'tcx> {\n+    fn same_mutex(&self, cx: &LateContext<'_>, op_mutex: &Expr<'_>) -> bool {\n         if let Some(arm_mutex) = self.found_mutex {\n             SpanlessEq::new(cx).eq_expr(op_mutex, arm_mutex)\n         } else {\n@@ -145,7 +145,7 @@ impl<'tcx, 'l> ArmVisitor<'tcx, 'l> {\n     }\n }\n \n-fn is_mutex_lock_call<'a>(cx: &LateContext<'a, '_>, expr: &'a Expr<'_>) -> Option<&'a Expr<'a>> {\n+fn is_mutex_lock_call<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     if_chain! {\n         if let ExprKind::MethodCall(path, _span, args, _) = &expr.kind;\n         if path.ident.to_string() == \"lock\";"}, {"sha": "9e2989dc01e52700f3f32d2006892fe5e5831a3f", "filename": "src/tools/clippy/clippy_lints/src/if_let_some_result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_some_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_some_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_some_result.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -37,8 +37,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(OkIfLet => [IF_LET_SOME_RESULT]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OkIfLet {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for OkIfLet {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! { //begin checking variables\n             if let ExprKind::Match(ref op, ref body, source) = expr.kind; //test if expr is a match\n             if let MatchSource::IfLetDesugar { .. } = source; //test if it is an If Let"}, {"sha": "22c4fef32a32b00c5cac0b25a44a066eba1d0b53", "filename": "src/tools/clippy/clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_return.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -44,7 +44,7 @@ declare_lint_pass!(ImplicitReturn => [IMPLICIT_RETURN]);\n static LINT_BREAK: &str = \"change `break` to `return` as shown\";\n static LINT_RETURN: &str = \"add `return` as shown\";\n \n-fn lint(cx: &LateContext<'_, '_>, outer_span: Span, inner_span: Span, msg: &str) {\n+fn lint(cx: &LateContext<'_>, outer_span: Span, inner_span: Span, msg: &str) {\n     let outer_span = outer_span.source_callsite();\n     let inner_span = inner_span.source_callsite();\n \n@@ -60,7 +60,7 @@ fn lint(cx: &LateContext<'_, '_>, outer_span: Span, inner_span: Span, msg: &str)\n     });\n }\n \n-fn expr_match(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+fn expr_match(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     match expr.kind {\n         // loops could be using `break` instead of `return`\n         ExprKind::Block(block, ..) | ExprKind::Loop(block, ..) => {\n@@ -122,10 +122,10 @@ fn expr_match(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitReturn {\n+impl<'tcx> LateLintPass<'tcx> for ImplicitReturn {\n     fn check_fn(\n         &mut self,\n-        cx: &LateContext<'a, 'tcx>,\n+        cx: &LateContext<'tcx>,\n         _: FnKind<'tcx>,\n         _: &'tcx FnDecl<'_>,\n         body: &'tcx Body<'_>,"}, {"sha": "f38530aca0cec8de00cc5114bede50e792f9f272", "filename": "src/tools/clippy/clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -36,8 +36,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(ImplicitSaturatingSub => [IMPLICIT_SATURATING_SUB]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitSaturatingSub {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'tcx>) {\n+impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         if in_macro(expr.span) {\n             return;\n         }\n@@ -118,7 +118,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitSaturatingSub {\n     }\n }\n \n-fn subtracts_one<'a>(cx: &LateContext<'_, '_>, expr: &Expr<'a>) -> Option<&'a Expr<'a>> {\n+fn subtracts_one<'a>(cx: &LateContext<'_>, expr: &Expr<'a>) -> Option<&'a Expr<'a>> {\n     match expr.kind {\n         ExprKind::AssignOp(ref op1, ref target, ref value) => {\n             if_chain! {\n@@ -153,7 +153,7 @@ fn subtracts_one<'a>(cx: &LateContext<'_, '_>, expr: &Expr<'a>) -> Option<&'a Ex\n     }\n }\n \n-fn print_lint_and_sugg(cx: &LateContext<'_, '_>, var_name: &str, expr: &Expr<'_>) {\n+fn print_lint_and_sugg(cx: &LateContext<'_>, var_name: &str, expr: &Expr<'_>) {\n     span_lint_and_sugg(\n         cx,\n         IMPLICIT_SATURATING_SUB,"}, {"sha": "5857a405b0cf37800293a1abecddbeb58341900a", "filename": "src/tools/clippy/clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -85,8 +85,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(IndexingSlicing => [INDEXING_SLICING, OUT_OF_BOUNDS_INDEXING]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for IndexingSlicing {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Index(ref array, ref index) = &expr.kind {\n             let ty = cx.tables().expr_ty(array);\n             if let Some(range) = higher::range(cx, index) {\n@@ -164,8 +164,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n \n /// Returns a tuple of options with the start and end (exclusive) values of\n /// the range. If the start or end is not constant, None is returned.\n-fn to_const_range<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn to_const_range<'tcx>(\n+    cx: &LateContext<'tcx>,\n     range: higher::Range<'_>,\n     array_size: u128,\n ) -> (Option<u128>, Option<u128>) {"}, {"sha": "3ffc2dd60d9c0b362077840c1b5f99b5384bdfba", "filename": "src/tools/clippy/clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -44,8 +44,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(InfiniteIter => [INFINITE_ITER, MAYBE_INFINITE_ITER]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InfiniteIter {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for InfiniteIter {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         let (lint, msg) = match complete_infinite_iter(cx, expr) {\n             Infinite => (INFINITE_ITER, \"infinite iteration detected\"),\n             MaybeInfinite => (MAYBE_INFINITE_ITER, \"possible infinite iteration detected\"),\n@@ -140,7 +140,7 @@ const HEURISTICS: [(&str, usize, Heuristic, Finiteness); 19] = [\n     (\"scan\", 3, First, MaybeInfinite),\n ];\n \n-fn is_infinite(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Finiteness {\n+fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n     match expr.kind {\n         ExprKind::MethodCall(ref method, _, ref args, _) => {\n             for &(name, len, heuristic, cap) in &HEURISTICS {\n@@ -216,7 +216,7 @@ const INFINITE_COLLECTORS: [&[&str]; 8] = [\n     &paths::VEC_DEQUE,\n ];\n \n-fn complete_infinite_iter(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Finiteness {\n+fn complete_infinite_iter(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n     match expr.kind {\n         ExprKind::MethodCall(ref method, _, ref args, _) => {\n             for &(name, len) in &COMPLETING_METHODS {"}, {"sha": "bd7ca03883945023458fc4ed6328e3ad14bc6d31", "filename": "src/tools/clippy/clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_impl.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -47,8 +47,8 @@ pub struct MultipleInherentImpl {\n \n impl_lint_pass!(MultipleInherentImpl => [MULTIPLE_INHERENT_IMPL]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MultipleInherentImpl {\n-    fn check_item(&mut self, _: &LateContext<'a, 'tcx>, item: &'tcx Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for MultipleInherentImpl {\n+    fn check_item(&mut self, _: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if let ItemKind::Impl {\n             ref generics,\n             of_trait: None,\n@@ -64,7 +64,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MultipleInherentImpl {\n         }\n     }\n \n-    fn check_crate_post(&mut self, cx: &LateContext<'a, 'tcx>, krate: &'tcx Crate<'_>) {\n+    fn check_crate_post(&mut self, cx: &LateContext<'tcx>, krate: &'tcx Crate<'_>) {\n         if let Some(item) = krate.items.values().next() {\n             // Retrieve all inherent implementations from the crate, grouped by type\n             for impls in cx"}, {"sha": "f330fa8fab8f4ea08c1a004f62be5fa58c53bed5", "filename": "src/tools/clippy/clippy_lints/src/inherent_to_string.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -92,8 +92,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(InherentToString => [INHERENT_TO_STRING, INHERENT_TO_STRING_SHADOW_DISPLAY]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InherentToString {\n-    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, impl_item: &'tcx ImplItem<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for InherentToString {\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx ImplItem<'_>) {\n         if impl_item.span.from_expansion() {\n             return;\n         }\n@@ -119,7 +119,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InherentToString {\n     }\n }\n \n-fn show_lint(cx: &LateContext<'_, '_>, item: &ImplItem<'_>) {\n+fn show_lint(cx: &LateContext<'_>, item: &ImplItem<'_>) {\n     let display_trait_id = get_trait_def_id(cx, &paths::DISPLAY_TRAIT).expect(\"Failed to get trait ID of `Display`!\");\n \n     // Get the real type of 'self'"}, {"sha": "decbee278154af452f837477b207df4063545e89", "filename": "src/tools/clippy/clippy_lints/src/inline_fn_without_body.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finline_fn_without_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finline_fn_without_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finline_fn_without_body.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -31,15 +31,15 @@ declare_clippy_lint! {\n \n declare_lint_pass!(InlineFnWithoutBody => [INLINE_FN_WITHOUT_BODY]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InlineFnWithoutBody {\n-    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for InlineFnWithoutBody {\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'_>) {\n         if let TraitItemKind::Fn(_, TraitFn::Required(_)) = item.kind {\n             check_attrs(cx, item.ident.name, &item.attrs);\n         }\n     }\n }\n \n-fn check_attrs(cx: &LateContext<'_, '_>, name: Symbol, attrs: &[Attribute]) {\n+fn check_attrs(cx: &LateContext<'_>, name: Symbol, attrs: &[Attribute]) {\n     for attr in attrs {\n         if !attr.check_name(sym!(inline)) {\n             continue;"}, {"sha": "e754c7b482a6882bf84043a756e0b86ceeadcbd7", "filename": "src/tools/clippy/clippy_lints/src/integer_division.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finteger_division.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finteger_division.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finteger_division.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -30,8 +30,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(IntegerDivision => [INTEGER_DIVISION]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IntegerDivision {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for IntegerDivision {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if is_integer_division(cx, expr) {\n             span_lint_and_help(\n                 cx,\n@@ -45,7 +45,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IntegerDivision {\n     }\n }\n \n-fn is_integer_division<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) -> bool {\n+fn is_integer_division<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) -> bool {\n     if_chain! {\n         if let hir::ExprKind::Binary(binop, left, right) = &expr.kind;\n         if let hir::BinOpKind::Div = &binop.node;"}, {"sha": "c6cc174a8c97b28b6203a684e729d7dfd599aa42", "filename": "src/tools/clippy/clippy_lints/src/large_const_arrays.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -45,8 +45,8 @@ impl LargeConstArrays {\n \n impl_lint_pass!(LargeConstArrays => [LARGE_CONST_ARRAYS]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeConstArrays {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for LargeConstArrays {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if_chain! {\n             if !item.span.from_expansion();\n             if let ItemKind::Const(hir_ty, _) = &item.kind;"}, {"sha": "3c7880d74ee6490ff27eec53f633337531e53542", "filename": "src/tools/clippy/clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -56,8 +56,8 @@ impl LargeEnumVariant {\n \n impl_lint_pass!(LargeEnumVariant => [LARGE_ENUM_VARIANT]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for LargeEnumVariant {\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n         let did = cx.tcx.hir().local_def_id(item.hir_id);\n         if let ItemKind::Enum(ref def, _) = item.kind {\n             let ty = cx.tcx.type_of(did);"}, {"sha": "8eb986c25ff790e8ff97a23ad5704dfe66b2a703", "filename": "src/tools/clippy/clippy_lints/src/large_stack_arrays.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -38,8 +38,8 @@ impl LargeStackArrays {\n \n impl_lint_pass!(LargeStackArrays => [LARGE_STACK_ARRAYS]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeStackArrays {\n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for LargeStackArrays {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Repeat(_, _) = expr.kind;\n             if let ty::Array(element_type, cst) = cx.tables().expr_ty(expr).kind;"}, {"sha": "26d96428771d6263db2c6623c3e54982b51bdee6", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -70,8 +70,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(LenZero => [LEN_ZERO, LEN_WITHOUT_IS_EMPTY]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for LenZero {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if item.span.from_expansion() {\n             return;\n         }\n@@ -87,7 +87,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if expr.span.from_expansion() {\n             return;\n         }\n@@ -118,8 +118,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n     }\n }\n \n-fn check_trait_items(cx: &LateContext<'_, '_>, visited_trait: &Item<'_>, trait_items: &[TraitItemRef]) {\n-    fn is_named_self(cx: &LateContext<'_, '_>, item: &TraitItemRef, name: &str) -> bool {\n+fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items: &[TraitItemRef]) {\n+    fn is_named_self(cx: &LateContext<'_>, item: &TraitItemRef, name: &str) -> bool {\n         item.ident.name.as_str() == name\n             && if let AssocItemKind::Fn { has_self } = item.kind {\n                 has_self && {\n@@ -132,7 +132,7 @@ fn check_trait_items(cx: &LateContext<'_, '_>, visited_trait: &Item<'_>, trait_i\n     }\n \n     // fill the set with current and super traits\n-    fn fill_trait_set(traitt: DefId, set: &mut FxHashSet<DefId>, cx: &LateContext<'_, '_>) {\n+    fn fill_trait_set(traitt: DefId, set: &mut FxHashSet<DefId>, cx: &LateContext<'_>) {\n         if set.insert(traitt) {\n             for supertrait in rustc_trait_selection::traits::supertrait_def_ids(cx.tcx, traitt) {\n                 fill_trait_set(supertrait, set, cx);\n@@ -169,8 +169,8 @@ fn check_trait_items(cx: &LateContext<'_, '_>, visited_trait: &Item<'_>, trait_i\n     }\n }\n \n-fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item<'_>, impl_items: &[ImplItemRef<'_>]) {\n-    fn is_named_self(cx: &LateContext<'_, '_>, item: &ImplItemRef<'_>, name: &str) -> bool {\n+fn check_impl_items(cx: &LateContext<'_>, item: &Item<'_>, impl_items: &[ImplItemRef<'_>]) {\n+    fn is_named_self(cx: &LateContext<'_>, item: &ImplItemRef<'_>, name: &str) -> bool {\n         item.ident.name.as_str() == name\n             && if let AssocItemKind::Fn { has_self } = item.kind {\n                 has_self && {\n@@ -210,7 +210,7 @@ fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item<'_>, impl_items: &[Imp\n     }\n }\n \n-fn check_cmp(cx: &LateContext<'_, '_>, span: Span, method: &Expr<'_>, lit: &Expr<'_>, op: &str, compare_to: u32) {\n+fn check_cmp(cx: &LateContext<'_>, span: Span, method: &Expr<'_>, lit: &Expr<'_>, op: &str, compare_to: u32) {\n     if let (&ExprKind::MethodCall(ref method_path, _, ref args, _), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind)\n     {\n         // check if we are in an is_empty() method\n@@ -225,7 +225,7 @@ fn check_cmp(cx: &LateContext<'_, '_>, span: Span, method: &Expr<'_>, lit: &Expr\n }\n \n fn check_len(\n-    cx: &LateContext<'_, '_>,\n+    cx: &LateContext<'_>,\n     span: Span,\n     method_name: Symbol,\n     args: &[Expr<'_>],\n@@ -259,9 +259,9 @@ fn check_len(\n }\n \n /// Checks if this type has an `is_empty` method.\n-fn has_is_empty(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     /// Special case ranges until `range_is_empty` is stabilized. See issue 3807.\n-    fn should_skip_range(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+    fn should_skip_range(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n         higher::range(cx, expr).map_or(false, |_| {\n             !cx.tcx\n                 .features()\n@@ -272,7 +272,7 @@ fn has_is_empty(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n     }\n \n     /// Gets an `AssocItem` and return true if it matches `is_empty(self)`.\n-    fn is_is_empty(cx: &LateContext<'_, '_>, item: &ty::AssocItem) -> bool {\n+    fn is_is_empty(cx: &LateContext<'_>, item: &ty::AssocItem) -> bool {\n         if let ty::AssocKind::Fn = item.kind {\n             if item.ident.name.as_str() == \"is_empty\" {\n                 let sig = cx.tcx.fn_sig(item.def_id);\n@@ -287,7 +287,7 @@ fn has_is_empty(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n     }\n \n     /// Checks the inherent impl's items for an `is_empty(self)` method.\n-    fn has_is_empty_impl(cx: &LateContext<'_, '_>, id: DefId) -> bool {\n+    fn has_is_empty_impl(cx: &LateContext<'_>, id: DefId) -> bool {\n         cx.tcx.inherent_impls(id).iter().any(|imp| {\n             cx.tcx\n                 .associated_items(*imp)"}, {"sha": "ddc41f89f8dec7da826c5106416de00b5299d14f", "filename": "src/tools/clippy/clippy_lints/src/let_and_return.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_and_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_and_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_and_return.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -40,8 +40,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(LetReturn => [LET_AND_RETURN]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetReturn {\n-    fn check_block(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx Block<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for LetReturn {\n+    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx Block<'_>) {\n         // we need both a let-binding stmt and an expr\n         if_chain! {\n             if let Some(retexpr) = block.expr;\n@@ -86,14 +86,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetReturn {\n     }\n }\n \n-fn last_statement_borrows<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+fn last_statement_borrows<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n     let mut visitor = BorrowVisitor { cx, borrows: false };\n     walk_expr(&mut visitor, expr);\n     visitor.borrows\n }\n \n struct BorrowVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     borrows: bool,\n }\n "}, {"sha": "706c73ce66c6191c3751b5a89eaa0e355146c874", "filename": "src/tools/clippy/clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -56,8 +56,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(LetIfSeq => [USELESS_LET_IF_SEQ]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetIfSeq {\n-    fn check_block(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx hir::Block<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n+    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx hir::Block<'_>) {\n         let mut it = block.stmts.iter().peekable();\n         while let Some(stmt) = it.next() {\n             if_chain! {\n@@ -137,7 +137,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetIfSeq {\n }\n \n struct UsedVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     id: hir::HirId,\n     used: bool,\n }\n@@ -162,8 +162,8 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n     }\n }\n \n-fn check_assign<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn check_assign<'tcx>(\n+    cx: &LateContext<'tcx>,\n     decl: hir::HirId,\n     block: &'tcx hir::Block<'_>,\n ) -> Option<&'tcx hir::Expr<'tcx>> {\n@@ -197,7 +197,7 @@ fn check_assign<'a, 'tcx>(\n     None\n }\n \n-fn used_in_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, id: hir::HirId, expr: &'tcx hir::Expr<'_>) -> bool {\n+fn used_in_expr<'tcx>(cx: &LateContext<'tcx>, id: hir::HirId, expr: &'tcx hir::Expr<'_>) -> bool {\n     let mut v = UsedVisitor { cx, id, used: false };\n     intravisit::walk_expr(&mut v, expr);\n     v.used"}, {"sha": "c7dda3c9928260bcbf06a015d456f479c8288f47", "filename": "src/tools/clippy/clippy_lints/src/let_underscore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -66,8 +66,8 @@ const SYNC_GUARD_PATHS: [&[&str]; 3] = [\n     &paths::RWLOCK_WRITE_GUARD,\n ];\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetUnderscore {\n-    fn check_local(&mut self, cx: &LateContext<'_, '_>, local: &Local<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n+    fn check_local(&mut self, cx: &LateContext<'_>, local: &Local<'_>) {\n         if in_external_macro(cx.tcx.sess, local.span) {\n             return;\n         }"}, {"sha": "a79f94855bdab7eb701d7d1e89fd2ba473b3a952", "filename": "src/tools/clippy/clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -76,14 +76,14 @@ declare_clippy_lint! {\n \n declare_lint_pass!(Lifetimes => [NEEDLESS_LIFETIMES, EXTRA_UNUSED_LIFETIMES]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Lifetimes {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if let ItemKind::Fn(ref sig, ref generics, id) = item.kind {\n             check_fn_inner(cx, &sig.decl, Some(id), generics, item.span, true);\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem<'_>) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n         if let ImplItemKind::Fn(ref sig, id) = item.kind {\n             let report_extra_lifetimes = trait_ref_of_method(cx, item.hir_id).is_none();\n             check_fn_inner(\n@@ -97,7 +97,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Lifetimes {\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem<'_>) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'_>) {\n         if let TraitItemKind::Fn(ref sig, ref body) = item.kind {\n             let body = match *body {\n                 TraitFn::Required(_) => None,\n@@ -116,8 +116,8 @@ enum RefLt {\n     Named(Name),\n }\n \n-fn check_fn_inner<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn check_fn_inner<'tcx>(\n+    cx: &LateContext<'tcx>,\n     decl: &'tcx FnDecl<'_>,\n     body: Option<BodyId>,\n     generics: &'tcx Generics<'_>,\n@@ -177,8 +177,8 @@ fn check_fn_inner<'a, 'tcx>(\n     }\n }\n \n-fn could_use_elision<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn could_use_elision<'tcx>(\n+    cx: &LateContext<'tcx>,\n     func: &'tcx FnDecl<'_>,\n     body: Option<BodyId>,\n     named_generics: &'tcx [GenericParam<'_>],\n@@ -296,13 +296,13 @@ fn unique_lifetimes(lts: &[RefLt]) -> usize {\n \n /// A visitor usable for `rustc_front::visit::walk_ty()`.\n struct RefVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     lts: Vec<RefLt>,\n     abort: bool,\n }\n \n-impl<'v, 't> RefVisitor<'v, 't> {\n-    fn new(cx: &'v LateContext<'v, 't>) -> Self {\n+impl<'a, 'tcx> RefVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>) -> Self {\n         Self {\n             cx,\n             lts: Vec::new(),\n@@ -412,7 +412,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n \n /// Are any lifetimes mentioned in the `where` clause? If so, we don't try to\n /// reason about elision.\n-fn has_where_lifetimes<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, where_clause: &'tcx WhereClause<'_>) -> bool {\n+fn has_where_lifetimes<'tcx>(cx: &LateContext<'tcx>, where_clause: &'tcx WhereClause<'_>) -> bool {\n     for predicate in where_clause.predicates {\n         match *predicate {\n             WherePredicate::RegionPredicate(..) => return true,\n@@ -482,7 +482,7 @@ impl<'tcx> Visitor<'tcx> for LifetimeChecker {\n     }\n }\n \n-fn report_extra_lifetimes<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, func: &'tcx FnDecl<'_>, generics: &'tcx Generics<'_>) {\n+fn report_extra_lifetimes<'tcx>(cx: &LateContext<'tcx>, func: &'tcx FnDecl<'_>, generics: &'tcx Generics<'_>) {\n     let hs = generics\n         .params\n         .iter()"}, {"sha": "d821b5134841e586e402ca2c884480d3be49d40f", "filename": "src/tools/clippy/clippy_lints/src/loops.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -438,9 +438,9 @@ declare_lint_pass!(Loops => [\n     WHILE_IMMUTABLE_CONDITION,\n ]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Loops {\n+impl<'tcx> LateLintPass<'tcx> for Loops {\n     #[allow(clippy::too_many_lines)]\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let Some((pat, arg, body)) = higher::for_loop(expr) {\n             // we don't want to check expanded macros\n             // this check is not at the top of the function\n@@ -732,8 +732,8 @@ fn never_loop_expr_branch<'a, T: Iterator<Item = &'a Expr<'a>>>(e: &mut T, main_\n         .fold(NeverLoopResult::AlwaysBreak, combine_branches)\n }\n \n-fn check_for_loop<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn check_for_loop<'tcx>(\n+    cx: &LateContext<'tcx>,\n     pat: &'tcx Pat<'_>,\n     arg: &'tcx Expr<'_>,\n     body: &'tcx Expr<'_>,\n@@ -747,7 +747,7 @@ fn check_for_loop<'a, 'tcx>(\n     detect_manual_memcpy(cx, pat, arg, body, expr);\n }\n \n-fn same_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr<'_>, var: HirId) -> bool {\n+fn same_var<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, var: HirId) -> bool {\n     if_chain! {\n         if let ExprKind::Path(qpath) = &expr.kind;\n         if let QPath::Resolved(None, path) = qpath;\n@@ -794,7 +794,7 @@ struct FixedOffsetVar<'hir> {\n     offset: Offset,\n }\n \n-fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'_>) -> bool {\n+fn is_slice_like<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'_>) -> bool {\n     let is_slice = match ty.kind {\n         ty::Ref(_, subty, _) => is_slice_like(cx, subty),\n         ty::Slice(..) | ty::Array(..) => true,\n@@ -814,8 +814,8 @@ fn fetch_cloned_expr<'tcx>(expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n     }\n }\n \n-fn get_offset<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, idx: &Expr<'_>, var: HirId) -> Option<Offset> {\n-    fn extract_offset<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &Expr<'_>, var: HirId) -> Option<String> {\n+fn get_offset<'tcx>(cx: &LateContext<'tcx>, idx: &Expr<'_>, var: HirId) -> Option<Offset> {\n+    fn extract_offset<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>, var: HirId) -> Option<String> {\n         match &e.kind {\n             ExprKind::Lit(l) => match l.node {\n                 ast::LitKind::Int(x, _ty) => Some(x.to_string()),\n@@ -880,8 +880,8 @@ fn get_assignments<'tcx>(body: &'tcx Expr<'tcx>) -> impl Iterator<Item = Option<\n     iter_a.into_iter().flatten().chain(iter_b.into_iter())\n }\n \n-fn build_manual_memcpy_suggestion<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn build_manual_memcpy_suggestion<'tcx>(\n+    cx: &LateContext<'tcx>,\n     start: &Expr<'_>,\n     end: &Expr<'_>,\n     limits: ast::RangeLimits,\n@@ -961,8 +961,8 @@ fn build_manual_memcpy_suggestion<'a, 'tcx>(\n }\n /// Checks for for loops that sequentially copy items from one slice-like\n /// object to another.\n-fn detect_manual_memcpy<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn detect_manual_memcpy<'tcx>(\n+    cx: &LateContext<'tcx>,\n     pat: &'tcx Pat<'_>,\n     arg: &'tcx Expr<'_>,\n     body: &'tcx Expr<'_>,\n@@ -1024,8 +1024,8 @@ fn detect_manual_memcpy<'a, 'tcx>(\n /// Checks for looping over a range and then indexing a sequence with it.\n /// The iteratee must be a range literal.\n #[allow(clippy::too_many_lines)]\n-fn check_for_loop_range<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn check_for_loop_range<'tcx>(\n+    cx: &LateContext<'tcx>,\n     pat: &'tcx Pat<'_>,\n     arg: &'tcx Expr<'_>,\n     body: &'tcx Expr<'_>,\n@@ -1205,7 +1205,7 @@ fn is_len_call(expr: &Expr<'_>, var: Name) -> bool {\n }\n \n fn is_end_eq_array_len<'tcx>(\n-    cx: &LateContext<'_, 'tcx>,\n+    cx: &LateContext<'tcx>,\n     end: &Expr<'_>,\n     limits: ast::RangeLimits,\n     indexed_ty: Ty<'tcx>,\n@@ -1226,7 +1226,7 @@ fn is_end_eq_array_len<'tcx>(\n     false\n }\n \n-fn lint_iter_method(cx: &LateContext<'_, '_>, args: &[Expr<'_>], arg: &Expr<'_>, method_name: &str) {\n+fn lint_iter_method(cx: &LateContext<'_>, args: &[Expr<'_>], arg: &Expr<'_>, method_name: &str) {\n     let mut applicability = Applicability::MachineApplicable;\n     let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n     let muta = if method_name == \"iter_mut\" { \"mut \" } else { \"\" };\n@@ -1242,7 +1242,7 @@ fn lint_iter_method(cx: &LateContext<'_, '_>, args: &[Expr<'_>], arg: &Expr<'_>,\n     )\n }\n \n-fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat<'_>, arg: &Expr<'_>, expr: &Expr<'_>) {\n+fn check_for_loop_arg(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>, expr: &Expr<'_>) {\n     let mut next_loop_linted = false; // whether or not ITER_NEXT_LOOP lint was used\n     if let ExprKind::MethodCall(ref method, _, ref args, _) = arg.kind {\n         // just the receiver, no arguments\n@@ -1299,7 +1299,7 @@ fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat<'_>, arg: &Expr<'_>, e\n }\n \n /// Checks for `for` loops over `Option`s and `Result`s.\n-fn check_arg_type(cx: &LateContext<'_, '_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n+fn check_arg_type(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n     let ty = cx.tables().expr_ty(arg);\n     if is_type_diagnostic_item(cx, ty, sym!(option_type)) {\n         span_lint_and_help(\n@@ -1338,8 +1338,8 @@ fn check_arg_type(cx: &LateContext<'_, '_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n     }\n }\n \n-fn check_for_loop_explicit_counter<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn check_for_loop_explicit_counter<'tcx>(\n+    cx: &LateContext<'tcx>,\n     pat: &'tcx Pat<'_>,\n     arg: &'tcx Expr<'_>,\n     body: &'tcx Expr<'_>,\n@@ -1403,7 +1403,7 @@ fn check_for_loop_explicit_counter<'a, 'tcx>(\n \n /// If `arg` was the argument to a `for` loop, return the \"cleanest\" way of writing the\n /// actual `Iterator` that the loop uses.\n-fn make_iterator_snippet(cx: &LateContext<'_, '_>, arg: &Expr<'_>, applic_ref: &mut Applicability) -> String {\n+fn make_iterator_snippet(cx: &LateContext<'_>, arg: &Expr<'_>, applic_ref: &mut Applicability) -> String {\n     let impls_iterator = get_trait_def_id(cx, &paths::ITERATOR)\n         .map_or(false, |id| implements_trait(cx, cx.tables().expr_ty(arg), id, &[]));\n     if impls_iterator {\n@@ -1437,8 +1437,8 @@ fn make_iterator_snippet(cx: &LateContext<'_, '_>, arg: &Expr<'_>, applic_ref: &\n }\n \n /// Checks for the `FOR_KV_MAP` lint.\n-fn check_for_loop_over_map_kv<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn check_for_loop_over_map_kv<'tcx>(\n+    cx: &LateContext<'tcx>,\n     pat: &'tcx Pat<'_>,\n     arg: &'tcx Expr<'_>,\n     body: &'tcx Expr<'_>,\n@@ -1490,7 +1490,7 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n }\n \n struct MutatePairDelegate<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     hir_id_low: Option<HirId>,\n     hir_id_high: Option<HirId>,\n     span_low: Option<Span>,\n@@ -1531,7 +1531,7 @@ impl MutatePairDelegate<'_, '_> {\n     }\n }\n \n-fn check_for_mut_range_bound(cx: &LateContext<'_, '_>, arg: &Expr<'_>, body: &Expr<'_>) {\n+fn check_for_mut_range_bound(cx: &LateContext<'_>, arg: &Expr<'_>, body: &Expr<'_>) {\n     if let Some(higher::Range {\n         start: Some(start),\n         end: Some(end),\n@@ -1547,7 +1547,7 @@ fn check_for_mut_range_bound(cx: &LateContext<'_, '_>, arg: &Expr<'_>, body: &Ex\n     }\n }\n \n-fn mut_warn_with_span(cx: &LateContext<'_, '_>, span: Option<Span>) {\n+fn mut_warn_with_span(cx: &LateContext<'_>, span: Option<Span>) {\n     if let Some(sp) = span {\n         span_lint(\n             cx,\n@@ -1558,7 +1558,7 @@ fn mut_warn_with_span(cx: &LateContext<'_, '_>, span: Option<Span>) {\n     }\n }\n \n-fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr<'_>) -> Option<HirId> {\n+fn check_for_mutability(cx: &LateContext<'_>, bound: &Expr<'_>) -> Option<HirId> {\n     if_chain! {\n         if let ExprKind::Path(ref qpath) = bound.kind;\n         if let QPath::Resolved(None, _) = *qpath;\n@@ -1580,8 +1580,8 @@ fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr<'_>) -> Option<Hi\n     None\n }\n \n-fn check_for_mutation<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn check_for_mutation<'tcx>(\n+    cx: &LateContext<'tcx>,\n     body: &Expr<'_>,\n     bound_ids: &[Option<HirId>],\n ) -> (Option<Span>, Option<Span>) {\n@@ -1609,7 +1609,7 @@ fn pat_is_wild<'tcx>(pat: &'tcx PatKind<'_>, body: &'tcx Expr<'_>) -> bool {\n }\n \n struct LocalUsedVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     local: HirId,\n     used: bool,\n }\n@@ -1632,7 +1632,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LocalUsedVisitor<'a, 'tcx> {\n \n struct VarVisitor<'a, 'tcx> {\n     /// context reference\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     /// var name to look for as index\n     var: HirId,\n     /// indexed variables that are used mutably\n@@ -1803,7 +1803,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n     }\n }\n \n-fn is_used_inside<'a, 'tcx>(cx: &'a LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>, container: &'tcx Expr<'_>) -> bool {\n+fn is_used_inside<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, container: &'tcx Expr<'_>) -> bool {\n     let def_id = match var_def_id(cx, expr) {\n         Some(id) => id,\n         None => return false,\n@@ -1816,7 +1816,7 @@ fn is_used_inside<'a, 'tcx>(cx: &'a LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>,\n     false\n }\n \n-fn is_iterator_used_after_while_let<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, iter_expr: &'tcx Expr<'_>) -> bool {\n+fn is_iterator_used_after_while_let<'tcx>(cx: &LateContext<'tcx>, iter_expr: &'tcx Expr<'_>) -> bool {\n     let def_id = match var_def_id(cx, iter_expr) {\n         Some(id) => id,\n         None => return false,\n@@ -1835,7 +1835,7 @@ fn is_iterator_used_after_while_let<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, iter_e\n }\n \n struct VarUsedAfterLoopVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     def_id: HirId,\n     iter_expr_id: HirId,\n     past_while_let: bool,\n@@ -1863,7 +1863,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor<'a, 'tcx> {\n /// Returns `true` if the type of expr is one that provides `IntoIterator` impls\n /// for `&T` and `&mut T`, such as `Vec`.\n #[rustfmt::skip]\n-fn is_ref_iterable_type(cx: &LateContext<'_, '_>, e: &Expr<'_>) -> bool {\n+fn is_ref_iterable_type(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n     // no walk_ptrs_ty: calling iter() on a reference can make sense because it\n     // will allow further borrows afterwards\n     let ty = cx.tables().expr_ty(e);\n@@ -1878,7 +1878,7 @@ fn is_ref_iterable_type(cx: &LateContext<'_, '_>, e: &Expr<'_>) -> bool {\n     match_type(cx, ty, &paths::BTREESET)\n }\n \n-fn is_iterable_array<'tcx>(ty: Ty<'tcx>, cx: &LateContext<'_, 'tcx>) -> bool {\n+fn is_iterable_array<'tcx>(ty: Ty<'tcx>, cx: &LateContext<'tcx>) -> bool {\n     // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n     match ty.kind {\n         ty::Array(_, n) => {\n@@ -1946,7 +1946,7 @@ enum VarState {\n \n /// Scan a for loop for variables that are incremented exactly once.\n struct IncrementVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,      // context reference\n+    cx: &'a LateContext<'tcx>,          // context reference\n     states: FxHashMap<HirId, VarState>, // incremented variables\n     depth: u32,                         // depth of conditional expressions\n     done: bool,\n@@ -2004,8 +2004,8 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n \n /// Checks whether a variable is initialized to zero at the start of a loop.\n struct InitializeVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>, // context reference\n-    end_expr: &'tcx Expr<'tcx>,    // the for loop. Stop scanning here.\n+    cx: &'a LateContext<'tcx>,  // context reference\n+    end_expr: &'tcx Expr<'tcx>, // the for loop. Stop scanning here.\n     var_id: HirId,\n     state: VarState,\n     name: Option<Name>,\n@@ -2094,7 +2094,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n     }\n }\n \n-fn var_def_id(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Option<HirId> {\n+fn var_def_id(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<HirId> {\n     if let ExprKind::Path(ref qpath) = expr.kind {\n         let path_res = qpath_res(cx, qpath, expr.hir_id);\n         if let Res::Local(hir_id) = path_res {\n@@ -2118,7 +2118,7 @@ fn is_conditional(expr: &Expr<'_>) -> bool {\n     }\n }\n \n-fn is_nested(cx: &LateContext<'_, '_>, match_expr: &Expr<'_>, iter_expr: &Expr<'_>) -> bool {\n+fn is_nested(cx: &LateContext<'_>, match_expr: &Expr<'_>, iter_expr: &Expr<'_>) -> bool {\n     if_chain! {\n         if let Some(loop_block) = get_enclosing_block(cx, match_expr.hir_id);\n         let parent_node = cx.tcx.hir().get_parent_node(loop_block.hir_id);\n@@ -2130,7 +2130,7 @@ fn is_nested(cx: &LateContext<'_, '_>, match_expr: &Expr<'_>, iter_expr: &Expr<'\n     false\n }\n \n-fn is_loop_nested(cx: &LateContext<'_, '_>, loop_expr: &Expr<'_>, iter_expr: &Expr<'_>) -> bool {\n+fn is_loop_nested(cx: &LateContext<'_>, loop_expr: &Expr<'_>, iter_expr: &Expr<'_>) -> bool {\n     let mut id = loop_expr.hir_id;\n     let iter_name = if let Some(name) = path_name(iter_expr) {\n         name\n@@ -2240,7 +2240,7 @@ fn path_name(e: &Expr<'_>) -> Option<Name> {\n     None\n }\n \n-fn check_infinite_loop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, cond: &'tcx Expr<'_>, expr: &'tcx Expr<'_>) {\n+fn check_infinite_loop<'tcx>(cx: &LateContext<'tcx>, cond: &'tcx Expr<'_>, expr: &'tcx Expr<'_>) {\n     if constant(cx, cx.tables(), cond).is_some() {\n         // A pure constant condition (e.g., `while false`) is not linted.\n         return;\n@@ -2321,7 +2321,7 @@ impl<'tcx> Visitor<'tcx> for HasBreakOrReturnVisitor {\n /// Note: In some cases such as `self`, there are no mutable annotation,\n /// All variables definition IDs are collected\n struct VarCollectorVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     ids: FxHashSet<HirId>,\n     def_ids: FxHashMap<def_id::DefId, bool>,\n     skip: bool,\n@@ -2369,7 +2369,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarCollectorVisitor<'a, 'tcx> {\n \n const NEEDLESS_COLLECT_MSG: &str = \"avoid using `collect()` when not needed\";\n \n-fn check_needless_collect<'a, 'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'a, 'tcx>) {\n+fn check_needless_collect<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n     if_chain! {\n         if let ExprKind::MethodCall(ref method, _, ref args, _) = expr.kind;\n         if let ExprKind::MethodCall(ref chain_method, _, _, _) = args[0].kind;"}, {"sha": "065c7c042d367514ed9fc77985647b56c9bf112e", "filename": "src/tools/clippy/clippy_lints/src/macro_use.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -44,7 +44,7 @@ pub struct MacroRefData {\n }\n \n impl MacroRefData {\n-    pub fn new(name: String, callee: Span, cx: &LateContext<'_, '_>) -> Self {\n+    pub fn new(name: String, callee: Span, cx: &LateContext<'_>) -> Self {\n         let mut path = cx.sess().source_map().span_to_filename(callee).to_string();\n \n         // std lib paths are <::std::module::file type>\n@@ -72,7 +72,7 @@ pub struct MacroUseImports {\n impl_lint_pass!(MacroUseImports => [MACRO_USE_IMPORTS]);\n \n impl MacroUseImports {\n-    fn push_unique_macro(&mut self, cx: &LateContext<'_, '_>, span: Span) {\n+    fn push_unique_macro(&mut self, cx: &LateContext<'_>, span: Span) {\n         let call_site = span.source_callsite();\n         let name = snippet(cx, cx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n         if let Some(callee) = span.source_callee() {\n@@ -89,7 +89,7 @@ impl MacroUseImports {\n         }\n     }\n \n-    fn push_unique_macro_pat_ty(&mut self, cx: &LateContext<'_, '_>, span: Span) {\n+    fn push_unique_macro_pat_ty(&mut self, cx: &LateContext<'_>, span: Span) {\n         let call_site = span.source_callsite();\n         let name = snippet(cx, cx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n         if let Some(callee) = span.source_callee() {\n@@ -102,8 +102,8 @@ impl MacroUseImports {\n     }\n }\n \n-impl<'l, 'txc> LateLintPass<'l, 'txc> for MacroUseImports {\n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for MacroUseImports {\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n         if_chain! {\n             if cx.sess().opts.edition == Edition::Edition2018;\n             if let hir::ItemKind::Use(path, _kind) = &item.kind;\n@@ -127,33 +127,33 @@ impl<'l, 'txc> LateLintPass<'l, 'txc> for MacroUseImports {\n             }\n         }\n     }\n-    fn check_attribute(&mut self, cx: &LateContext<'_, '_>, attr: &ast::Attribute) {\n+    fn check_attribute(&mut self, cx: &LateContext<'_>, attr: &ast::Attribute) {\n         if in_macro(attr.span) {\n             self.push_unique_macro(cx, attr.span);\n         }\n     }\n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &hir::Expr<'_>) {\n         if in_macro(expr.span) {\n             self.push_unique_macro(cx, expr.span);\n         }\n     }\n-    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, stmt: &hir::Stmt<'_>) {\n+    fn check_stmt(&mut self, cx: &LateContext<'_>, stmt: &hir::Stmt<'_>) {\n         if in_macro(stmt.span) {\n             self.push_unique_macro(cx, stmt.span);\n         }\n     }\n-    fn check_pat(&mut self, cx: &LateContext<'_, '_>, pat: &hir::Pat<'_>) {\n+    fn check_pat(&mut self, cx: &LateContext<'_>, pat: &hir::Pat<'_>) {\n         if in_macro(pat.span) {\n             self.push_unique_macro_pat_ty(cx, pat.span);\n         }\n     }\n-    fn check_ty(&mut self, cx: &LateContext<'_, '_>, ty: &hir::Ty<'_>) {\n+    fn check_ty(&mut self, cx: &LateContext<'_>, ty: &hir::Ty<'_>) {\n         if in_macro(ty.span) {\n             self.push_unique_macro_pat_ty(cx, ty.span);\n         }\n     }\n     #[allow(clippy::too_many_lines)]\n-    fn check_crate_post(&mut self, cx: &LateContext<'_, '_>, _krate: &hir::Crate<'_>) {\n+    fn check_crate_post(&mut self, cx: &LateContext<'_>, _krate: &hir::Crate<'_>) {\n         let mut used = FxHashMap::default();\n         let mut check_dup = vec![];\n         for (import, span) in &self.imports {"}, {"sha": "eceae706e4fc716c3c41ed948ef0fbffd275a2d9", "filename": "src/tools/clippy/clippy_lints/src/main_recursion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmain_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmain_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmain_recursion.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -31,12 +31,12 @@ pub struct MainRecursion {\n \n impl_lint_pass!(MainRecursion => [MAIN_RECURSION]);\n \n-impl LateLintPass<'_, '_> for MainRecursion {\n-    fn check_crate(&mut self, _: &LateContext<'_, '_>, krate: &Crate<'_>) {\n+impl LateLintPass<'_> for MainRecursion {\n+    fn check_crate(&mut self, _: &LateContext<'_>, krate: &Crate<'_>) {\n         self.has_no_std_attr = is_no_std_crate(krate);\n     }\n \n-    fn check_expr_post(&mut self, cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+    fn check_expr_post(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if self.has_no_std_attr {\n             return;\n         }"}, {"sha": "c19fb148cda590ef3f7f9fb34d78eee800f4bf23", "filename": "src/tools/clippy/clippy_lints/src/manual_async_fn.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -38,10 +38,10 @@ declare_clippy_lint! {\n \n declare_lint_pass!(ManualAsyncFn => [MANUAL_ASYNC_FN]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ManualAsyncFn {\n+impl<'tcx> LateLintPass<'tcx> for ManualAsyncFn {\n     fn check_fn(\n         &mut self,\n-        cx: &LateContext<'a, 'tcx>,\n+        cx: &LateContext<'tcx>,\n         kind: FnKind<'tcx>,\n         decl: &'tcx FnDecl<'_>,\n         body: &'tcx Body<'_>,\n@@ -97,7 +97,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ManualAsyncFn {\n     }\n }\n \n-fn future_trait_ref<'tcx>(cx: &LateContext<'_, 'tcx>, ty: &'tcx Ty<'tcx>) -> Option<&'tcx TraitRef<'tcx>> {\n+fn future_trait_ref<'tcx>(cx: &LateContext<'tcx>, ty: &'tcx Ty<'tcx>) -> Option<&'tcx TraitRef<'tcx>> {\n     if_chain! {\n         if let TyKind::OpaqueDef(item_id, _) = ty.kind;\n         let item = cx.tcx.hir().item(item_id.id);\n@@ -129,7 +129,7 @@ fn future_output_ty<'tcx>(trait_ref: &'tcx TraitRef<'tcx>) -> Option<&'tcx Ty<'t\n     None\n }\n \n-fn desugared_async_block<'tcx>(cx: &LateContext<'_, 'tcx>, block: &'tcx Block<'tcx>) -> Option<&'tcx Body<'tcx>> {\n+fn desugared_async_block<'tcx>(cx: &LateContext<'tcx>, block: &'tcx Block<'tcx>) -> Option<&'tcx Body<'tcx>> {\n     if_chain! {\n         if let Some(block_expr) = block.expr;\n         if let Some(args) = match_function_call(cx, block_expr, &FUTURE_FROM_GENERATOR);\n@@ -145,7 +145,7 @@ fn desugared_async_block<'tcx>(cx: &LateContext<'_, 'tcx>, block: &'tcx Block<'t\n     None\n }\n \n-fn suggested_ret(cx: &LateContext<'_, '_>, output: &Ty<'_>) -> Option<(&'static str, String)> {\n+fn suggested_ret(cx: &LateContext<'_>, output: &Ty<'_>) -> Option<(&'static str, String)> {\n     match output.kind {\n         TyKind::Tup(tys) if tys.is_empty() => {\n             let sugg = \"remove the return type\";"}, {"sha": "905a3f3ca71c71b6652dc43b5d25269487605f64", "filename": "src/tools/clippy/clippy_lints/src/map_clone.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -42,8 +42,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(MapClone => [MAP_CLONE]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MapClone {\n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, e: &hir::Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for MapClone {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, e: &hir::Expr<'_>) {\n         if e.span.from_expansion() {\n             return;\n         }\n@@ -106,7 +106,7 @@ fn ident_eq(name: Ident, path: &hir::Expr<'_>) -> bool {\n     }\n }\n \n-fn lint_needless_cloning(cx: &LateContext<'_, '_>, root: Span, receiver: Span) {\n+fn lint_needless_cloning(cx: &LateContext<'_>, root: Span, receiver: Span) {\n     span_lint_and_sugg(\n         cx,\n         MAP_CLONE,\n@@ -118,7 +118,7 @@ fn lint_needless_cloning(cx: &LateContext<'_, '_>, root: Span, receiver: Span) {\n     )\n }\n \n-fn lint(cx: &LateContext<'_, '_>, replace: Span, root: Span, copied: bool) {\n+fn lint(cx: &LateContext<'_>, replace: Span, root: Span, copied: bool) {\n     let mut applicability = Applicability::MachineApplicable;\n     if copied {\n         span_lint_and_sugg("}, {"sha": "316a71c500512d287b449ee4dfe4ecdde637093f", "filename": "src/tools/clippy/clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -100,7 +100,7 @@ fn is_unit_type(ty: Ty<'_>) -> bool {\n     }\n }\n \n-fn is_unit_function(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) -> bool {\n+fn is_unit_function(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> bool {\n     let ty = cx.tables().expr_ty(expr);\n \n     if let ty::FnDef(id, _) = ty.kind {\n@@ -111,15 +111,15 @@ fn is_unit_function(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) -> bool {\n     false\n }\n \n-fn is_unit_expression(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) -> bool {\n+fn is_unit_expression(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> bool {\n     is_unit_type(cx.tables().expr_ty(expr))\n }\n \n /// The expression inside a closure may or may not have surrounding braces and\n /// semicolons, which causes problems when generating a suggestion. Given an\n /// expression that evaluates to '()' or '!', recursively remove useless braces\n /// and semi-colons until is suitable for including in the suggestion template\n-fn reduce_unit_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a hir::Expr<'_>) -> Option<Span> {\n+fn reduce_unit_expression<'a>(cx: &LateContext<'_>, expr: &'a hir::Expr<'_>) -> Option<Span> {\n     if !is_unit_expression(cx, expr) {\n         return None;\n     }\n@@ -161,7 +161,7 @@ fn reduce_unit_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a hir::Expr<'_>)\n }\n \n fn unit_closure<'tcx>(\n-    cx: &LateContext<'_, 'tcx>,\n+    cx: &LateContext<'tcx>,\n     expr: &hir::Expr<'_>,\n ) -> Option<(&'tcx hir::Param<'tcx>, &'tcx hir::Expr<'tcx>)> {\n     if let hir::ExprKind::Closure(_, ref decl, inner_expr_id, _, _) = expr.kind {\n@@ -186,7 +186,7 @@ fn unit_closure<'tcx>(\n /// `y` => `_y`\n ///\n /// Anything else will return `a`.\n-fn let_binding_name(cx: &LateContext<'_, '_>, var_arg: &hir::Expr<'_>) -> String {\n+fn let_binding_name(cx: &LateContext<'_>, var_arg: &hir::Expr<'_>) -> String {\n     match &var_arg.kind {\n         hir::ExprKind::Field(_, _) => snippet(cx, var_arg.span, \"_\").replace(\".\", \"_\"),\n         hir::ExprKind::Path(_) => format!(\"_{}\", snippet(cx, var_arg.span, \"\")),\n@@ -202,7 +202,7 @@ fn suggestion_msg(function_type: &str, map_type: &str) -> String {\n     )\n }\n \n-fn lint_map_unit_fn(cx: &LateContext<'_, '_>, stmt: &hir::Stmt<'_>, expr: &hir::Expr<'_>, map_args: &[hir::Expr<'_>]) {\n+fn lint_map_unit_fn(cx: &LateContext<'_>, stmt: &hir::Stmt<'_>, expr: &hir::Expr<'_>, map_args: &[hir::Expr<'_>]) {\n     let var_arg = &map_args[0];\n \n     let (map_type, variant, lint) = if is_type_diagnostic_item(cx, cx.tables().expr_ty(var_arg), sym!(option_type)) {\n@@ -258,8 +258,8 @@ fn lint_map_unit_fn(cx: &LateContext<'_, '_>, stmt: &hir::Stmt<'_>, expr: &hir::\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MapUnit {\n-    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, stmt: &hir::Stmt<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for MapUnit {\n+    fn check_stmt(&mut self, cx: &LateContext<'_>, stmt: &hir::Stmt<'_>) {\n         if stmt.span.from_expansion() {\n             return;\n         }"}, {"sha": "0003aa94a031e708134efdb416bac03615a56a6b", "filename": "src/tools/clippy/clippy_lints/src/match_on_vec_items.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -44,8 +44,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(MatchOnVecItems => [MATCH_ON_VEC_ITEMS]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MatchOnVecItems {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'tcx>) {\n+impl<'tcx> LateLintPass<'tcx> for MatchOnVecItems {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         if_chain! {\n             if !in_external_macro(cx.sess(), expr.span);\n             if let ExprKind::Match(ref match_expr, _, MatchSource::Normal) = expr.kind;\n@@ -73,7 +73,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MatchOnVecItems {\n     }\n }\n \n-fn is_vec_indexing<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n+fn is_vec_indexing<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n     if_chain! {\n         if let ExprKind::Index(ref array, ref index) = expr.kind;\n         if is_vector(cx, array);\n@@ -87,13 +87,13 @@ fn is_vec_indexing<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'tcx>)\n     None\n }\n \n-fn is_vector(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+fn is_vector(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     let ty = cx.tables().expr_ty(expr);\n     let ty = walk_ptrs_ty(ty);\n     is_type_diagnostic_item(cx, ty, sym!(vec_type))\n }\n \n-fn is_full_range(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+fn is_full_range(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     let ty = cx.tables().expr_ty(expr);\n     let ty = walk_ptrs_ty(ty);\n     match_type(cx, ty, &utils::paths::RANGE_FULL)"}, {"sha": "b754a45aa404fff34f544e54dceee07490e24c46", "filename": "src/tools/clippy/clippy_lints/src/matches.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -430,8 +430,8 @@ impl_lint_pass!(Matches => [\n     REST_PAT_IN_FULLY_BOUND_STRUCTS\n ]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Matches {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for Matches {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n@@ -455,7 +455,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Matches {\n         }\n     }\n \n-    fn check_local(&mut self, cx: &LateContext<'a, 'tcx>, local: &'tcx Local<'_>) {\n+    fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'_>) {\n         if_chain! {\n             if !in_external_macro(cx.sess(), local.span);\n             if !in_macro(local.span);\n@@ -491,7 +491,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Matches {\n         }\n     }\n \n-    fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat<'_>) {\n+    fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {\n         if_chain! {\n             if !in_external_macro(cx.sess(), pat.span);\n             if !in_macro(pat.span);\n@@ -518,7 +518,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Matches {\n }\n \n #[rustfmt::skip]\n-fn check_single_match(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+fn check_single_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n         if in_macro(expr.span) {\n             // Don't lint match expressions present in\n@@ -549,7 +549,7 @@ fn check_single_match(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>],\n }\n \n fn check_single_match_single_pattern(\n-    cx: &LateContext<'_, '_>,\n+    cx: &LateContext<'_>,\n     ex: &Expr<'_>,\n     arms: &[Arm<'_>],\n     expr: &Expr<'_>,\n@@ -561,7 +561,7 @@ fn check_single_match_single_pattern(\n }\n \n fn report_single_match_single_pattern(\n-    cx: &LateContext<'_, '_>,\n+    cx: &LateContext<'_>,\n     ex: &Expr<'_>,\n     arms: &[Arm<'_>],\n     expr: &Expr<'_>,\n@@ -590,7 +590,7 @@ fn report_single_match_single_pattern(\n }\n \n fn check_single_match_opt_like(\n-    cx: &LateContext<'_, '_>,\n+    cx: &LateContext<'_>,\n     ex: &Expr<'_>,\n     arms: &[Arm<'_>],\n     expr: &Expr<'_>,\n@@ -630,7 +630,7 @@ fn check_single_match_opt_like(\n     }\n }\n \n-fn check_match_bool(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+fn check_match_bool(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     // Type of expression is `bool`.\n     if cx.tables().expr_ty(ex).kind == ty::Bool {\n         span_lint_and_then(\n@@ -694,7 +694,7 @@ fn check_match_bool(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>], e\n     }\n }\n \n-fn check_overlapping_arms<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ex: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) {\n+fn check_overlapping_arms<'tcx>(cx: &LateContext<'tcx>, ex: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) {\n     if arms.len() >= 2 && cx.tables().expr_ty(ex).is_integral() {\n         let ranges = all_ranges(cx, arms, cx.tables().expr_ty(ex));\n         let type_ranges = type_ranges(&ranges);\n@@ -713,7 +713,7 @@ fn check_overlapping_arms<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ex: &'tcx Expr<'\n     }\n }\n \n-fn check_wild_err_arm(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n+fn check_wild_err_arm(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n     let ex_ty = walk_ptrs_ty(cx.tables().expr_ty(ex));\n     if is_type_diagnostic_item(cx, ex_ty, sym!(result_type)) {\n         for arm in arms {\n@@ -754,7 +754,7 @@ fn check_wild_err_arm(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n     }\n }\n \n-fn check_wild_enum_match(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n+fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n     let ty = cx.tables().expr_ty(ex);\n     if !ty.is_enum() {\n         // If there isn't a nice closed set of possible values that can be conveniently enumerated,\n@@ -884,7 +884,7 @@ fn is_panic_block(block: &Block<'_>) -> bool {\n     }\n }\n \n-fn check_match_ref_pats(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+fn check_match_ref_pats(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     if has_only_ref_pats(arms) {\n         let mut suggs = Vec::with_capacity(arms.len() + 1);\n         let (title, msg) = if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, ref inner) = ex.kind {\n@@ -919,7 +919,7 @@ fn check_match_ref_pats(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>\n     }\n }\n \n-fn check_match_as_ref(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+fn check_match_as_ref(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n         let arm_ref: Option<BindingAnnotation> = if is_none_arm(&arms[0]) {\n             is_ref_some_arm(&arms[1])\n@@ -971,7 +971,7 @@ fn check_match_as_ref(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>],\n     }\n }\n \n-fn check_wild_in_or_pats(cx: &LateContext<'_, '_>, arms: &[Arm<'_>]) {\n+fn check_wild_in_or_pats(cx: &LateContext<'_>, arms: &[Arm<'_>]) {\n     for arm in arms {\n         if let PatKind::Or(ref fields) = arm.pat.kind {\n             // look for multiple fields in this arm that contains at least one Wild pattern\n@@ -989,7 +989,7 @@ fn check_wild_in_or_pats(cx: &LateContext<'_, '_>, arms: &[Arm<'_>]) {\n     }\n }\n \n-fn check_match_single_binding<'a>(cx: &LateContext<'_, 'a>, ex: &Expr<'a>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+fn check_match_single_binding<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     if in_macro(expr.span) || arms.len() != 1 || is_refutable(cx, arms[0].pat) {\n         return;\n     }\n@@ -1085,7 +1085,7 @@ fn check_match_single_binding<'a>(cx: &LateContext<'_, 'a>, ex: &Expr<'a>, arms:\n }\n \n /// Returns true if the `ex` match expression is in a local (`let`) statement\n-fn opt_parent_let<'a>(cx: &LateContext<'_, 'a>, ex: &Expr<'a>) -> Option<&'a Local<'a>> {\n+fn opt_parent_let<'a>(cx: &LateContext<'a>, ex: &Expr<'a>) -> Option<&'a Local<'a>> {\n     if_chain! {\n         let map = &cx.tcx.hir();\n         if let Some(Node::Expr(parent_arm_expr)) = map.find(map.get_parent_node(ex.hir_id));\n@@ -1098,11 +1098,7 @@ fn opt_parent_let<'a>(cx: &LateContext<'_, 'a>, ex: &Expr<'a>) -> Option<&'a Loc\n }\n \n /// Gets all arms that are unbounded `PatRange`s.\n-fn all_ranges<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    arms: &'tcx [Arm<'_>],\n-    ty: Ty<'tcx>,\n-) -> Vec<SpannedRange<Constant>> {\n+fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>) -> Vec<SpannedRange<Constant>> {\n     arms.iter()\n         .flat_map(|arm| {\n             if let Arm {"}, {"sha": "06c568513035f068bea8ccc71419fbfd13f67f4d", "filename": "src/tools/clippy/clippy_lints/src/mem_discriminant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_discriminant.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -29,8 +29,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(MemDiscriminant => [MEM_DISCRIMINANT_NON_ENUM]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemDiscriminant {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for MemDiscriminant {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Call(ref func, ref func_args) = expr.kind;\n             // is `mem::discriminant`"}, {"sha": "b895ba324c78a7ab5c9efaf57ae56ee751bd47d1", "filename": "src/tools/clippy/clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_forget.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -25,8 +25,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(MemForget => [MEM_FORGET]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemForget {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for MemForget {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if let ExprKind::Call(ref path_expr, ref args) = e.kind {\n             if let ExprKind::Path(ref qpath) = path_expr.kind {\n                 if let Some(def_id) = qpath_res(cx, qpath, path_expr.hir_id).opt_def_id() {"}, {"sha": "25f332cdcc2868d48142fa3b72424b7930cb1d4c", "filename": "src/tools/clippy/clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -97,7 +97,7 @@ declare_clippy_lint! {\n declare_lint_pass!(MemReplace =>\n     [MEM_REPLACE_OPTION_WITH_NONE, MEM_REPLACE_WITH_UNINIT, MEM_REPLACE_WITH_DEFAULT]);\n \n-fn check_replace_option_with_none(cx: &LateContext<'_, '_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n+fn check_replace_option_with_none(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n     if let ExprKind::Path(ref replacement_qpath) = src.kind {\n         // Check that second argument is `Option::None`\n         if match_qpath(replacement_qpath, &paths::OPTION_NONE) {\n@@ -135,7 +135,7 @@ fn check_replace_option_with_none(cx: &LateContext<'_, '_>, src: &Expr<'_>, dest\n     }\n }\n \n-fn check_replace_with_uninit(cx: &LateContext<'_, '_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n+fn check_replace_with_uninit(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n     if_chain! {\n         // check if replacement is mem::MaybeUninit::uninit().assume_init()\n         if let Some(method_def_id) = cx.tables().type_dependent_def_id(src.hir_id);\n@@ -193,7 +193,7 @@ fn check_replace_with_uninit(cx: &LateContext<'_, '_>, src: &Expr<'_>, dest: &Ex\n     }\n }\n \n-fn check_replace_with_default(cx: &LateContext<'_, '_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n+fn check_replace_with_default(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n     if let ExprKind::Call(ref repl_func, _) = src.kind {\n         if_chain! {\n             if !in_external_macro(cx.tcx.sess, expr_span);\n@@ -224,8 +224,8 @@ fn check_replace_with_default(cx: &LateContext<'_, '_>, src: &Expr<'_>, dest: &E\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemReplace {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for MemReplace {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // Check that `expr` is a call to `mem::replace()`\n             if let ExprKind::Call(ref func, ref func_args) = expr.kind;"}, {"sha": "fcf7b509eadbf6cf0eb518e7e7a6196264c614d0", "filename": "src/tools/clippy/clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -77,7 +77,7 @@ pub(crate) trait BindInsteadOfMap {\n     }\n \n     fn lint_closure_autofixable(\n-        cx: &LateContext<'_, '_>,\n+        cx: &LateContext<'_>,\n         expr: &hir::Expr<'_>,\n         args: &[hir::Expr<'_>],\n         closure_expr: &hir::Expr<'_>,\n@@ -120,7 +120,7 @@ pub(crate) trait BindInsteadOfMap {\n         }\n     }\n \n-    fn lint_closure(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, closure_expr: &hir::Expr<'_>) {\n+    fn lint_closure(cx: &LateContext<'_>, expr: &hir::Expr<'_>, closure_expr: &hir::Expr<'_>) {\n         let mut suggs = Vec::new();\n         let can_sugg = find_all_ret_expressions(cx, closure_expr, |ret_expr| {\n             if_chain! {\n@@ -156,7 +156,7 @@ pub(crate) trait BindInsteadOfMap {\n     }\n \n     /// Lint use of `_.and_then(|x| Some(y))` for `Option`s\n-    fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+    fn lint(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n         if !match_type(cx, cx.tables().expr_ty(&args[0]), Self::TYPE_QPATH) {\n             return;\n         }\n@@ -216,7 +216,7 @@ fn contains_try(expr: &hir::Expr<'_>) -> bool {\n     visitor.found\n }\n \n-fn find_all_ret_expressions<'hir, F>(_cx: &LateContext<'_, '_>, expr: &'hir hir::Expr<'hir>, callback: F) -> bool\n+fn find_all_ret_expressions<'hir, F>(_cx: &LateContext<'_>, expr: &'hir hir::Expr<'hir>, callback: F) -> bool\n where\n     F: FnMut(&'hir hir::Expr<'hir>) -> bool,\n {"}, {"sha": "1c0018a5b95e2c16703c84de8a9fa36732022442", "filename": "src/tools/clippy/clippy_lints/src/methods/inefficient_to_string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -9,7 +9,7 @@ use rustc_lint::LateContext;\n use rustc_middle::ty::{self, Ty};\n \n /// Checks for the `INEFFICIENT_TO_STRING` lint\n-pub fn lint<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'tcx>) {\n+pub fn lint<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'tcx>) {\n     if_chain! {\n         if let Some(to_string_meth_did) = cx.tables().type_dependent_def_id(expr.hir_id);\n         if match_def_path(cx, to_string_meth_did, &paths::TO_STRING_METHOD);\n@@ -45,7 +45,7 @@ pub fn lint<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &hir::Expr<'_>, arg: &hir::E\n \n /// Returns whether `ty` specializes `ToString`.\n /// Currently, these are `str`, `String`, and `Cow<'_, str>`.\n-fn specializes_tostring(cx: &LateContext<'_, '_>, ty: Ty<'_>) -> bool {\n+fn specializes_tostring(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n     if let ty::Str = ty.kind {\n         return true;\n     }"}, {"sha": "9c04b6d57b90f82c1040708f5e1e224f6aca8e6c", "filename": "src/tools/clippy/clippy_lints/src/methods/manual_saturating_arithmetic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -6,7 +6,7 @@ use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_target::abi::LayoutOf;\n \n-pub fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[&[hir::Expr<'_>]], arith: &str) {\n+pub fn lint(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[&[hir::Expr<'_>]], arith: &str) {\n     let unwrap_arg = &args[0][1];\n     let arith_lhs = &args[1][0];\n     let arith_rhs = &args[1][1];\n@@ -85,7 +85,7 @@ enum MinMax {\n     Max,\n }\n \n-fn is_min_or_max<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &hir::Expr<'_>) -> Option<MinMax> {\n+fn is_min_or_max<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>) -> Option<MinMax> {\n     // `T::max_value()` `T::min_value()` inherent methods\n     if_chain! {\n         if let hir::ExprKind::Call(func, args) = &expr.kind;"}, {"sha": "216db12f0115fb31943b72d255a64023ed7b70fc", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 82, "deletions": 112, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -1357,9 +1357,9 @@ declare_lint_pass!(Methods => [\n     OPTION_AS_REF_DEREF,\n ]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n+impl<'tcx> LateLintPass<'tcx> for Methods {\n     #[allow(clippy::too_many_lines)]\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if in_macro(expr.span) {\n             return;\n         }\n@@ -1471,7 +1471,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, impl_item: &'tcx hir::ImplItem<'_>) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx hir::ImplItem<'_>) {\n         if in_external_macro(cx.sess(), impl_item.span) {\n             return;\n         }\n@@ -1585,16 +1585,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n \n /// Checks for the `OR_FUN_CALL` lint.\n #[allow(clippy::too_many_lines)]\n-fn lint_or_fun_call<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn lint_or_fun_call<'tcx>(\n+    cx: &LateContext<'tcx>,\n     expr: &hir::Expr<'_>,\n     method_span: Span,\n     name: &str,\n     args: &'tcx [hir::Expr<'_>],\n ) {\n     // Searches an expression for method calls or function calls that aren't ctors\n     struct FunCallFinder<'a, 'tcx> {\n-        cx: &'a LateContext<'a, 'tcx>,\n+        cx: &'a LateContext<'tcx>,\n         found: bool,\n     }\n \n@@ -1625,7 +1625,7 @@ fn lint_or_fun_call<'a, 'tcx>(\n \n     /// Checks for `unwrap_or(T::new())` or `unwrap_or(T::default())`.\n     fn check_unwrap_or_default(\n-        cx: &LateContext<'_, '_>,\n+        cx: &LateContext<'_>,\n         name: &str,\n         fun: &hir::Expr<'_>,\n         self_expr: &hir::Expr<'_>,\n@@ -1667,8 +1667,8 @@ fn lint_or_fun_call<'a, 'tcx>(\n \n     /// Checks for `*or(foo())`.\n     #[allow(clippy::too_many_arguments)]\n-    fn check_general_case<'a, 'tcx>(\n-        cx: &LateContext<'a, 'tcx>,\n+    fn check_general_case<'tcx>(\n+        cx: &LateContext<'tcx>,\n         name: &str,\n         method_span: Span,\n         fun_span: Span,\n@@ -1769,15 +1769,15 @@ fn lint_or_fun_call<'a, 'tcx>(\n /// Checks for the `EXPECT_FUN_CALL` lint.\n #[allow(clippy::too_many_lines)]\n fn lint_expect_fun_call(\n-    cx: &LateContext<'_, '_>,\n+    cx: &LateContext<'_>,\n     expr: &hir::Expr<'_>,\n     method_span: Span,\n     name: &str,\n     args: &[hir::Expr<'_>],\n ) {\n     // Strip `&`, `as_ref()` and `as_str()` off `arg` until we're left with either a `String` or\n     // `&str`\n-    fn get_arg_root<'a>(cx: &LateContext<'_, '_>, arg: &'a hir::Expr<'a>) -> &'a hir::Expr<'a> {\n+    fn get_arg_root<'a>(cx: &LateContext<'_>, arg: &'a hir::Expr<'a>) -> &'a hir::Expr<'a> {\n         let mut arg_root = arg;\n         loop {\n             arg_root = match &arg_root.kind {\n@@ -1804,7 +1804,7 @@ fn lint_expect_fun_call(\n \n     // Only `&'static str` or `String` can be used directly in the `panic!`. Other types should be\n     // converted to string.\n-    fn requires_to_string(cx: &LateContext<'_, '_>, arg: &hir::Expr<'_>) -> bool {\n+    fn requires_to_string(cx: &LateContext<'_>, arg: &hir::Expr<'_>) -> bool {\n         let arg_ty = cx.tables().expr_ty(arg);\n         if is_type_diagnostic_item(cx, arg_ty, sym!(string_type)) {\n             return false;\n@@ -1819,7 +1819,7 @@ fn lint_expect_fun_call(\n \n     // Check if an expression could have type `&'static str`, knowing that it\n     // has type `&str` for some lifetime.\n-    fn can_be_static_str(cx: &LateContext<'_, '_>, arg: &hir::Expr<'_>) -> bool {\n+    fn can_be_static_str(cx: &LateContext<'_>, arg: &hir::Expr<'_>) -> bool {\n         match arg.kind {\n             hir::ExprKind::Lit(_) => true,\n             hir::ExprKind::Call(fun, _) => {\n@@ -1853,7 +1853,7 @@ fn lint_expect_fun_call(\n     }\n \n     fn generate_format_arg_snippet(\n-        cx: &LateContext<'_, '_>,\n+        cx: &LateContext<'_>,\n         a: &hir::Expr<'_>,\n         applicability: &mut Applicability,\n     ) -> Vec<String> {\n@@ -1956,7 +1956,7 @@ fn lint_expect_fun_call(\n }\n \n /// Checks for the `CLONE_ON_COPY` lint.\n-fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'_>) {\n+fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'_>) {\n     let ty = cx.tables().expr_ty(expr);\n     if let ty::Ref(_, inner, _) = arg_ty.kind {\n         if let ty::Ref(_, innermost, _) = inner.kind {\n@@ -2050,7 +2050,7 @@ fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, arg: &hir:\n     }\n }\n \n-fn lint_clone_on_ref_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n+fn lint_clone_on_ref_ptr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n     let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(arg));\n \n     if let ty::Adt(_, subst) = obj_ty.kind {\n@@ -2081,7 +2081,7 @@ fn lint_clone_on_ref_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, arg: &h\n     }\n }\n \n-fn lint_string_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+fn lint_string_extend(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     let arg = &args[1];\n     if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n         let target = &arglists[0][0];\n@@ -2112,14 +2112,14 @@ fn lint_string_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[hi\n     }\n }\n \n-fn lint_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+fn lint_extend(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(&args[0]));\n     if is_type_diagnostic_item(cx, obj_ty, sym!(string_type)) {\n         lint_string_extend(cx, expr, args);\n     }\n }\n \n-fn lint_cstring_as_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, source: &hir::Expr<'_>, unwrap: &hir::Expr<'_>) {\n+fn lint_cstring_as_ptr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, source: &hir::Expr<'_>, unwrap: &hir::Expr<'_>) {\n     if_chain! {\n         let source_type = cx.tables().expr_ty(source);\n         if let ty::Adt(def, substs) = source_type.kind;\n@@ -2139,11 +2139,7 @@ fn lint_cstring_as_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, source: &\n     }\n }\n \n-fn lint_iter_cloned_collect<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    expr: &hir::Expr<'_>,\n-    iter_args: &'tcx [hir::Expr<'_>],\n-) {\n+fn lint_iter_cloned_collect<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, iter_args: &'tcx [hir::Expr<'_>]) {\n     if_chain! {\n         if is_type_diagnostic_item(cx, cx.tables().expr_ty(expr), sym!(vec_type));\n         if let Some(slice) = derefs_to_slice(cx, &iter_args[0], cx.tables().expr_ty(&iter_args[0]));\n@@ -2164,9 +2160,9 @@ fn lint_iter_cloned_collect<'a, 'tcx>(\n     }\n }\n \n-fn lint_unnecessary_fold(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, fold_args: &[hir::Expr<'_>], fold_span: Span) {\n+fn lint_unnecessary_fold(cx: &LateContext<'_>, expr: &hir::Expr<'_>, fold_args: &[hir::Expr<'_>], fold_span: Span) {\n     fn check_fold_with_op(\n-        cx: &LateContext<'_, '_>,\n+        cx: &LateContext<'_>,\n         expr: &hir::Expr<'_>,\n         fold_args: &[hir::Expr<'_>],\n         fold_span: Span,\n@@ -2251,7 +2247,7 @@ fn lint_unnecessary_fold(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, fold_ar\n     }\n }\n \n-fn lint_step_by<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr<'_>, args: &'tcx [hir::Expr<'_>]) {\n+fn lint_step_by<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, args: &'tcx [hir::Expr<'_>]) {\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         if let Some((Constant::Int(0), _)) = constant(cx, cx.tables(), &args[1]) {\n             span_lint(\n@@ -2264,7 +2260,7 @@ fn lint_step_by<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr<'_>, args\n     }\n }\n \n-fn lint_iter_next<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>, iter_args: &'tcx [hir::Expr<'_>]) {\n+fn lint_iter_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, iter_args: &'tcx [hir::Expr<'_>]) {\n     let caller_expr = &iter_args[0];\n \n     // Skip lint if the `iter().next()` expression is a for loop argument,\n@@ -2318,8 +2314,8 @@ fn lint_iter_next<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_\n     }\n }\n \n-fn lint_iter_nth<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn lint_iter_nth<'tcx>(\n+    cx: &LateContext<'tcx>,\n     expr: &hir::Expr<'_>,\n     nth_and_iter_args: &[&'tcx [hir::Expr<'tcx>]],\n     is_mut: bool,\n@@ -2348,7 +2344,7 @@ fn lint_iter_nth<'a, 'tcx>(\n     );\n }\n \n-fn lint_iter_nth_zero<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr<'_>, nth_args: &'tcx [hir::Expr<'_>]) {\n+fn lint_iter_nth_zero<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, nth_args: &'tcx [hir::Expr<'_>]) {\n     if_chain! {\n         if match_trait_method(cx, expr, &paths::ITERATOR);\n         if let Some((Constant::Int(0), _)) = constant(cx, cx.tables(), &nth_args[1]);\n@@ -2367,12 +2363,7 @@ fn lint_iter_nth_zero<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr<'_>\n     }\n }\n \n-fn lint_get_unwrap<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    expr: &hir::Expr<'_>,\n-    get_args: &'tcx [hir::Expr<'_>],\n-    is_mut: bool,\n-) {\n+fn lint_get_unwrap<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, get_args: &'tcx [hir::Expr<'_>], is_mut: bool) {\n     // Note: we don't want to lint `get_mut().unwrap` for `HashMap` or `BTreeMap`,\n     // because they do not implement `IndexMut`\n     let mut applicability = Applicability::MachineApplicable;\n@@ -2445,7 +2436,7 @@ fn lint_get_unwrap<'a, 'tcx>(\n     );\n }\n \n-fn lint_iter_skip_next(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) {\n+fn lint_iter_skip_next(cx: &LateContext<'_>, expr: &hir::Expr<'_>) {\n     // lint if caller of skip is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         span_lint_and_help(\n@@ -2459,12 +2450,12 @@ fn lint_iter_skip_next(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) {\n     }\n }\n \n-fn derefs_to_slice<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn derefs_to_slice<'tcx>(\n+    cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'tcx>,\n     ty: Ty<'tcx>,\n ) -> Option<&'tcx hir::Expr<'tcx>> {\n-    fn may_slice<'a>(cx: &LateContext<'_, 'a>, ty: Ty<'a>) -> bool {\n+    fn may_slice<'a>(cx: &LateContext<'a>, ty: Ty<'a>) -> bool {\n         match ty.kind {\n             ty::Slice(_) => true,\n             ty::Adt(def, _) if def.is_box() => may_slice(cx, ty.boxed_ty()),\n@@ -2504,7 +2495,7 @@ fn derefs_to_slice<'a, 'tcx>(\n }\n \n /// lint use of `unwrap()` for `Option`s and `Result`s\n-fn lint_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, unwrap_args: &[hir::Expr<'_>]) {\n+fn lint_unwrap(cx: &LateContext<'_>, expr: &hir::Expr<'_>, unwrap_args: &[hir::Expr<'_>]) {\n     let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(&unwrap_args[0]));\n \n     let mess = if is_type_diagnostic_item(cx, obj_ty, sym!(option_type)) {\n@@ -2532,7 +2523,7 @@ fn lint_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, unwrap_args: &[hi\n }\n \n /// lint use of `expect()` for `Option`s and `Result`s\n-fn lint_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, expect_args: &[hir::Expr<'_>]) {\n+fn lint_expect(cx: &LateContext<'_>, expr: &hir::Expr<'_>, expect_args: &[hir::Expr<'_>]) {\n     let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(&expect_args[0]));\n \n     let mess = if is_type_diagnostic_item(cx, obj_ty, sym!(option_type)) {\n@@ -2556,7 +2547,7 @@ fn lint_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, expect_args: &[hi\n }\n \n /// lint use of `ok().expect()` for `Result`s\n-fn lint_ok_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, ok_args: &[hir::Expr<'_>]) {\n+fn lint_ok_expect(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ok_args: &[hir::Expr<'_>]) {\n     if_chain! {\n         // lint if the caller of `ok()` is a `Result`\n         if is_type_diagnostic_item(cx, cx.tables().expr_ty(&ok_args[0]), sym!(result_type));\n@@ -2578,7 +2569,7 @@ fn lint_ok_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, ok_args: &[hir\n }\n \n /// lint use of `map().flatten()` for `Iterators` and 'Options'\n-fn lint_map_flatten<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>, map_args: &'tcx [hir::Expr<'_>]) {\n+fn lint_map_flatten<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map_args: &'tcx [hir::Expr<'_>]) {\n     // lint if caller of `.map().flatten()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `map(..).flatten()` on an `Iterator`. \\\n@@ -2617,8 +2608,8 @@ fn lint_map_flatten<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<\n }\n \n /// lint use of `map().unwrap_or_else()` for `Option`s and `Result`s\n-fn lint_map_unwrap_or_else<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn lint_map_unwrap_or_else<'tcx>(\n+    cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n     map_args: &'tcx [hir::Expr<'_>],\n     unwrap_args: &'tcx [hir::Expr<'_>],\n@@ -2674,11 +2665,7 @@ fn lint_map_unwrap_or_else<'a, 'tcx>(\n }\n \n /// lint use of `_.map_or(None, _)` for `Option`s and `Result`s\n-fn lint_map_or_none<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx hir::Expr<'_>,\n-    map_or_args: &'tcx [hir::Expr<'_>],\n-) {\n+fn lint_map_or_none<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map_or_args: &'tcx [hir::Expr<'_>]) {\n     let is_option = is_type_diagnostic_item(cx, cx.tables().expr_ty(&map_or_args[0]), sym!(option_type));\n     let is_result = is_type_diagnostic_item(cx, cx.tables().expr_ty(&map_or_args[0]), sym!(result_type));\n \n@@ -2748,11 +2735,7 @@ fn lint_map_or_none<'a, 'tcx>(\n }\n \n /// lint use of `filter().next()` for `Iterators`\n-fn lint_filter_next<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx hir::Expr<'_>,\n-    filter_args: &'tcx [hir::Expr<'_>],\n-) {\n+fn lint_filter_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, filter_args: &'tcx [hir::Expr<'_>]) {\n     // lint if caller of `.filter().next()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n@@ -2775,8 +2758,8 @@ fn lint_filter_next<'a, 'tcx>(\n }\n \n /// lint use of `skip_while().next()` for `Iterators`\n-fn lint_skip_while_next<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn lint_skip_while_next<'tcx>(\n+    cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n     _skip_while_args: &'tcx [hir::Expr<'_>],\n ) {\n@@ -2794,8 +2777,8 @@ fn lint_skip_while_next<'a, 'tcx>(\n }\n \n /// lint use of `filter().map()` for `Iterators`\n-fn lint_filter_map<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn lint_filter_map<'tcx>(\n+    cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n     _filter_args: &'tcx [hir::Expr<'_>],\n     _map_args: &'tcx [hir::Expr<'_>],\n@@ -2809,11 +2792,7 @@ fn lint_filter_map<'a, 'tcx>(\n }\n \n /// lint use of `filter_map().next()` for `Iterators`\n-fn lint_filter_map_next<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx hir::Expr<'_>,\n-    filter_args: &'tcx [hir::Expr<'_>],\n-) {\n+fn lint_filter_map_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, filter_args: &'tcx [hir::Expr<'_>]) {\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter_map(p).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n                    `.find_map(p)` instead.\";\n@@ -2834,8 +2813,8 @@ fn lint_filter_map_next<'a, 'tcx>(\n }\n \n /// lint use of `find().map()` for `Iterators`\n-fn lint_find_map<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn lint_find_map<'tcx>(\n+    cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n     _find_args: &'tcx [hir::Expr<'_>],\n     map_args: &'tcx [hir::Expr<'_>],\n@@ -2849,8 +2828,8 @@ fn lint_find_map<'a, 'tcx>(\n }\n \n /// lint use of `filter_map().map()` for `Iterators`\n-fn lint_filter_map_map<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn lint_filter_map_map<'tcx>(\n+    cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n     _filter_args: &'tcx [hir::Expr<'_>],\n     _map_args: &'tcx [hir::Expr<'_>],\n@@ -2864,8 +2843,8 @@ fn lint_filter_map_map<'a, 'tcx>(\n }\n \n /// lint use of `filter().flat_map()` for `Iterators`\n-fn lint_filter_flat_map<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn lint_filter_flat_map<'tcx>(\n+    cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n     _filter_args: &'tcx [hir::Expr<'_>],\n     _map_args: &'tcx [hir::Expr<'_>],\n@@ -2880,8 +2859,8 @@ fn lint_filter_flat_map<'a, 'tcx>(\n }\n \n /// lint use of `filter_map().flat_map()` for `Iterators`\n-fn lint_filter_map_flat_map<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn lint_filter_map_flat_map<'tcx>(\n+    cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n     _filter_args: &'tcx [hir::Expr<'_>],\n     _map_args: &'tcx [hir::Expr<'_>],\n@@ -2896,8 +2875,8 @@ fn lint_filter_map_flat_map<'a, 'tcx>(\n }\n \n /// lint use of `flat_map` for `Iterators` where `flatten` would be sufficient\n-fn lint_flat_map_identity<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn lint_flat_map_identity<'tcx>(\n+    cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n     flat_map_args: &'tcx [hir::Expr<'_>],\n     flat_map_span: Span,\n@@ -2945,8 +2924,8 @@ fn lint_flat_map_identity<'a, 'tcx>(\n }\n \n /// lint searching an Iterator followed by `is_some()`\n-fn lint_search_is_some<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn lint_search_is_some<'tcx>(\n+    cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n     search_method: &str,\n     search_args: &'tcx [hir::Expr<'_>],\n@@ -3010,7 +2989,7 @@ struct BinaryExprInfo<'a> {\n }\n \n /// Checks for the `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints.\n-fn lint_binary_expr_with_method_call(cx: &LateContext<'_, '_>, info: &mut BinaryExprInfo<'_>) {\n+fn lint_binary_expr_with_method_call(cx: &LateContext<'_>, info: &mut BinaryExprInfo<'_>) {\n     macro_rules! lint_with_both_lhs_and_rhs {\n         ($func:ident, $cx:expr, $info:ident) => {\n             if !$func($cx, $info) {\n@@ -3030,7 +3009,7 @@ fn lint_binary_expr_with_method_call(cx: &LateContext<'_, '_>, info: &mut Binary\n \n /// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints.\n fn lint_chars_cmp(\n-    cx: &LateContext<'_, '_>,\n+    cx: &LateContext<'_>,\n     info: &BinaryExprInfo<'_>,\n     chain_methods: &[&str],\n     lint: &'static Lint,\n@@ -3073,12 +3052,12 @@ fn lint_chars_cmp(\n }\n \n /// Checks for the `CHARS_NEXT_CMP` lint.\n-fn lint_chars_next_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n+fn lint_chars_next_cmp<'tcx>(cx: &LateContext<'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n     lint_chars_cmp(cx, info, &[\"chars\", \"next\"], CHARS_NEXT_CMP, \"starts_with\")\n }\n \n /// Checks for the `CHARS_LAST_CMP` lint.\n-fn lint_chars_last_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n+fn lint_chars_last_cmp<'tcx>(cx: &LateContext<'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n     if lint_chars_cmp(cx, info, &[\"chars\", \"last\"], CHARS_LAST_CMP, \"ends_with\") {\n         true\n     } else {\n@@ -3087,8 +3066,8 @@ fn lint_chars_last_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprIn\n }\n \n /// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints with `unwrap()`.\n-fn lint_chars_cmp_with_unwrap<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn lint_chars_cmp_with_unwrap<'tcx>(\n+    cx: &LateContext<'tcx>,\n     info: &BinaryExprInfo<'_>,\n     chain_methods: &[&str],\n     lint: &'static Lint,\n@@ -3122,12 +3101,12 @@ fn lint_chars_cmp_with_unwrap<'a, 'tcx>(\n }\n \n /// Checks for the `CHARS_NEXT_CMP` lint with `unwrap()`.\n-fn lint_chars_next_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n+fn lint_chars_next_cmp_with_unwrap<'tcx>(cx: &LateContext<'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n     lint_chars_cmp_with_unwrap(cx, info, &[\"chars\", \"next\", \"unwrap\"], CHARS_NEXT_CMP, \"starts_with\")\n }\n \n /// Checks for the `CHARS_LAST_CMP` lint with `unwrap()`.\n-fn lint_chars_last_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n+fn lint_chars_last_cmp_with_unwrap<'tcx>(cx: &LateContext<'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n     if lint_chars_cmp_with_unwrap(cx, info, &[\"chars\", \"last\", \"unwrap\"], CHARS_LAST_CMP, \"ends_with\") {\n         true\n     } else {\n@@ -3136,11 +3115,7 @@ fn lint_chars_last_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &\n }\n \n /// lint for length-1 `str`s for methods in `PATTERN_METHODS`\n-fn lint_single_char_pattern<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    _expr: &'tcx hir::Expr<'_>,\n-    arg: &'tcx hir::Expr<'_>,\n-) {\n+fn lint_single_char_pattern<'tcx>(cx: &LateContext<'tcx>, _expr: &'tcx hir::Expr<'_>, arg: &'tcx hir::Expr<'_>) {\n     if_chain! {\n         if let hir::ExprKind::Lit(lit) = &arg.kind;\n         if let ast::LitKind::Str(r, style) = lit.node;\n@@ -3171,7 +3146,7 @@ fn lint_single_char_pattern<'a, 'tcx>(\n }\n \n /// Checks for the `USELESS_ASREF` lint.\n-fn lint_asref(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, call_name: &str, as_ref_args: &[hir::Expr<'_>]) {\n+fn lint_asref(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, as_ref_args: &[hir::Expr<'_>]) {\n     // when we get here, we've already checked that the call name is \"as_ref\" or \"as_mut\"\n     // check if the call is to the actual `AsRef` or `AsMut` trait\n     if match_trait_method(cx, expr, &paths::ASREF_TRAIT) || match_trait_method(cx, expr, &paths::ASMUT_TRAIT) {\n@@ -3206,7 +3181,7 @@ fn lint_asref(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, call_name: &str, a\n     }\n }\n \n-fn ty_has_iter_method(cx: &LateContext<'_, '_>, self_ref_ty: Ty<'_>) -> Option<(&'static str, &'static str)> {\n+fn ty_has_iter_method(cx: &LateContext<'_>, self_ref_ty: Ty<'_>) -> Option<(&'static str, &'static str)> {\n     has_iter_method(cx, self_ref_ty).map(|ty_name| {\n         let mutbl = match self_ref_ty.kind {\n             ty::Ref(_, _, mutbl) => mutbl,\n@@ -3220,7 +3195,7 @@ fn ty_has_iter_method(cx: &LateContext<'_, '_>, self_ref_ty: Ty<'_>) -> Option<(\n     })\n }\n \n-fn lint_into_iter(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, self_ref_ty: Ty<'_>, method_span: Span) {\n+fn lint_into_iter(cx: &LateContext<'_>, expr: &hir::Expr<'_>, self_ref_ty: Ty<'_>, method_span: Span) {\n     if !match_trait_method(cx, expr, &paths::INTO_ITERATOR) {\n         return;\n     }\n@@ -3241,7 +3216,7 @@ fn lint_into_iter(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, self_ref_ty: T\n }\n \n /// lint for `MaybeUninit::uninit().assume_init()` (we already have the latter)\n-fn lint_maybe_uninit(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, outer: &hir::Expr<'_>) {\n+fn lint_maybe_uninit(cx: &LateContext<'_>, expr: &hir::Expr<'_>, outer: &hir::Expr<'_>) {\n     if_chain! {\n         if let hir::ExprKind::Call(ref callee, ref args) = expr.kind;\n         if args.is_empty();\n@@ -3259,7 +3234,7 @@ fn lint_maybe_uninit(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, outer: &hir\n     }\n }\n \n-fn is_maybe_uninit_ty_valid(cx: &LateContext<'_, '_>, ty: Ty<'_>) -> bool {\n+fn is_maybe_uninit_ty_valid(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n     match ty.kind {\n         ty::Array(ref component, _) => is_maybe_uninit_ty_valid(cx, component),\n         ty::Tuple(ref types) => types.types().all(|ty| is_maybe_uninit_ty_valid(cx, ty)),\n@@ -3268,7 +3243,7 @@ fn is_maybe_uninit_ty_valid(cx: &LateContext<'_, '_>, ty: Ty<'_>) -> bool {\n     }\n }\n \n-fn lint_suspicious_map(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) {\n+fn lint_suspicious_map(cx: &LateContext<'_>, expr: &hir::Expr<'_>) {\n     span_lint_and_help(\n         cx,\n         SUSPICIOUS_MAP,\n@@ -3280,8 +3255,8 @@ fn lint_suspicious_map(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) {\n }\n \n /// lint use of `_.as_ref().map(Deref::deref)` for `Option`s\n-fn lint_option_as_ref_deref<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn lint_option_as_ref_deref<'tcx>(\n+    cx: &LateContext<'tcx>,\n     expr: &hir::Expr<'_>,\n     as_ref_args: &[hir::Expr<'_>],\n     map_args: &[hir::Expr<'_>],\n@@ -3376,15 +3351,15 @@ fn lint_option_as_ref_deref<'a, 'tcx>(\n }\n \n /// Given a `Result<T, E>` type, return its error type (`E`).\n-fn get_error_type<'a>(cx: &LateContext<'_, '_>, ty: Ty<'a>) -> Option<Ty<'a>> {\n+fn get_error_type<'a>(cx: &LateContext<'_>, ty: Ty<'a>) -> Option<Ty<'a>> {\n     match ty.kind {\n         ty::Adt(_, substs) if is_type_diagnostic_item(cx, ty, sym!(result_type)) => substs.types().nth(1),\n         _ => None,\n     }\n }\n \n /// This checks whether a given type is known to implement Debug.\n-fn has_debug_impl<'a, 'b>(ty: Ty<'a>, cx: &LateContext<'b, 'a>) -> bool {\n+fn has_debug_impl<'tcx>(ty: Ty<'tcx>, cx: &LateContext<'tcx>) -> bool {\n     cx.tcx\n         .get_diagnostic_item(sym::debug_trait)\n         .map_or(false, |debug| implements_trait(cx, ty, debug, &[]))\n@@ -3477,8 +3452,8 @@ enum SelfKind {\n }\n \n impl SelfKind {\n-    fn matches<'a>(self, cx: &LateContext<'_, 'a>, parent_ty: Ty<'a>, ty: Ty<'a>) -> bool {\n-        fn matches_value<'a>(cx: &LateContext<'_, 'a>, parent_ty: Ty<'_>, ty: Ty<'_>) -> bool {\n+    fn matches<'a>(self, cx: &LateContext<'a>, parent_ty: Ty<'a>, ty: Ty<'a>) -> bool {\n+        fn matches_value<'a>(cx: &LateContext<'a>, parent_ty: Ty<'_>, ty: Ty<'_>) -> bool {\n             if ty == parent_ty {\n                 true\n             } else if ty.is_box() {\n@@ -3494,12 +3469,7 @@ impl SelfKind {\n             }\n         }\n \n-        fn matches_ref<'a>(\n-            cx: &LateContext<'_, 'a>,\n-            mutability: hir::Mutability,\n-            parent_ty: Ty<'a>,\n-            ty: Ty<'a>,\n-        ) -> bool {\n+        fn matches_ref<'a>(cx: &LateContext<'a>, mutability: hir::Mutability, parent_ty: Ty<'a>, ty: Ty<'a>) -> bool {\n             if let ty::Ref(_, t, m) = ty.kind {\n                 return m == mutability && t == parent_ty;\n             }\n@@ -3563,7 +3533,7 @@ enum OutType {\n }\n \n impl OutType {\n-    fn matches(self, cx: &LateContext<'_, '_>, ty: &hir::FnRetTy<'_>) -> bool {\n+    fn matches(self, cx: &LateContext<'_>, ty: &hir::FnRetTy<'_>) -> bool {\n         let is_unit = |ty: &hir::Ty<'_>| SpanlessEq::new(cx).eq_ty_kind(&ty.kind, &hir::TyKind::Tup(&[]));\n         match (self, ty) {\n             (Self::Unit, &hir::FnRetTy::DefaultReturn(_)) => true,\n@@ -3614,7 +3584,7 @@ fn contains_return(expr: &hir::Expr<'_>) -> bool {\n     visitor.found\n }\n \n-fn check_pointer_offset(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+fn check_pointer_offset(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     if_chain! {\n         if args.len() == 2;\n         if let ty::RawPtr(ty::TypeAndMut { ref ty, .. }) = cx.tables().expr_ty(&args[0]).kind;\n@@ -3626,7 +3596,7 @@ fn check_pointer_offset(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[\n     }\n }\n \n-fn lint_filetype_is_file(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+fn lint_filetype_is_file(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     let ty = cx.tables().expr_ty(&args[0]);\n \n     if !match_type(cx, ty, &paths::FILE_TYPE) {"}, {"sha": "672eb75c57fc677988be130109bf982b18f16c96", "filename": "src/tools/clippy/clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -12,8 +12,8 @@ use rustc_span::symbol::Symbol;\n use super::MAP_UNWRAP_OR;\n \n /// lint use of `map().unwrap_or()` for `Option`s\n-pub(super) fn lint<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+pub(super) fn lint<'tcx>(\n+    cx: &LateContext<'tcx>,\n     expr: &rustc_hir::Expr<'_>,\n     map_args: &'tcx [rustc_hir::Expr<'_>],\n     unwrap_args: &'tcx [rustc_hir::Expr<'_>],\n@@ -87,7 +87,7 @@ pub(super) fn lint<'a, 'tcx>(\n }\n \n struct UnwrapVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     identifiers: FxHashSet<Symbol>,\n }\n \n@@ -105,7 +105,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrapVisitor<'a, 'tcx> {\n }\n \n struct MapExprVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     identifiers: FxHashSet<Symbol>,\n     found_identifier: bool,\n }"}, {"sha": "fdcba1105428841bfa4555a0c2d46c24bf5b13c0", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -11,7 +11,7 @@ use if_chain::if_chain;\n \n use super::UNNECESSARY_FILTER_MAP;\n \n-pub(super) fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+pub(super) fn lint(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     if !match_trait_method(cx, expr, &paths::ITERATOR) {\n         return;\n     }\n@@ -52,11 +52,7 @@ pub(super) fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[hir::\n }\n \n // returns (found_mapping, found_filtering)\n-fn check_expression<'a, 'tcx>(\n-    cx: &'a LateContext<'a, 'tcx>,\n-    arg_id: hir::HirId,\n-    expr: &'tcx hir::Expr<'_>,\n-) -> (bool, bool) {\n+fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tcx hir::Expr<'_>) -> (bool, bool) {\n     match &expr.kind {\n         hir::ExprKind::Call(ref func, ref args) => {\n             if_chain! {\n@@ -104,7 +100,7 @@ fn check_expression<'a, 'tcx>(\n }\n \n struct ReturnVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     arg_id: hir::HirId,\n     // Found a non-None return that isn't Some(input)\n     found_mapping: bool,\n@@ -113,7 +109,7 @@ struct ReturnVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> ReturnVisitor<'a, 'tcx> {\n-    fn new(cx: &'a LateContext<'a, 'tcx>, arg_id: hir::HirId) -> ReturnVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>, arg_id: hir::HirId) -> ReturnVisitor<'a, 'tcx> {\n         ReturnVisitor {\n             cx,\n             arg_id,"}, {"sha": "0a2d577396a5f94940442dc582e7e0c0a9b69e35", "filename": "src/tools/clippy/clippy_lints/src/minmax.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -27,8 +27,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(MinMaxPass => [MIN_MAX]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MinMaxPass {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for MinMaxPass {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let Some((outer_max, outer_c, oe)) = min_max(cx, expr) {\n             if let Some((inner_max, inner_c, ie)) = min_max(cx, oe) {\n                 if outer_max == inner_max {\n@@ -59,7 +59,7 @@ enum MinMax {\n     Max,\n }\n \n-fn min_max<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr<'a>) -> Option<(MinMax, Constant, &'a Expr<'a>)> {\n+fn min_max<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(MinMax, Constant, &'a Expr<'a>)> {\n     if let ExprKind::Call(ref path, ref args) = expr.kind {\n         if let ExprKind::Path(ref qpath) = path.kind {\n             cx.tables()\n@@ -82,11 +82,7 @@ fn min_max<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr<'a>) -> Option<(MinMax,\n     }\n }\n \n-fn fetch_const<'a>(\n-    cx: &LateContext<'_, '_>,\n-    args: &'a [Expr<'a>],\n-    m: MinMax,\n-) -> Option<(MinMax, Constant, &'a Expr<'a>)> {\n+fn fetch_const<'a>(cx: &LateContext<'_>, args: &'a [Expr<'a>], m: MinMax) -> Option<(MinMax, Constant, &'a Expr<'a>)> {\n     if args.len() != 2 {\n         return None;\n     }"}, {"sha": "d7e1a62a19d5204bd9d0e81bbe9b6c64bbc44dbe", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -260,10 +260,10 @@ declare_lint_pass!(MiscLints => [\n     FLOAT_CMP_CONST\n ]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MiscLints {\n+impl<'tcx> LateLintPass<'tcx> for MiscLints {\n     fn check_fn(\n         &mut self,\n-        cx: &LateContext<'a, 'tcx>,\n+        cx: &LateContext<'tcx>,\n         k: FnKind<'tcx>,\n         decl: &'tcx FnDecl<'_>,\n         body: &'tcx Body<'_>,\n@@ -287,7 +287,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MiscLints {\n         }\n     }\n \n-    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt<'_>) {\n+    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         if_chain! {\n             if let StmtKind::Local(ref local) = stmt.kind;\n             if let PatKind::Binding(an, .., name, None) = local.pat.kind;\n@@ -360,7 +360,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MiscLints {\n         };\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         match expr.kind {\n             ExprKind::Cast(ref e, ref ty) => {\n                 check_cast(cx, expr.span, e, ty);\n@@ -493,7 +493,7 @@ fn get_lint_and_message(\n     }\n }\n \n-fn check_nan(cx: &LateContext<'_, '_>, expr: &Expr<'_>, cmp_expr: &Expr<'_>) {\n+fn check_nan(cx: &LateContext<'_>, expr: &Expr<'_>, cmp_expr: &Expr<'_>) {\n     if_chain! {\n         if !in_constant(cx, cmp_expr.hir_id);\n         if let Some((value, _)) = constant(cx, cx.tables(), expr);\n@@ -516,15 +516,15 @@ fn check_nan(cx: &LateContext<'_, '_>, expr: &Expr<'_>, cmp_expr: &Expr<'_>) {\n     }\n }\n \n-fn is_named_constant<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+fn is_named_constant<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n     if let Some((_, res)) = constant(cx, cx.tables(), expr) {\n         res\n     } else {\n         false\n     }\n }\n \n-fn is_allowed<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+fn is_allowed<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n     match constant(cx, cx.tables(), expr) {\n         Some((Constant::F32(f), _)) => f == 0.0 || f.is_infinite(),\n         Some((Constant::F64(f), _)) => f == 0.0 || f.is_infinite(),\n@@ -538,7 +538,7 @@ fn is_allowed<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) -> boo\n }\n \n // Return true if `expr` is the result of `signum()` invoked on a float value.\n-fn is_signum(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+fn is_signum(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     // The negation of a signum is still a signum\n     if let ExprKind::Unary(UnOp::UnNeg, ref child_expr) = expr.kind {\n         return is_signum(cx, &child_expr);\n@@ -556,7 +556,7 @@ fn is_signum(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n     false\n }\n \n-fn is_float(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+fn is_float(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     let value = &walk_ptrs_ty(cx.tables().expr_ty(expr)).kind;\n \n     if let ty::Array(arr_ty, _) = value {\n@@ -566,11 +566,11 @@ fn is_float(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n     matches!(value, ty::Float(_))\n }\n \n-fn is_array(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+fn is_array(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     matches!(&walk_ptrs_ty(cx.tables().expr_ty(expr)).kind, ty::Array(_, _))\n }\n \n-fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr<'_>, other: &Expr<'_>) {\n+fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>) {\n     let (arg_ty, snip) = match expr.kind {\n         ExprKind::MethodCall(.., ref args, _) if args.len() == 1 => {\n             if match_trait_method(cx, expr, &paths::TO_STRING) || match_trait_method(cx, expr, &paths::TO_OWNED) {\n@@ -655,7 +655,7 @@ fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr<'_>, other: &Expr<'_>) {\n /// Heuristic to see if an expression is used. Should be compatible with\n /// `unused_variables`'s idea\n /// of what it means for an expression to be \"used\".\n-fn is_used(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+fn is_used(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     if let Some(parent) = get_parent_expr(cx, expr) {\n         match parent.kind {\n             ExprKind::Assign(_, ref rhs, _) | ExprKind::AssignOp(_, _, ref rhs) => {\n@@ -686,15 +686,15 @@ fn in_attributes_expansion(expr: &Expr<'_>) -> bool {\n }\n \n /// Tests whether `res` is a variable defined outside a macro.\n-fn non_macro_local(cx: &LateContext<'_, '_>, res: def::Res) -> bool {\n+fn non_macro_local(cx: &LateContext<'_>, res: def::Res) -> bool {\n     if let def::Res::Local(id) = res {\n         !cx.tcx.hir().span(id).from_expansion()\n     } else {\n         false\n     }\n }\n \n-fn check_cast(cx: &LateContext<'_, '_>, span: Span, e: &Expr<'_>, ty: &Ty<'_>) {\n+fn check_cast(cx: &LateContext<'_>, span: Span, e: &Expr<'_>, ty: &Ty<'_>) {\n     if_chain! {\n         if let TyKind::Ptr(ref mut_ty) = ty.kind;\n         if let ExprKind::Lit(ref lit) = e.kind;"}, {"sha": "bdce1bf15218041506f7f1b2a5301c012109e994", "filename": "src/tools/clippy/clippy_lints/src/missing_const_for_fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -71,10 +71,10 @@ declare_clippy_lint! {\n \n declare_lint_pass!(MissingConstForFn => [MISSING_CONST_FOR_FN]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingConstForFn {\n+impl<'tcx> LateLintPass<'tcx> for MissingConstForFn {\n     fn check_fn(\n         &mut self,\n-        cx: &LateContext<'_, '_>,\n+        cx: &LateContext<'_>,\n         kind: FnKind<'_>,\n         _: &FnDecl<'_>,\n         _: &Body<'_>,\n@@ -130,7 +130,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingConstForFn {\n \n /// Returns true if any of the method parameters is a type that implements `Drop`. The method\n /// can't be made const then, because `drop` can't be const-evaluated.\n-fn method_accepts_dropable(cx: &LateContext<'_, '_>, param_tys: &[hir::Ty<'_>]) -> bool {\n+fn method_accepts_dropable(cx: &LateContext<'_>, param_tys: &[hir::Ty<'_>]) -> bool {\n     // If any of the params are dropable, return true\n     param_tys.iter().any(|hir_ty| {\n         let ty_ty = hir_ty_to_ty(cx.tcx, hir_ty);"}, {"sha": "06e0f43c10bb82261ef0aa0f27326a18b84c4b52", "filename": "src/tools/clippy/clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -69,13 +69,7 @@ impl MissingDoc {\n         }\n     }\n \n-    fn check_missing_docs_attrs(\n-        &self,\n-        cx: &LateContext<'_, '_>,\n-        attrs: &[ast::Attribute],\n-        sp: Span,\n-        desc: &'static str,\n-    ) {\n+    fn check_missing_docs_attrs(&self, cx: &LateContext<'_>, attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n         // If we're building a test harness, then warning about\n         // documentation is probably not really relevant right now.\n         if cx.sess().opts.test {\n@@ -107,8 +101,8 @@ impl MissingDoc {\n \n impl_lint_pass!(MissingDoc => [MISSING_DOCS_IN_PRIVATE_ITEMS]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n-    fn enter_lint_attrs(&mut self, _: &LateContext<'a, 'tcx>, attrs: &'tcx [ast::Attribute]) {\n+impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n+    fn enter_lint_attrs(&mut self, _: &LateContext<'tcx>, attrs: &'tcx [ast::Attribute]) {\n         let doc_hidden = self.doc_hidden()\n             || attrs.iter().any(|attr| {\n                 attr.check_name(sym!(doc))\n@@ -120,15 +114,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         self.doc_hidden_stack.push(doc_hidden);\n     }\n \n-    fn exit_lint_attrs(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx [ast::Attribute]) {\n+    fn exit_lint_attrs(&mut self, _: &LateContext<'tcx>, _: &'tcx [ast::Attribute]) {\n         self.doc_hidden_stack.pop().expect(\"empty doc_hidden_stack\");\n     }\n \n-    fn check_crate(&mut self, cx: &LateContext<'a, 'tcx>, krate: &'tcx hir::Crate<'_>) {\n+    fn check_crate(&mut self, cx: &LateContext<'tcx>, krate: &'tcx hir::Crate<'_>) {\n         self.check_missing_docs_attrs(cx, &krate.item.attrs, krate.item.span, \"crate\");\n     }\n \n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx hir::Item<'_>) {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, it: &'tcx hir::Item<'_>) {\n         let desc = match it.kind {\n             hir::ItemKind::Const(..) => \"a constant\",\n             hir::ItemKind::Enum(..) => \"an enum\",\n@@ -161,7 +155,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         self.check_missing_docs_attrs(cx, &it.attrs, it.span, desc);\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, trait_item: &'tcx hir::TraitItem<'_>) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, trait_item: &'tcx hir::TraitItem<'_>) {\n         let desc = match trait_item.kind {\n             hir::TraitItemKind::Const(..) => \"an associated constant\",\n             hir::TraitItemKind::Fn(..) => \"a trait method\",\n@@ -171,7 +165,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         self.check_missing_docs_attrs(cx, &trait_item.attrs, trait_item.span, desc);\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, impl_item: &'tcx hir::ImplItem<'_>) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx hir::ImplItem<'_>) {\n         // If the method is an impl for a trait, don't doc.\n         let def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);\n         match cx.tcx.associated_item(def_id).container {\n@@ -191,13 +185,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         self.check_missing_docs_attrs(cx, &impl_item.attrs, impl_item.span, desc);\n     }\n \n-    fn check_struct_field(&mut self, cx: &LateContext<'a, 'tcx>, sf: &'tcx hir::StructField<'_>) {\n+    fn check_struct_field(&mut self, cx: &LateContext<'tcx>, sf: &'tcx hir::StructField<'_>) {\n         if !sf.is_positional() {\n             self.check_missing_docs_attrs(cx, &sf.attrs, sf.span, \"a struct field\");\n         }\n     }\n \n-    fn check_variant(&mut self, cx: &LateContext<'a, 'tcx>, v: &'tcx hir::Variant<'_>) {\n+    fn check_variant(&mut self, cx: &LateContext<'tcx>, v: &'tcx hir::Variant<'_>) {\n         self.check_missing_docs_attrs(cx, &v.attrs, v.span, \"a variant\");\n     }\n }"}, {"sha": "bf80b62afe6e04d99882a6500136cacc0d26153f", "filename": "src/tools/clippy/clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -56,7 +56,7 @@ declare_clippy_lint! {\n     \"detects missing `#[inline]` attribute for public callables (functions, trait methods, methods...)\"\n }\n \n-fn check_missing_inline_attrs(cx: &LateContext<'_, '_>, attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n+fn check_missing_inline_attrs(cx: &LateContext<'_>, attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n     let has_inline = attrs.iter().any(|a| a.check_name(sym!(inline)));\n     if !has_inline {\n         span_lint(\n@@ -68,7 +68,7 @@ fn check_missing_inline_attrs(cx: &LateContext<'_, '_>, attrs: &[ast::Attribute]\n     }\n }\n \n-fn is_executable(cx: &LateContext<'_, '_>) -> bool {\n+fn is_executable(cx: &LateContext<'_>) -> bool {\n     use rustc_session::config::CrateType;\n \n     cx.tcx.sess.crate_types().iter().any(|t: &CrateType| match t {\n@@ -79,8 +79,8 @@ fn is_executable(cx: &LateContext<'_, '_>) -> bool {\n \n declare_lint_pass!(MissingInline => [MISSING_INLINE_IN_PUBLIC_ITEMS]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx hir::Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for MissingInline {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, it: &'tcx hir::Item<'_>) {\n         if rustc_middle::lint::in_external_macro(cx.sess(), it.span) || is_executable(cx) {\n             return;\n         }\n@@ -129,7 +129,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n         };\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, impl_item: &'tcx hir::ImplItem<'_>) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx hir::ImplItem<'_>) {\n         use rustc_middle::ty::{ImplContainer, TraitContainer};\n         if rustc_middle::lint::in_external_macro(cx.sess(), impl_item.span) || is_executable(cx) {\n             return;"}, {"sha": "59ccc6333fdcd838dc28da84c89ba7062a7c32b4", "filename": "src/tools/clippy/clippy_lints/src/modulo_arithmetic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodulo_arithmetic.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -36,7 +36,7 @@ struct OperandInfo {\n     is_integral: bool,\n }\n \n-fn analyze_operand(operand: &Expr<'_>, cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Option<OperandInfo> {\n+fn analyze_operand(operand: &Expr<'_>, cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<OperandInfo> {\n     match constant(cx, cx.tables(), operand) {\n         Some((Constant::Int(v), _)) => match cx.tables().expr_ty(expr).kind {\n             ty::Int(ity) => {\n@@ -79,8 +79,8 @@ fn might_have_negative_value(t: &ty::TyS<'_>) -> bool {\n     t.is_signed() || t.is_floating_point()\n }\n \n-fn check_const_operands<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn check_const_operands<'tcx>(\n+    cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'_>,\n     lhs_operand: &OperandInfo,\n     rhs_operand: &OperandInfo,\n@@ -105,7 +105,7 @@ fn check_const_operands<'a, 'tcx>(\n     }\n }\n \n-fn check_non_const_operands<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>, operand: &Expr<'_>) {\n+fn check_non_const_operands<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, operand: &Expr<'_>) {\n     let operand_type = cx.tables().expr_ty(operand);\n     if might_have_negative_value(operand_type) {\n         span_lint_and_then(\n@@ -123,8 +123,8 @@ fn check_non_const_operands<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Ex\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ModuloArithmetic {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for ModuloArithmetic {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         match &expr.kind {\n             ExprKind::Binary(op, lhs, rhs) | ExprKind::AssignOp(op, lhs, rhs) => {\n                 if let BinOpKind::Rem = op.node {"}, {"sha": "c1773cef7a8b7f4c63b9af27269078a4ab91cf49", "filename": "src/tools/clippy/clippy_lints/src/multiple_crate_versions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmultiple_crate_versions.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -36,8 +36,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(MultipleCrateVersions => [MULTIPLE_CRATE_VERSIONS]);\n \n-impl LateLintPass<'_, '_> for MultipleCrateVersions {\n-    fn check_crate(&mut self, cx: &LateContext<'_, '_>, _: &Crate<'_>) {\n+impl LateLintPass<'_> for MultipleCrateVersions {\n+    fn check_crate(&mut self, cx: &LateContext<'_>, _: &Crate<'_>) {\n         if !run_lints(cx, &[MULTIPLE_CRATE_VERSIONS], CRATE_HIR_ID) {\n             return;\n         }"}, {"sha": "d8fb8a4bb776bafc273841a6ee4ac824aa94a807", "filename": "src/tools/clippy/clippy_lints/src/mut_key.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -51,36 +51,36 @@ declare_clippy_lint! {\n \n declare_lint_pass!(MutableKeyType => [ MUTABLE_KEY_TYPE ]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableKeyType {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item<'tcx>) {\n+impl<'tcx> LateLintPass<'tcx> for MutableKeyType {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         if let hir::ItemKind::Fn(ref sig, ..) = item.kind {\n             check_sig(cx, item.hir_id, &sig.decl);\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ImplItem<'tcx>) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'tcx>) {\n         if let hir::ImplItemKind::Fn(ref sig, ..) = item.kind {\n             if trait_ref_of_method(cx, item.hir_id).is_none() {\n                 check_sig(cx, item.hir_id, &sig.decl);\n             }\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem<'tcx>) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'tcx>) {\n         if let hir::TraitItemKind::Fn(ref sig, ..) = item.kind {\n             check_sig(cx, item.hir_id, &sig.decl);\n         }\n     }\n \n-    fn check_local(&mut self, cx: &LateContext<'_, '_>, local: &hir::Local<'_>) {\n+    fn check_local(&mut self, cx: &LateContext<'_>, local: &hir::Local<'_>) {\n         if let hir::PatKind::Wild = local.pat.kind {\n             return;\n         }\n         check_ty(cx, local.span, cx.tables().pat_ty(&*local.pat));\n     }\n }\n \n-fn check_sig<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item_hir_id: hir::HirId, decl: &hir::FnDecl<'_>) {\n+fn check_sig<'tcx>(cx: &LateContext<'tcx>, item_hir_id: hir::HirId, decl: &hir::FnDecl<'_>) {\n     let fn_def_id = cx.tcx.hir().local_def_id(item_hir_id);\n     let fn_sig = cx.tcx.fn_sig(fn_def_id);\n     for (hir_ty, ty) in decl.inputs.iter().zip(fn_sig.inputs().skip_binder().iter()) {\n@@ -95,7 +95,7 @@ fn check_sig<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item_hir_id: hir::HirId, decl\n \n // We want to lint 1. sets or maps with 2. not immutable key types and 3. no unerased\n // generics (because the compiler cannot ensure immutability for unknown types).\n-fn check_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, span: Span, ty: Ty<'tcx>) {\n+fn check_ty<'tcx>(cx: &LateContext<'tcx>, span: Span, ty: Ty<'tcx>) {\n     let ty = walk_ptrs_ty(ty);\n     if let Adt(def, substs) = ty.kind {\n         if [&paths::HASHMAP, &paths::BTREEMAP, &paths::HASHSET, &paths::BTREESET]\n@@ -108,7 +108,7 @@ fn check_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, span: Span, ty: Ty<'tcx>) {\n     }\n }\n \n-fn is_mutable_type<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>, span: Span) -> bool {\n+fn is_mutable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span) -> bool {\n     match ty.kind {\n         RawPtr(TypeAndMut { ty: inner_ty, mutbl }) | Ref(_, inner_ty, mutbl) => {\n             mutbl == hir::Mutability::Mut || is_mutable_type(cx, inner_ty, span)"}, {"sha": "259b4c73d7609b1cef0fe22899f677d41575c195", "filename": "src/tools/clippy/clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mut.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -28,20 +28,20 @@ declare_clippy_lint! {\n \n declare_lint_pass!(MutMut => [MUT_MUT]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutMut {\n-    fn check_block(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx hir::Block<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for MutMut {\n+    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx hir::Block<'_>) {\n         intravisit::walk_block(&mut MutVisitor { cx }, block);\n     }\n \n-    fn check_ty(&mut self, cx: &LateContext<'a, 'tcx>, ty: &'tcx hir::Ty<'_>) {\n+    fn check_ty(&mut self, cx: &LateContext<'tcx>, ty: &'tcx hir::Ty<'_>) {\n         use rustc_hir::intravisit::Visitor;\n \n         MutVisitor { cx }.visit_ty(ty);\n     }\n }\n \n pub struct MutVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n }\n \n impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {"}, {"sha": "53341b6eba752a019c1c948312068a549b94d029", "filename": "src/tools/clippy/clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -29,8 +29,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(UnnecessaryMutPassed => [UNNECESSARY_MUT_PASSED]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for UnnecessaryMutPassed {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         match e.kind {\n             ExprKind::Call(ref fn_expr, ref arguments) => {\n                 if let ExprKind::Path(ref path) = fn_expr.kind {\n@@ -53,12 +53,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n     }\n }\n \n-fn check_arguments<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    arguments: &[Expr<'_>],\n-    type_definition: Ty<'tcx>,\n-    name: &str,\n-) {\n+fn check_arguments<'tcx>(cx: &LateContext<'tcx>, arguments: &[Expr<'_>], type_definition: Ty<'tcx>, name: &str) {\n     match type_definition.kind {\n         ty::FnDef(..) | ty::FnPtr(_) => {\n             let parameters = type_definition.fn_sig(cx.tcx).skip_binder().inputs();"}, {"sha": "78d2356748f1ed6b164a1bd4939ebb77293ee5a3", "filename": "src/tools/clippy/clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -35,8 +35,8 @@ declare_lint_pass!(DebugAssertWithMutCall => [DEBUG_ASSERT_WITH_MUT_CALL]);\n \n const DEBUG_MACRO_NAMES: [&str; 3] = [\"debug_assert\", \"debug_assert_eq\", \"debug_assert_ne\"];\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DebugAssertWithMutCall {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for DebugAssertWithMutCall {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         for dmn in &DEBUG_MACRO_NAMES {\n             if is_direct_expn_of(e.span, dmn).is_some() {\n                 if let Some(span) = extract_call(cx, e) {\n@@ -53,7 +53,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DebugAssertWithMutCall {\n }\n \n //HACK(hellow554): remove this when #4694 is implemented\n-fn extract_call<'a, 'tcx>(cx: &'a LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) -> Option<Span> {\n+fn extract_call<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> Option<Span> {\n     if_chain! {\n         if let ExprKind::Block(ref block, _) = e.kind;\n         if block.stmts.len() == 1;\n@@ -102,13 +102,13 @@ fn extract_call<'a, 'tcx>(cx: &'a LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) -> O\n }\n \n struct MutArgVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     expr_span: Option<Span>,\n     found: bool,\n }\n \n impl<'a, 'tcx> MutArgVisitor<'a, 'tcx> {\n-    fn new(cx: &'a LateContext<'a, 'tcx>) -> Self {\n+    fn new(cx: &'a LateContext<'tcx>) -> Self {\n         Self {\n             cx,\n             expr_span: None,"}, {"sha": "1a821491fcaf2f5e78004cccf452478151838814", "filename": "src/tools/clippy/clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -64,8 +64,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(Mutex => [MUTEX_ATOMIC, MUTEX_INTEGER]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Mutex {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for Mutex {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         let ty = cx.tables().expr_ty(expr);\n         if let ty::Adt(_, subst) = ty.kind {\n             if is_type_diagnostic_item(cx, ty, sym!(mutex_type)) {"}, {"sha": "e15376b932628a229319a445c5f2ec4d6903844f", "filename": "src/tools/clippy/clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -67,8 +67,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(NeedlessBool => [NEEDLESS_BOOL]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         use self::Expression::{Bool, RetBool};\n         if let Some((ref pred, ref then_block, Some(ref else_expr))) = higher::if_block(&e) {\n             let reduce = |ret, not| {\n@@ -127,8 +127,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n \n declare_lint_pass!(BoolComparison => [BOOL_COMPARISON]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoolComparison {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for BoolComparison {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if e.span.from_expansion() {\n             return;\n         }\n@@ -218,7 +218,7 @@ fn one_side_is_unary_not<'tcx>(left_side: &'tcx Expr<'_>, right_side: &'tcx Expr\n }\n \n fn check_comparison<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+    cx: &LateContext<'tcx>,\n     e: &'tcx Expr<'_>,\n     left_true: Option<(impl FnOnce(Sugg<'a>) -> Sugg<'a>, &str)>,\n     left_false: Option<(impl FnOnce(Sugg<'a>) -> Sugg<'a>, &str)>,\n@@ -285,7 +285,7 @@ fn check_comparison<'a, 'tcx>(\n }\n \n fn suggest_bool_comparison<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+    cx: &LateContext<'tcx>,\n     e: &'tcx Expr<'_>,\n     expr: &Expr<'_>,\n     mut applicability: Applicability,"}, {"sha": "1bea93fcb75220ba364c05b91bc70a0b369cd9d2", "filename": "src/tools/clippy/clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -40,8 +40,8 @@ pub struct NeedlessBorrow {\n \n impl_lint_pass!(NeedlessBorrow => [NEEDLESS_BORROW]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if e.span.from_expansion() || self.derived_item.is_some() {\n             return;\n         }\n@@ -79,7 +79,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n             }\n         }\n     }\n-    fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat<'_>) {\n+    fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {\n         if pat.span.from_expansion() || self.derived_item.is_some() {\n             return;\n         }\n@@ -111,14 +111,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n         }\n     }\n \n-    fn check_item(&mut self, _: &LateContext<'a, 'tcx>, item: &'tcx Item<'_>) {\n+    fn check_item(&mut self, _: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if item.attrs.iter().any(|a| a.check_name(sym!(automatically_derived))) {\n             debug_assert!(self.derived_item.is_none());\n             self.derived_item = Some(item.hir_id);\n         }\n     }\n \n-    fn check_item_post(&mut self, _: &LateContext<'a, 'tcx>, item: &'tcx Item<'_>) {\n+    fn check_item_post(&mut self, _: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if let Some(id) = self.derived_item {\n             if item.hir_id == id {\n                 self.derived_item = None;"}, {"sha": "85184fdea4779af2cd537ab794d8f3e9e21c8bed", "filename": "src/tools/clippy/clippy_lints/src/needless_borrowed_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -52,8 +52,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(NeedlessBorrowedRef => [NEEDLESS_BORROWED_REFERENCE]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrowedRef {\n-    fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for NeedlessBorrowedRef {\n+    fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {\n         if pat.span.from_expansion() {\n             // OK, simple enough, lints doesn't check in macro.\n             return;"}, {"sha": "bc70c675ad6915e647825dfa8c557e7816dd3390", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -64,11 +64,11 @@ macro_rules! need {\n     };\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n+impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n     #[allow(clippy::too_many_lines)]\n     fn check_fn(\n         &mut self,\n-        cx: &LateContext<'a, 'tcx>,\n+        cx: &LateContext<'tcx>,\n         kind: FnKind<'tcx>,\n         decl: &'tcx FnDecl<'_>,\n         body: &'tcx Body<'_>,"}, {"sha": "6ec73041604e60b1ff0e43f929fe5cfbbcf94b61", "filename": "src/tools/clippy/clippy_lints/src/needless_update.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_update.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -44,8 +44,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(NeedlessUpdate => [NEEDLESS_UPDATE]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessUpdate {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for NeedlessUpdate {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Struct(_, ref fields, Some(ref base)) = expr.kind {\n             let ty = cx.tables().expr_ty(expr);\n             if let ty::Adt(def, _) = ty.kind {"}, {"sha": "1be766d8e8dc5765b420543bcc62353be4a850df", "filename": "src/tools/clippy/clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -45,8 +45,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(NoNegCompOpForPartialOrd => [NEG_CMP_OP_ON_PARTIAL_ORD]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NoNegCompOpForPartialOrd {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for NoNegCompOpForPartialOrd {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n \n             if !in_external_macro(cx.sess(), expr.span);"}, {"sha": "1346145da327ed4027d745093dfde18c16c79c7f", "filename": "src/tools/clippy/clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -26,8 +26,8 @@ declare_clippy_lint! {\n declare_lint_pass!(NegMultiply => [NEG_MULTIPLY]);\n \n #[allow(clippy::match_same_arms)]\n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NegMultiply {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for NegMultiply {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if let ExprKind::Binary(ref op, ref left, ref right) = e.kind {\n             if BinOpKind::Mul == op.node {\n                 match (&left.kind, &right.kind) {\n@@ -41,7 +41,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NegMultiply {\n     }\n }\n \n-fn check_mul(cx: &LateContext<'_, '_>, span: Span, lit: &Expr<'_>, exp: &Expr<'_>) {\n+fn check_mul(cx: &LateContext<'_>, span: Span, lit: &Expr<'_>, exp: &Expr<'_>) {\n     if_chain! {\n         if let ExprKind::Lit(ref l) = lit.kind;\n         if let Constant::Int(1) = consts::lit_to_constant(&l.node, cx.tables().expr_ty_opt(lit));"}, {"sha": "2597f5f6f17e22aebc3aa680de1c78cad85fa645", "filename": "src/tools/clippy/clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -56,9 +56,9 @@ pub struct NewWithoutDefault {\n \n impl_lint_pass!(NewWithoutDefault => [NEW_WITHOUT_DEFAULT]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n+impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n     #[allow(clippy::too_many_lines)]\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item<'_>) {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n         if let hir::ItemKind::Impl {\n             of_trait: None, items, ..\n         } = item.kind"}, {"sha": "95283dae714703c5c6144b2791e306a3db4feb5f", "filename": "src/tools/clippy/clippy_lints/src/no_effect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -42,7 +42,7 @@ declare_clippy_lint! {\n     \"outer expressions with no effect\"\n }\n \n-fn has_no_effect(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+fn has_no_effect(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     if expr.span.from_expansion() {\n         return false;\n     }\n@@ -87,8 +87,8 @@ fn has_no_effect(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n \n declare_lint_pass!(NoEffect => [NO_EFFECT, UNNECESSARY_OPERATION]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NoEffect {\n-    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for NoEffect {\n+    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         if let StmtKind::Semi(ref expr) = stmt.kind {\n             if has_no_effect(cx, expr) {\n                 span_lint(cx, NO_EFFECT, stmt.span, \"statement with no effect\");\n@@ -119,7 +119,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NoEffect {\n     }\n }\n \n-fn reduce_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr<'a>) -> Option<Vec<&'a Expr<'a>>> {\n+fn reduce_expression<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<Vec<&'a Expr<'a>>> {\n     if expr.span.from_expansion() {\n         return None;\n     }"}, {"sha": "c11a2ff9ee07ef4cd62d191acb8b651d942b51db", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -109,7 +109,7 @@ impl Source {\n     }\n }\n \n-fn verify_ty_bound<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>, source: Source) {\n+fn verify_ty_bound<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, source: Source) {\n     if ty.is_freeze(cx.tcx.at(DUMMY_SP), cx.param_env) || is_copy(cx, ty) {\n         // An `UnsafeCell` is `!Copy`, and an `UnsafeCell` is also the only type which\n         // is `!Freeze`, thus if our type is `Copy` we can be sure it must be `Freeze`\n@@ -141,15 +141,15 @@ fn verify_ty_bound<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>, source: S\n \n declare_lint_pass!(NonCopyConst => [DECLARE_INTERIOR_MUTABLE_CONST, BORROW_INTERIOR_MUTABLE_CONST]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, it: &'tcx Item<'_>) {\n         if let ItemKind::Const(hir_ty, ..) = &it.kind {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             verify_ty_bound(cx, ty, Source::Item { item: it.span });\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, trait_item: &'tcx TraitItem<'_>) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, trait_item: &'tcx TraitItem<'_>) {\n         if let TraitItemKind::Const(hir_ty, ..) = &trait_item.kind {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             verify_ty_bound(\n@@ -163,7 +163,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, impl_item: &'tcx ImplItem<'_>) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx ImplItem<'_>) {\n         if let ImplItemKind::Const(hir_ty, ..) = &impl_item.kind {\n             let item_hir_id = cx.tcx.hir().get_parent_node(impl_item.hir_id);\n             let item = cx.tcx.hir().expect_item(item_hir_id);\n@@ -182,7 +182,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Path(qpath) = &expr.kind {\n             // Only lint if we use the const item inside a function.\n             if in_constant(cx, expr.hir_id) {"}, {"sha": "2b83efa84f64dff645bcf55e095e65aee222ab32", "filename": "src/tools/clippy/clippy_lints/src/open_options.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fopen_options.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -27,8 +27,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(OpenOptions => [NONSENSICAL_OPEN_OPTIONS]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OpenOptions {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for OpenOptions {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if let ExprKind::MethodCall(ref path, _, ref arguments, _) = e.kind {\n             let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(&arguments[0]));\n             if path.ident.name == sym!(open) && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n@@ -56,7 +56,7 @@ enum OpenOption {\n     Append,\n }\n \n-fn get_open_options(cx: &LateContext<'_, '_>, argument: &Expr<'_>, options: &mut Vec<(OpenOption, Argument)>) {\n+fn get_open_options(cx: &LateContext<'_>, argument: &Expr<'_>, options: &mut Vec<(OpenOption, Argument)>) {\n     if let ExprKind::MethodCall(ref path, _, ref arguments, _) = argument.kind {\n         let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(&arguments[0]));\n \n@@ -107,7 +107,7 @@ fn get_open_options(cx: &LateContext<'_, '_>, argument: &Expr<'_>, options: &mut\n     }\n }\n \n-fn check_open_options(cx: &LateContext<'_, '_>, options: &[(OpenOption, Argument)], span: Span) {\n+fn check_open_options(cx: &LateContext<'_>, options: &[(OpenOption, Argument)], span: Span) {\n     let (mut create, mut append, mut truncate, mut read, mut write) = (false, false, false, false, false);\n     let (mut create_arg, mut append_arg, mut truncate_arg, mut read_arg, mut write_arg) =\n         (false, false, false, false, false);"}, {"sha": "0850f88df44fec4b7cf14d17456fa7b9f6dd868b", "filename": "src/tools/clippy/clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -25,9 +25,9 @@ declare_clippy_lint! {\n \n declare_lint_pass!(OverflowCheckConditional => [OVERFLOW_CHECK_CONDITIONAL]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OverflowCheckConditional {\n+impl<'tcx> LateLintPass<'tcx> for OverflowCheckConditional {\n     // a + b < a, a > a + b, a < a - b, a - b > a\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         let eq = |l, r| SpanlessEq::new(cx).eq_path_segment(l, r);\n         if_chain! {\n             if let ExprKind::Binary(ref op, ref first, ref second) = expr.kind;"}, {"sha": "10f4694640eed99907d31aedd6ee0beaed624aa7", "filename": "src/tools/clippy/clippy_lints/src/panic_unimplemented.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_unimplemented.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -91,8 +91,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(PanicUnimplemented => [PANIC_PARAMS, UNIMPLEMENTED, UNREACHABLE, TODO, PANIC]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PanicUnimplemented {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for PanicUnimplemented {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Block(ref block, _) = expr.kind;\n             if let Some(ref ex) = block.expr;\n@@ -136,7 +136,7 @@ fn get_outer_span(expr: &Expr<'_>) -> Span {\n     }\n }\n \n-fn match_panic(params: &[Expr<'_>], expr: &Expr<'_>, cx: &LateContext<'_, '_>) {\n+fn match_panic(params: &[Expr<'_>], expr: &Expr<'_>, cx: &LateContext<'_>) {\n     if_chain! {\n         if let ExprKind::Lit(ref lit) = params[0].kind;\n         if is_direct_expn_of(expr.span, \"panic\").is_some();"}, {"sha": "19d355e64ca8675add330df1facbe2a15cac00ae", "filename": "src/tools/clippy/clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -30,8 +30,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(PartialEqNeImpl => [PARTIALEQ_NE_IMPL]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PartialEqNeImpl {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for PartialEqNeImpl {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if_chain! {\n             if let ItemKind::Impl{ of_trait: Some(ref trait_ref), items: impl_items, .. } = item.kind;\n             if !is_automatically_derived(&*item.attrs);"}, {"sha": "48e609542793b2de9f086f53d74aae96b7e8a2c0", "filename": "src/tools/clippy/clippy_lints/src/path_buf_push_overwrite.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -40,8 +40,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(PathBufPushOverwrite => [PATH_BUF_PUSH_OVERWRITE]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PathBufPushOverwrite {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for PathBufPushOverwrite {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n             if path.ident.name == sym!(push);"}, {"sha": "7b6bd69ffca5c6d82d66001187f5e5262a0e1507", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -108,14 +108,14 @@ declare_clippy_lint! {\n \n declare_lint_pass!(Ptr => [PTR_ARG, CMP_NULL, MUT_FROM_REF]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Ptr {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for Ptr {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if let ItemKind::Fn(ref sig, _, body_id) = item.kind {\n             check_fn(cx, &sig.decl, item.hir_id, Some(body_id));\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem<'_>) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n         if let ImplItemKind::Fn(ref sig, body_id) = item.kind {\n             let parent_item = cx.tcx.hir().get_parent_item(item.hir_id);\n             if let Some(Node::Item(it)) = cx.tcx.hir().find(parent_item) {\n@@ -127,7 +127,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Ptr {\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem<'_>) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'_>) {\n         if let TraitItemKind::Fn(ref sig, ref trait_method) = item.kind {\n             let body_id = if let TraitFn::Provided(b) = *trait_method {\n                 Some(b)\n@@ -138,7 +138,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Ptr {\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Binary(ref op, ref l, ref r) = expr.kind {\n             if (op.node == BinOpKind::Eq || op.node == BinOpKind::Ne) && (is_null_path(l) || is_null_path(r)) {\n                 span_lint(\n@@ -153,7 +153,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Ptr {\n }\n \n #[allow(clippy::too_many_lines)]\n-fn check_fn(cx: &LateContext<'_, '_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_id: Option<BodyId>) {\n+fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_id: Option<BodyId>) {\n     let fn_def_id = cx.tcx.hir().local_def_id(fn_id);\n     let sig = cx.tcx.fn_sig(fn_def_id);\n     let fn_ty = sig.skip_binder();"}, {"sha": "61e186a4b4653f59c6218c3ad05e4f275b9a567f", "filename": "src/tools/clippy/clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -43,8 +43,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(PtrOffsetWithCast => [PTR_OFFSET_WITH_CAST]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PtrOffsetWithCast {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for PtrOffsetWithCast {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // Check if the expressions is a ptr.offset or ptr.wrapping_offset method call\n         let (receiver_expr, arg_expr, method) = match expr_as_ptr_offset_call(cx, expr) {\n             Some(call_arg) => call_arg,\n@@ -75,7 +75,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PtrOffsetWithCast {\n }\n \n // If the given expression is a cast from a usize, return the lhs of the cast\n-fn expr_as_cast_from_usize<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n+fn expr_as_cast_from_usize<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n     if let ExprKind::Cast(ref cast_lhs_expr, _) = expr.kind {\n         if is_expr_ty_usize(cx, &cast_lhs_expr) {\n             return Some(cast_lhs_expr);\n@@ -86,8 +86,8 @@ fn expr_as_cast_from_usize<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Exp\n \n // If the given expression is a ptr::offset  or ptr::wrapping_offset method call, return the\n // receiver, the arg of the method call, and the method.\n-fn expr_as_ptr_offset_call<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn expr_as_ptr_offset_call<'tcx>(\n+    cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'_>,\n ) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>, Method)> {\n     if let ExprKind::MethodCall(ref path_segment, _, ref args, _) = expr.kind {\n@@ -104,17 +104,17 @@ fn expr_as_ptr_offset_call<'a, 'tcx>(\n }\n \n // Is the type of the expression a usize?\n-fn is_expr_ty_usize<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr<'_>) -> bool {\n+fn is_expr_ty_usize<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> bool {\n     cx.tables().expr_ty(expr) == cx.tcx.types.usize\n }\n \n // Is the type of the expression a raw pointer?\n-fn is_expr_ty_raw_ptr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr<'_>) -> bool {\n+fn is_expr_ty_raw_ptr<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> bool {\n     cx.tables().expr_ty(expr).is_unsafe_ptr()\n }\n \n-fn build_suggestion<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn build_suggestion<'tcx>(\n+    cx: &LateContext<'tcx>,\n     method: Method,\n     receiver_expr: &Expr<'_>,\n     cast_lhs_expr: &Expr<'_>,"}, {"sha": "cc9c2f196079f001e552d7c407d80aa1beee54fa", "filename": "src/tools/clippy/clippy_lints/src/question_mark.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -47,7 +47,7 @@ impl QuestionMark {\n     /// ```\n     ///\n     /// If it matches, it will suggest to use the question mark operator instead\n-    fn check_is_none_and_early_return_none(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+    fn check_is_none_and_early_return_none(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n             if let Some((if_expr, body, else_)) = higher::if_block(&expr);\n             if let ExprKind::MethodCall(segment, _, args, _) = &if_expr.kind;\n@@ -93,7 +93,7 @@ impl QuestionMark {\n         }\n     }\n \n-    fn check_if_let_some_and_early_return_none(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+    fn check_if_let_some_and_early_return_none(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Match(subject, arms, source) = &expr.kind;\n             if *source == MatchSource::IfLetDesugar { contains_else_clause: true };\n@@ -134,19 +134,19 @@ impl QuestionMark {\n         }\n     }\n \n-    fn moves_by_default(cx: &LateContext<'_, '_>, expression: &Expr<'_>) -> bool {\n+    fn moves_by_default(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n         let expr_ty = cx.tables().expr_ty(expression);\n \n         !expr_ty.is_copy_modulo_regions(cx.tcx.at(expression.span), cx.param_env)\n     }\n \n-    fn is_option(cx: &LateContext<'_, '_>, expression: &Expr<'_>) -> bool {\n+    fn is_option(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n         let expr_ty = cx.tables().expr_ty(expression);\n \n         is_type_diagnostic_item(cx, expr_ty, sym!(option_type))\n     }\n \n-    fn expression_returns_none(cx: &LateContext<'_, '_>, expression: &Expr<'_>) -> bool {\n+    fn expression_returns_none(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n         match expression.kind {\n             ExprKind::Block(ref block, _) => {\n                 if let Some(return_expression) = Self::return_expression(block) {\n@@ -196,8 +196,8 @@ impl QuestionMark {\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for QuestionMark {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for QuestionMark {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         Self::check_is_none_and_early_return_none(cx, expr);\n         Self::check_if_let_some_and_early_return_none(cx, expr);\n     }"}, {"sha": "c164ec9aaf173ef2fa42bd36c3ff1b89c028e1b3", "filename": "src/tools/clippy/clippy_lints/src/ranges.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -127,8 +127,8 @@ declare_lint_pass!(Ranges => [\n     REVERSED_EMPTY_RANGES,\n ]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Ranges {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for Ranges {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind {\n             let name = path.ident.as_str();\n             if name == \"zip\" && args.len() == 2 {\n@@ -166,7 +166,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Ranges {\n }\n \n // exclusive range plus one: `x..(y+1)`\n-fn check_exclusive_range_plus_one(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+fn check_exclusive_range_plus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n         if let Some(higher::Range {\n             start,\n@@ -215,7 +215,7 @@ fn check_exclusive_range_plus_one(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n }\n \n // inclusive range minus one: `x..=(y-1)`\n-fn check_inclusive_range_minus_one(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+fn check_inclusive_range_minus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n         if let Some(higher::Range { start, end: Some(end), limits: RangeLimits::Closed }) = higher::range(cx, expr);\n         if let Some(y) = y_minus_one(cx, end);\n@@ -240,8 +240,8 @@ fn check_inclusive_range_minus_one(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n     }\n }\n \n-fn check_reversed_empty_range(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n-    fn inside_indexing_expr(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+fn check_reversed_empty_range(cx: &LateContext<'_>, expr: &Expr<'_>) {\n+    fn inside_indexing_expr(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n         matches!(\n             get_parent_expr(cx, expr),\n             Some(Expr {\n@@ -251,7 +251,7 @@ fn check_reversed_empty_range(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n         )\n     }\n \n-    fn is_for_loop_arg(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+    fn is_for_loop_arg(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n         let mut cur_expr = expr;\n         while let Some(parent_expr) = get_parent_expr(cx, cur_expr) {\n             match higher::for_loop(parent_expr) {\n@@ -320,7 +320,7 @@ fn check_reversed_empty_range(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n     }\n }\n \n-fn y_plus_one<'t>(cx: &LateContext<'_, '_>, expr: &'t Expr<'_>) -> Option<&'t Expr<'t>> {\n+fn y_plus_one<'t>(cx: &LateContext<'_>, expr: &'t Expr<'_>) -> Option<&'t Expr<'t>> {\n     match expr.kind {\n         ExprKind::Binary(\n             Spanned {\n@@ -341,7 +341,7 @@ fn y_plus_one<'t>(cx: &LateContext<'_, '_>, expr: &'t Expr<'_>) -> Option<&'t Ex\n     }\n }\n \n-fn y_minus_one<'t>(cx: &LateContext<'_, '_>, expr: &'t Expr<'_>) -> Option<&'t Expr<'t>> {\n+fn y_minus_one<'t>(cx: &LateContext<'_>, expr: &'t Expr<'_>) -> Option<&'t Expr<'t>> {\n     match expr.kind {\n         ExprKind::Binary(\n             Spanned {"}, {"sha": "fda7480194dce274089f7c765b78eb2e88e0ecac", "filename": "src/tools/clippy/clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -66,11 +66,11 @@ declare_clippy_lint! {\n \n declare_lint_pass!(RedundantClone => [REDUNDANT_CLONE]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantClone {\n+impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n     #[allow(clippy::too_many_lines)]\n     fn check_fn(\n         &mut self,\n-        cx: &LateContext<'a, 'tcx>,\n+        cx: &LateContext<'tcx>,\n         _: FnKind<'tcx>,\n         _: &'tcx FnDecl<'_>,\n         body: &'tcx Body<'_>,\n@@ -273,7 +273,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantClone {\n \n /// If `kind` is `y = func(x: &T)` where `T: !Copy`, returns `(DefId of func, x, T, y)`.\n fn is_call_with_ref_arg<'tcx>(\n-    cx: &LateContext<'_, 'tcx>,\n+    cx: &LateContext<'tcx>,\n     mir: &'tcx mir::Body<'tcx>,\n     kind: &'tcx mir::TerminatorKind<'tcx>,\n ) -> Option<(def_id::DefId, mir::Local, Ty<'tcx>, mir::Local)> {\n@@ -297,7 +297,7 @@ type CannotMoveOut = bool;\n /// Finds the first `to = (&)from`, and returns\n /// ``Some((from, whether `from` cannot be moved out))``.\n fn find_stmt_assigns_to<'tcx>(\n-    cx: &LateContext<'_, 'tcx>,\n+    cx: &LateContext<'tcx>,\n     mir: &mir::Body<'tcx>,\n     to_local: mir::Local,\n     by_ref: bool,\n@@ -331,7 +331,7 @@ fn find_stmt_assigns_to<'tcx>(\n ///\n /// Also reports whether given `place` cannot be moved out.\n fn base_local_and_movability<'tcx>(\n-    cx: &LateContext<'_, 'tcx>,\n+    cx: &LateContext<'tcx>,\n     mir: &mir::Body<'tcx>,\n     place: mir::Place<'tcx>,\n ) -> Option<(mir::Local, CannotMoveOut)> {\n@@ -459,11 +459,11 @@ impl BottomValue for MaybeStorageLive {\n struct PossibleBorrowerVisitor<'a, 'tcx> {\n     possible_borrower: TransitiveRelation<mir::Local>,\n     body: &'a mir::Body<'tcx>,\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n }\n \n impl<'a, 'tcx> PossibleBorrowerVisitor<'a, 'tcx> {\n-    fn new(cx: &'a LateContext<'a, 'tcx>, body: &'a mir::Body<'tcx>) -> Self {\n+    fn new(cx: &'a LateContext<'tcx>, body: &'a mir::Body<'tcx>) -> Self {\n         Self {\n             possible_borrower: TransitiveRelation::default(),\n             cx,\n@@ -473,7 +473,7 @@ impl<'a, 'tcx> PossibleBorrowerVisitor<'a, 'tcx> {\n \n     fn into_map(\n         self,\n-        cx: &LateContext<'a, 'tcx>,\n+        cx: &LateContext<'tcx>,\n         maybe_live: ResultsCursor<'tcx, 'tcx, MaybeStorageLive>,\n     ) -> PossibleBorrowerMap<'a, 'tcx> {\n         let mut map = FxHashMap::default();"}, {"sha": "d8d16efb978a53727fe61bdd746c11d2c5a10708", "filename": "src/tools/clippy/clippy_lints/src/redundant_pattern_matching.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pattern_matching.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -47,8 +47,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(RedundantPatternMatching => [REDUNDANT_PATTERN_MATCHING]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantPatternMatching {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for RedundantPatternMatching {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Match(op, arms, ref match_source) = &expr.kind {\n             match match_source {\n                 MatchSource::Normal => find_sugg_for_match(cx, expr, op, arms),\n@@ -60,14 +60,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantPatternMatching {\n     }\n }\n \n-fn find_sugg_for_if_let<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn find_sugg_for_if_let<'tcx>(\n+    cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'_>,\n     op: &Expr<'_>,\n     arms: &[Arm<'_>],\n     keyword: &'static str,\n ) {\n-    fn find_suggestion(cx: &LateContext<'_, '_>, hir_id: HirId, path: &QPath<'_>) -> Option<&'static str> {\n+    fn find_suggestion(cx: &LateContext<'_>, hir_id: HirId, path: &QPath<'_>) -> Option<&'static str> {\n         if match_qpath(path, &paths::RESULT_OK) && can_suggest(cx, hir_id, sym!(result_type), \"is_ok\") {\n             return Some(\"is_ok()\");\n         }\n@@ -138,7 +138,7 @@ fn find_sugg_for_if_let<'a, 'tcx>(\n     );\n }\n \n-fn find_sugg_for_match<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n+fn find_sugg_for_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n     if arms.len() == 2 {\n         let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n \n@@ -237,7 +237,7 @@ fn find_good_method_for_match<'a>(\n     }\n }\n \n-fn can_suggest(cx: &LateContext<'_, '_>, hir_id: HirId, diag_item: Symbol, name: &str) -> bool {\n+fn can_suggest(cx: &LateContext<'_>, hir_id: HirId, diag_item: Symbol, name: &str) -> bool {\n     if !in_constant(cx, hir_id) {\n         return true;\n     }"}, {"sha": "acd9047ace617459d3c7d5e54265d2b86573d14e", "filename": "src/tools/clippy/clippy_lints/src/redundant_pub_crate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -39,8 +39,8 @@ pub struct RedundantPubCrate {\n \n impl_lint_pass!(RedundantPubCrate => [REDUNDANT_PUB_CRATE]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantPubCrate {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item<'tcx>) {\n+impl<'tcx> LateLintPass<'tcx> for RedundantPubCrate {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n         if let VisibilityKind::Crate { .. } = item.vis.node {\n             if !cx.access_levels.is_exported(item.hir_id) {\n                 if let Some(false) = self.is_exported.last() {\n@@ -70,7 +70,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantPubCrate {\n         }\n     }\n \n-    fn check_item_post(&mut self, _cx: &LateContext<'a, 'tcx>, item: &'tcx Item<'tcx>) {\n+    fn check_item_post(&mut self, _cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n         if let ItemKind::Mod { .. } = item.kind {\n             self.is_exported.pop().expect(\"unbalanced check_item/check_item_post\");\n         }"}, {"sha": "b67abad6ccb8f502e3e89ae6e4163eb43d8ef8ca", "filename": "src/tools/clippy/clippy_lints/src/regex.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -73,12 +73,12 @@ pub struct Regex {\n \n impl_lint_pass!(Regex => [INVALID_REGEX, REGEX_MACRO, TRIVIAL_REGEX]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Regex {\n-    fn check_crate(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx Crate<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for Regex {\n+    fn check_crate(&mut self, _: &LateContext<'tcx>, _: &'tcx Crate<'_>) {\n         self.spans.clear();\n     }\n \n-    fn check_block(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx Block<'_>) {\n+    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx Block<'_>) {\n         if_chain! {\n             if self.last.is_none();\n             if let Some(ref expr) = block.expr;\n@@ -100,13 +100,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Regex {\n         }\n     }\n \n-    fn check_block_post(&mut self, _: &LateContext<'a, 'tcx>, block: &'tcx Block<'_>) {\n+    fn check_block_post(&mut self, _: &LateContext<'tcx>, block: &'tcx Block<'_>) {\n         if self.last.map_or(false, |id| block.hir_id == id) {\n             self.last = None;\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Call(ref fun, ref args) = expr.kind;\n             if let ExprKind::Path(ref qpath) = fun.kind;\n@@ -139,7 +139,7 @@ fn str_span(base: Span, c: regex_syntax::ast::Span, offset: u16) -> Span {\n     Span::new(start, end, base.ctxt())\n }\n \n-fn const_str<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) -> Option<String> {\n+fn const_str<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> Option<String> {\n     constant(cx, cx.tables(), e).and_then(|(c, _)| match c {\n         Constant::Str(s) => Some(s),\n         _ => None,\n@@ -185,7 +185,7 @@ fn is_trivial_regex(s: &regex_syntax::hir::Hir) -> Option<&'static str> {\n     }\n }\n \n-fn check_set<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>, utf8: bool) {\n+fn check_set<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, utf8: bool) {\n     if_chain! {\n         if let ExprKind::AddrOf(BorrowKind::Ref, _, ref expr) = expr.kind;\n         if let ExprKind::Array(exprs) = expr.kind;\n@@ -197,7 +197,7 @@ fn check_set<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>, utf8: b\n     }\n }\n \n-fn check_regex<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>, utf8: bool) {\n+fn check_regex<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, utf8: bool) {\n     let mut parser = regex_syntax::ParserBuilder::new()\n         .unicode(utf8)\n         .allow_invalid_utf8(!utf8)"}, {"sha": "339a7cf3bf5d204db649312fe704d654f8959c1a", "filename": "src/tools/clippy/clippy_lints/src/serde_api.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fserde_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fserde_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fserde_api.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -20,8 +20,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(SerdeAPI => [SERDE_API_MISUSE]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SerdeAPI {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for SerdeAPI {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if let ItemKind::Impl {\n             of_trait: Some(ref trait_ref),\n             items,"}, {"sha": "7da47ee4ff94b892c3ef369ccbfb0f8c028f6b05", "filename": "src/tools/clippy/clippy_lints/src/shadow.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -96,10 +96,10 @@ declare_clippy_lint! {\n \n declare_lint_pass!(Shadow => [SHADOW_SAME, SHADOW_REUSE, SHADOW_UNRELATED]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Shadow {\n+impl<'tcx> LateLintPass<'tcx> for Shadow {\n     fn check_fn(\n         &mut self,\n-        cx: &LateContext<'a, 'tcx>,\n+        cx: &LateContext<'tcx>,\n         _: FnKind<'tcx>,\n         decl: &'tcx FnDecl<'_>,\n         body: &'tcx Body<'_>,\n@@ -113,7 +113,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Shadow {\n     }\n }\n \n-fn check_fn<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl<'_>, body: &'tcx Body<'_>) {\n+fn check_fn<'tcx>(cx: &LateContext<'tcx>, decl: &'tcx FnDecl<'_>, body: &'tcx Body<'_>) {\n     let mut bindings = Vec::with_capacity(decl.inputs.len());\n     for arg in iter_input_pats(decl, body) {\n         if let PatKind::Binding(.., ident, _) = arg.pat.kind {\n@@ -123,7 +123,7 @@ fn check_fn<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl<'_>, body:\n     check_expr(cx, &body.value, &mut bindings);\n }\n \n-fn check_block<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, block: &'tcx Block<'_>, bindings: &mut Vec<(Name, Span)>) {\n+fn check_block<'tcx>(cx: &LateContext<'tcx>, block: &'tcx Block<'_>, bindings: &mut Vec<(Name, Span)>) {\n     let len = bindings.len();\n     for stmt in block.stmts {\n         match stmt.kind {\n@@ -138,7 +138,7 @@ fn check_block<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, block: &'tcx Block<'_>, bin\n     bindings.truncate(len);\n }\n \n-fn check_local<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, local: &'tcx Local<'_>, bindings: &mut Vec<(Name, Span)>) {\n+fn check_local<'tcx>(cx: &LateContext<'tcx>, local: &'tcx Local<'_>, bindings: &mut Vec<(Name, Span)>) {\n     if in_external_macro(cx.sess(), local.span) {\n         return;\n     }\n@@ -163,7 +163,7 @@ fn check_local<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, local: &'tcx Local<'_>, bin\n     }\n }\n \n-fn is_binding(cx: &LateContext<'_, '_>, pat_id: HirId) -> bool {\n+fn is_binding(cx: &LateContext<'_>, pat_id: HirId) -> bool {\n     let var_ty = cx.tables().node_type_opt(pat_id);\n     if let Some(var_ty) = var_ty {\n         match var_ty.kind {\n@@ -175,8 +175,8 @@ fn is_binding(cx: &LateContext<'_, '_>, pat_id: HirId) -> bool {\n     }\n }\n \n-fn check_pat<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn check_pat<'tcx>(\n+    cx: &LateContext<'tcx>,\n     pat: &'tcx Pat<'_>,\n     init: Option<&'tcx Expr<'_>>,\n     span: Span,\n@@ -259,8 +259,8 @@ fn check_pat<'a, 'tcx>(\n     }\n }\n \n-fn lint_shadow<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn lint_shadow<'tcx>(\n+    cx: &LateContext<'tcx>,\n     name: Name,\n     span: Span,\n     pattern_span: Span,\n@@ -326,7 +326,7 @@ fn lint_shadow<'a, 'tcx>(\n     }\n }\n \n-fn check_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>, bindings: &mut Vec<(Name, Span)>) {\n+fn check_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, bindings: &mut Vec<(Name, Span)>) {\n     if in_external_macro(cx.sess(), expr.span) {\n         return;\n     }\n@@ -362,7 +362,7 @@ fn check_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>, bindin\n     }\n }\n \n-fn check_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: &'tcx Ty<'_>, bindings: &mut Vec<(Name, Span)>) {\n+fn check_ty<'tcx>(cx: &LateContext<'tcx>, ty: &'tcx Ty<'_>, bindings: &mut Vec<(Name, Span)>) {\n     match ty.kind {\n         TyKind::Slice(ref sty) => check_ty(cx, sty, bindings),\n         TyKind::Array(ref fty, ref anon_const) => {"}, {"sha": "96f6881556cf380682e482615632a82aebc16243", "filename": "src/tools/clippy/clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -65,8 +65,8 @@ enum InitializationType<'tcx> {\n     Resize(&'tcx Expr<'tcx>),\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SlowVectorInit {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for SlowVectorInit {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // Matches initialization on reassignements. For example: `vec = Vec::with_capacity(100)`\n         if_chain! {\n             if let ExprKind::Assign(ref left, ref right, _) = expr.kind;\n@@ -90,7 +90,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SlowVectorInit {\n         }\n     }\n \n-    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt<'_>) {\n+    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         // Matches statements which initializes vectors. For example: `let mut vec = Vec::with_capacity(10)`\n         if_chain! {\n             if let StmtKind::Local(ref local) = stmt.kind;\n@@ -130,7 +130,7 @@ impl SlowVectorInit {\n     }\n \n     /// Search initialization for the given vector\n-    fn search_initialization<'tcx>(cx: &LateContext<'_, 'tcx>, vec_alloc: VecAllocation<'tcx>, parent_node: HirId) {\n+    fn search_initialization<'tcx>(cx: &LateContext<'tcx>, vec_alloc: VecAllocation<'tcx>, parent_node: HirId) {\n         let enclosing_body = get_enclosing_block(cx, parent_node);\n \n         if enclosing_body.is_none() {\n@@ -152,7 +152,7 @@ impl SlowVectorInit {\n     }\n \n     fn lint_initialization<'tcx>(\n-        cx: &LateContext<'_, 'tcx>,\n+        cx: &LateContext<'tcx>,\n         initialization: &InitializationType<'tcx>,\n         vec_alloc: &VecAllocation<'_>,\n     ) {\n@@ -168,7 +168,7 @@ impl SlowVectorInit {\n     }\n \n     fn emit_lint<'tcx>(\n-        cx: &LateContext<'_, 'tcx>,\n+        cx: &LateContext<'tcx>,\n         slow_fill: &Expr<'_>,\n         vec_alloc: &VecAllocation<'_>,\n         msg: &str,\n@@ -190,7 +190,7 @@ impl SlowVectorInit {\n /// `VectorInitializationVisitor` searches for unsafe or slow vector initializations for the given\n /// vector.\n struct VectorInitializationVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n \n     /// Contains the information.\n     vec_alloc: VecAllocation<'tcx>,"}, {"sha": "89aa6a4edd62d22880f265ca2d3a9f43110778b8", "filename": "src/tools/clippy/clippy_lints/src/strings.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -86,8 +86,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(StringAdd => [STRING_ADD, STRING_ADD_ASSIGN]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringAdd {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for StringAdd {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if in_external_macro(cx.sess(), e.span) {\n             return;\n         }\n@@ -133,11 +133,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringAdd {\n     }\n }\n \n-fn is_string(cx: &LateContext<'_, '_>, e: &Expr<'_>) -> bool {\n+fn is_string(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n     is_type_diagnostic_item(cx, walk_ptrs_ty(cx.tables().expr_ty(e)), sym!(string_type))\n }\n \n-fn is_add(cx: &LateContext<'_, '_>, src: &Expr<'_>, target: &Expr<'_>) -> bool {\n+fn is_add(cx: &LateContext<'_>, src: &Expr<'_>, target: &Expr<'_>) -> bool {\n     match src.kind {\n         ExprKind::Binary(\n             Spanned {\n@@ -158,8 +158,8 @@ const MAX_LENGTH_BYTE_STRING_LIT: usize = 32;\n \n declare_lint_pass!(StringLitAsBytes => [STRING_LIT_AS_BYTES]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         use crate::utils::{snippet, snippet_with_applicability};\n         use rustc_ast::ast::LitKind;\n "}, {"sha": "6d1d083fa8d40a145f45ecaabc13c8fc41f4c7b2", "filename": "src/tools/clippy/clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -52,8 +52,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(SuspiciousImpl => [SUSPICIOUS_ARITHMETIC_IMPL, SUSPICIOUS_OP_ASSIGN_IMPL]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for SuspiciousImpl {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if let hir::ExprKind::Binary(binop, _, _) | hir::ExprKind::AssignOp(binop, ..) = expr.kind {\n             match binop.node {\n                 hir::BinOpKind::Eq\n@@ -147,7 +147,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n }\n \n fn check_binop(\n-    cx: &LateContext<'_, '_>,\n+    cx: &LateContext<'_>,\n     expr: &hir::Expr<'_>,\n     binop: hir::BinOpKind,\n     traits: &[&'static str],"}, {"sha": "eb7d35839206ba9a0494bcc115e595045a7f2039", "filename": "src/tools/clippy/clippy_lints/src/swap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -65,15 +65,15 @@ declare_clippy_lint! {\n \n declare_lint_pass!(Swap => [MANUAL_SWAP, ALMOST_SWAPPED]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Swap {\n-    fn check_block(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx Block<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for Swap {\n+    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx Block<'_>) {\n         check_manual_swap(cx, block);\n         check_suspicious_swap(cx, block);\n     }\n }\n \n /// Implementation of the `MANUAL_SWAP` lint.\n-fn check_manual_swap(cx: &LateContext<'_, '_>, block: &Block<'_>) {\n+fn check_manual_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n     for w in block.stmts.windows(3) {\n         if_chain! {\n             // let t = foo();\n@@ -190,7 +190,7 @@ enum Slice<'a> {\n }\n \n /// Checks if both expressions are index operations into \"slice-like\" types.\n-fn check_for_slice<'a>(cx: &LateContext<'_, '_>, lhs1: &'a Expr<'_>, lhs2: &'a Expr<'_>) -> Slice<'a> {\n+fn check_for_slice<'a>(cx: &LateContext<'_>, lhs1: &'a Expr<'_>, lhs2: &'a Expr<'_>) -> Slice<'a> {\n     if let ExprKind::Index(ref lhs1, ref idx1) = lhs1.kind {\n         if let ExprKind::Index(ref lhs2, ref idx2) = lhs2.kind {\n             if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, lhs2) {\n@@ -213,7 +213,7 @@ fn check_for_slice<'a>(cx: &LateContext<'_, '_>, lhs1: &'a Expr<'_>, lhs2: &'a E\n }\n \n /// Implementation of the `ALMOST_SWAPPED` lint.\n-fn check_suspicious_swap(cx: &LateContext<'_, '_>, block: &Block<'_>) {\n+fn check_suspicious_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n     for w in block.stmts.windows(2) {\n         if_chain! {\n             if let StmtKind::Semi(ref first) = w[0].kind;"}, {"sha": "509bbfd27c1a5094184e4bbf775e631d89e445d2", "filename": "src/tools/clippy/clippy_lints/src/temporary_assignment.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftemporary_assignment.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -22,7 +22,7 @@ declare_clippy_lint! {\n     \"assignments to temporaries\"\n }\n \n-fn is_temporary(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+fn is_temporary(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     match &expr.kind {\n         ExprKind::Struct(..) | ExprKind::Tup(..) => true,\n         ExprKind::Path(qpath) => {\n@@ -38,8 +38,8 @@ fn is_temporary(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n \n declare_lint_pass!(TemporaryAssignment => [TEMPORARY_ASSIGNMENT]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TemporaryAssignment {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for TemporaryAssignment {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Assign(target, ..) = &expr.kind {\n             let mut base = target;\n             while let ExprKind::Field(f, _) | ExprKind::Index(f, _) = &base.kind {"}, {"sha": "4157103a574e12be1e2bddc64de6ee1dcd97d8db", "filename": "src/tools/clippy/clippy_lints/src/to_digit_is_some.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -31,8 +31,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(ToDigitIsSome => [TO_DIGIT_IS_SOME]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ToDigitIsSome {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for ToDigitIsSome {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n             if let hir::ExprKind::MethodCall(is_some_path, _, is_some_args, _) = &expr.kind;\n             if is_some_path.ident.name.as_str() == \"is_some\";"}, {"sha": "9eb2079c3ca2dffbec32bb6adb90ac89fe7bdf40", "filename": "src/tools/clippy/clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -31,8 +31,8 @@ declare_clippy_lint! {\n \n impl_lint_pass!(TraitBounds => [TYPE_REPETITION_IN_BOUNDS]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TraitBounds {\n-    fn check_generics(&mut self, cx: &LateContext<'a, 'tcx>, gen: &'tcx Generics<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for TraitBounds {\n+    fn check_generics(&mut self, cx: &LateContext<'tcx>, gen: &'tcx Generics<'_>) {\n         if in_macro(gen.span) {\n             return;\n         }"}, {"sha": "5f76d5c46efba4a061945801a415bb5d86fdbb30", "filename": "src/tools/clippy/clippy_lints/src/transmute.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -293,9 +293,9 @@ static COLLECTIONS: &[&[&str]] = &[\n     &paths::HASHSET,\n     &paths::HASHMAP,\n ];\n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n+impl<'tcx> LateLintPass<'tcx> for Transmute {\n     #[allow(clippy::similar_names, clippy::too_many_lines)]\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Call(ref path_expr, ref args) = e.kind;\n             if let ExprKind::Path(ref qpath) = path_expr.kind;\n@@ -613,7 +613,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n /// the type's `ToString` implementation. In weird cases it could lead to types\n /// with invalid `'_`\n /// lifetime, but it should be rare.\n-fn get_type_snippet(cx: &LateContext<'_, '_>, path: &QPath<'_>, to_ref_ty: Ty<'_>) -> String {\n+fn get_type_snippet(cx: &LateContext<'_>, path: &QPath<'_>, to_ref_ty: Ty<'_>) -> String {\n     let seg = last_path_segment(path);\n     if_chain! {\n         if let Some(ref params) = seg.args;\n@@ -633,7 +633,7 @@ fn get_type_snippet(cx: &LateContext<'_, '_>, path: &QPath<'_>, to_ref_ty: Ty<'_\n \n // check if the component types of the transmuted collection and the result have different ABI,\n // size or alignment\n-fn is_layout_incompatible<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, from: Ty<'tcx>, to: Ty<'tcx>) -> bool {\n+fn is_layout_incompatible<'tcx>(cx: &LateContext<'tcx>, from: Ty<'tcx>, to: Ty<'tcx>) -> bool {\n     let empty_param_env = ty::ParamEnv::empty();\n     // check if `from` and `to` are normalizable to avoid ICE (#4968)\n     if !(is_normalizable(cx, empty_param_env, from) && is_normalizable(cx, empty_param_env, to)) {"}, {"sha": "2f03c6db42d99379eb3c688cd3617de861406fd9", "filename": "src/tools/clippy/clippy_lints/src/transmuting_null.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmuting_null.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -29,8 +29,8 @@ declare_lint_pass!(TransmutingNull => [TRANSMUTING_NULL]);\n \n const LINT_MSG: &str = \"transmuting a known null pointer into a reference.\";\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TransmutingNull {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for TransmutingNull {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }"}, {"sha": "6a2b05e3e6df71bc605a573e64fd168906de5d5d", "filename": "src/tools/clippy/clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -73,7 +73,7 @@ impl<'tcx> TriviallyCopyPassByRef {\n         Self { limit }\n     }\n \n-    fn check_poly_fn(&mut self, cx: &LateContext<'_, 'tcx>, hir_id: HirId, decl: &FnDecl<'_>, span: Option<Span>) {\n+    fn check_poly_fn(&mut self, cx: &LateContext<'tcx>, hir_id: HirId, decl: &FnDecl<'_>, span: Option<Span>) {\n         let fn_def_id = cx.tcx.hir().local_def_id(hir_id);\n \n         let fn_sig = cx.tcx.fn_sig(fn_def_id);\n@@ -125,8 +125,8 @@ impl<'tcx> TriviallyCopyPassByRef {\n \n impl_lint_pass!(TriviallyCopyPassByRef => [TRIVIALLY_COPY_PASS_BY_REF]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TriviallyCopyPassByRef {\n-    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for TriviallyCopyPassByRef {\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n         if item.span.from_expansion() {\n             return;\n         }\n@@ -138,7 +138,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TriviallyCopyPassByRef {\n \n     fn check_fn(\n         &mut self,\n-        cx: &LateContext<'a, 'tcx>,\n+        cx: &LateContext<'tcx>,\n         kind: FnKind<'tcx>,\n         decl: &'tcx FnDecl<'_>,\n         _body: &'tcx Body<'_>,"}, {"sha": "208d248faa57d0fec568f87ad6e6f6e87305ed34", "filename": "src/tools/clippy/clippy_lints/src/try_err.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -43,8 +43,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(TryErr => [TRY_ERR]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TryErr {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for TryErr {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // Looks for a structure like this:\n         // match ::std::ops::Try::into_result(Err(5)) {\n         //     ::std::result::Result::Err(err) =>\n@@ -97,7 +97,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TryErr {\n // In order to determine whether to suggest `.into()` or not, we need to find the error type the\n // function returns. To do that, we look for the From::from call (see tree above), and capture\n // its output type.\n-fn find_err_return_type<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx ExprKind<'_>) -> Option<Ty<'tcx>> {\n+fn find_err_return_type<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx ExprKind<'_>) -> Option<Ty<'tcx>> {\n     if let ExprKind::Match(_, ref arms, MatchSource::TryDesugar) = expr {\n         arms.iter().find_map(|ty| find_err_return_type_arm(cx, ty))\n     } else {\n@@ -106,7 +106,7 @@ fn find_err_return_type<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx ExprKi\n }\n \n // Check for From::from in one of the match arms.\n-fn find_err_return_type_arm<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arm: &'tcx Arm<'_>) -> Option<Ty<'tcx>> {\n+fn find_err_return_type_arm<'tcx>(cx: &LateContext<'tcx>, arm: &'tcx Arm<'_>) -> Option<Ty<'tcx>> {\n     if_chain! {\n         if let ExprKind::Ret(Some(ref err_ret)) = arm.body.kind;\n         if let ExprKind::Call(ref from_error_path, ref from_error_args) = err_ret.kind;"}, {"sha": "b1345f0de5e4be74ad5f11ae97eff3bc4d8dec4b", "filename": "src/tools/clippy/clippy_lints/src/types.rs", "status": "modified", "additions": 64, "deletions": 72, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -218,16 +218,8 @@ pub struct Types {\n \n impl_lint_pass!(Types => [BOX_VEC, VEC_BOX, OPTION_OPTION, LINKEDLIST, BORROWED_BOX, REDUNDANT_ALLOCATION]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Types {\n-    fn check_fn(\n-        &mut self,\n-        cx: &LateContext<'_, '_>,\n-        _: FnKind<'_>,\n-        decl: &FnDecl<'_>,\n-        _: &Body<'_>,\n-        _: Span,\n-        id: HirId,\n-    ) {\n+impl<'tcx> LateLintPass<'tcx> for Types {\n+    fn check_fn(&mut self, cx: &LateContext<'_>, _: FnKind<'_>, decl: &FnDecl<'_>, _: &Body<'_>, _: Span, id: HirId) {\n         // Skip trait implementations; see issue #605.\n         if let Some(hir::Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_item(id)) {\n             if let ItemKind::Impl { of_trait: Some(_), .. } = item.kind {\n@@ -238,27 +230,27 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Types {\n         self.check_fn_decl(cx, decl);\n     }\n \n-    fn check_struct_field(&mut self, cx: &LateContext<'_, '_>, field: &hir::StructField<'_>) {\n+    fn check_struct_field(&mut self, cx: &LateContext<'_>, field: &hir::StructField<'_>) {\n         self.check_ty(cx, &field.ty, false);\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext<'_, '_>, item: &TraitItem<'_>) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'_>, item: &TraitItem<'_>) {\n         match item.kind {\n             TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => self.check_ty(cx, ty, false),\n             TraitItemKind::Fn(ref sig, _) => self.check_fn_decl(cx, &sig.decl),\n             _ => (),\n         }\n     }\n \n-    fn check_local(&mut self, cx: &LateContext<'_, '_>, local: &Local<'_>) {\n+    fn check_local(&mut self, cx: &LateContext<'_>, local: &Local<'_>) {\n         if let Some(ref ty) = local.ty {\n             self.check_ty(cx, ty, true);\n         }\n     }\n }\n \n /// Checks if `qpath` has last segment with type parameter matching `path`\n-fn match_type_parameter(cx: &LateContext<'_, '_>, qpath: &QPath<'_>, path: &[&str]) -> Option<Span> {\n+fn match_type_parameter(cx: &LateContext<'_>, qpath: &QPath<'_>, path: &[&str]) -> Option<Span> {\n     let last = last_path_segment(qpath);\n     if_chain! {\n         if let Some(ref params) = last.args;\n@@ -277,7 +269,7 @@ fn match_type_parameter(cx: &LateContext<'_, '_>, qpath: &QPath<'_>, path: &[&st\n     None\n }\n \n-fn match_borrows_parameter(_cx: &LateContext<'_, '_>, qpath: &QPath<'_>) -> Option<Span> {\n+fn match_borrows_parameter(_cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<Span> {\n     let last = last_path_segment(qpath);\n     if_chain! {\n         if let Some(ref params) = last.args;\n@@ -299,7 +291,7 @@ impl Types {\n         Self { vec_box_size_threshold }\n     }\n \n-    fn check_fn_decl(&mut self, cx: &LateContext<'_, '_>, decl: &FnDecl<'_>) {\n+    fn check_fn_decl(&mut self, cx: &LateContext<'_>, decl: &FnDecl<'_>) {\n         for input in decl.inputs {\n             self.check_ty(cx, input, false);\n         }\n@@ -315,7 +307,7 @@ impl Types {\n     /// The parameter `is_local` distinguishes the context of the type; types from\n     /// local bindings should only be checked for the `BORROWED_BOX` lint.\n     #[allow(clippy::too_many_lines)]\n-    fn check_ty(&mut self, cx: &LateContext<'_, '_>, hir_ty: &hir::Ty<'_>, is_local: bool) {\n+    fn check_ty(&mut self, cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, is_local: bool) {\n         if hir_ty.span.from_expansion() {\n             return;\n         }\n@@ -501,7 +493,7 @@ impl Types {\n \n     fn check_ty_rptr(\n         &mut self,\n-        cx: &LateContext<'_, '_>,\n+        cx: &LateContext<'_>,\n         hir_ty: &hir::Ty<'_>,\n         is_local: bool,\n         lt: &Lifetime,\n@@ -600,8 +592,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(LetUnitValue => [LET_UNIT_VALUE]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetUnitValue {\n-    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for LetUnitValue {\n+    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         if let StmtKind::Local(ref local) = stmt.kind {\n             if is_unit(cx.tables().pat_ty(&local.pat)) {\n                 if in_external_macro(cx.sess(), stmt.span) || local.pat.span.from_expansion() {\n@@ -681,8 +673,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(UnitCmp => [UNIT_CMP]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitCmp {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'tcx>) {\n+impl<'tcx> LateLintPass<'tcx> for UnitCmp {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         if expr.span.from_expansion() {\n             if let Some(callee) = expr.span.source_callee() {\n                 if let ExpnKind::Macro(MacroKind::Bang, symbol) = callee.kind {\n@@ -754,8 +746,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(UnitArg => [UNIT_ARG]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitArg {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for UnitArg {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if expr.span.from_expansion() {\n             return;\n         }\n@@ -802,7 +794,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitArg {\n     }\n }\n \n-fn lint_unit_args(cx: &LateContext<'_, '_>, expr: &Expr<'_>, args_to_recover: &[&Expr<'_>]) {\n+fn lint_unit_args(cx: &LateContext<'_>, expr: &Expr<'_>, args_to_recover: &[&Expr<'_>]) {\n     let mut applicability = Applicability::MachineApplicable;\n     let (singular, plural) = if args_to_recover.len() > 1 {\n         (\"\", \"s\")\n@@ -1168,7 +1160,7 @@ fn is_isize_or_usize(typ: Ty<'_>) -> bool {\n     }\n }\n \n-fn span_precision_loss_lint(cx: &LateContext<'_, '_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to_f64: bool) {\n+fn span_precision_loss_lint(cx: &LateContext<'_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to_f64: bool) {\n     let mantissa_nbits = if cast_to_f64 { 52 } else { 23 };\n     let arch_dependent = is_isize_or_usize(cast_from) && cast_to_f64;\n     let arch_dependent_str = \"on targets with 64-bit wide pointers \";\n@@ -1204,7 +1196,7 @@ fn should_strip_parens(op: &Expr<'_>, snip: &str) -> bool {\n     false\n }\n \n-fn span_lossless_lint(cx: &LateContext<'_, '_>, expr: &Expr<'_>, op: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+fn span_lossless_lint(cx: &LateContext<'_>, expr: &Expr<'_>, op: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n     // Do not suggest using From in consts/statics until it is valid to do so (see #2267).\n     if in_constant(cx, expr.hir_id) {\n         return;\n@@ -1244,7 +1236,7 @@ enum ArchSuffix {\n     None,\n }\n \n-fn check_loss_of_sign(cx: &LateContext<'_, '_>, expr: &Expr<'_>, op: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+fn check_loss_of_sign(cx: &LateContext<'_>, expr: &Expr<'_>, op: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n     if !cast_from.is_signed() || cast_to.is_signed() {\n         return;\n     }\n@@ -1291,7 +1283,7 @@ fn check_loss_of_sign(cx: &LateContext<'_, '_>, expr: &Expr<'_>, op: &Expr<'_>,\n     );\n }\n \n-fn check_truncation_and_wrapping(cx: &LateContext<'_, '_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+fn check_truncation_and_wrapping(cx: &LateContext<'_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n     let arch_64_suffix = \" on targets with 64-bit wide pointers\";\n     let arch_32_suffix = \" on targets with 32-bit wide pointers\";\n     let cast_unsigned_to_signed = !cast_from.is_signed() && cast_to.is_signed();\n@@ -1362,7 +1354,7 @@ fn check_truncation_and_wrapping(cx: &LateContext<'_, '_>, expr: &Expr<'_>, cast\n     }\n }\n \n-fn check_lossless(cx: &LateContext<'_, '_>, expr: &Expr<'_>, op: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+fn check_lossless(cx: &LateContext<'_>, expr: &Expr<'_>, op: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n     let cast_signed_to_unsigned = cast_from.is_signed() && !cast_to.is_signed();\n     let from_nbits = int_ty_to_nbits(cast_from, cx.tcx);\n     let to_nbits = int_ty_to_nbits(cast_to, cx.tcx);\n@@ -1386,7 +1378,7 @@ declare_lint_pass!(Casts => [\n \n // Check if the given type is either `core::ffi::c_void` or\n // one of the platform specific `libc::<platform>::c_void` of libc.\n-fn is_c_void(cx: &LateContext<'_, '_>, ty: Ty<'_>) -> bool {\n+fn is_c_void(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n     if let ty::Adt(adt, _) = ty.kind {\n         let names = cx.get_def_path(adt.did);\n \n@@ -1410,8 +1402,8 @@ fn fp_ty_mantissa_nbits(typ: Ty<'_>) -> u32 {\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Casts {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for Casts {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if expr.span.from_expansion() {\n             return;\n         }\n@@ -1467,7 +1459,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Casts {\n }\n \n fn lint_numeric_casts<'tcx>(\n-    cx: &LateContext<'_, 'tcx>,\n+    cx: &LateContext<'tcx>,\n     expr: &Expr<'tcx>,\n     cast_expr: &Expr<'_>,\n     cast_from: Ty<'tcx>,\n@@ -1528,7 +1520,7 @@ fn lint_numeric_casts<'tcx>(\n     }\n }\n \n-fn lint_cast_ptr_alignment<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &Expr<'_>, cast_from: Ty<'tcx>, cast_to: Ty<'tcx>) {\n+fn lint_cast_ptr_alignment<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, cast_from: Ty<'tcx>, cast_to: Ty<'tcx>) {\n     if_chain! {\n         if let ty::RawPtr(from_ptr_ty) = &cast_from.kind;\n         if let ty::RawPtr(to_ptr_ty) = &cast_to.kind;\n@@ -1557,7 +1549,7 @@ fn lint_cast_ptr_alignment<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &Expr<'_>, ca\n }\n \n fn lint_fn_to_numeric_cast(\n-    cx: &LateContext<'_, '_>,\n+    cx: &LateContext<'_>,\n     expr: &Expr<'_>,\n     cast_expr: &Expr<'_>,\n     cast_from: Ty<'_>,\n@@ -1637,10 +1629,10 @@ impl TypeComplexity {\n \n impl_lint_pass!(TypeComplexity => [TYPE_COMPLEXITY]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeComplexity {\n+impl<'tcx> LateLintPass<'tcx> for TypeComplexity {\n     fn check_fn(\n         &mut self,\n-        cx: &LateContext<'a, 'tcx>,\n+        cx: &LateContext<'tcx>,\n         _: FnKind<'tcx>,\n         decl: &'tcx FnDecl<'_>,\n         _: &'tcx Body<'_>,\n@@ -1650,20 +1642,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeComplexity {\n         self.check_fndecl(cx, decl);\n     }\n \n-    fn check_struct_field(&mut self, cx: &LateContext<'a, 'tcx>, field: &'tcx hir::StructField<'_>) {\n+    fn check_struct_field(&mut self, cx: &LateContext<'tcx>, field: &'tcx hir::StructField<'_>) {\n         // enum variants are also struct fields now\n         self.check_type(cx, &field.ty);\n     }\n \n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item<'_>) {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         match item.kind {\n             ItemKind::Static(ref ty, _, _) | ItemKind::Const(ref ty, _) => self.check_type(cx, ty),\n             // functions, enums, structs, impls and traits are covered\n             _ => (),\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem<'_>) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'_>) {\n         match item.kind {\n             TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => self.check_type(cx, ty),\n             TraitItemKind::Fn(FnSig { ref decl, .. }, TraitFn::Required(_)) => self.check_fndecl(cx, decl),\n@@ -1672,23 +1664,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeComplexity {\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem<'_>) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n         match item.kind {\n             ImplItemKind::Const(ref ty, _) | ImplItemKind::TyAlias(ref ty) => self.check_type(cx, ty),\n             // methods are covered by check_fn\n             _ => (),\n         }\n     }\n \n-    fn check_local(&mut self, cx: &LateContext<'a, 'tcx>, local: &'tcx Local<'_>) {\n+    fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'_>) {\n         if let Some(ref ty) = local.ty {\n             self.check_type(cx, ty);\n         }\n     }\n }\n \n-impl<'a, 'tcx> TypeComplexity {\n-    fn check_fndecl(&self, cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl<'_>) {\n+impl<'tcx> TypeComplexity {\n+    fn check_fndecl(&self, cx: &LateContext<'tcx>, decl: &'tcx FnDecl<'_>) {\n         for arg in decl.inputs {\n             self.check_type(cx, arg);\n         }\n@@ -1697,7 +1689,7 @@ impl<'a, 'tcx> TypeComplexity {\n         }\n     }\n \n-    fn check_type(&self, cx: &LateContext<'_, '_>, ty: &hir::Ty<'_>) {\n+    fn check_type(&self, cx: &LateContext<'_>, ty: &hir::Ty<'_>) {\n         if ty.span.from_expansion() {\n             return;\n         }\n@@ -1797,8 +1789,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(CharLitAsU8 => [CHAR_LIT_AS_U8]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CharLitAsU8 {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for CharLitAsU8 {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if !expr.span.from_expansion();\n             if let ExprKind::Cast(e, _) = &expr.kind;\n@@ -1878,7 +1870,7 @@ enum AbsurdComparisonResult {\n     InequalityImpossible,\n }\n \n-fn is_cast_between_fixed_and_target<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+fn is_cast_between_fixed_and_target<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n     if let ExprKind::Cast(ref cast_exp, _) = expr.kind {\n         let precast_ty = cx.tables().expr_ty(cast_exp);\n         let cast_ty = cx.tables().expr_ty(expr);\n@@ -1889,8 +1881,8 @@ fn is_cast_between_fixed_and_target<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr:\n     false\n }\n \n-fn detect_absurd_comparison<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn detect_absurd_comparison<'tcx>(\n+    cx: &LateContext<'tcx>,\n     op: BinOpKind,\n     lhs: &'tcx Expr<'_>,\n     rhs: &'tcx Expr<'_>,\n@@ -1936,7 +1928,7 @@ fn detect_absurd_comparison<'a, 'tcx>(\n     })\n }\n \n-fn detect_extreme_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) -> Option<ExtremeExpr<'tcx>> {\n+fn detect_extreme_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<ExtremeExpr<'tcx>> {\n     use crate::types::ExtremeType::{Maximum, Minimum};\n \n     let ty = cx.tables().expr_ty(expr);\n@@ -1960,8 +1952,8 @@ fn detect_extreme_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_\n     Some(ExtremeExpr { which, expr })\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AbsurdExtremeComparisons {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for AbsurdExtremeComparisons {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         use crate::types::AbsurdComparisonResult::{AlwaysFalse, AlwaysTrue, InequalityImpossible};\n         use crate::types::ExtremeType::{Maximum, Minimum};\n \n@@ -2069,7 +2061,7 @@ impl Ord for FullInt {\n     }\n }\n \n-fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr<'_>) -> Option<(FullInt, FullInt)> {\n+fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_>, expr: &'a Expr<'_>) -> Option<(FullInt, FullInt)> {\n     if let ExprKind::Cast(ref cast_exp, _) = expr.kind {\n         let pre_cast_ty = cx.tables().expr_ty(cast_exp);\n         let cast_ty = cx.tables().expr_ty(expr);\n@@ -2101,7 +2093,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr<'_>)\n     }\n }\n \n-fn node_as_const_fullint<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) -> Option<FullInt> {\n+fn node_as_const_fullint<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<FullInt> {\n     let val = constant(cx, cx.tables(), expr)?.0;\n     if let Constant::Int(const_int) = val {\n         match cx.tables().expr_ty(expr).kind {\n@@ -2114,7 +2106,7 @@ fn node_as_const_fullint<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<\n     }\n }\n \n-fn err_upcast_comparison(cx: &LateContext<'_, '_>, span: Span, expr: &Expr<'_>, always: bool) {\n+fn err_upcast_comparison(cx: &LateContext<'_>, span: Span, expr: &Expr<'_>, always: bool) {\n     if let ExprKind::Cast(ref cast_val, _) = expr.kind {\n         span_lint(\n             cx,\n@@ -2129,8 +2121,8 @@ fn err_upcast_comparison(cx: &LateContext<'_, '_>, span: Span, expr: &Expr<'_>,\n     }\n }\n \n-fn upcast_comparison_bounds_err<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn upcast_comparison_bounds_err<'tcx>(\n+    cx: &LateContext<'tcx>,\n     span: Span,\n     rel: comparisons::Rel,\n     lhs_bounds: Option<(FullInt, FullInt)>,\n@@ -2187,8 +2179,8 @@ fn upcast_comparison_bounds_err<'a, 'tcx>(\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidUpcastComparisons {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for InvalidUpcastComparisons {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Binary(ref cmp, ref lhs, ref rhs) = expr.kind {\n             let normalized = comparisons::normalize_comparison(cmp.node, lhs, rhs);\n             let (rel, normalized_lhs, normalized_rhs) = if let Some(val) = normalized {\n@@ -2243,13 +2235,13 @@ declare_clippy_lint! {\n \n declare_lint_pass!(ImplicitHasher => [IMPLICIT_HASHER]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitHasher {\n+impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n     #[allow(clippy::cast_possible_truncation, clippy::too_many_lines)]\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item<'_>) {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         use rustc_span::BytePos;\n \n-        fn suggestion<'a, 'tcx>(\n-            cx: &LateContext<'a, 'tcx>,\n+        fn suggestion<'tcx>(\n+            cx: &LateContext<'tcx>,\n             diag: &mut DiagnosticBuilder<'_>,\n             generics_span: Span,\n             generics_suggestion_span: Span,\n@@ -2393,7 +2385,7 @@ enum ImplicitHasherType<'tcx> {\n \n impl<'tcx> ImplicitHasherType<'tcx> {\n     /// Checks that `ty` is a target type without a `BuildHasher`.\n-    fn new<'a>(cx: &LateContext<'a, 'tcx>, hir_ty: &hir::Ty<'_>) -> Option<Self> {\n+    fn new(cx: &LateContext<'tcx>, hir_ty: &hir::Ty<'_>) -> Option<Self> {\n         if let TyKind::Path(QPath::Resolved(None, ref path)) = hir_ty.kind {\n             let params: Vec<_> = path\n                 .segments\n@@ -2461,12 +2453,12 @@ impl<'tcx> ImplicitHasherType<'tcx> {\n }\n \n struct ImplicitHasherTypeVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     found: Vec<ImplicitHasherType<'tcx>>,\n }\n \n impl<'a, 'tcx> ImplicitHasherTypeVisitor<'a, 'tcx> {\n-    fn new(cx: &'a LateContext<'a, 'tcx>) -> Self {\n+    fn new(cx: &'a LateContext<'tcx>) -> Self {\n         Self { cx, found: vec![] }\n     }\n }\n@@ -2489,14 +2481,14 @@ impl<'a, 'tcx> Visitor<'tcx> for ImplicitHasherTypeVisitor<'a, 'tcx> {\n \n /// Looks for default-hasher-dependent constructors like `HashMap::new`.\n struct ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     maybe_typeck_tables: Option<&'tcx TypeckTables<'tcx>>,\n     target: &'b ImplicitHasherType<'tcx>,\n     suggestions: BTreeMap<Span, String>,\n }\n \n impl<'a, 'b, 'tcx> ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n-    fn new(cx: &'a LateContext<'a, 'tcx>, target: &'b ImplicitHasherType<'tcx>) -> Self {\n+    fn new(cx: &'a LateContext<'tcx>, target: &'b ImplicitHasherType<'tcx>) -> Self {\n         Self {\n             cx,\n             maybe_typeck_tables: cx.maybe_typeck_tables(),\n@@ -2599,8 +2591,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(RefToMut => [CAST_REF_TO_MUT]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RefToMut {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for RefToMut {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Unary(UnOp::UnDeref, e) = &expr.kind;\n             if let ExprKind::Cast(e, t) = &e.kind;"}, {"sha": "d8c57f0e7ae7fd643ae07868c774aa1aecdbff80", "filename": "src/tools/clippy/clippy_lints/src/unicode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funicode.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -65,8 +65,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(Unicode => [ZERO_WIDTH_SPACE, NON_ASCII_LITERAL, UNICODE_NOT_NFC]);\n \n-impl LateLintPass<'_, '_> for Unicode {\n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &'_ Expr<'_>) {\n+impl LateLintPass<'_> for Unicode {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &'_ Expr<'_>) {\n         if let ExprKind::Lit(ref lit) = expr.kind {\n             if let LitKind::Str(_, _) = lit.node {\n                 check_str(cx, lit.span, expr.hir_id)\n@@ -89,7 +89,7 @@ fn escape<T: Iterator<Item = char>>(s: T) -> String {\n     result\n }\n \n-fn check_str(cx: &LateContext<'_, '_>, span: Span, id: HirId) {\n+fn check_str(cx: &LateContext<'_>, span: Span, id: HirId) {\n     let string = snippet(cx, span, \"\");\n     if string.contains('\\u{200B}') {\n         span_lint_and_sugg("}, {"sha": "b9aa202b328f6aad2637a20ed45697858e3352f6", "filename": "src/tools/clippy/clippy_lints/src/unnamed_address.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnamed_address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnamed_address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnamed_address.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -55,23 +55,23 @@ declare_clippy_lint! {\n \n declare_lint_pass!(UnnamedAddress => [FN_ADDRESS_COMPARISONS, VTABLE_ADDRESS_COMPARISONS]);\n \n-impl LateLintPass<'_, '_> for UnnamedAddress {\n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+impl LateLintPass<'_> for UnnamedAddress {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         fn is_comparison(binop: BinOpKind) -> bool {\n             match binop {\n                 BinOpKind::Eq | BinOpKind::Lt | BinOpKind::Le | BinOpKind::Ne | BinOpKind::Ge | BinOpKind::Gt => true,\n                 _ => false,\n             }\n         }\n \n-        fn is_trait_ptr(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+        fn is_trait_ptr(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n             match cx.tables().expr_ty_adjusted(expr).kind {\n                 ty::RawPtr(ty::TypeAndMut { ty, .. }) => ty.is_trait(),\n                 _ => false,\n             }\n         }\n \n-        fn is_fn_def(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+        fn is_fn_def(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n             if let ty::FnDef(..) = cx.tables().expr_ty(expr).kind {\n                 true\n             } else {"}, {"sha": "d940776817ca078453e21d6a5aa46d9814bafdb4", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -67,7 +67,7 @@ struct SortByKeyDetection {\n /// Detect if the two expressions are mirrored (identical, except one\n /// contains a and the other replaces it with b)\n fn mirrored_exprs(\n-    cx: &LateContext<'_, '_>,\n+    cx: &LateContext<'_>,\n     a_expr: &Expr<'_>,\n     a_ident: &Ident,\n     b_expr: &Expr<'_>,\n@@ -171,7 +171,7 @@ fn mirrored_exprs(\n     }\n }\n \n-fn detect_lint(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n+fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n     if_chain! {\n         if let ExprKind::MethodCall(name_ident, _, args, _) = &expr.kind;\n         if let name = name_ident.ident.name.to_ident_string();\n@@ -225,8 +225,8 @@ fn detect_lint(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Option<LintTrigger>\n     }\n }\n \n-impl LateLintPass<'_, '_> for UnnecessarySortBy {\n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+impl LateLintPass<'_> for UnnecessarySortBy {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         match detect_lint(cx, expr) {\n             Some(LintTrigger::SortByKey(trigger)) => utils::span_lint_and_sugg(\n                 cx,"}, {"sha": "1580f657d77113808fc788a4b87bde962370275f", "filename": "src/tools/clippy/clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -32,8 +32,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(UnusedIoAmount => [UNUSED_IO_AMOUNT]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n-    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for UnusedIoAmount {\n+    fn check_stmt(&mut self, cx: &LateContext<'_>, s: &hir::Stmt<'_>) {\n         let expr = match s.kind {\n             hir::StmtKind::Semi(ref expr) | hir::StmtKind::Expr(ref expr) => &**expr,\n             _ => return,\n@@ -64,7 +64,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n     }\n }\n \n-fn check_method_call(cx: &LateContext<'_, '_>, call: &hir::Expr<'_>, expr: &hir::Expr<'_>) {\n+fn check_method_call(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<'_>) {\n     if let hir::ExprKind::MethodCall(ref path, _, _, _) = call.kind {\n         let symbol = &*path.ident.as_str();\n         let read_trait = match_trait_method(cx, call, &paths::IO_READ);"}, {"sha": "da7517125c13b022fa8883ab80c84ef7da4f8096", "filename": "src/tools/clippy/clippy_lints/src/unused_self.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -39,8 +39,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(UnusedSelf => [UNUSED_SELF]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedSelf {\n-    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, impl_item: &ImplItem<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for UnusedSelf {\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &ImplItem<'_>) {\n         if impl_item.span.from_expansion() {\n             return;\n         }\n@@ -80,7 +80,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedSelf {\n }\n \n struct UnusedSelfVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     uses_self: bool,\n     self_hir_id: &'a HirId,\n }"}, {"sha": "56ff62eca033a172877893eb1d5e70e8afc568fa", "filename": "src/tools/clippy/clippy_lints/src/unwrap.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -68,7 +68,7 @@ declare_clippy_lint! {\n /// Visitor that keeps track of which variables are unwrappable.\n struct UnwrappableVariablesVisitor<'a, 'tcx> {\n     unwrappables: Vec<UnwrapInfo<'tcx>>,\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n }\n /// Contains information about whether a variable can be unwrapped.\n #[derive(Copy, Clone, Debug)]\n@@ -85,17 +85,17 @@ struct UnwrapInfo<'tcx> {\n \n /// Collects the information about unwrappable variables from an if condition\n /// The `invert` argument tells us whether the condition is negated.\n-fn collect_unwrap_info<'a, 'tcx>(\n-    cx: &'a LateContext<'a, 'tcx>,\n+fn collect_unwrap_info<'tcx>(\n+    cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'_>,\n     branch: &'tcx Expr<'_>,\n     invert: bool,\n ) -> Vec<UnwrapInfo<'tcx>> {\n-    fn is_relevant_option_call(cx: &LateContext<'_, '_>, ty: Ty<'_>, method_name: &str) -> bool {\n+    fn is_relevant_option_call(cx: &LateContext<'_>, ty: Ty<'_>, method_name: &str) -> bool {\n         is_type_diagnostic_item(cx, ty, sym!(option_type)) && [\"is_some\", \"is_none\"].contains(&method_name)\n     }\n \n-    fn is_relevant_result_call(cx: &LateContext<'_, '_>, ty: Ty<'_>, method_name: &str) -> bool {\n+    fn is_relevant_result_call(cx: &LateContext<'_>, ty: Ty<'_>, method_name: &str) -> bool {\n         is_type_diagnostic_item(cx, ty, sym!(result_type)) && [\"is_ok\", \"is_err\"].contains(&method_name)\n     }\n \n@@ -209,10 +209,10 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n \n declare_lint_pass!(Unwrap => [PANICKING_UNWRAP, UNNECESSARY_UNWRAP]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Unwrap {\n+impl<'tcx> LateLintPass<'tcx> for Unwrap {\n     fn check_fn(\n         &mut self,\n-        cx: &LateContext<'a, 'tcx>,\n+        cx: &LateContext<'tcx>,\n         kind: FnKind<'tcx>,\n         decl: &'tcx FnDecl<'_>,\n         body: &'tcx Body<'_>,"}, {"sha": "f85db1e2006e8e77327d2bc2e35d6bde02fea0a7", "filename": "src/tools/clippy/clippy_lints/src/use_self.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -57,7 +57,7 @@ declare_lint_pass!(UseSelf => [USE_SELF]);\n \n const SEGMENTS_MSG: &str = \"segments should be composed of at least 1 element\";\n \n-fn span_use_self_lint(cx: &LateContext<'_, '_>, path: &Path<'_>, last_segment: Option<&PathSegment<'_>>) {\n+fn span_use_self_lint(cx: &LateContext<'_>, path: &Path<'_>, last_segment: Option<&PathSegment<'_>>) {\n     let last_segment = last_segment.unwrap_or_else(|| path.segments.last().expect(SEGMENTS_MSG));\n \n     // Path segments only include actual path, no methods or fields.\n@@ -83,7 +83,7 @@ fn span_use_self_lint(cx: &LateContext<'_, '_>, path: &Path<'_>, last_segment: O\n \n // FIXME: always use this (more correct) visitor, not just in method signatures.\n struct SemanticUseSelfVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     self_ty: Ty<'tcx>,\n }\n \n@@ -110,8 +110,8 @@ impl<'a, 'tcx> Visitor<'tcx> for SemanticUseSelfVisitor<'a, 'tcx> {\n     }\n }\n \n-fn check_trait_method_impl_decl<'a, 'tcx>(\n-    cx: &'a LateContext<'a, 'tcx>,\n+fn check_trait_method_impl_decl<'tcx>(\n+    cx: &LateContext<'tcx>,\n     impl_item: &ImplItem<'_>,\n     impl_decl: &'tcx FnDecl<'_>,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n@@ -157,8 +157,8 @@ fn check_trait_method_impl_decl<'a, 'tcx>(\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UseSelf {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for UseSelf {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if in_external_macro(cx.sess(), item.span) {\n             return;\n         }\n@@ -211,7 +211,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UseSelf {\n \n struct UseSelfVisitor<'a, 'tcx> {\n     item_path: &'a Path<'a>,\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for UseSelfVisitor<'a, 'tcx> {"}, {"sha": "69c0b092520d86b11d069291abf848440c7bd7ab", "filename": "src/tools/clippy/clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -40,8 +40,8 @@ pub struct UselessConversion {\n impl_lint_pass!(UselessConversion => [USELESS_CONVERSION]);\n \n #[allow(clippy::too_many_lines)]\n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessConversion {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if e.span.from_expansion() {\n             return;\n         }\n@@ -173,7 +173,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessConversion {\n         }\n     }\n \n-    fn check_expr_post(&mut self, _: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+    fn check_expr_post(&mut self, _: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if Some(&e.hir_id) == self.try_desugar_arm.last() {\n             self.try_desugar_arm.pop();\n         }"}, {"sha": "128fa87a162124ce7c793a8ab6983095856aa5b1", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -64,8 +64,8 @@ fn done() {\n     println!(\"}}\");\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Author {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for Author {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n         if !has_attr(cx.sess(), &item.attrs) {\n             return;\n         }\n@@ -74,7 +74,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Author {\n         done();\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ImplItem<'_>) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n         if !has_attr(cx.sess(), &item.attrs) {\n             return;\n         }\n@@ -83,7 +83,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Author {\n         done();\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem<'_>) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n         if !has_attr(cx.sess(), &item.attrs) {\n             return;\n         }\n@@ -92,7 +92,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Author {\n         done();\n     }\n \n-    fn check_variant(&mut self, cx: &LateContext<'a, 'tcx>, var: &'tcx hir::Variant<'_>) {\n+    fn check_variant(&mut self, cx: &LateContext<'tcx>, var: &'tcx hir::Variant<'_>) {\n         if !has_attr(cx.sess(), &var.attrs) {\n             return;\n         }\n@@ -102,7 +102,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Author {\n         done();\n     }\n \n-    fn check_struct_field(&mut self, cx: &LateContext<'a, 'tcx>, field: &'tcx hir::StructField<'_>) {\n+    fn check_struct_field(&mut self, cx: &LateContext<'tcx>, field: &'tcx hir::StructField<'_>) {\n         if !has_attr(cx.sess(), &field.attrs) {\n             return;\n         }\n@@ -111,7 +111,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Author {\n         done();\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if !has_attr(cx.sess(), &expr.attrs) {\n             return;\n         }\n@@ -120,7 +120,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Author {\n         done();\n     }\n \n-    fn check_arm(&mut self, cx: &LateContext<'a, 'tcx>, arm: &'tcx hir::Arm<'_>) {\n+    fn check_arm(&mut self, cx: &LateContext<'tcx>, arm: &'tcx hir::Arm<'_>) {\n         if !has_attr(cx.sess(), &arm.attrs) {\n             return;\n         }\n@@ -129,7 +129,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Author {\n         done();\n     }\n \n-    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx hir::Stmt<'_>) {\n+    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx hir::Stmt<'_>) {\n         if !has_attr(cx.sess(), stmt.kind.attrs()) {\n             return;\n         }\n@@ -138,7 +138,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Author {\n         done();\n     }\n \n-    fn check_foreign_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ForeignItem<'_>) {\n+    fn check_foreign_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ForeignItem<'_>) {\n         if !has_attr(cx.sess(), &item.attrs) {\n             return;\n         }"}, {"sha": "e4e65b5f4d420b4937572ac2b7ee020dac9a4228", "filename": "src/tools/clippy/clippy_lints/src/utils/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -138,7 +138,7 @@ where\n     });\n }\n \n-pub fn span_lint_hir(cx: &LateContext<'_, '_>, lint: &'static Lint, hir_id: HirId, sp: Span, msg: &str) {\n+pub fn span_lint_hir(cx: &LateContext<'_>, lint: &'static Lint, hir_id: HirId, sp: Span, msg: &str) {\n     cx.tcx.struct_span_lint_hir(lint, hir_id, sp, |diag| {\n         let mut diag = diag.build(msg);\n         docs_link(&mut diag, lint);\n@@ -147,7 +147,7 @@ pub fn span_lint_hir(cx: &LateContext<'_, '_>, lint: &'static Lint, hir_id: HirI\n }\n \n pub fn span_lint_hir_and_then(\n-    cx: &LateContext<'_, '_>,\n+    cx: &LateContext<'_>,\n     lint: &'static Lint,\n     hir_id: HirId,\n     sp: Span,"}, {"sha": "eb7ac2447e493b5390bd4bbe0d55d256cf3e087e", "filename": "src/tools/clippy/clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -47,7 +47,7 @@ pub struct Range<'a> {\n }\n \n /// Higher a `hir` range to something similar to `ast::ExprKind::Range`.\n-pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr<'_>) -> Option<Range<'b>> {\n+pub fn range<'a, 'tcx>(cx: &LateContext<'tcx>, expr: &'a hir::Expr<'_>) -> Option<Range<'a>> {\n     /// Finds the field named `name` in the field. Always return `Some` for\n     /// convenience.\n     fn get_field<'c>(name: &str, fields: &'c [hir::Field<'_>]) -> Option<&'c hir::Expr<'c>> {\n@@ -257,7 +257,7 @@ pub enum VecArgs<'a> {\n \n /// Returns the arguments of the `vec!` macro if this expression was expanded\n /// from `vec!`.\n-pub fn vec_macro<'e>(cx: &LateContext<'_, '_>, expr: &'e hir::Expr<'_>) -> Option<VecArgs<'e>> {\n+pub fn vec_macro<'e>(cx: &LateContext<'_>, expr: &'e hir::Expr<'_>) -> Option<VecArgs<'e>> {\n     if_chain! {\n         if let hir::ExprKind::Call(ref fun, ref args) = expr.kind;\n         if let hir::ExprKind::Path(ref qpath) = fun.kind;"}, {"sha": "ae58f0a1521e69bf3ff32f7ae4e7cdd2cb1676b2", "filename": "src/tools/clippy/clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -21,15 +21,15 @@ use std::hash::Hash;\n /// Note that some expressions kinds are not considered but could be added.\n pub struct SpanlessEq<'a, 'tcx> {\n     /// Context used to evaluate constant expressions.\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     maybe_typeck_tables: Option<&'tcx TypeckTables<'tcx>>,\n     /// If is true, never consider as equal expressions containing function\n     /// calls.\n     ignore_fn: bool,\n }\n \n impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n-    pub fn new(cx: &'a LateContext<'a, 'tcx>) -> Self {\n+    pub fn new(cx: &'a LateContext<'tcx>) -> Self {\n         Self {\n             cx,\n             maybe_typeck_tables: cx.maybe_typeck_tables(),\n@@ -347,13 +347,13 @@ pub fn over<X>(left: &[X], right: &[X], mut eq_fn: impl FnMut(&X, &X) -> bool) -\n /// All expressions kind are hashed, but some might have a weaker hash.\n pub struct SpanlessHash<'a, 'tcx> {\n     /// Context used to evaluate constant expressions.\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     maybe_typeck_tables: Option<&'tcx TypeckTables<'tcx>>,\n     s: StableHasher,\n }\n \n impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n-    pub fn new(cx: &'a LateContext<'a, 'tcx>) -> Self {\n+    pub fn new(cx: &'a LateContext<'tcx>) -> Self {\n         Self {\n             cx,\n             maybe_typeck_tables: cx.maybe_typeck_tables(),"}, {"sha": "fbd103323e313fdebb08561834d1d7236af56a48", "filename": "src/tools/clippy/clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -31,15 +31,15 @@ declare_clippy_lint! {\n \n declare_lint_pass!(DeepCodeInspector => [DEEP_CODE_INSPECTION]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DeepCodeInspector {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for DeepCodeInspector {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n         if !has_attr(cx.sess(), &item.attrs) {\n             return;\n         }\n         print_item(cx, item);\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ImplItem<'_>) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n         if !has_attr(cx.sess(), &item.attrs) {\n             return;\n         }\n@@ -65,37 +65,37 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DeepCodeInspector {\n             hir::ImplItemKind::TyAlias(_) => println!(\"associated type\"),\n         }\n     }\n-    // fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx\n+    // fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx\n     // hir::TraitItem) {\n     // if !has_attr(&item.attrs) {\n     // return;\n     // }\n     // }\n     //\n-    // fn check_variant(&mut self, cx: &LateContext<'a, 'tcx>, var: &'tcx\n+    // fn check_variant(&mut self, cx: &LateContext<'tcx>, var: &'tcx\n     // hir::Variant, _:\n     // &hir::Generics) {\n     // if !has_attr(&var.node.attrs) {\n     // return;\n     // }\n     // }\n     //\n-    // fn check_struct_field(&mut self, cx: &LateContext<'a, 'tcx>, field: &'tcx\n+    // fn check_struct_field(&mut self, cx: &LateContext<'tcx>, field: &'tcx\n     // hir::StructField) {\n     // if !has_attr(&field.attrs) {\n     // return;\n     // }\n     // }\n     //\n \n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if !has_attr(cx.sess(), &expr.attrs) {\n             return;\n         }\n         print_expr(cx, expr, 0);\n     }\n \n-    fn check_arm(&mut self, cx: &LateContext<'a, 'tcx>, arm: &'tcx hir::Arm<'_>) {\n+    fn check_arm(&mut self, cx: &LateContext<'tcx>, arm: &'tcx hir::Arm<'_>) {\n         if !has_attr(cx.sess(), &arm.attrs) {\n             return;\n         }\n@@ -108,7 +108,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DeepCodeInspector {\n         print_expr(cx, &arm.body, 1);\n     }\n \n-    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx hir::Stmt<'_>) {\n+    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx hir::Stmt<'_>) {\n         if !has_attr(cx.sess(), stmt.kind.attrs()) {\n             return;\n         }\n@@ -126,7 +126,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DeepCodeInspector {\n             hir::StmtKind::Expr(ref e) | hir::StmtKind::Semi(ref e) => print_expr(cx, e, 0),\n         }\n     }\n-    // fn check_foreign_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx\n+    // fn check_foreign_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx\n     // hir::ForeignItem) {\n     // if !has_attr(&item.attrs) {\n     // return;\n@@ -141,7 +141,7 @@ fn has_attr(sess: &Session, attrs: &[Attribute]) -> bool {\n \n #[allow(clippy::similar_names)]\n #[allow(clippy::too_many_lines)]\n-fn print_expr(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, indent: usize) {\n+fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n     let ind = \"  \".repeat(indent);\n     println!(\"{}+\", ind);\n     println!(\"{}ty: {}\", ind, cx.tables().expr_ty(expr));\n@@ -348,7 +348,7 @@ fn print_expr(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, indent: usize) {\n     }\n }\n \n-fn print_item(cx: &LateContext<'_, '_>, item: &hir::Item<'_>) {\n+fn print_item(cx: &LateContext<'_>, item: &hir::Item<'_>) {\n     let did = cx.tcx.hir().local_def_id(item.hir_id);\n     println!(\"item `{}`\", item.ident.name);\n     match item.vis.node {\n@@ -425,7 +425,7 @@ fn print_item(cx: &LateContext<'_, '_>, item: &hir::Item<'_>) {\n \n #[allow(clippy::similar_names)]\n #[allow(clippy::too_many_lines)]\n-fn print_pat(cx: &LateContext<'_, '_>, pat: &hir::Pat<'_>, indent: usize) {\n+fn print_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, indent: usize) {\n     let ind = \"  \".repeat(indent);\n     println!(\"{}+\", ind);\n     match pat.kind {\n@@ -537,7 +537,7 @@ fn print_pat(cx: &LateContext<'_, '_>, pat: &hir::Pat<'_>, indent: usize) {\n     }\n }\n \n-fn print_guard(cx: &LateContext<'_, '_>, guard: &hir::Guard<'_>, indent: usize) {\n+fn print_guard(cx: &LateContext<'_>, guard: &hir::Guard<'_>, indent: usize) {\n     let ind = \"  \".repeat(indent);\n     println!(\"{}+\", ind);\n     match guard {"}, {"sha": "38cb764adde7b16a4784f1b2f1921b3dc23b546d", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -251,8 +251,8 @@ pub struct LintWithoutLintPass {\n \n impl_lint_pass!(LintWithoutLintPass => [DEFAULT_LINT, LINT_WITHOUT_LINT_PASS]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LintWithoutLintPass {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if !run_lints(cx, &[DEFAULT_LINT], item.hir_id) {\n             return;\n         }\n@@ -310,7 +310,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LintWithoutLintPass {\n         }\n     }\n \n-    fn check_crate_post(&mut self, cx: &LateContext<'a, 'tcx>, _: &'tcx Crate<'_>) {\n+    fn check_crate_post(&mut self, cx: &LateContext<'tcx>, _: &'tcx Crate<'_>) {\n         if !run_lints(cx, &[LINT_WITHOUT_LINT_PASS], CRATE_HIR_ID) {\n             return;\n         }\n@@ -337,7 +337,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LintWithoutLintPass {\n     }\n }\n \n-fn is_lint_ref_type<'tcx>(cx: &LateContext<'_, 'tcx>, ty: &Ty<'_>) -> bool {\n+fn is_lint_ref_type<'tcx>(cx: &LateContext<'tcx>, ty: &Ty<'_>) -> bool {\n     if let TyKind::Rptr(\n         _,\n         MutTy {\n@@ -358,7 +358,7 @@ fn is_lint_ref_type<'tcx>(cx: &LateContext<'_, 'tcx>, ty: &Ty<'_>) -> bool {\n \n struct LintCollector<'a, 'tcx> {\n     output: &'a mut FxHashSet<Symbol>,\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for LintCollector<'a, 'tcx> {\n@@ -395,8 +395,8 @@ impl CompilerLintFunctions {\n \n impl_lint_pass!(CompilerLintFunctions => [COMPILER_LINT_FUNCTIONS]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CompilerLintFunctions {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for CompilerLintFunctions {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if !run_lints(cx, &[COMPILER_LINT_FUNCTIONS], expr.hir_id) {\n             return;\n         }\n@@ -424,8 +424,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CompilerLintFunctions {\n \n declare_lint_pass!(OuterExpnDataPass => [OUTER_EXPN_EXPN_DATA]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OuterExpnDataPass {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for OuterExpnDataPass {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if !run_lints(cx, &[OUTER_EXPN_EXPN_DATA], expr.hir_id) {\n             return;\n         }\n@@ -474,8 +474,8 @@ fn is_trigger_fn(fn_kind: FnKind<'_>) -> bool {\n \n declare_lint_pass!(CollapsibleCalls => [COLLAPSIBLE_SPAN_LINT_CALLS]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CollapsibleCalls {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for CollapsibleCalls {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if !run_lints(cx, &[COLLAPSIBLE_SPAN_LINT_CALLS], expr.hir_id) {\n             return;\n         }\n@@ -529,10 +529,7 @@ struct AndThenSnippets<'a> {\n     msg: Cow<'a, str>,\n }\n \n-fn get_and_then_snippets<'a, 'hir>(\n-    cx: &LateContext<'_, '_>,\n-    and_then_snippets: &'hir [Expr<'hir>],\n-) -> AndThenSnippets<'a> {\n+fn get_and_then_snippets<'a, 'hir>(cx: &LateContext<'_>, and_then_snippets: &'hir [Expr<'hir>]) -> AndThenSnippets<'a> {\n     let cx_snippet = snippet(cx, and_then_snippets[0].span, \"cx\");\n     let lint_snippet = snippet(cx, and_then_snippets[1].span, \"..\");\n     let span_snippet = snippet(cx, and_then_snippets[2].span, \"span\");\n@@ -553,7 +550,7 @@ struct SpanSuggestionSnippets<'a> {\n }\n \n fn span_suggestion_snippets<'a, 'hir>(\n-    cx: &LateContext<'_, '_>,\n+    cx: &LateContext<'_>,\n     span_call_args: &'hir [Expr<'hir>],\n ) -> SpanSuggestionSnippets<'a> {\n     let help_snippet = snippet(cx, span_call_args[2].span, r#\"\"...\"\"#);\n@@ -568,7 +565,7 @@ fn span_suggestion_snippets<'a, 'hir>(\n }\n \n fn suggest_suggestion(\n-    cx: &LateContext<'_, '_>,\n+    cx: &LateContext<'_>,\n     expr: &Expr<'_>,\n     and_then_snippets: &AndThenSnippets<'_>,\n     span_suggestion_snippets: &SpanSuggestionSnippets<'_>,\n@@ -594,7 +591,7 @@ fn suggest_suggestion(\n }\n \n fn suggest_help(\n-    cx: &LateContext<'_, '_>,\n+    cx: &LateContext<'_>,\n     expr: &Expr<'_>,\n     and_then_snippets: &AndThenSnippets<'_>,\n     help: &str,\n@@ -626,7 +623,7 @@ fn suggest_help(\n }\n \n fn suggest_note(\n-    cx: &LateContext<'_, '_>,\n+    cx: &LateContext<'_>,\n     expr: &Expr<'_>,\n     and_then_snippets: &AndThenSnippets<'_>,\n     note: &str,"}, {"sha": "99ba7d64331cd02ff6dcb6b91177ce4721b2df58", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -70,7 +70,7 @@ pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n ///     // Do something\n /// }\n /// ```\n-pub fn in_constant(cx: &LateContext<'_, '_>, id: HirId) -> bool {\n+pub fn in_constant(cx: &LateContext<'_>, id: HirId) -> bool {\n     let parent_id = cx.tcx.hir().get_parent_item(id);\n     match cx.tcx.hir().get(parent_id) {\n         Node::Item(&Item {\n@@ -134,23 +134,23 @@ pub fn is_wild<'tcx>(pat: &impl std::ops::Deref<Target = Pat<'tcx>>) -> bool {\n }\n \n /// Checks if type is struct, enum or union type with the given def path.\n-pub fn match_type(cx: &LateContext<'_, '_>, ty: Ty<'_>, path: &[&str]) -> bool {\n+pub fn match_type(cx: &LateContext<'_>, ty: Ty<'_>, path: &[&str]) -> bool {\n     match ty.kind {\n         ty::Adt(adt, _) => match_def_path(cx, adt.did, path),\n         _ => false,\n     }\n }\n \n /// Checks if the type is equal to a diagnostic item\n-pub fn is_type_diagnostic_item(cx: &LateContext<'_, '_>, ty: Ty<'_>, diag_item: Symbol) -> bool {\n+pub fn is_type_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symbol) -> bool {\n     match ty.kind {\n         ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(diag_item, adt.did),\n         _ => false,\n     }\n }\n \n /// Checks if the method call given in `expr` belongs to the given trait.\n-pub fn match_trait_method(cx: &LateContext<'_, '_>, expr: &Expr<'_>, path: &[&str]) -> bool {\n+pub fn match_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, path: &[&str]) -> bool {\n     let def_id = cx.tables().type_dependent_def_id(expr.hir_id).unwrap();\n     let trt_id = cx.tcx.trait_of_item(def_id);\n     if let Some(trt_id) = trt_id {\n@@ -249,7 +249,7 @@ pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n }\n \n /// Gets the definition associated to a path.\n-pub fn path_to_res(cx: &LateContext<'_, '_>, path: &[&str]) -> Option<def::Res> {\n+pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Option<def::Res> {\n     let crates = cx.tcx.crates();\n     let krate = crates\n         .iter()\n@@ -285,7 +285,7 @@ pub fn path_to_res(cx: &LateContext<'_, '_>, path: &[&str]) -> Option<def::Res>\n     }\n }\n \n-pub fn qpath_res(cx: &LateContext<'_, '_>, qpath: &hir::QPath<'_>, id: hir::HirId) -> Res {\n+pub fn qpath_res(cx: &LateContext<'_>, qpath: &hir::QPath<'_>, id: hir::HirId) -> Res {\n     match qpath {\n         hir::QPath::Resolved(_, path) => path.res,\n         hir::QPath::TypeRelative(..) => {\n@@ -302,7 +302,7 @@ pub fn qpath_res(cx: &LateContext<'_, '_>, qpath: &hir::QPath<'_>, id: hir::HirI\n \n /// Convenience function to get the `DefId` of a trait by path.\n /// It could be a trait or trait alias.\n-pub fn get_trait_def_id(cx: &LateContext<'_, '_>, path: &[&str]) -> Option<DefId> {\n+pub fn get_trait_def_id(cx: &LateContext<'_>, path: &[&str]) -> Option<DefId> {\n     let res = match path_to_res(cx, path) {\n         Some(res) => res,\n         None => return None,\n@@ -317,8 +317,8 @@ pub fn get_trait_def_id(cx: &LateContext<'_, '_>, path: &[&str]) -> Option<DefId\n \n /// Checks whether a type implements a trait.\n /// See also `get_trait_def_id`.\n-pub fn implements_trait<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+pub fn implements_trait<'tcx>(\n+    cx: &LateContext<'tcx>,\n     ty: Ty<'tcx>,\n     trait_id: DefId,\n     ty_params: &[GenericArg<'tcx>],\n@@ -347,7 +347,7 @@ pub fn implements_trait<'a, 'tcx>(\n ///     }\n /// }\n /// ```\n-pub fn trait_ref_of_method<'tcx>(cx: &LateContext<'_, 'tcx>, hir_id: HirId) -> Option<&'tcx TraitRef<'tcx>> {\n+pub fn trait_ref_of_method<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<&'tcx TraitRef<'tcx>> {\n     // Get the implemented trait for the current function\n     let parent_impl = cx.tcx.hir().get_parent_item(hir_id);\n     if_chain! {\n@@ -360,7 +360,7 @@ pub fn trait_ref_of_method<'tcx>(cx: &LateContext<'_, 'tcx>, hir_id: HirId) -> O\n }\n \n /// Checks whether this type implements `Drop`.\n-pub fn has_drop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n+pub fn has_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.ty_adt_def() {\n         Some(def) => def.has_dtor(cx.tcx),\n         None => false,\n@@ -426,14 +426,14 @@ pub fn method_chain_args<'a>(expr: &'a Expr<'_>, methods: &[&str]) -> Option<Vec\n }\n \n /// Returns `true` if the provided `def_id` is an entrypoint to a program.\n-pub fn is_entrypoint_fn(cx: &LateContext<'_, '_>, def_id: DefId) -> bool {\n+pub fn is_entrypoint_fn(cx: &LateContext<'_>, def_id: DefId) -> bool {\n     cx.tcx\n         .entry_fn(LOCAL_CRATE)\n         .map_or(false, |(entry_fn_def_id, _)| def_id == entry_fn_def_id.to_def_id())\n }\n \n /// Gets the name of the item the expression is in, if available.\n-pub fn get_item_name(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Option<Name> {\n+pub fn get_item_name(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Name> {\n     let parent_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n     match cx.tcx.hir().find(parent_id) {\n         Some(\n@@ -717,7 +717,7 @@ fn trim_multiline_inner(s: Cow<'_, str>, ignore_first: bool, indent: Option<usiz\n }\n \n /// Gets the parent expression, if any \u2013- this is useful to constrain a lint.\n-pub fn get_parent_expr<'c>(cx: &'c LateContext<'_, '_>, e: &Expr<'_>) -> Option<&'c Expr<'c>> {\n+pub fn get_parent_expr<'c>(cx: &'c LateContext<'_>, e: &Expr<'_>) -> Option<&'c Expr<'c>> {\n     let map = &cx.tcx.hir();\n     let hir_id = e.hir_id;\n     let parent_id = map.get_parent_node(hir_id);\n@@ -733,7 +733,7 @@ pub fn get_parent_expr<'c>(cx: &'c LateContext<'_, '_>, e: &Expr<'_>) -> Option<\n     })\n }\n \n-pub fn get_enclosing_block<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, hir_id: HirId) -> Option<&'tcx Block<'tcx>> {\n+pub fn get_enclosing_block<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<&'tcx Block<'tcx>> {\n     let map = &cx.tcx.hir();\n     let enclosing_node = map\n         .get_enclosing_scope(hir_id)\n@@ -789,7 +789,7 @@ pub fn walk_ptrs_ty_depth(ty: Ty<'_>) -> (Ty<'_>, usize) {\n \n /// Checks whether the given expression is a constant integer of the given value.\n /// unlike `is_integer_literal`, this version does const folding\n-pub fn is_integer_const(cx: &LateContext<'_, '_>, e: &Expr<'_>, value: u128) -> bool {\n+pub fn is_integer_const(cx: &LateContext<'_>, e: &Expr<'_>, value: u128) -> bool {\n     if is_integer_literal(e, value) {\n         return true;\n     }\n@@ -823,7 +823,7 @@ pub fn is_integer_literal(expr: &Expr<'_>, value: u128) -> bool {\n ///\n /// See `rustc_middle::ty::adjustment::Adjustment` and `rustc_typeck::check::coercion` for more\n /// information on adjustments and coercions.\n-pub fn is_adjusted(cx: &LateContext<'_, '_>, e: &Expr<'_>) -> bool {\n+pub fn is_adjusted(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n     cx.tables().adjustments().get(e.hir_id).is_some()\n }\n \n@@ -876,26 +876,26 @@ pub fn is_direct_expn_of(span: Span, name: &str) -> Option<Span> {\n }\n \n /// Convenience function to get the return type of a function.\n-pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: hir::HirId) -> Ty<'tcx> {\n+pub fn return_ty<'tcx>(cx: &LateContext<'tcx>, fn_item: hir::HirId) -> Ty<'tcx> {\n     let fn_def_id = cx.tcx.hir().local_def_id(fn_item);\n     let ret_ty = cx.tcx.fn_sig(fn_def_id).output();\n     cx.tcx.erase_late_bound_regions(&ret_ty)\n }\n \n /// Returns `true` if the given type is an `unsafe` function.\n-pub fn type_is_unsafe_function<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n+pub fn type_is_unsafe_function<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.kind {\n         ty::FnDef(..) | ty::FnPtr(_) => ty.fn_sig(cx.tcx).unsafety() == Unsafety::Unsafe,\n         _ => false,\n     }\n }\n \n-pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n+pub fn is_copy<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     ty.is_copy_modulo_regions(cx.tcx.at(DUMMY_SP), cx.param_env)\n }\n \n /// Checks if an expression is constructing a tuple-like enum variant or struct\n-pub fn is_ctor_or_promotable_const_function(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+pub fn is_ctor_or_promotable_const_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     if let ExprKind::Call(ref fun, _) = expr.kind {\n         if let ExprKind::Path(ref qp) = fun.kind {\n             let res = cx.qpath_res(qp, fun.hir_id);\n@@ -911,15 +911,15 @@ pub fn is_ctor_or_promotable_const_function(cx: &LateContext<'_, '_>, expr: &Exp\n \n /// Returns `true` if a pattern is refutable.\n // TODO: should be implemented using rustc/mir_build/hair machinery\n-pub fn is_refutable(cx: &LateContext<'_, '_>, pat: &Pat<'_>) -> bool {\n-    fn is_enum_variant(cx: &LateContext<'_, '_>, qpath: &QPath<'_>, id: HirId) -> bool {\n+pub fn is_refutable(cx: &LateContext<'_>, pat: &Pat<'_>) -> bool {\n+    fn is_enum_variant(cx: &LateContext<'_>, qpath: &QPath<'_>, id: HirId) -> bool {\n         matches!(\n             cx.qpath_res(qpath, id),\n             def::Res::Def(DefKind::Variant, ..) | Res::Def(DefKind::Ctor(def::CtorOf::Variant, _), _)\n         )\n     }\n \n-    fn are_refutable<'a, I: Iterator<Item = &'a Pat<'a>>>(cx: &LateContext<'_, '_>, mut i: I) -> bool {\n+    fn are_refutable<'a, I: Iterator<Item = &'a Pat<'a>>>(cx: &LateContext<'_>, mut i: I) -> bool {\n         i.any(|pat| is_refutable(cx, pat))\n     }\n \n@@ -1050,7 +1050,7 @@ pub fn is_try<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n /// Returns `true` if the lint is allowed in the current context\n ///\n /// Useful for skipping long running code when it's unnecessary\n-pub fn is_allowed(cx: &LateContext<'_, '_>, lint: &'static Lint, id: HirId) -> bool {\n+pub fn is_allowed(cx: &LateContext<'_>, lint: &'static Lint, id: HirId) -> bool {\n     cx.tcx.lint_level_at_node(lint, id).0 == Level::Allow\n }\n \n@@ -1135,7 +1135,7 @@ pub fn any_parent_is_automatically_derived(tcx: TyCtxt<'_>, node: HirId) -> bool\n }\n \n /// Returns true if ty has `iter` or `iter_mut` methods\n-pub fn has_iter_method(cx: &LateContext<'_, '_>, probably_ref_ty: Ty<'_>) -> Option<&'static str> {\n+pub fn has_iter_method(cx: &LateContext<'_>, probably_ref_ty: Ty<'_>) -> Option<&'static str> {\n     // FIXME: instead of this hard-coded list, we should check if `<adt>::iter`\n     // exists and has the desired signature. Unfortunately FnCtxt is not exported\n     // so we can't use its `lookup_method` method.\n@@ -1182,8 +1182,8 @@ pub fn has_iter_method(cx: &LateContext<'_, '_>, probably_ref_ty: Ty<'_>) -> Opt\n /// ```rust,ignore\n /// if let Some(args) = match_function_call(cx, begin_panic_call, &paths::BEGIN_PANIC);\n /// ```\n-pub fn match_function_call<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+pub fn match_function_call<'tcx>(\n+    cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'_>,\n     path: &[&str],\n ) -> Option<&'tcx [Expr<'tcx>]> {\n@@ -1201,14 +1201,14 @@ pub fn match_function_call<'a, 'tcx>(\n \n /// Checks if `Ty` is normalizable. This function is useful\n /// to avoid crashes on `layout_of`.\n-pub fn is_normalizable<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> bool {\n+pub fn is_normalizable<'tcx>(cx: &LateContext<'tcx>, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> bool {\n     cx.tcx.infer_ctxt().enter(|infcx| {\n         let cause = rustc_middle::traits::ObligationCause::dummy();\n         infcx.at(&cause, param_env).normalize(&ty).is_ok()\n     })\n }\n \n-pub fn match_def_path<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, did: DefId, syms: &[&str]) -> bool {\n+pub fn match_def_path<'tcx>(cx: &LateContext<'tcx>, did: DefId, syms: &[&str]) -> bool {\n     // We have to convert `syms` to `&[Symbol]` here because rustc's `match_def_path`\n     // accepts only that. We should probably move to Symbols in Clippy as well.\n     let syms = syms.iter().map(|p| Symbol::intern(p)).collect::<Vec<Symbol>>();\n@@ -1250,7 +1250,7 @@ pub fn if_sequence<'tcx>(\n     (conds, blocks)\n }\n \n-pub fn parent_node_is_if_expr<'a, 'b>(expr: &Expr<'_>, cx: &LateContext<'a, 'b>) -> bool {\n+pub fn parent_node_is_if_expr(expr: &Expr<'_>, cx: &LateContext<'_>) -> bool {\n     let map = cx.tcx.hir();\n     let parent_id = map.get_parent_node(expr.hir_id);\n     let parent_node = map.get(parent_id);\n@@ -1275,7 +1275,7 @@ pub fn must_use_attr(attrs: &[Attribute]) -> Option<&Attribute> {\n }\n \n // Returns whether the type has #[must_use] attribute\n-pub fn is_must_use_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n+pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.kind {\n         ty::Adt(ref adt, _) => must_use_attr(&cx.tcx.get_attrs(adt.did)).is_some(),\n         ty::Foreign(ref did) => must_use_attr(&cx.tcx.get_attrs(*did)).is_some(),\n@@ -1313,7 +1313,7 @@ pub fn is_must_use_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> boo\n }\n \n // check if expr is calling method or function with #[must_use] attribyte\n-pub fn is_must_use_func_call(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     let did = match expr.kind {\n         ExprKind::Call(ref path, _) => if_chain! {\n             if let ExprKind::Path(ref qpath) = path.kind;\n@@ -1352,7 +1352,7 @@ pub fn is_no_std_crate(krate: &Crate<'_>) -> bool {\n ///     fn f() {}\n /// }\n /// ```\n-pub fn is_trait_impl_item(cx: &LateContext<'_, '_>, hir_id: HirId) -> bool {\n+pub fn is_trait_impl_item(cx: &LateContext<'_>, hir_id: HirId) -> bool {\n     if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id)) {\n         matches!(item.kind, ItemKind::Impl{ of_trait: Some(_), .. })\n     } else {\n@@ -1369,7 +1369,7 @@ pub fn is_trait_impl_item(cx: &LateContext<'_, '_>, hir_id: HirId) -> bool {\n ///     for _ in 2i32 {}\n /// }\n /// ```\n-pub fn fn_has_unsatisfiable_preds(cx: &LateContext<'_, '_>, did: DefId) -> bool {\n+pub fn fn_has_unsatisfiable_preds(cx: &LateContext<'_>, did: DefId) -> bool {\n     use rustc_trait_selection::traits;\n     let predicates =\n         cx.tcx\n@@ -1385,7 +1385,7 @@ pub fn fn_has_unsatisfiable_preds(cx: &LateContext<'_, '_>, did: DefId) -> bool\n     )\n }\n \n-pub fn run_lints(cx: &LateContext<'_, '_>, lints: &[&'static Lint], id: HirId) -> bool {\n+pub fn run_lints(cx: &LateContext<'_>, lints: &[&'static Lint], id: HirId) -> bool {\n     lints.iter().any(|lint| {\n         matches!(\n             cx.tcx.lint_level_at_node(lint, id),"}, {"sha": "bd2c619f00028167c4b730a3966cc3a31130aed9", "filename": "src/tools/clippy/clippy_lints/src/utils/ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fptr.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -7,7 +7,7 @@ use rustc_span::{Span, Symbol};\n use std::borrow::Cow;\n \n pub fn get_spans(\n-    cx: &LateContext<'_, '_>,\n+    cx: &LateContext<'_>,\n     opt_body_id: Option<BodyId>,\n     idx: usize,\n     replacements: &[(&'static str, &'static str)],\n@@ -22,8 +22,8 @@ pub fn get_spans(\n     }\n }\n \n-fn extract_clone_suggestions<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n+fn extract_clone_suggestions<'tcx>(\n+    cx: &LateContext<'tcx>,\n     name: Symbol,\n     replace: &[(&'static str, &'static str)],\n     body: &'tcx Body<'_>,\n@@ -44,7 +44,7 @@ fn extract_clone_suggestions<'a, 'tcx>(\n }\n \n struct PtrCloneVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    cx: &'a LateContext<'tcx>,\n     name: Symbol,\n     replace: &'a [(&'static str, &'static str)],\n     spans: Vec<(Span, Cow<'static, str>)>,"}, {"sha": "d05e81b9505795cf979985ea5bb2dcf714143afd", "filename": "src/tools/clippy/clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -39,7 +39,7 @@ impl Display for Sugg<'_> {\n #[allow(clippy::wrong_self_convention)] // ok, because of the function `as_ty` method\n impl<'a> Sugg<'a> {\n     /// Prepare a suggestion from an expression.\n-    pub fn hir_opt(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) -> Option<Self> {\n+    pub fn hir_opt(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Self> {\n         snippet_opt(cx, expr.span).map(|snippet| {\n             let snippet = Cow::Owned(snippet);\n             Self::hir_from_snippet(cx, expr, snippet)\n@@ -48,7 +48,7 @@ impl<'a> Sugg<'a> {\n \n     /// Convenience function around `hir_opt` for suggestions with a default\n     /// text.\n-    pub fn hir(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, default: &'a str) -> Self {\n+    pub fn hir(cx: &LateContext<'_>, expr: &hir::Expr<'_>, default: &'a str) -> Self {\n         Self::hir_opt(cx, expr).unwrap_or_else(|| Sugg::NonParen(Cow::Borrowed(default)))\n     }\n \n@@ -60,7 +60,7 @@ impl<'a> Sugg<'a> {\n     ///   to\n     /// `HasPlaceholders`\n     pub fn hir_with_applicability(\n-        cx: &LateContext<'_, '_>,\n+        cx: &LateContext<'_>,\n         expr: &hir::Expr<'_>,\n         default: &'a str,\n         applicability: &mut Applicability,\n@@ -77,15 +77,15 @@ impl<'a> Sugg<'a> {\n     }\n \n     /// Same as `hir`, but will use the pre expansion span if the `expr` was in a macro.\n-    pub fn hir_with_macro_callsite(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, default: &'a str) -> Self {\n+    pub fn hir_with_macro_callsite(cx: &LateContext<'_>, expr: &hir::Expr<'_>, default: &'a str) -> Self {\n         let snippet = snippet_with_macro_callsite(cx, expr.span, default);\n \n         Self::hir_from_snippet(cx, expr, snippet)\n     }\n \n     /// Generate a suggestion for an expression with the given snippet. This is used by the `hir_*`\n     /// function variants of `Sugg`, since these use different snippet functions.\n-    fn hir_from_snippet(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, snippet: Cow<'a, str>) -> Self {\n+    fn hir_from_snippet(cx: &LateContext<'_>, expr: &hir::Expr<'_>, snippet: Cow<'a, str>) -> Self {\n         if let Some(range) = higher::range(cx, expr) {\n             let op = match range.limits {\n                 ast::RangeLimits::HalfOpen => AssocOp::DotDot,"}, {"sha": "53d3a241f58af673ebb5648a71e3f17a2ceba57f", "filename": "src/tools/clippy/clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -11,7 +11,7 @@ use rustc_span::symbol::{Ident, Symbol};\n use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n \n /// Returns a set of mutated local variable IDs, or `None` if mutations could not be determined.\n-pub fn mutated_variables<'a, 'tcx>(expr: &'tcx Expr<'_>, cx: &'a LateContext<'a, 'tcx>) -> Option<FxHashSet<HirId>> {\n+pub fn mutated_variables<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) -> Option<FxHashSet<HirId>> {\n     let mut delegate = MutVarsDelegate {\n         used_mutably: FxHashSet::default(),\n         skip: false,\n@@ -27,11 +27,7 @@ pub fn mutated_variables<'a, 'tcx>(expr: &'tcx Expr<'_>, cx: &'a LateContext<'a,\n     Some(delegate.used_mutably)\n }\n \n-pub fn is_potentially_mutated<'a, 'tcx>(\n-    variable: &'tcx Path<'_>,\n-    expr: &'tcx Expr<'_>,\n-    cx: &'a LateContext<'a, 'tcx>,\n-) -> bool {\n+pub fn is_potentially_mutated<'tcx>(variable: &'tcx Path<'_>, expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) -> bool {\n     if let Res::Local(id) = variable.res {\n         mutated_variables(expr, cx).map_or(true, |mutated| mutated.contains(&id))\n     } else {"}, {"sha": "e1043c36e0a541c45653f045e17295cdddedd504", "filename": "src/tools/clippy/clippy_lints/src/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -33,8 +33,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(UselessVec => [USELESS_VEC]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessVec {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for UselessVec {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // search for `&vec![_]` expressions where the adjusted type is `&[_]`\n         if_chain! {\n             if let ty::Ref(_, ty, _) = cx.tables().expr_ty_adjusted(expr).kind;\n@@ -66,7 +66,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessVec {\n     }\n }\n \n-fn check_vec_macro<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, vec_args: &higher::VecArgs<'tcx>, span: Span) {\n+fn check_vec_macro<'tcx>(cx: &LateContext<'tcx>, vec_args: &higher::VecArgs<'tcx>, span: Span) {\n     let mut applicability = Applicability::MachineApplicable;\n     let snippet = match *vec_args {\n         higher::VecArgs::Repeat(elem, len) => {"}, {"sha": "cc5e21a7ca6fc876a627e6675ed54e923bc86518", "filename": "src/tools/clippy/clippy_lints/src/vec_resize_to_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_resize_to_zero.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -28,8 +28,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(VecResizeToZero => [VEC_RESIZE_TO_ZERO]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VecResizeToZero {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for VecResizeToZero {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let hir::ExprKind::MethodCall(path_segment, _, ref args, _) = expr.kind;\n             if let Some(method_def_id) = cx.tables().type_dependent_def_id(expr.hir_id);"}, {"sha": "b06fe36da631b65c925f25ec867b274594f6e436", "filename": "src/tools/clippy/clippy_lints/src/verbose_file_reads.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fverbose_file_reads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fverbose_file_reads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fverbose_file_reads.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -33,8 +33,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(VerboseFileReads => [VERBOSE_FILE_READS]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VerboseFileReads {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'tcx>) {\n+impl<'tcx> LateLintPass<'tcx> for VerboseFileReads {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         if is_file_read_to_end(cx, expr) {\n             span_lint_and_help(\n                 cx,\n@@ -57,7 +57,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VerboseFileReads {\n     }\n }\n \n-fn is_file_read_to_end<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+fn is_file_read_to_end<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n     if_chain! {\n         if let ExprKind::MethodCall(method_name, _, exprs, _) = expr.kind;\n         if method_name.ident.as_str() == \"read_to_end\";\n@@ -71,7 +71,7 @@ fn is_file_read_to_end<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'t\n     false\n }\n \n-fn is_file_read_to_string<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+fn is_file_read_to_string<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n     if_chain! {\n         if let ExprKind::MethodCall(method_name, _, exprs, _) = expr.kind;\n         if method_name.ident.as_str() == \"read_to_string\";"}, {"sha": "cd1864f461d3b284787ad22668339a502fe1107a", "filename": "src/tools/clippy/clippy_lints/src/wildcard_dependencies.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_dependencies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_dependencies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_dependencies.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -28,8 +28,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(WildcardDependencies => [WILDCARD_DEPENDENCIES]);\n \n-impl LateLintPass<'_, '_> for WildcardDependencies {\n-    fn check_crate(&mut self, cx: &LateContext<'_, '_>, _: &Crate<'_>) {\n+impl LateLintPass<'_> for WildcardDependencies {\n+    fn check_crate(&mut self, cx: &LateContext<'_>, _: &Crate<'_>) {\n         if !run_lints(cx, &[WILDCARD_DEPENDENCIES], CRATE_HIR_ID) {\n             return;\n         }"}, {"sha": "e7eb7c2e9802d05c249f9e9ebe8f4cbb633c7b40", "filename": "src/tools/clippy/clippy_lints/src/wildcard_imports.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -101,8 +101,8 @@ impl WildcardImports {\n \n impl_lint_pass!(WildcardImports => [ENUM_GLOB_USE, WILDCARD_IMPORTS]);\n \n-impl LateLintPass<'_, '_> for WildcardImports {\n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &Item<'_>) {\n+impl LateLintPass<'_> for WildcardImports {\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n         if is_test_module_or_function(item) {\n             self.test_modules_deep = self.test_modules_deep.saturating_add(1);\n         }\n@@ -180,7 +180,7 @@ impl LateLintPass<'_, '_> for WildcardImports {\n         }\n     }\n \n-    fn check_item_post(&mut self, _: &LateContext<'_, '_>, item: &Item<'_>) {\n+    fn check_item_post(&mut self, _: &LateContext<'_>, item: &Item<'_>) {\n         if is_test_module_or_function(item) {\n             self.test_modules_deep = self.test_modules_deep.saturating_sub(1);\n         }"}, {"sha": "1e011ea9cba5e4f316b4730cf1b18f7c0f50a765", "filename": "src/tools/clippy/clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -27,8 +27,8 @@ declare_clippy_lint! {\n \n declare_lint_pass!(ZeroDiv => [ZERO_DIVIDED_BY_ZERO]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ZeroDiv {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for ZeroDiv {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // check for instances of 0.0/0.0\n         if_chain! {\n             if let ExprKind::Binary(ref op, ref left, ref right) = expr.kind;"}, {"sha": "412ff99314d9969baa1997008b3d3d3ebbccd916", "filename": "src/tools/clippy/doc/common_tools_writing_lints.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -28,8 +28,8 @@ that gives you access to the underlying structure [`TyS`][TyS].\n \n Example of use:\n ```rust\n-impl LateLintPass<'_, '_> for MyStructLint {\n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+impl LateLintPass<'_> for MyStructLint {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         // Get type of `expr`\n         let ty = cx.tables().expr_ty(expr);\n         // Match its kind to enter its type\n@@ -56,8 +56,8 @@ Two noticeable items here:\n Starting with an `expr`, you can check whether it is calling a specific method `some_method`:\n \n ```rust\n-impl LateLintPass<'_, '_> for MyStructLint {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n+impl LateLintPass<'_> for MyStructLint {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n             // Check our expr is calling a method\n             if let hir::ExprKind::MethodCall(path, _, _args) = &expr.kind;\n@@ -78,8 +78,8 @@ There are two ways to do this, depending if the target trait is part of lang ite\n ```rust\n use crate::utils::{implements_trait, match_trait_method, paths};\n \n-impl LateLintPass<'_, '_> for MyStructLint {\n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+impl LateLintPass<'_> for MyStructLint {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         // 1. Using expression and Clippy's convenient method\n         // we use `match_trait_method` function from Clippy's toolbox\n         if match_trait_method(cx, expr, &paths::INTO) {\n@@ -112,8 +112,8 @@ To check if our type defines a method called `some_method`:\n ```rust\n use crate::utils::{is_type_diagnostic_item, return_ty};\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MyTypeImpl {\n-    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, impl_item: &'tcx ImplItem<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for MyTypeImpl {\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx ImplItem<'_>) {\n         if_chain! {\n             // Check if item is a method/function\n             if let ImplItemKind::Fn(ref signature, _) = impl_item.kind;"}, {"sha": "b0b3498f057f7f7d05eb87124c4acb68a45aa7e6", "filename": "src/tools/clippy/tests/ui/outer_expn_data.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fouter_expn_data.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fouter_expn_data.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fouter_expn_data.fixed?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -19,8 +19,8 @@ declare_lint! {\n \n declare_lint_pass!(Pass => [TEST_LINT]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n-    fn check_expr(&mut self, _cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+impl<'tcx> LateLintPass<'tcx> for Pass {\n+    fn check_expr(&mut self, _cx: &LateContext<'tcx>, expr: &'tcx Expr) {\n         let _ = expr.span.ctxt().outer_expn_data();\n     }\n }"}, {"sha": "55a3fed00d075dfa5a4d7360fa9b9f0a85ece34f", "filename": "src/tools/clippy/tests/ui/outer_expn_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fouter_expn_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/874f406ffdda1533cbbc04bc8fd48e7d9da59c47/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fouter_expn_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fouter_expn_data.rs?ref=874f406ffdda1533cbbc04bc8fd48e7d9da59c47", "patch": "@@ -19,8 +19,8 @@ declare_lint! {\n \n declare_lint_pass!(Pass => [TEST_LINT]);\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n-    fn check_expr(&mut self, _cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+impl<'tcx> LateLintPass<'tcx> for Pass {\n+    fn check_expr(&mut self, _cx: &LateContext<'tcx>, expr: &'tcx Expr) {\n         let _ = expr.span.ctxt().outer_expn().expn_data();\n     }\n }"}]}