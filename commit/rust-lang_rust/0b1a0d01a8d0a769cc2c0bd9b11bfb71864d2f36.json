{"sha": "0b1a0d01a8d0a769cc2c0bd9b11bfb71864d2f36", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiMWEwZDAxYThkMGE3NjljYzJjMGJkOWIxMWJmYjcxODY0ZDJmMzY=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-10-01T17:16:22Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-10-09T11:22:43Z"}, "message": "std::rand: move the Rand impls into a separate file for neatness.", "tree": {"sha": "f6e5ce1c4cbc6bfd5e75ba38c94cdff763a3b65d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6e5ce1c4cbc6bfd5e75ba38c94cdff763a3b65d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b1a0d01a8d0a769cc2c0bd9b11bfb71864d2f36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b1a0d01a8d0a769cc2c0bd9b11bfb71864d2f36", "html_url": "https://github.com/rust-lang/rust/commit/0b1a0d01a8d0a769cc2c0bd9b11bfb71864d2f36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b1a0d01a8d0a769cc2c0bd9b11bfb71864d2f36/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f4ec72362c2cf223b85d4fae9a1592a02e80317", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f4ec72362c2cf223b85d4fae9a1592a02e80317", "html_url": "https://github.com/rust-lang/rust/commit/6f4ec72362c2cf223b85d4fae9a1592a02e80317"}], "stats": {"total": 368, "additions": 201, "deletions": 167}, "files": [{"sha": "510bb0dbde38743539fb639e163f21fb927309cb", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 2, "deletions": 167, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/0b1a0d01a8d0a769cc2c0bd9b11bfb71864d2f36/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1a0d01a8d0a769cc2c0bd9b11bfb71864d2f36/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=0b1a0d01a8d0a769cc2c0bd9b11bfb71864d2f36", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -45,14 +45,11 @@ fn main () {\n \n use cast;\n use container::Container;\n-use int;\n use iter::{Iterator, range};\n use local_data;\n use prelude::*;\n use str;\n-use u32;\n use u64;\n-use uint;\n use vec;\n use os::getenv;\n \n@@ -64,6 +61,7 @@ pub mod isaac;\n pub mod os;\n pub mod reader;\n pub mod reseeding;\n+mod rand_impls;\n \n /// A type that can be randomly generated using an Rng\n pub trait Rand {\n@@ -72,169 +70,6 @@ pub trait Rand {\n     fn rand<R: Rng>(rng: &mut R) -> Self;\n }\n \n-impl Rand for int {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> int {\n-        if int::bits == 32 {\n-            rng.gen::<i32>() as int\n-        } else {\n-            rng.gen::<i64>() as int\n-        }\n-    }\n-}\n-\n-impl Rand for i8 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> i8 {\n-        rng.next_u32() as i8\n-    }\n-}\n-\n-impl Rand for i16 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> i16 {\n-        rng.next_u32() as i16\n-    }\n-}\n-\n-impl Rand for i32 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> i32 {\n-        rng.next_u32() as i32\n-    }\n-}\n-\n-impl Rand for i64 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> i64 {\n-        rng.next_u64() as i64\n-    }\n-}\n-\n-impl Rand for uint {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> uint {\n-        if uint::bits == 32 {\n-            rng.gen::<u32>() as uint\n-        } else {\n-            rng.gen::<u64>() as uint\n-        }\n-    }\n-}\n-\n-impl Rand for u8 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> u8 {\n-        rng.next_u32() as u8\n-    }\n-}\n-\n-impl Rand for u16 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> u16 {\n-        rng.next_u32() as u16\n-    }\n-}\n-\n-impl Rand for u32 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> u32 {\n-        rng.next_u32()\n-    }\n-}\n-\n-impl Rand for u64 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> u64 {\n-        rng.next_u64()\n-    }\n-}\n-\n-impl Rand for f32 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> f32 {\n-        rng.gen::<f64>() as f32\n-    }\n-}\n-\n-static SCALE : f64 = (u32::max_value as f64) + 1.0f64;\n-impl Rand for f64 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> f64 {\n-        let u1 = rng.next_u32() as f64;\n-        let u2 = rng.next_u32() as f64;\n-        let u3 = rng.next_u32() as f64;\n-\n-        ((u1 / SCALE + u2) / SCALE + u3) / SCALE\n-    }\n-}\n-\n-impl Rand for bool {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> bool {\n-        rng.gen::<u8>() & 1 == 1\n-    }\n-}\n-\n-macro_rules! tuple_impl {\n-    // use variables to indicate the arity of the tuple\n-    ($($tyvar:ident),* ) => {\n-        // the trailing commas are for the 1 tuple\n-        impl<\n-            $( $tyvar : Rand ),*\n-            > Rand for ( $( $tyvar ),* , ) {\n-\n-            #[inline]\n-            fn rand<R: Rng>(_rng: &mut R) -> ( $( $tyvar ),* , ) {\n-                (\n-                    // use the $tyvar's to get the appropriate number of\n-                    // repeats (they're not actually needed)\n-                    $(\n-                        _rng.gen::<$tyvar>()\n-                    ),*\n-                    ,\n-                )\n-            }\n-        }\n-    }\n-}\n-\n-impl Rand for () {\n-    #[inline]\n-    fn rand<R: Rng>(_: &mut R) -> () { () }\n-}\n-tuple_impl!{A}\n-tuple_impl!{A, B}\n-tuple_impl!{A, B, C}\n-tuple_impl!{A, B, C, D}\n-tuple_impl!{A, B, C, D, E}\n-tuple_impl!{A, B, C, D, E, F}\n-tuple_impl!{A, B, C, D, E, F, G}\n-tuple_impl!{A, B, C, D, E, F, G, H}\n-tuple_impl!{A, B, C, D, E, F, G, H, I}\n-tuple_impl!{A, B, C, D, E, F, G, H, I, J}\n-\n-impl<T:Rand> Rand for Option<T> {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> Option<T> {\n-        if rng.gen() {\n-            Some(rng.gen())\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl<T: Rand> Rand for ~T {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> ~T { ~rng.gen() }\n-}\n-\n-impl<T: Rand + 'static> Rand for @T {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> @T { @rng.gen() }\n-}\n-\n /// A value with a particular weight compared to other values\n pub struct Weighted<T> {\n     /// The numerical weight of this item"}, {"sha": "22980a3e1c4c3aebf24d63e3c4e33aa450d40d8d", "filename": "src/libstd/rand/rand_impls.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/0b1a0d01a8d0a769cc2c0bd9b11bfb71864d2f36/src%2Flibstd%2Frand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1a0d01a8d0a769cc2c0bd9b11bfb71864d2f36/src%2Flibstd%2Frand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Frand_impls.rs?ref=0b1a0d01a8d0a769cc2c0bd9b11bfb71864d2f36", "patch": "@@ -0,0 +1,199 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The implementations of `Rand` for the built-in types.\n+\n+use char;\n+use int;\n+use option::{Option, Some, None};\n+use rand::{Rand,Rng};\n+use u32;\n+use uint;\n+\n+impl Rand for int {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> int {\n+        if int::bits == 32 {\n+            rng.gen::<i32>() as int\n+        } else {\n+            rng.gen::<i64>() as int\n+        }\n+    }\n+}\n+\n+impl Rand for i8 {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> i8 {\n+        rng.next_u32() as i8\n+    }\n+}\n+\n+impl Rand for i16 {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> i16 {\n+        rng.next_u32() as i16\n+    }\n+}\n+\n+impl Rand for i32 {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> i32 {\n+        rng.next_u32() as i32\n+    }\n+}\n+\n+impl Rand for i64 {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> i64 {\n+        rng.next_u64() as i64\n+    }\n+}\n+\n+impl Rand for uint {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> uint {\n+        if uint::bits == 32 {\n+            rng.gen::<u32>() as uint\n+        } else {\n+            rng.gen::<u64>() as uint\n+        }\n+    }\n+}\n+\n+impl Rand for u8 {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> u8 {\n+        rng.next_u32() as u8\n+    }\n+}\n+\n+impl Rand for u16 {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> u16 {\n+        rng.next_u32() as u16\n+    }\n+}\n+\n+impl Rand for u32 {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> u32 {\n+        rng.next_u32()\n+    }\n+}\n+\n+impl Rand for u64 {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> u64 {\n+        rng.next_u64()\n+    }\n+}\n+\n+impl Rand for f32 {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> f32 {\n+        rng.gen::<f64>() as f32\n+    }\n+}\n+\n+static SCALE : f64 = (u32::max_value as f64) + 1.0f64;\n+impl Rand for f64 {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> f64 {\n+        let u1 = rng.next_u32() as f64;\n+        let u2 = rng.next_u32() as f64;\n+        let u3 = rng.next_u32() as f64;\n+\n+        ((u1 / SCALE + u2) / SCALE + u3) / SCALE\n+    }\n+}\n+\n+\n+impl Rand for char {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> char {\n+        // a char is 21 bits\n+        static CHAR_MASK: u32 = 0x001f_ffff;\n+        loop {\n+            // Rejection sampling. About 0.2% of numbers with at most\n+            // 21-bits are invalid codepoints (surrogates), so this\n+            // will succeed first go almost every time.\n+            match char::from_u32(rng.next_u32() & CHAR_MASK) {\n+                Some(c) => return c,\n+                None => {}\n+            }\n+        }\n+    }\n+}\n+\n+impl Rand for bool {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> bool {\n+        rng.gen::<u8>() & 1 == 1\n+    }\n+}\n+\n+macro_rules! tuple_impl {\n+    // use variables to indicate the arity of the tuple\n+    ($($tyvar:ident),* ) => {\n+        // the trailing commas are for the 1 tuple\n+        impl<\n+            $( $tyvar : Rand ),*\n+            > Rand for ( $( $tyvar ),* , ) {\n+\n+            #[inline]\n+            fn rand<R: Rng>(_rng: &mut R) -> ( $( $tyvar ),* , ) {\n+                (\n+                    // use the $tyvar's to get the appropriate number of\n+                    // repeats (they're not actually needed)\n+                    $(\n+                        _rng.gen::<$tyvar>()\n+                    ),*\n+                    ,\n+                )\n+            }\n+        }\n+    }\n+}\n+\n+impl Rand for () {\n+    #[inline]\n+    fn rand<R: Rng>(_: &mut R) -> () { () }\n+}\n+tuple_impl!{A}\n+tuple_impl!{A, B}\n+tuple_impl!{A, B, C}\n+tuple_impl!{A, B, C, D}\n+tuple_impl!{A, B, C, D, E}\n+tuple_impl!{A, B, C, D, E, F}\n+tuple_impl!{A, B, C, D, E, F, G}\n+tuple_impl!{A, B, C, D, E, F, G, H}\n+tuple_impl!{A, B, C, D, E, F, G, H, I}\n+tuple_impl!{A, B, C, D, E, F, G, H, I, J}\n+\n+impl<T:Rand> Rand for Option<T> {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> Option<T> {\n+        if rng.gen() {\n+            Some(rng.gen())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<T: Rand> Rand for ~T {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> ~T { ~rng.gen() }\n+}\n+\n+impl<T: Rand + 'static> Rand for @T {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> @T { @rng.gen() }\n+}"}]}