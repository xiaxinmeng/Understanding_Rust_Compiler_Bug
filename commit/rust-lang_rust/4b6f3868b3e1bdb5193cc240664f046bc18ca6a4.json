{"sha": "4b6f3868b3e1bdb5193cc240664f046bc18ca6a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiNmYzODY4YjNlMWJkYjUxOTNjYzI0MDY2NGYwNDZiYzE4Y2E2YTQ=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-02-10T13:59:13Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-06-19T07:52:35Z"}, "message": "Make interning explicitly care about types and the mutability of memory", "tree": {"sha": "4b842367a7e58a09037d2f2c099a6bdf3e8a6c0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b842367a7e58a09037d2f2c099a6bdf3e8a6c0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4", "html_url": "https://github.com/rust-lang/rust/commit/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d5728a7c8e77c01708ac6b829cd77ef62c32eaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d5728a7c8e77c01708ac6b829cd77ef62c32eaa", "html_url": "https://github.com/rust-lang/rust/commit/8d5728a7c8e77c01708ac6b829cd77ef62c32eaa"}], "stats": {"total": 840, "additions": 668, "deletions": 172}, "files": [{"sha": "31541842e2151880c484e7ee4596ea8be0913551", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 53, "deletions": 44, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=4b6f3868b3e1bdb5193cc240664f046bc18ca6a4", "patch": "@@ -9,7 +9,7 @@ use std::convert::TryInto;\n \n use rustc::hir::def::DefKind;\n use rustc::hir::def_id::DefId;\n-use rustc::mir::interpret::{ConstEvalErr, ErrorHandled};\n+use rustc::mir::interpret::{ConstEvalErr, ErrorHandled, ScalarMaybeUndef};\n use rustc::mir;\n use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n use rustc::ty::layout::{self, LayoutOf, VariantIdx};\n@@ -18,15 +18,14 @@ use rustc::traits::Reveal;\n use rustc::util::common::ErrorReported;\n use rustc_data_structures::fx::FxHashMap;\n \n-use syntax::ast::Mutability;\n use syntax::source_map::{Span, DUMMY_SP};\n \n use crate::interpret::{self,\n-    PlaceTy, MPlaceTy, MemPlace, OpTy, ImmTy, Immediate, Scalar,\n+    PlaceTy, MPlaceTy, OpTy, ImmTy, Immediate, Scalar,\n     RawConst, ConstValue,\n     InterpResult, InterpErrorInfo, InterpError, GlobalId, InterpretCx, StackPopCleanup,\n     Allocation, AllocId, MemoryKind,\n-    snapshot, RefTracking,\n+    snapshot, RefTracking, intern_const_alloc_recursive,\n };\n \n /// Number of steps until the detector even starts doing anything.\n@@ -63,33 +62,19 @@ pub(crate) fn eval_promoted<'mir, 'tcx>(\n     eval_body_using_ecx(&mut ecx, cid, body, param_env)\n }\n \n-fn mplace_to_const<'tcx>(\n-    ecx: &CompileTimeEvalContext<'_, 'tcx>,\n-    mplace: MPlaceTy<'tcx>,\n-) -> &'tcx ty::Const<'tcx> {\n-    let MemPlace { ptr, align, meta } = *mplace;\n-    // extract alloc-offset pair\n-    assert!(meta.is_none());\n-    let ptr = ptr.to_ptr().unwrap();\n-    let alloc = ecx.memory.get(ptr.alloc_id).unwrap();\n-    assert!(alloc.align >= align);\n-    assert!(alloc.bytes.len() as u64 - ptr.offset.bytes() >= mplace.layout.size.bytes());\n-    let mut alloc = alloc.clone();\n-    alloc.align = align;\n-    // FIXME shouldn't it be the case that `mark_static_initialized` has already\n-    // interned this?  I thought that is the entire point of that `FinishStatic` stuff?\n-    let alloc = ecx.tcx.intern_const_alloc(alloc);\n-    let val = ConstValue::ByRef(ptr, alloc);\n-    ecx.tcx.mk_const(ty::Const { val, ty: mplace.layout.ty })\n-}\n-\n fn op_to_const<'tcx>(\n     ecx: &CompileTimeEvalContext<'_, 'tcx>,\n     op: OpTy<'tcx>,\n ) -> &'tcx ty::Const<'tcx> {\n-    // We do not normalize just any data.  Only non-union scalars and slices.\n-    let normalize = match op.layout.abi {\n-        layout::Abi::Scalar(..) => op.layout.ty.ty_adt_def().map_or(true, |adt| !adt.is_union()),\n+    // We do not have value optmizations for everything.\n+    // Only scalars and slices, since they are very common.\n+    // Note that further down we turn scalars of undefined bits back to `ByRef`. These can result\n+    // from scalar unions that are initialized with one of their zero sized variants. We could\n+    // instead allow `ConstValue::Scalar` to store `ScalarMaybeUndef`, but that would affect all\n+    // the usual cases of extracting e.g. a `usize`, without there being a real use case for the\n+    // `Undef` situation.\n+    let try_as_immediate = match op.layout.abi {\n+        layout::Abi::Scalar(..) => true,\n         layout::Abi::ScalarPair(..) => match op.layout.ty.sty {\n             ty::Ref(_, inner, _) => match inner.sty {\n                 ty::Slice(elem) => elem == ecx.tcx.types.u8,\n@@ -100,16 +85,38 @@ fn op_to_const<'tcx>(\n         },\n         _ => false,\n     };\n-    let normalized_op = if normalize {\n-        Err(*ecx.read_immediate(op).expect(\"normalization works on validated constants\"))\n+    let immediate = if try_as_immediate {\n+        Err(ecx.read_immediate(op).expect(\"normalization works on validated constants\"))\n     } else {\n+        // It is guaranteed that any non-slice scalar pair is actually ByRef here.\n+        // When we come back from raw const eval, we are always by-ref. The only way our op here is\n+        // by-val is if we are in const_field, i.e., if this is (a field of) something that we\n+        // \"tried to make immediate\" before. We wouldn't do that for non-slice scalar pairs or\n+        // structs containing such.\n         op.try_as_mplace()\n     };\n-    let val = match normalized_op {\n-        Ok(mplace) => return mplace_to_const(ecx, mplace),\n-        Err(Immediate::Scalar(x)) =>\n-            ConstValue::Scalar(x.not_undef().unwrap()),\n-        Err(Immediate::ScalarPair(a, b)) => {\n+    let val = match immediate {\n+        Ok(mplace) => {\n+            let ptr = mplace.ptr.to_ptr().unwrap();\n+            let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n+            ConstValue::ByRef(ptr, alloc)\n+        },\n+        // see comment on `let try_as_immediate` above\n+        Err(ImmTy { imm: Immediate::Scalar(x), .. }) => match x {\n+            ScalarMaybeUndef::Scalar(s) => ConstValue::Scalar(s),\n+            ScalarMaybeUndef::Undef => {\n+                // When coming out of \"normal CTFE\", we'll always have an `Indirect` operand as\n+                // argument and we will not need this. The only way we can already have an\n+                // `Immediate` is when we are called from `const_field`, and that `Immediate`\n+                // comes from a constant so it can happen have `Undef`, because the indirect\n+                // memory that was read had undefined bytes.\n+                let mplace = op.to_mem_place();\n+                let ptr = mplace.ptr.to_ptr().unwrap();\n+                let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n+                ConstValue::ByRef(ptr, alloc)\n+            },\n+        },\n+        Err(ImmTy { imm: Immediate::ScalarPair(a, b), .. }) => {\n             let (data, start) = match a.not_undef().unwrap() {\n                 Scalar::Ptr(ptr) => (\n                     ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n@@ -164,13 +171,12 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     ecx.run()?;\n \n     // Intern the result\n-    let mutability = if tcx.is_mutable_static(cid.instance.def_id()) ||\n-                     !layout.ty.is_freeze(tcx, param_env, body.span) {\n-        Mutability::Mutable\n-    } else {\n-        Mutability::Immutable\n-    };\n-    ecx.memory.intern_static(ret.ptr.to_ptr()?.alloc_id, mutability)?;\n+    intern_const_alloc_recursive(\n+        ecx,\n+        cid.instance.def_id(),\n+        ret,\n+        param_env,\n+    )?;\n \n     debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n     Ok(ret)\n@@ -297,7 +303,7 @@ impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n     }\n }\n \n-type CompileTimeEvalContext<'mir, 'tcx> =\n+crate type CompileTimeEvalContext<'mir, 'tcx> =\n     InterpretCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>;\n \n impl interpret::MayLeak for ! {\n@@ -526,13 +532,16 @@ fn validate_and_turn_into_const<'tcx>(\n                 mplace.into(),\n                 path,\n                 Some(&mut ref_tracking),\n-                true, // const mode\n             )?;\n         }\n         // Now that we validated, turn this into a proper constant.\n         let def_id = cid.instance.def.def_id();\n         if tcx.is_static(def_id) || cid.promoted.is_some() {\n-            Ok(mplace_to_const(&ecx, mplace))\n+            let ptr = mplace.ptr.to_ptr()?;\n+            Ok(tcx.mk_const(ty::Const {\n+                val: ConstValue::ByRef(ptr, ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id)),\n+                ty: mplace.layout.ty,\n+            }))\n         } else {\n             Ok(op_to_const(&ecx, mplace.into()))\n         }"}, {"sha": "4afa4a0cbb3d74bba5810c1b7033fb04dfd21659", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=4b6f3868b3e1bdb5193cc240664f046bc18ca6a4", "patch": "@@ -576,7 +576,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n                     self.place_to_op(return_place)?,\n                     vec![],\n                     None,\n-                    /*const_mode*/false,\n                 )?;\n             }\n         } else {"}, {"sha": "47dcde95ca55be19353aa7567e9fb1dbddb2b303", "filename": "src/librustc_mir/interpret/intern.rs", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=4b6f3868b3e1bdb5193cc240664f046bc18ca6a4", "patch": "@@ -0,0 +1,326 @@\n+//! This module specifies the type based interner for constants.\n+//!\n+//! After a const evaluation has computed a value, before we destroy the const evaluator's session\n+//! memory, we need to extract all memory allocations to the global memory pool so they stay around.\n+\n+use rustc::ty::layout::LayoutOf;\n+use rustc::ty::{Ty, TyCtxt, ParamEnv, self};\n+use rustc::mir::interpret::{\n+    EvalResult, ErrorHandled,\n+};\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use super::validity::RefTracking;\n+use rustc_data_structures::fx::FxHashSet;\n+\n+use syntax::ast::Mutability;\n+use syntax_pos::Span;\n+\n+use super::{\n+    ValueVisitor, MemoryKind, Pointer, AllocId, MPlaceTy, InterpError, Scalar,\n+};\n+use crate::const_eval::{CompileTimeInterpreter, CompileTimeEvalContext};\n+\n+struct InternVisitor<'rt, 'a: 'rt, 'mir: 'rt, 'tcx: 'a+'rt+'mir> {\n+    /// previously encountered safe references\n+    ref_tracking: &'rt mut RefTracking<(MPlaceTy<'tcx>, Mutability, InternMode)>,\n+    ecx: &'rt mut CompileTimeEvalContext<'a, 'mir, 'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    /// The root node of the value that we're looking at. This field is never mutated and only used\n+    /// for sanity assertions that will ICE when `const_qualif` screws up.\n+    mode: InternMode,\n+    /// This field stores the mutability of the value *currently* being checked.\n+    /// It is set to mutable when an `UnsafeCell` is encountered\n+    /// When recursing across a reference, we don't recurse but store the\n+    /// value to be checked in `ref_tracking` together with the mutability at which we are checking\n+    /// the value.\n+    /// When encountering an immutable reference, we treat everything as immutable that is behind\n+    /// it.\n+    mutability: Mutability,\n+    /// A list of all encountered relocations. After type-based interning, we traverse this list to\n+    /// also intern allocations that are only referenced by a raw pointer or inside a union.\n+    leftover_relocations: &'rt mut FxHashSet<AllocId>,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Hash, Eq)]\n+enum InternMode {\n+    /// Mutable references don't change the `mutability` field to `Immutable`\n+    StaticMut,\n+    /// Mutable references must in fact be immutable due to their surrounding immutability\n+    Static,\n+    /// UnsafeCell is OK in the value of a constant, but not behind references in a constant\n+    ConstBase,\n+    /// `UnsafeCell` ICEs\n+    Const,\n+}\n+\n+/// Signalling data structure to ensure we don't recurse\n+/// into the memory of other constants or statics\n+struct IsStaticOrFn;\n+\n+impl<'rt, 'a, 'mir, 'tcx> InternVisitor<'rt, 'a, 'mir, 'tcx> {\n+    fn intern(\n+        &mut self,\n+        ptr: Pointer,\n+        mutability: Mutability,\n+    ) -> EvalResult<'tcx, Option<IsStaticOrFn>> {\n+        trace!(\n+            \"InternVisitor::intern {:?} with {:?}\",\n+            ptr, mutability,\n+        );\n+        // remove allocation\n+        let tcx = self.ecx.tcx;\n+        let memory = self.ecx.memory_mut();\n+        let (kind, mut alloc) = match memory.alloc_map.remove(&ptr.alloc_id) {\n+            Some(entry) => entry,\n+            None => {\n+                // if the pointer is dangling (neither in local nor global memory), we leave it\n+                // to validation to error. The `delay_span_bug` ensures that we don't forget such\n+                // a check in validation.\n+                if tcx.alloc_map.lock().get(ptr.alloc_id).is_none() {\n+                    tcx.sess.delay_span_bug(self.ecx.tcx.span, \"tried to intern dangling pointer\");\n+                }\n+                // treat dangling pointers like other statics\n+                // just to stop trying to recurse into them\n+                return Ok(Some(IsStaticOrFn));\n+            },\n+        };\n+        // This match is just a canary for future changes to `MemoryKind`, which most likely need\n+        // changes in this function.\n+        match kind {\n+            MemoryKind::Stack | MemoryKind::Vtable => {},\n+        }\n+        // Ensure llvm knows to only put this into immutable memory if the value is immutable either\n+        // by being behind a reference or by being part of a static or const without interior\n+        // mutability\n+        alloc.mutability = mutability;\n+        // link the alloc id to the actual allocation\n+        let alloc = tcx.intern_const_alloc(alloc);\n+        self.leftover_relocations.extend(alloc.relocations.iter().map(|&(_, ((), reloc))| reloc));\n+        tcx.alloc_map.lock().set_alloc_id_memory(ptr.alloc_id, alloc);\n+        Ok(None)\n+    }\n+}\n+\n+impl<'rt, 'a, 'mir, 'tcx>\n+    ValueVisitor<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>\n+for\n+    InternVisitor<'rt, 'a, 'mir, 'tcx>\n+{\n+    type V = MPlaceTy<'tcx>;\n+\n+    #[inline(always)]\n+    fn ecx(&self) -> &CompileTimeEvalContext<'a, 'mir, 'tcx> {\n+        &self.ecx\n+    }\n+\n+    fn visit_aggregate(\n+        &mut self,\n+        mplace: MPlaceTy<'tcx>,\n+        fields: impl Iterator<Item=EvalResult<'tcx, Self::V>>,\n+    ) -> EvalResult<'tcx> {\n+        if let Some(def) = mplace.layout.ty.ty_adt_def() {\n+            if Some(def.did) == self.ecx.tcx.lang_items().unsafe_cell_type() {\n+                // We are crossing over an `UnsafeCell`, we can mutate again\n+                let old = std::mem::replace(&mut self.mutability, Mutability::Mutable);\n+                assert_ne!(\n+                    self.mode, InternMode::Const,\n+                    \"UnsafeCells are not allowed behind references in constants. This should have \\\n+                    been prevented statically by const qualification. If this were allowed one \\\n+                    would be able to change a constant at one use site and other use sites may \\\n+                    arbitrarily decide to change, too.\",\n+                );\n+                let walked = self.walk_aggregate(mplace, fields);\n+                self.mutability = old;\n+                return walked;\n+            }\n+        }\n+        self.walk_aggregate(mplace, fields)\n+    }\n+\n+    fn visit_primitive(&mut self, mplace: MPlaceTy<'tcx>) -> EvalResult<'tcx> {\n+        // Handle Reference types, as these are the only relocations supported by const eval.\n+        // Raw pointers (and boxes) are handled by the `leftover_relocations` logic.\n+        let ty = mplace.layout.ty;\n+        if let ty::Ref(_, _, mutability) = ty.sty {\n+            let value = self.ecx.read_immediate(mplace.into())?;\n+            // Handle trait object vtables\n+            if let Ok(meta) = value.to_meta() {\n+                let layout = self.ecx.layout_of(ty.builtin_deref(true).unwrap().ty)?;\n+                if layout.is_unsized() {\n+                    if let ty::Dynamic(..) = self.ecx.tcx.struct_tail(layout.ty).sty {\n+                        if let Ok(vtable) = meta.unwrap().to_ptr() {\n+                            // explitly choose `Immutable` here, since vtables are immutable, even\n+                            // if the reference of the fat pointer is mutable\n+                            self.intern(vtable, Mutability::Immutable)?;\n+                        }\n+                    }\n+                }\n+            }\n+            let mplace = self.ecx.ref_to_mplace(value)?;\n+            // Check if we have encountered this pointer+layout combination before.\n+            // Only recurse for allocation-backed pointers.\n+            if let Scalar::Ptr(ptr) = mplace.ptr {\n+                // In the future we will probably allow `& &mut T`, and thus will want to merge\n+                // `mutability` with `self.mutability` to only choose `Mutable` if both are\n+                // `Mutable`.\n+\n+                // We do not have any `frozen` logic here, because it's essentially equivalent to\n+                // the mutability except for the outermost item. Only `UnsafeCell` can \"unfreeze\",\n+                // and we check that in `visit_aggregate`.\n+                match (self.mode, mutability) {\n+                    // all is \"good and well\" in the unsoundness of `static mut`\n+                    (InternMode::StaticMut, _) => {},\n+                    // immutable references are fine everywhere\n+                    (_, hir::Mutability::MutImmutable) => {},\n+                    // mutable references are ok in `static`. Either they are treated as immutable\n+                    // because they are behind an immutable one, or they are behind an `UnsafeCell`\n+                    // and thus ok.\n+                    (InternMode::Static, hir::Mutability::MutMutable) => {},\n+                    // we statically prevent `&mut T` via `const_qualif` and double check this here\n+                    (InternMode::ConstBase, hir::Mutability::MutMutable) |\n+                    (InternMode::Const, hir::Mutability::MutMutable) =>\n+                        bug!(\"const qualif failed to prevent mutable references\"),\n+                }\n+                let mutability = match (self.mutability, mutability) {\n+                    // The only way a mutable reference actually works as a mutable reference is\n+                    // by being in a `static mut` directly or behind another mutable reference.\n+                    // If there's an immutable reference or we are inside a static, then our\n+                    // mutable reference is equivalent to an immutable one. As an example:\n+                    // `&&mut Foo` is semantically equivalent to `&&Foo`\n+                    (Mutability::Mutable, hir::Mutability::MutMutable) => Mutability::Mutable,\n+                    _ => Mutability::Immutable,\n+                };\n+                let intern_mutability = intern_mutability(\n+                    self.ecx.tcx.tcx,\n+                    self.param_env,\n+                    mplace.layout.ty,\n+                    self.ecx.tcx.span,\n+                    mutability,\n+                );\n+                // Recursing behind references changes the intern mode for constants in order to\n+                // cause assertions to trigger if we encounter any `UnsafeCell`s.\n+                let mode = match self.mode {\n+                    InternMode::ConstBase => InternMode::Const,\n+                    other => other,\n+                };\n+                match self.intern(ptr, intern_mutability)? {\n+                    // No need to recurse, these are interned already and statics may have\n+                    // cycles, so we don't want to recurse there\n+                    Some(IsStaticOrFn) => {},\n+                    // intern everything referenced by this value. The mutability is taken from the\n+                    // reference. It is checked above that mutable references only happen in\n+                    // `static mut`\n+                    None => self.ref_tracking.track((mplace, mutability, mode), || ()),\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+/// Figure out the mutability of the allocation.\n+/// Mutable if it has interior mutability *anywhere* in the type.\n+fn intern_mutability<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    ty: Ty<'tcx>,\n+    span: Span,\n+    mutability: Mutability,\n+) -> Mutability {\n+    let has_interior_mutability = !ty.is_freeze(tcx, param_env, span);\n+    if has_interior_mutability {\n+        Mutability::Mutable\n+    } else {\n+        mutability\n+    }\n+}\n+\n+pub fn intern_const_alloc_recursive(\n+    ecx: &mut CompileTimeEvalContext<'a, 'mir, 'tcx>,\n+    def_id: DefId,\n+    ret: MPlaceTy<'tcx>,\n+    // FIXME(oli-obk): can we scrap the param env? I think we can, the final value of a const eval\n+    // must always be monomorphic, right?\n+    param_env: ty::ParamEnv<'tcx>,\n+) -> EvalResult<'tcx> {\n+    let tcx = ecx.tcx;\n+    let (mutability, base_intern_mode) = match tcx.static_mutability(def_id) {\n+        Some(hir::Mutability::MutImmutable) => (Mutability::Immutable, InternMode::Static),\n+        None => (Mutability::Immutable, InternMode::ConstBase),\n+        // `static mut` doesn't care about interior mutability, it's mutable anyway\n+        Some(hir::Mutability::MutMutable) => (Mutability::Mutable, InternMode::StaticMut),\n+    };\n+\n+    // type based interning\n+    let mut ref_tracking = RefTracking::new((ret, mutability, base_intern_mode));\n+    let leftover_relocations = &mut FxHashSet::default();\n+\n+    let alloc_mutability = intern_mutability(\n+        tcx.tcx, param_env, ret.layout.ty, tcx.span, mutability,\n+    );\n+\n+    // start with the outermost allocation\n+    InternVisitor {\n+        ref_tracking: &mut ref_tracking,\n+        ecx,\n+        mode: base_intern_mode,\n+        leftover_relocations,\n+        param_env,\n+        mutability,\n+    }.intern(ret.ptr.to_ptr()?, alloc_mutability)?;\n+\n+    while let Some(((mplace, mutability, mode), _)) = ref_tracking.todo.pop() {\n+        let interned = InternVisitor {\n+            ref_tracking: &mut ref_tracking,\n+            ecx,\n+            mode,\n+            leftover_relocations,\n+            param_env,\n+            mutability,\n+        }.visit_value(mplace);\n+        if let Err(error) = interned {\n+            // This can happen when e.g. the tag of an enum is not a valid discriminant. We do have\n+            // to read enum discriminants in order to find references in enum variant fields.\n+            if let InterpError::ValidationFailure(_) = error.kind {\n+                let err = crate::const_eval::error_to_const_error(&ecx, error);\n+                match err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\") {\n+                    Ok(mut diag) => {\n+                        diag.note(\"The rules on what exactly is undefined behavior aren't clear, \\\n+                            so this check might be overzealous. Please open an issue on the rust \\\n+                            compiler repository if you believe it should not be considered \\\n+                            undefined behavior\",\n+                        );\n+                        diag.emit();\n+                    }\n+                    Err(ErrorHandled::TooGeneric) |\n+                    Err(ErrorHandled::Reported) => {},\n+                }\n+            }\n+        }\n+    }\n+\n+    // Intern the rest of the allocations as mutable. These might be inside unions, padding, raw\n+    // pointers, ... So we can't intern them according to their type rules\n+\n+    let mut todo: Vec<_> = leftover_relocations.iter().cloned().collect();\n+    while let Some(alloc_id) = todo.pop() {\n+        if let Some((_, alloc)) = ecx.memory_mut().alloc_map.remove(&alloc_id) {\n+            // We can't call the `intern` method here, as its logic is tailored to safe references.\n+            // So we hand-roll the interning logic here again\n+            let alloc = tcx.intern_const_alloc(alloc);\n+            tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n+            for &(_, ((), reloc)) in alloc.relocations.iter() {\n+                if leftover_relocations.insert(reloc) {\n+                    todo.push(reloc);\n+                }\n+            }\n+        } else if ecx.memory().dead_alloc_map.contains_key(&alloc_id) {\n+            // dangling pointer\n+            return err!(ValidationFailure(\n+                \"encountered dangling pointer in final constant\".into(),\n+            ))\n+        }\n+    }\n+    Ok(())\n+}"}, {"sha": "a78c5a64894bf12eb8994d1bc680522411b5ab8c", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 18, "deletions": 60, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=4b6f3868b3e1bdb5193cc240664f046bc18ca6a4", "patch": "@@ -20,6 +20,7 @@ use super::{\n     Pointer, AllocId, Allocation, GlobalId, AllocationExtra,\n     InterpResult, Scalar, InterpError, GlobalAlloc, PointerArithmetic,\n     Machine, AllocMap, MayLeak, ErrorHandled, CheckInAllocMsg, InboundsCheck,\n+    InterpError::ValidationFailure,\n };\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n@@ -55,12 +56,12 @@ pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// the wrong type), so we let the machine override this type.\n     /// Either way, if the machine allows writing to a static, doing so will\n     /// create a copy of the static allocation here.\n-    alloc_map: M::MemoryMap,\n+    pub(super) alloc_map: M::MemoryMap,\n \n     /// To be able to compare pointers with NULL, and to check alignment for accesses\n     /// to ZSTs (where pointers may dangle), we keep track of the size even for allocations\n     /// that do not exist any more.\n-    dead_alloc_map: FxHashMap<AllocId, (Size, Align)>,\n+    pub(super) dead_alloc_map: FxHashMap<AllocId, (Size, Align)>,\n \n     /// Extra data added by the machine.\n     pub extra: M::MemoryExtra,\n@@ -455,6 +456,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // Could also be a fn ptr or extern static\n         match self.tcx.alloc_map.lock().get(id) {\n             Some(GlobalAlloc::Function(..)) => Ok((Size::ZERO, Align::from_bytes(1).unwrap())),\n+            // `self.get` would also work, but can cause cycles if a static refers to itself\n             Some(GlobalAlloc::Static(did)) => {\n                 // The only way `get` couldn't have worked here is if this is an extern static\n                 assert!(self.tcx.is_foreign_item(did));\n@@ -463,14 +465,20 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 let layout = self.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n                 Ok((layout.size, layout.align.abi))\n             }\n-            _ => match liveness {\n-                InboundsCheck::MaybeDead => {\n-                    // Must be a deallocated pointer\n-                    Ok(*self.dead_alloc_map.get(&id).expect(\n-                        \"allocation missing in dead_alloc_map\"\n-                    ))\n-                },\n-                InboundsCheck::Live => err!(DanglingPointerDeref),\n+            _ => {\n+                if let Ok(alloc) = self.get(id) {\n+                    return Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align));\n+                }\n+                match liveness {\n+                    InboundsCheck::MaybeDead => {\n+                        // Must be a deallocated pointer\n+                        self.dead_alloc_map.get(&id).cloned().ok_or_else(||\n+                            ValidationFailure(\"allocation missing in dead_alloc_map\".to_string())\n+                                .into()\n+                        )\n+                    },\n+                    InboundsCheck::Live => err!(DanglingPointerDeref),\n+                }\n             },\n         }\n     }\n@@ -633,56 +641,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n }\n \n-/// Interning (for CTFE)\n-impl<'mir, 'tcx, M> Memory<'mir, 'tcx, M>\n-where\n-    M: Machine<'mir, 'tcx, PointerTag = (), AllocExtra = (), MemoryExtra = ()>,\n-    // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n-    M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation)>,\n-{\n-    /// mark an allocation as static and initialized, either mutable or not\n-    pub fn intern_static(\n-        &mut self,\n-        alloc_id: AllocId,\n-        mutability: Mutability,\n-    ) -> InterpResult<'tcx> {\n-        trace!(\n-            \"mark_static_initialized {:?}, mutability: {:?}\",\n-            alloc_id,\n-            mutability\n-        );\n-        // remove allocation\n-        let (kind, mut alloc) = self.alloc_map.remove(&alloc_id).unwrap();\n-        match kind {\n-            MemoryKind::Machine(_) => bug!(\"Static cannot refer to machine memory\"),\n-            MemoryKind::Stack | MemoryKind::Vtable => {},\n-        }\n-        // ensure llvm knows not to put this into immutable memory\n-        alloc.mutability = mutability;\n-        let alloc = self.tcx.intern_const_alloc(alloc);\n-        self.tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n-        // recurse into inner allocations\n-        for &(_, alloc) in alloc.relocations.values() {\n-            // FIXME: Reusing the mutability here is likely incorrect.  It is originally\n-            // determined via `is_freeze`, and data is considered frozen if there is no\n-            // `UnsafeCell` *immediately* in that data -- however, this search stops\n-            // at references.  So whenever we follow a reference, we should likely\n-            // assume immutability -- and we should make sure that the compiler\n-            // does not permit code that would break this!\n-            if self.alloc_map.contains_key(&alloc) {\n-                // Not yet interned, so proceed recursively\n-                self.intern_static(alloc, mutability)?;\n-            } else if self.dead_alloc_map.contains_key(&alloc) {\n-                // dangling pointer\n-                return err!(ValidationFailure(\n-                    \"encountered dangling pointer in final constant\".into(),\n-                ))\n-            }\n-        }\n-        Ok(())\n-    }\n-}\n-\n /// Reading and writing.\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn copy("}, {"sha": "0293a8366d0837b6e84d904ca4817d1ac8f2f5ee", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=4b6f3868b3e1bdb5193cc240664f046bc18ca6a4", "patch": "@@ -14,6 +14,7 @@ mod traits;\n mod validity;\n mod intrinsics;\n mod visitor;\n+mod intern;\n \n pub use rustc::mir::interpret::*; // have all the `interpret` symbols in one place: here\n \n@@ -34,3 +35,5 @@ pub use self::visitor::{ValueVisitor, MutValueVisitor};\n pub use self::validity::RefTracking;\n \n pub(super) use self::intrinsics::type_name;\n+\n+pub use self::intern::intern_const_alloc_recursive;"}, {"sha": "ad841a57e7870ac8af8089f5ee0d1f2853654136", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=4b6f3868b3e1bdb5193cc240664f046bc18ca6a4", "patch": "@@ -217,7 +217,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     fn try_read_immediate_from_mplace(\n         &self,\n         mplace: MPlaceTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, Option<Immediate<M::PointerTag>>> {\n+    ) -> InterpResult<'tcx, Option<ImmTy<'tcx, M::PointerTag>>> {\n         if mplace.layout.is_unsized() {\n             // Don't touch unsized\n             return Ok(None);\n@@ -228,7 +228,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n             // Not all ZSTs have a layout we would handle below, so just short-circuit them\n             // all here.\n             self.memory.check_align(ptr, ptr_align)?;\n-            return Ok(Some(Immediate::Scalar(Scalar::zst().into())));\n+            return Ok(Some(ImmTy {\n+                imm: Immediate::Scalar(Scalar::zst().into()),\n+                layout: mplace.layout,\n+            }));\n         }\n \n         // check for integer pointers before alignment to report better errors\n@@ -239,7 +242,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n                 let scalar = self.memory\n                     .get(ptr.alloc_id)?\n                     .read_scalar(self, ptr, mplace.layout.size)?;\n-                Ok(Some(Immediate::Scalar(scalar)))\n+                Ok(Some(ImmTy {\n+                    imm: Immediate::Scalar(scalar),\n+                    layout: mplace.layout,\n+                }))\n             }\n             layout::Abi::ScalarPair(ref a, ref b) => {\n                 let (a, b) = (&a.value, &b.value);\n@@ -256,7 +262,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n                 let b_val = self.memory\n                     .get(ptr.alloc_id)?\n                     .read_scalar(self, b_ptr, b_size)?;\n-                Ok(Some(Immediate::ScalarPair(a_val, b_val)))\n+                Ok(Some(ImmTy {\n+                    imm: Immediate::ScalarPair(a_val, b_val),\n+                    layout: mplace.layout,\n+                }))\n             }\n             _ => Ok(None),\n         }\n@@ -271,13 +280,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     pub(crate) fn try_read_immediate(\n         &self,\n         src: OpTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, Result<Immediate<M::PointerTag>, MemPlace<M::PointerTag>>> {\n+    ) -> InterpResult<'tcx, Result<ImmTy<'tcx, M::PointerTag>, MPlaceTy<'tcx, M::PointerTag>>> {\n         Ok(match src.try_as_mplace() {\n             Ok(mplace) => {\n                 if let Some(val) = self.try_read_immediate_from_mplace(mplace)? {\n                     Ok(val)\n                 } else {\n-                    Err(*mplace)\n+                    Err(mplace)\n                 }\n             },\n             Err(val) => Ok(val),\n@@ -291,7 +300,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n         op: OpTy<'tcx, M::PointerTag>\n     ) -> InterpResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n         if let Ok(imm) = self.try_read_immediate(op)? {\n-            Ok(ImmTy { imm, layout: op.layout })\n+            Ok(imm)\n         } else {\n             bug!(\"primitive read failed for type: {:?}\", op.layout.ty);\n         }\n@@ -339,9 +348,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n             return Ok(OpTy { op: Operand::Immediate(immediate), layout: field_layout });\n         }\n         let offset = op.layout.fields.offset(field);\n-        let immediate = match base {\n+        let immediate = match *base {\n             // the field covers the entire type\n-            _ if offset.bytes() == 0 && field_layout.size == op.layout.size => base,\n+            _ if offset.bytes() == 0 && field_layout.size == op.layout.size => *base,\n             // extract fields from types with `ScalarPair` ABI\n             Immediate::ScalarPair(a, b) => {\n                 let val = if offset.bytes() == 0 { a } else { b };"}, {"sha": "a721cea85a245df6477ffa0ad0b8e6eb36002ab8", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=4b6f3868b3e1bdb5193cc240664f046bc18ca6a4", "patch": "@@ -232,10 +232,10 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n \n impl<'tcx, Tag: ::std::fmt::Debug + Copy> OpTy<'tcx, Tag> {\n     #[inline(always)]\n-    pub fn try_as_mplace(self) -> Result<MPlaceTy<'tcx, Tag>, Immediate<Tag>> {\n+    pub fn try_as_mplace(self) -> Result<MPlaceTy<'tcx, Tag>, ImmTy<'tcx, Tag>> {\n         match *self {\n             Operand::Indirect(mplace) => Ok(MPlaceTy { mplace, layout: self.layout }),\n-            Operand::Immediate(imm) => Err(imm),\n+            Operand::Immediate(imm) => Err(ImmTy { imm, layout: self.layout }),\n         }\n     }\n \n@@ -660,7 +660,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(self.place_to_op(dest)?, vec![], None, /*const_mode*/false)?;\n+            self.validate_operand(self.place_to_op(dest)?, vec![], None)?;\n         }\n \n         Ok(())\n@@ -809,7 +809,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(self.place_to_op(dest)?, vec![], None, /*const_mode*/false)?;\n+            self.validate_operand(self.place_to_op(dest)?, vec![], None)?;\n         }\n \n         Ok(())\n@@ -836,7 +836,7 @@ where\n                 // Yay, we got a value that we can write directly.\n                 // FIXME: Add a check to make sure that if `src` is indirect,\n                 // it does not overlap with `dest`.\n-                return self.write_immediate_no_validate(src_val, dest);\n+                return self.write_immediate_no_validate(*src_val, dest);\n             }\n             Err(mplace) => mplace,\n         };\n@@ -897,7 +897,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(dest.into(), vec![], None, /*const_mode*/false)?;\n+            self.validate_operand(dest.into(), vec![], None)?;\n         }\n \n         Ok(())"}, {"sha": "d747eddd8d7ba6fe62968a8d28589c9766d83ab1", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 56, "deletions": 31, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=4b6f3868b3e1bdb5193cc240664f046bc18ca6a4", "patch": "@@ -1,5 +1,4 @@\n use std::fmt::Write;\n-use std::hash::Hash;\n use std::ops::RangeInclusive;\n \n use syntax_pos::symbol::{sym, Symbol};\n@@ -11,6 +10,8 @@ use rustc::mir::interpret::{\n     Scalar, GlobalAlloc, InterpResult, InterpError, CheckInAllocMsg,\n };\n \n+use std::hash::Hash;\n+\n use super::{\n     OpTy, Machine, InterpretCx, ValueVisitor, MPlaceTy,\n };\n@@ -76,19 +77,34 @@ pub enum PathElem {\n }\n \n /// State for tracking recursive validation of references\n-pub struct RefTracking<T> {\n+pub struct RefTracking<T, PATH = ()> {\n     pub seen: FxHashSet<T>,\n-    pub todo: Vec<(T, Vec<PathElem>)>,\n+    pub todo: Vec<(T, PATH)>,\n }\n \n-impl<T: Copy + Eq + Hash> RefTracking<T> {\n+impl<T: Copy + Eq + Hash + std::fmt::Debug, PATH: Default> RefTracking<T, PATH> {\n+    pub fn empty() -> Self {\n+        RefTracking {\n+            seen: FxHashSet::default(),\n+            todo: vec![],\n+        }\n+    }\n     pub fn new(op: T) -> Self {\n-        let mut ref_tracking = RefTracking {\n+        let mut ref_tracking_for_consts = RefTracking {\n             seen: FxHashSet::default(),\n-            todo: vec![(op, Vec::new())],\n+            todo: vec![(op, PATH::default())],\n         };\n-        ref_tracking.seen.insert(op);\n-        ref_tracking\n+        ref_tracking_for_consts.seen.insert(op);\n+        ref_tracking_for_consts\n+    }\n+\n+    pub fn track(&mut self, op: T, path: impl FnOnce() -> PATH) {\n+        if self.seen.insert(op) {\n+            trace!(\"Recursing below ptr {:#?}\", op);\n+            let path = path();\n+            // Remember to come back to this later.\n+            self.todo.push((op, path));\n+        }\n     }\n }\n \n@@ -154,8 +170,10 @@ struct ValidityVisitor<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// starts must not be changed!  `visit_fields` and `visit_array` rely on\n     /// this stack discipline.\n     path: Vec<PathElem>,\n-    ref_tracking: Option<&'rt mut RefTracking<MPlaceTy<'tcx, M::PointerTag>>>,\n-    const_mode: bool,\n+    ref_tracking_for_consts: Option<&'rt mut RefTracking<\n+        MPlaceTy<'tcx, M::PointerTag>,\n+        Vec<PathElem>,\n+    >>,\n     ecx: &'rt InterpretCx<'mir, 'tcx, M>,\n }\n \n@@ -314,7 +332,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // types below!\n                 let size = value.layout.size;\n                 let value = value.to_scalar_or_undef();\n-                if self.const_mode {\n+                if self.ref_tracking_for_consts.is_some() {\n                     // Integers/floats in CTFE: Must be scalar bits, pointers are dangerous\n                     try_validation!(value.to_bits(size),\n                         value, self.path, \"initialized plain (non-pointer) bytes\");\n@@ -324,7 +342,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 }\n             }\n             ty::RawPtr(..) => {\n-                if self.const_mode {\n+                if self.ref_tracking_for_consts.is_some() {\n                     // Integers/floats in CTFE: For consistency with integers, we do not\n                     // accept undef.\n                     let _ptr = try_validation!(value.to_scalar_ptr(),\n@@ -393,8 +411,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     }\n                 }\n                 // Recursive checking\n-                if let Some(ref mut ref_tracking) = self.ref_tracking {\n-                    assert!(self.const_mode, \"We should only do recursie checking in const mode\");\n+                if let Some(ref mut ref_tracking) = self.ref_tracking_for_consts {\n                     let place = self.ecx.ref_to_mplace(value)?;\n                     // FIXME(RalfJ): check ZST for inbound pointers\n                     if size != Size::ZERO {\n@@ -424,16 +441,15 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     // before.  Proceed recursively even for integer pointers, no\n                     // reason to skip them! They are (recursively) valid for some ZST,\n                     // but not for others (e.g., `!` is a ZST).\n-                    if ref_tracking.seen.insert(place) {\n-                        trace!(\"Recursing below ptr {:#?}\", *place);\n+                    let path = &self.path;\n+                    ref_tracking.track(place, || {\n                         // We need to clone the path anyway, make sure it gets created\n                         // with enough space for the additional `Deref`.\n-                        let mut new_path = Vec::with_capacity(self.path.len()+1);\n-                        new_path.clone_from(&self.path);\n+                        let mut new_path = Vec::with_capacity(path.len() + 1);\n+                        new_path.clone_from(path);\n                         new_path.push(PathElem::Deref);\n-                        // Remember to come back to this later.\n-                        ref_tracking.todo.push((place, new_path));\n-                    }\n+                        new_path\n+                    });\n                 }\n             }\n             ty::FnPtr(_sig) => {\n@@ -489,10 +505,17 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     let non_null =\n                         self.ecx.memory.check_align(\n                             Scalar::Ptr(ptr), Align::from_bytes(1).unwrap()\n-                        ).is_ok() ||\n-                        self.ecx.memory.get_fn(ptr).is_ok();\n+                        ).is_ok();\n                     if !non_null {\n-                        // could be NULL\n+                        // These conditions are just here to improve the diagnostics so we can\n+                        // differentiate between null pointers and dangling pointers\n+                        if self.ref_tracking_for_consts.is_some() &&\n+                            self.ecx.memory.get(ptr.alloc_id).is_err() &&\n+                            self.ecx.memory.get_fn(ptr).is_err() {\n+                            return validation_failure!(\n+                                \"encountered dangling pointer\", self.path\n+                            );\n+                        }\n                         return validation_failure!(\"a potentially NULL pointer\", self.path);\n                     }\n                     return Ok(());\n@@ -575,7 +598,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     self.ecx,\n                     ptr,\n                     size,\n-                    /*allow_ptr_and_undef*/!self.const_mode,\n+                    /*allow_ptr_and_undef*/ self.ref_tracking_for_consts.is_none(),\n                 ) {\n                     // In the happy case, we needn't check anything else.\n                     Ok(()) => {},\n@@ -613,23 +636,25 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     /// is an indirect operand.\n     /// It will error if the bits at the destination do not match the ones described by the layout.\n     ///\n-    /// `ref_tracking` can be `None` to avoid recursive checking below references.\n+    /// `ref_tracking_for_consts` can be `None` to avoid recursive checking below references.\n     /// This also toggles between \"run-time\" (no recursion) and \"compile-time\" (with recursion)\n-    /// validation (e.g., pointer values are fine in integers at runtime).\n+    /// validation (e.g., pointer values are fine in integers at runtime) and various other const\n+    /// specific validation checks\n     pub fn validate_operand(\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n         path: Vec<PathElem>,\n-        ref_tracking: Option<&mut RefTracking<MPlaceTy<'tcx, M::PointerTag>>>,\n-        const_mode: bool,\n+        ref_tracking_for_consts: Option<&mut RefTracking<\n+            MPlaceTy<'tcx, M::PointerTag>,\n+            Vec<PathElem>,\n+        >>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"validate_operand: {:?}, {:?}\", *op, op.layout.ty);\n \n         // Construct a visitor\n         let mut visitor = ValidityVisitor {\n             path,\n-            ref_tracking,\n-            const_mode,\n+            ref_tracking_for_consts,\n             ecx: self,\n         };\n "}, {"sha": "805f15e374724942ba5bc36442718ebe96412739", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=4b6f3868b3e1bdb5193cc240664f046bc18ca6a4", "patch": "@@ -551,7 +551,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         source_info: SourceInfo,\n     ) {\n         trace!(\"attepting to replace {:?} with {:?}\", rval, value);\n-        if let Err(e) = self.ecx.validate_operand(value, vec![], None, true) {\n+        if let Err(e) = self.ecx.validate_operand(\n+            value,\n+            vec![],\n+            // FIXME: is ref tracking too expensive?\n+            Some(&mut interpret::RefTracking::empty()),\n+        ) {\n             trace!(\"validation error, attempt failed: {:?}\", e);\n             return;\n         }"}, {"sha": "f082b5e5a046cfedd7a0dde7c5cdf93ad9a47cf1", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=4b6f3868b3e1bdb5193cc240664f046bc18ca6a4", "patch": "@@ -738,27 +738,29 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                 qualifs[IsNotPromotable] = true;\n \n                 if self.mode.requires_const_checking() {\n-                    if let BorrowKind::Mut { .. } = kind {\n-                        let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n-                                                       \"references in {}s may only refer \\\n-                                                        to immutable values\", self.mode);\n-                        err.span_label(self.span, format!(\"{}s require immutable values\",\n-                                                            self.mode));\n-                        if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                            err.note(\"References in statics and constants may only refer to \\\n-                                      immutable values.\\n\\n\\\n-                                      Statics are shared everywhere, and if they refer to \\\n-                                      mutable data one might violate memory safety since \\\n-                                      holding multiple mutable references to shared data is \\\n-                                      not allowed.\\n\\n\\\n-                                      If you really want global mutable state, try using \\\n-                                      static mut or a global UnsafeCell.\");\n+                    if !self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n+                        if let BorrowKind::Mut { .. } = kind {\n+                            let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n+                                                        \"references in {}s may only refer \\\n+                                                            to immutable values\", self.mode);\n+                            err.span_label(self.span, format!(\"{}s require immutable values\",\n+                                                                self.mode));\n+                            if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                                err.note(\"References in statics and constants may only refer to \\\n+                                        immutable values.\\n\\n\\\n+                                        Statics are shared everywhere, and if they refer to \\\n+                                        mutable data one might violate memory safety since \\\n+                                        holding multiple mutable references to shared data is \\\n+                                        not allowed.\\n\\n\\\n+                                        If you really want global mutable state, try using \\\n+                                        static mut or a global UnsafeCell.\");\n+                            }\n+                            err.emit();\n+                        } else {\n+                            span_err!(self.tcx.sess, self.span, E0492,\n+                                    \"cannot borrow a constant which may contain \\\n+                                    interior mutability, create a static instead\");\n                         }\n-                        err.emit();\n-                    } else {\n-                        span_err!(self.tcx.sess, self.span, E0492,\n-                                  \"cannot borrow a constant which may contain \\\n-                                   interior mutability, create a static instead\");\n                     }\n                 }\n             } else if let BorrowKind::Mut { .. } | BorrowKind::Shared = kind {"}, {"sha": "5f9888053a1965e1e0c1b1c753bc59e16588131c", "filename": "src/test/ui/consts/miri_unleashed/mutable_references.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.rs?ref=4b6f3868b3e1bdb5193cc240664f046bc18ca6a4", "patch": "@@ -0,0 +1,35 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+#![allow(const_err)]\n+\n+use std::cell::UnsafeCell;\n+\n+// a test demonstrating what things we could allow with a smarter const qualification\n+\n+static FOO: &&mut u32 = &&mut 42;\n+\n+static BAR: &mut () = &mut ();\n+\n+struct Foo<T>(T);\n+\n+static BOO: &mut Foo<()> = &mut Foo(());\n+\n+struct Meh {\n+    x: &'static UnsafeCell<i32>,\n+}\n+\n+unsafe impl Sync for Meh {}\n+\n+static MEH: Meh = Meh {\n+    x: &UnsafeCell::new(42),\n+};\n+\n+static OH_YES: &mut i32 = &mut 42;\n+\n+fn main() {\n+    unsafe {\n+        *MEH.x.get() = 99; //~ WARN skipping const checks\n+        //~^ WARN skipping const checks\n+    }\n+    *OH_YES = 99; //~ ERROR cannot assign to `*OH_YES`, as `OH_YES` is an immutable static item\n+    //~^ WARN skipping const checks\n+}"}, {"sha": "b870aca640a0aea7abe6ca8ba8da834961415a3b", "filename": "src/test/ui/consts/miri_unleashed/mutable_references.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.stderr?ref=4b6f3868b3e1bdb5193cc240664f046bc18ca6a4", "patch": "@@ -0,0 +1,26 @@\n+warning: skipping const checks\n+  --> $DIR/mutable_references.rs:30:10\n+   |\n+LL |         *MEH.x.get() = 99;\n+   |          ^^^^^\n+\n+warning: skipping const checks\n+  --> $DIR/mutable_references.rs:30:9\n+   |\n+LL |         *MEH.x.get() = 99;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+warning: skipping const checks\n+  --> $DIR/mutable_references.rs:33:5\n+   |\n+LL |     *OH_YES = 99;\n+   |     ^^^^^^^^^^^^\n+\n+error[E0594]: cannot assign to `*OH_YES`, as `OH_YES` is an immutable static item\n+  --> $DIR/mutable_references.rs:33:5\n+   |\n+LL |     *OH_YES = 99;\n+   |     ^^^^^^^^^^^^ cannot assign\n+\n+error: aborting due to previous error\n+"}, {"sha": "4a77534c6c70ca3182551cd37552440292cf2111", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_ice.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.rs?ref=4b6f3868b3e1bdb5193cc240664f046bc18ca6a4", "patch": "@@ -0,0 +1,28 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+// failure-status: 101\n+// rustc-env:RUST_BACKTRACE=0\n+// normalize-stderr-test \"note: rustc 1.* running on .*\" -> \"note: rustc VERSION running on TARGET\"\n+// normalize-stderr-test \"note: compiler flags: .*\" -> \"note: compiler flags: FLAGS\"\n+\n+#![allow(const_err)]\n+\n+use std::cell::UnsafeCell;\n+\n+// this test ICEs to ensure that our mutability story is sound\n+\n+struct Meh {\n+    x: &'static UnsafeCell<i32>,\n+}\n+\n+unsafe impl Sync for Meh {}\n+\n+// the following will never be ok!\n+const MUH: Meh = Meh {\n+    x: &UnsafeCell::new(42),\n+};\n+\n+fn main() {\n+    unsafe {\n+        *MUH.x.get() = 99; //~ WARN skipping const checks\n+    }\n+}"}, {"sha": "efb175f445d955c24a89e37050bf58116618b28f", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_ice.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.stderr?ref=4b6f3868b3e1bdb5193cc240664f046bc18ca6a4", "patch": "@@ -0,0 +1,21 @@\n+warning: skipping const checks\n+  --> $DIR/mutable_references_ice.rs:26:9\n+   |\n+LL |         *MUH.x.get() = 99;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+thread 'rustc' panicked at 'assertion failed: `(left != right)`\n+  left: `Const`,\n+ right: `Const`: UnsafeCells are not allowed behind references in constants. This should have been prevented statically by const qualification. If this were allowed one would be able to change a constant at one use site and other use sites may arbitrarily decide to change, too.', src/librustc_mir/interpret/intern.rs:126:17\n+note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n+\n+error: internal compiler error: unexpected panic\n+\n+note: the compiler unexpectedly panicked. this is a bug.\n+\n+note: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\n+\n+note: rustc VERSION running on TARGET\n+\n+note: compiler flags: FLAGS\n+"}, {"sha": "37ae45b6df7ea104f887a1bc613758fdef7dced7", "filename": "src/test/ui/consts/packed_pattern.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Ftest%2Fui%2Fconsts%2Fpacked_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Ftest%2Fui%2Fconsts%2Fpacked_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fpacked_pattern.rs?ref=4b6f3868b3e1bdb5193cc240664f046bc18ca6a4", "patch": "@@ -0,0 +1,19 @@\n+// run-pass\n+\n+#[derive(PartialEq, Eq, Copy, Clone)]\n+#[repr(packed)]\n+struct Foo {\n+    field: (i64, u32, u32, u32),\n+}\n+\n+const FOO: Foo = Foo {\n+    field: (5, 6, 7, 8),\n+};\n+\n+fn main() {\n+    match FOO {\n+        Foo { field: (5, 6, 7, 8) } => {},\n+        FOO => unreachable!(),\n+        _ => unreachable!(),\n+    }\n+}"}, {"sha": "cab60c91e165cc469afb01e7dac2cb050211d507", "filename": "src/test/ui/consts/static-raw-pointer-interning.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Ftest%2Fui%2Fconsts%2Fstatic-raw-pointer-interning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Ftest%2Fui%2Fconsts%2Fstatic-raw-pointer-interning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstatic-raw-pointer-interning.rs?ref=4b6f3868b3e1bdb5193cc240664f046bc18ca6a4", "patch": "@@ -0,0 +1,15 @@\n+// run-pass\n+\n+static FOO: Foo = Foo {\n+    field: &42 as *const i32,\n+};\n+\n+struct Foo {\n+    field: *const i32,\n+}\n+\n+unsafe impl Sync for Foo {}\n+\n+fn main() {\n+    assert_eq!(unsafe { *FOO.field }, 42);\n+}"}, {"sha": "2b915fd7cb3291c64a9fe316479e4fd78c1e3d83", "filename": "src/test/ui/consts/static-raw-pointer-interning2.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Ftest%2Fui%2Fconsts%2Fstatic-raw-pointer-interning2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Ftest%2Fui%2Fconsts%2Fstatic-raw-pointer-interning2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstatic-raw-pointer-interning2.rs?ref=4b6f3868b3e1bdb5193cc240664f046bc18ca6a4", "patch": "@@ -0,0 +1,15 @@\n+// run-pass\n+\n+static mut FOO: Foo = Foo {\n+    field: &mut [42] as *mut [i32] as *mut i32,\n+};\n+\n+struct Foo {\n+    field: *mut i32,\n+}\n+\n+unsafe impl Sync for Foo {}\n+\n+fn main() {\n+    assert_eq!(unsafe { *FOO.field = 69; *FOO.field }, 69);\n+}"}, {"sha": "16b05310b9fcb64c8291a09f0be33c64ddbbb708", "filename": "src/test/ui/consts/union_constant.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Ftest%2Fui%2Fconsts%2Funion_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b6f3868b3e1bdb5193cc240664f046bc18ca6a4/src%2Ftest%2Fui%2Fconsts%2Funion_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funion_constant.rs?ref=4b6f3868b3e1bdb5193cc240664f046bc18ca6a4", "patch": "@@ -6,5 +6,6 @@ union Uninit {\n }\n \n const UNINIT: Uninit = Uninit { uninit: () };\n+const UNINIT2: (Uninit,) = (Uninit { uninit: () }, );\n \n fn main() {}"}]}