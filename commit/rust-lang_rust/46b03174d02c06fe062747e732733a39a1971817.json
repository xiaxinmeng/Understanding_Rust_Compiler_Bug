{"sha": "46b03174d02c06fe062747e732733a39a1971817", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2YjAzMTc0ZDAyYzA2ZmUwNjI3NDdlNzMyNzMzYTM5YTE5NzE4MTc=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-29T20:16:22Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-29T20:16:22Z"}, "message": "Improve code readability and comments.", "tree": {"sha": "8517a678b65a72925f1d34b19d27716495d0fa6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8517a678b65a72925f1d34b19d27716495d0fa6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46b03174d02c06fe062747e732733a39a1971817", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46b03174d02c06fe062747e732733a39a1971817", "html_url": "https://github.com/rust-lang/rust/commit/46b03174d02c06fe062747e732733a39a1971817", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46b03174d02c06fe062747e732733a39a1971817/comments", "author": null, "committer": null, "parents": [{"sha": "3b5854191c35107a50ff83dd1e8b46f58d964224", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b5854191c35107a50ff83dd1e8b46f58d964224", "html_url": "https://github.com/rust-lang/rust/commit/3b5854191c35107a50ff83dd1e8b46f58d964224"}], "stats": {"total": 83, "additions": 50, "deletions": 33}, "files": [{"sha": "6352d06268654823651bd059664bf10394e5af4d", "filename": "src/eval.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46b03174d02c06fe062747e732733a39a1971817/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b03174d02c06fe062747e732733a39a1971817/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=46b03174d02c06fe062747e732733a39a1971817", "patch": "@@ -211,6 +211,9 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) ->\n                     assert!(ecx.step()?, \"a terminated thread was scheduled for execution\");\n                 }\n                 SchedulingAction::ExecuteDtors => {\n+                    // This will either enable the thread again (so we go back\n+                    // to `ExecuteStep`), or determine that this thread is done\n+                    // for good.\n                     ecx.schedule_next_tls_dtor_for_active_thread()?;\n                 }\n                 SchedulingAction::Stop => {"}, {"sha": "bc64b1e97a50e7e1d8db056f914dea3f219c29ed", "filename": "src/shims/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46b03174d02c06fe062747e732733a39a1971817/src%2Fshims%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b03174d02c06fe062747e732733a39a1971817/src%2Fshims%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fsync.rs?ref=46b03174d02c06fe062747e732733a39a1971817", "patch": "@@ -555,7 +555,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // result, not only readers can starve writers, but also writers can\n             // starve readers.\n             if let Some(_writer) = this.unblock_some_thread(writer_blockset)? {\n-                rwlock_set_writers(this, rwlock_op, Scalar::from_u32(1))?;\n+                assert_eq!(writers, 1);\n             } else {\n                 rwlock_set_writers(this, rwlock_op, Scalar::from_u32(0))?;\n                 let mut readers = 0;"}, {"sha": "3aca9520f67185f833b6a834530e78a8e2aafa93", "filename": "src/shims/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46b03174d02c06fe062747e732733a39a1971817/src%2Fshims%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b03174d02c06fe062747e732733a39a1971817/src%2Fshims%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fthread.rs?ref=46b03174d02c06fe062747e732733a39a1971817", "patch": "@@ -25,7 +25,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let thread_info_place = this.deref_operand(thread)?;\n         this.write_scalar(\n-            Scalar::from_uint(new_thread_id.to_u128(), thread_info_place.layout.size),\n+            Scalar::from_uint(new_thread_id.to_u32(), thread_info_place.layout.size),\n             thread_info_place.into(),\n         )?;\n \n@@ -83,7 +83,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         let thread_id = this.get_active_thread()?;\n-        this.write_scalar(Scalar::from_uint(thread_id.to_u128(), dest.layout.size), dest)\n+        this.write_scalar(Scalar::from_uint(thread_id.to_u32(), dest.layout.size), dest)\n     }\n \n     fn prctl("}, {"sha": "8a5bb7b42c5d2e949c868a72e640e73578b4613b", "filename": "src/shims/tls.rs", "status": "modified", "additions": 41, "deletions": 26, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/46b03174d02c06fe062747e732733a39a1971817/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b03174d02c06fe062747e732733a39a1971817/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=46b03174d02c06fe062747e732733a39a1971817", "patch": "@@ -26,7 +26,9 @@ pub struct TlsEntry<'tcx> {\n \n #[derive(Clone, Debug)]\n struct RunningDtorsState {\n-    /// The last TlsKey used to retrieve a TLS destructor.\n+    /// The last TlsKey used to retrieve a TLS destructor. `None` means that we\n+    /// have not tried to retrieve a TLS destructor yet or that we already tried\n+    /// all keys.\n     last_dtor_key: Option<TlsKey>,\n }\n \n@@ -40,7 +42,7 @@ pub struct TlsData<'tcx> {\n \n     /// A single per thread destructor of the thread local storage (that's how\n     /// things work on macOS) with a data argument.\n-    thread_dtors: BTreeMap<ThreadId, (ty::Instance<'tcx>, Scalar<Tag>)>,\n+    macos_thread_dtors: BTreeMap<ThreadId, (ty::Instance<'tcx>, Scalar<Tag>)>,\n \n     /// State for currently running TLS dtors. If this map contains a key for a\n     /// specific thread, it means that we are in the \"destruct\" phase, during\n@@ -53,7 +55,7 @@ impl<'tcx> Default for TlsData<'tcx> {\n         TlsData {\n             next_key: 1, // start with 1 as we must not use 0 on Windows\n             keys: Default::default(),\n-            thread_dtors: Default::default(),\n+            macos_thread_dtors: Default::default(),\n             dtors_running: Default::default(),\n         }\n     }\n@@ -143,7 +145,7 @@ impl<'tcx> TlsData<'tcx> {\n             // UB, according to libstd docs.\n             throw_ub_format!(\"setting thread's local storage destructor while destructors are already running\");\n         }\n-        if self.thread_dtors.insert(thread, (dtor, data)).is_some() {\n+        if self.macos_thread_dtors.insert(thread, (dtor, data)).is_some() {\n             throw_unsup_format!(\"setting more than one thread local storage destructor for the same thread is not supported\");\n         }\n         Ok(())\n@@ -186,6 +188,7 @@ impl<'tcx> TlsData<'tcx> {\n             match data.entry(thread_id) {\n                 Entry::Occupied(entry) => {\n                     if let Some(dtor) = dtor {\n+                        // Set TLS data to NULL, and call dtor with old value.\n                         let data_scalar = entry.remove();\n                         let ret = Some((*dtor, data_scalar, key));\n                         return ret;\n@@ -204,6 +207,8 @@ impl<'tcx> TlsData<'tcx> {\n         if self.dtors_running.contains_key(&thread) {\n             true\n         } else {\n+            // We need to guard this `insert` with a check because otherwise we\n+            // would risk to overwrite `last_dtor_key` with `None`.\n             self.dtors_running.insert(\n                 thread,\n                 RunningDtorsState { last_dtor_key: None }\n@@ -259,7 +264,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn schedule_macos_tls_dtor(&mut self) -> InterpResult<'tcx, bool> {\n         let this = self.eval_context_mut();\n         let thread_id = this.get_active_thread()?;\n-        if let Some((instance, data)) = this.machine.tls.thread_dtors.remove(&thread_id) {\n+        if let Some((instance, data)) = this.machine.tls.macos_thread_dtors.remove(&thread_id) {\n             trace!(\"Running macos dtor {:?} on {:?} at {:?}\", instance, data, thread_id);\n \n             let ret_place = MPlaceTy::dangling(this.machine.layouts.unit, this).into();\n@@ -283,7 +288,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     /// Schedule a pthread TLS destructor. Returns `true` if found\n     /// a destructor to schedule, and `false` otherwise.\n-    fn schedule_pthread_tls_dtors(&mut self) -> InterpResult<'tcx, bool> {\n+    fn schedule_next_pthread_tls_dtor(&mut self) -> InterpResult<'tcx, bool> {\n         let this = self.eval_context_mut();\n         let active_thread = this.get_active_thread()?;\n \n@@ -329,33 +334,43 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ///\n     /// FIXME: we do not support yet deallocation of thread local statics.\n     /// Issue: https://github.com/rust-lang/miri/issues/1369\n+    ///\n+    /// Note: we consistently run TLS destructors for all threads, including the\n+    /// main thread. However, it is not clear that we should run the TLS\n+    /// destructors for the main thread. See issue:\n+    /// https://github.com/rust-lang/rust/issues/28129.\n     fn schedule_next_tls_dtor_for_active_thread(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let active_thread = this.get_active_thread()?;\n \n-        let scheduled_next = if this.tcx.sess.target.target.target_os == \"windows\" {\n-            if !this.machine.tls.set_dtors_running_for_thread(active_thread) {\n+        if this.machine.tls.set_dtors_running_for_thread(active_thread) {\n+            // This is the first time we got asked to schedule a destructor. The\n+            // Windows schedule destructor function must be called exactly once,\n+            // this is why it is in this block.\n+            if this.tcx.sess.target.target.target_os == \"windows\" {\n+                // On Windows, we signal that the thread quit by starting the\n+                // relevant function, reenabling the thread, and going back to\n+                // the scheduler.\n                 this.schedule_windows_tls_dtors()?;\n-                true\n-            } else {\n-                false\n-            }\n-        } else {\n-            this.machine.tls.set_dtors_running_for_thread(active_thread);\n-            // The macOS thread wide destructor runs \"before any TLS slots get\n-            // freed\", so do that first.\n-            if this.schedule_macos_tls_dtor()? {\n-                true\n-            } else {\n-                this.schedule_pthread_tls_dtors()?\n+                return Ok(())\n             }\n-        };\n-\n-        if !scheduled_next {\n-            // No dtors scheduled means that we are finished. Delete the\n-            // remaining TLS entries.\n-            this.machine.tls.delete_all_thread_tls(active_thread);\n         }\n+        // The macOS thread wide destructor runs \"before any TLS slots get\n+        // freed\", so do that first.\n+        if this.schedule_macos_tls_dtor()? {\n+            // We have scheduled a MacOS dtor to run on the thread. Execute it\n+            // to completion and come back here. Scheduling a destructor\n+            // destroys it, so we will not enter this branch again.\n+            return Ok(())\n+        }\n+        if this.schedule_next_pthread_tls_dtor()? {\n+            // We have scheduled a pthread destructor and removed it from the\n+            // destructors list. Run it to completion and come back here.\n+            return Ok(())\n+        }\n+\n+        // All dtors done!\n+        this.machine.tls.delete_all_thread_tls(active_thread);\n \n         Ok(())\n     }"}, {"sha": "7d394c900274fa5af4ef394536abf229f187ecf1", "filename": "src/thread.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/46b03174d02c06fe062747e732733a39a1971817/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b03174d02c06fe062747e732733a39a1971817/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=46b03174d02c06fe062747e732733a39a1971817", "patch": "@@ -2,7 +2,6 @@\n \n use std::cell::RefCell;\n use std::convert::TryFrom;\n-use std::convert::TryInto;\n use std::num::{NonZeroU32, TryFromIntError};\n \n use log::trace;\n@@ -36,8 +35,8 @@ pub struct ThreadId(u32);\n const MAIN_THREAD: ThreadId = ThreadId(0);\n \n impl ThreadId {\n-    pub fn to_u128(self) -> u128 {\n-        self.0.try_into().unwrap()\n+    pub fn to_u32(self) -> u32 {\n+        self.0\n     }\n }\n \n@@ -362,7 +361,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     fn schedule(&mut self) -> InterpResult<'tcx, SchedulingAction> {\n         // Check whether the thread has **just** terminated (`check_terminated`\n         // checks whether the thread has popped all its stack and if yes, sets\n-        // the thread state to terminated.)\n+        // the thread state to terminated).\n         if self.threads[self.active_thread].check_terminated() {\n             // Check if we need to unblock any threads.\n             for (i, thread) in self.threads.iter_enumerated_mut() {"}]}