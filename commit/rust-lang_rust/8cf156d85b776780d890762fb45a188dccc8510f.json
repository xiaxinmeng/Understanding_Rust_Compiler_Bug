{"sha": "8cf156d85b776780d890762fb45a188dccc8510f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjZjE1NmQ4NWI3NzY3ODBkODkwNzYyZmI0NWExODhkY2NjODUxMGY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-23T14:51:23Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-23T14:51:23Z"}, "message": "Add a test for macro parsing", "tree": {"sha": "6624ae0f2a999e6e8ddadee23ec751c0429114df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6624ae0f2a999e6e8ddadee23ec751c0429114df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cf156d85b776780d890762fb45a188dccc8510f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cf156d85b776780d890762fb45a188dccc8510f", "html_url": "https://github.com/rust-lang/rust/commit/8cf156d85b776780d890762fb45a188dccc8510f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cf156d85b776780d890762fb45a188dccc8510f/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8eac450f41c6d94215f5d8c02235cd5917abaa69", "url": "https://api.github.com/repos/rust-lang/rust/commits/8eac450f41c6d94215f5d8c02235cd5917abaa69", "html_url": "https://github.com/rust-lang/rust/commit/8eac450f41c6d94215f5d8c02235cd5917abaa69"}], "stats": {"total": 90, "additions": 80, "deletions": 10}, "files": [{"sha": "907402f5f8402b7d24a1c5217f8ea0e25ed55812", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8cf156d85b776780d890762fb45a188dccc8510f/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf156d85b776780d890762fb45a188dccc8510f/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=8cf156d85b776780d890762fb45a188dccc8510f", "patch": "@@ -164,14 +164,18 @@ impl_froms!(TokenTree: Leaf, Subtree);\n         crate::MacroRules::parse(&definition_tt).unwrap()\n     }\n \n-    fn assert_expansion(rules: &MacroRules, invocation: &str, expansion: &str) {\n+    fn expand(rules: &MacroRules, invocation: &str) -> tt::Subtree {\n         let source_file = ast::SourceFile::parse(invocation);\n         let macro_invocation =\n             source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n \n         let (invocation_tt, _) = ast_to_token_tree(macro_invocation.token_tree().unwrap()).unwrap();\n \n-        let expanded = rules.expand(&invocation_tt).unwrap();\n+        rules.expand(&invocation_tt).unwrap()\n+    }\n+\n+    fn assert_expansion(rules: &MacroRules, invocation: &str, expansion: &str) {\n+        let expanded = expand(rules, invocation);\n         assert_eq!(expanded.to_string(), expansion);\n     }\n \n@@ -268,4 +272,57 @@ impl_froms!(TokenTree: Leaf, Subtree);\n         assert_expansion(&rules, \"foo! { Foo,# Bar }\", \"struct Foo ; struct Bar ;\");\n     }\n \n+    #[test]\n+    fn expand_to_item_list() {\n+        let rules = create_rules(\n+            \"\n+            macro_rules! structs {\n+                ($($i:ident),*) => {\n+                    $(struct $i { field: u32 } )*\n+                }\n+            }\n+            \",\n+        );\n+        let expansion = expand(&rules, \"structs!(Foo, Bar)\");\n+        let tree = token_tree_to_ast_item_list(&expansion);\n+        assert_eq!(\n+            tree.syntax().debug_dump().trim(),\n+            r#\"\n+SOURCE_FILE@[0; 40)\n+  STRUCT_DEF@[0; 20)\n+    STRUCT_KW@[0; 6)\n+    NAME@[6; 9)\n+      IDENT@[6; 9) \"Foo\"\n+    NAMED_FIELD_DEF_LIST@[9; 20)\n+      L_CURLY@[9; 10)\n+      NAMED_FIELD_DEF@[10; 19)\n+        NAME@[10; 15)\n+          IDENT@[10; 15) \"field\"\n+        COLON@[15; 16)\n+        PATH_TYPE@[16; 19)\n+          PATH@[16; 19)\n+            PATH_SEGMENT@[16; 19)\n+              NAME_REF@[16; 19)\n+                IDENT@[16; 19) \"u32\"\n+      R_CURLY@[19; 20)\n+  STRUCT_DEF@[20; 40)\n+    STRUCT_KW@[20; 26)\n+    NAME@[26; 29)\n+      IDENT@[26; 29) \"Bar\"\n+    NAMED_FIELD_DEF_LIST@[29; 40)\n+      L_CURLY@[29; 30)\n+      NAMED_FIELD_DEF@[30; 39)\n+        NAME@[30; 35)\n+          IDENT@[30; 35) \"field\"\n+        COLON@[35; 36)\n+        PATH_TYPE@[36; 39)\n+          PATH@[36; 39)\n+            PATH_SEGMENT@[36; 39)\n+              NAME_REF@[36; 39)\n+                IDENT@[36; 39) \"u32\"\n+      R_CURLY@[39; 40)\"#\n+                .trim()\n+        );\n+    }\n+\n }"}, {"sha": "3fe5abba3c907faf39878eba0c4ac4624886ce32", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8cf156d85b776780d890762fb45a188dccc8510f/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf156d85b776780d890762fb45a188dccc8510f/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=8cf156d85b776780d890762fb45a188dccc8510f", "patch": "@@ -129,17 +129,26 @@ impl TtTokenSource {\n                 is_joint_to_next: false,\n                 text: l.text.clone(),\n             },\n-            tt::Leaf::Punct(p) => Tok {\n-                kind: SyntaxKind::from_char(p.char).unwrap(),\n-                is_joint_to_next: p.spacing == tt::Spacing::Joint,\n-                text: {\n+            tt::Leaf::Punct(p) => {\n+                let kind = match p.char {\n+                    // lexer may produce combpund tokens for these ones\n+                    '.' => DOT,\n+                    ':' => COLON,\n+                    '=' => EQ,\n+                    '!' => EXCL,\n+                    '-' => MINUS,\n+                    c => SyntaxKind::from_char(c).unwrap(),\n+                };\n+                let text = {\n                     let mut buf = [0u8; 4];\n                     let s: &str = p.char.encode_utf8(&mut buf);\n                     SmolStr::new(s)\n-                },\n-            },\n+                };\n+                Tok { kind, is_joint_to_next: p.spacing == tt::Spacing::Joint, text }\n+            }\n             tt::Leaf::Ident(ident) => {\n-                Tok { kind: IDENT, is_joint_to_next: false, text: ident.text.clone() }\n+                let kind = SyntaxKind::from_keyword(ident.text.as_str()).unwrap_or(IDENT);\n+                Tok { kind, is_joint_to_next: false, text: ident.text.clone() }\n             }\n         };\n         self.tokens.push(tok)\n@@ -161,7 +170,11 @@ impl TtTokenSource {\n \n impl TokenSource for TtTokenSource {\n     fn token_kind(&self, pos: usize) -> SyntaxKind {\n-        self.tokens[pos].kind\n+        if let Some(tok) = self.tokens.get(pos) {\n+            tok.kind\n+        } else {\n+            SyntaxKind::EOF\n+        }\n     }\n     fn is_token_joint_to_next(&self, pos: usize) -> bool {\n         self.tokens[pos].is_joint_to_next"}]}