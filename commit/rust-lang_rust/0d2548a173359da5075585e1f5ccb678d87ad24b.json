{"sha": "0d2548a173359da5075585e1f5ccb678d87ad24b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMjU0OGExNzMzNTlkYTUwNzU1ODVlMWY1Y2NiNjc4ZDg3YWQyNGI=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-11-23T13:41:53Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-12-25T08:33:58Z"}, "message": "BTreeMap: declare exclusive access to arrays when copying from them", "tree": {"sha": "382c8d71780e0ffb8e30c9ac2dab30c76597cae8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/382c8d71780e0ffb8e30c9ac2dab30c76597cae8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d2548a173359da5075585e1f5ccb678d87ad24b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d2548a173359da5075585e1f5ccb678d87ad24b", "html_url": "https://github.com/rust-lang/rust/commit/0d2548a173359da5075585e1f5ccb678d87ad24b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d2548a173359da5075585e1f5ccb678d87ad24b/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a40539c380d444d4f373ac1d87802bd5ab33f68", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a40539c380d444d4f373ac1d87802bd5ab33f68", "html_url": "https://github.com/rust-lang/rust/commit/9a40539c380d444d4f373ac1d87802bd5ab33f68"}], "stats": {"total": 81, "additions": 17, "deletions": 64}, "files": [{"sha": "16b4b1091eff75cb999ccf05923d78f796a208bc", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 17, "deletions": 64, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/0d2548a173359da5075585e1f5ccb678d87ad24b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d2548a173359da5075585e1f5ccb678d87ad24b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=0d2548a173359da5075585e1f5ccb678d87ad24b", "patch": "@@ -295,15 +295,6 @@ impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n     }\n }\n \n-impl<'a, K, V> NodeRef<marker::Immut<'a>, K, V, marker::Internal> {\n-    /// Exposes the data of an internal node in an immutable tree.\n-    fn as_internal(this: &Self) -> &'a InternalNode<K, V> {\n-        let ptr = Self::as_internal_ptr(this);\n-        // SAFETY: there can be no mutable references into this tree borrowed as `Immut`.\n-        unsafe { &*ptr }\n-    }\n-}\n-\n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     /// Borrows exclusive access to the data of an internal node.\n     fn as_internal_mut(&mut self) -> &mut InternalNode<K, V> {\n@@ -368,17 +359,6 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n     }\n }\n \n-impl<'a, K, V> NodeRef<marker::Immut<'a>, K, V, marker::Internal> {\n-    /// Exposes the contents of one of the edges in the node.\n-    ///\n-    /// # Safety\n-    /// The node has more than `idx` initialized elements.\n-    unsafe fn edge_at(self, idx: usize) -> &'a BoxedNode<K, V> {\n-        debug_assert!(idx <= self.len());\n-        unsafe { Self::as_internal(&self).edges.get_unchecked(idx).assume_init_ref() }\n-    }\n-}\n-\n impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     /// Finds the parent of the current node. Returns `Ok(handle)` if the current\n     /// node actually has a parent, where `handle` points to the edge of the parent\n@@ -550,31 +530,6 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     }\n }\n \n-impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n-    /// Exposes the entire key storage area in the node,\n-    /// regardless of the node's current length,\n-    /// having exclusive access to the entire node.\n-    unsafe fn key_area(self) -> &'a [MaybeUninit<K>] {\n-        self.into_leaf().keys.as_slice()\n-    }\n-\n-    /// Exposes the entire value storage area in the node,\n-    /// regardless of the node's current length,\n-    /// having exclusive access to the entire node.\n-    unsafe fn val_area(self) -> &'a [MaybeUninit<V>] {\n-        self.into_leaf().vals.as_slice()\n-    }\n-}\n-\n-impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::Internal> {\n-    /// Exposes the entire storage area for edge contents in the node,\n-    /// regardless of the node's current length,\n-    /// having exclusive access to the entire node.\n-    unsafe fn edge_area(self) -> &'a [MaybeUninit<BoxedNode<K, V>>] {\n-        Self::as_internal(&self).edges.as_slice()\n-    }\n-}\n-\n impl<'a, K, V, Type> NodeRef<marker::ValMut<'a>, K, V, Type> {\n     /// # Safety\n     /// - The node has more than `idx` initialized elements.\n@@ -707,12 +662,12 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         let idx = self.len() - 1;\n \n         unsafe {\n-            let key = ptr::read(self.reborrow().key_at(idx));\n-            let val = ptr::read(self.reborrow().val_at(idx));\n+            let key = self.key_area_mut_at(idx).assume_init_read();\n+            let val = self.val_area_mut_at(idx).assume_init_read();\n             let edge = match self.reborrow_mut().force() {\n                 ForceResult::Leaf(_) => None,\n-                ForceResult::Internal(internal) => {\n-                    let node = ptr::read(internal.reborrow().edge_at(idx + 1));\n+                ForceResult::Internal(mut internal) => {\n+                    let node = internal.edge_area_mut_at(idx + 1).assume_init_read();\n                     let mut edge = Root { node, height: internal.height - 1, _marker: PhantomData };\n                     // Currently, clearing the parent link is superfluous, because we will\n                     // insert the node elsewhere and set its parent link again.\n@@ -1172,16 +1127,16 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n         let new_len = self.node.len() - self.idx - 1;\n         new_node.len = new_len as u16;\n         unsafe {\n-            let k = ptr::read(self.node.reborrow().key_at(self.idx));\n-            let v = ptr::read(self.node.reborrow().val_at(self.idx));\n+            let k = self.node.key_area_mut_at(self.idx).assume_init_read();\n+            let v = self.node.val_area_mut_at(self.idx).assume_init_read();\n \n             ptr::copy_nonoverlapping(\n-                self.node.reborrow().key_area().as_ptr().add(self.idx + 1),\n+                self.node.key_area_mut_at(self.idx + 1..).as_ptr(),\n                 new_node.keys.as_mut_ptr(),\n                 new_len,\n             );\n             ptr::copy_nonoverlapping(\n-                self.node.reborrow().val_area().as_ptr().add(self.idx + 1),\n+                self.node.val_area_mut_at(self.idx + 1..).as_ptr(),\n                 new_node.vals.as_mut_ptr(),\n                 new_len,\n             );\n@@ -1240,7 +1195,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n             let kv = self.split_leaf_data(&mut new_node.data);\n             let new_len = usize::from(new_node.data.len);\n             ptr::copy_nonoverlapping(\n-                self.node.reborrow().edge_area().as_ptr().add(self.idx + 1),\n+                self.node.edge_area_mut_at(self.idx + 1..).as_ptr(),\n                 new_node.edges.as_mut_ptr(),\n                 new_len + 1,\n             );\n@@ -1352,7 +1307,7 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n         let old_parent_len = parent_node.len();\n         let mut left_node = self.left_child;\n         let old_left_len = left_node.len();\n-        let right_node = self.right_child;\n+        let mut right_node = self.right_child;\n         let right_len = right_node.len();\n         let new_left_len = old_left_len + 1 + right_len;\n \n@@ -1370,7 +1325,7 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n                 slice_remove(parent_node.key_area_mut_at(..old_parent_len), parent_idx);\n             left_node.key_area_mut_at(old_left_len).write(parent_key);\n             ptr::copy_nonoverlapping(\n-                right_node.reborrow().key_area().as_ptr(),\n+                right_node.key_area_mut_at(..).as_ptr(),\n                 left_node.key_area_mut_at(old_left_len + 1..).as_mut_ptr(),\n                 right_len,\n             );\n@@ -1379,7 +1334,7 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n                 slice_remove(parent_node.val_area_mut_at(..old_parent_len), parent_idx);\n             left_node.val_area_mut_at(old_left_len).write(parent_val);\n             ptr::copy_nonoverlapping(\n-                right_node.reborrow().val_area().as_ptr(),\n+                right_node.val_area_mut_at(..).as_ptr(),\n                 left_node.val_area_mut_at(old_left_len + 1..).as_mut_ptr(),\n                 right_len,\n             );\n@@ -1392,9 +1347,9 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n                 // SAFETY: the height of the nodes being merged is one below the height\n                 // of the node of this edge, thus above zero, so they are internal.\n                 let mut left_node = left_node.reborrow_mut().cast_to_internal_unchecked();\n-                let right_node = right_node.cast_to_internal_unchecked();\n+                let mut right_node = right_node.cast_to_internal_unchecked();\n                 ptr::copy_nonoverlapping(\n-                    right_node.reborrow().edge_area().as_ptr(),\n+                    right_node.edge_area_mut_at(..).as_ptr(),\n                     left_node.edge_area_mut_at(old_left_len + 1..).as_mut_ptr(),\n                     right_len + 1,\n                 );\n@@ -1503,7 +1458,6 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n             match (left_node.reborrow_mut().force(), right_node.reborrow_mut().force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n                     // Make room for stolen edges.\n-                    let left = left.reborrow();\n                     let right_edges = right.edge_area_mut_at(..).as_mut_ptr();\n                     ptr::copy(right_edges, right_edges.add(count), old_right_len + 1);\n                     right.correct_childrens_parent_links(count..new_right_len + 1);\n@@ -1561,7 +1515,7 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n             match (left_node.reborrow_mut().force(), right_node.reborrow_mut().force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n                     // Steal edges.\n-                    move_edges(right.reborrow(), 0, left, old_left_len + 1, count);\n+                    move_edges(right.reborrow_mut(), 0, left, old_left_len + 1, count);\n \n                     // Fill gap where stolen edges used to be.\n                     let right_edges = right.edge_area_mut_at(..).as_mut_ptr();\n@@ -1590,14 +1544,14 @@ unsafe fn move_kv<K, V>(\n \n // Source and destination must have the same height.\n unsafe fn move_edges<'a, K: 'a, V: 'a>(\n-    source: NodeRef<marker::Immut<'a>, K, V, marker::Internal>,\n+    mut source: NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     source_offset: usize,\n     mut dest: NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     dest_offset: usize,\n     count: usize,\n ) {\n     unsafe {\n-        let source_ptr = source.edge_area().as_ptr();\n+        let source_ptr = source.edge_area_mut_at(..).as_ptr();\n         let dest_ptr = dest.edge_area_mut_at(dest_offset..).as_mut_ptr();\n         ptr::copy_nonoverlapping(source_ptr.add(source_offset), dest_ptr, count);\n         dest.correct_childrens_parent_links(dest_offset..dest_offset + count);\n@@ -1699,7 +1653,6 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, ma\n \n                 match (left_node.force(), right_node.force()) {\n                     (ForceResult::Internal(left), ForceResult::Internal(right)) => {\n-                        let left = left.reborrow();\n                         move_edges(left, new_left_len + 1, right, 1, new_right_len);\n                     }\n                     (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}"}]}