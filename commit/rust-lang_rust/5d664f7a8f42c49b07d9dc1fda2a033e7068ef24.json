{"sha": "5d664f7a8f42c49b07d9dc1fda2a033e7068ef24", "node_id": "C_kwDOAAsO6NoAKDVkNjY0ZjdhOGY0MmM0OWIwN2Q5ZGMxZmRhMmEwMzNlNzA2OGVmMjQ", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-09-13T08:51:45Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-09-16T11:36:09Z"}, "message": "Merge two arguments into one", "tree": {"sha": "746c63f3681b7f486eafa1f903d899dd8236a82a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/746c63f3681b7f486eafa1f903d899dd8236a82a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24", "html_url": "https://github.com/rust-lang/rust/commit/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22f6aec42de6bce63f8e43f144058428d4dba0f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/22f6aec42de6bce63f8e43f144058428d4dba0f5", "html_url": "https://github.com/rust-lang/rust/commit/22f6aec42de6bce63f8e43f144058428d4dba0f5"}], "stats": {"total": 219, "additions": 92, "deletions": 127}, "files": [{"sha": "3550c7470cdc2e32f9fc6557ffbe723a2897d600", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 23, "deletions": 35, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=5d664f7a8f42c49b07d9dc1fda2a033e7068ef24", "patch": "@@ -69,7 +69,7 @@ pub(crate) enum PlaceBase {\n /// This is used internally when building a place for an expression like `a.b.c`. The fields `b`\n /// and `c` can be progressively pushed onto the place builder that is created when converting `a`.\n #[derive(Clone, Debug, PartialEq)]\n-pub(crate) struct PlaceBuilder<'tcx> {\n+pub(in crate::build) struct PlaceBuilder<'tcx> {\n     base: PlaceBase,\n     projection: Vec<PlaceElem<'tcx>>,\n }\n@@ -168,22 +168,22 @@ fn find_capture_matching_projections<'a, 'tcx>(\n /// `PlaceBuilder` now starts from `PlaceBase::Local`.\n ///\n /// Returns a Result with the error being the PlaceBuilder (`from_builder`) that was not found.\n-fn to_upvars_resolved_place_builder<'a, 'tcx>(\n+#[instrument(level = \"trace\", skip(cx))]\n+fn to_upvars_resolved_place_builder<'tcx>(\n     from_builder: PlaceBuilder<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n-    upvars: &'a CaptureMap<'tcx>,\n+    cx: &Builder<'_, 'tcx>,\n ) -> Result<PlaceBuilder<'tcx>, PlaceBuilder<'tcx>> {\n     match from_builder.base {\n         PlaceBase::Local(_) => Ok(from_builder),\n         PlaceBase::Upvar { var_hir_id, closure_def_id } => {\n             let Some((capture_index, capture)) =\n                 find_capture_matching_projections(\n-                    upvars,\n+                    &cx.upvars,\n                     var_hir_id,\n                     &from_builder.projection,\n                 ) else {\n-                let closure_span = tcx.def_span(closure_def_id);\n-                if !enable_precise_capture(tcx, closure_span) {\n+                let closure_span = cx.tcx.def_span(closure_def_id);\n+                if !enable_precise_capture(cx.tcx, closure_span) {\n                     bug!(\n                         \"No associated capture found for {:?}[{:#?}] even though \\\n                             capture_disjoint_fields isn't enabled\",\n@@ -200,18 +200,20 @@ fn to_upvars_resolved_place_builder<'a, 'tcx>(\n             };\n \n             // Access the capture by accessing the field within the Closure struct.\n-            let capture_info = &upvars[capture_index];\n+            let capture_info = &cx.upvars[capture_index];\n \n             let mut upvar_resolved_place_builder = PlaceBuilder::from(capture_info.use_place);\n \n             // We used some of the projections to build the capture itself,\n             // now we apply the remaining to the upvar resolved place.\n+            trace!(?capture.captured_place, ?from_builder.projection);\n             let remaining_projections = strip_prefix(\n                 capture.captured_place.place.base_ty,\n                 from_builder.projection,\n                 &capture.captured_place.place.projections,\n             );\n             upvar_resolved_place_builder.projection.extend(remaining_projections);\n+            trace!(?upvar_resolved_place_builder);\n \n             Ok(upvar_resolved_place_builder)\n         }\n@@ -251,24 +253,16 @@ fn strip_prefix<'tcx>(\n }\n \n impl<'tcx> PlaceBuilder<'tcx> {\n-    pub(in crate::build) fn into_place<'a>(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        upvars: &'a CaptureMap<'tcx>,\n-    ) -> Place<'tcx> {\n+    pub(in crate::build) fn into_place(self, cx: &Builder<'_, 'tcx>) -> Place<'tcx> {\n         if let PlaceBase::Local(local) = self.base {\n-            Place { local, projection: tcx.intern_place_elems(&self.projection) }\n+            Place { local, projection: cx.tcx.intern_place_elems(&self.projection) }\n         } else {\n-            self.expect_upvars_resolved(tcx, upvars).into_place(tcx, upvars)\n+            self.expect_upvars_resolved(cx).into_place(cx)\n         }\n     }\n \n-    fn expect_upvars_resolved<'a>(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        upvars: &'a CaptureMap<'tcx>,\n-    ) -> PlaceBuilder<'tcx> {\n-        to_upvars_resolved_place_builder(self, tcx, upvars).unwrap()\n+    fn expect_upvars_resolved(self, cx: &Builder<'_, 'tcx>) -> PlaceBuilder<'tcx> {\n+        to_upvars_resolved_place_builder(self, cx).unwrap()\n     }\n \n     /// Attempts to resolve the `PlaceBuilder`.\n@@ -282,12 +276,11 @@ impl<'tcx> PlaceBuilder<'tcx> {\n     /// not captured. This can happen because the final mir that will be\n     /// generated doesn't require a read for this place. Failures will only\n     /// happen inside closures.\n-    pub(in crate::build) fn try_upvars_resolved<'a>(\n+    pub(in crate::build) fn try_upvars_resolved(\n         self,\n-        tcx: TyCtxt<'tcx>,\n-        upvars: &'a CaptureMap<'tcx>,\n+        cx: &Builder<'_, 'tcx>,\n     ) -> Result<PlaceBuilder<'tcx>, PlaceBuilder<'tcx>> {\n-        to_upvars_resolved_place_builder(self, tcx, upvars)\n+        to_upvars_resolved_place_builder(self, cx)\n     }\n \n     pub(crate) fn base(&self) -> PlaceBase {\n@@ -353,7 +346,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         expr: &Expr<'tcx>,\n     ) -> BlockAnd<Place<'tcx>> {\n         let place_builder = unpack!(block = self.as_place_builder(block, expr));\n-        block.and(place_builder.into_place(self.tcx, &self.upvars))\n+        block.and(place_builder.into_place(self))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n@@ -377,7 +370,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         expr: &Expr<'tcx>,\n     ) -> BlockAnd<Place<'tcx>> {\n         let place_builder = unpack!(block = self.as_read_only_place_builder(block, expr));\n-        block.and(place_builder.into_place(self.tcx, &self.upvars))\n+        block.and(place_builder.into_place(self))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n@@ -472,7 +465,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             inferred_ty: expr.ty,\n                         });\n \n-                    let place = place_builder.clone().into_place(this.tcx, &this.upvars);\n+                    let place = place_builder.clone().into_place(this);\n                     this.cfg.push(\n                         block,\n                         Statement {\n@@ -610,7 +603,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         if is_outermost_index {\n             self.read_fake_borrows(block, fake_borrow_temps, source_info)\n         } else {\n-            base_place = base_place.expect_upvars_resolved(self.tcx, &self.upvars);\n+            base_place = base_place.expect_upvars_resolved(self);\n             self.add_fake_borrows_of_base(\n                 &base_place,\n                 block,\n@@ -638,12 +631,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let lt = self.temp(bool_ty, expr_span);\n \n         // len = len(slice)\n-        self.cfg.push_assign(\n-            block,\n-            source_info,\n-            len,\n-            Rvalue::Len(slice.into_place(self.tcx, &self.upvars)),\n-        );\n+        self.cfg.push_assign(block, source_info, len, Rvalue::Len(slice.into_place(self)));\n         // lt = idx < len\n         self.cfg.push_assign(\n             block,"}, {"sha": "16295b1b19a13ee48e1440399d4e907f8030c675", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=5d664f7a8f42c49b07d9dc1fda2a033e7068ef24", "patch": "@@ -329,10 +329,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     let place_builder =\n                         unpack!(block = this.as_place_builder(block, &this.thir[*thir_place]));\n \n-                    if let Ok(place_builder_resolved) =\n-                        place_builder.try_upvars_resolved(this.tcx, &this.upvars)\n-                    {\n-                        let mir_place = place_builder_resolved.into_place(this.tcx, &this.upvars);\n+                    if let Ok(place_builder_resolved) = place_builder.try_upvars_resolved(this) {\n+                        let mir_place = place_builder_resolved.into_place(this);\n                         this.cfg.push_fake_read(\n                             block,\n                             this.source_info(this.tcx.hir().span(*hir_id)),\n@@ -623,8 +621,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // by the parent itself. The mutability of the current capture\n             // is same as that of the capture in the parent closure.\n             PlaceBase::Upvar { .. } => {\n-                let enclosing_upvars_resolved =\n-                    arg_place_builder.clone().into_place(this.tcx, &this.upvars);\n+                let enclosing_upvars_resolved = arg_place_builder.clone().into_place(this);\n \n                 match enclosing_upvars_resolved.as_ref() {\n                     PlaceRef {\n@@ -661,7 +658,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             Mutability::Mut => BorrowKind::Mut { allow_two_phase_borrow: false },\n         };\n \n-        let arg_place = arg_place_builder.into_place(this.tcx, &this.upvars);\n+        let arg_place = arg_place_builder.into_place(this);\n \n         this.cfg.push_assign(\n             block,"}, {"sha": "0ca4e37451995aae9a11d8c10ad6cf0f63b481a5", "filename": "compiler/rustc_mir_build/src/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs?ref=5d664f7a8f42c49b07d9dc1fda2a033e7068ef24", "patch": "@@ -23,17 +23,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         ensure_sufficient_stack(|| self.as_temp_inner(block, temp_lifetime, expr, mutability))\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn as_temp_inner(\n         &mut self,\n         mut block: BasicBlock,\n         temp_lifetime: Option<region::Scope>,\n         expr: &Expr<'tcx>,\n         mutability: Mutability,\n     ) -> BlockAnd<Local> {\n-        debug!(\n-            \"as_temp(block={:?}, temp_lifetime={:?}, expr={:?}, mutability={:?})\",\n-            block, temp_lifetime, expr, mutability\n-        );\n         let this = self;\n \n         let expr_span = expr.span;"}, {"sha": "4b8c134b9d0a836496873a53914e06f02c284ed8", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=5d664f7a8f42c49b07d9dc1fda2a033e7068ef24", "patch": "@@ -15,14 +15,13 @@ use std::iter;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which\n     /// is assumed to be uninitialized.\n+    #[instrument(level = \"debug\", skip(self))]\n     pub(crate) fn expr_into_dest(\n         &mut self,\n         destination: Place<'tcx>,\n         mut block: BasicBlock,\n         expr: &Expr<'tcx>,\n     ) -> BlockAnd<()> {\n-        debug!(\"expr_into_dest(destination={:?}, block={:?}, expr={:?})\", destination, block, expr);\n-\n         // since we frequently have to reference `self` from within a\n         // closure, where `self` would be shadowed, it's easier to\n         // just use the name `this` uniformly\n@@ -366,7 +365,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             None => {\n                                 let place_builder = place_builder.clone();\n                                 this.consume_by_copy_or_move(\n-                                    place_builder.field(n, *ty).into_place(this.tcx, &this.upvars),\n+                                    place_builder.field(n, *ty).into_place(this),\n                                 )\n                             }\n                         })"}, {"sha": "d283c33a0050c4b6f44b90c5e6ff7d3685a7f25b", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 34, "deletions": 39, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=5d664f7a8f42c49b07d9dc1fda2a033e7068ef24", "patch": "@@ -220,10 +220,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let cause_matched_place = FakeReadCause::ForMatchedPlace(None);\n         let source_info = self.source_info(scrutinee_span);\n \n-        if let Ok(scrutinee_builder) =\n-            scrutinee_place_builder.clone().try_upvars_resolved(self.tcx, &self.upvars)\n-        {\n-            let scrutinee_place = scrutinee_builder.into_place(self.tcx, &self.upvars);\n+        if let Ok(scrutinee_builder) = scrutinee_place_builder.clone().try_upvars_resolved(self) {\n+            let scrutinee_place = scrutinee_builder.into_place(self);\n             self.cfg.push_fake_read(block, source_info, cause_matched_place, scrutinee_place);\n         }\n \n@@ -349,9 +347,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     let mut opt_scrutinee_place: Option<(Option<&Place<'tcx>>, Span)> = None;\n                     let scrutinee_place: Place<'tcx>;\n                     if let Ok(scrutinee_builder) =\n-                        scrutinee_place_builder.clone().try_upvars_resolved(this.tcx, &this.upvars)\n+                        scrutinee_place_builder.clone().try_upvars_resolved(this)\n                     {\n-                        scrutinee_place = scrutinee_builder.into_place(this.tcx, &this.upvars);\n+                        scrutinee_place = scrutinee_builder.into_place(this);\n                         opt_scrutinee_place = Some((Some(&scrutinee_place), scrutinee_span));\n                     }\n                     let scope = this.declare_bindings(\n@@ -597,12 +595,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             while let Some(next) = {\n                 for binding in &candidate_ref.bindings {\n                     let local = self.var_local_id(binding.var_id, OutsideGuard);\n-\n-                    let Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n-                        VarBindingForm { opt_match_place: Some((ref mut match_place, _)), .. },\n-                    )))) = self.local_decls[local].local_info else {\n-                        bug!(\"Let binding to non-user variable.\")\n-                    };\n                     // `try_upvars_resolved` may fail if it is unable to resolve the given\n                     // `PlaceBuilder` inside a closure. In this case, we don't want to include\n                     // a scrutinee place. `scrutinee_place_builder` will fail for destructured\n@@ -617,10 +609,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     //    let (v1, v2) = foo;\n                     // };\n                     // ```\n-                    if let Ok(match_pair_resolved) =\n-                        initializer.clone().try_upvars_resolved(self.tcx, &self.upvars)\n-                    {\n-                        let place = match_pair_resolved.into_place(self.tcx, &self.upvars);\n+                    if let Ok(match_pair_resolved) = initializer.clone().try_upvars_resolved(self) {\n+                        let place = match_pair_resolved.into_place(self);\n+\n+                        let Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                            VarBindingForm { opt_match_place: Some((ref mut match_place, _)), .. },\n+                        )))) = self.local_decls[local].local_info else {\n+                            bug!(\"Let binding to non-user variable.\")\n+                        };\n                         *match_place = Some(place);\n                     }\n                 }\n@@ -649,6 +645,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// scope for the bindings in these patterns, if such a scope had to be\n     /// created. NOTE: Declaring the bindings should always be done in their\n     /// drop scope.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub(crate) fn declare_bindings(\n         &mut self,\n         mut visibility_scope: Option<SourceScope>,\n@@ -657,7 +654,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         has_guard: ArmHasGuard,\n         opt_match_place: Option<(Option<&Place<'tcx>>, Span)>,\n     ) -> Option<SourceScope> {\n-        debug!(\"declare_bindings: pattern={:?}\", pattern);\n         self.visit_primary_bindings(\n             &pattern,\n             UserTypeProjections::none(),\n@@ -867,7 +863,7 @@ impl<'tcx, 'pat> Candidate<'pat, 'tcx> {\n         Candidate {\n             span: pattern.span,\n             has_guard,\n-            match_pairs: smallvec![MatchPair { place, pattern }],\n+            match_pairs: smallvec![MatchPair::new(place, pattern)],\n             bindings: Vec::new(),\n             ascriptions: Vec::new(),\n             subcandidates: Vec::new(),\n@@ -1043,6 +1039,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// if `x.0` matches `false` (for the third arm). In the (impossible at\n     /// runtime) case when `x.0` is now `true`, we branch to\n     /// `otherwise_block`.\n+    #[instrument(skip(self, fake_borrows), level = \"debug\")]\n     fn match_candidates<'pat>(\n         &mut self,\n         span: Span,\n@@ -1052,11 +1049,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         candidates: &mut [&mut Candidate<'pat, 'tcx>],\n         fake_borrows: &mut Option<FxIndexSet<Place<'tcx>>>,\n     ) {\n-        debug!(\n-            \"matched_candidate(span={:?}, candidates={:?}, start_block={:?}, otherwise_block={:?})\",\n-            span, candidates, start_block, otherwise_block,\n-        );\n-\n         // Start by simplifying candidates. Once this process is complete, all\n         // the match pairs which remain require some form of test, whether it\n         // be a switch or pattern comparison.\n@@ -1375,6 +1367,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         )\n     }\n \n+    #[instrument(\n+        skip(self, otherwise, or_span, place, fake_borrows, candidate, pats),\n+        level = \"debug\"\n+    )]\n     fn test_or_pattern<'pat>(\n         &mut self,\n         candidate: &mut Candidate<'pat, 'tcx>,\n@@ -1384,7 +1380,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         place: PlaceBuilder<'tcx>,\n         fake_borrows: &mut Option<FxIndexSet<Place<'tcx>>>,\n     ) {\n-        debug!(\"test_or_pattern:\\ncandidate={:#?}\\npats={:#?}\", candidate, pats);\n+        debug!(\"candidate={:#?}\\npats={:#?}\", candidate, pats);\n         let mut or_candidates: Vec<_> = pats\n             .iter()\n             .map(|pat| Candidate::new(place.clone(), pat, candidate.has_guard))\n@@ -1600,9 +1596,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         // Insert a Shallow borrow of any places that is switched on.\n         if let Some(fb) = fake_borrows && let Ok(match_place_resolved) =\n-            match_place.clone().try_upvars_resolved(self.tcx, &self.upvars)\n+            match_place.clone().try_upvars_resolved(self)\n         {\n-            let resolved_place = match_place_resolved.into_place(self.tcx, &self.upvars);\n+            let resolved_place = match_place_resolved.into_place(self);\n             fb.insert(resolved_place);\n         }\n \n@@ -1629,9 +1625,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             candidates = rest;\n         }\n         // at least the first candidate ought to be tested\n-        assert!(total_candidate_count > candidates.len());\n-        debug!(\"test_candidates: tested_candidates: {}\", total_candidate_count - candidates.len());\n-        debug!(\"test_candidates: untested_candidates: {}\", candidates.len());\n+        assert!(\n+            total_candidate_count > candidates.len(),\n+            \"{}, {:#?}\",\n+            total_candidate_count,\n+            candidates\n+        );\n+        debug!(\"tested_candidates: {}\", total_candidate_count - candidates.len());\n+        debug!(\"untested_candidates: {}\", candidates.len());\n \n         // HACK(matthewjasper) This is a closure so that we can let the test\n         // create its blocks before the rest of the match. This currently\n@@ -1789,8 +1790,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         );\n         let mut opt_expr_place: Option<(Option<&Place<'tcx>>, Span)> = None;\n         let expr_place: Place<'tcx>;\n-        if let Ok(expr_builder) = expr_place_builder.try_upvars_resolved(self.tcx, &self.upvars) {\n-            expr_place = expr_builder.into_place(self.tcx, &self.upvars);\n+        if let Ok(expr_builder) = expr_place_builder.try_upvars_resolved(self) {\n+            expr_place = expr_builder.into_place(self);\n             opt_expr_place = Some((Some(&expr_place), expr_span));\n         }\n         let otherwise_post_guard_block = otherwise_candidate.pre_binding_block.unwrap();\n@@ -2188,6 +2189,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// first local is a binding for occurrences of `var` in the guard, which\n     /// will have type `&T`. The second local is a binding for occurrences of\n     /// `var` in the arm body, which will have type `T`.\n+    #[instrument(skip(self), level = \"debug\")]\n     fn declare_binding(\n         &mut self,\n         source_info: SourceInfo,\n@@ -2202,19 +2204,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         opt_match_place: Option<(Option<Place<'tcx>>, Span)>,\n         pat_span: Span,\n     ) {\n-        debug!(\n-            \"declare_binding(var_id={:?}, name={:?}, mode={:?}, var_ty={:?}, \\\n-             visibility_scope={:?}, source_info={:?})\",\n-            var_id, name, mode, var_ty, visibility_scope, source_info\n-        );\n-\n         let tcx = self.tcx;\n         let debug_source_info = SourceInfo { span: source_info.span, scope: visibility_scope };\n         let binding_mode = match mode {\n             BindingMode::ByValue => ty::BindingMode::BindByValue(mutability),\n             BindingMode::ByRef(_) => ty::BindingMode::BindByReference(mutability),\n         };\n-        debug!(\"declare_binding: user_ty={:?}\", user_ty);\n         let local = LocalDecl::<'tcx> {\n             mutability,\n             ty: var_ty,\n@@ -2264,7 +2259,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         } else {\n             LocalsForNode::One(for_arm_body)\n         };\n-        debug!(\"declare_binding: vars={:?}\", locals);\n+        debug!(?locals);\n         self.var_indices.insert(var_id, locals);\n     }\n "}, {"sha": "7117554933de326a6fbd43db5af29f945fe2d545", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=5d664f7a8f42c49b07d9dc1fda2a033e7068ef24", "patch": "@@ -37,12 +37,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// only generates a single switch. If this happens this method returns\n     /// `true`.\n+    #[instrument(skip(self, candidate), level = \"debug\")]\n     pub(super) fn simplify_candidate<'pat>(\n         &mut self,\n         candidate: &mut Candidate<'pat, 'tcx>,\n     ) -> bool {\n         // repeatedly simplify match pairs until fixed point is reached\n-        debug!(?candidate, \"simplify_candidate\");\n+        debug!(\"{candidate:#?}\");\n \n         // existing_bindings and new_bindings exists to keep the semantics in order.\n         // Reversing the binding order for bindings after `@` changes the binding order in places\n@@ -155,12 +156,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 ascription: thir::Ascription { ref annotation, variance },\n             } => {\n                 // Apply the type ascription to the value at `match_pair.place`, which is the\n-                if let Ok(place_resolved) =\n-                    match_pair.place.clone().try_upvars_resolved(self.tcx, &self.upvars)\n-                {\n+                if let Ok(place_resolved) = match_pair.place.clone().try_upvars_resolved(self) {\n                     candidate.ascriptions.push(Ascription {\n                         annotation: annotation.clone(),\n-                        source: place_resolved.into_place(self.tcx, &self.upvars),\n+                        source: place_resolved.into_place(self),\n                         variance,\n                     });\n                 }\n@@ -184,12 +183,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 ref subpattern,\n                 is_primary: _,\n             } => {\n-                if let Ok(place_resolved) =\n-                    match_pair.place.clone().try_upvars_resolved(self.tcx, &self.upvars)\n-                {\n+                if let Ok(place_resolved) = match_pair.place.clone().try_upvars_resolved(self) {\n                     candidate.bindings.push(Binding {\n                         span: match_pair.pattern.span,\n-                        source: place_resolved.into_place(self.tcx, &self.upvars),\n+                        source: place_resolved.into_place(self),\n                         var_id: var,\n                         binding_mode: mode,\n                     });"}, {"sha": "a8adf490db8020b1aaff2a69922654bc92245b20", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=5d664f7a8f42c49b07d9dc1fda2a033e7068ef24", "patch": "@@ -144,6 +144,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self, make_target_blocks, place_builder), level = \"debug\")]\n     pub(super) fn perform_test(\n         &mut self,\n         match_start_span: Span,\n@@ -153,19 +154,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         test: &Test<'tcx>,\n         make_target_blocks: impl FnOnce(&mut Self) -> Vec<BasicBlock>,\n     ) {\n-        let place: Place<'tcx>;\n-        if let Ok(test_place_builder) = place_builder.try_upvars_resolved(self.tcx, &self.upvars) {\n-            place = test_place_builder.into_place(self.tcx, &self.upvars);\n-        } else {\n-            return;\n-        }\n-        debug!(\n-            \"perform_test({:?}, {:?}: {:?}, {:?})\",\n-            block,\n-            place,\n-            place.ty(&self.local_decls, self.tcx),\n-            test\n-        );\n+        let place = place_builder.into_place(self);\n+        let place_ty = place.ty(&self.local_decls, self.tcx);\n+        debug!(?place, ?place_ty,);\n \n         let source_info = self.source_info(test.span);\n         match test.kind {\n@@ -733,9 +724,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // So, if we have a match-pattern like `x @ Enum::Variant(P1, P2)`,\n         // we want to create a set of derived match-patterns like\n         // `(x as Variant).0 @ P1` and `(x as Variant).1 @ P1`.\n-        let elem =\n-            ProjectionElem::Downcast(Some(adt_def.variant(variant_index).name), variant_index);\n-        let downcast_place = match_pair.place.project(elem); // `(x as Variant)`\n+        let downcast_place = match_pair.place.downcast(adt_def, variant_index); // `(x as Variant)`\n         let consequent_match_pairs = subpatterns.iter().map(|subpattern| {\n             // e.g., `(x as Variant).0`\n             let place = downcast_place.clone().field(subpattern.field, subpattern.pattern.ty);"}, {"sha": "f47626731eb8871cb400d77ee09bdb363b343d34", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=5d664f7a8f42c49b07d9dc1fda2a033e7068ef24", "patch": "@@ -31,17 +31,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         suffix: &'pat [Box<Pat<'tcx>>],\n     ) {\n         let tcx = self.tcx;\n-        let (min_length, exact_size) = if let Ok(place_resolved) =\n-            place.clone().try_upvars_resolved(tcx, &self.upvars)\n-        {\n-            match place_resolved.into_place(tcx, &self.upvars).ty(&self.local_decls, tcx).ty.kind()\n-            {\n-                ty::Array(_, length) => (length.eval_usize(tcx, self.param_env), true),\n-                _ => ((prefix.len() + suffix.len()).try_into().unwrap(), false),\n-            }\n-        } else {\n-            ((prefix.len() + suffix.len()).try_into().unwrap(), false)\n-        };\n+        let (min_length, exact_size) =\n+            if let Ok(place_resolved) = place.clone().try_upvars_resolved(self) {\n+                match place_resolved.into_place(self).ty(&self.local_decls, tcx).ty.kind() {\n+                    ty::Array(_, length) => (length.eval_usize(tcx, self.param_env), true),\n+                    _ => ((prefix.len() + suffix.len()).try_into().unwrap(), false),\n+                }\n+            } else {\n+                ((prefix.len() + suffix.len()).try_into().unwrap(), false)\n+            };\n \n         match_pairs.extend(prefix.iter().enumerate().map(|(idx, subpattern)| {\n             let elem =\n@@ -96,7 +94,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n }\n \n impl<'pat, 'tcx> MatchPair<'pat, 'tcx> {\n-    pub(crate) fn new(\n+    pub(in crate::build) fn new(\n         place: PlaceBuilder<'tcx>,\n         pattern: &'pat Pat<'tcx>,\n     ) -> MatchPair<'pat, 'tcx> {"}, {"sha": "2c7d6a572f45b3e6c5e3c586907cad4281487e08", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=5d664f7a8f42c49b07d9dc1fda2a033e7068ef24", "patch": "@@ -553,6 +553,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     /// Convenience wrapper that pushes a scope and then executes `f`\n     /// to build its contents, popping the scope afterwards.\n+    #[instrument(skip(self, f), level = \"debug\")]\n     pub(crate) fn in_scope<F, R>(\n         &mut self,\n         region_scope: (region::Scope, SourceInfo),\n@@ -562,7 +563,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     where\n         F: FnOnce(&mut Builder<'a, 'tcx>) -> BlockAnd<R>,\n     {\n-        debug!(\"in_scope(region_scope={:?})\", region_scope);\n         let source_scope = self.source_scope;\n         let tcx = self.tcx;\n         if let LintLevel::Explicit(current_hir_id) = lint_level {\n@@ -589,7 +589,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let rv = unpack!(block = f(self));\n         unpack!(block = self.pop_scope(region_scope, block));\n         self.source_scope = source_scope;\n-        debug!(\"in_scope: exiting region_scope={:?} block={:?}\", region_scope, block);\n+        debug!(?block);\n         block.and(rv)\n     }\n "}, {"sha": "3f8a9d21cd8d1dfb34a0d155e0e3f0d62d00877a", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=5d664f7a8f42c49b07d9dc1fda2a033e7068ef24", "patch": "@@ -48,6 +48,8 @@ impl<'tcx> Cx<'tcx> {\n             _ => None,\n         };\n \n+        trace!(?expr.ty);\n+\n         // Now apply adjustments, if any.\n         for adjustment in self.typeck_results.expr_adjustments(hir_expr) {\n             trace!(?expr, ?adjustment);\n@@ -56,6 +58,8 @@ impl<'tcx> Cx<'tcx> {\n                 self.apply_adjustment(hir_expr, expr, adjustment, adjustment_span.unwrap_or(span));\n         }\n \n+        trace!(?expr.ty, \"after adjustments\");\n+\n         // Next, wrap this up in the expr's scope.\n         expr = Expr {\n             temp_lifetime,"}, {"sha": "a679ea8bed0c3b3072b695805baecefcfa4836f8", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d664f7a8f42c49b07d9dc1fda2a033e7068ef24/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=5d664f7a8f42c49b07d9dc1fda2a033e7068ef24", "patch": "@@ -200,6 +200,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Box<Pat<'tcx>> {\n         let mut ty = self.typeck_results.node_type(pat.hir_id);\n         let mut span = pat.span;"}]}