{"sha": "71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxYzFiNWI3MDRjYTM5NTVlNWNhMjJkNzdhMGQ1OWI1NWM5YWY0ZjE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-13T23:23:32Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-16T20:28:15Z"}, "message": "rustdoc: Inline methods inhereted through Deref\n\nWhenever a type implements Deref, rustdoc will now add a section to the \"methods\navailable\" sections for \"Methods from Deref<Target=Foo>\", listing all the\ninherent methods of the type `Foo`.\n\nCloses #19190", "tree": {"sha": "b233e253ba43b1fc0077464a2bba0ebf50162639", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b233e253ba43b1fc0077464a2bba0ebf50162639"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1", "html_url": "https://github.com/rust-lang/rust/commit/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fb31f75c95c52cfef40c6ffe2f1452c959ca5e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fb31f75c95c52cfef40c6ffe2f1452c959ca5e4", "html_url": "https://github.com/rust-lang/rust/commit/8fb31f75c95c52cfef40c6ffe2f1452c959ca5e4"}], "stats": {"total": 399, "additions": 333, "deletions": 66}, "files": [{"sha": "4fc86cf181b8daf361d8756e527cbe25279b5e3f", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1", "patch": "@@ -218,15 +218,17 @@ fn build_type(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEn\n     })\n }\n \n-fn build_impls(cx: &DocContext, tcx: &ty::ctxt,\n-               did: ast::DefId) -> Vec<clean::Item> {\n+pub fn build_impls(cx: &DocContext, tcx: &ty::ctxt,\n+                   did: ast::DefId) -> Vec<clean::Item> {\n     ty::populate_implementations_for_type_if_necessary(tcx, did);\n     let mut impls = Vec::new();\n \n     match tcx.inherent_impls.borrow().get(&did) {\n         None => {}\n         Some(i) => {\n-            impls.extend(i.iter().map(|&did| { build_impl(cx, tcx, did) }));\n+            for &did in i.iter() {\n+                build_impl(cx, tcx, did, &mut impls);\n+            }\n         }\n     }\n \n@@ -247,9 +249,9 @@ fn build_impls(cx: &DocContext, tcx: &ty::ctxt,\n \n         fn populate_impls(cx: &DocContext, tcx: &ty::ctxt,\n                           def: decoder::DefLike,\n-                          impls: &mut Vec<Option<clean::Item>>) {\n+                          impls: &mut Vec<clean::Item>) {\n             match def {\n-                decoder::DlImpl(did) => impls.push(build_impl(cx, tcx, did)),\n+                decoder::DlImpl(did) => build_impl(cx, tcx, did, impls),\n                 decoder::DlDef(def::DefMod(did)) => {\n                     csearch::each_child_of_item(&tcx.sess.cstore,\n                                                 did,\n@@ -262,14 +264,15 @@ fn build_impls(cx: &DocContext, tcx: &ty::ctxt,\n         }\n     }\n \n-    impls.into_iter().filter_map(|a| a).collect()\n+    return impls;\n }\n \n-fn build_impl(cx: &DocContext,\n-              tcx: &ty::ctxt,\n-              did: ast::DefId) -> Option<clean::Item> {\n+pub fn build_impl(cx: &DocContext,\n+                  tcx: &ty::ctxt,\n+                  did: ast::DefId,\n+                  ret: &mut Vec<clean::Item>) {\n     if !cx.inlined.borrow_mut().as_mut().unwrap().insert(did) {\n-        return None\n+        return\n     }\n \n     let attrs = load_attrs(cx, tcx, did);\n@@ -278,13 +281,13 @@ fn build_impl(cx: &DocContext,\n         // If this is an impl for a #[doc(hidden)] trait, be sure to not inline\n         let trait_attrs = load_attrs(cx, tcx, t.def_id);\n         if trait_attrs.iter().any(|a| is_doc_hidden(a)) {\n-            return None\n+            return\n         }\n     }\n \n     // If this is a defaulted impl, then bail out early here\n     if csearch::is_default_impl(&tcx.sess.cstore, did) {\n-        return Some(clean::Item {\n+        return ret.push(clean::Item {\n             inner: clean::DefaultImplItem(clean::DefaultImpl {\n                 // FIXME: this should be decoded\n                 unsafety: ast::Unsafety::Normal,\n@@ -352,19 +355,25 @@ fn build_impl(cx: &DocContext,\n                 })\n             }\n         }\n-    }).collect();\n+    }).collect::<Vec<_>>();\n     let polarity = csearch::get_impl_polarity(tcx, did);\n     let ty = ty::lookup_item_type(tcx, did);\n-    return Some(clean::Item {\n+    let trait_ = associated_trait.clean(cx).map(|bound| {\n+        match bound {\n+            clean::TraitBound(polyt, _) => polyt.trait_,\n+            clean::RegionBound(..) => unreachable!(),\n+        }\n+    });\n+    if let Some(clean::ResolvedPath { did, .. }) = trait_ {\n+        if Some(did) == cx.deref_trait_did.get() {\n+            super::build_deref_target_impls(cx, &trait_items, ret);\n+        }\n+    }\n+    ret.push(clean::Item {\n         inner: clean::ImplItem(clean::Impl {\n             unsafety: ast::Unsafety::Normal, // FIXME: this should be decoded\n             derived: clean::detect_derived(&attrs),\n-            trait_: associated_trait.clean(cx).map(|bound| {\n-                match bound {\n-                    clean::TraitBound(polyt, _) => polyt.trait_,\n-                    clean::RegionBound(..) => unreachable!(),\n-                }\n-            }),\n+            trait_: trait_,\n             for_: ty.ty.clean(cx),\n             generics: (&ty.generics, &predicates, subst::TypeSpace).clean(cx),\n             items: trait_items,"}, {"sha": "f7fbb67e08a28d65f7cdd9c28cce696b013bb0dc", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 77, "deletions": 7, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1", "patch": "@@ -128,6 +128,10 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n     fn clean(&self, cx: &DocContext) -> Crate {\n         use rustc::session::config::Input;\n \n+        if let Some(t) = cx.tcx_opt() {\n+            cx.deref_trait_did.set(t.lang_items.deref_trait());\n+        }\n+\n         let mut externs = Vec::new();\n         cx.sess().cstore.iter_crate_data(|n, meta| {\n             externs.push((n, meta.clean(cx)));\n@@ -321,7 +325,7 @@ impl Item {\n                     attr::Unstable => \"unstable\".to_string(),\n                     attr::Stable => String::new(),\n                 };\n-                if s.deprecated_since.len() > 0 {\n+                if !s.deprecated_since.is_empty() {\n                     base.push_str(\" deprecated\");\n                 }\n                 base\n@@ -387,7 +391,7 @@ impl Clean<Item> for doctree::Module {\n         items.extend(self.statics.iter().map(|x| x.clean(cx)));\n         items.extend(self.constants.iter().map(|x| x.clean(cx)));\n         items.extend(self.traits.iter().map(|x| x.clean(cx)));\n-        items.extend(self.impls.iter().map(|x| x.clean(cx)));\n+        items.extend(self.impls.iter().flat_map(|x| x.clean(cx).into_iter()));\n         items.extend(self.macros.iter().map(|x| x.clean(cx)));\n         items.extend(self.def_traits.iter().map(|x| x.clean(cx)));\n \n@@ -2186,9 +2190,21 @@ fn detect_derived<M: AttrMetaMethods>(attrs: &[M]) -> bool {\n     attr::contains_name(attrs, \"automatically_derived\")\n }\n \n-impl Clean<Item> for doctree::Impl {\n-    fn clean(&self, cx: &DocContext) -> Item {\n-        Item {\n+impl Clean<Vec<Item>> for doctree::Impl {\n+    fn clean(&self, cx: &DocContext) -> Vec<Item> {\n+        let mut ret = Vec::new();\n+        let trait_ = self.trait_.clean(cx);\n+        let items = self.items.clean(cx);\n+\n+        // If this impl block is an implementation of the Deref trait, then we\n+        // need to try inlining the target's inherent impl blocks as well.\n+        if let Some(ResolvedPath { did, .. }) = trait_ {\n+            if Some(did) == cx.deref_trait_did.get() {\n+                build_deref_target_impls(cx, &items, &mut ret);\n+            }\n+        }\n+\n+        ret.push(Item {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n@@ -2198,12 +2214,66 @@ impl Clean<Item> for doctree::Impl {\n             inner: ImplItem(Impl {\n                 unsafety: self.unsafety,\n                 generics: self.generics.clean(cx),\n-                trait_: self.trait_.clean(cx),\n+                trait_: trait_,\n                 for_: self.for_.clean(cx),\n-                items: self.items.clean(cx),\n+                items: items,\n                 derived: detect_derived(&self.attrs),\n                 polarity: Some(self.polarity.clean(cx)),\n             }),\n+        });\n+        return ret;\n+    }\n+}\n+\n+fn build_deref_target_impls(cx: &DocContext,\n+                            items: &[Item],\n+                            ret: &mut Vec<Item>) {\n+    let tcx = match cx.tcx_opt() {\n+        Some(t) => t,\n+        None => return,\n+    };\n+\n+    for item in items {\n+        let target = match item.inner {\n+            TypedefItem(ref t) => &t.type_,\n+            _ => continue,\n+        };\n+        let primitive = match *target {\n+            ResolvedPath { did, .. } if ast_util::is_local(did) => continue,\n+            ResolvedPath { did, .. } => {\n+                ret.extend(inline::build_impls(cx, tcx, did));\n+                continue\n+            }\n+            _ => match target.primitive_type() {\n+                Some(prim) => prim,\n+                None => continue,\n+            }\n+        };\n+        let did = match primitive {\n+            Isize => tcx.lang_items.isize_impl(),\n+            I8 => tcx.lang_items.i8_impl(),\n+            I16 => tcx.lang_items.i16_impl(),\n+            I32 => tcx.lang_items.i32_impl(),\n+            I64 => tcx.lang_items.i64_impl(),\n+            Usize => tcx.lang_items.usize_impl(),\n+            U8 => tcx.lang_items.u8_impl(),\n+            U16 => tcx.lang_items.u16_impl(),\n+            U32 => tcx.lang_items.u32_impl(),\n+            U64 => tcx.lang_items.u64_impl(),\n+            F32 => tcx.lang_items.f32_impl(),\n+            F64 => tcx.lang_items.f64_impl(),\n+            Char => tcx.lang_items.char_impl(),\n+            Bool => None,\n+            Str => tcx.lang_items.str_impl(),\n+            Slice => tcx.lang_items.slice_impl(),\n+            Array => tcx.lang_items.slice_impl(),\n+            PrimitiveTuple => None,\n+            PrimitiveRawPointer => tcx.lang_items.const_ptr_impl(),\n+        };\n+        if let Some(did) = did {\n+            if !ast_util::is_local(did) {\n+                inline::build_impl(cx, tcx, did, ret);\n+            }\n         }\n     }\n }"}, {"sha": "1b74123c4adcde4a9fa17c9d2517e0d64a5354ae", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1", "patch": "@@ -20,7 +20,7 @@ use rustc_resolve as resolve;\n \n use syntax::{ast, ast_map, codemap, diagnostic};\n \n-use std::cell::RefCell;\n+use std::cell::{RefCell, Cell};\n use std::collections::{HashMap, HashSet};\n \n use visit_ast::RustdocVisitor;\n@@ -48,6 +48,7 @@ pub struct DocContext<'tcx> {\n     pub external_typarams: RefCell<Option<HashMap<ast::DefId, String>>>,\n     pub inlined: RefCell<Option<HashSet<ast::DefId>>>,\n     pub populated_crate_impls: RefCell<HashSet<ast::CrateNum>>,\n+    pub deref_trait_did: Cell<Option<ast::DefId>>,\n }\n \n impl<'tcx> DocContext<'tcx> {\n@@ -77,6 +78,7 @@ pub struct CrateAnalysis {\n     pub external_paths: ExternalPaths,\n     pub external_typarams: RefCell<Option<HashMap<ast::DefId, String>>>,\n     pub inlined: RefCell<Option<HashSet<ast::DefId>>>,\n+    pub deref_trait_did: Option<ast::DefId>,\n }\n \n pub type Externs = HashMap<String, Vec<String>>;\n@@ -147,15 +149,17 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n         external_paths: RefCell::new(Some(HashMap::new())),\n         inlined: RefCell::new(Some(HashSet::new())),\n         populated_crate_impls: RefCell::new(HashSet::new()),\n+        deref_trait_did: Cell::new(None),\n     };\n     debug!(\"crate: {:?}\", ctxt.krate);\n \n-    let analysis = CrateAnalysis {\n+    let mut analysis = CrateAnalysis {\n         exported_items: exported_items,\n         public_items: public_items,\n         external_paths: RefCell::new(None),\n         external_typarams: RefCell::new(None),\n         inlined: RefCell::new(None),\n+        deref_trait_did: None,\n     };\n \n     let krate = {\n@@ -170,5 +174,6 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n     *analysis.external_typarams.borrow_mut() = map;\n     let map = ctxt.inlined.borrow_mut().take();\n     *analysis.inlined.borrow_mut() = map;\n+    analysis.deref_trait_did = ctxt.deref_trait_did.get();\n     (krate, analysis)\n }"}, {"sha": "f87a86eb3a68c1d8315cc35183cbfc156140984b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 99, "deletions": 34, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1", "patch": "@@ -209,6 +209,7 @@ pub struct Cache {\n     privmod: bool,\n     remove_priv: bool,\n     public_items: NodeSet,\n+    deref_trait_did: Option<ast::DefId>,\n \n     // In rare case where a structure is defined in one module but implemented\n     // in another, if the implementing module is parsed before defining module,\n@@ -396,15 +397,14 @@ pub fn run(mut krate: clean::Crate,\n         public_items: public_items,\n         orphan_methods: Vec::new(),\n         traits: mem::replace(&mut krate.external_traits, HashMap::new()),\n+        deref_trait_did: analysis.as_ref().and_then(|a| a.deref_trait_did),\n         typarams: analysis.as_ref().map(|a| {\n             a.external_typarams.borrow_mut().take().unwrap()\n         }).unwrap_or(HashMap::new()),\n         inlined: analysis.as_ref().map(|a| {\n             a.inlined.borrow_mut().take().unwrap()\n         }).unwrap_or(HashSet::new()),\n     };\n-    cache.stack.push(krate.name.clone());\n-    krate = cache.fold_crate(krate);\n \n     // Cache where all our extern crates are located\n     for &(n, ref e) in &krate.externs {\n@@ -427,6 +427,9 @@ pub fn run(mut krate: clean::Crate,\n         cache.primitive_locations.insert(prim, ast::LOCAL_CRATE);\n     }\n \n+    cache.stack.push(krate.name.clone());\n+    krate = cache.fold_crate(krate);\n+\n     // Build our search index\n     let index = try!(build_index(&krate, &mut cache));\n \n@@ -1069,8 +1072,11 @@ impl DocFolder for Cache {\n                             }\n \n                             ref t => {\n-                                t.primitive_type().map(|p| {\n-                                    ast_util::local_def(p.to_node_id())\n+                                t.primitive_type().and_then(|t| {\n+                                    self.primitive_locations.get(&t).map(|n| {\n+                                        let id = t.to_node_id();\n+                                        ast::DefId { krate: *n, node: id }\n+                                    })\n                                 })\n                             }\n                         };\n@@ -1684,12 +1690,12 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n \n fn short_stability(item: &clean::Item, show_reason: bool) -> Option<String> {\n     item.stability.as_ref().and_then(|stab| {\n-        let reason = if show_reason && stab.reason.len() > 0 {\n+        let reason = if show_reason && !stab.reason.is_empty() {\n             format!(\": {}\", stab.reason)\n         } else {\n             String::new()\n         };\n-        let text = if stab.deprecated_since.len() > 0 {\n+        let text = if !stab.deprecated_since.is_empty() {\n             let since = if show_reason {\n                 format!(\" since {}\", Escape(&stab.deprecated_since))\n             } else {\n@@ -1865,7 +1871,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    try!(render_methods(w, it));\n+    try!(render_methods(w, it.def_id, MethodRender::All));\n \n     let cache = cache();\n     try!(write!(w, \"\n@@ -1995,7 +2001,7 @@ fn item_struct(w: &mut fmt::Formatter, it: &clean::Item,\n             try!(write!(w, \"</table>\"));\n         }\n     }\n-    render_methods(w, it)\n+    render_methods(w, it.def_id, MethodRender::All)\n }\n \n fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n@@ -2094,7 +2100,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n         try!(write!(w, \"</table>\"));\n \n     }\n-    try!(render_methods(w, it));\n+    try!(render_methods(w, it.def_id, MethodRender::All));\n     Ok(())\n }\n \n@@ -2183,55 +2189,114 @@ enum MethodLink {\n     GotoSource(ast::DefId),\n }\n \n-fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n-    let v = match cache().impls.get(&it.def_id) {\n-        Some(v) => v.clone(),\n+enum MethodRender<'a> {\n+    All,\n+    DerefFor { trait_: &'a clean::Type, type_: &'a clean::Type },\n+}\n+\n+fn render_methods(w: &mut fmt::Formatter,\n+                  it: ast::DefId,\n+                  what: MethodRender) -> fmt::Result {\n+    let c = cache();\n+    let v = match c.impls.get(&it) {\n+        Some(v) => v,\n         None => return Ok(()),\n     };\n-    let (non_trait, traits): (Vec<_>, _) = v.into_iter()\n-        .partition(|i| i.impl_.trait_.is_none());\n+    let (non_trait, traits): (Vec<_>, _) = v.iter().partition(|i| {\n+        i.impl_.trait_.is_none()\n+    });\n     if !non_trait.is_empty() {\n-        try!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n+        let render_header = match what {\n+            MethodRender::All => {\n+                try!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n+                true\n+            }\n+            MethodRender::DerefFor { trait_, type_ } => {\n+                try!(write!(w, \"<h2 id='deref-methods'>Methods from \\\n+                                    {}&lt;Target={}&gt;</h2>\", trait_, type_));\n+                false\n+            }\n+        };\n         for i in &non_trait {\n-            try!(render_impl(w, i, MethodLink::Anchor));\n+            try!(render_impl(w, i, MethodLink::Anchor, render_header));\n         }\n     }\n+    if let MethodRender::DerefFor { .. } = what {\n+        return Ok(())\n+    }\n     if !traits.is_empty() {\n+        let deref_impl = traits.iter().find(|t| {\n+            match *t.impl_.trait_.as_ref().unwrap() {\n+                clean::ResolvedPath { did, .. } => {\n+                    Some(did) == c.deref_trait_did\n+                }\n+                _ => false\n+            }\n+        });\n+        if let Some(impl_) = deref_impl {\n+            try!(render_deref_methods(w, impl_));\n+        }\n         try!(write!(w, \"<h2 id='implementations'>Trait \\\n                           Implementations</h2>\"));\n-        let (derived, manual): (Vec<_>, _) = traits.into_iter()\n-            .partition(|i| i.impl_.derived);\n+        let (derived, manual): (Vec<_>, _) = traits.iter().partition(|i| {\n+            i.impl_.derived\n+        });\n         for i in &manual {\n             let did = i.trait_did().unwrap();\n-            try!(render_impl(w, i, MethodLink::GotoSource(did)));\n+            try!(render_impl(w, i, MethodLink::GotoSource(did), true));\n         }\n         if !derived.is_empty() {\n             try!(write!(w, \"<h3 id='derived_implementations'>\\\n                 Derived Implementations \\\n             </h3>\"));\n             for i in &derived {\n                 let did = i.trait_did().unwrap();\n-                try!(render_impl(w, i, MethodLink::GotoSource(did)));\n+                try!(render_impl(w, i, MethodLink::GotoSource(did), true));\n             }\n         }\n     }\n     Ok(())\n }\n \n-fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink)\n-               -> fmt::Result {\n-    try!(write!(w, \"<h3 class='impl'><code>impl{} \",\n-                i.impl_.generics));\n-    if let Some(clean::ImplPolarity::Negative) = i.impl_.polarity {\n-        try!(write!(w, \"!\"));\n-    }\n-    if let Some(ref ty) = i.impl_.trait_ {\n-        try!(write!(w, \"{} for \", *ty));\n+fn render_deref_methods(w: &mut fmt::Formatter, impl_: &Impl) -> fmt::Result {\n+    let deref_type = impl_.impl_.trait_.as_ref().unwrap();\n+    let target = impl_.impl_.items.iter().filter_map(|item| {\n+        match item.inner {\n+            clean::TypedefItem(ref t) => Some(&t.type_),\n+            _ => None,\n+        }\n+    }).next().unwrap();\n+    let what = MethodRender::DerefFor { trait_: deref_type, type_: target };\n+    match *target {\n+        clean::ResolvedPath { did, .. } => render_methods(w, did, what),\n+        _ => {\n+            if let Some(prim) = target.primitive_type() {\n+                if let Some(c) = cache().primitive_locations.get(&prim) {\n+                    let did = ast::DefId { krate: *c, node: prim.to_node_id() };\n+                    try!(render_methods(w, did, what));\n+                }\n+            }\n+            Ok(())\n+        }\n     }\n-    try!(write!(w, \"{}{}</code></h3>\", i.impl_.for_,\n-                WhereClause(&i.impl_.generics)));\n-    if let Some(ref dox) = i.dox {\n-        try!(write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox)));\n+}\n+\n+fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink,\n+               render_header: bool) -> fmt::Result {\n+    if render_header {\n+        try!(write!(w, \"<h3 class='impl'><code>impl{} \",\n+                    i.impl_.generics));\n+        if let Some(clean::ImplPolarity::Negative) = i.impl_.polarity {\n+            try!(write!(w, \"!\"));\n+        }\n+        if let Some(ref ty) = i.impl_.trait_ {\n+            try!(write!(w, \"{} for \", *ty));\n+        }\n+        try!(write!(w, \"{}{}</code></h3>\", i.impl_.for_,\n+                    WhereClause(&i.impl_.generics)));\n+        if let Some(ref dox) = i.dox {\n+            try!(write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox)));\n+        }\n     }\n \n     fn doctraititem(w: &mut fmt::Formatter, item: &clean::Item,\n@@ -2393,7 +2458,7 @@ fn item_primitive(w: &mut fmt::Formatter,\n                   it: &clean::Item,\n                   _p: &clean::PrimitiveType) -> fmt::Result {\n     try!(document(w, it));\n-    render_methods(w, it)\n+    render_methods(w, it.def_id, MethodRender::All)\n }\n \n fn get_basic_keywords() -> &'static str {"}, {"sha": "c94dbc15103321f031d33a8ed0d587484d239530", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1", "patch": "@@ -481,9 +481,12 @@ em.stab.unstable { background: #FFF5D6; border-color: #FFC600; }\n em.stab.deprecated { background: #F3DFFF; border-color: #7F0087; }\n em.stab {\n     display: inline-block;\n-    border-width: 2px;\n+    border-width: 1px;\n     border-style: solid;\n-    padding: 5px;\n+    padding: 3px;\n+    margin-bottom: 5px;\n+    font-size: 90%;\n+    font-style: normal;\n }\n em.stab p {\n     display: inline;\n@@ -492,6 +495,7 @@ em.stab p {\n .module-item .stab {\n     border-width: 0;\n     padding: 0;\n+    margin: 0;\n     background: inherit !important;\n }\n "}, {"sha": "bbe0a6f267538e9524e387dc55306ebf30f388da", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cell::RefCell;\n+use std::cell::{RefCell, Cell};\n use std::collections::{HashSet, HashMap};\n use std::dynamic_lib::DynamicLibrary;\n use std::env;\n@@ -92,6 +92,7 @@ pub fn run(input: &str,\n         external_typarams: RefCell::new(None),\n         inlined: RefCell::new(None),\n         populated_crate_impls: RefCell::new(HashSet::new()),\n+        deref_trait_did: Cell::new(None),\n     };\n \n     let mut v = RustdocVisitor::new(&ctx, None);"}, {"sha": "435f0176162b89db3968973dae1f18e37324bf84", "filename": "src/test/auxiliary/issue-19190-3.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1/src%2Ftest%2Fauxiliary%2Fissue-19190-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1/src%2Ftest%2Fauxiliary%2Fissue-19190-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-19190-3.rs?ref=71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::Deref;\n+\n+pub struct Foo;\n+\n+impl Deref for Foo {\n+    type Target = i32;\n+    fn deref(&self) -> &i32 { loop {} }\n+}\n+\n+pub struct Bar;\n+pub struct Baz;\n+\n+impl Baz {\n+    pub fn baz(&self) {}\n+}\n+\n+impl Deref for Bar {\n+    type Target = Baz;\n+    fn deref(&self) -> &Baz { loop {} }\n+}"}, {"sha": "b84ec6d616636b211adcbf790921e78cb0f9e0d6", "filename": "src/test/rustdoc/issue-19190-2.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1/src%2Ftest%2Frustdoc%2Fissue-19190-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1/src%2Ftest%2Frustdoc%2Fissue-19190-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-19190-2.rs?ref=71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::Deref;\n+\n+pub struct Bar;\n+\n+impl Deref for Bar {\n+    type Target = i32;\n+    fn deref(&self) -> &i32 { loop {} }\n+}\n+\n+// @has issue_19190_2/struct.Bar.html\n+// @has - '//*[@id=\"method.count_ones\"]' 'fn count_ones(self) -> u32'\n+"}, {"sha": "c315ea26d264291f3ec4a8641c1dc3797d2afc04", "filename": "src/test/rustdoc/issue-19190-3.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1/src%2Ftest%2Frustdoc%2Fissue-19190-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1/src%2Ftest%2Frustdoc%2Fissue-19190-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-19190-3.rs?ref=71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-19190-3.rs\n+// ignore-android\n+\n+extern crate issue_19190_3;\n+\n+use std::ops::Deref;\n+use issue_19190_3::Baz;\n+\n+// @has issue_19190_3/struct.Foo.html\n+// @has - '//*[@id=\"method.count_ones\"]' 'fn count_ones(self) -> u32'\n+pub use issue_19190_3::Foo;\n+\n+// @has issue_19190_3/struct.Bar.html\n+// @has - '//*[@id=\"method.baz\"]' 'fn baz(&self)'\n+pub use issue_19190_3::Bar;\n+\n+// @has issue_19190_3/struct.MyBar.html\n+// @has - '//*[@id=\"method.baz\"]' 'fn baz(&self)'\n+pub struct MyBar;\n+\n+impl Deref for MyBar {\n+    type Target = Baz;\n+    fn deref(&self) -> &Baz { loop {} }\n+}\n+"}, {"sha": "f011a3e64a6be0f6ba8023ac2f8dc54b29a87eaf", "filename": "src/test/rustdoc/issue-19190.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1/src%2Ftest%2Frustdoc%2Fissue-19190.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1/src%2Ftest%2Frustdoc%2Fissue-19190.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-19190.rs?ref=71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::Deref;\n+\n+pub struct Foo;\n+pub struct Bar;\n+\n+impl Foo {\n+    pub fn foo(&self) {}\n+}\n+\n+impl Deref for Bar {\n+    type Target = Foo;\n+    fn deref(&self) -> &Foo { loop {} }\n+}\n+\n+// @has issue_19190/struct.Bar.html\n+// @has - '//*[@id=\"method.foo\"]' 'fn foo(&self)'"}]}