{"sha": "786dea207d5b891d37e596e96dd2f84c4cb59f49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4NmRlYTIwN2Q1Yjg5MWQzN2U1OTZlOTZkZDJmODRjNGNiNTlmNDk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-04T00:44:16Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-10T23:13:12Z"}, "message": "libextra: Another round of de-`Cell`-ing.\n\n34 uses of `Cell` remain.", "tree": {"sha": "f275936b26e6602b11363446fcac5ad3b09dbe92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f275936b26e6602b11363446fcac5ad3b09dbe92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/786dea207d5b891d37e596e96dd2f84c4cb59f49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/786dea207d5b891d37e596e96dd2f84c4cb59f49", "html_url": "https://github.com/rust-lang/rust/commit/786dea207d5b891d37e596e96dd2f84c4cb59f49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/786dea207d5b891d37e596e96dd2f84c4cb59f49/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5aad292fb99f7e9a2730b35ed535bda0ab9c6117", "url": "https://api.github.com/repos/rust-lang/rust/commits/5aad292fb99f7e9a2730b35ed535bda0ab9c6117", "html_url": "https://github.com/rust-lang/rust/commit/5aad292fb99f7e9a2730b35ed535bda0ab9c6117"}], "stats": {"total": 598, "additions": 211, "deletions": 387}, "files": [{"sha": "58007e491da8914e0164fbbbe9e3f13e3bb4b8fd", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -628,10 +628,10 @@ mod tests {\n         let arc = ~MutexArc::new(false);\n         let arc2 = ~arc.clone();\n         let (p,c) = comm::oneshot();\n-        let (c,p) = (Cell::new(c), Cell::new(p));\n-        do task::spawn || {\n+        let c = Cell::new(c);\n+        do task::spawn {\n             // wait until parent gets in\n-            p.take().recv();\n+            p.recv();\n             arc2.access_cond(|state, cond| {\n                 *state = true;\n                 cond.signal();"}, {"sha": "1a2ac39813270db92ff252e213a470e9f55660c1", "filename": "src/libextra/future.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -25,7 +25,6 @@\n \n #[allow(missing_doc)];\n \n-use std::cell::Cell;\n use std::comm::{PortOne, oneshot};\n use std::util::replace;\n \n@@ -113,9 +112,8 @@ impl<A:Send> Future<A> {\n          * waiting for the result to be received on the port.\n          */\n \n-        let port = Cell::new(port);\n         do Future::from_fn {\n-            port.take().recv()\n+            port.recv()\n         }\n     }\n \n@@ -141,7 +139,6 @@ impl<A:Send> Future<A> {\n mod test {\n     use future::Future;\n \n-    use std::cell::Cell;\n     use std::comm::oneshot;\n     use std::task;\n \n@@ -199,9 +196,9 @@ mod test {\n     #[test]\n     fn test_sendable_future() {\n         let expected = \"schlorf\";\n-        let f = Cell::new(do Future::spawn { expected });\n+        let f = do Future::spawn { expected };\n         do task::spawn {\n-            let mut f = f.take();\n+            let mut f = f;\n             let actual = f.get();\n             assert_eq!(actual, expected);\n         }"}, {"sha": "1bda69360c22edd8cb368dfe0ae078481827beb0", "filename": "src/libextra/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -872,15 +872,14 @@ pub fn run_test(force_ignore: bool,\n     fn run_test_inner(desc: TestDesc,\n                       monitor_ch: SharedChan<MonitorMsg>,\n                       testfn: proc()) {\n-        let testfn_cell = ::std::cell::Cell::new(testfn);\n         do task::spawn {\n             let mut task = task::task();\n             task.name(match desc.name {\n                 DynTestName(ref name) => SendStrOwned(name.clone()),\n                 StaticTestName(name) => SendStrStatic(name),\n             });\n             let result_future = task.future_result();\n-            task.spawn(testfn_cell.take());\n+            task.spawn(testfn);\n \n             let task_result = result_future.recv();\n             let test_result = calc_result(&desc, task_result.is_ok());"}, {"sha": "1487cee75cc870fb6da392080840ae84aa15f707", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -15,7 +15,6 @@ use json::ToJson;\n use serialize::{Encoder, Encodable, Decoder, Decodable};\n use arc::{Arc,RWArc};\n use treemap::TreeMap;\n-use std::cell::Cell;\n use std::comm::{PortOne, oneshot};\n use std::{str, task};\n use std::io;\n@@ -430,15 +429,13 @@ impl<'self> Prep<'self> {\n                 debug!(\"Cache miss!\");\n                 let (port, chan) = oneshot();\n                 let blk = bo.take_unwrap();\n-                let chan = Cell::new(chan);\n \n                 // XXX: What happens if the task fails?\n                 do task::spawn {\n                     let mut exe = Exec {\n                         discovered_inputs: WorkMap::new(),\n                         discovered_outputs: WorkMap::new(),\n                     };\n-                    let chan = chan.take();\n                     let v = blk(&mut exe);\n                     chan.send((exe, v));\n                 }"}, {"sha": "9edb80d8e744995c0e9a358de2167bf12a8b4a32", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -24,7 +24,6 @@ extern mod syntax;\n extern mod rustc;\n extern mod extra;\n \n-use std::cell::Cell;\n use std::local_data;\n use std::io;\n use std::io::File;\n@@ -194,13 +193,13 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n     let mut plugins = matches.opt_strs(\"plugins\");\n \n     // First, parse the crate and extract all relevant information.\n-    let libs = Cell::new(matches.opt_strs(\"L\").map(|s| Path::new(s.as_slice())));\n-    let cfgs = Cell::new(matches.opt_strs(\"cfg\"));\n-    let cr = Cell::new(Path::new(cratefile));\n+    let libs = matches.opt_strs(\"L\").map(|s| Path::new(s.as_slice()));\n+    let cfgs = matches.opt_strs(\"cfg\");\n+    let cr = Path::new(cratefile);\n     info!(\"starting to run rustc\");\n     let (crate, analysis) = do std::task::try {\n-        let cr = cr.take();\n-        core::run_core(libs.take().move_iter().collect(), cfgs.take(), &cr)\n+        let cr = cr;\n+        core::run_core(libs.move_iter().collect(), cfgs, &cr)\n     }.unwrap();\n     info!(\"finished with rustc\");\n     local_data::set(analysiskey, analysis);"}, {"sha": "1ca9fb1e98ccd860a3f9f8f265afe276318e8299", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -8,12 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::num;\n-use std::cell::Cell;\n-use std::uint;\n use std::hashmap::HashSet;\n use std::local_data;\n-\n+use std::num;\n+use std::uint;\n use syntax::ast;\n \n use clean;\n@@ -56,11 +54,10 @@ pub fn strip_hidden(crate: clean::Crate) -> plugins::PluginResult {\n pub fn strip_private(crate: clean::Crate) -> plugins::PluginResult {\n     // This stripper collects all *retained* nodes.\n     let mut retained = HashSet::new();\n-    let crate = Cell::new(crate);\n     let exported_items = local_data::get(super::analysiskey, |analysis| {\n         analysis.unwrap().exported_items.clone()\n     });\n-    let mut crate = crate.take();\n+    let mut crate = crate;\n \n     // strip all private items\n     {"}, {"sha": "efc2d2c866dae33df67bf8fbe90fe4065549dced", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -125,7 +125,6 @@ impl Drop for AsyncWatcher {\n \n #[cfg(test)]\n mod test_remote {\n-    use std::cell::Cell;\n     use std::rt::rtio::Callback;\n     use std::rt::thread::Thread;\n     use std::rt::tube::Tube;\n@@ -150,10 +149,10 @@ mod test_remote {\n \n         let mut tube = Tube::new();\n         let cb = ~MyCallback(Some(tube.clone()));\n-        let watcher = Cell::new(AsyncWatcher::new(local_loop(), cb as ~Callback));\n+        let watcher = AsyncWatcher::new(local_loop(), cb as ~Callback);\n \n         let thread = do Thread::start {\n-            watcher.take().fire();\n+            watcher.fire();\n         };\n \n         assert_eq!(tube.recv(), 1);"}, {"sha": "1af0266f16a81bbb8b5205acf269e4c7e3d19153", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 28, "deletions": 53, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -691,7 +691,6 @@ mod test {\n     #[test]\n     fn listen_ip4() {\n         let (port, chan) = oneshot();\n-        let chan = Cell::new(chan);\n         let addr = next_test_ip4();\n \n         do spawn {\n@@ -701,7 +700,7 @@ mod test {\n             let mut w = match w.listen() {\n                 Ok(w) => w, Err(e) => fail!(\"{:?}\", e),\n             };\n-            chan.take().send(());\n+            chan.send(());\n             match w.accept() {\n                 Ok(mut stream) => {\n                     let mut buf = [0u8, ..10];\n@@ -728,7 +727,6 @@ mod test {\n     #[test]\n     fn listen_ip6() {\n         let (port, chan) = oneshot();\n-        let chan = Cell::new(chan);\n         let addr = next_test_ip6();\n \n         do spawn {\n@@ -738,7 +736,7 @@ mod test {\n             let mut w = match w.listen() {\n                 Ok(w) => w, Err(e) => fail!(\"{:?}\", e),\n             };\n-            chan.take().send(());\n+            chan.send(());\n             match w.accept() {\n                 Ok(mut stream) => {\n                     let mut buf = [0u8, ..10];\n@@ -765,14 +763,13 @@ mod test {\n     #[test]\n     fn udp_recv_ip4() {\n         let (port, chan) = oneshot();\n-        let chan = Cell::new(chan);\n         let client = next_test_ip4();\n         let server = next_test_ip4();\n \n         do spawn {\n             match UdpWatcher::bind(local_loop(), server) {\n                 Ok(mut w) => {\n-                    chan.take().send(());\n+                    chan.send(());\n                     let mut buf = [0u8, ..10];\n                     match w.recvfrom(buf) {\n                         Ok((10, addr)) => assert_eq!(addr, client),\n@@ -798,14 +795,13 @@ mod test {\n     #[test]\n     fn udp_recv_ip6() {\n         let (port, chan) = oneshot();\n-        let chan = Cell::new(chan);\n         let client = next_test_ip6();\n         let server = next_test_ip6();\n \n         do spawn {\n             match UdpWatcher::bind(local_loop(), server) {\n                 Ok(mut w) => {\n-                    chan.take().send(());\n+                    chan.send(());\n                     let mut buf = [0u8, ..10];\n                     match w.recvfrom(buf) {\n                         Ok((10, addr)) => assert_eq!(addr, client),\n@@ -834,13 +830,11 @@ mod test {\n         let addr = next_test_ip4();\n         static MAX: uint = 5000;\n         let (port, chan) = oneshot();\n-        let port = Cell::new(port);\n-        let chan = Cell::new(chan);\n \n         do spawn {\n             let listener = TcpListener::bind(local_loop(), addr).unwrap();\n             let mut acceptor = listener.listen().unwrap();\n-            chan.take().send(());\n+            chan.send(());\n             let mut stream = acceptor.accept().unwrap();\n             let buf = [1, .. 2048];\n             let mut total_bytes_written = 0;\n@@ -852,7 +846,7 @@ mod test {\n         }\n \n         do spawn {\n-            port.take().recv();\n+            port.recv();\n             let mut stream = TcpWatcher::connect(local_loop(), addr).unwrap();\n             let mut buf = [0, .. 2048];\n             let mut total_bytes_read = 0;\n@@ -873,18 +867,16 @@ mod test {\n         let server_addr = next_test_ip4();\n         let client_addr = next_test_ip4();\n         let (port, chan) = oneshot();\n-        let port = Cell::new(port);\n-        let chan = Cell::new(chan);\n \n         do spawn {\n             let mut client = UdpWatcher::bind(local_loop(), client_addr).unwrap();\n-            port.take().recv();\n+            port.recv();\n             assert!(client.sendto([1], server_addr).is_ok());\n             assert!(client.sendto([2], server_addr).is_ok());\n         }\n \n         let mut server = UdpWatcher::bind(local_loop(), server_addr).unwrap();\n-        chan.take().send(());\n+        chan.send(());\n         let mut buf1 = [0];\n         let mut buf2 = [0];\n         let (nread1, src1) = server.recvfrom(buf1).unwrap();\n@@ -908,14 +900,11 @@ mod test {\n         let (p1, c1) = oneshot();\n         let (p2, c2) = oneshot();\n \n-        let first = Cell::new((p1, c2));\n-        let second = Cell::new((p2, c1));\n-\n         do spawn {\n             let l = local_loop();\n             let mut server_out = UdpWatcher::bind(l, server_out_addr).unwrap();\n             let mut server_in = UdpWatcher::bind(l, server_in_addr).unwrap();\n-            let (port, chan) = first.take();\n+            let (port, chan) = (p1, c2);\n             chan.send(());\n             port.recv();\n             let msg = [1, .. 2048];\n@@ -939,7 +928,7 @@ mod test {\n             let l = local_loop();\n             let mut client_out = UdpWatcher::bind(l, client_out_addr).unwrap();\n             let mut client_in = UdpWatcher::bind(l, client_in_addr).unwrap();\n-            let (port, chan) = second.take();\n+            let (port, chan) = (p2, c1);\n             port.recv();\n             chan.send(());\n             let mut total_bytes_recv = 0;\n@@ -966,14 +955,12 @@ mod test {\n     fn test_read_and_block() {\n         let addr = next_test_ip4();\n         let (port, chan) = oneshot();\n-        let port = Cell::new(port);\n-        let chan = Cell::new(chan);\n \n         do spawn {\n             let listener = TcpListener::bind(local_loop(), addr).unwrap();\n             let mut acceptor = listener.listen().unwrap();\n             let (port2, chan2) = stream();\n-            chan.take().send(port2);\n+            chan.send(port2);\n             let mut stream = acceptor.accept().unwrap();\n             let mut buf = [0, .. 2048];\n \n@@ -998,7 +985,7 @@ mod test {\n         }\n \n         do spawn {\n-            let port2 = port.take().recv();\n+            let port2 = port.recv();\n             let mut stream = TcpWatcher::connect(local_loop(), addr).unwrap();\n             stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n             stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n@@ -1041,18 +1028,14 @@ mod test {\n     #[test]\n     fn test_homing_closes_correctly() {\n         let (port, chan) = oneshot();\n-        let port = Cell::new(port);\n-        let chan = Cell::new(chan);\n \n         do task::spawn_sched(task::SingleThreaded) {\n-            let chan = Cell::new(chan.take());\n             let listener = UdpWatcher::bind(local_loop(), next_test_ip4()).unwrap();\n-            chan.take().send(listener);\n+            chan.send(listener);\n         }\n \n         do task::spawn_sched(task::SingleThreaded) {\n-            let port = Cell::new(port.take());\n-            port.take().recv();\n+            port.recv();\n         }\n     }\n \n@@ -1086,13 +1069,13 @@ mod test {\n             let mut sched2 = ~Scheduler::new(loop2, worker2, queues.clone(),\n                                              sleepers.clone());\n \n-            let handle1 = Cell::new(sched1.make_handle());\n-            let handle2 = Cell::new(sched2.make_handle());\n+            let handle1 = sched1.make_handle();\n+            let handle2 = sched2.make_handle();\n             let tasksFriendHandle = Cell::new(sched2.make_handle());\n \n             let on_exit: proc(UnwindResult) = proc(exit_status) {\n-                handle1.take().send(Shutdown);\n-                handle2.take().send(Shutdown);\n+                handle1.send(Shutdown);\n+                handle2.send(Shutdown);\n                 assert!(exit_status.is_success());\n             };\n \n@@ -1133,19 +1116,16 @@ mod test {\n             let mut main_task = ~Task::new_root(&mut sched1.stack_pool, None,\n                                                 test_function);\n             main_task.death.on_exit = Some(on_exit);\n-            let main_task = Cell::new(main_task);\n-\n-            let null_task = Cell::new(~do Task::new_root(&mut sched2.stack_pool,\n-                                                         None) || {});\n \n-            let sched1 = Cell::new(sched1);\n-            let sched2 = Cell::new(sched2);\n+            let null_task = ~do Task::new_root(&mut sched2.stack_pool, None) {\n+                // nothing\n+            };\n \n             let thread1 = do Thread::start {\n-                sched1.take().bootstrap(main_task.take());\n+                sched1.bootstrap(main_task);\n             };\n             let thread2 = do Thread::start {\n-                sched2.take().bootstrap(null_task.take());\n+                sched2.bootstrap(null_task);\n             };\n \n             thread1.join();\n@@ -1164,13 +1144,12 @@ mod test {\n     #[should_fail] #[test]\n     fn tcp_stream_fail_cleanup() {\n         let (port, chan) = oneshot();\n-        let chan = Cell::new(chan);\n         let addr = next_test_ip4();\n \n         do spawn {\n             let w = TcpListener::bind(local_loop(), addr).unwrap();\n             let mut w = w.listen().unwrap();\n-            chan.take().send(());\n+            chan.send(());\n             w.accept();\n         }\n         port.recv();\n@@ -1189,14 +1168,13 @@ mod test {\n     fn udp_fail_other_task() {\n         let addr = next_test_ip4();\n         let (port, chan) = oneshot();\n-        let chan = Cell::new(chan);\n \n         // force the handle to be created on a different scheduler, failure in\n         // the original task will force a homing operation back to this\n         // scheduler.\n         do task::spawn_sched(task::SingleThreaded) {\n             let w = UdpWatcher::bind(local_loop(), addr).unwrap();\n-            chan.take().send(w);\n+            chan.send(w);\n         }\n \n         let _w = port.recv();\n@@ -1208,13 +1186,12 @@ mod test {\n     #[ignore(reason = \"linked failure\")]\n     fn linked_failure1() {\n         let (port, chan) = oneshot();\n-        let chan = Cell::new(chan);\n         let addr = next_test_ip4();\n \n         do spawn {\n             let w = TcpListener::bind(local_loop(), addr).unwrap();\n             let mut w = w.listen().unwrap();\n-            chan.take().send(());\n+            chan.send(());\n             w.accept();\n         }\n \n@@ -1227,13 +1204,12 @@ mod test {\n     #[ignore(reason = \"linked failure\")]\n     fn linked_failure2() {\n         let (port, chan) = oneshot();\n-        let chan = Cell::new(chan);\n         let addr = next_test_ip4();\n \n         do spawn {\n             let w = TcpListener::bind(local_loop(), addr).unwrap();\n             let mut w = w.listen().unwrap();\n-            chan.take().send(());\n+            chan.send(());\n             let mut buf = [0];\n             w.accept().unwrap().read(buf);\n         }\n@@ -1249,11 +1225,10 @@ mod test {\n     #[ignore(reason = \"linked failure\")]\n     fn linked_failure3() {\n         let (port, chan) = stream();\n-        let chan = Cell::new(chan);\n         let addr = next_test_ip4();\n \n         do spawn {\n-            let chan = chan.take();\n+            let chan = chan;\n             let w = TcpListener::bind(local_loop(), addr).unwrap();\n             let mut w = w.listen().unwrap();\n             chan.send(());"}, {"sha": "86ebae45f19530960ee4c88bf3c5fbcc62728535", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -231,7 +231,6 @@ impl HomingIO for PipeAcceptor {\n \n #[cfg(test)]\n mod tests {\n-    use std::cell::Cell;\n     use std::comm::oneshot;\n     use std::rt::rtio::{RtioUnixListener, RtioUnixAcceptor, RtioPipe};\n     use std::rt::test::next_test_unix;\n@@ -276,12 +275,11 @@ mod tests {\n         let path = next_test_unix();\n         let path2 = path.clone();\n         let (port, chan) = oneshot();\n-        let chan = Cell::new(chan);\n \n         do spawn {\n             let p = PipeListener::bind(local_loop(), &path2.to_c_str()).unwrap();\n             let mut p = p.listen().unwrap();\n-            chan.take().send(());\n+            chan.send(());\n             let mut client = p.accept().unwrap();\n             let mut buf = [0];\n             assert!(client.read(buf).unwrap() == 1);\n@@ -301,12 +299,11 @@ mod tests {\n         let path = next_test_unix();\n         let path2 = path.clone();\n         let (port, chan) = oneshot();\n-        let chan = Cell::new(chan);\n \n         do spawn {\n             let p = PipeListener::bind(local_loop(), &path2.to_c_str()).unwrap();\n             let mut p = p.listen().unwrap();\n-            chan.take().send(());\n+            chan.send(());\n             p.accept();\n         }\n         port.recv();"}, {"sha": "db698f80e38c1b7cc330719c0ed689808f1c7a9d", "filename": "src/librustuv/signal.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -76,7 +76,6 @@ impl Drop for SignalWatcher {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use std::cell::Cell;\n     use super::super::local_loop;\n     use std::io::signal;\n     use std::comm::{SharedChan, stream};\n@@ -89,9 +88,8 @@ mod test {\n         let _signal = SignalWatcher::new(local_loop(), signal::Interrupt,\n                                          chan);\n \n-        let port = Cell::new(port);\n         do spawn {\n-            port.take().try_recv();\n+            port.try_recv();\n         }\n \n         // when we drop the SignalWatcher we're going to destroy the channel,"}, {"sha": "a229c000066d8b3f34d837b363b39aaed4edf97e", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -163,7 +163,6 @@ impl Drop for TimerWatcher {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use std::cell::Cell;\n     use std::rt::rtio::RtioTimer;\n     use super::super::local_loop;\n \n@@ -229,10 +228,10 @@ mod test {\n     fn closing_channel_during_drop_doesnt_kill_everything() {\n         // see issue #10375\n         let mut timer = TimerWatcher::new(local_loop());\n-        let timer_port = Cell::new(timer.period(1000));\n+        let timer_port = timer.period(1000);\n \n         do spawn {\n-            timer_port.take().try_recv();\n+            timer_port.try_recv();\n         }\n \n         // when we drop the TimerWatcher we're going to destroy the channel,\n@@ -243,10 +242,10 @@ mod test {\n     fn reset_doesnt_switch_tasks() {\n         // similar test to the one above.\n         let mut timer = TimerWatcher::new(local_loop());\n-        let timer_port = Cell::new(timer.period(1000));\n+        let timer_port = timer.period(1000);\n \n         do spawn {\n-            timer_port.take().try_recv();\n+            timer_port.try_recv();\n         }\n \n         timer.oneshot(1);\n@@ -255,10 +254,10 @@ mod test {\n     fn reset_doesnt_switch_tasks2() {\n         // similar test to the one above.\n         let mut timer = TimerWatcher::new(local_loop());\n-        let timer_port = Cell::new(timer.period(1000));\n+        let timer_port = timer.period(1000);\n \n         do spawn {\n-            timer_port.take().try_recv();\n+            timer_port.try_recv();\n         }\n \n         timer.sleep(1);"}, {"sha": "122ededfbc3a9f88f0c03e7b6f78bfbd48c40e9d", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 30, "deletions": 61, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -146,7 +146,6 @@ impl Acceptor<TcpStream> for TcpAcceptor {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use cell::Cell;\n     use rt::test::*;\n     use io::net::ip::{Ipv4Addr, SocketAddr};\n     use io::*;\n@@ -196,20 +195,18 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip4();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 let mut stream = acceptor.accept();\n                 let mut buf = [0];\n                 stream.read(buf);\n                 assert!(buf[0] == 99);\n             }\n \n             do spawntask {\n-                port.take().recv();\n+                port.recv();\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write([99]);\n             }\n@@ -221,20 +218,18 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip6();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 let mut stream = acceptor.accept();\n                 let mut buf = [0];\n                 stream.read(buf);\n                 assert!(buf[0] == 99);\n             }\n \n             do spawntask {\n-                port.take().recv();\n+                port.recv();\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write([99]);\n             }\n@@ -246,20 +241,18 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip4();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 let mut stream = acceptor.accept();\n                 let mut buf = [0];\n                 let nread = stream.read(buf);\n                 assert!(nread.is_none());\n             }\n \n             do spawntask {\n-                port.take().recv();\n+                port.recv();\n                 let _stream = TcpStream::connect(addr);\n                 // Close\n             }\n@@ -271,20 +264,18 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip6();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 let mut stream = acceptor.accept();\n                 let mut buf = [0];\n                 let nread = stream.read(buf);\n                 assert!(nread.is_none());\n             }\n \n             do spawntask {\n-                port.take().recv();\n+                port.recv();\n                 let _stream = TcpStream::connect(addr);\n                 // Close\n             }\n@@ -296,12 +287,10 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip4();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 let mut stream = acceptor.accept();\n                 let mut buf = [0];\n                 let nread = stream.read(buf);\n@@ -319,7 +308,7 @@ mod test {\n             }\n \n             do spawntask {\n-                port.take().recv();\n+                port.recv();\n                 let _stream = TcpStream::connect(addr);\n                 // Close\n             }\n@@ -331,12 +320,10 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip6();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 let mut stream = acceptor.accept();\n                 let mut buf = [0];\n                 let nread = stream.read(buf);\n@@ -354,7 +341,7 @@ mod test {\n             }\n \n             do spawntask {\n-                port.take().recv();\n+                port.recv();\n                 let _stream = TcpStream::connect(addr);\n                 // Close\n             }\n@@ -366,12 +353,10 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip4();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 let mut stream = acceptor.accept();\n                 let buf = [0];\n                 loop {\n@@ -392,7 +377,7 @@ mod test {\n             }\n \n             do spawntask {\n-                port.take().recv();\n+                port.recv();\n                 let _stream = TcpStream::connect(addr);\n                 // Close\n             }\n@@ -404,12 +389,10 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip6();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 let mut stream = acceptor.accept();\n                 let buf = [0];\n                 loop {\n@@ -430,7 +413,7 @@ mod test {\n             }\n \n             do spawntask {\n-                port.take().recv();\n+                port.recv();\n                 let _stream = TcpStream::connect(addr);\n                 // Close\n             }\n@@ -443,12 +426,10 @@ mod test {\n             let addr = next_test_ip4();\n             let max = 10;\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 for ref mut stream in acceptor.incoming().take(max) {\n                     let mut buf = [0];\n                     stream.read(buf);\n@@ -457,7 +438,7 @@ mod test {\n             }\n \n             do spawntask {\n-                port.take().recv();\n+                port.recv();\n                 max.times(|| {\n                     let mut stream = TcpStream::connect(addr);\n                     stream.write([99]);\n@@ -472,12 +453,10 @@ mod test {\n             let addr = next_test_ip6();\n             let max = 10;\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 for ref mut stream in acceptor.incoming().take(max) {\n                     let mut buf = [0];\n                     stream.read(buf);\n@@ -486,7 +465,7 @@ mod test {\n             }\n \n             do spawntask {\n-                port.take().recv();\n+                port.recv();\n                 max.times(|| {\n                     let mut stream = TcpStream::connect(addr);\n                     stream.write([99]);\n@@ -501,16 +480,14 @@ mod test {\n             let addr = next_test_ip4();\n             static MAX: int = 10;\n             let (port, chan) = oneshot();\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n-                    let stream = Cell::new(stream);\n                     // Start another task to handle the connection\n                     do spawntask {\n-                        let mut stream = stream.take();\n+                        let mut stream = stream;\n                         let mut buf = [0];\n                         stream.read(buf);\n                         assert!(buf[0] == i as u8);\n@@ -543,16 +520,14 @@ mod test {\n             let addr = next_test_ip6();\n             static MAX: int = 10;\n             let (port, chan) = oneshot();\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n-                    let stream = Cell::new(stream);\n                     // Start another task to handle the connection\n                     do spawntask {\n-                        let mut stream = stream.take();\n+                        let mut stream = stream;\n                         let mut buf = [0];\n                         stream.read(buf);\n                         assert!(buf[0] == i as u8);\n@@ -585,16 +560,14 @@ mod test {\n             let addr = next_test_ip4();\n             static MAX: int = 10;\n             let (port, chan) = oneshot();\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 for stream in acceptor.incoming().take(MAX as uint) {\n-                    let stream = Cell::new(stream);\n                     // Start another task to handle the connection\n                     do spawntask_later {\n-                        let mut stream = stream.take();\n+                        let mut stream = stream;\n                         let mut buf = [0];\n                         stream.read(buf);\n                         assert!(buf[0] == 99);\n@@ -626,16 +599,14 @@ mod test {\n             let addr = next_test_ip6();\n             static MAX: int = 10;\n             let (port, chan) = oneshot();\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 for stream in acceptor.incoming().take(MAX as uint) {\n-                    let stream = Cell::new(stream);\n                     // Start another task to handle the connection\n                     do spawntask_later {\n-                        let mut stream = stream.take();\n+                        let mut stream = stream;\n                         let mut buf = [0];\n                         stream.read(buf);\n                         assert!(buf[0] == 99);\n@@ -682,18 +653,16 @@ mod test {\n     fn peer_name(addr: SocketAddr) {\n         do run_in_mt_newsched_task {\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n \n                 acceptor.accept();\n             }\n \n             do spawntask {\n-                port.take().recv();\n+                port.recv();\n                 let stream = TcpStream::connect(addr);\n \n                 assert!(stream.is_some());"}, {"sha": "2e07269ed0ca512cdeb6f51aa7d5e098bd18f3ea", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -110,7 +110,6 @@ mod test {\n     use io::*;\n     use option::{Some, None};\n     use rt::comm::oneshot;\n-    use cell::Cell;\n \n     #[test]  #[ignore]\n     fn bind_error() {\n@@ -134,13 +133,11 @@ mod test {\n             let server_ip = next_test_ip4();\n             let client_ip = next_test_ip4();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 match UdpSocket::bind(server_ip) {\n                     Some(ref mut server) => {\n-                        chan.take().send(());\n+                        chan.send(());\n                         let mut buf = [0];\n                         match server.recvfrom(buf) {\n                             Some((nread, src)) => {\n@@ -158,7 +155,7 @@ mod test {\n             do spawntask {\n                 match UdpSocket::bind(client_ip) {\n                     Some(ref mut client) => {\n-                        port.take().recv();\n+                        port.recv();\n                         client.sendto([99], server_ip)\n                     }\n                     None => fail!()\n@@ -173,13 +170,11 @@ mod test {\n             let server_ip = next_test_ip6();\n             let client_ip = next_test_ip6();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 match UdpSocket::bind(server_ip) {\n                     Some(ref mut server) => {\n-                        chan.take().send(());\n+                        chan.send(());\n                         let mut buf = [0];\n                         match server.recvfrom(buf) {\n                             Some((nread, src)) => {\n@@ -197,7 +192,7 @@ mod test {\n             do spawntask {\n                 match UdpSocket::bind(client_ip) {\n                     Some(ref mut client) => {\n-                        port.take().recv();\n+                        port.recv();\n                         client.sendto([99], server_ip)\n                     }\n                     None => fail!()\n@@ -212,15 +207,13 @@ mod test {\n             let server_ip = next_test_ip4();\n             let client_ip = next_test_ip4();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 match UdpSocket::bind(server_ip) {\n                     Some(server) => {\n                         let server = ~server;\n                         let mut stream = server.connect(client_ip);\n-                        chan.take().send(());\n+                        chan.send(());\n                         let mut buf = [0];\n                         match stream.read(buf) {\n                             Some(nread) => {\n@@ -239,7 +232,7 @@ mod test {\n                     Some(client) => {\n                         let client = ~client;\n                         let mut stream = client.connect(server_ip);\n-                        port.take().recv();\n+                        port.recv();\n                         stream.write([99]);\n                     }\n                     None => fail!()\n@@ -254,15 +247,13 @@ mod test {\n             let server_ip = next_test_ip6();\n             let client_ip = next_test_ip6();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 match UdpSocket::bind(server_ip) {\n                     Some(server) => {\n                         let server = ~server;\n                         let mut stream = server.connect(client_ip);\n-                        chan.take().send(());\n+                        chan.send(());\n                         let mut buf = [0];\n                         match stream.read(buf) {\n                             Some(nread) => {\n@@ -281,7 +272,7 @@ mod test {\n                     Some(client) => {\n                         let client = ~client;\n                         let mut stream = client.connect(server_ip);\n-                        port.take().recv();\n+                        port.recv();\n                         stream.write([99]);\n                     }\n                     None => fail!()"}, {"sha": "7cbf3108a800edb5c74f289679f683aa72b5b48b", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -152,32 +152,26 @@ impl Acceptor<UnixStream> for UnixAcceptor {\n mod tests {\n     use prelude::*;\n     use super::*;\n-    use cell::Cell;\n     use rt::test::*;\n     use io::*;\n     use rt::comm::oneshot;\n \n     fn smalltest(server: proc(UnixStream), client: proc(UnixStream)) {\n-        let server = Cell::new(server);\n-        let client = Cell::new(client);\n         do run_in_mt_newsched_task {\n-            let server = Cell::new(server.take());\n-            let client = Cell::new(client.take());\n             let path1 = next_test_unix();\n             let path2 = path1.clone();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n+            let (client, server) = (client, server);\n \n             do spawntask {\n                 let mut acceptor = UnixListener::bind(&path1).listen();\n-                chan.take().send(());\n-                server.take()(acceptor.accept().unwrap());\n+                chan.send(());\n+                server(acceptor.accept().unwrap());\n             }\n \n             do spawntask {\n-                port.take().recv();\n-                client.take()(UnixStream::connect(&path2).unwrap());\n+                port.recv();\n+                client(UnixStream::connect(&path2).unwrap());\n             }\n         }\n     }\n@@ -260,12 +254,10 @@ mod tests {\n             let path1 = next_test_unix();\n             let path2 = path1.clone();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = UnixListener::bind(&path1).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 times.times(|| {\n                     let mut client = acceptor.accept();\n                     let mut buf = [0];\n@@ -275,7 +267,7 @@ mod tests {\n             }\n \n             do spawntask {\n-                port.take().recv();\n+                port.recv();\n                 times.times(|| {\n                     let mut stream = UnixStream::connect(&path2);\n                     stream.write([100]);"}, {"sha": "1b5303e76c953e27edd480e2359b4f8841d46b37", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 17, "deletions": 35, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -843,9 +843,8 @@ mod test {\n     fn oneshot_multi_task_recv_then_send() {\n         do run_in_newsched_task {\n             let (port, chan) = oneshot::<~int>();\n-            let port_cell = Cell::new(port);\n             do spawntask {\n-                assert!(port_cell.take().recv() == ~10);\n+                assert!(port.recv() == ~10);\n             }\n \n             chan.send(~10);\n@@ -856,13 +855,11 @@ mod test {\n     fn oneshot_multi_task_recv_then_close() {\n         do run_in_newsched_task {\n             let (port, chan) = oneshot::<~int>();\n-            let port_cell = Cell::new(port);\n-            let chan_cell = Cell::new(chan);\n             do spawntask_later {\n-                let _cell = chan_cell.take();\n+                let _ = chan;\n             }\n             let res = do spawntask_try {\n-                assert!(port_cell.take().recv() == ~10);\n+                assert!(port.recv() == ~10);\n             };\n             assert!(res.is_err());\n         }\n@@ -874,9 +871,8 @@ mod test {\n         stress_factor().times(|| {\n             do run_in_newsched_task {\n                 let (port, chan) = oneshot::<int>();\n-                let port_cell = Cell::new(port);\n                 let thread = do spawntask_thread {\n-                    let _p = port_cell.take();\n+                    let _ = port;\n                 };\n                 let _chan = chan;\n                 thread.join();\n@@ -890,14 +886,11 @@ mod test {\n         stress_factor().times(|| {\n             do run_in_newsched_task {\n                 let (port, chan) = oneshot::<int>();\n-                let chan_cell = Cell::new(chan);\n-                let port_cell = Cell::new(port);\n                 let thread1 = do spawntask_thread {\n-                    let _p = port_cell.take();\n+                    let _ = port;\n                 };\n                 let thread2 = do spawntask_thread {\n-                    let c = chan_cell.take();\n-                    c.send(1);\n+                    chan.send(1);\n                 };\n                 thread1.join();\n                 thread2.join();\n@@ -911,19 +904,17 @@ mod test {\n         stress_factor().times(|| {\n             do run_in_newsched_task {\n                 let (port, chan) = oneshot::<int>();\n-                let chan_cell = Cell::new(chan);\n-                let port_cell = Cell::new(port);\n                 let thread1 = do spawntask_thread {\n-                    let port_cell = Cell::new(port_cell.take());\n+                    let port = port;\n                     let res = do spawntask_try {\n-                        port_cell.take().recv();\n+                        port.recv();\n                     };\n                     assert!(res.is_err());\n                 };\n                 let thread2 = do spawntask_thread {\n-                    let chan_cell = Cell::new(chan_cell.take());\n+                    let chan = chan;\n                     do spawntask {\n-                        chan_cell.take();\n+                        let _ = chan;\n                     }\n                 };\n                 thread1.join();\n@@ -938,13 +929,11 @@ mod test {\n         stress_factor().times(|| {\n             do run_in_newsched_task {\n                 let (port, chan) = oneshot::<~int>();\n-                let chan_cell = Cell::new(chan);\n-                let port_cell = Cell::new(port);\n                 let thread1 = do spawntask_thread {\n-                    chan_cell.take().send(~10);\n+                    chan.send(~10);\n                 };\n                 let thread2 = do spawntask_thread {\n-                    assert!(port_cell.take().recv() == ~10);\n+                    assert!(port.recv() == ~10);\n                 };\n                 thread1.join();\n                 thread2.join();\n@@ -965,9 +954,7 @@ mod test {\n                 fn send(chan: Chan<~int>, i: int) {\n                     if i == 10 { return }\n \n-                    let chan_cell = Cell::new(chan);\n                     do spawntask_random {\n-                        let chan = chan_cell.take();\n                         chan.send(~i);\n                         send(chan, i + 1);\n                     }\n@@ -976,9 +963,7 @@ mod test {\n                 fn recv(port: Port<~int>, i: int) {\n                     if i == 10 { return }\n \n-                    let port_cell = Cell::new(port);\n                     do spawntask_random {\n-                        let port = port_cell.take();\n                         assert!(port.recv() == ~i);\n                         recv(port, i + 1);\n                     };\n@@ -1141,14 +1126,11 @@ mod test {\n             let cshared = SharedChan::new(cshared);\n             let mp = megapipe();\n \n-            let pone = Cell::new(pone);\n-            do spawntask { pone.take().recv(); }\n-            let pstream = Cell::new(pstream);\n-            do spawntask { pstream.take().recv(); }\n-            let pshared = Cell::new(pshared);\n-            do spawntask { pshared.take().recv(); }\n-            let p_mp = Cell::new(mp.clone());\n-            do spawntask { p_mp.take().recv(); }\n+            do spawntask { pone.recv(); }\n+            do spawntask { pstream.recv(); }\n+            do spawntask { pshared.recv(); }\n+            let p_mp = mp.clone();\n+            do spawntask { p_mp.recv(); }\n \n             let cs = Cell::new((cone, cstream, cshared, mp));\n             unsafe {"}, {"sha": "e3f9cd09632b39cd43172e1393b9e5e72e76f471", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -151,7 +151,6 @@ There are two known issues with the current scheme for exit code propagation.\n */\n \n use cast;\n-use cell::Cell;\n use option::{Option, Some, None};\n use prelude::*;\n use rt::task::Task;\n@@ -256,8 +255,10 @@ impl Death {\n \n     /// Collect failure exit codes from children and propagate them to a parent.\n     pub fn collect_failure(&mut self, result: UnwindResult) {\n-        let result = Cell::new(result);\n-        self.on_exit.take().map(|on_exit| on_exit(result.take()));\n+        match self.on_exit.take() {\n+            None => {}\n+            Some(on_exit) => on_exit(result),\n+        }\n     }\n \n     /// Enter a possibly-nested \"atomic\" section of code. Just for assertions."}, {"sha": "ce8d1ab1983a1fdf0c3b8f1d6b32b5d28465a2bf", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -57,7 +57,6 @@ Several modules in `core` are clients of `rt`:\n // XXX: this should not be here.\n #[allow(missing_doc)];\n \n-use cell::Cell;\n use clone::Clone;\n use container::Container;\n use iter::Iterator;\n@@ -274,7 +273,7 @@ fn run_(main: proc(), use_main_sched: bool) -> int {\n \n     let nscheds = util::default_sched_threads();\n \n-    let main = Cell::new(main);\n+    let mut main = Some(main);\n \n     // The shared list of sleeping schedulers.\n     let sleepers = SleeperList::new();\n@@ -376,34 +375,33 @@ fn run_(main: proc(), use_main_sched: bool) -> int {\n     };\n \n     let mut threads = ~[];\n-\n-    let on_exit = Cell::new(on_exit);\n+    let mut on_exit = Some(on_exit);\n \n     if !use_main_sched {\n \n         // In the case where we do not use a main_thread scheduler we\n         // run the main task in one of our threads.\n \n-        let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool, None, main.take());\n+        let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool,\n+                                            None,\n+                                            ::util::replace(&mut main,\n+                                                            None).unwrap());\n         main_task.name = Some(SendStrStatic(\"<main>\"));\n-        main_task.death.on_exit = Some(on_exit.take());\n-        let main_task_cell = Cell::new(main_task);\n+        main_task.death.on_exit = ::util::replace(&mut on_exit, None);\n \n         let sched = scheds.pop();\n-        let sched_cell = Cell::new(sched);\n+        let main_task = main_task;\n         let thread = do Thread::start {\n-            let sched = sched_cell.take();\n-            sched.bootstrap(main_task_cell.take());\n+            sched.bootstrap(main_task);\n         };\n         threads.push(thread);\n     }\n \n     // Run each remaining scheduler in a thread.\n     for sched in scheds.move_rev_iter() {\n         rtdebug!(\"creating regular schedulers\");\n-        let sched_cell = Cell::new(sched);\n         let thread = do Thread::start {\n-            let mut sched = sched_cell.take();\n+            let mut sched = sched;\n             let bootstrap_task = ~do Task::new_root(&mut sched.stack_pool, None) || {\n                 rtdebug!(\"boostraping a non-primary scheduler\");\n             };\n@@ -415,16 +413,19 @@ fn run_(main: proc(), use_main_sched: bool) -> int {\n     // If we do have a main thread scheduler, run it now.\n \n     if use_main_sched {\n-\n         rtdebug!(\"about to create the main scheduler task\");\n \n         let mut main_sched = main_sched.unwrap();\n \n         let home = Sched(main_sched.make_handle());\n-        let mut main_task = ~Task::new_root_homed(&mut main_sched.stack_pool, None,\n-                                                  home, main.take());\n+        let mut main_task = ~Task::new_root_homed(&mut main_sched.stack_pool,\n+                                                  None,\n+                                                  home,\n+                                                  ::util::replace(&mut main,\n+                                                                  None).\n+                                                                  unwrap());\n         main_task.name = Some(SendStrStatic(\"<main>\"));\n-        main_task.death.on_exit = Some(on_exit.take());\n+        main_task.death.on_exit = ::util::replace(&mut on_exit, None);\n         rtdebug!(\"bootstrapping main_task\");\n \n         main_sched.bootstrap(main_task);"}, {"sha": "af8de06adb7850a5f6ab90cd7d6129ce87f98be9", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 21, "deletions": 36, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -924,7 +924,6 @@ mod test {\n     use unstable::run_in_bare_thread;\n     use borrow::to_uint;\n     use rt::sched::{Scheduler};\n-    use cell::Cell;\n     use rt::deque::BufferPool;\n     use rt::thread::Thread;\n     use rt::task::{Task, Sched};\n@@ -1050,7 +1049,7 @@ mod test {\n                 queues.clone(),\n                 sleepers.clone());\n \n-            let normal_handle = Cell::new(normal_sched.make_handle());\n+            let normal_handle = normal_sched.make_handle();\n \n             let friend_handle = normal_sched.make_handle();\n \n@@ -1063,7 +1062,7 @@ mod test {\n                 false,\n                 Some(friend_handle));\n \n-            let special_handle = Cell::new(special_sched.make_handle());\n+            let special_handle = special_sched.make_handle();\n \n             let t1_handle = special_sched.make_handle();\n             let t4_handle = special_sched.make_handle();\n@@ -1094,54 +1093,44 @@ mod test {\n             };\n             rtdebug!(\"task4 id: **{}**\", borrow::to_uint(task4));\n \n-            let task1 = Cell::new(task1);\n-            let task2 = Cell::new(task2);\n-            let task3 = Cell::new(task3);\n-            let task4 = Cell::new(task4);\n-\n             // Signal from the special task that we are done.\n             let (port, chan) = oneshot::<()>();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             let normal_task = ~do Task::new_root(&mut normal_sched.stack_pool, None) {\n                 rtdebug!(\"*about to submit task2*\");\n-                Scheduler::run_task(task2.take());\n+                Scheduler::run_task(task2);\n                 rtdebug!(\"*about to submit task4*\");\n-                Scheduler::run_task(task4.take());\n+                Scheduler::run_task(task4);\n                 rtdebug!(\"*normal_task done*\");\n-                port.take().recv();\n-                let mut nh = normal_handle.take();\n+                port.recv();\n+                let mut nh = normal_handle;\n                 nh.send(Shutdown);\n-                let mut sh = special_handle.take();\n+                let mut sh = special_handle;\n                 sh.send(Shutdown);\n             };\n \n             rtdebug!(\"normal task: {}\", borrow::to_uint(normal_task));\n \n             let special_task = ~do Task::new_root(&mut special_sched.stack_pool, None) {\n                 rtdebug!(\"*about to submit task1*\");\n-                Scheduler::run_task(task1.take());\n+                Scheduler::run_task(task1);\n                 rtdebug!(\"*about to submit task3*\");\n-                Scheduler::run_task(task3.take());\n+                Scheduler::run_task(task3);\n                 rtdebug!(\"*done with special_task*\");\n-                chan.take().send(());\n+                chan.send(());\n             };\n \n             rtdebug!(\"special task: {}\", borrow::to_uint(special_task));\n \n-            let special_sched = Cell::new(special_sched);\n-            let normal_sched = Cell::new(normal_sched);\n-            let special_task = Cell::new(special_task);\n-            let normal_task = Cell::new(normal_task);\n-\n+            let normal_sched = normal_sched;\n             let normal_thread = do Thread::start {\n-                normal_sched.take().bootstrap(normal_task.take());\n+                normal_sched.bootstrap(normal_task);\n                 rtdebug!(\"finished with normal_thread\");\n             };\n \n+            let special_sched = special_sched;\n             let special_thread = do Thread::start {\n-                special_sched.take().bootstrap(special_task.take());\n+                special_sched.bootstrap(special_task);\n                 rtdebug!(\"finished with special_sched\");\n             };\n \n@@ -1180,20 +1169,18 @@ mod test {\n \n         do run_in_bare_thread {\n             let (port, chan) = oneshot::<()>();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             let thread_one = do Thread::start {\n-                let chan = Cell::new(chan.take());\n+                let chan = chan;\n                 do run_in_newsched_task_core {\n-                    chan.take().send(());\n+                    chan.send(());\n                 }\n             };\n \n             let thread_two = do Thread::start {\n-                let port = Cell::new(port.take());\n+                let port = port;\n                 do run_in_newsched_task_core {\n-                    port.take().recv();\n+                    port.recv();\n                 }\n             };\n \n@@ -1224,10 +1211,9 @@ mod test {\n \n                 let mut handle = sched.make_handle();\n \n-                let sched = Cell::new(sched);\n-\n+                let sched = sched;\n                 let thread = do Thread::start {\n-                    let mut sched = sched.take();\n+                    let mut sched = sched;\n                     let bootstrap_task =\n                         ~Task::new_root(&mut sched.stack_pool,\n                                         None,\n@@ -1258,9 +1244,8 @@ mod test {\n             let mut ports = ~[];\n             10.times(|| {\n                 let (port, chan) = oneshot();\n-                let chan_cell = Cell::new(chan);\n                 do spawntask_later {\n-                    chan_cell.take().send(());\n+                    chan.send(());\n                 }\n                 ports.push(port);\n             });"}, {"sha": "96b80d1112915cf0484578aae1bc991f3dbac4bd", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -10,7 +10,6 @@\n \n use io::net::ip::{SocketAddr, Ipv4Addr, Ipv6Addr};\n \n-use cell::Cell;\n use clone::Clone;\n use container::Container;\n use iter::{Iterator, range};\n@@ -65,16 +64,14 @@ pub fn new_test_sched() -> Scheduler {\n }\n \n pub fn run_in_uv_task(f: proc()) {\n-    let f = Cell::new(f);\n     do run_in_bare_thread {\n-        run_in_uv_task_core(f.take());\n+        run_in_uv_task_core(f);\n     }\n }\n \n pub fn run_in_newsched_task(f: proc()) {\n-    let f = Cell::new(f);\n     do run_in_bare_thread {\n-        run_in_newsched_task_core(f.take());\n+        run_in_newsched_task_core(f);\n     }\n }\n \n@@ -206,8 +203,6 @@ pub fn run_in_mt_newsched_task(f: proc()) {\n     // see comment in other function (raising fd limits)\n     prepare_for_lots_of_tests();\n \n-    let f = Cell::new(f);\n-\n     do run_in_bare_thread {\n         let nthreads = match os::getenv(\"RUST_RT_TEST_THREADS\") {\n             Some(nstr) => FromStr::from_str(nstr).unwrap(),\n@@ -254,18 +249,18 @@ pub fn run_in_mt_newsched_task(f: proc()) {\n \n             rtassert!(exit_status.is_success());\n         };\n-        let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool, None, f.take());\n+        let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool,\n+                                            None,\n+                                            f);\n         main_task.death.on_exit = Some(on_exit);\n \n         let mut threads = ~[];\n-        let main_task = Cell::new(main_task);\n \n         let main_thread = {\n             let sched = scheds.pop();\n-            let sched_cell = Cell::new(sched);\n+            let main_task = main_task;\n             do Thread::start {\n-                let sched = sched_cell.take();\n-                sched.bootstrap(main_task.take());\n+                sched.bootstrap(main_task);\n             }\n         };\n         threads.push(main_thread);\n@@ -275,11 +270,9 @@ pub fn run_in_mt_newsched_task(f: proc()) {\n             let bootstrap_task = ~do Task::new_root(&mut sched.stack_pool, None) || {\n                 rtdebug!(\"bootstrapping non-primary scheduler\");\n             };\n-            let bootstrap_task_cell = Cell::new(bootstrap_task);\n-            let sched_cell = Cell::new(sched);\n+            let sched = sched;\n             let thread = do Thread::start {\n-                let sched = sched_cell.take();\n-                sched.bootstrap(bootstrap_task_cell.take());\n+                sched.bootstrap(bootstrap_task);\n             };\n \n             threads.push(thread);\n@@ -335,11 +328,8 @@ pub fn spawntask_try(f: proc()) -> Result<(),()> {\n \n /// Spawn a new task in a new scheduler and return a thread handle.\n pub fn spawntask_thread(f: proc()) -> Thread<()> {\n-\n-    let f = Cell::new(f);\n-\n     let thread = do Thread::start {\n-        run_in_newsched_task_core(f.take());\n+        run_in_newsched_task_core(f);\n     };\n \n     return thread;"}, {"sha": "1777a5230734681a4a27ccafef0227acaeb4d0a6", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -55,7 +55,6 @@\n \n use prelude::*;\n \n-use cell::Cell;\n use comm::{stream, Chan, GenericChan, GenericPort, Port, Peekable};\n use result::{Result, Ok, Err};\n use rt::in_green_task_context;\n@@ -284,10 +283,8 @@ impl TaskBuilder {\n                 f\n             }\n         };\n-        let prev_gen_body = Cell::new(prev_gen_body);\n         let next_gen_body = {\n             let f: proc(proc()) -> proc() = proc(body) {\n-                let prev_gen_body = prev_gen_body.take();\n                 wrapper(prev_gen_body(body))\n             };\n             f\n@@ -548,11 +545,9 @@ struct Wrapper {\n fn test_add_wrapper() {\n     let (po, ch) = stream::<()>();\n     let mut b0 = task();\n-    let ch = Cell::new(ch);\n     do b0.add_wrapper |body| {\n-        let ch = Cell::new(ch.take());\n+        let ch = ch;\n         let result: proc() = proc() {\n-            let ch = ch.take();\n             body();\n             ch.send(());\n         };\n@@ -642,12 +637,10 @@ fn test_spawn_sched_childs_on_default_sched() {\n     // Assuming tests run on the default scheduler\n     let default_id = get_sched_id();\n \n-    let ch = Cell::new(ch);\n     do spawn_sched(SingleThreaded) {\n         let parent_sched_id = get_sched_id();\n-        let ch = Cell::new(ch.take());\n+        let ch = ch;\n         do spawn {\n-            let ch = ch.take();\n             let child_sched_id = get_sched_id();\n             assert!(parent_sched_id != child_sched_id);\n             assert_eq!(child_sched_id, default_id);\n@@ -671,10 +664,10 @@ fn test_spawn_sched_blocking() {\n             let (fin_po, fin_ch) = stream();\n \n             let mut lock = Mutex::new();\n-            let lock2 = Cell::new(lock.clone());\n+            let lock2 = lock.clone();\n \n             do spawn_sched(SingleThreaded) {\n-                let mut lock = lock2.take();\n+                let mut lock = lock2;\n                 lock.lock();\n \n                 start_ch.send(());"}, {"sha": "4ab7b74d300687b647ee5b9aa0abdd4f6f14a738", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -77,7 +77,6 @@\n \n use prelude::*;\n \n-use cell::Cell;\n use comm::{GenericChan, oneshot};\n use rt::local::Local;\n use rt::sched::{Scheduler, Shutdown, TaskFromFriend};\n@@ -134,23 +133,19 @@ pub fn spawn_raw(mut opts: TaskOpts, f: proc()) {\n             // Create a task that will later be used to join with the new scheduler\n             // thread when it is ready to terminate\n             let (thread_port, thread_chan) = oneshot();\n-            let thread_port_cell = Cell::new(thread_port);\n             let join_task = do Task::build_child(None) {\n                 debug!(\"running join task\");\n-                let thread_port = thread_port_cell.take();\n                 let thread: Thread<()> = thread_port.recv();\n                 thread.join();\n             };\n \n             // Put the scheduler into another thread\n-            let new_sched_cell = Cell::new(new_sched);\n-            let orig_sched_handle_cell = Cell::new((*sched).make_handle());\n-            let join_task_cell = Cell::new(join_task);\n+            let orig_sched_handle = (*sched).make_handle();\n \n+            let new_sched = new_sched;\n             let thread = do Thread::start {\n-                let mut new_sched = new_sched_cell.take();\n-                let mut orig_sched_handle = orig_sched_handle_cell.take();\n-                let join_task = join_task_cell.take();\n+                let mut new_sched = new_sched;\n+                let mut orig_sched_handle = orig_sched_handle;\n \n                 let bootstrap_task = ~do Task::new_root(&mut new_sched.stack_pool, None) || {\n                     debug!(\"boostrapping a 1:1 scheduler\");\n@@ -178,9 +173,8 @@ pub fn spawn_raw(mut opts: TaskOpts, f: proc()) {\n \n     if opts.notify_chan.is_some() {\n         let notify_chan = opts.notify_chan.take_unwrap();\n-        let notify_chan = Cell::new(notify_chan);\n         let on_exit: proc(UnwindResult) = proc(task_result) {\n-            notify_chan.take().send(task_result)\n+            notify_chan.send(task_result)\n         };\n         task.death.on_exit = Some(on_exit);\n     }"}, {"sha": "f8e2ea54f44f943d7f849218d342ad100b973aee", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -37,15 +37,13 @@ The executing thread has no access to a task pointer and will be using\n a normal large stack.\n */\n pub fn run_in_bare_thread(f: proc()) {\n-    use cell::Cell;\n     use rt::thread::Thread;\n \n-    let f_cell = Cell::new(f);\n     let (port, chan) = comm::stream();\n     // FIXME #4525: Unfortunate that this creates an extra scheduler but it's\n     // necessary since rust_raw_thread_join is blocking\n     do task::spawn_sched(task::SingleThreaded) {\n-        Thread::start(f_cell.take()).join();\n+        Thread::start(f).join();\n         chan.send(());\n     }\n     port.recv();"}, {"sha": "6eacbd12a705e335e7d532f6b878a08c33fd43f5", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -20,7 +20,6 @@ extern mod extra;\n use extra::arc;\n use extra::future::Future;\n use extra::time;\n-use std::cell::Cell;\n use std::os;\n use std::uint;\n \n@@ -91,12 +90,8 @@ fn main() {\n     for i in range(1u, num_tasks) {\n         //error!(\"spawning %?\", i);\n         let (new_chan, num_port) = init();\n-        let num_chan2 = Cell::new(num_chan);\n-        let num_port = Cell::new(num_port);\n         let new_future = do Future::spawn() {\n-            let num_chan = num_chan2.take();\n-            let num_port1 = num_port.take();\n-            thread_ring(i, msg_per_task, num_chan, num_port1)\n+            thread_ring(i, msg_per_task, num_chan, num_port)\n         };\n         futures.push(new_future);\n         num_chan = new_chan;"}, {"sha": "b713652e31d1cdf7ba8f0f1d6334f069d436d05f", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -20,7 +20,6 @@ extern mod extra;\n use extra::arc;\n use extra::future::Future;\n use extra::time;\n-use std::cell::Cell;\n use std::os;\n use std::uint;\n \n@@ -87,12 +86,8 @@ fn main() {\n     for i in range(1u, num_tasks) {\n         //error!(\"spawning %?\", i);\n         let (new_chan, num_port) = init();\n-        let num_chan2 = Cell::new(num_chan);\n-        let num_port = Cell::new(num_port);\n         let new_future = do Future::spawn {\n-            let num_chan = num_chan2.take();\n-            let num_port1 = num_port.take();\n-            thread_ring(i, msg_per_task, num_chan, num_port1)\n+            thread_ring(i, msg_per_task, num_chan, num_port)\n         };\n         futures.push(new_future);\n         num_chan = new_chan;"}, {"sha": "8fa26b42e852714defedc6321aa687bdce37907e", "filename": "src/test/bench/rt-messaging-ping-pong.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -13,7 +13,6 @@ extern mod extra;\n use std::os;\n use std::uint;\n use std::rt::test::spawntask_later;\n-use std::cell::Cell;\n \n // This is a simple bench that creates M pairs of of tasks. These\n // tasks ping-pong back and forth over a pair of streams. This is a\n@@ -24,28 +23,23 @@ fn ping_pong_bench(n: uint, m: uint) {\n \n     // Create pairs of tasks that pingpong back and forth.\n     fn run_pair(n: uint) {\n-            // Create a stream A->B\n-            let (pa,ca) = stream::<()>();\n-            // Create a stream B->A\n-            let (pb,cb) = stream::<()>();\n-\n-            let pa = Cell::new(pa);\n-            let ca = Cell::new(ca);\n-            let pb = Cell::new(pb);\n-            let cb = Cell::new(cb);\n+        // Create a stream A->B\n+        let (pa,ca) = stream::<()>();\n+        // Create a stream B->A\n+        let (pb,cb) = stream::<()>();\n \n         do spawntask_later() || {\n-            let chan = ca.take();\n-            let port = pb.take();\n+            let chan = ca;\n+            let port = pb;\n             n.times(|| {\n                 chan.send(());\n                 port.recv();\n             })\n         }\n \n         do spawntask_later() || {\n-            let chan = cb.take();\n-            let port = pa.take();\n+            let chan = cb;\n+            let port = pa;\n             n.times(|| {\n                 port.recv();\n                 chan.send(());"}, {"sha": "e6519a7885629d7166ec94f8600e2bef4371fa0c", "filename": "src/test/bench/rt-parfib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Fbench%2Frt-parfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Fbench%2Frt-parfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-parfib.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -13,7 +13,6 @@ extern mod extra;\n use std::os;\n use std::uint;\n use std::rt::test::spawntask_later;\n-use std::cell::Cell;\n use std::comm::oneshot;\n \n // A simple implementation of parfib. One subtree is found in a new\n@@ -26,9 +25,8 @@ fn parfib(n: uint) -> uint {\n     }\n \n     let (port,chan) = oneshot::<uint>();\n-    let chan = Cell::new(chan);\n     do spawntask_later {\n-        chan.take().send(parfib(n-1));\n+        chan.send(parfib(n-1));\n     };\n     let m2 = parfib(n-2);\n     return (port.recv() + m2);"}, {"sha": "464bc664fb5b2b09a99fd218dc567c6e34181217", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -12,7 +12,6 @@\n \n extern mod extra;\n \n-use std::cell::Cell;\n use std::comm::{stream, SharedChan};\n use std::option;\n use std::os;\n@@ -156,9 +155,11 @@ fn rendezvous(nn: uint, set: ~[color]) {\n             let to_rendezvous = to_rendezvous.clone();\n             let to_rendezvous_log = to_rendezvous_log.clone();\n             let (from_rendezvous, to_creature) = stream();\n-            let from_rendezvous = Cell::new(from_rendezvous);\n-            do task::spawn || {\n-                creature(ii, col, from_rendezvous.take(), to_rendezvous.clone(),\n+            do task::spawn {\n+                creature(ii,\n+                         col,\n+                         from_rendezvous,\n+                         to_rendezvous.clone(),\n                          to_rendezvous_log.clone());\n             }\n             to_creature"}, {"sha": "8e7b48040cdf12909d55e25a1a7930bfc2cca8e2", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -17,7 +17,6 @@\n //\n // The filename is a song reference; google it in quotes.\n \n-use std::cell::Cell;\n use std::comm;\n use std::os;\n use std::task;\n@@ -27,9 +26,7 @@ fn child_generation(gens_left: uint, c: comm::Chan<()>) {\n     // This used to be O(n^2) in the number of generations that ever existed.\n     // With this code, only as many generations are alive at a time as tasks\n     // alive at a time,\n-    let c = Cell::new(c);\n     do spawn {\n-        let c = c.take();\n         if gens_left & 1 == 1 {\n             task::deschedule(); // shake things up a bit\n         }"}, {"sha": "87173d779240f9c4f55f9eb348b1400d076c6319", "filename": "src/test/compile-fail/no-send-res-ports.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -10,7 +10,6 @@\n \n #[feature(managed_boxes)];\n \n-use std::cell::Cell;\n use std::task;\n \n struct Port<T>(@T);\n@@ -31,10 +30,10 @@ fn main() {\n         }\n     }\n \n-    let x = Cell::new(foo(Port(@())));\n+    let x = foo(Port(@()));\n \n     do task::spawn {\n-        let y = x.take();   //~ ERROR does not fulfill `Send`\n+        let y = x;   //~ ERROR does not fulfill `Send`\n         error!(\"{:?}\", y);\n     }\n }"}, {"sha": "dbf5d0fb3f98b1c1475aea70b7035cb99ae8fe3d", "filename": "src/test/compile-fail/no_freeze-rc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Fcompile-fail%2Fno_freeze-rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Fcompile-fail%2Fno_freeze-rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_freeze-rc.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n use std::rc::Rc;\n-use std::cell::Cell;\n+use std::cell::RefCell;\n \n fn bar<T: Freeze>(_: T) {}\n \n fn main() {\n-    let x = Rc::from_send(Cell::new(5));\n-    bar(x); //~ ERROR instantiating a type parameter with an incompatible type `std::rc::Rc<std::cell::Cell<int>>`, which does not fulfill `Freeze`\n+    let x = Rc::from_send(RefCell::new(5));\n+    bar(x); //~ ERROR instantiating a type parameter with an incompatible type `std::rc::Rc<std::cell::RefCell<int>>`, which does not fulfill `Freeze`\n }"}, {"sha": "2c18361fd46fcf685615f3eac3032db80bea1061", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -313,8 +313,6 @@ pub fn main() {\n //    Commented out because of option::get error\n \n     let (client_, server_) = pingpong::init();\n-    let client_ = Cell::new(client_);\n-    let server_ = Cell::new(server_);\n \n     task::spawn {|client_|\n         let client__ = client_.take();"}, {"sha": "a39907d5c7ede0890c3f33b67443aba19e27e089", "filename": "src/test/run-pass/sendfn-spawn-with-fn-arg.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cell::Cell;\n use std::task;\n \n pub fn main() { test05(); }\n@@ -23,8 +22,7 @@ fn test05() {\n         error!(\"{}\", *three + n); // will copy x into the closure\n         assert_eq!(*three, 3);\n     };\n-    let fn_to_send = Cell::new(fn_to_send);\n     task::spawn(proc() {\n-        test05_start(fn_to_send.take());\n+        test05_start(fn_to_send);\n     });\n }"}, {"sha": "a490cc6020fda5b6501e4112fa5335e4f6685725", "filename": "src/test/run-pass/task-killjoin-rsrc.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -13,7 +13,6 @@\n // A port of task-killjoin to use a class with a dtor to manage\n // the join.\n \n-use std::cell::Cell;\n use std::comm::*;\n use std::ptr;\n use std::task;\n@@ -55,9 +54,8 @@ fn joinable(f: proc()) -> Port<bool> {\n         *b = true;\n     }\n     let (p, c) = stream();\n-    let c = Cell::new(c);\n     do task::spawn_unlinked {\n-        let ccc = c.take();\n+        let ccc = c;\n         wrapper(ccc, f)\n     }\n     p"}, {"sha": "663eafe1700154752f0c08a2d06ee08b4358f5bf", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -22,11 +22,10 @@\n extern mod extra;\n \n use extra::tempfile::TempDir;\n+use std::io::fs;\n+use std::io;\n use std::os;\n use std::task;\n-use std::cell::Cell;\n-use std::io;\n-use std::io::fs;\n \n fn test_tempdir() {\n     let path = {\n@@ -51,9 +50,8 @@ fn test_rm_tempdir() {\n \n     let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n     let path = tmp.path().clone();\n-    let cell = Cell::new(tmp);\n     let f: proc() = proc() {\n-        let _tmp = cell.take();\n+        let _tmp = tmp;\n         fail!(\"fail to unwind past `tmp`\");\n     };\n     task::try(f);"}, {"sha": "abd9ea1733f49f863d4dc85d8ec43c72c5164dc5", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786dea207d5b891d37e596e96dd2f84c4cb59f49/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=786dea207d5b891d37e596e96dd2f84c4cb59f49", "patch": "@@ -16,10 +16,10 @@\n // xfail-fast\n \n extern mod extra;\n+\n use extra::arc;\n use std::comm;\n use std::task;\n-use std::cell;\n \n trait Pet {\n     fn name(&self, blk: |&str|);\n@@ -71,14 +71,14 @@ fn main() {\n                          ~fishe  as ~Pet:Freeze+Send,\n                          ~dogge2 as ~Pet:Freeze+Send]);\n     let (p1,c1) = comm::stream();\n-    let arc1 = cell::Cell::new(arc.clone());\n-    do task::spawn { check_legs(arc1.take()); c1.send(()); }\n+    let arc1 = arc.clone();\n+    do task::spawn { check_legs(arc1); c1.send(()); }\n     let (p2,c2) = comm::stream();\n-    let arc2 = cell::Cell::new(arc.clone());\n-    do task::spawn { check_names(arc2.take()); c2.send(()); }\n+    let arc2 = arc.clone();\n+    do task::spawn { check_names(arc2); c2.send(()); }\n     let (p3,c3) = comm::stream();\n-    let arc3 = cell::Cell::new(arc.clone());\n-    do task::spawn { check_pedigree(arc3.take()); c3.send(()); }\n+    let arc3 = arc.clone();\n+    do task::spawn { check_pedigree(arc3); c3.send(()); }\n     p1.recv();\n     p2.recv();\n     p3.recv();"}]}