{"sha": "0e969d2889473f92d74fe7ac1a2699bf972431df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlOTY5ZDI4ODk0NzNmOTJkNzRmZTdhYzFhMjY5OWJmOTcyNDMxZGY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-10-14T04:23:39Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-10-14T07:20:54Z"}, "message": "Rollup merge of #28991 - goyox86:goyox86/rustfmting-liblog-II, r=alexcrichton\n\nHi Rustaceans!\n\nThis is the second version of running rustfmt on liblog https://github.com/rust-lang/rust/pull/28898. There are only rustfmt suggested changes. Because I think that some patterns here (that I fixed up in the prev PR need to be discussed in detail.\n\n//cc @nrc", "tree": {"sha": "3e2f7960d632b187cb71b65ca6adf7849a7776c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e2f7960d632b187cb71b65ca6adf7849a7776c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e969d2889473f92d74fe7ac1a2699bf972431df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e969d2889473f92d74fe7ac1a2699bf972431df", "html_url": "https://github.com/rust-lang/rust/commit/0e969d2889473f92d74fe7ac1a2699bf972431df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e969d2889473f92d74fe7ac1a2699bf972431df/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "293966694c3c8e0c7028e8f54340fbc328d85bff", "url": "https://api.github.com/repos/rust-lang/rust/commits/293966694c3c8e0c7028e8f54340fbc328d85bff", "html_url": "https://github.com/rust-lang/rust/commit/293966694c3c8e0c7028e8f54340fbc328d85bff"}, {"sha": "94946db60d84d1a6a5d45dc7be7e778882637367", "url": "https://api.github.com/repos/rust-lang/rust/commits/94946db60d84d1a6a5d45dc7be7e778882637367", "html_url": "https://github.com/rust-lang/rust/commit/94946db60d84d1a6a5d45dc7be7e778882637367"}], "stats": {"total": 202, "additions": 114, "deletions": 88}, "files": [{"sha": "12a5c1311705d34c9835ccba0dec2e0f2ba4ca97", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 45, "deletions": 39, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/0e969d2889473f92d74fe7ac1a2699bf972431df/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e969d2889473f92d74fe7ac1a2699bf972431df/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=0e969d2889473f92d74fe7ac1a2699bf972431df", "patch": "@@ -17,15 +17,17 @@ pub struct LogDirective {\n     pub level: u32,\n }\n \n-pub const LOG_LEVEL_NAMES: [&'static str; 4] = [\"ERROR\", \"WARN\", \"INFO\",\n-                                               \"DEBUG\"];\n+pub const LOG_LEVEL_NAMES: [&'static str; 4] = [\"ERROR\", \"WARN\", \"INFO\", \"DEBUG\"];\n \n /// Parse an individual log level that is either a number or a symbolic log level\n fn parse_log_level(level: &str) -> Option<u32> {\n-    level.parse::<u32>().ok().or_else(|| {\n-        let pos = LOG_LEVEL_NAMES.iter().position(|&name| name.eq_ignore_ascii_case(level));\n-        pos.map(|p| p as u32 + 1)\n-    }).map(|p| cmp::min(p, ::MAX_LOG_LEVEL))\n+    level.parse::<u32>()\n+         .ok()\n+         .or_else(|| {\n+             let pos = LOG_LEVEL_NAMES.iter().position(|&name| name.eq_ignore_ascii_case(level));\n+             pos.map(|p| p as u32 + 1)\n+         })\n+         .map(|p| cmp::min(p, ::MAX_LOG_LEVEL))\n }\n \n /// Parse a logging specification string (e.g: \"crate1,crate2::mod3,crate3::x=1/foo\")\n@@ -40,44 +42,48 @@ pub fn parse_logging_spec(spec: &str) -> (Vec<LogDirective>, Option<String>) {\n     let mods = parts.next();\n     let filter = parts.next();\n     if parts.next().is_some() {\n-        println!(\"warning: invalid logging spec '{}', \\\n-                 ignoring it (too many '/'s)\", spec);\n+        println!(\"warning: invalid logging spec '{}', ignoring it (too many '/'s)\",\n+                 spec);\n         return (dirs, None);\n     }\n-    mods.map(|m| { for s in m.split(',') {\n-        if s.is_empty() { continue }\n-        let mut parts = s.split('=');\n-        let (log_level, name) = match (parts.next(), parts.next().map(|s| s.trim()), parts.next()) {\n-            (Some(part0), None, None) => {\n-                // if the single argument is a log-level string or number,\n-                // treat that as a global fallback\n-                match parse_log_level(part0) {\n-                    Some(num) => (num, None),\n-                    None => (::MAX_LOG_LEVEL, Some(part0)),\n-                }\n+    mods.map(|m| {\n+        for s in m.split(',') {\n+            if s.is_empty() {\n+                continue\n             }\n-            (Some(part0), Some(\"\"), None) => (::MAX_LOG_LEVEL, Some(part0)),\n-            (Some(part0), Some(part1), None) => {\n-                match parse_log_level(part1) {\n-                    Some(num) => (num, Some(part0)),\n-                    _ => {\n-                        println!(\"warning: invalid logging spec '{}', \\\n-                                 ignoring it\", part1);\n-                        continue\n+            let mut parts = s.split('=');\n+            let (log_level, name) = match (parts.next(),\n+                                           parts.next().map(|s| s.trim()),\n+                                           parts.next()) {\n+                (Some(part0), None, None) => {\n+                    // if the single argument is a log-level string or number,\n+                    // treat that as a global fallback\n+                    match parse_log_level(part0) {\n+                        Some(num) => (num, None),\n+                        None => (::MAX_LOG_LEVEL, Some(part0)),\n                     }\n                 }\n-            },\n-            _ => {\n-                println!(\"warning: invalid logging spec '{}', \\\n-                         ignoring it\", s);\n-                continue\n-            }\n-        };\n-        dirs.push(LogDirective {\n-            name: name.map(str::to_owned),\n-            level: log_level,\n-        });\n-    }});\n+                (Some(part0), Some(\"\"), None) => (::MAX_LOG_LEVEL, Some(part0)),\n+                (Some(part0), Some(part1), None) => {\n+                    match parse_log_level(part1) {\n+                        Some(num) => (num, Some(part0)),\n+                        _ => {\n+                            println!(\"warning: invalid logging spec '{}', ignoring it\", part1);\n+                            continue\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    println!(\"warning: invalid logging spec '{}', ignoring it\", s);\n+                    continue\n+                }\n+            };\n+            dirs.push(LogDirective {\n+                name: name.map(str::to_owned),\n+                level: log_level,\n+            });\n+        }\n+    });\n \n     (dirs, filter.map(str::to_owned))\n }"}, {"sha": "b3268c32f18f7392e7aa3b5efc88eb8f99073d47", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 69, "deletions": 49, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/0e969d2889473f92d74fe7ac1a2699bf972431df/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e969d2889473f92d74fe7ac1a2699bf972431df/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=0e969d2889473f92d74fe7ac1a2699bf972431df", "patch": "@@ -235,7 +235,9 @@ pub trait Logger {\n     fn log(&mut self, record: &LogRecord);\n }\n \n-struct DefaultLogger { handle: Stderr }\n+struct DefaultLogger {\n+    handle: Stderr,\n+}\n \n /// Wraps the log level with fmt implementations.\n #[derive(Copy, Clone, PartialEq, PartialOrd, Debug)]\n@@ -246,7 +248,7 @@ impl fmt::Display for LogLevel {\n         let LogLevel(level) = *self;\n         match LOG_LEVEL_NAMES.get(level as usize - 1) {\n             Some(ref name) => fmt::Display::fmt(name, fmt),\n-            None => fmt::Display::fmt(&level, fmt)\n+            None => fmt::Display::fmt(&level, fmt),\n         }\n     }\n }\n@@ -301,11 +303,10 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n     // Completely remove the local logger from TLS in case anyone attempts to\n     // frob the slot while we're doing the logging. This will destroy any logger\n     // set during logging.\n-    let mut logger: Box<Logger + Send> = LOCAL_LOGGER.with(|s| {\n-        s.borrow_mut().take()\n-    }).unwrap_or_else(|| {\n-        box DefaultLogger { handle: io::stderr() }\n-    });\n+    let mut logger: Box<Logger + Send> = LOCAL_LOGGER.with(|s| s.borrow_mut().take())\n+                                                     .unwrap_or_else(|| {\n+                                                         box DefaultLogger { handle: io::stderr() }\n+                                                     });\n     logger.log(&LogRecord {\n         level: LogLevel(level),\n         args: args,\n@@ -320,22 +321,21 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n /// safely\n #[doc(hidden)]\n #[inline(always)]\n-pub fn log_level() -> u32 { unsafe { LOG_LEVEL } }\n+pub fn log_level() -> u32 {\n+    unsafe { LOG_LEVEL }\n+}\n \n /// Replaces the thread-local logger with the specified logger, returning the old\n /// logger.\n pub fn set_logger(logger: Box<Logger + Send>) -> Option<Box<Logger + Send>> {\n     let mut l = Some(logger);\n-    LOCAL_LOGGER.with(|slot| {\n-        mem::replace(&mut *slot.borrow_mut(), l.take())\n-    })\n+    LOCAL_LOGGER.with(|slot| mem::replace(&mut *slot.borrow_mut(), l.take()))\n }\n \n /// A LogRecord is created by the logging macros, and passed as the only\n /// argument to Loggers.\n #[derive(Debug)]\n pub struct LogRecord<'a> {\n-\n     /// The module path of where the LogRecord originated.\n     pub module_path: &'a str,\n \n@@ -373,7 +373,9 @@ pub fn mod_enabled(level: u32, module: &str) -> bool {\n     // again to whether they should really be here or not. Hence, despite this\n     // check being expanded manually in the logging macro, this function checks\n     // the log level again.\n-    if level > unsafe { LOG_LEVEL } { return false }\n+    if level > unsafe { LOG_LEVEL } {\n+        return false\n+    }\n \n     // This assertion should never get tripped unless we're in an at_exit\n     // handler after logging has been torn down and a logging attempt was made.\n@@ -385,14 +387,11 @@ pub fn mod_enabled(level: u32, module: &str) -> bool {\n     }\n }\n \n-fn enabled(level: u32,\n-           module: &str,\n-           iter: slice::Iter<directive::LogDirective>)\n-           -> bool {\n+fn enabled(level: u32, module: &str, iter: slice::Iter<directive::LogDirective>) -> bool {\n     // Search for the longest match, the vector is assumed to be pre-sorted.\n     for directive in iter.rev() {\n         match directive.name {\n-            Some(ref name) if !module.starts_with(&name[..]) => {},\n+            Some(ref name) if !module.starts_with(&name[..]) => {}\n             Some(..) | None => {\n                 return level <= directive.level\n             }\n@@ -445,16 +444,14 @@ mod tests {\n \n     #[test]\n     fn match_full_path() {\n-        let dirs = [\n-            LogDirective {\n-                name: Some(\"crate2\".to_string()),\n-                level: 3\n-            },\n-            LogDirective {\n-                name: Some(\"crate1::mod1\".to_string()),\n-                level: 2\n-            }\n-        ];\n+        let dirs = [LogDirective {\n+                        name: Some(\"crate2\".to_string()),\n+                        level: 3,\n+                    },\n+                    LogDirective {\n+                        name: Some(\"crate1::mod1\".to_string()),\n+                        level: 2,\n+                    }];\n         assert!(enabled(2, \"crate1::mod1\", dirs.iter()));\n         assert!(!enabled(3, \"crate1::mod1\", dirs.iter()));\n         assert!(enabled(3, \"crate2\", dirs.iter()));\n@@ -463,49 +460,72 @@ mod tests {\n \n     #[test]\n     fn no_match() {\n-        let dirs = [\n-            LogDirective { name: Some(\"crate2\".to_string()), level: 3 },\n-            LogDirective { name: Some(\"crate1::mod1\".to_string()), level: 2 }\n-        ];\n+        let dirs = [LogDirective {\n+                        name: Some(\"crate2\".to_string()),\n+                        level: 3,\n+                    },\n+                    LogDirective {\n+                        name: Some(\"crate1::mod1\".to_string()),\n+                        level: 2,\n+                    }];\n         assert!(!enabled(2, \"crate3\", dirs.iter()));\n     }\n \n     #[test]\n     fn match_beginning() {\n-        let dirs = [\n-            LogDirective { name: Some(\"crate2\".to_string()), level: 3 },\n-            LogDirective { name: Some(\"crate1::mod1\".to_string()), level: 2 }\n-        ];\n+        let dirs = [LogDirective {\n+                        name: Some(\"crate2\".to_string()),\n+                        level: 3,\n+                    },\n+                    LogDirective {\n+                        name: Some(\"crate1::mod1\".to_string()),\n+                        level: 2,\n+                    }];\n         assert!(enabled(3, \"crate2::mod1\", dirs.iter()));\n     }\n \n     #[test]\n     fn match_beginning_longest_match() {\n-        let dirs = [\n-            LogDirective { name: Some(\"crate2\".to_string()), level: 3 },\n-            LogDirective { name: Some(\"crate2::mod\".to_string()), level: 4 },\n-            LogDirective { name: Some(\"crate1::mod1\".to_string()), level: 2 }\n-        ];\n+        let dirs = [LogDirective {\n+                        name: Some(\"crate2\".to_string()),\n+                        level: 3,\n+                    },\n+                    LogDirective {\n+                        name: Some(\"crate2::mod\".to_string()),\n+                        level: 4,\n+                    },\n+                    LogDirective {\n+                        name: Some(\"crate1::mod1\".to_string()),\n+                        level: 2,\n+                    }];\n         assert!(enabled(4, \"crate2::mod1\", dirs.iter()));\n         assert!(!enabled(4, \"crate2\", dirs.iter()));\n     }\n \n     #[test]\n     fn match_default() {\n-        let dirs = [\n-            LogDirective { name: None, level: 3 },\n-            LogDirective { name: Some(\"crate1::mod1\".to_string()), level: 2 }\n-        ];\n+        let dirs = [LogDirective {\n+                        name: None,\n+                        level: 3,\n+                    },\n+                    LogDirective {\n+                        name: Some(\"crate1::mod1\".to_string()),\n+                        level: 2,\n+                    }];\n         assert!(enabled(2, \"crate1::mod1\", dirs.iter()));\n         assert!(enabled(3, \"crate2::mod2\", dirs.iter()));\n     }\n \n     #[test]\n     fn zero_level() {\n-        let dirs = [\n-            LogDirective { name: None, level: 3 },\n-            LogDirective { name: Some(\"crate1::mod1\".to_string()), level: 0 }\n-        ];\n+        let dirs = [LogDirective {\n+                        name: None,\n+                        level: 3,\n+                    },\n+                    LogDirective {\n+                        name: Some(\"crate1::mod1\".to_string()),\n+                        level: 0,\n+                    }];\n         assert!(!enabled(1, \"crate1::mod1\", dirs.iter()));\n         assert!(enabled(3, \"crate2::mod2\", dirs.iter()));\n     }"}]}