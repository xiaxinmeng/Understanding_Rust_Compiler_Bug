{"sha": "3b4402ccf505818c901d1d2ac9852293331438fe", "node_id": "C_kwDOAAsO6NoAKDNiNDQwMmNjZjUwNTgxOGM5MDFkMWQyYWM5ODUyMjkzMzMxNDM4ZmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-25T02:05:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-25T02:05:18Z"}, "message": "Auto merge of #2196 - carbotaniuman:permissive-stacked-borrows, r=RalfJung\n\nHandle wildcard pointers in SB\n\nThis uses an permissive `Unknown` implementation, where a wildcard pointer (and any SRW derived from a wildcard pointer) can access any previously-exposed SB tag. This is missing any meaningful test-cases, and all of the edge-cases have not yet been worked through.\n\nI think there's also some bugs here with differing Unknowns in different ranges and having things behave really weirdly too, alongside some issues with retagging to `SRO` or `Unique`.", "tree": {"sha": "774331fdfd80d1d96e07e117011735a3186c71a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/774331fdfd80d1d96e07e117011735a3186c71a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b4402ccf505818c901d1d2ac9852293331438fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b4402ccf505818c901d1d2ac9852293331438fe", "html_url": "https://github.com/rust-lang/rust/commit/3b4402ccf505818c901d1d2ac9852293331438fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b4402ccf505818c901d1d2ac9852293331438fe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1226c43b6f6bae61b9225efca3f09cf712f5864", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1226c43b6f6bae61b9225efca3f09cf712f5864", "html_url": "https://github.com/rust-lang/rust/commit/a1226c43b6f6bae61b9225efca3f09cf712f5864"}, {"sha": "58c79c5b6f2717241ec14aa61442b98ca8b66d00", "url": "https://api.github.com/repos/rust-lang/rust/commits/58c79c5b6f2717241ec14aa61442b98ca8b66d00", "html_url": "https://github.com/rust-lang/rust/commit/58c79c5b6f2717241ec14aa61442b98ca8b66d00"}], "stats": {"total": 718, "additions": 555, "deletions": 163}, "files": [{"sha": "f6b2413c65f594d04bf7faf8d6c8d7156b7be586", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b4402ccf505818c901d1d2ac9852293331438fe/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/3b4402ccf505818c901d1d2ac9852293331438fe/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=3b4402ccf505818c901d1d2ac9852293331438fe", "patch": "@@ -358,9 +358,7 @@ to Miri failing to detect cases of undefined behavior in a program.\n   for pointer-to-int and int-to-pointer casts, respectively. This will\n   necessarily miss some bugs as those semantics are not efficiently\n   implementable in a sanitizer, but it will only miss bugs that concerns\n-  memory/pointers which is subject to these operations. Also note that this flag\n-  is currently incompatible with Stacked Borrows, so you will have to also pass\n-  `-Zmiri-disable-stacked-borrows` to use this.\n+  memory/pointers which is subject to these operations.\n * `-Zmiri-symbolic-alignment-check` makes the alignment check more strict.  By\n   default, alignment is checked by casting the pointer to an integer, and making\n   sure that is a multiple of the alignment.  This can lead to cases where a"}, {"sha": "230f46c569dbffa8ffebdef23ac7883ef51fab3e", "filename": "src/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3b4402ccf505818c901d1d2ac9852293331438fe/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4402ccf505818c901d1d2ac9852293331438fe/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=3b4402ccf505818c901d1d2ac9852293331438fe", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::ty;\n use rustc_span::{source_map::DUMMY_SP, Span, SpanData, Symbol};\n \n use crate::helpers::HexRange;\n-use crate::stacked_borrows::{diagnostics::TagHistory, AccessKind, SbTag};\n+use crate::stacked_borrows::{diagnostics::TagHistory, AccessKind};\n use crate::*;\n \n /// Details of premature program termination.\n@@ -61,9 +61,9 @@ impl MachineStopType for TerminationInfo {}\n /// Miri specific diagnostics\n pub enum NonHaltingDiagnostic {\n     CreatedPointerTag(NonZeroU64),\n-    /// This `Item` was popped from the borrow stack, either due to a grant of\n-    /// `AccessKind` to `SbTag` or a deallocation when the second argument is `None`.\n-    PoppedPointerTag(Item, Option<(SbTag, AccessKind)>),\n+    /// This `Item` was popped from the borrow stack, either due to an access with the given tag or\n+    /// a deallocation when the second argument is `None`.\n+    PoppedPointerTag(Item, Option<(SbTagExtra, AccessKind)>),\n     CreatedCallId(CallId),\n     CreatedAlloc(AllocId),\n     FreedAlloc(AllocId),"}, {"sha": "cfaf61f9d5c887b11f1998532454dca672622b4a", "filename": "src/intptrcast.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3b4402ccf505818c901d1d2ac9852293331438fe/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4402ccf505818c901d1d2ac9852293331438fe/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=3b4402ccf505818c901d1d2ac9852293331438fe", "patch": "@@ -101,14 +101,16 @@ impl<'mir, 'tcx> GlobalStateInner {\n         }\n     }\n \n-    pub fn expose_addr(ecx: &MiriEvalContext<'mir, 'tcx>, alloc_id: AllocId) {\n-        trace!(\"Exposing allocation id {:?}\", alloc_id);\n-\n-        let mut global_state = ecx.machine.intptrcast.borrow_mut();\n+    pub fn expose_ptr(ecx: &mut MiriEvalContext<'mir, 'tcx>, alloc_id: AllocId, sb: SbTag) {\n+        let global_state = ecx.machine.intptrcast.get_mut();\n         // In legacy and strict mode, we don't need this, so we can save some cycles\n         // by not tracking it.\n         if global_state.provenance_mode == ProvenanceMode::Permissive {\n+            trace!(\"Exposing allocation id {alloc_id:?}\");\n             global_state.exposed.insert(alloc_id);\n+            if ecx.machine.stacked_borrows.is_some() {\n+                ecx.expose_tag(alloc_id, sb);\n+            }\n         }\n     }\n \n@@ -140,9 +142,7 @@ impl<'mir, 'tcx> GlobalStateInner {\n                 // Determine the allocation this points to at cast time.\n                 let alloc_id = Self::alloc_id_from_addr(ecx, addr);\n                 Pointer::new(\n-                    alloc_id.map(|alloc_id| {\n-                        Tag::Concrete(ConcreteTag { alloc_id, sb: SbTag::Untagged })\n-                    }),\n+                    alloc_id.map(|alloc_id| Tag::Concrete { alloc_id, sb: SbTag::Untagged }),\n                     Size::from_bytes(addr),\n                 )\n             }\n@@ -220,8 +220,8 @@ impl<'mir, 'tcx> GlobalStateInner {\n     ) -> Option<(AllocId, Size)> {\n         let (tag, addr) = ptr.into_parts(); // addr is absolute (Tag provenance)\n \n-        let alloc_id = if let Tag::Concrete(concrete) = tag {\n-            concrete.alloc_id\n+        let alloc_id = if let Tag::Concrete { alloc_id, .. } = tag {\n+            alloc_id\n         } else {\n             // A wildcard pointer.\n             assert_eq!(ecx.machine.intptrcast.borrow().provenance_mode, ProvenanceMode::Permissive);"}, {"sha": "68489c9b47b96a0c0793ad7cf626a90eea1b8eaa", "filename": "src/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3b4402ccf505818c901d1d2ac9852293331438fe/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4402ccf505818c901d1d2ac9852293331438fe/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=3b4402ccf505818c901d1d2ac9852293331438fe", "patch": "@@ -6,6 +6,8 @@\n #![feature(let_else)]\n #![feature(io_error_more)]\n #![feature(yeet_expr)]\n+#![feature(is_some_with)]\n+#![feature(nonzero_ops)]\n #![warn(rust_2018_idioms)]\n #![allow(\n     clippy::collapsible_else_if,\n@@ -80,15 +82,15 @@ pub use crate::eval::{\n pub use crate::helpers::{CurrentSpan, EvalContextExt as HelpersEvalContextExt};\n pub use crate::intptrcast::ProvenanceMode;\n pub use crate::machine::{\n-    AllocExtra, ConcreteTag, Evaluator, FrameData, MiriEvalContext, MiriEvalContextExt,\n-    MiriMemoryKind, Tag, NUM_CPUS, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n+    AllocExtra, Evaluator, FrameData, MiriEvalContext, MiriEvalContextExt, MiriMemoryKind, Tag,\n+    NUM_CPUS, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n };\n pub use crate::mono_hash_map::MonoHashMap;\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n pub use crate::range_map::RangeMap;\n pub use crate::stacked_borrows::{\n-    CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, PtrId, SbTag, Stack,\n-    Stacks,\n+    CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, PtrId, SbTag, SbTagExtra,\n+    Stack, Stacks,\n };\n pub use crate::sync::{CondvarId, EvalContextExt as SyncEvalContextExt, MutexId, RwLockId};\n pub use crate::thread::{"}, {"sha": "79414ada5eac900c2655e99287e598cbbf97091c", "filename": "src/machine.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3b4402ccf505818c901d1d2ac9852293331438fe/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4402ccf505818c901d1d2ac9852293331438fe/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=3b4402ccf505818c901d1d2ac9852293331438fe", "patch": "@@ -130,17 +130,14 @@ impl fmt::Display for MiriMemoryKind {\n /// Pointer provenance (tag).\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum Tag {\n-    Concrete(ConcreteTag),\n+    Concrete {\n+        alloc_id: AllocId,\n+        /// Stacked Borrows tag.\n+        sb: SbTag,\n+    },\n     Wildcard,\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct ConcreteTag {\n-    pub alloc_id: AllocId,\n-    /// Stacked Borrows tag.\n-    pub sb: SbTag,\n-}\n-\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(Pointer<Tag>, 24);\n // #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n@@ -160,15 +157,15 @@ impl Provenance for Tag {\n         write!(f, \"0x{:x}\", addr.bytes())?;\n \n         match tag {\n-            Tag::Concrete(tag) => {\n+            Tag::Concrete { alloc_id, sb } => {\n                 // Forward `alternate` flag to `alloc_id` printing.\n                 if f.alternate() {\n-                    write!(f, \"[{:#?}]\", tag.alloc_id)?;\n+                    write!(f, \"[{:#?}]\", alloc_id)?;\n                 } else {\n-                    write!(f, \"[{:?}]\", tag.alloc_id)?;\n+                    write!(f, \"[{:?}]\", alloc_id)?;\n                 }\n                 // Print Stacked Borrows tag.\n-                write!(f, \"{:?}\", tag.sb)?;\n+                write!(f, \"{:?}\", sb)?;\n             }\n             Tag::Wildcard => {\n                 write!(f, \"[Wildcard]\")?;\n@@ -180,7 +177,7 @@ impl Provenance for Tag {\n \n     fn get_alloc_id(self) -> Option<AllocId> {\n         match self {\n-            Tag::Concrete(concrete) => Some(concrete.alloc_id),\n+            Tag::Concrete { alloc_id, .. } => Some(alloc_id),\n             Tag::Wildcard => None,\n         }\n     }\n@@ -489,7 +486,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     type AllocExtra = AllocExtra;\n \n     type PointerTag = Tag;\n-    type TagExtra = SbTag;\n+    type TagExtra = SbTagExtra;\n \n     type MemoryMap =\n         MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<Tag, Self::AllocExtra>)>;\n@@ -649,7 +646,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         let alloc: Allocation<Tag, Self::AllocExtra> = alloc.convert_tag_add_extra(\n             &ecx.tcx,\n             AllocExtra {\n-                stacked_borrows: stacks,\n+                stacked_borrows: stacks.map(RefCell::new),\n                 data_race: race_alloc,\n                 weak_memory: buffer_alloc,\n             },\n@@ -682,7 +679,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n             SbTag::Untagged\n         };\n         Pointer::new(\n-            Tag::Concrete(ConcreteTag { alloc_id: ptr.provenance, sb: sb_tag }),\n+            Tag::Concrete { alloc_id: ptr.provenance, sb: sb_tag },\n             Size::from_bytes(absolute_addr),\n         )\n     }\n@@ -708,8 +705,9 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         ptr: Pointer<Self::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         match ptr.provenance {\n-            Tag::Concrete(concrete) =>\n-                intptrcast::GlobalStateInner::expose_addr(ecx, concrete.alloc_id),\n+            Tag::Concrete { alloc_id, sb } => {\n+                intptrcast::GlobalStateInner::expose_ptr(ecx, alloc_id, sb);\n+            }\n             Tag::Wildcard => {\n                 // No need to do anything for wildcard pointers as\n                 // their provenances have already been previously exposed.\n@@ -728,8 +726,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n         rel.map(|(alloc_id, size)| {\n             let sb = match ptr.provenance {\n-                Tag::Concrete(ConcreteTag { sb, .. }) => sb,\n-                Tag::Wildcard => SbTag::Untagged,\n+                Tag::Concrete { sb, .. } => SbTagExtra::Concrete(sb),\n+                Tag::Wildcard => SbTagExtra::Wildcard,\n             };\n             (alloc_id, size, sb)\n         })\n@@ -747,7 +745,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n             data_race.read(alloc_id, range, machine.data_race.as_ref().unwrap())?;\n         }\n         if let Some(stacked_borrows) = &alloc_extra.stacked_borrows {\n-            stacked_borrows.memory_read(\n+            stacked_borrows.borrow_mut().memory_read(\n                 alloc_id,\n                 tag,\n                 range,\n@@ -773,7 +771,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n             data_race.write(alloc_id, range, machine.data_race.as_mut().unwrap())?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n-            stacked_borrows.memory_written(\n+            stacked_borrows.get_mut().memory_written(\n                 alloc_id,\n                 tag,\n                 range,\n@@ -802,7 +800,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n             data_race.deallocate(alloc_id, range, machine.data_race.as_mut().unwrap())?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n-            stacked_borrows.memory_deallocated(\n+            stacked_borrows.get_mut().memory_deallocated(\n                 alloc_id,\n                 tag,\n                 range,"}, {"sha": "6fa70ddfc5d4e64b4dc61cc2286e0efcd50b170f", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 284, "deletions": 101, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/3b4402ccf505818c901d1d2ac9852293331438fe/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4402ccf505818c901d1d2ac9852293331438fe/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=3b4402ccf505818c901d1d2ac9852293331438fe", "patch": "@@ -3,6 +3,7 @@\n \n use log::trace;\n use std::cell::RefCell;\n+use std::cmp;\n use std::fmt;\n use std::num::NonZeroU64;\n \n@@ -24,7 +25,8 @@ use diagnostics::{AllocHistory, TagHistory};\n \n pub type PtrId = NonZeroU64;\n pub type CallId = NonZeroU64;\n-pub type AllocExtra = Stacks;\n+// Even reading memory can have effects on the stack, so we need a `RefCell` here.\n+pub type AllocExtra = RefCell<Stacks>;\n \n /// Tracking pointer provenance\n #[derive(Copy, Clone, Hash, Eq)]\n@@ -60,6 +62,32 @@ impl fmt::Debug for SbTag {\n     }\n }\n \n+/// The \"extra\" information an SB pointer has over a regular AllocId.\n+/// Newtype for `Option<SbTag>`.\n+#[derive(Copy, Clone)]\n+pub enum SbTagExtra {\n+    Concrete(SbTag),\n+    Wildcard,\n+}\n+\n+impl fmt::Debug for SbTagExtra {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            SbTagExtra::Concrete(tag) => write!(f, \"{tag:?}\"),\n+            SbTagExtra::Wildcard => write!(f, \"<wildcard>\"),\n+        }\n+    }\n+}\n+\n+impl SbTagExtra {\n+    fn and_then<T>(self, f: impl FnOnce(SbTag) -> Option<T>) -> Option<T> {\n+        match self {\n+            SbTagExtra::Concrete(tag) => f(tag),\n+            SbTagExtra::Wildcard => None,\n+        }\n+    }\n+}\n+\n /// Indicates which permission is granted (by this item to some pointers)\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum Permission {\n@@ -104,15 +132,24 @@ pub struct Stack {\n     /// * Above a `SharedReadOnly` there can only be more `SharedReadOnly`.\n     /// * Except for `Untagged`, no tag occurs in the stack more than once.\n     borrows: Vec<Item>,\n+    /// If this is `Some(id)`, then the actual current stack is unknown. This can happen when\n+    /// wildcard pointers are used to access this location. What we do know is that `borrows` are at\n+    /// the top of the stack, and below it are arbitrarily many items whose `tag` is either\n+    /// `Untagged` or strictly less than `id`.\n+    /// When the bottom is unknown, `borrows` always has a `SharedReadOnly` or `Unique` at the bottom;\n+    /// we never have the unknown-to-known boundary in an SRW group.\n+    unknown_bottom: Option<PtrId>,\n }\n \n /// Extra per-allocation state.\n #[derive(Clone, Debug)]\n pub struct Stacks {\n     // Even reading memory can have effects on the stack, so we need a `RefCell` here.\n-    stacks: RefCell<RangeMap<Stack>>,\n+    stacks: RangeMap<Stack>,\n     /// Stores past operations on this allocation\n-    history: RefCell<AllocHistory>,\n+    history: AllocHistory,\n+    /// The set of tags that have been exposed inside this allocation.\n+    exposed_tags: FxHashSet<SbTag>,\n }\n \n /// Extra global state, available to the memory access hooks.\n@@ -282,19 +319,61 @@ impl Permission {\n /// Core per-location operations: access, dealloc, reborrow.\n impl<'tcx> Stack {\n     /// Find the item granting the given kind of access to the given tag, and return where\n-    /// it is on the stack.\n-    fn find_granting(&self, access: AccessKind, tag: SbTag) -> Option<usize> {\n-        self.borrows\n-            .iter()\n-            .enumerate() // we also need to know *where* in the stack\n-            .rev() // search top-to-bottom\n-            // Return permission of first item that grants access.\n-            // We require a permission with the right tag, ensuring U3 and F3.\n-            .find_map(\n-                |(idx, item)| {\n+    /// it is on the stack. For wildcard tags, the given index is approximate, but if *no*\n+    /// index is given it means the match was *not* in the known part of the stack.\n+    /// `Ok(None)` indicates it matched the \"unknown\" part of the stack.\n+    /// `Err` indicates it was not found.\n+    fn find_granting(\n+        &self,\n+        access: AccessKind,\n+        tag: SbTagExtra,\n+        exposed_tags: &FxHashSet<SbTag>,\n+    ) -> Result<Option<usize>, ()> {\n+        let SbTagExtra::Concrete(tag) = tag else {\n+            // Handle the wildcard case.\n+            // Go search the stack for an exposed tag.\n+            if let Some(idx) =\n+                self.borrows\n+                    .iter()\n+                    .enumerate() // we also need to know *where* in the stack\n+                    .rev() // search top-to-bottom\n+                    .find_map(|(idx, item)| {\n+                        // If the item fits and *might* be this wildcard, use it.\n+                        if item.perm.grants(access) && exposed_tags.contains(&item.tag) {\n+                            Some(idx)\n+                        } else {\n+                            None\n+                        }\n+                    })\n+            {\n+                return Ok(Some(idx));\n+            }\n+            // If we couldn't find it in the stack, check the unknown bottom.\n+            return if self.unknown_bottom.is_some() { Ok(None) } else { Err(()) };\n+        };\n+\n+        if let Some(idx) =\n+            self.borrows\n+                .iter()\n+                .enumerate() // we also need to know *where* in the stack\n+                .rev() // search top-to-bottom\n+                // Return permission of first item that grants access.\n+                // We require a permission with the right tag, ensuring U3 and F3.\n+                .find_map(|(idx, item)| {\n                     if tag == item.tag && item.perm.grants(access) { Some(idx) } else { None }\n-                },\n-            )\n+                })\n+        {\n+            return Ok(Some(idx));\n+        }\n+\n+        // Couldn't find it in the stack; but if there is an unknown bottom it might be there.\n+        let found = self.unknown_bottom.is_some_and(|&unknown_limit| {\n+            match tag {\n+                SbTag::Tagged(tag_id) => tag_id < unknown_limit, // unknown_limit is an upper bound for what can be in the unknown bottom.\n+                SbTag::Untagged => true,                         // yeah whatever\n+            }\n+        });\n+        if found { Ok(None) } else { Err(()) }\n     }\n \n     /// Find the first write-incompatible item above the given one --\n@@ -304,8 +383,10 @@ impl<'tcx> Stack {\n         match perm {\n             Permission::SharedReadOnly => bug!(\"Cannot use SharedReadOnly for writing\"),\n             Permission::Disabled => bug!(\"Cannot use Disabled for anything\"),\n-            // On a write, everything above us is incompatible.\n-            Permission::Unique => granting + 1,\n+            Permission::Unique => {\n+                // On a write, everything above us is incompatible.\n+                granting + 1\n+            }\n             Permission::SharedReadWrite => {\n                 // The SharedReadWrite *just* above us are compatible, to skip those.\n                 let mut idx = granting + 1;\n@@ -333,7 +414,7 @@ impl<'tcx> Stack {\n     /// currently checking.\n     fn check_protector(\n         item: &Item,\n-        provoking_access: Option<(SbTag, AllocRange, Size, AccessKind)>, // just for debug printing and error messages\n+        provoking_access: Option<(SbTagExtra, AllocRange, Size, AccessKind)>, // just for debug printing and error messages\n         global: &GlobalStateInner,\n         alloc_history: &mut AllocHistory,\n     ) -> InterpResult<'tcx> {\n@@ -354,12 +435,14 @@ impl<'tcx> Stack {\n                             tag, item\n                         ),\n                         None,\n-                        alloc_history.get_logs_relevant_to(\n-                            tag,\n-                            alloc_range,\n-                            offset,\n-                            Some(item.tag),\n-                        ),\n+                        tag.and_then(|tag| {\n+                            alloc_history.get_logs_relevant_to(\n+                                tag,\n+                                alloc_range,\n+                                offset,\n+                                Some(item.tag),\n+                            )\n+                        }),\n                     ))?\n                 } else {\n                     Err(err_sb_ub(\n@@ -380,25 +463,36 @@ impl<'tcx> Stack {\n     fn access(\n         &mut self,\n         access: AccessKind,\n-        tag: SbTag,\n+        tag: SbTagExtra,\n         (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &mut GlobalStateInner,\n         current_span: &mut CurrentSpan<'_, '_, 'tcx>,\n         alloc_history: &mut AllocHistory,\n+        exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n         // Two main steps: Find granting item, remove incompatible items above.\n \n         // Step 1: Find granting item.\n-        let granting_idx = self.find_granting(access, tag).ok_or_else(|| {\n+        let granting_idx = self.find_granting(access, tag, exposed_tags).map_err(|_| {\n             alloc_history.access_error(access, tag, alloc_id, alloc_range, offset, self)\n         })?;\n \n         // Step 2: Remove incompatible items above them.  Make sure we do not remove protected\n         // items.  Behavior differs for reads and writes.\n+        // In case of wildcards/unknown matches, we remove everything that is *definitely* gone.\n         if access == AccessKind::Write {\n             // Remove everything above the write-compatible items, like a proper stack. This makes sure read-only and unique\n             // pointers become invalid on write accesses (ensures F2a, and ensures U2 for write accesses).\n-            let first_incompatible_idx = self.find_first_write_incompatible(granting_idx);\n+            let first_incompatible_idx = if let Some(granting_idx) = granting_idx {\n+                // The granting_idx *might* be approximate, but any lower idx would remove more\n+                // things. Even if this is a Unique and the lower idx is an SRW (which removes\n+                // less), there is an SRW group boundary here so strictly more would get removed.\n+                self.find_first_write_incompatible(granting_idx)\n+            } else {\n+                // We are writing to something in the unknown part.\n+                // There is a SRW group boundary between the unknown and the known, so everything is incompatible.\n+                0\n+            };\n             for item in self.borrows.drain(first_incompatible_idx..).rev() {\n                 trace!(\"access: popping item {:?}\", item);\n                 Stack::check_protector(\n@@ -418,8 +512,16 @@ impl<'tcx> Stack {\n             // This pattern occurs a lot in the standard library: create a raw pointer, then also create a shared\n             // reference and use that.\n             // We *disable* instead of removing `Unique` to avoid \"connecting\" two neighbouring blocks of SRWs.\n-            for idx in ((granting_idx + 1)..self.borrows.len()).rev() {\n+            let first_incompatible_idx = if let Some(granting_idx) = granting_idx {\n+                // The granting_idx *might* be approximate, but any lower idx would disable more things.\n+                granting_idx + 1\n+            } else {\n+                // We are reading from something in the unknown part. That means *all* `Unique` we know about are dead now.\n+                0\n+            };\n+            for idx in (first_incompatible_idx..self.borrows.len()).rev() {\n                 let item = &mut self.borrows[idx];\n+\n                 if item.perm == Permission::Unique {\n                     trace!(\"access: disabling item {:?}\", item);\n                     Stack::check_protector(\n@@ -434,6 +536,31 @@ impl<'tcx> Stack {\n             }\n         }\n \n+        // If this was an approximate action, we now collapse everything into an unknown.\n+        if granting_idx.is_none() || matches!(tag, SbTagExtra::Wildcard) {\n+            // Compute the upper bound of the items that remain.\n+            // (This is why we did all the work above: to reduce the items we have to consider here.)\n+            let mut max = NonZeroU64::new(1).unwrap();\n+            for item in &self.borrows {\n+                // Skip disabled items, they cannot be matched anyway.\n+                if !matches!(item.perm, Permission::Disabled) {\n+                    if let SbTag::Tagged(tag) = item.tag {\n+                        // We are looking for a strict upper bound, so add 1 to this tag.\n+                        max = cmp::max(tag.checked_add(1).unwrap(), max);\n+                    }\n+                }\n+            }\n+            if let Some(unk) = self.unknown_bottom {\n+                max = cmp::max(unk, max);\n+            }\n+            // Use `max` as new strict upper bound for everything.\n+            trace!(\n+                \"access: forgetting stack to upper bound {max} due to wildcard or unknown access\"\n+            );\n+            self.borrows.clear();\n+            self.unknown_bottom = Some(max);\n+        }\n+\n         // Done.\n         Ok(())\n     }\n@@ -442,27 +569,27 @@ impl<'tcx> Stack {\n     /// active protectors at all because we will remove all items.\n     fn dealloc(\n         &mut self,\n-        tag: SbTag,\n+        tag: SbTagExtra,\n         (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &GlobalStateInner,\n         alloc_history: &mut AllocHistory,\n+        exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n-        // Step 1: Find granting item.\n-        self.find_granting(AccessKind::Write, tag).ok_or_else(|| {\n+        // Step 1: Make sure there is a granting item.\n+        self.find_granting(AccessKind::Write, tag, exposed_tags).map_err(|_| {\n             err_sb_ub(format!(\n                 \"no item granting write access for deallocation to tag {:?} at {:?} found in borrow stack\",\n                 tag, alloc_id,\n                 ),\n                 None,\n-                alloc_history.get_logs_relevant_to(tag, alloc_range, offset, None),\n+                tag.and_then(|tag| alloc_history.get_logs_relevant_to(tag, alloc_range, offset, None)),\n             )\n         })?;\n \n         // Step 2: Remove all items.  Also checks for protectors.\n         for item in self.borrows.drain(..).rev() {\n             Stack::check_protector(&item, None, global, alloc_history)?;\n         }\n-\n         Ok(())\n     }\n \n@@ -474,21 +601,24 @@ impl<'tcx> Stack {\n     /// `range` that we are currently checking.\n     fn grant(\n         &mut self,\n-        derived_from: SbTag,\n+        derived_from: SbTagExtra,\n         new: Item,\n         (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &mut GlobalStateInner,\n         current_span: &mut CurrentSpan<'_, '_, 'tcx>,\n         alloc_history: &mut AllocHistory,\n+        exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n         // Figure out which access `perm` corresponds to.\n         let access =\n             if new.perm.grants(AccessKind::Write) { AccessKind::Write } else { AccessKind::Read };\n+\n         // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n         // We use that to determine where to put the new item.\n-        let granting_idx = self.find_granting(access, derived_from).ok_or_else(|| {\n-            alloc_history.grant_error(derived_from, new, alloc_id, alloc_range, offset, self)\n-        })?;\n+        let granting_idx =\n+            self.find_granting(access, derived_from, exposed_tags).map_err(|_| {\n+                alloc_history.grant_error(derived_from, new, alloc_id, alloc_range, offset, self)\n+            })?;\n \n         // Compute where to put the new item.\n         // Either way, we ensure that we insert the new item in a way such that between\n@@ -498,6 +628,18 @@ impl<'tcx> Stack {\n                 access == AccessKind::Write,\n                 \"this case only makes sense for stack-like accesses\"\n             );\n+\n+            let (Some(granting_idx), SbTagExtra::Concrete(_)) = (granting_idx, derived_from) else {\n+                // The parent is a wildcard pointer or matched the unknown bottom.\n+                // This is approximate. Nobody knows what happened, so forget everything.\n+                // The new thing is SRW anyway, so we cannot push it \"on top of the unkown part\"\n+                // (for all we know, it might join an SRW group inside the unknown).\n+                trace!(\"reborrow: forgetting stack entirely due to SharedReadWrite reborrow from wildcard or unknown\");\n+                self.borrows.clear();\n+                self.unknown_bottom = Some(global.next_ptr_id);\n+                return Ok(());\n+            };\n+\n             // SharedReadWrite can coexist with \"existing loans\", meaning they don't act like a write\n             // access.  Instead of popping the stack, we insert the item at the place the stack would\n             // be popped to (i.e., we insert it above all the write-compatible items).\n@@ -514,6 +656,7 @@ impl<'tcx> Stack {\n                 global,\n                 current_span,\n                 alloc_history,\n+                exposed_tags,\n             )?;\n \n             // We insert \"as far up as possible\": We know only compatible items are remaining\n@@ -524,14 +667,16 @@ impl<'tcx> Stack {\n         };\n \n         // Put the new item there. As an optimization, deduplicate if it is equal to one of its new neighbors.\n-        if self.borrows[new_idx - 1] == new || self.borrows.get(new_idx) == Some(&new) {\n+        // `new_idx` might be 0 if we just cleared the entire stack.\n+        if self.borrows.get(new_idx) == Some(&new)\n+            || (new_idx > 0 && self.borrows[new_idx - 1] == new)\n+        {\n             // Optimization applies, done.\n             trace!(\"reborrow: avoiding adding redundant item {:?}\", new);\n         } else {\n             trace!(\"reborrow: adding item {:?}\", new);\n             self.borrows.insert(new_idx, new);\n         }\n-\n         Ok(())\n     }\n }\n@@ -542,38 +687,28 @@ impl<'tcx> Stacks {\n     /// Creates new stack with initial tag.\n     fn new(size: Size, perm: Permission, tag: SbTag) -> Self {\n         let item = Item { perm, tag, protector: None };\n-        let stack = Stack { borrows: vec![item] };\n+        let stack = Stack { borrows: vec![item], unknown_bottom: None };\n \n         Stacks {\n-            stacks: RefCell::new(RangeMap::new(size, stack)),\n-            history: RefCell::new(AllocHistory::new()),\n+            stacks: RangeMap::new(size, stack),\n+            history: AllocHistory::new(),\n+            exposed_tags: FxHashSet::default(),\n         }\n     }\n \n     /// Call `f` on every stack in the range.\n     fn for_each(\n-        &self,\n-        range: AllocRange,\n-        mut f: impl FnMut(Size, &mut Stack, &mut AllocHistory) -> InterpResult<'tcx>,\n-    ) -> InterpResult<'tcx> {\n-        let mut stacks = self.stacks.borrow_mut();\n-        let history = &mut *self.history.borrow_mut();\n-        for (offset, stack) in stacks.iter_mut(range.start, range.size) {\n-            f(offset, stack, history)?;\n-        }\n-        Ok(())\n-    }\n-\n-    /// Call `f` on every stack in the range.\n-    fn for_each_mut(\n         &mut self,\n         range: AllocRange,\n-        mut f: impl FnMut(Size, &mut Stack, &mut AllocHistory) -> InterpResult<'tcx>,\n+        mut f: impl FnMut(\n+            Size,\n+            &mut Stack,\n+            &mut AllocHistory,\n+            &mut FxHashSet<SbTag>,\n+        ) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n-        let stacks = self.stacks.get_mut();\n-        let history = &mut *self.history.borrow_mut();\n-        for (offset, stack) in stacks.iter_mut(range.start, range.size) {\n-            f(offset, stack, history)?;\n+        for (offset, stack) in self.stacks.iter_mut(range.start, range.size) {\n+            f(offset, stack, &mut self.history, &mut self.exposed_tags)?;\n         }\n         Ok(())\n     }\n@@ -620,8 +755,8 @@ impl Stacks {\n                 (tag, Permission::SharedReadWrite)\n             }\n         };\n-        let stacks = Stacks::new(size, perm, base_tag);\n-        stacks.history.borrow_mut().log_creation(\n+        let mut stacks = Stacks::new(size, perm, base_tag);\n+        stacks.history.log_creation(\n             None,\n             base_tag,\n             alloc_range(Size::ZERO, size),\n@@ -632,9 +767,9 @@ impl Stacks {\n \n     #[inline(always)]\n     pub fn memory_read<'tcx>(\n-        &self,\n+        &mut self,\n         alloc_id: AllocId,\n-        tag: SbTag,\n+        tag: SbTagExtra,\n         range: AllocRange,\n         state: &GlobalState,\n         mut current_span: CurrentSpan<'_, '_, 'tcx>,\n@@ -646,14 +781,15 @@ impl Stacks {\n             range.size.bytes()\n         );\n         let mut state = state.borrow_mut();\n-        self.for_each(range, |offset, stack, history| {\n+        self.for_each(range, |offset, stack, history, exposed_tags| {\n             stack.access(\n                 AccessKind::Read,\n                 tag,\n                 (alloc_id, range, offset),\n                 &mut state,\n                 &mut current_span,\n                 history,\n+                exposed_tags,\n             )\n         })\n     }\n@@ -662,7 +798,7 @@ impl Stacks {\n     pub fn memory_written<'tcx>(\n         &mut self,\n         alloc_id: AllocId,\n-        tag: SbTag,\n+        tag: SbTagExtra,\n         range: AllocRange,\n         state: &GlobalState,\n         mut current_span: CurrentSpan<'_, '_, 'tcx>,\n@@ -674,14 +810,15 @@ impl Stacks {\n             range.size.bytes()\n         );\n         let mut state = state.borrow_mut();\n-        self.for_each_mut(range, |offset, stack, history| {\n+        self.for_each(range, |offset, stack, history, exposed_tags| {\n             stack.access(\n                 AccessKind::Write,\n                 tag,\n                 (alloc_id, range, offset),\n                 &mut state,\n                 &mut current_span,\n                 history,\n+                exposed_tags,\n             )\n         })\n     }\n@@ -690,14 +827,14 @@ impl Stacks {\n     pub fn memory_deallocated<'tcx>(\n         &mut self,\n         alloc_id: AllocId,\n-        tag: SbTag,\n+        tag: SbTagExtra,\n         range: AllocRange,\n         state: &GlobalState,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", tag, alloc_id, range.size.bytes());\n         let state = state.borrow();\n-        self.for_each_mut(range, |offset, stack, history| {\n-            stack.dealloc(tag, (alloc_id, range, offset), &state, history)\n+        self.for_each(range, |offset, stack, history, exposed_tags| {\n+            stack.dealloc(tag, (alloc_id, range, offset), &state, history, exposed_tags)\n         })?;\n         Ok(())\n     }\n@@ -707,14 +844,16 @@ impl Stacks {\n /// to grant for which references, and when to add protectors.\n impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    /// Returns the `AllocId` the reborrow was done in, if some actual borrow stack manipulation\n+    /// happened.\n     fn reborrow(\n         &mut self,\n         place: &MPlaceTy<'tcx, Tag>,\n         size: Size,\n         kind: RefKind,\n         new_tag: SbTag,\n         protect: bool,\n-    ) -> InterpResult<'tcx> {\n+    ) -> InterpResult<'tcx, Option<AllocId>> {\n         let this = self.eval_context_mut();\n         let current_span = &mut this.machine.current_span();\n \n@@ -724,23 +863,36 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                             base_offset,\n                             orig_tag|\n          -> InterpResult<'tcx> {\n+            let SbTagExtra::Concrete(orig_tag) = orig_tag else {\n+                // FIXME: should we log this?\n+                return Ok(())\n+            };\n             let extra = this.get_alloc_extra(alloc_id)?;\n-            let stacked_borrows =\n-                extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n-            let mut alloc_history = stacked_borrows.history.borrow_mut();\n-            alloc_history.log_creation(\n+            let mut stacked_borrows = extra\n+                .stacked_borrows\n+                .as_ref()\n+                .expect(\"we should have Stacked Borrows data\")\n+                .borrow_mut();\n+            stacked_borrows.history.log_creation(\n                 Some(orig_tag),\n                 new_tag,\n                 alloc_range(base_offset, size),\n                 current_span,\n             );\n             if protect {\n-                alloc_history.log_protector(orig_tag, new_tag, current_span);\n+                stacked_borrows.history.log_protector(orig_tag, new_tag, current_span);\n             }\n             Ok(())\n         };\n \n         if size == Size::ZERO {\n+            trace!(\n+                \"reborrow of size 0: {} reference {:?} derived from {:?} (pointee {})\",\n+                kind,\n+                new_tag,\n+                place.ptr,\n+                place.layout.ty,\n+            );\n             // Don't update any stacks for a zero-sized access; borrow stacks are per-byte and this\n             // touches no bytes so there is no stack to put this tag in.\n             // However, if the pointer for this operation points at a real allocation we still\n@@ -750,16 +902,10 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // pointer tagging for example all calls to get_unchecked on them are invalid.\n             if let Ok((alloc_id, base_offset, orig_tag)) = this.ptr_try_get_alloc_id(place.ptr) {\n                 log_creation(this, current_span, alloc_id, base_offset, orig_tag)?;\n+                return Ok(Some(alloc_id));\n             }\n-\n-            trace!(\n-                \"reborrow of size 0: {} reference {:?} derived from {:?} (pointee {})\",\n-                kind,\n-                new_tag,\n-                place.ptr,\n-                place.layout.ty,\n-            );\n-            return Ok(());\n+            // This pointer doesn't come with an AllocId. :shrug:\n+            return Ok(None);\n         }\n         let (alloc_id, base_offset, orig_tag) = this.ptr_get_alloc_id(place.ptr)?;\n         log_creation(this, current_span, alloc_id, base_offset, orig_tag)?;\n@@ -810,8 +956,11 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // We have to use shared references to alloc/memory_extra here since\n                 // `visit_freeze_sensitive` needs to access the global state.\n                 let extra = this.get_alloc_extra(alloc_id)?;\n-                let stacked_borrows =\n-                    extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n+                let mut stacked_borrows = extra\n+                    .stacked_borrows\n+                    .as_ref()\n+                    .expect(\"we should have Stacked Borrows data\")\n+                    .borrow_mut();\n                 this.visit_freeze_sensitive(place, size, |mut range, frozen| {\n                     // Adjust range.\n                     range.start += base_offset;\n@@ -830,42 +979,47 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     };\n                     let item = Item { perm, tag: new_tag, protector };\n                     let mut global = this.machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n-                    stacked_borrows.for_each(range, |offset, stack, history| {\n+                    stacked_borrows.for_each(range, |offset, stack, history, exposed_tags| {\n                         stack.grant(\n                             orig_tag,\n                             item,\n                             (alloc_id, range, offset),\n                             &mut *global,\n                             current_span,\n                             history,\n+                            exposed_tags,\n                         )\n                     })\n                 })?;\n-                return Ok(());\n+                return Ok(Some(alloc_id));\n             }\n         };\n         // Here we can avoid `borrow()` calls because we have mutable references.\n         // Note that this asserts that the allocation is mutable -- but since we are creating a\n         // mutable pointer, that seems reasonable.\n         let (alloc_extra, machine) = this.get_alloc_extra_mut(alloc_id)?;\n-        let stacked_borrows =\n-            alloc_extra.stacked_borrows.as_mut().expect(\"we should have Stacked Borrows data\");\n+        let mut stacked_borrows = alloc_extra\n+            .stacked_borrows\n+            .as_mut()\n+            .expect(\"we should have Stacked Borrows data\")\n+            .borrow_mut();\n         let item = Item { perm, tag: new_tag, protector };\n         let range = alloc_range(base_offset, size);\n         let mut global = machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n         let current_span = &mut machine.current_span(); // `get_alloc_extra_mut` invalidated our old `current_span`\n-        stacked_borrows.for_each_mut(range, |offset, stack, history| {\n+        stacked_borrows.for_each(range, |offset, stack, history, exposed_tags| {\n             stack.grant(\n                 orig_tag,\n                 item,\n                 (alloc_id, range, offset),\n                 &mut global,\n                 current_span,\n                 history,\n+                exposed_tags,\n             )\n         })?;\n \n-        Ok(())\n+        Ok(Some(alloc_id))\n     }\n \n     /// Retags an indidual pointer, returning the retagged version.\n@@ -900,16 +1054,22 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         };\n \n         // Reborrow.\n-        this.reborrow(&place, size, kind, new_tag, protect)?;\n+        let alloc_id = this.reborrow(&place, size, kind, new_tag, protect)?;\n \n         // Adjust pointer.\n         let new_place = place.map_provenance(|p| {\n-            p.map(|t| {\n-                // TODO: Fix this eventually\n-                if let Tag::Concrete(t) = t {\n-                    Tag::Concrete(ConcreteTag { sb: new_tag, ..t })\n-                } else {\n-                    t\n+            p.map(|prov| {\n+                match alloc_id {\n+                    Some(alloc_id) => {\n+                        // If `reborrow` could figure out the AllocId of this ptr, hard-code it into the new one.\n+                        // Even if we started out with a wildcard, this newly retagged pointer is tied to that allocation.\n+                        Tag::Concrete { alloc_id, sb: new_tag }\n+                    }\n+                    None => {\n+                        // Looks like this has to stay a wildcard pointer.\n+                        assert!(matches!(prov, Tag::Wildcard));\n+                        Tag::Wildcard\n+                    }\n                 }\n             })\n         });\n@@ -990,4 +1150,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         Ok(())\n     }\n+\n+    /// Mark the given tag as exposed. It was found on a pointer with the given AllocId.\n+    fn expose_tag(&mut self, alloc_id: AllocId, tag: SbTag) {\n+        let this = self.eval_context_mut();\n+\n+        // Function pointers and dead objects don't have an alloc_extra so we ignore them.\n+        // This is okay because accessing them is UB anyway, no need for any Stacked Borrows checks.\n+        // NOT using `get_alloc_extra_mut` since this might be a read-only allocation!\n+        // FIXME: this catches `InterpError`, which we should not usually do.\n+        // We might need a proper fallible API from `memory.rs` to avoid this though.\n+        match this.get_alloc_extra(alloc_id) {\n+            Ok(alloc_extra) => {\n+                trace!(\"Stacked Borrows tag {tag:?} exposed in {alloc_id}\");\n+                alloc_extra.stacked_borrows.as_ref().unwrap().borrow_mut().exposed_tags.insert(tag);\n+            }\n+            Err(err) => {\n+                trace!(\n+                    \"Not exposing Stacked Borrows tag {tag:?} due to error \\\n+                    when accessing {alloc_id}: {err}\"\n+                );\n+            }\n+        }\n+    }\n }"}, {"sha": "a4a7f5e7a1e350bd3aa95df8d9aef94081092d8f", "filename": "src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3b4402ccf505818c901d1d2ac9852293331438fe/src%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4402ccf505818c901d1d2ac9852293331438fe/src%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fdiagnostics.rs?ref=3b4402ccf505818c901d1d2ac9852293331438fe", "patch": "@@ -8,6 +8,7 @@ use crate::helpers::{CurrentSpan, HexRange};\n use crate::stacked_borrows::{err_sb_ub, AccessKind, Permission};\n use crate::Item;\n use crate::SbTag;\n+use crate::SbTagExtra;\n use crate::Stack;\n \n use rustc_middle::mir::interpret::InterpError;\n@@ -197,48 +198,47 @@ impl AllocHistory {\n     /// Report a descriptive error when `new` could not be granted from `derived_from`.\n     pub fn grant_error<'tcx>(\n         &self,\n-        derived_from: SbTag,\n+        derived_from: SbTagExtra,\n         new: Item,\n         alloc_id: AllocId,\n         alloc_range: AllocRange,\n         error_offset: Size,\n         stack: &Stack,\n     ) -> InterpError<'tcx> {\n         let action = format!(\n-            \"trying to reborrow {:?} for {:?} permission at {}[{:#x}]\",\n-            derived_from,\n+            \"trying to reborrow {derived_from:?} for {:?} permission at {}[{:#x}]\",\n             new.perm,\n             alloc_id,\n             error_offset.bytes(),\n         );\n         err_sb_ub(\n             format!(\"{}{}\", action, error_cause(stack, derived_from)),\n             Some(operation_summary(\"a reborrow\", alloc_id, alloc_range)),\n-            self.get_logs_relevant_to(derived_from, alloc_range, error_offset, None),\n+            derived_from.and_then(|derived_from| {\n+                self.get_logs_relevant_to(derived_from, alloc_range, error_offset, None)\n+            }),\n         )\n     }\n \n     /// Report a descriptive error when `access` is not permitted based on `tag`.\n     pub fn access_error<'tcx>(\n         &self,\n         access: AccessKind,\n-        tag: SbTag,\n+        tag: SbTagExtra,\n         alloc_id: AllocId,\n         alloc_range: AllocRange,\n         error_offset: Size,\n         stack: &Stack,\n     ) -> InterpError<'tcx> {\n         let action = format!(\n-            \"attempting a {} using {:?} at {}[{:#x}]\",\n-            access,\n-            tag,\n+            \"attempting a {access} using {tag:?} at {}[{:#x}]\",\n             alloc_id,\n             error_offset.bytes(),\n         );\n         err_sb_ub(\n             format!(\"{}{}\", action, error_cause(stack, tag)),\n             Some(operation_summary(\"an access\", alloc_id, alloc_range)),\n-            self.get_logs_relevant_to(tag, alloc_range, error_offset, None),\n+            tag.and_then(|tag| self.get_logs_relevant_to(tag, alloc_range, error_offset, None)),\n         )\n     }\n }\n@@ -251,10 +251,14 @@ fn operation_summary(\n     format!(\"this error occurs as part of {} at {:?}{}\", operation, alloc_id, HexRange(alloc_range))\n }\n \n-fn error_cause(stack: &Stack, tag: SbTag) -> &'static str {\n-    if stack.borrows.iter().any(|item| item.tag == tag && item.perm != Permission::Disabled) {\n-        \", but that tag only grants SharedReadOnly permission for this location\"\n+fn error_cause(stack: &Stack, tag: SbTagExtra) -> &'static str {\n+    if let SbTagExtra::Concrete(tag) = tag {\n+        if stack.borrows.iter().any(|item| item.tag == tag && item.perm != Permission::Disabled) {\n+            \", but that tag only grants SharedReadOnly permission for this location\"\n+        } else {\n+            \", but that tag does not exist in the borrow stack for this location\"\n+        }\n     } else {\n-        \", but that tag does not exist in the borrow stack for this location\"\n+        \", but no exposed tags have suitable permission in the borrow stack for this location\"\n     }\n }"}, {"sha": "28e6ba6230803423ef6b459f9d1e0c8d6aa22418", "filename": "tests/fail/provenance/permissive_provenance_transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b4402ccf505818c901d1d2ac9852293331438fe/tests%2Ffail%2Fprovenance%2Fpermissive_provenance_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4402ccf505818c901d1d2ac9852293331438fe/tests%2Ffail%2Fprovenance%2Fpermissive_provenance_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fprovenance%2Fpermissive_provenance_transmute.rs?ref=3b4402ccf505818c901d1d2ac9852293331438fe", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -Zmiri-permissive-provenance -Zmiri-disable-stacked-borrows\n+// compile-flags: -Zmiri-permissive-provenance\n #![feature(strict_provenance)]\n \n use std::mem;"}, {"sha": "ad29d38dc3f7af9fe67c3c6e6e1d6b1b08cf424f", "filename": "tests/fail/provenance/ptr_int_unexposed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b4402ccf505818c901d1d2ac9852293331438fe/tests%2Ffail%2Fprovenance%2Fptr_int_unexposed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4402ccf505818c901d1d2ac9852293331438fe/tests%2Ffail%2Fprovenance%2Fptr_int_unexposed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fprovenance%2Fptr_int_unexposed.rs?ref=3b4402ccf505818c901d1d2ac9852293331438fe", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -Zmiri-permissive-provenance -Zmiri-disable-stacked-borrows\n+// compile-flags: -Zmiri-permissive-provenance\n #![feature(strict_provenance)]\n \n fn main() {"}, {"sha": "9b4234499df044644b74922305db7b662c874759", "filename": "tests/fail/stacked_borrows/exposed_only_ro.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3b4402ccf505818c901d1d2ac9852293331438fe/tests%2Ffail%2Fstacked_borrows%2Fexposed_only_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4402ccf505818c901d1d2ac9852293331438fe/tests%2Ffail%2Fstacked_borrows%2Fexposed_only_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fexposed_only_ro.rs?ref=3b4402ccf505818c901d1d2ac9852293331438fe", "patch": "@@ -0,0 +1,12 @@\n+// compile-flags: -Zmiri-permissive-provenance\n+#![feature(strict_provenance)]\n+\n+// If we have only exposed read-only pointers, doing a write through a wildcard ptr should fail.\n+\n+fn main() {\n+    let mut x = 0;\n+    let _fool = &mut x as *mut i32; // this would have fooled the old untagged pointer logic\n+    let addr = (&x as *const i32).expose_addr();\n+    let ptr = std::ptr::from_exposed_addr_mut::<i32>(addr);\n+    unsafe { *ptr = 0 }; //~ ERROR: borrow stack\n+}"}, {"sha": "28fa98b6020c0bf894bddb30d19f622f789601c2", "filename": "tests/fail/stacked_borrows/exposed_only_ro.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3b4402ccf505818c901d1d2ac9852293331438fe/tests%2Ffail%2Fstacked_borrows%2Fexposed_only_ro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b4402ccf505818c901d1d2ac9852293331438fe/tests%2Ffail%2Fstacked_borrows%2Fexposed_only_ro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fexposed_only_ro.stderr?ref=3b4402ccf505818c901d1d2ac9852293331438fe", "patch": "@@ -0,0 +1,18 @@\n+error: Undefined Behavior: attempting a write access using <wildcard> at ALLOC[0x0], but no exposed tags have suitable permission in the borrow stack for this location\n+  --> $DIR/exposed_only_ro.rs:LL:CC\n+   |\n+LL |     unsafe { *ptr = 0 };\n+   |              ^^^^^^^^\n+   |              |\n+   |              attempting a write access using <wildcard> at ALLOC[0x0], but no exposed tags have suitable permission in the borrow stack for this location\n+   |              this error occurs as part of an access at ALLOC[0x0..0x4]\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+           \n+   = note: inside `main` at $DIR/exposed_only_ro.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "61a5e05d34cd34251b915683b9f5fa8355502ae0", "filename": "tests/fail/stacked_borrows/illegal_read_despite_exposed1.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3b4402ccf505818c901d1d2ac9852293331438fe/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4402ccf505818c901d1d2ac9852293331438fe/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed1.rs?ref=3b4402ccf505818c901d1d2ac9852293331438fe", "patch": "@@ -0,0 +1,17 @@\n+// compile-flags: -Zmiri-permissive-provenance\n+\n+fn main() {\n+    unsafe {\n+        let root = &mut 42;\n+        let addr = root as *mut i32 as usize;\n+        let exposed_ptr = addr as *mut i32;\n+        // From the exposed ptr, we get a new unique ptr.\n+        let root2 = &mut *exposed_ptr;\n+        let _fool = root2 as *mut _; // this would have fooled the old untagged pointer logic\n+        // Stack: Unknown(<N), Unique(N), SRW(N+1)\n+        // And we test that it has uniqueness by doing a conflicting write.\n+        *exposed_ptr = 0;\n+        // Stack: Unknown(<N)\n+        let _val = *root2; //~ ERROR: borrow stack\n+    }\n+}"}, {"sha": "fde135f752f7889324ae7f203d84e17122c88336", "filename": "tests/fail/stacked_borrows/illegal_read_despite_exposed1.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3b4402ccf505818c901d1d2ac9852293331438fe/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b4402ccf505818c901d1d2ac9852293331438fe/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed1.stderr?ref=3b4402ccf505818c901d1d2ac9852293331438fe", "patch": "@@ -0,0 +1,18 @@\n+error: Undefined Behavior: attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+  --> $DIR/illegal_read_despite_exposed1.rs:LL:CC\n+   |\n+LL |         let _val = *root2;\n+   |                    ^^^^^^\n+   |                    |\n+   |                    attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |                    this error occurs as part of an access at ALLOC[0x0..0x4]\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+           \n+   = note: inside `main` at $DIR/illegal_read_despite_exposed1.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "19d0784591e496e5675ca90501e1683e8446e3a3", "filename": "tests/fail/stacked_borrows/illegal_read_despite_exposed2.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3b4402ccf505818c901d1d2ac9852293331438fe/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4402ccf505818c901d1d2ac9852293331438fe/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed2.rs?ref=3b4402ccf505818c901d1d2ac9852293331438fe", "patch": "@@ -0,0 +1,20 @@\n+// compile-flags: -Zmiri-permissive-provenance\n+\n+fn main() {\n+    unsafe {\n+        let root = &mut 42;\n+        let addr = root as *mut i32 as usize;\n+        let exposed_ptr = addr as *mut i32;\n+        // From the exposed ptr, we get a new unique ptr.\n+        let root2 = &mut *exposed_ptr;\n+        // let _fool = root2 as *mut _; // this would fool us, since SRW(N+1) remains on the stack\n+        // Stack: Unknown(<N), Unique(N)\n+        // Stack if _fool existed: Unknown(<N), Unique(N), SRW(N+1)\n+        // And we test that it has uniqueness by doing a conflicting read.\n+        let _val = *exposed_ptr;\n+        // Stack: Unknown(<N), Disabled(N)\n+        // collapsed to Unknown(<N)\n+        // Stack if _fool existed: Unknown(<N), Disabled(N), SRW(N+1); collapsed to Unknown(<N+2) which would not cause an ERROR\n+        let _val = *root2; //~ ERROR: borrow stack\n+    }\n+}"}, {"sha": "947d9fd70a0d2046f972d3172463398da0f2d1a9", "filename": "tests/fail/stacked_borrows/illegal_read_despite_exposed2.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3b4402ccf505818c901d1d2ac9852293331438fe/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b4402ccf505818c901d1d2ac9852293331438fe/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed2.stderr?ref=3b4402ccf505818c901d1d2ac9852293331438fe", "patch": "@@ -0,0 +1,18 @@\n+error: Undefined Behavior: attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+  --> $DIR/illegal_read_despite_exposed2.rs:LL:CC\n+   |\n+LL |         let _val = *root2;\n+   |                    ^^^^^^\n+   |                    |\n+   |                    attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |                    this error occurs as part of an access at ALLOC[0x0..0x4]\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+           \n+   = note: inside `main` at $DIR/illegal_read_despite_exposed2.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "b50399b9df52177f875353e469dbe8f98eeff277", "filename": "tests/fail/stacked_borrows/illegal_write_despite_exposed1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3b4402ccf505818c901d1d2ac9852293331438fe/tests%2Ffail%2Fstacked_borrows%2Fillegal_write_despite_exposed1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4402ccf505818c901d1d2ac9852293331438fe/tests%2Ffail%2Fstacked_borrows%2Fillegal_write_despite_exposed1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write_despite_exposed1.rs?ref=3b4402ccf505818c901d1d2ac9852293331438fe", "patch": "@@ -0,0 +1,16 @@\n+// compile-flags: -Zmiri-permissive-provenance\n+\n+fn main() {\n+    unsafe {\n+        let root = &mut 42;\n+        let addr = root as *mut i32 as usize;\n+        let exposed_ptr = addr as *mut i32;\n+        // From the exposed ptr, we get a new SRO ptr.\n+        let root2 = &*exposed_ptr;\n+        // Stack: Unknown(<N), SRO(N), SRO(N+1)\n+        // And we test that it is read-only by doing a conflicting write.\n+        *exposed_ptr = 0;\n+        // Stack: Unknown(<N)\n+        let _val = *root2; //~ ERROR: borrow stack\n+    }\n+}"}, {"sha": "ac96c9dac8d8402275b07b831d95b573a1e42cff", "filename": "tests/fail/stacked_borrows/illegal_write_despite_exposed1.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3b4402ccf505818c901d1d2ac9852293331438fe/tests%2Ffail%2Fstacked_borrows%2Fillegal_write_despite_exposed1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b4402ccf505818c901d1d2ac9852293331438fe/tests%2Ffail%2Fstacked_borrows%2Fillegal_write_despite_exposed1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write_despite_exposed1.stderr?ref=3b4402ccf505818c901d1d2ac9852293331438fe", "patch": "@@ -0,0 +1,18 @@\n+error: Undefined Behavior: attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+  --> $DIR/illegal_write_despite_exposed1.rs:LL:CC\n+   |\n+LL |         let _val = *root2;\n+   |                    ^^^^^^\n+   |                    |\n+   |                    attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |                    this error occurs as part of an access at ALLOC[0x0..0x4]\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+           \n+   = note: inside `main` at $DIR/illegal_write_despite_exposed1.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "dc9cb393b781537d722fb0d645f0585b418c28c7", "filename": "tests/pass/ptr_int_from_exposed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b4402ccf505818c901d1d2ac9852293331438fe/tests%2Fpass%2Fptr_int_from_exposed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4402ccf505818c901d1d2ac9852293331438fe/tests%2Fpass%2Fptr_int_from_exposed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fptr_int_from_exposed.rs?ref=3b4402ccf505818c901d1d2ac9852293331438fe", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -Zmiri-permissive-provenance -Zmiri-disable-stacked-borrows\n+// compile-flags: -Zmiri-permissive-provenance\n #![feature(strict_provenance)]\n \n use std::ptr;"}, {"sha": "dc3675406276fd0547cb5954724f4f17457d6f1c", "filename": "tests/pass/stacked-borrows/int-to-ptr.rs", "status": "modified", "additions": 73, "deletions": 3, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/3b4402ccf505818c901d1d2ac9852293331438fe/tests%2Fpass%2Fstacked-borrows%2Fint-to-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4402ccf505818c901d1d2ac9852293331438fe/tests%2Fpass%2Fstacked-borrows%2Fint-to-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fstacked-borrows%2Fint-to-ptr.rs?ref=3b4402ccf505818c901d1d2ac9852293331438fe", "patch": "@@ -1,6 +1,6 @@\n-fn main() {\n-    ref_raw_int_raw();\n-}\n+// compile-flags: -Zmiri-permissive-provenance\n+#![feature(strict_provenance)]\n+use std::ptr;\n \n // Just to make sure that casting a ref to raw, to int and back to raw\n // and only then using it works. This rules out ideas like \"do escape-to-raw lazily\";\n@@ -11,3 +11,73 @@ fn ref_raw_int_raw() {\n     let xraw = xref as *mut i32 as usize as *mut i32;\n     assert_eq!(unsafe { *xraw }, 3);\n }\n+\n+/// Ensure that we do not just pick the topmost possible item on int2ptr casts.\n+fn example(variant: bool) {\n+    unsafe {\n+        fn not_so_innocent(x: &mut u32) -> usize {\n+            let x_raw4 = x as *mut u32;\n+            x_raw4.expose_addr()\n+        }\n+\n+        let mut c = 42u32;\n+\n+        let x_unique1 = &mut c;\n+        // [..., Unique(1)]\n+\n+        let x_raw2 = x_unique1 as *mut u32;\n+        let x_raw2_addr = x_raw2.expose_addr();\n+        // [..., Unique(1), SharedRW(2)]\n+\n+        let x_unique3 = &mut *x_raw2;\n+        // [.., Unique(1), SharedRW(2), Unique(3)]\n+\n+        assert_eq!(not_so_innocent(x_unique3), x_raw2_addr);\n+        // [.., Unique(1), SharedRW(2), Unique(3), ..., SharedRW(4)]\n+\n+        // Do an int2ptr cast. This can pick tag 2 or 4 (the two previously exposed tags).\n+        // 4 is the \"obvious\" choice (topmost tag, what we used to do with untagged pointers).\n+        // And indeed if `variant == true` it is the only possible choice.\n+        // But if `variant == false` then 2 is the only possible choice!\n+        let x_wildcard = ptr::from_exposed_addr_mut::<i32>(x_raw2_addr);\n+\n+        if variant {\n+            // If we picked 2, this will invalidate 3.\n+            *x_wildcard = 10;\n+            // Now we use 3. Only possible if above we picked 4.\n+            *x_unique3 = 12;\n+        } else {\n+            // This invalidates tag 4.\n+            *x_unique3 = 10;\n+            // Now try to write with the \"guessed\" tag; it must be 2.\n+            *x_wildcard = 12;\n+        }\n+    }\n+}\n+\n+fn test() {\n+    unsafe {\n+        let root = &mut 42;\n+        let root_raw = root as *mut i32;\n+        let addr1 = root_raw as usize;\n+        let child = &mut *root_raw;\n+        let child_raw = child as *mut i32;\n+        let addr2 = child_raw as usize;\n+        assert_eq!(addr1, addr2);\n+        // First use child.\n+        *(addr2 as *mut i32) -= 2; // picks child_raw\n+        *child -= 2;\n+        // Then use root.\n+        *(addr1 as *mut i32) += 2; // picks root_raw\n+        *root += 2;\n+        // Value should be unchanged.\n+        assert_eq!(*root, 42);\n+    }\n+}\n+\n+fn main() {\n+    ref_raw_int_raw();\n+    example(false);\n+    example(true);\n+    test();\n+}"}]}