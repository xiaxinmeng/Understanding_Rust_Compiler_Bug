{"sha": "13e380d798cd13fac2c4683f673da50514770cb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzZTM4MGQ3OThjZDEzZmFjMmM0NjgzZjY3M2RhNTA1MTQ3NzBjYjM=", "commit": {"author": {"name": "Thom Chiovoloni", "email": "tchiovoloni@mozilla.com", "date": "2020-07-05T21:51:05Z"}, "committer": {"name": "Thom Chiovoloni", "email": "tchiovoloni@mozilla.com", "date": "2020-07-05T21:51:05Z"}, "message": "Benchmark the unaligned case for is_ascii, and add missing SAFETY", "tree": {"sha": "4d0deb0cf06410bdec551c8630dc5395177e7059", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d0deb0cf06410bdec551c8630dc5395177e7059"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13e380d798cd13fac2c4683f673da50514770cb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13e380d798cd13fac2c4683f673da50514770cb3", "html_url": "https://github.com/rust-lang/rust/commit/13e380d798cd13fac2c4683f673da50514770cb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13e380d798cd13fac2c4683f673da50514770cb3/comments", "author": null, "committer": null, "parents": [{"sha": "e1d4db605581097742e8fc236ba7f0a0890aa93f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1d4db605581097742e8fc236ba7f0a0890aa93f", "html_url": "https://github.com/rust-lang/rust/commit/e1d4db605581097742e8fc236ba7f0a0890aa93f"}], "stats": {"total": 24, "additions": 21, "deletions": 3}, "files": [{"sha": "21199ecaac14f76116adaefaae66aede6be18584", "filename": "src/libcore/benches/ascii.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/13e380d798cd13fac2c4683f673da50514770cb3/src%2Flibcore%2Fbenches%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13e380d798cd13fac2c4683f673da50514770cb3/src%2Flibcore%2Fbenches%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fascii.rs?ref=13e380d798cd13fac2c4683f673da50514770cb3", "patch": "@@ -65,6 +65,23 @@ macro_rules! benches {\n         benches!(@ro mod short_readonly SHORT $($name $arg $body)+);\n         benches!(@ro mod medium_readonly MEDIUM $($name $arg $body)+);\n         benches!(@ro mod long_readonly LONG $($name $arg $body)+);\n+        // Add another `MEDIUM` bench, but trim the ends so that we can (try to)\n+        // benchmark a case where the function has to handle misalignment.\n+        mod medium_unaligned {\n+            use super::*;\n+            $(\n+                #[bench]\n+                fn $name(bencher: &mut Bencher) {\n+                    bencher.bytes = MEDIUM.len() as u64 - 2;\n+                    let mut vec = MEDIUM.as_bytes().to_vec();\n+                    bencher.iter(|| {\n+                        black_box(&mut vec);\n+                        let $arg = black_box(&vec[1..(vec.len() - 1)]);\n+                        black_box($body)\n+                    })\n+                }\n+            )+\n+        }\n     };\n     (@ro mod $mod_name: ident $input: ident $($name: ident $arg: ident $body: block)+) => {\n         mod $mod_name {\n@@ -291,10 +308,11 @@ fn is_ascii_align_to_impl(bytes: &[u8]) -> bool {\n     if bytes.len() < core::mem::size_of::<usize>() {\n         return bytes.iter().all(|b| b.is_ascii());\n     }\n+    // SAFETY: transmuting a sequence of `u8` to `usize` is always fine\n     let (head, body, tail) = unsafe { bytes.align_to::<usize>() };\n-    head.iter().all(|b| b.is_ascii()) &&\n-    body.iter().all(|w| !contains_nonascii(*w)) &&\n-    tail.iter().all(|b| b.is_ascii())\n+    head.iter().all(|b| b.is_ascii())\n+        && body.iter().all(|w| !contains_nonascii(*w))\n+        && tail.iter().all(|b| b.is_ascii())\n }\n \n #[inline]"}]}