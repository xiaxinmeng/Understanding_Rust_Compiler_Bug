{"sha": "413328b0f2be70303c53ecde89c1f59f450a38ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxMzMyOGIwZjJiZTcwMzAzYzUzZWNkZTg5YzFmNTlmNDUwYTM4YmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-09T03:06:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-09T03:06:21Z"}, "message": "auto merge of #15964 : huonw/rust/gensym-test, r=alexcrichton\n\nThis requires avoiding `quote_...!` for constructing the parts of the\r\n__test module, since that stringifies and reinterns the idents, losing\r\nthe special gensym'd nature of them. (#15962.)", "tree": {"sha": "24b349fa7b6c1132de3638eb2c046e0729743920", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24b349fa7b6c1132de3638eb2c046e0729743920"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/413328b0f2be70303c53ecde89c1f59f450a38ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/413328b0f2be70303c53ecde89c1f59f450a38ba", "html_url": "https://github.com/rust-lang/rust/commit/413328b0f2be70303c53ecde89c1f59f450a38ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/413328b0f2be70303c53ecde89c1f59f450a38ba/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39bafb09fd616ae6aceec4abf05c270435e8cc42", "url": "https://api.github.com/repos/rust-lang/rust/commits/39bafb09fd616ae6aceec4abf05c270435e8cc42", "html_url": "https://github.com/rust-lang/rust/commit/39bafb09fd616ae6aceec4abf05c270435e8cc42"}, {"sha": "edc9191921a9ef8ff8438a10b5f315ae9190e48c", "url": "https://api.github.com/repos/rust-lang/rust/commits/edc9191921a9ef8ff8438a10b5f315ae9190e48c", "html_url": "https://github.com/rust-lang/rust/commit/edc9191921a9ef8ff8438a10b5f315ae9190e48c"}], "stats": {"total": 299, "additions": 184, "deletions": 115}, "files": [{"sha": "14cda7d62c35def4dc62053e12af7a95184c1f61", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 107, "deletions": 67, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/413328b0f2be70303c53ecde89c1f59f450a38ba/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413328b0f2be70303c53ecde89c1f59f450a38ba/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=413328b0f2be70303c53ecde89c1f59f450a38ba", "patch": "@@ -51,6 +51,7 @@ struct TestCtxt<'a> {\n     ext_cx: ExtCtxt<'a>,\n     testfns: Vec<Test>,\n     reexport_mod_ident: ast::Ident,\n+    reexport_test_harness_main: Option<InternedString>,\n     is_test_crate: bool,\n     config: ast::CrateConfig,\n }\n@@ -64,8 +65,16 @@ pub fn modify_for_testing(sess: &Session,\n     // command line options.\n     let should_test = attr::contains_name(krate.config.as_slice(), \"test\");\n \n+    // Check for #[reexport_test_harness_main = \"some_name\"] which\n+    // creates a `use some_name = __test::main;`. This needs to be\n+    // unconditional, so that the attribute is still marked as used in\n+    // non-test builds.\n+    let reexport_test_harness_main =\n+        attr::first_attr_value_str_by_name(krate.attrs.as_slice(),\n+                                           \"reexport_test_harness_main\");\n+\n     if should_test {\n-        generate_test_harness(sess, krate)\n+        generate_test_harness(sess, reexport_test_harness_main, krate)\n     } else {\n         strip_test_functions(krate)\n     }\n@@ -79,14 +88,17 @@ struct TestHarnessGenerator<'a> {\n \n impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n     fn fold_crate(&mut self, c: ast::Crate) -> ast::Crate {\n-        let folded = fold::noop_fold_crate(c, self);\n+        let mut folded = fold::noop_fold_crate(c, self);\n \n         // Add a special __test module to the crate that will contain code\n         // generated for the test harness\n-        ast::Crate {\n-            module: add_test_module(&self.cx, &folded.module),\n-            .. folded\n+        let (mod_, reexport) = mk_test_module(&self.cx, &self.cx.reexport_test_harness_main);\n+        folded.module.items.push(mod_);\n+        match reexport {\n+            Some(re) => folded.module.view_items.push(re),\n+            None => {}\n         }\n+        folded\n     }\n \n     fn fold_item(&mut self, i: Gc<ast::Item>) -> SmallVector<Gc<ast::Item>> {\n@@ -196,7 +208,9 @@ fn mk_reexport_mod(cx: &mut TestCtxt, tests: Vec<ast::Ident>,\n     }\n }\n \n-fn generate_test_harness(sess: &Session, krate: ast::Crate) -> ast::Crate {\n+fn generate_test_harness(sess: &Session,\n+                         reexport_test_harness_main: Option<InternedString>,\n+                         krate: ast::Crate) -> ast::Crate {\n     let mut cx: TestCtxt = TestCtxt {\n         sess: sess,\n         ext_cx: ExtCtxt::new(&sess.parse_sess, sess.opts.cfg.clone(),\n@@ -206,7 +220,8 @@ fn generate_test_harness(sess: &Session, krate: ast::Crate) -> ast::Crate {\n                              }),\n         path: Vec::new(),\n         testfns: Vec::new(),\n-        reexport_mod_ident: token::str_to_ident(\"__test_reexports\"),\n+        reexport_mod_ident: token::gensym_ident(\"__test_reexports\"),\n+        reexport_test_harness_main: reexport_test_harness_main,\n         is_test_crate: is_test_crate(&krate),\n         config: krate.config.clone(),\n     };\n@@ -314,14 +329,6 @@ fn should_fail(i: Gc<ast::Item>) -> bool {\n     attr::contains_name(i.attrs.as_slice(), \"should_fail\")\n }\n \n-fn add_test_module(cx: &TestCtxt, m: &ast::Mod) -> ast::Mod {\n-    let testmod = mk_test_module(cx);\n-    ast::Mod {\n-        items: m.items.clone().append_one(testmod),\n-        ..(*m).clone()\n-    }\n-}\n-\n /*\n \n We're going to be building a module that looks more or less like:\n@@ -359,7 +366,8 @@ fn mk_std(cx: &TestCtxt) -> ast::ViewItem {\n     }\n }\n \n-fn mk_test_module(cx: &TestCtxt) -> Gc<ast::Item> {\n+fn mk_test_module(cx: &TestCtxt, reexport_test_harness_main: &Option<InternedString>)\n+                  -> (Gc<ast::Item>, Option<ast::ViewItem>) {\n     // Link to test crate\n     let view_items = vec!(mk_std(cx));\n \n@@ -383,18 +391,35 @@ fn mk_test_module(cx: &TestCtxt) -> Gc<ast::Item> {\n     };\n     let item_ = ast::ItemMod(testmod);\n \n+    let mod_ident = token::gensym_ident(\"__test\");\n     let item = ast::Item {\n-        ident: token::str_to_ident(\"__test\"),\n+        ident: mod_ident,\n         attrs: Vec::new(),\n         id: ast::DUMMY_NODE_ID,\n         node: item_,\n         vis: ast::Public,\n         span: DUMMY_SP,\n-     };\n+    };\n+    let reexport = reexport_test_harness_main.as_ref().map(|s| {\n+        // building `use <ident> = __test::main`\n+        let reexport_ident = token::str_to_ident(s.get());\n+\n+        let use_path =\n+            nospan(ast::ViewPathSimple(reexport_ident,\n+                                       path_node(vec![mod_ident, token::str_to_ident(\"main\")]),\n+                                       ast::DUMMY_NODE_ID));\n+\n+        ast::ViewItem {\n+            node: ast::ViewItemUse(box(GC) use_path),\n+            attrs: vec![],\n+            vis: ast::Inherited,\n+            span: DUMMY_SP\n+        }\n+    });\n \n     debug!(\"Synthetic test module:\\n{}\\n\", pprust::item_to_string(&item));\n \n-    box(GC) item\n+    (box(GC) item, reexport)\n }\n \n fn nospan<T>(t: T) -> codemap::Spanned<T> {\n@@ -417,11 +442,27 @@ fn mk_tests(cx: &TestCtxt) -> Gc<ast::Item> {\n     // The vector of test_descs for this crate\n     let test_descs = mk_test_descs(cx);\n \n-    (quote_item!(&cx.ext_cx,\n-        pub static TESTS : &'static [self::test::TestDescAndFn] =\n-            $test_descs\n-        ;\n-    )).unwrap()\n+    // FIXME #15962: should be using quote_item, but that stringifies\n+    // __test_reexports, causing it to be reinterned, losing the\n+    // gensym information.\n+    let sp = DUMMY_SP;\n+    let ecx = &cx.ext_cx;\n+    let struct_type = ecx.ty_path(ecx.path(sp, vec![ecx.ident_of(\"self\"),\n+                                                    ecx.ident_of(\"test\"),\n+                                                    ecx.ident_of(\"TestDescAndFn\")]),\n+                                  None);\n+    let static_lt = ecx.lifetime(sp, token::special_idents::static_lifetime.name);\n+    // &'static [self::test::TestDescAndFn]\n+    let static_type = ecx.ty_rptr(sp,\n+                                  ecx.ty(sp, ast::TyVec(struct_type)),\n+                                  Some(static_lt),\n+                                  ast::MutImmutable);\n+    // static TESTS: $static_type = &[...];\n+    ecx.item_static(sp,\n+                    ecx.ident_of(\"TESTS\"),\n+                    static_type,\n+                    ast::MutImmutable,\n+                    test_descs)\n }\n \n fn is_test_crate(krate: &ast::Crate) -> bool {\n@@ -448,59 +489,58 @@ fn mk_test_descs(cx: &TestCtxt) -> Gc<ast::Expr> {\n }\n \n fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> Gc<ast::Expr> {\n+    // FIXME #15962: should be using quote_expr, but that stringifies\n+    // __test_reexports, causing it to be reinterned, losing the\n+    // gensym information.\n+\n     let span = test.span;\n     let path = test.path.clone();\n+    let ecx = &cx.ext_cx;\n+    let self_id = ecx.ident_of(\"self\");\n+    let test_id = ecx.ident_of(\"test\");\n+\n+    // creates self::test::$name\n+    let test_path = |name| {\n+        ecx.path(span, vec![self_id, test_id, ecx.ident_of(name)])\n+    };\n+    // creates $name: $expr\n+    let field = |name, expr| ecx.field_imm(span, ecx.ident_of(name), expr);\n \n     debug!(\"encoding {}\", ast_util::path_name_i(path.as_slice()));\n \n-    let name_lit: ast::Lit =\n-        nospan(ast::LitStr(token::intern_and_get_ident(\n-                    ast_util::path_name_i(path.as_slice()).as_slice()),\n-                    ast::CookedStr));\n+    // path to the #[test] function: \"foo::bar::baz\"\n+    let path_string = ast_util::path_name_i(path.as_slice());\n+    let name_expr = ecx.expr_str(span, token::intern_and_get_ident(path_string.as_slice()));\n \n-    let name_expr = box(GC) ast::Expr {\n-          id: ast::DUMMY_NODE_ID,\n-          node: ast::ExprLit(box(GC) name_lit),\n-          span: span\n-    };\n+    // self::test::StaticTestName($name_expr)\n+    let name_expr = ecx.expr_call(span,\n+                                  ecx.expr_path(test_path(\"StaticTestName\")),\n+                                  vec![name_expr]);\n \n-    let mut visible_path = vec![cx.reexport_mod_ident.clone()];\n-    visible_path.extend(path.move_iter());\n-    let fn_path = cx.ext_cx.path_global(DUMMY_SP, visible_path);\n+    let ignore_expr = ecx.expr_bool(span, test.ignore);\n+    let fail_expr = ecx.expr_bool(span, test.should_fail);\n \n-    let fn_expr = box(GC) ast::Expr {\n-        id: ast::DUMMY_NODE_ID,\n-        node: ast::ExprPath(fn_path),\n-        span: span,\n-    };\n+    // self::test::TestDesc { ... }\n+    let desc_expr = ecx.expr_struct(\n+        span,\n+        test_path(\"TestDesc\"),\n+        vec![field(\"name\", name_expr),\n+             field(\"ignore\", ignore_expr),\n+             field(\"should_fail\", fail_expr)]);\n \n-    let t_expr = if test.bench {\n-        quote_expr!(&cx.ext_cx, self::test::StaticBenchFn($fn_expr) )\n-    } else {\n-        quote_expr!(&cx.ext_cx, self::test::StaticTestFn($fn_expr) )\n-    };\n \n-    let ignore_expr = if test.ignore {\n-        quote_expr!(&cx.ext_cx, true )\n-    } else {\n-        quote_expr!(&cx.ext_cx, false )\n-    };\n+    let mut visible_path = vec![cx.reexport_mod_ident.clone()];\n+    visible_path.extend(path.move_iter());\n \n-    let fail_expr = if test.should_fail {\n-        quote_expr!(&cx.ext_cx, true )\n-    } else {\n-        quote_expr!(&cx.ext_cx, false )\n-    };\n+    let fn_expr = ecx.expr_path(ecx.path_global(span, visible_path));\n \n-    let e = quote_expr!(&cx.ext_cx,\n-        self::test::TestDescAndFn {\n-            desc: self::test::TestDesc {\n-                name: self::test::StaticTestName($name_expr),\n-                ignore: $ignore_expr,\n-                should_fail: $fail_expr\n-            },\n-            testfn: $t_expr,\n-        }\n-    );\n-    e\n+    let variant_name = if test.bench { \"StaticBenchFn\" } else { \"StaticTestFn\" };\n+    // self::test::$variant_name($fn_expr)\n+    let testfn_expr = ecx.expr_call(span, ecx.expr_path(test_path(variant_name)), vec![fn_expr]);\n+\n+    // self::test::TestDescAndFn { ... }\n+    ecx.expr_struct(span,\n+                    test_path(\"TestDescAndFn\"),\n+                    vec![field(\"desc\", desc_expr),\n+                         field(\"testfn\", testfn_expr)])\n }"}, {"sha": "dd80ab3ee78a15f23545e908c094b2c5224ba05e", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/413328b0f2be70303c53ecde89c1f59f450a38ba/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413328b0f2be70303c53ecde89c1f59f450a38ba/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=413328b0f2be70303c53ecde89c1f59f450a38ba", "patch": "@@ -48,6 +48,8 @@ via `close` and `delete` methods.\n #![deny(unused_result, unused_must_use)]\n #![allow(visible_private_types)]\n \n+#![reexport_test_harness_main = \"test_main\"]\n+\n #[cfg(test)] extern crate green;\n #[cfg(test)] extern crate debug;\n #[cfg(test)] extern crate realrustuv = \"rustuv\";\n@@ -76,13 +78,9 @@ pub use self::timer::TimerWatcher;\n pub use self::tty::TtyWatcher;\n \n // Run tests with libgreen instead of libnative.\n-//\n-// FIXME: This egregiously hacks around starting the test runner in a different\n-//        threading mode than the default by reaching into the auto-generated\n-//        '__test' module.\n #[cfg(test)] #[start]\n fn start(argc: int, argv: *const *const u8) -> int {\n-    green::start(argc, argv, event_loop, __test::main)\n+    green::start(argc, argv, event_loop, test_main)\n }\n \n mod macros;"}, {"sha": "20fc7efeb574f15d4a7a0884286e082dc1504d8e", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/413328b0f2be70303c53ecde89c1f59f450a38ba/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413328b0f2be70303c53ecde89c1f59f450a38ba/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=413328b0f2be70303c53ecde89c1f59f450a38ba", "patch": "@@ -114,6 +114,8 @@\n #![allow(deprecated)]\n #![deny(missing_doc)]\n \n+#![reexport_test_harness_main = \"test_main\"]\n+\n // When testing libstd, bring in libuv as the I/O backend so tests can print\n // things and all of the std::io tests have an I/O interface to run on top\n // of\n@@ -186,13 +188,9 @@ pub use unicode::char;\n pub use core_sync::comm;\n \n // Run tests with libgreen instead of libnative.\n-//\n-// FIXME: This egregiously hacks around starting the test runner in a different\n-//        threading mode than the default by reaching into the auto-generated\n-//        '__test' module.\n #[cfg(test)] #[start]\n fn start(argc: int, argv: *const *const u8) -> int {\n-    green::start(argc, argv, rustuv::event_loop, __test::main)\n+    green::start(argc, argv, rustuv::event_loop, test_main)\n }\n \n /* Exported macros */"}, {"sha": "b646f8083b8d5590286cf99672a9fb1db7d5a060", "filename": "src/test/compile-fail/inaccessible-test-modules.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/413328b0f2be70303c53ecde89c1f59f450a38ba/src%2Ftest%2Fcompile-fail%2Finaccessible-test-modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413328b0f2be70303c53ecde89c1f59f450a38ba/src%2Ftest%2Fcompile-fail%2Finaccessible-test-modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finaccessible-test-modules.rs?ref=413328b0f2be70303c53ecde89c1f59f450a38ba", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:--test\n+\n+// the `--test` harness creates modules with these textual names, but\n+// they should be inaccessible from normal code.\n+use x = __test; //~ ERROR unresolved import `__test`\n+use y = __test_reexports; //~ ERROR unresolved import `__test_reexports`\n+\n+#[test]\n+fn baz() {}"}, {"sha": "4517af8e24be595c38c3a735077297fd51572864", "filename": "src/test/run-make/test-harness/Makefile", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/413328b0f2be70303c53ecde89c1f59f450a38ba/src%2Ftest%2Frun-make%2Ftest-harness%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/413328b0f2be70303c53ecde89c1f59f450a38ba/src%2Ftest%2Frun-make%2Ftest-harness%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftest-harness%2FMakefile?ref=413328b0f2be70303c53ecde89c1f59f450a38ba", "patch": "@@ -0,0 +1,7 @@\n+-include ../tools.mk\n+\n+all:\n+\t# check that #[ignore(cfg(...))] does the right thing.\n+\t$(RUSTC) --test test-ignore-cfg.rs --cfg ignorecfg\n+\t$(call RUN,test-ignore-cfg) | grep 'shouldnotignore ... ok'\n+\t$(call RUN,test-ignore-cfg) | grep 'shouldignore ... ignored'"}, {"sha": "a8f88cc8544a927685fc18e484d59fe9c3fe0ed2", "filename": "src/test/run-make/test-harness/test-ignore-cfg.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/413328b0f2be70303c53ecde89c1f59f450a38ba/src%2Ftest%2Frun-make%2Ftest-harness%2Ftest-ignore-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413328b0f2be70303c53ecde89c1f59f450a38ba/src%2Ftest%2Frun-make%2Ftest-harness%2Ftest-ignore-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftest-harness%2Ftest-ignore-cfg.rs?ref=413328b0f2be70303c53ecde89c1f59f450a38ba", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[test]\n+#[ignore(cfg(ignorecfg))]\n+fn shouldignore() {\n+}\n+\n+#[test]\n+#[ignore(cfg(noignorecfg))]\n+fn shouldnotignore() {\n+}"}, {"sha": "d187a6a8afebb17346fd0763a7ca07a2a97bc6ad", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/413328b0f2be70303c53ecde89c1f59f450a38ba/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413328b0f2be70303c53ecde89c1f59f450a38ba/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=413328b0f2be70303c53ecde89c1f59f450a38ba", "patch": "@@ -16,6 +16,8 @@\n // instead of in std.\n \n #![feature(macro_rules)]\n+#![reexport_test_harness_main = \"test_main\"]\n+\n extern crate libc;\n \n extern crate native;\n@@ -55,7 +57,7 @@ macro_rules! iotest (\n \n #[cfg(test)] #[start]\n fn start(argc: int, argv: *const *const u8) -> int {\n-    green::start(argc, argv, rustuv::event_loop, __test::main)\n+    green::start(argc, argv, rustuv::event_loop, test_main)\n }\n \n iotest!(fn test_destroy_once() {"}, {"sha": "309ae1bcc56eceb6151b35af5aff7a8cf0b87ecc", "filename": "src/test/run-pass/reexport-test-harness-main.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/413328b0f2be70303c53ecde89c1f59f450a38ba/src%2Ftest%2Frun-pass%2Freexport-test-harness-main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413328b0f2be70303c53ecde89c1f59f450a38ba/src%2Ftest%2Frun-pass%2Freexport-test-harness-main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freexport-test-harness-main.rs?ref=413328b0f2be70303c53ecde89c1f59f450a38ba", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty\n+// compile-flags:--test\n+\n+#![reexport_test_harness_main = \"test_main\"]\n+\n+#[cfg(test)]\n+fn _unused() {\n+    // should resolve to the entry point function the --test harness\n+    // creates.\n+    test_main();\n+}"}, {"sha": "6f6fff15814d556f8865acac9353475f5bb09718", "filename": "src/test/run-pass/tcp-connect-timeouts.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/413328b0f2be70303c53ecde89c1f59f450a38ba/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413328b0f2be70303c53ecde89c1f59f450a38ba/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs?ref=413328b0f2be70303c53ecde89c1f59f450a38ba", "patch": "@@ -18,14 +18,15 @@\n \n #![feature(macro_rules, globs)]\n #![allow(experimental)]\n+#![reexport_test_harness_main = \"test_main\"]\n \n extern crate native;\n extern crate green;\n extern crate rustuv;\n \n #[cfg(test)] #[start]\n fn start(argc: int, argv: *const *const u8) -> int {\n-    green::start(argc, argv, rustuv::event_loop, __test::main)\n+    green::start(argc, argv, rustuv::event_loop, test_main)\n }\n \n macro_rules! iotest ("}, {"sha": "b36fbca2da048a68f9b82af3c19712e00677ec47", "filename": "src/test/run-pass/test-ignore-cfg.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/39bafb09fd616ae6aceec4abf05c270435e8cc42/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39bafb09fd616ae6aceec4abf05c270435e8cc42/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs?ref=39bafb09fd616ae6aceec4abf05c270435e8cc42", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: --test --cfg ignorecfg\n-// ignore-pretty: does not work well with `--test`\n-\n-#[test]\n-#[ignore(cfg(ignorecfg))]\n-fn shouldignore() {\n-}\n-\n-#[test]\n-#[ignore(cfg(noignorecfg))]\n-fn shouldnotignore() {\n-}\n-\n-#[test]\n-fn checktests() {\n-    // Pull the tests out of the secreturn test module\n-    let tests = __test::TESTS;\n-\n-    assert!(\n-        tests.iter().any(|t| t.desc.name.to_string().as_slice() == \"shouldignore\" &&\n-                         t.desc.ignore));\n-\n-    assert!(\n-        tests.iter().any(|t| t.desc.name.to_string().as_slice() == \"shouldnotignore\" &&\n-                         !t.desc.ignore));\n-}"}]}