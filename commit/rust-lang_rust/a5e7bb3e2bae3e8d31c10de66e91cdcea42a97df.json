{"sha": "a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ZTdiYjNlMmJhZTNlOGQzMWMxMGRlNjZlOTFjZGNlYTQyYTk3ZGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-27T15:41:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-27T15:41:45Z"}, "message": "Auto merge of #63043 - Centril:rollup-f4baee4, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #62423 (Fix cycle error with existential types)\n - #62979 (Cleanup save-analysis JsonDumper)\n - #62982 (Don't access a static just for its size and alignment)\n - #63013 (add `repr(transparent)` to `IoSliceMut` where missing)\n - #63014 (Stop bare trait lint applying to macro call sites)\n - #63036 (Add lib section to rustc_lexer's Cargo.toml)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "3bda6c31bb326cb96e871a1d751a0d9756e8a7b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bda6c31bb326cb96e871a1d751a0d9756e8a7b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "html_url": "https://github.com/rust-lang/rust/commit/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e9b465d729d07101b29b4d096d83edf9be82df0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e9b465d729d07101b29b4d096d83edf9be82df0", "html_url": "https://github.com/rust-lang/rust/commit/0e9b465d729d07101b29b4d096d83edf9be82df0"}, {"sha": "51769b3012b3f2819bbcde05a574e6f3015b7d37", "url": "https://api.github.com/repos/rust-lang/rust/commits/51769b3012b3f2819bbcde05a574e6f3015b7d37", "html_url": "https://github.com/rust-lang/rust/commit/51769b3012b3f2819bbcde05a574e6f3015b7d37"}], "stats": {"total": 607, "additions": 388, "deletions": 219}, "files": [{"sha": "639994ed14d86dac521ccc67afed785a24e41d0a", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -5753,13 +5753,21 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn maybe_lint_bare_trait(&self, span: Span, id: NodeId, is_global: bool) {\n-        self.sess.buffer_lint_with_diagnostic(\n-            builtin::BARE_TRAIT_OBJECTS,\n-            id,\n-            span,\n-            \"trait objects without an explicit `dyn` are deprecated\",\n-            builtin::BuiltinLintDiagnostics::BareTraitObject(span, is_global),\n-        )\n+        // FIXME(davidtwco): This is a hack to detect macros which produce spans of the\n+        // call site which do not have a macro backtrace. See #61963.\n+        let is_macro_callsite = self.sess.source_map()\n+            .span_to_snippet(span)\n+            .map(|snippet| snippet.starts_with(\"#[\"))\n+            .unwrap_or(true);\n+        if !is_macro_callsite {\n+            self.sess.buffer_lint_with_diagnostic(\n+                builtin::BARE_TRAIT_OBJECTS,\n+                id,\n+                span,\n+                \"trait objects without an explicit `dyn` are deprecated\",\n+                builtin::BuiltinLintDiagnostics::BareTraitObject(span, is_global),\n+            )\n+        }\n     }\n \n     fn wrap_in_try_constructor("}, {"sha": "0dbcda618ecac32a33b36a29fdbdb9391784feea", "filename": "src/librustc_lexer/Cargo.toml", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Flibrustc_lexer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Flibrustc_lexer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2FCargo.toml?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -7,3 +7,9 @@ edition = \"2018\"\n # Note that this crate purposefully does not depend on other rustc crates\n [dependencies]\n unicode-xid = { version = \"0.1.0\", optional = true }\n+\n+# Note: do not remove this blank `[lib]` section.\n+# This will be used when publishing this crate as `rustc-ap-rustc_lexer`.\n+[lib]\n+doctest = false\n+name = \"rustc_lexer\""}, {"sha": "45b806bd286d8286c8d77fd0f2497a0e53b4a373", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -1281,15 +1281,43 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let opaque_defn_ty = tcx.type_of(opaque_def_id);\n                         let opaque_defn_ty = opaque_defn_ty.subst(tcx, opaque_decl.substs);\n                         let opaque_defn_ty = renumber::renumber_regions(infcx, &opaque_defn_ty);\n+                        let concrete_is_opaque = infcx\n+                            .resolve_vars_if_possible(&opaque_decl.concrete_ty).is_impl_trait();\n+\n                         debug!(\n-                            \"eq_opaque_type_and_type: concrete_ty={:?}={:?} opaque_defn_ty={:?}\",\n+                            \"eq_opaque_type_and_type: concrete_ty={:?}={:?} opaque_defn_ty={:?} \\\n+                            concrete_is_opaque={}\",\n                             opaque_decl.concrete_ty,\n                             infcx.resolve_vars_if_possible(&opaque_decl.concrete_ty),\n-                            opaque_defn_ty\n+                            opaque_defn_ty,\n+                            concrete_is_opaque\n                         );\n-                        obligations.add(infcx\n-                            .at(&ObligationCause::dummy(), param_env)\n-                            .eq(opaque_decl.concrete_ty, opaque_defn_ty)?);\n+\n+                        // concrete_is_opaque is `true` when we're using an existential\n+                        // type without 'revealing' it. For example, code like this:\n+                        //\n+                        // existential type Foo: Debug;\n+                        // fn foo1() -> Foo { ... }\n+                        // fn foo2() -> Foo { foo1() }\n+                        //\n+                        // In `foo2`, we're not revealing the type of `Foo` - we're\n+                        // just treating it as the opaque type.\n+                        //\n+                        // When this occurs, we do *not* want to try to equate\n+                        // the concrete type with the underlying defining type\n+                        // of the existential type - this will always fail, since\n+                        // the defining type of an existential type is always\n+                        // some other type (e.g. not itself)\n+                        // Essentially, none of the normal obligations apply here -\n+                        // we're just passing around some unknown opaque type,\n+                        // without actually looking at the underlying type it\n+                        // gets 'revealed' into\n+\n+                        if !concrete_is_opaque {\n+                            obligations.add(infcx\n+                                .at(&ObligationCause::dummy(), param_env)\n+                                .eq(opaque_decl.concrete_ty, opaque_defn_ty)?);\n+                        }\n                     }\n \n                     debug!(\"eq_opaque_type_and_type: equated\");"}, {"sha": "4575784ac3703ba9dd08075da9549837836eac11", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 41, "deletions": 34, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -535,41 +535,48 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         id: AllocId,\n         liveness: AllocCheck,\n     ) -> InterpResult<'static, (Size, Align)> {\n-        // Regular allocations.\n-        if let Ok(alloc) = self.get(id) {\n-            return Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align));\n-        }\n-        // Function pointers.\n-        if let Ok(_) = self.get_fn_alloc(id) {\n-            return if let AllocCheck::Dereferencable = liveness {\n-                // The caller requested no function pointers.\n-                err!(DerefFunctionPointer)\n-            } else {\n-                Ok((Size::ZERO, Align::from_bytes(1).unwrap()))\n-            };\n-        }\n-        // Foreign statics.\n-        // Can't do this in the match argument, we may get cycle errors since the lock would\n-        // be held throughout the match.\n-        let alloc = self.tcx.alloc_map.lock().get(id);\n-        match alloc {\n-            Some(GlobalAlloc::Static(did)) => {\n-                assert!(self.tcx.is_foreign_item(did));\n-                // Use size and align of the type\n-                let ty = self.tcx.type_of(did);\n-                let layout = self.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n-                return Ok((layout.size, layout.align.abi));\n+        // Don't use `self.get` here as that will\n+        // a) cause cycles in case `id` refers to a static\n+        // b) duplicate a static's allocation in miri\n+        match self.alloc_map.get_or(id, || Err(())) {\n+            Ok((_, alloc)) => Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align)),\n+            Err(()) => {\n+                // Not a local allocation, check the global `tcx.alloc_map`.\n+\n+                // Can't do this in the match argument, we may get cycle errors since the lock would\n+                // be held throughout the match.\n+                let alloc = self.tcx.alloc_map.lock().get(id);\n+                match alloc {\n+                    Some(GlobalAlloc::Static(did)) => {\n+                        // Use size and align of the type.\n+                        let ty = self.tcx.type_of(did);\n+                        let layout = self.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n+                        Ok((layout.size, layout.align.abi))\n+                    },\n+                    Some(GlobalAlloc::Memory(alloc)) =>\n+                        // Need to duplicate the logic here, because the global allocations have\n+                        // different associated types than the interpreter-local ones.\n+                        Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align)),\n+                    Some(GlobalAlloc::Function(_)) => {\n+                        if let AllocCheck::Dereferencable = liveness {\n+                            // The caller requested no function pointers.\n+                            err!(DerefFunctionPointer)\n+                        } else {\n+                            Ok((Size::ZERO, Align::from_bytes(1).unwrap()))\n+                        }\n+                    },\n+                    // The rest must be dead.\n+                    None => if let AllocCheck::MaybeDead = liveness {\n+                        // Deallocated pointers are allowed, we should be able to find\n+                        // them in the map.\n+                        Ok(*self.dead_alloc_map.get(&id)\n+                            .expect(\"deallocated pointers should all be recorded in \\\n+                                    `dead_alloc_map`\"))\n+                    } else {\n+                        err!(DanglingPointerDeref)\n+                    },\n+                }\n             }\n-            _ => {}\n-        }\n-        // The rest must be dead.\n-        if let AllocCheck::MaybeDead = liveness {\n-            // Deallocated pointers are allowed, we should be able to find\n-            // them in the map.\n-            Ok(*self.dead_alloc_map.get(&id)\n-                .expect(\"deallocated pointers should all be recorded in `dead_alloc_map`\"))\n-        } else {\n-            err!(DanglingPointerDeref)\n         }\n     }\n "}, {"sha": "2b349613dc54f3e1135cd4abaa67b4378423a949", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -10,7 +10,7 @@\n //!\n //! SpanUtils is used to manipulate spans. In particular, to extract sub-spans\n //! from spans (e.g., the span for `bar` from the above example path).\n-//! DumpVisitor walks the AST and processes it, and JsonDumper is used for\n+//! DumpVisitor walks the AST and processes it, and Dumper is used for\n //! recording the output.\n \n use rustc::hir::def::{Res, DefKind as HirDefKind};\n@@ -38,7 +38,7 @@ use syntax_pos::*;\n \n use crate::{escape, generated_code, id_from_def_id, id_from_node_id, lower_attributes,\n             PathCollector, SaveContext};\n-use crate::json_dumper::{Access, DumpOutput, JsonDumper};\n+use crate::dumper::{Access, Dumper};\n use crate::span_utils::SpanUtils;\n use crate::sig;\n \n@@ -75,10 +75,10 @@ macro_rules! access_from_vis {\n     };\n }\n \n-pub struct DumpVisitor<'l, 'tcx, 'll, O: DumpOutput> {\n+pub struct DumpVisitor<'l, 'tcx, 'll> {\n     save_ctxt: SaveContext<'l, 'tcx>,\n     tcx: TyCtxt<'tcx>,\n-    dumper: &'ll mut JsonDumper<O>,\n+    dumper: &'ll mut Dumper,\n \n     span: SpanUtils<'l>,\n \n@@ -92,11 +92,11 @@ pub struct DumpVisitor<'l, 'tcx, 'll, O: DumpOutput> {\n     // macro_calls: FxHashSet<Span>,\n }\n \n-impl<'l, 'tcx, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n+impl<'l, 'tcx, 'll> DumpVisitor<'l, 'tcx, 'll> {\n     pub fn new(\n         save_ctxt: SaveContext<'l, 'tcx>,\n-        dumper: &'ll mut JsonDumper<O>,\n-    ) -> DumpVisitor<'l, 'tcx, 'll, O> {\n+        dumper: &'ll mut Dumper,\n+    ) -> DumpVisitor<'l, 'tcx, 'll> {\n         let span_utils = SpanUtils::new(&save_ctxt.tcx.sess);\n         DumpVisitor {\n             tcx: save_ctxt.tcx,\n@@ -111,7 +111,7 @@ impl<'l, 'tcx, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n     fn nest_scope<F>(&mut self, scope_id: NodeId, f: F)\n     where\n-        F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll, O>),\n+        F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll>),\n     {\n         let parent_scope = self.cur_scope;\n         self.cur_scope = scope_id;\n@@ -121,7 +121,7 @@ impl<'l, 'tcx, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n     fn nest_tables<F>(&mut self, item_id: NodeId, f: F)\n     where\n-        F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll, O>),\n+        F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll>),\n     {\n         let item_def_id = self.tcx.hir().local_def_id_from_node_id(item_id);\n         if self.tcx.has_typeck_tables(item_def_id) {\n@@ -1311,7 +1311,7 @@ impl<'l, 'tcx, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     }\n }\n \n-impl<'l, 'tcx, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll, O> {\n+impl<'l, 'tcx, 'll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll> {\n     fn visit_mod(&mut self, m: &'l ast::Mod, span: Span, attrs: &[ast::Attribute], id: NodeId) {\n         // Since we handle explicit modules ourselves in visit_item, this should\n         // only get called for the root module of a crate."}, {"sha": "6fb55e6c9905540ac99b921964fb0caa82057ec1", "filename": "src/librustc_save_analysis/dumper.rs", "status": "renamed", "additions": 7, "deletions": 54, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Flibrustc_save_analysis%2Fdumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Flibrustc_save_analysis%2Fdumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdumper.rs?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -1,80 +1,33 @@\n-use std::io::Write;\n-\n use rls_data::config::Config;\n use rls_data::{self, Analysis, CompilationOptions, CratePreludeData, Def, DefKind, Impl, Import,\n                MacroRef, Ref, RefKind, Relation};\n use rls_span::{Column, Row};\n \n-use log::error;\n-\n #[derive(Debug)]\n pub struct Access {\n     pub reachable: bool,\n     pub public: bool,\n }\n \n-pub struct JsonDumper<O: DumpOutput> {\n+pub struct Dumper {\n     result: Analysis,\n     config: Config,\n-    output: O,\n-}\n-\n-pub trait DumpOutput {\n-    fn dump(&mut self, result: &Analysis);\n-}\n-\n-pub struct WriteOutput<'b, W: Write> {\n-    output: &'b mut W,\n-}\n-\n-impl<'b, W: Write> DumpOutput for WriteOutput<'b, W> {\n-    fn dump(&mut self, result: &Analysis) {\n-        if let Err(e) = serde_json::to_writer(self.output.by_ref(), result) {\n-            error!(\"Can't serialize save-analysis: {:?}\", e);\n-        }\n-    }\n-}\n-\n-pub struct CallbackOutput<'b> {\n-    callback: &'b mut dyn FnMut(&Analysis),\n-}\n-\n-impl<'b> DumpOutput for CallbackOutput<'b> {\n-    fn dump(&mut self, result: &Analysis) {\n-        (self.callback)(result)\n-    }\n }\n \n-impl<'b, W: Write> JsonDumper<WriteOutput<'b, W>> {\n-    pub fn new(writer: &'b mut W, config: Config) -> JsonDumper<WriteOutput<'b, W>> {\n-        JsonDumper {\n-            output: WriteOutput { output: writer },\n+impl Dumper {\n+    pub fn new(config: Config) -> Dumper {\n+        Dumper {\n             config: config.clone(),\n             result: Analysis::new(config),\n         }\n     }\n-}\n-\n-impl<'b> JsonDumper<CallbackOutput<'b>> {\n-    pub fn with_callback(\n-        callback: &'b mut dyn FnMut(&Analysis),\n-        config: Config,\n-    ) -> JsonDumper<CallbackOutput<'b>> {\n-        JsonDumper {\n-            output: CallbackOutput { callback },\n-            config: config.clone(),\n-            result: Analysis::new(config),\n-        }\n-    }\n-}\n \n-impl<O: DumpOutput> Drop for JsonDumper<O> {\n-    fn drop(&mut self) {\n-        self.output.dump(&self.result);\n+    pub fn to_output(self, f: impl FnOnce(&Analysis)) {\n+        f(&self.result)\n     }\n }\n \n-impl<'b, O: DumpOutput + 'b> JsonDumper<O> {\n+impl Dumper {\n     pub fn crate_prelude(&mut self, data: CratePreludeData) {\n         self.result.prelude = Some(data)\n     }", "previous_filename": "src/librustc_save_analysis/json_dumper.rs"}, {"sha": "ade5e2eca60ba56d2848dfb60a5153368a658b88", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -7,7 +7,7 @@\n #![recursion_limit=\"256\"]\n \n \n-mod json_dumper;\n+mod dumper;\n mod dump_visitor;\n #[macro_use]\n mod span_utils;\n@@ -39,7 +39,7 @@ use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{arg_to_string, ty_to_string};\n use syntax_pos::*;\n \n-use json_dumper::JsonDumper;\n+use dumper::Dumper;\n use dump_visitor::DumpVisitor;\n use span_utils::SpanUtils;\n \n@@ -1075,17 +1075,19 @@ impl<'a> SaveHandler for DumpHandler<'a> {\n         input: &'l Input,\n     ) {\n         let sess = &save_ctxt.tcx.sess;\n-        let file_name = {\n-            let (mut output, file_name) = self.output_file(&save_ctxt);\n-            let mut dumper = JsonDumper::new(&mut output, save_ctxt.config.clone());\n-            let mut visitor = DumpVisitor::new(save_ctxt, &mut dumper);\n+        let (output, file_name) = self.output_file(&save_ctxt);\n+        let mut dumper = Dumper::new(save_ctxt.config.clone());\n+        let mut visitor = DumpVisitor::new(save_ctxt, &mut dumper);\n \n-            visitor.dump_crate_info(cratename, krate);\n-            visitor.dump_compilation_options(input, cratename);\n-            visit::walk_crate(&mut visitor, krate);\n+        visitor.dump_crate_info(cratename, krate);\n+        visitor.dump_compilation_options(input, cratename);\n+        visit::walk_crate(&mut visitor, krate);\n \n-            file_name\n-        };\n+        dumper.to_output(|analysis| {\n+            if let Err(e) = serde_json::to_writer(output, analysis) {\n+                error!(\"Can't serialize save-analysis: {:?}\", e);\n+            }\n+        });\n \n         if sess.opts.debugging_opts.emit_artifact_notifications {\n             sess.parse_sess.span_diagnostic\n@@ -1107,17 +1109,19 @@ impl<'b> SaveHandler for CallbackHandler<'b> {\n         cratename: &str,\n         input: &'l Input,\n     ) {\n-        // We're using the JsonDumper here because it has the format of the\n+        // We're using the Dumper here because it has the format of the\n         // save-analysis results that we will pass to the callback. IOW, we are\n-        // using the JsonDumper to collect the save-analysis results, but not\n+        // using the Dumper to collect the save-analysis results, but not\n         // actually to dump them to a file. This is all a bit convoluted and\n         // there is certainly a simpler design here trying to get out (FIXME).\n-        let mut dumper = JsonDumper::with_callback(self.callback, save_ctxt.config.clone());\n+        let mut dumper = Dumper::new(save_ctxt.config.clone());\n         let mut visitor = DumpVisitor::new(save_ctxt, &mut dumper);\n \n         visitor.dump_crate_info(cratename, krate);\n         visitor.dump_compilation_options(input, cratename);\n         visit::walk_crate(&mut visitor, krate);\n+\n+        dumper.to_output(|a| (self.callback)(a))\n     }\n }\n "}, {"sha": "cfafdd02a6ad9fe962a553a446145012f0e0d0a5", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -453,36 +453,43 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             let definition_ty = self.fcx.infer_opaque_definition_from_instantiation(\n                 def_id, opaque_defn, instantiated_ty, span);\n \n+            let mut skip_add = false;\n+\n             if let ty::Opaque(defin_ty_def_id, _substs) = definition_ty.sty {\n                 if def_id == defin_ty_def_id {\n-                    // Concrete type resolved to the existential type itself.\n-                    // Force a cycle error.\n-                    // FIXME(oli-obk): we could just not insert it into `concrete_existential_types`\n-                    // which simply would make this use not a defining use.\n-                    self.tcx().at(span).type_of(defin_ty_def_id);\n+                    debug!(\"Skipping adding concrete definition for opaque type {:?} {:?}\",\n+                           opaque_defn, defin_ty_def_id);\n+                    skip_add = true;\n                 }\n             }\n \n             if !opaque_defn.substs.has_local_value() {\n-                let new = ty::ResolvedOpaqueTy {\n-                    concrete_type: definition_ty,\n-                    substs: opaque_defn.substs,\n-                };\n-\n-                let old = self.tables\n-                    .concrete_existential_types\n-                    .insert(def_id, new);\n-                if let Some(old) = old {\n-                    if old.concrete_type != definition_ty || old.substs != opaque_defn.substs {\n-                        span_bug!(\n-                            span,\n-                            \"visit_opaque_types tried to write \\\n-                            different types for the same existential type: {:?}, {:?}, {:?}, {:?}\",\n-                            def_id,\n-                            definition_ty,\n-                            opaque_defn,\n-                            old,\n-                        );\n+                // We only want to add an entry into `concrete_existential_types`\n+                // if we actually found a defining usage of this existential type.\n+                // Otherwise, we do nothing - we'll either find a defining usage\n+                // in some other location, or we'll end up emitting an error due\n+                // to the lack of defining usage\n+                if !skip_add {\n+                    let new = ty::ResolvedOpaqueTy {\n+                        concrete_type: definition_ty,\n+                        substs: opaque_defn.substs,\n+                    };\n+\n+                    let old = self.tables\n+                        .concrete_existential_types\n+                        .insert(def_id, new);\n+                    if let Some(old) = old {\n+                        if old.concrete_type != definition_ty || old.substs != opaque_defn.substs {\n+                            span_bug!(\n+                                span,\n+                                \"visit_opaque_types tried to write different types for the same \\\n+                                existential type: {:?}, {:?}, {:?}, {:?}\",\n+                                def_id,\n+                                definition_ty,\n+                                opaque_defn,\n+                                old,\n+                            );\n+                        }\n                     }\n                 }\n             } else {"}, {"sha": "bc854e772e16f31f6eec086c646c43a4e1488107", "filename": "src/libstd/sys/unix/io.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Flibstd%2Fsys%2Funix%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Flibstd%2Fsys%2Funix%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fio.rs?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -29,6 +29,7 @@ impl<'a> IoSlice<'a> {\n     }\n }\n \n+#[repr(transparent)]\n pub struct IoSliceMut<'a> {\n     vec: iovec,\n     _p: PhantomData<&'a mut [u8]>,"}, {"sha": "a5bddad708b193b061333467dcdfc9838f66bde0", "filename": "src/libstd/sys/wasi/io.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Flibstd%2Fsys%2Fwasi%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Flibstd%2Fsys%2Fwasi%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fio.rs?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -29,6 +29,7 @@ impl<'a> IoSlice<'a> {\n     }\n }\n \n+#[repr(transparent)]\n pub struct IoSliceMut<'a> {\n     vec: __wasi_iovec_t,\n     _p: PhantomData<&'a mut [u8]>,"}, {"sha": "f0da2323f4f57c007853ef33c26e8c2587f15436", "filename": "src/libstd/sys/windows/io.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Flibstd%2Fsys%2Fwindows%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Flibstd%2Fsys%2Fwindows%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fio.rs?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -29,6 +29,7 @@ impl<'a> IoSlice<'a> {\n     }\n }\n \n+#[repr(transparent)]\n pub struct IoSliceMut<'a> {\n     vec: c::WSABUF,\n     _p: PhantomData<&'a mut [u8]>,"}, {"sha": "9ce050aae218174de810976cf2cff825bbd86c75", "filename": "src/test/ui/consts/static-cycle-error.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fconsts%2Fstatic-cycle-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fconsts%2Fstatic-cycle-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstatic-cycle-error.rs?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+\n+struct Foo {\n+    foo: Option<&'static Foo>\n+}\n+\n+static FOO: Foo = Foo {\n+    foo: Some(&FOO),\n+};\n+\n+fn main() {}"}, {"sha": "38fcabb5cc170fc360b8de518de23a80b10b5dba", "filename": "src/test/ui/existential_types/existential-types-with-cycle-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.rs?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -1,7 +1,7 @@\n #![feature(existential_type)]\n \n existential type Foo: Fn() -> Foo;\n-//~^ ERROR: cycle detected when processing `Foo`\n+//~^ ERROR: could not find defining uses\n \n fn crash(x: Foo) -> Foo {\n     x"}, {"sha": "98a269d5271a222691209e55992755f9e9990967", "filename": "src/test/ui/existential_types/existential-types-with-cycle-error.stderr", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.stderr?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -1,30 +1,8 @@\n-error[E0391]: cycle detected when processing `Foo`\n+error: could not find defining uses\n   --> $DIR/existential-types-with-cycle-error.rs:3:1\n    |\n LL | existential type Foo: Fn() -> Foo;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...which requires processing `crash`...\n-  --> $DIR/existential-types-with-cycle-error.rs:6:25\n-   |\n-LL |   fn crash(x: Foo) -> Foo {\n-   |  _________________________^\n-LL | |     x\n-LL | | }\n-   | |_^\n-   = note: ...which again requires processing `Foo`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n-  --> $DIR/existential-types-with-cycle-error.rs:1:1\n-   |\n-LL | / #![feature(existential_type)]\n-LL | |\n-LL | | existential type Foo: Fn() -> Foo;\n-LL | |\n-...  |\n-LL | |\n-LL | | }\n-   | |_^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0391`."}, {"sha": "f9e6bdb67d4dec6e1a0e94e6ff8b7e6fcb7c6f02", "filename": "src/test/ui/existential_types/existential-types-with-cycle-error2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.rs?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -5,7 +5,7 @@ pub trait Bar<T> {\n }\n \n existential type Foo: Bar<Foo, Item = Foo>;\n-//~^ ERROR: cycle detected when processing `Foo`\n+//~^ ERROR: could not find defining uses\n \n fn crash(x: Foo) -> Foo {\n     x"}, {"sha": "830305d863119bc8d1e085e8b0fa9b1900c0c328", "filename": "src/test/ui/existential_types/existential-types-with-cycle-error2.stderr", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.stderr?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -1,30 +1,8 @@\n-error[E0391]: cycle detected when processing `Foo`\n+error: could not find defining uses\n   --> $DIR/existential-types-with-cycle-error2.rs:7:1\n    |\n LL | existential type Foo: Bar<Foo, Item = Foo>;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...which requires processing `crash`...\n-  --> $DIR/existential-types-with-cycle-error2.rs:10:25\n-   |\n-LL |   fn crash(x: Foo) -> Foo {\n-   |  _________________________^\n-LL | |     x\n-LL | | }\n-   | |_^\n-   = note: ...which again requires processing `Foo`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n-  --> $DIR/existential-types-with-cycle-error2.rs:1:1\n-   |\n-LL | / #![feature(existential_type)]\n-LL | |\n-LL | | pub trait Bar<T> {\n-LL | |     type Item;\n-...  |\n-LL | |\n-LL | | }\n-   | |_^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0391`."}, {"sha": "646e9a734244e2cd95da86bb9a41a6c4326818ab", "filename": "src/test/ui/existential_types/existential_type_const.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type_const.rs?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -0,0 +1,20 @@\n+// check-pass\n+\n+#![feature(existential_type)]\n+// Currently, the `existential_type` feature implicitly\n+// depends on `impl_trait_in_bindings` in order to work properly.\n+// Specifically, this line requires `impl_trait_in_bindings` to be enabled:\n+// https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src/librustc_typeck/check/mod.rs#L856\n+#![feature(impl_trait_in_bindings)]\n+//~^ WARN the feature `impl_trait_in_bindings` is incomplete and may cause the compiler to crash\n+\n+// Ensures that `const` items can constrain an `existential type`.\n+\n+use std::fmt::Debug;\n+\n+pub existential type Foo: Debug;\n+\n+const _FOO: Foo = 5;\n+\n+fn main() {\n+}"}, {"sha": "049b4f75dd204ff84bc63714a8298fe9f91df7de", "filename": "src/test/ui/existential_types/existential_type_const.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type_const.stderr?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -0,0 +1,6 @@\n+warning: the feature `impl_trait_in_bindings` is incomplete and may cause the compiler to crash\n+  --> $DIR/existential_type_const.rs:8:12\n+   |\n+LL | #![feature(impl_trait_in_bindings)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^\n+"}, {"sha": "6f22eef2849855f21a362bc8d136c6e102be0d31", "filename": "src/test/ui/existential_types/existential_type_fns.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type_fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type_fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type_fns.rs?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -0,0 +1,27 @@\n+// check-pass\n+\n+#![feature(existential_type)]\n+\n+// Regression test for issue #61863\n+\n+pub trait MyTrait {}\n+\n+#[derive(Debug)]\n+pub struct MyStruct {\n+  v: u64\n+}\n+\n+impl MyTrait for MyStruct {}\n+\n+pub fn bla() -> TE {\n+    return MyStruct {v:1}\n+}\n+\n+pub fn bla2() -> TE {\n+    bla()\n+}\n+\n+\n+existential type TE: MyTrait;\n+\n+fn main() {}"}, {"sha": "0f134a528979c41a0ac411bacd35797a4f63ae5f", "filename": "src/test/ui/existential_types/existential_type_tuple.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type_tuple.rs?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -0,0 +1,33 @@\n+// check-pass\n+\n+#![feature(existential_type)]\n+#![allow(dead_code)]\n+\n+pub trait MyTrait {}\n+\n+impl MyTrait for bool {}\n+\n+struct Blah {\n+    my_foo: Foo,\n+    my_u8: u8\n+}\n+\n+impl Blah {\n+    fn new() -> Blah {\n+        Blah {\n+            my_foo: make_foo(),\n+            my_u8: 12\n+        }\n+    }\n+    fn into_inner(self) -> (Foo, u8) {\n+        (self.my_foo, self.my_u8)\n+    }\n+}\n+\n+fn make_foo() -> Foo {\n+    true\n+}\n+\n+existential type Foo: MyTrait;\n+\n+fn main() {}"}, {"sha": "eec8a4be63d9808bebca26c107b73c1c52b91489", "filename": "src/test/ui/existential_types/no_inferrable_concrete_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fexistential_types%2Fno_inferrable_concrete_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fexistential_types%2Fno_inferrable_concrete_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fno_inferrable_concrete_type.rs?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -1,9 +1,9 @@\n-// Issue 52985: Cause cycle error if user code provides no use case that allows an existential type\n-// to be inferred to a concrete type. This results in an infinite cycle during type normalization.\n+// Issue 52985: user code provides no use case that allows an existential type\n+// We now emit a 'could not find defining uses' error\n \n #![feature(existential_type)]\n \n-existential type Foo: Copy; //~ cycle detected\n+existential type Foo: Copy; //~ could not find defining uses\n \n // make compiler happy about using 'Foo'\n fn bar(x: Foo) -> Foo { x }"}, {"sha": "bc9a883c8365c7b120531f3b7f504bddc9d35261", "filename": "src/test/ui/existential_types/no_inferrable_concrete_type.stderr", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fexistential_types%2Fno_inferrable_concrete_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fexistential_types%2Fno_inferrable_concrete_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fno_inferrable_concrete_type.stderr?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -1,27 +1,8 @@\n-error[E0391]: cycle detected when processing `Foo`\n+error: could not find defining uses\n   --> $DIR/no_inferrable_concrete_type.rs:6:1\n    |\n LL | existential type Foo: Copy;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...which requires processing `bar`...\n-  --> $DIR/no_inferrable_concrete_type.rs:9:23\n-   |\n-LL | fn bar(x: Foo) -> Foo { x }\n-   |                       ^^^^^\n-   = note: ...which again requires processing `Foo`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n-  --> $DIR/no_inferrable_concrete_type.rs:4:1\n-   |\n-LL | / #![feature(existential_type)]\n-LL | |\n-LL | | existential type Foo: Copy;\n-LL | |\n-...  |\n-LL | |     let _: Foo = std::mem::transmute(0u8);\n-LL | | }\n-   | |_^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0391`."}, {"sha": "6c2df7e84e07c4dacb17221dc808ba1b6ebff9d8", "filename": "src/test/ui/suggestions/auxiliary/issue-61963-1.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fsuggestions%2Fauxiliary%2Fissue-61963-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fsuggestions%2Fauxiliary%2Fissue-61963-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fauxiliary%2Fissue-61963-1.rs?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -0,0 +1,40 @@\n+// force-host\n+// no-prefer-dynamic\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::{Group, TokenStream, TokenTree};\n+\n+// This macro exists as part of a reproduction of #61963 but without using quote/syn/proc_macro2.\n+\n+#[proc_macro_derive(DomObject)]\n+pub fn expand_token_stream(input: TokenStream) -> TokenStream {\n+    // Construct a dummy span - `#0 bytes(0..0)` - which is present in the input because\n+    // of the specially crafted generated tokens in the `attribute-crate` proc-macro.\n+    let dummy_span = input.clone().into_iter().nth(0).unwrap().span();\n+\n+    // Define what the macro would output if constructed properly from the source using syn/quote.\n+    let output: TokenStream = \"impl Bar for ((), Qux<Qux<Baz> >) { }\n+    impl Bar for ((), Box<Bar>) { }\".parse().unwrap();\n+\n+    let mut tokens: Vec<_> = output.into_iter().collect();\n+    // Adjust token spans to match the original crate (which would use `quote`). Some of the\n+    // generated tokens point to the dummy span.\n+    for token in tokens.iter_mut() {\n+        if let TokenTree::Group(group) = token {\n+            let mut tokens: Vec<_> = group.stream().into_iter().collect();\n+            for token in tokens.iter_mut().skip(2) {\n+                token.set_span(dummy_span);\n+            }\n+\n+            let mut stream = TokenStream::new();\n+            stream.extend(tokens);\n+            *group = Group::new(group.delimiter(), stream);\n+        }\n+    }\n+\n+    let mut output = TokenStream::new();\n+    output.extend(tokens);\n+    output\n+}"}, {"sha": "e86f1610ab0d0459a2651ef3780f966dc4b5c3c8", "filename": "src/test/ui/suggestions/auxiliary/issue-61963.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fsuggestions%2Fauxiliary%2Fissue-61963.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fsuggestions%2Fauxiliary%2Fissue-61963.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fauxiliary%2Fissue-61963.rs?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -0,0 +1,41 @@\n+// force-host\n+// no-prefer-dynamic\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::{Group, Spacing, Punct, TokenTree, TokenStream};\n+\n+// This macro exists as part of a reproduction of #61963 but without using quote/syn/proc_macro2.\n+\n+#[proc_macro_attribute]\n+pub fn dom_struct(_: TokenStream, input: TokenStream) -> TokenStream {\n+    // Construct the expected output tokens - the input but with a `#[derive(DomObject)]` applied.\n+    let attributes: TokenStream =\n+        \"#[derive(DomObject)]\".to_string().parse().unwrap();\n+    let output: TokenStream = attributes.into_iter()\n+        .chain(input.into_iter()).collect();\n+\n+    let mut tokens: Vec<_> = output.into_iter().collect();\n+    // Adjust the spacing of `>` tokens to match what `quote` would produce.\n+    for token in tokens.iter_mut() {\n+        if let TokenTree::Group(group) = token {\n+            let mut tokens: Vec<_> = group.stream().into_iter().collect();\n+            for token in tokens.iter_mut() {\n+                if let TokenTree::Punct(p) = token {\n+                    if p.as_char() == '>' {\n+                        *p = Punct::new('>', Spacing::Alone);\n+                    }\n+                }\n+            }\n+\n+            let mut stream = TokenStream::new();\n+            stream.extend(tokens);\n+            *group = Group::new(group.delimiter(), stream);\n+        }\n+    }\n+\n+    let mut output = TokenStream::new();\n+    output.extend(tokens);\n+    output\n+}"}, {"sha": "c9d738f5a283e375591925ae40f68a8dbdf9e88d", "filename": "src/test/ui/suggestions/issue-61963.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61963.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61963.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61963.rs?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -0,0 +1,24 @@\n+// aux-build:issue-61963.rs\n+// aux-build:issue-61963-1.rs\n+#![deny(bare_trait_objects)]\n+\n+#[macro_use]\n+extern crate issue_61963;\n+#[macro_use]\n+extern crate issue_61963_1;\n+\n+// This test checks that the bare trait object lint does not trigger on macro attributes that\n+// generate code which would trigger the lint.\n+\n+pub struct Baz;\n+pub trait Bar { }\n+pub struct Qux<T>(T);\n+\n+#[dom_struct]\n+pub struct Foo {\n+    qux: Qux<Qux<Baz>>,\n+    bar: Box<Bar>,\n+    //~^ ERROR trait objects without an explicit `dyn` are deprecated [bare_trait_objects]\n+}\n+\n+fn main() {}"}, {"sha": "46943f40066ff5f343ebe29b17c88f13b2dad804", "filename": "src/test/ui/suggestions/issue-61963.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61963.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61963.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61963.stderr?ref=a5e7bb3e2bae3e8d31c10de66e91cdcea42a97df", "patch": "@@ -0,0 +1,14 @@\n+error: trait objects without an explicit `dyn` are deprecated\n+  --> $DIR/issue-61963.rs:20:14\n+   |\n+LL |     bar: Box<Bar>,\n+   |              ^^^ help: use `dyn`: `dyn Bar`\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-61963.rs:3:9\n+   |\n+LL | #![deny(bare_trait_objects)]\n+   |         ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}]}