{"sha": "d1e7f0b4146aaaf3aa54902de9eb2ac44ad01160", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxZTdmMGI0MTQ2YWFhZjNhYTU0OTAyZGU5ZWIyYWM0NGFkMDExNjA=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-11T01:46:49Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-11T01:46:49Z"}, "message": "Redo the scheme for block context chaining and termination, to simplify and support ret better.", "tree": {"sha": "abf363aa278a546ab3065c228cb068c270aec4c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/abf363aa278a546ab3065c228cb068c270aec4c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1e7f0b4146aaaf3aa54902de9eb2ac44ad01160", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1e7f0b4146aaaf3aa54902de9eb2ac44ad01160", "html_url": "https://github.com/rust-lang/rust/commit/d1e7f0b4146aaaf3aa54902de9eb2ac44ad01160", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1e7f0b4146aaaf3aa54902de9eb2ac44ad01160/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a404e542614c0848931544eb0281fd546a62a971", "url": "https://api.github.com/repos/rust-lang/rust/commits/a404e542614c0848931544eb0281fd546a62a971", "html_url": "https://github.com/rust-lang/rust/commit/a404e542614c0848931544eb0281fd546a62a971"}], "stats": {"total": 161, "additions": 91, "deletions": 70}, "files": [{"sha": "4f02455aad5402bfaae547d22a489a8f8ddae4ba", "filename": "src/boot/me/semant.ml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1e7f0b4146aaaf3aa54902de9eb2ac44ad01160/src%2Fboot%2Fme%2Fsemant.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d1e7f0b4146aaaf3aa54902de9eb2ac44ad01160/src%2Fboot%2Fme%2Fsemant.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fsemant.ml?ref=d1e7f0b4146aaaf3aa54902de9eb2ac44ad01160", "patch": "@@ -1286,7 +1286,8 @@ let is_prim_type (t:Ast.ty) : bool =\n     | Ast.TY_uint\n     | Ast.TY_char\n     | Ast.TY_mach _\n-    | Ast.TY_bool -> true\n+    | Ast.TY_bool\n+    | Ast.TY_native _ -> true\n     | _ -> false\n ;;\n "}, {"sha": "d30bb3ba6aa3f7635b2012494d2168ce81130a98", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1e7f0b4146aaaf3aa54902de9eb2ac44ad01160/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1e7f0b4146aaaf3aa54902de9eb2ac44ad01160/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=d1e7f0b4146aaaf3aa54902de9eb2ac44ad01160", "patch": "@@ -679,6 +679,8 @@ native mod llvm = llvm_lib {\n     fn LLVMBuildPtrDiff(BuilderRef B, ValueRef LHS,\n                         ValueRef RHS, sbuf Name) -> ValueRef;\n \n+    /* Selected entries from the downcasts. */\n+    fn LLVMIsATerminatorInst(ValueRef Inst) -> ValueRef;\n \n     /** Writes a module to the specified path. Returns 0 on success. */\n     fn LLVMWriteBitcodeToFile(ModuleRef M, sbuf Path) -> int;"}, {"sha": "d2afa46759951ea79b77f6369b5fe25e27544007", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 87, "deletions": 69, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/d1e7f0b4146aaaf3aa54902de9eb2ac44ad01160/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1e7f0b4146aaaf3aa54902de9eb2ac44ad01160/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=d1e7f0b4146aaaf3aa54902de9eb2ac44ad01160", "patch": "@@ -57,18 +57,24 @@ state type fn_ctxt = rec(ValueRef llfn,\n                          hashmap[ast.def_id, ValueRef] lllocals,\n                          @trans_ctxt tcx);\n \n-type terminator = fn(@fn_ctxt cx, builder build);\n-\n tag cleanup {\n     clean(fn(@block_ctxt cx) -> result);\n }\n \n state type block_ctxt = rec(BasicBlockRef llbb,\n                             builder build,\n-                            terminator term,\n+                            block_parent parent,\n                             mutable vec[cleanup] cleanups,\n                             @fn_ctxt fcx);\n \n+// FIXME: we should be able to use option.t[@block_parent] here but\n+// the infinite-tag check in rustboot gets upset.\n+\n+tag block_parent {\n+    parent_none;\n+    parent_some(@block_ctxt);\n+}\n+\n \n state type result = rec(mutable @block_ctxt bcx,\n                         mutable ValueRef val);\n@@ -399,8 +405,8 @@ fn incr_refcnt(@block_ctxt cx, ValueRef box_ptr) -> result {\n                                             C_int(abi.box_rc_field_refcnt)));\n     auto rc = cx.build.Load(rc_ptr);\n \n-    auto next_cx = new_extension_block_ctxt(cx);\n-    auto rc_adj_cx = new_empty_block_ctxt(cx.fcx);\n+    auto next_cx = new_sub_block_ctxt(cx, \"next\");\n+    auto rc_adj_cx = new_sub_block_ctxt(cx, \"rc++\");\n \n     auto const_test = cx.build.ICmp(lib.llvm.LLVMIntEQ,\n                                     C_int(abi.const_refcount as int), rc);\n@@ -416,32 +422,35 @@ fn incr_refcnt(@block_ctxt cx, ValueRef box_ptr) -> result {\n fn decr_refcnt_and_if_zero(@block_ctxt cx,\n                            ValueRef box_ptr,\n                            fn(@block_ctxt cx) -> result inner,\n+                           str inner_name,\n                            TypeRef t_else, ValueRef v_else) -> result {\n+\n+    auto rc_adj_cx = new_sub_block_ctxt(cx, \"rc--\");\n+    auto inner_cx = new_sub_block_ctxt(cx, inner_name);\n+    auto next_cx = new_sub_block_ctxt(cx, \"next\");\n+\n     auto rc_ptr = cx.build.GEP(box_ptr, vec(C_int(0),\n                                             C_int(abi.box_rc_field_refcnt)));\n     auto rc = cx.build.Load(rc_ptr);\n \n-    auto rc_adj_cx = new_empty_block_ctxt(cx.fcx);\n-    auto next_cx = new_extension_block_ctxt(cx);\n-\n     auto const_test = cx.build.ICmp(lib.llvm.LLVMIntEQ,\n                                     C_int(abi.const_refcount as int), rc);\n     cx.build.CondBr(const_test, next_cx.llbb, rc_adj_cx.llbb);\n \n     rc = rc_adj_cx.build.Sub(rc, C_int(1));\n     rc_adj_cx.build.Store(rc, rc_ptr);\n-\n     auto zero_test = rc_adj_cx.build.ICmp(lib.llvm.LLVMIntEQ, C_int(0), rc);\n+    rc_adj_cx.build.CondBr(zero_test, inner_cx.llbb, next_cx.llbb);\n+\n+    auto inner_res = inner(inner_cx);\n+    inner_res.bcx.build.Br(next_cx.llbb);\n \n-    auto then_cx = new_empty_block_ctxt(cx.fcx);\n-    auto then_res = inner(then_cx);\n-    then_res.bcx.build.Br(next_cx.llbb);\n-    rc_adj_cx.build.CondBr(zero_test, then_res.bcx.llbb, next_cx.llbb);\n     auto phi = next_cx.build.Phi(t_else,\n-                                 vec(v_else, v_else, then_res.val),\n+                                 vec(v_else, v_else, inner_res.val),\n                                  vec(cx.llbb,\n                                      rc_adj_cx.llbb,\n-                                     then_res.bcx.llbb));\n+                                     inner_res.bcx.llbb));\n+\n     ret res(next_cx, phi);\n }\n \n@@ -483,6 +492,7 @@ fn trans_copy_ty(@block_ctxt cx,\n fn trans_drop_str(@block_ctxt cx, ValueRef v) -> result {\n     ret decr_refcnt_and_if_zero(cx, v,\n                                 bind trans_non_gc_free(_, v),\n+                                \"free string\",\n                                 T_int(), C_int(0));\n }\n \n@@ -571,10 +581,10 @@ impure fn trans_binary(@block_ctxt cx, ast.binop op,\n             // Lazy-eval and\n             auto lhs_res = trans_expr(cx, a);\n \n-            auto rhs_cx = new_empty_block_ctxt(cx.fcx);\n+            auto rhs_cx = new_sub_block_ctxt(cx, \"rhs\");\n             auto rhs_res = trans_expr(rhs_cx, b);\n \n-            auto next_cx = new_extension_block_ctxt(cx);\n+            auto next_cx = new_sub_block_ctxt(cx, \"next\");\n             rhs_res.bcx.build.Br(next_cx.llbb);\n \n             lhs_res.bcx.build.CondBr(lhs_res.val,\n@@ -592,10 +602,10 @@ impure fn trans_binary(@block_ctxt cx, ast.binop op,\n             // Lazy-eval or\n             auto lhs_res = trans_expr(cx, a);\n \n-            auto rhs_cx = new_empty_block_ctxt(cx.fcx);\n+            auto rhs_cx = new_sub_block_ctxt(cx, \"rhs\");\n             auto rhs_res = trans_expr(rhs_cx, b);\n \n-            auto next_cx = new_extension_block_ctxt(cx);\n+            auto next_cx = new_sub_block_ctxt(cx, \"next\");\n             rhs_res.bcx.build.Br(next_cx.llbb);\n \n             lhs_res.bcx.build.CondBr(lhs_res.val,\n@@ -717,16 +727,16 @@ impure fn trans_if(@block_ctxt cx, &ast.expr cond,\n \n     auto cond_res = trans_expr(cx, cond);\n \n-    auto then_cx = new_empty_block_ctxt(cx.fcx);\n+    auto then_cx = new_sub_block_ctxt(cx, \"then\");\n     auto then_res = trans_block(then_cx, thn);\n \n-    auto next_cx = new_extension_block_ctxt(cx);\n+    auto next_cx = new_sub_block_ctxt(cx, \"next\");\n     then_res.bcx.build.Br(next_cx.llbb);\n     auto phi;\n \n     alt (els) {\n         case (some[ast.block](?eblk)) {\n-            auto else_cx = new_empty_block_ctxt(cx.fcx);\n+            auto else_cx = new_sub_block_ctxt(cx, \"else\");\n             auto else_res = trans_block(else_cx, eblk);\n             cond_res.bcx.build.CondBr(cond_res.val,\n                                       then_cx.llbb,\n@@ -756,9 +766,9 @@ impure fn trans_if(@block_ctxt cx, &ast.expr cond,\n impure fn trans_while(@block_ctxt cx, &ast.expr cond,\n                       &ast.block body) -> result {\n \n-    auto cond_cx = new_empty_block_ctxt(cx.fcx);\n-    auto body_cx = new_empty_block_ctxt(cx.fcx);\n-    auto next_cx = new_extension_block_ctxt(cx);\n+    auto cond_cx = new_sub_block_ctxt(cx, \"while cond\");\n+    auto body_cx = new_sub_block_ctxt(cx, \"while loop body\");\n+    auto next_cx = new_sub_block_ctxt(cx, \"next\");\n \n     auto body_res = trans_block(body_cx, body);\n     auto cond_res = trans_expr(cond_cx, cond);\n@@ -775,8 +785,8 @@ impure fn trans_while(@block_ctxt cx, &ast.expr cond,\n impure fn trans_do_while(@block_ctxt cx, &ast.block body,\n                          &ast.expr cond) -> result {\n \n-    auto body_cx = new_empty_block_ctxt(cx.fcx);\n-    auto next_cx = new_extension_block_ctxt(cx);\n+    auto body_cx = new_sub_block_ctxt(cx, \"do-while loop body\");\n+    auto next_cx = new_sub_block_ctxt(cx, \"next\");\n \n     auto body_res = trans_block(body_cx, body);\n     auto cond_res = trans_expr(body_res.bcx, cond);\n@@ -867,8 +877,8 @@ impure fn trans_expr(@block_ctxt cx, &ast.expr e) -> result {\n         }\n \n         case (ast.expr_block(?blk, _)) {\n-            auto sub_cx = new_empty_block_ctxt(cx.fcx);\n-            auto next_cx = new_extension_block_ctxt(cx);\n+            auto sub_cx = new_sub_block_ctxt(cx, \"block-expr body\");\n+            auto next_cx = new_sub_block_ctxt(cx, \"next\");\n             auto sub = trans_block(sub_cx, blk);\n \n             cx.build.Br(sub_cx.llbb);\n@@ -958,10 +968,10 @@ impure fn trans_check_expr(@block_ctxt cx, &ast.expr e) -> result {\n     auto V_line = e.span.lo.line as int;\n     auto args = vec(V_expr_str, V_filename, C_int(V_line));\n \n-    auto fail_cx = new_empty_block_ctxt(cx.fcx);\n+    auto fail_cx = new_sub_block_ctxt(cx, \"fail\");\n     auto fail_res = trans_upcall(fail_cx, \"upcall_fail\", args);\n \n-    auto next_cx = new_extension_block_ctxt(cx);\n+    auto next_cx = new_sub_block_ctxt(cx, \"next\");\n     fail_res.bcx.build.Br(next_cx.llbb);\n     cond_res.bcx.build.CondBr(cond_res.val,\n                               next_cx.llbb,\n@@ -977,11 +987,23 @@ impure fn trans_ret(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n             r.bcx.build.Store(r.val, cx.fcx.lloutptr);\n         }\n     }\n-    // FIXME: if we actually ret here, the block structure falls apart;\n-    // need to do something more-clever with terminators and block cleanup.\n-    // Mean time 'ret' means 'copy result to output slot and keep going'.\n \n-    // r.val = r.bcx.build.RetVoid();\n+    // Run all cleanups and back out.\n+    let bool more_cleanups = true;\n+    auto bcx = cx;\n+    while (more_cleanups) {\n+        bcx = trans_block_cleanups(bcx);\n+        alt (bcx.parent) {\n+            case (parent_some(?b)) {\n+                bcx = b;\n+            }\n+            case (parent_none) {\n+                more_cleanups = false;\n+            }\n+        }\n+    }\n+\n+    r.val = r.bcx.build.RetVoid();\n     ret r;\n }\n \n@@ -1024,55 +1046,42 @@ impure fn trans_stmt(@block_ctxt cx, &ast.stmt s) -> result {\n     ret sub;\n }\n \n-fn new_builder(BasicBlockRef llbb) -> builder {\n+fn new_builder(BasicBlockRef llbb, str name) -> builder {\n     let BuilderRef llbuild = llvm.LLVMCreateBuilder();\n     llvm.LLVMPositionBuilderAtEnd(llbuild, llbb);\n     ret builder(llbuild);\n }\n \n // You probably don't want to use this one. See the\n // next three functions instead.\n-fn new_block_ctxt(@fn_ctxt cx, terminator term,\n-                  vec[cleanup] cleanups) -> @block_ctxt {\n+fn new_block_ctxt(@fn_ctxt cx, block_parent parent,\n+                  vec[cleanup] cleanups,\n+                  str name) -> @block_ctxt {\n     let BasicBlockRef llbb =\n-        llvm.LLVMAppendBasicBlock(cx.llfn, _str.buf(\"\"));\n+        llvm.LLVMAppendBasicBlock(cx.llfn,\n+                                  _str.buf(cx.tcx.names.next(name)));\n+\n     ret @rec(llbb=llbb,\n-             build=new_builder(llbb),\n-             term=term,\n+             build=new_builder(llbb, name),\n+             parent=parent,\n              mutable cleanups=cleanups,\n              fcx=cx);\n }\n \n-// Use this when you are making a block_ctxt to replace the\n-// current one, i.e. when chaining together sequences of stmts\n-// or making sub-blocks you will branch back out of and wish to\n-// \"carry on\" in the parent block's context.\n-fn new_extension_block_ctxt(@block_ctxt bcx) -> @block_ctxt {\n-    ret new_block_ctxt(bcx.fcx, bcx.term, bcx.cleanups);\n-}\n-\n // Use this when you're at the top block of a function or the like.\n fn new_top_block_ctxt(@fn_ctxt fcx) -> @block_ctxt {\n-    fn terminate_ret_void(@fn_ctxt cx, builder build) {\n-        build.RetVoid();\n-    }\n-    auto term = terminate_ret_void;\n     let vec[cleanup] cleanups = vec();\n-    ret new_block_ctxt(fcx, term, cleanups);\n+    ret new_block_ctxt(fcx, parent_none, cleanups, \"function top level\");\n \n }\n \n-// Use this when you are making a block_ctxt that starts with a fresh\n-// terminator and empty cleanups (no locals, no implicit return when\n-// falling off the end).\n-fn new_empty_block_ctxt(@fn_ctxt fcx) -> @block_ctxt {\n-    fn terminate_no_op(@fn_ctxt cx, builder build) {\n-    }\n-    auto term = terminate_no_op;\n+// Use this when you're making a block-within-a-block.\n+fn new_sub_block_ctxt(@block_ctxt bcx, str n) -> @block_ctxt {\n     let vec[cleanup] cleanups = vec();\n-    ret new_block_ctxt(fcx, term, cleanups);\n+    ret new_block_ctxt(bcx.fcx, parent_some(bcx), cleanups, n);\n }\n \n+\n fn trans_block_cleanups(@block_ctxt cx) -> @block_ctxt {\n     auto bcx = cx;\n     for (cleanup c in cx.cleanups) {\n@@ -1117,14 +1126,15 @@ impure fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n         auto val = bcx.build.Alloca(ty);\n         cx.fcx.lllocals.insert(local.id, val);\n     }\n+    auto r = res(bcx, C_nil());\n \n     for (@ast.stmt s in b.node.stmts) {\n-        bcx = trans_stmt(bcx, *s).bcx;\n+        r = trans_stmt(bcx, *s);\n+        bcx = r.bcx;\n     }\n \n     bcx = trans_block_cleanups(bcx);\n-    bcx.term(bcx.fcx, bcx.build);\n-    ret res(bcx, C_nil());\n+    ret res(bcx, r.val);\n }\n \n fn new_fn_ctxt(@trans_ctxt cx,\n@@ -1155,11 +1165,19 @@ fn new_fn_ctxt(@trans_ctxt cx,\n              tcx=cx);\n }\n \n+fn is_terminated(@block_ctxt cx) -> bool {\n+    auto inst = llvm.LLVMGetLastInstruction(cx.llbb);\n+    ret llvm.LLVMIsATerminatorInst(inst) as int != 0;\n+}\n+\n impure fn trans_fn(@trans_ctxt cx, &ast._fn f, ast.def_id fid) {\n \n     auto fcx = new_fn_ctxt(cx, cx.path, f, fid);\n-\n-    trans_block(new_top_block_ctxt(fcx), f.body);\n+    auto bcx = new_top_block_ctxt(fcx);\n+    auto res = trans_block(bcx, f.body);\n+    if (!is_terminated(res.bcx)) {\n+        res.bcx.build.RetVoid();\n+    }\n }\n \n impure fn trans_item(@trans_ctxt cx, &ast.item item) {\n@@ -1240,7 +1258,7 @@ fn trans_exit_task_glue(@trans_ctxt cx) {\n \n     auto bcx = new_top_block_ctxt(fcx);\n     trans_upcall(bcx, \"upcall_exit\", V_args);\n-    bcx.term(fcx, bcx.build);\n+    bcx.build.RetVoid();\n }\n \n fn crate_constant(@trans_ctxt cx) -> ValueRef {\n@@ -1312,7 +1330,7 @@ fn trans_main_fn(@trans_ctxt cx, ValueRef llcrate) {\n \n     let BasicBlockRef llbb =\n         llvm.LLVMAppendBasicBlock(llmain, _str.buf(\"\"));\n-    auto b = new_builder(llbb);\n+    auto b = new_builder(llbb, \"\");\n \n     auto start_args = vec(p2i(llrust_main), p2i(llcrate), llargc, llargv);\n "}]}