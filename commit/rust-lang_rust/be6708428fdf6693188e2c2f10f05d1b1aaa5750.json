{"sha": "be6708428fdf6693188e2c2f10f05d1b1aaa5750", "node_id": "C_kwDOAAsO6NoAKGJlNjcwODQyOGZkZjY2OTMxODhlMmMyZjEwZjA1ZDFiMWFhYTU3NTA", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-05-28T10:43:51Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-11-26T19:35:32Z"}, "message": "Rewrite LLVM's archive writer in Rust\n\nThis allows it to be used by other codegen backends", "tree": {"sha": "d4a02ed59895692fe4ade067fceb1c92575e3bb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4a02ed59895692fe4ade067fceb1c92575e3bb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be6708428fdf6693188e2c2f10f05d1b1aaa5750", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be6708428fdf6693188e2c2f10f05d1b1aaa5750", "html_url": "https://github.com/rust-lang/rust/commit/be6708428fdf6693188e2c2f10f05d1b1aaa5750", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be6708428fdf6693188e2c2f10f05d1b1aaa5750/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3a1c023c0784ffbcf4dd57cf4618d208bccae69", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3a1c023c0784ffbcf4dd57cf4618d208bccae69", "html_url": "https://github.com/rust-lang/rust/commit/c3a1c023c0784ffbcf4dd57cf4618d208bccae69"}], "stats": {"total": 972, "additions": 445, "deletions": 527}, "files": [{"sha": "8157e78fdf681655b51250efaf8d3855cf4d0c6c", "filename": "Cargo.lock", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/be6708428fdf6693188e2c2f10f05d1b1aaa5750/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/be6708428fdf6693188e2c2f10f05d1b1aaa5750/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=be6708428fdf6693188e2c2f10f05d1b1aaa5750", "patch": "@@ -92,6 +92,15 @@ version = \"1.0.65\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"98161a4e3e2184da77bb14f02184cdd111e83bbbcc9979dfee3c44b9a85f5602\"\n \n+[[package]]\n+name = \"ar_archive_writer\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"276881980556fdadeb88aa1ffc667e4d2e8fe72531dfabcb7a82bb3c9ea9ba31\"\n+dependencies = [\n+ \"object\",\n+]\n+\n [[package]]\n name = \"array_tool\"\n version = \"1.0.3\"\n@@ -3413,6 +3422,7 @@ dependencies = [\n name = \"rustc_codegen_ssa\"\n version = \"0.0.0\"\n dependencies = [\n+ \"ar_archive_writer\",\n  \"bitflags\",\n  \"cc\",\n  \"itertools\","}, {"sha": "fa4b725a0ee50ef723ce5292865e54de7b0bfca4", "filename": "LICENSES/LLVM-exception.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/be6708428fdf6693188e2c2f10f05d1b1aaa5750/LICENSES%2FLLVM-exception.txt", "raw_url": "https://github.com/rust-lang/rust/raw/be6708428fdf6693188e2c2f10f05d1b1aaa5750/LICENSES%2FLLVM-exception.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSES%2FLLVM-exception.txt?ref=be6708428fdf6693188e2c2f10f05d1b1aaa5750", "patch": "@@ -0,0 +1,15 @@\n+---- LLVM Exceptions to the Apache 2.0 License ----\n+\n+   As an exception, if, as a result of your compiling your source code, portions\n+   of this Software are embedded into an Object form of such source code, you\n+   may redistribute such embedded portions in such Object form without complying\n+   with the conditions of Sections 4(a), 4(b) and 4(d) of the License.\n+\n+   In addition, if you combine or link compiled forms of this Software with\n+   software that is licensed under the GPLv2 (\"Combined Software\") and if a\n+   court of competent jurisdiction determines that the patent provision (Section\n+   3), the indemnity provision (Section 9) or other Section of the License\n+   conflicts with the conditions of the GPLv2, you may retroactively and\n+   prospectively choose to deem waived or otherwise exclude such Section(s) of\n+   the License, but only in their entirety and only with respect to the Combined\n+   Software."}, {"sha": "3b406036c356e9e3023964f049184a2d1f0121f5", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=be6708428fdf6693188e2c2f10f05d1b1aaa5750", "patch": "@@ -19,11 +19,6 @@ version = \"1.0.60\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c794e162a5eff65c72ef524dfe393eb923c354e350bb78b9c7383df13f3bc142\"\n \n-[[package]]\n-name = \"ar\"\n-version = \"0.8.0\"\n-source = \"git+https://github.com/bjorn3/rust-ar.git?branch=do_not_remove_cg_clif_ranlib#de9ab0e56bf3a208381d342aa5b60f9ff2891648\"\n-\n [[package]]\n name = \"arrayvec\"\n version = \"0.7.2\"\n@@ -324,7 +319,6 @@ dependencies = [\n name = \"rustc_codegen_cranelift\"\n version = \"0.1.0\"\n dependencies = [\n- \"ar\",\n  \"cranelift-codegen\",\n  \"cranelift-frontend\",\n  \"cranelift-jit\","}, {"sha": "0fdd5de118ccb10cb4db0776c5ca9c69b19cc07f", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=be6708428fdf6693188e2c2f10f05d1b1aaa5750", "patch": "@@ -18,7 +18,6 @@ target-lexicon = \"0.12.0\"\n gimli = { version = \"0.26.0\", default-features = false, features = [\"write\"]}\n object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n \n-ar = { git = \"https://github.com/bjorn3/rust-ar.git\", branch = \"do_not_remove_cg_clif_ranlib\" }\n indexmap = \"1.9.1\"\n libloading = { version = \"0.7.3\", optional = true }\n once_cell = \"1.10.0\""}, {"sha": "5a29bc18def549cd035bb0a1144b5cab54addef4", "filename": "compiler/rustc_codegen_cranelift/src/archive.rs", "status": "modified", "additions": 5, "deletions": 219, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs?ref=be6708428fdf6693188e2c2f10f05d1b1aaa5750", "patch": "@@ -1,35 +1,15 @@\n-//! Creation of ar archives like for the lib and staticlib crate type\n-\n-use std::collections::BTreeMap;\n-use std::fs::File;\n-use std::io::{self, Read, Seek};\n use std::path::{Path, PathBuf};\n \n-use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n+use rustc_codegen_ssa::back::archive::{\n+    get_native_object_symbols, ArArchiveBuilder, ArchiveBuilder, ArchiveBuilderBuilder,\n+};\n use rustc_session::Session;\n \n-use object::read::archive::ArchiveFile;\n-use object::{Object, ObjectSymbol, ReadCache};\n-\n-#[derive(Debug)]\n-enum ArchiveEntry {\n-    FromArchive { archive_index: usize, file_range: (u64, u64) },\n-    File(PathBuf),\n-}\n-\n pub(crate) struct ArArchiveBuilderBuilder;\n \n impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n     fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a> {\n-        Box::new(ArArchiveBuilder {\n-            sess,\n-            use_gnu_style_archive: sess.target.archive_format == \"gnu\",\n-            // FIXME fix builtin ranlib on macOS\n-            no_builtin_ranlib: sess.target.is_like_osx,\n-\n-            src_archives: vec![],\n-            entries: vec![],\n-        })\n+        Box::new(ArArchiveBuilder::new(sess, get_native_object_symbols))\n     }\n \n     fn create_dll_import_lib(\n@@ -40,200 +20,6 @@ impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n         _tmpdir: &Path,\n         _is_direct_dependency: bool,\n     ) -> PathBuf {\n-        bug!(\"creating dll imports is not supported\");\n-    }\n-}\n-\n-pub(crate) struct ArArchiveBuilder<'a> {\n-    sess: &'a Session,\n-    use_gnu_style_archive: bool,\n-    no_builtin_ranlib: bool,\n-\n-    src_archives: Vec<File>,\n-    // Don't use `HashMap` here, as the order is important. `rust.metadata.bin` must always be at\n-    // the end of an archive for linkers to not get confused.\n-    entries: Vec<(Vec<u8>, ArchiveEntry)>,\n-}\n-\n-impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n-    fn add_file(&mut self, file: &Path) {\n-        self.entries.push((\n-            file.file_name().unwrap().to_str().unwrap().to_string().into_bytes(),\n-            ArchiveEntry::File(file.to_owned()),\n-        ));\n-    }\n-\n-    fn add_archive(\n-        &mut self,\n-        archive_path: &Path,\n-        mut skip: Box<dyn FnMut(&str) -> bool + 'static>,\n-    ) -> std::io::Result<()> {\n-        let read_cache = ReadCache::new(std::fs::File::open(&archive_path)?);\n-        let archive = ArchiveFile::parse(&read_cache).unwrap();\n-        let archive_index = self.src_archives.len();\n-\n-        for entry in archive.members() {\n-            let entry = entry.map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n-            let file_name = String::from_utf8(entry.name().to_vec())\n-                .map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n-            if !skip(&file_name) {\n-                self.entries.push((\n-                    file_name.into_bytes(),\n-                    ArchiveEntry::FromArchive { archive_index, file_range: entry.file_range() },\n-                ));\n-            }\n-        }\n-\n-        self.src_archives.push(read_cache.into_inner());\n-        Ok(())\n-    }\n-\n-    fn build(mut self: Box<Self>, output: &Path) -> bool {\n-        enum BuilderKind {\n-            Bsd(ar::Builder<File>),\n-            Gnu(ar::GnuBuilder<File>),\n-        }\n-\n-        let sess = self.sess;\n-\n-        let mut symbol_table = BTreeMap::new();\n-\n-        let mut entries = Vec::new();\n-\n-        for (mut entry_name, entry) in self.entries {\n-            // FIXME only read the symbol table of the object files to avoid having to keep all\n-            // object files in memory at once, or read them twice.\n-            let data = match entry {\n-                ArchiveEntry::FromArchive { archive_index, file_range } => {\n-                    // FIXME read symbols from symtab\n-                    let src_read_cache = &mut self.src_archives[archive_index];\n-\n-                    src_read_cache.seek(io::SeekFrom::Start(file_range.0)).unwrap();\n-                    let mut data = std::vec::from_elem(0, usize::try_from(file_range.1).unwrap());\n-                    src_read_cache.read_exact(&mut data).unwrap();\n-\n-                    data\n-                }\n-                ArchiveEntry::File(file) => std::fs::read(file).unwrap_or_else(|err| {\n-                    sess.fatal(&format!(\n-                        \"error while reading object file during archive building: {}\",\n-                        err\n-                    ));\n-                }),\n-            };\n-\n-            if !self.no_builtin_ranlib {\n-                if symbol_table.contains_key(&entry_name) {\n-                    // The ar crate can't handle creating a symbol table in case of multiple archive\n-                    // members with the same name. Work around this by prepending a number until we\n-                    // get a unique name.\n-                    for i in 1.. {\n-                        let new_name = format!(\"{}_\", i)\n-                            .into_bytes()\n-                            .into_iter()\n-                            .chain(entry_name.iter().copied())\n-                            .collect::<Vec<_>>();\n-                        if !symbol_table.contains_key(&new_name) {\n-                            entry_name = new_name;\n-                            break;\n-                        }\n-                    }\n-                }\n-\n-                match object::File::parse(&*data) {\n-                    Ok(object) => {\n-                        symbol_table.insert(\n-                            entry_name.to_vec(),\n-                            object\n-                                .symbols()\n-                                .filter_map(|symbol| {\n-                                    if symbol.is_undefined() || symbol.is_local() {\n-                                        None\n-                                    } else {\n-                                        symbol.name().map(|name| name.as_bytes().to_vec()).ok()\n-                                    }\n-                                })\n-                                .collect::<Vec<_>>(),\n-                        );\n-                    }\n-                    Err(err) => {\n-                        let err = err.to_string();\n-                        if err == \"Unknown file magic\" {\n-                            // Not an object file; skip it.\n-                        } else if object::read::archive::ArchiveFile::parse(&*data).is_ok() {\n-                            // Nested archive file; skip it.\n-                        } else {\n-                            sess.fatal(&format!(\n-                                \"error parsing `{}` during archive creation: {}\",\n-                                String::from_utf8_lossy(&entry_name),\n-                                err\n-                            ));\n-                        }\n-                    }\n-                }\n-            }\n-\n-            entries.push((entry_name, data));\n-        }\n-\n-        let mut builder = if self.use_gnu_style_archive {\n-            BuilderKind::Gnu(\n-                ar::GnuBuilder::new(\n-                    File::create(output).unwrap_or_else(|err| {\n-                        sess.fatal(&format!(\n-                            \"error opening destination during archive building: {}\",\n-                            err\n-                        ));\n-                    }),\n-                    entries.iter().map(|(name, _)| name.clone()).collect(),\n-                    ar::GnuSymbolTableFormat::Size32,\n-                    symbol_table,\n-                )\n-                .unwrap(),\n-            )\n-        } else {\n-            BuilderKind::Bsd(\n-                ar::Builder::new(\n-                    File::create(output).unwrap_or_else(|err| {\n-                        sess.fatal(&format!(\n-                            \"error opening destination during archive building: {}\",\n-                            err\n-                        ));\n-                    }),\n-                    symbol_table,\n-                )\n-                .unwrap(),\n-            )\n-        };\n-\n-        let any_members = !entries.is_empty();\n-\n-        // Add all files\n-        for (entry_name, data) in entries.into_iter() {\n-            let header = ar::Header::new(entry_name, data.len() as u64);\n-            match builder {\n-                BuilderKind::Bsd(ref mut builder) => builder.append(&header, &mut &*data).unwrap(),\n-                BuilderKind::Gnu(ref mut builder) => builder.append(&header, &mut &*data).unwrap(),\n-            }\n-        }\n-\n-        // Finalize archive\n-        std::mem::drop(builder);\n-\n-        if self.no_builtin_ranlib {\n-            let ranlib = crate::toolchain::get_toolchain_binary(self.sess, \"ranlib\");\n-\n-            // Run ranlib to be able to link the archive\n-            let status = std::process::Command::new(ranlib)\n-                .arg(output)\n-                .status()\n-                .expect(\"Couldn't run ranlib\");\n-\n-            if !status.success() {\n-                self.sess.fatal(&format!(\"Ranlib exited with code {:?}\", status.code()));\n-            }\n-        }\n-\n-        any_members\n+        unimplemented!(\"creating dll imports is not yet supported\");\n     }\n }"}, {"sha": "1cb219e12e04d5a88bea03e20028a78c4eab377c", "filename": "compiler/rustc_codegen_gcc/Cargo.lock", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_gcc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_gcc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FCargo.lock?ref=be6708428fdf6693188e2c2f10f05d1b1aaa5750", "patch": "@@ -11,12 +11,6 @@ dependencies = [\n  \"memchr\",\n ]\n \n-[[package]]\n-name = \"ar\"\n-version = \"0.8.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"450575f58f7bee32816abbff470cbc47797397c2a81e0eaced4b98436daf52e1\"\n-\n [[package]]\n name = \"bitflags\"\n version = \"1.3.2\"\n@@ -212,10 +206,8 @@ dependencies = [\n name = \"rustc_codegen_gcc\"\n version = \"0.1.0\"\n dependencies = [\n- \"ar\",\n  \"gccjit\",\n  \"lang_tester\",\n- \"target-lexicon\",\n  \"tempfile\",\n ]\n \n@@ -228,12 +220,6 @@ dependencies = [\n  \"winapi-util\",\n ]\n \n-[[package]]\n-name = \"target-lexicon\"\n-version = \"0.10.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ab0e7238dcc7b40a7be719a25365910f6807bd864f4cce6b2e6b873658e2b19d\"\n-\n [[package]]\n name = \"tempfile\"\n version = \"3.2.0\""}, {"sha": "1f3da2f799b781991000e123eceb6d9e3547db23", "filename": "compiler/rustc_codegen_gcc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_gcc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_gcc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FCargo.toml?ref=be6708428fdf6693188e2c2f10f05d1b1aaa5750", "patch": "@@ -27,10 +27,6 @@ gccjit = { git = \"https://github.com/antoyo/gccjit.rs\" }\n # Local copy.\n #gccjit = { path = \"../gccjit.rs\" }\n \n-target-lexicon = \"0.10.0\"\n-\n-ar = \"0.8.0\"\n-\n [dev-dependencies]\n lang_tester = \"0.3.9\"\n tempfile = \"3.1.0\""}, {"sha": "11fa074f5ac79e81a9902d8b93c5ce9839727423", "filename": "compiler/rustc_codegen_gcc/src/archive.rs", "status": "modified", "additions": 6, "deletions": 171, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs?ref=be6708428fdf6693188e2c2f10f05d1b1aaa5750", "patch": "@@ -1,44 +1,17 @@\n-use std::fs::File;\n use std::path::{Path, PathBuf};\n \n-use crate::errors::RanlibFailure;\n-\n-use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n+use rustc_codegen_ssa::back::archive::{\n+    get_native_object_symbols, ArArchiveBuilder, ArchiveBuilder, ArchiveBuilderBuilder,\n+};\n use rustc_session::Session;\n \n use rustc_session::cstore::DllImport;\n \n-struct ArchiveConfig<'a> {\n-    sess: &'a Session,\n-    use_native_ar: bool,\n-    use_gnu_style_archive: bool,\n-}\n-\n-#[derive(Debug)]\n-enum ArchiveEntry {\n-    FromArchive {\n-        archive_index: usize,\n-        entry_index: usize,\n-    },\n-    File(PathBuf),\n-}\n-\n-pub struct ArArchiveBuilderBuilder;\n+pub(crate) struct ArArchiveBuilderBuilder;\n \n impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n     fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a> {\n-        let config = ArchiveConfig {\n-            sess,\n-            use_native_ar: false,\n-            // FIXME test for linux and System V derivatives instead\n-            use_gnu_style_archive: sess.target.options.archive_format == \"gnu\",\n-        };\n-\n-        Box::new(ArArchiveBuilder {\n-            config,\n-            src_archives: vec![],\n-            entries: vec![],\n-        })\n+        Box::new(ArArchiveBuilder::new(sess, get_native_object_symbols))\n     }\n \n     fn create_dll_import_lib(\n@@ -49,144 +22,6 @@ impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n         _tmpdir: &Path,\n         _is_direct_dependency: bool,\n     ) -> PathBuf {\n-        unimplemented!();\n-    }\n-}\n-\n-pub struct ArArchiveBuilder<'a> {\n-    config: ArchiveConfig<'a>,\n-    src_archives: Vec<(PathBuf, ar::Archive<File>)>,\n-    // Don't use `HashMap` here, as the order is important. `rust.metadata.bin` must always be at\n-    // the end of an archive for linkers to not get confused.\n-    entries: Vec<(String, ArchiveEntry)>,\n-}\n-\n-impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n-    fn add_file(&mut self, file: &Path) {\n-        self.entries.push((\n-            file.file_name().unwrap().to_str().unwrap().to_string(),\n-            ArchiveEntry::File(file.to_owned()),\n-        ));\n-    }\n-\n-    fn add_archive(\n-        &mut self,\n-        archive_path: &Path,\n-        mut skip: Box<dyn FnMut(&str) -> bool + 'static>,\n-    ) -> std::io::Result<()> {\n-        let mut archive = ar::Archive::new(std::fs::File::open(&archive_path)?);\n-        let archive_index = self.src_archives.len();\n-\n-        let mut i = 0;\n-        while let Some(entry) = archive.next_entry() {\n-            let entry = entry?;\n-            let file_name = String::from_utf8(entry.header().identifier().to_vec())\n-                .map_err(|err| std::io::Error::new(std::io::ErrorKind::InvalidData, err))?;\n-            if !skip(&file_name) {\n-                self.entries\n-                    .push((file_name, ArchiveEntry::FromArchive { archive_index, entry_index: i }));\n-            }\n-            i += 1;\n-        }\n-\n-        self.src_archives.push((archive_path.to_owned(), archive));\n-        Ok(())\n-    }\n-\n-    fn build(mut self: Box<Self>, output: &Path) -> bool {\n-        use std::process::Command;\n-\n-        fn add_file_using_ar(archive: &Path, file: &Path) {\n-            Command::new(\"ar\")\n-                .arg(\"r\") // add or replace file\n-                .arg(\"-c\") // silence created file message\n-                .arg(archive)\n-                .arg(&file)\n-                .status()\n-                .unwrap();\n-        }\n-\n-        enum BuilderKind<'a> {\n-            Bsd(ar::Builder<File>),\n-            Gnu(ar::GnuBuilder<File>),\n-            NativeAr(&'a Path),\n-        }\n-\n-        let mut builder = if self.config.use_native_ar {\n-            BuilderKind::NativeAr(output)\n-        } else if self.config.use_gnu_style_archive {\n-            BuilderKind::Gnu(ar::GnuBuilder::new(\n-                File::create(output).unwrap(),\n-                self.entries\n-                    .iter()\n-                    .map(|(name, _)| name.as_bytes().to_vec())\n-                    .collect(),\n-            ))\n-        } else {\n-            BuilderKind::Bsd(ar::Builder::new(File::create(output).unwrap()))\n-        };\n-\n-        let any_members = !self.entries.is_empty();\n-\n-        // Add all files\n-        for (entry_name, entry) in self.entries.into_iter() {\n-            match entry {\n-                ArchiveEntry::FromArchive {\n-                    archive_index,\n-                    entry_index,\n-                } => {\n-                    let (ref src_archive_path, ref mut src_archive) =\n-                        self.src_archives[archive_index];\n-                    let entry = src_archive.jump_to_entry(entry_index).unwrap();\n-                    let header = entry.header().clone();\n-\n-                    match builder {\n-                        BuilderKind::Bsd(ref mut builder) => {\n-                            builder.append(&header, entry).unwrap()\n-                        }\n-                        BuilderKind::Gnu(ref mut builder) => {\n-                            builder.append(&header, entry).unwrap()\n-                        }\n-                        BuilderKind::NativeAr(archive_file) => {\n-                            Command::new(\"ar\")\n-                                .arg(\"x\")\n-                                .arg(src_archive_path)\n-                                .arg(&entry_name)\n-                                .status()\n-                                .unwrap();\n-                            add_file_using_ar(archive_file, Path::new(&entry_name));\n-                            std::fs::remove_file(entry_name).unwrap();\n-                        }\n-                    }\n-                }\n-                ArchiveEntry::File(file) =>\n-                    match builder {\n-                        BuilderKind::Bsd(ref mut builder) => {\n-                            builder\n-                                .append_file(entry_name.as_bytes(), &mut File::open(file).expect(\"file for bsd builder\"))\n-                                .unwrap()\n-                        },\n-                        BuilderKind::Gnu(ref mut builder) => {\n-                            builder\n-                                .append_file(entry_name.as_bytes(), &mut File::open(&file).expect(&format!(\"file {:?} for gnu builder\", file)))\n-                                .unwrap()\n-                        },\n-                        BuilderKind::NativeAr(archive_file) => add_file_using_ar(archive_file, &file),\n-                    },\n-            }\n-        }\n-\n-        // Finalize archive\n-        std::mem::drop(builder);\n-\n-        // Run ranlib to be able to link the archive\n-        let status =\n-            std::process::Command::new(\"ranlib\").arg(output).status().expect(\"Couldn't run ranlib\");\n-\n-        if !status.success() {\n-            self.config.sess.emit_fatal(RanlibFailure::new(status.code()));\n-        }\n-\n-        any_members\n+        unimplemented!(\"creating dll imports is not yet supported\");\n     }\n }"}, {"sha": "89fed7be1315614e91331d4b2c05fb58ff320989", "filename": "compiler/rustc_codegen_gcc/src/errors.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs?ref=be6708428fdf6693188e2c2f10f05d1b1aaa5750", "patch": "@@ -16,18 +16,6 @@ impl IntoDiagnosticArg for ExitCode {\n     }\n }\n \n-#[derive(Diagnostic)]\n-#[diag(codegen_gcc_ranlib_failure)]\n-pub(crate) struct RanlibFailure {\n-    exit_code: ExitCode,\n-}\n-\n-impl RanlibFailure {\n-    pub fn new(exit_code: Option<i32>) -> Self {\n-        RanlibFailure { exit_code: ExitCode(exit_code) }\n-    }\n-}\n-\n #[derive(Diagnostic)]\n #[diag(codegen_gcc_invalid_monomorphization_basic_integer, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationBasicInteger<'a> {\n@@ -227,7 +215,7 @@ pub(crate) struct InvalidMonomorphizationUnsupportedOperation<'a> {\n #[diag(codegen_gcc_linkage_const_or_mut_type)]\n pub(crate) struct LinkageConstOrMutType {\n     #[primary_span]\n-    pub span: Span\n+    pub span: Span,\n }\n \n #[derive(Diagnostic)]\n@@ -238,5 +226,5 @@ pub(crate) struct LTONotSupported;\n #[diag(codegen_gcc_unwinding_inline_asm)]\n pub(crate) struct UnwindingInlineAsm {\n     #[primary_span]\n-    pub span: Span\n+    pub span: Span,\n }"}, {"sha": "93d6234dc884550875cf4aef0b3ce89dc2250f5d", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=be6708428fdf6693188e2c2f10f05d1b1aaa5750", "patch": "@@ -11,7 +11,7 @@ bitflags = \"1.0\"\n cstr = \"0.2\"\n libc = \"0.2\"\n measureme = \"10.0.0\"\n-object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n+object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read\"] }\n tracing = \"0.1\"\n rustc_middle = { path = \"../rustc_middle\" }\n rustc-demangle = \"0.1.21\""}, {"sha": "dba352734855fb699bf3d40bd3f4e93b6e937600", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 61, "deletions": 62, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=be6708428fdf6693188e2c2f10f05d1b1aaa5750", "patch": "@@ -1,31 +1,30 @@\n //! A helper class for dealing with static archives\n \n use std::env;\n-use std::ffi::{CStr, CString, OsString};\n-use std::fs;\n-use std::io::{self, Write};\n+use std::ffi::{c_char, c_void, CStr, CString, OsString};\n+use std::io;\n use std::mem;\n use std::path::{Path, PathBuf};\n use std::ptr;\n use std::str;\n \n-use object::read::macho::FatArch;\n-\n use crate::common;\n use crate::errors::{\n-    ArchiveBuildFailure, DlltoolFailImportLibrary, ErrorCallingDllTool, ErrorCreatingImportLibrary,\n-    ErrorWritingDEFFile, UnknownArchiveKind,\n+    DlltoolFailImportLibrary, ErrorCallingDllTool, ErrorCreatingImportLibrary, ErrorWritingDEFFile,\n };\n use crate::llvm::archive_ro::{ArchiveRO, Child};\n use crate::llvm::{self, ArchiveKind, LLVMMachineType, LLVMRustCOFFShortExport};\n-use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n-use rustc_data_structures::memmap::Mmap;\n+use rustc_codegen_ssa::back::archive::{\n+    get_native_object_symbols, try_extract_macho_fat_archive, ArArchiveBuilder,\n+    ArchiveBuildFailure, ArchiveBuilder, ArchiveBuilderBuilder, UnknownArchiveKind,\n+};\n+\n use rustc_session::cstore::DllImport;\n use rustc_session::Session;\n \n /// Helper for adding many files to an archive.\n #[must_use = \"must call build() to finish building the archive\"]\n-pub struct LlvmArchiveBuilder<'a> {\n+pub(crate) struct LlvmArchiveBuilder<'a> {\n     sess: &'a Session,\n     additions: Vec<Addition>,\n }\n@@ -61,57 +60,6 @@ fn llvm_machine_type(cpu: &str) -> LLVMMachineType {\n     }\n }\n \n-fn try_filter_fat_archs(\n-    archs: object::read::Result<&[impl FatArch]>,\n-    target_arch: object::Architecture,\n-    archive_path: &Path,\n-    archive_map_data: &[u8],\n-) -> io::Result<Option<PathBuf>> {\n-    let archs = archs.map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;\n-\n-    let desired = match archs.iter().filter(|a| a.architecture() == target_arch).next() {\n-        Some(a) => a,\n-        None => return Ok(None),\n-    };\n-\n-    let (mut new_f, extracted_path) = tempfile::Builder::new()\n-        .suffix(archive_path.file_name().unwrap())\n-        .tempfile()?\n-        .keep()\n-        .unwrap();\n-\n-    new_f.write_all(\n-        desired.data(archive_map_data).map_err(|e| io::Error::new(io::ErrorKind::Other, e))?,\n-    )?;\n-\n-    Ok(Some(extracted_path))\n-}\n-\n-fn try_extract_macho_fat_archive(\n-    sess: &Session,\n-    archive_path: &Path,\n-) -> io::Result<Option<PathBuf>> {\n-    let archive_map = unsafe { Mmap::map(fs::File::open(&archive_path)?)? };\n-    let target_arch = match sess.target.arch.as_ref() {\n-        \"aarch64\" => object::Architecture::Aarch64,\n-        \"x86_64\" => object::Architecture::X86_64,\n-        _ => return Ok(None),\n-    };\n-\n-    match object::macho::FatHeader::parse(&*archive_map) {\n-        Ok(h) if h.magic.get(object::endian::BigEndian) == object::macho::FAT_MAGIC => {\n-            let archs = object::macho::FatHeader::parse_arch32(&*archive_map);\n-            try_filter_fat_archs(archs, target_arch, archive_path, &*archive_map)\n-        }\n-        Ok(h) if h.magic.get(object::endian::BigEndian) == object::macho::FAT_MAGIC_64 => {\n-            let archs = object::macho::FatHeader::parse_arch64(&*archive_map);\n-            try_filter_fat_archs(archs, target_arch, archive_path, &*archive_map)\n-        }\n-        // Not a FatHeader at all, just return None.\n-        _ => Ok(None),\n-    }\n-}\n-\n impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n     fn add_archive(\n         &mut self,\n@@ -160,7 +108,11 @@ pub struct LlvmArchiveBuilderBuilder;\n \n impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n     fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a> {\n-        Box::new(LlvmArchiveBuilder { sess, additions: Vec::new() })\n+        if sess.target.arch == \"wasm32\" || sess.target.arch == \"wasm64\" {\n+            Box::new(LlvmArchiveBuilder { sess, additions: Vec::new() })\n+        } else {\n+            Box::new(ArArchiveBuilder::new(sess, get_llvm_object_symbols))\n+        }\n     }\n \n     fn create_dll_import_lib(\n@@ -309,6 +261,53 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n     }\n }\n \n+#[deny(unsafe_op_in_unsafe_fn)]\n+fn get_llvm_object_symbols(\n+    buf: &[u8],\n+    f: &mut dyn FnMut(&[u8]) -> io::Result<()>,\n+) -> io::Result<bool> {\n+    if unsafe { llvm::LLVMRustIsBitcode(buf.as_ptr(), buf.len()) } {\n+        let mut state = Box::new(f);\n+\n+        let err = unsafe {\n+            llvm::LLVMRustGetSymbols(\n+                buf.as_ptr(),\n+                buf.len(),\n+                &mut *state as *mut &mut _ as *mut c_void,\n+                callback,\n+                error_callback,\n+            )\n+        };\n+\n+        if err.is_null() {\n+            return Ok(true);\n+        } else {\n+            return Err(unsafe { *Box::from_raw(err as *mut io::Error) });\n+        }\n+\n+        unsafe extern \"C\" fn callback(\n+            state: *mut c_void,\n+            symbol_name: *const c_char,\n+        ) -> *mut c_void {\n+            let f = unsafe { &mut *(state as *mut &mut dyn FnMut(&[u8]) -> io::Result<()>) };\n+            match f(unsafe { CStr::from_ptr(symbol_name) }.to_bytes()) {\n+                Ok(()) => std::ptr::null_mut(),\n+                Err(err) => Box::into_raw(Box::new(err)) as *mut c_void,\n+            }\n+        }\n+\n+        unsafe extern \"C\" fn error_callback(error: *const c_char) -> *mut c_void {\n+            let error = unsafe { CStr::from_ptr(error) };\n+            Box::into_raw(Box::new(io::Error::new(\n+                io::ErrorKind::Other,\n+                format!(\"LLVM error: {}\", error.to_string_lossy()),\n+            ))) as *mut c_void\n+        }\n+    } else {\n+        get_native_object_symbols(buf, f)\n+    }\n+}\n+\n impl<'a> LlvmArchiveBuilder<'a> {\n     fn build_with_llvm(&mut self, output: &Path) -> io::Result<bool> {\n         let kind = &*self.sess.target.archive_format;"}, {"sha": "fddfbb23c67d5737a7d3031eee72f77707ca7fe9", "filename": "compiler/rustc_codegen_llvm/src/errors.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs?ref=be6708428fdf6693188e2c2f10f05d1b1aaa5750", "patch": "@@ -72,12 +72,6 @@ pub(crate) struct LinkageConstOrMutType {\n #[diag(codegen_llvm_sanitizer_memtag_requires_mte)]\n pub(crate) struct SanitizerMemtagRequiresMte;\n \n-#[derive(Diagnostic)]\n-#[diag(codegen_llvm_archive_build_failure)]\n-pub(crate) struct ArchiveBuildFailure {\n-    pub error: std::io::Error,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(codegen_llvm_error_writing_def_file)]\n pub(crate) struct ErrorWritingDEFFile {\n@@ -97,12 +91,6 @@ pub(crate) struct DlltoolFailImportLibrary<'a> {\n     pub stderr: Cow<'a, str>,\n }\n \n-#[derive(Diagnostic)]\n-#[diag(codegen_llvm_unknown_archive_kind)]\n-pub(crate) struct UnknownArchiveKind<'a> {\n-    pub kind: &'a str,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(codegen_llvm_dynamic_linking_with_lto)]\n #[note]"}, {"sha": "aca09ab526073ceec211fa8ad100ff0c80837d28", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=be6708428fdf6693188e2c2f10f05d1b1aaa5750", "patch": "@@ -983,6 +983,9 @@ pub type SelfProfileBeforePassCallback =\n     unsafe extern \"C\" fn(*mut c_void, *const c_char, *const c_char);\n pub type SelfProfileAfterPassCallback = unsafe extern \"C\" fn(*mut c_void);\n \n+pub type GetSymbolsCallback = unsafe extern \"C\" fn(*mut c_void, *const c_char) -> *mut c_void;\n+pub type GetSymbolsErrorCallback = unsafe extern \"C\" fn(*const c_char) -> *mut c_void;\n+\n extern \"C\" {\n     pub fn LLVMRustInstallFatalErrorHandler();\n     pub fn LLVMRustDisableSystemDialogsOnCrash();\n@@ -2474,4 +2477,14 @@ extern \"C\" {\n     pub fn LLVMRustGetMangledName(V: &Value, out: &RustString);\n \n     pub fn LLVMRustGetElementTypeArgIndex(CallSite: &Value) -> i32;\n+\n+    pub fn LLVMRustIsBitcode(ptr: *const u8, len: usize) -> bool;\n+\n+    pub fn LLVMRustGetSymbols(\n+        buf_ptr: *const u8,\n+        buf_len: usize,\n+        state: *mut c_void,\n+        callback: GetSymbolsCallback,\n+        error_callback: GetSymbolsErrorCallback,\n+    ) -> *mut c_void;\n }"}, {"sha": "345174fb595ab1de60c74441c44e3481730bdb7c", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=be6708428fdf6693188e2c2f10f05d1b1aaa5750", "patch": "@@ -7,6 +7,7 @@ edition = \"2021\"\n test = false\n \n [dependencies]\n+ar_archive_writer = \"0.1.1\"\n bitflags = \"1.2.1\"\n cc = \"1.0.69\"\n itertools = \"0.10.1\""}, {"sha": "280fa49e29b60ef941717e26e18058d5dd1705be", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 205, "deletions": 2, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=be6708428fdf6693188e2c2f10f05d1b1aaa5750", "patch": "@@ -6,14 +6,18 @@ use rustc_span::symbol::Symbol;\n \n use super::metadata::search_for_section;\n \n+pub use ar_archive_writer::get_native_object_symbols;\n+use ar_archive_writer::{write_archive_to_stream, ArchiveKind, NewArchiveMember};\n use object::read::archive::ArchiveFile;\n+use object::read::macho::FatArch;\n \n use std::error::Error;\n use std::fs::File;\n-use std::io;\n+use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n \n-use crate::errors::ExtractBundledLibsError;\n+// Re-exporting for rustc_codegen_llvm::back::archive\n+pub use crate::errors::{ArchiveBuildFailure, ExtractBundledLibsError, UnknownArchiveKind};\n \n pub trait ArchiveBuilderBuilder {\n     fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a>;\n@@ -80,3 +84,202 @@ pub trait ArchiveBuilder<'a> {\n \n     fn build(self: Box<Self>, output: &Path) -> bool;\n }\n+\n+#[must_use = \"must call build() to finish building the archive\"]\n+pub struct ArArchiveBuilder<'a> {\n+    sess: &'a Session,\n+    get_object_symbols:\n+        fn(buf: &[u8], f: &mut dyn FnMut(&[u8]) -> io::Result<()>) -> io::Result<bool>,\n+\n+    src_archives: Vec<(PathBuf, Mmap)>,\n+    // Don't use an `HashMap` here, as the order is important. `lib.rmeta` needs\n+    // to be at the end of an archive in some cases for linkers to not get confused.\n+    entries: Vec<(Vec<u8>, ArchiveEntry)>,\n+}\n+\n+#[derive(Debug)]\n+enum ArchiveEntry {\n+    FromArchive { archive_index: usize, file_range: (u64, u64) },\n+    File(PathBuf),\n+}\n+\n+impl<'a> ArArchiveBuilder<'a> {\n+    pub fn new(\n+        sess: &'a Session,\n+        get_object_symbols: fn(\n+            buf: &[u8],\n+            f: &mut dyn FnMut(&[u8]) -> io::Result<()>,\n+        ) -> io::Result<bool>,\n+    ) -> ArArchiveBuilder<'a> {\n+        ArArchiveBuilder { sess, get_object_symbols, src_archives: vec![], entries: vec![] }\n+    }\n+}\n+\n+fn try_filter_fat_archs(\n+    archs: object::read::Result<&[impl FatArch]>,\n+    target_arch: object::Architecture,\n+    archive_path: &Path,\n+    archive_map_data: &[u8],\n+) -> io::Result<Option<PathBuf>> {\n+    let archs = archs.map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;\n+\n+    let desired = match archs.iter().filter(|a| a.architecture() == target_arch).next() {\n+        Some(a) => a,\n+        None => return Ok(None),\n+    };\n+\n+    let (mut new_f, extracted_path) = tempfile::Builder::new()\n+        .suffix(archive_path.file_name().unwrap())\n+        .tempfile()?\n+        .keep()\n+        .unwrap();\n+\n+    new_f.write_all(\n+        desired.data(archive_map_data).map_err(|e| io::Error::new(io::ErrorKind::Other, e))?,\n+    )?;\n+\n+    Ok(Some(extracted_path))\n+}\n+\n+pub fn try_extract_macho_fat_archive(\n+    sess: &Session,\n+    archive_path: &Path,\n+) -> io::Result<Option<PathBuf>> {\n+    let archive_map = unsafe { Mmap::map(File::open(&archive_path)?)? };\n+    let target_arch = match sess.target.arch.as_ref() {\n+        \"aarch64\" => object::Architecture::Aarch64,\n+        \"x86_64\" => object::Architecture::X86_64,\n+        _ => return Ok(None),\n+    };\n+\n+    match object::macho::FatHeader::parse(&*archive_map) {\n+        Ok(h) if h.magic.get(object::endian::BigEndian) == object::macho::FAT_MAGIC => {\n+            let archs = object::macho::FatHeader::parse_arch32(&*archive_map);\n+            try_filter_fat_archs(archs, target_arch, archive_path, &*archive_map)\n+        }\n+        Ok(h) if h.magic.get(object::endian::BigEndian) == object::macho::FAT_MAGIC_64 => {\n+            let archs = object::macho::FatHeader::parse_arch64(&*archive_map);\n+            try_filter_fat_archs(archs, target_arch, archive_path, &*archive_map)\n+        }\n+        // Not a FatHeader at all, just return None.\n+        _ => Ok(None),\n+    }\n+}\n+\n+impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n+    fn add_archive(\n+        &mut self,\n+        archive_path: &Path,\n+        mut skip: Box<dyn FnMut(&str) -> bool + 'static>,\n+    ) -> io::Result<()> {\n+        let mut archive_path = archive_path.to_path_buf();\n+        if self.sess.target.llvm_target.contains(\"-apple-macosx\") {\n+            if let Some(new_archive_path) =\n+                try_extract_macho_fat_archive(&self.sess, &archive_path)?\n+            {\n+                archive_path = new_archive_path\n+            }\n+        }\n+\n+        if self.src_archives.iter().any(|archive| archive.0 == archive_path) {\n+            return Ok(());\n+        }\n+\n+        let archive_map = unsafe { Mmap::map(File::open(&archive_path)?)? };\n+        let archive = ArchiveFile::parse(&*archive_map)\n+            .map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n+        let archive_index = self.src_archives.len();\n+\n+        for entry in archive.members() {\n+            let entry = entry.map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n+            let file_name = String::from_utf8(entry.name().to_vec())\n+                .map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n+            if !skip(&file_name) {\n+                self.entries.push((\n+                    file_name.into_bytes(),\n+                    ArchiveEntry::FromArchive { archive_index, file_range: entry.file_range() },\n+                ));\n+            }\n+        }\n+\n+        self.src_archives.push((archive_path.to_owned(), archive_map));\n+        Ok(())\n+    }\n+\n+    /// Adds an arbitrary file to this archive\n+    fn add_file(&mut self, file: &Path) {\n+        self.entries.push((\n+            file.file_name().unwrap().to_str().unwrap().to_string().into_bytes(),\n+            ArchiveEntry::File(file.to_owned()),\n+        ));\n+    }\n+\n+    /// Combine the provided files, rlibs, and native libraries into a single\n+    /// `Archive`.\n+    fn build(self: Box<Self>, output: &Path) -> bool {\n+        let sess = self.sess;\n+        match self.build_inner(output) {\n+            Ok(any_members) => any_members,\n+            Err(e) => sess.emit_fatal(ArchiveBuildFailure { error: e }),\n+        }\n+    }\n+}\n+\n+impl<'a> ArArchiveBuilder<'a> {\n+    fn build_inner(self, output: &Path) -> io::Result<bool> {\n+        let archive_kind = match &*self.sess.target.archive_format {\n+            \"gnu\" => ArchiveKind::Gnu,\n+            \"bsd\" => ArchiveKind::Bsd,\n+            \"darwin\" => ArchiveKind::Darwin,\n+            \"coff\" => ArchiveKind::Coff,\n+            kind => {\n+                self.sess.emit_fatal(UnknownArchiveKind { kind });\n+            }\n+        };\n+\n+        let mut entries = Vec::new();\n+\n+        for (entry_name, entry) in self.entries {\n+            let data =\n+                match entry {\n+                    ArchiveEntry::FromArchive { archive_index, file_range } => {\n+                        let src_archive = &self.src_archives[archive_index];\n+\n+                        let data = &src_archive.1\n+                            [file_range.0 as usize..file_range.0 as usize + file_range.1 as usize];\n+\n+                        Box::new(data) as Box<dyn AsRef<[u8]>>\n+                    }\n+                    ArchiveEntry::File(file) => unsafe {\n+                        Box::new(\n+                            Mmap::map(File::open(file).map_err(|err| {\n+                                io_error_context(\"failed to open object file\", err)\n+                            })?)\n+                            .map_err(|err| io_error_context(\"failed to map object file\", err))?,\n+                        ) as Box<dyn AsRef<[u8]>>\n+                    },\n+                };\n+\n+            entries.push(NewArchiveMember {\n+                buf: data,\n+                get_symbols: self.get_object_symbols,\n+                member_name: String::from_utf8(entry_name).unwrap(),\n+                mtime: 0,\n+                uid: 0,\n+                gid: 0,\n+                perms: 0o644,\n+            })\n+        }\n+\n+        let mut w = File::create(output)\n+            .map_err(|err| io_error_context(\"failed to create archive file\", err))?;\n+\n+        write_archive_to_stream(&mut w, &entries, true, archive_kind, true, false)?;\n+\n+        Ok(!entries.is_empty())\n+    }\n+}\n+\n+fn io_error_context(context: &str, err: io::Error) -> io::Error {\n+    io::Error::new(io::ErrorKind::Other, format!(\"{context}: {err}\"))\n+}"}, {"sha": "e3b6fbf1bc7f0e1bf07f39e7f6d581d1d8046427", "filename": "compiler/rustc_codegen_ssa/src/errors.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs?ref=be6708428fdf6693188e2c2f10f05d1b1aaa5750", "patch": "@@ -534,3 +534,17 @@ pub struct ReadFileError {\n #[derive(Diagnostic)]\n #[diag(codegen_ssa_unsupported_link_self_contained)]\n pub struct UnsupportedLinkSelfContained;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_archive_build_failure)]\n+// Public for rustc_codegen_llvm::back::archive\n+pub struct ArchiveBuildFailure {\n+    pub error: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unknown_archive_kind)]\n+// Public for rustc_codegen_llvm::back::archive\n+pub struct UnknownArchiveKind<'a> {\n+    pub kind: &'a str,\n+}"}, {"sha": "47d5d88363bd987db84a992f96f2e1eb42abf916", "filename": "compiler/rustc_data_structures/src/memmap.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs?ref=be6708428fdf6693188e2c2f10f05d1b1aaa5750", "patch": "@@ -40,6 +40,12 @@ impl Deref for Mmap {\n     }\n }\n \n+impl AsRef<[u8]> for Mmap {\n+    fn as_ref(&self) -> &[u8] {\n+        &*self.0\n+    }\n+}\n+\n // SAFETY: On architectures other than WASM, mmap is used as backing storage. The address of this\n // memory map is stable. On WASM, `Vec<u8>` is used as backing storage. The `Mmap` type doesn't\n // export any function that can cause the `Vec` to be re-allocated. As such the address of the"}, {"sha": "a1b7afeb7099d5084e8f619e528a3408e794c56b", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_gcc.ftl", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_gcc.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_gcc.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_gcc.ftl?ref=be6708428fdf6693188e2c2f10f05d1b1aaa5750", "patch": "@@ -1,6 +1,3 @@\n-codegen_gcc_ranlib_failure =\n-    Ranlib exited with code {$exit_code}\n-\n codegen_gcc_linkage_const_or_mut_type =\n     must have type `*const T` or `*mut T` due to `#[linkage]` attribute\n "}, {"sha": "e273476b60bb69d2c44ce27185cb56ea9af7653e", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_llvm.ftl", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl?ref=be6708428fdf6693188e2c2f10f05d1b1aaa5750", "patch": "@@ -29,9 +29,6 @@ codegen_llvm_linkage_const_or_mut_type =\n codegen_llvm_sanitizer_memtag_requires_mte =\n     `-Zsanitizer=memtag` requires `-Ctarget-feature=+mte`\n \n-codegen_llvm_archive_build_failure =\n-    failed to build archive: {$error}\n-\n codegen_llvm_error_writing_def_file =\n     Error writing .DEF file: {$error}\n \n@@ -41,9 +38,6 @@ codegen_llvm_error_calling_dlltool =\n codegen_llvm_dlltool_fail_import_library =\n     Dlltool could not create import library: {$stdout}\\n{$stderr}\n \n-codegen_llvm_unknown_archive_kind =\n-    Don't know how to build archive of type: {$kind}\n-\n codegen_llvm_target_feature_disable_or_enable =\n     the target features {$features} must all be either enabled or disabled together\n "}, {"sha": "4d1f9c1c901fc63d7fc4d877c76379baa2634e8b", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_ssa.ftl", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl?ref=be6708428fdf6693188e2c2f10f05d1b1aaa5750", "patch": "@@ -186,3 +186,9 @@ codegen_ssa_apple_sdk_error_sdk_path = failed to get {$sdk_name} SDK path: {erro\n codegen_ssa_read_file = failed to read file: {message}\n \n codegen_ssa_unsupported_link_self_contained = option `-C link-self-contained` is not supported on this target\n+\n+codegen_ssa_archive_build_failure =\n+    failed to build archive: {$error}\n+\n+codegen_ssa_unknown_archive_kind =\n+    Don't know how to build archive of type: {$kind}"}, {"sha": "79f06ac146c77953267734d0d37022d3abfa9853", "filename": "compiler/rustc_llvm/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fbuild.rs?ref=be6708428fdf6693188e2c2f10f05d1b1aaa5750", "patch": "@@ -222,6 +222,7 @@ fn main() {\n         .file(\"llvm-wrapper/RustWrapper.cpp\")\n         .file(\"llvm-wrapper/ArchiveWrapper.cpp\")\n         .file(\"llvm-wrapper/CoverageMappingWrapper.cpp\")\n+        .file(\"llvm-wrapper/SymbolWrapper.cpp\")\n         .file(\"llvm-wrapper/Linker.cpp\")\n         .cpp(true)\n         .cpp_link_stdlib(None) // we handle this below"}, {"sha": "792d921c6a4f99568776f1175223fccd69f016ac", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=be6708428fdf6693188e2c2f10f05d1b1aaa5750", "patch": "@@ -1967,3 +1967,7 @@ extern \"C\" int32_t LLVMRustGetElementTypeArgIndex(LLVMValueRef CallSite) {\n #endif\n     return -1;\n }\n+\n+extern \"C\" bool LLVMRustIsBitcode(char *ptr, size_t len) {\n+  return identify_magic(StringRef(ptr, len)) == file_magic::bitcode;\n+}"}, {"sha": "054f5f62a30272bbd0c7a4566dc0434dd5dad48c", "filename": "compiler/rustc_llvm/llvm-wrapper/SymbolWrapper.cpp", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_llvm%2Fllvm-wrapper%2FSymbolWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/be6708428fdf6693188e2c2f10f05d1b1aaa5750/compiler%2Frustc_llvm%2Fllvm-wrapper%2FSymbolWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FSymbolWrapper.cpp?ref=be6708428fdf6693188e2c2f10f05d1b1aaa5750", "patch": "@@ -0,0 +1,82 @@\n+// Derived from code in LLVM, which is:\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+\n+// Derived from:\n+// * https://github.com/llvm/llvm-project/blob/8ef3e895ad8ab1724e2b87cabad1dacdc7a397a3/llvm/include/llvm/Object/ArchiveWriter.h\n+// * https://github.com/llvm/llvm-project/blob/8ef3e895ad8ab1724e2b87cabad1dacdc7a397a3/llvm/lib/Object/ArchiveWriter.cpp\n+\n+#include \"llvm/IR/LLVMContext.h\"\n+#include \"llvm/Object/ObjectFile.h\"\n+#include \"llvm/ADT/Optional.h\"\n+\n+using namespace llvm;\n+using namespace llvm::sys;\n+using namespace llvm::object;\n+\n+static bool isArchiveSymbol(const object::BasicSymbolRef &S) {\n+  Expected<uint32_t> SymFlagsOrErr = S.getFlags();\n+  if (!SymFlagsOrErr)\n+    // FIXME: Actually report errors helpfully.\n+    report_fatal_error(SymFlagsOrErr.takeError());\n+  if (*SymFlagsOrErr & object::SymbolRef::SF_FormatSpecific)\n+    return false;\n+  if (!(*SymFlagsOrErr & object::SymbolRef::SF_Global))\n+    return false;\n+  if (*SymFlagsOrErr & object::SymbolRef::SF_Undefined)\n+    return false;\n+  return true;\n+}\n+\n+typedef void *(*LLVMRustGetSymbolsCallback)(void *, const char *);\n+typedef void *(*LLVMRustGetSymbolsErrorCallback)(const char *);\n+\n+// Note: This is implemented in C++ instead of using the C api from Rust as IRObjectFile doesn't\n+// implement getSymbolName, only printSymbolName, which is inaccessible from the C api.\n+extern \"C\" void *LLVMRustGetSymbols(\n+  char *BufPtr, size_t BufLen, void *State, LLVMRustGetSymbolsCallback Callback,\n+  LLVMRustGetSymbolsErrorCallback ErrorCallback) {\n+  std::unique_ptr<MemoryBuffer> Buf =\n+    MemoryBuffer::getMemBuffer(StringRef(BufPtr, BufLen), StringRef(\"LLVMRustGetSymbolsObject\"),\n+                               false);\n+  SmallString<0> SymNameBuf;\n+  raw_svector_ostream SymName(SymNameBuf);\n+\n+  // In the scenario when LLVMContext is populated SymbolicFile will contain a\n+  // reference to it, thus SymbolicFile should be destroyed first.\n+  LLVMContext Context;\n+  std::unique_ptr<object::SymbolicFile> Obj;\n+\n+  const file_magic Type = identify_magic(Buf->getBuffer());\n+  if (Type != file_magic::bitcode) {\n+    return ErrorCallback(\"not bitcode\");\n+  }\n+  auto ObjOrErr = object::SymbolicFile::createSymbolicFile(\n+      Buf->getMemBufferRef(), file_magic::bitcode, &Context);\n+  if (!ObjOrErr) {\n+    Error E = ObjOrErr.takeError();\n+    SmallString<0> ErrorBuf;\n+    raw_svector_ostream Error(ErrorBuf);\n+    Error << E << '\\0';\n+    return ErrorCallback(Error.str().data());\n+  }\n+  Obj = std::move(*ObjOrErr);\n+\n+  for (const object::BasicSymbolRef &S : Obj->symbols()) {\n+    if (!isArchiveSymbol(S))\n+      continue;\n+    if (Error E = S.printName(SymName)) {\n+      SmallString<0> ErrorBuf;\n+      raw_svector_ostream Error(ErrorBuf);\n+      Error << E << '\\0';\n+      return ErrorCallback(Error.str().data());\n+    }\n+    SymName << '\\0';\n+    if (void *E = Callback(State, SymNameBuf.str().data())) {\n+      return E;\n+    }\n+    SymNameBuf.clear();\n+  }\n+  return 0;\n+}"}, {"sha": "b92714524abf69c8e8846ecd3d74b8043731a718", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/be6708428fdf6693188e2c2f10f05d1b1aaa5750/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6708428fdf6693188e2c2f10f05d1b1aaa5750/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=be6708428fdf6693188e2c2f10f05d1b1aaa5750", "patch": "@@ -31,18 +31,19 @@ const LICENSES: &[&str] = &[\n /// tooling. It is _crucial_ that no exception crates be dependencies\n /// of the Rust runtime (std/test).\n const EXCEPTIONS: &[(&str, &str)] = &[\n-    (\"mdbook\", \"MPL-2.0\"),            // mdbook\n-    (\"openssl\", \"Apache-2.0\"),        // cargo, mdbook\n-    (\"colored\", \"MPL-2.0\"),           // rustfmt\n-    (\"ryu\", \"Apache-2.0 OR BSL-1.0\"), // cargo/... (because of serde)\n-    (\"bytesize\", \"Apache-2.0\"),       // cargo\n-    (\"im-rc\", \"MPL-2.0+\"),            // cargo\n-    (\"sized-chunks\", \"MPL-2.0+\"),     // cargo via im-rc\n-    (\"bitmaps\", \"MPL-2.0+\"),          // cargo via im-rc\n-    (\"instant\", \"BSD-3-Clause\"),      // rustc_driver/tracing-subscriber/parking_lot\n-    (\"snap\", \"BSD-3-Clause\"),         // rustc\n+    (\"ar_archive_writer\", \"Apache-2.0 WITH LLVM-exception\"), // rustc\n+    (\"mdbook\", \"MPL-2.0\"),                                   // mdbook\n+    (\"openssl\", \"Apache-2.0\"),                               // cargo, mdbook\n+    (\"colored\", \"MPL-2.0\"),                                  // rustfmt\n+    (\"ryu\", \"Apache-2.0 OR BSL-1.0\"),                        // cargo/... (because of serde)\n+    (\"bytesize\", \"Apache-2.0\"),                              // cargo\n+    (\"im-rc\", \"MPL-2.0+\"),                                   // cargo\n+    (\"sized-chunks\", \"MPL-2.0+\"),                            // cargo via im-rc\n+    (\"bitmaps\", \"MPL-2.0+\"),                                 // cargo via im-rc\n+    (\"instant\", \"BSD-3-Clause\"), // rustc_driver/tracing-subscriber/parking_lot\n+    (\"snap\", \"BSD-3-Clause\"),    // rustc\n     (\"fluent-langneg\", \"Apache-2.0\"), // rustc (fluent translations)\n-    (\"self_cell\", \"Apache-2.0\"),      // rustc (fluent translations)\n+    (\"self_cell\", \"Apache-2.0\"), // rustc (fluent translations)\n     // FIXME: this dependency violates the documentation comment above:\n     (\"fortanix-sgx-abi\", \"MPL-2.0\"), // libstd but only for `sgx` target\n     (\"dunce\", \"CC0-1.0\"),            // cargo (dev dependency)\n@@ -86,6 +87,7 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"aho-corasick\",\n     \"annotate-snippets\",\n     \"ansi_term\",\n+    \"ar_archive_writer\",\n     \"arrayvec\",\n     \"atty\",\n     \"autocfg\",\n@@ -274,7 +276,6 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n const PERMITTED_CRANELIFT_DEPENDENCIES: &[&str] = &[\n     \"ahash\",\n     \"anyhow\",\n-    \"ar\",\n     \"arrayvec\",\n     \"autocfg\",\n     \"bumpalo\","}]}