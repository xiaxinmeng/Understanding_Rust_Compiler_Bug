{"sha": "28fd1b04e56f33fecc843c0a78fc490b03100f43", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4ZmQxYjA0ZTU2ZjMzZmVjYzg0M2MwYTc4ZmM0OTBiMDMxMDBmNDM=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-12-18T20:27:22Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-12-30T13:30:59Z"}, "message": "Stop well-formedness checking unreachable code.\n\nThis commit stops well-formedness checking applying to unreachable code\nand therefore stops some of the ICEs that the intended solution taken by\nthis PR causes.\n\nBy disabling these checks, we can land the other fixes and larger\nrefactors that this PR includes.", "tree": {"sha": "8d54c82be1266aec3f22d05fa37ef26cb2d09933", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d54c82be1266aec3f22d05fa37ef26cb2d09933"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28fd1b04e56f33fecc843c0a78fc490b03100f43", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAlwoyJMACgkQAXYLT59T\n8VSsAA//RYaLfKW6HrtOYEe2x8hAz89T+SfB4GwYWFYI41kM6nPkTvCij0tssyek\ntIsqHEreuaMo5SHTkF3njbkY4859npytLkbRW/kIJQKXGshpGoDHZcN/VVhI5+My\nfccs9rrBpyjhu+wsUsm9w4O4OeZfR07Z2s3u4vTeoOEgwt8sk1Z0FzCqIjNOvE7G\n+EomHyFgoZMC/+xLOZXW9qUG7L+8O+tONX6oCaqPE/Rfy8VADTF9zkTJdYJd03yb\n7ZHeJrAZJMpP2Urw129+micCwUYHo3p9j2XCj/fSlIdAjot76CY+KrWiSyh6SMXv\nIV00UScebICVwKUXRgxxSq87EGc5uU6EK+MMqtSQje6yTiQwTyfSC/aj5uc2apew\nHHmY3ckMhGUJBG6KzUDDA8ZD00oeh9IimQSYEujmKT+d3NIzntzOxzrGHUgm8J9Q\n1AZpOSf4OdYWwrhcRBhi5E1H6dryXbtELONF7rZNx4gy9MoKpE0sBBnJ5ouoP11T\nri93F0vnzcr7d+SuCDKpFxS/rZh1nKXHFjYG+Cs/TSOtZ28hck2apaB2BeeiQ+Er\nz88bAuXu4e1+AlIbxr9XG3ihLHBy465XtYpINHz6dK9ndpr9V5f1tqLZcoD59o+J\nydryBYBwPso89p/wtY7qyvVPGX2CMnblE7Q7wcPg43wSh8TtZWY=\n=NdZb\n-----END PGP SIGNATURE-----", "payload": "tree 8d54c82be1266aec3f22d05fa37ef26cb2d09933\nparent 95c18382cb01480b99b55163c19f35907de80eb4\nauthor David Wood <david@davidtw.co> 1545164842 +0100\ncommitter David Wood <david@davidtw.co> 1546176659 +0100\n\nStop well-formedness checking unreachable code.\n\nThis commit stops well-formedness checking applying to unreachable code\nand therefore stops some of the ICEs that the intended solution taken by\nthis PR causes.\n\nBy disabling these checks, we can land the other fixes and larger\nrefactors that this PR includes.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28fd1b04e56f33fecc843c0a78fc490b03100f43", "html_url": "https://github.com/rust-lang/rust/commit/28fd1b04e56f33fecc843c0a78fc490b03100f43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28fd1b04e56f33fecc843c0a78fc490b03100f43/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95c18382cb01480b99b55163c19f35907de80eb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/95c18382cb01480b99b55163c19f35907de80eb4", "html_url": "https://github.com/rust-lang/rust/commit/95c18382cb01480b99b55163c19f35907de80eb4"}], "stats": {"total": 315, "additions": 70, "deletions": 245}, "files": [{"sha": "e5fd0aa3c9cbd8d8af9d26d7a854d1504048c0d4", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28fd1b04e56f33fecc843c0a78fc490b03100f43/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28fd1b04e56f33fecc843c0a78fc490b03100f43/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=28fd1b04e56f33fecc843c0a78fc490b03100f43", "patch": "@@ -62,8 +62,7 @@ use syntax_pos::symbol::InternedString;\n use traits;\n use traits::query::{\n     CanonicalProjectionGoal, CanonicalTyGoal, CanonicalTypeOpAscribeUserTypeGoal,\n-    CanonicalTypeOpAscribeUserTypeWellFormedGoal, CanonicalTypeOpEqGoal,\n-    CanonicalTypeOpSubtypeGoal, CanonicalPredicateGoal,\n+    CanonicalTypeOpEqGoal, CanonicalTypeOpSubtypeGoal, CanonicalPredicateGoal,\n     CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpNormalizeGoal,\n };\n use ty::{TyCtxt, FnSig, Instance, InstanceDef,\n@@ -651,7 +650,6 @@ define_dep_nodes!( <'tcx>\n     [] EvaluateObligation(CanonicalPredicateGoal<'tcx>),\n     [] EvaluateGoal(traits::ChalkCanonicalGoal<'tcx>),\n     [] TypeOpAscribeUserType(CanonicalTypeOpAscribeUserTypeGoal<'tcx>),\n-    [] TypeOpAscribeUserTypeWellFormed(CanonicalTypeOpAscribeUserTypeWellFormedGoal<'tcx>),\n     [] TypeOpEq(CanonicalTypeOpEqGoal<'tcx>),\n     [] TypeOpSubtype(CanonicalTypeOpSubtypeGoal<'tcx>),\n     [] TypeOpProvePredicate(CanonicalTypeOpProvePredicateGoal<'tcx>),"}, {"sha": "59f786025b22485d75fe5b42088ae8d69c4b6b3d", "filename": "src/librustc/traits/query/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28fd1b04e56f33fecc843c0a78fc490b03100f43/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28fd1b04e56f33fecc843c0a78fc490b03100f43/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=28fd1b04e56f33fecc843c0a78fc490b03100f43", "patch": "@@ -28,10 +28,6 @@ pub type CanonicalPredicateGoal<'tcx> =\n pub type CanonicalTypeOpAscribeUserTypeGoal<'tcx> =\n     Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::ascribe_user_type::AscribeUserType<'tcx>>>;\n \n-pub type CanonicalTypeOpAscribeUserTypeWellFormedGoal<'tcx> =\n-    Canonical<'tcx, ty::ParamEnvAnd<'tcx,\n-        type_op::ascribe_user_type::AscribeUserTypeWellFormed<'tcx>>>;\n-\n pub type CanonicalTypeOpEqGoal<'tcx> =\n     Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::eq::Eq<'tcx>>>;\n "}, {"sha": "b2f30564de93a5d387a7fe19a666d892df02691b", "filename": "src/librustc/traits/query/type_op/ascribe_user_type.rs", "status": "modified", "additions": 1, "deletions": 57, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/28fd1b04e56f33fecc843c0a78fc490b03100f43/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28fd1b04e56f33fecc843c0a78fc490b03100f43/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=28fd1b04e56f33fecc843c0a78fc490b03100f43", "patch": "@@ -2,7 +2,7 @@ use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, Que\n use traits::query::Fallible;\n use hir::def_id::DefId;\n use mir::ProjectionKind;\n-use ty::{self, ParamEnvAnd, Ty, TyCtxt, UserTypeAnnotation};\n+use ty::{self, ParamEnvAnd, Ty, TyCtxt};\n use ty::subst::UserSubsts;\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n@@ -68,59 +68,3 @@ impl_stable_hash_for! {\n         mir_ty, variance, def_id, user_substs, projs\n     }\n }\n-\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub struct AscribeUserTypeWellFormed<'tcx> {\n-    pub user_type_annotation: UserTypeAnnotation<'tcx>,\n-}\n-\n-impl<'tcx> AscribeUserTypeWellFormed<'tcx> {\n-    pub fn new(\n-        user_type_annotation: UserTypeAnnotation<'tcx>,\n-    ) -> Self {\n-        Self { user_type_annotation, }\n-    }\n-}\n-\n-impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for AscribeUserTypeWellFormed<'tcx> {\n-    type QueryResponse = ();\n-\n-    fn try_fast_path(\n-        _tcx: TyCtxt<'_, 'gcx, 'tcx>,\n-        _key: &ParamEnvAnd<'tcx, Self>,\n-    ) -> Option<Self::QueryResponse> {\n-        None\n-    }\n-\n-    fn perform_query(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n-        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'gcx, ()>> {\n-        tcx.type_op_ascribe_user_type_well_formed(canonicalized)\n-    }\n-\n-    fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'gcx, ()>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, ()>> {\n-        v\n-    }\n-}\n-\n-BraceStructTypeFoldableImpl! {\n-    impl<'tcx> TypeFoldable<'tcx> for AscribeUserTypeWellFormed<'tcx> {\n-        user_type_annotation\n-    }\n-}\n-\n-BraceStructLiftImpl! {\n-    impl<'a, 'tcx> Lift<'tcx> for AscribeUserTypeWellFormed<'a> {\n-        type Lifted = AscribeUserTypeWellFormed<'tcx>;\n-        user_type_annotation\n-    }\n-}\n-\n-impl_stable_hash_for! {\n-    struct AscribeUserTypeWellFormed<'tcx> {\n-        user_type_annotation\n-    }\n-}"}, {"sha": "3464464aa229c9cc77dd5f0b47c26318dffd763b", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/28fd1b04e56f33fecc843c0a78fc490b03100f43/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28fd1b04e56f33fecc843c0a78fc490b03100f43/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=28fd1b04e56f33fecc843c0a78fc490b03100f43", "patch": "@@ -5,8 +5,7 @@ use mir::interpret::GlobalId;\n use traits;\n use traits::query::{\n     CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal,\n-    CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpAscribeUserTypeWellFormedGoal,\n-    CanonicalTypeOpEqGoal, CanonicalTypeOpNormalizeGoal,\n+    CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpNormalizeGoal,\n     CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpSubtypeGoal,\n };\n use ty::{self, ParamEnvAnd, Ty, TyCtxt};\n@@ -125,15 +124,6 @@ impl<'tcx> QueryDescription<'tcx> for queries::type_op_ascribe_user_type<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription<'tcx> for queries::type_op_ascribe_user_type_well_formed<'tcx> {\n-    fn describe(\n-        _tcx: TyCtxt<'_, '_, '_>,\n-        goal: CanonicalTypeOpAscribeUserTypeWellFormedGoal<'tcx>,\n-    ) -> Cow<'static, str> {\n-        format!(\"evaluating `type_op_ascribe_user_type_well_formed` `{:?}`\", goal).into()\n-    }\n-}\n-\n impl<'tcx> QueryDescription<'tcx> for queries::type_op_eq<'tcx> {\n     fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTypeOpEqGoal<'tcx>) -> Cow<'static, str> {\n         format!(\"evaluating `type_op_eq` `{:?}`\", goal).into()"}, {"sha": "842aea07614ddb0bc3d745e364cb50ba6ed55289", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/28fd1b04e56f33fecc843c0a78fc490b03100f43/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28fd1b04e56f33fecc843c0a78fc490b03100f43/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=28fd1b04e56f33fecc843c0a78fc490b03100f43", "patch": "@@ -27,8 +27,7 @@ use traits::{self, Vtable};\n use traits::query::{\n     CanonicalPredicateGoal, CanonicalProjectionGoal,\n     CanonicalTyGoal, CanonicalTypeOpAscribeUserTypeGoal,\n-    CanonicalTypeOpAscribeUserTypeWellFormedGoal, CanonicalTypeOpEqGoal,\n-    CanonicalTypeOpSubtypeGoal, CanonicalTypeOpProvePredicateGoal,\n+    CanonicalTypeOpEqGoal, CanonicalTypeOpSubtypeGoal, CanonicalTypeOpProvePredicateGoal,\n     CanonicalTypeOpNormalizeGoal, NoSolution,\n };\n use traits::query::method_autoderef::MethodAutoderefStepsResult;\n@@ -610,14 +609,6 @@ define_queries! { <'tcx>\n             NoSolution,\n         >,\n \n-        /// Do not call this query directly: part of the `Eq` type-op\n-        [] fn type_op_ascribe_user_type_well_formed: TypeOpAscribeUserTypeWellFormed(\n-            CanonicalTypeOpAscribeUserTypeWellFormedGoal<'tcx>\n-        ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n-            NoSolution,\n-        >,\n-\n         /// Do not call this query directly: part of the `Eq` type-op\n         [] fn type_op_eq: TypeOpEq(\n             CanonicalTypeOpEqGoal<'tcx>"}, {"sha": "5d23ee0994a06ac8c1430c883c71c975dad68ad6", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28fd1b04e56f33fecc843c0a78fc490b03100f43/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28fd1b04e56f33fecc843c0a78fc490b03100f43/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=28fd1b04e56f33fecc843c0a78fc490b03100f43", "patch": "@@ -1208,7 +1208,6 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::EvaluateObligation |\n         DepKind::EvaluateGoal |\n         DepKind::TypeOpAscribeUserType |\n-        DepKind::TypeOpAscribeUserTypeWellFormed |\n         DepKind::TypeOpEq |\n         DepKind::TypeOpSubtype |\n         DepKind::TypeOpProvePredicate |"}, {"sha": "aacc63c47de61fefd7d546eb0204e988e2508823", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/28fd1b04e56f33fecc843c0a78fc490b03100f43/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28fd1b04e56f33fecc843c0a78fc490b03100f43/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=28fd1b04e56f33fecc843c0a78fc490b03100f43", "patch": "@@ -289,6 +289,11 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     self.out.extend(obligations);\n                 }\n \n+                ty::FnDef(did, substs) => {\n+                    let obligations = self.nominal_obligations(did, substs);\n+                    self.out.extend(obligations);\n+                }\n+\n                 ty::Ref(r, rty, _) => {\n                     // WfReference\n                     if !r.has_escaping_bound_vars() && !rty.has_escaping_bound_vars() {\n@@ -349,7 +354,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                ty::FnDef(..) | ty::FnPtr(_) => {\n+                ty::FnPtr(_) => {\n                     // let the loop iterate into the argument/return\n                     // types appearing in the fn signature\n                 }"}, {"sha": "796a2f79f7554ceb119d7d2b6ad7e77da2c8d804", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/28fd1b04e56f33fecc843c0a78fc490b03100f43/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28fd1b04e56f33fecc843c0a78fc490b03100f43/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=28fd1b04e56f33fecc843c0a78fc490b03100f43", "patch": "@@ -928,37 +928,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         );\n     }\n \n-    /// Check that user type annotations are well formed.\n-    fn check_user_type_annotations_are_well_formed(&mut self) {\n-        for index in self.mir.user_type_annotations.indices() {\n-            let (span, _) = &self.mir.user_type_annotations[index];\n-            let type_annotation = self.instantiated_type_annotations[&index];\n-            match type_annotation {\n-                // We can't check the well-formedness of a `UserTypeAnnotation::Ty` here, it will\n-                // cause ICEs (see comment in `relate_type_and_user_type`).\n-                UserTypeAnnotation::TypeOf(..) => {\n-                    if let Err(terr) = self.fully_perform_op(\n-                        Locations::All(*span),\n-                        ConstraintCategory::Assignment,\n-                        self.param_env.and(\n-                            type_op::ascribe_user_type::AscribeUserTypeWellFormed::new(\n-                                type_annotation,\n-                            )\n-                        ),\n-                    ) {\n-                        span_mirbug!(\n-                            self,\n-                            type_annotation,\n-                            \"bad user type annotation: {:?}\",\n-                            terr,\n-                        );\n-                    }\n-                },\n-                _ => {},\n-            }\n-        }\n-    }\n-\n     /// Given some operation `op` that manipulates types, proves\n     /// predicates, or otherwise uses the inference context, executes\n     /// `op` and then executes all the further obligations that `op`\n@@ -1127,27 +1096,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 if let Ok(projected_ty) = curr_projected_ty {\n                     let ty = projected_ty.to_ty(tcx);\n                     self.relate_types(ty, v1, a, locations, category)?;\n-\n-                    // We'll get an ICE if we check for well-formedness of a\n-                    // `UserTypeAnnotation::Ty` that hasn't had types related.\n-                    //\n-                    // Doing this without the types having been related will result in\n-                    // `probe_ty_var` failing in the canonicalizer - in practice, this\n-                    // results in three run-pass tests failing. You can work around that\n-                    // by keeping an vec of projections instead of annotations and performing\n-                    // the projections before storing into `instantiated_type_annotations`\n-                    // but that still fails in dead code.\n-                    self.fully_perform_op(\n-                        locations,\n-                        category,\n-                        self.param_env.and(\n-                            type_op::ascribe_user_type::AscribeUserTypeWellFormed::new(\n-                                UserTypeAnnotation::Ty(ty),\n-                            )\n-                        ),\n-                    )?;\n                 }\n-\n             }\n             UserTypeAnnotation::TypeOf(def_id, user_substs) => {\n                 let projs = self.infcx.tcx.intern_projs(&user_ty.projs);\n@@ -2453,8 +2402,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             self.check_terminator(mir, block_data.terminator(), location);\n             self.check_iscleanup(mir, block_data);\n         }\n-\n-        self.check_user_type_annotations_are_well_formed();\n     }\n \n     fn normalize<T>(&mut self, value: T, location: impl NormalizeLocation) -> T"}, {"sha": "52fcb5b80f4ae9d4dec96886c8dd3b0cc02b31aa", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 27, "deletions": 76, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/28fd1b04e56f33fecc843c0a78fc490b03100f43/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28fd1b04e56f33fecc843c0a78fc490b03100f43/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=28fd1b04e56f33fecc843c0a78fc490b03100f43", "patch": "@@ -4,7 +4,7 @@ use rustc::infer::InferCtxt;\n use rustc::hir::def_id::DefId;\n use rustc::mir::ProjectionKind;\n use rustc::mir::tcx::PlaceTy;\n-use rustc::traits::query::type_op::ascribe_user_type::{AscribeUserType, AscribeUserTypeWellFormed};\n+use rustc::traits::query::type_op::ascribe_user_type::AscribeUserType;\n use rustc::traits::query::type_op::eq::Eq;\n use rustc::traits::query::type_op::normalize::Normalize;\n use rustc::traits::query::type_op::prove_predicate::ProvePredicate;\n@@ -17,7 +17,6 @@ use rustc::ty::query::Providers;\n use rustc::ty::subst::{Kind, Subst, UserSubsts, UserSelfTy};\n use rustc::ty::{\n     FnSig, Lift, ParamEnv, ParamEnvAnd, PolyFnSig, Predicate, Ty, TyCtxt, TypeFoldable, Variance,\n-    UserTypeAnnotation,\n };\n use rustc_data_structures::sync::Lrc;\n use std::fmt;\n@@ -27,7 +26,6 @@ use syntax_pos::DUMMY_SP;\n crate fn provide(p: &mut Providers) {\n     *p = Providers {\n         type_op_ascribe_user_type,\n-        type_op_ascribe_user_type_well_formed,\n         type_op_eq,\n         type_op_prove_predicate,\n         type_op_subtype,\n@@ -62,28 +60,6 @@ fn type_op_ascribe_user_type<'tcx>(\n         })\n }\n \n-fn type_op_ascribe_user_type_well_formed<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-    canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, AscribeUserTypeWellFormed<'tcx>>>,\n-) -> Result<Lrc<Canonical<'tcx, QueryResponse<'tcx, ()>>>, NoSolution> {\n-    tcx.infer_ctxt()\n-        .enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n-            let (\n-                param_env, AscribeUserTypeWellFormed { user_type_annotation }\n-            ) = key.into_parts();\n-\n-            debug!(\n-                \"type_op_ascribe_user_type_well_formed: user_type_annotation={:?}\",\n-                user_type_annotation,\n-            );\n-\n-            let mut cx = AscribeUserTypeCx { infcx, param_env, fulfill_cx };\n-            cx.well_formed(user_type_annotation)?;\n-\n-            Ok(())\n-        })\n-}\n-\n struct AscribeUserTypeCx<'me, 'gcx: 'tcx, 'tcx: 'me> {\n     infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n     param_env: ParamEnv<'tcx>,\n@@ -133,56 +109,6 @@ impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n         value.subst(self.tcx(), substs)\n     }\n \n-    fn well_formed(\n-        &mut self,\n-        type_annotation: UserTypeAnnotation<'tcx>\n-    ) -> Result<(), NoSolution> {\n-        match type_annotation {\n-            UserTypeAnnotation::Ty(ty) => {\n-                self.prove_predicate(Predicate::WellFormed(ty));\n-                Ok(())\n-            },\n-            UserTypeAnnotation::TypeOf(did, user_substs) => {\n-                let UserSubsts {\n-                    user_self_ty,\n-                    substs,\n-                } = user_substs;\n-\n-                let ty = self.tcx().type_of(did);\n-                let ty = self.subst(ty, substs);\n-                debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n-                let ty = self.normalize(ty);\n-\n-                if let Some(UserSelfTy {\n-                    impl_def_id,\n-                    self_ty,\n-                }) = user_self_ty {\n-                    let impl_self_ty = self.tcx().type_of(impl_def_id);\n-                    let impl_self_ty = self.subst(impl_self_ty, &substs);\n-                    let impl_self_ty = self.normalize(impl_self_ty);\n-\n-                    self.relate(self_ty, Variance::Invariant, impl_self_ty)?;\n-\n-                    self.prove_predicate(Predicate::WellFormed(impl_self_ty));\n-                }\n-\n-                // In addition to proving the predicates, we have to\n-                // prove that `ty` is well-formed -- this is because\n-                // the WF of `ty` is predicated on the substs being\n-                // well-formed, and we haven't proven *that*. We don't\n-                // want to prove the WF of types from  `substs` directly because they\n-                // haven't been normalized.\n-                //\n-                // FIXME(nmatsakis): Well, perhaps we should normalize\n-                // them?  This would only be relevant if some input\n-                // type were ill-formed but did not appear in `ty`,\n-                // which...could happen with normalization...\n-                self.prove_predicate(Predicate::WellFormed(ty));\n-                Ok(())\n-            },\n-        }\n-    }\n-\n     fn relate_mir_and_user_ty(\n         &mut self,\n         mir_ty: Ty<'tcx>,\n@@ -192,7 +118,7 @@ impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n         projs: &[ProjectionKind<'tcx>],\n     ) -> Result<(), NoSolution> {\n         let UserSubsts {\n-            user_self_ty: _,\n+            user_self_ty,\n             substs,\n         } = user_substs;\n         let tcx = self.tcx();\n@@ -245,6 +171,31 @@ impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n             self.prove_predicate(instantiated_predicate);\n         }\n \n+        if let Some(UserSelfTy {\n+            impl_def_id,\n+            self_ty,\n+        }) = user_self_ty {\n+            let impl_self_ty = self.tcx().type_of(impl_def_id);\n+            let impl_self_ty = self.subst(impl_self_ty, &substs);\n+            let impl_self_ty = self.normalize(impl_self_ty);\n+\n+            self.relate(self_ty, Variance::Invariant, impl_self_ty)?;\n+\n+            self.prove_predicate(Predicate::WellFormed(impl_self_ty));\n+        }\n+\n+        // In addition to proving the predicates, we have to\n+        // prove that `ty` is well-formed -- this is because\n+        // the WF of `ty` is predicated on the substs being\n+        // well-formed, and we haven't proven *that*. We don't\n+        // want to prove the WF of types from  `substs` directly because they\n+        // haven't been normalized.\n+        //\n+        // FIXME(nmatsakis): Well, perhaps we should normalize\n+        // them?  This would only be relevant if some input\n+        // type were ill-formed but did not appear in `ty`,\n+        // which...could happen with normalization...\n+        self.prove_predicate(Predicate::WellFormed(ty));\n         Ok(())\n     }\n }"}, {"sha": "185077bd684a87ecaac408212899eaeba80a8188", "filename": "src/test/ui/issue-54943-3.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/28fd1b04e56f33fecc843c0a78fc490b03100f43/src%2Ftest%2Fui%2Fissue-54943-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28fd1b04e56f33fecc843c0a78fc490b03100f43/src%2Ftest%2Fui%2Fissue-54943-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-54943-3.rs?ref=28fd1b04e56f33fecc843c0a78fc490b03100f43", "patch": "@@ -0,0 +1,21 @@\n+// compile-pass\n+// FIXME(#54943) This test targets the scenario where proving the WF requirements requires\n+// knowing the value of the `_` type present in the user type annotation - unfortunately, figuring\n+// out the value of that `_` requires type-checking the surrounding code, but that code is dead,\n+// so our NLL region checker doesn't have access to it. This test should actually fail to compile.\n+\n+#![feature(nll)]\n+#![allow(warnings)]\n+\n+use std::fmt::Debug;\n+\n+fn foo<T: 'static + Debug>(_: T) { }\n+\n+fn bar<'a>() {\n+    return;\n+\n+    let _x = foo::<Vec<_>>(Vec::<&'a u32>::new());\n+    //~^ ERROR the type `&'a u32` does not fulfill the required lifetime [E0477]\n+}\n+\n+fn main() {}"}, {"sha": "c720f6279758068643488b9a43fcc873358840eb", "filename": "src/test/ui/issue-54943.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/28fd1b04e56f33fecc843c0a78fc490b03100f43/src%2Ftest%2Fui%2Fissue-54943.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28fd1b04e56f33fecc843c0a78fc490b03100f43/src%2Ftest%2Fui%2Fissue-54943.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-54943.rs?ref=28fd1b04e56f33fecc843c0a78fc490b03100f43", "patch": "@@ -1,8 +1,17 @@\n+// compile-pass\n+// FIXME(#54943) This test targets the scenario where proving the WF requirements of a user\n+// type annotation requires checking dead code. This test should actually fail to compile.\n+\n+#![feature(nll)]\n+#![allow(warnings)]\n+\n fn foo<T: 'static>() { }\n \n-fn main<'a>() {\n+fn boo<'a>() {\n     return;\n \n     let x = foo::<&'a u32>();\n     //~^ ERROR the type `&'a u32` does not fulfill the required lifetime [E0477]\n }\n+\n+fn main() {}"}, {"sha": "62aacee811110503b084cb877ab3dbdb60970573", "filename": "src/test/ui/issue-54943.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/95c18382cb01480b99b55163c19f35907de80eb4/src%2Ftest%2Fui%2Fissue-54943.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95c18382cb01480b99b55163c19f35907de80eb4/src%2Ftest%2Fui%2Fissue-54943.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-54943.stderr?ref=95c18382cb01480b99b55163c19f35907de80eb4", "patch": "@@ -1,11 +0,0 @@\n-error[E0477]: the type `&'a u32` does not fulfill the required lifetime\n-  --> $DIR/issue-54943.rs:6:13\n-   |\n-LL |     let x = foo::<&'a u32>();\n-   |             ^^^^^^^^^^^^^^\n-   |\n-   = note: type must satisfy the static lifetime\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0477`."}, {"sha": "92c21fcb4aec5196f7cf1248674969b794bb39aa", "filename": "src/test/ui/regions/regions-free-region-ordering-caller1.nll.stderr", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/28fd1b04e56f33fecc843c0a78fc490b03100f43/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28fd1b04e56f33fecc843c0a78fc490b03100f43/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller1.nll.stderr?ref=28fd1b04e56f33fecc843c0a78fc490b03100f43", "patch": "@@ -12,21 +12,6 @@ LL |     let z: &'a & usize = &(&y);\n LL | }\n    | - temporary value is freed at the end of this statement\n \n-error[E0597]: `y` does not live long enough\n-  --> $DIR/regions-free-region-ordering-caller1.rs:9:27\n-   |\n-LL | fn call1<'a>(x: &'a usize) {\n-   |          -- lifetime `'a` defined here\n-...\n-LL |     let z: &'a & usize = &(&y);\n-   |            -----------    ^^^^ borrowed value does not live long enough\n-   |            |\n-   |            type annotation requires that `y` is borrowed for `'a`\n-...\n-LL | }\n-   | - `y` dropped here while still borrowed\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors occurred: E0597, E0716.\n-For more information about an error, try `rustc --explain E0597`.\n+For more information about this error, try `rustc --explain E0716`."}]}