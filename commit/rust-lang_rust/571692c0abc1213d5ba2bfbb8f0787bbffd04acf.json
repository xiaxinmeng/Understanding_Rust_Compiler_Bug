{"sha": "571692c0abc1213d5ba2bfbb8f0787bbffd04acf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3MTY5MmMwYWJjMTIxM2Q1YmEyYmZiYjhmMDc4N2JiZmZkMDRhY2Y=", "commit": {"author": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-07-21T12:39:28Z"}, "committer": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-07-24T09:41:23Z"}, "message": "Document PriorityQueue.", "tree": {"sha": "193a33db17da1b1cd497836ee1a0c0ddad4aea34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/193a33db17da1b1cd497836ee1a0c0ddad4aea34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/571692c0abc1213d5ba2bfbb8f0787bbffd04acf", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/571692c0abc1213d5ba2bfbb8f0787bbffd04acf", "html_url": "https://github.com/rust-lang/rust/commit/571692c0abc1213d5ba2bfbb8f0787bbffd04acf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/571692c0abc1213d5ba2bfbb8f0787bbffd04acf/comments", "author": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87ef2f390b7e463ce3e64973abce02be8c7a9ceb", "url": "https://api.github.com/repos/rust-lang/rust/commits/87ef2f390b7e463ce3e64973abce02be8c7a9ceb", "html_url": "https://github.com/rust-lang/rust/commit/87ef2f390b7e463ce3e64973abce02be8c7a9ceb"}], "stats": {"total": 189, "additions": 177, "deletions": 12}, "files": [{"sha": "f76fae39f3426d443b258ae88557be6273cfd4ba", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 177, "deletions": 12, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/571692c0abc1213d5ba2bfbb8f0787bbffd04acf/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/571692c0abc1213d5ba2bfbb8f0787bbffd04acf/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=571692c0abc1213d5ba2bfbb8f0787bbffd04acf", "patch": "@@ -158,7 +158,9 @@ use {Collection, Mutable, MutableSeq};\n use slice;\n use vec::Vec;\n \n-/// A priority queue implemented with a binary heap\n+/// A priority queue implemented with a binary heap.\n+///\n+/// This will be a max-heap.\n #[deriving(Clone)]\n pub struct PriorityQueue<T> {\n     data: Vec<T>,\n@@ -180,15 +182,40 @@ impl<T: Ord> Default for PriorityQueue<T> {\n }\n \n impl<T: Ord> PriorityQueue<T> {\n-    /// Create an empty PriorityQueue\n+    /// Create an empty PriorityQueue as a max-heap.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    /// let pq: PriorityQueue<uint> = PriorityQueue::new();\n+    /// ```\n     pub fn new() -> PriorityQueue<T> { PriorityQueue{data: vec!(),} }\n \n-    /// Create an empty PriorityQueue with capacity `capacity`\n+    /// Create an empty PriorityQueue with a specific capacity.\n+    /// This preallocates enough memory for `capacity` elements,\n+    /// so that the PriorityQueue does not have to be reallocated\n+    /// until it contains at least that many values.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    /// let pq: PriorityQueue<uint> = PriorityQueue::with_capacity(10u);\n+    /// ```\n     pub fn with_capacity(capacity: uint) -> PriorityQueue<T> {\n         PriorityQueue { data: Vec::with_capacity(capacity) }\n     }\n \n-    /// Create a PriorityQueue from a vector (heapify)\n+    /// Create a PriorityQueue from a vector. This is sometimes called\n+    /// `heapifying` the vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    /// let pq = PriorityQueue::from_vec(vec![9i, 1, 2, 7, 3, 2]);\n+    /// ```\n     pub fn from_vec(xs: Vec<T>) -> PriorityQueue<T> {\n         let mut q = PriorityQueue{data: xs,};\n         let mut n = q.len() / 2;\n@@ -201,33 +228,101 @@ impl<T: Ord> PriorityQueue<T> {\n \n     /// An iterator visiting all values in underlying vector, in\n     /// arbitrary order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    /// let pq = PriorityQueue::from_vec(vec![1i, 2, 3, 4]);\n+    ///\n+    /// // Print 1, 2, 3, 4 in arbitrary order\n+    /// for x in pq.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     pub fn iter<'a>(&'a self) -> Items<'a, T> {\n         Items { iter: self.data.iter() }\n     }\n \n-    /// Returns the greatest item in a queue or None if it is empty\n+    /// Returns the greatest item in a queue or `None` if it is empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    ///\n+    /// let mut pq = PriorityQueue::new();\n+    /// assert_eq!(pq.top(), None);\n+    ///\n+    /// pq.push(1i);\n+    /// pq.push(5i);\n+    /// pq.push(2i);\n+    /// assert_eq!(pq.top(), Some(&5i));\n+    ///\n+    /// ```\n     pub fn top<'a>(&'a self) -> Option<&'a T> {\n         if self.is_empty() { None } else { Some(self.data.get(0)) }\n     }\n \n     #[deprecated=\"renamed to `top`\"]\n     pub fn maybe_top<'a>(&'a self) -> Option<&'a T> { self.top() }\n \n-    /// Returns the number of elements the queue can hold without reallocating\n+    /// Returns the number of elements the queue can hold without reallocating.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    ///\n+    /// let pq: PriorityQueue<uint> = PriorityQueue::with_capacity(100u);\n+    /// assert!(pq.capacity() >= 100u);\n+    /// ```\n     pub fn capacity(&self) -> uint { self.data.capacity() }\n \n-    /// Reserve capacity for exactly n elements in the PriorityQueue.\n+    /// Reserve capacity for exactly `n` elements in the PriorityQueue.\n     /// Do nothing if the capacity is already sufficient.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    ///\n+    /// let mut pq: PriorityQueue<uint> = PriorityQueue::new();\n+    /// pq.reserve_exact(100u);\n+    /// assert!(pq.capacity() == 100u);\n+    /// ```\n     pub fn reserve_exact(&mut self, n: uint) { self.data.reserve_exact(n) }\n \n-    /// Reserve capacity for at least n elements in the PriorityQueue.\n+    /// Reserve capacity for at least `n` elements in the PriorityQueue.\n     /// Do nothing if the capacity is already sufficient.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    ///\n+    /// let mut pq: PriorityQueue<uint> = PriorityQueue::new();\n+    /// pq.reserve(100u);\n+    /// assert!(pq.capacity() >= 100u);\n+    /// ```\n     pub fn reserve(&mut self, n: uint) {\n         self.data.reserve(n)\n     }\n \n     /// Remove the greatest item from a queue and return it, or `None` if it is\n     /// empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    ///\n+    /// let mut pq = PriorityQueue::from_vec(vec![1i, 3]);\n+    ///\n+    /// assert_eq!(pq.pop(), Some(3i));\n+    /// assert_eq!(pq.pop(), Some(1i));\n+    /// assert_eq!(pq.pop(), None);\n+    /// ```\n     pub fn pop(&mut self) -> Option<T> {\n         match self.data.pop() {\n             None           => { None }\n@@ -244,14 +339,43 @@ impl<T: Ord> PriorityQueue<T> {\n     #[deprecated=\"renamed to `pop`\"]\n     pub fn maybe_pop(&mut self) -> Option<T> { self.pop() }\n \n-    /// Push an item onto the queue\n+    /// Push an item onto the queue.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    ///\n+    /// let mut pq = PriorityQueue::new();\n+    /// pq.push(3i);\n+    /// pq.push(5i);\n+    /// pq.push(1i);\n+    ///\n+    /// assert_eq!(pq.len(), 3);\n+    /// assert_eq!(pq.top(), Some(&5i));\n+    /// ```\n     pub fn push(&mut self, item: T) {\n         self.data.push(item);\n         let new_len = self.len() - 1;\n         self.siftup(0, new_len);\n     }\n \n-    /// Optimized version of a push followed by a pop\n+    /// Optimized version of a push followed by a pop.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    ///\n+    /// let mut pq = PriorityQueue::new();\n+    /// pq.push(1i);\n+    /// pq.push(5i);\n+    ///\n+    /// assert_eq!(pq.push_pop(3i), 5);\n+    /// assert_eq!(pq.push_pop(9i), 9);\n+    /// assert_eq!(pq.len(), 2);\n+    /// assert_eq!(pq.top(), Some(&3i));\n+    /// ```\n     pub fn push_pop(&mut self, mut item: T) -> T {\n         if !self.is_empty() && *self.top().unwrap() > item {\n             swap(&mut item, self.data.get_mut(0));\n@@ -262,6 +386,19 @@ impl<T: Ord> PriorityQueue<T> {\n \n     /// Optimized version of a pop followed by a push. The push is done\n     /// regardless of whether the queue is empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    ///\n+    /// let mut pq = PriorityQueue::new();\n+    ///\n+    /// assert_eq!(pq.replace(1i), None);\n+    /// assert_eq!(pq.replace(3i), Some(1i));\n+    /// assert_eq!(pq.len(), 1);\n+    /// assert_eq!(pq.top(), Some(&3i));\n+    /// ```\n     pub fn replace(&mut self, mut item: T) -> Option<T> {\n         if !self.is_empty() {\n             swap(&mut item, self.data.get_mut(0));\n@@ -282,10 +419,38 @@ impl<T: Ord> PriorityQueue<T> {\n     fn to_sorted_vec(self) -> Vec<T> { self.into_sorted_vec() }\n \n     /// Consume the PriorityQueue and return the underlying vector\n+    /// in arbitrary order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    ///\n+    /// let pq = PriorityQueue::from_vec(vec![1i, 2, 3, 4, 5, 6, 7]);\n+    /// let vec = pq.into_vec();\n+    ///\n+    /// // Will print in some order\n+    /// for x in vec.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     pub fn into_vec(self) -> Vec<T> { let PriorityQueue{data: v} = self; v }\n \n     /// Consume the PriorityQueue and return a vector in sorted\n-    /// (ascending) order\n+    /// (ascending) order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    ///\n+    /// let mut pq = PriorityQueue::from_vec(vec![1i, 2, 4, 5, 7]);\n+    /// pq.push(6);\n+    /// pq.push(3);\n+    ///\n+    /// let vec = pq.into_sorted_vec();\n+    /// assert_eq!(vec, vec![1i, 2, 3, 4, 5, 6, 7]);\n+    /// ```\n     pub fn into_sorted_vec(self) -> Vec<T> {\n         let mut q = self;\n         let mut end = q.len();\n@@ -348,7 +513,7 @@ impl<T: Ord> PriorityQueue<T> {\n     }\n }\n \n-/// PriorityQueue iterator\n+/// PriorityQueue iterator.\n pub struct Items <'a, T> {\n     iter: slice::Items<'a, T>,\n }"}]}