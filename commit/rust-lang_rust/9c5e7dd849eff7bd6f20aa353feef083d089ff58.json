{"sha": "9c5e7dd849eff7bd6f20aa353feef083d089ff58", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljNWU3ZGQ4NDllZmY3YmQ2ZjIwYWEzNTNmZWVmMDgzZDA4OWZmNTg=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-05-12T16:33:47Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-06-15T16:21:23Z"}, "message": "Implement autoderef using the Deref trait\n\n - add support for other lang item targets, since we need the Deref lang item", "tree": {"sha": "5639ff8814d3f4ba0f5ac41de215ed3720f3d1b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5639ff8814d3f4ba0f5ac41de215ed3720f3d1b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c5e7dd849eff7bd6f20aa353feef083d089ff58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c5e7dd849eff7bd6f20aa353feef083d089ff58", "html_url": "https://github.com/rust-lang/rust/commit/9c5e7dd849eff7bd6f20aa353feef083d089ff58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c5e7dd849eff7bd6f20aa353feef083d089ff58/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49489dc20cc9f340d43acb467677b9bc59495ed2", "url": "https://api.github.com/repos/rust-lang/rust/commits/49489dc20cc9f340d43acb467677b9bc59495ed2", "html_url": "https://github.com/rust-lang/rust/commit/49489dc20cc9f340d43acb467677b9bc59495ed2"}], "stats": {"total": 199, "additions": 152, "deletions": 47}, "files": [{"sha": "c7a8bce20250bc9be86a95e2facfe6a64984b619", "filename": "crates/ra_assists/src/fill_match_arms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c5e7dd849eff7bd6f20aa353feef083d089ff58/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5e7dd849eff7bd6f20aa353feef083d089ff58/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs?ref=9c5e7dd849eff7bd6f20aa353feef083d089ff58", "patch": "@@ -22,7 +22,7 @@ pub(crate) fn fill_match_arms(mut ctx: AssistCtx<impl HirDatabase>) -> Option<As\n     let expr = match_expr.expr()?;\n     let analyzer = hir::SourceAnalyzer::new(ctx.db, ctx.frange.file_id, expr.syntax(), None);\n     let match_expr_ty = analyzer.type_of(ctx.db, expr)?;\n-    let enum_def = match_expr_ty.autoderef(ctx.db).find_map(|ty| match ty.as_adt() {\n+    let enum_def = analyzer.autoderef(ctx.db, match_expr_ty).find_map(|ty| match ty.as_adt() {\n         Some((AdtDef::Enum(e), _)) => Some(e),\n         _ => None,\n     })?;"}, {"sha": "ada8aeb5b959f9800f035a13f66421e8dd6a203f", "filename": "crates/ra_hir/src/lang_item.rs", "status": "modified", "additions": 46, "deletions": 9, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/9c5e7dd849eff7bd6f20aa353feef083d089ff58/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5e7dd849eff7bd6f20aa353feef083d089ff58/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flang_item.rs?ref=9c5e7dd849eff7bd6f20aa353feef083d089ff58", "patch": "@@ -4,7 +4,7 @@ use rustc_hash::FxHashMap;\n use ra_syntax::{SmolStr, ast::AttrsOwner};\n \n use crate::{\n-    Crate, DefDatabase, Enum, Function, HirDatabase, ImplBlock, Module, Static, Struct, Trait, AstDatabase,\n+        Crate, DefDatabase, Enum, Function, HirDatabase, ImplBlock, Module, Static, Struct, Trait, ModuleDef, AstDatabase, HasSource\n };\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -87,23 +87,60 @@ impl LangItems {\n         let source = module.definition_source(db).ast;\n         for (impl_id, _) in impl_blocks.impls.iter() {\n             let impl_block = source_map.get(&source, impl_id);\n-            let lang_item_name = impl_block\n-                .attrs()\n-                .filter_map(|a| a.as_key_value())\n-                .filter(|(key, _)| key == \"lang\")\n-                .map(|(_, val)| val)\n-                .nth(0);\n-            if let Some(lang_item_name) = lang_item_name {\n+            if let Some(lang_item_name) = lang_item_name(&*impl_block) {\n                 let imp = ImplBlock::from_id(*module, impl_id);\n                 self.items.entry(lang_item_name).or_insert_with(|| LangItemTarget::ImplBlock(imp));\n             }\n         }\n \n-        // FIXME we should look for the other lang item targets (traits, structs, ...)\n+        // FIXME make this nicer\n+        for def in module.declarations(db) {\n+            match def {\n+                ModuleDef::Trait(trait_) => {\n+                    let node = trait_.source(db).ast;\n+                    if let Some(lang_item_name) = lang_item_name(&*node) {\n+                        self.items.entry(lang_item_name).or_insert(LangItemTarget::Trait(trait_));\n+                    }\n+                }\n+                ModuleDef::Enum(e) => {\n+                    let node = e.source(db).ast;\n+                    if let Some(lang_item_name) = lang_item_name(&*node) {\n+                        self.items.entry(lang_item_name).or_insert(LangItemTarget::Enum(e));\n+                    }\n+                }\n+                ModuleDef::Struct(s) => {\n+                    let node = s.source(db).ast;\n+                    if let Some(lang_item_name) = lang_item_name(&*node) {\n+                        self.items.entry(lang_item_name).or_insert(LangItemTarget::Struct(s));\n+                    }\n+                }\n+                ModuleDef::Function(f) => {\n+                    let node = f.source(db).ast;\n+                    if let Some(lang_item_name) = lang_item_name(&*node) {\n+                        self.items.entry(lang_item_name).or_insert(LangItemTarget::Function(f));\n+                    }\n+                }\n+                ModuleDef::Static(s) => {\n+                    let node = s.source(db).ast;\n+                    if let Some(lang_item_name) = lang_item_name(&*node) {\n+                        self.items.entry(lang_item_name).or_insert(LangItemTarget::Static(s));\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n \n         // Look for lang items in the children\n         for child in module.children(db) {\n             self.collect_lang_items_recursive(db, &child);\n         }\n     }\n }\n+\n+fn lang_item_name<T: AttrsOwner>(node: &T) -> Option<SmolStr> {\n+    node.attrs()\n+        .filter_map(|a| a.as_key_value())\n+        .filter(|(key, _)| key == \"lang\")\n+        .map(|(_, val)| val)\n+        .nth(0)\n+}"}, {"sha": "ba17958eb9f146b0b01f8ea39fe7051191d21a1e", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c5e7dd849eff7bd6f20aa353feef083d089ff58/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5e7dd849eff7bd6f20aa353feef083d089ff58/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=9c5e7dd849eff7bd6f20aa353feef083d089ff58", "patch": "@@ -46,6 +46,11 @@ impl Name {\n         Name::new(idx.to_string().into())\n     }\n \n+    // Needed for Deref\n+    pub(crate) fn target() -> Name {\n+        Name::new(\"Target\".into())\n+    }\n+\n     // There's should be no way to extract a string out of `Name`: `Name` in the\n     // future, `Name` will include hygiene information, and you can't encode\n     // hygiene into a String."}, {"sha": "08e86844de190df0393455e6445d9a4573d8bc3e", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9c5e7dd849eff7bd6f20aa353feef083d089ff58/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5e7dd849eff7bd6f20aa353feef083d089ff58/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=9c5e7dd849eff7bd6f20aa353feef083d089ff58", "patch": "@@ -369,6 +369,17 @@ impl SourceAnalyzer {\n         )\n     }\n \n+    pub fn autoderef<'a>(\n+        &'a self,\n+        db: &'a impl HirDatabase,\n+        ty: Ty,\n+    ) -> impl Iterator<Item = Ty> + 'a {\n+        // There should be no inference vars in types passed here\n+        // FIXME check that?\n+        let canonical = crate::ty::Canonical { value: ty, num_vars: 0 };\n+        crate::ty::autoderef(db, &self.resolver, canonical).map(|canonical| canonical.value)\n+    }\n+\n     #[cfg(test)]\n     pub(crate) fn body_source_map(&self) -> Arc<BodySourceMap> {\n         self.body_source_map.clone().unwrap()"}, {"sha": "d2f92a1f269b98066ee7666aad26e51154730c15", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c5e7dd849eff7bd6f20aa353feef083d089ff58/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5e7dd849eff7bd6f20aa353feef083d089ff58/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=9c5e7dd849eff7bd6f20aa353feef083d089ff58", "patch": "@@ -22,6 +22,7 @@ use display::{HirDisplay, HirFormatter};\n pub(crate) use lower::{TypableDef, type_for_def, type_for_field, callable_item_sig, generic_predicates, generic_defaults};\n pub(crate) use infer::{infer_query, InferenceResult, InferTy};\n pub use lower::CallableDef;\n+pub(crate) use autoderef::autoderef;\n \n /// A type constructor or type name: this might be something like the primitive\n /// type `bool`, a struct like `Vec`, or things like function pointers or\n@@ -225,8 +226,8 @@ impl Deref for Substs {\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct TraitRef {\n     /// FIXME name?\n-    trait_: Trait,\n-    substs: Substs,\n+    pub trait_: Trait,\n+    pub substs: Substs,\n }\n \n impl TraitRef {"}, {"sha": "bee756d80421cc4344e10bd22f1125a8d9c5a464", "filename": "crates/ra_hir/src/ty/autoderef.rs", "status": "modified", "additions": 59, "deletions": 9, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9c5e7dd849eff7bd6f20aa353feef083d089ff58/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5e7dd849eff7bd6f20aa353feef083d089ff58/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs?ref=9c5e7dd849eff7bd6f20aa353feef083d089ff58", "patch": "@@ -5,17 +5,67 @@\n \n use std::iter::successors;\n \n-use crate::HirDatabase;\n-use super::Ty;\n+use log::info;\n \n-impl Ty {\n-    /// Iterates over the possible derefs of `ty`.\n-    pub fn autoderef<'a>(self, db: &'a impl HirDatabase) -> impl Iterator<Item = Ty> + 'a {\n-        successors(Some(self), move |ty| ty.autoderef_step(db))\n+use crate::{HirDatabase, Name, Resolver};\n+use super::{traits::Solution, Ty, Canonical};\n+\n+pub(crate) fn autoderef<'a>(\n+    db: &'a impl HirDatabase,\n+    resolver: &'a Resolver,\n+    ty: Canonical<Ty>,\n+) -> impl Iterator<Item = Canonical<Ty>> + 'a {\n+    successors(Some(ty), move |ty| deref(db, resolver, ty))\n+}\n+\n+pub(crate) fn deref(\n+    db: &impl HirDatabase,\n+    resolver: &Resolver,\n+    ty: &Canonical<Ty>,\n+) -> Option<Canonical<Ty>> {\n+    if let Some(derefed) = ty.value.builtin_deref() {\n+        Some(Canonical { value: derefed, num_vars: ty.num_vars })\n+    } else {\n+        deref_by_trait(db, resolver, ty)\n     }\n+}\n+\n+fn deref_by_trait(\n+    db: &impl HirDatabase,\n+    resolver: &Resolver,\n+    ty: &Canonical<Ty>,\n+) -> Option<Canonical<Ty>> {\n+    let krate = resolver.krate()?;\n+    let deref_trait = match db.lang_item(krate, \"deref\".into())? {\n+        crate::lang_item::LangItemTarget::Trait(t) => t,\n+        _ => return None,\n+    };\n+    let target = deref_trait.associated_type_by_name(db, Name::target())?;\n+\n+    // FIXME we should check that Deref has no type parameters, because we assume it below\n+\n+    // FIXME make the Canonical handling nicer\n+    // TODO shift inference variables in ty\n+\n+    let projection = super::traits::ProjectionPredicate {\n+        ty: Ty::Bound(0),\n+        projection_ty: super::ProjectionTy {\n+            associated_ty: target,\n+            parameters: vec![ty.value.clone()].into(),\n+        },\n+    };\n+\n+    let canonical = super::Canonical { num_vars: 1 + ty.num_vars, value: projection };\n+\n+    let solution = db.normalize(krate, canonical)?;\n \n-    fn autoderef_step(&self, _db: &impl HirDatabase) -> Option<Ty> {\n-        // FIXME Deref::deref\n-        self.builtin_deref()\n+    match &solution {\n+        Solution::Unique(vars) => {\n+            Some(Canonical { value: vars.0.value[0].clone(), num_vars: vars.0.num_vars })\n+        }\n+        Solution::Ambig(_) => {\n+            info!(\"Ambiguous solution for deref: {:?}\", solution);\n+            None\n+        }\n     }\n }"}, {"sha": "fdb444de28f4f96d570afe65037832a2adf68db8", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9c5e7dd849eff7bd6f20aa353feef083d089ff58/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5e7dd849eff7bd6f20aa353feef083d089ff58/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=9c5e7dd849eff7bd6f20aa353feef083d089ff58", "patch": "@@ -46,7 +46,7 @@ use crate::{\n use super::{\n     Ty, TypableDef, Substs, primitive, op, ApplicationTy, TypeCtor, CallableDef, TraitRef,\n     traits::{Solution, Obligation, Guidance},\n-    method_resolution,\n+    method_resolution, autoderef,\n };\n \n mod unify;\n@@ -1074,25 +1074,27 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             Expr::Field { expr, name } => {\n                 let receiver_ty = self.infer_expr(*expr, &Expectation::none());\n-                let ty = receiver_ty\n-                    .autoderef(self.db)\n-                    .find_map(|derefed_ty| match derefed_ty {\n-                        Ty::Apply(a_ty) => match a_ty.ctor {\n-                            TypeCtor::Tuple { .. } => {\n-                                let i = name.to_string().parse::<usize>().ok();\n-                                i.and_then(|i| a_ty.parameters.0.get(i).cloned())\n-                            }\n-                            TypeCtor::Adt(AdtDef::Struct(s)) => {\n-                                s.field(self.db, name).map(|field| {\n-                                    self.write_field_resolution(tgt_expr, field);\n-                                    field.ty(self.db).subst(&a_ty.parameters)\n-                                })\n-                            }\n-                            _ => None,\n-                        },\n+                let canonicalized = self.canonicalizer().canonicalize_ty(receiver_ty);\n+                let ty = autoderef::autoderef(\n+                    self.db,\n+                    &self.resolver.clone(),\n+                    canonicalized.value.clone(),\n+                )\n+                .find_map(|derefed_ty| match canonicalized.decanonicalize_ty(derefed_ty.value) {\n+                    Ty::Apply(a_ty) => match a_ty.ctor {\n+                        TypeCtor::Tuple { .. } => {\n+                            let i = name.to_string().parse::<usize>().ok();\n+                            i.and_then(|i| a_ty.parameters.0.get(i).cloned())\n+                        }\n+                        TypeCtor::Adt(AdtDef::Struct(s)) => s.field(self.db, name).map(|field| {\n+                            self.write_field_resolution(tgt_expr, field);\n+                            field.ty(self.db).subst(&a_ty.parameters)\n+                        }),\n                         _ => None,\n-                    })\n-                    .unwrap_or(Ty::Unknown);\n+                    },\n+                    _ => None,\n+                })\n+                .unwrap_or(Ty::Unknown);\n                 self.insert_type_vars(ty)\n             }\n             Expr::Try { expr } => {"}, {"sha": "ad26d591ce0012f39aa6c647c988a678c5f437b8", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c5e7dd849eff7bd6f20aa353feef083d089ff58/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5e7dd849eff7bd6f20aa353feef083d089ff58/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=9c5e7dd849eff7bd6f20aa353feef083d089ff58", "patch": "@@ -16,7 +16,7 @@ use crate::{\n     generics::HasGenericParams,\n     ty::primitive::{UncertainIntTy, UncertainFloatTy}\n };\n-use super::{TraitRef, Canonical};\n+use super::{TraitRef, Canonical, autoderef};\n \n /// This is used as a key for indexing impls.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -162,8 +162,7 @@ pub(crate) fn iterate_method_candidates<T>(\n     // rustc does an autoderef and then autoref again).\n \n     let krate = resolver.krate()?;\n-    for derefed_ty in ty.value.clone().autoderef(db) {\n-        let derefed_ty = Canonical { value: derefed_ty, num_vars: ty.num_vars };\n+    for derefed_ty in autoderef::autoderef(db, resolver, ty.clone()) {\n         if let Some(result) = iterate_inherent_methods(&derefed_ty, db, name, krate, &mut callback)\n         {\n             return Some(result);"}, {"sha": "6cf3dd70a54bfa032523e537eb42f48b7d689f13", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c5e7dd849eff7bd6f20aa353feef083d089ff58/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5e7dd849eff7bd6f20aa353feef083d089ff58/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=9c5e7dd849eff7bd6f20aa353feef083d089ff58", "patch": "@@ -80,8 +80,8 @@ pub enum Obligation {\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub struct ProjectionPredicate {\n-    projection_ty: ProjectionTy,\n-    ty: Ty,\n+    pub projection_ty: ProjectionTy,\n+    pub ty: Ty,\n }\n \n /// Check using Chalk whether trait is implemented for given parameters including `Self` type."}, {"sha": "f26fd06b370348aec0279dc2a7d90e5c967e0f14", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c5e7dd849eff7bd6f20aa353feef083d089ff58/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5e7dd849eff7bd6f20aa353feef083d089ff58/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=9c5e7dd849eff7bd6f20aa353feef083d089ff58", "patch": "@@ -15,7 +15,7 @@ pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n }\n \n fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) {\n-    for receiver in receiver.autoderef(ctx.db) {\n+    for receiver in ctx.analyzer.autoderef(ctx.db, receiver) {\n         if let Ty::Apply(a_ty) = receiver {\n             match a_ty.ctor {\n                 TypeCtor::Adt(AdtDef::Struct(s)) => {"}, {"sha": "6f5164e0babddebf2a9456ca19569dae12a9e922", "filename": "crates/ra_ide_api/src/goto_type_definition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c5e7dd849eff7bd6f20aa353feef083d089ff58/crates%2Fra_ide_api%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5e7dd849eff7bd6f20aa353feef083d089ff58/crates%2Fra_ide_api%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_type_definition.rs?ref=9c5e7dd849eff7bd6f20aa353feef083d089ff58", "patch": "@@ -30,7 +30,7 @@ pub(crate) fn goto_type_definition(\n         return None;\n     };\n \n-    let adt_def = ty.autoderef(db).find_map(|ty| ty.as_adt().map(|adt| adt.0))?;\n+    let adt_def = analyzer.autoderef(db, ty).find_map(|ty| ty.as_adt().map(|adt| adt.0))?;\n \n     let nav = NavigationTarget::from_adt_def(db, adt_def);\n     Some(RangeInfo::new(node.range(), vec![nav]))"}]}