{"sha": "871608791934f81cdd430797fdd64a8f9da19074", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3MTYwODc5MTkzNGY4MWNkZDQzMDc5N2ZkZDY0YThmOWRhMTkwNzQ=", "commit": {"author": {"name": "Xavier Denis", "email": "xldenis@gmail.com", "date": "2020-11-10T20:50:05Z"}, "committer": {"name": "Xavier Denis", "email": "xldenis@gmail.com", "date": "2020-11-11T11:45:40Z"}, "message": "Add support for loading rustc private crates", "tree": {"sha": "9dfd9fd0f6dae3a736c882fc410723acd643138b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9dfd9fd0f6dae3a736c882fc410723acd643138b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/871608791934f81cdd430797fdd64a8f9da19074", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/871608791934f81cdd430797fdd64a8f9da19074", "html_url": "https://github.com/rust-lang/rust/commit/871608791934f81cdd430797fdd64a8f9da19074", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/871608791934f81cdd430797fdd64a8f9da19074/comments", "author": {"login": "xldenis", "id": 451373, "node_id": "MDQ6VXNlcjQ1MTM3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/451373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xldenis", "html_url": "https://github.com/xldenis", "followers_url": "https://api.github.com/users/xldenis/followers", "following_url": "https://api.github.com/users/xldenis/following{/other_user}", "gists_url": "https://api.github.com/users/xldenis/gists{/gist_id}", "starred_url": "https://api.github.com/users/xldenis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xldenis/subscriptions", "organizations_url": "https://api.github.com/users/xldenis/orgs", "repos_url": "https://api.github.com/users/xldenis/repos", "events_url": "https://api.github.com/users/xldenis/events{/privacy}", "received_events_url": "https://api.github.com/users/xldenis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xldenis", "id": 451373, "node_id": "MDQ6VXNlcjQ1MTM3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/451373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xldenis", "html_url": "https://github.com/xldenis", "followers_url": "https://api.github.com/users/xldenis/followers", "following_url": "https://api.github.com/users/xldenis/following{/other_user}", "gists_url": "https://api.github.com/users/xldenis/gists{/gist_id}", "starred_url": "https://api.github.com/users/xldenis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xldenis/subscriptions", "organizations_url": "https://api.github.com/users/xldenis/orgs", "repos_url": "https://api.github.com/users/xldenis/repos", "events_url": "https://api.github.com/users/xldenis/events{/privacy}", "received_events_url": "https://api.github.com/users/xldenis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c06e820fa02b47a1550576f2a7071ff94fb0c64", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c06e820fa02b47a1550576f2a7071ff94fb0c64", "html_url": "https://github.com/rust-lang/rust/commit/5c06e820fa02b47a1550576f2a7071ff94fb0c64"}], "stats": {"total": 3687, "additions": 3608, "deletions": 79}, "files": [{"sha": "608a031d49293b1a13fb09ec6ed3e83a51e6605d", "filename": "crates/project_model/src/cargo_workspace.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/871608791934f81cdd430797fdd64a8f9da19074/crates%2Fproject_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871608791934f81cdd430797fdd64a8f9da19074/crates%2Fproject_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fcargo_workspace.rs?ref=871608791934f81cdd430797fdd64a8f9da19074", "patch": "@@ -64,6 +64,9 @@ pub struct CargoConfig {\n \n     /// rustc target\n     pub target: Option<String>,\n+\n+    /// rustc private crate source\n+    pub rustc_source: Option<AbsPathBuf>,\n }\n \n pub type Package = Idx<PackageData>;"}, {"sha": "40eb05f7035f4c5a13b28ec3e10cc3ba66047cea", "filename": "crates/project_model/src/lib.rs", "status": "modified", "additions": 206, "deletions": 67, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/871608791934f81cdd430797fdd64a8f9da19074/crates%2Fproject_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871608791934f81cdd430797fdd64a8f9da19074/crates%2Fproject_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Flib.rs?ref=871608791934f81cdd430797fdd64a8f9da19074", "patch": "@@ -9,6 +9,7 @@ use std::{\n     fmt,\n     fs::{self, read_dir, ReadDir},\n     io,\n+    path::Component,\n     process::Command,\n };\n \n@@ -31,18 +32,22 @@ pub use proc_macro_api::ProcMacroClient;\n #[derive(Clone, Eq, PartialEq)]\n pub enum ProjectWorkspace {\n     /// Project workspace was discovered by running `cargo metadata` and `rustc --print sysroot`.\n-    Cargo { cargo: CargoWorkspace, sysroot: Sysroot },\n+    Cargo { cargo: CargoWorkspace, sysroot: Sysroot, rustc: Option<CargoWorkspace> },\n     /// Project workspace was manually specified using a `rust-project.json` file.\n     Json { project: ProjectJson, sysroot: Option<Sysroot> },\n }\n \n impl fmt::Debug for ProjectWorkspace {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            ProjectWorkspace::Cargo { cargo, sysroot } => f\n+            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => f\n                 .debug_struct(\"Cargo\")\n                 .field(\"n_packages\", &cargo.packages().len())\n                 .field(\"n_sysroot_crates\", &sysroot.crates().len())\n+                .field(\n+                    \"n_rustc_compiler_crates\",\n+                    &rustc.as_ref().map(|rc| rc.packages().len()).unwrap_or(0),\n+                )\n                 .finish(),\n             ProjectWorkspace::Json { project, sysroot } => {\n                 let mut debug_struct = f.debug_struct(\"Json\");\n@@ -200,7 +205,19 @@ impl ProjectWorkspace {\n                 } else {\n                     Sysroot::default()\n                 };\n-                ProjectWorkspace::Cargo { cargo, sysroot }\n+\n+                let rustc = if let Some(rustc_dir) = &cargo_config.rustc_source {\n+                    Some(\n+                        CargoWorkspace::from_cargo_metadata(&rustc_dir, cargo_config)\n+                            .with_context(|| {\n+                                format!(\"Failed to read Cargo metadata for Rust sources\")\n+                            })?,\n+                    )\n+                } else {\n+                    None\n+                };\n+\n+                ProjectWorkspace::Cargo { cargo, sysroot, rustc }\n             }\n         };\n \n@@ -238,31 +255,43 @@ impl ProjectWorkspace {\n                     })\n                 }))\n                 .collect::<Vec<_>>(),\n-            ProjectWorkspace::Cargo { cargo, sysroot } => cargo\n-                .packages()\n-                .map(|pkg| {\n-                    let is_member = cargo[pkg].is_member;\n-                    let pkg_root = cargo[pkg].root().to_path_buf();\n-\n-                    let mut include = vec![pkg_root.clone()];\n-                    include.extend(cargo[pkg].out_dir.clone());\n-\n-                    let mut exclude = vec![pkg_root.join(\".git\")];\n-                    if is_member {\n-                        exclude.push(pkg_root.join(\"target\"));\n-                    } else {\n-                        exclude.push(pkg_root.join(\"tests\"));\n-                        exclude.push(pkg_root.join(\"examples\"));\n-                        exclude.push(pkg_root.join(\"benches\"));\n-                    }\n-                    PackageRoot { is_member, include, exclude }\n-                })\n-                .chain(sysroot.crates().map(|krate| PackageRoot {\n-                    is_member: false,\n-                    include: vec![sysroot[krate].root_dir().to_path_buf()],\n-                    exclude: Vec::new(),\n-                }))\n-                .collect(),\n+            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => {\n+                let roots = cargo\n+                    .packages()\n+                    .map(|pkg| {\n+                        let is_member = cargo[pkg].is_member;\n+                        let pkg_root = cargo[pkg].root().to_path_buf();\n+\n+                        let mut include = vec![pkg_root.clone()];\n+                        include.extend(cargo[pkg].out_dir.clone());\n+\n+                        let mut exclude = vec![pkg_root.join(\".git\")];\n+                        if is_member {\n+                            exclude.push(pkg_root.join(\"target\"));\n+                        } else {\n+                            exclude.push(pkg_root.join(\"tests\"));\n+                            exclude.push(pkg_root.join(\"examples\"));\n+                            exclude.push(pkg_root.join(\"benches\"));\n+                        }\n+                        PackageRoot { is_member, include, exclude }\n+                    })\n+                    .chain(sysroot.crates().map(|krate| PackageRoot {\n+                        is_member: false,\n+                        include: vec![sysroot[krate].root_dir().to_path_buf()],\n+                        exclude: Vec::new(),\n+                    }));\n+                if let Some(rustc_packages) = rustc {\n+                    roots\n+                        .chain(rustc_packages.packages().map(|krate| PackageRoot {\n+                            is_member: false,\n+                            include: vec![rustc_packages[krate].root().to_path_buf()],\n+                            exclude: Vec::new(),\n+                        }))\n+                        .collect()\n+                } else {\n+                    roots.collect()\n+                }\n+            }\n         }\n     }\n \n@@ -273,7 +302,7 @@ impl ProjectWorkspace {\n                 .filter_map(|(_, krate)| krate.proc_macro_dylib_path.as_ref())\n                 .cloned()\n                 .collect(),\n-            ProjectWorkspace::Cargo { cargo, sysroot: _sysroot } => cargo\n+            ProjectWorkspace::Cargo { cargo, sysroot: _sysroot, rustc: _rustc_crates } => cargo\n                 .packages()\n                 .filter_map(|pkg| cargo[pkg].proc_macro_dylib_path.as_ref())\n                 .cloned()\n@@ -284,8 +313,10 @@ impl ProjectWorkspace {\n     pub fn n_packages(&self) -> usize {\n         match self {\n             ProjectWorkspace::Json { project, .. } => project.n_crates(),\n-            ProjectWorkspace::Cargo { cargo, sysroot } => {\n-                cargo.packages().len() + sysroot.crates().len()\n+            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => {\n+                let rustc_package_len = rustc.as_ref().map(|rc| rc.packages().len()).unwrap_or(0);\n+                dbg!(rustc_package_len);\n+                cargo.packages().len() + sysroot.crates().len() + rustc_package_len\n             }\n         }\n     }\n@@ -365,58 +396,96 @@ impl ProjectWorkspace {\n                     }\n                 }\n             }\n-            ProjectWorkspace::Cargo { cargo, sysroot } => {\n+            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => {\n                 let (public_deps, libproc_macro) =\n                     sysroot_to_crate_graph(&mut crate_graph, sysroot, target, load);\n \n                 let mut cfg_options = CfgOptions::default();\n                 cfg_options.extend(get_rustc_cfg_options(target));\n \n                 let mut pkg_to_lib_crate = FxHashMap::default();\n-                let mut pkg_crates = FxHashMap::default();\n \n                 // Add test cfg for non-sysroot crates\n                 cfg_options.insert_atom(\"test\".into());\n                 cfg_options.insert_atom(\"debug_assertions\".into());\n \n+                let mut rustc_pkg_crates = FxHashMap::default();\n+\n+                // Add crate roots for rustc_private libs if a path to source is provided\n+                if let Some(rustc_workspace) = rustc {\n+                    for pkg in rustc_workspace.packages() {\n+                        for &tgt in rustc_workspace[pkg].targets.iter() {\n+                            if rustc_workspace[tgt].kind != TargetKind::Lib {\n+                                continue;\n+                            }\n+                            // Exclude alloc / core / std\n+                            if rustc_workspace[tgt]\n+                                .root\n+                                .components()\n+                                .any(|c| c == Component::Normal(\"library\".as_ref()))\n+                            {\n+                                continue;\n+                            }\n+\n+                            if let Some(crate_id) = add_target_crate_root(\n+                                &mut crate_graph,\n+                                &rustc_workspace[pkg],\n+                                &rustc_workspace[tgt],\n+                                &cfg_options,\n+                                proc_macro_client,\n+                                load,\n+                            ) {\n+                                pkg_to_lib_crate.insert(pkg, crate_id);\n+                                // Add dependencies on the core / std / alloc for rustc\n+                                for (name, krate) in public_deps.iter() {\n+                                    if let Err(_) =\n+                                        crate_graph.add_dep(crate_id, name.clone(), *krate)\n+                                    {\n+                                        log::error!(\n+                                            \"cyclic dependency on {} for {}\",\n+                                            name,\n+                                            &cargo[pkg].name\n+                                        )\n+                                    }\n+                                }\n+                                rustc_pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n+                            }\n+                        }\n+                    }\n+                    // Now add a dep edge from all targets of upstream to the lib\n+                    // target of downstream.\n+                    for pkg in rustc_workspace.packages() {\n+                        for dep in rustc_workspace[pkg].dependencies.iter() {\n+                            let name = CrateName::new(&dep.name).unwrap();\n+                            if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n+                                for &from in rustc_pkg_crates.get(&pkg).into_iter().flatten() {\n+                                    if let Err(_) = crate_graph.add_dep(from, name.clone(), to) {\n+                                        log::error!(\n+                                            \"cyclic dependency {} -> {}\",\n+                                            &rustc_workspace[pkg].name,\n+                                            &rustc_workspace[dep.pkg].name\n+                                        )\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                };\n+\n+                let mut pkg_crates = FxHashMap::default();\n+\n                 // Next, create crates for each package, target pair\n                 for pkg in cargo.packages() {\n                     let mut lib_tgt = None;\n                     for &tgt in cargo[pkg].targets.iter() {\n-                        let root = cargo[tgt].root.as_path();\n-                        if let Some(file_id) = load(root) {\n-                            let edition = cargo[pkg].edition;\n-                            let cfg_options = {\n-                                let mut opts = cfg_options.clone();\n-                                for feature in cargo[pkg].features.iter() {\n-                                    opts.insert_key_value(\"feature\".into(), feature.into());\n-                                }\n-                                opts.extend(cargo[pkg].cfgs.iter().cloned());\n-                                opts\n-                            };\n-                            let mut env = Env::default();\n-                            if let Some(out_dir) = &cargo[pkg].out_dir {\n-                                // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n-                                if let Some(out_dir) = out_dir.to_str().map(|s| s.to_owned()) {\n-                                    env.set(\"OUT_DIR\", out_dir);\n-                                }\n-                            }\n-                            let proc_macro = cargo[pkg]\n-                                .proc_macro_dylib_path\n-                                .as_ref()\n-                                .map(|it| proc_macro_client.by_dylib_path(&it))\n-                                .unwrap_or_default();\n-\n-                            let display_name =\n-                                CrateDisplayName::from_canonical_name(cargo[pkg].name.clone());\n-                            let crate_id = crate_graph.add_crate_root(\n-                                file_id,\n-                                edition,\n-                                Some(display_name),\n-                                cfg_options,\n-                                env,\n-                                proc_macro.clone(),\n-                            );\n+                        if let Some(crate_id) = add_target_crate_root(\n+                            &mut crate_graph,\n+                            &cargo[pkg],\n+                            &cargo[tgt],\n+                            &cfg_options,\n+                            proc_macro_client,\n+                            load,\n+                        ) {\n                             if cargo[tgt].kind == TargetKind::Lib {\n                                 lib_tgt = Some((crate_id, cargo[tgt].name.clone()));\n                                 pkg_to_lib_crate.insert(pkg, crate_id);\n@@ -466,6 +535,30 @@ impl ProjectWorkspace {\n                     }\n                 }\n \n+                // If we have access to the rust sources, create dependencies onto rustc_private libraries from all targets\n+                // that are members of the current workspace\n+                if let Some(rustc_workspace) = rustc {\n+                    for dep in rustc_workspace.packages() {\n+                        let name = CrateName::normalize_dashes(&rustc_workspace[dep].name);\n+\n+                        if let Some(&from) = pkg_to_lib_crate.get(&dep) {\n+                            for pkg in cargo.packages() {\n+                                if !cargo[pkg].is_member {\n+                                    continue;\n+                                }\n+                                for &to in pkg_crates.get(&pkg).into_iter().flatten() {\n+                                    if let Err(_) = crate_graph.add_dep(to, name.clone(), from) {\n+                                        log::error!(\n+                                            \"cyclic dependency22 {} -> {}\",\n+                                            &cargo[pkg].name,\n+                                            &rustc_workspace[dep].name\n+                                        )\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n                 // Now add a dep edge from all targets of upstream to the lib\n                 // target of downstream.\n                 for pkg in cargo.packages() {\n@@ -537,6 +630,52 @@ fn utf8_stdout(mut cmd: Command) -> Result<String> {\n     Ok(stdout.trim().to_string())\n }\n \n+fn add_target_crate_root(\n+    crate_graph: &mut CrateGraph,\n+    pkg: &cargo_workspace::PackageData,\n+    tgt: &cargo_workspace::TargetData,\n+    cfg_options: &CfgOptions,\n+    proc_macro_client: &ProcMacroClient,\n+    load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n+) -> Option<CrateId> {\n+    let root = tgt.root.as_path();\n+    if let Some(file_id) = load(root) {\n+        let edition = pkg.edition;\n+        let cfg_options = {\n+            let mut opts = cfg_options.clone();\n+            for feature in pkg.features.iter() {\n+                opts.insert_key_value(\"feature\".into(), feature.into());\n+            }\n+            opts.extend(pkg.cfgs.iter().cloned());\n+            opts\n+        };\n+        let mut env = Env::default();\n+        if let Some(out_dir) = &pkg.out_dir {\n+            // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n+            if let Some(out_dir) = out_dir.to_str().map(|s| s.to_owned()) {\n+                env.set(\"OUT_DIR\", out_dir);\n+            }\n+        }\n+        let proc_macro = pkg\n+            .proc_macro_dylib_path\n+            .as_ref()\n+            .map(|it| proc_macro_client.by_dylib_path(&it))\n+            .unwrap_or_default();\n+\n+        let display_name = CrateDisplayName::from_canonical_name(pkg.name.clone());\n+        let crate_id = crate_graph.add_crate_root(\n+            file_id,\n+            edition,\n+            Some(display_name),\n+            cfg_options,\n+            env,\n+            proc_macro.clone(),\n+        );\n+\n+        return Some(crate_id);\n+    }\n+    None\n+}\n fn sysroot_to_crate_graph(\n     crate_graph: &mut CrateGraph,\n     sysroot: &Sysroot,"}, {"sha": "372180ab58c11493b005e9aa80d177a02de8575d", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/871608791934f81cdd430797fdd64a8f9da19074/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871608791934f81cdd430797fdd64a8f9da19074/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=871608791934f81cdd430797fdd64a8f9da19074", "patch": "@@ -7,7 +7,7 @@\n //! configure the server itself, feature flags are passed into analysis, and\n //! tweak things like automatic insertion of `()` in completions.\n \n-use std::{ffi::OsString, path::PathBuf};\n+use std::{convert::TryFrom, ffi::OsString, path::PathBuf};\n \n use flycheck::FlycheckConfig;\n use hir::PrefixKind;\n@@ -227,12 +227,25 @@ impl Config {\n         self.notifications =\n             NotificationsConfig { cargo_toml_not_found: data.notifications_cargoTomlNotFound };\n         self.cargo_autoreload = data.cargo_autoreload;\n+\n+        let rustc_source = if let Some(rustc_source) = data.rustcSource {\n+            let rustpath: PathBuf = rustc_source.into();\n+            AbsPathBuf::try_from(rustpath)\n+                .map_err(|_| {\n+                    log::error!(\"rustc source directory must be an absolute path\");\n+                })\n+                .ok()\n+        } else {\n+            None\n+        };\n+\n         self.cargo = CargoConfig {\n             no_default_features: data.cargo_noDefaultFeatures,\n             all_features: data.cargo_allFeatures,\n             features: data.cargo_features.clone(),\n             load_out_dirs_from_check: data.cargo_loadOutDirsFromCheck,\n             target: data.cargo_target.clone(),\n+            rustc_source: rustc_source,\n         };\n         self.runnables = RunnablesConfig {\n             override_cargo: data.runnables_overrideCargo,\n@@ -532,5 +545,6 @@ config_data! {\n         rustfmt_overrideCommand: Option<Vec<String>> = None,\n \n         withSysroot: bool = true,\n+        rustcSource : Option<String> = None,\n     }\n }"}, {"sha": "11c8d0e5f8c901d586f8bc77131f4dd6ac234668", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/871608791934f81cdd430797fdd64a8f9da19074/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/871608791934f81cdd430797fdd64a8f9da19074/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=871608791934f81cdd430797fdd64a8f9da19074", "patch": "@@ -246,7 +246,9 @@ impl GlobalState {\n             .iter()\n             .enumerate()\n             .filter_map(|(id, w)| match w {\n-                ProjectWorkspace::Cargo { cargo, sysroot: _ } => Some((id, cargo.workspace_root())),\n+                ProjectWorkspace::Cargo { cargo, sysroot: _, rustc: _ } => {\n+                    Some((id, cargo.workspace_root()))\n+                }\n                 ProjectWorkspace::Json { project, .. } => {\n                     // Enable flychecks for json projects if a custom flycheck command was supplied\n                     // in the workspace configuration."}, {"sha": "d6d85b86c1f4c7ef0fd5b90fcf077b9139ce8847", "filename": "editors/code/package-lock.json", "status": "modified", "additions": 3375, "deletions": 10, "changes": 3385, "blob_url": "https://github.com/rust-lang/rust/blob/871608791934f81cdd430797fdd64a8f9da19074/editors%2Fcode%2Fpackage-lock.json", "raw_url": "https://github.com/rust-lang/rust/raw/871608791934f81cdd430797fdd64a8f9da19074/editors%2Fcode%2Fpackage-lock.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage-lock.json?ref=871608791934f81cdd430797fdd64a8f9da19074"}, {"sha": "a6eeae2b53c16f454a89983971dc497bd7e1d331", "filename": "editors/code/package.json", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/871608791934f81cdd430797fdd64a8f9da19074/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/871608791934f81cdd430797fdd64a8f9da19074/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=871608791934f81cdd430797fdd64a8f9da19074", "patch": "@@ -687,6 +687,12 @@\n                     },\n                     \"default\": [],\n                     \"description\": \"Additional arguments to be passed to cargo for runnables such as tests or binaries.\\nFor example, it may be '--release'\"\n+                },\n+                \"rust-analyzer.rustcSource\" : {\n+                    \"type\": [ \"null\", \"string\" ],\n+                    \"default\": null,\n+                    \"description\": \"Path to the rust compiler sources, for usage in rustc_private projects.\"\n+\n                 }\n             }\n         },"}]}