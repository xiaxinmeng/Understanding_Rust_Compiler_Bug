{"sha": "575ea18d4642380a8ace0afe27d528bb47a9f310", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3NWVhMThkNDY0MjM4MGE4YWNlMGFmZTI3ZDUyOGJiNDdhOWYzMTA=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-08-07T16:22:24Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-08-09T08:18:02Z"}, "message": "pretty-printer: let users choose particular items to pretty print.\n\nWith this change:\n\n  * `--pretty variant=<node-id>` will print the item associated with\n    `<node-id>` (where `<node-id>` is an integer for some node-id in\n    the AST, and `variant` means one of {`normal`,`expanded`,...}).\n\n  * `--pretty variant=<path-suffix>` will print all of the items that\n    match the `<path-suffix>` (where `<path-suffix>` is a suffix of a\n    path, and `variant` again means one of {`normal`,`expanded`,...}).\n\n    Example 1: the suffix `typeck::check::check_struct` matches the\n    item with the path `rustc::middle::typeck::check::check_struct`\n    when compiling the `rustc` crate.\n\n    Example 2: the suffix `and` matches `core::option::Option::and`\n    and `core::result::Result::and` when compiling the `core` crate.\n\nBoth of the `--pretty variant=...` modes will include the full path to\nthe item in a comment that follows the item.\n\nNote that when multiple paths match, then either:\n\n  1. all matching items are printed, in series; this is what happens in\n     the usual pretty-print variants, or\n\n  2. the compiler signals an error; this is what happens in flowgraph\n     printing.\n\n----\n\nSome drive-by improvements:\n\nHeavily refactored the pretty-printing glue in driver.rs, introducing\na couple local traits to avoid cut-and-pasting very code segments that\ndiffered only in how they accessed the `Session` or the\n`ast_map::Map`. (Note the previous code had three similar calls to\n`print_crate` which have all been unified in this revision; the\naddition of printing individual node-ids exacerbated the situation\nbeyond tolerance.) We may want to consider promoting some of these\ntraits, e.g. `SessionCarrier`, for use more generally elsewhere in the\ncompiler; right now I have to double check how to access the `Session`\ndepending on what context I am hacking in.\n\nRefactored `PpMode` to make the data directly reflect the fundamental\ndifference in the categories (in terms of printing source-code with\nvarious annotations, versus printing a control-flow graph).\n\n(also, addressed review feedback.)", "tree": {"sha": "b3587a7dacb4608c138022ad8ba0d1e9a89793ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3587a7dacb4608c138022ad8ba0d1e9a89793ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/575ea18d4642380a8ace0afe27d528bb47a9f310", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/575ea18d4642380a8ace0afe27d528bb47a9f310", "html_url": "https://github.com/rust-lang/rust/commit/575ea18d4642380a8ace0afe27d528bb47a9f310", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/575ea18d4642380a8ace0afe27d528bb47a9f310/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a80e0fdab93cb6fb9eeb592857b8eeb35d14f15", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a80e0fdab93cb6fb9eeb592857b8eeb35d14f15", "html_url": "https://github.com/rust-lang/rust/commit/8a80e0fdab93cb6fb9eeb592857b8eeb35d14f15"}], "stats": {"total": 394, "additions": 319, "deletions": 75}, "files": [{"sha": "477fc5e1c0f30374080c2e2d3564e31d8c17ff98", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 297, "deletions": 52, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/575ea18d4642380a8ace0afe27d528bb47a9f310/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/575ea18d4642380a8ace0afe27d528bb47a9f310/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=575ea18d4642380a8ace0afe27d528bb47a9f310", "patch": "@@ -11,9 +11,9 @@\n \n use back::link;\n use driver::session::Session;\n-use driver::{config, PpMode};\n+use driver::{config, PpMode, PpSourceMode};\n use driver::{PpmFlowGraph, PpmExpanded, PpmExpandedIdentified, PpmTyped};\n-use driver::{PpmIdentified};\n+use driver::{PpmIdentified, PpmNormal, PpmSource};\n use front;\n use lint;\n use llvm::{ContextRef, ModuleRef};\n@@ -39,11 +39,15 @@ use dot = graphviz;\n \n use serialize::{json, Encodable};\n \n+use std::from_str::FromStr;\n use std::io;\n use std::io::fs;\n use std::io::MemReader;\n+use std::option;\n use syntax::ast;\n+use syntax::ast_map;\n use syntax::ast_map::blocks;\n+use syntax::ast_map::NodePrinter;\n use syntax::attr;\n use syntax::attr::{AttrMetaMethods};\n use syntax::diagnostics;\n@@ -602,7 +606,90 @@ fn write_out_deps(sess: &Session,\n     }\n }\n \n-struct IdentifiedAnnotation;\n+// This slightly awkward construction is to allow for each PpMode to\n+// choose whether it needs to do analyses (which can consume the\n+// Session) and then pass through the session (now attached to the\n+// analysis results) on to the chosen pretty-printer, along with the\n+// `&PpAnn` object.\n+//\n+// Note that since the `&PrinterSupport` is freshly constructed on each\n+// call, it would not make sense to try to attach the lifetime of `self`\n+// to the lifetime of the `&PrinterObject`.\n+//\n+// (The `use_once_payload` is working around the current lack of once\n+// functions in the compiler.)\n+trait CratePrinter {\n+    /// Constructs a `PrinterSupport` object and passes it to `f`.\n+    fn call_with_pp_support<A,B>(&self,\n+                                 sess: Session,\n+                                 krate: &ast::Crate,\n+                                 ast_map: Option<syntax::ast_map::Map>,\n+                                 id: String,\n+                                 use_once_payload: B,\n+                                 f: |&PrinterSupport, B| -> A) -> A;\n+}\n+\n+trait SessionCarrier {\n+    /// Provides a uniform interface for re-extracting a reference to a\n+    /// `Session` from a value that now owns it.\n+    fn sess<'a>(&'a self) -> &'a Session;\n+}\n+\n+trait AstMapCarrier {\n+    /// Provides a uniform interface for re-extracting a reference to an\n+    /// `ast_map::Map` from a value that now owns it.\n+    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map>;\n+}\n+\n+trait PrinterSupport : SessionCarrier + AstMapCarrier {\n+    /// Produces the pretty-print annotation object.\n+    ///\n+    /// Usually implemented via `self as &pprust::PpAnn`.\n+    ///\n+    /// (Rust does not yet support upcasting from a trait object to\n+    /// an object for one of its super-traits.)\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn;\n+}\n+\n+struct NoAnn {\n+    sess: Session,\n+    ast_map: Option<ast_map::Map>,\n+}\n+\n+impl PrinterSupport for NoAnn {\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n+}\n+\n+impl SessionCarrier for NoAnn {\n+    fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n+}\n+\n+impl AstMapCarrier for NoAnn {\n+    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map> {\n+        self.ast_map.as_ref()\n+    }\n+}\n+\n+impl pprust::PpAnn for NoAnn {}\n+\n+struct IdentifiedAnnotation {\n+    sess: Session,\n+    ast_map: Option<ast_map::Map>,\n+}\n+\n+impl PrinterSupport for IdentifiedAnnotation {\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n+}\n+\n+impl SessionCarrier for IdentifiedAnnotation {\n+    fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n+}\n+\n+impl AstMapCarrier for IdentifiedAnnotation {\n+    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map> {\n+        self.ast_map.as_ref()\n+    }\n+}\n \n impl pprust::PpAnn for IdentifiedAnnotation {\n     fn pre(&self,\n@@ -642,6 +729,20 @@ struct TypedAnnotation {\n     analysis: CrateAnalysis,\n }\n \n+impl PrinterSupport for TypedAnnotation {\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n+}\n+\n+impl SessionCarrier for TypedAnnotation {\n+    fn sess<'a>(&'a self) -> &'a Session { &self.analysis.ty_cx.sess }\n+}\n+\n+impl AstMapCarrier for TypedAnnotation {\n+    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map> {\n+        Some(&self.analysis.ty_cx.map)\n+    }\n+}\n+\n impl pprust::PpAnn for TypedAnnotation {\n     fn pre(&self,\n            s: &mut pprust::State,\n@@ -690,25 +791,155 @@ fn gather_flowgraph_variants(sess: &Session) -> Vec<borrowck_dot::Variant> {\n     variants\n }\n \n+#[deriving(Clone, Show)]\n+pub enum UserIdentifiedItem {\n+    ItemViaNode(ast::NodeId),\n+    ItemViaPath(Vec<String>),\n+}\n+\n+impl FromStr for UserIdentifiedItem {\n+    fn from_str(s: &str) -> Option<UserIdentifiedItem> {\n+        let extract_path_parts = || {\n+            let v : Vec<_> = s.split_str(\"::\")\n+                .map(|x|x.to_string())\n+                .collect();\n+            Some(ItemViaPath(v))\n+        };\n+\n+        from_str(s).map(ItemViaNode).or_else(extract_path_parts)\n+    }\n+}\n+\n+enum NodesMatchingUII<'a> {\n+    NodesMatchingDirect(option::Item<ast::NodeId>),\n+    NodesMatchingSuffix(ast_map::NodesMatchingSuffix<'a, String>),\n+}\n+\n+impl<'a> Iterator<ast::NodeId> for NodesMatchingUII<'a> {\n+    fn next(&mut self) -> Option<ast::NodeId> {\n+        match self {\n+            &NodesMatchingDirect(ref mut iter) => iter.next(),\n+            &NodesMatchingSuffix(ref mut iter) => iter.next(),\n+        }\n+    }\n+}\n+\n+impl UserIdentifiedItem {\n+    fn reconstructed_input(&self) -> String {\n+        match *self {\n+            ItemViaNode(node_id) => node_id.to_string(),\n+            ItemViaPath(ref parts) => parts.connect(\"::\"),\n+        }\n+    }\n+\n+    fn all_matching_node_ids<'a>(&'a self, map: &'a ast_map::Map) -> NodesMatchingUII<'a> {\n+        match *self {\n+            ItemViaNode(node_id) =>\n+                NodesMatchingDirect(Some(node_id).move_iter()),\n+            ItemViaPath(ref parts) =>\n+                NodesMatchingSuffix(map.nodes_matching_suffix(parts.as_slice())),\n+        }\n+    }\n+\n+    fn to_one_node_id(self, user_option: &str, sess: &Session, map: &ast_map::Map) -> ast::NodeId {\n+        let fail_because = |is_wrong_because| -> ast::NodeId {\n+            let message =\n+                format!(\"{:s} needs NodeId (int) or unique \\\n+                         path suffix (b::c::d); got {:s}, which {:s}\",\n+                        user_option,\n+                        self.reconstructed_input(),\n+                        is_wrong_because);\n+            sess.fatal(message.as_slice())\n+        };\n+\n+        let mut saw_node = ast::DUMMY_NODE_ID;\n+        let mut seen = 0u;\n+        for node in self.all_matching_node_ids(map) {\n+            saw_node = node;\n+            seen += 1;\n+            if seen > 1 {\n+                fail_because(\"does not resolve uniquely\");\n+            }\n+        }\n+        if seen == 0 {\n+            fail_because(\"does not resolve to any item\");\n+        }\n+\n+        assert!(seen == 1);\n+        return saw_node;\n+    }\n+}\n+\n+impl CratePrinter for PpSourceMode {\n+    fn call_with_pp_support<A,B>(&self,\n+                                 sess: Session,\n+                                 krate: &ast::Crate,\n+                                 ast_map: Option<syntax::ast_map::Map>,\n+                                 id: String,\n+                                 payload: B,\n+                                 f: |&PrinterSupport, B| -> A) -> A {\n+        match *self {\n+            PpmNormal | PpmExpanded => {\n+                let annotation = NoAnn { sess: sess, ast_map: ast_map };\n+                f(&annotation, payload)\n+            }\n+\n+            PpmIdentified | PpmExpandedIdentified => {\n+                let annotation = IdentifiedAnnotation { sess: sess, ast_map: ast_map };\n+                f(&annotation, payload)\n+            }\n+            PpmTyped => {\n+                let ast_map = ast_map.expect(\"--pretty=typed missing ast_map\");\n+                let analysis = phase_3_run_analysis_passes(sess, krate, ast_map, id);\n+                let annotation = TypedAnnotation { analysis: analysis };\n+                f(&annotation, payload)\n+            }\n+        }\n+    }\n+}\n+\n+fn needs_ast_map(ppm: &PpMode, opt_uii: &Option<UserIdentifiedItem>) -> bool {\n+    match *ppm {\n+        PpmSource(PpmNormal) |\n+        PpmSource(PpmIdentified) => opt_uii.is_some(),\n+\n+        PpmSource(PpmExpanded) |\n+        PpmSource(PpmExpandedIdentified) |\n+        PpmSource(PpmTyped) |\n+        PpmFlowGraph => true\n+    }\n+}\n+\n+fn needs_expansion(ppm: &PpMode) -> bool {\n+    match *ppm {\n+        PpmSource(PpmNormal) |\n+        PpmSource(PpmIdentified) => false,\n+\n+        PpmSource(PpmExpanded) |\n+        PpmSource(PpmExpandedIdentified) |\n+        PpmSource(PpmTyped) |\n+        PpmFlowGraph => true\n+    }\n+}\n pub fn pretty_print_input(sess: Session,\n                           cfg: ast::CrateConfig,\n                           input: &Input,\n                           ppm: PpMode,\n+                          opt_uii: Option<UserIdentifiedItem>,\n                           ofile: Option<Path>) {\n     let krate = phase_1_parse_input(&sess, cfg, input);\n     let id = link::find_crate_name(Some(&sess), krate.attrs.as_slice(), input);\n \n-    let (krate, ast_map, is_expanded) = match ppm {\n-        PpmExpanded | PpmExpandedIdentified | PpmTyped | PpmFlowGraph(_) => {\n-            let (krate, ast_map)\n-                = match phase_2_configure_and_expand(&sess, krate,\n-                                                     id.as_slice(), None) {\n-                    None => return,\n-                    Some(p) => p,\n-                };\n-            (krate, Some(ast_map), true)\n-        }\n-        _ => (krate, None, false)\n+    let is_expanded = needs_expansion(&ppm);\n+    let (krate, ast_map) = if needs_ast_map(&ppm, &opt_uii) {\n+        let k = phase_2_configure_and_expand(&sess, krate, id.as_slice(), None);\n+        let (krate, ast_map) = match k {\n+            None => return,\n+            Some(p) => p,\n+        };\n+        (krate, Some(ast_map))\n+    } else {\n+        (krate, None)\n     };\n \n     let src_name = source_name(input);\n@@ -729,38 +960,63 @@ pub fn pretty_print_input(sess: Session,\n             }\n         }\n     };\n-    match ppm {\n-        PpmIdentified | PpmExpandedIdentified => {\n-            pprust::print_crate(sess.codemap(),\n-                                sess.diagnostic(),\n-                                &krate,\n-                                src_name.to_string(),\n-                                &mut rdr,\n-                                out,\n-                                &IdentifiedAnnotation,\n-                                is_expanded)\n-        }\n-        PpmTyped => {\n-            let ast_map = ast_map.expect(\"--pretty=typed missing ast_map\");\n-            let analysis = phase_3_run_analysis_passes(sess, &krate, ast_map, id);\n-            let annotation = TypedAnnotation {\n-                analysis: analysis\n-            };\n-            pprust::print_crate(annotation.analysis.ty_cx.sess.codemap(),\n-                                annotation.analysis.ty_cx.sess.diagnostic(),\n-                                &krate,\n-                                src_name.to_string(),\n-                                &mut rdr,\n-                                out,\n-                                &annotation,\n-                                is_expanded)\n-        }\n-        PpmFlowGraph(nodeid) => {\n+\n+    match (ppm, opt_uii) {\n+        (PpmSource(s), None) =>\n+            s.call_with_pp_support(\n+                sess, &krate, ast_map, id, out, |annotation, out| {\n+                    debug!(\"pretty printing source code {}\", s);\n+                    let sess = annotation.sess();\n+                    pprust::print_crate(sess.codemap(),\n+                                        sess.diagnostic(),\n+                                        &krate,\n+                                        src_name.to_string(),\n+                                        &mut rdr,\n+                                        out,\n+                                        annotation.pp_ann(),\n+                                        is_expanded)\n+                }),\n+\n+        (PpmSource(s), Some(uii)) =>\n+            s.call_with_pp_support(\n+                sess, &krate, ast_map, id, (out,uii), |annotation, (out,uii)| {\n+                    debug!(\"pretty printing source code {}\", s);\n+                    let sess = annotation.sess();\n+                    let ast_map = annotation.ast_map()\n+                        .expect(\"--pretty missing ast_map\");\n+                    let mut pp_state =\n+                        pprust::State::new_from_input(sess.codemap(),\n+                                                      sess.diagnostic(),\n+                                                      src_name.to_string(),\n+                                                      &mut rdr,\n+                                                      out,\n+                                                      annotation.pp_ann(),\n+                                                      is_expanded);\n+                    for node_id in uii.all_matching_node_ids(ast_map) {\n+                        let node = ast_map.get(node_id);\n+                        try!(pp_state.print_node(&node));\n+                        try!(pp::space(&mut pp_state.s));\n+                        try!(pp_state.synth_comment(ast_map.path_to_string(node_id)));\n+                        try!(pp::hardbreak(&mut pp_state.s));\n+                    }\n+                    pp::eof(&mut pp_state.s)\n+                }),\n+\n+        (PpmFlowGraph, opt_uii) => {\n+            debug!(\"pretty printing flow graph for {}\", opt_uii);\n+            let uii = opt_uii.unwrap_or_else(|| {\n+                sess.fatal(format!(\"`pretty flowgraph=..` needs NodeId (int) or\n+                                     unique path suffix (b::c::d)\").as_slice())\n+\n+            });\n             let ast_map = ast_map.expect(\"--pretty flowgraph missing ast_map\");\n+            let nodeid = uii.to_one_node_id(\"--pretty\", &sess, &ast_map);\n+\n             let node = ast_map.find(nodeid).unwrap_or_else(|| {\n                 sess.fatal(format!(\"--pretty flowgraph couldn't find id: {}\",\n                                    nodeid).as_slice())\n             });\n+\n             let code = blocks::Code::from_node(node);\n             match code {\n                 Some(code) => {\n@@ -783,18 +1039,7 @@ pub fn pretty_print_input(sess: Session,\n                 }\n             }\n         }\n-        _ => {\n-            pprust::print_crate(sess.codemap(),\n-                                sess.diagnostic(),\n-                                &krate,\n-                                src_name.to_string(),\n-                                &mut rdr,\n-                                out,\n-                                &pprust::NoAnn,\n-                                is_expanded)\n-        }\n     }.unwrap()\n-\n }\n \n fn print_flowgraph<W:io::Writer>(variants: Vec<borrowck_dot::Variant>,"}, {"sha": "05762aa3db2762c709cc8570e48342374ec36218", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/575ea18d4642380a8ace0afe27d528bb47a9f310/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/575ea18d4642380a8ace0afe27d528bb47a9f310/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=575ea18d4642380a8ace0afe27d528bb47a9f310", "patch": "@@ -99,11 +99,11 @@ fn run_compiler(args: &[String]) {\n         parse_pretty(&sess, a.as_slice())\n     });\n     match pretty {\n-        Some::<PpMode>(ppm) => {\n-            driver::pretty_print_input(sess, cfg, &input, ppm, ofile);\n+        Some((ppm, opt_uii)) => {\n+            driver::pretty_print_input(sess, cfg, &input, ppm, opt_uii, ofile);\n             return;\n         }\n-        None::<PpMode> => {/* continue */ }\n+        None => {/* continue */ }\n     }\n \n     let r = matches.opt_strs(\"Z\");\n@@ -340,42 +340,41 @@ fn print_crate_info(sess: &Session,\n     }\n }\n \n-pub enum PpMode {\n+#[deriving(PartialEq, Show)]\n+pub enum PpSourceMode {\n     PpmNormal,\n     PpmExpanded,\n     PpmTyped,\n     PpmIdentified,\n     PpmExpandedIdentified,\n-    PpmFlowGraph(ast::NodeId),\n }\n \n-pub fn parse_pretty(sess: &Session, name: &str) -> PpMode {\n+#[deriving(PartialEq, Show)]\n+pub enum PpMode {\n+    PpmSource(PpSourceMode),\n+    PpmFlowGraph,\n+}\n+\n+fn parse_pretty(sess: &Session, name: &str) -> (PpMode, Option<driver::UserIdentifiedItem>) {\n     let mut split = name.splitn('=', 1);\n     let first = split.next().unwrap();\n     let opt_second = split.next();\n-    match (opt_second, first) {\n-        (None, \"normal\")       => PpmNormal,\n-        (None, \"expanded\")     => PpmExpanded,\n-        (None, \"typed\")        => PpmTyped,\n-        (None, \"expanded,identified\") => PpmExpandedIdentified,\n-        (None, \"identified\")   => PpmIdentified,\n-        (arg, \"flowgraph\") => {\n-             match arg.and_then(from_str) {\n-                 Some(id) => PpmFlowGraph(id),\n-                 None => {\n-                     sess.fatal(format!(\"`pretty flowgraph=<nodeid>` needs \\\n-                                         an integer <nodeid>; got {}\",\n-                                        arg.unwrap_or(\"nothing\")).as_slice())\n-                 }\n-             }\n-        }\n+    let first = match first {\n+        \"normal\"       => PpmSource(PpmNormal),\n+        \"expanded\"     => PpmSource(PpmExpanded),\n+        \"typed\"        => PpmSource(PpmTyped),\n+        \"expanded,identified\" => PpmSource(PpmExpandedIdentified),\n+        \"identified\"   => PpmSource(PpmIdentified),\n+        \"flowgraph\"    => PpmFlowGraph,\n         _ => {\n             sess.fatal(format!(\n                 \"argument to `pretty` must be one of `normal`, \\\n                  `expanded`, `flowgraph=<nodeid>`, `typed`, `identified`, \\\n                  or `expanded,identified`; got {}\", name).as_slice());\n         }\n-    }\n+    };\n+    let opt_second = opt_second.and_then::<driver::UserIdentifiedItem>(from_str);\n+    (first, opt_second)\n }\n \n fn parse_crate_attrs(sess: &Session, input: &Input) ->"}]}