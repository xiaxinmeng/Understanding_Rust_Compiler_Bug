{"sha": "a641996796f0ab11021671c0ce70a3c975bb4e37", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2NDE5OTY3OTZmMGFiMTEwMjE2NzFjMGNlNzBhM2M5NzViYjRlMzc=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2015-02-17T22:47:08Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2015-02-19T23:58:07Z"}, "message": "Fix tidy and rebase fallout\n\nAdded a few bugfixes and additional testcases", "tree": {"sha": "5724986b305b79e56e25603688f8f62a37e5838d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5724986b305b79e56e25603688f8f62a37e5838d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a641996796f0ab11021671c0ce70a3c975bb4e37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a641996796f0ab11021671c0ce70a3c975bb4e37", "html_url": "https://github.com/rust-lang/rust/commit/a641996796f0ab11021671c0ce70a3c975bb4e37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a641996796f0ab11021671c0ce70a3c975bb4e37/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1de0a0f9ea9863407363ce31bb698e9988215ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1de0a0f9ea9863407363ce31bb698e9988215ee", "html_url": "https://github.com/rust-lang/rust/commit/c1de0a0f9ea9863407363ce31bb698e9988215ee"}], "stats": {"total": 221, "additions": 171, "deletions": 50}, "files": [{"sha": "e86cf462cab9c23902fab432cb53fe78f472a74e", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a641996796f0ab11021671c0ce70a3c975bb4e37/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a641996796f0ab11021671c0ce70a3c975bb4e37/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=a641996796f0ab11021671c0ce70a3c975bb4e37", "patch": "@@ -2893,22 +2893,6 @@ mod bench {\n         b.iter(|| assert_eq!(s.split('V').count(), 3));\n     }\n \n-    #[bench]\n-    fn split_unicode_not_ascii(b: &mut Bencher) {\n-        struct NotAscii(char);\n-        impl CharEq for NotAscii {\n-            fn matches(&mut self, c: char) -> bool {\n-                let NotAscii(cc) = *self;\n-                cc == c\n-            }\n-            fn only_ascii(&self) -> bool { false }\n-        }\n-        let s = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-\n-        b.iter(|| assert_eq!(s.split(NotAscii('V')).count(), 3));\n-    }\n-\n-\n     #[bench]\n     fn split_ascii(b: &mut Bencher) {\n         let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n@@ -2917,23 +2901,6 @@ mod bench {\n         b.iter(|| assert_eq!(s.split(' ').count(), len));\n     }\n \n-    #[bench]\n-    fn split_not_ascii(b: &mut Bencher) {\n-        struct NotAscii(char);\n-        impl CharEq for NotAscii {\n-            #[inline]\n-            fn matches(&mut self, c: char) -> bool {\n-                let NotAscii(cc) = *self;\n-                cc == c\n-            }\n-            fn only_ascii(&self) -> bool { false }\n-        }\n-        let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n-        let len = s.split(' ').count();\n-\n-        b.iter(|| assert_eq!(s.split(NotAscii(' ')).count(), len));\n-    }\n-\n     #[bench]\n     fn split_extern_fn(b: &mut Bencher) {\n         let s = \"Mary had a little lamb, Little lamb, little-lamb.\";"}, {"sha": "820ad4d8586ada18474e4ae674f9d46ffef30225", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a641996796f0ab11021671c0ce70a3c975bb4e37/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a641996796f0ab11021671c0ce70a3c975bb4e37/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=a641996796f0ab11021671c0ce70a3c975bb4e37", "patch": "@@ -156,7 +156,6 @@ impl FromStr for bool {\n \n /// An error returned when parsing a `bool` from a string fails.\n #[derive(Debug, Clone, PartialEq)]\n-#[allow(missing_copy_implementations)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ParseBoolError { _priv: () }\n \n@@ -235,7 +234,7 @@ pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n pub unsafe fn from_c_str(s: *const i8) -> &'static str {\n     let s = s as *const u8;\n     let mut len = 0;\n-    while *s.offset(len as int) != 0 {\n+    while *s.offset(len as isize) != 0 {\n         len += 1;\n     }\n     let v: &'static [u8] = ::mem::transmute(Slice { data: s, len: len });\n@@ -258,7 +257,7 @@ impl CharEq for char {\n     fn matches(&mut self, c: char) -> bool { *self == c }\n \n     #[inline]\n-    fn only_ascii(&self) -> bool { (*self as usize) < 128 }\n+    fn only_ascii(&self) -> bool { (*self as u32) < 128 }\n }\n \n impl<F> CharEq for F where F: FnMut(char) -> bool {\n@@ -764,7 +763,8 @@ impl TwoWaySearcher {\n     // How far we can jump when we encounter a mismatch is all based on the fact\n     // that (u, v) is a critical factorization for the needle.\n     #[inline]\n-    fn next(&mut self, haystack: &[u8], needle: &[u8], long_period: bool) -> Option<(usize, usize)> {\n+    fn next(&mut self, haystack: &[u8], needle: &[u8], long_period: bool)\n+    -> Option<(usize, usize)> {\n         'search: loop {\n             // Check that we have room to search in\n             if self.position + needle.len() > haystack.len() {\n@@ -955,6 +955,7 @@ Section: Comparing strings\n /// to compare &[u8] byte slices that are not necessarily valid UTF-8.\n #[inline]\n fn eq_slice_(a: &str, b: &str) -> bool {\n+    // NOTE: In theory n should be libc::size_t and not usize, but libc is not available here\n     #[allow(improper_ctypes)]\n     extern { fn memcmp(s1: *const i8, s2: *const i8, n: usize) -> i32; }\n     a.len() == b.len() && unsafe {\n@@ -1489,7 +1490,7 @@ impl StrExt for str {\n     fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n     where P::Searcher: DoubleEndedSearcher<'a> {\n         let mut i = 0;\n-        let mut j = self.len();\n+        let mut j = 0;\n         let mut matcher = pat.into_searcher(self);\n         if let Some((a, b)) = matcher.next_reject() {\n             i = a;\n@@ -1507,7 +1508,7 @@ impl StrExt for str {\n \n     #[inline]\n     fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n-        let mut i = 0;\n+        let mut i = self.len();\n         let mut matcher = pat.into_searcher(self);\n         if let Some((a, _)) = matcher.next_reject() {\n             i = a;\n@@ -1521,7 +1522,7 @@ impl StrExt for str {\n     #[inline]\n     fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n     where P::Searcher: ReverseSearcher<'a> {\n-        let mut j = self.len();\n+        let mut j = 0;\n         let mut matcher = pat.into_searcher(self);\n         if let Some((_, b)) = matcher.next_reject_back() {\n             j = b;"}, {"sha": "9cd5510db37024dadf8074d49d641b6ac9b0dc8e", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a641996796f0ab11021671c0ce70a3c975bb4e37/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a641996796f0ab11021671c0ce70a3c975bb4e37/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=a641996796f0ab11021671c0ce70a3c975bb4e37", "patch": "@@ -58,6 +58,7 @@ pub trait Pattern<'a>: Sized {\n \n // Searcher\n \n+#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n pub enum SearchStep {\n     Match(usize, usize),\n     Reject(usize, usize),\n@@ -190,7 +191,7 @@ impl<'a, C: CharEq> DoubleEndedSearcher<'a> for CharEqSearcher<'a, C> {}\n \n // Impl for &str\n \n-// TODO: Optimize the naive implementation here\n+// Todo: Optimize the naive implementation here\n \n #[derive(Clone)]\n pub struct StrSearcher<'a, 'b> {\n@@ -235,13 +236,16 @@ unsafe impl<'a, 'b> Searcher<'a> for StrSearcher<'a, 'b>  {\n         },\n         |m: &mut StrSearcher| {\n             // Forward step for nonempty needle\n-            let possible_match = &m.haystack[m.start .. m.start + m.needle.len()];\n+            // Compare if bytes are equal\n+            let possible_match = &m.haystack.as_bytes()[m.start .. m.start + m.needle.len()];\n             let current_start = m.start;\n-            if possible_match == m.needle {\n+            if possible_match == m.needle.as_bytes() {\n                 m.start += m.needle.len();\n                 SearchStep::Match(current_start, m.start)\n             } else {\n-                m.start += possible_match.chars().next().unwrap().len_utf8();\n+                // Skip a char\n+                let haystack_suffix = &m.haystack[m.start..];\n+                m.start += haystack_suffix.chars().next().unwrap().len_utf8();\n                 SearchStep::Reject(current_start, m.start)\n             }\n         })\n@@ -262,13 +266,16 @@ unsafe impl<'a, 'b> ReverseSearcher<'a> for StrSearcher<'a, 'b>  {\n         },\n         |m: &mut StrSearcher| {\n             // Backward step for nonempty needle\n-            let possible_match = &m.haystack[m.end - m.needle.len() .. m.end];\n+            // Compare if bytes are equal\n+            let possible_match = &m.haystack.as_bytes()[m.end - m.needle.len() .. m.end];\n             let current_end = m.end;\n-            if possible_match == m.needle {\n+            if possible_match == m.needle.as_bytes() {\n                 m.end -= m.needle.len();\n                 SearchStep::Match(m.end, current_end)\n             } else {\n-                m.end -= possible_match.chars().rev().next().unwrap().len_utf8();\n+                // Skip a char\n+                let haystack_prefix = &m.haystack[..m.end];\n+                m.end -= haystack_prefix.chars().rev().next().unwrap().len_utf8();\n                 SearchStep::Reject(m.end, current_end)\n             }\n         })\n@@ -290,6 +297,9 @@ where F: FnOnce(&mut StrSearcher) -> SearchStep,\n     } else if m.start + m.needle.len() <= m.end {\n         // Case for needle != \"\"\n         g(&mut m)\n+    } else if m.start < m.end {\n+        m.done = true;\n+        SearchStep::Reject(m.start, m.end)\n     } else {\n         m.done = true;\n         SearchStep::Done\n@@ -352,7 +362,8 @@ impl<'a, F> Pattern<'a> for F where F: FnMut(char) -> bool {\n \n use ops::Deref;\n \n-impl<'a, 'b, P: 'b + ?Sized, T: Deref<Target = P> + ?Sized> Pattern<'a> for &'b T where &'b P: Pattern<'a> {\n+impl<'a, 'b, P: 'b + ?Sized, T: Deref<Target = P> + ?Sized> Pattern<'a> for &'b T\n+where &'b P: Pattern<'a> {\n     type Searcher =   <&'b P as Pattern<'a>>::Searcher;\n     associated_items!(<&'b P as Pattern<'a>>::Searcher,\n                       s, (&**s));"}, {"sha": "beb746d25b61cf81a9b0f2d80bdd0b5383de7cd4", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 144, "deletions": 2, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/a641996796f0ab11021671c0ce70a3c975bb4e37/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a641996796f0ab11021671c0ce70a3c975bb4e37/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=a641996796f0ab11021671c0ce70a3c975bb4e37", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -139,8 +139,150 @@ fn test_utf16_code_units() {\n                vec![0xE9, 0xD83D, 0xDCA9])\n }\n \n+#[test]\n+fn starts_with_in_unicode() {\n+    assert!(!\"\u251c\u2500\u2500 Cargo.toml\".starts_with(\"# \"));\n+}\n \n-// rm x86_64-unknown-linux-gnu/stage1/test/coretesttest-x86_64-unknown-linux-gnu; env PLEASE_BENCH=1 make check-stage1-coretest TESTNAME=str::bench\n+#[test]\n+fn starts_short_long() {\n+    assert!(!\"\".starts_with(\"##\"));\n+    assert!(!\"##\".starts_with(\"####\"));\n+    assert!(\"####\".starts_with(\"##\"));\n+    assert!(!\"##\u00e4\".starts_with(\"####\"));\n+    assert!(\"####\u00e4\".starts_with(\"##\"));\n+    assert!(!\"##\".starts_with(\"####\u00e4\"));\n+    assert!(\"##\u00e4##\".starts_with(\"##\u00e4\"));\n+\n+    assert!(\"\".starts_with(\"\"));\n+    assert!(\"\u00e4\".starts_with(\"\"));\n+    assert!(\"#\u00e4\".starts_with(\"\"));\n+    assert!(\"##\u00e4\".starts_with(\"\"));\n+    assert!(\"\u00e4###\".starts_with(\"\"));\n+    assert!(\"#\u00e4##\".starts_with(\"\"));\n+    assert!(\"##\u00e4#\".starts_with(\"\"));\n+}\n+\n+#[test]\n+fn contains_weird_cases() {\n+    assert!(\"* \\t\".contains_char(' '));\n+    assert!(!\"* \\t\".contains_char('?'));\n+    assert!(!\"* \\t\".contains_char('\\u{1F4A9}'));\n+}\n+\n+#[test]\n+fn trim_ws() {\n+    assert_eq!(\" \\t  a \\t  \".trim_left_matches(|c: char| c.is_whitespace()),\n+                    \"a \\t  \");\n+    assert_eq!(\" \\t  a \\t  \".trim_right_matches(|c: char| c.is_whitespace()),\n+               \" \\t  a\");\n+    assert_eq!(\" \\t  a \\t  \".trim_matches(|c: char| c.is_whitespace()),\n+                    \"a\");\n+    assert_eq!(\" \\t   \\t  \".trim_left_matches(|c: char| c.is_whitespace()),\n+                         \"\");\n+    assert_eq!(\" \\t   \\t  \".trim_right_matches(|c: char| c.is_whitespace()),\n+               \"\");\n+    assert_eq!(\" \\t   \\t  \".trim_matches(|c: char| c.is_whitespace()),\n+               \"\");\n+}\n+\n+mod pattern {\n+    use std::str::Pattern;\n+    use std::str::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n+    use std::str::SearchStep::{self, Match, Reject, Done};\n+\n+    macro_rules! make_test {\n+        ($name:ident, $p:expr, $h:expr, [$($e:expr,)*]) => {\n+            mod $name {\n+                use std::str::Pattern;\n+                use std::str::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n+                use std::str::SearchStep::{self, Match, Reject, Done};\n+                use super::{cmp_search_to_vec};\n+                #[test]\n+                fn fwd() {\n+                    cmp_search_to_vec(false, $p, $h, vec![$($e),*]);\n+                }\n+                #[test]\n+                fn bwd() {\n+                    cmp_search_to_vec(true, $p, $h, vec![$($e),*]);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn cmp_search_to_vec<'a, P: Pattern<'a>>(rev: bool, pat: P, haystack: &'a str,\n+                                             right: Vec<SearchStep>)\n+    where P::Searcher: ReverseSearcher<'a>\n+    {\n+        let mut searcher = pat.into_searcher(haystack);\n+        let mut v = vec![];\n+        loop {\n+            match if !rev {searcher.next()} else {searcher.next_back()} {\n+                Match(a, b) => v.push(Match(a, b)),\n+                Reject(a, b) => v.push(Reject(a, b)),\n+                Done => break,\n+            }\n+        }\n+        if rev {\n+            v.reverse();\n+        }\n+        assert_eq!(v, right);\n+    }\n+\n+    make_test!(str_searcher_ascii_haystack, \"bb\", \"abbcbbd\", [\n+        Reject(0, 1),\n+        Match (1, 3),\n+        Reject(3, 4),\n+        Match (4, 6),\n+        Reject(6, 7),\n+    ]);\n+    make_test!(str_searcher_empty_needle_ascii_haystack, \"\", \"abbcbbd\", [\n+        Match(0, 0),\n+        Match(1, 1),\n+        Match(2, 2),\n+        Match(3, 3),\n+        Match(4, 4),\n+        Match(5, 5),\n+        Match(6, 6),\n+        Match(7, 7),\n+    ]);\n+    make_test!(str_searcher_mulibyte_haystack, \" \", \"\u251c\u2500\u2500\", [\n+        Reject(0, 3),\n+        Reject(3, 6),\n+        Reject(6, 9),\n+    ]);\n+    make_test!(str_searcher_empty_needle_mulibyte_haystack, \"\", \"\u251c\u2500\u2500\", [\n+        Match(0, 0),\n+        Match(3, 3),\n+        Match(6, 6),\n+        Match(9, 9),\n+    ]);\n+    make_test!(str_searcher_empty_needle_empty_haystack, \"\", \"\", [\n+        Match(0, 0),\n+    ]);\n+    make_test!(str_searcher_nonempty_needle_empty_haystack, \"\u251c\", \"\", [\n+    ]);\n+    make_test!(char_searcher_ascii_haystack, 'b', \"abbcbbd\", [\n+        Reject(0, 1),\n+        Match (1, 2),\n+        Match (2, 3),\n+        Reject(3, 4),\n+        Match (4, 5),\n+        Match (5, 6),\n+        Reject(6, 7),\n+    ]);\n+    make_test!(char_searcher_mulibyte_haystack, ' ', \"\u251c\u2500\u2500\", [\n+        Reject(0, 3),\n+        Reject(3, 6),\n+        Reject(6, 9),\n+    ]);\n+    make_test!(char_searcher_short_haystack, '\\u{1F4A9}', \"* \\t\", [\n+        Reject(0, 1),\n+        Reject(1, 2),\n+        Reject(2, 3),\n+    ]);\n+\n+}\n \n mod bench {\n     macro_rules! make_test_inner {"}]}