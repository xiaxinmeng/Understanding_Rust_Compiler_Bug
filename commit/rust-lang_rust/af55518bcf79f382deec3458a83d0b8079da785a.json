{"sha": "af55518bcf79f382deec3458a83d0b8079da785a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmNTU1MThiY2Y3OWYzODJkZWVjMzQ1OGE4M2QwYjgwNzlkYTc4NWE=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-02-28T11:15:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-02-28T11:15:34Z"}, "message": "Rollup merge of #48479 - mark-i-m:rustc-guide, r=nikomatsakis\n\nStart moving to the rustc guide!\n\nr? @nikomatsakis\n\ncc #48478", "tree": {"sha": "47d4922b2e60bdb53cbfbe85b48e3ac0b09b5064", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47d4922b2e60bdb53cbfbe85b48e3ac0b09b5064"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af55518bcf79f382deec3458a83d0b8079da785a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJalo9WCRBK7hj4Ov3rIwAAdHIIACzwoV1+yQlmzr0WZuh2UU87\nCEDUwu6XWgZYGBAShjVoFb3qLnif5FVozIkn8sX9GjM3A6HaFvuqs9RG5PyySJIR\n5BuTB1Ltz+FT9iRe3pjs/xhN1mrq3lqMw0yZfv4UT19MrTDrUkkQywb57EV+XXB2\nbGf5I4EjPSFtfuxyvFT7yBnT9MlAV8CMj8AjppDjWUpZ4V09SoKFAetqO0fcDOWW\nmludXajTFYpFHqSD55A2ye0PY2eg5qN+KDvpiHDiqXuEzggV2CPG1s94L2z9wQ1W\ny0kGG5GlonagF+0AlUV/lXnFDSYdHXFea4eIYAicaQpo+AkP+OP1JqO7NtdkLvs=\n=ospg\n-----END PGP SIGNATURE-----\n", "payload": "tree 47d4922b2e60bdb53cbfbe85b48e3ac0b09b5064\nparent cbd0a2c6fdf3270d659488512311917957fee624\nparent 7a82da1c4d3c5cb3e7bfa0dc43337842a677943c\nauthor kennytm <kennytm@gmail.com> 1519816534 +0800\ncommitter GitHub <noreply@github.com> 1519816534 +0800\n\nRollup merge of #48479 - mark-i-m:rustc-guide, r=nikomatsakis\n\nStart moving to the rustc guide!\n\nr? @nikomatsakis\n\ncc #48478\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af55518bcf79f382deec3458a83d0b8079da785a", "html_url": "https://github.com/rust-lang/rust/commit/af55518bcf79f382deec3458a83d0b8079da785a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af55518bcf79f382deec3458a83d0b8079da785a/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbd0a2c6fdf3270d659488512311917957fee624", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbd0a2c6fdf3270d659488512311917957fee624", "html_url": "https://github.com/rust-lang/rust/commit/cbd0a2c6fdf3270d659488512311917957fee624"}, {"sha": "7a82da1c4d3c5cb3e7bfa0dc43337842a677943c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a82da1c4d3c5cb3e7bfa0dc43337842a677943c", "html_url": "https://github.com/rust-lang/rust/commit/7a82da1c4d3c5cb3e7bfa0dc43337842a677943c"}], "stats": {"total": 1373, "additions": 61, "deletions": 1312}, "files": [{"sha": "552961b9b66c13ca69ab58671ed2bea808558d93", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af55518bcf79f382deec3458a83d0b8079da785a/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/af55518bcf79f382deec3458a83d0b8079da785a/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=af55518bcf79f382deec3458a83d0b8079da785a", "patch": "@@ -623,6 +623,7 @@ For people new to Rust, and just starting to contribute, or even for\n more seasoned developers, some useful places to look for information\n are:\n \n+* The [rustc guide] contains information about how various parts of the compiler work\n * [Rust Forge][rustforge] contains additional documentation, including write-ups of how to achieve common tasks\n * The [Rust Internals forum][rif], a place to ask questions and\n   discuss Rust's internals\n@@ -635,6 +636,7 @@ are:\n * **Google!** ([search only in Rust Documentation][gsearchdocs] to find types, traits, etc. quickly)\n * Don't be afraid to ask! The Rust community is friendly and helpful.\n \n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/about-this-guide.html\n [gdfrustc]: http://manishearth.github.io/rust-internals-docs/rustc/\n [gsearchdocs]: https://www.google.com/search?q=site:doc.rust-lang.org+your+query+here\n [rif]: http://internals.rust-lang.org"}, {"sha": "fd35606ec0dbb21ccad4ba00f59d5f983f3ef843", "filename": "README.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af55518bcf79f382deec3458a83d0b8079da785a/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/af55518bcf79f382deec3458a83d0b8079da785a/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=af55518bcf79f382deec3458a83d0b8079da785a", "patch": "@@ -227,9 +227,13 @@ variety of channels on Mozilla's IRC network, irc.mozilla.org. The\n most popular channel is [#rust], a venue for general discussion about\n Rust. And a good place to ask for help would be [#rust-beginners].\n \n+Also, the [rustc guide] might be a good place to start if you want to\n+find out how various parts of the compiler work.\n+\n [IRC]: https://en.wikipedia.org/wiki/Internet_Relay_Chat\n [#rust]: irc://irc.mozilla.org/rust\n [#rust-beginners]: irc://irc.mozilla.org/rust-beginners\n+[rustc-guide]: https://rust-lang-nursery.github.io/rustc-guide/about-this-guide.html\n \n ## License\n [license]: #license"}, {"sha": "690ab674c64ebd96bf1700994b0097f506c58955", "filename": "src/README.md", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/af55518bcf79f382deec3458a83d0b8079da785a/src%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/af55518bcf79f382deec3458a83d0b8079da785a/src%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.md?ref=af55518bcf79f382deec3458a83d0b8079da785a", "patch": "@@ -0,0 +1,15 @@\n+This directory contains the source code of the rust project, including:\n+- `rustc` and its tests\n+- `libstd`\n+- Various submodules for tools, like rustdoc, rls, etc.\n+\n+For more information on how various parts of the compiler work, see the [rustc guide].\n+\n+Their is also useful content in the following READMEs, which are gradually being moved over to the guide:\n+- https://github.com/rust-lang/rust/tree/master/src/librustc/ty/maps\n+- https://github.com/rust-lang/rust/tree/master/src/librustc/dep_graph\n+- https://github.com/rust-lang/rust/blob/master/src/librustc/infer/region_constraints\n+- https://github.com/rust-lang/rust/tree/master/src/librustc/infer/higher_ranked\n+- https://github.com/rust-lang/rust/tree/master/src/librustc/infer/lexical_region_resolve\n+\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/about-this-guide.html"}, {"sha": "9909ff91a18aabe186dc2142bb4e1cf47464f65c", "filename": "src/librustc/README.md", "status": "modified", "additions": 2, "deletions": 203, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/af55518bcf79f382deec3458a83d0b8079da785a/src%2Flibrustc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/af55518bcf79f382deec3458a83d0b8079da785a/src%2Flibrustc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FREADME.md?ref=af55518bcf79f382deec3458a83d0b8079da785a", "patch": "@@ -1,204 +1,3 @@\n-An informal guide to reading and working on the rustc compiler.\n-==================================================================\n+For more information about how rustc works, see the [rustc guide].\n \n-If you wish to expand on this document, or have a more experienced\n-Rust contributor add anything else to it, please get in touch:\n-\n-* https://internals.rust-lang.org/\n-* https://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust\n-\n-or file a bug:\n-\n-https://github.com/rust-lang/rust/issues\n-\n-Your concerns are probably the same as someone else's.\n-\n-You may also be interested in the\n-[Rust Forge](https://forge.rust-lang.org/), which includes a number of\n-interesting bits of information.\n-\n-Finally, at the end of this file is a GLOSSARY defining a number of\n-common (and not necessarily obvious!) names that are used in the Rust\n-compiler code. If you see some funky name and you'd like to know what\n-it stands for, check there!\n-\n-The crates of rustc\n-===================\n-\n-Rustc consists of a number of crates, including `syntax`,\n-`rustc`, `rustc_back`, `rustc_trans`, `rustc_driver`, and\n-many more. The source for each crate can be found in a directory\n-like `src/libXXX`, where `XXX` is the crate name.\n-\n-(NB. The names and divisions of these crates are not set in\n-stone and may change over time -- for the time being, we tend towards\n-a finer-grained division to help with compilation time, though as\n-incremental improves that may change.)\n-\n-The dependency structure of these crates is roughly a diamond:\n-\n-```\n-                  rustc_driver\n-                /      |       \\\n-              /        |         \\\n-            /          |           \\\n-          /            v             \\\n-rustc_trans    rustc_borrowck   ...  rustc_metadata\n-          \\            |            /\n-            \\          |          /\n-              \\        |        /\n-                \\      v      /\n-                    rustc\n-                       |\n-                       v\n-                    syntax\n-                    /    \\\n-                  /       \\\n-           syntax_pos  syntax_ext\n-```                    \n-\n-The `rustc_driver` crate, at the top of this lattice, is effectively\n-the \"main\" function for the rust compiler. It doesn't have much \"real\n-code\", but instead ties together all of the code defined in the other\n-crates and defines the overall flow of execution. (As we transition\n-more and more to the [query model](ty/maps/README.md), however, the\n-\"flow\" of compilation is becoming less centrally defined.)\n-\n-At the other extreme, the `rustc` crate defines the common and\n-pervasive data structures that all the rest of the compiler uses\n-(e.g., how to represent types, traits, and the program itself). It\n-also contains some amount of the compiler itself, although that is\n-relatively limited.\n-\n-Finally, all the crates in the bulge in the middle define the bulk of\n-the compiler -- they all depend on `rustc`, so that they can make use\n-of the various types defined there, and they export public routines\n-that `rustc_driver` will invoke as needed (more and more, what these\n-crates export are \"query definitions\", but those are covered later\n-on).\n-\n-Below `rustc` lie various crates that make up the parser and error\n-reporting mechanism. For historical reasons, these crates do not have\n-the `rustc_` prefix, but they are really just as much an internal part\n-of the compiler and not intended to be stable (though they do wind up\n-getting used by some crates in the wild; a practice we hope to\n-gradually phase out).\n-\n-Each crate has a `README.md` file that describes, at a high-level,\n-what it contains, and tries to give some kind of explanation (some\n-better than others).\n-\n-The compiler process\n-====================\n-\n-The Rust compiler is in a bit of transition right now. It used to be a\n-purely \"pass-based\" compiler, where we ran a number of passes over the\n-entire program, and each did a particular check of transformation.\n-\n-We are gradually replacing this pass-based code with an alternative\n-setup based on on-demand **queries**. In the query-model, we work\n-backwards, executing a *query* that expresses our ultimate goal (e.g.,\n-\"compile this crate\"). This query in turn may make other queries\n-(e.g., \"get me a list of all modules in the crate\"). Those queries\n-make other queries that ultimately bottom out in the base operations,\n-like parsing the input, running the type-checker, and so forth. This\n-on-demand model permits us to do exciting things like only do the\n-minimal amount of work needed to type-check a single function. It also\n-helps with incremental compilation. (For details on defining queries,\n-check out `src/librustc/ty/maps/README.md`.)\n-\n-Regardless of the general setup, the basic operations that the\n-compiler must perform are the same. The only thing that changes is\n-whether these operations are invoked front-to-back, or on demand.  In\n-order to compile a Rust crate, these are the general steps that we\n-take:\n-\n-1. **Parsing input**\n-    - this processes the `.rs` files and produces the AST (\"abstract syntax tree\")\n-    - the AST is defined in `syntax/ast.rs`. It is intended to match the lexical\n-      syntax of the Rust language quite closely.\n-2. **Name resolution, macro expansion, and configuration**\n-    - once parsing is complete, we process the AST recursively, resolving paths\n-      and expanding macros. This same process also processes `#[cfg]` nodes, and hence\n-      may strip things out of the AST as well.\n-3. **Lowering to HIR**\n-    - Once name resolution completes, we convert the AST into the HIR,\n-      or \"high-level IR\". The HIR is defined in `src/librustc/hir/`; that module also includes\n-      the lowering code.\n-    - The HIR is a lightly desugared variant of the AST. It is more processed than the\n-      AST and more suitable for the analyses that follow. It is **not** required to match\n-      the syntax of the Rust language.\n-    - As a simple example, in the **AST**, we preserve the parentheses\n-      that the user wrote, so `((1 + 2) + 3)` and `1 + 2 + 3` parse\n-      into distinct trees, even though they are equivalent. In the\n-      HIR, however, parentheses nodes are removed, and those two\n-      expressions are represented in the same way.\n-3. **Type-checking and subsequent analyses**\n-    - An important step in processing the HIR is to perform type\n-      checking. This process assigns types to every HIR expression,\n-      for example, and also is responsible for resolving some\n-      \"type-dependent\" paths, such as field accesses (`x.f` -- we\n-      can't know what field `f` is being accessed until we know the\n-      type of `x`) and associated type references (`T::Item` -- we\n-      can't know what type `Item` is until we know what `T` is).\n-    - Type checking creates \"side-tables\" (`TypeckTables`) that include\n-      the types of expressions, the way to resolve methods, and so forth.\n-    - After type-checking, we can do other analyses, such as privacy checking.\n-4. **Lowering to MIR and post-processing**\n-    - Once type-checking is done, we can lower the HIR into MIR (\"middle IR\"), which\n-      is a **very** desugared version of Rust, well suited to the borrowck but also\n-      certain high-level optimizations. \n-5. **Translation to LLVM and LLVM optimizations**\n-    - From MIR, we can produce LLVM IR.\n-    - LLVM then runs its various optimizations, which produces a number of `.o` files\n-      (one for each \"codegen unit\").\n-6. **Linking**\n-    - Finally, those `.o` files are linked together.\n-\n-Glossary\n-========\n-\n-The compiler uses a number of...idiosyncratic abbreviations and\n-things. This glossary attempts to list them and give you a few\n-pointers for understanding them better.\n-\n-- AST -- the **abstract syntax tree** produced by the `syntax` crate; reflects user syntax\n-  very closely. \n-- codegen unit -- when we produce LLVM IR, we group the Rust code into a number of codegen\n-  units. Each of these units is processed by LLVM independently from one another,\n-  enabling parallelism. They are also the unit of incremental re-use. \n-- cx -- we tend to use \"cx\" as an abbrevation for context. See also tcx, infcx, etc.\n-- `DefId` -- an index identifying a **definition** (see `librustc/hir/def_id.rs`). Uniquely\n-  identifies a `DefPath`.\n-- HIR -- the **High-level IR**, created by lowering and desugaring the AST. See `librustc/hir`.\n-- `HirId` -- identifies a particular node in the HIR by combining a\n-  def-id with an \"intra-definition offset\".\n-- `'gcx` -- the lifetime of the global arena (see `librustc/ty`).\n-- generics -- the set of generic type parameters defined on a type or item\n-- ICE -- internal compiler error. When the compiler crashes.\n-- ICH -- incremental compilation hash.\n-- infcx -- the inference context (see `librustc/infer`)\n-- MIR -- the **Mid-level IR** that is created after type-checking for use by borrowck and trans.\n-  Defined in the `src/librustc/mir/` module, but much of the code that manipulates it is\n-  found in `src/librustc_mir`.\n-- obligation -- something that must be proven by the trait system; see `librustc/traits`.\n-- local crate -- the crate currently being compiled.\n-- node-id or `NodeId` -- an index identifying a particular node in the\n-  AST or HIR; gradually being phased out and replaced with `HirId`.\n-- query -- perhaps some sub-computation during compilation; see `librustc/maps`.\n-- provider -- the function that executes a query; see `librustc/maps`.\n-- sess -- the **compiler session**, which stores global data used throughout compilation\n-- side tables -- because the AST and HIR are immutable once created, we often carry extra\n-  information about them in the form of hashtables, indexed by the id of a particular node.\n-- span -- a location in the user's source code, used for error\n-  reporting primarily.  These are like a file-name/line-number/column\n-  tuple on steroids: they carry a start/end point, and also track\n-  macro expansions and compiler desugaring. All while being packed\n-  into a few bytes (really, it's an index into a table). See the\n-  `Span` datatype for more.\n-- substs -- the **substitutions** for a given generic type or item\n-  (e.g., the `i32, u32` in `HashMap<i32, u32>`)\n-- tcx -- the \"typing context\", main data structure of the compiler (see `librustc/ty`).\n-- trans -- the code to **translate** MIR into LLVM IR.\n-- trait reference -- a trait and values for its type parameters (see `librustc/ty`).\n-- ty -- the internal representation of a **type** (see `librustc/ty`).\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/"}, {"sha": "61a8fb09118bfa4b6aff217e5ebd59b84c021535", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af55518bcf79f382deec3458a83d0b8079da785a/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af55518bcf79f382deec3458a83d0b8079da785a/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=af55518bcf79f382deec3458a83d0b8079da785a", "patch": "@@ -168,7 +168,7 @@ impl DepGraph {\n     /// what state they have access to. In particular, we want to\n     /// prevent implicit 'leaks' of tracked state into the task (which\n     /// could then be read without generating correct edges in the\n-    /// dep-graph -- see the module-level [README] for more details on\n+    /// dep-graph -- see the [rustc guide] for more details on\n     /// the dep-graph). To this end, the task function gets exactly two\n     /// pieces of state: the context `cx` and an argument `arg`. Both\n     /// of these bits of state must be of some type that implements\n@@ -188,7 +188,7 @@ impl DepGraph {\n     /// - If you need 3+ arguments, use a tuple for the\n     ///   `arg` parameter.\n     ///\n-    /// [README]: https://github.com/rust-lang/rust/blob/master/src/librustc/dep_graph/README.md\n+    /// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/incremental-compilation.html\n     pub fn with_task<C, A, R, HCX>(&self,\n                                    key: DepNode,\n                                    cx: C,"}, {"sha": "e283fc40c50a345fc9ed5658753bc45eb9d6836a", "filename": "src/librustc/hir/README.md", "status": "removed", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/cbd0a2c6fdf3270d659488512311917957fee624/src%2Flibrustc%2Fhir%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/cbd0a2c6fdf3270d659488512311917957fee624/src%2Flibrustc%2Fhir%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2FREADME.md?ref=cbd0a2c6fdf3270d659488512311917957fee624", "patch": "@@ -1,119 +0,0 @@\n-# Introduction to the HIR\n-\n-The HIR -- \"High-level IR\" -- is the primary IR used in most of\n-rustc. It is a desugared version of the \"abstract syntax tree\" (AST)\n-that is generated after parsing, macro expansion, and name resolution\n-have completed. Many parts of HIR resemble Rust surface syntax quite\n-closely, with the exception that some of Rust's expression forms have\n-been desugared away (as an example, `for` loops are converted into a\n-`loop` and do not appear in the HIR).\n-\n-This README covers the main concepts of the HIR.\n-\n-### Out-of-band storage and the `Crate` type\n-\n-The top-level data-structure in the HIR is the `Crate`, which stores\n-the contents of the crate currently being compiled (we only ever\n-construct HIR for the current crate). Whereas in the AST the crate\n-data structure basically just contains the root module, the HIR\n-`Crate` structure contains a number of maps and other things that\n-serve to organize the content of the crate for easier access.\n-\n-For example, the contents of individual items (e.g., modules,\n-functions, traits, impls, etc) in the HIR are not immediately\n-accessible in the parents. So, for example, if had a module item `foo`\n-containing a function `bar()`:\n-\n-```\n-mod foo {\n-  fn bar() { }\n-}\n-```\n-\n-Then in the HIR the representation of module `foo` (the `Mod`\n-stuct) would have only the **`ItemId`** `I` of `bar()`. To get the\n-details of the function `bar()`, we would lookup `I` in the\n-`items` map.\n-\n-One nice result from this representation is that one can iterate\n-over all items in the crate by iterating over the key-value pairs\n-in these maps (without the need to trawl through the IR in total).\n-There are similar maps for things like trait items and impl items,\n-as well as \"bodies\" (explained below).\n-\n-The other reason to setup the representation this way is for better\n-integration with incremental compilation. This way, if you gain access\n-to a `&hir::Item` (e.g. for the mod `foo`), you do not immediately\n-gain access to the contents of the function `bar()`. Instead, you only\n-gain access to the **id** for `bar()`, and you must invoke some\n-function to lookup the contents of `bar()` given its id; this gives us\n-a chance to observe that you accessed the data for `bar()` and record\n-the dependency.\n-\n-### Identifiers in the HIR\n-\n-Most of the code that has to deal with things in HIR tends not to\n-carry around references into the HIR, but rather to carry around\n-*identifier numbers* (or just \"ids\"). Right now, you will find four\n-sorts of identifiers in active use:\n-\n-- `DefId`, which primarily names \"definitions\" or top-level items.\n-  - You can think of a `DefId` as being shorthand for a very explicit\n-    and complete path, like `std::collections::HashMap`. However,\n-    these paths are able to name things that are not nameable in\n-    normal Rust (e.g., impls), and they also include extra information\n-    about the crate (such as its version number, as two versions of\n-    the same crate can co-exist).\n-  - A `DefId` really consists of two parts, a `CrateNum` (which\n-    identifies the crate) and a `DefIndex` (which indixes into a list\n-    of items that is maintained per crate).\n-- `HirId`, which combines the index of a particular item with an\n-  offset within that item.\n-  - the key point of a `HirId` is that it is *relative* to some item (which is named\n-    via a `DefId`).\n-- `BodyId`, this is an absolute identifier that refers to a specific\n-  body (definition of a function or constant) in the crate. It is currently\n-  effectively a \"newtype'd\" `NodeId`.\n-- `NodeId`, which is an absolute id that identifies a single node in the HIR tree.\n-  - While these are still in common use, **they are being slowly phased out**.\n-  - Since they are absolute within the crate, adding a new node\n-    anywhere in the tree causes the node-ids of all subsequent code in\n-    the crate to change. This is terrible for incremental compilation,\n-    as you can perhaps imagine.\n-\n-### HIR Map\n-\n-Most of the time when you are working with the HIR, you will do so via\n-the **HIR Map**, accessible in the tcx via `tcx.hir` (and defined in\n-the `hir::map` module). The HIR map contains a number of methods to\n-convert between ids of various kinds and to lookup data associated\n-with a HIR node.\n-\n-For example, if you have a `DefId`, and you would like to convert it\n-to a `NodeId`, you can use `tcx.hir.as_local_node_id(def_id)`. This\n-returns an `Option<NodeId>` -- this will be `None` if the def-id\n-refers to something outside of the current crate (since then it has no\n-HIR node), but otherwise returns `Some(n)` where `n` is the node-id of\n-the definition.\n-\n-Similarly, you can use `tcx.hir.find(n)` to lookup the node for a\n-`NodeId`. This returns a `Option<Node<'tcx>>`, where `Node` is an enum\n-defined in the map; by matching on this you can find out what sort of\n-node the node-id referred to and also get a pointer to the data\n-itself. Often, you know what sort of node `n` is -- e.g., if you know\n-that `n` must be some HIR expression, you can do\n-`tcx.hir.expect_expr(n)`, which will extract and return the\n-`&hir::Expr`, panicking if `n` is not in fact an expression.\n-\n-Finally, you can use the HIR map to find the parents of nodes, via\n-calls like `tcx.hir.get_parent_node(n)`.\n-\n-### HIR Bodies\n-\n-A **body** represents some kind of executable code, such as the body\n-of a function/closure or the definition of a constant. Bodies are\n-associated with an **owner**, which is typically some kind of item\n-(e.g., a `fn()` or `const`), but could also be a closure expression\n-(e.g., `|x, y| x + y`). You can use the HIR map to find the body\n-associated with a given def-id (`maybe_body_owned_by()`) or to find\n-the owner of a body (`body_owner_def_id()`)."}, {"sha": "34ed325705ab98c231f0ae9ac578fd252c6a6f1d", "filename": "src/librustc/hir/map/README.md", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbd0a2c6fdf3270d659488512311917957fee624/src%2Flibrustc%2Fhir%2Fmap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/cbd0a2c6fdf3270d659488512311917957fee624/src%2Flibrustc%2Fhir%2Fmap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2FREADME.md?ref=cbd0a2c6fdf3270d659488512311917957fee624", "patch": "@@ -1,4 +0,0 @@\n-The HIR map, accessible via `tcx.hir`, allows you to quickly navigate the\n-HIR and convert between various forms of identifiers. See [the HIR README] for more information.\n-\n-[the HIR README]: ../README.md"}, {"sha": "c4873cb83076a1cb636a27aa3ba08b8cdb5ed7c2", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af55518bcf79f382deec3458a83d0b8079da785a/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af55518bcf79f382deec3458a83d0b8079da785a/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=af55518bcf79f382deec3458a83d0b8079da785a", "patch": "@@ -602,9 +602,9 @@ pub type CrateConfig = HirVec<P<MetaItem>>;\n /// The top-level data structure that stores the entire contents of\n /// the crate currently being compiled.\n ///\n-/// For more details, see the module-level [README].\n+/// For more details, see the [rustc guide].\n ///\n-/// [README]: https://github.com/rust-lang/rust/blob/master/src/librustc/hir/README.md.\n+/// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/hir.html\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n pub struct Crate {\n     pub module: Mod,"}, {"sha": "7f58d03906026ee0a79f23334f48c86d63d111b7", "filename": "src/librustc/infer/README.md", "status": "removed", "additions": 0, "deletions": 227, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/cbd0a2c6fdf3270d659488512311917957fee624/src%2Flibrustc%2Finfer%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/cbd0a2c6fdf3270d659488512311917957fee624/src%2Flibrustc%2Finfer%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2FREADME.md?ref=cbd0a2c6fdf3270d659488512311917957fee624", "patch": "@@ -1,227 +0,0 @@\n-# Type inference engine\n-\n-The type inference is based on standard HM-type inference, but\n-extended in various way to accommodate subtyping, region inference,\n-and higher-ranked types.\n-\n-## A note on terminology\n-\n-We use the notation `?T` to refer to inference variables, also called\n-existential variables.\n-\n-We use the term \"region\" and \"lifetime\" interchangeably. Both refer to\n-the `'a` in `&'a T`.\n-\n-The term \"bound region\" refers to regions bound in a function\n-signature, such as the `'a` in `for<'a> fn(&'a u32)`. A region is\n-\"free\" if it is not bound.\n-\n-## Creating an inference context\n-\n-You create and \"enter\" an inference context by doing something like\n-the following:\n-\n-```rust\n-tcx.infer_ctxt().enter(|infcx| {\n-    // use the inference context `infcx` in here\n-})\n-```\n-\n-Each inference context creates a short-lived type arena to store the\n-fresh types and things that it will create, as described in\n-[the README in the ty module][ty-readme]. This arena is created by the `enter`\n-function and disposed after it returns.\n-\n-[ty-readme]: src/librustc/ty/README.md\n-\n-Within the closure, the infcx will have the type `InferCtxt<'cx, 'gcx,\n-'tcx>` for some fresh `'cx` and `'tcx` -- the latter corresponds to\n-the lifetime of this temporary arena, and the `'cx` is the lifetime of\n-the `InferCtxt` itself. (Again, see [that ty README][ty-readme] for\n-more details on this setup.)\n-\n-The `tcx.infer_ctxt` method actually returns a build, which means\n-there are some kinds of configuration you can do before the `infcx` is\n-created. See `InferCtxtBuilder` for more information.\n-\n-## Inference variables\n-\n-The main purpose of the inference context is to house a bunch of\n-**inference variables** -- these represent types or regions whose precise\n-value is not yet known, but will be uncovered as we perform type-checking.\n-\n-If you're familiar with the basic ideas of unification from H-M type\n-systems, or logic languages like Prolog, this is the same concept. If\n-you're not, you might want to read a tutorial on how H-M type\n-inference works, or perhaps this blog post on\n-[unification in the Chalk project].\n-\n-[Unification in the Chalk project]: http://smallcultfollowing.com/babysteps/blog/2017/03/25/unification-in-chalk-part-1/\n-\n-All told, the inference context stores four kinds of inference variables as of this\n-writing:\n-\n-- Type variables, which come in three varieties:\n-  - General type variables (the most common). These can be unified with any type.\n-  - Integral type variables, which can only be unified with an integral type, and\n-    arise from an integer literal expression like `22`.\n-  - Float type variables, which can only be unified with a float type, and\n-    arise from a float literal expression like `22.0`.\n-- Region variables, which represent lifetimes, and arise all over the dang place.\n-\n-All the type variables work in much the same way: you can create a new\n-type variable, and what you get is `Ty<'tcx>` representing an\n-unresolved type `?T`. Then later you can apply the various operations\n-that the inferencer supports, such as equality or subtyping, and it\n-will possibly **instantiate** (or **bind**) that `?T` to a specific\n-value as a result.\n-\n-The region variables work somewhat differently, and are described\n-below in a separate section.\n-\n-## Enforcing equality / subtyping\n-\n-The most basic operations you can perform in the type inferencer is\n-**equality**, which forces two types `T` and `U` to be the same. The\n-recommended way to add an equality constraint is using the `at`\n-method, roughly like so:\n-\n-```\n-infcx.at(...).eq(t, u);\n-```\n-\n-The first `at()` call provides a bit of context, i.e., why you are\n-doing this unification, and in what environment, and the `eq` method\n-performs the actual equality constraint.\n-\n-When you equate things, you force them to be precisely equal. Equating\n-returns a `InferResult` -- if it returns `Err(err)`, then equating\n-failed, and the enclosing `TypeError` will tell you what went wrong.\n-\n-The success case is perhaps more interesting. The \"primary\" return\n-type of `eq` is `()` -- that is, when it succeeds, it doesn't return a\n-value of any particular interest. Rather, it is executed for its\n-side-effects of constraining type variables and so forth. However, the\n-actual return type is not `()`, but rather `InferOk<()>`. The\n-`InferOk` type is used to carry extra trait obligations -- your job is\n-to ensure that these are fulfilled (typically by enrolling them in a\n-fulfillment context). See the [trait README] for more background here.\n-\n-[trait README]: ../traits/README.md\n-\n-You can also enforce subtyping through `infcx.at(..).sub(..)`. The same\n-basic concepts apply as above.\n-\n-## \"Trying\" equality\n-\n-Sometimes you would like to know if it is *possible* to equate two\n-types without error.  You can test that with `infcx.can_eq` (or\n-`infcx.can_sub` for subtyping). If this returns `Ok`, then equality\n-is possible -- but in all cases, any side-effects are reversed.\n-\n-Be aware though that the success or failure of these methods is always\n-**modulo regions**. That is, two types `&'a u32` and `&'b u32` will\n-return `Ok` for `can_eq`, even if `'a != 'b`.  This falls out from the\n-\"two-phase\" nature of how we solve region constraints.\n-\n-## Snapshots\n-\n-As described in the previous section on `can_eq`, often it is useful\n-to be able to do a series of operations and then roll back their\n-side-effects. This is done for various reasons: one of them is to be\n-able to backtrack, trying out multiple possibilities before settling\n-on which path to take. Another is in order to ensure that a series of\n-smaller changes take place atomically or not at all.\n-\n-To allow for this, the inference context supports a `snapshot` method.\n-When you call it, it will start recording changes that occur from the\n-operations you perform. When you are done, you can either invoke\n-`rollback_to`, which will undo those changes, or else `confirm`, which\n-will make the permanent. Snapshots can be nested as long as you follow\n-a stack-like discipline.\n-\n-Rather than use snapshots directly, it is often helpful to use the\n-methods like `commit_if_ok` or `probe` that encapsulate higher-level\n-patterns.\n-\n-## Subtyping obligations\n-\n-One thing worth discussing are subtyping obligations. When you force\n-two types to be a subtype, like `?T <: i32`, we can often convert those\n-into equality constraints. This follows from Rust's rather limited notion\n-of subtyping: so, in the above case, `?T <: i32` is equivalent to `?T = i32`.\n-\n-However, in some cases we have to be more careful. For example, when\n-regions are involved. So if you have `?T <: &'a i32`, what we would do\n-is to first \"generalize\" `&'a i32` into a type with a region variable:\n-`&'?b i32`, and then unify `?T` with that (`?T = &'?b i32`). We then\n-relate this new variable with the original bound:\n-\n-    &'?b i32 <: &'a i32\n-    \n-This will result in a region constraint (see below) of `'?b: 'a`.\n-\n-One final interesting case is relating two unbound type variables,\n-like `?T <: ?U`.  In that case, we can't make progress, so we enqueue\n-an obligation `Subtype(?T, ?U)` and return it via the `InferOk`\n-mechanism. You'll have to try again when more details about `?T` or\n-`?U` are known.\n-\n-## Region constraints\n-\n-Regions are inferred somewhat differently from types. Rather than\n-eagerly unifying things, we simply collect constraints as we go, but\n-make (almost) no attempt to solve regions. These constraints have the\n-form of an outlives constraint:\n-\n-    'a: 'b\n-    \n-Actually the code tends to view them as a subregion relation, but it's the same\n-idea:\n-\n-    'b <= 'a\n-\n-(There are various other kinds of constriants, such as \"verifys\"; see\n-the `region_constraints` module for details.)\n-\n-There is one case where we do some amount of eager unification. If you have an equality constraint\n-between two regions\n-\n-    'a = 'b\n-    \n-we will record that fact in a unification table. You can then use\n-`opportunistic_resolve_var` to convert `'b` to `'a` (or vice\n-versa). This is sometimes needed to ensure termination of fixed-point\n-algorithms.\n-\n-## Extracting region constraints\n-\n-Ultimately, region constraints are only solved at the very end of\n-type-checking, once all other constraints are known. There are two\n-ways to solve region constraints right now: lexical and\n-non-lexical. Eventually there will only be one.\n-\n-To solve **lexical** region constraints, you invoke\n-`resolve_regions_and_report_errors`.  This will \"close\" the region\n-constraint process and invoke the `lexical_region_resolve` code. Once\n-this is done, any further attempt to equate or create a subtyping\n-relationship will yield an ICE.\n-\n-Non-lexical region constraints are not handled within the inference\n-context. Instead, the NLL solver (actually, the MIR type-checker)\n-invokes `take_and_reset_region_constraints` periodically. This\n-extracts all of the outlives constraints from the region solver, but\n-leaves the set of variables intact. This is used to get *just* the\n-region constraints that resulted from some particular point in the\n-program, since the NLL solver needs to know not just *what* regions\n-were subregions but *where*. Finally, the NLL solver invokes\n-`take_region_var_origins`, which \"closes\" the region constraint\n-process in the same way as normal solving.\n-\n-## Lexical region resolution\n-\n-Lexical region resolution is done by initially assigning each region\n-variable to an empty value. We then process each outlives constraint\n-repeatedly, growing region variables until a fixed-point is reached.\n-Region variables can be grown using a least-upper-bound relation on\n-the region lattice in a fairly straight-forward fashion."}, {"sha": "d08a41010ab166ab452ac807e248f1b2479d35bc", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af55518bcf79f382deec3458a83d0b8079da785a/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af55518bcf79f382deec3458a83d0b8079da785a/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=af55518bcf79f382deec3458a83d0b8079da785a", "patch": "@@ -28,8 +28,9 @@\n //!   this code handles low-level equality and subtyping operations. The\n //!   type check pass in the compiler is found in the `librustc_typeck` crate.\n //!\n-//! For a deeper explanation of how the compiler works and is\n-//! organized, see the README.md file in this directory.\n+//! For more information about how rustc works, see the [rustc guide].\n+//!\n+//! [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/\n //!\n //! # Note\n //!"}, {"sha": "cac86be0fcb75c76a191cfb3a5223704ff868d37", "filename": "src/librustc/mir/README.md", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/cbd0a2c6fdf3270d659488512311917957fee624/src%2Flibrustc%2Fmir%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/cbd0a2c6fdf3270d659488512311917957fee624/src%2Flibrustc%2Fmir%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2FREADME.md?ref=cbd0a2c6fdf3270d659488512311917957fee624", "patch": "@@ -1,90 +0,0 @@\n-# MIR definition and pass system\n-\n-This file contains the definition of the MIR datatypes along with the\n-various types for the \"MIR Pass\" system, which lets you easily\n-register and define new MIR transformations and analyses.\n-\n-Most of the code that operates on MIR can be found in the\n-`librustc_mir` crate or other crates. The code found here in\n-`librustc` is just the datatype definitions, along with the functions\n-which operate on MIR to be placed everywhere else.\n-\n-## MIR Data Types and visitor\n-\n-The main MIR data type is `rustc::mir::Mir`, defined in `mod.rs`.\n-There is also the MIR visitor (in `visit.rs`) which allows you to walk\n-the MIR and override what actions will be taken at various points (you\n-can visit in either shared or mutable mode; the latter allows changing\n-the MIR in place). Finally `traverse.rs` contains various traversal\n-routines for visiting the MIR CFG in [different standard orders][traversal]\n-(e.g. pre-order, reverse post-order, and so forth).\n-\n-[traversal]: https://en.wikipedia.org/wiki/Tree_traversal\n-\n-## MIR pass suites and their integration into the query system\n-\n-As a MIR *consumer*, you are expected to use one of the queries that\n-returns a \"final MIR\". As of the time of this writing, there is only\n-one: `optimized_mir(def_id)`, but more are expected to come in the\n-future. For foreign def-ids, we simply read the MIR from the other\n-crate's metadata. But for local def-ids, the query will construct the\n-MIR and then iteratively optimize it by putting it through various\n-pipeline stages. This section describes those pipeline stages and how\n-you can extend them.\n-\n-To produce the `optimized_mir(D)` for a given def-id `D`, the MIR\n-passes through several suites of optimizations, each represented by a\n-query. Each suite consists of multiple optimizations and\n-transformations. These suites represent useful intermediate points\n-where we want to access the MIR for type checking or other purposes:\n-\n-- `mir_build(D)` -- not a query, but this constructs the initial MIR\n-- `mir_const(D)` -- applies some simple transformations to make MIR ready for constant evaluation;\n-- `mir_validated(D)` -- applies some more transformations, making MIR ready for borrow checking;\n-- `optimized_mir(D)` -- the final state, after all optimizations have been performed.\n-\n-### Stealing\n-\n-The intermediate queries `mir_const()` and `mir_validated()` yield up\n-a `&'tcx Steal<Mir<'tcx>>`, allocated using\n-`tcx.alloc_steal_mir()`. This indicates that the result may be\n-**stolen** by the next suite of optimizations -- this is an\n-optimization to avoid cloning the MIR. Attempting to use a stolen\n-result will cause a panic in the compiler. Therefore, it is important\n-that you do not read directly from these intermediate queries except as\n-part of the MIR processing pipeline.\n-\n-Because of this stealing mechanism, some care must also be taken to\n-ensure that, before the MIR at a particular phase in the processing\n-pipeline is stolen, anyone who may want to read from it has already\n-done so. Concretely, this means that if you have some query `foo(D)`\n-that wants to access the result of `mir_const(D)` or\n-`mir_validated(D)`, you need to have the successor pass \"force\"\n-`foo(D)` using `ty::queries::foo::force(...)`. This will force a query\n-to execute even though you don't directly require its result.\n-\n-As an example, consider MIR const qualification. It wants to read the\n-result produced by the `mir_const()` suite. However, that result will\n-be **stolen** by the `mir_validated()` suite. If nothing was done,\n-then `mir_const_qualif(D)` would succeed if it came before\n-`mir_validated(D)`, but fail otherwise. Therefore, `mir_validated(D)`\n-will **force** `mir_const_qualif` before it actually steals, thus\n-ensuring that the reads have already happened:\n-\n-```\n-mir_const(D) --read-by--> mir_const_qualif(D)\n-     |                       ^\n-  stolen-by                  |\n-     |                    (forces)\n-     v                       |\n-mir_validated(D) ------------+\n-```\n-\n-### Implementing and registering a pass\n-\n-To create a new MIR pass, you simply implement the `MirPass` trait for\n-some fresh singleton type `Foo`. Once you have implemented a trait for\n-your type `Foo`, you then have to insert `Foo` into one of the suites;\n-this is done in `librustc_driver/driver.rs` by invoking `push_pass(S,\n-Foo)` with the appropriate suite substituted for `S`.\n-"}, {"sha": "fa7f5c08608bb6486aa3b0e9444c8eeca9b6a885", "filename": "src/librustc/traits/README.md", "status": "removed", "additions": 0, "deletions": 482, "changes": 482, "blob_url": "https://github.com/rust-lang/rust/blob/cbd0a2c6fdf3270d659488512311917957fee624/src%2Flibrustc%2Ftraits%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/cbd0a2c6fdf3270d659488512311917957fee624/src%2Flibrustc%2Ftraits%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2FREADME.md?ref=cbd0a2c6fdf3270d659488512311917957fee624", "patch": "@@ -1,482 +0,0 @@\n-# TRAIT RESOLUTION\n-\n-This document describes the general process and points out some non-obvious\n-things.\n-\n-## Major concepts\n-\n-Trait resolution is the process of pairing up an impl with each\n-reference to a trait. So, for example, if there is a generic function like:\n-\n-```rust\n-fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> { /*...*/ }\n-```\n-\n-and then a call to that function:\n-\n-```rust\n-let v: Vec<isize> = clone_slice(&[1, 2, 3])\n-```\n-\n-it is the job of trait resolution to figure out (in which case)\n-whether there exists an impl of `isize : Clone`\n-\n-Note that in some cases, like generic functions, we may not be able to\n-find a specific impl, but we can figure out that the caller must\n-provide an impl. To see what I mean, consider the body of `clone_slice`:\n-\n-```rust\n-fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> {\n-    let mut v = Vec::new();\n-    for e in &x {\n-        v.push((*e).clone()); // (*)\n-    }\n-}\n-```\n-\n-The line marked `(*)` is only legal if `T` (the type of `*e`)\n-implements the `Clone` trait. Naturally, since we don't know what `T`\n-is, we can't find the specific impl; but based on the bound `T:Clone`,\n-we can say that there exists an impl which the caller must provide.\n-\n-We use the term *obligation* to refer to a trait reference in need of\n-an impl.\n-\n-## Overview\n-\n-Trait resolution consists of three major parts:\n-\n-- SELECTION: Deciding how to resolve a specific obligation. For\n-  example, selection might decide that a specific obligation can be\n-  resolved by employing an impl which matches the self type, or by\n-  using a parameter bound. In the case of an impl, Selecting one\n-  obligation can create *nested obligations* because of where clauses\n-  on the impl itself. It may also require evaluating those nested\n-  obligations to resolve ambiguities.\n-\n-- FULFILLMENT: The fulfillment code is what tracks that obligations\n-  are completely fulfilled. Basically it is a worklist of obligations\n-  to be selected: once selection is successful, the obligation is\n-  removed from the worklist and any nested obligations are enqueued.\n-\n-- COHERENCE: The coherence checks are intended to ensure that there\n-  are never overlapping impls, where two impls could be used with\n-  equal precedence.\n-\n-## Selection\n-\n-Selection is the process of deciding whether an obligation can be\n-resolved and, if so, how it is to be resolved (via impl, where clause, etc).\n-The main interface is the `select()` function, which takes an obligation\n-and returns a `SelectionResult`. There are three possible outcomes:\n-\n-- `Ok(Some(selection))` -- yes, the obligation can be resolved, and\n-  `selection` indicates how. If the impl was resolved via an impl,\n-  then `selection` may also indicate nested obligations that are required\n-  by the impl.\n-\n-- `Ok(None)` -- we are not yet sure whether the obligation can be\n-  resolved or not. This happens most commonly when the obligation\n-  contains unbound type variables.\n-\n-- `Err(err)` -- the obligation definitely cannot be resolved due to a\n-  type error, or because there are no impls that could possibly apply,\n-  etc.\n-\n-The basic algorithm for selection is broken into two big phases:\n-candidate assembly and confirmation.\n-\n-### Candidate assembly\n-\n-Searches for impls/where-clauses/etc that might\n-possibly be used to satisfy the obligation. Each of those is called\n-a candidate. To avoid ambiguity, we want to find exactly one\n-candidate that is definitively applicable. In some cases, we may not\n-know whether an impl/where-clause applies or not -- this occurs when\n-the obligation contains unbound inference variables.\n-\n-The basic idea for candidate assembly is to do a first pass in which\n-we identify all possible candidates. During this pass, all that we do\n-is try and unify the type parameters. (In particular, we ignore any\n-nested where clauses.) Presuming that this unification succeeds, the\n-impl is added as a candidate.\n-\n-Once this first pass is done, we can examine the set of candidates. If\n-it is a singleton set, then we are done: this is the only impl in\n-scope that could possibly apply. Otherwise, we can winnow down the set\n-of candidates by using where clauses and other conditions. If this\n-reduced set yields a single, unambiguous entry, we're good to go,\n-otherwise the result is considered ambiguous.\n-\n-#### The basic process: Inferring based on the impls we see\n-\n-This process is easier if we work through some examples. Consider\n-the following trait:\n-\n-```rust\n-trait Convert<Target> {\n-    fn convert(&self) -> Target;\n-}\n-```\n-\n-This trait just has one method. It's about as simple as it gets. It\n-converts from the (implicit) `Self` type to the `Target` type. If we\n-wanted to permit conversion between `isize` and `usize`, we might\n-implement `Convert` like so:\n-\n-```rust\n-impl Convert<usize> for isize { /*...*/ } // isize -> usize\n-impl Convert<isize> for usize { /*...*/ } // usize -> isize\n-```\n-\n-Now imagine there is some code like the following:\n-\n-```rust\n-let x: isize = ...;\n-let y = x.convert();\n-```\n-\n-The call to convert will generate a trait reference `Convert<$Y> for\n-isize`, where `$Y` is the type variable representing the type of\n-`y`. When we match this against the two impls we can see, we will find\n-that only one remains: `Convert<usize> for isize`. Therefore, we can\n-select this impl, which will cause the type of `$Y` to be unified to\n-`usize`. (Note that while assembling candidates, we do the initial\n-unifications in a transaction, so that they don't affect one another.)\n-\n-There are tests to this effect in src/test/run-pass:\n-\n-   traits-multidispatch-infer-convert-source-and-target.rs\n-   traits-multidispatch-infer-convert-target.rs\n-\n-#### Winnowing: Resolving ambiguities\n-\n-But what happens if there are multiple impls where all the types\n-unify? Consider this example:\n-\n-```rust\n-trait Get {\n-    fn get(&self) -> Self;\n-}\n-\n-impl<T:Copy> Get for T {\n-    fn get(&self) -> T { *self }\n-}\n-\n-impl<T:Get> Get for Box<T> {\n-    fn get(&self) -> Box<T> { box get_it(&**self) }\n-}\n-```\n-\n-What happens when we invoke `get_it(&box 1_u16)`, for example? In this\n-case, the `Self` type is `Box<u16>` -- that unifies with both impls,\n-because the first applies to all types, and the second to all\n-boxes. In the olden days we'd have called this ambiguous. But what we\n-do now is do a second *winnowing* pass that considers where clauses\n-and attempts to remove candidates -- in this case, the first impl only\n-applies if `Box<u16> : Copy`, which doesn't hold. After winnowing,\n-then, we are left with just one candidate, so we can proceed. There is\n-a test of this in `src/test/run-pass/traits-conditional-dispatch.rs`.\n-\n-#### Matching\n-\n-The subroutines that decide whether a particular impl/where-clause/etc\n-applies to a particular obligation. At the moment, this amounts to\n-unifying the self types, but in the future we may also recursively\n-consider some of the nested obligations, in the case of an impl.\n-\n-#### Lifetimes and selection\n-\n-Because of how that lifetime inference works, it is not possible to\n-give back immediate feedback as to whether a unification or subtype\n-relationship between lifetimes holds or not. Therefore, lifetime\n-matching is *not* considered during selection. This is reflected in\n-the fact that subregion assignment is infallible. This may yield\n-lifetime constraints that will later be found to be in error (in\n-contrast, the non-lifetime-constraints have already been checked\n-during selection and can never cause an error, though naturally they\n-may lead to other errors downstream).\n-\n-#### Where clauses\n-\n-Besides an impl, the other major way to resolve an obligation is via a\n-where clause. The selection process is always given a *parameter\n-environment* which contains a list of where clauses, which are\n-basically obligations that can assume are satisfiable. We will iterate\n-over that list and check whether our current obligation can be found\n-in that list, and if so it is considered satisfied. More precisely, we\n-want to check whether there is a where-clause obligation that is for\n-the same trait (or some subtrait) and for which the self types match,\n-using the definition of *matching* given above.\n-\n-Consider this simple example:\n-\n-```rust\n-trait A1 { /*...*/ }\n-trait A2 : A1 { /*...*/ }\n-\n-trait B { /*...*/ }\n-\n-fn foo<X:A2+B> { /*...*/ }\n-```\n-\n-Clearly we can use methods offered by `A1`, `A2`, or `B` within the\n-body of `foo`. In each case, that will incur an obligation like `X :\n-A1` or `X : A2`. The parameter environment will contain two\n-where-clauses, `X : A2` and `X : B`. For each obligation, then, we\n-search this list of where-clauses.  To resolve an obligation `X:A1`,\n-we would note that `X:A2` implies that `X:A1`.\n-\n-### Confirmation\n-\n-Confirmation unifies the output type parameters of the trait with the\n-values found in the obligation, possibly yielding a type error.  If we\n-return to our example of the `Convert` trait from the previous\n-section, confirmation is where an error would be reported, because the\n-impl specified that `T` would be `usize`, but the obligation reported\n-`char`. Hence the result of selection would be an error.\n-\n-### Selection during translation\n-\n-During type checking, we do not store the results of trait selection.\n-We simply wish to verify that trait selection will succeed. Then\n-later, at trans time, when we have all concrete types available, we\n-can repeat the trait selection.  In this case, we do not consider any\n-where-clauses to be in scope. We know that therefore each resolution\n-will resolve to a particular impl.\n-\n-One interesting twist has to do with nested obligations. In general, in trans,\n-we only need to do a \"shallow\" selection for an obligation. That is, we wish to\n-identify which impl applies, but we do not (yet) need to decide how to select\n-any nested obligations. Nonetheless, we *do* currently do a complete resolution,\n-and that is because it can sometimes inform the results of type inference. That is,\n-we do not have the full substitutions in terms of the type variables of the impl available\n-to us, so we must run trait selection to figure everything out.\n-\n-Here is an example:\n-\n-```rust\n-trait Foo { /*...*/ }\n-impl<U,T:Bar<U>> Foo for Vec<T> { /*...*/ }\n-\n-impl Bar<usize> for isize { /*...*/ }\n-```\n-\n-After one shallow round of selection for an obligation like `Vec<isize>\n-: Foo`, we would know which impl we want, and we would know that\n-`T=isize`, but we do not know the type of `U`.  We must select the\n-nested obligation `isize : Bar<U>` to find out that `U=usize`.\n-\n-It would be good to only do *just as much* nested resolution as\n-necessary. Currently, though, we just do a full resolution.\n-\n-# Higher-ranked trait bounds\n-\n-One of the more subtle concepts at work are *higher-ranked trait\n-bounds*. An example of such a bound is `for<'a> MyTrait<&'a isize>`.\n-Let's walk through how selection on higher-ranked trait references\n-works.\n-\n-## Basic matching and skolemization leaks\n-\n-Let's walk through the test `compile-fail/hrtb-just-for-static.rs` to see\n-how it works. The test starts with the trait `Foo`:\n-\n-```rust\n-trait Foo<X> {\n-    fn foo(&self, x: X) { }\n-}\n-```\n-\n-Let's say we have a function `want_hrtb` that wants a type which\n-implements `Foo<&'a isize>` for any `'a`:\n-\n-```rust\n-fn want_hrtb<T>() where T : for<'a> Foo<&'a isize> { ... }\n-```\n-\n-Now we have a struct `AnyInt` that implements `Foo<&'a isize>` for any\n-`'a`:\n-\n-```rust\n-struct AnyInt;\n-impl<'a> Foo<&'a isize> for AnyInt { }\n-```\n-\n-And the question is, does `AnyInt : for<'a> Foo<&'a isize>`? We want the\n-answer to be yes. The algorithm for figuring it out is closely related\n-to the subtyping for higher-ranked types (which is described in\n-`middle::infer::higher_ranked::doc`, but also in a [paper by SPJ] that\n-I recommend you read).\n-\n-1. Skolemize the obligation.\n-2. Match the impl against the skolemized obligation.\n-3. Check for skolemization leaks.\n-\n-[paper by SPJ]: http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/\n-\n-So let's work through our example. The first thing we would do is to\n-skolemize the obligation, yielding `AnyInt : Foo<&'0 isize>` (here `'0`\n-represents skolemized region #0). Note that now have no quantifiers;\n-in terms of the compiler type, this changes from a `ty::PolyTraitRef`\n-to a `TraitRef`. We would then create the `TraitRef` from the impl,\n-using fresh variables for it's bound regions (and thus getting\n-`Foo<&'$a isize>`, where `'$a` is the inference variable for `'a`). Next\n-we relate the two trait refs, yielding a graph with the constraint\n-that `'0 == '$a`. Finally, we check for skolemization \"leaks\" -- a\n-leak is basically any attempt to relate a skolemized region to another\n-skolemized region, or to any region that pre-existed the impl match.\n-The leak check is done by searching from the skolemized region to find\n-the set of regions that it is related to in any way. This is called\n-the \"taint\" set. To pass the check, that set must consist *solely* of\n-itself and region variables from the impl. If the taint set includes\n-any other region, then the match is a failure. In this case, the taint\n-set for `'0` is `{'0, '$a}`, and hence the check will succeed.\n-\n-Let's consider a failure case. Imagine we also have a struct\n-\n-```rust\n-struct StaticInt;\n-impl Foo<&'static isize> for StaticInt;\n-```\n-\n-We want the obligation `StaticInt : for<'a> Foo<&'a isize>` to be\n-considered unsatisfied. The check begins just as before. `'a` is\n-skolemized to `'0` and the impl trait reference is instantiated to\n-`Foo<&'static isize>`. When we relate those two, we get a constraint\n-like `'static == '0`. This means that the taint set for `'0` is `{'0,\n-'static}`, which fails the leak check.\n-\n-## Higher-ranked trait obligations\n-\n-Once the basic matching is done, we get to another interesting topic:\n-how to deal with impl obligations. I'll work through a simple example\n-here. Imagine we have the traits `Foo` and `Bar` and an associated impl:\n-\n-```rust\n-trait Foo<X> {\n-    fn foo(&self, x: X) { }\n-}\n-\n-trait Bar<X> {\n-    fn bar(&self, x: X) { }\n-}\n-\n-impl<X,F> Foo<X> for F\n-    where F : Bar<X>\n-{\n-}\n-```\n-\n-Now let's say we have a obligation `for<'a> Foo<&'a isize>` and we match\n-this impl. What obligation is generated as a result? We want to get\n-`for<'a> Bar<&'a isize>`, but how does that happen?\n-\n-After the matching, we are in a position where we have a skolemized\n-substitution like `X => &'0 isize`. If we apply this substitution to the\n-impl obligations, we get `F : Bar<&'0 isize>`. Obviously this is not\n-directly usable because the skolemized region `'0` cannot leak out of\n-our computation.\n-\n-What we do is to create an inverse mapping from the taint set of `'0`\n-back to the original bound region (`'a`, here) that `'0` resulted\n-from. (This is done in `higher_ranked::plug_leaks`). We know that the\n-leak check passed, so this taint set consists solely of the skolemized\n-region itself plus various intermediate region variables. We then walk\n-the trait-reference and convert every region in that taint set back to\n-a late-bound region, so in this case we'd wind up with `for<'a> F :\n-Bar<&'a isize>`.\n-\n-# Caching and subtle considerations therewith\n-\n-In general we attempt to cache the results of trait selection.  This\n-is a somewhat complex process. Part of the reason for this is that we\n-want to be able to cache results even when all the types in the trait\n-reference are not fully known. In that case, it may happen that the\n-trait selection process is also influencing type variables, so we have\n-to be able to not only cache the *result* of the selection process,\n-but *replay* its effects on the type variables.\n-\n-## An example\n-\n-The high-level idea of how the cache works is that we first replace\n-all unbound inference variables with skolemized versions. Therefore,\n-if we had a trait reference `usize : Foo<$1>`, where `$n` is an unbound\n-inference variable, we might replace it with `usize : Foo<%0>`, where\n-`%n` is a skolemized type. We would then look this up in the cache.\n-If we found a hit, the hit would tell us the immediate next step to\n-take in the selection process: i.e., apply impl #22, or apply where\n-clause `X : Foo<Y>`. Let's say in this case there is no hit.\n-Therefore, we search through impls and where clauses and so forth, and\n-we come to the conclusion that the only possible impl is this one,\n-with def-id 22:\n-\n-```rust\n-impl Foo<isize> for usize { ... } // Impl #22\n-```\n-\n-We would then record in the cache `usize : Foo<%0> ==>\n-ImplCandidate(22)`. Next we would confirm `ImplCandidate(22)`, which\n-would (as a side-effect) unify `$1` with `isize`.\n-\n-Now, at some later time, we might come along and see a `usize :\n-Foo<$3>`.  When skolemized, this would yield `usize : Foo<%0>`, just as\n-before, and hence the cache lookup would succeed, yielding\n-`ImplCandidate(22)`. We would confirm `ImplCandidate(22)` which would\n-(as a side-effect) unify `$3` with `isize`.\n-\n-## Where clauses and the local vs global cache\n-\n-One subtle interaction is that the results of trait lookup will vary\n-depending on what where clauses are in scope. Therefore, we actually\n-have *two* caches, a local and a global cache. The local cache is\n-attached to the `ParamEnv` and the global cache attached to the\n-`tcx`. We use the local cache whenever the result might depend on the\n-where clauses that are in scope. The determination of which cache to\n-use is done by the method `pick_candidate_cache` in `select.rs`. At\n-the moment, we use a very simple, conservative rule: if there are any\n-where-clauses in scope, then we use the local cache.  We used to try\n-and draw finer-grained distinctions, but that led to a serious of\n-annoying and weird bugs like #22019 and #18290. This simple rule seems\n-to be pretty clearly safe and also still retains a very high hit rate\n-(~95% when compiling rustc).\n-\n-# Specialization\n-\n-Defined in the `specialize` module.\n-\n-The basic strategy is to build up a *specialization graph* during\n-coherence checking. Insertion into the graph locates the right place\n-to put an impl in the specialization hierarchy; if there is no right\n-place (due to partial overlap but no containment), you get an overlap\n-error. Specialization is consulted when selecting an impl (of course),\n-and the graph is consulted when propagating defaults down the\n-specialization hierarchy.\n-\n-You might expect that the specialization graph would be used during\n-selection -- i.e., when actually performing specialization. This is\n-not done for two reasons:\n-\n-- It's merely an optimization: given a set of candidates that apply,\n-  we can determine the most specialized one by comparing them directly\n-  for specialization, rather than consulting the graph. Given that we\n-  also cache the results of selection, the benefit of this\n-  optimization is questionable.\n-\n-- To build the specialization graph in the first place, we need to use\n-  selection (because we need to determine whether one impl specializes\n-  another). Dealing with this reentrancy would require some additional\n-  mode switch for selection. Given that there seems to be no strong\n-  reason to use the graph anyway, we stick with a simpler approach in\n-  selection, and use the graph only for propagating default\n-  implementations.\n-\n-Trait impl selection can succeed even when multiple impls can apply,\n-as long as they are part of the same specialization family. In that\n-case, it returns a *single* impl on success -- this is the most\n-specialized impl *known* to apply. However, if there are any inference\n-variables in play, the returned impl may not be the actual impl we\n-will use at trans time. Thus, we take special care to avoid projecting\n-associated types unless either (1) the associated type does not use\n-`default` and thus cannot be overridden or (2) all input types are\n-known concretely."}, {"sha": "a9f1c8750f4be77f61c8e8d9c18e6bbff12d8764", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af55518bcf79f382deec3458a83d0b8079da785a/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af55518bcf79f382deec3458a83d0b8079da785a/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=af55518bcf79f382deec3458a83d0b8079da785a", "patch": "@@ -8,7 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! See `README.md` for high-level documentation\n+//! See rustc guide chapters on [trait-resolution] and [trait-specialization] for more info on how\n+//! this works.\n+//!\n+//! [trait-resolution]: https://rust-lang-nursery.github.io/rustc-guide/trait-resolution.html\n+//! [trait-specialization]: https://rust-lang-nursery.github.io/rustc-guide/trait-specialization.html\n \n use hir::def_id::{DefId, LOCAL_CRATE};\n use syntax_pos::DUMMY_SP;"}, {"sha": "c1ffc10c3c0f0f65e51b1904915c3d8b91c1e0e5", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af55518bcf79f382deec3458a83d0b8079da785a/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af55518bcf79f382deec3458a83d0b8079da785a/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=af55518bcf79f382deec3458a83d0b8079da785a", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Trait Resolution. See README.md for an overview of how this works.\n+//! Trait Resolution. See [rustc guide] for more info on how this works.\n+//!\n+//! [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/trait-resolution.html\n \n pub use self::SelectionError::*;\n pub use self::FulfillmentErrorCode::*;"}, {"sha": "f21ec295c5f7b014d075f8feb3b1901c15e09014", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/af55518bcf79f382deec3458a83d0b8079da785a/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af55518bcf79f382deec3458a83d0b8079da785a/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=af55518bcf79f382deec3458a83d0b8079da785a", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! See `README.md` for high-level documentation\n+//! See [rustc guide] for more info on how this works.\n+//!\n+//! [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/trait-resolution.html#selection\n \n use self::SelectionCandidate::*;\n use self::EvaluationResult::*;\n@@ -1045,8 +1047,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     //\n     // The selection process begins by examining all in-scope impls,\n     // caller obligations, and so forth and assembling a list of\n-    // candidates. See `README.md` and the `Candidate` type for more\n-    // details.\n+    // candidates. See [rustc guide] for more details.\n+    //\n+    // [rustc guide]:\n+    // https://rust-lang-nursery.github.io/rustc-guide/trait-resolution.html#candidate-assembly\n \n     fn candidate_from_obligation<'o>(&mut self,\n                                      stack: &TraitObligationStack<'o, 'tcx>)\n@@ -2333,7 +2337,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     //\n     // Confirmation unifies the output type parameters of the trait\n     // with the values found in the obligation, possibly yielding a\n-    // type error.  See `README.md` for more details.\n+    // type error.  See [rustc guide] for more details.\n+    //\n+    // [rustc guide]:\n+    // https://rust-lang-nursery.github.io/rustc-guide/trait-resolution.html#confirmation\n \n     fn confirm_candidate(&mut self,\n                          obligation: &TraitObligation<'tcx>,"}, {"sha": "72d9dd9012ca98f892ded68e8dff277c4304efef", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/af55518bcf79f382deec3458a83d0b8079da785a/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af55518bcf79f382deec3458a83d0b8079da785a/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=af55518bcf79f382deec3458a83d0b8079da785a", "patch": "@@ -8,14 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Logic and data structures related to impl specialization, explained in\n-// greater detail below.\n-//\n-// At the moment, this implementation support only the simple \"chain\" rule:\n-// If any two impls overlap, one must be a strict subset of the other.\n-//\n-// See traits/README.md for a bit more detail on how specialization\n-// fits together with the rest of the trait machinery.\n+//! Logic and data structures related to impl specialization, explained in\n+//! greater detail below.\n+//!\n+//! At the moment, this implementation support only the simple \"chain\" rule:\n+//! If any two impls overlap, one must be a strict subset of the other.\n+//!\n+//! See the [rustc guide] for a bit more detail on how specialization\n+//! fits together with the rest of the trait machinery.\n+//!\n+//! [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/trait-specialization.html\n \n use super::{SelectionContext, FulfillmentContext};\n use super::util::impl_trait_ref_and_oblig;"}, {"sha": "3fd956ecfb87dea7f60567b9cf192103b7b5c8e2", "filename": "src/librustc/ty/README.md", "status": "removed", "additions": 0, "deletions": 165, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/cbd0a2c6fdf3270d659488512311917957fee624/src%2Flibrustc%2Fty%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/cbd0a2c6fdf3270d659488512311917957fee624/src%2Flibrustc%2Fty%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2FREADME.md?ref=cbd0a2c6fdf3270d659488512311917957fee624", "patch": "@@ -1,165 +0,0 @@\n-# Types and the Type Context\n-\n-The `ty` module defines how the Rust compiler represents types\n-internally. It also defines the *typing context* (`tcx` or `TyCtxt`),\n-which is the central data structure in the compiler.\n-\n-## The tcx and how it uses lifetimes\n-\n-The `tcx` (\"typing context\") is the central data structure in the\n-compiler. It is the context that you use to perform all manner of\n-queries. The struct `TyCtxt` defines a reference to this shared context:\n-\n-```rust\n-tcx: TyCtxt<'a, 'gcx, 'tcx>\n-//          --  ----  ----\n-//          |   |     |\n-//          |   |     innermost arena lifetime (if any)\n-//          |   \"global arena\" lifetime\n-//          lifetime of this reference\n-```\n-\n-As you can see, the `TyCtxt` type takes three lifetime parameters.\n-These lifetimes are perhaps the most complex thing to understand about\n-the tcx. During Rust compilation, we allocate most of our memory in\n-**arenas**, which are basically pools of memory that get freed all at\n-once. When you see a reference with a lifetime like `'tcx` or `'gcx`,\n-you know that it refers to arena-allocated data (or data that lives as\n-long as the arenas, anyhow).\n-\n-We use two distinct levels of arenas. The outer level is the \"global\n-arena\". This arena lasts for the entire compilation: so anything you\n-allocate in there is only freed once compilation is basically over\n-(actually, when we shift to executing LLVM).\n-\n-To reduce peak memory usage, when we do type inference, we also use an\n-inner level of arena. These arenas get thrown away once type inference\n-is over. This is done because type inference generates a lot of\n-\"throw-away\" types that are not particularly interesting after type\n-inference completes, so keeping around those allocations would be\n-wasteful.\n-\n-Often, we wish to write code that explicitly asserts that it is not\n-taking place during inference. In that case, there is no \"local\"\n-arena, and all the types that you can access are allocated in the\n-global arena.  To express this, the idea is to use the same lifetime\n-for the `'gcx` and `'tcx` parameters of `TyCtxt`. Just to be a touch\n-confusing, we tend to use the name `'tcx` in such contexts. Here is an\n-example:\n-\n-```rust\n-fn not_in_inference<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n-    //                                        ----  ----\n-    //                                        Using the same lifetime here asserts\n-    //                                        that the innermost arena accessible through\n-    //                                        this reference *is* the global arena.\n-}\n-```\n-\n-In contrast, if we want to code that can be usable during type inference, then you\n-need to declare a distinct `'gcx` and `'tcx` lifetime parameter:\n-\n-```rust\n-fn maybe_in_inference<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId) {\n-    //                                                ----  ----\n-    //                                        Using different lifetimes here means that\n-    //                                        the innermost arena *may* be distinct\n-    //                                        from the global arena (but doesn't have to be).\n-}\n-```\n-\n-### Allocating and working with types\n-\n-Rust types are represented using the `Ty<'tcx>` defined in the `ty`\n-module (not to be confused with the `Ty` struct from [the HIR]). This\n-is in fact a simple type alias for a reference with `'tcx` lifetime:\n-\n-```rust\n-pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n-```\n-\n-[the HIR]: ../hir/README.md\n-\n-You can basically ignore the `TyS` struct -- you will basically never\n-access it explicitly. We always pass it by reference using the\n-`Ty<'tcx>` alias -- the only exception I think is to define inherent\n-methods on types. Instances of `TyS` are only ever allocated in one of\n-the rustc arenas (never e.g. on the stack).\n-\n-One common operation on types is to **match** and see what kinds of\n-types they are. This is done by doing `match ty.sty`, sort of like this:\n-\n-```rust\n-fn test_type<'tcx>(ty: Ty<'tcx>) {\n-    match ty.sty {\n-        ty::TyArray(elem_ty, len) => { ... }\n-        ...\n-    }\n-}\n-```\n-\n-The `sty` field (the origin of this name is unclear to me; perhaps\n-structural type?) is of type `TypeVariants<'tcx>`, which is an enum\n-defining all of the different kinds of types in the compiler.\n-\n-> NB: inspecting the `sty` field on types during type inference can be\n-> risky, as there may be inference variables and other things to\n-> consider, or sometimes types are not yet known that will become\n-> known later.).\n-\n-To allocate a new type, you can use the various `mk_` methods defined\n-on the `tcx`. These have names that correpond mostly to the various kinds\n-of type variants. For example:\n-\n-```rust\n-let array_ty = tcx.mk_array(elem_ty, len * 2);\n-```\n-\n-These methods all return a `Ty<'tcx>` -- note that the lifetime you\n-get back is the lifetime of the innermost arena that this `tcx` has\n-access to. In fact, types are always canonicalized and interned (so we\n-never allocate exactly the same type twice) and are always allocated\n-in the outermost arena where they can be (so, if they do not contain\n-any inference variables or other \"temporary\" types, they will be\n-allocated in the global arena). However, the lifetime `'tcx` is always\n-a safe approximation, so that is what you get back.\n-\n-> NB. Because types are interned, it is possible to compare them for\n-> equality efficiently using `==` -- however, this is almost never what\n-> you want to do unless you happen to be hashing and looking for\n-> duplicates. This is because often in Rust there are multiple ways to\n-> represent the same type, particularly once inference is involved. If\n-> you are going to be testing for type equality, you probably need to\n-> start looking into the inference code to do it right.\n-\n-You can also find various common types in the `tcx` itself by accessing\n-`tcx.types.bool`, `tcx.types.char`, etc (see `CommonTypes` for more).\n-\n-### Beyond types: Other kinds of arena-allocated data structures\n-\n-In addition to types, there are a number of other arena-allocated data\n-structures that you can allocate, and which are found in this\n-module. Here are a few examples:\n-\n-- `Substs`, allocated with `mk_substs` -- this will intern a slice of types, often used to\n-  specify the values to be substituted for generics (e.g., `HashMap<i32, u32>`\n-  would be represented as a slice `&'tcx [tcx.types.i32, tcx.types.u32]`).\n-- `TraitRef`, typically passed by value -- a **trait reference**\n-  consists of a reference to a trait along with its various type\n-  parameters (including `Self`), like `i32: Display` (here, the def-id\n-  would reference the `Display` trait, and the substs would contain\n-  `i32`).\n-- `Predicate` defines something the trait system has to prove (see `traits` module).\n-\n-### Import conventions\n-\n-Although there is no hard and fast rule, the `ty` module tends to be used like so:\n-\n-```rust\n-use ty::{self, Ty, TyCtxt};\n-```\n-\n-In particular, since they are so common, the `Ty` and `TyCtxt` types\n-are imported directly. Other types are often referenced with an\n-explicit `ty::` prefix (e.g., `ty::TraitRef<'tcx>`). But some modules\n-choose to import a larger or smaller set of names explicitly."}, {"sha": "3613a34f66af6505f6552ef12b87ccf0c8c6cdd5", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af55518bcf79f382deec3458a83d0b8079da785a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af55518bcf79f382deec3458a83d0b8079da785a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=af55518bcf79f382deec3458a83d0b8079da785a", "patch": "@@ -779,9 +779,9 @@ impl<'tcx> CommonTypes<'tcx> {\n /// The central data structure of the compiler. It stores references\n /// to the various **arenas** and also houses the results of the\n /// various **compiler queries** that have been performed. See the\n-/// module-level [README] for more details.\n+/// [rustc guide] for more details.\n ///\n-/// [README]: https://github.com/rust-lang/rust/blob/master/src/librustc/ty/README.md\n+/// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/ty.html\n #[derive(Copy, Clone)]\n pub struct TyCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     gcx: &'a GlobalCtxt<'gcx>,"}]}