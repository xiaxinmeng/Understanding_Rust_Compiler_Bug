{"sha": "acd4dc2d0ca8676fbf105507504e24d44e5dd1f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjZDRkYzJkMGNhODY3NmZiZjEwNTUwNzUwNGUyNGQ0NGU1ZGQxZjY=", "commit": {"author": {"name": "Justus K", "email": "justus.k@protonmail.com", "date": "2021-06-26T15:10:52Z"}, "committer": {"name": "Justus K", "email": "justus.k@protonmail.com", "date": "2021-07-05T17:49:48Z"}, "message": "rustdoc: Rename `expect_real` to `expect_def_id`, remove `Item::is_fake`", "tree": {"sha": "61838b769e919de0dfc89ca1e4c7389663c46978", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61838b769e919de0dfc89ca1e4c7389663c46978"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEDDGYqKFKtc1ioGY0jGL+mKYvxGIFAmDjRjwACgkQjGL+mKYv\nxGK4Gg//VhTPzcmVHHsbTR1aJ/M3a+p+6yiIn0zyelbDmQZwfHuyJW6QpTgTi+Ya\nVP8bGKtUMKbhqCrA9GjVXOn4pEd9GFbiQArSRxMrPeloSpXyMfc70cfD+vN+NXvW\nPk1IRM2iecBf9MMEwwzugwaiGwNqErMiT2cOYbo4tUbrvonKncxpiY5s3jGx8Nyt\n2MbFWfsZQmXGivEXUN4+ctQBhFE6lQYhEHVer03e8jvqRlZfbut/PiHJvNa0ReUQ\nO9OW8LwpmvoaqfLThDH3cU7kT0xSWUkOzYQ3G6h0PEUroxmfDcJfZfc8BMAM6r9q\neHhvLXgGurntaisOE+BQG1ggxuTBSGlMte4IuYSoWZ5db2imn33lGki1uC55NjWb\nVJbAuBGFztDOmSm/wH16AjItXiELNfxeNIAum6b7/Ap6/eTI4v7LbBEMm37tJbs+\nDFNwQ2R0s7Hx5oY2m3hhtIru65Q1xi3V7EWWvRmtwBRWWJM7WcyIreZv+4lWBWBB\nM9JwFpPu0mpj5MnPmhnppAXYZg77kn0dr6vfSVv/O+tN+TaOLbcQoib2HX1TfPHz\nepx8fpoR0d0iMh/Th8+IqAY+GrIJbh8XHspYM7dQ6chJHquGK4ikV4fso4GXjCPy\nx7b0cHMSoBTk97iMHr37qajsO2ACzp39FZCawgisSDyP7mO2hME=\n=VC/g\n-----END PGP SIGNATURE-----", "payload": "tree 61838b769e919de0dfc89ca1e4c7389663c46978\nparent 43e1cdbaf9230cc36b18f9ab41079449c5cac375\nauthor Justus K <justus.k@protonmail.com> 1624720252 +0200\ncommitter Justus K <justus.k@protonmail.com> 1625507388 +0200\n\nrustdoc: Rename `expect_real` to `expect_def_id`, remove `Item::is_fake`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6", "html_url": "https://github.com/rust-lang/rust/commit/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/comments", "author": {"login": "Stupremee", "id": 39732259, "node_id": "MDQ6VXNlcjM5NzMyMjU5", "avatar_url": "https://avatars.githubusercontent.com/u/39732259?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Stupremee", "html_url": "https://github.com/Stupremee", "followers_url": "https://api.github.com/users/Stupremee/followers", "following_url": "https://api.github.com/users/Stupremee/following{/other_user}", "gists_url": "https://api.github.com/users/Stupremee/gists{/gist_id}", "starred_url": "https://api.github.com/users/Stupremee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Stupremee/subscriptions", "organizations_url": "https://api.github.com/users/Stupremee/orgs", "repos_url": "https://api.github.com/users/Stupremee/repos", "events_url": "https://api.github.com/users/Stupremee/events{/privacy}", "received_events_url": "https://api.github.com/users/Stupremee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Stupremee", "id": 39732259, "node_id": "MDQ6VXNlcjM5NzMyMjU5", "avatar_url": "https://avatars.githubusercontent.com/u/39732259?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Stupremee", "html_url": "https://github.com/Stupremee", "followers_url": "https://api.github.com/users/Stupremee/followers", "following_url": "https://api.github.com/users/Stupremee/following{/other_user}", "gists_url": "https://api.github.com/users/Stupremee/gists{/gist_id}", "starred_url": "https://api.github.com/users/Stupremee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Stupremee/subscriptions", "organizations_url": "https://api.github.com/users/Stupremee/orgs", "repos_url": "https://api.github.com/users/Stupremee/repos", "events_url": "https://api.github.com/users/Stupremee/events{/privacy}", "received_events_url": "https://api.github.com/users/Stupremee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43e1cdbaf9230cc36b18f9ab41079449c5cac375", "url": "https://api.github.com/repos/rust-lang/rust/commits/43e1cdbaf9230cc36b18f9ab41079449c5cac375", "html_url": "https://github.com/rust-lang/rust/commit/43e1cdbaf9230cc36b18f9ab41079449c5cac375"}], "stats": {"total": 208, "additions": 103, "deletions": 105}, "files": [{"sha": "12c9e561f04be1438c8cb90c36250ebcadaad2aa", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=acd4dc2d0ca8676fbf105507504e24d44e5dd1f6", "patch": "@@ -66,20 +66,22 @@ impl ItemId {\n     #[inline]\n     crate fn is_local(self) -> bool {\n         match self {\n-            ItemId::DefId(id) => id.is_local(),\n-            _ => false,\n+            ItemId::Auto { for_: id, .. }\n+            | ItemId::Blanket { for_: id, .. }\n+            | ItemId::DefId(id) => id.is_local(),\n+            ItemId::Primitive(krate) => krate == LOCAL_CRATE,\n         }\n     }\n \n     #[inline]\n     #[track_caller]\n-    crate fn expect_real(self) -> rustc_hir::def_id::DefId {\n-        self.as_real()\n-            .unwrap_or_else(|| panic!(\"ItemId::expect_real: `{:?}` isn't a real ItemId\", self))\n+    crate fn expect_def_id(self) -> DefId {\n+        self.as_def_id()\n+            .unwrap_or_else(|| panic!(\"ItemId::expect_def_id: `{:?}` isn't a DefId\", self))\n     }\n \n     #[inline]\n-    crate fn as_real(self) -> Option<DefId> {\n+    crate fn as_def_id(self) -> Option<DefId> {\n         match self {\n             ItemId::DefId(id) => Some(id),\n             _ => None,\n@@ -89,9 +91,9 @@ impl ItemId {\n     #[inline]\n     crate fn krate(self) -> CrateNum {\n         match self {\n-            ItemId::DefId(id) => id.krate,\n-            ItemId::Auto { trait_, .. } => trait_.krate,\n-            ItemId::Blanket { trait_, .. } => trait_.krate,\n+            ItemId::Auto { for_: id, .. }\n+            | ItemId::Blanket { for_: id, .. }\n+            | ItemId::DefId(id) => id.krate,\n             ItemId::Primitive(krate) => krate,\n         }\n     }\n@@ -100,9 +102,7 @@ impl ItemId {\n     crate fn index(self) -> Option<DefIndex> {\n         match self {\n             ItemId::DefId(id) => Some(id.index),\n-            ItemId::Auto { trait_, .. } => Some(trait_.index),\n-            ItemId::Blanket { trait_, .. } => Some(trait_.index),\n-            ItemId::Primitive(..) => None,\n+            _ => None,\n         }\n     }\n }\n@@ -354,19 +354,19 @@ crate fn rustc_span(def_id: DefId, tcx: TyCtxt<'_>) -> Span {\n \n impl Item {\n     crate fn stability<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<&'tcx Stability> {\n-        if self.is_fake() { None } else { tcx.lookup_stability(self.def_id.expect_real()) }\n+        self.def_id.as_def_id().and_then(|did| tcx.lookup_stability(did))\n     }\n \n     crate fn const_stability<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<&'tcx ConstStability> {\n-        if self.is_fake() { None } else { tcx.lookup_const_stability(self.def_id.expect_real()) }\n+        self.def_id.as_def_id().and_then(|did| tcx.lookup_const_stability(did))\n     }\n \n     crate fn deprecation(&self, tcx: TyCtxt<'_>) -> Option<Deprecation> {\n-        if self.is_fake() { None } else { tcx.lookup_deprecation(self.def_id.expect_real()) }\n+        self.def_id.as_def_id().and_then(|did| tcx.lookup_deprecation(did))\n     }\n \n     crate fn inner_docs(&self, tcx: TyCtxt<'_>) -> bool {\n-        if self.is_fake() { false } else { tcx.get_attrs(self.def_id.expect_real()).inner_docs() }\n+        self.def_id.as_def_id().map(|did| tcx.get_attrs(did).inner_docs()).unwrap_or(false)\n     }\n \n     crate fn span(&self, tcx: TyCtxt<'_>) -> Span {\n@@ -378,10 +378,8 @@ impl Item {\n             kind\n         {\n             *span\n-        } else if self.is_fake() {\n-            Span::dummy()\n         } else {\n-            rustc_span(self.def_id.expect_real(), tcx)\n+            self.def_id.as_def_id().map(|did| rustc_span(did, tcx)).unwrap_or_else(|| Span::dummy())\n         }\n     }\n \n@@ -546,7 +544,7 @@ impl Item {\n     }\n \n     crate fn is_crate(&self) -> bool {\n-        self.is_mod() && self.def_id.as_real().map_or(false, |did| did.index == CRATE_DEF_INDEX)\n+        self.is_mod() && self.def_id.as_def_id().map_or(false, |did| did.index == CRATE_DEF_INDEX)\n     }\n     crate fn is_mod(&self) -> bool {\n         self.type_() == ItemType::Module\n@@ -657,11 +655,6 @@ impl Item {\n             _ => false,\n         }\n     }\n-\n-    crate fn is_fake(&self) -> bool {\n-        // FIXME: Find a better way to handle this\n-        !matches!(self.def_id, ItemId::DefId(..))\n-    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "671e9e5c382b2f94b6b936c57746f3c5186b86c8", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=acd4dc2d0ca8676fbf105507504e24d44e5dd1f6", "patch": "@@ -215,7 +215,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n         // Propagate a trait method's documentation to all implementors of the\n         // trait.\n         if let clean::TraitItem(ref t) = *item.kind {\n-            self.cache.traits.entry(item.def_id.expect_real()).or_insert_with(|| {\n+            self.cache.traits.entry(item.def_id.expect_def_id()).or_insert_with(|| {\n                 clean::TraitWithExtraInfo {\n                     trait_: t.clone(),\n                     is_notable: item.attrs.has_doc_flag(sym::notable_trait),\n@@ -348,11 +348,11 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                     // `public_items` map, so we can skip inserting into the\n                     // paths map if there was already an entry present and we're\n                     // not a public item.\n-                    if !self.cache.paths.contains_key(&item.def_id.expect_real())\n-                        || self.cache.access_levels.is_public(item.def_id.expect_real())\n+                    if !self.cache.paths.contains_key(&item.def_id.expect_def_id())\n+                        || self.cache.access_levels.is_public(item.def_id.expect_def_id())\n                     {\n                         self.cache.paths.insert(\n-                            item.def_id.expect_real(),\n+                            item.def_id.expect_def_id(),\n                             (self.cache.stack.clone(), item.type_()),\n                         );\n                     }\n@@ -361,7 +361,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n             clean::PrimitiveItem(..) => {\n                 self.cache\n                     .paths\n-                    .insert(item.def_id.expect_real(), (self.cache.stack.clone(), item.type_()));\n+                    .insert(item.def_id.expect_def_id(), (self.cache.stack.clone(), item.type_()));\n             }\n \n             clean::ExternCrateItem { .. }\n@@ -391,7 +391,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n             | clean::StructItem(..)\n             | clean::UnionItem(..)\n             | clean::VariantItem(..) => {\n-                self.cache.parent_stack.push(item.def_id.expect_real());\n+                self.cache.parent_stack.push(item.def_id.expect_def_id());\n                 self.cache.parent_is_trait_impl = false;\n                 true\n             }"}, {"sha": "c08fe47696bf1b85115949e7938a5afe1b0cfb7a", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=acd4dc2d0ca8676fbf105507504e24d44e5dd1f6", "patch": "@@ -1191,7 +1191,7 @@ impl clean::Visibility {\n                 // FIXME(camelid): This may not work correctly if `item_did` is a module.\n                 //                 However, rustdoc currently never displays a module's\n                 //                 visibility, so it shouldn't matter.\n-                let parent_module = find_nearest_parent_module(cx.tcx(), item_did.expect_real());\n+                let parent_module = find_nearest_parent_module(cx.tcx(), item_did.expect_def_id());\n \n                 if vis_did.index == CRATE_DEF_INDEX {\n                     \"pub(crate) \".to_owned()"}, {"sha": "61057ff515b169aecd40f9411389021c369ada21", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=acd4dc2d0ca8676fbf105507504e24d44e5dd1f6", "patch": "@@ -230,7 +230,7 @@ impl<'tcx> Context<'tcx> {\n                 &self.shared.style_files,\n             )\n         } else {\n-            if let Some(&(ref names, ty)) = self.cache.paths.get(&it.def_id.expect_real()) {\n+            if let Some(&(ref names, ty)) = self.cache.paths.get(&it.def_id.expect_def_id()) {\n                 let mut path = String::new();\n                 for name in &names[..names.len() - 1] {\n                     path.push_str(name);"}, {"sha": "97ee682c11c4d6a5eb5d6f77a4516a9dcc82313c", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=acd4dc2d0ca8676fbf105507504e24d44e5dd1f6", "patch": "@@ -735,7 +735,7 @@ fn naive_assoc_href(it: &clean::Item, link: AssocItemLink<'_>, cx: &Context<'_>)\n         AssocItemLink::Anchor(Some(ref id)) => format!(\"#{}\", id),\n         AssocItemLink::Anchor(None) => anchor,\n         AssocItemLink::GotoSource(did, _) => {\n-            href(did.expect_real(), cx).map(|p| format!(\"{}{}\", p.0, anchor)).unwrap_or(anchor)\n+            href(did.expect_def_id(), cx).map(|p| format!(\"{}{}\", p.0, anchor)).unwrap_or(anchor)\n         }\n     }\n }\n@@ -867,7 +867,7 @@ fn render_assoc_item(\n                     ItemType::TyMethod\n                 };\n \n-                href(did.expect_real(), cx)\n+                href(did.expect_def_id(), cx)\n                     .map(|p| format!(\"{}#{}.{}\", p.0, ty, name))\n                     .unwrap_or_else(|| format!(\"#{}.{}\", ty, name))\n             }\n@@ -1819,7 +1819,7 @@ fn small_url_encode(s: String) -> String {\n }\n \n fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n-    let did = it.def_id.expect_real();\n+    let did = it.def_id.expect_def_id();\n     if let Some(v) = cx.cache.impls.get(&did) {\n         let mut used_links = FxHashSet::default();\n         let cache = cx.cache();\n@@ -2109,7 +2109,7 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n         \"</div>\",\n     );\n \n-    if let Some(implementors) = cx.cache.implementors.get(&it.def_id.expect_real()) {\n+    if let Some(implementors) = cx.cache.implementors.get(&it.def_id.expect_def_id()) {\n         let cache = cx.cache();\n         let mut res = implementors\n             .iter()"}, {"sha": "eeac9d1a9db76365d87d810ba56b0c5962825ee1", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=acd4dc2d0ca8676fbf105507504e24d44e5dd1f6", "patch": "@@ -289,15 +289,15 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                         w,\n                         \"<div class=\\\"item-left\\\"><code>{}extern crate {} as {};\",\n                         myitem.visibility.print_with_space(myitem.def_id, cx),\n-                        anchor(myitem.def_id.expect_real(), &*src.as_str(), cx),\n+                        anchor(myitem.def_id.expect_def_id(), &*src.as_str(), cx),\n                         myitem.name.as_ref().unwrap(),\n                     ),\n                     None => write!(\n                         w,\n                         \"<div class=\\\"item-left\\\"><code>{}extern crate {};\",\n                         myitem.visibility.print_with_space(myitem.def_id, cx),\n                         anchor(\n-                            myitem.def_id.expect_real(),\n+                            myitem.def_id.expect_def_id(),\n                             &*myitem.name.as_ref().unwrap().as_str(),\n                             cx\n                         ),\n@@ -669,9 +669,9 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    render_assoc_items(w, cx, it, it.def_id.expect_real(), AssocItemRender::All);\n+    render_assoc_items(w, cx, it, it.def_id.expect_def_id(), AssocItemRender::All);\n \n-    if let Some(implementors) = cx.cache.implementors.get(&it.def_id.expect_real()) {\n+    if let Some(implementors) = cx.cache.implementors.get(&it.def_id.expect_def_id()) {\n         // The DefId is for the first Type found with that name. The bool is\n         // if any Types with the same name but different DefId have been found.\n         let mut implementor_dups: FxHashMap<Symbol, (DefId, bool)> = FxHashMap::default();\n@@ -787,7 +787,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         path = if it.def_id.is_local() {\n             cx.current.join(\"/\")\n         } else {\n-            let (ref path, _) = cx.cache.external_paths[&it.def_id.expect_real()];\n+            let (ref path, _) = cx.cache.external_paths[&it.def_id.expect_def_id()];\n             path[..path.len() - 1].join(\"/\")\n         },\n         ty = it.type_(),\n@@ -813,7 +813,7 @@ fn item_trait_alias(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clea\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id.expect_real(), AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id.expect_def_id(), AssocItemRender::All)\n }\n \n fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::OpaqueTy) {\n@@ -834,7 +834,7 @@ fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean:\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id.expect_real(), AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id.expect_def_id(), AssocItemRender::All)\n }\n \n fn item_typedef(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n@@ -851,7 +851,7 @@ fn item_typedef(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::T\n \n     document(w, cx, it, None);\n \n-    let def_id = it.def_id.expect_real();\n+    let def_id = it.def_id.expect_def_id();\n     // Render any items associated directly to this alias, as otherwise they\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n@@ -903,7 +903,7 @@ fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Uni\n             document(w, cx, field, Some(it));\n         }\n     }\n-    let def_id = it.def_id.expect_real();\n+    let def_id = it.def_id.expect_def_id();\n     render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n     document_type_layout(w, cx, def_id);\n }\n@@ -1041,7 +1041,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n             }\n         }\n     }\n-    let def_id = it.def_id.expect_real();\n+    let def_id = it.def_id.expect_def_id();\n     render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n     document_type_layout(w, cx, def_id);\n }\n@@ -1093,7 +1093,7 @@ fn item_proc_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, m: &clean\n \n fn item_primitive(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n     document(w, cx, it, None);\n-    render_assoc_items(w, cx, it, it.def_id.expect_real(), AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id.expect_def_id(), AssocItemRender::All)\n }\n \n fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::Constant) {\n@@ -1182,7 +1182,7 @@ fn item_struct(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n             }\n         }\n     }\n-    let def_id = it.def_id.expect_real();\n+    let def_id = it.def_id.expect_def_id();\n     render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n     document_type_layout(w, cx, def_id);\n }\n@@ -1213,7 +1213,7 @@ fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n \n     document(w, cx, it, None);\n \n-    render_assoc_items(w, cx, it, it.def_id.expect_real(), AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id.expect_def_id(), AssocItemRender::All)\n }\n \n fn item_keyword(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {"}, {"sha": "8bdf1a598123043e08f7595f818b7633b920b5d3", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=acd4dc2d0ca8676fbf105507504e24d44e5dd1f6", "patch": "@@ -164,11 +164,11 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n         let id = item.def_id;\n         if let Some(mut new_item) = self.convert_item(item) {\n             if let types::ItemEnum::Trait(ref mut t) = new_item.inner {\n-                t.implementors = self.get_trait_implementors(id.expect_real())\n+                t.implementors = self.get_trait_implementors(id.expect_def_id())\n             } else if let types::ItemEnum::Struct(ref mut s) = new_item.inner {\n-                s.impls = self.get_impls(id.expect_real())\n+                s.impls = self.get_impls(id.expect_def_id())\n             } else if let types::ItemEnum::Enum(ref mut e) = new_item.inner {\n-                e.impls = self.get_impls(id.expect_real())\n+                e.impls = self.get_impls(id.expect_def_id())\n             }\n             let removed = self.index.borrow_mut().insert(from_item_id(id), new_item.clone());\n "}, {"sha": "92e678e4c024ba9f3f67b8f2f3bba8aa35715570", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=acd4dc2d0ca8676fbf105507504e24d44e5dd1f6", "patch": "@@ -213,13 +213,13 @@ impl<'a, 'b> fold::DocFolder for CoverageCalculator<'a, 'b> {\n \n                 let filename = i.span(self.ctx.tcx).filename(self.ctx.sess());\n                 let has_doc_example = tests.found_tests != 0;\n-                // The `expect_real()` should be okay because `local_def_id_to_hir_id`\n+                // The `expect_def_id()` should be okay because `local_def_id_to_hir_id`\n                 // would presumably panic if a fake `DefIndex` were passed.\n                 let hir_id = self\n                     .ctx\n                     .tcx\n                     .hir()\n-                    .local_def_id_to_hir_id(i.def_id.expect_real().expect_local());\n+                    .local_def_id_to_hir_id(i.def_id.expect_def_id().expect_local());\n                 let (level, source) = self.ctx.tcx.lint_level_at_node(MISSING_DOCS, hir_id);\n                 // `missing_docs` is allow-by-default, so don't treat this as ignoring the item\n                 // unless the user had an explicit `allow`"}, {"sha": "d961340f1f8d3993d0615d8b14d1fc095b430001", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=acd4dc2d0ca8676fbf105507504e24d44e5dd1f6", "patch": "@@ -53,7 +53,7 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n             return;\n         }\n \n-        let local_id = match item.def_id.as_real().and_then(|x| x.as_local()) {\n+        let local_id = match item.def_id.as_def_id().and_then(|x| x.as_local()) {\n             Some(id) => id,\n             // We don't need to check the syntax for other crates so returning\n             // without doing anything should not be a problem.\n@@ -137,7 +137,7 @@ impl<'a, 'tcx> DocFolder for SyntaxChecker<'a, 'tcx> {\n             let sp = item.attr_span(self.cx.tcx);\n             let extra = crate::html::markdown::ExtraInfo::new_did(\n                 self.cx.tcx,\n-                item.def_id.expect_real(),\n+                item.def_id.expect_def_id(),\n                 sp,\n             );\n             for code_block in markdown::rust_code_blocks(&dox, &extra) {"}, {"sha": "44a3faf6f7be26317fdb6961d4f61ac14c942622", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=acd4dc2d0ca8676fbf105507504e24d44e5dd1f6", "patch": "@@ -830,49 +830,48 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n     fn fold_item(&mut self, item: Item) -> Option<Item> {\n         use rustc_middle::ty::DefIdTree;\n \n-        let parent_node = if item.is_fake() {\n-            None\n-        } else {\n-            find_nearest_parent_module(self.cx.tcx, item.def_id.expect_real())\n-        };\n-\n+        let parent_node =\n+            item.def_id.as_def_id().and_then(|did| find_nearest_parent_module(self.cx.tcx, did));\n         if parent_node.is_some() {\n             trace!(\"got parent node for {:?} {:?}, id {:?}\", item.type_(), item.name, item.def_id);\n         }\n \n         // find item's parent to resolve `Self` in item's docs below\n         debug!(\"looking for the `Self` type\");\n-        let self_id = if item.is_fake() {\n-            None\n-        // Checking if the item is a field in an enum variant\n-        } else if (matches!(self.cx.tcx.def_kind(item.def_id.expect_real()), DefKind::Field)\n-            && matches!(\n-                self.cx.tcx.def_kind(self.cx.tcx.parent(item.def_id.expect_real()).unwrap()),\n-                DefKind::Variant\n-            ))\n-        {\n-            self.cx\n-                .tcx\n-                .parent(item.def_id.expect_real())\n-                .and_then(|item_id| self.cx.tcx.parent(item_id))\n-        } else if matches!(\n-            self.cx.tcx.def_kind(item.def_id.expect_real()),\n-            DefKind::AssocConst\n-                | DefKind::AssocFn\n-                | DefKind::AssocTy\n-                | DefKind::Variant\n-                | DefKind::Field\n-        ) {\n-            self.cx.tcx.parent(item.def_id.expect_real())\n-        // HACK(jynelson): `clean` marks associated types as `TypedefItem`, not as `AssocTypeItem`.\n-        // Fixing this breaks `fn render_deref_methods`.\n-        // As a workaround, see if the parent of the item is an `impl`; if so this must be an associated item,\n-        // regardless of what rustdoc wants to call it.\n-        } else if let Some(parent) = self.cx.tcx.parent(item.def_id.expect_real()) {\n-            let parent_kind = self.cx.tcx.def_kind(parent);\n-            Some(if parent_kind == DefKind::Impl { parent } else { item.def_id.expect_real() })\n-        } else {\n-            Some(item.def_id.expect_real())\n+        let self_id = match item.def_id.as_def_id() {\n+            None => None,\n+            Some(did)\n+                if (matches!(self.cx.tcx.def_kind(did), DefKind::Field)\n+                    && matches!(\n+                        self.cx.tcx.def_kind(self.cx.tcx.parent(did).unwrap()),\n+                        DefKind::Variant\n+                    )) =>\n+            {\n+                self.cx.tcx.parent(did).and_then(|item_id| self.cx.tcx.parent(item_id))\n+            }\n+            Some(did)\n+                if matches!(\n+                    self.cx.tcx.def_kind(did),\n+                    DefKind::AssocConst\n+                        | DefKind::AssocFn\n+                        | DefKind::AssocTy\n+                        | DefKind::Variant\n+                        | DefKind::Field\n+                ) =>\n+            {\n+                self.cx.tcx.parent(did)\n+            }\n+            Some(did) => match self.cx.tcx.parent(did) {\n+                // HACK(jynelson): `clean` marks associated types as `TypedefItem`, not as `AssocTypeItem`.\n+                // Fixing this breaks `fn render_deref_methods`.\n+                // As a workaround, see if the parent of the item is an `impl`; if so this must be an associated item,\n+                // regardless of what rustdoc wants to call it.\n+                Some(parent) => {\n+                    let parent_kind = self.cx.tcx.def_kind(parent);\n+                    Some(if parent_kind == DefKind::Impl { parent } else { did })\n+                }\n+                None => Some(did),\n+            },\n         };\n \n         // FIXME(jynelson): this shouldn't go through stringification, rustdoc should just use the DefId directly\n@@ -897,7 +896,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         let inner_docs = item.inner_docs(self.cx.tcx);\n \n         if item.is_mod() && inner_docs {\n-            self.mod_ids.push(item.def_id.expect_real());\n+            self.mod_ids.push(item.def_id.expect_def_id());\n         }\n \n         // We want to resolve in the lexical scope of the documentation.\n@@ -924,7 +923,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n \n         Some(if item.is_mod() {\n             if !inner_docs {\n-                self.mod_ids.push(item.def_id.expect_real());\n+                self.mod_ids.push(item.def_id.expect_def_id());\n             }\n \n             let ret = self.fold_item_recur(item);\n@@ -1235,10 +1234,10 @@ impl LinkCollector<'_, '_> {\n             // item can be non-local e.g. when using #[doc(primitive = \"pointer\")]\n             if let Some((src_id, dst_id)) = id\n                 .as_local()\n-                // The `expect_real()` should be okay because `local_def_id_to_hir_id`\n+                // The `expect_def_id()` should be okay because `local_def_id_to_hir_id`\n                 // would presumably panic if a fake `DefIndex` were passed.\n                 .and_then(|dst_id| {\n-                    item.def_id.expect_real().as_local().map(|src_id| (src_id, dst_id))\n+                    item.def_id.expect_def_id().as_local().map(|src_id| (src_id, dst_id))\n                 })\n             {\n                 let hir_src = self.cx.tcx.hir().local_def_id_to_hir_id(src_id);"}, {"sha": "91c495a2bbc069d95cb1c898657bcc3dcdfd7cb1", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=acd4dc2d0ca8676fbf105507504e24d44e5dd1f6", "patch": "@@ -136,10 +136,15 @@ impl<'a, 'tcx> DocFolder for SyntheticImplCollector<'a, 'tcx> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if i.is_struct() || i.is_enum() || i.is_union() {\n             // FIXME(eddyb) is this `doc(hidden)` check needed?\n-            if !self.cx.tcx.get_attrs(i.def_id.expect_real()).lists(sym::doc).has_word(sym::hidden)\n+            if !self\n+                .cx\n+                .tcx\n+                .get_attrs(i.def_id.expect_def_id())\n+                .lists(sym::doc)\n+                .has_word(sym::hidden)\n             {\n                 self.impls\n-                    .extend(get_auto_trait_and_blanket_impls(self.cx, i.def_id.expect_real()));\n+                    .extend(get_auto_trait_and_blanket_impls(self.cx, i.def_id.expect_def_id()));\n             }\n         }\n "}, {"sha": "03bc2b52f178f5336d9047485688691d91d4bb70", "filename": "src/librustdoc/passes/doc_test_lints.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs?ref=acd4dc2d0ca8676fbf105507504e24d44e5dd1f6", "patch": "@@ -53,7 +53,7 @@ impl crate::doctest::Tester for Tests {\n }\n \n crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> bool {\n-    if !cx.cache.access_levels.is_public(item.def_id.expect_real())\n+    if !cx.cache.access_levels.is_public(item.def_id.expect_def_id())\n         || matches!(\n             *item.kind,\n             clean::StructFieldItem(_)\n@@ -71,9 +71,9 @@ crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> boo\n     {\n         return false;\n     }\n-    // The `expect_real()` should be okay because `local_def_id_to_hir_id`\n+    // The `expect_def_id()` should be okay because `local_def_id_to_hir_id`\n     // would presumably panic if a fake `DefIndex` were passed.\n-    let hir_id = cx.tcx.hir().local_def_id_to_hir_id(item.def_id.expect_real().expect_local());\n+    let hir_id = cx.tcx.hir().local_def_id_to_hir_id(item.def_id.expect_def_id().expect_local());\n     if cx.tcx.hir().attrs(hir_id).lists(sym::doc).has_word(sym::hidden)\n         || inherits_doc_hidden(cx.tcx, hir_id)\n     {\n@@ -107,7 +107,8 @@ crate fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item) {\n                 |lint| lint.build(\"missing code example in this documentation\").emit(),\n             );\n         }\n-    } else if tests.found_tests > 0 && !cx.cache.access_levels.is_public(item.def_id.expect_real())\n+    } else if tests.found_tests > 0\n+        && !cx.cache.access_levels.is_public(item.def_id.expect_def_id())\n     {\n         cx.tcx.struct_span_lint_hir(\n             crate::lint::PRIVATE_DOC_TESTS,"}, {"sha": "4305268c9aab051991d6cff42ebff6ee46abf507", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=acd4dc2d0ca8676fbf105507504e24d44e5dd1f6", "patch": "@@ -42,7 +42,7 @@ impl<'a> DocFolder for Stripper<'a> {\n             | clean::TraitAliasItem(..)\n             | clean::ForeignTypeItem => {\n                 if i.def_id.is_local() {\n-                    if !self.access_levels.is_exported(i.def_id.expect_real()) {\n+                    if !self.access_levels.is_exported(i.def_id.expect_def_id()) {\n                         debug!(\"Stripper: stripping {:?} {:?}\", i.type_(), i.name);\n                         return None;\n                     }"}]}