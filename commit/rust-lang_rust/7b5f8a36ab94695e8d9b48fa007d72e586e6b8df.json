{"sha": "7b5f8a36ab94695e8d9b48fa007d72e586e6b8df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiNWY4YTM2YWI5NDY5NWU4ZDliNDhmYTAwN2Q3MmU1ODZlNmI4ZGY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-08-09T01:38:01Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-08-09T22:49:47Z"}, "message": "try harder to preserve regions when doing inference\n\nThis is not complete yet, but it is enough to make unsized-tuple-impls work.", "tree": {"sha": "e2f5ef62f4fd5225685430bd31b8fe9e364131b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2f5ef62f4fd5225685430bd31b8fe9e364131b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b5f8a36ab94695e8d9b48fa007d72e586e6b8df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b5f8a36ab94695e8d9b48fa007d72e586e6b8df", "html_url": "https://github.com/rust-lang/rust/commit/7b5f8a36ab94695e8d9b48fa007d72e586e6b8df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b5f8a36ab94695e8d9b48fa007d72e586e6b8df/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bff1ad156e6fd9c49e51028c56f2d091cc106495", "url": "https://api.github.com/repos/rust-lang/rust/commits/bff1ad156e6fd9c49e51028c56f2d091cc106495", "html_url": "https://github.com/rust-lang/rust/commit/bff1ad156e6fd9c49e51028c56f2d091cc106495"}], "stats": {"total": 131, "additions": 119, "deletions": 12}, "files": [{"sha": "468b2d71faed6d1f835deba64eae39dce75a3a4f", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7b5f8a36ab94695e8d9b48fa007d72e586e6b8df/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b5f8a36ab94695e8d9b48fa007d72e586e6b8df/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=7b5f8a36ab94695e8d9b48fa007d72e586e6b8df", "patch": "@@ -531,9 +531,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                 trace!(\"Releasing {:?} at {:?}\", lock.active, lock_lft);\n                 // Disable the lock\n                 lock.active = NoLock;\n+            } else {\n+                trace!(\"Not touching {:?} at {:?} as its not our lock\", lock.active, lock_lft);\n             }\n             match suspend {\n                 Some(suspend_region) => {\n+                    trace!(\"Adding suspension to {:?} at {:?}\", lock.active, lock_lft);\n                     // We just released this lock, so add a new suspension.\n                     // FIXME: Really, if there ever already is a suspension when is_our_lock, or if there is no suspension when !is_our_lock, something is amiss.\n                     // But this model is not good enough yet to prevent that."}, {"sha": "f23cf52c9bbeebbaefdef9eecc127713252eea6d", "filename": "src/librustc_mir/interpret/validation.rs", "status": "modified", "additions": 116, "deletions": 12, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/7b5f8a36ab94695e8d9b48fa007d72e586e6b8df/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b5f8a36ab94695e8d9b48fa007d72e586e6b8df/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs?ref=7b5f8a36ab94695e8d9b48fa007d72e586e6b8df", "patch": "@@ -1,10 +1,11 @@\n use rustc::hir::Mutability;\n use rustc::hir::Mutability::*;\n use rustc::mir::{self, ValidationOp, ValidationOperand};\n-use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::subst::Subst;\n+use rustc::ty::{self, Ty, TypeFoldable, TyCtxt};\n+use rustc::ty::subst::{Substs, Subst};\n+use rustc::traits;\n+use rustc::infer::InferCtxt;\n use rustc::traits::Reveal;\n-use rustc::infer::TransNormalize;\n use rustc::middle::region::CodeExtent;\n \n use super::{\n@@ -110,6 +111,116 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         Ok(())\n     }\n \n+    fn normalize_type_unerased(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        return normalize_associated_type(self.tcx, &ty);\n+\n+        use syntax::codemap::{Span, DUMMY_SP};\n+\n+        // We copy a bunch of stuff from rustc/infer/mod.rs to be able to tweak its behavior\n+        fn normalize_projections_in<'a, 'gcx, 'tcx, T>(\n+                self_: &InferCtxt<'a, 'gcx, 'tcx>,\n+                param_env: ty::ParamEnv<'tcx>,\n+                value: &T)\n+                -> T::Lifted\n+            where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n+        {\n+            let mut selcx = traits::SelectionContext::new(self_);\n+            let cause = traits::ObligationCause::dummy();\n+            let traits::Normalized { value: result, obligations } =\n+                traits::normalize(&mut selcx, param_env, cause, value);\n+\n+            debug!(\"normalize_projections_in: result={:?} obligations={:?}\",\n+                    result, obligations);\n+\n+            let mut fulfill_cx = traits::FulfillmentContext::new();\n+\n+            for obligation in obligations {\n+                fulfill_cx.register_predicate_obligation(self_, obligation);\n+            }\n+\n+            drain_fulfillment_cx_or_panic(self_, DUMMY_SP, &mut fulfill_cx, &result)\n+        }\n+\n+        fn drain_fulfillment_cx_or_panic<'a, 'gcx, 'tcx, T>(\n+                                                self_: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                                span: Span,\n+                                                fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n+                                                result: &T)\n+                                                -> T::Lifted\n+            where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n+        {\n+            debug!(\"drain_fulfillment_cx_or_panic()\");\n+\n+            // In principle, we only need to do this so long as `result`\n+            // contains unbound type parameters. It could be a slight\n+            // optimization to stop iterating early.\n+            match fulfill_cx.select_all_or_error(self_) {\n+                Ok(()) => { }\n+                Err(errors) => {\n+                    span_bug!(span, \"Encountered errors `{:?}` resolving bounds after type-checking\",\n+                                errors);\n+                }\n+            }\n+\n+            let result = self_.resolve_type_vars_if_possible(result);\n+            let result = self_.tcx.fold_regions(&result, &mut false, |r, _| match *r { ty::ReVar(_) => self_.tcx.types.re_erased, _ => r });\n+\n+            match self_.tcx.lift_to_global(&result) {\n+                Some(result) => result,\n+                None => {\n+                    span_bug!(span, \"Uninferred types/regions in `{:?}`\", result);\n+                }\n+            }\n+        }\n+\n+        trait MyTransNormalize<'gcx>: TypeFoldable<'gcx> {\n+            fn my_trans_normalize<'a, 'tcx>(&self,\n+                                        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                        param_env: ty::ParamEnv<'tcx>)\n+                                        -> Self;\n+        }\n+\n+        macro_rules! items { ($($item:item)+) => ($($item)+) }\n+        macro_rules! impl_trans_normalize {\n+            ($lt_gcx:tt, $($ty:ty),+) => {\n+                items!($(impl<$lt_gcx> MyTransNormalize<$lt_gcx> for $ty {\n+                    fn my_trans_normalize<'a, 'tcx>(&self,\n+                                                infcx: &InferCtxt<'a, $lt_gcx, 'tcx>,\n+                                                param_env: ty::ParamEnv<'tcx>)\n+                                                -> Self {\n+                        normalize_projections_in(infcx, param_env, self)\n+                    }\n+                })+);\n+            }\n+        }\n+\n+        impl_trans_normalize!('gcx,\n+            Ty<'gcx>,\n+            &'gcx Substs<'gcx>,\n+            ty::FnSig<'gcx>,\n+            ty::PolyFnSig<'gcx>,\n+            ty::ClosureSubsts<'gcx>,\n+            ty::PolyTraitRef<'gcx>,\n+            ty::ExistentialTraitRef<'gcx>\n+        );\n+\n+        fn normalize_associated_type<'a, 'tcx, T>(self_: TyCtxt<'a, 'tcx, 'tcx>, value: &T) -> T\n+            where T: MyTransNormalize<'tcx>\n+        {\n+            debug!(\"normalize_associated_type(t={:?})\", value);\n+\n+            let param_env = ty::ParamEnv::empty(Reveal::All);\n+\n+            if !value.has_projection_types() {\n+                return value.clone();\n+            }\n+\n+            self_.infer_ctxt().enter(|infcx| {\n+                value.my_trans_normalize(&infcx, param_env)\n+            })\n+        }\n+    }\n+\n     fn validate_variant(\n         &mut self,\n         query: ValidationQuery<'tcx>,\n@@ -189,14 +300,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             _ => {}\n         }\n \n-        // This is essentially a copy of normalize_associated_type, but without erasure\n-        if query.ty.has_projection_types() {\n-            let param_env = ty::ParamEnv::empty(Reveal::All);\n-            let old_ty = query.ty;\n-            query.ty = self.tcx.infer_ctxt().enter(move |infcx| {\n-                old_ty.trans_normalize(&infcx, param_env)\n-            })\n-        }\n+        query.ty = self.normalize_type_unerased(&query.ty);\n         trace!(\"{:?} on {:?}\", mode, query);\n \n         // Decide whether this type *owns* the memory it covers (like integers), or whether it\n@@ -215,7 +319,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             // Tracking the same state for locals not backed by memory would just duplicate too\n             // much machinery.\n             // FIXME: We ignore alignment.\n-            let (ptr, extra, _aligned) = self.force_allocation(query.lval)?.to_ptr_extra_aligned();\n+            let (ptr, extra) = self.force_allocation(query.lval)?.to_ptr_extra_aligned();\n             // Determine the size\n             // FIXME: Can we reuse size_and_align_of_dst for Lvalues?\n             let len = match self.type_size(query.ty)? {"}]}