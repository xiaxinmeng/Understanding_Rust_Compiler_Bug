{"sha": "07b86a94c77483127a7b7371cb046e67d8e59279", "node_id": "C_kwDOAAsO6NoAKDA3Yjg2YTk0Yzc3NDgzMTI3YTdiNzM3MWNiMDQ2ZTY3ZDhlNTkyNzk", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-11-28T19:16:44Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-11-29T08:09:57Z"}, "message": "`rustc_ast_passes`: remove `ref` patterns", "tree": {"sha": "e4dbf63b5273f822c942b7e0cd7776516448c8d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4dbf63b5273f822c942b7e0cd7776516448c8d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07b86a94c77483127a7b7371cb046e67d8e59279", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07b86a94c77483127a7b7371cb046e67d8e59279", "html_url": "https://github.com/rust-lang/rust/commit/07b86a94c77483127a7b7371cb046e67d8e59279", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07b86a94c77483127a7b7371cb046e67d8e59279/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ef685ea39280cc4a4a32f7c3c586d2ce946e8f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ef685ea39280cc4a4a32f7c3c586d2ce946e8f0", "html_url": "https://github.com/rust-lang/rust/commit/1ef685ea39280cc4a4a32f7c3c586d2ce946e8f0"}], "stats": {"total": 115, "additions": 55, "deletions": 60}, "files": [{"sha": "e47c434454602773d236a61ba7f1fb85e877fa83", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 45, "deletions": 50, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/07b86a94c77483127a7b7371cb046e67d8e59279/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b86a94c77483127a7b7371cb046e67d8e59279/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=07b86a94c77483127a7b7371cb046e67d8e59279", "patch": "@@ -209,15 +209,15 @@ impl<'a> AstValidator<'a> {\n \n     // Mirrors `visit::walk_ty`, but tracks relevant state.\n     fn walk_ty(&mut self, t: &'a Ty) {\n-        match t.kind {\n+        match &t.kind {\n             TyKind::ImplTrait(..) => {\n                 self.with_impl_trait(Some(t.span), |this| visit::walk_ty(this, t))\n             }\n             TyKind::TraitObject(..) => self\n                 .with_banned_tilde_const(DisallowTildeConstContext::TraitObject, |this| {\n                     visit::walk_ty(this, t)\n                 }),\n-            TyKind::Path(ref qself, ref path) => {\n+            TyKind::Path(qself, path) => {\n                 // We allow these:\n                 //  - `Option<impl Trait>`\n                 //  - `option::Option<impl Trait>`\n@@ -231,7 +231,7 @@ impl<'a> AstValidator<'a> {\n                 // (for cases like `<impl Trait>::Foo>`)\n                 // but we allow `impl Trait` in `GenericArgs`\n                 // iff there are no more PathSegments.\n-                if let Some(ref qself) = *qself {\n+                if let Some(qself) = qself {\n                     // `impl Trait` in `qself` is always illegal\n                     self.with_banned_impl_trait(|this| this.visit_ty(&qself.ty));\n                 }\n@@ -738,8 +738,8 @@ impl<'a> AstValidator<'a> {\n     }\n \n     fn visit_ty_common(&mut self, ty: &'a Ty) {\n-        match ty.kind {\n-            TyKind::BareFn(ref bfty) => {\n+        match &ty.kind {\n+            TyKind::BareFn(bfty) => {\n                 self.check_fn_decl(&bfty.decl, SelfSemantic::No);\n                 Self::check_decl_no_pat(&bfty.decl, |span, _, _| {\n                     struct_span_err!(\n@@ -756,10 +756,10 @@ impl<'a> AstValidator<'a> {\n                     self.maybe_lint_missing_abi(sig_span, ty.id);\n                 }\n             }\n-            TyKind::TraitObject(ref bounds, ..) => {\n+            TyKind::TraitObject(bounds, ..) => {\n                 let mut any_lifetime_bounds = false;\n                 for bound in bounds {\n-                    if let GenericBound::Outlives(ref lifetime) = *bound {\n+                    if let GenericBound::Outlives(lifetime) = bound {\n                         if any_lifetime_bounds {\n                             struct_span_err!(\n                                 self.session,\n@@ -774,7 +774,7 @@ impl<'a> AstValidator<'a> {\n                     }\n                 }\n             }\n-            TyKind::ImplTrait(_, ref bounds) => {\n+            TyKind::ImplTrait(_, bounds) => {\n                 if self.is_impl_trait_banned {\n                     struct_span_err!(\n                         self.session,\n@@ -842,8 +842,8 @@ fn validate_generic_param_order(\n         let (kind, bounds, span) = (&param.kind, &param.bounds, ident.span);\n         let (ord_kind, ident) = match &param.kind {\n             GenericParamKind::Lifetime => (ParamKindOrd::Lifetime, ident.to_string()),\n-            GenericParamKind::Type { default: _ } => (ParamKindOrd::TypeOrConst, ident.to_string()),\n-            GenericParamKind::Const { ref ty, kw_span: _, default: _ } => {\n+            GenericParamKind::Type { .. } => (ParamKindOrd::TypeOrConst, ident.to_string()),\n+            GenericParamKind::Const { ty, .. } => {\n                 let ty = pprust::ty_to_string(ty);\n                 (ParamKindOrd::TypeOrConst, format!(\"const {}: {}\", ident, ty))\n             }\n@@ -948,8 +948,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 }\n                 ExprKind::Paren(local_expr) => {\n                     fn has_let_expr(expr: &Expr) -> bool {\n-                        match expr.kind {\n-                            ExprKind::Binary(_, ref lhs, ref rhs) => has_let_expr(lhs) || has_let_expr(rhs),\n+                        match &expr.kind {\n+                            ExprKind::Binary(_, lhs, rhs) => has_let_expr(lhs) || has_let_expr(rhs),\n                             ExprKind::Let(..) => true,\n                             _ => false,\n                         }\n@@ -1005,18 +1005,18 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             self.check_nomangle_item_asciionly(item.ident, item.span);\n         }\n \n-        match item.kind {\n+        match &item.kind {\n             ItemKind::Impl(box Impl {\n                 unsafety,\n                 polarity,\n                 defaultness: _,\n                 constness,\n-                ref generics,\n-                of_trait: Some(ref t),\n-                ref self_ty,\n-                ref items,\n+                generics,\n+                of_trait: Some(t),\n+                self_ty,\n+                items,\n             }) => {\n-                self.with_in_trait_impl(true, Some(constness), |this| {\n+                self.with_in_trait_impl(true, Some(*constness), |this| {\n                     this.invalid_visibility(&item.vis, None);\n                     if let TyKind::Err = self_ty.kind {\n                         this.err_handler()\n@@ -1027,7 +1027,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                             .help(\"use `auto trait Trait {}` instead\")\n                             .emit();\n                     }\n-                    if let (Unsafe::Yes(span), ImplPolarity::Negative(sp)) = (unsafety, polarity) {\n+                    if let (&Unsafe::Yes(span), &ImplPolarity::Negative(sp)) = (unsafety, polarity)\n+                    {\n                         struct_span_err!(\n                             this.session,\n                             sp.to(t.path.span),\n@@ -1061,7 +1062,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 constness,\n                 generics: _,\n                 of_trait: None,\n-                ref self_ty,\n+                self_ty,\n                 items: _,\n             }) => {\n                 let error = |annotation_span, annotation| {\n@@ -1078,25 +1079,25 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     &item.vis,\n                     Some(InvalidVisibilityNote::IndividualImplItems),\n                 );\n-                if let Unsafe::Yes(span) = unsafety {\n+                if let &Unsafe::Yes(span) = unsafety {\n                     error(span, \"unsafe\").code(error_code!(E0197)).emit();\n                 }\n-                if let ImplPolarity::Negative(span) = polarity {\n+                if let &ImplPolarity::Negative(span) = polarity {\n                     error(span, \"negative\").emit();\n                 }\n-                if let Defaultness::Default(def_span) = defaultness {\n+                if let &Defaultness::Default(def_span) = defaultness {\n                     error(def_span, \"`default`\")\n                         .note(\"only trait implementations may be annotated with `default`\")\n                         .emit();\n                 }\n-                if let Const::Yes(span) = constness {\n+                if let &Const::Yes(span) = constness {\n                     error(span, \"`const`\")\n                         .note(\"only trait implementations may be annotated with `const`\")\n                         .emit();\n                 }\n             }\n-            ItemKind::Fn(box Fn { defaultness, ref sig, ref generics, ref body }) => {\n-                self.check_defaultness(item.span, defaultness);\n+            ItemKind::Fn(box Fn { defaultness, sig, generics, body }) => {\n+                self.check_defaultness(item.span, *defaultness);\n \n                 if body.is_none() {\n                     self.session.emit_err(FnWithoutBody {\n@@ -1132,7 +1133,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     &item.vis,\n                     Some(InvalidVisibilityNote::IndividualForeignItems),\n                 );\n-                if let Unsafe::Yes(span) = unsafety {\n+                if let &Unsafe::Yes(span) = unsafety {\n                     self.err_handler().span_err(span, \"extern block cannot be declared unsafe\");\n                 }\n                 if abi.is_none() {\n@@ -1142,16 +1143,16 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self.extern_mod = old_item;\n                 return; // Avoid visiting again.\n             }\n-            ItemKind::Enum(ref def, _) => {\n+            ItemKind::Enum(def, _) => {\n                 for variant in &def.variants {\n                     self.invalid_visibility(&variant.vis, None);\n                     for field in variant.data.fields() {\n                         self.invalid_visibility(&field.vis, None);\n                     }\n                 }\n             }\n-            ItemKind::Trait(box Trait { is_auto, ref generics, ref bounds, ref items, .. }) => {\n-                if is_auto == IsAuto::Yes {\n+            ItemKind::Trait(box Trait { is_auto, generics, bounds, items, .. }) => {\n+                if *is_auto == IsAuto::Yes {\n                     // Auto traits cannot have generics, super traits nor contain items.\n                     self.deny_generic_params(generics, item.ident.span);\n                     self.deny_super_traits(bounds, item.ident.span);\n@@ -1171,8 +1172,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 walk_list!(self, visit_attribute, &item.attrs);\n                 return; // Avoid visiting again\n             }\n-            ItemKind::Mod(unsafety, ref mod_kind) => {\n-                if let Unsafe::Yes(span) = unsafety {\n+            ItemKind::Mod(unsafety, mod_kind) => {\n+                if let &Unsafe::Yes(span) = unsafety {\n                     self.err_handler().span_err(span, \"module cannot be declared unsafe\");\n                 }\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n@@ -1182,13 +1183,13 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     self.check_mod_file_item_asciionly(item.ident);\n                 }\n             }\n-            ItemKind::Union(ref vdata, ..) => {\n+            ItemKind::Union(vdata, ..) => {\n                 if vdata.fields().is_empty() {\n                     self.err_handler().span_err(item.span, \"unions cannot have zero fields\");\n                 }\n             }\n             ItemKind::Const(def, .., None) => {\n-                self.check_defaultness(item.span, def);\n+                self.check_defaultness(item.span, *def);\n                 self.session.emit_err(ConstWithoutBody {\n                     span: item.span,\n                     replace_span: self.ending_semi_or_hi(item.span),\n@@ -1200,14 +1201,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     replace_span: self.ending_semi_or_hi(item.span),\n                 });\n             }\n-            ItemKind::TyAlias(box TyAlias {\n-                defaultness,\n-                where_clauses,\n-                ref bounds,\n-                ref ty,\n-                ..\n-            }) => {\n-                self.check_defaultness(item.span, defaultness);\n+            ItemKind::TyAlias(box TyAlias { defaultness, where_clauses, bounds, ty, .. }) => {\n+                self.check_defaultness(item.span, *defaultness);\n                 if ty.is_none() {\n                     self.session.emit_err(TyAliasWithoutBody {\n                         span: item.span,\n@@ -1266,8 +1261,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n \n     // Mirrors `visit::walk_generic_args`, but tracks relevant state.\n     fn visit_generic_args(&mut self, generic_args: &'a GenericArgs) {\n-        match *generic_args {\n-            GenericArgs::AngleBracketed(ref data) => {\n+        match generic_args {\n+            GenericArgs::AngleBracketed(data) => {\n                 self.check_generic_args_before_constraints(data);\n \n                 for arg in &data.args {\n@@ -1283,7 +1278,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     }\n                 }\n             }\n-            GenericArgs::Parenthesized(ref data) => {\n+            GenericArgs::Parenthesized(data) => {\n                 walk_list!(self, visit_ty, &data.inputs);\n                 if let FnRetTy::Ty(ty) = &data.output {\n                     // `-> Foo` syntax is essentially an associated type binding,\n@@ -1319,7 +1314,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         validate_generic_param_order(self.err_handler(), &generics.params, generics.span);\n \n         for predicate in &generics.where_clause.predicates {\n-            if let WherePredicate::EqPredicate(ref predicate) = *predicate {\n+            if let WherePredicate::EqPredicate(predicate) = predicate {\n                 deny_equality_constraints(self, predicate, generics);\n             }\n         }\n@@ -1368,7 +1363,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_param_bound(&mut self, bound: &'a GenericBound, ctxt: BoundKind) {\n-        if let GenericBound::Trait(ref poly, modify) = *bound {\n+        if let GenericBound::Trait(poly, modify) = bound {\n             match (ctxt, modify) {\n                 (BoundKind::SuperTraits, TraitBoundModifier::Maybe) => {\n                     let mut err = self\n@@ -1573,8 +1568,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             self.check_item_named(item.ident, \"const\");\n         }\n \n-        match item.kind {\n-            AssocItemKind::Type(box TyAlias { ref generics, ref bounds, ref ty, .. })\n+        match &item.kind {\n+            AssocItemKind::Type(box TyAlias { generics, bounds, ty, .. })\n                 if ctxt == AssocCtxt::Trait =>\n             {\n                 self.visit_vis(&item.vis);\n@@ -1586,7 +1581,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 });\n                 walk_list!(self, visit_ty, ty);\n             }\n-            AssocItemKind::Fn(box Fn { ref sig, ref generics, ref body, .. })\n+            AssocItemKind::Fn(box Fn { sig, generics, body, .. })\n                 if self.in_const_trait_impl\n                     || ctxt == AssocCtxt::Trait\n                     || matches!(sig.header.constness, Const::Yes(_)) =>"}, {"sha": "32f45f8b59e90a4050a7a41fb525d93ed9609ae5", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/07b86a94c77483127a7b7371cb046e67d8e59279/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b86a94c77483127a7b7371cb046e67d8e59279/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=07b86a94c77483127a7b7371cb046e67d8e59279", "patch": "@@ -198,8 +198,8 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_item(&mut self, i: &'a ast::Item) {\n-        match i.kind {\n-            ast::ItemKind::ForeignMod(ref foreign_module) => {\n+        match &i.kind {\n+            ast::ItemKind::ForeignMod(foreign_module) => {\n                 if let Some(abi) = foreign_module.abi {\n                     self.check_abi(abi, ast::Const::No);\n                 }\n@@ -233,8 +233,8 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 }\n             }\n \n-            ast::ItemKind::Impl(box ast::Impl { polarity, defaultness, ref of_trait, .. }) => {\n-                if let ast::ImplPolarity::Negative(span) = polarity {\n+            ast::ItemKind::Impl(box ast::Impl { polarity, defaultness, of_trait, .. }) => {\n+                if let &ast::ImplPolarity::Negative(span) = polarity {\n                     gate_feature_post!(\n                         &self,\n                         negative_impls,\n@@ -267,7 +267,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 gate_feature_post!(&self, decl_macro, i.span, msg);\n             }\n \n-            ast::ItemKind::TyAlias(box ast::TyAlias { ty: Some(ref ty), .. }) => {\n+            ast::ItemKind::TyAlias(box ast::TyAlias { ty: Some(ty), .. }) => {\n                 self.check_impl_trait(&ty)\n             }\n \n@@ -302,8 +302,8 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_ty(&mut self, ty: &'a ast::Ty) {\n-        match ty.kind {\n-            ast::TyKind::BareFn(ref bare_fn_ty) => {\n+        match &ty.kind {\n+            ast::TyKind::BareFn(bare_fn_ty) => {\n                 // Function pointers cannot be `const`\n                 self.check_extern(bare_fn_ty.ext, ast::Const::No);\n             }\n@@ -319,7 +319,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_fn_ret_ty(&mut self, ret_ty: &'a ast::FnRetTy) {\n-        if let ast::FnRetTy::Ty(ref output_ty) = *ret_ty {\n+        if let ast::FnRetTy::Ty(output_ty) = ret_ty {\n             if let ast::TyKind::Never = output_ty.kind {\n                 // Do nothing.\n             } else {\n@@ -455,9 +455,9 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_assoc_item(&mut self, i: &'a ast::AssocItem, ctxt: AssocCtxt) {\n-        let is_fn = match i.kind {\n+        let is_fn = match &i.kind {\n             ast::AssocItemKind::Fn(_) => true,\n-            ast::AssocItemKind::Type(box ast::TyAlias { ref ty, .. }) => {\n+            ast::AssocItemKind::Type(box ast::TyAlias { ty, .. }) => {\n                 if let (Some(_), AssocCtxt::Trait) = (ty, ctxt) {\n                     gate_feature_post!(\n                         &self,"}]}