{"sha": "9dfb2107615c3e1159e213c2c18dcbfd5e831d10", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkZmIyMTA3NjE1YzNlMTE1OWUyMTNjMmMxOGRjYmZkNWU4MzFkMTA=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2017-10-18T17:59:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-10-18T17:59:46Z"}, "message": "Rollup merge of #45082 - jacwah:explain-E0382, r=steveklabnik\n\nMention Clone and refs in --explain E0382\n\nI followed the discussion in #42446 and came up with these additions.\n\n- Mention references before going into traits. They're probably more likely solutions.\n- Mention `Clone` before `Copy`. Cloning has wider applicability and `#derive[Copy, Clone]` makes more sense after learning about `Clone`.\n\nThe language is not great, any suggestions there would be appreciated :sparkles:", "tree": {"sha": "a0b5efbee6d5872dd68f6dddc2f75fb504672aab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0b5efbee6d5872dd68f6dddc2f75fb504672aab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9dfb2107615c3e1159e213c2c18dcbfd5e831d10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9dfb2107615c3e1159e213c2c18dcbfd5e831d10", "html_url": "https://github.com/rust-lang/rust/commit/9dfb2107615c3e1159e213c2c18dcbfd5e831d10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9dfb2107615c3e1159e213c2c18dcbfd5e831d10/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebdfe338e503bda5bfa2117e29d30a1044d2402c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebdfe338e503bda5bfa2117e29d30a1044d2402c", "html_url": "https://github.com/rust-lang/rust/commit/ebdfe338e503bda5bfa2117e29d30a1044d2402c"}, {"sha": "47ea51e4e50a83adaeb872952d5d67eed243ed02", "url": "https://api.github.com/repos/rust-lang/rust/commits/47ea51e4e50a83adaeb872952d5d67eed243ed02", "html_url": "https://github.com/rust-lang/rust/commit/47ea51e4e50a83adaeb872952d5d67eed243ed02"}], "stats": {"total": 66, "additions": 57, "deletions": 9}, "files": [{"sha": "0f67f7bf6deb47fe14cdd2881b5d085703036ff0", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 57, "deletions": 9, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/9dfb2107615c3e1159e213c2c18dcbfd5e831d10/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dfb2107615c3e1159e213c2c18dcbfd5e831d10/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=9dfb2107615c3e1159e213c2c18dcbfd5e831d10", "patch": "@@ -320,20 +320,68 @@ Since `MyStruct` is a type that is not marked `Copy`, the data gets moved out\n of `x` when we set `y`. This is fundamental to Rust's ownership system: outside\n of workarounds like `Rc`, a value cannot be owned by more than one variable.\n \n-If we own the type, the easiest way to address this problem is to implement\n-`Copy` and `Clone` on it, as shown below. This allows `y` to copy the\n-information in `x`, while leaving the original version owned by `x`. Subsequent\n-changes to `x` will not be reflected when accessing `y`.\n+Sometimes we don't need to move the value. Using a reference, we can let another\n+function borrow the value without changing its ownership. In the example below,\n+we don't actually have to move our string to `calculate_length`, we can give it\n+a reference to it with `&` instead.\n+\n+```\n+fn main() {\n+    let s1 = String::from(\"hello\");\n+\n+    let len = calculate_length(&s1);\n+\n+    println!(\"The length of '{}' is {}.\", s1, len);\n+}\n+\n+fn calculate_length(s: &String) -> usize {\n+    s.len()\n+}\n+```\n+\n+A mutable reference can be created with `&mut`.\n+\n+Sometimes we don't want a reference, but a duplicate. All types marked `Clone`\n+can be duplicated by calling `.clone()`. Subsequent changes to a clone do not\n+affect the original variable.\n+\n+Most types in the standard library are marked `Clone`. The example below\n+demonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\n+copied to `s2`. Then the first character of `s1` is removed, without affecting\n+`s2`. \"any many\" is printed to the console.\n+\n+```\n+fn main() {\n+    let mut s1 = String::from(\"many\");\n+    let s2 = s1.clone();\n+    s1.remove(0);\n+    println!(\"{} {}\", s1, s2);\n+}\n+```\n+\n+If we control the definition of a type, we can implement `Clone` on it ourselves\n+with `#[derive(Clone)]`.\n+\n+Some types have no ownership semantics at all and are trivial to duplicate. An\n+example is `i32` and the other number types. We don't have to call `.clone()` to\n+clone them, because they are marked `Copy` in addition to `Clone`.  Implicit\n+cloning is more convienient in this case. We can mark our own types `Copy` if\n+all their members also are marked `Copy`.\n+\n+In the example below, we implement a `Point` type. Because it only stores two\n+integers, we opt-out of ownership semantics with `Copy`. Then we can\n+`let p2 = p1` without `p1` being moved.\n \n ```\n #[derive(Copy, Clone)]\n-struct MyStruct { s: u32 }\n+struct Point { x: i32, y: i32 }\n \n fn main() {\n-    let mut x = MyStruct{ s: 5u32 };\n-    let y = x;\n-    x.s = 6;\n-    println!(\"{}\", x.s);\n+    let mut p1 = Point{ x: -1, y: 2 };\n+    let p2 = p1;\n+    p1.x = 1;\n+    println!(\"p1: {}, {}\", p1.x, p1.y);\n+    println!(\"p2: {}, {}\", p2.x, p2.y);\n }\n ```\n "}]}