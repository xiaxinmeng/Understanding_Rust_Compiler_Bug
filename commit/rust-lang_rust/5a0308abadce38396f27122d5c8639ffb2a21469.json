{"sha": "5a0308abadce38396f27122d5c8639ffb2a21469", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMDMwOGFiYWRjZTM4Mzk2ZjI3MTIyZDVjODYzOWZmYjJhMjE0Njk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-29T22:30:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-29T22:30:44Z"}, "message": "Auto merge of #31884 - alexcrichton:no-bootstrap-from-existing, r=brson\n\nThese commits add support to the rustbuild build system to compile non-build-system compilers. For example this will allow creating an ARM compiler on a x86 system. The high level way this works is:\n\n* The only compiler ever run is the build target compiler. No other compiler is assumed to be runnable.\n* As a result, all output artifacts come from the build compiler.\n* The libs for the stageN cross-compiled compiler will be linked into place after the build target builds them.\n\nThis will break the assumption that a compiler never links to anything it didn't itself produce, but it retains the assumption that a compiler only ever links to anything built in the same stage. I believe this means that the stage1 cross-compiled compilers will still be usable.\n\nI tested this by creating an `arm-unknown-linux-gnueabihf` compiler. So far the linking ended up all working OK (including LLVM being cross compiled), but I haven't been able to run it yet (in QEMU for a raspberry pi). I think that's because my system linker is messed up or something like that (some newer option is assumed when it's not actually there).\n\nOverall, though, this means that rustbuild can compile an arm-unknown-linux-gnueabihf compiler. Ideally we could even start shipping nightlies based on this at some point!", "tree": {"sha": "dea07a69f16b6640d4e276a175ba1dca7f4926b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dea07a69f16b6640d4e276a175ba1dca7f4926b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a0308abadce38396f27122d5c8639ffb2a21469", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a0308abadce38396f27122d5c8639ffb2a21469", "html_url": "https://github.com/rust-lang/rust/commit/5a0308abadce38396f27122d5c8639ffb2a21469", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a0308abadce38396f27122d5c8639ffb2a21469/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52cb8a9d39d05126a79e7b9a3adc31a5e3cdde94", "url": "https://api.github.com/repos/rust-lang/rust/commits/52cb8a9d39d05126a79e7b9a3adc31a5e3cdde94", "html_url": "https://github.com/rust-lang/rust/commit/52cb8a9d39d05126a79e7b9a3adc31a5e3cdde94"}, {"sha": "15b4a8c2f32460b4b9b9ba27c17cbcf5144b14bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/15b4a8c2f32460b4b9b9ba27c17cbcf5144b14bb", "html_url": "https://github.com/rust-lang/rust/commit/15b4a8c2f32460b4b9b9ba27c17cbcf5144b14bb"}], "stats": {"total": 317, "additions": 216, "deletions": 101}, "files": [{"sha": "05186d48ce2d1c9851f1d98a7214287695d597b3", "filename": "src/bootstrap/Cargo.lock", "status": "modified", "additions": 18, "deletions": 35, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/5a0308abadce38396f27122d5c8639ffb2a21469/src%2Fbootstrap%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5a0308abadce38396f27122d5c8639ffb2a21469/src%2Fbootstrap%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.lock?ref=5a0308abadce38396f27122d5c8639ffb2a21469", "patch": "@@ -3,57 +3,42 @@ name = \"bootstrap\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"cmake 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"filetime 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cmake 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num_cpus 0.2.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"toml 0.1.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num_cpus 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"advapi32-sys\"\n-version = \"0.1.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"winapi 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"build_helper\"\n version = \"0.1.0\"\n \n [[package]]\n name = \"cmake\"\n-version = \"0.1.10\"\n+version = \"0.1.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"filetime\"\n-version = \"0.1.8\"\n+version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"kernel32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"gcc\"\n-version = \"0.3.19\"\n+version = \"0.3.25\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"advapi32-sys 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n \n [[package]]\n name = \"getopts\"\n@@ -71,30 +56,28 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.2\"\n+version = \"0.2.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"num_cpus\"\n-version = \"0.2.9\"\n+version = \"0.2.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"kernel32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-serialize\"\n-version = \"0.3.16\"\n+version = \"0.3.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"toml\"\n-version = \"0.1.23\"\n+version = \"0.1.27\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"rustc-serialize 0.3.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]"}, {"sha": "6659894a171f04f191d2bd8b3a216755acd88ff6", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5a0308abadce38396f27122d5c8639ffb2a21469/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/5a0308abadce38396f27122d5c8639ffb2a21469/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=5a0308abadce38396f27122d5c8639ffb2a21469", "patch": "@@ -73,6 +73,7 @@ def download_rust_nightly(self):\n \n         if self.rustc().startswith(self.bin_root()) and \\\n            (not os.path.exists(self.rustc()) or self.rustc_out_of_date()):\n+            shutil.rmtree(self.bin_root())\n             filename = \"rust-std-nightly-\" + self.build + \".tar.gz\"\n             url = \"https://static.rust-lang.org/dist/\" + self.snap_rustc_date()\n             tarball = os.path.join(rustc_cache, filename)"}, {"sha": "3be4199352ca1e5da0f4e8e75680fded2a903803", "filename": "src/bootstrap/build/compile.rs", "status": "modified", "additions": 60, "deletions": 22, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/5a0308abadce38396f27122d5c8639ffb2a21469/src%2Fbootstrap%2Fbuild%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a0308abadce38396f27122d5c8639ffb2a21469/src%2Fbootstrap%2Fbuild%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fcompile.rs?ref=5a0308abadce38396f27122d5c8639ffb2a21469", "patch": "@@ -58,6 +58,30 @@ pub fn std<'a>(build: &'a Build, stage: u32, target: &str,\n     }\n \n     build.run(&mut cargo);\n+    std_link(build, stage, target, compiler, host);\n+}\n+\n+/// Link all libstd rlibs/dylibs into the sysroot location.\n+///\n+/// Links those artifacts generated in the given `stage` for `target` produced\n+/// by `compiler` into `host`'s sysroot.\n+pub fn std_link(build: &Build,\n+                stage: u32,\n+                target: &str,\n+                compiler: &Compiler,\n+                host: &str) {\n+    let libdir = build.sysroot_libdir(stage, host, target);\n+    let out_dir = build.cargo_out(stage, compiler.host, true, target);\n+\n+    // If we're linking one compiler host's output into another, then we weren't\n+    // called from the `std` method above. In that case we clean out what's\n+    // already there and then also link compiler-rt into place.\n+    if host != compiler.host {\n+        let _ = fs::remove_dir_all(&libdir);\n+        t!(fs::create_dir_all(&libdir));\n+        t!(fs::hard_link(&build.compiler_rt_built.borrow()[target],\n+                         libdir.join(staticlib(\"compiler-rt\", target))));\n+    }\n     add_to_sysroot(&out_dir, &libdir);\n }\n \n@@ -99,7 +123,6 @@ pub fn rustc<'a>(build: &'a Build, stage: u32, target: &str,\n              host, target);\n \n     let out_dir = build.cargo_out(stage, &host, false, target);\n-    let rustc = out_dir.join(exe(\"rustc\", target));\n     build.clear_if_dirty(&out_dir, &libstd_shim(build, stage, &host, target));\n \n     let mut cargo = build.cargo(stage, compiler, false, target, \"build\");\n@@ -131,10 +154,13 @@ pub fn rustc<'a>(build: &'a Build, stage: u32, target: &str,\n     if !build.unstable_features {\n         cargo.env(\"CFG_DISABLE_UNSTABLE_FEATURES\", \"1\");\n     }\n-    if let Some(config) = build.config.target_config.get(target) {\n-        if let Some(ref s) = config.llvm_config {\n-            cargo.env(\"LLVM_CONFIG\", s);\n-        }\n+    let target_config = build.config.target_config.get(target);\n+    if let Some(ref s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n+        cargo.env(\"LLVM_CONFIG\", s);\n+    } else {\n+        let llvm_config = build.llvm_out(&build.config.build).join(\"bin\")\n+                               .join(exe(\"llvm-config\", target));\n+        cargo.env(\"LLVM_CONFIG\", llvm_config);\n     }\n     if build.config.llvm_static_stdcpp {\n         cargo.env(\"LLVM_STATIC_STDCPP\",\n@@ -148,12 +174,21 @@ pub fn rustc<'a>(build: &'a Build, stage: u32, target: &str,\n     }\n     build.run(&mut cargo);\n \n-    let sysroot_libdir = build.sysroot_libdir(stage, host, target);\n-    add_to_sysroot(&out_dir, &sysroot_libdir);\n+    rustc_link(build, stage, target, compiler, compiler.host);\n+}\n \n-    if host == target {\n-        assemble_compiler(build, stage, target, &rustc);\n-    }\n+/// Link all librustc rlibs/dylibs into the sysroot location.\n+///\n+/// Links those artifacts generated in the given `stage` for `target` produced\n+/// by `compiler` into `host`'s sysroot.\n+pub fn rustc_link(build: &Build,\n+                  stage: u32,\n+                  target: &str,\n+                  compiler: &Compiler,\n+                  host: &str) {\n+    let libdir = build.sysroot_libdir(stage, host, target);\n+    let out_dir = build.cargo_out(stage, compiler.host, false, target);\n+    add_to_sysroot(&out_dir, &libdir);\n }\n \n /// Cargo's output path for the standard library in a given stage, compiled\n@@ -169,39 +204,42 @@ fn compiler_file(compiler: &Path, file: &str) -> String {\n \n /// Prepare a new compiler from the artifacts in `stage`\n ///\n-/// This will link the compiler built by `host` during the stage\n-/// specified to the sysroot location for `host` to be the official\n-/// `stage + 1` compiler for that host. This means that the `rustc` binary\n-/// itself will be linked into place along with all supporting dynamic\n-/// libraries.\n-fn assemble_compiler(build: &Build, stage: u32, host: &str, rustc: &Path) {\n+/// This will assemble a compiler in `build/$host/stage$stage`. The compiler\n+/// must have been previously produced by the `stage - 1` build.config.build\n+/// compiler.\n+pub fn assemble_rustc(build: &Build, stage: u32, host: &str) {\n+    assert!(stage > 0, \"the stage0 compiler isn't assembled, it's downloaded\");\n+\n     // Clear out old files\n-    let sysroot = build.sysroot(stage + 1, host);\n+    let sysroot = build.sysroot(stage, host);\n     let _ = fs::remove_dir_all(&sysroot);\n     t!(fs::create_dir_all(&sysroot));\n \n     // Link in all dylibs to the libdir\n     let sysroot_libdir = sysroot.join(libdir(host));\n     t!(fs::create_dir_all(&sysroot_libdir));\n-    let src_libdir = build.sysroot_libdir(stage, host, host);\n+    let src_libdir = build.sysroot_libdir(stage - 1, &build.config.build, host);\n     for f in t!(fs::read_dir(&src_libdir)).map(|f| t!(f)) {\n         let filename = f.file_name().into_string().unwrap();\n         if is_dylib(&filename) {\n             t!(fs::hard_link(&f.path(), sysroot_libdir.join(&filename)));\n         }\n     }\n \n+    let out_dir = build.cargo_out(stage - 1, &build.config.build, false, host);\n+\n     // Link the compiler binary itself into place\n+    let rustc = out_dir.join(exe(\"rustc\", host));\n     let bindir = sysroot.join(\"bin\");\n     t!(fs::create_dir_all(&bindir));\n-    let compiler = build.compiler_path(&Compiler::new(stage + 1, host));\n+    let compiler = build.compiler_path(&Compiler::new(stage, host));\n     let _ = fs::remove_file(&compiler);\n     t!(fs::hard_link(rustc, compiler));\n \n     // See if rustdoc exists to link it into place\n-    let exe = exe(\"rustdoc\", host);\n-    let rustdoc_src = rustc.parent().unwrap().join(&exe);\n-    let rustdoc_dst = bindir.join(exe);\n+    let rustdoc = exe(\"rustdoc\", host);\n+    let rustdoc_src = out_dir.join(&rustdoc);\n+    let rustdoc_dst = bindir.join(&rustdoc);\n     if fs::metadata(&rustdoc_src).is_ok() {\n         let _ = fs::remove_file(&rustdoc_dst);\n         t!(fs::hard_link(&rustdoc_src, &rustdoc_dst));"}, {"sha": "7b3ac7d2f7e97c3654b7a09e24532bfdaa813c43", "filename": "src/bootstrap/build/mod.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5a0308abadce38396f27122d5c8639ffb2a21469/src%2Fbootstrap%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a0308abadce38396f27122d5c8639ffb2a21469/src%2Fbootstrap%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fmod.rs?ref=5a0308abadce38396f27122d5c8639ffb2a21469", "patch": "@@ -39,6 +39,14 @@ mod sanity;\n mod step;\n mod util;\n \n+#[cfg(windows)]\n+mod job;\n+\n+#[cfg(not(windows))]\n+mod job {\n+    pub unsafe fn setup() {}\n+}\n+\n pub use build::config::Config;\n pub use build::flags::Flags;\n \n@@ -114,14 +122,9 @@ impl Build {\n     pub fn build(&mut self) {\n         use build::step::Source::*;\n \n-        // see comments in job.rs for what's going on here\n-        #[cfg(windows)]\n-        fn setup_job() {\n-            mod job;\n-            unsafe { job::setup() }\n+        unsafe {\n+            job::setup();\n         }\n-        #[cfg(not(windows))] fn setup_job() {}\n-        setup_job();\n \n         if self.flags.clean {\n             return clean::clean(self);\n@@ -146,8 +149,19 @@ impl Build {\n                 Librustc { stage, compiler } => {\n                     compile::rustc(self, stage, target.target, &compiler);\n                 }\n+                LibstdLink { stage, compiler, host } => {\n+                    compile::std_link(self, stage, target.target,\n+                                      &compiler, host);\n+                }\n+                LibrustcLink { stage, compiler, host } => {\n+                    compile::rustc_link(self, stage, target.target,\n+                                        &compiler, host);\n+                }\n+                Rustc { stage: 0 } => {\n+                    // nothing to do...\n+                }\n                 Rustc { stage } => {\n-                    println!(\"ok, rustc stage{} in {}\", stage, target.target);\n+                    compile::assemble_rustc(self, stage, target.target);\n                 }\n             }\n         }\n@@ -425,21 +439,7 @@ impl Build {\n     }\n \n     fn rustc_flags(&self, target: &str) -> Vec<String> {\n-        let mut base = match target {\n-            \"arm-unknown-linux-gnueabihf\" => {\n-                vec![\"-Ctarget-feature=+v6,+vfp2\".to_string()]\n-            }\n-            \"mips-unknown-linux-gnu\" => {\n-                vec![\"-Ctarget-cpu=mips32r2\".to_string(),\n-                     \"-Ctarget-feature=+mips32r2\".to_string(),\n-                     \"-Csoft-float\".to_string()]\n-            }\n-            \"mipsel-unknown-linux-gnu\" => {\n-                vec![\"-Ctarget-cpu=mips32\".to_string(),\n-                     \"-Ctarget-feature=+mips32\".to_string()]\n-            }\n-            _ => Vec::new(),\n-        };\n+        let mut base = Vec::new();\n         if target != self.config.build && !target.contains(\"msvc\") {\n             base.push(format!(\"-Clinker={}\", self.cc(target).display()));\n         }"}, {"sha": "a9d84b60fbff81d244726559d3aadd2adcd2c5f3", "filename": "src/bootstrap/build/native.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a0308abadce38396f27122d5c8639ffb2a21469/src%2Fbootstrap%2Fbuild%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a0308abadce38396f27122d5c8639ffb2a21469/src%2Fbootstrap%2Fbuild%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fnative.rs?ref=5a0308abadce38396f27122d5c8639ffb2a21469", "patch": "@@ -115,6 +115,11 @@ pub fn compiler_rt(build: &Build, target: &str) {\n     let mode = if build.config.rust_optimize {\"Release\"} else {\"Debug\"};\n     let (dir, build_target, libname) = if target.contains(\"linux\") {\n         let os = if target.contains(\"android\") {\"-android\"} else {\"\"};\n+        let arch = if arch.starts_with(\"arm\") && target.contains(\"eabihf\") {\n+            \"armhf\"\n+        } else {\n+            arch\n+        };\n         let target = format!(\"clang_rt.builtins-{}{}\", arch, os);\n         (\"linux\".to_string(), target.clone(), target)\n     } else if target.contains(\"darwin\") {\n@@ -151,7 +156,10 @@ pub fn compiler_rt(build: &Build, target: &str) {\n        .define(\"COMPILER_RT_DEFAULT_TARGET_TRIPLE\", target)\n        .define(\"COMPILER_RT_BUILD_SANITIZERS\", \"OFF\")\n        .define(\"COMPILER_RT_BUILD_EMUTLS\", \"OFF\")\n+       // inform about c/c++ compilers, the c++ compiler isn't actually used but\n+       // it's needed to get the initial configure to work on all platforms.\n        .define(\"CMAKE_C_COMPILER\", build.cc(target))\n+       .define(\"CMAKE_CXX_COMPILER\", build.cc(target))\n        .build_target(&build_target);\n     cfg.build();\n }"}, {"sha": "21c3c514698c6fe464c006a7d4dff06a20ace067", "filename": "src/bootstrap/build/step.rs", "status": "modified", "additions": 59, "deletions": 12, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/5a0308abadce38396f27122d5c8639ffb2a21469/src%2Fbootstrap%2Fbuild%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a0308abadce38396f27122d5c8639ffb2a21469/src%2Fbootstrap%2Fbuild%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fstep.rs?ref=5a0308abadce38396f27122d5c8639ffb2a21469", "patch": "@@ -21,9 +21,36 @@ pub struct Step<'a> {\n macro_rules! targets {\n     ($m:ident) => {\n         $m! {\n+            // Step representing building the stageN compiler. This is just the\n+            // compiler executable itself, not any of the support libraries\n             (rustc, Rustc { stage: u32 }),\n+\n+            // Steps for the two main cargo builds, one for the standard library\n+            // and one for the compiler itself. These are parameterized over the\n+            // stage output they're going to be placed in along with the\n+            // compiler which is producing the copy of libstd or librustc\n             (libstd, Libstd { stage: u32, compiler: Compiler<'a> }),\n             (librustc, Librustc { stage: u32, compiler: Compiler<'a> }),\n+\n+            // Links the standard library/librustc produced by the compiler\n+            // provided into the host's directory also provided.\n+            (libstd_link, LibstdLink {\n+                stage: u32,\n+                compiler: Compiler<'a>,\n+                host: &'a str\n+            }),\n+            (librustc_link, LibrustcLink {\n+                stage: u32,\n+                compiler: Compiler<'a>,\n+                host: &'a str\n+            }),\n+\n+            // Steps for long-running native builds. Ideally these wouldn't\n+            // actually exist and would be part of build scripts, but for now\n+            // these are here.\n+            //\n+            // There aren't really any parameters to this, but empty structs\n+            // with braces are unstable so we just pick something that works.\n             (llvm, Llvm { _dummy: () }),\n             (compiler_rt, CompilerRt { _dummy: () }),\n         }\n@@ -93,13 +120,25 @@ fn top_level(build: &Build) -> Vec<Step> {\n                 continue\n             }\n             let host = t.target(host);\n-            targets.push(host.librustc(stage, host.compiler(stage)));\n+            if host.target == build.config.build {\n+                targets.push(host.librustc(stage, host.compiler(stage)));\n+            } else {\n+                targets.push(host.librustc_link(stage, t.compiler(stage),\n+                                                host.target));\n+            }\n             for target in build.config.target.iter() {\n                 if !build.flags.target.contains(target) {\n                     continue\n                 }\n-                targets.push(host.target(target)\n-                                 .libstd(stage, host.compiler(stage)));\n+\n+                if host.target == build.config.build {\n+                    targets.push(host.target(target)\n+                                     .libstd(stage, host.compiler(stage)));\n+                } else {\n+                    targets.push(host.target(target)\n+                                     .libstd_link(stage, t.compiler(stage),\n+                                                  host.target));\n+                }\n             }\n         }\n     }\n@@ -114,10 +153,14 @@ fn add_steps<'a>(build: &'a Build,\n                  target: &Step<'a>,\n                  targets: &mut Vec<Step<'a>>) {\n     for step in build.flags.step.iter() {\n-        let compiler = host.compiler(stage);\n+        let compiler = host.target(&build.config.build).compiler(stage);\n         match &step[..] {\n             \"libstd\" => targets.push(target.libstd(stage, compiler)),\n-            \"librustc\" => targets.push(target.libstd(stage, compiler)),\n+            \"librustc\" => targets.push(target.librustc(stage, compiler)),\n+            \"libstd-link\" => targets.push(target.libstd_link(stage, compiler,\n+                                                             host.target)),\n+            \"librustc-link\" => targets.push(target.librustc_link(stage, compiler,\n+                                                                 host.target)),\n             \"rustc\" => targets.push(host.rustc(stage)),\n             \"llvm\" => targets.push(target.llvm(())),\n             \"compiler-rt\" => targets.push(target.compiler_rt(())),\n@@ -151,15 +194,11 @@ impl<'a> Step<'a> {\n     pub fn deps(&self, build: &'a Build) -> Vec<Step<'a>> {\n         match self.src {\n             Source::Rustc { stage: 0 } => {\n-                if self.target == build.config.build {\n-                    Vec::new()\n-                } else {\n-                    let compiler = Compiler::new(0, &build.config.build);\n-                    vec![self.librustc(0, compiler)]\n-                }\n+                Vec::new()\n             }\n             Source::Rustc { stage } => {\n-                vec![self.librustc(stage - 1, self.compiler(stage - 1))]\n+                let compiler = Compiler::new(stage - 1, &build.config.build);\n+                vec![self.librustc(stage - 1, compiler)]\n             }\n             Source::Librustc { stage, compiler } => {\n                 vec![self.libstd(stage, compiler), self.llvm(())]\n@@ -168,6 +207,14 @@ impl<'a> Step<'a> {\n                 vec![self.compiler_rt(()),\n                      self.rustc(compiler.stage).target(compiler.host)]\n             }\n+            Source::LibrustcLink { stage, compiler, host } => {\n+                vec![self.librustc(stage, compiler),\n+                     self.libstd_link(stage, compiler, host)]\n+            }\n+            Source::LibstdLink { stage, compiler, host } => {\n+                vec![self.libstd(stage, compiler),\n+                     self.target(host).rustc(stage)]\n+            }\n             Source::CompilerRt { _dummy } => {\n                 vec![self.llvm(()).target(&build.config.build)]\n             }"}, {"sha": "4e9d6da9157de2f9643d09002e0a53cf5c779426", "filename": "src/bootstrap/rustc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a0308abadce38396f27122d5c8639ffb2a21469/src%2Fbootstrap%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a0308abadce38396f27122d5c8639ffb2a21469/src%2Fbootstrap%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frustc.rs?ref=5a0308abadce38396f27122d5c8639ffb2a21469", "patch": "@@ -61,6 +61,9 @@ fn main() {\n             root.push(\"/lib\");\n             cmd.arg(\"-L\").arg(&root);\n         }\n+        if let Ok(s) = env::var(\"RUSTC_FLAGS\") {\n+            cmd.args(&s.split(\" \").filter(|s| !s.is_empty()).collect::<Vec<_>>());\n+        }\n     }\n \n     // Set various options from config.toml to configure how we're building\n@@ -79,9 +82,6 @@ fn main() {\n     if let Ok(s) = env::var(\"RUSTC_CODEGEN_UNITS\") {\n         cmd.arg(\"-C\").arg(format!(\"codegen-units={}\", s));\n     }\n-    if let Ok(s) = env::var(\"RUSTC_FLAGS\") {\n-        cmd.args(&s.split(\" \").filter(|s| !s.is_empty()).collect::<Vec<_>>());\n-    }\n \n     // Actually run the compiler!\n     std::process::exit(match cmd.status() {"}, {"sha": "59164161b3d5ec12289ebec50f883f762dca9517", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 43, "deletions": 3, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5a0308abadce38396f27122d5c8639ffb2a21469/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a0308abadce38396f27122d5c8639ffb2a21469/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=5a0308abadce38396f27122d5c8639ffb2a21469", "patch": "@@ -38,6 +38,25 @@ fn main() {\n \n     println!(\"cargo:rerun-if-changed={}\", llvm_config.display());\n \n+    // Test whether we're cross-compiling LLVM. This is a pretty rare case\n+    // currently where we're producing an LLVM for a different platform than\n+    // what this build script is currently running on.\n+    //\n+    // In that case, there's no guarantee that we can actually run the target,\n+    // so the build system works around this by giving us the LLVM_CONFIG for\n+    // the host platform. This only really works if the host LLVM and target\n+    // LLVM are compiled the same way, but for us that's typically the case.\n+    //\n+    // We detect this cross compiling situation by asking llvm-config what it's\n+    // host-target is. If that's not the TARGET, then we're cross compiling.\n+    // This generally just means that we can't trust all the output of\n+    // llvm-config becaues it might be targeted for the host rather than the\n+    // target.\n+    let target = env::var(\"TARGET\").unwrap();\n+    let host = output(Command::new(&llvm_config).arg(\"--host-target\"));\n+    let host = host.trim();\n+    let is_crossed = target != host;\n+\n     let optional_components = [\"x86\", \"arm\", \"aarch64\", \"mips\", \"powerpc\",\n                                \"pnacl\"];\n \n@@ -69,6 +88,10 @@ fn main() {\n     let cxxflags = output(&mut cmd);\n     let mut cfg = gcc::Config::new();\n     for flag in cxxflags.split_whitespace() {\n+        // Ignore flags like `-m64` when we're doing a cross build\n+        if is_crossed && flag.starts_with(\"-m\") {\n+            continue\n+        }\n         cfg.flag(flag);\n     }\n     cfg.file(\"../rustllvm/ExecutionEngineWrapper.cpp\")\n@@ -79,9 +102,16 @@ fn main() {\n        .cpp_link_stdlib(None) // we handle this below\n        .compile(\"librustllvm.a\");\n \n-    // Link in all LLVM libraries\n+    // Link in all LLVM libraries, if we're uwring the \"wrong\" llvm-config then\n+    // we don't pick up system libs because unfortunately they're for the host\n+    // of llvm-config, not the target that we're attempting to link.\n     let mut cmd = Command::new(&llvm_config);\n-    cmd.arg(\"--libs\").arg(\"--system-libs\").args(&components[..]);\n+    cmd.arg(\"--libs\");\n+    if !is_crossed {\n+        cmd.arg(\"--system-libs\");\n+    }\n+    cmd.args(&components[..]);\n+\n     for lib in output(&mut cmd).split_whitespace() {\n         let name = if lib.starts_with(\"-l\") {\n             &lib[2..]\n@@ -105,10 +135,20 @@ fn main() {\n     }\n \n     // LLVM ldflags\n+    //\n+    // If we're a cross-compile of LLVM then unfortunately we can't trust these\n+    // ldflags (largely where all the LLVM libs are located). Currently just\n+    // hack around this by replacing the host triple with the target and pray\n+    // that those -L directories are the same!\n     let mut cmd = Command::new(&llvm_config);\n     cmd.arg(\"--ldflags\");\n     for lib in output(&mut cmd).split_whitespace() {\n-        if lib.starts_with(\"-l\") {\n+        if is_crossed {\n+            if lib.starts_with(\"-L\") {\n+                println!(\"cargo:rustc-link-search=native={}\",\n+                         lib[2..].replace(&host, &target));\n+            }\n+        } else if lib.starts_with(\"-l\") {\n             println!(\"cargo:rustc-link-lib={}\", &lib[2..]);\n         } else if lib.starts_with(\"-L\") {\n             println!(\"cargo:rustc-link-search=native={}\", &lib[2..]);"}, {"sha": "59e2fce6f0938b2dda0d7fed95650519864ac35a", "filename": "src/nightlies.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a0308abadce38396f27122d5c8639ffb2a21469/src%2Fnightlies.txt", "raw_url": "https://github.com/rust-lang/rust/raw/5a0308abadce38396f27122d5c8639ffb2a21469/src%2Fnightlies.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnightlies.txt?ref=5a0308abadce38396f27122d5c8639ffb2a21469", "patch": "@@ -1,2 +1,2 @@\n-rustc: 2015-12-19\n+rustc: 2016-02-17\n cargo: 2016-01-21"}, {"sha": "530c04da8a0c9503a102f740bbc16284e0ddb339", "filename": "src/rustc/std_shim/Cargo.lock", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a0308abadce38396f27122d5c8639ffb2a21469/src%2Frustc%2Fstd_shim%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5a0308abadce38396f27122d5c8639ffb2a21469/src%2Frustc%2Fstd_shim%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fstd_shim%2FCargo.lock?ref=5a0308abadce38396f27122d5c8639ffb2a21469", "patch": "@@ -18,9 +18,7 @@ dependencies = [\n name = \"alloc\"\n version = \"0.0.0\"\n dependencies = [\n- \"alloc_system 0.0.0\",\n  \"core 0.0.0\",\n- \"libc 0.0.0\",\n ]\n \n [[package]]"}]}