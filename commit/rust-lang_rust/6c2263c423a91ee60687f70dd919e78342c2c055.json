{"sha": "6c2263c423a91ee60687f70dd919e78342c2c055", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjMjI2M2M0MjNhOTFlZTYwNjg3ZjcwZGQ5MTllNzgzNDJjMmMwNTU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T02:37:58Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T02:37:58Z"}, "message": "rollup merge of #20519: ville-h/rwlock-rename\n\nConflicts:\n\tsrc/libstd/sync/rwlock.rs", "tree": {"sha": "820acaf8644cc7c58d14683127b9143e39abeff1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/820acaf8644cc7c58d14683127b9143e39abeff1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c2263c423a91ee60687f70dd919e78342c2c055", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c2263c423a91ee60687f70dd919e78342c2c055", "html_url": "https://github.com/rust-lang/rust/commit/6c2263c423a91ee60687f70dd919e78342c2c055", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c2263c423a91ee60687f70dd919e78342c2c055/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a73c35249d7a9ddf92e5c203b244a4a10a6e8119", "url": "https://api.github.com/repos/rust-lang/rust/commits/a73c35249d7a9ddf92e5c203b244a4a10a6e8119", "html_url": "https://github.com/rust-lang/rust/commit/a73c35249d7a9ddf92e5c203b244a4a10a6e8119"}, {"sha": "fee1f2ade962c913ba2da81f7a97ab39c6f66989", "url": "https://api.github.com/repos/rust-lang/rust/commits/fee1f2ade962c913ba2da81f7a97ab39c6f66989", "html_url": "https://github.com/rust-lang/rust/commit/fee1f2ade962c913ba2da81f7a97ab39c6f66989"}], "stats": {"total": 168, "additions": 84, "deletions": 84}, "files": [{"sha": "0a76a2c4fc7b0d2c02e6db49c586532345feb49c", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2263c423a91ee60687f70dd919e78342c2c055/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2263c423a91ee60687f70dd919e78342c2c055/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=6c2263c423a91ee60687f70dd919e78342c2c055", "patch": "@@ -22,8 +22,8 @@ pub use core::atomic;\n \n pub use self::mutex::{Mutex, MutexGuard, StaticMutex};\n pub use self::mutex::MUTEX_INIT;\n-pub use self::rwlock::{RWLock, StaticRWLock, RWLOCK_INIT};\n-pub use self::rwlock::{RWLockReadGuard, RWLockWriteGuard};\n+pub use self::rwlock::{RwLock, StaticRwLock, RW_LOCK_INIT};\n+pub use self::rwlock::{RwLockReadGuard, RwLockWriteGuard};\n pub use self::condvar::{Condvar, StaticCondvar, CONDVAR_INIT};\n pub use self::once::{Once, ONCE_INIT};\n pub use self::semaphore::{Semaphore, SemaphoreGuard};"}, {"sha": "385df45b400c41a8cebfeab79d47c92ac6c5aed5", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2263c423a91ee60687f70dd919e78342c2c055/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2263c423a91ee60687f70dd919e78342c2c055/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=6c2263c423a91ee60687f70dd919e78342c2c055", "patch": "@@ -49,7 +49,7 @@ pub struct Guard {\n \n /// A type of error which can be returned whenever a lock is acquired.\n ///\n-/// Both Mutexes and RWLocks are poisoned whenever a task fails while the lock\n+/// Both Mutexes and RwLocks are poisoned whenever a task fails while the lock\n /// is held. The precise semantics for when a lock is poisoned is documented on\n /// each lock, but once a lock is poisoned then all future acquisitions will\n /// return this error."}, {"sha": "7aad5f51abe122bd426e0a93852f4fb9bdf8293c", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 81, "deletions": 81, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/6c2263c423a91ee60687f70dd919e78342c2c055/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2263c423a91ee60687f70dd919e78342c2c055/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=6c2263c423a91ee60687f70dd919e78342c2c055", "patch": "@@ -31,17 +31,17 @@ use sys_common::rwlock as sys;\n ///\n /// # Poisoning\n ///\n-/// RWLocks, like Mutexes, will become poisoned on panics. Note, however, that\n-/// an RWLock may only be poisoned if a panic occurs while it is locked\n+/// RwLocks, like Mutexes, will become poisoned on panics. Note, however, that\n+/// an RwLock may only be poisoned if a panic occurs while it is locked\n /// exclusively (write mode). If a panic occurs in any reader, then the lock\n /// will not be poisoned.\n ///\n /// # Examples\n ///\n /// ```\n-/// use std::sync::RWLock;\n+/// use std::sync::RwLock;\n ///\n-/// let lock = RWLock::new(5);\n+/// let lock = RwLock::new(5);\n ///\n /// // many reader locks can be held at once\n /// {\n@@ -59,26 +59,26 @@ use sys_common::rwlock as sys;\n /// } // write lock is dropped here\n /// ```\n #[stable]\n-pub struct RWLock<T> {\n-    inner: Box<StaticRWLock>,\n+pub struct RwLock<T> {\n+    inner: Box<StaticRwLock>,\n     data: UnsafeCell<T>,\n }\n \n-unsafe impl<T:'static+Send> Send for RWLock<T> {}\n-unsafe impl<T> Sync for RWLock<T> {}\n+unsafe impl<T:'static+Send> Send for RwLock<T> {}\n+unsafe impl<T> Sync for RwLock<T> {}\n \n-/// Structure representing a statically allocated RWLock.\n+/// Structure representing a statically allocated RwLock.\n ///\n /// This structure is intended to be used inside of a `static` and will provide\n /// automatic global access as well as lazy initialization. The internal\n-/// resources of this RWLock, however, must be manually deallocated.\n+/// resources of this RwLock, however, must be manually deallocated.\n ///\n /// # Example\n ///\n /// ```\n-/// use std::sync::{StaticRWLock, RWLOCK_INIT};\n+/// use std::sync::{StaticRwLock, RW_LOCK_INIT};\n ///\n-/// static LOCK: StaticRWLock = RWLOCK_INIT;\n+/// static LOCK: StaticRwLock = RW_LOCK_INIT;\n ///\n /// {\n ///     let _g = LOCK.read().unwrap();\n@@ -90,18 +90,18 @@ unsafe impl<T> Sync for RWLock<T> {}\n /// }\n /// unsafe { LOCK.destroy() } // free all resources\n /// ```\n-#[unstable = \"may be merged with RWLock in the future\"]\n-pub struct StaticRWLock {\n+#[unstable = \"may be merged with RwLock in the future\"]\n+pub struct StaticRwLock {\n     lock: sys::RWLock,\n     poison: poison::Flag,\n }\n \n-unsafe impl Send for StaticRWLock {}\n-unsafe impl Sync for StaticRWLock {}\n+unsafe impl Send for StaticRwLock {}\n+unsafe impl Sync for StaticRwLock {}\n \n /// Constant initialization for a statically-initialized rwlock.\n-#[unstable = \"may be merged with RWLock in the future\"]\n-pub const RWLOCK_INIT: StaticRWLock = StaticRWLock {\n+#[unstable = \"may be merged with RwLock in the future\"]\n+pub const RW_LOCK_INIT: StaticRwLock = StaticRwLock {\n     lock: sys::RWLOCK_INIT,\n     poison: poison::FLAG_INIT,\n };\n@@ -110,8 +110,8 @@ pub const RWLOCK_INIT: StaticRWLock = StaticRWLock {\n /// dropped.\n #[must_use]\n #[stable]\n-pub struct RWLockReadGuard<'a, T: 'a> {\n-    __lock: &'a StaticRWLock,\n+pub struct RwLockReadGuard<'a, T: 'a> {\n+    __lock: &'a StaticRwLock,\n     __data: &'a UnsafeCell<T>,\n     __marker: marker::NoSend,\n }\n@@ -120,18 +120,18 @@ pub struct RWLockReadGuard<'a, T: 'a> {\n /// dropped.\n #[must_use]\n #[stable]\n-pub struct RWLockWriteGuard<'a, T: 'a> {\n-    __lock: &'a StaticRWLock,\n+pub struct RwLockWriteGuard<'a, T: 'a> {\n+    __lock: &'a StaticRwLock,\n     __data: &'a UnsafeCell<T>,\n     __poison: poison::Guard,\n     __marker: marker::NoSend,\n }\n \n-impl<T: Send + Sync> RWLock<T> {\n-    /// Creates a new instance of an RWLock which is unlocked and read to go.\n+impl<T: Send + Sync> RwLock<T> {\n+    /// Creates a new instance of an RwLock which is unlocked and read to go.\n     #[stable]\n-    pub fn new(t: T) -> RWLock<T> {\n-        RWLock { inner: box RWLOCK_INIT, data: UnsafeCell::new(t) }\n+    pub fn new(t: T) -> RwLock<T> {\n+        RwLock { inner: box RW_LOCK_INIT, data: UnsafeCell::new(t) }\n     }\n \n     /// Locks this rwlock with shared read access, blocking the current thread\n@@ -148,14 +148,14 @@ impl<T: Send + Sync> RWLock<T> {\n     ///\n     /// # Failure\n     ///\n-    /// This function will return an error if the RWLock is poisoned. An RWLock\n+    /// This function will return an error if the RwLock is poisoned. An RwLock\n     /// is poisoned whenever a writer panics while holding an exclusive lock.\n     /// The failure will occur immediately after the lock has been acquired.\n     #[inline]\n     #[stable]\n-    pub fn read(&self) -> LockResult<RWLockReadGuard<T>> {\n+    pub fn read(&self) -> LockResult<RwLockReadGuard<T>> {\n         unsafe { self.inner.lock.read() }\n-        RWLockReadGuard::new(&*self.inner, &self.data)\n+        RwLockReadGuard::new(&*self.inner, &self.data)\n     }\n \n     /// Attempt to acquire this lock with shared read access.\n@@ -169,15 +169,15 @@ impl<T: Send + Sync> RWLock<T> {\n     ///\n     /// # Failure\n     ///\n-    /// This function will return an error if the RWLock is poisoned. An RWLock\n+    /// This function will return an error if the RwLock is poisoned. An RwLock\n     /// is poisoned whenever a writer panics while holding an exclusive lock. An\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n     #[inline]\n     #[stable]\n-    pub fn try_read(&self) -> TryLockResult<RWLockReadGuard<T>> {\n+    pub fn try_read(&self) -> TryLockResult<RwLockReadGuard<T>> {\n         if unsafe { self.inner.lock.try_read() } {\n-            Ok(try!(RWLockReadGuard::new(&*self.inner, &self.data)))\n+            Ok(try!(RwLockReadGuard::new(&*self.inner, &self.data)))\n         } else {\n             Err(TryLockError::WouldBlock)\n         }\n@@ -194,14 +194,14 @@ impl<T: Send + Sync> RWLock<T> {\n     ///\n     /// # Failure\n     ///\n-    /// This function will return an error if the RWLock is poisoned. An RWLock\n+    /// This function will return an error if the RwLock is poisoned. An RwLock\n     /// is poisoned whenever a writer panics while holding an exclusive lock.\n     /// An error will be returned when the lock is acquired.\n     #[inline]\n     #[stable]\n-    pub fn write(&self) -> LockResult<RWLockWriteGuard<T>> {\n+    pub fn write(&self) -> LockResult<RwLockWriteGuard<T>> {\n         unsafe { self.inner.lock.write() }\n-        RWLockWriteGuard::new(&*self.inner, &self.data)\n+        RwLockWriteGuard::new(&*self.inner, &self.data)\n     }\n \n     /// Attempt to lock this rwlock with exclusive write access.\n@@ -212,23 +212,23 @@ impl<T: Send + Sync> RWLock<T> {\n     ///\n     /// # Failure\n     ///\n-    /// This function will return an error if the RWLock is poisoned. An RWLock\n+    /// This function will return an error if the RwLock is poisoned. An RwLock\n     /// is poisoned whenever a writer panics while holding an exclusive lock. An\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n     #[inline]\n     #[stable]\n-    pub fn try_write(&self) -> TryLockResult<RWLockWriteGuard<T>> {\n+    pub fn try_write(&self) -> TryLockResult<RwLockWriteGuard<T>> {\n         if unsafe { self.inner.lock.try_read() } {\n-            Ok(try!(RWLockWriteGuard::new(&*self.inner, &self.data)))\n+            Ok(try!(RwLockWriteGuard::new(&*self.inner, &self.data)))\n         } else {\n             Err(TryLockError::WouldBlock)\n         }\n     }\n }\n \n #[unsafe_destructor]\n-impl<T> Drop for RWLock<T> {\n+impl<T> Drop for RwLock<T> {\n     fn drop(&mut self) {\n         unsafe { self.inner.lock.destroy() }\n     }\n@@ -238,27 +238,27 @@ struct Dummy(UnsafeCell<()>);\n unsafe impl Sync for Dummy {}\n static DUMMY: Dummy = Dummy(UnsafeCell { value: () });\n \n-impl StaticRWLock {\n+impl StaticRwLock {\n     /// Locks this rwlock with shared read access, blocking the current thread\n     /// until it can be acquired.\n     ///\n-    /// See `RWLock::read`.\n+    /// See `RwLock::read`.\n     #[inline]\n-    #[unstable = \"may be merged with RWLock in the future\"]\n-    pub fn read(&'static self) -> LockResult<RWLockReadGuard<'static, ()>> {\n+    #[unstable = \"may be merged with RwLock in the future\"]\n+    pub fn read(&'static self) -> LockResult<RwLockReadGuard<'static, ()>> {\n         unsafe { self.lock.read() }\n-        RWLockReadGuard::new(self, &DUMMY.0)\n+        RwLockReadGuard::new(self, &DUMMY.0)\n     }\n \n     /// Attempt to acquire this lock with shared read access.\n     ///\n-    /// See `RWLock::try_read`.\n+    /// See `RwLock::try_read`.\n     #[inline]\n-    #[unstable = \"may be merged with RWLock in the future\"]\n+    #[unstable = \"may be merged with RwLock in the future\"]\n     pub fn try_read(&'static self)\n-                    -> TryLockResult<RWLockReadGuard<'static, ()>> {\n+                    -> TryLockResult<RwLockReadGuard<'static, ()>> {\n         if unsafe { self.lock.try_read() } {\n-            Ok(try!(RWLockReadGuard::new(self, &DUMMY.0)))\n+            Ok(try!(RwLockReadGuard::new(self, &DUMMY.0)))\n         } else {\n             Err(TryLockError::WouldBlock)\n         }\n@@ -267,23 +267,23 @@ impl StaticRWLock {\n     /// Lock this rwlock with exclusive write access, blocking the current\n     /// thread until it can be acquired.\n     ///\n-    /// See `RWLock::write`.\n+    /// See `RwLock::write`.\n     #[inline]\n-    #[unstable = \"may be merged with RWLock in the future\"]\n-    pub fn write(&'static self) -> LockResult<RWLockWriteGuard<'static, ()>> {\n+    #[unstable = \"may be merged with RwLock in the future\"]\n+    pub fn write(&'static self) -> LockResult<RwLockWriteGuard<'static, ()>> {\n         unsafe { self.lock.write() }\n-        RWLockWriteGuard::new(self, &DUMMY.0)\n+        RwLockWriteGuard::new(self, &DUMMY.0)\n     }\n \n     /// Attempt to lock this rwlock with exclusive write access.\n     ///\n-    /// See `RWLock::try_write`.\n+    /// See `RwLock::try_write`.\n     #[inline]\n-    #[unstable = \"may be merged with RWLock in the future\"]\n+    #[unstable = \"may be merged with RwLock in the future\"]\n     pub fn try_write(&'static self)\n-                     -> TryLockResult<RWLockWriteGuard<'static, ()>> {\n+                     -> TryLockResult<RwLockWriteGuard<'static, ()>> {\n         if unsafe { self.lock.try_write() } {\n-            Ok(try!(RWLockWriteGuard::new(self, &DUMMY.0)))\n+            Ok(try!(RwLockWriteGuard::new(self, &DUMMY.0)))\n         } else {\n             Err(TryLockError::WouldBlock)\n         }\n@@ -295,29 +295,29 @@ impl StaticRWLock {\n     /// active users of the lock, and this also doesn't prevent any future users\n     /// of this lock. This method is required to be called to not leak memory on\n     /// all platforms.\n-    #[unstable = \"may be merged with RWLock in the future\"]\n+    #[unstable = \"may be merged with RwLock in the future\"]\n     pub unsafe fn destroy(&'static self) {\n         self.lock.destroy()\n     }\n }\n \n-impl<'rwlock, T> RWLockReadGuard<'rwlock, T> {\n-    fn new(lock: &'rwlock StaticRWLock, data: &'rwlock UnsafeCell<T>)\n-           -> LockResult<RWLockReadGuard<'rwlock, T>> {\n+impl<'rwlock, T> RwLockReadGuard<'rwlock, T> {\n+    fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n+           -> LockResult<RwLockReadGuard<'rwlock, T>> {\n         poison::map_result(lock.poison.borrow(), |_| {\n-            RWLockReadGuard {\n+            RwLockReadGuard {\n                 __lock: lock,\n                 __data: data,\n                 __marker: marker::NoSend,\n             }\n         })\n     }\n }\n-impl<'rwlock, T> RWLockWriteGuard<'rwlock, T> {\n-    fn new(lock: &'rwlock StaticRWLock, data: &'rwlock UnsafeCell<T>)\n-           -> LockResult<RWLockWriteGuard<'rwlock, T>> {\n+impl<'rwlock, T> RwLockWriteGuard<'rwlock, T> {\n+    fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n+           -> LockResult<RwLockWriteGuard<'rwlock, T>> {\n         poison::map_result(lock.poison.borrow(), |guard| {\n-            RWLockWriteGuard {\n+            RwLockWriteGuard {\n                 __lock: lock,\n                 __data: data,\n                 __poison: guard,\n@@ -327,31 +327,31 @@ impl<'rwlock, T> RWLockWriteGuard<'rwlock, T> {\n     }\n }\n \n-impl<'rwlock, T> Deref for RWLockReadGuard<'rwlock, T> {\n+impl<'rwlock, T> Deref for RwLockReadGuard<'rwlock, T> {\n     type Target = T;\n \n     fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n }\n-impl<'rwlock, T> Deref for RWLockWriteGuard<'rwlock, T> {\n+impl<'rwlock, T> Deref for RwLockWriteGuard<'rwlock, T> {\n     type Target = T;\n \n     fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n }\n-impl<'rwlock, T> DerefMut for RWLockWriteGuard<'rwlock, T> {\n+impl<'rwlock, T> DerefMut for RwLockWriteGuard<'rwlock, T> {\n     fn deref_mut(&mut self) -> &mut T {\n         unsafe { &mut *self.__data.get() }\n     }\n }\n \n #[unsafe_destructor]\n-impl<'a, T> Drop for RWLockReadGuard<'a, T> {\n+impl<'a, T> Drop for RwLockReadGuard<'a, T> {\n     fn drop(&mut self) {\n         unsafe { self.__lock.lock.read_unlock(); }\n     }\n }\n \n #[unsafe_destructor]\n-impl<'a, T> Drop for RWLockWriteGuard<'a, T> {\n+impl<'a, T> Drop for RwLockWriteGuard<'a, T> {\n     fn drop(&mut self) {\n         self.__lock.poison.done(&self.__poison);\n         unsafe { self.__lock.lock.write_unlock(); }\n@@ -365,11 +365,11 @@ mod tests {\n     use rand::{self, Rng};\n     use sync::mpsc::channel;\n     use thread::Thread;\n-    use sync::{Arc, RWLock, StaticRWLock, RWLOCK_INIT};\n+    use sync::{Arc, RwLock, StaticRwLock, RW_LOCK_INIT};\n \n     #[test]\n     fn smoke() {\n-        let l = RWLock::new(());\n+        let l = RwLock::new(());\n         drop(l.read().unwrap());\n         drop(l.write().unwrap());\n         drop((l.read().unwrap(), l.read().unwrap()));\n@@ -378,7 +378,7 @@ mod tests {\n \n     #[test]\n     fn static_smoke() {\n-        static R: StaticRWLock = RWLOCK_INIT;\n+        static R: StaticRwLock = RW_LOCK_INIT;\n         drop(R.read().unwrap());\n         drop(R.write().unwrap());\n         drop((R.read().unwrap(), R.read().unwrap()));\n@@ -388,7 +388,7 @@ mod tests {\n \n     #[test]\n     fn frob() {\n-        static R: StaticRWLock = RWLOCK_INIT;\n+        static R: StaticRwLock = RW_LOCK_INIT;\n         static N: uint = 10;\n         static M: uint = 1000;\n \n@@ -414,7 +414,7 @@ mod tests {\n \n     #[test]\n     fn test_rw_arc_poison_wr() {\n-        let arc = Arc::new(RWLock::new(1i));\n+        let arc = Arc::new(RwLock::new(1i));\n         let arc2 = arc.clone();\n         let _: Result<uint, _> = Thread::spawn(move|| {\n             let _lock = arc2.write().unwrap();\n@@ -425,7 +425,7 @@ mod tests {\n \n     #[test]\n     fn test_rw_arc_poison_ww() {\n-        let arc = Arc::new(RWLock::new(1i));\n+        let arc = Arc::new(RwLock::new(1i));\n         let arc2 = arc.clone();\n         let _: Result<uint, _> = Thread::spawn(move|| {\n             let _lock = arc2.write().unwrap();\n@@ -436,7 +436,7 @@ mod tests {\n \n     #[test]\n     fn test_rw_arc_no_poison_rr() {\n-        let arc = Arc::new(RWLock::new(1i));\n+        let arc = Arc::new(RwLock::new(1i));\n         let arc2 = arc.clone();\n         let _: Result<uint, _> = Thread::spawn(move|| {\n             let _lock = arc2.read().unwrap();\n@@ -447,7 +447,7 @@ mod tests {\n     }\n     #[test]\n     fn test_rw_arc_no_poison_rw() {\n-        let arc = Arc::new(RWLock::new(1i));\n+        let arc = Arc::new(RwLock::new(1i));\n         let arc2 = arc.clone();\n         let _: Result<uint, _> = Thread::spawn(move|| {\n             let _lock = arc2.read().unwrap();\n@@ -459,7 +459,7 @@ mod tests {\n \n     #[test]\n     fn test_rw_arc() {\n-        let arc = Arc::new(RWLock::new(0i));\n+        let arc = Arc::new(RwLock::new(0i));\n         let arc2 = arc.clone();\n         let (tx, rx) = channel();\n \n@@ -497,11 +497,11 @@ mod tests {\n \n     #[test]\n     fn test_rw_arc_access_in_unwind() {\n-        let arc = Arc::new(RWLock::new(1i));\n+        let arc = Arc::new(RwLock::new(1i));\n         let arc2 = arc.clone();\n         let _ = Thread::spawn(move|| -> () {\n             struct Unwinder {\n-                i: Arc<RWLock<int>>,\n+                i: Arc<RwLock<int>>,\n             }\n             impl Drop for Unwinder {\n                 fn drop(&mut self) {"}]}