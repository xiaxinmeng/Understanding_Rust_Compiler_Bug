{"sha": "4b5cffc04b526d9d9f94e07f0fecb24a22595f00", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiNWNmZmMwNGI1MjZkOWQ5Zjk0ZTA3ZjBmZWNiMjRhMjI1OTVmMDA=", "commit": {"author": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2016-12-19T07:59:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-12-19T07:59:38Z"}, "message": "Rollup merge of #38421 - apasel422:issue-36934, r=alexcrichton\n\nReplace invalid use of `&mut` with `UnsafeCell` in `std::sync::mpsc`\n\nCloses #36934\n\nr? @alexcrichton", "tree": {"sha": "91007043a51b2c1881bd98c488fbf23006934bde", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91007043a51b2c1881bd98c488fbf23006934bde"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b5cffc04b526d9d9f94e07f0fecb24a22595f00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b5cffc04b526d9d9f94e07f0fecb24a22595f00", "html_url": "https://github.com/rust-lang/rust/commit/4b5cffc04b526d9d9f94e07f0fecb24a22595f00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b5cffc04b526d9d9f94e07f0fecb24a22595f00/comments", "author": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d38beccdc441e6023f084e16281a530e05b6bb0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d38beccdc441e6023f084e16281a530e05b6bb0a", "html_url": "https://github.com/rust-lang/rust/commit/d38beccdc441e6023f084e16281a530e05b6bb0a"}, {"sha": "26d4308c6acbbde642be4621f5e3487b24ed8bd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/26d4308c6acbbde642be4621f5e3487b24ed8bd1", "html_url": "https://github.com/rust-lang/rust/commit/26d4308c6acbbde642be4621f5e3487b24ed8bd1"}], "stats": {"total": 656, "additions": 328, "deletions": 328}, "files": [{"sha": "8bcf008649f222cdc70b16a11302d8445064faa7", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 85, "deletions": 107, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/4b5cffc04b526d9d9f94e07f0fecb24a22595f00/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b5cffc04b526d9d9f94e07f0fecb24a22595f00/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=4b5cffc04b526d9d9f94e07f0fecb24a22595f00", "patch": "@@ -348,7 +348,7 @@ impl<T> !Sync for Sender<T> { }\n /// owned by one thread, but it can be cloned to send to other threads.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SyncSender<T> {\n-    inner: Arc<UnsafeCell<sync::Packet<T>>>,\n+    inner: Arc<sync::Packet<T>>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -426,10 +426,10 @@ pub enum TrySendError<T> {\n }\n \n enum Flavor<T> {\n-    Oneshot(Arc<UnsafeCell<oneshot::Packet<T>>>),\n-    Stream(Arc<UnsafeCell<stream::Packet<T>>>),\n-    Shared(Arc<UnsafeCell<shared::Packet<T>>>),\n-    Sync(Arc<UnsafeCell<sync::Packet<T>>>),\n+    Oneshot(Arc<oneshot::Packet<T>>),\n+    Stream(Arc<stream::Packet<T>>),\n+    Shared(Arc<shared::Packet<T>>),\n+    Sync(Arc<sync::Packet<T>>),\n }\n \n #[doc(hidden)]\n@@ -487,7 +487,7 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn channel<T>() -> (Sender<T>, Receiver<T>) {\n-    let a = Arc::new(UnsafeCell::new(oneshot::Packet::new()));\n+    let a = Arc::new(oneshot::Packet::new());\n     (Sender::new(Flavor::Oneshot(a.clone())), Receiver::new(Flavor::Oneshot(a)))\n }\n \n@@ -532,7 +532,7 @@ pub fn channel<T>() -> (Sender<T>, Receiver<T>) {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn sync_channel<T>(bound: usize) -> (SyncSender<T>, Receiver<T>) {\n-    let a = Arc::new(UnsafeCell::new(sync::Packet::new(bound)));\n+    let a = Arc::new(sync::Packet::new(bound));\n     (SyncSender::new(a.clone()), Receiver::new(Flavor::Sync(a)))\n }\n \n@@ -578,38 +578,30 @@ impl<T> Sender<T> {\n     pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n         let (new_inner, ret) = match *unsafe { self.inner() } {\n             Flavor::Oneshot(ref p) => {\n-                unsafe {\n-                    let p = p.get();\n-                    if !(*p).sent() {\n-                        return (*p).send(t).map_err(SendError);\n-                    } else {\n-                        let a =\n-                            Arc::new(UnsafeCell::new(stream::Packet::new()));\n-                        let rx = Receiver::new(Flavor::Stream(a.clone()));\n-                        match (*p).upgrade(rx) {\n-                            oneshot::UpSuccess => {\n-                                let ret = (*a.get()).send(t);\n-                                (a, ret)\n-                            }\n-                            oneshot::UpDisconnected => (a, Err(t)),\n-                            oneshot::UpWoke(token) => {\n-                                // This send cannot panic because the thread is\n-                                // asleep (we're looking at it), so the receiver\n-                                // can't go away.\n-                                (*a.get()).send(t).ok().unwrap();\n-                                token.signal();\n-                                (a, Ok(()))\n-                            }\n+                if !p.sent() {\n+                    return p.send(t).map_err(SendError);\n+                } else {\n+                    let a = Arc::new(stream::Packet::new());\n+                    let rx = Receiver::new(Flavor::Stream(a.clone()));\n+                    match p.upgrade(rx) {\n+                        oneshot::UpSuccess => {\n+                            let ret = a.send(t);\n+                            (a, ret)\n+                        }\n+                        oneshot::UpDisconnected => (a, Err(t)),\n+                        oneshot::UpWoke(token) => {\n+                            // This send cannot panic because the thread is\n+                            // asleep (we're looking at it), so the receiver\n+                            // can't go away.\n+                            a.send(t).ok().unwrap();\n+                            token.signal();\n+                            (a, Ok(()))\n                         }\n                     }\n                 }\n             }\n-            Flavor::Stream(ref p) => return unsafe {\n-                (*p.get()).send(t).map_err(SendError)\n-            },\n-            Flavor::Shared(ref p) => return unsafe {\n-                (*p.get()).send(t).map_err(SendError)\n-            },\n+            Flavor::Stream(ref p) => return p.send(t).map_err(SendError),\n+            Flavor::Shared(ref p) => return p.send(t).map_err(SendError),\n             Flavor::Sync(..) => unreachable!(),\n         };\n \n@@ -624,41 +616,43 @@ impl<T> Sender<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Sender<T> {\n     fn clone(&self) -> Sender<T> {\n-        let (packet, sleeper, guard) = match *unsafe { self.inner() } {\n+        let packet = match *unsafe { self.inner() } {\n             Flavor::Oneshot(ref p) => {\n-                let a = Arc::new(UnsafeCell::new(shared::Packet::new()));\n-                unsafe {\n-                    let guard = (*a.get()).postinit_lock();\n+                let a = Arc::new(shared::Packet::new());\n+                {\n+                    let guard = a.postinit_lock();\n                     let rx = Receiver::new(Flavor::Shared(a.clone()));\n-                    match (*p.get()).upgrade(rx) {\n+                    let sleeper = match p.upgrade(rx) {\n                         oneshot::UpSuccess |\n-                        oneshot::UpDisconnected => (a, None, guard),\n-                        oneshot::UpWoke(task) => (a, Some(task), guard)\n-                    }\n+                        oneshot::UpDisconnected => None,\n+                        oneshot::UpWoke(task) => Some(task),\n+                    };\n+                    a.inherit_blocker(sleeper, guard);\n                 }\n+                a\n             }\n             Flavor::Stream(ref p) => {\n-                let a = Arc::new(UnsafeCell::new(shared::Packet::new()));\n-                unsafe {\n-                    let guard = (*a.get()).postinit_lock();\n+                let a = Arc::new(shared::Packet::new());\n+                {\n+                    let guard = a.postinit_lock();\n                     let rx = Receiver::new(Flavor::Shared(a.clone()));\n-                    match (*p.get()).upgrade(rx) {\n+                    let sleeper = match p.upgrade(rx) {\n                         stream::UpSuccess |\n-                        stream::UpDisconnected => (a, None, guard),\n-                        stream::UpWoke(task) => (a, Some(task), guard),\n-                    }\n+                        stream::UpDisconnected => None,\n+                        stream::UpWoke(task) => Some(task),\n+                    };\n+                    a.inherit_blocker(sleeper, guard);\n                 }\n+                a\n             }\n             Flavor::Shared(ref p) => {\n-                unsafe { (*p.get()).clone_chan(); }\n+                p.clone_chan();\n                 return Sender::new(Flavor::Shared(p.clone()));\n             }\n             Flavor::Sync(..) => unreachable!(),\n         };\n \n         unsafe {\n-            (*packet.get()).inherit_blocker(sleeper, guard);\n-\n             let tmp = Sender::new(Flavor::Shared(packet.clone()));\n             mem::swap(self.inner_mut(), tmp.inner_mut());\n         }\n@@ -669,10 +663,10 @@ impl<T> Clone for Sender<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Sender<T> {\n     fn drop(&mut self) {\n-        match *unsafe { self.inner_mut() } {\n-            Flavor::Oneshot(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n-            Flavor::Stream(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n-            Flavor::Shared(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n+        match *unsafe { self.inner() } {\n+            Flavor::Oneshot(ref p) => p.drop_chan(),\n+            Flavor::Stream(ref p) => p.drop_chan(),\n+            Flavor::Shared(ref p) => p.drop_chan(),\n             Flavor::Sync(..) => unreachable!(),\n         }\n     }\n@@ -690,7 +684,7 @@ impl<T> fmt::Debug for Sender<T> {\n ////////////////////////////////////////////////////////////////////////////////\n \n impl<T> SyncSender<T> {\n-    fn new(inner: Arc<UnsafeCell<sync::Packet<T>>>) -> SyncSender<T> {\n+    fn new(inner: Arc<sync::Packet<T>>) -> SyncSender<T> {\n         SyncSender { inner: inner }\n     }\n \n@@ -710,7 +704,7 @@ impl<T> SyncSender<T> {\n     /// information.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n-        unsafe { (*self.inner.get()).send(t).map_err(SendError) }\n+        self.inner.send(t).map_err(SendError)\n     }\n \n     /// Attempts to send a value on this channel without blocking.\n@@ -724,22 +718,22 @@ impl<T> SyncSender<T> {\n     /// receiver has received the data or not if this function is successful.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> {\n-        unsafe { (*self.inner.get()).try_send(t) }\n+        self.inner.try_send(t)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for SyncSender<T> {\n     fn clone(&self) -> SyncSender<T> {\n-        unsafe { (*self.inner.get()).clone_chan(); }\n+        self.inner.clone_chan();\n         SyncSender::new(self.inner.clone())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for SyncSender<T> {\n     fn drop(&mut self) {\n-        unsafe { (*self.inner.get()).drop_chan(); }\n+        self.inner.drop_chan();\n     }\n }\n \n@@ -772,7 +766,7 @@ impl<T> Receiver<T> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n                 Flavor::Oneshot(ref p) => {\n-                    match unsafe { (*p.get()).try_recv() } {\n+                    match p.try_recv() {\n                         Ok(t) => return Ok(t),\n                         Err(oneshot::Empty) => return Err(TryRecvError::Empty),\n                         Err(oneshot::Disconnected) => {\n@@ -782,7 +776,7 @@ impl<T> Receiver<T> {\n                     }\n                 }\n                 Flavor::Stream(ref p) => {\n-                    match unsafe { (*p.get()).try_recv() } {\n+                    match p.try_recv() {\n                         Ok(t) => return Ok(t),\n                         Err(stream::Empty) => return Err(TryRecvError::Empty),\n                         Err(stream::Disconnected) => {\n@@ -792,7 +786,7 @@ impl<T> Receiver<T> {\n                     }\n                 }\n                 Flavor::Shared(ref p) => {\n-                    match unsafe { (*p.get()).try_recv() } {\n+                    match p.try_recv() {\n                         Ok(t) => return Ok(t),\n                         Err(shared::Empty) => return Err(TryRecvError::Empty),\n                         Err(shared::Disconnected) => {\n@@ -801,7 +795,7 @@ impl<T> Receiver<T> {\n                     }\n                 }\n                 Flavor::Sync(ref p) => {\n-                    match unsafe { (*p.get()).try_recv() } {\n+                    match p.try_recv() {\n                         Ok(t) => return Ok(t),\n                         Err(sync::Empty) => return Err(TryRecvError::Empty),\n                         Err(sync::Disconnected) => {\n@@ -875,31 +869,29 @@ impl<T> Receiver<T> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n                 Flavor::Oneshot(ref p) => {\n-                    match unsafe { (*p.get()).recv(None) } {\n+                    match p.recv(None) {\n                         Ok(t) => return Ok(t),\n                         Err(oneshot::Disconnected) => return Err(RecvError),\n                         Err(oneshot::Upgraded(rx)) => rx,\n                         Err(oneshot::Empty) => unreachable!(),\n                     }\n                 }\n                 Flavor::Stream(ref p) => {\n-                    match unsafe { (*p.get()).recv(None) } {\n+                    match p.recv(None) {\n                         Ok(t) => return Ok(t),\n                         Err(stream::Disconnected) => return Err(RecvError),\n                         Err(stream::Upgraded(rx)) => rx,\n                         Err(stream::Empty) => unreachable!(),\n                     }\n                 }\n                 Flavor::Shared(ref p) => {\n-                    match unsafe { (*p.get()).recv(None) } {\n+                    match p.recv(None) {\n                         Ok(t) => return Ok(t),\n                         Err(shared::Disconnected) => return Err(RecvError),\n                         Err(shared::Empty) => unreachable!(),\n                     }\n                 }\n-                Flavor::Sync(ref p) => return unsafe {\n-                    (*p.get()).recv(None).map_err(|_| RecvError)\n-                }\n+                Flavor::Sync(ref p) => return p.recv(None).map_err(|_| RecvError),\n             };\n             unsafe {\n                 mem::swap(self.inner_mut(), new_port.inner_mut());\n@@ -952,30 +944,30 @@ impl<T> Receiver<T> {\n         loop {\n             let port_or_empty = match *unsafe { self.inner() } {\n                 Flavor::Oneshot(ref p) => {\n-                    match unsafe { (*p.get()).recv(Some(deadline)) } {\n+                    match p.recv(Some(deadline)) {\n                         Ok(t) => return Ok(t),\n                         Err(oneshot::Disconnected) => return Err(Disconnected),\n                         Err(oneshot::Upgraded(rx)) => Some(rx),\n                         Err(oneshot::Empty) => None,\n                     }\n                 }\n                 Flavor::Stream(ref p) => {\n-                    match unsafe { (*p.get()).recv(Some(deadline)) } {\n+                    match p.recv(Some(deadline)) {\n                         Ok(t) => return Ok(t),\n                         Err(stream::Disconnected) => return Err(Disconnected),\n                         Err(stream::Upgraded(rx)) => Some(rx),\n                         Err(stream::Empty) => None,\n                     }\n                 }\n                 Flavor::Shared(ref p) => {\n-                    match unsafe { (*p.get()).recv(Some(deadline)) } {\n+                    match p.recv(Some(deadline)) {\n                         Ok(t) => return Ok(t),\n                         Err(shared::Disconnected) => return Err(Disconnected),\n                         Err(shared::Empty) => None,\n                     }\n                 }\n                 Flavor::Sync(ref p) => {\n-                    match unsafe { (*p.get()).recv(Some(deadline)) } {\n+                    match p.recv(Some(deadline)) {\n                         Ok(t) => return Ok(t),\n                         Err(sync::Disconnected) => return Err(Disconnected),\n                         Err(sync::Empty) => None,\n@@ -1020,23 +1012,19 @@ impl<T> select::Packet for Receiver<T> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n                 Flavor::Oneshot(ref p) => {\n-                    match unsafe { (*p.get()).can_recv() } {\n+                    match p.can_recv() {\n                         Ok(ret) => return ret,\n                         Err(upgrade) => upgrade,\n                     }\n                 }\n                 Flavor::Stream(ref p) => {\n-                    match unsafe { (*p.get()).can_recv() } {\n+                    match p.can_recv() {\n                         Ok(ret) => return ret,\n                         Err(upgrade) => upgrade,\n                     }\n                 }\n-                Flavor::Shared(ref p) => {\n-                    return unsafe { (*p.get()).can_recv() };\n-                }\n-                Flavor::Sync(ref p) => {\n-                    return unsafe { (*p.get()).can_recv() };\n-                }\n+                Flavor::Shared(ref p) => return p.can_recv(),\n+                Flavor::Sync(ref p) => return p.can_recv(),\n             };\n             unsafe {\n                 mem::swap(self.inner_mut(),\n@@ -1049,25 +1037,21 @@ impl<T> select::Packet for Receiver<T> {\n         loop {\n             let (t, new_port) = match *unsafe { self.inner() } {\n                 Flavor::Oneshot(ref p) => {\n-                    match unsafe { (*p.get()).start_selection(token) } {\n+                    match p.start_selection(token) {\n                         oneshot::SelSuccess => return Installed,\n                         oneshot::SelCanceled => return Abort,\n                         oneshot::SelUpgraded(t, rx) => (t, rx),\n                     }\n                 }\n                 Flavor::Stream(ref p) => {\n-                    match unsafe { (*p.get()).start_selection(token) } {\n+                    match p.start_selection(token) {\n                         stream::SelSuccess => return Installed,\n                         stream::SelCanceled => return Abort,\n                         stream::SelUpgraded(t, rx) => (t, rx),\n                     }\n                 }\n-                Flavor::Shared(ref p) => {\n-                    return unsafe { (*p.get()).start_selection(token) };\n-                }\n-                Flavor::Sync(ref p) => {\n-                    return unsafe { (*p.get()).start_selection(token) };\n-                }\n+                Flavor::Shared(ref p) => return p.start_selection(token),\n+                Flavor::Sync(ref p) => return p.start_selection(token),\n             };\n             token = t;\n             unsafe {\n@@ -1080,16 +1064,10 @@ impl<T> select::Packet for Receiver<T> {\n         let mut was_upgrade = false;\n         loop {\n             let result = match *unsafe { self.inner() } {\n-                Flavor::Oneshot(ref p) => unsafe { (*p.get()).abort_selection() },\n-                Flavor::Stream(ref p) => unsafe {\n-                    (*p.get()).abort_selection(was_upgrade)\n-                },\n-                Flavor::Shared(ref p) => return unsafe {\n-                    (*p.get()).abort_selection(was_upgrade)\n-                },\n-                Flavor::Sync(ref p) => return unsafe {\n-                    (*p.get()).abort_selection()\n-                },\n+                Flavor::Oneshot(ref p) => p.abort_selection(),\n+                Flavor::Stream(ref p) => p.abort_selection(was_upgrade),\n+                Flavor::Shared(ref p) => return p.abort_selection(was_upgrade),\n+                Flavor::Sync(ref p) => return p.abort_selection(),\n             };\n             let new_port = match result { Ok(b) => return b, Err(p) => p };\n             was_upgrade = true;\n@@ -1142,11 +1120,11 @@ impl <T> IntoIterator for Receiver<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Receiver<T> {\n     fn drop(&mut self) {\n-        match *unsafe { self.inner_mut() } {\n-            Flavor::Oneshot(ref mut p) => unsafe { (*p.get()).drop_port(); },\n-            Flavor::Stream(ref mut p) => unsafe { (*p.get()).drop_port(); },\n-            Flavor::Shared(ref mut p) => unsafe { (*p.get()).drop_port(); },\n-            Flavor::Sync(ref mut p) => unsafe { (*p.get()).drop_port(); },\n+        match *unsafe { self.inner() } {\n+            Flavor::Oneshot(ref p) => p.drop_port(),\n+            Flavor::Stream(ref p) => p.drop_port(),\n+            Flavor::Shared(ref p) => p.drop_port(),\n+            Flavor::Sync(ref p) => p.drop_port(),\n         }\n     }\n }"}, {"sha": "b8e50c9297b647c852eed8d5d4ed5e803c575047", "filename": "src/libstd/sync/mpsc/oneshot.rs", "status": "modified", "additions": 153, "deletions": 140, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/4b5cffc04b526d9d9f94e07f0fecb24a22595f00/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b5cffc04b526d9d9f94e07f0fecb24a22595f00/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs?ref=4b5cffc04b526d9d9f94e07f0fecb24a22595f00", "patch": "@@ -39,7 +39,8 @@ use self::MyUpgrade::*;\n \n use sync::mpsc::Receiver;\n use sync::mpsc::blocking::{self, SignalToken};\n-use core::mem;\n+use cell::UnsafeCell;\n+use ptr;\n use sync::atomic::{AtomicUsize, Ordering};\n use time::Instant;\n \n@@ -57,10 +58,10 @@ pub struct Packet<T> {\n     // Internal state of the chan/port pair (stores the blocked thread as well)\n     state: AtomicUsize,\n     // One-shot data slot location\n-    data: Option<T>,\n+    data: UnsafeCell<Option<T>>,\n     // when used for the second time, a oneshot channel must be upgraded, and\n     // this contains the slot for the upgrade\n-    upgrade: MyUpgrade<T>,\n+    upgrade: UnsafeCell<MyUpgrade<T>>,\n }\n \n pub enum Failure<T> {\n@@ -90,56 +91,60 @@ enum MyUpgrade<T> {\n impl<T> Packet<T> {\n     pub fn new() -> Packet<T> {\n         Packet {\n-            data: None,\n-            upgrade: NothingSent,\n+            data: UnsafeCell::new(None),\n+            upgrade: UnsafeCell::new(NothingSent),\n             state: AtomicUsize::new(EMPTY),\n         }\n     }\n \n-    pub fn send(&mut self, t: T) -> Result<(), T> {\n-        // Sanity check\n-        match self.upgrade {\n-            NothingSent => {}\n-            _ => panic!(\"sending on a oneshot that's already sent on \"),\n-        }\n-        assert!(self.data.is_none());\n-        self.data = Some(t);\n-        self.upgrade = SendUsed;\n-\n-        match self.state.swap(DATA, Ordering::SeqCst) {\n-            // Sent the data, no one was waiting\n-            EMPTY => Ok(()),\n-\n-            // Couldn't send the data, the port hung up first. Return the data\n-            // back up the stack.\n-            DISCONNECTED => {\n-                self.state.swap(DISCONNECTED, Ordering::SeqCst);\n-                self.upgrade = NothingSent;\n-                Err(self.data.take().unwrap())\n+    pub fn send(&self, t: T) -> Result<(), T> {\n+        unsafe {\n+            // Sanity check\n+            match *self.upgrade.get() {\n+                NothingSent => {}\n+                _ => panic!(\"sending on a oneshot that's already sent on \"),\n             }\n+            assert!((*self.data.get()).is_none());\n+            ptr::write(self.data.get(), Some(t));\n+            ptr::write(self.upgrade.get(), SendUsed);\n+\n+            match self.state.swap(DATA, Ordering::SeqCst) {\n+                // Sent the data, no one was waiting\n+                EMPTY => Ok(()),\n+\n+                // Couldn't send the data, the port hung up first. Return the data\n+                // back up the stack.\n+                DISCONNECTED => {\n+                    self.state.swap(DISCONNECTED, Ordering::SeqCst);\n+                    ptr::write(self.upgrade.get(), NothingSent);\n+                    Err((&mut *self.data.get()).take().unwrap())\n+                }\n \n-            // Not possible, these are one-use channels\n-            DATA => unreachable!(),\n+                // Not possible, these are one-use channels\n+                DATA => unreachable!(),\n \n-            // There is a thread waiting on the other end. We leave the 'DATA'\n-            // state inside so it'll pick it up on the other end.\n-            ptr => unsafe {\n-                SignalToken::cast_from_usize(ptr).signal();\n-                Ok(())\n+                // There is a thread waiting on the other end. We leave the 'DATA'\n+                // state inside so it'll pick it up on the other end.\n+                ptr => {\n+                    SignalToken::cast_from_usize(ptr).signal();\n+                    Ok(())\n+                }\n             }\n         }\n     }\n \n     // Just tests whether this channel has been sent on or not, this is only\n     // safe to use from the sender.\n     pub fn sent(&self) -> bool {\n-        match self.upgrade {\n-            NothingSent => false,\n-            _ => true,\n+        unsafe {\n+            match *self.upgrade.get() {\n+                NothingSent => false,\n+                _ => true,\n+            }\n         }\n     }\n \n-    pub fn recv(&mut self, deadline: Option<Instant>) -> Result<T, Failure<T>> {\n+    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, Failure<T>> {\n         // Attempt to not block the thread (it's a little expensive). If it looks\n         // like we're not empty, then immediately go through to `try_recv`.\n         if self.state.load(Ordering::SeqCst) == EMPTY {\n@@ -167,73 +172,77 @@ impl<T> Packet<T> {\n         self.try_recv()\n     }\n \n-    pub fn try_recv(&mut self) -> Result<T, Failure<T>> {\n-        match self.state.load(Ordering::SeqCst) {\n-            EMPTY => Err(Empty),\n-\n-            // We saw some data on the channel, but the channel can be used\n-            // again to send us an upgrade. As a result, we need to re-insert\n-            // into the channel that there's no data available (otherwise we'll\n-            // just see DATA next time). This is done as a cmpxchg because if\n-            // the state changes under our feet we'd rather just see that state\n-            // change.\n-            DATA => {\n-                self.state.compare_and_swap(DATA, EMPTY, Ordering::SeqCst);\n-                match self.data.take() {\n-                    Some(data) => Ok(data),\n-                    None => unreachable!(),\n+    pub fn try_recv(&self) -> Result<T, Failure<T>> {\n+        unsafe {\n+            match self.state.load(Ordering::SeqCst) {\n+                EMPTY => Err(Empty),\n+\n+                // We saw some data on the channel, but the channel can be used\n+                // again to send us an upgrade. As a result, we need to re-insert\n+                // into the channel that there's no data available (otherwise we'll\n+                // just see DATA next time). This is done as a cmpxchg because if\n+                // the state changes under our feet we'd rather just see that state\n+                // change.\n+                DATA => {\n+                    self.state.compare_and_swap(DATA, EMPTY, Ordering::SeqCst);\n+                    match (&mut *self.data.get()).take() {\n+                        Some(data) => Ok(data),\n+                        None => unreachable!(),\n+                    }\n                 }\n-            }\n \n-            // There's no guarantee that we receive before an upgrade happens,\n-            // and an upgrade flags the channel as disconnected, so when we see\n-            // this we first need to check if there's data available and *then*\n-            // we go through and process the upgrade.\n-            DISCONNECTED => {\n-                match self.data.take() {\n-                    Some(data) => Ok(data),\n-                    None => {\n-                        match mem::replace(&mut self.upgrade, SendUsed) {\n-                            SendUsed | NothingSent => Err(Disconnected),\n-                            GoUp(upgrade) => Err(Upgraded(upgrade))\n+                // There's no guarantee that we receive before an upgrade happens,\n+                // and an upgrade flags the channel as disconnected, so when we see\n+                // this we first need to check if there's data available and *then*\n+                // we go through and process the upgrade.\n+                DISCONNECTED => {\n+                    match (&mut *self.data.get()).take() {\n+                        Some(data) => Ok(data),\n+                        None => {\n+                            match ptr::replace(self.upgrade.get(), SendUsed) {\n+                                SendUsed | NothingSent => Err(Disconnected),\n+                                GoUp(upgrade) => Err(Upgraded(upgrade))\n+                            }\n                         }\n                     }\n                 }\n-            }\n \n-            // We are the sole receiver; there cannot be a blocking\n-            // receiver already.\n-            _ => unreachable!()\n+                // We are the sole receiver; there cannot be a blocking\n+                // receiver already.\n+                _ => unreachable!()\n+            }\n         }\n     }\n \n     // Returns whether the upgrade was completed. If the upgrade wasn't\n     // completed, then the port couldn't get sent to the other half (it will\n     // never receive it).\n-    pub fn upgrade(&mut self, up: Receiver<T>) -> UpgradeResult {\n-        let prev = match self.upgrade {\n-            NothingSent => NothingSent,\n-            SendUsed => SendUsed,\n-            _ => panic!(\"upgrading again\"),\n-        };\n-        self.upgrade = GoUp(up);\n-\n-        match self.state.swap(DISCONNECTED, Ordering::SeqCst) {\n-            // If the channel is empty or has data on it, then we're good to go.\n-            // Senders will check the data before the upgrade (in case we\n-            // plastered over the DATA state).\n-            DATA | EMPTY => UpSuccess,\n-\n-            // If the other end is already disconnected, then we failed the\n-            // upgrade. Be sure to trash the port we were given.\n-            DISCONNECTED => { self.upgrade = prev; UpDisconnected }\n-\n-            // If someone's waiting, we gotta wake them up\n-            ptr => UpWoke(unsafe { SignalToken::cast_from_usize(ptr) })\n+    pub fn upgrade(&self, up: Receiver<T>) -> UpgradeResult {\n+        unsafe {\n+            let prev = match *self.upgrade.get() {\n+                NothingSent => NothingSent,\n+                SendUsed => SendUsed,\n+                _ => panic!(\"upgrading again\"),\n+            };\n+            ptr::write(self.upgrade.get(), GoUp(up));\n+\n+            match self.state.swap(DISCONNECTED, Ordering::SeqCst) {\n+                // If the channel is empty or has data on it, then we're good to go.\n+                // Senders will check the data before the upgrade (in case we\n+                // plastered over the DATA state).\n+                DATA | EMPTY => UpSuccess,\n+\n+                // If the other end is already disconnected, then we failed the\n+                // upgrade. Be sure to trash the port we were given.\n+                DISCONNECTED => { ptr::replace(self.upgrade.get(), prev); UpDisconnected }\n+\n+                // If someone's waiting, we gotta wake them up\n+                ptr => UpWoke(SignalToken::cast_from_usize(ptr))\n+            }\n         }\n     }\n \n-    pub fn drop_chan(&mut self) {\n+    pub fn drop_chan(&self) {\n         match self.state.swap(DISCONNECTED, Ordering::SeqCst) {\n             DATA | DISCONNECTED | EMPTY => {}\n \n@@ -244,7 +253,7 @@ impl<T> Packet<T> {\n         }\n     }\n \n-    pub fn drop_port(&mut self) {\n+    pub fn drop_port(&self) {\n         match self.state.swap(DISCONNECTED, Ordering::SeqCst) {\n             // An empty channel has nothing to do, and a remotely disconnected\n             // channel also has nothing to do b/c we're about to run the drop\n@@ -254,7 +263,7 @@ impl<T> Packet<T> {\n             // There's data on the channel, so make sure we destroy it promptly.\n             // This is why not using an arc is a little difficult (need the box\n             // to stay valid while we take the data).\n-            DATA => { self.data.take().unwrap(); }\n+            DATA => unsafe { (&mut *self.data.get()).take().unwrap(); },\n \n             // We're the only ones that can block on this port\n             _ => unreachable!()\n@@ -267,70 +276,74 @@ impl<T> Packet<T> {\n \n     // If Ok, the value is whether this port has data, if Err, then the upgraded\n     // port needs to be checked instead of this one.\n-    pub fn can_recv(&mut self) -> Result<bool, Receiver<T>> {\n-        match self.state.load(Ordering::SeqCst) {\n-            EMPTY => Ok(false), // Welp, we tried\n-            DATA => Ok(true),   // we have some un-acquired data\n-            DISCONNECTED if self.data.is_some() => Ok(true), // we have data\n-            DISCONNECTED => {\n-                match mem::replace(&mut self.upgrade, SendUsed) {\n-                    // The other end sent us an upgrade, so we need to\n-                    // propagate upwards whether the upgrade can receive\n-                    // data\n-                    GoUp(upgrade) => Err(upgrade),\n-\n-                    // If the other end disconnected without sending an\n-                    // upgrade, then we have data to receive (the channel is\n-                    // disconnected).\n-                    up => { self.upgrade = up; Ok(true) }\n+    pub fn can_recv(&self) -> Result<bool, Receiver<T>> {\n+        unsafe {\n+            match self.state.load(Ordering::SeqCst) {\n+                EMPTY => Ok(false), // Welp, we tried\n+                DATA => Ok(true),   // we have some un-acquired data\n+                DISCONNECTED if (*self.data.get()).is_some() => Ok(true), // we have data\n+                DISCONNECTED => {\n+                    match ptr::replace(self.upgrade.get(), SendUsed) {\n+                        // The other end sent us an upgrade, so we need to\n+                        // propagate upwards whether the upgrade can receive\n+                        // data\n+                        GoUp(upgrade) => Err(upgrade),\n+\n+                        // If the other end disconnected without sending an\n+                        // upgrade, then we have data to receive (the channel is\n+                        // disconnected).\n+                        up => { ptr::write(self.upgrade.get(), up); Ok(true) }\n+                    }\n                 }\n+                _ => unreachable!(), // we're the \"one blocker\"\n             }\n-            _ => unreachable!(), // we're the \"one blocker\"\n         }\n     }\n \n     // Attempts to start selection on this port. This can either succeed, fail\n     // because there is data, or fail because there is an upgrade pending.\n-    pub fn start_selection(&mut self, token: SignalToken) -> SelectionResult<T> {\n-        let ptr = unsafe { token.cast_to_usize() };\n-        match self.state.compare_and_swap(EMPTY, ptr, Ordering::SeqCst) {\n-            EMPTY => SelSuccess,\n-            DATA => {\n-                drop(unsafe { SignalToken::cast_from_usize(ptr) });\n-                SelCanceled\n-            }\n-            DISCONNECTED if self.data.is_some() => {\n-                drop(unsafe { SignalToken::cast_from_usize(ptr) });\n-                SelCanceled\n-            }\n-            DISCONNECTED => {\n-                match mem::replace(&mut self.upgrade, SendUsed) {\n-                    // The other end sent us an upgrade, so we need to\n-                    // propagate upwards whether the upgrade can receive\n-                    // data\n-                    GoUp(upgrade) => {\n-                        SelUpgraded(unsafe { SignalToken::cast_from_usize(ptr) }, upgrade)\n-                    }\n+    pub fn start_selection(&self, token: SignalToken) -> SelectionResult<T> {\n+        unsafe {\n+            let ptr = token.cast_to_usize();\n+            match self.state.compare_and_swap(EMPTY, ptr, Ordering::SeqCst) {\n+                EMPTY => SelSuccess,\n+                DATA => {\n+                    drop(SignalToken::cast_from_usize(ptr));\n+                    SelCanceled\n+                }\n+                DISCONNECTED if (*self.data.get()).is_some() => {\n+                    drop(SignalToken::cast_from_usize(ptr));\n+                    SelCanceled\n+                }\n+                DISCONNECTED => {\n+                    match ptr::replace(self.upgrade.get(), SendUsed) {\n+                        // The other end sent us an upgrade, so we need to\n+                        // propagate upwards whether the upgrade can receive\n+                        // data\n+                        GoUp(upgrade) => {\n+                            SelUpgraded(SignalToken::cast_from_usize(ptr), upgrade)\n+                        }\n \n-                    // If the other end disconnected without sending an\n-                    // upgrade, then we have data to receive (the channel is\n-                    // disconnected).\n-                    up => {\n-                        self.upgrade = up;\n-                        drop(unsafe { SignalToken::cast_from_usize(ptr) });\n-                        SelCanceled\n+                        // If the other end disconnected without sending an\n+                        // upgrade, then we have data to receive (the channel is\n+                        // disconnected).\n+                        up => {\n+                            ptr::write(self.upgrade.get(), up);\n+                            drop(SignalToken::cast_from_usize(ptr));\n+                            SelCanceled\n+                        }\n                     }\n                 }\n+                _ => unreachable!(), // we're the \"one blocker\"\n             }\n-            _ => unreachable!(), // we're the \"one blocker\"\n         }\n     }\n \n     // Remove a previous selecting thread from this port. This ensures that the\n     // blocked thread will no longer be visible to any other threads.\n     //\n     // The return value indicates whether there's data on this port.\n-    pub fn abort_selection(&mut self) -> Result<bool, Receiver<T>> {\n+    pub fn abort_selection(&self) -> Result<bool, Receiver<T>> {\n         let state = match self.state.load(Ordering::SeqCst) {\n             // Each of these states means that no further activity will happen\n             // with regard to abortion selection\n@@ -356,16 +369,16 @@ impl<T> Packet<T> {\n             //\n             // We then need to check to see if there was an upgrade requested,\n             // and if so, the upgraded port needs to have its selection aborted.\n-            DISCONNECTED => {\n-                if self.data.is_some() {\n+            DISCONNECTED => unsafe {\n+                if (*self.data.get()).is_some() {\n                     Ok(true)\n                 } else {\n-                    match mem::replace(&mut self.upgrade, SendUsed) {\n+                    match ptr::replace(self.upgrade.get(), SendUsed) {\n                         GoUp(port) => Err(port),\n                         _ => Ok(true),\n                     }\n                 }\n-            }\n+            },\n \n             // We woke ourselves up from select.\n             ptr => unsafe {"}, {"sha": "f9e0290416432001d464d51e71d9a1d30cfc524b", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 56, "deletions": 50, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/4b5cffc04b526d9d9f94e07f0fecb24a22595f00/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b5cffc04b526d9d9f94e07f0fecb24a22595f00/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=4b5cffc04b526d9d9f94e07f0fecb24a22595f00", "patch": "@@ -24,6 +24,8 @@ use core::cmp;\n use core::intrinsics::abort;\n use core::isize;\n \n+use cell::UnsafeCell;\n+use ptr;\n use sync::atomic::{AtomicUsize, AtomicIsize, AtomicBool, Ordering};\n use sync::mpsc::blocking::{self, SignalToken};\n use sync::mpsc::mpsc_queue as mpsc;\n@@ -44,7 +46,7 @@ const MAX_STEALS: isize = 1 << 20;\n pub struct Packet<T> {\n     queue: mpsc::Queue<T>,\n     cnt: AtomicIsize, // How many items are on this channel\n-    steals: isize, // How many times has a port received without blocking?\n+    steals: UnsafeCell<isize>, // How many times has a port received without blocking?\n     to_wake: AtomicUsize, // SignalToken for wake up\n \n     // The number of channels which are currently using this packet.\n@@ -72,7 +74,7 @@ impl<T> Packet<T> {\n         Packet {\n             queue: mpsc::Queue::new(),\n             cnt: AtomicIsize::new(0),\n-            steals: 0,\n+            steals: UnsafeCell::new(0),\n             to_wake: AtomicUsize::new(0),\n             channels: AtomicUsize::new(2),\n             port_dropped: AtomicBool::new(false),\n@@ -95,7 +97,7 @@ impl<T> Packet<T> {\n     // threads in select().\n     //\n     // This can only be called at channel-creation time\n-    pub fn inherit_blocker(&mut self,\n+    pub fn inherit_blocker(&self,\n                            token: Option<SignalToken>,\n                            guard: MutexGuard<()>) {\n         token.map(|token| {\n@@ -122,7 +124,7 @@ impl<T> Packet<T> {\n             // To offset this bad increment, we initially set the steal count to\n             // -1. You'll find some special code in abort_selection() as well to\n             // ensure that this -1 steal count doesn't escape too far.\n-            self.steals = -1;\n+            unsafe { *self.steals.get() = -1; }\n         });\n \n         // When the shared packet is constructed, we grabbed this lock. The\n@@ -133,7 +135,7 @@ impl<T> Packet<T> {\n         drop(guard);\n     }\n \n-    pub fn send(&mut self, t: T) -> Result<(), T> {\n+    pub fn send(&self, t: T) -> Result<(), T> {\n         // See Port::drop for what's going on\n         if self.port_dropped.load(Ordering::SeqCst) { return Err(t) }\n \n@@ -218,7 +220,7 @@ impl<T> Packet<T> {\n         Ok(())\n     }\n \n-    pub fn recv(&mut self, deadline: Option<Instant>) -> Result<T, Failure> {\n+    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, Failure> {\n         // This code is essentially the exact same as that found in the stream\n         // case (see stream.rs)\n         match self.try_recv() {\n@@ -239,37 +241,38 @@ impl<T> Packet<T> {\n         }\n \n         match self.try_recv() {\n-            data @ Ok(..) => { self.steals -= 1; data }\n+            data @ Ok(..) => unsafe { *self.steals.get() -= 1; data },\n             data => data,\n         }\n     }\n \n     // Essentially the exact same thing as the stream decrement function.\n     // Returns true if blocking should proceed.\n-    fn decrement(&mut self, token: SignalToken) -> StartResult {\n-        assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n-        let ptr = unsafe { token.cast_to_usize() };\n-        self.to_wake.store(ptr, Ordering::SeqCst);\n-\n-        let steals = self.steals;\n-        self.steals = 0;\n-\n-        match self.cnt.fetch_sub(1 + steals, Ordering::SeqCst) {\n-            DISCONNECTED => { self.cnt.store(DISCONNECTED, Ordering::SeqCst); }\n-            // If we factor in our steals and notice that the channel has no\n-            // data, we successfully sleep\n-            n => {\n-                assert!(n >= 0);\n-                if n - steals <= 0 { return Installed }\n+    fn decrement(&self, token: SignalToken) -> StartResult {\n+        unsafe {\n+            assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n+            let ptr = token.cast_to_usize();\n+            self.to_wake.store(ptr, Ordering::SeqCst);\n+\n+            let steals = ptr::replace(self.steals.get(), 0);\n+\n+            match self.cnt.fetch_sub(1 + steals, Ordering::SeqCst) {\n+                DISCONNECTED => { self.cnt.store(DISCONNECTED, Ordering::SeqCst); }\n+                // If we factor in our steals and notice that the channel has no\n+                // data, we successfully sleep\n+                n => {\n+                    assert!(n >= 0);\n+                    if n - steals <= 0 { return Installed }\n+                }\n             }\n-        }\n \n-        self.to_wake.store(0, Ordering::SeqCst);\n-        drop(unsafe { SignalToken::cast_from_usize(ptr) });\n-        Abort\n+            self.to_wake.store(0, Ordering::SeqCst);\n+            drop(SignalToken::cast_from_usize(ptr));\n+            Abort\n+        }\n     }\n \n-    pub fn try_recv(&mut self) -> Result<T, Failure> {\n+    pub fn try_recv(&self) -> Result<T, Failure> {\n         let ret = match self.queue.pop() {\n             mpsc::Data(t) => Some(t),\n             mpsc::Empty => None,\n@@ -303,23 +306,23 @@ impl<T> Packet<T> {\n         match ret {\n             // See the discussion in the stream implementation for why we\n             // might decrement steals.\n-            Some(data) => {\n-                if self.steals > MAX_STEALS {\n+            Some(data) => unsafe {\n+                if *self.steals.get() > MAX_STEALS {\n                     match self.cnt.swap(0, Ordering::SeqCst) {\n                         DISCONNECTED => {\n                             self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n                         }\n                         n => {\n-                            let m = cmp::min(n, self.steals);\n-                            self.steals -= m;\n+                            let m = cmp::min(n, *self.steals.get());\n+                            *self.steals.get() -= m;\n                             self.bump(n - m);\n                         }\n                     }\n-                    assert!(self.steals >= 0);\n+                    assert!(*self.steals.get() >= 0);\n                 }\n-                self.steals += 1;\n+                *self.steals.get() += 1;\n                 Ok(data)\n-            }\n+            },\n \n             // See the discussion in the stream implementation for why we try\n             // again.\n@@ -341,7 +344,7 @@ impl<T> Packet<T> {\n \n     // Prepares this shared packet for a channel clone, essentially just bumping\n     // a refcount.\n-    pub fn clone_chan(&mut self) {\n+    pub fn clone_chan(&self) {\n         let old_count = self.channels.fetch_add(1, Ordering::SeqCst);\n \n         // See comments on Arc::clone() on why we do this (for `mem::forget`).\n@@ -355,7 +358,7 @@ impl<T> Packet<T> {\n     // Decrement the reference count on a channel. This is called whenever a\n     // Chan is dropped and may end up waking up a receiver. It's the receiver's\n     // responsibility on the other end to figure out that we've disconnected.\n-    pub fn drop_chan(&mut self) {\n+    pub fn drop_chan(&self) {\n         match self.channels.fetch_sub(1, Ordering::SeqCst) {\n             1 => {}\n             n if n > 1 => return,\n@@ -371,9 +374,9 @@ impl<T> Packet<T> {\n \n     // See the long discussion inside of stream.rs for why the queue is drained,\n     // and why it is done in this fashion.\n-    pub fn drop_port(&mut self) {\n+    pub fn drop_port(&self) {\n         self.port_dropped.store(true, Ordering::SeqCst);\n-        let mut steals = self.steals;\n+        let mut steals = unsafe { *self.steals.get() };\n         while {\n             let cnt = self.cnt.compare_and_swap(steals, DISCONNECTED, Ordering::SeqCst);\n             cnt != DISCONNECTED && cnt != steals\n@@ -390,7 +393,7 @@ impl<T> Packet<T> {\n     }\n \n     // Consumes ownership of the 'to_wake' field.\n-    fn take_to_wake(&mut self) -> SignalToken {\n+    fn take_to_wake(&self) -> SignalToken {\n         let ptr = self.to_wake.load(Ordering::SeqCst);\n         self.to_wake.store(0, Ordering::SeqCst);\n         assert!(ptr != 0);\n@@ -406,13 +409,13 @@ impl<T> Packet<T> {\n     //\n     // This is different than the stream version because there's no need to peek\n     // at the queue, we can just look at the local count.\n-    pub fn can_recv(&mut self) -> bool {\n+    pub fn can_recv(&self) -> bool {\n         let cnt = self.cnt.load(Ordering::SeqCst);\n-        cnt == DISCONNECTED || cnt - self.steals > 0\n+        cnt == DISCONNECTED || cnt - unsafe { *self.steals.get() } > 0\n     }\n \n     // increment the count on the channel (used for selection)\n-    fn bump(&mut self, amt: isize) -> isize {\n+    fn bump(&self, amt: isize) -> isize {\n         match self.cnt.fetch_add(amt, Ordering::SeqCst) {\n             DISCONNECTED => {\n                 self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n@@ -427,7 +430,7 @@ impl<T> Packet<T> {\n     //\n     // The code here is the same as in stream.rs, except that it doesn't need to\n     // peek at the channel to see if an upgrade is pending.\n-    pub fn start_selection(&mut self, token: SignalToken) -> StartResult {\n+    pub fn start_selection(&self, token: SignalToken) -> StartResult {\n         match self.decrement(token) {\n             Installed => Installed,\n             Abort => {\n@@ -443,7 +446,7 @@ impl<T> Packet<T> {\n     //\n     // This is similar to the stream implementation (hence fewer comments), but\n     // uses a different value for the \"steals\" variable.\n-    pub fn abort_selection(&mut self, _was_upgrade: bool) -> bool {\n+    pub fn abort_selection(&self, _was_upgrade: bool) -> bool {\n         // Before we do anything else, we bounce on this lock. The reason for\n         // doing this is to ensure that any upgrade-in-progress is gone and\n         // done with. Without this bounce, we can race with inherit_blocker\n@@ -477,12 +480,15 @@ impl<T> Packet<T> {\n                     thread::yield_now();\n                 }\n             }\n-            // if the number of steals is -1, it was the pre-emptive -1 steal\n-            // count from when we inherited a blocker. This is fine because\n-            // we're just going to overwrite it with a real value.\n-            assert!(self.steals == 0 || self.steals == -1);\n-            self.steals = steals;\n-            prev >= 0\n+            unsafe {\n+                // if the number of steals is -1, it was the pre-emptive -1 steal\n+                // count from when we inherited a blocker. This is fine because\n+                // we're just going to overwrite it with a real value.\n+                let old = self.steals.get();\n+                assert!(*old == 0 || *old == -1);\n+                *old = steals;\n+                prev >= 0\n+            }\n         }\n     }\n }"}, {"sha": "47cd8977fda23ced729085ce1339ca7c25b0ea6e", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/4b5cffc04b526d9d9f94e07f0fecb24a22595f00/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b5cffc04b526d9d9f94e07f0fecb24a22595f00/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=4b5cffc04b526d9d9f94e07f0fecb24a22595f00", "patch": "@@ -22,8 +22,10 @@ pub use self::UpgradeResult::*;\n pub use self::SelectionResult::*;\n use self::Message::*;\n \n+use cell::UnsafeCell;\n use core::cmp;\n use core::isize;\n+use ptr;\n use thread;\n use time::Instant;\n \n@@ -42,7 +44,7 @@ pub struct Packet<T> {\n     queue: spsc::Queue<Message<T>>, // internal queue for all message\n \n     cnt: AtomicIsize, // How many items are on this channel\n-    steals: isize, // How many times has a port received without blocking?\n+    steals: UnsafeCell<isize>, // How many times has a port received without blocking?\n     to_wake: AtomicUsize, // SignalToken for the blocked thread to wake up\n \n     port_dropped: AtomicBool, // flag if the channel has been destroyed.\n@@ -79,14 +81,14 @@ impl<T> Packet<T> {\n             queue: unsafe { spsc::Queue::new(128) },\n \n             cnt: AtomicIsize::new(0),\n-            steals: 0,\n+            steals: UnsafeCell::new(0),\n             to_wake: AtomicUsize::new(0),\n \n             port_dropped: AtomicBool::new(false),\n         }\n     }\n \n-    pub fn send(&mut self, t: T) -> Result<(), T> {\n+    pub fn send(&self, t: T) -> Result<(), T> {\n         // If the other port has deterministically gone away, then definitely\n         // must return the data back up the stack. Otherwise, the data is\n         // considered as being sent.\n@@ -99,15 +101,15 @@ impl<T> Packet<T> {\n         Ok(())\n     }\n \n-    pub fn upgrade(&mut self, up: Receiver<T>) -> UpgradeResult {\n+    pub fn upgrade(&self, up: Receiver<T>) -> UpgradeResult {\n         // If the port has gone away, then there's no need to proceed any\n         // further.\n         if self.port_dropped.load(Ordering::SeqCst) { return UpDisconnected }\n \n         self.do_send(GoUp(up))\n     }\n \n-    fn do_send(&mut self, t: Message<T>) -> UpgradeResult {\n+    fn do_send(&self, t: Message<T>) -> UpgradeResult {\n         self.queue.push(t);\n         match self.cnt.fetch_add(1, Ordering::SeqCst) {\n             // As described in the mod's doc comment, -1 == wakeup\n@@ -141,7 +143,7 @@ impl<T> Packet<T> {\n     }\n \n     // Consumes ownership of the 'to_wake' field.\n-    fn take_to_wake(&mut self) -> SignalToken {\n+    fn take_to_wake(&self) -> SignalToken {\n         let ptr = self.to_wake.load(Ordering::SeqCst);\n         self.to_wake.store(0, Ordering::SeqCst);\n         assert!(ptr != 0);\n@@ -151,13 +153,12 @@ impl<T> Packet<T> {\n     // Decrements the count on the channel for a sleeper, returning the sleeper\n     // back if it shouldn't sleep. Note that this is the location where we take\n     // steals into account.\n-    fn decrement(&mut self, token: SignalToken) -> Result<(), SignalToken> {\n+    fn decrement(&self, token: SignalToken) -> Result<(), SignalToken> {\n         assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n         let ptr = unsafe { token.cast_to_usize() };\n         self.to_wake.store(ptr, Ordering::SeqCst);\n \n-        let steals = self.steals;\n-        self.steals = 0;\n+        let steals = unsafe { ptr::replace(self.steals.get(), 0) };\n \n         match self.cnt.fetch_sub(1 + steals, Ordering::SeqCst) {\n             DISCONNECTED => { self.cnt.store(DISCONNECTED, Ordering::SeqCst); }\n@@ -173,7 +174,7 @@ impl<T> Packet<T> {\n         Err(unsafe { SignalToken::cast_from_usize(ptr) })\n     }\n \n-    pub fn recv(&mut self, deadline: Option<Instant>) -> Result<T, Failure<T>> {\n+    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, Failure<T>> {\n         // Optimistic preflight check (scheduling is expensive).\n         match self.try_recv() {\n             Err(Empty) => {}\n@@ -199,16 +200,16 @@ impl<T> Packet<T> {\n             // a steal, so offset the decrement here (we already have our\n             // \"steal\" factored into the channel count above).\n             data @ Ok(..) |\n-            data @ Err(Upgraded(..)) => {\n-                self.steals -= 1;\n+            data @ Err(Upgraded(..)) => unsafe {\n+                *self.steals.get() -= 1;\n                 data\n-            }\n+            },\n \n             data => data,\n         }\n     }\n \n-    pub fn try_recv(&mut self) -> Result<T, Failure<T>> {\n+    pub fn try_recv(&self) -> Result<T, Failure<T>> {\n         match self.queue.pop() {\n             // If we stole some data, record to that effect (this will be\n             // factored into cnt later on).\n@@ -221,26 +222,26 @@ impl<T> Packet<T> {\n             // a pretty slow operation, of swapping 0 into cnt, taking steals\n             // down as much as possible (without going negative), and then\n             // adding back in whatever we couldn't factor into steals.\n-            Some(data) => {\n-                if self.steals > MAX_STEALS {\n+            Some(data) => unsafe {\n+                if *self.steals.get() > MAX_STEALS {\n                     match self.cnt.swap(0, Ordering::SeqCst) {\n                         DISCONNECTED => {\n                             self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n                         }\n                         n => {\n-                            let m = cmp::min(n, self.steals);\n-                            self.steals -= m;\n+                            let m = cmp::min(n, *self.steals.get());\n+                            *self.steals.get() -= m;\n                             self.bump(n - m);\n                         }\n                     }\n-                    assert!(self.steals >= 0);\n+                    assert!(*self.steals.get() >= 0);\n                 }\n-                self.steals += 1;\n+                *self.steals.get() += 1;\n                 match data {\n                     Data(t) => Ok(t),\n                     GoUp(up) => Err(Upgraded(up)),\n                 }\n-            }\n+            },\n \n             None => {\n                 match self.cnt.load(Ordering::SeqCst) {\n@@ -269,7 +270,7 @@ impl<T> Packet<T> {\n         }\n     }\n \n-    pub fn drop_chan(&mut self) {\n+    pub fn drop_chan(&self) {\n         // Dropping a channel is pretty simple, we just flag it as disconnected\n         // and then wakeup a blocker if there is one.\n         match self.cnt.swap(DISCONNECTED, Ordering::SeqCst) {\n@@ -279,7 +280,7 @@ impl<T> Packet<T> {\n         }\n     }\n \n-    pub fn drop_port(&mut self) {\n+    pub fn drop_port(&self) {\n         // Dropping a port seems like a fairly trivial thing. In theory all we\n         // need to do is flag that we're disconnected and then everything else\n         // can take over (we don't have anyone to wake up).\n@@ -309,7 +310,7 @@ impl<T> Packet<T> {\n         // continue to fail while active senders send data while we're dropping\n         // data, but eventually we're guaranteed to break out of this loop\n         // (because there is a bounded number of senders).\n-        let mut steals = self.steals;\n+        let mut steals = unsafe { *self.steals.get() };\n         while {\n             let cnt = self.cnt.compare_and_swap(\n                             steals, DISCONNECTED, Ordering::SeqCst);\n@@ -332,7 +333,7 @@ impl<T> Packet<T> {\n     // Tests to see whether this port can receive without blocking. If Ok is\n     // returned, then that's the answer. If Err is returned, then the returned\n     // port needs to be queried instead (an upgrade happened)\n-    pub fn can_recv(&mut self) -> Result<bool, Receiver<T>> {\n+    pub fn can_recv(&self) -> Result<bool, Receiver<T>> {\n         // We peek at the queue to see if there's anything on it, and we use\n         // this return value to determine if we should pop from the queue and\n         // upgrade this channel immediately. If it looks like we've got an\n@@ -351,7 +352,7 @@ impl<T> Packet<T> {\n     }\n \n     // increment the count on the channel (used for selection)\n-    fn bump(&mut self, amt: isize) -> isize {\n+    fn bump(&self, amt: isize) -> isize {\n         match self.cnt.fetch_add(amt, Ordering::SeqCst) {\n             DISCONNECTED => {\n                 self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n@@ -363,7 +364,7 @@ impl<T> Packet<T> {\n \n     // Attempts to start selecting on this port. Like a oneshot, this can fail\n     // immediately because of an upgrade.\n-    pub fn start_selection(&mut self, token: SignalToken) -> SelectionResult<T> {\n+    pub fn start_selection(&self, token: SignalToken) -> SelectionResult<T> {\n         match self.decrement(token) {\n             Ok(()) => SelSuccess,\n             Err(token) => {\n@@ -387,7 +388,7 @@ impl<T> Packet<T> {\n     }\n \n     // Removes a previous thread from being blocked in this port\n-    pub fn abort_selection(&mut self,\n+    pub fn abort_selection(&self,\n                            was_upgrade: bool) -> Result<bool, Receiver<T>> {\n         // If we're aborting selection after upgrading from a oneshot, then\n         // we're guarantee that no one is waiting. The only way that we could\n@@ -403,7 +404,7 @@ impl<T> Packet<T> {\n         // this end. This is fine because we know it's a small bounded windows\n         // of time until the data is actually sent.\n         if was_upgrade {\n-            assert_eq!(self.steals, 0);\n+            assert_eq!(unsafe { *self.steals.get() }, 0);\n             assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n             return Ok(true)\n         }\n@@ -444,8 +445,10 @@ impl<T> Packet<T> {\n                     thread::yield_now();\n                 }\n             }\n-            assert_eq!(self.steals, 0);\n-            self.steals = steals;\n+            unsafe {\n+                assert_eq!(*self.steals.get(), 0);\n+                *self.steals.get() = steals;\n+            }\n \n             // if we were previously positive, then there's surely data to\n             // receive"}]}