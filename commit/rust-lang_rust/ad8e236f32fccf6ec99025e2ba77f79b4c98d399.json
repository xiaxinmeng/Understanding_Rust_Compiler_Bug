{"sha": "ad8e236f32fccf6ec99025e2ba77f79b4c98d399", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkOGUyMzZmMzJmY2NmNmVjOTkwMjVlMmJhNzdmNzliNGM5OGQzOTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-10T00:50:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-10T00:50:21Z"}, "message": "auto merge of #6336 : nikomatsakis/rust/issue-6308-closure-bounds, r=nikomatsakis\n\nUse a bitset to represent built-in bounds. There are several places in the language where only builtin bounds (aka kinds) will be accepted, e.g. on closures, destructor type parameters perhaps, and on trait types.\r\n\r\nr? @brson", "tree": {"sha": "91801294e31bb049b04d53fafb0314e6fd587542", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91801294e31bb049b04d53fafb0314e6fd587542"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad8e236f32fccf6ec99025e2ba77f79b4c98d399", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad8e236f32fccf6ec99025e2ba77f79b4c98d399", "html_url": "https://github.com/rust-lang/rust/commit/ad8e236f32fccf6ec99025e2ba77f79b4c98d399", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f547a671dcc64530f0cf07f39698d63174f37733", "url": "https://api.github.com/repos/rust-lang/rust/commits/f547a671dcc64530f0cf07f39698d63174f37733", "html_url": "https://github.com/rust-lang/rust/commit/f547a671dcc64530f0cf07f39698d63174f37733"}, {"sha": "78520867b928ba33c557617895dd197c11361cbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/78520867b928ba33c557617895dd197c11361cbd", "html_url": "https://github.com/rust-lang/rust/commit/78520867b928ba33c557617895dd197c11361cbd"}], "stats": {"total": 728, "additions": 515, "deletions": 213}, "files": [{"sha": "c220ae45b1a3febcf2a64915780ca1e511cc8e98", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=ad8e236f32fccf6ec99025e2ba77f79b4c98d399", "patch": "@@ -555,18 +555,34 @@ fn parse_type_param_def(st: @mut PState, conv: conv_did) -> ty::TypeParameterDef\n                           bounds: parse_bounds(st, conv)}\n }\n \n-fn parse_bounds(st: @mut PState, conv: conv_did) -> @~[ty::param_bound] {\n-    let mut bounds = ~[];\n+fn parse_bounds(st: @mut PState, conv: conv_did) -> @ty::ParamBounds {\n+    let mut param_bounds = ty::ParamBounds {\n+        builtin_bounds: ty::EmptyBuiltinBounds(),\n+        trait_bounds: ~[]\n+    };\n     loop {\n-        bounds.push(match next(st) {\n-          'S' => ty::bound_owned,\n-          'C' => ty::bound_copy,\n-          'K' => ty::bound_const,\n-          'O' => ty::bound_durable,\n-          'I' => ty::bound_trait(@parse_trait_ref(st, conv)),\n-          '.' => break,\n-          _ => fail!(~\"parse_bounds: bad bounds\")\n-        });\n+        match next(st) {\n+            'S' => {\n+                param_bounds.builtin_bounds.add(ty::BoundOwned);\n+            }\n+            'C' => {\n+                param_bounds.builtin_bounds.add(ty::BoundCopy);\n+            }\n+            'K' => {\n+                param_bounds.builtin_bounds.add(ty::BoundConst);\n+            }\n+            'O' => {\n+                param_bounds.builtin_bounds.add(ty::BoundStatic);\n+            }\n+            'I' => {\n+                param_bounds.trait_bounds.push(@parse_trait_ref(st, conv));\n+            }\n+            '.' => {\n+                return @param_bounds;\n+            }\n+            _ => {\n+                fail!(~\"parse_bounds: bad bounds\")\n+            }\n+        }\n     }\n-    @bounds\n }"}, {"sha": "86088646bcae3a1e2f09f7f0c1b9ecf071b00a00", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=ad8e236f32fccf6ec99025e2ba77f79b4c98d399", "patch": "@@ -396,19 +396,21 @@ fn enc_fn_sig(w: @io::Writer, cx: @ctxt, fsig: &ty::FnSig) {\n     enc_ty(w, cx, fsig.output);\n }\n \n-fn enc_bounds(w: @io::Writer, cx: @ctxt, bs: @~[ty::param_bound]) {\n-    for (*bs).each |bound| {\n-        match *bound {\n-          ty::bound_owned => w.write_char('S'),\n-          ty::bound_copy => w.write_char('C'),\n-          ty::bound_const => w.write_char('K'),\n-          ty::bound_durable => w.write_char('O'),\n-          ty::bound_trait(tp) => {\n-              w.write_char('I');\n-              enc_trait_ref(w, cx, tp);\n-          }\n+fn enc_bounds(w: @io::Writer, cx: @ctxt, bs: @ty::ParamBounds) {\n+    for bs.builtin_bounds.each |bound| {\n+        match bound {\n+            ty::BoundOwned => w.write_char('S'),\n+            ty::BoundCopy => w.write_char('C'),\n+            ty::BoundConst => w.write_char('K'),\n+            ty::BoundStatic => w.write_char('O'),\n         }\n     }\n+\n+    for bs.trait_bounds.each |&tp| {\n+        w.write_char('I');\n+        enc_trait_ref(w, cx, tp);\n+    }\n+\n     w.write_char('.');\n }\n "}, {"sha": "f8f6dbd82595e8a960282898812d2c356ca76873", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 7, "deletions": 33, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=ad8e236f32fccf6ec99025e2ba77f79b4c98d399", "patch": "@@ -14,6 +14,7 @@ use middle::pat_util;\n use middle::ty;\n use middle::typeck;\n use util::ppaux::{Repr, ty_to_str};\n+use util::ppaux::UserString;\n \n use syntax::ast::*;\n use syntax::attr::attrs_contains_name;\n@@ -338,46 +339,19 @@ pub fn check_bounds(cx: Context,\n                     type_param_def: &ty::TypeParameterDef)\n {\n     let kind = ty::type_contents(cx.tcx, ty);\n-    let mut missing = ~[];\n-    for type_param_def.bounds.each |bound| {\n-        match *bound {\n-            ty::bound_trait(_) => {\n-                /* Not our job, checking in typeck */\n-            }\n-\n-            ty::bound_copy => {\n-                if !kind.is_copy(cx.tcx) {\n-                    missing.push(\"Copy\");\n-                }\n-            }\n-\n-            ty::bound_durable => {\n-                if !kind.is_durable(cx.tcx) {\n-                    missing.push(\"'static\");\n-                }\n-            }\n-\n-            ty::bound_owned => {\n-                if !kind.is_owned(cx.tcx) {\n-                    missing.push(\"Owned\");\n-                }\n-            }\n-\n-            ty::bound_const => {\n-                if !kind.is_const(cx.tcx) {\n-                    missing.push(\"Const\");\n-                }\n-            }\n+    let mut missing = ty::EmptyBuiltinBounds();\n+    for type_param_def.bounds.builtin_bounds.each |bound| {\n+        if !kind.meets_bound(cx.tcx, bound) {\n+            missing.add(bound);\n         }\n     }\n-\n     if !missing.is_empty() {\n         cx.tcx.sess.span_err(\n             sp,\n             fmt!(\"instantiating a type parameter with an incompatible type \\\n                   `%s`, which does not fulfill `%s`\",\n                  ty_to_str(cx.tcx, ty),\n-                 str::connect_slices(missing, \" \")));\n+                 missing.user_string(cx.tcx)));\n     }\n }\n \n@@ -440,7 +414,7 @@ pub fn check_owned(cx: Context, ty: ty::t, sp: span) -> bool {\n \n // note: also used from middle::typeck::regionck!\n pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: span) -> bool {\n-    if !ty::type_is_durable(tcx, ty) {\n+    if !ty::type_is_static(tcx, ty) {\n         match ty::get(ty).sty {\n           ty::ty_param(*) => {\n             tcx.sess.span_err(sp, \"value may contain borrowed \\"}, {"sha": "5c7c33d35b238a86dff19c1ad5b26e26d3cdefa8", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=ad8e236f32fccf6ec99025e2ba77f79b4c98d399", "patch": "@@ -78,9 +78,11 @@ impl<T:Subst> Subst for ~[T] {\n     }\n }\n \n-impl<T:Subst> Subst for @~[T] {\n-    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> @~[T] {\n-        @(**self).subst(tcx, substs)\n+impl<T:Subst> Subst for @T {\n+    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> @T {\n+        match self {\n+            &@ref t => @t.subst(tcx, substs)\n+        }\n     }\n }\n \n@@ -115,19 +117,11 @@ impl Subst for ty::BareFnTy {\n     }\n }\n \n-impl Subst for ty::param_bound {\n-    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::param_bound {\n-        match self {\n-            &ty::bound_copy |\n-            &ty::bound_durable |\n-            &ty::bound_owned |\n-            &ty::bound_const => {\n-                *self\n-            }\n-\n-            &ty::bound_trait(tref) => {\n-                ty::bound_trait(@tref.subst(tcx, substs))\n-            }\n+impl Subst for ty::ParamBounds {\n+    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::ParamBounds {\n+        ty::ParamBounds {\n+            builtin_bounds: self.builtin_bounds,\n+            trait_bounds: self.trait_bounds.subst(tcx, substs)\n         }\n     }\n }"}, {"sha": "905e5ed912c52e4feb03a1261659d72bc1c54e65", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=ad8e236f32fccf6ec99025e2ba77f79b4c98d399", "patch": "@@ -348,14 +348,9 @@ pub fn make_mono_id(ccx: @CrateContext,\n         let mut i = 0;\n         vec::map_zip(*item_ty.generics.type_param_defs, substs, |type_param_def, subst| {\n             let mut v = ~[];\n-            for type_param_def.bounds.each |bound| {\n-                match *bound {\n-                  ty::bound_trait(_) => {\n-                    v.push(meth::vtable_id(ccx, /*bad*/copy vts[i]));\n-                    i += 1;\n-                  }\n-                  _ => ()\n-                }\n+            for type_param_def.bounds.trait_bounds.each |_bound| {\n+                v.push(meth::vtable_id(ccx, /*bad*/copy vts[i]));\n+                i += 1;\n             }\n             (*subst, if !v.is_empty() { Some(v) } else { None })\n         })"}, {"sha": "c31843870e88c9af839aaf31620c3c75a3f943fb", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 61, "deletions": 46, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ad8e236f32fccf6ec99025e2ba77f79b4c98d399", "patch": "@@ -26,6 +26,7 @@ use util::ppaux::{note_and_explain_region, bound_region_to_str};\n use util::ppaux::{trait_store_to_str, ty_to_str, vstore_to_str};\n use util::ppaux::Repr;\n use util::common::{indenter};\n+use util::enum_set::{EnumSet, CLike};\n \n use core;\n use core::ptr::to_unsafe_ptr;\n@@ -58,8 +59,6 @@ pub struct field {\n     mt: mt\n }\n \n-pub type param_bounds = @~[param_bound];\n-\n pub struct method {\n     ident: ast::ident,\n     generics: ty::Generics,\n@@ -655,12 +654,32 @@ pub enum type_err {\n }\n \n #[deriving(Eq, IterBytes)]\n-pub enum param_bound {\n-    bound_copy,\n-    bound_durable,\n-    bound_owned,\n-    bound_const,\n-    bound_trait(@TraitRef),\n+pub struct ParamBounds {\n+    builtin_bounds: BuiltinBounds,\n+    trait_bounds: ~[@TraitRef]\n+}\n+\n+pub type BuiltinBounds = EnumSet<BuiltinBound>;\n+\n+#[deriving(Eq, IterBytes)]\n+pub enum BuiltinBound {\n+    BoundCopy,\n+    BoundStatic,\n+    BoundOwned,\n+    BoundConst,\n+}\n+\n+pub fn EmptyBuiltinBounds() -> BuiltinBounds {\n+    EnumSet::empty()\n+}\n+\n+impl CLike for BuiltinBound {\n+    pub fn to_uint(&self) -> uint {\n+        *self as uint\n+    }\n+    pub fn from_uint(v: uint) -> BuiltinBound {\n+        unsafe { cast::transmute(v) }\n+    }\n }\n \n #[deriving(Eq)]\n@@ -817,7 +836,7 @@ impl to_bytes::IterBytes for RegionVid {\n \n pub struct TypeParameterDef {\n     def_id: ast::def_id,\n-    bounds: param_bounds\n+    bounds: @ParamBounds\n }\n \n /// Information about the type/lifetime parametesr associated with an item.\n@@ -1497,14 +1516,6 @@ pub fn substs_to_str(cx: ctxt, substs: &substs) -> ~str {\n     substs.repr(cx)\n }\n \n-pub fn param_bound_to_str(cx: ctxt, pb: &param_bound) -> ~str {\n-    pb.repr(cx)\n-}\n-\n-pub fn param_bounds_to_str(cx: ctxt, pbs: param_bounds) -> ~str {\n-    pbs.repr(cx)\n-}\n-\n pub fn subst(cx: ctxt,\n              substs: &substs,\n              typ: t)\n@@ -1795,6 +1806,19 @@ pub struct TypeContents {\n }\n \n pub impl TypeContents {\n+    fn meets_bounds(&self, cx: ctxt, bbs: BuiltinBounds) -> bool {\n+        iter::all(|bb| self.meets_bound(cx, bb), |f| bbs.each(f))\n+    }\n+\n+    fn meets_bound(&self, cx: ctxt, bb: BuiltinBound) -> bool {\n+        match bb {\n+            BoundCopy => self.is_copy(cx),\n+            BoundStatic => self.is_static(cx),\n+            BoundConst => self.is_const(cx),\n+            BoundOwned => self.is_owned(cx)\n+        }\n+    }\n+\n     fn intersects(&self, tc: TypeContents) -> bool {\n         (self.bits & tc.bits) != 0\n     }\n@@ -1808,11 +1832,11 @@ pub impl TypeContents {\n             TC_EMPTY_ENUM\n     }\n \n-    fn is_durable(&self, cx: ctxt) -> bool {\n-        !self.intersects(TypeContents::nondurable(cx))\n+    fn is_static(&self, cx: ctxt) -> bool {\n+        !self.intersects(TypeContents::nonstatic(cx))\n     }\n \n-    fn nondurable(_cx: ctxt) -> TypeContents {\n+    fn nonstatic(_cx: ctxt) -> TypeContents {\n         TC_BORROWED_POINTER\n     }\n \n@@ -1917,8 +1941,8 @@ pub fn type_is_copyable(cx: ctxt, t: ty::t) -> bool {\n     type_contents(cx, t).is_copy(cx)\n }\n \n-pub fn type_is_durable(cx: ctxt, t: ty::t) -> bool {\n-    type_contents(cx, t).is_durable(cx)\n+pub fn type_is_static(cx: ctxt, t: ty::t) -> bool {\n+    type_contents(cx, t).is_static(cx)\n }\n \n pub fn type_is_owned(cx: ctxt, t: ty::t) -> bool {\n@@ -2198,19 +2222,19 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         debug!(\"type_param_def_to_contents(%s)\", type_param_def.repr(cx));\n         let _i = indenter();\n \n-        let r = type_param_def.bounds.foldl(TC_ALL, |tc, bound| {\n+        let mut tc = TC_ALL;\n+        for type_param_def.bounds.builtin_bounds.each |bound| {\n             debug!(\"tc = %s, bound = %?\", tc.to_str(), bound);\n-            match *bound {\n-                bound_copy => tc - TypeContents::nonimplicitly_copyable(cx),\n-                bound_durable => tc - TypeContents::nondurable(cx),\n-                bound_owned => tc - TypeContents::nonowned(cx),\n-                bound_const => tc - TypeContents::nonconst(cx),\n-                bound_trait(_) => *tc\n-            }\n-        });\n+            tc = tc - match bound {\n+                BoundCopy => TypeContents::nonimplicitly_copyable(cx),\n+                BoundStatic => TypeContents::nonstatic(cx),\n+                BoundOwned => TypeContents::nonowned(cx),\n+                BoundConst => TypeContents::nonconst(cx),\n+            };\n+        }\n \n-        debug!(\"result = %s\", r.to_str());\n-        return r;\n+        debug!(\"result = %s\", tc.to_str());\n+        return tc;\n     }\n }\n \n@@ -3577,7 +3601,7 @@ pub fn trait_supertraits(cx: ctxt,\n pub fn trait_ref_supertraits(cx: ctxt, trait_ref: &ty::TraitRef) -> ~[@TraitRef] {\n     let supertrait_refs = trait_supertraits(cx, trait_ref.def_id);\n     supertrait_refs.map(\n-        |supertrait_ref| @supertrait_ref.subst(cx, &trait_ref.substs))\n+        |supertrait_ref| supertrait_ref.subst(cx, &trait_ref.substs))\n }\n \n fn lookup_locally_or_in_crate_store<V:Copy>(\n@@ -4261,18 +4285,9 @@ pub fn determine_inherited_purity(parent: (ast::purity, ast::node_id),\n // relation on the supertraits from each bounded trait's constraint\n // list.\n pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n-                                         bounds: param_bounds,\n-                                         f: &fn(&TraitRef) -> bool) {\n-    for bounds.each |bound| {\n-        let bound_trait_ref = match *bound {\n-            ty::bound_trait(bound_t) => bound_t,\n-\n-            ty::bound_copy | ty::bound_owned |\n-            ty::bound_const | ty::bound_durable => {\n-                loop; // skip non-trait bounds\n-            }\n-        };\n-\n+                                        bounds: &ParamBounds,\n+                                        f: &fn(@TraitRef) -> bool) {\n+    for bounds.trait_bounds.each |&bound_trait_ref| {\n         let mut supertrait_set = HashMap::new();\n         let mut trait_refs = ~[];\n         let mut i = 0;"}, {"sha": "1277715982158c0b45abb59295c0c48666150d90", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=ad8e236f32fccf6ec99025e2ba77f79b4c98d399", "patch": "@@ -67,8 +67,7 @@ pub impl VtableContext {\n \n fn has_trait_bounds(type_param_defs: &[ty::TypeParameterDef]) -> bool {\n     type_param_defs.any(\n-        |type_param_def| type_param_def.bounds.any(\n-            |bound| match bound { &ty::bound_trait(*) => true, _ => false }))\n+        |type_param_def| !type_param_def.bounds.trait_bounds.is_empty())\n }\n \n fn lookup_vtables(vcx: &VtableContext,\n@@ -99,7 +98,7 @@ fn lookup_vtables(vcx: &VtableContext,\n \n             // Substitute the values of the type parameters that may\n             // appear in the bound.\n-            let trait_ref = trait_ref.subst(tcx, substs);\n+            let trait_ref = (*trait_ref).subst(tcx, substs);\n \n             debug!(\"after subst: %s\", trait_ref.repr(tcx));\n \n@@ -339,7 +338,8 @@ fn lookup_vtable(vcx: &VtableContext,\n                                    vcx.infcx.trait_ref_to_str(trait_ref),\n                                    vcx.infcx.trait_ref_to_str(of_trait_ref));\n \n-                            let of_trait_ref = of_trait_ref.subst(tcx, &substs);\n+                            let of_trait_ref =\n+                                (*of_trait_ref).subst(tcx, &substs);\n                             relate_trait_refs(\n                                 vcx, location_info,\n                                 &of_trait_ref, trait_ref);\n@@ -458,7 +458,7 @@ fn connect_trait_tps(vcx: &VtableContext,\n \n     // XXX: This should work for multiple traits.\n     let impl_trait_ref = ty::impl_trait_refs(tcx, impl_did)[0];\n-    let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n+    let impl_trait_ref = (*impl_trait_ref).subst(tcx, impl_substs);\n     relate_trait_refs(vcx, location_info, &impl_trait_ref, trait_ref);\n }\n "}, {"sha": "6a83db6baee3c4dbf1dc1388dc910a04a51c97f2", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=ad8e236f32fccf6ec99025e2ba77f79b4c98d399", "patch": "@@ -22,7 +22,7 @@ use metadata::csearch;\n use metadata::cstore::{CStore, iter_crate_data};\n use metadata::decoder::{dl_def, dl_field, dl_impl};\n use middle::resolve::{Impl, MethodInfo};\n-use middle::ty::{ProvidedMethodSource, ProvidedMethodInfo, bound_copy, get};\n+use middle::ty::{ProvidedMethodSource, ProvidedMethodInfo, get};\n use middle::ty::{lookup_item_type, subst};\n use middle::ty::{substs, t, ty_bool, ty_bot, ty_box, ty_enum, ty_err};\n use middle::ty::{ty_estr, ty_evec, ty_float, ty_infer, ty_int, ty_nil};\n@@ -603,34 +603,28 @@ pub impl CoherenceChecker {\n                 // Check to ensure that each parameter binding respected its\n                 // kind bounds.\n                 for [ a, b ].each |result| {\n-                    for vec::each2(result.type_variables, *result.type_param_defs)\n-                            |ty_var, type_param_def| {\n-                        match resolve_type(self.inference_context,\n-                                           *ty_var,\n-                                           resolve_nested_tvar) {\n-                            Ok(resolved_ty) => {\n-                                for type_param_def.bounds.each |bound| {\n-                                    match *bound {\n-                                        bound_copy => {\n-                                            if !ty::type_is_copyable(\n-                                                self.inference_context.tcx,\n-                                                resolved_ty)\n-                                            {\n-                                                might_unify = false;\n-                                                break;\n-                                            }\n-                                        }\n-\n-                                        // XXX: We could be smarter here.\n-                                        // Check to see whether owned, send,\n-                                        // const, trait param bounds could\n-                                        // possibly unify.\n-                                        _ => {}\n+                    for vec::each2(result.type_variables,\n+                                   *result.type_param_defs)\n+                        |ty_var, type_param_def|\n+                    {\n+                        if type_param_def.bounds.builtin_bounds.contains_elem(\n+                            ty::BoundCopy)\n+                        {\n+                            match resolve_type(self.inference_context,\n+                                               *ty_var,\n+                                               resolve_nested_tvar) {\n+                                Ok(resolved_ty) => {\n+                                    if !ty::type_is_copyable(\n+                                        self.inference_context.tcx,\n+                                        resolved_ty)\n+                                    {\n+                                        might_unify = false;\n+                                        break;\n                                     }\n                                 }\n-                            }\n-                            Err(*) => {\n-                                // Conservatively assume it might unify.\n+                                Err(*) => {\n+                                    // Conservatively assume it might unify.\n+                                }\n                             }\n                         }\n                     }"}, {"sha": "6de877620315b165bfc3a7e7df6b9a6f61154a97", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 59, "deletions": 28, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=ad8e236f32fccf6ec99025e2ba77f79b4c98d399", "patch": "@@ -41,8 +41,9 @@ use middle::typeck::infer;\n use middle::typeck::rscope::*;\n use middle::typeck::rscope;\n use middle::typeck::{CrateCtxt, lookup_def_tcx, no_params, write_ty_to_tcx};\n-use util::common::{indenter, pluralize};\n+use util::common::pluralize;\n use util::ppaux;\n+use util::ppaux::UserString;\n \n use syntax::abi::AbiSet;\n use syntax::ast::{RegionTyParamBound, TraitTyParamBound};\n@@ -341,10 +342,13 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n \n         // add in the \"self\" type parameter\n         let self_trait_def = get_trait_def(ccx, local_def(trait_id));\n-        let self_trait_ref = @self_trait_def.trait_ref.subst(tcx, &substs);\n+        let self_trait_ref = self_trait_def.trait_ref.subst(tcx, &substs);\n         new_type_param_defs.push(ty::TypeParameterDef {\n             def_id: dummy_defid,\n-            bounds: @~[ty::bound_trait(self_trait_ref)]\n+            bounds: @ty::ParamBounds {\n+                builtin_bounds: ty::EmptyBuiltinBounds(),\n+                trait_bounds: ~[self_trait_ref]\n+            }\n         });\n \n         // add in the type parameters from the method\n@@ -444,7 +448,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n                            trait_substs: &ty::substs,\n                            self_ty: ty::t) {\n     debug!(\"compare_impl_method()\");\n-    let _indenter = indenter();\n+    let infcx = infer::new_infer_ctxt(tcx);\n \n     let impl_m = &cm.mty;\n \n@@ -507,28 +511,50 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n         return;\n     }\n \n-    // FIXME(#2687)---we should be checking that the bounds of the\n-    // trait imply the bounds of the subtype, but it appears\n-    // we are...not checking this.\n     for trait_m.generics.type_param_defs.eachi |i, trait_param_def| {\n         // For each of the corresponding impl ty param's bounds...\n         let impl_param_def = &impl_m.generics.type_param_defs[i];\n-        // Make sure the bounds lists have the same length\n-        // Would be nice to use the ty param names in the error message,\n-        // but we don't have easy access to them here\n-        if impl_param_def.bounds.len() != trait_param_def.bounds.len() {\n+\n+        // Check that the impl does not require any builtin-bounds\n+        // that the trait does not guarantee:\n+        let extra_bounds =\n+            impl_param_def.bounds.builtin_bounds -\n+            trait_param_def.bounds.builtin_bounds;\n+        if !extra_bounds.is_empty() {\n            tcx.sess.span_err(\n                cm.span,\n                fmt!(\"in method `%s`, \\\n-                     type parameter %u has %u %s, but the same type \\\n-                     parameter in its trait declaration has %u %s\",\n+                     type parameter %u requires `%s`, \\\n+                     which is not required by \\\n+                     the corresponding type parameter \\\n+                     in the trait declaration\",\n                     *tcx.sess.str_of(trait_m.ident),\n-                    i, impl_param_def.bounds.len(),\n-                    pluralize(impl_param_def.bounds.len(), ~\"bound\"),\n-                    trait_param_def.bounds.len(),\n-                    pluralize(trait_param_def.bounds.len(), ~\"bound\")));\n+                    i,\n+                    extra_bounds.user_string(tcx)));\n            return;\n         }\n+\n+        // FIXME(#2687)---we should be checking that the bounds of the\n+        // trait imply the bounds of the subtype, but it appears we\n+        // are...not checking this.\n+        if impl_param_def.bounds.trait_bounds.len() !=\n+            trait_param_def.bounds.trait_bounds.len()\n+        {\n+            tcx.sess.span_err(\n+                cm.span,\n+                fmt!(\"in method `%s`, \\\n+                      type parameter %u has %u trait %s, but the \\\n+                      corresponding type parameter in \\\n+                      the trait declaration has %u trait %s\",\n+                     *tcx.sess.str_of(trait_m.ident),\n+                     i, impl_param_def.bounds.trait_bounds.len(),\n+                     pluralize(impl_param_def.bounds.trait_bounds.len(),\n+                               ~\"bound\"),\n+                     trait_param_def.bounds.trait_bounds.len(),\n+                     pluralize(trait_param_def.bounds.trait_bounds.len(),\n+                               ~\"bound\")));\n+            return;\n+        }\n     }\n \n     // Replace any references to the self region in the self type with\n@@ -619,7 +645,6 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     };\n     debug!(\"trait_fty (post-subst): %s\", trait_fty.repr(tcx));\n \n-    let infcx = infer::new_infer_ctxt(tcx);\n     match infer::mk_subty(infcx, false, cm.span, impl_fty, trait_fty) {\n         result::Ok(()) => {}\n         result::Err(ref terr) => {\n@@ -1152,8 +1177,8 @@ pub fn ty_generics(ccx: &CrateCtxt,\n                 None => {\n                     let param_ty = ty::param_ty {idx: base_index + offset,\n                                                  def_id: local_def(param.id)};\n-                    let bounds = compute_bounds(ccx, rp, generics,\n-                                                param_ty, param.bounds);\n+                    let bounds = @compute_bounds(ccx, rp, generics,\n+                                                 param_ty, param.bounds);\n                     let def = ty::TypeParameterDef {\n                         def_id: local_def(param.id),\n                         bounds: bounds\n@@ -1171,7 +1196,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n         rp: Option<ty::region_variance>,\n         generics: &ast::Generics,\n         param_ty: ty::param_ty,\n-        ast_bounds: @OptVec<ast::TyParamBound>) -> ty::param_bounds\n+        ast_bounds: @OptVec<ast::TyParamBound>) -> ty::ParamBounds\n     {\n         /*!\n          *\n@@ -1182,29 +1207,35 @@ pub fn ty_generics(ccx: &CrateCtxt,\n          * as kinds): Const, Copy, and Send.\n          */\n \n-        @ast_bounds.flat_map_to_vec(|b| {\n+        let mut param_bounds = ty::ParamBounds {\n+            builtin_bounds: ty::EmptyBuiltinBounds(),\n+            trait_bounds: ~[]\n+        };\n+        for ast_bounds.each |b| {\n             match b {\n                 &TraitTyParamBound(b) => {\n                     let li = &ccx.tcx.lang_items;\n                     let ty = ty::mk_param(ccx.tcx, param_ty.idx, param_ty.def_id);\n                     let trait_ref = instantiate_trait_ref(ccx, b, rp, generics, ty);\n                     if trait_ref.def_id == li.owned_trait() {\n-                        ~[ty::bound_owned]\n+                        param_bounds.builtin_bounds.add(ty::BoundOwned);\n                     } else if trait_ref.def_id == li.copy_trait() {\n-                        ~[ty::bound_copy]\n+                        param_bounds.builtin_bounds.add(ty::BoundCopy);\n                     } else if trait_ref.def_id == li.const_trait() {\n-                        ~[ty::bound_const]\n+                        param_bounds.builtin_bounds.add(ty::BoundConst);\n                     } else {\n                         // Must be a user-defined trait\n-                        ~[ty::bound_trait(trait_ref)]\n+                        param_bounds.trait_bounds.push(trait_ref);\n                     }\n                 }\n \n                 &RegionTyParamBound => {\n-                    ~[ty::bound_durable]\n+                    param_bounds.builtin_bounds.add(ty::BoundStatic);\n                 }\n             }\n-        })\n+        }\n+\n+        param_bounds\n     }\n }\n "}, {"sha": "6027a04454180886db6da0e8e60498b023512e5c", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=ad8e236f32fccf6ec99025e2ba77f79b4c98d399", "patch": "@@ -131,6 +131,7 @@ pub mod driver;\n pub mod util {\n     pub mod common;\n     pub mod ppaux;\n+    pub mod enum_set;\n }\n \n pub mod lib {"}, {"sha": "859e743b43bfa983fd1faf384cb73269d8771492", "filename": "src/librustc/util/enum_set.rs", "status": "added", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Flibrustc%2Futil%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Flibrustc%2Futil%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fenum_set.rs?ref=ad8e236f32fccf6ec99025e2ba77f79b4c98d399", "patch": "@@ -0,0 +1,233 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core;\n+\n+#[deriving(Eq, IterBytes)]\n+pub struct EnumSet<E> {\n+    bits: uint\n+}\n+\n+pub trait CLike {\n+    pub fn to_uint(&self) -> uint;\n+    pub fn from_uint(uint) -> Self;\n+}\n+\n+fn bit<E:CLike>(e: E) -> uint {\n+    1 << e.to_uint()\n+}\n+\n+pub impl<E:CLike> EnumSet<E> {\n+    fn empty() -> EnumSet<E> {\n+        EnumSet {bits: 0}\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.bits == 0\n+    }\n+\n+    fn intersects(&self, e: EnumSet<E>) -> bool {\n+        (self.bits & e.bits) != 0\n+    }\n+\n+    fn contains(&self, e: EnumSet<E>) -> bool {\n+        (self.bits & e.bits) == e.bits\n+    }\n+\n+    fn add(&mut self, e: E) {\n+        self.bits |= bit(e);\n+    }\n+\n+    fn contains_elem(&self, e: E) -> bool {\n+        (self.bits & bit(e)) != 0\n+    }\n+\n+    fn each(&self, f: &fn(E) -> bool) {\n+        let mut bits = self.bits;\n+        let mut index = 0;\n+        while bits != 0 {\n+            if (bits & 1) != 0 {\n+                let e = CLike::from_uint(index);\n+                if !f(e) {\n+                    return;\n+                }\n+            }\n+            index += 1;\n+            bits >>= 1;\n+        }\n+    }\n+}\n+\n+impl<E:CLike> core::Sub<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n+    fn sub(&self, e: &EnumSet<E>) -> EnumSet<E> {\n+        EnumSet {bits: self.bits & !e.bits}\n+    }\n+}\n+\n+impl<E:CLike> core::BitOr<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n+    fn bitor(&self, e: &EnumSet<E>) -> EnumSet<E> {\n+        EnumSet {bits: self.bits | e.bits}\n+    }\n+}\n+\n+impl<E:CLike> core::BitAnd<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n+    fn bitand(&self, e: &EnumSet<E>) -> EnumSet<E> {\n+        EnumSet {bits: self.bits & e.bits}\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use core;\n+    use core::iter;\n+    use util::enum_set::*;\n+\n+    #[deriving(Eq)]\n+    enum Foo {\n+        A, B, C\n+    }\n+\n+    impl CLike for Foo {\n+        pub fn to_uint(&self) -> uint {\n+            *self as uint\n+        }\n+\n+        pub fn from_uint(v: uint) -> Foo {\n+            unsafe { cast::transmute(v) }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_empty() {\n+        let e: EnumSet<Foo> = EnumSet::empty();\n+        assert!(e.is_empty());\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // intersect\n+\n+    #[test]\n+    fn test_two_empties_do_not_intersect() {\n+        let e1: EnumSet<Foo> = EnumSet::empty();\n+        let e2: EnumSet<Foo> = EnumSet::empty();\n+        assert!(!e1.intersects(e2));\n+    }\n+\n+    #[test]\n+    fn test_empty_does_not_intersect_with_full() {\n+        let e1: EnumSet<Foo> = EnumSet::empty();\n+\n+        let mut e2: EnumSet<Foo> = EnumSet::empty();\n+        e2.add(A);\n+        e2.add(B);\n+        e2.add(C);\n+\n+        assert!(!e1.intersects(e2));\n+    }\n+\n+    #[test]\n+    fn test_disjoint_intersects() {\n+        let mut e1: EnumSet<Foo> = EnumSet::empty();\n+        e1.add(A);\n+\n+        let mut e2: EnumSet<Foo> = EnumSet::empty();\n+        e2.add(B);\n+\n+        assert!(!e1.intersects(e2));\n+    }\n+\n+    #[test]\n+    fn test_overlapping_intersects() {\n+        let mut e1: EnumSet<Foo> = EnumSet::empty();\n+        e1.add(A);\n+\n+        let mut e2: EnumSet<Foo> = EnumSet::empty();\n+        e2.add(A);\n+        e2.add(B);\n+\n+        assert!(e1.intersects(e2));\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // contains and contains_elem\n+\n+    #[test]\n+    fn test_contains() {\n+        let mut e1: EnumSet<Foo> = EnumSet::empty();\n+        e1.add(A);\n+\n+        let mut e2: EnumSet<Foo> = EnumSet::empty();\n+        e2.add(A);\n+        e2.add(B);\n+\n+        assert!(!e1.contains(e2));\n+        assert!(e2.contains(e1));\n+    }\n+\n+    #[test]\n+    fn test_contains_elem() {\n+        let mut e1: EnumSet<Foo> = EnumSet::empty();\n+        e1.add(A);\n+        assert!(e1.contains_elem(A));\n+        assert!(!e1.contains_elem(B));\n+        assert!(!e1.contains_elem(C));\n+\n+        e1.add(A);\n+        e1.add(B);\n+        assert!(e1.contains_elem(A));\n+        assert!(e1.contains_elem(B));\n+        assert!(!e1.contains_elem(C));\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // each\n+\n+    #[test]\n+    fn test_each() {\n+        let mut e1: EnumSet<Foo> = EnumSet::empty();\n+\n+        assert_eq!(~[], iter::to_vec(|f| e1.each(f)))\n+\n+        e1.add(A);\n+        assert_eq!(~[A], iter::to_vec(|f| e1.each(f)))\n+\n+        e1.add(C);\n+        assert_eq!(~[A,C], iter::to_vec(|f| e1.each(f)))\n+\n+        e1.add(C);\n+        assert_eq!(~[A,C], iter::to_vec(|f| e1.each(f)))\n+\n+        e1.add(B);\n+        assert_eq!(~[A,B,C], iter::to_vec(|f| e1.each(f)))\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // operators\n+\n+    #[test]\n+    fn test_operators() {\n+        let mut e1: EnumSet<Foo> = EnumSet::empty();\n+        e1.add(A);\n+        e1.add(C);\n+\n+        let mut e2: EnumSet<Foo> = EnumSet::empty();\n+        e2.add(B);\n+        e2.add(C);\n+\n+        let e_union = e1 | e2;\n+        assert_eq!(~[A,B,C], iter::to_vec(|f| e_union.each(f)))\n+\n+        let e_intersection = e1 & e2;\n+        assert_eq!(~[C], iter::to_vec(|f| e_intersection.each(f)))\n+\n+        let e_subtract = e1 - e2;\n+        assert_eq!(~[A], iter::to_vec(|f| e_subtract.each(f)))\n+    }\n+}"}, {"sha": "804b23025f09e9aa2bf673dbec80d1c55ae943a5", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 71, "deletions": 21, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=ad8e236f32fccf6ec99025e2ba77f79b4c98d399", "patch": "@@ -12,7 +12,7 @@ use metadata::encoder;\n use middle::ty::{ReSkolemized, ReVar};\n use middle::ty::{bound_region, br_anon, br_named, br_self, br_cap_avoid};\n use middle::ty::{br_fresh, ctxt, field, method};\n-use middle::ty::{mt, t, param_bound, param_ty};\n+use middle::ty::{mt, t, param_ty};\n use middle::ty::{re_bound, re_free, re_scope, re_infer, re_static, Region,\n                  re_empty};\n use middle::ty::{ty_bool, ty_bot, ty_box, ty_struct, ty_enum};\n@@ -29,10 +29,16 @@ use syntax::codemap::span;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n \n+/// Produces a string suitable for debugging output.\n pub trait Repr {\n     fn repr(&self, tcx: ctxt) -> ~str;\n }\n \n+/// Produces a string suitable for showing to the user.\n+pub trait UserString {\n+    fn user_string(&self, tcx: ctxt) -> ~str;\n+}\n+\n pub fn note_and_explain_region(cx: ctxt,\n                                prefix: &str,\n                                region: ty::Region,\n@@ -273,26 +279,14 @@ pub fn tys_to_str(cx: ctxt, ts: &[t]) -> ~str {\n     fmt!(\"(%s)\", str::connect(tstrs, \", \"))\n }\n \n-pub fn bound_to_str(cx: ctxt, b: param_bound) -> ~str {\n-    ty::param_bound_to_str(cx, &b)\n-}\n-\n pub fn fn_sig_to_str(cx: ctxt, typ: &ty::FnSig) -> ~str {\n     fmt!(\"fn%s -> %s\",\n          tys_to_str(cx, typ.inputs.map(|a| a.ty)),\n          ty_to_str(cx, typ.output))\n }\n \n pub fn trait_ref_to_str(cx: ctxt, trait_ref: &ty::TraitRef) -> ~str {\n-    let path = ty::item_path(cx, trait_ref.def_id);\n-    let base = ast_map::path_to_str(path, cx.sess.intr());\n-    if cx.sess.verbose() && trait_ref.substs.self_ty.is_some() {\n-        let mut all_tps = copy trait_ref.substs.tps;\n-        for trait_ref.substs.self_ty.each |&t| { all_tps.push(t); }\n-        parameterized(cx, base, trait_ref.substs.self_r, all_tps)\n-    } else {\n-        parameterized(cx, base, trait_ref.substs.self_r, trait_ref.substs.tps)\n-    }\n+    trait_ref.user_string(cx)\n }\n \n pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n@@ -555,15 +549,21 @@ impl Repr for ty::substs {\n     }\n }\n \n-impl Repr for ty::param_bound {\n+impl Repr for ty::ParamBounds {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        match *self {\n-            ty::bound_copy => ~\"copy\",\n-            ty::bound_durable => ~\"'static\",\n-            ty::bound_owned => ~\"owned\",\n-            ty::bound_const => ~\"const\",\n-            ty::bound_trait(ref t) => t.repr(tcx)\n+        let mut res = ~[];\n+        for self.builtin_bounds.each |b| {\n+            res.push(match b {\n+                ty::BoundCopy => ~\"Copy\",\n+                ty::BoundStatic => ~\"'static\",\n+                ty::BoundOwned => ~\"Owned\",\n+                ty::BoundConst => ~\"Const\",\n+            });\n+        }\n+        for self.trait_bounds.each |t| {\n+            res.push(t.repr(tcx));\n         }\n+        str::connect(res, \"+\")\n     }\n }\n \n@@ -755,3 +755,53 @@ impl Repr for ast_map::path_elt {\n         }\n     }\n }\n+\n+impl Repr for ty::BuiltinBound {\n+    fn repr(&self, _tcx: ctxt) -> ~str {\n+        fmt!(\"%?\", *self)\n+    }\n+}\n+\n+impl UserString for ty::BuiltinBound {\n+    fn user_string(&self, _tcx: ctxt) -> ~str {\n+        match *self {\n+            ty::BoundCopy => ~\"Copy\",\n+            ty::BoundStatic => ~\"'static\",\n+            ty::BoundOwned => ~\"Owned\",\n+            ty::BoundConst => ~\"Const\"\n+        }\n+    }\n+}\n+\n+impl Repr for ty::BuiltinBounds {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        self.user_string(tcx)\n+    }\n+}\n+\n+impl UserString for ty::BuiltinBounds {\n+    fn user_string(&self, tcx: ctxt) -> ~str {\n+        if self.is_empty() { ~\"<no-bounds>\" } else {\n+            let mut result = ~[];\n+            for self.each |bb| {\n+                result.push(bb.user_string(tcx));\n+            }\n+            str::connect(result, \"+\")\n+        }\n+    }\n+}\n+\n+impl UserString for ty::TraitRef {\n+    fn user_string(&self, tcx: ctxt) -> ~str {\n+        let path = ty::item_path(tcx, self.def_id);\n+        let base = ast_map::path_to_str(path, tcx.sess.intr());\n+        if tcx.sess.verbose() && self.substs.self_ty.is_some() {\n+            let mut all_tps = copy self.substs.tps;\n+            for self.substs.self_ty.each |&t| { all_tps.push(t); }\n+            parameterized(tcx, base, self.substs.self_r, all_tps)\n+        } else {\n+            parameterized(tcx, base, self.substs.self_r,\n+                          self.substs.tps)\n+        }\n+    }\n+}"}, {"sha": "2385be5723e2a700d2ae901302fa21e047e39023", "filename": "src/test/compile-fail/issue-2611-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs?ref=ad8e236f32fccf6ec99025e2ba77f79b4c98d399", "patch": "@@ -20,7 +20,7 @@ struct E {\n }\n \n impl A for E {\n-  fn b<F:Copy + Const,G>(_x: F) -> F { fail!() } //~ ERROR in method `b`, type parameter 0 has 2 bounds, but\n+  fn b<F:Copy + Const,G>(_x: F) -> F { fail!() } //~ ERROR type parameter 0 requires `Const`\n }\n \n fn main() {}"}, {"sha": "acc6ffd0dd1b3cf9716a67dd6d8fb2f59c669a49", "filename": "src/test/run-pass/issue-2611-3.rs", "status": "renamed", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Ftest%2Frun-pass%2Fissue-2611-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e236f32fccf6ec99025e2ba77f79b4c98d399/src%2Ftest%2Frun-pass%2Fissue-2611-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2611-3.rs?ref=ad8e236f32fccf6ec99025e2ba77f79b4c98d399", "patch": "@@ -8,11 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Tests that impl methods are matched to traits exactly:\n-// we might be tempted to think matching is contravariant, but if\n-// we let an impl method can have more permissive bounds than the trait\n-// method it's implementing, the return type might be less specific than\n-// needed. Just punt and make it invariant.\n+// Tests that impls are allowed to have looser, more permissive bounds\n+// than the traits require.\n \n trait A {\n   fn b<C:Copy + Const,D>(x: C) -> C;", "previous_filename": "src/test/compile-fail/issue-2611-3.rs"}]}