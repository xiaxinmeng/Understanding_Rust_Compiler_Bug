{"sha": "0169dc3f36aec63e5926f2d69e788a396fd10f82", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxNjlkYzNmMzZhZWM2M2U1OTI2ZjJkNjllNzg4YTM5NmZkMTBmODI=", "commit": {"author": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-11-09T13:49:37Z"}, "committer": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-11-29T20:57:40Z"}, "message": "Implement `ResolventOps`", "tree": {"sha": "fb68558b06e5c6a17c11b1f1bc310c2f5dabb8da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb68558b06e5c6a17c11b1f1bc310c2f5dabb8da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0169dc3f36aec63e5926f2d69e788a396fd10f82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0169dc3f36aec63e5926f2d69e788a396fd10f82", "html_url": "https://github.com/rust-lang/rust/commit/0169dc3f36aec63e5926f2d69e788a396fd10f82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0169dc3f36aec63e5926f2d69e788a396fd10f82/comments", "author": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b2cfc510b523f62b66c7106f04153f7625c8936", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b2cfc510b523f62b66c7106f04153f7625c8936", "html_url": "https://github.com/rust-lang/rust/commit/3b2cfc510b523f62b66c7106f04153f7625c8936"}], "stats": {"total": 607, "additions": 572, "deletions": 35}, "files": [{"sha": "5b9193ad74ac33aeb5f5c02f90caf1c809c2358f", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0169dc3f36aec63e5926f2d69e788a396fd10f82/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169dc3f36aec63e5926f2d69e788a396fd10f82/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=0169dc3f36aec63e5926f2d69e788a396fd10f82", "patch": "@@ -679,24 +679,31 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n // vars. See comment on `shift_vars_through_binders` method in\n // `subst.rs` for more details.\n \n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+enum Direction {\n+    In,\n+    Out,\n+}\n+\n struct Shifter<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-\n     current_index: ty::DebruijnIndex,\n     amount: u32,\n+    direction: Direction,\n }\n \n impl Shifter<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, amount: u32) -> Self {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, amount: u32, direction: Direction) -> Self {\n         Shifter {\n             tcx,\n             current_index: ty::INNERMOST,\n             amount,\n+            direction,\n         }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Shifter<'a, 'gcx, 'tcx> {\n+impl TypeFolder<'gcx, 'tcx> for Shifter<'a, 'gcx, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n@@ -712,7 +719,14 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Shifter<'a, 'gcx, 'tcx> {\n                 if self.amount == 0 || debruijn < self.current_index {\n                     r\n                 } else {\n-                    let shifted = ty::ReLateBound(debruijn.shifted_in(self.amount), br);\n+                    let debruijn = match self.direction {\n+                        Direction::In => debruijn.shifted_in(self.amount),\n+                        Direction::Out => {\n+                            assert!(debruijn.as_u32() >= self.amount);\n+                            debruijn.shifted_out(self.amount)\n+                        }\n+                    };\n+                    let shifted = ty::ReLateBound(debruijn, br);\n                     self.tcx.mk_region(shifted)\n                 }\n             }\n@@ -726,8 +740,15 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Shifter<'a, 'gcx, 'tcx> {\n                 if self.amount == 0 || debruijn < self.current_index {\n                     ty\n                 } else {\n+                    let debruijn = match self.direction {\n+                        Direction::In => debruijn.shifted_in(self.amount),\n+                        Direction::Out => {\n+                            assert!(debruijn.as_u32() >= self.amount);\n+                            debruijn.shifted_out(self.amount)\n+                        }\n+                    };\n                     self.tcx.mk_ty(\n-                        ty::Bound(debruijn.shifted_in(self.amount), bound_ty)\n+                        ty::Bound(debruijn, bound_ty)\n                     )\n                 }\n             }\n@@ -760,7 +781,18 @@ pub fn shift_vars<'a, 'gcx, 'tcx, T>(\n     debug!(\"shift_vars(value={:?}, amount={})\",\n            value, amount);\n \n-    value.fold_with(&mut Shifter::new(tcx, amount))\n+    value.fold_with(&mut Shifter::new(tcx, amount, Direction::In))\n+}\n+\n+pub fn shift_out_vars<'a, 'gcx, 'tcx, T>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    value: &T,\n+    amount: u32\n+) -> T where T: TypeFoldable<'tcx> {\n+    debug!(\"shift_out_vars(value={:?}, amount={})\",\n+           value, amount);\n+\n+    value.fold_with(&mut Shifter::new(tcx, amount, Direction::Out))\n }\n \n /// An \"escaping var\" is a bound var whose binder is not part of `t`. A bound var can be a"}, {"sha": "1b64a686794c0a4de2da60fb605b61fc0a3be18c", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/0169dc3f36aec63e5926f2d69e788a396fd10f82/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169dc3f36aec63e5926f2d69e788a396fd10f82/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=0169dc3f36aec63e5926f2d69e788a396fd10f82", "patch": "@@ -25,6 +25,7 @@ use std::rc::Rc;\n use std::iter;\n use rustc_target::spec::abi;\n use hir as ast;\n+use traits;\n \n pub type RelateResult<'tcx, T> = Result<T, TypeError<'tcx>>;\n \n@@ -723,6 +724,283 @@ impl<'tcx> Relate<'tcx> for Kind<'tcx> {\n     }\n }\n \n+impl<'tcx> Relate<'tcx> for ty::TraitPredicate<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::TraitPredicate<'tcx>,\n+        b: &ty::TraitPredicate<'tcx>\n+    ) -> RelateResult<'tcx, ty::TraitPredicate<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        Ok(ty::TraitPredicate {\n+            trait_ref: relation.relate(&a.trait_ref, &b.trait_ref)?,\n+        })\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for ty::ProjectionPredicate<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::ProjectionPredicate<'tcx>,\n+        b: &ty::ProjectionPredicate<'tcx>,\n+    ) -> RelateResult<'tcx, ty::ProjectionPredicate<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        Ok(ty::ProjectionPredicate {\n+            projection_ty: relation.relate(&a.projection_ty, &b.projection_ty)?,\n+            ty: relation.relate(&a.ty, &b.ty)?,\n+        })\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::WhereClause<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::WhereClause<'tcx>,\n+        b: &traits::WhereClause<'tcx>\n+    ) -> RelateResult<'tcx, traits::WhereClause<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        use traits::WhereClause::*;\n+        match (a, b) {\n+            (Implemented(a_pred), Implemented(b_pred)) => {\n+                Ok(Implemented(relation.relate(a_pred, b_pred)?))\n+            }\n+\n+            (ProjectionEq(a_pred), ProjectionEq(b_pred)) => {\n+                Ok(ProjectionEq(relation.relate(a_pred, b_pred)?))\n+            }\n+\n+            (RegionOutlives(a_pred), RegionOutlives(b_pred)) => {\n+                Ok(RegionOutlives(ty::OutlivesPredicate(\n+                    relation.relate(&a_pred.0, &b_pred.0)?,\n+                    relation.relate(&a_pred.1, &b_pred.1)?,\n+                )))\n+            }\n+\n+            (TypeOutlives(a_pred), TypeOutlives(b_pred)) => {\n+                Ok(TypeOutlives(ty::OutlivesPredicate(\n+                    relation.relate(&a_pred.0, &b_pred.0)?,\n+                    relation.relate(&a_pred.1, &b_pred.1)?,\n+                )))\n+            }\n+\n+            _ =>  Err(TypeError::Mismatch),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::WellFormed<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::WellFormed<'tcx>,\n+        b: &traits::WellFormed<'tcx>\n+    ) -> RelateResult<'tcx, traits::WellFormed<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        use traits::WellFormed::*;\n+        match (a, b) {\n+            (Trait(a_pred), Trait(b_pred)) => Ok(Trait(relation.relate(a_pred, b_pred)?)),\n+            (Ty(a_ty), Ty(b_ty)) => Ok(Ty(relation.relate(a_ty, b_ty)?)),\n+            _ =>  Err(TypeError::Mismatch),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::FromEnv<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::FromEnv<'tcx>,\n+        b: &traits::FromEnv<'tcx>\n+    ) -> RelateResult<'tcx, traits::FromEnv<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        use traits::FromEnv::*;\n+        match (a, b) {\n+            (Trait(a_pred), Trait(b_pred)) => Ok(Trait(relation.relate(a_pred, b_pred)?)),\n+            (Ty(a_ty), Ty(b_ty)) => Ok(Ty(relation.relate(a_ty, b_ty)?)),\n+            _ =>  Err(TypeError::Mismatch),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::DomainGoal<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::DomainGoal<'tcx>,\n+        b: &traits::DomainGoal<'tcx>\n+    ) -> RelateResult<'tcx, traits::DomainGoal<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        use traits::DomainGoal::*;\n+        match (a, b) {\n+            (Holds(a_wc), Holds(b_wc)) => Ok(Holds(relation.relate(a_wc, b_wc)?)),\n+            (WellFormed(a_wf), WellFormed(b_wf)) => Ok(WellFormed(relation.relate(a_wf, b_wf)?)),\n+            (FromEnv(a_fe), FromEnv(b_fe)) => Ok(FromEnv(relation.relate(a_fe, b_fe)?)),\n+\n+            (Normalize(a_pred), Normalize(b_pred)) => {\n+                Ok(Normalize(relation.relate(a_pred, b_pred)?))\n+            }\n+\n+            _ =>  Err(TypeError::Mismatch),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::Goal<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::Goal<'tcx>,\n+        b: &traits::Goal<'tcx>\n+    ) -> RelateResult<'tcx, traits::Goal<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        use traits::GoalKind::*;\n+        match (a, b) {\n+            (Implies(a_clauses, a_goal), Implies(b_clauses, b_goal)) => {\n+                let clauses = relation.relate(a_clauses, b_clauses)?;\n+                let goal = relation.relate(a_goal, b_goal)?;\n+                Ok(relation.tcx().mk_goal(Implies(clauses, goal)))\n+            }\n+\n+            (And(a_left, a_right), And(b_left, b_right)) => {\n+                let left = relation.relate(a_left, b_left)?;\n+                let right = relation.relate(a_right, b_right)?;\n+                Ok(relation.tcx().mk_goal(And(left, right)))\n+            }\n+\n+            (Not(a_goal), Not(b_goal)) => {\n+                let goal = relation.relate(a_goal, b_goal)?;\n+                Ok(relation.tcx().mk_goal(Not(goal)))\n+            }\n+\n+            (DomainGoal(a_goal), DomainGoal(b_goal)) => {\n+                let goal = relation.relate(a_goal, b_goal)?;\n+                Ok(relation.tcx().mk_goal(DomainGoal(goal)))\n+            }\n+\n+            (Quantified(a_qkind, a_goal), Quantified(b_qkind, b_goal))\n+                if a_qkind == b_qkind =>\n+            {\n+                let goal = relation.relate(a_goal, b_goal)?;\n+                Ok(relation.tcx().mk_goal(Quantified(*a_qkind, goal)))\n+            }\n+\n+            (CannotProve, CannotProve) => Ok(*a),\n+\n+            _ => Err(TypeError::Mismatch),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::Goals<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::Goals<'tcx>,\n+        b: &traits::Goals<'tcx>\n+    ) -> RelateResult<'tcx, traits::Goals<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        if a.len() != b.len() {\n+            return Err(TypeError::Mismatch);\n+        }\n+\n+        let tcx = relation.tcx();\n+        let goals = a.iter().zip(b.iter()).map(|(a, b)| relation.relate(a, b));\n+        Ok(tcx.mk_goals(goals)?)\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::Clause<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::Clause<'tcx>,\n+        b: &traits::Clause<'tcx>\n+    ) -> RelateResult<'tcx, traits::Clause<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        use traits::Clause::*;\n+        match (a, b) {\n+            (Implies(a_clause), Implies(b_clause)) => {\n+                let clause = relation.relate(a_clause, b_clause)?;\n+                Ok(Implies(clause))\n+            }\n+\n+            (ForAll(a_clause), ForAll(b_clause)) => {\n+                let clause = relation.relate(a_clause, b_clause)?;\n+                Ok(ForAll(clause))\n+            }\n+\n+            _ => Err(TypeError::Mismatch),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::Clauses<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::Clauses<'tcx>,\n+        b: &traits::Clauses<'tcx>\n+    ) -> RelateResult<'tcx, traits::Clauses<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        if a.len() != b.len() {\n+            return Err(TypeError::Mismatch);\n+        }\n+\n+        let tcx = relation.tcx();\n+        let clauses = a.iter().zip(b.iter()).map(|(a, b)| relation.relate(a, b));\n+        Ok(tcx.mk_clauses(clauses)?)\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::ProgramClause<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::ProgramClause<'tcx>,\n+        b: &traits::ProgramClause<'tcx>\n+    ) -> RelateResult<'tcx, traits::ProgramClause<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        Ok(traits::ProgramClause {\n+            goal: relation.relate(&a.goal, &b.goal)?,\n+            hypotheses: relation.relate(&a.hypotheses, &b.hypotheses)?,\n+            category: traits::ProgramClauseCategory::Other,\n+        })\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for traits::Environment<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::Environment<'tcx>,\n+        b: &traits::Environment<'tcx>\n+    ) -> RelateResult<'tcx, traits::Environment<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        Ok(traits::Environment {\n+            clauses: relation.relate(&a.clauses, &b.clauses)?,\n+        })\n+    }\n+}\n+\n+impl<'tcx, G> Relate<'tcx> for traits::InEnvironment<'tcx, G>\n+    where G: Relate<'tcx>\n+{\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &traits::InEnvironment<'tcx, G>,\n+        b: &traits::InEnvironment<'tcx, G>\n+    ) -> RelateResult<'tcx, traits::InEnvironment<'tcx, G>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    {\n+        Ok(traits::InEnvironment {\n+            environment: relation.relate(&a.environment, &b.environment)?,\n+            goal: relation.relate(&a.goal, &b.goal)?,\n+        })\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Error handling\n "}, {"sha": "bc3f2fd951b931f61333b86f1cbf56e1842e1248", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0169dc3f36aec63e5926f2d69e788a396fd10f82/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169dc3f36aec63e5926f2d69e788a396fd10f82/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=0169dc3f36aec63e5926f2d69e788a396fd10f82", "patch": "@@ -9,14 +9,24 @@\n // except according to those terms.\n \n mod program_clauses;\n+mod resolvent_ops;\n mod unify;\n \n use chalk_engine::fallible::{Fallible, NoSolution};\n-use chalk_engine::{context, hh::HhGoal, DelayedLiteral, Literal, ExClause};\n-use rustc::infer::canonical::{\n-    Canonical, CanonicalVarValues, OriginalQueryValues, QueryResponse,\n+use chalk_engine::{\n+    context,\n+    hh::HhGoal,\n+    DelayedLiteral,\n+    Literal,\n+    ExClause\n };\n use rustc::infer::{InferCtxt, LateBoundRegionConversionTime};\n+use rustc::infer::canonical::{\n+    Canonical,\n+    CanonicalVarValues,\n+    OriginalQueryValues,\n+    QueryResponse,\n+};\n use rustc::traits::{\n     DomainGoal,\n     ExClauseFold,\n@@ -28,9 +38,9 @@ use rustc::traits::{\n     Environment,\n     InEnvironment,\n };\n+use rustc::ty::{self, TyCtxt};\n use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc::ty::subst::{Kind, UnpackedKind};\n-use rustc::ty::{self, TyCtxt};\n use syntax_pos::DUMMY_SP;\n \n use std::fmt::{self, Debug};\n@@ -201,7 +211,7 @@ impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n \n     fn is_trivial_substitution(\n         u_canon: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n-        canonical_subst: &Canonical<'tcx, ConstrainedSubst<'tcx>>,\n+        canonical_subst: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n     ) -> bool {\n         let subst = &canonical_subst.value.subst;\n         assert_eq!(u_canon.variables.len(), subst.var_values.len());\n@@ -286,30 +296,6 @@ impl context::InferenceTable<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n     }\n }\n \n-impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n-    for ChalkInferenceContext<'cx, 'gcx, 'tcx>\n-{\n-    fn resolvent_clause(\n-        &mut self,\n-        _environment: &Environment<'tcx>,\n-        _goal: &DomainGoal<'tcx>,\n-        _subst: &CanonicalVarValues<'tcx>,\n-        _clause: &Clause<'tcx>,\n-    ) -> Fallible<Canonical<'gcx, ChalkExClause<'gcx>>> {\n-        panic!()\n-    }\n-\n-    fn apply_answer_subst(\n-        &mut self,\n-        _ex_clause: ChalkExClause<'tcx>,\n-        _selected_goal: &InEnvironment<'tcx, Goal<'tcx>>,\n-        _answer_table_goal: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n-        _canonical_answer_subst: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n-    ) -> Fallible<ChalkExClause<'tcx>> {\n-        panic!()\n-    }\n-}\n-\n impl context::TruncateOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n     for ChalkInferenceContext<'cx, 'gcx, 'tcx>\n {"}, {"sha": "df6458a766d4e89f128697551a741469333627a0", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/0169dc3f36aec63e5926f2d69e788a396fd10f82/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0169dc3f36aec63e5926f2d69e788a396fd10f82/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=0169dc3f36aec63e5926f2d69e788a396fd10f82", "patch": "@@ -0,0 +1,241 @@\n+use chalk_engine::fallible::{Fallible, NoSolution};\n+use chalk_engine::{\n+    context,\n+    Literal,\n+    ExClause\n+};\n+use rustc::infer::{InferCtxt, LateBoundRegionConversionTime};\n+use rustc::infer::canonical::{Canonical, CanonicalVarValues};\n+use rustc::traits::{\n+    DomainGoal,\n+    Goal,\n+    GoalKind,\n+    Clause,\n+    ProgramClause,\n+    Environment,\n+    InEnvironment,\n+};\n+use rustc::ty::{self, Ty};\n+use rustc::ty::subst::Kind;\n+use rustc::ty::relate::{Relate, RelateResult, TypeRelation};\n+use syntax_pos::DUMMY_SP;\n+\n+use super::{ChalkInferenceContext, ChalkArenas, ChalkExClause, ConstrainedSubst};\n+use super::unify::*;\n+\n+impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n+    for ChalkInferenceContext<'cx, 'gcx, 'tcx>\n+{\n+    fn resolvent_clause(\n+        &mut self,\n+        environment: &Environment<'tcx>,\n+        goal: &DomainGoal<'tcx>,\n+        subst: &CanonicalVarValues<'tcx>,\n+        clause: &Clause<'tcx>,\n+    ) -> Fallible<Canonical<'gcx, ChalkExClause<'gcx>>> {\n+        use chalk_engine::context::UnificationOps;\n+\n+        self.infcx.probe(|_| {\n+            let ProgramClause {\n+                goal: consequence,\n+                hypotheses,\n+                ..\n+            } = match clause {\n+                Clause::Implies(program_clause) => *program_clause,\n+                Clause::ForAll(program_clause) => self.infcx.replace_bound_vars_with_fresh_vars(\n+                    DUMMY_SP,\n+                    LateBoundRegionConversionTime::HigherRankedType,\n+                    program_clause\n+                ).0,\n+            };\n+\n+            let result = unify(self.infcx, *environment, goal, &consequence)\n+                .map_err(|_| NoSolution)?;\n+\n+            let mut ex_clause = ExClause {\n+                subst: subst.clone(),\n+                delayed_literals: vec![],\n+                constraints: vec![],\n+                subgoals: vec![],\n+            };\n+\n+            self.into_ex_clause(result, &mut ex_clause);\n+\n+            ex_clause.subgoals.extend(\n+                hypotheses.iter().map(|g| match g {\n+                    GoalKind::Not(g) => Literal::Negative(environment.with(*g)),\n+                    g => Literal::Positive(environment.with(*g)),\n+                })\n+            );\n+\n+            let canonical_ex_clause = self.canonicalize_ex_clause(&ex_clause);\n+            Ok(canonical_ex_clause)\n+        })\n+    }\n+\n+    fn apply_answer_subst(\n+        &mut self,\n+        ex_clause: ChalkExClause<'tcx>,\n+        selected_goal: &InEnvironment<'tcx, Goal<'tcx>>,\n+        answer_table_goal: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n+        canonical_answer_subst: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n+    ) -> Fallible<ChalkExClause<'tcx>> {\n+        let (answer_subst, _) = self.infcx.instantiate_canonical_with_fresh_inference_vars(\n+            DUMMY_SP,\n+            canonical_answer_subst\n+        );\n+\n+        let mut substitutor = AnswerSubstitutor {\n+            infcx: self.infcx,\n+            environment: selected_goal.environment,\n+            answer_subst: answer_subst.subst,\n+            binder_index: ty::INNERMOST,\n+            ex_clause,\n+        };\n+\n+        substitutor.relate(&answer_table_goal.value, &selected_goal)\n+            .map_err(|_| NoSolution)?;\n+\n+        let mut ex_clause = substitutor.ex_clause;\n+        ex_clause.constraints.extend(answer_subst.constraints);\n+        Ok(ex_clause)\n+    }\n+}\n+\n+struct AnswerSubstitutor<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+    environment: Environment<'tcx>,\n+    answer_subst: CanonicalVarValues<'tcx>,\n+    binder_index: ty::DebruijnIndex,\n+    ex_clause: ChalkExClause<'tcx>,\n+}\n+\n+impl AnswerSubstitutor<'cx, 'gcx, 'tcx> {\n+    fn unify_free_answer_var(\n+        &mut self,\n+        answer_var: ty::BoundVar,\n+        pending: Kind<'tcx>\n+    ) -> RelateResult<'tcx, ()> {\n+        let answer_param = &self.answer_subst.var_values[answer_var];\n+        let pending = &ty::fold::shift_out_vars(\n+            self.infcx.tcx,\n+            &pending,\n+            self.binder_index.as_u32()\n+        );\n+\n+        super::into_ex_clause(\n+            unify(self.infcx, self.environment, answer_param, pending)?,\n+            &mut self.ex_clause\n+        );\n+\n+        Ok(())\n+    }\n+}\n+\n+impl TypeRelation<'cx, 'gcx, 'tcx> for AnswerSubstitutor<'cx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> ty::TyCtxt<'cx, 'gcx, 'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn tag(&self) -> &'static str {\n+        \"chalk_context::answer_substitutor\"\n+    }\n+\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    }\n+\n+    fn relate_with_variance<T: Relate<'tcx>>(\n+        &mut self,\n+        _variance: ty::Variance,\n+        a: &T,\n+        b: &T,\n+    ) -> RelateResult<'tcx, T> {\n+        // We don't care about variance.\n+        self.relate(a, b)\n+    }\n+\n+    fn binders<T: Relate<'tcx>>(\n+        &mut self,\n+        a: &ty::Binder<T>,\n+        b: &ty::Binder<T>,\n+    ) -> RelateResult<'tcx, ty::Binder<T>> {\n+        self.binder_index.shift_in(1);\n+        let result = self.relate(a.skip_binder(), b.skip_binder())?;\n+        self.binder_index.shift_out(1);\n+        Ok(ty::Binder::bind(result))\n+    }\n+\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        let b = self.infcx.shallow_resolve(b);\n+\n+        if let &ty::Bound(debruijn, bound_ty) = &a.sty {\n+            // Free bound var\n+            if debruijn == self.binder_index {\n+                self.unify_free_answer_var(bound_ty.var, b.into())?;\n+                return Ok(b);\n+            }\n+        }\n+\n+        match (&a.sty, &b.sty) {\n+            (&ty::Bound(a_debruijn, a_bound), &ty::Bound(b_debruijn, b_bound)) => {\n+                assert_eq!(a_debruijn, b_debruijn);\n+                assert_eq!(a_bound.var, b_bound.var);\n+                Ok(a)\n+            }\n+\n+            // Those should have been canonicalized away.\n+            (ty::Placeholder(..), _) => {\n+                bug!(\"unexpected placeholder ty in `AnswerSubstitutor`: {:?} \", a);\n+            }\n+\n+            // Everything else should just be a perfect match as well,\n+            // and we forbid inference variables.\n+            _ => match ty::relate::super_relate_tys(self, a, b) {\n+                Ok(ty) => Ok(ty),\n+                Err(err) => bug!(\"type mismatch in `AnswerSubstitutor`: {}\", err),\n+            }\n+        }\n+    }\n+\n+    fn regions(\n+        &mut self,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        let b = match b {\n+            &ty::ReVar(vid) => self.infcx\n+                .borrow_region_constraints()\n+                .opportunistic_resolve_var(self.infcx.tcx, vid),\n+\n+            other => other,\n+        };\n+\n+        if let &ty::ReLateBound(debruijn, bound) = a {\n+            // Free bound region\n+            if debruijn == self.binder_index {\n+                self.unify_free_answer_var(bound.assert_bound_var(), b.into())?;\n+                return Ok(b);\n+            }\n+        }\n+\n+        match (a, b) {\n+            (&ty::ReLateBound(a_debruijn, a_bound), &ty::ReLateBound(b_debruijn, b_bound)) => {\n+                assert_eq!(a_debruijn, b_debruijn);\n+                assert_eq!(a_bound.assert_bound_var(), b_bound.assert_bound_var());\n+            }\n+\n+            (ty::ReStatic, ty::ReStatic) |\n+            (ty::ReErased, ty::ReErased) |\n+            (ty::ReEmpty, ty::ReEmpty) => (),\n+\n+            (&ty::ReFree(a_free), &ty::ReFree(b_free)) => {\n+                assert_eq!(a_free, b_free);\n+            }\n+\n+            _ => bug!(\"unexpected regions in `AnswerSubstitutor`: {:?}, {:?}\", a, b),\n+        }\n+\n+        Ok(a)\n+    }\n+}"}]}