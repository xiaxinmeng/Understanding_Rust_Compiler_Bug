{"sha": "c97b539e408ea353f4fde2f9251d598291fec421", "node_id": "C_kwDOAAsO6NoAKGM5N2I1MzllNDA4ZWEzNTNmNGZkZTJmOTI1MWQ1OTgyOTFmZWM0MjE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-30T17:20:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-30T17:20:14Z"}, "message": "Auto merge of #104940 - cjgillot:query-feed-simple, r=oli-obk\n\nAllow to feed a value in another query's cache\n\nRestricted version of https://github.com/rust-lang/rust/pull/96840\n\nA query can create new definitions.\n\nIf those definitions are created after HIR lowering, they do not appear in the initial HIR map, and information for them cannot be provided in the normal pull-based way.\n\nIn order to make those definitions useful, we allow to feed values as query results for the newly created definition.\n\nThe API is as follows:\n```rust\nlet feed = tcx.create_def(<parent def id>, <DefPathData>);\n// `feed` is a TyCtxtFeed<'tcx>.\n\n// Access the created definition.\nlet def_id: LocalDefId = feed.def_id;\n\n// Assign `my_query(def_id) := my_value`.\nfeed.my_query(my_value).\n```\n\nThis PR keeps the consistency checks introduced by https://github.com/rust-lang/rust/pull/96840, even if they are not reachable. This allows to extend the behaviour later without forgetting them.\n\ncc `@oli-obk` `@spastorino`", "tree": {"sha": "1d6b1d663abdca782966f108c23cdee2c5ef296b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d6b1d663abdca782966f108c23cdee2c5ef296b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c97b539e408ea353f4fde2f9251d598291fec421", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c97b539e408ea353f4fde2f9251d598291fec421", "html_url": "https://github.com/rust-lang/rust/commit/c97b539e408ea353f4fde2f9251d598291fec421", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c97b539e408ea353f4fde2f9251d598291fec421/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90711a86e5bdd4b0b65d293f0c2c48fd2db761b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/90711a86e5bdd4b0b65d293f0c2c48fd2db761b3", "html_url": "https://github.com/rust-lang/rust/commit/90711a86e5bdd4b0b65d293f0c2c48fd2db761b3"}, {"sha": "6477fd8fc3f30af2f691a69ab9ba772c65ee4f0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6477fd8fc3f30af2f691a69ab9ba772c65ee4f0b", "html_url": "https://github.com/rust-lang/rust/commit/6477fd8fc3f30af2f691a69ab9ba772c65ee4f0b"}], "stats": {"total": 351, "additions": 298, "deletions": 53}, "files": [{"sha": "1d27970627854558902e9b661a9a34f07a14733e", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c97b539e408ea353f4fde2f9251d598291fec421/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c97b539e408ea353f4fde2f9251d598291fec421/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=c97b539e408ea353f4fde2f9251d598291fec421", "patch": "@@ -497,7 +497,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             self.tcx.hir().def_key(self.local_def_id(node_id)),\n         );\n \n-        let def_id = self.tcx.create_def(parent, data);\n+        let def_id = self.tcx.create_def(parent, data).def_id();\n \n         debug!(\"create_def: def_id_to_node_id[{:?}] <-> {:?}\", def_id, node_id);\n         self.resolver.node_id_to_def_id.insert(node_id, def_id);"}, {"sha": "dd37efb6983b429e5db6869e707662775ec444c3", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c97b539e408ea353f4fde2f9251d598291fec421/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c97b539e408ea353f4fde2f9251d598291fec421/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=c97b539e408ea353f4fde2f9251d598291fec421", "patch": "@@ -368,10 +368,6 @@ impl Definitions {\n         LocalDefId { local_def_index: self.table.allocate(key, def_path_hash) }\n     }\n \n-    pub fn iter_local_def_id(&self) -> impl Iterator<Item = LocalDefId> + '_ {\n-        self.table.def_path_hashes.indices().map(|local_def_index| LocalDefId { local_def_index })\n-    }\n-\n     #[inline(always)]\n     pub fn local_def_path_hash_to_def_id(\n         &self,\n@@ -389,6 +385,10 @@ impl Definitions {\n     pub fn def_path_hash_to_def_index_map(&self) -> &DefPathHashMap {\n         &self.table.def_path_hash_to_index\n     }\n+\n+    pub fn num_definitions(&self) -> usize {\n+        self.table.def_path_hashes.len()\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]"}, {"sha": "4047969724aa93bcca3ea9e9a9a54f45f2b26e9d", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c97b539e408ea353f4fde2f9251d598291fec421/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c97b539e408ea353f4fde2f9251d598291fec421/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=c97b539e408ea353f4fde2f9251d598291fec421", "patch": "@@ -114,6 +114,9 @@ struct QueryModifiers {\n \n     /// Always remap the ParamEnv's constness before hashing.\n     remap_env_constness: Option<Ident>,\n+\n+    /// Generate a `feed` method to set the query's value from another query.\n+    feedable: Option<Ident>,\n }\n \n fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n@@ -128,6 +131,7 @@ fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n     let mut depth_limit = None;\n     let mut separate_provide_extern = None;\n     let mut remap_env_constness = None;\n+    let mut feedable = None;\n \n     while !input.is_empty() {\n         let modifier: Ident = input.parse()?;\n@@ -187,6 +191,8 @@ fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n             try_insert!(separate_provide_extern = modifier);\n         } else if modifier == \"remap_env_constness\" {\n             try_insert!(remap_env_constness = modifier);\n+        } else if modifier == \"feedable\" {\n+            try_insert!(feedable = modifier);\n         } else {\n             return Err(Error::new(modifier.span(), \"unknown query modifier\"));\n         }\n@@ -206,6 +212,7 @@ fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n         depth_limit,\n         separate_provide_extern,\n         remap_env_constness,\n+        feedable,\n     })\n }\n \n@@ -296,6 +303,7 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n     let mut query_stream = quote! {};\n     let mut query_description_stream = quote! {};\n     let mut query_cached_stream = quote! {};\n+    let mut feedable_queries = quote! {};\n \n     for query in queries.0 {\n         let Query { name, arg, modifiers, .. } = &query;\n@@ -350,6 +358,22 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n             [#attribute_stream] fn #name(#arg) #result,\n         });\n \n+        if modifiers.feedable.is_some() {\n+            assert!(modifiers.anon.is_none(), \"Query {name} cannot be both `feedable` and `anon`.\");\n+            assert!(\n+                modifiers.eval_always.is_none(),\n+                \"Query {name} cannot be both `feedable` and `eval_always`.\"\n+            );\n+            assert!(\n+                modifiers.no_hash.is_none(),\n+                \"Query {name} cannot be both `feedable` and `no_hash`.\"\n+            );\n+            feedable_queries.extend(quote! {\n+                #(#doc_comments)*\n+                [#attribute_stream] fn #name(#arg) #result,\n+            });\n+        }\n+\n         add_query_desc_cached_impl(&query, &mut query_description_stream, &mut query_cached_stream);\n     }\n \n@@ -363,7 +387,11 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 }\n             }\n         }\n-\n+        macro_rules! rustc_feedable_queries {\n+            ( $macro:ident! ) => {\n+                $macro!(#feedable_queries);\n+            }\n+        }\n         pub mod descs {\n             use super::*;\n             #query_description_stream"}, {"sha": "7e4063c2ffd78fb0f0f2280dbcfade275fce56ad", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c97b539e408ea353f4fde2f9251d598291fec421/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c97b539e408ea353f4fde2f9251d598291fec421/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=c97b539e408ea353f4fde2f9251d598291fec421", "patch": "@@ -30,8 +30,10 @@\n #![feature(core_intrinsics)]\n #![feature(discriminant_kind)]\n #![feature(exhaustive_patterns)]\n+#![feature(generators)]\n #![feature(get_mut_unchecked)]\n #![feature(if_let_guard)]\n+#![feature(iter_from_generator)]\n #![feature(negative_impls)]\n #![feature(never_type)]\n #![feature(extern_types)]"}, {"sha": "a9a7a2c8b01cced710a674156f94c20ce246a95f", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c97b539e408ea353f4fde2f9251d598291fec421/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c97b539e408ea353f4fde2f9251d598291fec421/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=c97b539e408ea353f4fde2f9251d598291fec421", "patch": "@@ -53,6 +53,7 @@ use rustc_hir::{\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n use rustc_middle::mir::FakeReadCause;\n+use rustc_query_system::dep_graph::DepNodeIndex;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_session::config::{CrateType, OutputFilenames};\n@@ -1031,6 +1032,21 @@ pub struct FreeRegionInfo {\n     pub is_impl_item: bool,\n }\n \n+/// This struct should only be created by `create_def`.\n+#[derive(Copy, Clone)]\n+pub struct TyCtxtFeed<'tcx> {\n+    pub tcx: TyCtxt<'tcx>,\n+    // Do not allow direct access, as downstream code must not mutate this field.\n+    def_id: LocalDefId,\n+}\n+\n+impl<'tcx> TyCtxtFeed<'tcx> {\n+    #[inline(always)]\n+    pub fn def_id(&self) -> LocalDefId {\n+        self.def_id\n+    }\n+}\n+\n /// The central data structure of the compiler. It stores references\n /// to the various **arenas** and also houses the results of the\n /// various **compiler queries** that have been performed. See the\n@@ -1493,12 +1509,15 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Create a new definition within the incr. comp. engine.\n-    pub fn create_def(self, parent: LocalDefId, data: hir::definitions::DefPathData) -> LocalDefId {\n+    pub fn create_def(\n+        self,\n+        parent: LocalDefId,\n+        data: hir::definitions::DefPathData,\n+    ) -> TyCtxtFeed<'tcx> {\n         // This function modifies `self.definitions` using a side-effect.\n         // We need to ensure that these side effects are re-run by the incr. comp. engine.\n         // Depending on the forever-red node will tell the graph that the calling query\n         // needs to be re-evaluated.\n-        use rustc_query_system::dep_graph::DepNodeIndex;\n         self.dep_graph.read_index(DepNodeIndex::FOREVER_RED_NODE);\n \n         // The following call has the side effect of modifying the tables inside `definitions`.\n@@ -1515,23 +1534,38 @@ impl<'tcx> TyCtxt<'tcx> {\n         // This is fine because:\n         // - those queries are `eval_always` so we won't miss their result changing;\n         // - this write will have happened before these queries are called.\n-        self.definitions.write().create_def(parent, data)\n+        let def_id = self.definitions.write().create_def(parent, data);\n+\n+        TyCtxtFeed { tcx: self, def_id }\n     }\n \n     pub fn iter_local_def_id(self) -> impl Iterator<Item = LocalDefId> + 'tcx {\n-        // Create a dependency to the crate to be sure we re-execute this when the amount of\n+        // Create a dependency to the red node to be sure we re-execute this when the amount of\n         // definitions change.\n-        self.ensure().hir_crate(());\n-        // Leak a read lock once we start iterating on definitions, to prevent adding new ones\n-        // while iterating.  If some query needs to add definitions, it should be `ensure`d above.\n-        let definitions = self.definitions.leak();\n-        definitions.iter_local_def_id()\n+        self.dep_graph.read_index(DepNodeIndex::FOREVER_RED_NODE);\n+\n+        let definitions = &self.definitions;\n+        std::iter::from_generator(|| {\n+            let mut i = 0;\n+\n+            // Recompute the number of definitions each time, because our caller may be creating\n+            // new ones.\n+            while i < { definitions.read().num_definitions() } {\n+                let local_def_index = rustc_span::def_id::DefIndex::from_usize(i);\n+                yield LocalDefId { local_def_index };\n+                i += 1;\n+            }\n+\n+            // Leak a read lock once we finish iterating on definitions, to prevent adding new ones.\n+            definitions.leak();\n+        })\n     }\n \n     pub fn def_path_table(self) -> &'tcx rustc_hir::definitions::DefPathTable {\n         // Create a dependency to the crate to be sure we re-execute this when the amount of\n         // definitions change.\n-        self.ensure().hir_crate(());\n+        self.dep_graph.read_index(DepNodeIndex::FOREVER_RED_NODE);\n+\n         // Leak a read lock once we start iterating on definitions, to prevent adding new ones\n         // while iterating.  If some query needs to add definitions, it should be `ensure`d above.\n         let definitions = self.definitions.leak();"}, {"sha": "47c1379b308ebd3fa3dcf1b9e7bd5e78c987265b", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c97b539e408ea353f4fde2f9251d598291fec421/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c97b539e408ea353f4fde2f9251d598291fec421/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=c97b539e408ea353f4fde2f9251d598291fec421", "patch": "@@ -28,6 +28,7 @@ use crate::traits::query::{\n };\n use crate::traits::specialization_graph;\n use crate::traits::{self, ImplSource};\n+use crate::ty::context::TyCtxtFeed;\n use crate::ty::fast_reject::SimplifiedType;\n use crate::ty::layout::TyAndLayout;\n use crate::ty::subst::{GenericArg, SubstsRef};\n@@ -327,6 +328,46 @@ macro_rules! define_callbacks {\n     };\n }\n \n+macro_rules! define_feedable {\n+    ($($(#[$attr:meta])* [$($modifiers:tt)*] fn $name:ident($($K:tt)*) -> $V:ty,)*) => {\n+        impl<'tcx> TyCtxtFeed<'tcx> {\n+            $($(#[$attr])*\n+            #[inline(always)]\n+            pub fn $name(self, value: $V) -> query_stored::$name<'tcx> {\n+                let key = self.def_id().into_query_param();\n+                opt_remap_env_constness!([$($modifiers)*][key]);\n+\n+                let tcx = self.tcx;\n+                let cache = &tcx.query_caches.$name;\n+\n+                let cached = try_get_cached(tcx, cache, &key, copy);\n+\n+                match cached {\n+                    Ok(old) => {\n+                        assert_eq!(\n+                            value, old,\n+                            \"Trying to feed an already recorded value for query {} key={key:?}\",\n+                            stringify!($name),\n+                        );\n+                        return old;\n+                    }\n+                    Err(()) => (),\n+                }\n+\n+                let dep_node = dep_graph::DepNode::construct(tcx, dep_graph::DepKind::$name, &key);\n+                let dep_node_index = tcx.dep_graph.with_feed_task(\n+                    dep_node,\n+                    tcx,\n+                    key,\n+                    &value,\n+                    dep_graph::hash_result,\n+                );\n+                cache.complete(key, value, dep_node_index)\n+            })*\n+        }\n+    }\n+}\n+\n // Each of these queries corresponds to a function pointer field in the\n // `Providers` struct for requesting a value of that type, and a method\n // on `tcx: TyCtxt` (and `tcx.at(span)`) for doing that request in a way\n@@ -340,6 +381,7 @@ macro_rules! define_callbacks {\n // as they will raise an fatal error on query cycles instead.\n \n rustc_query_append! { define_callbacks! }\n+rustc_feedable_queries! { define_feedable! }\n \n mod sealed {\n     use super::{DefId, LocalDefId, OwnerId};"}, {"sha": "8d5d84c5db48a17d553e6b532fa5a8b775f3ebce", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c97b539e408ea353f4fde2f9251d598291fec421/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c97b539e408ea353f4fde2f9251d598291fec421/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=c97b539e408ea353f4fde2f9251d598291fec421", "patch": "@@ -252,6 +252,18 @@ macro_rules! depth_limit {\n     };\n }\n \n+macro_rules! feedable {\n+    ([]) => {{\n+        false\n+    }};\n+    ([(feedable) $($rest:tt)*]) => {{\n+        true\n+    }};\n+    ([$other:tt $($modifiers:tt)*]) => {\n+        feedable!([$($modifiers)*])\n+    };\n+}\n+\n macro_rules! hash_result {\n     ([]) => {{\n         Some(dep_graph::hash_result)\n@@ -309,7 +321,7 @@ pub(crate) fn create_query_frame<\n         ty::print::with_forced_impl_filename_line!(do_describe(tcx.tcx, key))\n     );\n     let description =\n-        if tcx.sess.verbose() { format!(\"{} [{}]\", description, name) } else { description };\n+        if tcx.sess.verbose() { format!(\"{} [{:?}]\", description, name) } else { description };\n     let span = if kind == dep_graph::DepKind::def_span {\n         // The `def_span` query is used to calculate `default_span`,\n         // so exit to avoid infinite recursion.\n@@ -491,6 +503,7 @@ macro_rules! define_queries {\n                     anon: is_anon!([$($modifiers)*]),\n                     eval_always: is_eval_always!([$($modifiers)*]),\n                     depth_limit: depth_limit!([$($modifiers)*]),\n+                    feedable: feedable!([$($modifiers)*]),\n                     dep_kind: dep_graph::DepKind::$name,\n                     hash_result: hash_result!([$($modifiers)*]),\n                     handle_cycle_error: handle_cycle_error!([$($modifiers)*]),"}, {"sha": "e44857a023857f4a928062c44ca6d776defcf48b", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 120, "deletions": 19, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/c97b539e408ea353f4fde2f9251d598291fec421/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c97b539e408ea353f4fde2f9251d598291fec421/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=c97b539e408ea353f4fde2f9251d598291fec421", "patch": "@@ -489,6 +489,91 @@ impl<K: DepKind> DepGraph<K> {\n         }\n     }\n \n+    /// Create a node when we force-feed a value into the query cache.\n+    /// This is used to remove cycles during type-checking const generic parameters.\n+    ///\n+    /// As usual in the query system, we consider the current state of the calling query\n+    /// only depends on the list of dependencies up to now.  As a consequence, the value\n+    /// that this query gives us can only depend on those dependencies too.  Therefore,\n+    /// it is sound to use the current dependency set for the created node.\n+    ///\n+    /// During replay, the order of the nodes is relevant in the dependency graph.\n+    /// So the unchanged replay will mark the caller query before trying to mark this one.\n+    /// If there is a change to report, the caller query will be re-executed before this one.\n+    ///\n+    /// FIXME: If the code is changed enough for this node to be marked before requiring the\n+    /// caller's node, we suppose that those changes will be enough to mark this node red and\n+    /// force a recomputation using the \"normal\" way.\n+    pub fn with_feed_task<Ctxt: DepContext<DepKind = K>, A: Debug, R: Debug>(\n+        &self,\n+        node: DepNode<K>,\n+        cx: Ctxt,\n+        key: A,\n+        result: &R,\n+        hash_result: fn(&mut StableHashingContext<'_>, &R) -> Fingerprint,\n+    ) -> DepNodeIndex {\n+        if let Some(data) = self.data.as_ref() {\n+            // The caller query has more dependencies than the node we are creating.  We may\n+            // encounter a case where this created node is marked as green, but the caller query is\n+            // subsequently marked as red or recomputed.  In this case, we will end up feeding a\n+            // value to an existing node.\n+            //\n+            // For sanity, we still check that the loaded stable hash and the new one match.\n+            if let Some(dep_node_index) = self.dep_node_index_of_opt(&node) {\n+                let _current_fingerprint =\n+                    crate::query::incremental_verify_ich(cx, result, &node, Some(hash_result));\n+\n+                #[cfg(debug_assertions)]\n+                data.current.record_edge(dep_node_index, node, _current_fingerprint);\n+\n+                return dep_node_index;\n+            }\n+\n+            let mut edges = SmallVec::new();\n+            K::read_deps(|task_deps| match task_deps {\n+                TaskDepsRef::Allow(deps) => edges.extend(deps.lock().reads.iter().copied()),\n+                TaskDepsRef::Ignore | TaskDepsRef::Forbid => {\n+                    panic!(\"Cannot summarize when dependencies are not recorded.\")\n+                }\n+            });\n+\n+            let hashing_timer = cx.profiler().incr_result_hashing();\n+            let current_fingerprint =\n+                cx.with_stable_hashing_context(|mut hcx| hash_result(&mut hcx, result));\n+\n+            let print_status = cfg!(debug_assertions) && cx.sess().opts.unstable_opts.dep_tasks;\n+\n+            // Intern the new `DepNode` with the dependencies up-to-now.\n+            let (dep_node_index, prev_and_color) = data.current.intern_node(\n+                cx.profiler(),\n+                &data.previous,\n+                node,\n+                edges,\n+                Some(current_fingerprint),\n+                print_status,\n+            );\n+\n+            hashing_timer.finish_with_query_invocation_id(dep_node_index.into());\n+\n+            if let Some((prev_index, color)) = prev_and_color {\n+                debug_assert!(\n+                    data.colors.get(prev_index).is_none(),\n+                    \"DepGraph::with_task() - Duplicate DepNodeColor insertion for {key:?}\",\n+                );\n+\n+                data.colors.insert(prev_index, color);\n+            }\n+\n+            dep_node_index\n+        } else {\n+            // Incremental compilation is turned off. We just execute the task\n+            // without tracking. We still provide a dep-node index that uniquely\n+            // identifies the task so that we have a cheap way of referring to\n+            // the query for self-profiling.\n+            self.next_virtual_depnode_index()\n+        }\n+    }\n+\n     #[inline]\n     pub fn dep_node_index_of(&self, dep_node: &DepNode<K>) -> DepNodeIndex {\n         self.dep_node_index_of_opt(dep_node).unwrap()\n@@ -916,6 +1001,11 @@ pub(super) struct CurrentDepGraph<K: DepKind> {\n     new_node_to_index: Sharded<FxHashMap<DepNode<K>, DepNodeIndex>>,\n     prev_index_to_index: Lock<IndexVec<SerializedDepNodeIndex, Option<DepNodeIndex>>>,\n \n+    /// This is used to verify that fingerprints do not change between the creation of a node\n+    /// and its recomputation.\n+    #[cfg(debug_assertions)]\n+    fingerprints: Lock<FxHashMap<DepNode<K>, Fingerprint>>,\n+\n     /// Used to trap when a specific edge is added to the graph.\n     /// This is used for debug purposes and is only active with `debug_assertions`.\n     #[cfg(debug_assertions)]\n@@ -999,17 +1089,27 @@ impl<K: DepKind> CurrentDepGraph<K> {\n             anon_id_seed,\n             #[cfg(debug_assertions)]\n             forbidden_edge,\n+            #[cfg(debug_assertions)]\n+            fingerprints: Lock::new(Default::default()),\n             total_read_count: AtomicU64::new(0),\n             total_duplicate_read_count: AtomicU64::new(0),\n             node_intern_event_id,\n         }\n     }\n \n     #[cfg(debug_assertions)]\n-    fn record_edge(&self, dep_node_index: DepNodeIndex, key: DepNode<K>) {\n+    fn record_edge(&self, dep_node_index: DepNodeIndex, key: DepNode<K>, fingerprint: Fingerprint) {\n         if let Some(forbidden_edge) = &self.forbidden_edge {\n             forbidden_edge.index_to_node.lock().insert(dep_node_index, key);\n         }\n+        match self.fingerprints.lock().entry(key) {\n+            Entry::Vacant(v) => {\n+                v.insert(fingerprint);\n+            }\n+            Entry::Occupied(o) => {\n+                assert_eq!(*o.get(), fingerprint, \"Unstable fingerprints for {:?}\", key);\n+            }\n+        }\n     }\n \n     /// Writes the node to the current dep-graph and allocates a `DepNodeIndex` for it.\n@@ -1021,17 +1121,21 @@ impl<K: DepKind> CurrentDepGraph<K> {\n         edges: EdgesVec,\n         current_fingerprint: Fingerprint,\n     ) -> DepNodeIndex {\n-        match self.new_node_to_index.get_shard_by_value(&key).lock().entry(key) {\n+        let dep_node_index = match self.new_node_to_index.get_shard_by_value(&key).lock().entry(key)\n+        {\n             Entry::Occupied(entry) => *entry.get(),\n             Entry::Vacant(entry) => {\n                 let dep_node_index =\n                     self.encoder.borrow().send(profiler, key, current_fingerprint, edges);\n                 entry.insert(dep_node_index);\n-                #[cfg(debug_assertions)]\n-                self.record_edge(dep_node_index, key);\n                 dep_node_index\n             }\n-        }\n+        };\n+\n+        #[cfg(debug_assertions)]\n+        self.record_edge(dep_node_index, key, current_fingerprint);\n+\n+        dep_node_index\n     }\n \n     fn intern_node(\n@@ -1072,7 +1176,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n                     };\n \n                     #[cfg(debug_assertions)]\n-                    self.record_edge(dep_node_index, key);\n+                    self.record_edge(dep_node_index, key, fingerprint);\n                     (dep_node_index, Some((prev_index, DepNodeColor::Green(dep_node_index))))\n                 } else {\n                     if print_status {\n@@ -1094,7 +1198,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n                     };\n \n                     #[cfg(debug_assertions)]\n-                    self.record_edge(dep_node_index, key);\n+                    self.record_edge(dep_node_index, key, fingerprint);\n                     (dep_node_index, Some((prev_index, DepNodeColor::Red)))\n                 }\n             } else {\n@@ -1119,7 +1223,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n                 };\n \n                 #[cfg(debug_assertions)]\n-                self.record_edge(dep_node_index, key);\n+                self.record_edge(dep_node_index, key, Fingerprint::ZERO);\n                 (dep_node_index, Some((prev_index, DepNodeColor::Red)))\n             }\n         } else {\n@@ -1150,19 +1254,16 @@ impl<K: DepKind> CurrentDepGraph<K> {\n             Some(dep_node_index) => dep_node_index,\n             None => {\n                 let key = prev_graph.index_to_node(prev_index);\n-                let dep_node_index = self.encoder.borrow().send(\n-                    profiler,\n-                    key,\n-                    prev_graph.fingerprint_by_index(prev_index),\n-                    prev_graph\n-                        .edge_targets_from(prev_index)\n-                        .iter()\n-                        .map(|i| prev_index_to_index[*i].unwrap())\n-                        .collect(),\n-                );\n+                let edges = prev_graph\n+                    .edge_targets_from(prev_index)\n+                    .iter()\n+                    .map(|i| prev_index_to_index[*i].unwrap())\n+                    .collect();\n+                let fingerprint = prev_graph.fingerprint_by_index(prev_index);\n+                let dep_node_index = self.encoder.borrow().send(profiler, key, fingerprint, edges);\n                 prev_index_to_index[prev_index] = Some(dep_node_index);\n                 #[cfg(debug_assertions)]\n-                self.record_edge(dep_node_index, key);\n+                self.record_edge(dep_node_index, key, fingerprint);\n                 dep_node_index\n             }\n         }"}, {"sha": "4c4680b5d8ea89b7d241e548a0e386da06e998df", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c97b539e408ea353f4fde2f9251d598291fec421/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c97b539e408ea353f4fde2f9251d598291fec421/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=c97b539e408ea353f4fde2f9251d598291fec421", "patch": "@@ -117,6 +117,8 @@ where\n         let mut lock = self.cache.get_shard_by_value(&key).lock();\n         #[cfg(not(parallel_compiler))]\n         let mut lock = self.cache.lock();\n+        // We may be overwriting another value.  This is all right, since the dep-graph\n+        // will check that the fingerprint matches.\n         lock.insert(key, (value.clone(), index));\n         value\n     }\n@@ -202,6 +204,8 @@ where\n         let mut lock = self.cache.get_shard_by_value(&key).lock();\n         #[cfg(not(parallel_compiler))]\n         let mut lock = self.cache.lock();\n+        // We may be overwriting another value.  This is all right, since the dep-graph\n+        // will check that the fingerprint matches.\n         lock.insert(key, value);\n         &value.0\n     }"}, {"sha": "7d1b62ab10237d176ecf25aae385bc6376eaacfc", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c97b539e408ea353f4fde2f9251d598291fec421/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c97b539e408ea353f4fde2f9251d598291fec421/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=c97b539e408ea353f4fde2f9251d598291fec421", "patch": "@@ -15,8 +15,8 @@ pub trait QueryConfig<Qcx: QueryContext> {\n     const NAME: &'static str;\n \n     type Key: Eq + Hash + Clone + Debug;\n-    type Value;\n-    type Stored: Clone;\n+    type Value: Debug;\n+    type Stored: Debug + Clone + std::borrow::Borrow<Self::Value>;\n \n     type Cache: QueryCache<Key = Self::Key, Stored = Self::Stored, Value = Self::Value>;\n \n@@ -45,6 +45,7 @@ pub struct QueryVTable<Qcx: QueryContext, K, V> {\n     pub dep_kind: Qcx::DepKind,\n     pub eval_always: bool,\n     pub depth_limit: bool,\n+    pub feedable: bool,\n \n     pub compute: fn(Qcx::DepContext, K) -> V,\n     pub hash_result: Option<fn(&mut StableHashingContext<'_>, &V) -> Fingerprint>,"}, {"sha": "848fa67e3df25f4e1643b9ca06a004747ae092a7", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c97b539e408ea353f4fde2f9251d598291fec421/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c97b539e408ea353f4fde2f9251d598291fec421/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=c97b539e408ea353f4fde2f9251d598291fec421", "patch": "@@ -3,6 +3,7 @@\n //! manage the caches, and so forth.\n \n use crate::dep_graph::{DepContext, DepNode, DepNodeIndex, DepNodeParams};\n+use crate::ich::StableHashingContext;\n use crate::query::caches::QueryCache;\n use crate::query::config::QueryVTable;\n use crate::query::job::{report_cycle, QueryInfo, QueryJob, QueryJobId, QueryJobInfo};\n@@ -19,6 +20,7 @@ use rustc_data_structures::sync::Lock;\n use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed, FatalError};\n use rustc_session::Session;\n use rustc_span::{Span, DUMMY_SP};\n+use std::borrow::Borrow;\n use std::cell::Cell;\n use std::collections::hash_map::Entry;\n use std::fmt::Debug;\n@@ -369,11 +371,26 @@ where\n     C: QueryCache,\n     C::Key: Clone + DepNodeParams<Qcx::DepContext>,\n     C::Value: Value<Qcx::DepContext>,\n+    C::Stored: Debug + std::borrow::Borrow<C::Value>,\n     Qcx: QueryContext,\n {\n     match JobOwner::<'_, C::Key>::try_start(&qcx, state, span, key.clone()) {\n         TryGetJob::NotYetStarted(job) => {\n-            let (result, dep_node_index) = execute_job(qcx, key, dep_node, query, job.id);\n+            let (result, dep_node_index) = execute_job(qcx, key.clone(), dep_node, query, job.id);\n+            if query.feedable {\n+                // We may have put a value inside the cache from inside the execution.\n+                // Verify that it has the same hash as what we have now, to ensure consistency.\n+                let _ = cache.lookup(&key, |cached_result, _| {\n+                    let hasher = query.hash_result.expect(\"feedable forbids no_hash\");\n+                    let old_hash = qcx.dep_context().with_stable_hashing_context(|mut hcx| hasher(&mut hcx, cached_result.borrow()));\n+                    let new_hash = qcx.dep_context().with_stable_hashing_context(|mut hcx| hasher(&mut hcx, &result));\n+                    debug_assert_eq!(\n+                        old_hash, new_hash,\n+                        \"Computed query value for {:?}({:?}) is inconsistent with fed value,\\ncomputed={:#?}\\nfed={:#?}\",\n+                        query.dep_kind, key, result, cached_result,\n+                    );\n+                });\n+            }\n             let result = job.complete(cache, result, dep_node_index);\n             (result, Some(dep_node_index))\n         }\n@@ -525,7 +542,7 @@ where\n             if std::intrinsics::unlikely(\n                 try_verify || qcx.dep_context().sess().opts.unstable_opts.incremental_verify_ich,\n             ) {\n-                incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query);\n+                incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query.hash_result);\n             }\n \n             return Some((result, dep_node_index));\n@@ -558,39 +575,42 @@ where\n     //\n     // See issue #82920 for an example of a miscompilation that would get turned into\n     // an ICE by this check\n-    incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query);\n+    incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query.hash_result);\n \n     Some((result, dep_node_index))\n }\n \n-#[instrument(skip(qcx, result, query), level = \"debug\")]\n-fn incremental_verify_ich<Qcx, K, V: Debug>(\n-    qcx: Qcx::DepContext,\n+#[instrument(skip(tcx, result, hash_result), level = \"debug\")]\n+pub(crate) fn incremental_verify_ich<Tcx, V: Debug>(\n+    tcx: Tcx,\n     result: &V,\n-    dep_node: &DepNode<Qcx::DepKind>,\n-    query: &QueryVTable<Qcx, K, V>,\n-) where\n-    Qcx: QueryContext,\n+    dep_node: &DepNode<Tcx::DepKind>,\n+    hash_result: Option<fn(&mut StableHashingContext<'_>, &V) -> Fingerprint>,\n+) -> Fingerprint\n+where\n+    Tcx: DepContext,\n {\n     assert!(\n-        qcx.dep_graph().is_green(dep_node),\n+        tcx.dep_graph().is_green(dep_node),\n         \"fingerprint for green query instance not loaded from cache: {:?}\",\n         dep_node,\n     );\n \n-    let new_hash = query.hash_result.map_or(Fingerprint::ZERO, |f| {\n-        qcx.with_stable_hashing_context(|mut hcx| f(&mut hcx, result))\n+    let new_hash = hash_result.map_or(Fingerprint::ZERO, |f| {\n+        tcx.with_stable_hashing_context(|mut hcx| f(&mut hcx, result))\n     });\n \n-    let old_hash = qcx.dep_graph().prev_fingerprint_of(dep_node);\n+    let old_hash = tcx.dep_graph().prev_fingerprint_of(dep_node);\n \n     if Some(new_hash) != old_hash {\n         incremental_verify_ich_failed(\n-            qcx.sess(),\n+            tcx.sess(),\n             DebugArg::from(&dep_node),\n             DebugArg::from(&result),\n         );\n     }\n+\n+    new_hash\n }\n \n // This DebugArg business is largely a mirror of std::fmt::ArgumentV1, which is"}]}