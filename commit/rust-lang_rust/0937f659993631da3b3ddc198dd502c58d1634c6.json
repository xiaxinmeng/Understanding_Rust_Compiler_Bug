{"sha": "0937f659993631da3b3ddc198dd502c58d1634c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5MzdmNjU5OTkzNjMxZGEzYjNkZGMxOThkZDUwMmM1OGQxNjM0YzY=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-15T01:01:52Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-15T23:13:56Z"}, "message": "std: add a NativeMutex type as a wrapper to destroy StaticNativeMutex.\n\nThis obsoletes LittleLock, and so it is removed.", "tree": {"sha": "3b241161b563b4ef77a840188d822522e26ef174", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b241161b563b4ef77a840188d822522e26ef174"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0937f659993631da3b3ddc198dd502c58d1634c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0937f659993631da3b3ddc198dd502c58d1634c6", "html_url": "https://github.com/rust-lang/rust/commit/0937f659993631da3b3ddc198dd502c58d1634c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0937f659993631da3b3ddc198dd502c58d1634c6/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b87ed605c0ef27f5532ec30c92128bd890de5955", "url": "https://api.github.com/repos/rust-lang/rust/commits/b87ed605c0ef27f5532ec30c92128bd890de5955", "html_url": "https://github.com/rust-lang/rust/commit/b87ed605c0ef27f5532ec30c92128bd890de5955"}], "stats": {"total": 188, "additions": 115, "deletions": 73}, "files": [{"sha": "297c22e2cd6ced672f32ad3b602f95e2dca48387", "filename": "src/libgreen/simple.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0937f659993631da3b3ddc198dd502c58d1634c6/src%2Flibgreen%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0937f659993631da3b3ddc198dd502c58d1634c6/src%2Flibgreen%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsimple.rs?ref=0937f659993631da3b3ddc198dd502c58d1634c6", "patch": "@@ -17,10 +17,10 @@ use std::rt::local::Local;\n use std::rt::rtio;\n use std::rt::task::{Task, BlockedTask};\n use std::task::TaskOpts;\n-use std::unstable::sync::LittleLock;\n+use std::unstable::mutex::NativeMutex;\n \n struct SimpleTask {\n-    lock: LittleLock,\n+    lock: NativeMutex,\n     awoken: bool,\n }\n \n@@ -59,9 +59,9 @@ impl Runtime for SimpleTask {\n         to_wake.put_runtime(self as ~Runtime);\n         unsafe {\n             cast::forget(to_wake);\n-            let _l = (*me).lock.lock();\n+            let mut guard = (*me).lock.lock();\n             (*me).awoken = true;\n-            (*me).lock.signal();\n+            guard.signal();\n         }\n     }\n \n@@ -83,7 +83,7 @@ impl Runtime for SimpleTask {\n pub fn task() -> ~Task {\n     let mut task = ~Task::new();\n     task.put_runtime(~SimpleTask {\n-        lock: LittleLock::new(),\n+        lock: unsafe {NativeMutex::new()},\n         awoken: false,\n     } as ~Runtime);\n     return task;"}, {"sha": "da502ca72de57652d651acfaa5b46e549383e8a8", "filename": "src/librustuv/queue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0937f659993631da3b3ddc198dd502c58d1634c6/src%2Flibrustuv%2Fqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0937f659993631da3b3ddc198dd502c58d1634c6/src%2Flibrustuv%2Fqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fqueue.rs?ref=0937f659993631da3b3ddc198dd502c58d1634c6", "patch": "@@ -23,7 +23,7 @@\n use std::cast;\n use std::libc::{c_void, c_int};\n use std::rt::task::BlockedTask;\n-use std::unstable::sync::LittleLock;\n+use std::unstable::mutex::NativeMutex;\n use std::sync::arc::UnsafeArc;\n use mpsc = std::sync::mpsc_queue;\n \n@@ -39,7 +39,7 @@ enum Message {\n \n struct State {\n     handle: *uvll::uv_async_t,\n-    lock: LittleLock, // see comments in async_cb for why this is needed\n+    lock: NativeMutex, // see comments in async_cb for why this is needed\n     queue: mpsc::Queue<Message>,\n }\n \n@@ -112,7 +112,7 @@ impl QueuePool {\n         let handle = UvHandle::alloc(None::<AsyncWatcher>, uvll::UV_ASYNC);\n         let state = UnsafeArc::new(State {\n             handle: handle,\n-            lock: LittleLock::new(),\n+            lock: unsafe {NativeMutex::new()},\n             queue: mpsc::Queue::new(),\n         });\n         let q = ~QueuePool {"}, {"sha": "d217e90522cb44fe124895ee8bd72b68689ddf11", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 100, "deletions": 18, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/0937f659993631da3b3ddc198dd502c58d1634c6/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0937f659993631da3b3ddc198dd502c58d1634c6/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=0937f659993631da3b3ddc198dd502c58d1634c6", "patch": "@@ -8,44 +8,50 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A native mutex and condition variable type\n+//! A native mutex and condition variable type.\n //!\n //! This module contains bindings to the platform's native mutex/condition\n-//! variable primitives. It provides a single type, `StaticNativeMutex`, which can be\n-//! statically initialized via the `NATIVE_MUTEX_INIT` value. This object serves as\n-//! both a mutex and a condition variable simultaneously.\n+//! variable primitives. It provides two types: `StaticNativeMutex`, which can\n+//! be statically initialized via the `NATIVE_MUTEX_INIT` value, and a simple\n+//! wrapper `NativeMutex` that has a destructor to clean up after itself. These\n+//! objects serve as both mutexes and condition variables simultaneously.\n //!\n-//! The lock is lazily initialized, but it can only be unsafely destroyed. A\n-//! statically initialized lock doesn't necessarily have a time at which it can\n-//! get deallocated. For this reason, there is no `Drop` implementation of the\n-//! mutex, but rather the `destroy()` method must be invoked manually if\n-//! destruction of the mutex is desired.\n+//! The static lock is lazily initialized, but it can only be unsafely\n+//! destroyed. A statically initialized lock doesn't necessarily have a time at\n+//! which it can get deallocated. For this reason, there is no `Drop`\n+//! implementation of the static mutex, but rather the `destroy()` method must\n+//! be invoked manually if destruction of the mutex is desired.\n //!\n-//! It is not recommended to use this type for idiomatic rust use. This type is\n-//! appropriate where no other options are available, but other rust concurrency\n-//! primitives should be used before this type.\n+//! The non-static `NativeMutex` type does have a destructor, but cannot be\n+//! statically initialized.\n+//!\n+//! It is not recommended to use this type for idiomatic rust use. These types\n+//! are appropriate where no other options are available, but other rust\n+//! concurrency primitives should be used before them.\n //!\n //! # Example\n //!\n //!     use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n //!\n //!     // Use a statically initialized mutex\n-//!     static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+//!     static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n //!\n //!     unsafe {\n-//!         let _guard = lock.lock();\n+//!         let _guard = LOCK.lock();\n //!     } // automatically unlocked here\n //!\n //!     // Use a normally initialized mutex\n //!     unsafe {\n-//!         let mut lock = StaticNativeMutex::new();\n+//!         let mut lock = NativeMutex::new();\n+//!\n+//!         {\n+//!             let _guard = lock.lock();\n+//!         } // unlocked here\n //!\n //!         // sometimes the RAII guard isn't appropriate\n //!         lock.lock_noguard();\n //!         lock.unlock_noguard();\n-//!\n-//!         lock.destroy();\n-//!     }\n+//!     } // `lock` is deallocated here\n \n #[allow(non_camel_case_types)];\n \n@@ -54,10 +60,20 @@ use ops::Drop;\n \n /// A native mutex suitable for storing in statics (that is, it has\n /// the `destroy` method rather than a destructor).\n+///\n+/// Prefer the `NativeMutex` type where possible.\n pub struct StaticNativeMutex {\n     priv inner: imp::Mutex,\n }\n \n+/// A native mutex with a destructor for clean-up.\n+///\n+/// See `StaticNativeMutex` for a version that is suitable for storing in\n+/// statics.\n+pub struct NativeMutex {\n+    priv inner: StaticNativeMutex\n+}\n+\n /// Automatically unlocks the mutex that it was created from on\n /// destruction.\n ///\n@@ -144,6 +160,72 @@ impl StaticNativeMutex {\n     pub unsafe fn destroy(&mut self) { self.inner.destroy() }\n }\n \n+impl NativeMutex {\n+    /// Creates a new mutex.\n+    ///\n+    /// The user must be careful to ensure the mutex is not locked when its is\n+    /// being destroyed.\n+    pub unsafe fn new() -> NativeMutex {\n+        NativeMutex { inner: StaticNativeMutex::new() }\n+    }\n+\n+    /// Acquires this lock. This assumes that the current thread does not\n+    /// already hold the lock.\n+    ///\n+    /// # Example\n+    /// ```rust\n+    /// use std::unstable::mutex::NativeMutex;\n+    /// let mut lock = NativeMutex::new();\n+    /// unsafe {\n+    ///     let _guard = lock.lock();\n+    ///     // critical section...\n+    /// } // automatically unlocked in `_guard`'s destructor\n+    /// ```\n+    pub unsafe fn lock<'a>(&'a mut self) -> LockGuard<'a> {\n+        self.inner.lock()\n+    }\n+\n+    /// Attempts to acquire the lock. The value returned is `Some` if\n+    /// the attempt succeeded.\n+    pub unsafe fn trylock<'a>(&'a mut self) -> Option<LockGuard<'a>> {\n+        self.inner.trylock()\n+    }\n+\n+    /// Acquire the lock without creating a `LockGuard`.\n+    ///\n+    /// Prefer using `.lock`.\n+    pub unsafe fn lock_noguard(&mut self) { self.inner.lock_noguard() }\n+\n+    /// Attempts to acquire the lock without creating a\n+    /// `LockGuard`. The value returned is whether the lock was\n+    /// acquired or not.\n+    ///\n+    /// Prefer using `.trylock`.\n+    pub unsafe fn trylock_noguard(&mut self) -> bool {\n+        self.inner.trylock_noguard()\n+    }\n+\n+    /// Unlocks the lock. This assumes that the current thread already holds the\n+    /// lock.\n+    pub unsafe fn unlock_noguard(&mut self) { self.inner.unlock_noguard() }\n+\n+    /// Block on the internal condition variable.\n+    ///\n+    /// This function assumes that the lock is already held. Prefer\n+    /// using `LockGuard.wait` since that guarantees that the lock is\n+    /// held.\n+    pub unsafe fn wait_noguard(&mut self) { self.inner.wait_noguard() }\n+\n+    /// Signals a thread in `wait` to wake up\n+    pub unsafe fn signal_noguard(&mut self) { self.inner.signal_noguard() }\n+}\n+\n+impl Drop for NativeMutex {\n+    fn drop(&mut self) {\n+        unsafe {self.inner.destroy()}\n+    }\n+}\n+\n impl<'a> LockGuard<'a> {\n     /// Block on the internal condition variable.\n     pub unsafe fn wait(&mut self) {"}, {"sha": "93322977bc1215c1c80fc1c7713db46a863f358a", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 7, "deletions": 47, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0937f659993631da3b3ddc198dd502c58d1634c6/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0937f659993631da3b3ddc198dd502c58d1634c6/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=0937f659993631da3b3ddc198dd502c58d1634c6", "patch": "@@ -10,51 +10,11 @@\n \n use clone::Clone;\n use kinds::Send;\n-use ops::Drop;\n-use option::Option;\n use sync::arc::UnsafeArc;\n-use unstable::mutex::{StaticNativeMutex, LockGuard};\n-\n-pub struct LittleLock {\n-    priv l: StaticNativeMutex,\n-}\n-\n-pub struct LittleGuard<'a> {\n-    priv l: LockGuard<'a>\n-}\n-\n-impl Drop for LittleLock {\n-    fn drop(&mut self) {\n-        unsafe { self.l.destroy(); }\n-    }\n-}\n-\n-impl LittleLock {\n-    pub fn new() -> LittleLock {\n-        unsafe { LittleLock { l: StaticNativeMutex::new() } }\n-    }\n-\n-    pub unsafe fn lock<'a>(&'a mut self) -> LittleGuard<'a> {\n-        LittleGuard { l: self.l.lock() }\n-    }\n-\n-    pub unsafe fn try_lock<'a>(&'a mut self) -> Option<LittleGuard<'a>> {\n-        self.l.trylock().map(|guard| LittleGuard { l: guard })\n-    }\n-\n-    pub unsafe fn signal(&mut self) {\n-        self.l.signal_noguard();\n-    }\n-}\n-\n-impl<'a> LittleGuard<'a> {\n-    pub unsafe fn wait(&mut self) {\n-        self.l.wait();\n-    }\n-}\n+use unstable::mutex::NativeMutex;\n \n struct ExData<T> {\n-    lock: LittleLock,\n+    lock: NativeMutex,\n     failed: bool,\n     data: T,\n }\n@@ -83,7 +43,7 @@ impl<T:Send> Clone for Exclusive<T> {\n impl<T:Send> Exclusive<T> {\n     pub fn new(user_data: T) -> Exclusive<T> {\n         let data = ExData {\n-            lock: LittleLock::new(),\n+            lock: unsafe {NativeMutex::new()},\n             failed: false,\n             data: user_data\n         };\n@@ -92,8 +52,8 @@ impl<T:Send> Exclusive<T> {\n         }\n     }\n \n-    // Exactly like std::arc::MutexArc,access(), but with the LittleLock\n-    // instead of a proper mutex. Same reason for being unsafe.\n+    // Exactly like sync::MutexArc.access(). Same reason for being\n+    // unsafe.\n     //\n     // Currently, scheduling operations (i.e., descheduling, receiving on a pipe,\n     // accessing the provided condition variable) are prohibited while inside\n@@ -119,14 +79,14 @@ impl<T:Send> Exclusive<T> {\n     #[inline]\n     pub unsafe fn hold_and_signal(&self, f: |x: &mut T|) {\n         let rec = self.x.get();\n-        let _l = (*rec).lock.lock();\n+        let mut guard = (*rec).lock.lock();\n         if (*rec).failed {\n             fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n         }\n         (*rec).failed = true;\n         f(&mut (*rec).data);\n         (*rec).failed = false;\n-        (*rec).lock.signal();\n+        guard.signal();\n     }\n \n     #[inline]"}]}