{"sha": "e1a2649aff0a9387fb14646a56cb652061bc42ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxYTI2NDlhZmYwYTkzODdmYjE0NjQ2YTU2Y2I2NTIwNjFiYzQyZWM=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-14T19:55:18Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-14T19:55:18Z"}, "message": "Merge #1144\n\n1144: Refactor method candidate generation a bit r=flodiebold a=flodiebold\n\nThis fixes the order in which candidates are chosen a bit (not completely though, as the ignored test demonstrates), and makes autoderef work with trait methods.\r\nAs a side effect, this also makes completion of trait methods work :)\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "b8275843aa56b922b6325b50be2aae063234cc2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8275843aa56b922b6325b50be2aae063234cc2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1a2649aff0a9387fb14646a56cb652061bc42ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1a2649aff0a9387fb14646a56cb652061bc42ec", "html_url": "https://github.com/rust-lang/rust/commit/e1a2649aff0a9387fb14646a56cb652061bc42ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1a2649aff0a9387fb14646a56cb652061bc42ec/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "88be6f32172813f53dae60d73c9f5deb0c3fb29f", "url": "https://api.github.com/repos/rust-lang/rust/commits/88be6f32172813f53dae60d73c9f5deb0c3fb29f", "html_url": "https://github.com/rust-lang/rust/commit/88be6f32172813f53dae60d73c9f5deb0c3fb29f"}, {"sha": "4f8a49f43cad086a656626c43062ff89b46f505a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f8a49f43cad086a656626c43062ff89b46f505a", "html_url": "https://github.com/rust-lang/rust/commit/4f8a49f43cad086a656626c43062ff89b46f505a"}], "stats": {"total": 231, "additions": 176, "deletions": 55}, "files": [{"sha": "f1bb13bc67142237dedbbce9ae773085980b93fc", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e1a2649aff0a9387fb14646a56cb652061bc42ec/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1a2649aff0a9387fb14646a56cb652061bc42ec/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=e1a2649aff0a9387fb14646a56cb652061bc42ec", "patch": "@@ -18,7 +18,7 @@ use ra_syntax::{\n \n use crate::{\n     HirDatabase, Function, Struct, Enum, Const, Static, Either, DefWithBody, PerNs, Name,\n-    AsName, Module, HirFileId, Crate, Trait, Resolver,\n+    AsName, Module, HirFileId, Crate, Trait, Resolver, Ty,\n     expr::{BodySourceMap, scope::{ScopeId, ExprScopes}},\n     ids::LocationCtx,\n     expr, AstId\n@@ -343,6 +343,16 @@ impl SourceAnalyzer {\n             .collect()\n     }\n \n+    pub fn iterate_method_candidates<T>(\n+        &self,\n+        db: &impl HirDatabase,\n+        ty: Ty,\n+        name: Option<&Name>,\n+        callback: impl FnMut(&Ty, Function) -> Option<T>,\n+    ) -> Option<T> {\n+        ty.iterate_method_candidates(db, &self.resolver, name, callback)\n+    }\n+\n     #[cfg(test)]\n     pub(crate) fn body_source_map(&self) -> Arc<BodySourceMap> {\n         self.body_source_map.clone().unwrap()"}, {"sha": "667b6609520f6b09beae5d0983b5d9af1d7b8d95", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 73, "deletions": 53, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/e1a2649aff0a9387fb14646a56cb652061bc42ec/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1a2649aff0a9387fb14646a56cb652061bc42ec/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=e1a2649aff0a9387fb14646a56cb652061bc42ec", "patch": "@@ -129,85 +129,105 @@ impl Ty {\n         name: &Name,\n         resolver: &Resolver,\n     ) -> Option<(Ty, Function)> {\n-        // FIXME: trait methods should be used before autoderefs\n-        // (and we need to do autoderefs for trait method calls as well)\n-        let inherent_method = self.clone().iterate_methods(db, |ty, f| {\n-            let sig = f.signature(db);\n-            if sig.name() == name && sig.has_self_param() {\n-                Some((ty.clone(), f))\n-            } else {\n-                None\n-            }\n-        });\n-        inherent_method.or_else(|| self.lookup_trait_method(db, name, resolver))\n+        self.iterate_method_candidates(db, resolver, Some(name), |ty, f| Some((ty.clone(), f)))\n     }\n \n-    fn lookup_trait_method(\n+    // This would be nicer if it just returned an iterator, but that runs into\n+    // lifetime problems, because we need to borrow temp `CrateImplBlocks`.\n+    pub(crate) fn iterate_method_candidates<T>(\n         self,\n         db: &impl HirDatabase,\n-        name: &Name,\n         resolver: &Resolver,\n-    ) -> Option<(Ty, Function)> {\n-        let mut candidates = Vec::new();\n-        for t in resolver.traits_in_scope() {\n+        name: Option<&Name>,\n+        mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n+    ) -> Option<T> {\n+        // For method calls, rust first does any number of autoderef, and then one\n+        // autoref (i.e. when the method takes &self or &mut self). We just ignore\n+        // the autoref currently -- when we find a method matching the given name,\n+        // we assume it fits.\n+\n+        // Also note that when we've got a receiver like &S, even if the method we\n+        // find in the end takes &self, we still do the autoderef step (just as\n+        // rustc does an autoderef and then autoref again).\n+\n+        for derefed_ty in self.autoderef(db) {\n+            if let Some(result) = derefed_ty.iterate_inherent_methods(db, name, &mut callback) {\n+                return Some(result);\n+            }\n+            if let Some(result) =\n+                derefed_ty.iterate_trait_method_candidates(db, resolver, name, &mut callback)\n+            {\n+                return Some(result);\n+            }\n+        }\n+        None\n+    }\n+\n+    fn iterate_trait_method_candidates<T>(\n+        &self,\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        name: Option<&Name>,\n+        mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n+    ) -> Option<T> {\n+        'traits: for t in resolver.traits_in_scope() {\n             let data = t.trait_data(db);\n+            // we'll be lazy about checking whether the type implements the\n+            // trait, but if we find out it doesn't, we'll skip the rest of the\n+            // iteration\n+            let mut known_implemented = false;\n             for item in data.items() {\n                 match item {\n                     &TraitItem::Function(m) => {\n                         let sig = m.signature(db);\n-                        if sig.name() == name && sig.has_self_param() {\n-                            candidates.push((t, m));\n+                        if name.map_or(true, |name| sig.name() == name) && sig.has_self_param() {\n+                            if !known_implemented {\n+                                let trait_ref = TraitRef {\n+                                    trait_: t,\n+                                    substs: fresh_substs_for_trait(db, t, self.clone()),\n+                                };\n+                                let (trait_ref, _) = super::traits::canonicalize(trait_ref);\n+                                if db.implements(trait_ref).is_none() {\n+                                    continue 'traits;\n+                                }\n+                            }\n+                            known_implemented = true;\n+                            if let Some(result) = callback(self, m) {\n+                                return Some(result);\n+                            }\n                         }\n                     }\n                     _ => {}\n                 }\n             }\n         }\n-        candidates.retain(|(t, _m)| {\n-            let trait_ref =\n-                TraitRef { trait_: *t, substs: fresh_substs_for_trait(db, *t, self.clone()) };\n-            let (trait_ref, _) = super::traits::canonicalize(trait_ref);\n-            db.implements(trait_ref).is_some()\n-        });\n-        // FIXME if there's multiple candidates here, that's an ambiguity error\n-        let (_chosen_trait, chosen_method) = candidates.first()?;\n-        // FIXME return correct receiver type\n-        Some((self.clone(), *chosen_method))\n+        None\n     }\n \n-    // This would be nicer if it just returned an iterator, but that runs into\n-    // lifetime problems, because we need to borrow temp `CrateImplBlocks`.\n-    pub fn iterate_methods<T>(\n-        self,\n+    fn iterate_inherent_methods<T>(\n+        &self,\n         db: &impl HirDatabase,\n+        name: Option<&Name>,\n         mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n     ) -> Option<T> {\n-        // For method calls, rust first does any number of autoderef, and then one\n-        // autoref (i.e. when the method takes &self or &mut self). We just ignore\n-        // the autoref currently -- when we find a method matching the given name,\n-        // we assume it fits.\n-\n-        // Also note that when we've got a receiver like &S, even if the method we\n-        // find in the end takes &self, we still do the autoderef step (just as\n-        // rustc does an autoderef and then autoref again).\n+        let krate = match def_crate(db, self) {\n+            Some(krate) => krate,\n+            None => return None,\n+        };\n+        let impls = db.impls_in_crate(krate);\n \n-        for derefed_ty in self.autoderef(db) {\n-            let krate = match def_crate(db, &derefed_ty) {\n-                Some(krate) => krate,\n-                None => continue,\n-            };\n-            let impls = db.impls_in_crate(krate);\n-\n-            for impl_block in impls.lookup_impl_blocks(&derefed_ty) {\n-                for item in impl_block.items(db) {\n-                    match item {\n-                        ImplItem::Method(f) => {\n-                            if let Some(result) = callback(&derefed_ty, f) {\n+        for impl_block in impls.lookup_impl_blocks(self) {\n+            for item in impl_block.items(db) {\n+                match item {\n+                    ImplItem::Method(f) => {\n+                        let sig = f.signature(db);\n+                        if name.map_or(true, |name| sig.name() == name) && sig.has_self_param() {\n+                            if let Some(result) = callback(self, f) {\n                                 return Some(result);\n                             }\n                         }\n-                        _ => {}\n                     }\n+                    _ => {}\n                 }\n             }\n         }"}, {"sha": "82c4aeddb72542bee215bb24bb8e19453df64721", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e1a2649aff0a9387fb14646a56cb652061bc42ec/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1a2649aff0a9387fb14646a56cb652061bc42ec/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=e1a2649aff0a9387fb14646a56cb652061bc42ec", "patch": "@@ -2336,6 +2336,66 @@ fn test() -> u64 {\n     );\n }\n \n+#[ignore]\n+#[test]\n+fn method_resolution_trait_before_autoref() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl S { fn foo(&self) -> i8 { 0 } }\n+impl Trait for S { fn foo(self) -> u128 { 0 } }\n+fn test() { S.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"u128\");\n+}\n+\n+#[test]\n+fn method_resolution_trait_before_autoderef() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl S { fn foo(self) -> i8 { 0 } }\n+impl Trait for &S { fn foo(self) -> u128 { 0 } }\n+fn test() { (&S).foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"u128\");\n+}\n+\n+#[test]\n+fn method_resolution_impl_before_trait() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl S { fn foo(self) -> i8 { 0 } }\n+impl Trait for S { fn foo(self) -> u128 { 0 } }\n+fn test() { S.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"i8\");\n+}\n+\n+#[test]\n+fn method_resolution_trait_autoderef() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl Trait for S { fn foo(self) -> u128 { 0 } }\n+fn test() { (&S).foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"u128\");\n+}\n+\n fn type_at_pos(db: &MockDatabase, pos: FilePosition) -> String {\n     let file = db.parse(pos.file_id);\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();\n@@ -2344,6 +2404,11 @@ fn type_at_pos(db: &MockDatabase, pos: FilePosition) -> String {\n     ty.display(db).to_string()\n }\n \n+fn type_at(content: &str) -> String {\n+    let (db, file_pos) = MockDatabase::with_position(content);\n+    type_at_pos(&db, file_pos)\n+}\n+\n fn infer(content: &str) -> String {\n     let (db, _, file_id) = MockDatabase::with_single_file(content);\n     let source_file = db.parse(file_id);"}, {"sha": "e34ddf24af482cfa606a9e268a038a45b97cfbd0", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e1a2649aff0a9387fb14646a56cb652061bc42ec/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1a2649aff0a9387fb14646a56cb652061bc42ec/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=e1a2649aff0a9387fb14646a56cb652061bc42ec", "patch": "@@ -37,7 +37,7 @@ fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty)\n }\n \n fn complete_methods(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) {\n-    receiver.iterate_methods(ctx.db, |_ty, func| {\n+    ctx.analyzer.iterate_method_candidates(ctx.db, receiver, None, |_ty, func| {\n         let sig = func.signature(ctx.db);\n         if sig.has_self_param() {\n             acc.add_function(ctx, func);\n@@ -195,6 +195,32 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_trait_method_completion() {\n+        assert_debug_snapshot_matches!(\n+            do_ref_completion(\n+                r\"\n+            struct A {}\n+            trait Trait { fn the_method(&self); }\n+            impl Trait for A {}\n+            fn foo(a: A) {\n+               a.<|>\n+            }\n+            \",\n+            ),\n+            @r###\"[\n+    CompletionItem {\n+        label: \"the_method\",\n+        source_range: [151; 151),\n+        delete: [151; 151),\n+        insert: \"the_method()$0\",\n+        kind: Method,\n+        detail: \"fn the_method(&self)\"\n+    }\n+]\"###\n+        );\n+    }\n+\n     #[test]\n     fn test_no_non_self_method() {\n         assert_debug_snapshot_matches!("}]}