{"sha": "4007006574561280139659a42000321020d589ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwMDcwMDY1NzQ1NjEyODAxMzk2NTlhNDIwMDAzMjEwMjBkNTg5ZmY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-30T22:40:25Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-08-31T04:08:07Z"}, "message": "Convert compiletest to istrs. Issue #855", "tree": {"sha": "516ff501d7c18d7b37661bcf560a9a1e11b9cc97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/516ff501d7c18d7b37661bcf560a9a1e11b9cc97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4007006574561280139659a42000321020d589ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4007006574561280139659a42000321020d589ff", "html_url": "https://github.com/rust-lang/rust/commit/4007006574561280139659a42000321020d589ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4007006574561280139659a42000321020d589ff/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb70267e5e731a5b489aabf0e2214a9c4a264e26", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb70267e5e731a5b489aabf0e2214a9c4a264e26", "html_url": "https://github.com/rust-lang/rust/commit/eb70267e5e731a5b489aabf0e2214a9c4a264e26"}], "stats": {"total": 461, "additions": 248, "deletions": 213}, "files": [{"sha": "bc029b407b8fe8a7b698ddd87f05dcfb51dcddc6", "filename": "src/test/compiletest/compiletest.rs", "status": "modified", "additions": 57, "deletions": 44, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/4007006574561280139659a42000321020d589ff/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007006574561280139659a42000321020d589ff/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fcompiletest.rs?ref=4007006574561280139659a42000321020d589ff", "patch": "@@ -23,14 +23,13 @@ import common::mode;\n import util::logv;\n \n fn main(args: [str]) {\n-\n+    let args = istr::from_estrs(args);\n     let config = parse_config(args);\n     log_config(config);\n     run_tests(config);\n }\n \n-fn parse_config(args: &[str]) -> config {\n-    let args = istr::from_estrs(args);\n+fn parse_config(args: &[istr]) -> config {\n     let opts =\n         [getopts::reqopt(~\"compile-lib-path\"),\n          getopts::reqopt(~\"run-lib-path\"),\n@@ -60,7 +59,7 @@ fn parse_config(args: &[str]) -> config {\n          src_base: getopts::opt_str(match, ~\"src-base\"),\n          build_base: getopts::opt_str(match, ~\"build-base\"),\n          stage_id: getopts::opt_str(match, ~\"stage-id\"),\n-         mode: str_mode(istr::to_estr(getopts::opt_str(match, ~\"mode\"))),\n+         mode: str_mode(getopts::opt_str(match, ~\"mode\")),\n          run_ignored: getopts::opt_present(match, ~\"ignored\"),\n          filter:\n              if vec::len(match.free) > 0u {\n@@ -73,36 +72,49 @@ fn parse_config(args: &[str]) -> config {\n \n fn log_config(config: &config) {\n     let c = config;\n-    logv(c, #fmt[\"configuration:\"]);\n-    logv(c, #fmt[\"compile_lib_path: %s\",\n-                 istr::to_estr(config.compile_lib_path)]);\n-    logv(c, #fmt[\"run_lib_path: %s\", istr::to_estr(config.run_lib_path)]);\n-    logv(c, #fmt[\"rustc_path: %s\", istr::to_estr(config.rustc_path)]);\n-    logv(c, #fmt[\"src_base: %s\", istr::to_estr(config.src_base)]);\n-    logv(c, #fmt[\"build_base: %s\", istr::to_estr(config.build_base)]);\n-    logv(c, #fmt[\"stage_id: %s\", istr::to_estr(config.stage_id)]);\n-    logv(c, #fmt[\"mode: %s\", mode_str(config.mode)]);\n-    logv(c, #fmt[\"run_ignored: %b\", config.run_ignored]);\n-    logv(c, #fmt[\"filter: %s\", opt_str(config.filter)]);\n-    logv(c, #fmt[\"runtool: %s\", opt_str(config.runtool)]);\n-    logv(c, #fmt[\"rustcflags: %s\", opt_str(config.rustcflags)]);\n-    logv(c, #fmt[\"verbose: %b\", config.verbose]);\n-    logv(c, #fmt[\"\\n\"]);\n+    logv(c, istr::from_estr(\n+        #fmt[\"configuration:\"]));\n+    logv(c, istr::from_estr(\n+        #fmt[\"compile_lib_path: %s\",\n+             istr::to_estr(config.compile_lib_path)]));\n+    logv(c, istr::from_estr(\n+        #fmt[\"run_lib_path: %s\", istr::to_estr(config.run_lib_path)]));\n+    logv(c, istr::from_estr(\n+        #fmt[\"rustc_path: %s\", istr::to_estr(config.rustc_path)]));\n+    logv(c, istr::from_estr(\n+        #fmt[\"src_base: %s\", istr::to_estr(config.src_base)]));\n+    logv(c, istr::from_estr(\n+        #fmt[\"build_base: %s\", istr::to_estr(config.build_base)]));\n+    logv(c, istr::from_estr(\n+        #fmt[\"stage_id: %s\", istr::to_estr(config.stage_id)]));\n+    logv(c, istr::from_estr(\n+        #fmt[\"mode: %s\", istr::to_estr(mode_str(config.mode))]));\n+    logv(c, istr::from_estr(\n+        #fmt[\"run_ignored: %b\", config.run_ignored]));\n+    logv(c, istr::from_estr(\n+        #fmt[\"filter: %s\", istr::to_estr(opt_str(config.filter))]));\n+    logv(c, istr::from_estr(\n+        #fmt[\"runtool: %s\", istr::to_estr(opt_str(config.runtool))]));\n+    logv(c, istr::from_estr(\n+        #fmt[\"rustcflags: %s\", istr::to_estr(opt_str(config.rustcflags))]));\n+    logv(c, istr::from_estr(\n+        #fmt[\"verbose: %b\", config.verbose]));\n+    logv(c, istr::from_estr(#fmt[\"\\n\"]));\n }\n \n-fn opt_str(maybestr: option::t<istr>) -> str {\n+fn opt_str(maybestr: option::t<istr>) -> istr {\n     alt maybestr {\n-      option::some(s) { istr::to_estr(s) }\n-      option::none. { \"(none)\" }\n+      option::some(s) { s }\n+      option::none. { ~\"(none)\" }\n     }\n }\n \n fn str_opt(maybestr: &istr) -> option::t<istr> {\n     if maybestr != ~\"(none)\" { option::some(maybestr) } else { option::none }\n }\n \n-fn str_mode(s: str) -> mode {\n-    alt s {\n+fn str_mode(s: &istr) -> mode {\n+    alt istr::to_estr(s) {\n       \"compile-fail\" { mode_compile_fail }\n       \"run-fail\" { mode_run_fail }\n       \"run-pass\" { mode_run_pass }\n@@ -111,12 +123,12 @@ fn str_mode(s: str) -> mode {\n     }\n }\n \n-fn mode_str(mode: mode) -> str {\n+fn mode_str(mode: mode) -> istr {\n     alt mode {\n-      mode_compile_fail. { \"compile-fail\" }\n-      mode_run_fail. { \"run-fail\" }\n-      mode_run_pass. { \"run-pass\" }\n-      mode_pretty. { \"pretty\" }\n+      mode_compile_fail. { ~\"compile-fail\" }\n+      mode_run_fail. { ~\"run-fail\" }\n+      mode_run_pass. { ~\"run-pass\" }\n+      mode_pretty. { ~\"pretty\" }\n     }\n }\n \n@@ -146,23 +158,22 @@ fn make_tests(cx: &cx) -> tests_and_conv_fn {\n     let configport = port::<[u8]>();\n     let tests = [];\n     for file: istr in fs::list_dir(cx.config.src_base) {\n-        let file = istr::to_estr(file);\n-        log #fmt[\"inspecting file %s\", file];\n+        log #fmt[\"inspecting file %s\", istr::to_estr(file)];\n         if is_test(cx.config, file) {\n             tests += [make_test(cx, file, configport)];\n         }\n     }\n     ret {tests: tests, to_task: bind closure_to_task(cx, configport, _)};\n }\n \n-fn is_test(config: &config, testfile: &str) -> bool {\n+fn is_test(config: &config, testfile: &istr) -> bool {\n     // Pretty-printer does not work with .rc files yet\n     let valid_extensions = alt config.mode {\n       mode_pretty. { [~\".rs\"] }\n       _ { [~\".rc\", ~\".rs\"] }\n     };\n     let invalid_prefixes = [~\".\", ~\"#\", ~\"~\"];\n-    let name = fs::basename(istr::from_estr(testfile));\n+    let name = fs::basename(testfile);\n \n     let valid = false;\n \n@@ -177,15 +188,17 @@ fn is_test(config: &config, testfile: &str) -> bool {\n     ret valid;\n }\n \n-fn make_test(cx: &cx, testfile: &str, configport: &port<[u8]>) ->\n+fn make_test(cx: &cx, testfile: &istr, configport: &port<[u8]>) ->\n    test::test_desc {\n     {name: make_test_name(cx.config, testfile),\n      fn: make_test_closure(testfile, chan(configport)),\n      ignore: header::is_test_ignored(cx.config, testfile)}\n }\n \n-fn make_test_name(config: &config, testfile: &str) -> str {\n-    #fmt[\"[%s] %s\", mode_str(config.mode), testfile]\n+fn make_test_name(config: &config, testfile: &istr) -> str {\n+    #fmt[\"[%s] %s\",\n+         istr::to_estr(mode_str(config.mode)),\n+         istr::to_estr(testfile)]\n }\n \n /*\n@@ -207,13 +220,13 @@ up. Then we'll spawn that data into another task and return the task.\n Really convoluted. Need to think up of a better definition for tests.\n */\n \n-fn make_test_closure(testfile: &str, configchan: chan<[u8]>) ->\n+fn make_test_closure(testfile: &istr, configchan: chan<[u8]>) ->\n    test::test_fn {\n     bind send_config(testfile, configchan)\n }\n \n-fn send_config(testfile: str, configchan: chan<[u8]>) {\n-    send(configchan, str::bytes(testfile));\n+fn send_config(testfile: istr, configchan: chan<[u8]>) {\n+    send(configchan, istr::bytes(testfile));\n }\n \n /*\n@@ -237,11 +250,11 @@ fn closure_to_task(cx: cx, configport: port<[u8]>, testfn: &fn()) ->\n     let src_base = cx.config.src_base;\n     let build_base = cx.config.build_base;\n     let stage_id = cx.config.stage_id;\n-    let mode = istr::from_estr(mode_str(cx.config.mode));\n+    let mode = mode_str(cx.config.mode);\n     let run_ignored = cx.config.run_ignored;\n-    let filter = istr::from_estr(opt_str(cx.config.filter));\n-    let runtool = istr::from_estr(opt_str(cx.config.runtool));\n-    let rustcflags = istr::from_estr(opt_str(cx.config.rustcflags));\n+    let filter = opt_str(cx.config.filter);\n+    let runtool = opt_str(cx.config.runtool);\n+    let rustcflags = opt_str(cx.config.rustcflags);\n     let verbose = cx.config.verbose;\n     let chan = cx.procsrv.chan;\n \n@@ -277,7 +290,7 @@ fn run_test_task(compile_lib_path: -istr, run_lib_path: -istr,\n          src_base: src_base,\n          build_base: build_base,\n          stage_id: stage_id,\n-         mode: str_mode(istr::to_estr(mode)),\n+         mode: str_mode(mode),\n          run_ignored: run_ignored,\n          filter: str_opt(opt_filter),\n          runtool: str_opt(opt_runtool),"}, {"sha": "d953a903c39b2192f82e1ab341464e0830a91fbe", "filename": "src/test/compiletest/header.rs", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/4007006574561280139659a42000321020d589ff/src%2Ftest%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007006574561280139659a42000321020d589ff/src%2Ftest%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fheader.rs?ref=4007006574561280139659a42000321020d589ff", "patch": "@@ -12,24 +12,24 @@ export is_test_ignored;\n \n type test_props = {\n     // Lines that should be expected, in order, on standard out\n-    error_patterns: [str],\n+    error_patterns: [istr],\n     // Extra flags to pass to the compiler\n-    compile_flags: option::t<str>,\n+    compile_flags: option::t<istr>,\n     // If present, the name of a file that this test should match when\n     // pretty-printed\n-    pp_exact: option::t<str>,\n+    pp_exact: option::t<istr>,\n     // FIXME: no-valgrind is a temporary directive until all of run-fail\n     // is valgrind-clean\n     no_valgrind: bool\n };\n \n // Load any test directives embedded in the file\n-fn load_props(testfile: &str) -> test_props {\n+fn load_props(testfile: &istr) -> test_props {\n     let error_patterns = [];\n     let compile_flags = option::none;\n     let pp_exact = option::none;\n     let no_valgrind = false;\n-    for each ln: str in iter_header(testfile) {\n+    for each ln: istr in iter_header(testfile) {\n         alt parse_error_pattern(ln) {\n           option::some(ep) { error_patterns += [ep]; }\n           option::none. { }\n@@ -44,7 +44,7 @@ fn load_props(testfile: &str) -> test_props {\n         }\n \n         if no_valgrind == false {\n-            no_valgrind = parse_name_directive(ln, \"no-valgrind\");\n+            no_valgrind = parse_name_directive(ln, ~\"no-valgrind\");\n         }\n     }\n     ret {\n@@ -55,70 +55,72 @@ fn load_props(testfile: &str) -> test_props {\n     };\n }\n \n-fn is_test_ignored(config: &config, testfile: &str) -> bool {\n+fn is_test_ignored(config: &config, testfile: &istr) -> bool {\n     let found = false;\n-    for each ln: str in iter_header(testfile) {\n+    for each ln: istr in iter_header(testfile) {\n         // FIXME: Can't return or break from iterator\n         found = found\n-            || parse_name_directive(ln, \"xfail-\"\n-                                    + istr::to_estr(config.stage_id));\n+            || parse_name_directive(ln, ~\"xfail-\"\n+                                    + config.stage_id);\n         if (config.mode == common::mode_pretty) {\n             found = found\n-                || parse_name_directive(ln, \"xfail-pretty\");\n+                || parse_name_directive(ln, ~\"xfail-pretty\");\n         }\n     }\n     ret found;\n }\n \n-iter iter_header(testfile: &str) -> str {\n-    let rdr = io::file_reader(istr::from_estr(testfile));\n+iter iter_header(testfile: &istr) -> istr {\n+    let rdr = io::file_reader(testfile);\n     while !rdr.eof() {\n-        let ln = istr::to_estr(rdr.read_line());\n+        let ln = rdr.read_line();\n \n         // Assume that any directives will be found before the first\n         // module or function. This doesn't seem to be an optimization\n         // with a warm page cache. Maybe with a cold one.\n-        if str::starts_with(ln, \"fn\") || str::starts_with(ln, \"mod\") {\n+        if istr::starts_with(ln, ~\"fn\")\n+            || istr::starts_with(ln, ~\"mod\") {\n             break;\n         } else { put ln; }\n     }\n }\n \n-fn parse_error_pattern(line: &str) -> option::t<str> {\n-    parse_name_value_directive(line, \"error-pattern\")\n+fn parse_error_pattern(line: &istr) -> option::t<istr> {\n+    parse_name_value_directive(line, ~\"error-pattern\")\n }\n \n-fn parse_compile_flags(line: &str) -> option::t<str> {\n-    parse_name_value_directive(line, \"compile-flags\")\n+fn parse_compile_flags(line: &istr) -> option::t<istr> {\n+    parse_name_value_directive(line, ~\"compile-flags\")\n }\n \n-fn parse_pp_exact(line: &str, testfile: &str) -> option::t<str> {\n-    alt parse_name_value_directive(line, \"pp-exact\") {\n+fn parse_pp_exact(line: &istr, testfile: &istr) -> option::t<istr> {\n+    alt parse_name_value_directive(line, ~\"pp-exact\") {\n       option::some(s) { option::some(s) }\n       option::none. {\n-        if parse_name_directive(line, \"pp-exact\") {\n-            option::some(istr::to_estr(\n-                fs::basename(istr::from_estr(testfile))))\n+        if parse_name_directive(line, ~\"pp-exact\") {\n+            option::some(fs::basename(testfile))\n         } else {\n             option::none\n         }\n       }\n     }\n }\n \n-fn parse_name_directive(line: &str, directive: &str) -> bool {\n-    str::find(line, directive) >= 0\n+fn parse_name_directive(line: &istr, directive: &istr) -> bool {\n+    istr::find(line, directive) >= 0\n }\n \n-fn parse_name_value_directive(line: &str,\n-                              directive: &str) -> option::t<str> {\n-    let keycolon = directive + \":\";\n-    if str::find(line, keycolon) >= 0 {\n-        let colon = str::find(line, keycolon) as uint;\n+fn parse_name_value_directive(line: &istr,\n+                              directive: &istr) -> option::t<istr> {\n+    let keycolon = directive + ~\":\";\n+    if istr::find(line, keycolon) >= 0 {\n+        let colon = istr::find(line, keycolon) as uint;\n         let value =\n-            str::slice(line, colon + str::byte_len(keycolon),\n-                       str::byte_len(line));\n-        log #fmt(\"%s: %s\", directive, value);\n+            istr::slice(line, colon + istr::byte_len(keycolon),\n+                       istr::byte_len(line));\n+        log #fmt(\"%s: %s\",\n+                 istr::to_estr(directive),\n+                 istr::to_estr(value));\n         option::some(value)\n     } else { option::none }\n }"}, {"sha": "3fb2bfc37002fda50232a8615d409687f66714c4", "filename": "src/test/compiletest/procsrv.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4007006574561280139659a42000321020d589ff/src%2Ftest%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007006574561280139659a42000321020d589ff/src%2Ftest%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fprocsrv.rs?ref=4007006574561280139659a42000321020d589ff", "patch": "@@ -54,12 +54,12 @@ fn close(handle: &handle) {\n     task::join(option::get(handle.task));\n }\n \n-fn run(handle: &handle, lib_path: &str, prog: &str, args: &[str],\n-       input: &option::t<str>) -> {status: int, out: str, err: str} {\n+fn run(handle: &handle, lib_path: &istr, prog: &istr, args: &[istr],\n+       input: &option::t<istr>) -> {status: int, out: istr, err: istr} {\n     let p = port();\n     let ch = chan(p);\n     send(handle.chan,\n-         exec(str::bytes(lib_path), str::bytes(prog), clone_vecstr(args),\n+         exec(istr::bytes(lib_path), istr::bytes(prog), clone_vecstr(args),\n               ch));\n     let resp = recv(p);\n \n@@ -70,23 +70,23 @@ fn run(handle: &handle, lib_path: &str, prog: &str, args: &[str],\n     ret {status: status, out: output, err: errput};\n }\n \n-fn writeclose(fd: int, s: &option::t<str>) {\n+fn writeclose(fd: int, s: &option::t<istr>) {\n     if option::is_some(s) {\n         let writer = io::new_writer(io::fd_buf_writer(fd, option::none));\n-        writer.write_str(istr::from_estr(option::get(s)));\n+        writer.write_str(option::get(s));\n     }\n \n     os::libc::close(fd);\n }\n \n-fn readclose(fd: int) -> str {\n+fn readclose(fd: int) -> istr {\n     // Copied from run::program_output\n     let file = os::fd_FILE(fd);\n     let reader = io::new_reader(io::FILE_buf_reader(file, option::none));\n-    let buf = \"\";\n+    let buf = ~\"\";\n     while !reader.eof() {\n         let bytes = reader.read_bytes(4096u);\n-        buf += str::unsafe_from_bytes(bytes);\n+        buf += istr::unsafe_from_bytes(bytes);\n     }\n     os::libc::fclose(file);\n     ret buf;\n@@ -115,8 +115,8 @@ fn worker(p: port<request>) {\n                 // the alt discriminant are wrong.\n                 alt recv(p) {\n                   exec(lib_path, prog, args, respchan) {\n-                    {lib_path: str::unsafe_from_bytes(lib_path),\n-                     prog: str::unsafe_from_bytes(prog),\n+                    {lib_path: istr::unsafe_from_bytes(lib_path),\n+                     prog: istr::unsafe_from_bytes(prog),\n                      args: clone_vecu8str(args),\n                      respchan: respchan}\n                   }\n@@ -129,8 +129,8 @@ fn worker(p: port<request>) {\n         let pipe_out = os::pipe();\n         let pipe_err = os::pipe();\n         let spawnproc =\n-            bind run::spawn_process(istr::from_estr(execparms.prog),\n-                                    istr::from_estrs(execparms.args),\n+            bind run::spawn_process(execparms.prog,\n+                                    execparms.args,\n                                     pipe_in.in, pipe_out.out, pipe_err.out);\n         let pid = with_lib_path(execparms.lib_path, spawnproc);\n \n@@ -152,35 +152,37 @@ fn worker(p: port<request>) {\n     }\n }\n \n-fn with_lib_path<@T>(path: &str, f: fn() -> T) -> T {\n-    let maybe_oldpath = getenv(istr::from_estr(util::lib_path_env_var()));\n+fn with_lib_path<@T>(path: &istr, f: fn() -> T) -> T {\n+    let maybe_oldpath = getenv(util::lib_path_env_var());\n     append_lib_path(path);\n     let res = f();\n     if option::is_some(maybe_oldpath) {\n-        export_lib_path(istr::to_estr(option::get(maybe_oldpath)));\n+        export_lib_path(option::get(maybe_oldpath));\n     } else {\n         // FIXME: This should really be unset but we don't have that yet\n-        export_lib_path(\"\");\n+        export_lib_path(~\"\");\n     }\n     ret res;\n }\n \n-fn append_lib_path(path: &str) { export_lib_path(util::make_new_path(path)); }\n+fn append_lib_path(path: &istr) {\n+    export_lib_path(util::make_new_path(path));\n+}\n \n-fn export_lib_path(path: &str) {\n-    setenv(istr::from_estr(util::lib_path_env_var()), istr::from_estr(path));\n+fn export_lib_path(path: &istr) {\n+    setenv(util::lib_path_env_var(), path);\n }\n \n-fn clone_vecstr(v: &[str]) -> [[u8]] {\n+fn clone_vecstr(v: &[istr]) -> [[u8]] {\n     let r = [];\n-    for t: str in vec::slice(v, 0u, vec::len(v)) { r += [str::bytes(t)]; }\n+    for t: istr in vec::slice(v, 0u, vec::len(v)) { r += [istr::bytes(t)]; }\n     ret r;\n }\n \n-fn clone_vecu8str(v: &[[u8]]) -> [str] {\n+fn clone_vecu8str(v: &[[u8]]) -> [istr] {\n     let r = [];\n     for t in vec::slice(v, 0u, vec::len(v)) {\n-        r += [str::unsafe_from_bytes(t)];\n+        r += [istr::unsafe_from_bytes(t)];\n     }\n     ret r;\n }"}, {"sha": "3192e168c57ecc111e303d0e00ec7c49a6ed4b70", "filename": "src/test/compiletest/runtest.rs", "status": "modified", "additions": 120, "deletions": 104, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/4007006574561280139659a42000321020d589ff/src%2Ftest%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007006574561280139659a42000321020d589ff/src%2Ftest%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fruntest.rs?ref=4007006574561280139659a42000321020d589ff", "patch": "@@ -20,12 +20,12 @@ import util::logv;\n export run;\n \n fn run(cx: &cx, _testfile: -[u8]) {\n-    let testfile = str::unsafe_from_bytes(_testfile);\n+    let testfile = istr::unsafe_from_bytes(_testfile);\n     if cx.config.verbose {\n         // We're going to be dumping a lot of info. Start on a new line.\n         io::stdout().write_str(~\"\\n\\n\");\n     }\n-    log #fmt[\"running %s\", testfile];\n+    log #fmt[\"running %s\", istr::to_estr(testfile)];\n     let props = load_props(testfile);\n     alt cx.config.mode {\n       mode_compile_fail. { run_cfail_test(cx, props, testfile); }\n@@ -35,25 +35,25 @@ fn run(cx: &cx, _testfile: -[u8]) {\n     }\n }\n \n-fn run_cfail_test(cx: &cx, props: &test_props, testfile: &str) {\n+fn run_cfail_test(cx: &cx, props: &test_props, testfile: &istr) {\n     let procres = compile_test(cx, props, testfile);\n \n     if procres.status == 0 {\n-        fatal_procres(\"compile-fail test compiled successfully!\", procres);\n+        fatal_procres(~\"compile-fail test compiled successfully!\", procres);\n     }\n \n     check_error_patterns(props, testfile, procres);\n }\n \n-fn run_rfail_test(cx: &cx, props: &test_props, testfile: &str) {\n+fn run_rfail_test(cx: &cx, props: &test_props, testfile: &istr) {\n     let procres = compile_test(cx, props, testfile);\n \n-    if procres.status != 0 { fatal_procres(\"compilation failed!\", procres); }\n+    if procres.status != 0 { fatal_procres(~\"compilation failed!\", procres); }\n \n     procres = exec_compiled_test(cx, props, testfile);\n \n     if procres.status == 0 {\n-        fatal_procres(\"run-fail test didn't produce an error!\", procres);\n+        fatal_procres(~\"run-fail test didn't produce an error!\", procres);\n     }\n \n     // This is the value valgrind returns on failure\n@@ -62,42 +62,44 @@ fn run_rfail_test(cx: &cx, props: &test_props, testfile: &str) {\n     // exit code on the command-line (137)?\n     const valgrind_err: int = 9;\n     if procres.status == valgrind_err {\n-        fatal_procres(\"run-fail test isn't valgrind-clean!\", procres);\n+        fatal_procres(~\"run-fail test isn't valgrind-clean!\", procres);\n     }\n \n     check_error_patterns(props, testfile, procres);\n }\n \n-fn run_rpass_test(cx: &cx, props: &test_props, testfile: &str) {\n+fn run_rpass_test(cx: &cx, props: &test_props, testfile: &istr) {\n     let procres = compile_test(cx, props, testfile);\n \n-    if procres.status != 0 { fatal_procres(\"compilation failed!\", procres); }\n+    if procres.status != 0 { fatal_procres(~\"compilation failed!\", procres); }\n \n     procres = exec_compiled_test(cx, props, testfile);\n \n \n-    if procres.status != 0 { fatal_procres(\"test run failed!\", procres); }\n+    if procres.status != 0 { fatal_procres(~\"test run failed!\", procres); }\n }\n \n-fn run_pretty_test(cx: &cx, props: &test_props, testfile: &str) {\n+fn run_pretty_test(cx: &cx, props: &test_props, testfile: &istr) {\n     if option::is_some(props.pp_exact) {\n-        logv(cx.config, \"testing for exact pretty-printing\");\n-    } else { logv(cx.config, \"testing for converging pretty-printing\"); }\n+        logv(cx.config, ~\"testing for exact pretty-printing\");\n+    } else { logv(cx.config, ~\"testing for converging pretty-printing\"); }\n \n     let rounds =\n         alt props.pp_exact { option::some(_) { 1 } option::none. { 2 } };\n \n-    let srcs = [istr::to_estr(io::read_whole_file_str(\n-        istr::from_estr(testfile)))];\n+    let srcs = [io::read_whole_file_str(testfile)];\n \n     let round = 0;\n     while round < rounds {\n-        logv(cx.config, #fmt[\"pretty-printing round %d\", round]);\n+        logv(cx.config,\n+             istr::from_estr(#fmt[\"pretty-printing round %d\", round]));\n         let procres = print_source(cx, testfile, srcs[round]);\n \n         if procres.status != 0 {\n-            fatal_procres(#fmt[\"pretty-printing failed in round %d\", round],\n-                          procres);\n+            fatal_procres(\n+                istr::from_estr(#fmt[\"pretty-printing failed in round %d\",\n+                                     round]),\n+                procres);\n         }\n \n         srcs += [procres.stdout];\n@@ -107,20 +109,19 @@ fn run_pretty_test(cx: &cx, props: &test_props, testfile: &str) {\n     let expected =\n         alt props.pp_exact {\n           option::some(file) {\n-            let filepath = fs::connect(fs::dirname(\n-                istr::from_estr(testfile)), istr::from_estr(file));\n-            istr::to_estr(io::read_whole_file_str(filepath))\n+            let filepath = fs::connect(fs::dirname(testfile), file);\n+            io::read_whole_file_str(filepath)\n           }\n           option::none. { srcs[vec::len(srcs) - 2u] }\n         };\n     let actual = srcs[vec::len(srcs) - 1u];\n \n     if option::is_some(props.pp_exact) {\n         // Now we have to care about line endings\n-        let cr = \"\\r\";\n-        check (str::is_not_empty(cr));\n-        actual = str::replace(actual, cr, \"\");\n-        expected = str::replace(expected, cr, \"\");\n+        let cr = ~\"\\r\";\n+        check (istr::is_not_empty(cr));\n+        actual = istr::replace(actual, cr, ~\"\");\n+        expected = istr::replace(expected, cr, ~\"\");\n     }\n \n     compare_source(expected, actual);\n@@ -129,25 +130,25 @@ fn run_pretty_test(cx: &cx, props: &test_props, testfile: &str) {\n     let procres = typecheck_source(cx, testfile, actual);\n \n     if procres.status != 0 {\n-        fatal_procres(\"pretty-printed source does not typecheck\", procres);\n+        fatal_procres(~\"pretty-printed source does not typecheck\", procres);\n     }\n \n     ret;\n \n-    fn print_source(cx: &cx, testfile: &str, src: &str) -> procres {\n+    fn print_source(cx: &cx, testfile: &istr, src: &istr) -> procres {\n         compose_and_run(cx, testfile, make_pp_args,\n                         cx.config.compile_lib_path, option::some(src))\n     }\n \n-    fn make_pp_args(config: &config, _testfile: &str) -> procargs {\n-        let prog = istr::to_estr(config.rustc_path);\n-        let args = [\"-\", \"--pretty\", \"normal\"];\n+    fn make_pp_args(config: &config, _testfile: &istr) -> procargs {\n+        let prog = config.rustc_path;\n+        let args = [~\"-\", ~\"--pretty\", ~\"normal\"];\n         ret {prog: prog, args: args};\n     }\n \n-    fn compare_source(expected: &str, actual: &str) {\n+    fn compare_source(expected: &istr, actual: &istr) {\n         if expected != actual {\n-            error(\"pretty-printed source does match expected source\");\n+            error(~\"pretty-printed source does match expected source\");\n             let msg =\n                 #fmt[\"\\n\\\n expected:\\n\\\n@@ -159,39 +160,39 @@ actual:\\n\\\n %s\\n\\\n ------------------------------------------\\n\\\n \\n\",\n-                     expected, actual];\n+                     istr::to_estr(expected), istr::to_estr(actual)];\n             io::stdout().write_str(istr::from_estr(msg));\n             fail;\n         }\n     }\n \n-    fn typecheck_source(cx: &cx, testfile: &str, src: &str) -> procres {\n+    fn typecheck_source(cx: &cx, testfile: &istr, src: &istr) -> procres {\n         compose_and_run(cx, testfile, make_typecheck_args,\n                         cx.config.compile_lib_path, option::some(src))\n     }\n \n-    fn make_typecheck_args(config: &config, _testfile: &str) -> procargs {\n-        let prog = istr::to_estr(config.rustc_path);\n-        let args = [\"-\", \"--no-trans\", \"--lib\"];\n+    fn make_typecheck_args(config: &config, _testfile: &istr) -> procargs {\n+        let prog = config.rustc_path;\n+        let args = [~\"-\", ~\"--no-trans\", ~\"--lib\"];\n         ret {prog: prog, args: args};\n     }\n }\n \n-fn check_error_patterns(props: &test_props, testfile: &str,\n+fn check_error_patterns(props: &test_props, testfile: &istr,\n                         procres: &procres) {\n     if vec::is_empty(props.error_patterns) {\n-        fatal(\"no error pattern specified in \" + testfile);\n+        fatal(~\"no error pattern specified in \" + testfile);\n     }\n \n     if procres.status == 0 {\n-        fatal(\"process did not return an error status\");\n+        fatal(~\"process did not return an error status\");\n     }\n \n     let next_err_idx = 0u;\n     let next_err_pat = props.error_patterns[next_err_idx];\n-    for line: str in str::split(procres.stdout, '\\n' as u8) {\n-        if str::find(line, next_err_pat) > 0 {\n-            log #fmt[\"found error pattern %s\", next_err_pat];\n+    for line: istr in istr::split(procres.stdout, '\\n' as u8) {\n+        if istr::find(line, next_err_pat) > 0 {\n+            log #fmt[\"found error pattern %s\", istr::to_estr(next_err_pat)];\n             next_err_idx += 1u;\n             if next_err_idx == vec::len(props.error_patterns) {\n                 log \"found all error patterns\";\n@@ -205,63 +206,67 @@ fn check_error_patterns(props: &test_props, testfile: &str,\n         vec::slice(props.error_patterns, next_err_idx,\n                    vec::len(props.error_patterns));\n     if vec::len(missing_patterns) == 1u {\n-        fatal_procres(#fmt[\"error pattern '%s' not found!\",\n-                           missing_patterns[0]], procres);\n+        fatal_procres(istr::from_estr(\n+            #fmt[\"error pattern '%s' not found!\",\n+                 istr::to_estr(missing_patterns[0])]), procres);\n     } else {\n-        for pattern: str in missing_patterns {\n-            error(#fmt[\"error pattern '%s' not found!\", pattern]);\n+        for pattern: istr in missing_patterns {\n+            error(istr::from_estr(\n+                #fmt[\"error pattern '%s' not found!\",\n+                     istr::to_estr(pattern)]));\n         }\n-        fatal_procres(\"multiple error patterns not found\", procres);\n+        fatal_procres(~\"multiple error patterns not found\", procres);\n     }\n }\n \n-type procargs = {prog: str, args: [str]};\n+type procargs = {prog: istr, args: [istr]};\n \n-type procres = {status: int, stdout: str, stderr: str, cmdline: str};\n+type procres = {status: int, stdout: istr, stderr: istr, cmdline: istr};\n \n-fn compile_test(cx: &cx, props: &test_props, testfile: &str) -> procres {\n+fn compile_test(cx: &cx, props: &test_props, testfile: &istr) -> procres {\n     compose_and_run(cx, testfile, bind make_compile_args(_, props, _),\n                     cx.config.compile_lib_path, option::none)\n }\n \n-fn exec_compiled_test(cx: &cx, props: &test_props, testfile: &str) ->\n+fn exec_compiled_test(cx: &cx, props: &test_props, testfile: &istr) ->\n    procres {\n     compose_and_run(cx, testfile, bind make_run_args(_, props, _),\n                     cx.config.run_lib_path, option::none)\n }\n \n-fn compose_and_run(cx: &cx, testfile: &str,\n-                   make_args: fn(&config, &str) -> procargs, lib_path: &istr,\n-                   input: option::t<str>) -> procres {\n+fn compose_and_run(cx: &cx, testfile: &istr,\n+                   make_args: fn(&config, &istr) -> procargs,\n+                   lib_path: &istr,\n+                   input: option::t<istr>) -> procres {\n     let procargs = make_args(cx.config, testfile);\n     ret program_output(cx, testfile, lib_path, procargs.prog, procargs.args,\n                        input);\n }\n \n-fn make_compile_args(config: &config, props: &test_props, testfile: &str) ->\n+fn make_compile_args(config: &config, props: &test_props, testfile: &istr) ->\n    procargs {\n-    let prog = istr::to_estr(config.rustc_path);\n-    let args = [testfile, \"-o\", make_exe_name(config, testfile)];\n+    let prog = config.rustc_path;\n+    let args = [testfile, ~\"-o\", make_exe_name(config, testfile)];\n     let rustcflags = alt config.rustcflags {\n-      option::some(s) { option::some(istr::to_estr(s)) }\n+      option::some(s) { option::some(s) }\n       option::none. { option::none }\n     };\n     args += split_maybe_args(rustcflags);\n     args += split_maybe_args(props.compile_flags);\n     ret {prog: prog, args: args};\n }\n \n-fn make_exe_name(config: &config, testfile: &str) -> str {\n-    output_base_name(config, testfile) + istr::to_estr(os::exec_suffix())\n+fn make_exe_name(config: &config, testfile: &istr) -> istr {\n+    output_base_name(config, testfile) + os::exec_suffix()\n }\n \n-fn make_run_args(config: &config, props: &test_props, testfile: &str) ->\n+fn make_run_args(config: &config, props: &test_props, testfile: &istr) ->\n    procargs {\n     let toolargs = if !props.no_valgrind {\n         // If we've got another tool to run under (valgrind),\n         // then split apart its command\n         let runtool = alt config.runtool {\n-          option::some(s) { option::some(istr::to_estr(s)) }\n+          option::some(s) { option::some(s) }\n           option::none. { option::none }\n         };\n         split_maybe_args(runtool)\n@@ -271,33 +276,34 @@ fn make_run_args(config: &config, props: &test_props, testfile: &str) ->\n     ret {prog: args[0], args: vec::slice(args, 1u, vec::len(args))};\n }\n \n-fn split_maybe_args(argstr: &option::t<str>) -> [str] {\n-    fn rm_whitespace(v: &[str]) -> [str] {\n-        fn flt(s: &str) -> option::t<str> {\n+fn split_maybe_args(argstr: &option::t<istr>) -> [istr] {\n+    fn rm_whitespace(v: &[istr]) -> [istr] {\n+        fn flt(s: &istr) -> option::t<istr> {\n             if !is_whitespace(s) { option::some(s) } else { option::none }\n         }\n \n         // FIXME: This should be in std\n-        fn is_whitespace(s: str) -> bool {\n+        fn is_whitespace(s: &istr) -> bool {\n             for c: u8 in s { if c != ' ' as u8 { ret false; } }\n             ret true;\n         }\n         vec::filter_map(flt, v)\n     }\n \n     alt argstr {\n-      option::some(s) { rm_whitespace(str::split(s, ' ' as u8)) }\n+      option::some(s) { rm_whitespace(istr::split(s, ' ' as u8)) }\n       option::none. { [] }\n     }\n }\n \n-fn program_output(cx: &cx, testfile: &str, lib_path: &istr, prog: &str,\n-                  args: &[str], input: option::t<str>) -> procres {\n-    let lib_path = istr::to_estr(lib_path);\n+fn program_output(cx: &cx, testfile: &istr, lib_path: &istr, prog: &istr,\n+                  args: &[istr], input: option::t<istr>) -> procres {\n     let cmdline =\n         {\n             let cmdline = make_cmdline(lib_path, prog, args);\n-            logv(cx.config, #fmt[\"executing %s\", cmdline]);\n+            logv(cx.config,\n+                 istr::from_estr(#fmt[\"executing %s\",\n+                                      istr::to_estr(cmdline)]));\n             cmdline\n         };\n     let res = procsrv::run(cx.procsrv, lib_path, prog, args, input);\n@@ -308,76 +314,83 @@ fn program_output(cx: &cx, testfile: &str, lib_path: &istr, prog: &str,\n          cmdline: cmdline};\n }\n \n-fn make_cmdline(libpath: &str, prog: &str, args: &[str]) -> str {\n-    #fmt[\"%s %s %s\", lib_path_cmd_prefix(libpath), prog,\n-         str::connect(args, \" \")]\n+fn make_cmdline(libpath: &istr, prog: &istr, args: &[istr]) -> istr {\n+    istr::from_estr(#fmt[\"%s %s %s\",\n+                         istr::to_estr(lib_path_cmd_prefix(libpath)),\n+                         istr::to_estr(prog),\n+                         istr::to_estr(istr::connect(args, ~\" \"))])\n }\n \n // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n // for diagnostic purposes\n-fn lib_path_cmd_prefix(path: &str) -> str {\n-    #fmt[\"%s=\\\"%s\\\"\", util::lib_path_env_var(), util::make_new_path(path)]\n+fn lib_path_cmd_prefix(path: &istr) -> istr {\n+    istr::from_estr(#fmt[\"%s=\\\"%s\\\"\",\n+                         istr::to_estr(util::lib_path_env_var()),\n+                         istr::to_estr(util::make_new_path(path))])\n }\n \n-fn dump_output(config: &config, testfile: &str, out: &str, err: &str) {\n-    dump_output_file(config, testfile, out, \"out\");\n-    dump_output_file(config, testfile, err, \"err\");\n+fn dump_output(config: &config, testfile: &istr, out: &istr, err: &istr) {\n+    dump_output_file(config, testfile, out, ~\"out\");\n+    dump_output_file(config, testfile, err, ~\"err\");\n     maybe_dump_to_stdout(config, out, err);\n }\n \n #[cfg(target_os = \"win32\")]\n #[cfg(target_os = \"linux\")]\n-fn dump_output_file(config: &config, testfile: &str, out: &str,\n-                    extension: &str) {\n+fn dump_output_file(config: &config, testfile: &istr, out: &istr,\n+                    extension: &istr) {\n     let outfile = make_out_name(config, testfile, extension);\n-    let writer = io::file_writer(istr::from_estr(outfile),\n+    let writer = io::file_writer(outfile,\n                                  [io::create, io::truncate]);\n-    writer.write_str(istr::from_estr(out));\n+    writer.write_str(out);\n }\n \n // FIXME (726): Can't use file_writer on mac\n #[cfg(target_os = \"macos\")]\n-fn dump_output_file(config: &config, testfile: &str, out: &str,\n-                    extension: &str) {\n+fn dump_output_file(config: &config, testfile: &istr, out: &istr,\n+                    extension: &istr) {\n }\n \n-fn make_out_name(config: &config, testfile: &str, extension: &str) -> str {\n-    output_base_name(config, testfile) + \".\" + extension\n+fn make_out_name(config: &config, testfile: &istr,\n+                 extension: &istr) -> istr {\n+    output_base_name(config, testfile) + ~\".\" + extension\n }\n \n-fn output_base_name(config: &config, testfile: &str) -> str {\n-    let base = istr::to_estr(config.build_base);\n+fn output_base_name(config: &config, testfile: &istr) -> istr {\n+    let base = config.build_base;\n     let filename =\n         {\n-            let parts = istr::split(fs::basename(istr::from_estr(testfile)),\n+            let parts = istr::split(fs::basename(testfile),\n                                     '.' as u8);\n             parts = vec::slice(parts, 0u, vec::len(parts) - 1u);\n             istr::connect(parts, ~\".\")\n         };\n-    #fmt[\"%s%s.%s\", base, istr::to_estr(filename),\n-         istr::to_estr(config.stage_id)]\n+    istr::from_estr(#fmt[\"%s%s.%s\", istr::to_estr(base),\n+                         istr::to_estr(filename),\n+                         istr::to_estr(config.stage_id)])\n }\n \n-fn maybe_dump_to_stdout(config: &config, out: &str, err: &str) {\n+fn maybe_dump_to_stdout(config: &config, out: &istr, err: &istr) {\n     if config.verbose {\n         let sep1 = #fmt[\"------%s------------------------------\", \"stdout\"];\n         let sep2 = #fmt[\"------%s------------------------------\", \"stderr\"];\n-        let sep3 = \"------------------------------------------\";\n+        let sep3 = ~\"------------------------------------------\";\n         io::stdout().write_line(istr::from_estr(sep1));\n-        io::stdout().write_line(istr::from_estr(out));\n+        io::stdout().write_line(out);\n         io::stdout().write_line(istr::from_estr(sep2));\n-        io::stdout().write_line(istr::from_estr(err));\n-        io::stdout().write_line(istr::from_estr(sep3));\n+        io::stdout().write_line(err);\n+        io::stdout().write_line(sep3);\n     }\n }\n \n-fn error(err: &str) {\n-    io::stdout().write_line(istr::from_estr(#fmt[\"\\nerror: %s\", err]));\n+fn error(err: &istr) {\n+    io::stdout().write_line(istr::from_estr(#fmt[\"\\nerror: %s\",\n+                                                 istr::to_estr(err)]));\n }\n \n-fn fatal(err: &str) -> ! { error(err); fail; }\n+fn fatal(err: &istr) -> ! { error(err); fail; }\n \n-fn fatal_procres(err: &str, procres: procres) -> ! {\n+fn fatal_procres(err: &istr, procres: procres) -> ! {\n     let msg =\n         istr::from_estr(#fmt[\"\\n\\\n error: %s\\n\\\n@@ -391,7 +404,10 @@ stderr:\\n\\\n %s\\n\\\n ------------------------------------------\\n\\\n \\n\",\n-             err, procres.cmdline, procres.stdout, procres.stderr]);\n+                             istr::to_estr(err),\n+                             istr::to_estr(procres.cmdline),\n+                             istr::to_estr(procres.stdout),\n+                             istr::to_estr(procres.stderr)]);\n     io::stdout().write_str(msg);\n     fail;\n }"}, {"sha": "e979c177a4788df8039cfd01cf4ce3bc6b0279b2", "filename": "src/test/compiletest/util.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4007006574561280139659a42000321020d589ff/src%2Ftest%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007006574561280139659a42000321020d589ff/src%2Ftest%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Futil.rs?ref=4007006574561280139659a42000321020d589ff", "patch": "@@ -5,28 +5,30 @@ import std::istr;\n \n import common::config;\n \n-fn make_new_path(path: &str) -> str {\n+fn make_new_path(path: &istr) -> istr {\n \n     // Windows just uses PATH as the library search path, so we have to\n     // maintain the current value while adding our own\n-    alt getenv(istr::from_estr(lib_path_env_var())) {\n-      option::some(curr) { #fmt[\"%s:%s\", path, istr::to_estr(curr)] }\n+    alt getenv(lib_path_env_var()) {\n+      option::some(curr) {\n+        istr::from_estr(#fmt[\"%s:%s\",\n+                             istr::to_estr(path), istr::to_estr(curr)]) }\n       option::none. { path }\n     }\n }\n \n #[cfg(target_os = \"linux\")]\n-fn lib_path_env_var() -> str { \"LD_LIBRARY_PATH\" }\n+fn lib_path_env_var() -> istr { ~\"LD_LIBRARY_PATH\" }\n \n #[cfg(target_os = \"macos\")]\n-fn lib_path_env_var() -> str { \"DYLD_LIBRARY_PATH\" }\n+fn lib_path_env_var() -> istr { ~\"DYLD_LIBRARY_PATH\" }\n \n #[cfg(target_os = \"win32\")]\n-fn lib_path_env_var() -> str { \"PATH\" }\n+fn lib_path_env_var() -> istr { \"PATH\" }\n \n-fn logv(config: &config, s: &str) {\n+fn logv(config: &config, s: &istr) {\n     log s;\n     if config.verbose {\n-        io::stdout().write_line(std::istr::from_estr(s));\n+        io::stdout().write_line(s);\n     }\n }"}]}