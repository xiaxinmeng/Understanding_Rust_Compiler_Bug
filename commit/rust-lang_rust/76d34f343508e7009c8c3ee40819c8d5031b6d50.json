{"sha": "76d34f343508e7009c8c3ee40819c8d5031b6d50", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2ZDM0ZjM0MzUwOGU3MDA5YzhjM2VlNDA4MTljOGQ1MDMxYjZkNTA=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-09-18T04:27:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-18T04:27:26Z"}, "message": "Rollup merge of #64528 - Aaron1011:fix/proc-macro-type, r=alexcrichton\n\nLoad proc macro metadata in the correct order.\n\nSerialized proc macro metadata is assumed to have a one-to-one\ncorrespondence with the entries in static array generated by proc_macro_harness.\nHowever, we were previously serializing proc macro metadata in a\ndifferent order than proc macros were laied out in the static array.\nThis lead to us associating the wrong data with a proc macro when\ngenerating documentation, causing Rustdoc to generate incorrect docs for\nproc macros.\n\nThis commit keeps track of the order in which we insert proc macros into\nthe generated static array. We use this same order when serializing proc\nmacro metadata, ensuring that we can later associate the metadata for a\nproc macro with its entry in the static array.\n\nFixes #64251", "tree": {"sha": "472f37ba762da52367a989cd9f61668db4e239e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/472f37ba762da52367a989cd9f61668db4e239e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76d34f343508e7009c8c3ee40819c8d5031b6d50", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdgbIuCRBK7hj4Ov3rIwAAdHIIAIgfIcjd27ymDTX9eWB6IVqd\nOHXtvy1Aus/HsHG22JCgUy0P6G3DPoNOazlWsuqFKQHjThgPYlptUpUQ6SpRmqHu\nAcy9fxZdSgESuiWgQyuJbXFrgCIB0DuyrQXpkFEdR9qiQz/6p8BsfePdAvJGGjl/\nvubgQDFxWiXy2+b8zQZ/UjKMKBZkAW+MLUEa+U2J5Ty8TApIQjBdP8kpt4MxKAKf\nA0OPIsF8UcXdMSTej7qukhl/c+BxFAH3tah3sP0CPBuPAV8BQq5YKxdBRVbJWJaO\n+Db3EYn5SSlUH5OZxcIRserSZGope/F5HvkHFAghynwooHvJrrNrgYdl92qyqAk=\n=/7+D\n-----END PGP SIGNATURE-----\n", "payload": "tree 472f37ba762da52367a989cd9f61668db4e239e8\nparent b2501a1269b4bccf454556736b8433979df43835\nparent 3daa8bd2e473c80e71b036786fa15729960562af\nauthor Tyler Mandry <tmandry@gmail.com> 1568780846 -0700\ncommitter GitHub <noreply@github.com> 1568780846 -0700\n\nRollup merge of #64528 - Aaron1011:fix/proc-macro-type, r=alexcrichton\n\nLoad proc macro metadata in the correct order.\n\nSerialized proc macro metadata is assumed to have a one-to-one\ncorrespondence with the entries in static array generated by proc_macro_harness.\nHowever, we were previously serializing proc macro metadata in a\ndifferent order than proc macros were laied out in the static array.\nThis lead to us associating the wrong data with a proc macro when\ngenerating documentation, causing Rustdoc to generate incorrect docs for\nproc macros.\n\nThis commit keeps track of the order in which we insert proc macros into\nthe generated static array. We use this same order when serializing proc\nmacro metadata, ensuring that we can later associate the metadata for a\nproc macro with its entry in the static array.\n\nFixes #64251\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76d34f343508e7009c8c3ee40819c8d5031b6d50", "html_url": "https://github.com/rust-lang/rust/commit/76d34f343508e7009c8c3ee40819c8d5031b6d50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76d34f343508e7009c8c3ee40819c8d5031b6d50/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2501a1269b4bccf454556736b8433979df43835", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2501a1269b4bccf454556736b8433979df43835", "html_url": "https://github.com/rust-lang/rust/commit/b2501a1269b4bccf454556736b8433979df43835"}, {"sha": "3daa8bd2e473c80e71b036786fa15729960562af", "url": "https://api.github.com/repos/rust-lang/rust/commits/3daa8bd2e473c80e71b036786fa15729960562af", "html_url": "https://github.com/rust-lang/rust/commit/3daa8bd2e473c80e71b036786fa15729960562af"}], "stats": {"total": 128, "additions": 79, "deletions": 49}, "files": [{"sha": "34c84b1d79d4b0030a418cb4328bb94bb407f952", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76d34f343508e7009c8c3ee40819c8d5031b6d50/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d34f343508e7009c8c3ee40819c8d5031b6d50/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=76d34f343508e7009c8c3ee40819c8d5031b6d50", "patch": "@@ -489,7 +489,11 @@ impl<'a, 'tcx> CrateMetadata {\n \n     fn raw_proc_macro(&self, id: DefIndex) -> &ProcMacro {\n         // DefIndex's in root.proc_macro_data have a one-to-one correspondence\n-        // with items in 'raw_proc_macros'\n+        // with items in 'raw_proc_macros'.\n+        // NOTE: If you update the order of macros in 'proc_macro_data' for any reason,\n+        // you must also update src/libsyntax_ext/proc_macro_harness.rs\n+        // Failing to do so will result in incorrect data being associated\n+        // with proc macros when deserialized.\n         let pos = self.root.proc_macro_data.unwrap().decode(self).position(|i| i == id).unwrap();\n         &self.raw_proc_macros.unwrap()[pos]\n     }"}, {"sha": "f33c813d86cfe4e8aea1fdae5974e06e6a30af0a", "filename": "src/libsyntax_ext/proc_macro_harness.rs", "status": "modified", "additions": 62, "deletions": 47, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/76d34f343508e7009c8c3ee40819c8d5031b6d50/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d34f343508e7009c8c3ee40819c8d5031b6d50/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_harness.rs?ref=76d34f343508e7009c8c3ee40819c8d5031b6d50", "patch": "@@ -20,15 +20,24 @@ struct ProcMacroDerive {\n     attrs: Vec<ast::Name>,\n }\n \n+enum ProcMacroDefType {\n+    Attr,\n+    Bang\n+}\n+\n struct ProcMacroDef {\n     function_name: Ident,\n     span: Span,\n+    def_type: ProcMacroDefType\n+}\n+\n+enum ProcMacro {\n+    Derive(ProcMacroDerive),\n+    Def(ProcMacroDef)\n }\n \n struct CollectProcMacros<'a> {\n-    derives: Vec<ProcMacroDerive>,\n-    attr_macros: Vec<ProcMacroDef>,\n-    bang_macros: Vec<ProcMacroDef>,\n+    macros: Vec<ProcMacro>,\n     in_root: bool,\n     handler: &'a errors::Handler,\n     is_proc_macro_crate: bool,\n@@ -46,22 +55,22 @@ pub fn inject(sess: &ParseSess,\n     let ecfg = ExpansionConfig::default(\"proc_macro\".to_string());\n     let mut cx = ExtCtxt::new(sess, ecfg, resolver);\n \n-    let (derives, attr_macros, bang_macros) = {\n-        let mut collect = CollectProcMacros {\n-            derives: Vec::new(),\n-            attr_macros: Vec::new(),\n-            bang_macros: Vec::new(),\n-            in_root: true,\n-            handler,\n-            is_proc_macro_crate,\n-            is_test_crate,\n-        };\n-        if has_proc_macro_decls || is_proc_macro_crate {\n-            visit::walk_crate(&mut collect, &krate);\n-        }\n-        (collect.derives, collect.attr_macros, collect.bang_macros)\n+    let mut collect = CollectProcMacros {\n+        macros: Vec::new(),\n+        in_root: true,\n+        handler,\n+        is_proc_macro_crate,\n+        is_test_crate,\n     };\n \n+    if has_proc_macro_decls || is_proc_macro_crate {\n+        visit::walk_crate(&mut collect, &krate);\n+    }\n+    // NOTE: If you change the order of macros in this vec\n+    // for any reason, you must also update 'raw_proc_macro'\n+    // in src/librustc_metadata/decoder.rs\n+    let macros = collect.macros;\n+\n     if !is_proc_macro_crate {\n         return krate\n     }\n@@ -74,7 +83,7 @@ pub fn inject(sess: &ParseSess,\n         return krate;\n     }\n \n-    krate.module.items.push(mk_decls(&mut cx, &derives, &attr_macros, &bang_macros));\n+    krate.module.items.push(mk_decls(&mut cx, &macros));\n \n     krate\n }\n@@ -161,12 +170,12 @@ impl<'a> CollectProcMacros<'a> {\n         };\n \n         if self.in_root && item.vis.node.is_pub() {\n-            self.derives.push(ProcMacroDerive {\n+            self.macros.push(ProcMacro::Derive(ProcMacroDerive {\n                 span: item.span,\n                 trait_name: trait_ident.name,\n                 function_name: item.ident,\n                 attrs: proc_attrs,\n-            });\n+            }));\n         } else {\n             let msg = if !self.in_root {\n                 \"functions tagged with `#[proc_macro_derive]` must \\\n@@ -180,10 +189,11 @@ impl<'a> CollectProcMacros<'a> {\n \n     fn collect_attr_proc_macro(&mut self, item: &'a ast::Item) {\n         if self.in_root && item.vis.node.is_pub() {\n-            self.attr_macros.push(ProcMacroDef {\n+            self.macros.push(ProcMacro::Def(ProcMacroDef {\n                 span: item.span,\n                 function_name: item.ident,\n-            });\n+                def_type: ProcMacroDefType::Attr\n+            }));\n         } else {\n             let msg = if !self.in_root {\n                 \"functions tagged with `#[proc_macro_attribute]` must \\\n@@ -197,10 +207,11 @@ impl<'a> CollectProcMacros<'a> {\n \n     fn collect_bang_proc_macro(&mut self, item: &'a ast::Item) {\n         if self.in_root && item.vis.node.is_pub() {\n-            self.bang_macros.push(ProcMacroDef {\n+            self.macros.push(ProcMacro::Def(ProcMacroDef {\n                 span: item.span,\n                 function_name: item.ident,\n-            });\n+                def_type: ProcMacroDefType::Bang\n+            }));\n         } else {\n             let msg = if !self.in_root {\n                 \"functions tagged with `#[proc_macro]` must \\\n@@ -322,9 +333,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n //      }\n fn mk_decls(\n     cx: &mut ExtCtxt<'_>,\n-    custom_derives: &[ProcMacroDerive],\n-    custom_attrs: &[ProcMacroDef],\n-    custom_macros: &[ProcMacroDef],\n+    macros: &[ProcMacro],\n ) -> P<ast::Item> {\n     let expn_id = cx.resolver.expansion_for_ast_pass(\n         DUMMY_SP,\n@@ -354,26 +363,32 @@ fn mk_decls(\n         let proc_macro_ty_method_path = |method| cx.expr_path(cx.path(span, vec![\n             proc_macro, bridge, client, proc_macro_ty, method,\n         ]));\n-        custom_derives.iter().map(|cd| {\n-            cx.expr_call(span, proc_macro_ty_method_path(custom_derive), vec![\n-                cx.expr_str(cd.span, cd.trait_name),\n-                cx.expr_vec_slice(\n-                    span,\n-                    cd.attrs.iter().map(|&s| cx.expr_str(cd.span, s)).collect::<Vec<_>>()\n-                ),\n-                local_path(cd.span, cd.function_name),\n-            ])\n-        }).chain(custom_attrs.iter().map(|ca| {\n-            cx.expr_call(span, proc_macro_ty_method_path(attr), vec![\n-                cx.expr_str(ca.span, ca.function_name.name),\n-                local_path(ca.span, ca.function_name),\n-            ])\n-        })).chain(custom_macros.iter().map(|cm| {\n-            cx.expr_call(span, proc_macro_ty_method_path(bang), vec![\n-                cx.expr_str(cm.span, cm.function_name.name),\n-                local_path(cm.span, cm.function_name),\n-            ])\n-        })).collect()\n+        macros.iter().map(|m| {\n+            match m {\n+                ProcMacro::Derive(cd) => {\n+                    cx.expr_call(span, proc_macro_ty_method_path(custom_derive), vec![\n+                        cx.expr_str(cd.span, cd.trait_name),\n+                        cx.expr_vec_slice(\n+                            span,\n+                            cd.attrs.iter().map(|&s| cx.expr_str(cd.span, s)).collect::<Vec<_>>()\n+                        ),\n+                        local_path(cd.span, cd.function_name),\n+                    ])\n+                },\n+                ProcMacro::Def(ca) => {\n+                    let ident = match ca.def_type {\n+                        ProcMacroDefType::Attr => attr,\n+                        ProcMacroDefType::Bang => bang\n+                    };\n+\n+                    cx.expr_call(span, proc_macro_ty_method_path(ident), vec![\n+                        cx.expr_str(ca.span, ca.function_name.name),\n+                        local_path(ca.span, ca.function_name),\n+                    ])\n+\n+                }\n+            }\n+        }).collect()\n     };\n \n     let decls_static = cx.item_static("}, {"sha": "3dc8de3fe579de37215c9a25cf65e35ee227cb4d", "filename": "src/test/rustdoc/inline_cross/proc_macro.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/76d34f343508e7009c8c3ee40819c8d5031b6d50/src%2Ftest%2Frustdoc%2Finline_cross%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d34f343508e7009c8c3ee40819c8d5031b6d50/src%2Ftest%2Frustdoc%2Finline_cross%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fproc_macro.rs?ref=76d34f343508e7009c8c3ee40819c8d5031b6d50", "patch": "@@ -10,8 +10,19 @@ extern crate some_macros;\n // @has proc_macro/macro.some_proc_macro.html\n // @has proc_macro/attr.some_proc_attr.html\n // @has proc_macro/derive.SomeDerive.html\n-pub use some_macros::{some_proc_macro, some_proc_attr, SomeDerive};\n+\n+// @has proc_macro/macro.some_proc_macro.html\n+// @has - 'a proc-macro that swallows its input and does nothing.'\n+pub use some_macros::some_proc_macro;\n \n // @has proc_macro/macro.reexported_macro.html\n // @has - 'Doc comment from the original crate'\n pub use some_macros::reexported_macro;\n+\n+// @has proc_macro/attr.some_proc_attr.html\n+// @has - 'a proc-macro attribute that passes its item through verbatim.'\n+pub use some_macros::some_proc_attr;\n+\n+// @has proc_macro/derive.SomeDerive.html\n+// @has - 'a derive attribute that adds nothing to its input.'\n+pub use some_macros::SomeDerive;"}]}