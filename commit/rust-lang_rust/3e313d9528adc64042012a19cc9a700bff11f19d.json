{"sha": "3e313d9528adc64042012a19cc9a700bff11f19d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlMzEzZDk1MjhhZGM2NDA0MjAxMmExOWNjOWE3MDBiZmYxMWYxOWQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-27T05:51:55Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-27T05:51:55Z"}, "message": "rustc_trans: don't round up the DST prefix size to its alignment.", "tree": {"sha": "3b317966d2d4d91a9390dab238851f7018c19e91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b317966d2d4d91a9390dab238851f7018c19e91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e313d9528adc64042012a19cc9a700bff11f19d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e313d9528adc64042012a19cc9a700bff11f19d", "html_url": "https://github.com/rust-lang/rust/commit/3e313d9528adc64042012a19cc9a700bff11f19d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e313d9528adc64042012a19cc9a700bff11f19d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1987131063f08afc54d57cdba56c2acddcff191d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1987131063f08afc54d57cdba56c2acddcff191d", "html_url": "https://github.com/rust-lang/rust/commit/1987131063f08afc54d57cdba56c2acddcff191d"}], "stats": {"total": 118, "additions": 70, "deletions": 48}, "files": [{"sha": "94e8aed7cb73b6f6c6cce31c6542996a205cbc88", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3e313d9528adc64042012a19cc9a700bff11f19d/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e313d9528adc64042012a19cc9a700bff11f19d/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=3e313d9528adc64042012a19cc9a700bff11f19d", "patch": "@@ -124,18 +124,7 @@ pub fn type_pair_fields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n /// Returns true if the type is represented as a pair of immediates.\n pub fn type_is_imm_pair<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n                                   -> bool {\n-    let tcx = ccx.tcx();\n-    let layout = tcx.normalizing_infer_ctxt(Reveal::All).enter(|infcx| {\n-        match ty.layout(&infcx) {\n-            Ok(layout) => layout,\n-            Err(err) => {\n-                bug!(\"type_is_imm_pair: layout for `{:?}` failed: {}\",\n-                     ty, err);\n-            }\n-        }\n-    });\n-\n-    match *layout {\n+    match *ccx.layout_of(ty) {\n         Layout::FatPointer { .. } => true,\n         Layout::Univariant { ref variant, .. } => {\n             // There must be only 2 fields."}, {"sha": "77be9964f68b9443671d0a94394a3a5061b2bc20", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e313d9528adc64042012a19cc9a700bff11f19d/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e313d9528adc64042012a19cc9a700bff11f19d/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=3e313d9528adc64042012a19cc9a700bff11f19d", "patch": "@@ -947,6 +947,14 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         TypeOfDepthLock(self.local())\n     }\n \n+    pub fn layout_of(&self, ty: Ty<'tcx>) -> &'tcx ty::layout::Layout {\n+        self.tcx().normalizing_infer_ctxt(traits::Reveal::All).enter(|infcx| {\n+            ty.layout(&infcx).unwrap_or_else(|e| {\n+                bug!(\"failed to get layout for `{}`: {}\", ty, e);\n+            })\n+        })\n+    }\n+\n     pub fn check_overflow(&self) -> bool {\n         self.shared.check_overflow\n     }"}, {"sha": "823c23b2e66b3b232bfb668d8cc1937ed0f5c209", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3e313d9528adc64042012a19cc9a700bff11f19d/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e313d9528adc64042012a19cc9a700bff11f19d/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=3e313d9528adc64042012a19cc9a700bff11f19d", "patch": "@@ -338,13 +338,22 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n         ty::TyStruct(def, substs) => {\n             let ccx = bcx.ccx();\n             // First get the size of all statically known fields.\n-            // Don't use type_of::sizing_type_of because that expects t to be sized.\n+            // Don't use type_of::sizing_type_of because that expects t to be sized,\n+            // and it also rounds up to alignment, which we want to avoid,\n+            // as the unsized field's alignment could be smaller.\n             assert!(!t.is_simd());\n-            let repr = adt::represent_type(ccx, t);\n-            let sizing_type = adt::sizing_type_of(ccx, &repr, true);\n-            debug!(\"DST {} sizing_type: {:?}\", t, sizing_type);\n-            let sized_size = llsize_of_alloc(ccx, sizing_type);\n-            let sized_align = llalign_of_min(ccx, sizing_type);\n+            let layout = ccx.layout_of(t);\n+            debug!(\"DST {} layout: {:?}\", t, layout);\n+\n+            let (sized_size, sized_align) = match *layout {\n+                ty::layout::Layout::Univariant { ref variant, .. } => {\n+                    (variant.min_size().bytes(), variant.align.abi())\n+                }\n+                _ => {\n+                    bug!(\"size_and_align_of_dst: expcted Univariant for `{}`, found {:#?}\",\n+                         t, layout);\n+                }\n+            };\n             debug!(\"DST {} statically sized prefix size: {} align: {}\",\n                    t, sized_size, sized_align);\n             let sized_size = C_uint(ccx, sized_size);"}, {"sha": "153df13e048dbced5dc36135a9f19b1d738a26b6", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/3e313d9528adc64042012a19cc9a700bff11f19d/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e313d9528adc64042012a19cc9a700bff11f19d/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=3e313d9528adc64042012a19cc9a700bff11f19d", "patch": "@@ -15,7 +15,6 @@ use abi::FnType;\n use adt;\n use common::*;\n use machine;\n-use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TypeFoldable};\n \n use type_::Type;\n@@ -124,37 +123,31 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n     cx.llsizingtypes().borrow_mut().insert(t, llsizingty);\n \n     // FIXME(eddyb) Temporary sanity check for ty::layout.\n-    let layout = cx.tcx().normalizing_infer_ctxt(Reveal::All).enter(|infcx| {\n-        t.layout(&infcx)\n-    });\n-    match layout {\n-        Ok(layout) => {\n-            if !type_is_sized(cx.tcx(), t) {\n-                if !layout.is_unsized() {\n-                    bug!(\"layout should be unsized for type `{}` / {:#?}\",\n-                         t, layout);\n-                }\n-\n-                // Unsized types get turned into a fat pointer for LLVM.\n-                return llsizingty;\n-            }\n-            let r = layout.size(&cx.tcx().data_layout).bytes();\n-            let l = machine::llsize_of_alloc(cx, llsizingty);\n-            if r != l {\n-                bug!(\"size differs (rustc: {}, llvm: {}) for type `{}` / {:#?}\",\n-                     r, l, t, layout);\n-            }\n-            let r = layout.align(&cx.tcx().data_layout).abi();\n-            let l = machine::llalign_of_min(cx, llsizingty) as u64;\n-            if r != l {\n-                bug!(\"align differs (rustc: {}, llvm: {}) for type `{}` / {:#?}\",\n-                     r, l, t, layout);\n-            }\n-        }\n-        Err(e) => {\n-            bug!(\"failed to get layout for `{}`: {}\", t, e);\n+    let layout = cx.layout_of(t);\n+    if !type_is_sized(cx.tcx(), t) {\n+        if !layout.is_unsized() {\n+            bug!(\"layout should be unsized for type `{}` / {:#?}\",\n+                 t, layout);\n         }\n+\n+        // Unsized types get turned into a fat pointer for LLVM.\n+        return llsizingty;\n+    }\n+\n+    let r = layout.size(&cx.tcx().data_layout).bytes();\n+    let l = machine::llsize_of_alloc(cx, llsizingty);\n+    if r != l {\n+        bug!(\"size differs (rustc: {}, llvm: {}) for type `{}` / {:#?}\",\n+             r, l, t, layout);\n     }\n+\n+    let r = layout.align(&cx.tcx().data_layout).abi();\n+    let l = machine::llalign_of_min(cx, llsizingty) as u64;\n+    if r != l {\n+        bug!(\"align differs (rustc: {}, llvm: {}) for type `{}` / {:#?}\",\n+             r, l, t, layout);\n+    }\n+\n     llsizingty\n }\n "}, {"sha": "619542926500ba03ed1c4cb0138bb1599608f4ca", "filename": "src/test/run-pass/issue-35815.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3e313d9528adc64042012a19cc9a700bff11f19d/src%2Ftest%2Frun-pass%2Fissue-35815.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e313d9528adc64042012a19cc9a700bff11f19d/src%2Ftest%2Frun-pass%2Fissue-35815.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-35815.rs?ref=3e313d9528adc64042012a19cc9a700bff11f19d", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mem;\n+\n+struct Foo<T: ?Sized> {\n+    a: i64,\n+    b: bool,\n+    c: T,\n+}\n+\n+fn main() {\n+    let foo: &Foo<i32> = &Foo { a: 1, b: false, c: 2i32 };\n+    let foo_unsized: &Foo<Send> = foo;\n+    assert_eq!(mem::size_of_val(foo), mem::size_of_val(foo_unsized));\n+}"}]}