{"sha": "1f411f87ea683fa9b6a1206b030d38db28123547", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmNDExZjg3ZWE2ODNmYTliNmExMjA2YjAzMGQzOGRiMjgxMjM1NDc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-15T08:09:10Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-15T08:09:10Z"}, "message": "Refactor CallInfo tests", "tree": {"sha": "ef5b6c35f3323d2992080cf5deb813c8f1863ec2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef5b6c35f3323d2992080cf5deb813c8f1863ec2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f411f87ea683fa9b6a1206b030d38db28123547", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f411f87ea683fa9b6a1206b030d38db28123547", "html_url": "https://github.com/rust-lang/rust/commit/1f411f87ea683fa9b6a1206b030d38db28123547", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f411f87ea683fa9b6a1206b030d38db28123547/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc2f761d654aa17f4af7d3c40cb9b31ea7d91ad0", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc2f761d654aa17f4af7d3c40cb9b31ea7d91ad0", "html_url": "https://github.com/rust-lang/rust/commit/fc2f761d654aa17f4af7d3c40cb9b31ea7d91ad0"}], "stats": {"total": 465, "additions": 239, "deletions": 226}, "files": [{"sha": "e291c8e4b24b5004af1f7cfa779505ace72b37e5", "filename": "crates/ra_ide/src/call_info.rs", "status": "modified", "additions": 239, "deletions": 226, "changes": 465, "blob_url": "https://github.com/rust-lang/rust/blob/1f411f87ea683fa9b6a1206b030d38db28123547/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f411f87ea683fa9b6a1206b030d38db28123547/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcall_info.rs?ref=1f411f87ea683fa9b6a1206b030d38db28123547", "patch": "@@ -213,169 +213,187 @@ impl CallInfo {\n \n #[cfg(test)]\n mod tests {\n+    use expect::{expect, Expect};\n     use test_utils::mark;\n \n     use crate::mock_analysis::analysis_and_position;\n \n-    use super::*;\n-\n-    // These are only used when testing\n-    impl CallInfo {\n-        fn doc(&self) -> Option<hir::Documentation> {\n-            self.signature.doc.clone()\n-        }\n-\n-        fn label(&self) -> String {\n-            self.signature.to_string()\n-        }\n-    }\n-\n-    fn call_info_helper(text: &str) -> Option<CallInfo> {\n-        let (analysis, position) = analysis_and_position(text);\n-        analysis.call_info(position).unwrap()\n-    }\n-\n-    fn call_info(text: &str) -> CallInfo {\n-        let info = call_info_helper(text);\n-        assert!(info.is_some());\n-        info.unwrap()\n-    }\n-\n-    fn no_call_info(text: &str) {\n-        let info = call_info_helper(text);\n-        assert!(info.is_none());\n+    fn check(ra_fixture: &str, expect: Expect) {\n+        let (analysis, position) = analysis_and_position(ra_fixture);\n+        let call_info = analysis.call_info(position).unwrap();\n+        let actual = match call_info {\n+            Some(call_info) => {\n+                let docs = match &call_info.signature.doc {\n+                    None => \"\".to_string(),\n+                    Some(docs) => format!(\"{}\\n------\\n\", docs.as_str()),\n+                };\n+                let params = call_info\n+                    .parameters()\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(i, param)| {\n+                        if Some(i) == call_info.active_parameter {\n+                            format!(\"<{}>\", param)\n+                        } else {\n+                            param.clone()\n+                        }\n+                    })\n+                    .collect::<Vec<_>>()\n+                    .join(\", \");\n+                format!(\"{}{}\\n({})\\n\", docs, call_info.signature, params)\n+            }\n+            None => String::new(),\n+        };\n+        expect.assert_eq(&actual);\n     }\n \n     #[test]\n-    fn test_fn_signature_two_args_firstx() {\n-        let info = call_info(\n-            r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(<|>3, ); }\"#,\n+    fn test_fn_signature_two_args() {\n+        check(\n+            r#\"\n+fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo(<|>3, ); }\n+\"#,\n+            expect![[r#\"\n+                fn foo(x: u32, y: u32) -> u32\n+                (<x: u32>, y: u32)\n+            \"#]],\n         );\n-\n-        assert_eq!(info.parameters(), [\"x: u32\", \"y: u32\"]);\n-        assert_eq!(info.active_parameter, Some(0));\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_two_args_second() {\n-        let info = call_info(\n-            r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(3, <|>); }\"#,\n+        check(\n+            r#\"\n+fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo(3<|>, ); }\n+\"#,\n+            expect![[r#\"\n+                fn foo(x: u32, y: u32) -> u32\n+                (<x: u32>, y: u32)\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo(3,<|> ); }\n+\"#,\n+            expect![[r#\"\n+                fn foo(x: u32, y: u32) -> u32\n+                (<x: u32>, y: u32)\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo(3, <|>); }\n+\"#,\n+            expect![[r#\"\n+                fn foo(x: u32, y: u32) -> u32\n+                (x: u32, <y: u32>)\n+            \"#]],\n         );\n-\n-        assert_eq!(info.parameters(), [\"x: u32\", \"y: u32\"]);\n-        assert_eq!(info.active_parameter, Some(1));\n     }\n \n     #[test]\n     fn test_fn_signature_two_args_empty() {\n-        let info = call_info(\n-            r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(<|>); }\"#,\n+        check(\n+            r#\"\n+fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo(<|>); }\n+\"#,\n+            expect![[r#\"\n+                fn foo(x: u32, y: u32) -> u32\n+                (<x: u32>, y: u32)\n+            \"#]],\n         );\n-\n-        assert_eq!(info.parameters(), [\"x: u32\", \"y: u32\"]);\n-        assert_eq!(info.active_parameter, Some(0));\n     }\n \n     #[test]\n     fn test_fn_signature_two_args_first_generics() {\n-        let info = call_info(\n-            r#\"fn foo<T, U: Copy + Display>(x: T, y: U) -> u32 where T: Copy + Display, U: Debug {x + y}\n-fn bar() { foo(<|>3, ); }\"#,\n-        );\n-\n-        assert_eq!(info.parameters(), [\"x: T\", \"y: U\"]);\n-        assert_eq!(\n-            info.label(),\n+        check(\n             r#\"\n fn foo<T, U: Copy + Display>(x: T, y: U) -> u32\n-where T: Copy + Display,\n-      U: Debug\n-    \"#\n-            .trim()\n+    where T: Copy + Display, U: Debug\n+{ x + y }\n+\n+fn bar() { foo(<|>3, ); }\n+\"#,\n+            expect![[r#\"\n+                fn foo<T, U: Copy + Display>(x: T, y: U) -> u32\n+                where T: Copy + Display,\n+                      U: Debug\n+                (<x: T>, y: U)\n+            \"#]],\n         );\n-        assert_eq!(info.active_parameter, Some(0));\n     }\n \n     #[test]\n     fn test_fn_signature_no_params() {\n-        let info = call_info(\n-            r#\"fn foo<T>() -> T where T: Copy + Display {}\n-fn bar() { foo(<|>); }\"#,\n-        );\n-\n-        assert!(info.parameters().is_empty());\n-        assert_eq!(\n-            info.label(),\n+        check(\n             r#\"\n-fn foo<T>() -> T\n-where T: Copy + Display\n-    \"#\n-            .trim()\n+fn foo<T>() -> T where T: Copy + Display {}\n+fn bar() { foo(<|>); }\n+\"#,\n+            expect![[r#\"\n+                fn foo<T>() -> T\n+                where T: Copy + Display\n+                ()\n+            \"#]],\n         );\n-        assert!(info.active_parameter.is_none());\n     }\n \n     #[test]\n     fn test_fn_signature_for_impl() {\n-        let info = call_info(\n-            r#\"struct F; impl F { pub fn new() { F{}} }\n-fn bar() {let _ : F = F::new(<|>);}\"#,\n+        check(\n+            r#\"\n+struct F; impl F { pub fn new() { F{}} }\n+fn bar() {let _ : F = F::new(<|>);}\n+\"#,\n+            expect![[r#\"\n+                pub fn new()\n+                ()\n+            \"#]],\n         );\n-\n-        assert!(info.parameters().is_empty());\n-        assert_eq!(info.active_parameter, None);\n     }\n \n     #[test]\n     fn test_fn_signature_for_method_self() {\n-        let info = call_info(\n-            r#\"struct F;\n-impl F {\n-    pub fn new() -> F{\n-        F{}\n-    }\n-\n-    pub fn do_it(&self) {}\n-}\n+        check(\n+            r#\"\n+struct S;\n+impl S { pub fn do_it(&self) {} }\n \n fn bar() {\n-    let f : F = F::new();\n-    f.do_it(<|>);\n-}\"#,\n+    let s: S = S;\n+    s.do_it(<|>);\n+}\n+\"#,\n+            expect![[r#\"\n+                pub fn do_it(&self)\n+                (&self)\n+            \"#]],\n         );\n-\n-        assert_eq!(info.parameters(), [\"&self\"]);\n-        assert_eq!(info.active_parameter, None);\n     }\n \n     #[test]\n     fn test_fn_signature_for_method_with_arg() {\n-        let info = call_info(\n-            r#\"struct F;\n-impl F {\n-    pub fn new() -> F{\n-        F{}\n-    }\n-\n-    pub fn do_it(&self, x: i32) {}\n-}\n+        check(\n+            r#\"\n+struct S;\n+impl S { pub fn do_it(&self, x: i32) {} }\n \n fn bar() {\n-    let f : F = F::new();\n-    f.do_it(<|>);\n-}\"#,\n+    let s: S = S;\n+    s.do_it(<|>);\n+}\n+\"#,\n+            expect![[r#\"\n+                pub fn do_it(&self, x: i32)\n+                (&self, <x: i32>)\n+            \"#]],\n         );\n-\n-        assert_eq!(info.parameters(), [\"&self\", \"x: i32\"]);\n-        assert_eq!(info.active_parameter, Some(1));\n     }\n \n     #[test]\n     fn test_fn_signature_with_docs_simple() {\n-        let info = call_info(\n+        check(\n             r#\"\n /// test\n // non-doc-comment\n@@ -387,17 +405,18 @@ fn bar() {\n     let _ = foo(<|>);\n }\n \"#,\n+            expect![[r#\"\n+                test\n+                ------\n+                fn foo(j: u32) -> u32\n+                (<j: u32>)\n+            \"#]],\n         );\n-\n-        assert_eq!(info.parameters(), [\"j: u32\"]);\n-        assert_eq!(info.active_parameter, Some(0));\n-        assert_eq!(info.label(), \"fn foo(j: u32) -> u32\");\n-        assert_eq!(info.doc().map(|it| it.into()), Some(\"test\".to_string()));\n     }\n \n     #[test]\n     fn test_fn_signature_with_docs() {\n-        let info = call_info(\n+        check(\n             r#\"\n /// Adds one to the number given.\n ///\n@@ -415,31 +434,26 @@ pub fn add_one(x: i32) -> i32 {\n pub fn do() {\n     add_one(<|>\n }\"#,\n-        );\n-\n-        assert_eq!(info.parameters(), [\"x: i32\"]);\n-        assert_eq!(info.active_parameter, Some(0));\n-        assert_eq!(info.label(), \"pub fn add_one(x: i32) -> i32\");\n-        assert_eq!(\n-            info.doc().map(|it| it.into()),\n-            Some(\n-                r#\"Adds one to the number given.\n+            expect![[r##\"\n+                Adds one to the number given.\n \n-# Examples\n+                # Examples\n \n-```\n-let five = 5;\n+                ```\n+                let five = 5;\n \n-assert_eq!(6, my_crate::add_one(5));\n-```\"#\n-                    .to_string()\n-            )\n+                assert_eq!(6, my_crate::add_one(5));\n+                ```\n+                ------\n+                pub fn add_one(x: i32) -> i32\n+                (<x: i32>)\n+            \"##]],\n         );\n     }\n \n     #[test]\n     fn test_fn_signature_with_docs_impl() {\n-        let info = call_info(\n+        check(\n             r#\"\n struct addr;\n impl addr {\n@@ -460,32 +474,28 @@ impl addr {\n pub fn do_it() {\n     addr {};\n     addr::add_one(<|>);\n-}\"#,\n-        );\n-\n-        assert_eq!(info.parameters(), [\"x: i32\"]);\n-        assert_eq!(info.active_parameter, Some(0));\n-        assert_eq!(info.label(), \"pub fn add_one(x: i32) -> i32\");\n-        assert_eq!(\n-            info.doc().map(|it| it.into()),\n-            Some(\n-                r#\"Adds one to the number given.\n+}\n+\"#,\n+            expect![[r##\"\n+                Adds one to the number given.\n \n-# Examples\n+                # Examples\n \n-```\n-let five = 5;\n+                ```\n+                let five = 5;\n \n-assert_eq!(6, my_crate::add_one(5));\n-```\"#\n-                    .to_string()\n-            )\n+                assert_eq!(6, my_crate::add_one(5));\n+                ```\n+                ------\n+                pub fn add_one(x: i32) -> i32\n+                (<x: i32>)\n+            \"##]],\n         );\n     }\n \n     #[test]\n     fn test_fn_signature_with_docs_from_actix() {\n-        let info = call_info(\n+        check(\n             r#\"\n struct WriteHandler<E>;\n \n@@ -509,101 +519,102 @@ impl<E> WriteHandler<E> {\n pub fn foo(mut r: WriteHandler<()>) {\n     r.finished(<|>);\n }\n-\n \"#,\n-        );\n-\n-        assert_eq!(info.label(), \"fn finished(&mut self, ctx: &mut Self::Context)\".to_string());\n-        assert_eq!(info.parameters(), [\"&mut self\", \"ctx: &mut Self::Context\"]);\n-        assert_eq!(info.active_parameter, Some(1));\n-        assert_eq!(\n-            info.doc().map(|it| it.into()),\n-            Some(\n-                r#\"Method is called when writer finishes.\n-\n-By default this method stops actor's `Context`.\"#\n-                    .to_string()\n-            )\n+            expect![[r#\"\n+                Method is called when writer finishes.\n+\n+                By default this method stops actor's `Context`.\n+                ------\n+                fn finished(&mut self, ctx: &mut Self::Context)\n+                (&mut self, <ctx: &mut Self::Context>)\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn call_info_bad_offset() {\n         mark::check!(call_info_bad_offset);\n-        let (analysis, position) = analysis_and_position(\n-            r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n-               fn bar() { foo <|> (3, ); }\"#,\n+        check(\n+            r#\"\n+fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo <|> (3, ); }\n+\"#,\n+            expect![[\"\"]],\n         );\n-        let call_info = analysis.call_info(position).unwrap();\n-        assert!(call_info.is_none());\n     }\n \n     #[test]\n-    fn test_nested_method_in_lamba() {\n-        let info = call_info(\n-            r#\"struct Foo;\n-\n-impl Foo {\n-    fn bar(&self, _: u32) { }\n-}\n+    fn test_nested_method_in_lambda() {\n+        check(\n+            r#\"\n+struct Foo;\n+impl Foo { fn bar(&self, _: u32) { } }\n \n fn bar(_: u32) { }\n \n fn main() {\n     let foo = Foo;\n     std::thread::spawn(move || foo.bar(<|>));\n-}\"#,\n+}\n+\"#,\n+            expect![[r#\"\n+                fn bar(&self, _: u32)\n+                (&self, <_: u32>)\n+            \"#]],\n         );\n-\n-        assert_eq!(info.parameters(), [\"&self\", \"_: u32\"]);\n-        assert_eq!(info.active_parameter, Some(1));\n-        assert_eq!(info.label(), \"fn bar(&self, _: u32)\");\n     }\n \n     #[test]\n     fn works_for_tuple_structs() {\n-        let info = call_info(\n+        check(\n             r#\"\n /// A cool tuple struct\n struct TS(u32, i32);\n fn main() {\n     let s = TS(0, <|>);\n-}\"#,\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct TS(u32, i32) -> TS\n+                (u32, <i32>)\n+            \"#]],\n         );\n-\n-        assert_eq!(info.label(), \"struct TS(u32, i32) -> TS\");\n-        assert_eq!(info.doc().map(|it| it.into()), Some(\"A cool tuple struct\".to_string()));\n-        assert_eq!(info.active_parameter, Some(1));\n     }\n \n     #[test]\n     fn generic_struct() {\n-        let info = call_info(\n+        check(\n             r#\"\n struct TS<T>(T);\n fn main() {\n     let s = TS(<|>);\n-}\"#,\n+}\n+\"#,\n+            expect![[r#\"\n+                struct TS<T>(T) -> TS\n+                (<T>)\n+            \"#]],\n         );\n-\n-        assert_eq!(info.label(), \"struct TS<T>(T) -> TS\");\n-        assert_eq!(info.active_parameter, Some(0));\n     }\n \n     #[test]\n     fn cant_call_named_structs() {\n-        no_call_info(\n+        check(\n             r#\"\n struct TS { x: u32, y: i32 }\n fn main() {\n     let s = TS(<|>);\n-}\"#,\n+}\n+\"#,\n+            expect![[\"\"]],\n         );\n     }\n \n     #[test]\n     fn works_for_enum_variants() {\n-        let info = call_info(\n+        check(\n             r#\"\n enum E {\n     /// A Variant\n@@ -617,17 +628,19 @@ enum E {\n fn main() {\n     let a = E::A(<|>);\n }\n-            \"#,\n+\"#,\n+            expect![[r#\"\n+                A Variant\n+                ------\n+                E::A(0: i32)\n+                (<0: i32>)\n+            \"#]],\n         );\n-\n-        assert_eq!(info.label(), \"E::A(0: i32)\");\n-        assert_eq!(info.doc().map(|it| it.into()), Some(\"A Variant\".to_string()));\n-        assert_eq!(info.active_parameter, Some(0));\n     }\n \n     #[test]\n     fn cant_call_enum_records() {\n-        no_call_info(\n+        check(\n             r#\"\n enum E {\n     /// A Variant\n@@ -641,13 +654,14 @@ enum E {\n fn main() {\n     let a = E::C(<|>);\n }\n-            \"#,\n+\"#,\n+            expect![[\"\"]],\n         );\n     }\n \n     #[test]\n     fn fn_signature_for_macro() {\n-        let info = call_info(\n+        check(\n             r#\"\n /// empty macro\n macro_rules! foo {\n@@ -657,31 +671,30 @@ macro_rules! foo {\n fn f() {\n     foo!(<|>);\n }\n-        \"#,\n+\"#,\n+            expect![[r#\"\n+                empty macro\n+                ------\n+                foo!()\n+                ()\n+            \"#]],\n         );\n-\n-        assert_eq!(info.label(), \"foo!()\");\n-        assert_eq!(info.doc().map(|it| it.into()), Some(\"empty macro\".to_string()));\n     }\n \n     #[test]\n     fn fn_signature_for_call_in_macro() {\n-        let info = call_info(\n+        check(\n             r#\"\n-            macro_rules! id {\n-                ($($tt:tt)*) => { $($tt)* }\n-            }\n-            fn foo() {\n-\n-            }\n-            id! {\n-                fn bar() {\n-                    foo(<|>);\n-                }\n-            }\n-            \"#,\n+macro_rules! id { ($($tt:tt)*) => { $($tt)* } }\n+fn foo() { }\n+id! {\n+    fn bar() { foo(<|>); }\n+}\n+\"#,\n+            expect![[r#\"\n+                fn foo()\n+                ()\n+            \"#]],\n         );\n-\n-        assert_eq!(info.label(), \"fn foo()\");\n     }\n }"}]}