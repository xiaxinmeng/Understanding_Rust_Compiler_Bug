{"sha": "ad292ac8fd1fe79b4db389a32dde986b9549d6c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkMjkyYWM4ZmQxZmU3OWI0ZGIzODlhMzJkZGU5ODZiOTU0OWQ2YzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-10T04:36:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-10T04:36:29Z"}, "message": "auto merge of #10873 : pradeep90/rust/rust-mode-changes, r=pcwalton\n\nSpecifically, we can now use:\r\n+ beginning-of-defun\r\n+ end-of-defun\r\n+ mark-defun\r\n\r\nwhere \"defun\" means a Rust item.\r\n\r\n+ Add tests in rust-mode-tests.el\r\n+ Fix indentation in rust-mode-tests.el\r\n+ Add support for trait to Imenu", "tree": {"sha": "e6794edbe8bf222d6c0d8d853b663a9426f38a64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6794edbe8bf222d6c0d8d853b663a9426f38a64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad292ac8fd1fe79b4db389a32dde986b9549d6c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad292ac8fd1fe79b4db389a32dde986b9549d6c3", "html_url": "https://github.com/rust-lang/rust/commit/ad292ac8fd1fe79b4db389a32dde986b9549d6c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad292ac8fd1fe79b4db389a32dde986b9549d6c3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29ca4350c8d64facb39311660e8ee919766f481a", "url": "https://api.github.com/repos/rust-lang/rust/commits/29ca4350c8d64facb39311660e8ee919766f481a", "html_url": "https://github.com/rust-lang/rust/commit/29ca4350c8d64facb39311660e8ee919766f481a"}, {"sha": "04d852aeb1c296169f3e7ddc328533c2ab217175", "url": "https://api.github.com/repos/rust-lang/rust/commits/04d852aeb1c296169f3e7ddc328533c2ab217175", "html_url": "https://github.com/rust-lang/rust/commit/04d852aeb1c296169f3e7ddc328533c2ab217175"}], "stats": {"total": 294, "additions": 269, "deletions": 25}, "files": [{"sha": "524d474d8350d0f4497cd99fed7529dc879d1b6c", "filename": "src/etc/emacs/rust-mode-tests.el", "status": "modified", "additions": 226, "deletions": 24, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/ad292ac8fd1fe79b4db389a32dde986b9549d6c3/src%2Fetc%2Femacs%2Frust-mode-tests.el", "raw_url": "https://github.com/rust-lang/rust/raw/ad292ac8fd1fe79b4db389a32dde986b9549d6c3/src%2Fetc%2Femacs%2Frust-mode-tests.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode-tests.el?ref=ad292ac8fd1fe79b4db389a32dde986b9549d6c3", "patch": "@@ -52,24 +52,24 @@ Also, the result should be the same regardless of whether the code is at the beg\n     (loop\n      for pad-at-beginning from 0 to 1\n      do (loop for pad-at-end from 0 to 1\n-           with padding-beginning = (if (= 0 pad-at-beginning) \"\" padding)\n-           with padding-end = (if (= 0 pad-at-end) \"\" padding)\n-           with padding-adjust = (* padding-len pad-at-beginning)\n-           with padding-beginning = (if (= 0 pad-at-beginning) \"\" padding)\n-           with padding-end = (if (= 0 pad-at-end) \"\" padding)\n-           ;; If we're adding space to the beginning, and our start position\n-           ;; is at the very beginning, we want to test within the added space.\n-           ;; Otherwise adjust the start and end for the beginning padding.\n-           with start-pos = (if (= 1 start-pos) 1 (+ padding-adjust start-pos))\n-           with end-pos = (+ end-pos padding-adjust)\n-           do (loop for pos from start-pos to end-pos\n-                 do (rust-test-manip-code\n-                     (concat padding-beginning unfilled padding-end)\n-                     pos\n-                     (lambda () \n-                       (let ((fill-column rust-test-fill-column))\n-                         (fill-paragraph)))\n-                     (concat padding-beginning expected padding-end)))))))\n+              with padding-beginning = (if (= 0 pad-at-beginning) \"\" padding)\n+              with padding-end = (if (= 0 pad-at-end) \"\" padding)\n+              with padding-adjust = (* padding-len pad-at-beginning)\n+              with padding-beginning = (if (= 0 pad-at-beginning) \"\" padding)\n+              with padding-end = (if (= 0 pad-at-end) \"\" padding)\n+              ;; If we're adding space to the beginning, and our start position\n+              ;; is at the very beginning, we want to test within the added space.\n+              ;; Otherwise adjust the start and end for the beginning padding.\n+              with start-pos = (if (= 1 start-pos) 1 (+ padding-adjust start-pos))\n+              with end-pos = (+ end-pos padding-adjust)\n+              do (loop for pos from start-pos to end-pos\n+                       do (rust-test-manip-code\n+                           (concat padding-beginning unfilled padding-end)\n+                           pos\n+                           (lambda () \n+                             (let ((fill-column rust-test-fill-column))\n+                               (fill-paragraph)))\n+                           (concat padding-beginning expected padding-end)))))))\n \n (ert-deftest fill-paragraph-top-level-multi-line-style-doc-comment-second-line ()\n   (test-fill-paragraph \n@@ -262,14 +262,14 @@ fn bar() { }\" 14 67))\n /// \"\n    103\n    \"This is the second really really really really really really long paragraph\"\n-    \"/// This is the first really\n+   \"/// This is the first really\n /// really really really really\n /// really really long paragraph\n ///\n /// This is the second really\n /// really really really really\n /// really long paragraph\"\n-    ))\n+   ))\n \n (ert-deftest auto-fill-multi-line-prefixless ()\n   (test-auto-fill\n@@ -295,7 +295,7 @@ very very very long string\n \n (ert-deftest indent-struct-fields-aligned ()\n   (test-indent\n-\"\n+   \"\n struct Foo { bar: int,\n              baz: int }\n \n@@ -305,7 +305,7 @@ struct Blah {x:int,\n \n (ert-deftest indent-doc-comments ()\n   (test-indent\n-\"\n+   \"\n /**\n  * This is a doc comment\n  *\n@@ -411,7 +411,7 @@ fn nexted_fns(a: fn(b:int,\n     0\n }\n \"\n-))\n+   ))\n \n (ert-deftest indent-multi-line-expr ()\n   (test-indent\n@@ -423,4 +423,206 @@ fn foo()\n         b();\n }\n \"\n-))\n+   ))\n+\n+(setq rust-test-motion-string\n+      \"\n+fn fn1(arg: int) -> bool {\n+    let x = 5;\n+    let y = b();\n+    true\n+}\n+\n+fn fn2(arg: int) -> bool {\n+    let x = 5;\n+    let y = b();\n+    true\n+}\n+\n+pub fn fn3(arg: int) -> bool {\n+    let x = 5;\n+    let y = b();\n+    true\n+}\n+\n+struct Foo {\n+    x: int\n+}\n+\"\n+      rust-test-region-string rust-test-motion-string\n+      ;; Symbol -> (line column)\n+      rust-test-positions-alist '((start-of-fn1 (2 0))\n+                                  (start-of-fn1-middle-of-line (2 15))\n+                                  (middle-of-fn1 (3 7))\n+                                  (end-of-fn1 (6 0))\n+                                  (between-fn1-fn2 (7 0))\n+                                  (start-of-fn2 (8 0))\n+                                  (middle-of-fn2 (10 4))\n+                                  (before-start-of-fn1 (1 0))\n+                                  (after-end-of-fn2 (13 0))\n+                                  (beginning-of-fn3 (14 0))\n+                                  (middle-of-fn3 (16 4))\n+                                  (middle-of-struct (21 10))\n+                                  (before-start-of-struct (19 0))\n+                                  (after-end-of-struct (23 0))))\n+\n+(defun rust-get-buffer-pos (pos-symbol)\n+  \"Get buffer position from POS-SYMBOL.\n+\n+POS-SYMBOL is a symbol found in `rust-test-positions-alist'.\n+Convert the line-column information from that list into a buffer position value.\"\n+  (interactive \"P\")\n+  (pcase-let ((`(,line ,column) (cadr (assoc pos-symbol rust-test-positions-alist))))\n+    (save-excursion\n+      (goto-line line)\n+      (move-to-column column)\n+      (point))))\n+\n+;;; TODO: Maybe add an ERT explainer function (something that shows the\n+;;; surrounding code of the final point, not just the position).\n+(defun rust-test-motion (source-code init-pos final-pos manip-func &optional &rest args)\n+  \"Test that MANIP-FUNC moves point from INIT-POS to FINAL-POS.\n+\n+If ARGS are provided, send them to MANIP-FUNC.\n+\n+INIT-POS, FINAL-POS are position symbols found in `rust-test-positions-alist'.\"\n+  (with-temp-buffer\n+    (rust-mode)\n+    (insert source-code)\n+    (goto-char (rust-get-buffer-pos init-pos))\n+    (apply manip-func args)\n+    (should (equal (point) (rust-get-buffer-pos final-pos)))))\n+\n+(defun rust-test-region (source-code init-pos reg-beg reg-end manip-func &optional &rest args)\n+  \"Test that MANIP-FUNC marks region from REG-BEG to REG-END.\n+\n+INIT-POS is the initial position of point.\n+If ARGS are provided, send them to MANIP-FUNC.\n+All positions are position symbols found in `rust-test-positions-alist'.\"\n+  (with-temp-buffer\n+    (rust-mode)\n+    (insert source-code)\n+    (goto-char (rust-get-buffer-pos init-pos))\n+    (apply manip-func args)\n+    (should (equal (list (region-beginning) (region-end))\n+                   (list (rust-get-buffer-pos reg-beg)\n+                         (rust-get-buffer-pos reg-end))))))\n+\n+(ert-deftest rust-beginning-of-defun-from-middle-of-fn ()\n+  (rust-test-motion \n+   rust-test-motion-string\n+   'middle-of-fn1\n+   'start-of-fn1\n+   #'beginning-of-defun))\n+\n+(ert-deftest rust-beginning-of-defun-from-end ()\n+  (rust-test-motion \n+   rust-test-motion-string\n+   'end-of-fn1\n+   'start-of-fn1\n+   #'beginning-of-defun))\n+\n+(ert-deftest rust-beginning-of-defun-before-open-brace ()\n+  (rust-test-motion \n+   rust-test-motion-string\n+   'start-of-fn1-middle-of-line\n+   'start-of-fn1\n+   #'beginning-of-defun))\n+\n+(ert-deftest rust-beginning-of-defun-between-fns ()\n+  (rust-test-motion \n+   rust-test-motion-string\n+   'between-fn1-fn2\n+   'start-of-fn1\n+   #'beginning-of-defun))\n+\n+(ert-deftest rust-beginning-of-defun-with-arg ()\n+  (rust-test-motion \n+   rust-test-motion-string\n+   'middle-of-fn2\n+   'start-of-fn1\n+   #'beginning-of-defun 2))\n+\n+(ert-deftest rust-beginning-of-defun-with-negative-arg ()\n+  (rust-test-motion \n+   rust-test-motion-string\n+   'middle-of-fn1\n+   'beginning-of-fn3\n+   #'beginning-of-defun -2))\n+\n+(ert-deftest rust-beginning-of-defun-pub-fn ()\n+  (rust-test-motion \n+   rust-test-motion-string\n+   'middle-of-fn3\n+   'beginning-of-fn3\n+   #'beginning-of-defun))\n+\n+(ert-deftest rust-end-of-defun-from-middle-of-fn ()\n+  (rust-test-motion \n+   rust-test-motion-string\n+   'middle-of-fn1\n+   'between-fn1-fn2\n+   #'end-of-defun))\n+\n+(ert-deftest rust-end-of-defun-from-beg ()\n+  (rust-test-motion \n+   rust-test-motion-string\n+   'start-of-fn1\n+   'between-fn1-fn2\n+   #'end-of-defun))\n+\n+(ert-deftest rust-end-of-defun-before-open-brace ()\n+  (rust-test-motion \n+   rust-test-motion-string\n+   'start-of-fn1-middle-of-line\n+   'between-fn1-fn2\n+   #'end-of-defun))\n+\n+(ert-deftest rust-end-of-defun-between-fns ()\n+  (rust-test-motion \n+   rust-test-motion-string\n+   'between-fn1-fn2\n+   'after-end-of-fn2\n+   #'end-of-defun))\n+\n+(ert-deftest rust-end-of-defun-with-arg ()\n+  (rust-test-motion \n+   rust-test-motion-string\n+   'middle-of-fn1\n+   'after-end-of-fn2\n+   #'end-of-defun 2))\n+\n+(ert-deftest rust-end-of-defun-with-negative-arg ()\n+  (rust-test-motion \n+   rust-test-motion-string\n+   'middle-of-fn3\n+   'between-fn1-fn2\n+   #'end-of-defun -2))\n+\n+(ert-deftest rust-mark-defun-from-middle-of-fn ()\n+  (rust-test-region\n+   rust-test-region-string\n+   'middle-of-fn2\n+   'between-fn1-fn2 'after-end-of-fn2\n+   #'mark-defun))\n+\n+(ert-deftest rust-mark-defun-from-end ()\n+  (rust-test-region \n+   rust-test-region-string\n+   'end-of-fn1\n+   'before-start-of-fn1 'between-fn1-fn2\n+   #'mark-defun))\n+\n+(ert-deftest rust-mark-defun-start-of-defun ()\n+  (rust-test-region \n+   rust-test-region-string\n+   'start-of-fn2\n+   'between-fn1-fn2 'after-end-of-fn2\n+   #'mark-defun))\n+\n+(ert-deftest rust-mark-defun-from-middle-of-struct ()\n+  (rust-test-region\n+   rust-test-region-string\n+   'middle-of-struct\n+   'before-start-of-struct 'after-end-of-struct\n+   #'mark-defun))"}, {"sha": "66cc3c3d472cd34e7c814fca69e16c1730cb062f", "filename": "src/etc/emacs/rust-mode.el", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ad292ac8fd1fe79b4db389a32dde986b9549d6c3/src%2Fetc%2Femacs%2Frust-mode.el", "raw_url": "https://github.com/rust-lang/rust/raw/ad292ac8fd1fe79b4db389a32dde986b9549d6c3/src%2Fetc%2Femacs%2Frust-mode.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode.el?ref=ad292ac8fd1fe79b4db389a32dde986b9549d6c3", "patch": "@@ -324,7 +324,7 @@\n ;;; Imenu support\n (defvar rust-imenu-generic-expression\n   (append (loop for item in\n-                '(\"enum\" \"struct\" \"type\" \"mod\" \"fn\")\n+                '(\"enum\" \"struct\" \"type\" \"mod\" \"fn\" \"trait\")\n                 collect `(nil ,(rust-re-item-def item) 1))\n           `((\"Impl\" ,(rust-re-item-def \"impl\") 1)))\n   \"Value for `imenu-generic-expression' in Rust mode.\n@@ -335,6 +335,46 @@ Imenu will show all the enums, structs, etc. at the same level.\n Implementations will be shown under the `Impl` subheading.\n Use idomenu (imenu with ido-mode) for best mileage.\")\n \n+;;; Defun Motions\n+\n+;;; Start of a Rust item\n+(setq rust-top-item-beg-re\n+      (concat \"^\\\\s-*\\\\(?:priv\\\\|pub\\\\)?\\\\s-*\"\n+              (regexp-opt\n+               '(\"enum\" \"struct\" \"type\" \"mod\" \"use\" \"fn\" \"static\" \"impl\"\n+                 \"extern\" \"impl\" \"static\" \"trait\"\n+                 ))))\n+\n+(defun rust-beginning-of-defun (&optional arg)\n+  \"Move backward to the beginning of the current defun.\n+\n+With ARG, move backward multiple defuns.  Negative ARG means\n+move forward.\n+\n+This is written mainly to be used as `beginning-of-defun-function' for Rust.\n+Don't move to the beginning of the line. `beginning-of-defun',\n+which calls this, does that afterwards.\"\n+  (interactive \"p\")\n+  (re-search-backward (concat \"^\\\\(\" rust-top-item-beg-re \"\\\\)\\\\b\")\n+                      nil 'move (or arg 1)))\n+\n+(defun rust-end-of-defun ()\n+  \"Move forward to the next end of defun.\n+\n+With argument, do it that many times.\n+Negative argument -N means move back to Nth preceding end of defun.\n+\n+Assume that this is called after beginning-of-defun. So point is\n+at the beginning of the defun body. \n+\n+This is written mainly to be used as `end-of-defun-function' for Rust.\"\n+  (interactive \"p\")\n+  ;; Find the opening brace\n+  (re-search-forward \"[{]\" nil t)\n+  (goto-char (match-beginning 0))\n+  ;; Go to the closing brace\n+  (forward-sexp))\n+\n ;; For compatibility with Emacs < 24, derive conditionally\n (defalias 'rust-parent-mode\n   (if (fboundp 'prog-mode) 'prog-mode 'fundamental-mode))\n@@ -374,6 +414,8 @@ Use idomenu (imenu with ido-mode) for best mileage.\")\n   (set (make-local-variable 'comment-multi-line) t)\n   (set (make-local-variable 'comment-line-break-function) 'rust-comment-indent-new-line)\n   (set (make-local-variable 'imenu-generic-expression) rust-imenu-generic-expression)\n+  (set (make-local-variable 'beginning-of-defun-function) 'rust-beginning-of-defun)\n+  (set (make-local-variable 'end-of-defun-function) 'rust-end-of-defun)\n   )\n \n "}]}