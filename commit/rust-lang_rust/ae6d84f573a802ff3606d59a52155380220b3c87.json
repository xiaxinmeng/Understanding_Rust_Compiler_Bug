{"sha": "ae6d84f573a802ff3606d59a52155380220b3c87", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlNmQ4NGY1NzNhODAyZmYzNjA2ZDU5YTUyMTU1MzgwMjIwYjNjODc=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-07T18:17:24Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-07T18:26:41Z"}, "message": "Rework task::try for new task_builder interface (close #3103)", "tree": {"sha": "95e7775b5f85b1035a43abb2ea366753cb576aa0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95e7775b5f85b1035a43abb2ea366753cb576aa0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae6d84f573a802ff3606d59a52155380220b3c87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae6d84f573a802ff3606d59a52155380220b3c87", "html_url": "https://github.com/rust-lang/rust/commit/ae6d84f573a802ff3606d59a52155380220b3c87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae6d84f573a802ff3606d59a52155380220b3c87/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0cc6cefaec4cedfc91ec7de447e116e6eba82915", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cc6cefaec4cedfc91ec7de447e116e6eba82915", "html_url": "https://github.com/rust-lang/rust/commit/0cc6cefaec4cedfc91ec7de447e116e6eba82915"}], "stats": {"total": 58, "additions": 41, "deletions": 17}, "files": [{"sha": "06f3c0b2f50c0245757a1fb56add99613c9a4f17", "filename": "src/libcore/task.rs", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ae6d84f573a802ff3606d59a52155380220b3c87/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6d84f573a802ff3606d59a52155380220b3c87/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=ae6d84f573a802ff3606d59a52155380220b3c87", "patch": "@@ -267,13 +267,20 @@ impl task_builder for task_builder {\n      * builder. If additional tasks are spawned with the same builder\n      * then a new result future must be obtained prior to spawning each\n      * task.\n+     *\n+     * # Failure\n+     * Fails if a future_result was already set for this task.\n      */\n     fn future_result(blk: fn(-future::future<task_result>)) -> task_builder {\n         // FIXME (#1087, #1857): Once linked failure and notification are\n         // handled in the library, I can imagine implementing this by just\n         // registering an arbitrary number of task::on_exit handlers and\n         // sending out messages.\n \n+        if self.opts.notify_chan.is_some() {\n+            fail ~\"Can't set multiple future_results for one task!\";\n+        }\n+\n         // Construct the future and give it to the caller.\n         let po = comm::port::<notification>();\n         let ch = comm::chan(po);\n@@ -368,6 +375,33 @@ impl task_builder for task_builder {\n         }\n         comm::recv(setup_po)\n     }\n+\n+    /**\n+     * Execute a function in another task and return either the return value\n+     * of the function or result::err.\n+     *\n+     * # Return value\n+     *\n+     * If the function executed successfully then try returns result::ok\n+     * containing the value returned by the function. If the function fails\n+     * then try returns result::err containing nil.\n+     *\n+     * # Failure\n+     * Fails if a future_result was already set for this task.\n+     */\n+    fn try<T: send>(+f: fn~() -> T) -> result<T,()> {\n+        let po = comm::port();\n+        let ch = comm::chan(po);\n+        let mut result = none;\n+\n+        do self.future_result(|-r| { result = some(r); }).spawn {\n+            comm::send(ch, f());\n+        }\n+        match future::get(option::unwrap(result)) {\n+            success => result::ok(comm::recv(po)),\n+            failure => result::err(())\n+        }\n+    }\n }\n \n \n@@ -487,25 +521,10 @@ fn try<T:send>(+f: fn~() -> T) -> result<T,()> {\n      * Execute a function in another task and return either the return value\n      * of the function or result::err.\n      *\n-     * # Return value\n-     *\n-     * If the function executed successfully then try returns result::ok\n-     * containing the value returned by the function. If the function fails\n-     * then try returns result::err containing nil.\n+     * This is equivalent to task().supervised().try.\n      */\n \n-    let po = comm::port();\n-    let ch = comm::chan(po);\n-\n-    let mut result = none;\n-\n-    do task().unlinked().future_result(|-r| { result = some(r); }).spawn {\n-        comm::send(ch, f());\n-    }\n-    match future::get(option::unwrap(result)) {\n-      success => result::ok(comm::recv(po)),\n-      failure => result::err(())\n-    }\n+    task().supervised().try(f)\n }\n \n \n@@ -1675,6 +1694,11 @@ fn test_future_result() {\n     assert future::get(option::unwrap(result)) == failure;\n }\n \n+#[test] #[should_fail] #[ignore(cfg(windows))]\n+fn test_back_to_the_future_result() {\n+    let _ = task().future_result(|-r| ()).future_result(|-r| ());\n+}\n+\n #[test]\n fn test_spawn_listiner_bidi() {\n     let po = comm::port();"}]}