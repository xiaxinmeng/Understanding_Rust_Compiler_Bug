{"sha": "bfed3c4f0d285df97c0e9cbe342665b8b37b7a96", "node_id": "C_kwDOAAsO6NoAKGJmZWQzYzRmMGQyODVkZjk3YzBlOWNiZTM0MjY2NWI4YjM3YjdhOTY", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-03-17T00:33:54Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-03-17T17:08:01Z"}, "message": "implement simd bitmask intrinsics", "tree": {"sha": "ea94f1d19efc3e9260cfd2d527e3ecd42fb9c683", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea94f1d19efc3e9260cfd2d527e3ecd42fb9c683"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfed3c4f0d285df97c0e9cbe342665b8b37b7a96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfed3c4f0d285df97c0e9cbe342665b8b37b7a96", "html_url": "https://github.com/rust-lang/rust/commit/bfed3c4f0d285df97c0e9cbe342665b8b37b7a96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfed3c4f0d285df97c0e9cbe342665b8b37b7a96/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "670dc7d55126cad910e554d98ad6f49e5381f645", "url": "https://api.github.com/repos/rust-lang/rust/commits/670dc7d55126cad910e554d98ad6f49e5381f645", "html_url": "https://github.com/rust-lang/rust/commit/670dc7d55126cad910e554d98ad6f49e5381f645"}], "stats": {"total": 104, "additions": 87, "deletions": 17}, "files": [{"sha": "fe2f33ffd33e52c78b20f9aa2c35fa20774779c5", "filename": "src/helpers.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bfed3c4f0d285df97c0e9cbe342665b8b37b7a96/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfed3c4f0d285df97c0e9cbe342665b8b37b7a96/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=bfed3c4f0d285df97c0e9cbe342665b8b37b7a96", "patch": "@@ -775,18 +775,3 @@ pub fn isolation_abort_error(name: &str) -> InterpResult<'static> {\n         name,\n     )))\n }\n-\n-pub fn bool_to_simd_element(b: bool, size: Size) -> Scalar<Tag> {\n-    // SIMD uses all-1 as pattern for \"true\"\n-    let val = if b { -1 } else { 0 };\n-    Scalar::from_int(val, size)\n-}\n-\n-pub fn simd_element_to_bool<'tcx>(elem: ImmTy<'tcx, Tag>) -> InterpResult<'tcx, bool> {\n-    let val = elem.to_scalar()?.to_int(elem.layout.size)?;\n-    Ok(match val {\n-        0 => false,\n-        -1 => true,\n-        _ => throw_ub_format!(\"each element of a SIMD mask must be all-0-bits or all-1-bits\"),\n-    })\n-}"}, {"sha": "b704004e16c0f6d21d7226e163a768c35848d12b", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 72, "deletions": 2, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/bfed3c4f0d285df97c0e9cbe342665b8b37b7a96/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfed3c4f0d285df97c0e9cbe342665b8b37b7a96/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=bfed3c4f0d285df97c0e9cbe342665b8b37b7a96", "patch": "@@ -1,14 +1,15 @@\n+use std::convert::TryInto;\n use std::iter;\n \n use log::trace;\n \n use rustc_apfloat::{Float, Round};\n use rustc_middle::ty::layout::{HasParamEnv, IntegerExt, LayoutOf};\n use rustc_middle::{mir, mir::BinOp, ty, ty::FloatTy};\n-use rustc_target::abi::{Align, Integer};\n+use rustc_target::abi::{Align, Endian, HasDataLayout, Integer, Size};\n \n use crate::*;\n-use helpers::{bool_to_simd_element, check_arg_count, simd_element_to_bool};\n+use helpers::check_arg_count;\n \n pub enum AtomicOp {\n     MirOp(mir::BinOp, bool),\n@@ -663,6 +664,35 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     this.write_immediate(*val, &dest.into())?;\n                 }\n             }\n+            \"simd_select_bitmask\" => {\n+                let &[ref mask, ref yes, ref no] = check_arg_count(args)?;\n+                let (yes, yes_len) = this.operand_to_simd(yes)?;\n+                let (no, no_len) = this.operand_to_simd(no)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+\n+                assert!(mask.layout.ty.is_integral());\n+                assert_eq!(dest_len.max(8), mask.layout.size.bits());\n+                assert!(dest_len <= 64);\n+                assert_eq!(dest_len, yes_len);\n+                assert_eq!(dest_len, no_len);\n+\n+                let mask: u64 = this\n+                    .read_scalar(mask)?\n+                    .check_init()?\n+                    .to_bits(mask.layout.size)?\n+                    .try_into()\n+                    .unwrap();\n+                for i in 0..dest_len {\n+                    let mask =\n+                        mask & (1 << simd_bitmask_index(i, dest_len, this.data_layout().endian));\n+                    let yes = this.read_immediate(&this.mplace_index(&yes, i)?.into())?;\n+                    let no = this.read_immediate(&this.mplace_index(&no, i)?.into())?;\n+                    let dest = this.mplace_index(&dest, i)?;\n+\n+                    let val = if mask != 0 { yes } else { no };\n+                    this.write_immediate(*val, &dest.into())?;\n+                }\n+            }\n             #[rustfmt::skip]\n             \"simd_cast\" | \"simd_as\" => {\n                 let &[ref op] = check_arg_count(args)?;\n@@ -787,6 +817,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     }\n                 }\n             }\n+            \"simd_bitmask\" => {\n+                let &[ref op] = check_arg_count(args)?;\n+                let (op, op_len) = this.operand_to_simd(op)?;\n+\n+                assert!(dest.layout.ty.is_integral());\n+                assert_eq!(op_len.max(8), dest.layout.size.bits());\n+                assert!(op_len <= 64);\n+\n+                let mut res = 0u64;\n+                for i in 0..op_len {\n+                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n+                    if simd_element_to_bool(op)? {\n+                        res |= 1 << simd_bitmask_index(i, op_len, this.data_layout().endian);\n+                    }\n+                }\n+                this.write_int(res, dest)?;\n+            }\n \n             // Atomic operations\n             \"atomic_load\" => this.atomic_load(args, dest, AtomicReadOp::SeqCst)?,\n@@ -1307,3 +1354,26 @@ fn fmin_op<'tcx>(\n         FloatTy::F64 => Scalar::from_f64(left.to_f64()?.min(right.to_f64()?)),\n     })\n }\n+\n+fn bool_to_simd_element(b: bool, size: Size) -> Scalar<Tag> {\n+    // SIMD uses all-1 as pattern for \"true\"\n+    let val = if b { -1 } else { 0 };\n+    Scalar::from_int(val, size)\n+}\n+\n+fn simd_element_to_bool<'tcx>(elem: ImmTy<'tcx, Tag>) -> InterpResult<'tcx, bool> {\n+    let val = elem.to_scalar()?.to_int(elem.layout.size)?;\n+    Ok(match val {\n+        0 => false,\n+        -1 => true,\n+        _ => throw_ub_format!(\"each element of a SIMD mask must be all-0-bits or all-1-bits\"),\n+    })\n+}\n+\n+fn simd_bitmask_index(idx: u64, len: u64, endianess: Endian) -> u64 {\n+    assert!(idx < len);\n+    match endianess {\n+        Endian::Little => idx,\n+        Endian::Big => len.max(8) - 1 - idx, // reverse order of bits\n+    }\n+}"}, {"sha": "a74559b72be4b7bf774c571c5f9f62eab6cc3db1", "filename": "tests/run-pass/portable-simd.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bfed3c4f0d285df97c0e9cbe342665b8b37b7a96/tests%2Frun-pass%2Fportable-simd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfed3c4f0d285df97c0e9cbe342665b8b37b7a96/tests%2Frun-pass%2Fportable-simd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fportable-simd.rs?ref=bfed3c4f0d285df97c0e9cbe342665b8b37b7a96", "patch": "@@ -187,6 +187,21 @@ fn simd_mask() {\n     let intmask = Mask::from_int(i32x4::from_array([0, -1, 0, 0]));\n     assert_eq!(intmask, Mask::from_array([false, true, false, false]));\n     assert_eq!(intmask.to_array(), [false, true, false, false]);\n+\n+    let values = [\n+        true, false, false, true, false, false, true, false, true, true, false, false, false, true,\n+        false, true,\n+    ];\n+    let mask = Mask::<i64, 16>::from_array(values);\n+    let bitmask = mask.to_bitmask();\n+    assert_eq!(bitmask, 0b1010001101001001);\n+    assert_eq!(Mask::<i64, 16>::from_bitmask(bitmask), mask);\n+\n+    let values = [false, false, false, true];\n+    let mask = Mask::<i64, 4>::from_array(values);\n+    let bitmask = mask.to_bitmask();\n+    assert_eq!(bitmask, 0b1000);\n+    assert_eq!(Mask::<i64, 4>::from_bitmask(bitmask), mask);\n }\n \n fn simd_cast() {"}]}