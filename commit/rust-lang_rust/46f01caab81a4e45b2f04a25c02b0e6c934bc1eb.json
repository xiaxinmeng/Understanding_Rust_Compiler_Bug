{"sha": "46f01caab81a4e45b2f04a25c02b0e6c934bc1eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2ZjAxY2FhYjgxYTRlNDViMmYwNGEyNWMwMmIwZTZjOTM0YmMxZWI=", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-08-02T02:03:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-02T02:03:23Z"}, "message": "Rollup merge of #87282 - pietroalbini:refactor-extended, r=Mark-Simulacrum\n\nEnsure `./x.py dist` adheres to `build.tools`\n\nAccording to `config.toml.example`, the way to produce dist artifacts for both the compiler and a *subset* of tools would be to enable the extended build and manually specify the list of tools to build:\n\n```toml\n[build]\nextended = true\ntools = [\"cargo\", \"rustfmt\"]\n```\n\nThis works as expected for `./x.py build` and `./x.py install`, but *not* for `./x.py dist`. Before this PR `./x.py dist` simply ignored the contents of `build.tools`, building just rustc/rustdoc if `build.extended = false` and all of the tools otherwise. This PR does two things:\n\n* Changes `./x.py dist extended` to only build the tools defined in `build.tools`, if `build.tools` is not empty. The rest of the extended step was refactored to simplify the code.\n* Changes how dist jobs for tools are gated: instead of `assert!(builder.config.extended)` to prevent tools from being built with `build.extended = false`, tools are simply built by default depending on `build.extended` and `build.tools`. This also enables to **explicitly** dist tools even with `build.extended = false`.\n\nThis PR is best reviewed commit-by-commit.\n\nFixes #86436", "tree": {"sha": "8c374b2897ac552f8346a2fa55ad2c7f4a064dee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c374b2897ac552f8346a2fa55ad2c7f4a064dee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46f01caab81a4e45b2f04a25c02b0e6c934bc1eb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhB1JsCRBK7hj4Ov3rIwAAPg0IAJIQMLPy7zPGh5WjpAgbrL31\ncvOGbKE+o3vMki+BjQBwLo2Xy7pZlcanvkdsGbRLvEHfOL8ZguF+n/gyuHLXlSyi\nvJhzm8hRZvvjj3WdZFlqm7cs6gVc6ih2+pBOdSYN1WrnoeHbliYd90w4i3UEQ2YX\n/RYg5+0x/bBimnKeUy6jDhR63NpBkQeGWnab3T1YwhZarA/iFZy+dQj0rFzOmpWy\nr8M1xbDl0raeeUa5YdUHh7C7+4lkKB8JgXPFoMXjabeJfWAomxoVKPDCIVu3f58k\nYu82Qs4pHFL92eEECqug5BkV/40R8ITIVy4/OeOjTylTpKwTUPh5L5SlZDyTK2o=\n=yaPa\n-----END PGP SIGNATURE-----\n", "payload": "tree 8c374b2897ac552f8346a2fa55ad2c7f4a064dee\nparent f386ae3533798b75122bbbf659d1ed10fc3aeff4\nparent 69f712c088b16fa88672efa2d49fe2d6ea4ca06e\nauthor Yuki Okushi <jtitor@2k36.org> 1627869803 +0900\ncommitter GitHub <noreply@github.com> 1627869803 +0900\n\nRollup merge of #87282 - pietroalbini:refactor-extended, r=Mark-Simulacrum\n\nEnsure `./x.py dist` adheres to `build.tools`\n\nAccording to `config.toml.example`, the way to produce dist artifacts for both the compiler and a *subset* of tools would be to enable the extended build and manually specify the list of tools to build:\n\n```toml\n[build]\nextended = true\ntools = [\"cargo\", \"rustfmt\"]\n```\n\nThis works as expected for `./x.py build` and `./x.py install`, but *not* for `./x.py dist`. Before this PR `./x.py dist` simply ignored the contents of `build.tools`, building just rustc/rustdoc if `build.extended = false` and all of the tools otherwise. This PR does two things:\n\n* Changes `./x.py dist extended` to only build the tools defined in `build.tools`, if `build.tools` is not empty. The rest of the extended step was refactored to simplify the code.\n* Changes how dist jobs for tools are gated: instead of `assert!(builder.config.extended)` to prevent tools from being built with `build.extended = false`, tools are simply built by default depending on `build.extended` and `build.tools`. This also enables to **explicitly** dist tools even with `build.extended = false`.\n\nThis PR is best reviewed commit-by-commit.\n\nFixes #86436\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46f01caab81a4e45b2f04a25c02b0e6c934bc1eb", "html_url": "https://github.com/rust-lang/rust/commit/46f01caab81a4e45b2f04a25c02b0e6c934bc1eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46f01caab81a4e45b2f04a25c02b0e6c934bc1eb/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f386ae3533798b75122bbbf659d1ed10fc3aeff4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f386ae3533798b75122bbbf659d1ed10fc3aeff4", "html_url": "https://github.com/rust-lang/rust/commit/f386ae3533798b75122bbbf659d1ed10fc3aeff4"}, {"sha": "69f712c088b16fa88672efa2d49fe2d6ea4ca06e", "url": "https://api.github.com/repos/rust-lang/rust/commits/69f712c088b16fa88672efa2d49fe2d6ea4ca06e", "html_url": "https://github.com/rust-lang/rust/commit/69f712c088b16fa88672efa2d49fe2d6ea4ca06e"}], "stats": {"total": 289, "additions": 154, "deletions": 135}, "files": [{"sha": "f2d841cb335ab5a0316839fbaba9cef1883e2d73", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 37, "deletions": 7, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/46f01caab81a4e45b2f04a25c02b0e6c934bc1eb/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f01caab81a4e45b2f04a25c02b0e6c934bc1eb/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=46f01caab81a4e45b2f04a25c02b0e6c934bc1eb", "patch": "@@ -163,14 +163,8 @@ impl StepDescription {\n     }\n \n     fn maybe_run(&self, builder: &Builder<'_>, pathset: &PathSet) {\n-        if builder.config.exclude.iter().any(|e| pathset.has(e)) {\n-            eprintln!(\"Skipping {:?} because it is excluded\", pathset);\n+        if self.is_excluded(builder, pathset) {\n             return;\n-        } else if !builder.config.exclude.is_empty() {\n-            eprintln!(\n-                \"{:?} not skipped for {:?} -- not in {:?}\",\n-                pathset, self.name, builder.config.exclude\n-            );\n         }\n \n         // Determine the targets participating in this rule.\n@@ -182,6 +176,21 @@ impl StepDescription {\n         }\n     }\n \n+    fn is_excluded(&self, builder: &Builder<'_>, pathset: &PathSet) -> bool {\n+        if builder.config.exclude.iter().any(|e| pathset.has(e)) {\n+            eprintln!(\"Skipping {:?} because it is excluded\", pathset);\n+            return true;\n+        }\n+\n+        if !builder.config.exclude.is_empty() {\n+            eprintln!(\n+                \"{:?} not skipped for {:?} -- not in {:?}\",\n+                pathset, self.name, builder.config.exclude\n+            );\n+        }\n+        false\n+    }\n+\n     fn run(v: &[StepDescription], builder: &Builder<'_>, paths: &[PathBuf]) {\n         let should_runs =\n             v.iter().map(|desc| (desc.should_run)(ShouldRun::new(builder))).collect::<Vec<_>>();\n@@ -1579,6 +1588,27 @@ impl<'a> Builder<'a> {\n         self.cache.put(step, out.clone());\n         out\n     }\n+\n+    /// Ensure that a given step is built *only if it's supposed to be built by default*, returning\n+    /// its output. This will cache the step, so it's safe (and good!) to call this as often as\n+    /// needed to ensure that all dependencies are build.\n+    pub(crate) fn ensure_if_default<T, S: Step<Output = Option<T>>>(\n+        &'a self,\n+        step: S,\n+    ) -> S::Output {\n+        let desc = StepDescription::from::<S>();\n+        let should_run = (desc.should_run)(ShouldRun::new(self));\n+\n+        // Avoid running steps contained in --exclude\n+        for pathset in &should_run.paths {\n+            if desc.is_excluded(self, pathset) {\n+                return None;\n+            }\n+        }\n+\n+        // Only execute if it's supposed to run as default\n+        if desc.default && should_run.is_really_default() { self.ensure(step) } else { None }\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "64075e18366bfbada2f733a93a2b7c3dc6c706c2", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 109, "deletions": 120, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/46f01caab81a4e45b2f04a25c02b0e6c934bc1eb/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f01caab81a4e45b2f04a25c02b0e6c934bc1eb/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=46f01caab81a4e45b2f04a25c02b0e6c934bc1eb", "patch": "@@ -8,6 +8,7 @@\n //! out to `rust-installer` still. This may one day be replaced with bits and\n //! pieces of `rustup.rs`!\n \n+use std::collections::HashSet;\n use std::env;\n use std::fs;\n use std::path::{Path, PathBuf};\n@@ -45,6 +46,13 @@ fn missing_tool(tool_name: &str, skip: bool) {\n     }\n }\n \n+fn should_build_extended_tool(builder: &Builder<'_>, tool: &str) -> bool {\n+    if !builder.config.extended {\n+        return false;\n+    }\n+    builder.config.tools.as_ref().map_or(true, |tools| tools.contains(tool))\n+}\n+\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Docs {\n     pub host: TargetSelection,\n@@ -55,7 +63,8 @@ impl Step for Docs {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.path(\"src/doc\")\n+        let default = run.builder.config.docs;\n+        run.path(\"src/doc\").default_condition(default)\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -65,9 +74,6 @@ impl Step for Docs {\n     /// Builds the `rust-docs` installer component.\n     fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let host = self.host;\n-        if !builder.config.docs {\n-            return None;\n-        }\n         builder.default_doc(&[]);\n \n         let dest = \"share/doc/rust/html\";\n@@ -676,8 +682,8 @@ impl Step for Analysis {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        let builder = run.builder;\n-        run.path(\"analysis\").default_condition(builder.config.extended)\n+        let default = should_build_extended_tool(&run.builder, \"analysis\");\n+        run.path(\"analysis\").default_condition(default)\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -698,7 +704,6 @@ impl Step for Analysis {\n     fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let compiler = self.compiler;\n         let target = self.target;\n-        assert!(builder.config.extended);\n         if compiler.host != builder.config.build {\n             return None;\n         }\n@@ -953,11 +958,13 @@ pub struct Cargo {\n }\n \n impl Step for Cargo {\n-    type Output = GeneratedTarball;\n+    type Output = Option<GeneratedTarball>;\n+    const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.path(\"cargo\")\n+        let default = should_build_extended_tool(&run.builder, \"cargo\");\n+        run.path(\"cargo\").default_condition(default)\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -971,7 +978,7 @@ impl Step for Cargo {\n         });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> GeneratedTarball {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let compiler = self.compiler;\n         let target = self.target;\n \n@@ -996,7 +1003,7 @@ impl Step for Cargo {\n             }\n         }\n \n-        tarball.generate()\n+        Some(tarball.generate())\n     }\n }\n \n@@ -1009,9 +1016,11 @@ pub struct Rls {\n impl Step for Rls {\n     type Output = Option<GeneratedTarball>;\n     const ONLY_HOSTS: bool = true;\n+    const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.path(\"rls\")\n+        let default = should_build_extended_tool(&run.builder, \"rls\");\n+        run.path(\"rls\").default_condition(default)\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -1028,7 +1037,6 @@ impl Step for Rls {\n     fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let compiler = self.compiler;\n         let target = self.target;\n-        assert!(builder.config.extended);\n \n         let rls = builder\n             .ensure(tool::Rls { compiler, target, extra_features: Vec::new() })\n@@ -1054,10 +1062,12 @@ pub struct RustAnalyzer {\n \n impl Step for RustAnalyzer {\n     type Output = Option<GeneratedTarball>;\n+    const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.path(\"rust-analyzer\")\n+        let default = should_build_extended_tool(&run.builder, \"rust-analyzer\");\n+        run.path(\"rust-analyzer\").default_condition(default)\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -1080,7 +1090,6 @@ impl Step for RustAnalyzer {\n         }\n         let compiler = self.compiler;\n         let target = self.target;\n-        assert!(builder.config.extended);\n \n         if target.contains(\"riscv64\") {\n             // riscv64 currently has an LLVM bug that makes rust-analyzer unable\n@@ -1108,11 +1117,13 @@ pub struct Clippy {\n }\n \n impl Step for Clippy {\n-    type Output = GeneratedTarball;\n+    type Output = Option<GeneratedTarball>;\n+    const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.path(\"clippy\")\n+        let default = should_build_extended_tool(&run.builder, \"clippy\");\n+        run.path(\"clippy\").default_condition(default)\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -1126,10 +1137,9 @@ impl Step for Clippy {\n         });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> GeneratedTarball {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let compiler = self.compiler;\n         let target = self.target;\n-        assert!(builder.config.extended);\n \n         // Prepare the image directory\n         // We expect clippy to build, because we've exited this step above if tool\n@@ -1147,7 +1157,7 @@ impl Step for Clippy {\n         tarball.add_file(clippy, \"bin\", 0o755);\n         tarball.add_file(cargoclippy, \"bin\", 0o755);\n         tarball.add_legal_and_readme_to(\"share/doc/clippy\");\n-        tarball.generate()\n+        Some(tarball.generate())\n     }\n }\n \n@@ -1159,10 +1169,12 @@ pub struct Miri {\n \n impl Step for Miri {\n     type Output = Option<GeneratedTarball>;\n+    const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.path(\"miri\")\n+        let default = should_build_extended_tool(&run.builder, \"miri\");\n+        run.path(\"miri\").default_condition(default)\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -1185,7 +1197,6 @@ impl Step for Miri {\n         }\n         let compiler = self.compiler;\n         let target = self.target;\n-        assert!(builder.config.extended);\n \n         let miri = builder\n             .ensure(tool::Miri { compiler, target, extra_features: Vec::new() })\n@@ -1218,10 +1229,12 @@ pub struct Rustfmt {\n \n impl Step for Rustfmt {\n     type Output = Option<GeneratedTarball>;\n+    const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.path(\"rustfmt\")\n+        let default = should_build_extended_tool(&run.builder, \"rustfmt\");\n+        run.path(\"rustfmt\").default_condition(default)\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -1270,10 +1283,17 @@ pub struct RustDemangler {\n \n impl Step for RustDemangler {\n     type Output = Option<GeneratedTarball>;\n+    const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.path(\"rust-demangler\")\n+        // While other tools use `should_build_extended_tool` to decide whether to be run by\n+        // default or not, `rust-demangler` must be build when *either* it's enabled as a tool like\n+        // the other ones or if `profiler = true`. Because we don't know the target at this stage\n+        // we run the step by default when only `extended = true`, and decide whether to actually\n+        // run it or not later.\n+        let default = run.builder.config.extended;\n+        run.path(\"rust-demangler\").default_condition(default)\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -1290,11 +1310,11 @@ impl Step for RustDemangler {\n     fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let compiler = self.compiler;\n         let target = self.target;\n-        assert!(builder.config.extended);\n \n         // Only build this extended tool if explicitly included in `tools`, or if `profiler = true`\n-        let profiler = builder.config.profiler_enabled(target);\n-        if !builder.config.tools.as_ref().map_or(profiler, |t| t.contains(\"rust-demangler\")) {\n+        let condition = should_build_extended_tool(builder, \"rust-demangler\")\n+            || builder.config.profiler_enabled(target);\n+        if builder.config.extended && !condition {\n             return None;\n         }\n \n@@ -1345,51 +1365,44 @@ impl Step for Extended {\n \n         builder.info(&format!(\"Dist extended stage{} ({})\", compiler.stage, target));\n \n-        let rustc_installer = builder.ensure(Rustc { compiler: builder.compiler(stage, target) });\n-        let cargo_installer = builder.ensure(Cargo { compiler, target });\n-        let rustfmt_installer = builder.ensure(Rustfmt { compiler, target });\n-        let rust_demangler_installer = builder.ensure(RustDemangler { compiler, target });\n-        let rls_installer = builder.ensure(Rls { compiler, target });\n-        let rust_analyzer_installer = builder.ensure(RustAnalyzer { compiler, target });\n-        let llvm_tools_installer = builder.ensure(LlvmTools { target });\n-        let clippy_installer = builder.ensure(Clippy { compiler, target });\n-        let miri_installer = builder.ensure(Miri { compiler, target });\n-        let mingw_installer = builder.ensure(Mingw { host: target });\n-        let analysis_installer = builder.ensure(Analysis { compiler, target });\n-\n-        let docs_installer = builder.ensure(Docs { host: target });\n-        let std_installer = builder.ensure(Std { compiler, target });\n-\n-        let etc = builder.src.join(\"src/etc/installer\");\n-\n-        // Avoid producing tarballs during a dry run.\n-        if builder.config.dry_run {\n-            return;\n+        let mut tarballs = Vec::new();\n+        let mut built_tools = HashSet::new();\n+        macro_rules! add_component {\n+            ($name:expr => $step:expr) => {\n+                if let Some(tarball) = builder.ensure_if_default($step) {\n+                    tarballs.push(tarball);\n+                    built_tools.insert($name);\n+                }\n+            };\n         }\n \n         // When rust-std package split from rustc, we needed to ensure that during\n         // upgrades rustc was upgraded before rust-std. To avoid rustc clobbering\n         // the std files during uninstall. To do this ensure that rustc comes\n         // before rust-std in the list below.\n-        let mut tarballs = Vec::new();\n-        tarballs.push(rustc_installer);\n-        tarballs.push(cargo_installer);\n-        tarballs.push(clippy_installer);\n-        tarballs.extend(rust_demangler_installer.clone());\n-        tarballs.extend(rls_installer.clone());\n-        tarballs.extend(rust_analyzer_installer.clone());\n-        tarballs.extend(miri_installer.clone());\n-        tarballs.extend(rustfmt_installer.clone());\n-        tarballs.extend(llvm_tools_installer);\n-        if let Some(analysis_installer) = analysis_installer {\n-            tarballs.push(analysis_installer);\n-        }\n-        tarballs.push(std_installer.expect(\"missing std\"));\n-        if let Some(docs_installer) = docs_installer {\n-            tarballs.push(docs_installer);\n+        tarballs.push(builder.ensure(Rustc { compiler: builder.compiler(stage, target) }));\n+        tarballs.push(builder.ensure(Std { compiler, target }).expect(\"missing std\"));\n+\n+        if target.contains(\"windows-gnu\") {\n+            tarballs.push(builder.ensure(Mingw { host: target }).expect(\"missing mingw\"));\n         }\n-        if target.contains(\"pc-windows-gnu\") {\n-            tarballs.push(mingw_installer.unwrap());\n+\n+        add_component!(\"rust-docs\" => Docs { host: target });\n+        add_component!(\"rust-demangler\"=> RustDemangler { compiler, target });\n+        add_component!(\"cargo\" => Cargo { compiler, target });\n+        add_component!(\"rustfmt\" => Rustfmt { compiler, target });\n+        add_component!(\"rls\" => Rls { compiler, target });\n+        add_component!(\"rust-analyzer\" => RustAnalyzer { compiler, target });\n+        add_component!(\"llvm-components\" => LlvmTools { target });\n+        add_component!(\"clippy\" => Clippy { compiler, target });\n+        add_component!(\"miri\" => Miri { compiler, target });\n+        add_component!(\"analysis\" => Analysis { compiler, target });\n+\n+        let etc = builder.src.join(\"src/etc/installer\");\n+\n+        // Avoid producing tarballs during a dry run.\n+        if builder.config.dry_run {\n+            return;\n         }\n \n         let tarball = Tarball::new(builder, \"rust\", &target.triple);\n@@ -1434,20 +1447,10 @@ impl Step for Extended {\n \n         let xform = |p: &Path| {\n             let mut contents = t!(fs::read_to_string(p));\n-            if rust_demangler_installer.is_none() {\n-                contents = filter(&contents, \"rust-demangler\");\n-            }\n-            if rls_installer.is_none() {\n-                contents = filter(&contents, \"rls\");\n-            }\n-            if rust_analyzer_installer.is_none() {\n-                contents = filter(&contents, \"rust-analyzer\");\n-            }\n-            if miri_installer.is_none() {\n-                contents = filter(&contents, \"miri\");\n-            }\n-            if rustfmt_installer.is_none() {\n-                contents = filter(&contents, \"rustfmt\");\n+            for tool in &[\"rust-demangler\", \"rls\", \"rust-analyzer\", \"miri\", \"rustfmt\"] {\n+                if !built_tools.contains(tool) {\n+                    contents = filter(&contents, tool);\n+                }\n             }\n             let ret = tmp.join(p.file_name().unwrap());\n             t!(fs::write(&ret, &contents));\n@@ -1485,19 +1488,11 @@ impl Step for Extended {\n             prepare(\"rust-std\");\n             prepare(\"rust-analysis\");\n             prepare(\"clippy\");\n-            if rust_demangler_installer.is_some() {\n-                prepare(\"rust-demangler\");\n-            }\n-            if rls_installer.is_some() {\n-                prepare(\"rls\");\n-            }\n-            if rust_analyzer_installer.is_some() {\n-                prepare(\"rust-analyzer\");\n-            }\n-            if miri_installer.is_some() {\n-                prepare(\"miri\");\n+            for tool in &[\"rust-demangler\", \"rls\", \"rust-analyzer\", \"miri\"] {\n+                if built_tools.contains(tool) {\n+                    prepare(tool);\n+                }\n             }\n-\n             // create an 'uninstall' package\n             builder.install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"uninstall\"), 0o755);\n             pkgbuild(\"uninstall\");\n@@ -1554,17 +1549,10 @@ impl Step for Extended {\n             prepare(\"rust-docs\");\n             prepare(\"rust-std\");\n             prepare(\"clippy\");\n-            if rust_demangler_installer.is_some() {\n-                prepare(\"rust-demangler\");\n-            }\n-            if rls_installer.is_some() {\n-                prepare(\"rls\");\n-            }\n-            if rust_analyzer_installer.is_some() {\n-                prepare(\"rust-analyzer\");\n-            }\n-            if miri_installer.is_some() {\n-                prepare(\"miri\");\n+            for tool in &[\"rust-demangler\", \"rls\", \"rust-analyzer\", \"miri\"] {\n+                if built_tools.contains(tool) {\n+                    prepare(tool);\n+                }\n             }\n             if target.contains(\"windows-gnu\") {\n                 prepare(\"rust-mingw\");\n@@ -1643,7 +1631,7 @@ impl Step for Extended {\n                     .arg(\"-out\")\n                     .arg(exe.join(\"StdGroup.wxs\")),\n             );\n-            if rls_installer.is_some() {\n+            if built_tools.contains(\"rls\") {\n                 builder.run(\n                     Command::new(&heat)\n                         .current_dir(&exe)\n@@ -1662,7 +1650,7 @@ impl Step for Extended {\n                         .arg(etc.join(\"msi/remove-duplicates.xsl\")),\n                 );\n             }\n-            if rust_analyzer_installer.is_some() {\n+            if built_tools.contains(\"rust-analyzer\") {\n                 builder.run(\n                     Command::new(&heat)\n                         .current_dir(&exe)\n@@ -1698,7 +1686,7 @@ impl Step for Extended {\n                     .arg(\"-t\")\n                     .arg(etc.join(\"msi/remove-duplicates.xsl\")),\n             );\n-            if rust_demangler_installer.is_some() {\n+            if built_tools.contains(\"rust-demangler\") {\n                 builder.run(\n                     Command::new(&heat)\n                         .current_dir(&exe)\n@@ -1717,7 +1705,7 @@ impl Step for Extended {\n                         .arg(etc.join(\"msi/remove-duplicates.xsl\")),\n                 );\n             }\n-            if miri_installer.is_some() {\n+            if built_tools.contains(\"miri\") {\n                 builder.run(\n                     Command::new(&heat)\n                         .current_dir(&exe)\n@@ -1790,16 +1778,16 @@ impl Step for Extended {\n                     .arg(&input);\n                 add_env(builder, &mut cmd, target);\n \n-                if rust_demangler_installer.is_some() {\n+                if built_tools.contains(\"rust-demangler\") {\n                     cmd.arg(\"-dRustDemanglerDir=rust-demangler\");\n                 }\n-                if rls_installer.is_some() {\n+                if built_tools.contains(\"rls\") {\n                     cmd.arg(\"-dRlsDir=rls\");\n                 }\n-                if rust_analyzer_installer.is_some() {\n+                if built_tools.contains(\"rust-analyzer\") {\n                     cmd.arg(\"-dRustAnalyzerDir=rust-analyzer\");\n                 }\n-                if miri_installer.is_some() {\n+                if built_tools.contains(\"miri\") {\n                     cmd.arg(\"-dMiriDir=miri\");\n                 }\n                 if target.contains(\"windows-gnu\") {\n@@ -1815,16 +1803,16 @@ impl Step for Extended {\n             candle(\"CargoGroup.wxs\".as_ref());\n             candle(\"StdGroup.wxs\".as_ref());\n             candle(\"ClippyGroup.wxs\".as_ref());\n-            if rust_demangler_installer.is_some() {\n+            if built_tools.contains(\"rust-demangler\") {\n                 candle(\"RustDemanglerGroup.wxs\".as_ref());\n             }\n-            if rls_installer.is_some() {\n+            if built_tools.contains(\"rls\") {\n                 candle(\"RlsGroup.wxs\".as_ref());\n             }\n-            if rust_analyzer_installer.is_some() {\n+            if built_tools.contains(\"rust-analyzer\") {\n                 candle(\"RustAnalyzerGroup.wxs\".as_ref());\n             }\n-            if miri_installer.is_some() {\n+            if built_tools.contains(\"miri\") {\n                 candle(\"MiriGroup.wxs\".as_ref());\n             }\n             candle(\"AnalysisGroup.wxs\".as_ref());\n@@ -1858,16 +1846,16 @@ impl Step for Extended {\n                 .arg(\"ClippyGroup.wixobj\")\n                 .current_dir(&exe);\n \n-            if rls_installer.is_some() {\n+            if built_tools.contains(\"rls\") {\n                 cmd.arg(\"RlsGroup.wixobj\");\n             }\n-            if rust_analyzer_installer.is_some() {\n+            if built_tools.contains(\"rust-analyzer\") {\n                 cmd.arg(\"RustAnalyzerGroup.wixobj\");\n             }\n-            if rust_demangler_installer.is_some() {\n+            if built_tools.contains(\"rust-demangler\") {\n                 cmd.arg(\"RustDemanglerGroup.wixobj\");\n             }\n-            if miri_installer.is_some() {\n+            if built_tools.contains(\"miri\") {\n                 cmd.arg(\"MiriGroup.wixobj\");\n             }\n \n@@ -2003,9 +1991,11 @@ pub struct LlvmTools {\n impl Step for LlvmTools {\n     type Output = Option<GeneratedTarball>;\n     const ONLY_HOSTS: bool = true;\n+    const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.path(\"llvm-tools\")\n+        let default = should_build_extended_tool(&run.builder, \"llvm-tools\");\n+        run.path(\"llvm-tools\").default_condition(default)\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -2014,7 +2004,6 @@ impl Step for LlvmTools {\n \n     fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let target = self.target;\n-        assert!(builder.config.extended);\n \n         /* run only if llvm-config isn't used */\n         if let Some(config) = builder.config.target_config.get(&target) {"}, {"sha": "06acf1a9a008367bc2f85cabb20db0090ad06619", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/46f01caab81a4e45b2f04a25c02b0e6c934bc1eb/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f01caab81a4e45b2f04a25c02b0e6c934bc1eb/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=46f01caab81a4e45b2f04a25c02b0e6c934bc1eb", "patch": "@@ -139,12 +139,8 @@ macro_rules! install {\n \n install!((self, builder, _config),\n     Docs, \"src/doc\", _config.docs, only_hosts: false, {\n-        if let Some(tarball) = builder.ensure(dist::Docs { host: self.target }) {\n-            install_sh(builder, \"docs\", self.compiler.stage, Some(self.target), &tarball);\n-        } else {\n-            panic!(\"docs are not available to install, \\\n-                check that `build.docs` is true in `config.toml`\");\n-        }\n+        let tarball = builder.ensure(dist::Docs { host: self.target }).expect(\"missing docs\");\n+        install_sh(builder, \"docs\", self.compiler.stage, Some(self.target), &tarball);\n     };\n     Std, \"library/std\", true, only_hosts: false, {\n         for target in &builder.targets {\n@@ -158,7 +154,9 @@ install!((self, builder, _config),\n         }\n     };\n     Cargo, \"cargo\", Self::should_build(_config), only_hosts: true, {\n-        let tarball = builder.ensure(dist::Cargo { compiler: self.compiler, target: self.target });\n+        let tarball = builder\n+            .ensure(dist::Cargo { compiler: self.compiler, target: self.target })\n+            .expect(\"missing cargo\");\n         install_sh(builder, \"cargo\", self.compiler.stage, Some(self.target), &tarball);\n     };\n     Rls, \"rls\", Self::should_build(_config), only_hosts: true, {\n@@ -182,7 +180,9 @@ install!((self, builder, _config),\n         }\n     };\n     Clippy, \"clippy\", Self::should_build(_config), only_hosts: true, {\n-        let tarball = builder.ensure(dist::Clippy { compiler: self.compiler, target: self.target });\n+        let tarball = builder\n+            .ensure(dist::Clippy { compiler: self.compiler, target: self.target })\n+            .expect(\"missing clippy\");\n         install_sh(builder, \"clippy\", self.compiler.stage, Some(self.target), &tarball);\n     };\n     Miri, \"miri\", Self::should_build(_config), only_hosts: true, {"}]}