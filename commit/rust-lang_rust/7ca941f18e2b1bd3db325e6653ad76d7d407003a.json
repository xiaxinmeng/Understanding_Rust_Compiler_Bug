{"sha": "7ca941f18e2b1bd3db325e6653ad76d7d407003a", "node_id": "C_kwDOAAsO6NoAKDdjYTk0MWYxOGUyYjFiZDNkYjMyNWU2NjUzYWQ3NmQ3ZDQwNzAwM2E", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-05-31T05:07:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-31T05:07:00Z"}, "message": "Rollup merge of #112053 - nnethercote:rm-Zcpu-partitioning-strategy, r=wesleywiser\n\nRemove `-Zcgu-partitioning-strategy`.\n\nThis option was introduced three years ago, but it's never been meaningfully used, and `default` is the only acceptable value.\n\nAlso, I think the `Partition` trait presents an interface that is too closely tied to the existing strategy and would probably be wrong for other strategies. (My rule of thumb is to not make something generic until there are at least two instances of it, to avoid this kind of problem.)\n\nAlso, I don't think providing multiple partitioning strategies to the user is a good idea, because the compiler already has enough obscure knobs.\n\nThis commit removes the option, along with the `Partition` trait, and the `Partitioner` and `DefaultPartitioning` types. I left the existing code in `compiler/rustc_monomorphize/src/partitioning/default.rs`, though I could be persuaded that moving it into\n`compiler/rustc_monomorphize/src/partitioning/mod.rs` is better.\n\nr? ``@wesleywiser``", "tree": {"sha": "d826e62574471257ddb528c552fdf664f951ce9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d826e62574471257ddb528c552fdf664f951ce9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ca941f18e2b1bd3db325e6653ad76d7d407003a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkdtX0CRBK7hj4Ov3rIwAA+mcIAAqbLec1rhoord3MLd4iv6yv\nNBYgD9FesttTtcr4VkFh7epi/3nBoi7E2ppsFHfzkafBFDJlY7CAEWc6yI8km8XX\nNQeah7siGnJVcXS5anWGAK/iot6ybt5PBokKoUUcigplHV0f5FaZ65XRWaRazpz2\nPb0WwZQ+q8kiDhUc7Z7L1yVJfcmW4GP2VUAZCTgS/l3C/qzgZDyWpL1Dqs5AHrK5\n9I67HTBEYQwtxSlLsNBMnT+jp1htkoYwoTAftuuM2uGuPzhzCE99GmwF1w8UYDJg\nBNg1UMxiacqPhh4xUuDJxk5dEUIAjeMM1mMmp3n7J8cVi3dxs2/JosI0JlsREnI=\n=0XM5\n-----END PGP SIGNATURE-----\n", "payload": "tree d826e62574471257ddb528c552fdf664f951ce9b\nparent fdd62cfe7d2ea9189e957951b8b7b8251cd50854\nparent 5ed014977e59f886a51844fcae8eab80467e45e6\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1685509620 +0200\ncommitter GitHub <noreply@github.com> 1685509620 +0200\n\nRollup merge of #112053 - nnethercote:rm-Zcpu-partitioning-strategy, r=wesleywiser\n\nRemove `-Zcgu-partitioning-strategy`.\n\nThis option was introduced three years ago, but it's never been meaningfully used, and `default` is the only acceptable value.\n\nAlso, I think the `Partition` trait presents an interface that is too closely tied to the existing strategy and would probably be wrong for other strategies. (My rule of thumb is to not make something generic until there are at least two instances of it, to avoid this kind of problem.)\n\nAlso, I don't think providing multiple partitioning strategies to the user is a good idea, because the compiler already has enough obscure knobs.\n\nThis commit removes the option, along with the `Partition` trait, and the `Partitioner` and `DefaultPartitioning` types. I left the existing code in `compiler/rustc_monomorphize/src/partitioning/default.rs`, though I could be persuaded that moving it into\n`compiler/rustc_monomorphize/src/partitioning/mod.rs` is better.\n\nr? ``@wesleywiser``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ca941f18e2b1bd3db325e6653ad76d7d407003a", "html_url": "https://github.com/rust-lang/rust/commit/7ca941f18e2b1bd3db325e6653ad76d7d407003a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ca941f18e2b1bd3db325e6653ad76d7d407003a/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdd62cfe7d2ea9189e957951b8b7b8251cd50854", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdd62cfe7d2ea9189e957951b8b7b8251cd50854", "html_url": "https://github.com/rust-lang/rust/commit/fdd62cfe7d2ea9189e957951b8b7b8251cd50854"}, {"sha": "5ed014977e59f886a51844fcae8eab80467e45e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ed014977e59f886a51844fcae8eab80467e45e6", "html_url": "https://github.com/rust-lang/rust/commit/5ed014977e59f886a51844fcae8eab80467e45e6"}], "stats": {"total": 2501, "additions": 1182, "deletions": 1319}, "files": [{"sha": "be9c349c3841621857f1b587bb4389e961fa29bb", "filename": "compiler/rustc_monomorphize/src/partitioning.rs", "status": "added", "additions": 1182, "deletions": 0, "changes": 1182, "blob_url": "https://github.com/rust-lang/rust/blob/7ca941f18e2b1bd3db325e6653ad76d7d407003a/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca941f18e2b1bd3db325e6653ad76d7d407003a/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs?ref=7ca941f18e2b1bd3db325e6653ad76d7d407003a", "patch": "@@ -0,0 +1,1182 @@\n+//! Partitioning Codegen Units for Incremental Compilation\n+//! ======================================================\n+//!\n+//! The task of this module is to take the complete set of monomorphizations of\n+//! a crate and produce a set of codegen units from it, where a codegen unit\n+//! is a named set of (mono-item, linkage) pairs. That is, this module\n+//! decides which monomorphization appears in which codegen units with which\n+//! linkage. The following paragraphs describe some of the background on the\n+//! partitioning scheme.\n+//!\n+//! The most important opportunity for saving on compilation time with\n+//! incremental compilation is to avoid re-codegenning and re-optimizing code.\n+//! Since the unit of codegen and optimization for LLVM is \"modules\" or, how\n+//! we call them \"codegen units\", the particulars of how much time can be saved\n+//! by incremental compilation are tightly linked to how the output program is\n+//! partitioned into these codegen units prior to passing it to LLVM --\n+//! especially because we have to treat codegen units as opaque entities once\n+//! they are created: There is no way for us to incrementally update an existing\n+//! LLVM module and so we have to build any such module from scratch if it was\n+//! affected by some change in the source code.\n+//!\n+//! From that point of view it would make sense to maximize the number of\n+//! codegen units by, for example, putting each function into its own module.\n+//! That way only those modules would have to be re-compiled that were actually\n+//! affected by some change, minimizing the number of functions that could have\n+//! been re-used but just happened to be located in a module that is\n+//! re-compiled.\n+//!\n+//! However, since LLVM optimization does not work across module boundaries,\n+//! using such a highly granular partitioning would lead to very slow runtime\n+//! code since it would effectively prohibit inlining and other inter-procedure\n+//! optimizations. We want to avoid that as much as possible.\n+//!\n+//! Thus we end up with a trade-off: The bigger the codegen units, the better\n+//! LLVM's optimizer can do its work, but also the smaller the compilation time\n+//! reduction we get from incremental compilation.\n+//!\n+//! Ideally, we would create a partitioning such that there are few big codegen\n+//! units with few interdependencies between them. For now though, we use the\n+//! following heuristic to determine the partitioning:\n+//!\n+//! - There are two codegen units for every source-level module:\n+//! - One for \"stable\", that is non-generic, code\n+//! - One for more \"volatile\" code, i.e., monomorphized instances of functions\n+//!   defined in that module\n+//!\n+//! In order to see why this heuristic makes sense, let's take a look at when a\n+//! codegen unit can get invalidated:\n+//!\n+//! 1. The most straightforward case is when the BODY of a function or global\n+//! changes. Then any codegen unit containing the code for that item has to be\n+//! re-compiled. Note that this includes all codegen units where the function\n+//! has been inlined.\n+//!\n+//! 2. The next case is when the SIGNATURE of a function or global changes. In\n+//! this case, all codegen units containing a REFERENCE to that item have to be\n+//! re-compiled. This is a superset of case 1.\n+//!\n+//! 3. The final and most subtle case is when a REFERENCE to a generic function\n+//! is added or removed somewhere. Even though the definition of the function\n+//! might be unchanged, a new REFERENCE might introduce a new monomorphized\n+//! instance of this function which has to be placed and compiled somewhere.\n+//! Conversely, when removing a REFERENCE, it might have been the last one with\n+//! that particular set of generic arguments and thus we have to remove it.\n+//!\n+//! From the above we see that just using one codegen unit per source-level\n+//! module is not such a good idea, since just adding a REFERENCE to some\n+//! generic item somewhere else would invalidate everything within the module\n+//! containing the generic item. The heuristic above reduces this detrimental\n+//! side-effect of references a little by at least not touching the non-generic\n+//! code of the module.\n+//!\n+//! A Note on Inlining\n+//! ------------------\n+//! As briefly mentioned above, in order for LLVM to be able to inline a\n+//! function call, the body of the function has to be available in the LLVM\n+//! module where the call is made. This has a few consequences for partitioning:\n+//!\n+//! - The partitioning algorithm has to take care of placing functions into all\n+//!   codegen units where they should be available for inlining. It also has to\n+//!   decide on the correct linkage for these functions.\n+//!\n+//! - The partitioning algorithm has to know which functions are likely to get\n+//!   inlined, so it can distribute function instantiations accordingly. Since\n+//!   there is no way of knowing for sure which functions LLVM will decide to\n+//!   inline in the end, we apply a heuristic here: Only functions marked with\n+//!   `#[inline]` are considered for inlining by the partitioner. The current\n+//!   implementation will not try to determine if a function is likely to be\n+//!   inlined by looking at the functions definition.\n+//!\n+//! Note though that as a side-effect of creating a codegen units per\n+//! source-level module, functions from the same module will be available for\n+//! inlining, even when they are not marked `#[inline]`.\n+\n+use std::cmp;\n+use std::collections::hash_map::Entry;\n+use std::fs::{self, File};\n+use std::io::{BufWriter, Write};\n+use std::path::{Path, PathBuf};\n+\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::sync;\n+use rustc_hir::def::DefKind;\n+use rustc_hir::def_id::{DefId, DefIdSet, LOCAL_CRATE};\n+use rustc_hir::definitions::DefPathDataName;\n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n+use rustc_middle::middle::exported_symbols::{SymbolExportInfo, SymbolExportLevel};\n+use rustc_middle::mir;\n+use rustc_middle::mir::mono::{\n+    CodegenUnit, CodegenUnitNameBuilder, InstantiationMode, Linkage, MonoItem, Visibility,\n+};\n+use rustc_middle::query::Providers;\n+use rustc_middle::ty::print::{characteristic_def_id_of_type, with_no_trimmed_paths};\n+use rustc_middle::ty::{self, visit::TypeVisitableExt, InstanceDef, TyCtxt};\n+use rustc_session::config::{DumpMonoStatsFormat, SwitchWithOptPath};\n+use rustc_span::symbol::Symbol;\n+\n+use crate::collector::InliningMap;\n+use crate::collector::{self, MonoItemCollectionMode};\n+use crate::errors::{CouldntDumpMonoStats, SymbolAlreadyDefined, UnknownCguCollectionMode};\n+\n+struct PartitioningCx<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    target_cgu_count: usize,\n+    inlining_map: &'a InliningMap<'tcx>,\n+}\n+\n+struct PlacedRootMonoItems<'tcx> {\n+    codegen_units: Vec<CodegenUnit<'tcx>>,\n+    roots: FxHashSet<MonoItem<'tcx>>,\n+    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n+}\n+\n+fn partition<'tcx, I>(\n+    tcx: TyCtxt<'tcx>,\n+    mono_items: &mut I,\n+    max_cgu_count: usize,\n+    inlining_map: &InliningMap<'tcx>,\n+) -> Vec<CodegenUnit<'tcx>>\n+where\n+    I: Iterator<Item = MonoItem<'tcx>>,\n+{\n+    let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning\");\n+\n+    let cx = &PartitioningCx { tcx, target_cgu_count: max_cgu_count, inlining_map };\n+    // In the first step, we place all regular monomorphizations into their\n+    // respective 'home' codegen unit. Regular monomorphizations are all\n+    // functions and statics defined in the local crate.\n+    let PlacedRootMonoItems { mut codegen_units, roots, internalization_candidates } = {\n+        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_roots\");\n+        place_root_mono_items(cx, mono_items)\n+    };\n+\n+    for cgu in &mut codegen_units {\n+        cgu.create_size_estimate(tcx);\n+    }\n+\n+    debug_dump(tcx, \"INITIAL PARTITIONING\", &codegen_units);\n+\n+    // Merge until we have at most `max_cgu_count` codegen units.\n+    // `merge_codegen_units` is responsible for updating the CGU size\n+    // estimates.\n+    {\n+        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_merge_cgus\");\n+        merge_codegen_units(cx, &mut codegen_units);\n+        debug_dump(tcx, \"POST MERGING\", &codegen_units);\n+    }\n+\n+    // In the next step, we use the inlining map to determine which additional\n+    // monomorphizations have to go into each codegen unit. These additional\n+    // monomorphizations can be drop-glue, functions from external crates, and\n+    // local functions the definition of which is marked with `#[inline]`.\n+    let mono_item_placements = {\n+        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_inline_items\");\n+        place_inlined_mono_items(cx, &mut codegen_units, roots)\n+    };\n+\n+    for cgu in &mut codegen_units {\n+        cgu.create_size_estimate(tcx);\n+    }\n+\n+    debug_dump(tcx, \"POST INLINING\", &codegen_units);\n+\n+    // Next we try to make as many symbols \"internal\" as possible, so LLVM has\n+    // more freedom to optimize.\n+    if !tcx.sess.link_dead_code() {\n+        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_internalize_symbols\");\n+        internalize_symbols(\n+            cx,\n+            &mut codegen_units,\n+            mono_item_placements,\n+            internalization_candidates,\n+        );\n+    }\n+\n+    let instrument_dead_code =\n+        tcx.sess.instrument_coverage() && !tcx.sess.instrument_coverage_except_unused_functions();\n+\n+    if instrument_dead_code {\n+        assert!(\n+            codegen_units.len() > 0,\n+            \"There must be at least one CGU that code coverage data can be generated in.\"\n+        );\n+\n+        // Find the smallest CGU that has exported symbols and put the dead\n+        // function stubs in that CGU. We look for exported symbols to increase\n+        // the likelihood the linker won't throw away the dead functions.\n+        // FIXME(#92165): In order to truly resolve this, we need to make sure\n+        // the object file (CGU) containing the dead function stubs is included\n+        // in the final binary. This will probably require forcing these\n+        // function symbols to be included via `-u` or `/include` linker args.\n+        let mut cgus: Vec<_> = codegen_units.iter_mut().collect();\n+        cgus.sort_by_key(|cgu| cgu.size_estimate());\n+\n+        let dead_code_cgu =\n+            if let Some(cgu) = cgus.into_iter().rev().find(|cgu| {\n+                cgu.items().iter().any(|(_, (linkage, _))| *linkage == Linkage::External)\n+            }) {\n+                cgu\n+            } else {\n+                // If there are no CGUs that have externally linked items,\n+                // then we just pick the first CGU as a fallback.\n+                &mut codegen_units[0]\n+            };\n+        dead_code_cgu.make_code_coverage_dead_code_cgu();\n+    }\n+\n+    // Finally, sort by codegen unit name, so that we get deterministic results.\n+    codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n+\n+    debug_dump(tcx, \"FINAL\", &codegen_units);\n+\n+    codegen_units\n+}\n+\n+fn place_root_mono_items<'tcx, I>(\n+    cx: &PartitioningCx<'_, 'tcx>,\n+    mono_items: &mut I,\n+) -> PlacedRootMonoItems<'tcx>\n+where\n+    I: Iterator<Item = MonoItem<'tcx>>,\n+{\n+    let mut roots = FxHashSet::default();\n+    let mut codegen_units = FxHashMap::default();\n+    let is_incremental_build = cx.tcx.sess.opts.incremental.is_some();\n+    let mut internalization_candidates = FxHashSet::default();\n+\n+    // Determine if monomorphizations instantiated in this crate will be made\n+    // available to downstream crates. This depends on whether we are in\n+    // share-generics mode and whether the current crate can even have\n+    // downstream crates.\n+    let export_generics =\n+        cx.tcx.sess.opts.share_generics() && cx.tcx.local_crate_exports_generics();\n+\n+    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n+    let cgu_name_cache = &mut FxHashMap::default();\n+\n+    for mono_item in mono_items {\n+        match mono_item.instantiation_mode(cx.tcx) {\n+            InstantiationMode::GloballyShared { .. } => {}\n+            InstantiationMode::LocalCopy => continue,\n+        }\n+\n+        let characteristic_def_id = characteristic_def_id_of_mono_item(cx.tcx, mono_item);\n+        let is_volatile = is_incremental_build && mono_item.is_generic_fn();\n+\n+        let codegen_unit_name = match characteristic_def_id {\n+            Some(def_id) => compute_codegen_unit_name(\n+                cx.tcx,\n+                cgu_name_builder,\n+                def_id,\n+                is_volatile,\n+                cgu_name_cache,\n+            ),\n+            None => fallback_cgu_name(cgu_name_builder),\n+        };\n+\n+        let codegen_unit = codegen_units\n+            .entry(codegen_unit_name)\n+            .or_insert_with(|| CodegenUnit::new(codegen_unit_name));\n+\n+        let mut can_be_internalized = true;\n+        let (linkage, visibility) = mono_item_linkage_and_visibility(\n+            cx.tcx,\n+            &mono_item,\n+            &mut can_be_internalized,\n+            export_generics,\n+        );\n+        if visibility == Visibility::Hidden && can_be_internalized {\n+            internalization_candidates.insert(mono_item);\n+        }\n+\n+        codegen_unit.items_mut().insert(mono_item, (linkage, visibility));\n+        roots.insert(mono_item);\n+    }\n+\n+    // Always ensure we have at least one CGU; otherwise, if we have a\n+    // crate with just types (for example), we could wind up with no CGU.\n+    if codegen_units.is_empty() {\n+        let codegen_unit_name = fallback_cgu_name(cgu_name_builder);\n+        codegen_units.insert(codegen_unit_name, CodegenUnit::new(codegen_unit_name));\n+    }\n+\n+    let codegen_units = codegen_units.into_values().collect();\n+    PlacedRootMonoItems { codegen_units, roots, internalization_candidates }\n+}\n+\n+fn merge_codegen_units<'tcx>(\n+    cx: &PartitioningCx<'_, 'tcx>,\n+    codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n+) {\n+    assert!(cx.target_cgu_count >= 1);\n+\n+    // Note that at this point in time the `codegen_units` here may not be\n+    // in a deterministic order (but we know they're deterministically the\n+    // same set). We want this merging to produce a deterministic ordering\n+    // of codegen units from the input.\n+    //\n+    // Due to basically how we've implemented the merging below (merge the\n+    // two smallest into each other) we're sure to start off with a\n+    // deterministic order (sorted by name). This'll mean that if two cgus\n+    // have the same size the stable sort below will keep everything nice\n+    // and deterministic.\n+    codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n+\n+    // This map keeps track of what got merged into what.\n+    let mut cgu_contents: FxHashMap<Symbol, Vec<Symbol>> =\n+        codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name()])).collect();\n+\n+    // Merge the two smallest codegen units until the target size is\n+    // reached.\n+    while codegen_units.len() > cx.target_cgu_count {\n+        // Sort small cgus to the back\n+        codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n+        let mut smallest = codegen_units.pop().unwrap();\n+        let second_smallest = codegen_units.last_mut().unwrap();\n+\n+        // Move the mono-items from `smallest` to `second_smallest`\n+        second_smallest.modify_size_estimate(smallest.size_estimate());\n+        for (k, v) in smallest.items_mut().drain() {\n+            second_smallest.items_mut().insert(k, v);\n+        }\n+\n+        // Record that `second_smallest` now contains all the stuff that was\n+        // in `smallest` before.\n+        let mut consumed_cgu_names = cgu_contents.remove(&smallest.name()).unwrap();\n+        cgu_contents.get_mut(&second_smallest.name()).unwrap().append(&mut consumed_cgu_names);\n+\n+        debug!(\n+            \"CodegenUnit {} merged into CodegenUnit {}\",\n+            smallest.name(),\n+            second_smallest.name()\n+        );\n+    }\n+\n+    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n+\n+    if cx.tcx.sess.opts.incremental.is_some() {\n+        // If we are doing incremental compilation, we want CGU names to\n+        // reflect the path of the source level module they correspond to.\n+        // For CGUs that contain the code of multiple modules because of the\n+        // merging done above, we use a concatenation of the names of all\n+        // contained CGUs.\n+        let new_cgu_names: FxHashMap<Symbol, String> = cgu_contents\n+            .into_iter()\n+            // This `filter` makes sure we only update the name of CGUs that\n+            // were actually modified by merging.\n+            .filter(|(_, cgu_contents)| cgu_contents.len() > 1)\n+            .map(|(current_cgu_name, cgu_contents)| {\n+                let mut cgu_contents: Vec<&str> = cgu_contents.iter().map(|s| s.as_str()).collect();\n+\n+                // Sort the names, so things are deterministic and easy to\n+                // predict. We are sorting primitive `&str`s here so we can\n+                // use unstable sort.\n+                cgu_contents.sort_unstable();\n+\n+                (current_cgu_name, cgu_contents.join(\"--\"))\n+            })\n+            .collect();\n+\n+        for cgu in codegen_units.iter_mut() {\n+            if let Some(new_cgu_name) = new_cgu_names.get(&cgu.name()) {\n+                if cx.tcx.sess.opts.unstable_opts.human_readable_cgu_names {\n+                    cgu.set_name(Symbol::intern(&new_cgu_name));\n+                } else {\n+                    // If we don't require CGU names to be human-readable,\n+                    // we use a fixed length hash of the composite CGU name\n+                    // instead.\n+                    let new_cgu_name = CodegenUnit::mangle_name(&new_cgu_name);\n+                    cgu.set_name(Symbol::intern(&new_cgu_name));\n+                }\n+            }\n+        }\n+    } else {\n+        // If we are compiling non-incrementally we just generate simple CGU\n+        // names containing an index.\n+        for (index, cgu) in codegen_units.iter_mut().enumerate() {\n+            let numbered_codegen_unit_name =\n+                cgu_name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index));\n+            cgu.set_name(numbered_codegen_unit_name);\n+        }\n+    }\n+}\n+\n+/// For symbol internalization, we need to know whether a symbol/mono-item is\n+/// accessed from outside the codegen unit it is defined in. This type is used\n+/// to keep track of that.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+enum MonoItemPlacement {\n+    SingleCgu { cgu_name: Symbol },\n+    MultipleCgus,\n+}\n+\n+fn place_inlined_mono_items<'tcx>(\n+    cx: &PartitioningCx<'_, 'tcx>,\n+    codegen_units: &mut [CodegenUnit<'tcx>],\n+    roots: FxHashSet<MonoItem<'tcx>>,\n+) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement> {\n+    let mut mono_item_placements = FxHashMap::default();\n+\n+    let single_codegen_unit = codegen_units.len() == 1;\n+\n+    for old_codegen_unit in codegen_units.iter_mut() {\n+        // Collect all items that need to be available in this codegen unit.\n+        let mut reachable = FxHashSet::default();\n+        for root in old_codegen_unit.items().keys() {\n+            follow_inlining(*root, cx.inlining_map, &mut reachable);\n+        }\n+\n+        let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name());\n+\n+        // Add all monomorphizations that are not already there.\n+        for mono_item in reachable {\n+            if let Some(linkage) = old_codegen_unit.items().get(&mono_item) {\n+                // This is a root, just copy it over.\n+                new_codegen_unit.items_mut().insert(mono_item, *linkage);\n+            } else {\n+                if roots.contains(&mono_item) {\n+                    bug!(\n+                        \"GloballyShared mono-item inlined into other CGU: \\\n+                          {:?}\",\n+                        mono_item\n+                    );\n+                }\n+\n+                // This is a CGU-private copy.\n+                new_codegen_unit\n+                    .items_mut()\n+                    .insert(mono_item, (Linkage::Internal, Visibility::Default));\n+            }\n+\n+            if !single_codegen_unit {\n+                // If there is more than one codegen unit, we need to keep track\n+                // in which codegen units each monomorphization is placed.\n+                match mono_item_placements.entry(mono_item) {\n+                    Entry::Occupied(e) => {\n+                        let placement = e.into_mut();\n+                        debug_assert!(match *placement {\n+                            MonoItemPlacement::SingleCgu { cgu_name } => {\n+                                cgu_name != new_codegen_unit.name()\n+                            }\n+                            MonoItemPlacement::MultipleCgus => true,\n+                        });\n+                        *placement = MonoItemPlacement::MultipleCgus;\n+                    }\n+                    Entry::Vacant(e) => {\n+                        e.insert(MonoItemPlacement::SingleCgu {\n+                            cgu_name: new_codegen_unit.name(),\n+                        });\n+                    }\n+                }\n+            }\n+        }\n+\n+        *old_codegen_unit = new_codegen_unit;\n+    }\n+\n+    return mono_item_placements;\n+\n+    fn follow_inlining<'tcx>(\n+        mono_item: MonoItem<'tcx>,\n+        inlining_map: &InliningMap<'tcx>,\n+        visited: &mut FxHashSet<MonoItem<'tcx>>,\n+    ) {\n+        if !visited.insert(mono_item) {\n+            return;\n+        }\n+\n+        inlining_map.with_inlining_candidates(mono_item, |target| {\n+            follow_inlining(target, inlining_map, visited);\n+        });\n+    }\n+}\n+\n+fn internalize_symbols<'tcx>(\n+    cx: &PartitioningCx<'_, 'tcx>,\n+    codegen_units: &mut [CodegenUnit<'tcx>],\n+    mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n+    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n+) {\n+    if codegen_units.len() == 1 {\n+        // Fast path for when there is only one codegen unit. In this case we\n+        // can internalize all candidates, since there is nowhere else they\n+        // could be accessed from.\n+        for cgu in codegen_units {\n+            for candidate in &internalization_candidates {\n+                cgu.items_mut().insert(*candidate, (Linkage::Internal, Visibility::Default));\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    // Build a map from every monomorphization to all the monomorphizations that\n+    // reference it.\n+    let mut accessor_map: FxHashMap<MonoItem<'tcx>, Vec<MonoItem<'tcx>>> = Default::default();\n+    cx.inlining_map.iter_accesses(|accessor, accessees| {\n+        for accessee in accessees {\n+            accessor_map.entry(*accessee).or_default().push(accessor);\n+        }\n+    });\n+\n+    // For each internalization candidates in each codegen unit, check if it is\n+    // accessed from outside its defining codegen unit.\n+    for cgu in codegen_units {\n+        let home_cgu = MonoItemPlacement::SingleCgu { cgu_name: cgu.name() };\n+\n+        for (accessee, linkage_and_visibility) in cgu.items_mut() {\n+            if !internalization_candidates.contains(accessee) {\n+                // This item is no candidate for internalizing, so skip it.\n+                continue;\n+            }\n+            debug_assert_eq!(mono_item_placements[accessee], home_cgu);\n+\n+            if let Some(accessors) = accessor_map.get(accessee) {\n+                if accessors\n+                    .iter()\n+                    .filter_map(|accessor| {\n+                        // Some accessors might not have been\n+                        // instantiated. We can safely ignore those.\n+                        mono_item_placements.get(accessor)\n+                    })\n+                    .any(|placement| *placement != home_cgu)\n+                {\n+                    // Found an accessor from another CGU, so skip to the next\n+                    // item without marking this one as internal.\n+                    continue;\n+                }\n+            }\n+\n+            // If we got here, we did not find any accesses from other CGUs,\n+            // so it's fine to make this monomorphization internal.\n+            *linkage_and_visibility = (Linkage::Internal, Visibility::Default);\n+        }\n+    }\n+}\n+\n+fn characteristic_def_id_of_mono_item<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    mono_item: MonoItem<'tcx>,\n+) -> Option<DefId> {\n+    match mono_item {\n+        MonoItem::Fn(instance) => {\n+            let def_id = match instance.def {\n+                ty::InstanceDef::Item(def) => def,\n+                ty::InstanceDef::VTableShim(..)\n+                | ty::InstanceDef::ReifyShim(..)\n+                | ty::InstanceDef::FnPtrShim(..)\n+                | ty::InstanceDef::ClosureOnceShim { .. }\n+                | ty::InstanceDef::Intrinsic(..)\n+                | ty::InstanceDef::DropGlue(..)\n+                | ty::InstanceDef::Virtual(..)\n+                | ty::InstanceDef::CloneShim(..)\n+                | ty::InstanceDef::ThreadLocalShim(..)\n+                | ty::InstanceDef::FnPtrAddrShim(..) => return None,\n+            };\n+\n+            // If this is a method, we want to put it into the same module as\n+            // its self-type. If the self-type does not provide a characteristic\n+            // DefId, we use the location of the impl after all.\n+\n+            if tcx.trait_of_item(def_id).is_some() {\n+                let self_ty = instance.substs.type_at(0);\n+                // This is a default implementation of a trait method.\n+                return characteristic_def_id_of_type(self_ty).or(Some(def_id));\n+            }\n+\n+            if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n+                if tcx.sess.opts.incremental.is_some()\n+                    && tcx.trait_id_of_impl(impl_def_id) == tcx.lang_items().drop_trait()\n+                {\n+                    // Put `Drop::drop` into the same cgu as `drop_in_place`\n+                    // since `drop_in_place` is the only thing that can\n+                    // call it.\n+                    return None;\n+                }\n+\n+                // When polymorphization is enabled, methods which do not depend on their generic\n+                // parameters, but the self-type of their impl block do will fail to normalize.\n+                if !tcx.sess.opts.unstable_opts.polymorphize || !instance.has_param() {\n+                    // This is a method within an impl, find out what the self-type is:\n+                    let impl_self_ty = tcx.subst_and_normalize_erasing_regions(\n+                        instance.substs,\n+                        ty::ParamEnv::reveal_all(),\n+                        tcx.type_of(impl_def_id),\n+                    );\n+                    if let Some(def_id) = characteristic_def_id_of_type(impl_self_ty) {\n+                        return Some(def_id);\n+                    }\n+                }\n+            }\n+\n+            Some(def_id)\n+        }\n+        MonoItem::Static(def_id) => Some(def_id),\n+        MonoItem::GlobalAsm(item_id) => Some(item_id.owner_id.to_def_id()),\n+    }\n+}\n+\n+fn compute_codegen_unit_name(\n+    tcx: TyCtxt<'_>,\n+    name_builder: &mut CodegenUnitNameBuilder<'_>,\n+    def_id: DefId,\n+    volatile: bool,\n+    cache: &mut CguNameCache,\n+) -> Symbol {\n+    // Find the innermost module that is not nested within a function.\n+    let mut current_def_id = def_id;\n+    let mut cgu_def_id = None;\n+    // Walk backwards from the item we want to find the module for.\n+    loop {\n+        if current_def_id.is_crate_root() {\n+            if cgu_def_id.is_none() {\n+                // If we have not found a module yet, take the crate root.\n+                cgu_def_id = Some(def_id.krate.as_def_id());\n+            }\n+            break;\n+        } else if tcx.def_kind(current_def_id) == DefKind::Mod {\n+            if cgu_def_id.is_none() {\n+                cgu_def_id = Some(current_def_id);\n+            }\n+        } else {\n+            // If we encounter something that is not a module, throw away\n+            // any module that we've found so far because we now know that\n+            // it is nested within something else.\n+            cgu_def_id = None;\n+        }\n+\n+        current_def_id = tcx.parent(current_def_id);\n+    }\n+\n+    let cgu_def_id = cgu_def_id.unwrap();\n+\n+    *cache.entry((cgu_def_id, volatile)).or_insert_with(|| {\n+        let def_path = tcx.def_path(cgu_def_id);\n+\n+        let components = def_path.data.iter().map(|part| match part.data.name() {\n+            DefPathDataName::Named(name) => name,\n+            DefPathDataName::Anon { .. } => unreachable!(),\n+        });\n+\n+        let volatile_suffix = volatile.then_some(\"volatile\");\n+\n+        name_builder.build_cgu_name(def_path.krate, components, volatile_suffix)\n+    })\n+}\n+\n+// Anything we can't find a proper codegen unit for goes into this.\n+fn fallback_cgu_name(name_builder: &mut CodegenUnitNameBuilder<'_>) -> Symbol {\n+    name_builder.build_cgu_name(LOCAL_CRATE, &[\"fallback\"], Some(\"cgu\"))\n+}\n+\n+fn mono_item_linkage_and_visibility<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    mono_item: &MonoItem<'tcx>,\n+    can_be_internalized: &mut bool,\n+    export_generics: bool,\n+) -> (Linkage, Visibility) {\n+    if let Some(explicit_linkage) = mono_item.explicit_linkage(tcx) {\n+        return (explicit_linkage, Visibility::Default);\n+    }\n+    let vis = mono_item_visibility(tcx, mono_item, can_be_internalized, export_generics);\n+    (Linkage::External, vis)\n+}\n+\n+type CguNameCache = FxHashMap<(DefId, bool), Symbol>;\n+\n+fn static_visibility<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    can_be_internalized: &mut bool,\n+    def_id: DefId,\n+) -> Visibility {\n+    if tcx.is_reachable_non_generic(def_id) {\n+        *can_be_internalized = false;\n+        default_visibility(tcx, def_id, false)\n+    } else {\n+        Visibility::Hidden\n+    }\n+}\n+\n+fn mono_item_visibility<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    mono_item: &MonoItem<'tcx>,\n+    can_be_internalized: &mut bool,\n+    export_generics: bool,\n+) -> Visibility {\n+    let instance = match mono_item {\n+        // This is pretty complicated; see below.\n+        MonoItem::Fn(instance) => instance,\n+\n+        // Misc handling for generics and such, but otherwise:\n+        MonoItem::Static(def_id) => return static_visibility(tcx, can_be_internalized, *def_id),\n+        MonoItem::GlobalAsm(item_id) => {\n+            return static_visibility(tcx, can_be_internalized, item_id.owner_id.to_def_id());\n+        }\n+    };\n+\n+    let def_id = match instance.def {\n+        InstanceDef::Item(def_id) | InstanceDef::DropGlue(def_id, Some(_)) => def_id,\n+\n+        // We match the visibility of statics here\n+        InstanceDef::ThreadLocalShim(def_id) => {\n+            return static_visibility(tcx, can_be_internalized, def_id);\n+        }\n+\n+        // These are all compiler glue and such, never exported, always hidden.\n+        InstanceDef::VTableShim(..)\n+        | InstanceDef::ReifyShim(..)\n+        | InstanceDef::FnPtrShim(..)\n+        | InstanceDef::Virtual(..)\n+        | InstanceDef::Intrinsic(..)\n+        | InstanceDef::ClosureOnceShim { .. }\n+        | InstanceDef::DropGlue(..)\n+        | InstanceDef::CloneShim(..)\n+        | InstanceDef::FnPtrAddrShim(..) => return Visibility::Hidden,\n+    };\n+\n+    // The `start_fn` lang item is actually a monomorphized instance of a\n+    // function in the standard library, used for the `main` function. We don't\n+    // want to export it so we tag it with `Hidden` visibility but this symbol\n+    // is only referenced from the actual `main` symbol which we unfortunately\n+    // don't know anything about during partitioning/collection. As a result we\n+    // forcibly keep this symbol out of the `internalization_candidates` set.\n+    //\n+    // FIXME: eventually we don't want to always force this symbol to have\n+    //        hidden visibility, it should indeed be a candidate for\n+    //        internalization, but we have to understand that it's referenced\n+    //        from the `main` symbol we'll generate later.\n+    //\n+    //        This may be fixable with a new `InstanceDef` perhaps? Unsure!\n+    if tcx.lang_items().start_fn() == Some(def_id) {\n+        *can_be_internalized = false;\n+        return Visibility::Hidden;\n+    }\n+\n+    let is_generic = instance.substs.non_erasable_generics().next().is_some();\n+\n+    // Upstream `DefId` instances get different handling than local ones.\n+    let Some(def_id) = def_id.as_local() else {\n+        return if export_generics && is_generic {\n+            // If it is an upstream monomorphization and we export generics, we must make\n+            // it available to downstream crates.\n+            *can_be_internalized = false;\n+            default_visibility(tcx, def_id, true)\n+        } else {\n+            Visibility::Hidden\n+        };\n+    };\n+\n+    if is_generic {\n+        if export_generics {\n+            if tcx.is_unreachable_local_definition(def_id) {\n+                // This instance cannot be used from another crate.\n+                Visibility::Hidden\n+            } else {\n+                // This instance might be useful in a downstream crate.\n+                *can_be_internalized = false;\n+                default_visibility(tcx, def_id.to_def_id(), true)\n+            }\n+        } else {\n+            // We are not exporting generics or the definition is not reachable\n+            // for downstream crates, we can internalize its instantiations.\n+            Visibility::Hidden\n+        }\n+    } else {\n+        // If this isn't a generic function then we mark this a `Default` if\n+        // this is a reachable item, meaning that it's a symbol other crates may\n+        // access when they link to us.\n+        if tcx.is_reachable_non_generic(def_id.to_def_id()) {\n+            *can_be_internalized = false;\n+            debug_assert!(!is_generic);\n+            return default_visibility(tcx, def_id.to_def_id(), false);\n+        }\n+\n+        // If this isn't reachable then we're gonna tag this with `Hidden`\n+        // visibility. In some situations though we'll want to prevent this\n+        // symbol from being internalized.\n+        //\n+        // There's two categories of items here:\n+        //\n+        // * First is weak lang items. These are basically mechanisms for\n+        //   libcore to forward-reference symbols defined later in crates like\n+        //   the standard library or `#[panic_handler]` definitions. The\n+        //   definition of these weak lang items needs to be referencable by\n+        //   libcore, so we're no longer a candidate for internalization.\n+        //   Removal of these functions can't be done by LLVM but rather must be\n+        //   done by the linker as it's a non-local decision.\n+        //\n+        // * Second is \"std internal symbols\". Currently this is primarily used\n+        //   for allocator symbols. Allocators are a little weird in their\n+        //   implementation, but the idea is that the compiler, at the last\n+        //   minute, defines an allocator with an injected object file. The\n+        //   `alloc` crate references these symbols (`__rust_alloc`) and the\n+        //   definition doesn't get hooked up until a linked crate artifact is\n+        //   generated.\n+        //\n+        //   The symbols synthesized by the compiler (`__rust_alloc`) are thin\n+        //   veneers around the actual implementation, some other symbol which\n+        //   implements the same ABI. These symbols (things like `__rg_alloc`,\n+        //   `__rdl_alloc`, `__rde_alloc`, etc), are all tagged with \"std\n+        //   internal symbols\".\n+        //\n+        //   The std-internal symbols here **should not show up in a dll as an\n+        //   exported interface**, so they return `false` from\n+        //   `is_reachable_non_generic` above and we'll give them `Hidden`\n+        //   visibility below. Like the weak lang items, though, we can't let\n+        //   LLVM internalize them as this decision is left up to the linker to\n+        //   omit them, so prevent them from being internalized.\n+        let attrs = tcx.codegen_fn_attrs(def_id);\n+        if attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL) {\n+            *can_be_internalized = false;\n+        }\n+\n+        Visibility::Hidden\n+    }\n+}\n+\n+fn default_visibility(tcx: TyCtxt<'_>, id: DefId, is_generic: bool) -> Visibility {\n+    if !tcx.sess.target.default_hidden_visibility {\n+        return Visibility::Default;\n+    }\n+\n+    // Generic functions never have export-level C.\n+    if is_generic {\n+        return Visibility::Hidden;\n+    }\n+\n+    // Things with export level C don't get instantiated in\n+    // downstream crates.\n+    if !id.is_local() {\n+        return Visibility::Hidden;\n+    }\n+\n+    // C-export level items remain at `Default`, all other internal\n+    // items become `Hidden`.\n+    match tcx.reachable_non_generics(id.krate).get(&id) {\n+        Some(SymbolExportInfo { level: SymbolExportLevel::C, .. }) => Visibility::Default,\n+        _ => Visibility::Hidden,\n+    }\n+}\n+fn debug_dump<'a, 'tcx: 'a>(tcx: TyCtxt<'tcx>, label: &str, cgus: &[CodegenUnit<'tcx>]) {\n+    let dump = move || {\n+        use std::fmt::Write;\n+\n+        let num_cgus = cgus.len();\n+        let max = cgus.iter().map(|cgu| cgu.size_estimate()).max().unwrap();\n+        let min = cgus.iter().map(|cgu| cgu.size_estimate()).min().unwrap();\n+        let ratio = max as f64 / min as f64;\n+\n+        let s = &mut String::new();\n+        let _ = writeln!(\n+            s,\n+            \"{label} ({num_cgus} CodegenUnits, max={max}, min={min}, max/min={ratio:.1}):\"\n+        );\n+        for cgu in cgus {\n+            let _ =\n+                writeln!(s, \"CodegenUnit {} estimated size {}:\", cgu.name(), cgu.size_estimate());\n+\n+            for (mono_item, linkage) in cgu.items() {\n+                let symbol_name = mono_item.symbol_name(tcx).name;\n+                let symbol_hash_start = symbol_name.rfind('h');\n+                let symbol_hash = symbol_hash_start.map_or(\"<no hash>\", |i| &symbol_name[i..]);\n+\n+                let _ = with_no_trimmed_paths!(writeln!(\n+                    s,\n+                    \" - {} [{:?}] [{}] estimated size {}\",\n+                    mono_item,\n+                    linkage,\n+                    symbol_hash,\n+                    mono_item.size_estimate(tcx)\n+                ));\n+            }\n+\n+            let _ = writeln!(s);\n+        }\n+\n+        std::mem::take(s)\n+    };\n+\n+    debug!(\"{}\", dump());\n+}\n+\n+#[inline(never)] // give this a place in the profiler\n+fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'tcx>, mono_items: I)\n+where\n+    I: Iterator<Item = &'a MonoItem<'tcx>>,\n+    'tcx: 'a,\n+{\n+    let _prof_timer = tcx.prof.generic_activity(\"assert_symbols_are_distinct\");\n+\n+    let mut symbols: Vec<_> =\n+        mono_items.map(|mono_item| (mono_item, mono_item.symbol_name(tcx))).collect();\n+\n+    symbols.sort_by_key(|sym| sym.1);\n+\n+    for &[(mono_item1, ref sym1), (mono_item2, ref sym2)] in symbols.array_windows() {\n+        if sym1 == sym2 {\n+            let span1 = mono_item1.local_span(tcx);\n+            let span2 = mono_item2.local_span(tcx);\n+\n+            // Deterministically select one of the spans for error reporting\n+            let span = match (span1, span2) {\n+                (Some(span1), Some(span2)) => {\n+                    Some(if span1.lo().0 > span2.lo().0 { span1 } else { span2 })\n+                }\n+                (span1, span2) => span1.or(span2),\n+            };\n+\n+            tcx.sess.emit_fatal(SymbolAlreadyDefined { span, symbol: sym1.to_string() });\n+        }\n+    }\n+}\n+\n+fn collect_and_partition_mono_items(tcx: TyCtxt<'_>, (): ()) -> (&DefIdSet, &[CodegenUnit<'_>]) {\n+    let collection_mode = match tcx.sess.opts.unstable_opts.print_mono_items {\n+        Some(ref s) => {\n+            let mode = s.to_lowercase();\n+            let mode = mode.trim();\n+            if mode == \"eager\" {\n+                MonoItemCollectionMode::Eager\n+            } else {\n+                if mode != \"lazy\" {\n+                    tcx.sess.emit_warning(UnknownCguCollectionMode { mode });\n+                }\n+\n+                MonoItemCollectionMode::Lazy\n+            }\n+        }\n+        None => {\n+            if tcx.sess.link_dead_code() {\n+                MonoItemCollectionMode::Eager\n+            } else {\n+                MonoItemCollectionMode::Lazy\n+            }\n+        }\n+    };\n+\n+    let (items, inlining_map) = collector::collect_crate_mono_items(tcx, collection_mode);\n+\n+    tcx.sess.abort_if_errors();\n+\n+    let (codegen_units, _) = tcx.sess.time(\"partition_and_assert_distinct_symbols\", || {\n+        sync::join(\n+            || {\n+                let mut codegen_units = partition(\n+                    tcx,\n+                    &mut items.iter().copied(),\n+                    tcx.sess.codegen_units(),\n+                    &inlining_map,\n+                );\n+                codegen_units[0].make_primary();\n+                &*tcx.arena.alloc_from_iter(codegen_units)\n+            },\n+            || assert_symbols_are_distinct(tcx, items.iter()),\n+        )\n+    });\n+\n+    if tcx.prof.enabled() {\n+        // Record CGU size estimates for self-profiling.\n+        for cgu in codegen_units {\n+            tcx.prof.artifact_size(\n+                \"codegen_unit_size_estimate\",\n+                cgu.name().as_str(),\n+                cgu.size_estimate() as u64,\n+            );\n+        }\n+    }\n+\n+    let mono_items: DefIdSet = items\n+        .iter()\n+        .filter_map(|mono_item| match *mono_item {\n+            MonoItem::Fn(ref instance) => Some(instance.def_id()),\n+            MonoItem::Static(def_id) => Some(def_id),\n+            _ => None,\n+        })\n+        .collect();\n+\n+    // Output monomorphization stats per def_id\n+    if let SwitchWithOptPath::Enabled(ref path) = tcx.sess.opts.unstable_opts.dump_mono_stats {\n+        if let Err(err) =\n+            dump_mono_items_stats(tcx, &codegen_units, path, tcx.crate_name(LOCAL_CRATE))\n+        {\n+            tcx.sess.emit_fatal(CouldntDumpMonoStats { error: err.to_string() });\n+        }\n+    }\n+\n+    if tcx.sess.opts.unstable_opts.print_mono_items.is_some() {\n+        let mut item_to_cgus: FxHashMap<_, Vec<_>> = Default::default();\n+\n+        for cgu in codegen_units {\n+            for (&mono_item, &linkage) in cgu.items() {\n+                item_to_cgus.entry(mono_item).or_default().push((cgu.name(), linkage));\n+            }\n+        }\n+\n+        let mut item_keys: Vec<_> = items\n+            .iter()\n+            .map(|i| {\n+                let mut output = with_no_trimmed_paths!(i.to_string());\n+                output.push_str(\" @@\");\n+                let mut empty = Vec::new();\n+                let cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);\n+                cgus.sort_by_key(|(name, _)| *name);\n+                cgus.dedup();\n+                for &(ref cgu_name, (linkage, _)) in cgus.iter() {\n+                    output.push(' ');\n+                    output.push_str(cgu_name.as_str());\n+\n+                    let linkage_abbrev = match linkage {\n+                        Linkage::External => \"External\",\n+                        Linkage::AvailableExternally => \"Available\",\n+                        Linkage::LinkOnceAny => \"OnceAny\",\n+                        Linkage::LinkOnceODR => \"OnceODR\",\n+                        Linkage::WeakAny => \"WeakAny\",\n+                        Linkage::WeakODR => \"WeakODR\",\n+                        Linkage::Appending => \"Appending\",\n+                        Linkage::Internal => \"Internal\",\n+                        Linkage::Private => \"Private\",\n+                        Linkage::ExternalWeak => \"ExternalWeak\",\n+                        Linkage::Common => \"Common\",\n+                    };\n+\n+                    output.push('[');\n+                    output.push_str(linkage_abbrev);\n+                    output.push(']');\n+                }\n+                output\n+            })\n+            .collect();\n+\n+        item_keys.sort();\n+\n+        for item in item_keys {\n+            println!(\"MONO_ITEM {item}\");\n+        }\n+    }\n+\n+    (tcx.arena.alloc(mono_items), codegen_units)\n+}\n+\n+/// Outputs stats about instantiation counts and estimated size, per `MonoItem`'s\n+/// def, to a file in the given output directory.\n+fn dump_mono_items_stats<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    codegen_units: &[CodegenUnit<'tcx>],\n+    output_directory: &Option<PathBuf>,\n+    crate_name: Symbol,\n+) -> Result<(), Box<dyn std::error::Error>> {\n+    let output_directory = if let Some(ref directory) = output_directory {\n+        fs::create_dir_all(directory)?;\n+        directory\n+    } else {\n+        Path::new(\".\")\n+    };\n+\n+    let format = tcx.sess.opts.unstable_opts.dump_mono_stats_format;\n+    let ext = format.extension();\n+    let filename = format!(\"{crate_name}.mono_items.{ext}\");\n+    let output_path = output_directory.join(&filename);\n+    let file = File::create(&output_path)?;\n+    let mut file = BufWriter::new(file);\n+\n+    // Gather instantiated mono items grouped by def_id\n+    let mut items_per_def_id: FxHashMap<_, Vec<_>> = Default::default();\n+    for cgu in codegen_units {\n+        for (&mono_item, _) in cgu.items() {\n+            // Avoid variable-sized compiler-generated shims\n+            if mono_item.is_user_defined() {\n+                items_per_def_id.entry(mono_item.def_id()).or_default().push(mono_item);\n+            }\n+        }\n+    }\n+\n+    #[derive(serde::Serialize)]\n+    struct MonoItem {\n+        name: String,\n+        instantiation_count: usize,\n+        size_estimate: usize,\n+        total_estimate: usize,\n+    }\n+\n+    // Output stats sorted by total instantiated size, from heaviest to lightest\n+    let mut stats: Vec<_> = items_per_def_id\n+        .into_iter()\n+        .map(|(def_id, items)| {\n+            let name = with_no_trimmed_paths!(tcx.def_path_str(def_id));\n+            let instantiation_count = items.len();\n+            let size_estimate = items[0].size_estimate(tcx);\n+            let total_estimate = instantiation_count * size_estimate;\n+            MonoItem { name, instantiation_count, size_estimate, total_estimate }\n+        })\n+        .collect();\n+    stats.sort_unstable_by_key(|item| cmp::Reverse(item.total_estimate));\n+\n+    if !stats.is_empty() {\n+        match format {\n+            DumpMonoStatsFormat::Json => serde_json::to_writer(file, &stats)?,\n+            DumpMonoStatsFormat::Markdown => {\n+                writeln!(\n+                    file,\n+                    \"| Item | Instantiation count | Estimated Cost Per Instantiation | Total Estimated Cost |\"\n+                )?;\n+                writeln!(file, \"| --- | ---: | ---: | ---: |\")?;\n+\n+                for MonoItem { name, instantiation_count, size_estimate, total_estimate } in stats {\n+                    writeln!(\n+                        file,\n+                        \"| `{name}` | {instantiation_count} | {size_estimate} | {total_estimate} |\"\n+                    )?;\n+                }\n+            }\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+fn codegened_and_inlined_items(tcx: TyCtxt<'_>, (): ()) -> &DefIdSet {\n+    let (items, cgus) = tcx.collect_and_partition_mono_items(());\n+    let mut visited = DefIdSet::default();\n+    let mut result = items.clone();\n+\n+    for cgu in cgus {\n+        for (item, _) in cgu.items() {\n+            if let MonoItem::Fn(ref instance) = item {\n+                let did = instance.def_id();\n+                if !visited.insert(did) {\n+                    continue;\n+                }\n+                let body = tcx.instance_mir(instance.def);\n+                for block in body.basic_blocks.iter() {\n+                    for statement in &block.statements {\n+                        let mir::StatementKind::Coverage(_) = statement.kind else { continue };\n+                        let scope = statement.source_info.scope;\n+                        if let Some(inlined) = scope.inlined_instance(&body.source_scopes) {\n+                            result.insert(inlined.def_id());\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    tcx.arena.alloc(result)\n+}\n+\n+pub fn provide(providers: &mut Providers) {\n+    providers.collect_and_partition_mono_items = collect_and_partition_mono_items;\n+    providers.codegened_and_inlined_items = codegened_and_inlined_items;\n+\n+    providers.is_codegened_item = |tcx, def_id| {\n+        let (all_mono_items, _) = tcx.collect_and_partition_mono_items(());\n+        all_mono_items.contains(&def_id)\n+    };\n+\n+    providers.codegen_unit = |tcx, name| {\n+        let (_, all) = tcx.collect_and_partition_mono_items(());\n+        all.iter()\n+            .find(|cgu| cgu.name() == name)\n+            .unwrap_or_else(|| panic!(\"failed to find cgu with name {name:?}\"))\n+    };\n+}"}, {"sha": "603b3ddc106e931ea2864506243a43b35fd9e819", "filename": "compiler/rustc_monomorphize/src/partitioning/default.rs", "status": "removed", "additions": 0, "deletions": 644, "changes": 644, "blob_url": "https://github.com/rust-lang/rust/blob/fdd62cfe7d2ea9189e957951b8b7b8251cd50854/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd62cfe7d2ea9189e957951b8b7b8251cd50854/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs?ref=fdd62cfe7d2ea9189e957951b8b7b8251cd50854", "patch": "@@ -1,644 +0,0 @@\n-use std::cmp;\n-use std::collections::hash_map::Entry;\n-\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_hir::definitions::DefPathDataName;\n-use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n-use rustc_middle::middle::exported_symbols::{SymbolExportInfo, SymbolExportLevel};\n-use rustc_middle::mir::mono::{CodegenUnit, CodegenUnitNameBuilder, Linkage, Visibility};\n-use rustc_middle::mir::mono::{InstantiationMode, MonoItem};\n-use rustc_middle::ty::print::characteristic_def_id_of_type;\n-use rustc_middle::ty::{self, visit::TypeVisitableExt, InstanceDef, TyCtxt};\n-use rustc_span::symbol::Symbol;\n-\n-use super::PartitioningCx;\n-use crate::collector::InliningMap;\n-use crate::partitioning::{MonoItemPlacement, Partition, PlacedRootMonoItems};\n-\n-pub struct DefaultPartitioning;\n-\n-impl<'tcx> Partition<'tcx> for DefaultPartitioning {\n-    fn place_root_mono_items<I>(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        mono_items: &mut I,\n-    ) -> PlacedRootMonoItems<'tcx>\n-    where\n-        I: Iterator<Item = MonoItem<'tcx>>,\n-    {\n-        let mut roots = FxHashSet::default();\n-        let mut codegen_units = FxHashMap::default();\n-        let is_incremental_build = cx.tcx.sess.opts.incremental.is_some();\n-        let mut internalization_candidates = FxHashSet::default();\n-\n-        // Determine if monomorphizations instantiated in this crate will be made\n-        // available to downstream crates. This depends on whether we are in\n-        // share-generics mode and whether the current crate can even have\n-        // downstream crates.\n-        let export_generics =\n-            cx.tcx.sess.opts.share_generics() && cx.tcx.local_crate_exports_generics();\n-\n-        let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n-        let cgu_name_cache = &mut FxHashMap::default();\n-\n-        for mono_item in mono_items {\n-            match mono_item.instantiation_mode(cx.tcx) {\n-                InstantiationMode::GloballyShared { .. } => {}\n-                InstantiationMode::LocalCopy => continue,\n-            }\n-\n-            let characteristic_def_id = characteristic_def_id_of_mono_item(cx.tcx, mono_item);\n-            let is_volatile = is_incremental_build && mono_item.is_generic_fn();\n-\n-            let codegen_unit_name = match characteristic_def_id {\n-                Some(def_id) => compute_codegen_unit_name(\n-                    cx.tcx,\n-                    cgu_name_builder,\n-                    def_id,\n-                    is_volatile,\n-                    cgu_name_cache,\n-                ),\n-                None => fallback_cgu_name(cgu_name_builder),\n-            };\n-\n-            let codegen_unit = codegen_units\n-                .entry(codegen_unit_name)\n-                .or_insert_with(|| CodegenUnit::new(codegen_unit_name));\n-\n-            let mut can_be_internalized = true;\n-            let (linkage, visibility) = mono_item_linkage_and_visibility(\n-                cx.tcx,\n-                &mono_item,\n-                &mut can_be_internalized,\n-                export_generics,\n-            );\n-            if visibility == Visibility::Hidden && can_be_internalized {\n-                internalization_candidates.insert(mono_item);\n-            }\n-\n-            codegen_unit.items_mut().insert(mono_item, (linkage, visibility));\n-            roots.insert(mono_item);\n-        }\n-\n-        // Always ensure we have at least one CGU; otherwise, if we have a\n-        // crate with just types (for example), we could wind up with no CGU.\n-        if codegen_units.is_empty() {\n-            let codegen_unit_name = fallback_cgu_name(cgu_name_builder);\n-            codegen_units.insert(codegen_unit_name, CodegenUnit::new(codegen_unit_name));\n-        }\n-\n-        let codegen_units = codegen_units.into_values().collect();\n-        PlacedRootMonoItems { codegen_units, roots, internalization_candidates }\n-    }\n-\n-    fn merge_codegen_units(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n-    ) {\n-        assert!(cx.target_cgu_count >= 1);\n-\n-        // Note that at this point in time the `codegen_units` here may not be\n-        // in a deterministic order (but we know they're deterministically the\n-        // same set). We want this merging to produce a deterministic ordering\n-        // of codegen units from the input.\n-        //\n-        // Due to basically how we've implemented the merging below (merge the\n-        // two smallest into each other) we're sure to start off with a\n-        // deterministic order (sorted by name). This'll mean that if two cgus\n-        // have the same size the stable sort below will keep everything nice\n-        // and deterministic.\n-        codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n-\n-        // This map keeps track of what got merged into what.\n-        let mut cgu_contents: FxHashMap<Symbol, Vec<Symbol>> =\n-            codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name()])).collect();\n-\n-        // Merge the two smallest codegen units until the target size is\n-        // reached.\n-        while codegen_units.len() > cx.target_cgu_count {\n-            // Sort small cgus to the back\n-            codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n-            let mut smallest = codegen_units.pop().unwrap();\n-            let second_smallest = codegen_units.last_mut().unwrap();\n-\n-            // Move the mono-items from `smallest` to `second_smallest`\n-            second_smallest.modify_size_estimate(smallest.size_estimate());\n-            for (k, v) in smallest.items_mut().drain() {\n-                second_smallest.items_mut().insert(k, v);\n-            }\n-\n-            // Record that `second_smallest` now contains all the stuff that was\n-            // in `smallest` before.\n-            let mut consumed_cgu_names = cgu_contents.remove(&smallest.name()).unwrap();\n-            cgu_contents.get_mut(&second_smallest.name()).unwrap().append(&mut consumed_cgu_names);\n-\n-            debug!(\n-                \"CodegenUnit {} merged into CodegenUnit {}\",\n-                smallest.name(),\n-                second_smallest.name()\n-            );\n-        }\n-\n-        let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n-\n-        if cx.tcx.sess.opts.incremental.is_some() {\n-            // If we are doing incremental compilation, we want CGU names to\n-            // reflect the path of the source level module they correspond to.\n-            // For CGUs that contain the code of multiple modules because of the\n-            // merging done above, we use a concatenation of the names of all\n-            // contained CGUs.\n-            let new_cgu_names: FxHashMap<Symbol, String> = cgu_contents\n-                .into_iter()\n-                // This `filter` makes sure we only update the name of CGUs that\n-                // were actually modified by merging.\n-                .filter(|(_, cgu_contents)| cgu_contents.len() > 1)\n-                .map(|(current_cgu_name, cgu_contents)| {\n-                    let mut cgu_contents: Vec<&str> =\n-                        cgu_contents.iter().map(|s| s.as_str()).collect();\n-\n-                    // Sort the names, so things are deterministic and easy to\n-                    // predict. We are sorting primitive `&str`s here so we can\n-                    // use unstable sort.\n-                    cgu_contents.sort_unstable();\n-\n-                    (current_cgu_name, cgu_contents.join(\"--\"))\n-                })\n-                .collect();\n-\n-            for cgu in codegen_units.iter_mut() {\n-                if let Some(new_cgu_name) = new_cgu_names.get(&cgu.name()) {\n-                    if cx.tcx.sess.opts.unstable_opts.human_readable_cgu_names {\n-                        cgu.set_name(Symbol::intern(&new_cgu_name));\n-                    } else {\n-                        // If we don't require CGU names to be human-readable,\n-                        // we use a fixed length hash of the composite CGU name\n-                        // instead.\n-                        let new_cgu_name = CodegenUnit::mangle_name(&new_cgu_name);\n-                        cgu.set_name(Symbol::intern(&new_cgu_name));\n-                    }\n-                }\n-            }\n-        } else {\n-            // If we are compiling non-incrementally we just generate simple CGU\n-            // names containing an index.\n-            for (index, cgu) in codegen_units.iter_mut().enumerate() {\n-                let numbered_codegen_unit_name =\n-                    cgu_name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index));\n-                cgu.set_name(numbered_codegen_unit_name);\n-            }\n-        }\n-    }\n-\n-    fn place_inlined_mono_items(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut [CodegenUnit<'tcx>],\n-        roots: FxHashSet<MonoItem<'tcx>>,\n-    ) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement> {\n-        let mut mono_item_placements = FxHashMap::default();\n-\n-        let single_codegen_unit = codegen_units.len() == 1;\n-\n-        for old_codegen_unit in codegen_units.iter_mut() {\n-            // Collect all items that need to be available in this codegen unit.\n-            let mut reachable = FxHashSet::default();\n-            for root in old_codegen_unit.items().keys() {\n-                follow_inlining(*root, cx.inlining_map, &mut reachable);\n-            }\n-\n-            let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name());\n-\n-            // Add all monomorphizations that are not already there.\n-            for mono_item in reachable {\n-                if let Some(linkage) = old_codegen_unit.items().get(&mono_item) {\n-                    // This is a root, just copy it over.\n-                    new_codegen_unit.items_mut().insert(mono_item, *linkage);\n-                } else {\n-                    if roots.contains(&mono_item) {\n-                        bug!(\n-                            \"GloballyShared mono-item inlined into other CGU: \\\n-                              {:?}\",\n-                            mono_item\n-                        );\n-                    }\n-\n-                    // This is a CGU-private copy.\n-                    new_codegen_unit\n-                        .items_mut()\n-                        .insert(mono_item, (Linkage::Internal, Visibility::Default));\n-                }\n-\n-                if !single_codegen_unit {\n-                    // If there is more than one codegen unit, we need to keep track\n-                    // in which codegen units each monomorphization is placed.\n-                    match mono_item_placements.entry(mono_item) {\n-                        Entry::Occupied(e) => {\n-                            let placement = e.into_mut();\n-                            debug_assert!(match *placement {\n-                                MonoItemPlacement::SingleCgu { cgu_name } => {\n-                                    cgu_name != new_codegen_unit.name()\n-                                }\n-                                MonoItemPlacement::MultipleCgus => true,\n-                            });\n-                            *placement = MonoItemPlacement::MultipleCgus;\n-                        }\n-                        Entry::Vacant(e) => {\n-                            e.insert(MonoItemPlacement::SingleCgu {\n-                                cgu_name: new_codegen_unit.name(),\n-                            });\n-                        }\n-                    }\n-                }\n-            }\n-\n-            *old_codegen_unit = new_codegen_unit;\n-        }\n-\n-        return mono_item_placements;\n-\n-        fn follow_inlining<'tcx>(\n-            mono_item: MonoItem<'tcx>,\n-            inlining_map: &InliningMap<'tcx>,\n-            visited: &mut FxHashSet<MonoItem<'tcx>>,\n-        ) {\n-            if !visited.insert(mono_item) {\n-                return;\n-            }\n-\n-            inlining_map.with_inlining_candidates(mono_item, |target| {\n-                follow_inlining(target, inlining_map, visited);\n-            });\n-        }\n-    }\n-\n-    fn internalize_symbols(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut [CodegenUnit<'tcx>],\n-        mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n-        internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n-    ) {\n-        if codegen_units.len() == 1 {\n-            // Fast path for when there is only one codegen unit. In this case we\n-            // can internalize all candidates, since there is nowhere else they\n-            // could be accessed from.\n-            for cgu in codegen_units {\n-                for candidate in &internalization_candidates {\n-                    cgu.items_mut().insert(*candidate, (Linkage::Internal, Visibility::Default));\n-                }\n-            }\n-\n-            return;\n-        }\n-\n-        // Build a map from every monomorphization to all the monomorphizations that\n-        // reference it.\n-        let mut accessor_map: FxHashMap<MonoItem<'tcx>, Vec<MonoItem<'tcx>>> = Default::default();\n-        cx.inlining_map.iter_accesses(|accessor, accessees| {\n-            for accessee in accessees {\n-                accessor_map.entry(*accessee).or_default().push(accessor);\n-            }\n-        });\n-\n-        // For each internalization candidates in each codegen unit, check if it is\n-        // accessed from outside its defining codegen unit.\n-        for cgu in codegen_units {\n-            let home_cgu = MonoItemPlacement::SingleCgu { cgu_name: cgu.name() };\n-\n-            for (accessee, linkage_and_visibility) in cgu.items_mut() {\n-                if !internalization_candidates.contains(accessee) {\n-                    // This item is no candidate for internalizing, so skip it.\n-                    continue;\n-                }\n-                debug_assert_eq!(mono_item_placements[accessee], home_cgu);\n-\n-                if let Some(accessors) = accessor_map.get(accessee) {\n-                    if accessors\n-                        .iter()\n-                        .filter_map(|accessor| {\n-                            // Some accessors might not have been\n-                            // instantiated. We can safely ignore those.\n-                            mono_item_placements.get(accessor)\n-                        })\n-                        .any(|placement| *placement != home_cgu)\n-                    {\n-                        // Found an accessor from another CGU, so skip to the next\n-                        // item without marking this one as internal.\n-                        continue;\n-                    }\n-                }\n-\n-                // If we got here, we did not find any accesses from other CGUs,\n-                // so it's fine to make this monomorphization internal.\n-                *linkage_and_visibility = (Linkage::Internal, Visibility::Default);\n-            }\n-        }\n-    }\n-}\n-\n-fn characteristic_def_id_of_mono_item<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    mono_item: MonoItem<'tcx>,\n-) -> Option<DefId> {\n-    match mono_item {\n-        MonoItem::Fn(instance) => {\n-            let def_id = match instance.def {\n-                ty::InstanceDef::Item(def) => def,\n-                ty::InstanceDef::VTableShim(..)\n-                | ty::InstanceDef::ReifyShim(..)\n-                | ty::InstanceDef::FnPtrShim(..)\n-                | ty::InstanceDef::ClosureOnceShim { .. }\n-                | ty::InstanceDef::Intrinsic(..)\n-                | ty::InstanceDef::DropGlue(..)\n-                | ty::InstanceDef::Virtual(..)\n-                | ty::InstanceDef::CloneShim(..)\n-                | ty::InstanceDef::ThreadLocalShim(..)\n-                | ty::InstanceDef::FnPtrAddrShim(..) => return None,\n-            };\n-\n-            // If this is a method, we want to put it into the same module as\n-            // its self-type. If the self-type does not provide a characteristic\n-            // DefId, we use the location of the impl after all.\n-\n-            if tcx.trait_of_item(def_id).is_some() {\n-                let self_ty = instance.substs.type_at(0);\n-                // This is a default implementation of a trait method.\n-                return characteristic_def_id_of_type(self_ty).or(Some(def_id));\n-            }\n-\n-            if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n-                if tcx.sess.opts.incremental.is_some()\n-                    && tcx.trait_id_of_impl(impl_def_id) == tcx.lang_items().drop_trait()\n-                {\n-                    // Put `Drop::drop` into the same cgu as `drop_in_place`\n-                    // since `drop_in_place` is the only thing that can\n-                    // call it.\n-                    return None;\n-                }\n-\n-                // When polymorphization is enabled, methods which do not depend on their generic\n-                // parameters, but the self-type of their impl block do will fail to normalize.\n-                if !tcx.sess.opts.unstable_opts.polymorphize || !instance.has_param() {\n-                    // This is a method within an impl, find out what the self-type is:\n-                    let impl_self_ty = tcx.subst_and_normalize_erasing_regions(\n-                        instance.substs,\n-                        ty::ParamEnv::reveal_all(),\n-                        tcx.type_of(impl_def_id),\n-                    );\n-                    if let Some(def_id) = characteristic_def_id_of_type(impl_self_ty) {\n-                        return Some(def_id);\n-                    }\n-                }\n-            }\n-\n-            Some(def_id)\n-        }\n-        MonoItem::Static(def_id) => Some(def_id),\n-        MonoItem::GlobalAsm(item_id) => Some(item_id.owner_id.to_def_id()),\n-    }\n-}\n-\n-fn compute_codegen_unit_name(\n-    tcx: TyCtxt<'_>,\n-    name_builder: &mut CodegenUnitNameBuilder<'_>,\n-    def_id: DefId,\n-    volatile: bool,\n-    cache: &mut CguNameCache,\n-) -> Symbol {\n-    // Find the innermost module that is not nested within a function.\n-    let mut current_def_id = def_id;\n-    let mut cgu_def_id = None;\n-    // Walk backwards from the item we want to find the module for.\n-    loop {\n-        if current_def_id.is_crate_root() {\n-            if cgu_def_id.is_none() {\n-                // If we have not found a module yet, take the crate root.\n-                cgu_def_id = Some(def_id.krate.as_def_id());\n-            }\n-            break;\n-        } else if tcx.def_kind(current_def_id) == DefKind::Mod {\n-            if cgu_def_id.is_none() {\n-                cgu_def_id = Some(current_def_id);\n-            }\n-        } else {\n-            // If we encounter something that is not a module, throw away\n-            // any module that we've found so far because we now know that\n-            // it is nested within something else.\n-            cgu_def_id = None;\n-        }\n-\n-        current_def_id = tcx.parent(current_def_id);\n-    }\n-\n-    let cgu_def_id = cgu_def_id.unwrap();\n-\n-    *cache.entry((cgu_def_id, volatile)).or_insert_with(|| {\n-        let def_path = tcx.def_path(cgu_def_id);\n-\n-        let components = def_path.data.iter().map(|part| match part.data.name() {\n-            DefPathDataName::Named(name) => name,\n-            DefPathDataName::Anon { .. } => unreachable!(),\n-        });\n-\n-        let volatile_suffix = volatile.then_some(\"volatile\");\n-\n-        name_builder.build_cgu_name(def_path.krate, components, volatile_suffix)\n-    })\n-}\n-\n-// Anything we can't find a proper codegen unit for goes into this.\n-fn fallback_cgu_name(name_builder: &mut CodegenUnitNameBuilder<'_>) -> Symbol {\n-    name_builder.build_cgu_name(LOCAL_CRATE, &[\"fallback\"], Some(\"cgu\"))\n-}\n-\n-fn mono_item_linkage_and_visibility<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    mono_item: &MonoItem<'tcx>,\n-    can_be_internalized: &mut bool,\n-    export_generics: bool,\n-) -> (Linkage, Visibility) {\n-    if let Some(explicit_linkage) = mono_item.explicit_linkage(tcx) {\n-        return (explicit_linkage, Visibility::Default);\n-    }\n-    let vis = mono_item_visibility(tcx, mono_item, can_be_internalized, export_generics);\n-    (Linkage::External, vis)\n-}\n-\n-type CguNameCache = FxHashMap<(DefId, bool), Symbol>;\n-\n-fn static_visibility<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    can_be_internalized: &mut bool,\n-    def_id: DefId,\n-) -> Visibility {\n-    if tcx.is_reachable_non_generic(def_id) {\n-        *can_be_internalized = false;\n-        default_visibility(tcx, def_id, false)\n-    } else {\n-        Visibility::Hidden\n-    }\n-}\n-\n-fn mono_item_visibility<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    mono_item: &MonoItem<'tcx>,\n-    can_be_internalized: &mut bool,\n-    export_generics: bool,\n-) -> Visibility {\n-    let instance = match mono_item {\n-        // This is pretty complicated; see below.\n-        MonoItem::Fn(instance) => instance,\n-\n-        // Misc handling for generics and such, but otherwise:\n-        MonoItem::Static(def_id) => return static_visibility(tcx, can_be_internalized, *def_id),\n-        MonoItem::GlobalAsm(item_id) => {\n-            return static_visibility(tcx, can_be_internalized, item_id.owner_id.to_def_id());\n-        }\n-    };\n-\n-    let def_id = match instance.def {\n-        InstanceDef::Item(def_id) | InstanceDef::DropGlue(def_id, Some(_)) => def_id,\n-\n-        // We match the visibility of statics here\n-        InstanceDef::ThreadLocalShim(def_id) => {\n-            return static_visibility(tcx, can_be_internalized, def_id);\n-        }\n-\n-        // These are all compiler glue and such, never exported, always hidden.\n-        InstanceDef::VTableShim(..)\n-        | InstanceDef::ReifyShim(..)\n-        | InstanceDef::FnPtrShim(..)\n-        | InstanceDef::Virtual(..)\n-        | InstanceDef::Intrinsic(..)\n-        | InstanceDef::ClosureOnceShim { .. }\n-        | InstanceDef::DropGlue(..)\n-        | InstanceDef::CloneShim(..)\n-        | InstanceDef::FnPtrAddrShim(..) => return Visibility::Hidden,\n-    };\n-\n-    // The `start_fn` lang item is actually a monomorphized instance of a\n-    // function in the standard library, used for the `main` function. We don't\n-    // want to export it so we tag it with `Hidden` visibility but this symbol\n-    // is only referenced from the actual `main` symbol which we unfortunately\n-    // don't know anything about during partitioning/collection. As a result we\n-    // forcibly keep this symbol out of the `internalization_candidates` set.\n-    //\n-    // FIXME: eventually we don't want to always force this symbol to have\n-    //        hidden visibility, it should indeed be a candidate for\n-    //        internalization, but we have to understand that it's referenced\n-    //        from the `main` symbol we'll generate later.\n-    //\n-    //        This may be fixable with a new `InstanceDef` perhaps? Unsure!\n-    if tcx.lang_items().start_fn() == Some(def_id) {\n-        *can_be_internalized = false;\n-        return Visibility::Hidden;\n-    }\n-\n-    let is_generic = instance.substs.non_erasable_generics().next().is_some();\n-\n-    // Upstream `DefId` instances get different handling than local ones.\n-    let Some(def_id) = def_id.as_local() else {\n-        return if export_generics && is_generic {\n-            // If it is an upstream monomorphization and we export generics, we must make\n-            // it available to downstream crates.\n-            *can_be_internalized = false;\n-            default_visibility(tcx, def_id, true)\n-        } else {\n-            Visibility::Hidden\n-        };\n-    };\n-\n-    if is_generic {\n-        if export_generics {\n-            if tcx.is_unreachable_local_definition(def_id) {\n-                // This instance cannot be used from another crate.\n-                Visibility::Hidden\n-            } else {\n-                // This instance might be useful in a downstream crate.\n-                *can_be_internalized = false;\n-                default_visibility(tcx, def_id.to_def_id(), true)\n-            }\n-        } else {\n-            // We are not exporting generics or the definition is not reachable\n-            // for downstream crates, we can internalize its instantiations.\n-            Visibility::Hidden\n-        }\n-    } else {\n-        // If this isn't a generic function then we mark this a `Default` if\n-        // this is a reachable item, meaning that it's a symbol other crates may\n-        // access when they link to us.\n-        if tcx.is_reachable_non_generic(def_id.to_def_id()) {\n-            *can_be_internalized = false;\n-            debug_assert!(!is_generic);\n-            return default_visibility(tcx, def_id.to_def_id(), false);\n-        }\n-\n-        // If this isn't reachable then we're gonna tag this with `Hidden`\n-        // visibility. In some situations though we'll want to prevent this\n-        // symbol from being internalized.\n-        //\n-        // There's two categories of items here:\n-        //\n-        // * First is weak lang items. These are basically mechanisms for\n-        //   libcore to forward-reference symbols defined later in crates like\n-        //   the standard library or `#[panic_handler]` definitions. The\n-        //   definition of these weak lang items needs to be referencable by\n-        //   libcore, so we're no longer a candidate for internalization.\n-        //   Removal of these functions can't be done by LLVM but rather must be\n-        //   done by the linker as it's a non-local decision.\n-        //\n-        // * Second is \"std internal symbols\". Currently this is primarily used\n-        //   for allocator symbols. Allocators are a little weird in their\n-        //   implementation, but the idea is that the compiler, at the last\n-        //   minute, defines an allocator with an injected object file. The\n-        //   `alloc` crate references these symbols (`__rust_alloc`) and the\n-        //   definition doesn't get hooked up until a linked crate artifact is\n-        //   generated.\n-        //\n-        //   The symbols synthesized by the compiler (`__rust_alloc`) are thin\n-        //   veneers around the actual implementation, some other symbol which\n-        //   implements the same ABI. These symbols (things like `__rg_alloc`,\n-        //   `__rdl_alloc`, `__rde_alloc`, etc), are all tagged with \"std\n-        //   internal symbols\".\n-        //\n-        //   The std-internal symbols here **should not show up in a dll as an\n-        //   exported interface**, so they return `false` from\n-        //   `is_reachable_non_generic` above and we'll give them `Hidden`\n-        //   visibility below. Like the weak lang items, though, we can't let\n-        //   LLVM internalize them as this decision is left up to the linker to\n-        //   omit them, so prevent them from being internalized.\n-        let attrs = tcx.codegen_fn_attrs(def_id);\n-        if attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL) {\n-            *can_be_internalized = false;\n-        }\n-\n-        Visibility::Hidden\n-    }\n-}\n-\n-fn default_visibility(tcx: TyCtxt<'_>, id: DefId, is_generic: bool) -> Visibility {\n-    if !tcx.sess.target.default_hidden_visibility {\n-        return Visibility::Default;\n-    }\n-\n-    // Generic functions never have export-level C.\n-    if is_generic {\n-        return Visibility::Hidden;\n-    }\n-\n-    // Things with export level C don't get instantiated in\n-    // downstream crates.\n-    if !id.is_local() {\n-        return Visibility::Hidden;\n-    }\n-\n-    // C-export level items remain at `Default`, all other internal\n-    // items become `Hidden`.\n-    match tcx.reachable_non_generics(id.krate).get(&id) {\n-        Some(SymbolExportInfo { level: SymbolExportLevel::C, .. }) => Visibility::Default,\n-        _ => Visibility::Hidden,\n-    }\n-}"}, {"sha": "d0b23ca9ea44494dcc9dbe891f998bda48a31dc4", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "removed", "additions": 0, "deletions": 673, "changes": 673, "blob_url": "https://github.com/rust-lang/rust/blob/fdd62cfe7d2ea9189e957951b8b7b8251cd50854/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd62cfe7d2ea9189e957951b8b7b8251cd50854/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=fdd62cfe7d2ea9189e957951b8b7b8251cd50854", "patch": "@@ -1,673 +0,0 @@\n-//! Partitioning Codegen Units for Incremental Compilation\n-//! ======================================================\n-//!\n-//! The task of this module is to take the complete set of monomorphizations of\n-//! a crate and produce a set of codegen units from it, where a codegen unit\n-//! is a named set of (mono-item, linkage) pairs. That is, this module\n-//! decides which monomorphization appears in which codegen units with which\n-//! linkage. The following paragraphs describe some of the background on the\n-//! partitioning scheme.\n-//!\n-//! The most important opportunity for saving on compilation time with\n-//! incremental compilation is to avoid re-codegenning and re-optimizing code.\n-//! Since the unit of codegen and optimization for LLVM is \"modules\" or, how\n-//! we call them \"codegen units\", the particulars of how much time can be saved\n-//! by incremental compilation are tightly linked to how the output program is\n-//! partitioned into these codegen units prior to passing it to LLVM --\n-//! especially because we have to treat codegen units as opaque entities once\n-//! they are created: There is no way for us to incrementally update an existing\n-//! LLVM module and so we have to build any such module from scratch if it was\n-//! affected by some change in the source code.\n-//!\n-//! From that point of view it would make sense to maximize the number of\n-//! codegen units by, for example, putting each function into its own module.\n-//! That way only those modules would have to be re-compiled that were actually\n-//! affected by some change, minimizing the number of functions that could have\n-//! been re-used but just happened to be located in a module that is\n-//! re-compiled.\n-//!\n-//! However, since LLVM optimization does not work across module boundaries,\n-//! using such a highly granular partitioning would lead to very slow runtime\n-//! code since it would effectively prohibit inlining and other inter-procedure\n-//! optimizations. We want to avoid that as much as possible.\n-//!\n-//! Thus we end up with a trade-off: The bigger the codegen units, the better\n-//! LLVM's optimizer can do its work, but also the smaller the compilation time\n-//! reduction we get from incremental compilation.\n-//!\n-//! Ideally, we would create a partitioning such that there are few big codegen\n-//! units with few interdependencies between them. For now though, we use the\n-//! following heuristic to determine the partitioning:\n-//!\n-//! - There are two codegen units for every source-level module:\n-//! - One for \"stable\", that is non-generic, code\n-//! - One for more \"volatile\" code, i.e., monomorphized instances of functions\n-//!   defined in that module\n-//!\n-//! In order to see why this heuristic makes sense, let's take a look at when a\n-//! codegen unit can get invalidated:\n-//!\n-//! 1. The most straightforward case is when the BODY of a function or global\n-//! changes. Then any codegen unit containing the code for that item has to be\n-//! re-compiled. Note that this includes all codegen units where the function\n-//! has been inlined.\n-//!\n-//! 2. The next case is when the SIGNATURE of a function or global changes. In\n-//! this case, all codegen units containing a REFERENCE to that item have to be\n-//! re-compiled. This is a superset of case 1.\n-//!\n-//! 3. The final and most subtle case is when a REFERENCE to a generic function\n-//! is added or removed somewhere. Even though the definition of the function\n-//! might be unchanged, a new REFERENCE might introduce a new monomorphized\n-//! instance of this function which has to be placed and compiled somewhere.\n-//! Conversely, when removing a REFERENCE, it might have been the last one with\n-//! that particular set of generic arguments and thus we have to remove it.\n-//!\n-//! From the above we see that just using one codegen unit per source-level\n-//! module is not such a good idea, since just adding a REFERENCE to some\n-//! generic item somewhere else would invalidate everything within the module\n-//! containing the generic item. The heuristic above reduces this detrimental\n-//! side-effect of references a little by at least not touching the non-generic\n-//! code of the module.\n-//!\n-//! A Note on Inlining\n-//! ------------------\n-//! As briefly mentioned above, in order for LLVM to be able to inline a\n-//! function call, the body of the function has to be available in the LLVM\n-//! module where the call is made. This has a few consequences for partitioning:\n-//!\n-//! - The partitioning algorithm has to take care of placing functions into all\n-//!   codegen units where they should be available for inlining. It also has to\n-//!   decide on the correct linkage for these functions.\n-//!\n-//! - The partitioning algorithm has to know which functions are likely to get\n-//!   inlined, so it can distribute function instantiations accordingly. Since\n-//!   there is no way of knowing for sure which functions LLVM will decide to\n-//!   inline in the end, we apply a heuristic here: Only functions marked with\n-//!   `#[inline]` are considered for inlining by the partitioner. The current\n-//!   implementation will not try to determine if a function is likely to be\n-//!   inlined by looking at the functions definition.\n-//!\n-//! Note though that as a side-effect of creating a codegen units per\n-//! source-level module, functions from the same module will be available for\n-//! inlining, even when they are not marked `#[inline]`.\n-\n-mod default;\n-\n-use std::cmp;\n-use std::fs::{self, File};\n-use std::io::{BufWriter, Write};\n-use std::path::{Path, PathBuf};\n-\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::sync;\n-use rustc_hir::def_id::{DefIdSet, LOCAL_CRATE};\n-use rustc_middle::mir;\n-use rustc_middle::mir::mono::MonoItem;\n-use rustc_middle::mir::mono::{CodegenUnit, Linkage};\n-use rustc_middle::query::Providers;\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::{DumpMonoStatsFormat, SwitchWithOptPath};\n-use rustc_span::symbol::Symbol;\n-\n-use crate::collector::InliningMap;\n-use crate::collector::{self, MonoItemCollectionMode};\n-use crate::errors::{\n-    CouldntDumpMonoStats, SymbolAlreadyDefined, UnknownCguCollectionMode, UnknownPartitionStrategy,\n-};\n-\n-enum Partitioner {\n-    Default(default::DefaultPartitioning),\n-    // Other partitioning strategies can go here.\n-    Unknown,\n-}\n-\n-impl<'tcx> Partition<'tcx> for Partitioner {\n-    fn place_root_mono_items<I>(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        mono_items: &mut I,\n-    ) -> PlacedRootMonoItems<'tcx>\n-    where\n-        I: Iterator<Item = MonoItem<'tcx>>,\n-    {\n-        match self {\n-            Partitioner::Default(partitioner) => partitioner.place_root_mono_items(cx, mono_items),\n-            Partitioner::Unknown => cx.tcx.sess.emit_fatal(UnknownPartitionStrategy),\n-        }\n-    }\n-\n-    fn merge_codegen_units(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n-    ) {\n-        match self {\n-            Partitioner::Default(partitioner) => partitioner.merge_codegen_units(cx, codegen_units),\n-            Partitioner::Unknown => cx.tcx.sess.emit_fatal(UnknownPartitionStrategy),\n-        }\n-    }\n-\n-    fn place_inlined_mono_items(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut [CodegenUnit<'tcx>],\n-        roots: FxHashSet<MonoItem<'tcx>>,\n-    ) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement> {\n-        match self {\n-            Partitioner::Default(partitioner) => {\n-                partitioner.place_inlined_mono_items(cx, codegen_units, roots)\n-            }\n-            Partitioner::Unknown => cx.tcx.sess.emit_fatal(UnknownPartitionStrategy),\n-        }\n-    }\n-\n-    fn internalize_symbols(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut [CodegenUnit<'tcx>],\n-        mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n-        internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n-    ) {\n-        match self {\n-            Partitioner::Default(partitioner) => partitioner.internalize_symbols(\n-                cx,\n-                codegen_units,\n-                mono_item_placements,\n-                internalization_candidates,\n-            ),\n-            Partitioner::Unknown => cx.tcx.sess.emit_fatal(UnknownPartitionStrategy),\n-        }\n-    }\n-}\n-\n-struct PartitioningCx<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    target_cgu_count: usize,\n-    inlining_map: &'a InliningMap<'tcx>,\n-}\n-\n-pub struct PlacedRootMonoItems<'tcx> {\n-    codegen_units: Vec<CodegenUnit<'tcx>>,\n-    roots: FxHashSet<MonoItem<'tcx>>,\n-    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n-}\n-\n-trait Partition<'tcx> {\n-    fn place_root_mono_items<I>(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        mono_items: &mut I,\n-    ) -> PlacedRootMonoItems<'tcx>\n-    where\n-        I: Iterator<Item = MonoItem<'tcx>>;\n-\n-    fn merge_codegen_units(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n-    );\n-\n-    fn place_inlined_mono_items(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut [CodegenUnit<'tcx>],\n-        roots: FxHashSet<MonoItem<'tcx>>,\n-    ) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement>;\n-\n-    fn internalize_symbols(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut [CodegenUnit<'tcx>],\n-        mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n-        internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n-    );\n-}\n-\n-fn get_partitioner(tcx: TyCtxt<'_>) -> Partitioner {\n-    let strategy = match &tcx.sess.opts.unstable_opts.cgu_partitioning_strategy {\n-        None => \"default\",\n-        Some(s) => &s[..],\n-    };\n-\n-    match strategy {\n-        \"default\" => Partitioner::Default(default::DefaultPartitioning),\n-        _ => Partitioner::Unknown,\n-    }\n-}\n-\n-fn partition<'tcx, I>(\n-    tcx: TyCtxt<'tcx>,\n-    mono_items: &mut I,\n-    max_cgu_count: usize,\n-    inlining_map: &InliningMap<'tcx>,\n-) -> Vec<CodegenUnit<'tcx>>\n-where\n-    I: Iterator<Item = MonoItem<'tcx>>,\n-{\n-    let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning\");\n-\n-    let mut partitioner = get_partitioner(tcx);\n-    let cx = &PartitioningCx { tcx, target_cgu_count: max_cgu_count, inlining_map };\n-    // In the first step, we place all regular monomorphizations into their\n-    // respective 'home' codegen unit. Regular monomorphizations are all\n-    // functions and statics defined in the local crate.\n-    let PlacedRootMonoItems { mut codegen_units, roots, internalization_candidates } = {\n-        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_roots\");\n-        partitioner.place_root_mono_items(cx, mono_items)\n-    };\n-\n-    for cgu in &mut codegen_units {\n-        cgu.create_size_estimate(tcx);\n-    }\n-\n-    debug_dump(tcx, \"INITIAL PARTITIONING\", &codegen_units);\n-\n-    // Merge until we have at most `max_cgu_count` codegen units.\n-    // `merge_codegen_units` is responsible for updating the CGU size\n-    // estimates.\n-    {\n-        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_merge_cgus\");\n-        partitioner.merge_codegen_units(cx, &mut codegen_units);\n-        debug_dump(tcx, \"POST MERGING\", &codegen_units);\n-    }\n-\n-    // In the next step, we use the inlining map to determine which additional\n-    // monomorphizations have to go into each codegen unit. These additional\n-    // monomorphizations can be drop-glue, functions from external crates, and\n-    // local functions the definition of which is marked with `#[inline]`.\n-    let mono_item_placements = {\n-        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_inline_items\");\n-        partitioner.place_inlined_mono_items(cx, &mut codegen_units, roots)\n-    };\n-\n-    for cgu in &mut codegen_units {\n-        cgu.create_size_estimate(tcx);\n-    }\n-\n-    debug_dump(tcx, \"POST INLINING\", &codegen_units);\n-\n-    // Next we try to make as many symbols \"internal\" as possible, so LLVM has\n-    // more freedom to optimize.\n-    if !tcx.sess.link_dead_code() {\n-        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_internalize_symbols\");\n-        partitioner.internalize_symbols(\n-            cx,\n-            &mut codegen_units,\n-            mono_item_placements,\n-            internalization_candidates,\n-        );\n-    }\n-\n-    let instrument_dead_code =\n-        tcx.sess.instrument_coverage() && !tcx.sess.instrument_coverage_except_unused_functions();\n-\n-    if instrument_dead_code {\n-        assert!(\n-            codegen_units.len() > 0,\n-            \"There must be at least one CGU that code coverage data can be generated in.\"\n-        );\n-\n-        // Find the smallest CGU that has exported symbols and put the dead\n-        // function stubs in that CGU. We look for exported symbols to increase\n-        // the likelihood the linker won't throw away the dead functions.\n-        // FIXME(#92165): In order to truly resolve this, we need to make sure\n-        // the object file (CGU) containing the dead function stubs is included\n-        // in the final binary. This will probably require forcing these\n-        // function symbols to be included via `-u` or `/include` linker args.\n-        let mut cgus: Vec<_> = codegen_units.iter_mut().collect();\n-        cgus.sort_by_key(|cgu| cgu.size_estimate());\n-\n-        let dead_code_cgu =\n-            if let Some(cgu) = cgus.into_iter().rev().find(|cgu| {\n-                cgu.items().iter().any(|(_, (linkage, _))| *linkage == Linkage::External)\n-            }) {\n-                cgu\n-            } else {\n-                // If there are no CGUs that have externally linked items,\n-                // then we just pick the first CGU as a fallback.\n-                &mut codegen_units[0]\n-            };\n-        dead_code_cgu.make_code_coverage_dead_code_cgu();\n-    }\n-\n-    // Finally, sort by codegen unit name, so that we get deterministic results.\n-    codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n-\n-    debug_dump(tcx, \"FINAL\", &codegen_units);\n-\n-    codegen_units\n-}\n-\n-/// For symbol internalization, we need to know whether a symbol/mono-item is\n-/// accessed from outside the codegen unit it is defined in. This type is used\n-/// to keep track of that.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-enum MonoItemPlacement {\n-    SingleCgu { cgu_name: Symbol },\n-    MultipleCgus,\n-}\n-\n-fn debug_dump<'a, 'tcx: 'a>(tcx: TyCtxt<'tcx>, label: &str, cgus: &[CodegenUnit<'tcx>]) {\n-    let dump = move || {\n-        use std::fmt::Write;\n-\n-        let num_cgus = cgus.len();\n-        let max = cgus.iter().map(|cgu| cgu.size_estimate()).max().unwrap();\n-        let min = cgus.iter().map(|cgu| cgu.size_estimate()).min().unwrap();\n-        let ratio = max as f64 / min as f64;\n-\n-        let s = &mut String::new();\n-        let _ = writeln!(\n-            s,\n-            \"{label} ({num_cgus} CodegenUnits, max={max}, min={min}, max/min={ratio:.1}):\"\n-        );\n-        for cgu in cgus {\n-            let _ =\n-                writeln!(s, \"CodegenUnit {} estimated size {}:\", cgu.name(), cgu.size_estimate());\n-\n-            for (mono_item, linkage) in cgu.items() {\n-                let symbol_name = mono_item.symbol_name(tcx).name;\n-                let symbol_hash_start = symbol_name.rfind('h');\n-                let symbol_hash = symbol_hash_start.map_or(\"<no hash>\", |i| &symbol_name[i..]);\n-\n-                let _ = with_no_trimmed_paths!(writeln!(\n-                    s,\n-                    \" - {} [{:?}] [{}] estimated size {}\",\n-                    mono_item,\n-                    linkage,\n-                    symbol_hash,\n-                    mono_item.size_estimate(tcx)\n-                ));\n-            }\n-\n-            let _ = writeln!(s);\n-        }\n-\n-        std::mem::take(s)\n-    };\n-\n-    debug!(\"{}\", dump());\n-}\n-\n-#[inline(never)] // give this a place in the profiler\n-fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'tcx>, mono_items: I)\n-where\n-    I: Iterator<Item = &'a MonoItem<'tcx>>,\n-    'tcx: 'a,\n-{\n-    let _prof_timer = tcx.prof.generic_activity(\"assert_symbols_are_distinct\");\n-\n-    let mut symbols: Vec<_> =\n-        mono_items.map(|mono_item| (mono_item, mono_item.symbol_name(tcx))).collect();\n-\n-    symbols.sort_by_key(|sym| sym.1);\n-\n-    for &[(mono_item1, ref sym1), (mono_item2, ref sym2)] in symbols.array_windows() {\n-        if sym1 == sym2 {\n-            let span1 = mono_item1.local_span(tcx);\n-            let span2 = mono_item2.local_span(tcx);\n-\n-            // Deterministically select one of the spans for error reporting\n-            let span = match (span1, span2) {\n-                (Some(span1), Some(span2)) => {\n-                    Some(if span1.lo().0 > span2.lo().0 { span1 } else { span2 })\n-                }\n-                (span1, span2) => span1.or(span2),\n-            };\n-\n-            tcx.sess.emit_fatal(SymbolAlreadyDefined { span, symbol: sym1.to_string() });\n-        }\n-    }\n-}\n-\n-fn collect_and_partition_mono_items(tcx: TyCtxt<'_>, (): ()) -> (&DefIdSet, &[CodegenUnit<'_>]) {\n-    let collection_mode = match tcx.sess.opts.unstable_opts.print_mono_items {\n-        Some(ref s) => {\n-            let mode = s.to_lowercase();\n-            let mode = mode.trim();\n-            if mode == \"eager\" {\n-                MonoItemCollectionMode::Eager\n-            } else {\n-                if mode != \"lazy\" {\n-                    tcx.sess.emit_warning(UnknownCguCollectionMode { mode });\n-                }\n-\n-                MonoItemCollectionMode::Lazy\n-            }\n-        }\n-        None => {\n-            if tcx.sess.link_dead_code() {\n-                MonoItemCollectionMode::Eager\n-            } else {\n-                MonoItemCollectionMode::Lazy\n-            }\n-        }\n-    };\n-\n-    let (items, inlining_map) = collector::collect_crate_mono_items(tcx, collection_mode);\n-\n-    tcx.sess.abort_if_errors();\n-\n-    let (codegen_units, _) = tcx.sess.time(\"partition_and_assert_distinct_symbols\", || {\n-        sync::join(\n-            || {\n-                let mut codegen_units = partition(\n-                    tcx,\n-                    &mut items.iter().copied(),\n-                    tcx.sess.codegen_units(),\n-                    &inlining_map,\n-                );\n-                codegen_units[0].make_primary();\n-                &*tcx.arena.alloc_from_iter(codegen_units)\n-            },\n-            || assert_symbols_are_distinct(tcx, items.iter()),\n-        )\n-    });\n-\n-    if tcx.prof.enabled() {\n-        // Record CGU size estimates for self-profiling.\n-        for cgu in codegen_units {\n-            tcx.prof.artifact_size(\n-                \"codegen_unit_size_estimate\",\n-                cgu.name().as_str(),\n-                cgu.size_estimate() as u64,\n-            );\n-        }\n-    }\n-\n-    let mono_items: DefIdSet = items\n-        .iter()\n-        .filter_map(|mono_item| match *mono_item {\n-            MonoItem::Fn(ref instance) => Some(instance.def_id()),\n-            MonoItem::Static(def_id) => Some(def_id),\n-            _ => None,\n-        })\n-        .collect();\n-\n-    // Output monomorphization stats per def_id\n-    if let SwitchWithOptPath::Enabled(ref path) = tcx.sess.opts.unstable_opts.dump_mono_stats {\n-        if let Err(err) =\n-            dump_mono_items_stats(tcx, &codegen_units, path, tcx.crate_name(LOCAL_CRATE))\n-        {\n-            tcx.sess.emit_fatal(CouldntDumpMonoStats { error: err.to_string() });\n-        }\n-    }\n-\n-    if tcx.sess.opts.unstable_opts.print_mono_items.is_some() {\n-        let mut item_to_cgus: FxHashMap<_, Vec<_>> = Default::default();\n-\n-        for cgu in codegen_units {\n-            for (&mono_item, &linkage) in cgu.items() {\n-                item_to_cgus.entry(mono_item).or_default().push((cgu.name(), linkage));\n-            }\n-        }\n-\n-        let mut item_keys: Vec<_> = items\n-            .iter()\n-            .map(|i| {\n-                let mut output = with_no_trimmed_paths!(i.to_string());\n-                output.push_str(\" @@\");\n-                let mut empty = Vec::new();\n-                let cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);\n-                cgus.sort_by_key(|(name, _)| *name);\n-                cgus.dedup();\n-                for &(ref cgu_name, (linkage, _)) in cgus.iter() {\n-                    output.push(' ');\n-                    output.push_str(cgu_name.as_str());\n-\n-                    let linkage_abbrev = match linkage {\n-                        Linkage::External => \"External\",\n-                        Linkage::AvailableExternally => \"Available\",\n-                        Linkage::LinkOnceAny => \"OnceAny\",\n-                        Linkage::LinkOnceODR => \"OnceODR\",\n-                        Linkage::WeakAny => \"WeakAny\",\n-                        Linkage::WeakODR => \"WeakODR\",\n-                        Linkage::Appending => \"Appending\",\n-                        Linkage::Internal => \"Internal\",\n-                        Linkage::Private => \"Private\",\n-                        Linkage::ExternalWeak => \"ExternalWeak\",\n-                        Linkage::Common => \"Common\",\n-                    };\n-\n-                    output.push('[');\n-                    output.push_str(linkage_abbrev);\n-                    output.push(']');\n-                }\n-                output\n-            })\n-            .collect();\n-\n-        item_keys.sort();\n-\n-        for item in item_keys {\n-            println!(\"MONO_ITEM {item}\");\n-        }\n-    }\n-\n-    (tcx.arena.alloc(mono_items), codegen_units)\n-}\n-\n-/// Outputs stats about instantiation counts and estimated size, per `MonoItem`'s\n-/// def, to a file in the given output directory.\n-fn dump_mono_items_stats<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    codegen_units: &[CodegenUnit<'tcx>],\n-    output_directory: &Option<PathBuf>,\n-    crate_name: Symbol,\n-) -> Result<(), Box<dyn std::error::Error>> {\n-    let output_directory = if let Some(ref directory) = output_directory {\n-        fs::create_dir_all(directory)?;\n-        directory\n-    } else {\n-        Path::new(\".\")\n-    };\n-\n-    let format = tcx.sess.opts.unstable_opts.dump_mono_stats_format;\n-    let ext = format.extension();\n-    let filename = format!(\"{crate_name}.mono_items.{ext}\");\n-    let output_path = output_directory.join(&filename);\n-    let file = File::create(&output_path)?;\n-    let mut file = BufWriter::new(file);\n-\n-    // Gather instantiated mono items grouped by def_id\n-    let mut items_per_def_id: FxHashMap<_, Vec<_>> = Default::default();\n-    for cgu in codegen_units {\n-        for (&mono_item, _) in cgu.items() {\n-            // Avoid variable-sized compiler-generated shims\n-            if mono_item.is_user_defined() {\n-                items_per_def_id.entry(mono_item.def_id()).or_default().push(mono_item);\n-            }\n-        }\n-    }\n-\n-    #[derive(serde::Serialize)]\n-    struct MonoItem {\n-        name: String,\n-        instantiation_count: usize,\n-        size_estimate: usize,\n-        total_estimate: usize,\n-    }\n-\n-    // Output stats sorted by total instantiated size, from heaviest to lightest\n-    let mut stats: Vec<_> = items_per_def_id\n-        .into_iter()\n-        .map(|(def_id, items)| {\n-            let name = with_no_trimmed_paths!(tcx.def_path_str(def_id));\n-            let instantiation_count = items.len();\n-            let size_estimate = items[0].size_estimate(tcx);\n-            let total_estimate = instantiation_count * size_estimate;\n-            MonoItem { name, instantiation_count, size_estimate, total_estimate }\n-        })\n-        .collect();\n-    stats.sort_unstable_by_key(|item| cmp::Reverse(item.total_estimate));\n-\n-    if !stats.is_empty() {\n-        match format {\n-            DumpMonoStatsFormat::Json => serde_json::to_writer(file, &stats)?,\n-            DumpMonoStatsFormat::Markdown => {\n-                writeln!(\n-                    file,\n-                    \"| Item | Instantiation count | Estimated Cost Per Instantiation | Total Estimated Cost |\"\n-                )?;\n-                writeln!(file, \"| --- | ---: | ---: | ---: |\")?;\n-\n-                for MonoItem { name, instantiation_count, size_estimate, total_estimate } in stats {\n-                    writeln!(\n-                        file,\n-                        \"| `{name}` | {instantiation_count} | {size_estimate} | {total_estimate} |\"\n-                    )?;\n-                }\n-            }\n-        }\n-    }\n-\n-    Ok(())\n-}\n-\n-fn codegened_and_inlined_items(tcx: TyCtxt<'_>, (): ()) -> &DefIdSet {\n-    let (items, cgus) = tcx.collect_and_partition_mono_items(());\n-    let mut visited = DefIdSet::default();\n-    let mut result = items.clone();\n-\n-    for cgu in cgus {\n-        for (item, _) in cgu.items() {\n-            if let MonoItem::Fn(ref instance) = item {\n-                let did = instance.def_id();\n-                if !visited.insert(did) {\n-                    continue;\n-                }\n-                let body = tcx.instance_mir(instance.def);\n-                for block in body.basic_blocks.iter() {\n-                    for statement in &block.statements {\n-                        let mir::StatementKind::Coverage(_) = statement.kind else { continue };\n-                        let scope = statement.source_info.scope;\n-                        if let Some(inlined) = scope.inlined_instance(&body.source_scopes) {\n-                            result.insert(inlined.def_id());\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    tcx.arena.alloc(result)\n-}\n-\n-pub fn provide(providers: &mut Providers) {\n-    providers.collect_and_partition_mono_items = collect_and_partition_mono_items;\n-    providers.codegened_and_inlined_items = codegened_and_inlined_items;\n-\n-    providers.is_codegened_item = |tcx, def_id| {\n-        let (all_mono_items, _) = tcx.collect_and_partition_mono_items(());\n-        all_mono_items.contains(&def_id)\n-    };\n-\n-    providers.codegen_unit = |tcx, name| {\n-        let (_, all) = tcx.collect_and_partition_mono_items(());\n-        all.iter()\n-            .find(|cgu| cgu.name() == name)\n-            .unwrap_or_else(|| panic!(\"failed to find cgu with name {name:?}\"))\n-    };\n-}"}, {"sha": "7cc2b2c880c60bd75931ec04e2a596622619d366", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ca941f18e2b1bd3db325e6653ad76d7d407003a/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca941f18e2b1bd3db325e6653ad76d7d407003a/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=7ca941f18e2b1bd3db325e6653ad76d7d407003a", "patch": "@@ -1372,8 +1372,6 @@ options! {\n         \"set options for branch target identification and pointer authentication on AArch64\"),\n     cf_protection: CFProtection = (CFProtection::None, parse_cfprotection, [TRACKED],\n         \"instrument control-flow architecture protection\"),\n-    cgu_partitioning_strategy: Option<String> = (None, parse_opt_string, [TRACKED],\n-        \"the codegen unit partitioning strategy to use\"),\n     codegen_backend: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"the backend to use\"),\n     combine_cgu: bool = (false, parse_bool, [TRACKED],"}]}