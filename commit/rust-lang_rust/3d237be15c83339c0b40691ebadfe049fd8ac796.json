{"sha": "3d237be15c83339c0b40691ebadfe049fd8ac796", "node_id": "C_kwDOAAsO6NoAKDNkMjM3YmUxNWM4MzMzOWMwYjQwNjkxZWJhZGZlMDQ5ZmQ4YWM3OTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-25T10:39:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-25T10:39:02Z"}, "message": "Auto merge of #2436 - RalfJung:lib-crates, r=oli-obk\n\nfix build.rs invoking RUSTC to do check builds\n\nThis makes the Miri driver, when invokved via the RUSTC env var from inside a build script, behave almost entirely like rustc. I had to redo how we propagate sysroot information for this (which is actually back to how we used to do sysroot propagation many years ago).\n\nFixes https://github.com/rust-lang/miri/issues/2431", "tree": {"sha": "74dbb3c07cb01dc59514b0d9c8d3eef41954112b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74dbb3c07cb01dc59514b0d9c8d3eef41954112b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d237be15c83339c0b40691ebadfe049fd8ac796", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d237be15c83339c0b40691ebadfe049fd8ac796", "html_url": "https://github.com/rust-lang/rust/commit/3d237be15c83339c0b40691ebadfe049fd8ac796", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d237be15c83339c0b40691ebadfe049fd8ac796/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30d1c68206f5e85e841b82efdb6526db4f17f361", "url": "https://api.github.com/repos/rust-lang/rust/commits/30d1c68206f5e85e841b82efdb6526db4f17f361", "html_url": "https://github.com/rust-lang/rust/commit/30d1c68206f5e85e841b82efdb6526db4f17f361"}, {"sha": "9406b6da68762ec26d9e60b03b38722fee6395ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/9406b6da68762ec26d9e60b03b38722fee6395ef", "html_url": "https://github.com/rust-lang/rust/commit/9406b6da68762ec26d9e60b03b38722fee6395ef"}], "stats": {"total": 217, "additions": 136, "deletions": 81}, "files": [{"sha": "5fbf89c86b9694b305cbc21b84a0c611bd301006", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d237be15c83339c0b40691ebadfe049fd8ac796/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/3d237be15c83339c0b40691ebadfe049fd8ac796/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=3d237be15c83339c0b40691ebadfe049fd8ac796", "patch": "@@ -409,10 +409,9 @@ Moreover, Miri recognizes some environment variables:\n   checkout. Note that changing files in that directory does not automatically\n   trigger a re-build of the standard library; you have to clear the Miri build\n   cache manually (on Linux, `rm -rf ~/.cache/miri`).\n-* `MIRI_SYSROOT` (recognized by `cargo miri` and the test suite) indicates the\n-  sysroot to use. Only set this if you do not want to use the automatically\n-  created sysroot. (The `miri` driver sysroot is controlled via the `--sysroot`\n-  flag instead.)\n+* `MIRI_SYSROOT` (recognized by `cargo miri` and the Miri driver) indicates the sysroot to use. When\n+  using `cargo miri`, only set this if you do not want to use the automatically created sysroot. For\n+  directly invoking the Miri driver, this variable (or a `--sysroot` flag) is mandatory.\n * `MIRI_TEST_TARGET` (recognized by the test suite and the `./miri` script) indicates which target\n   architecture to test against.  `miri` and `cargo miri` accept the `--target` flag for the same\n   purpose."}, {"sha": "8aeeb044d3c17c250b835806ea005cf8aa1bf207", "filename": "cargo-miri/bin.rs", "status": "modified", "additions": 65, "deletions": 48, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/3d237be15c83339c0b40691ebadfe049fd8ac796/cargo-miri%2Fbin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d237be15c83339c0b40691ebadfe049fd8ac796/cargo-miri%2Fbin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fbin.rs?ref=3d237be15c83339c0b40691ebadfe049fd8ac796", "patch": "@@ -205,12 +205,6 @@ fn forward_patched_extern_arg(args: &mut impl Iterator<Item = String>, cmd: &mut\n     }\n }\n \n-fn forward_miri_sysroot(cmd: &mut Command) {\n-    let sysroot = env::var_os(\"MIRI_SYSROOT\").expect(\"the wrapper should have set MIRI_SYSROOT\");\n-    cmd.arg(\"--sysroot\");\n-    cmd.arg(sysroot);\n-}\n-\n /// Escapes `s` in a way that is suitable for using it as a string literal in TOML syntax.\n fn escape_for_toml(s: &str) -> String {\n     // We want to surround this string in quotes `\"`. So we first escape all quotes,\n@@ -237,8 +231,15 @@ fn miri() -> Command {\n     Command::new(find_miri())\n }\n \n+fn miri_for_host() -> Command {\n+    let mut cmd = miri();\n+    cmd.env(\"MIRI_BE_RUSTC\", \"host\");\n+    cmd\n+}\n+\n fn version_info() -> VersionMeta {\n-    VersionMeta::for_command(miri()).expect(\"failed to determine underlying rustc version of Miri\")\n+    VersionMeta::for_command(miri_for_host())\n+        .expect(\"failed to determine underlying rustc version of Miri\")\n }\n \n fn cargo() -> Command {\n@@ -336,7 +337,7 @@ fn ask_to_run(mut cmd: Command, ask: bool, text: &str) {\n             a => show_error(format!(\"invalid answer `{}`\", a)),\n         };\n     } else {\n-        println!(\"Running `{:?}` to {}.\", cmd, text);\n+        eprintln!(\"Running `{:?}` to {}.\", cmd, text);\n     }\n \n     if cmd.status().unwrap_or_else(|_| panic!(\"failed to execute {:?}\", cmd)).success().not() {\n@@ -364,7 +365,7 @@ fn write_to_file(filename: &Path, content: &str) {\n /// Performs the setup required to make `cargo miri` work: Getting a custom-built libstd. Then sets\n /// `MIRI_SYSROOT`. Skipped if `MIRI_SYSROOT` is already set, in which case we expect the user has\n /// done all this already.\n-fn setup(subcommand: &MiriCommand) {\n+fn setup(subcommand: &MiriCommand, host: &str, target: &str) {\n     let only_setup = matches!(subcommand, MiriCommand::Setup);\n     let ask_user = !only_setup;\n     let print_sysroot = only_setup && has_arg_flag(\"--print-sysroot\"); // whether we just print the sysroot path\n@@ -398,8 +399,10 @@ fn setup(subcommand: &MiriCommand) {\n         }\n         None => {\n             // Check for `rust-src` rustup component.\n-            let output =\n-                miri().args(&[\"--print\", \"sysroot\"]).output().expect(\"failed to determine sysroot\");\n+            let output = miri_for_host()\n+                .args(&[\"--print\", \"sysroot\"])\n+                .output()\n+                .expect(\"failed to determine sysroot\");\n             if !output.status.success() {\n                 show_error(format!(\n                     \"Failed to determine sysroot; Miri said:\\n{}\",\n@@ -472,18 +475,21 @@ path = \"lib.rs\"\n     );\n     write_to_file(&dir.join(\"lib.rs\"), \"#![no_std]\");\n \n-    // Determine architectures.\n-    // We always need to set a target so rustc bootstrap can tell apart host from target crates.\n-    let host = version_info().host;\n-    let target = get_arg_flag_value(\"--target\");\n-    let target = target.as_ref().unwrap_or(&host);\n+    // Figure out where xargo will build its stuff.\n+    // Unfortunately, it puts things into a different directory when the\n+    // architecture matches the host.\n+    let sysroot = if target == host { dir.join(\"HOST\") } else { PathBuf::from(dir) };\n+    // Make sure all target-level Miri invocations know their sysroot.\n+    std::env::set_var(\"MIRI_SYSROOT\", &sysroot);\n+\n     // Now invoke xargo.\n     let mut command = xargo_check();\n     command.arg(\"check\").arg(\"-q\");\n-    command.arg(\"--target\").arg(target);\n     command.current_dir(&dir);\n     command.env(\"XARGO_HOME\", &dir);\n     command.env(\"XARGO_RUST_SRC\", &rust_src);\n+    // We always need to set a target so rustc bootstrap can tell apart host from target crates.\n+    command.arg(\"--target\").arg(target);\n     // Use Miri as rustc to build a libstd compatible with us (and use the right flags).\n     // However, when we are running in bootstrap, we cannot just overwrite `RUSTC`,\n     // because we still need bootstrap to distinguish between host and target crates.\n@@ -523,6 +529,7 @@ path = \"lib.rs\"\n         command.stdout(process::Stdio::null());\n         command.stderr(process::Stdio::null());\n     }\n+\n     // Finally run it!\n     if command.status().expect(\"failed to run xargo\").success().not() {\n         if only_setup {\n@@ -534,11 +541,6 @@ path = \"lib.rs\"\n         }\n     }\n \n-    // That should be it! But we need to figure out where xargo built stuff.\n-    // Unfortunately, it puts things into a different directory when the\n-    // architecture matches the host.\n-    let sysroot = if target == &host { dir.join(\"HOST\") } else { PathBuf::from(dir) };\n-    std::env::set_var(\"MIRI_SYSROOT\", &sysroot); // pass the env var to the processes we spawn, which will turn it into \"--sysroot\" flags\n     // Figure out what to print.\n     if only_setup {\n         eprintln!(\"A sysroot for Miri is now available in `{}`.\", sysroot.display());\n@@ -677,8 +679,13 @@ fn phase_cargo_miri(mut args: impl Iterator<Item = String>) {\n     };\n     let verbose = num_arg_flag(\"-v\");\n \n+    // Determine the involved architectures.\n+    let host = version_info().host;\n+    let target = get_arg_flag_value(\"--target\");\n+    let target = target.as_ref().unwrap_or(&host);\n+\n     // We always setup.\n-    setup(&subcommand);\n+    setup(&subcommand, &host, target);\n \n     // Invoke actual cargo for the job, but with different flags.\n     // We re-use `cargo test` and `cargo run`, which makes target and binary handling very easy but\n@@ -727,7 +734,7 @@ fn phase_cargo_miri(mut args: impl Iterator<Item = String>) {\n     if get_arg_flag_value(\"--target\").is_none() {\n         // No target given. Explicitly pick the host.\n         cmd.arg(\"--target\");\n-        cmd.arg(version_info().host);\n+        cmd.arg(&host);\n     }\n \n     // Set ourselves as runner for al binaries invoked by cargo.\n@@ -754,16 +761,21 @@ fn phase_cargo_miri(mut args: impl Iterator<Item = String>) {\n             \"WARNING: Ignoring `RUSTC` environment variable; set `MIRI` if you want to control the binary used as the driver.\"\n         );\n     }\n-    // We'd prefer to just clear this env var, but cargo does not always honor `RUSTC_WRAPPER`\n-    // (https://github.com/rust-lang/cargo/issues/10885). There is no good way to single out these invocations;\n-    // some build scripts use the RUSTC env var as well. So we set it directly to the `miri` driver and\n-    // hope that all they do is ask for the version number -- things could quickly go downhill from here.\n+    // Build scripts (and also cargo: https://github.com/rust-lang/cargo/issues/10885) will invoke\n+    // `rustc` even when `RUSTC_WRAPPER` is set. To make sure everything is coherent, we want that\n+    // to be the Miri driver, but acting as rustc, on the target level. (Target, rather than host,\n+    // is needed for cross-interpretation situations.) This is not a perfect emulation of real rustc\n+    // (it might be unable to produce binaries since the sysroot is check-only), but it's as close\n+    // as we can get, and it's good enough for autocfg.\n+    //\n     // In `main`, we need the value of `RUSTC` to distinguish RUSTC_WRAPPER invocations from rustdoc\n     // or TARGET_RUNNER invocations, so we canonicalize it here to make it exceedingly unlikely that\n-    // there would be a collision with other invocations of cargo-miri (as rustdoc or as runner).\n-    // We explicitly do this even if RUSTC_STAGE is set, since for these builds we do *not* want the\n-    // bootstrap `rustc` thing in our way! Instead, we have MIRI_HOST_SYSROOT to use for host builds.\n+    // there would be a collision with other invocations of cargo-miri (as rustdoc or as runner). We\n+    // explicitly do this even if RUSTC_STAGE is set, since for these builds we do *not* want the\n+    // bootstrap `rustc` thing in our way! Instead, we have MIRI_HOST_SYSROOT to use for host\n+    // builds.\n     cmd.env(\"RUSTC\", &fs::canonicalize(find_miri()).unwrap());\n+    cmd.env(\"MIRI_BE_RUSTC\", \"target\"); // we better remember to *unset* this in the other phases!\n \n     // Set rustdoc to us as well, so we can run doctests.\n     cmd.env(\"RUSTDOC\", &cargo_miri_path);\n@@ -832,10 +844,16 @@ fn phase_rustc(mut args: impl Iterator<Item = String>, phase: RustcPhase) {\n         }\n     }\n \n+    // phase_cargo_miri set `MIRI_BE_RUSTC` for when build scripts directly invoke the driver;\n+    // however, if we get called back by cargo here, we'll carefully compute the right flags\n+    // ourselves, so we first un-do what the earlier phase did.\n+    env::remove_var(\"MIRI_BE_RUSTC\");\n+\n     let verbose = std::env::var(\"MIRI_VERBOSE\")\n         .map_or(0, |verbose| verbose.parse().expect(\"verbosity flag must be an integer\"));\n     let target_crate = is_target_crate();\n-    let print = get_arg_flag_value(\"--print\").is_some() || has_arg_flag(\"-vV\"); // whether this is cargo/xargo invoking rustc to get some infos\n+    // Determine whether this is cargo/xargo invoking rustc to get some infos.\n+    let info_query = get_arg_flag_value(\"--print\").is_some() || has_arg_flag(\"-vV\");\n \n     let store_json = |info: CrateRunInfo| {\n         // Create a stub .d file to stop Cargo from \"rebuilding\" the crate:\n@@ -857,7 +875,7 @@ fn phase_rustc(mut args: impl Iterator<Item = String>, phase: RustcPhase) {\n         info.store(&out_filename(\"\", \".exe\"));\n     };\n \n-    let runnable_crate = !print && is_runnable_crate();\n+    let runnable_crate = !info_query && is_runnable_crate();\n \n     if runnable_crate && target_crate {\n         assert!(\n@@ -919,7 +937,7 @@ fn phase_rustc(mut args: impl Iterator<Item = String>, phase: RustcPhase) {\n     let mut emit_link_hack = false;\n     // Arguments are treated very differently depending on whether this crate is\n     // for interpretation by Miri, or for use by a build script / proc macro.\n-    if !print && target_crate {\n+    if !info_query && target_crate {\n         // Forward arguments, but remove \"link\" from \"--emit\" to make this a check-only build.\n         let emit_flag = \"--emit\";\n         while let Some(arg) = args.next() {\n@@ -946,20 +964,16 @@ fn phase_rustc(mut args: impl Iterator<Item = String>, phase: RustcPhase) {\n             }\n         }\n \n-        // Use our custom sysroot (but not if that is what we are currently building).\n-        if phase != RustcPhase::Setup {\n-            forward_miri_sysroot(&mut cmd);\n-        }\n-\n         // During setup, patch the panic runtime for `libpanic_abort` (mirroring what bootstrap usually does).\n         if phase == RustcPhase::Setup\n             && get_arg_flag_value(\"--crate-name\").as_deref() == Some(\"panic_abort\")\n         {\n             cmd.arg(\"-C\").arg(\"panic=abort\");\n         }\n     } else {\n-        // For host crates (but not when we are printing), we might still have to set the sysroot.\n-        if !print {\n+        // For host crates (but not when we are just printing some info),\n+        // we might still have to set the sysroot.\n+        if !info_query {\n             // When we're running `cargo-miri` from `x.py` we need to pass the sysroot explicitly\n             // due to bootstrap complications.\n             if let Some(sysroot) = std::env::var_os(\"MIRI_HOST_SYSROOT\") {\n@@ -980,7 +994,7 @@ fn phase_rustc(mut args: impl Iterator<Item = String>, phase: RustcPhase) {\n     // Run it.\n     if verbose > 0 {\n         eprintln!(\n-            \"[cargo-miri rustc] target_crate={target_crate} runnable_crate={runnable_crate} print={print}\"\n+            \"[cargo-miri rustc] target_crate={target_crate} runnable_crate={runnable_crate} info_query={info_query}\"\n         );\n     }\n     debug_cmd(\"[cargo-miri rustc]\", verbose, &cmd);\n@@ -1010,12 +1024,19 @@ enum RunnerPhase {\n }\n \n fn phase_runner(mut binary_args: impl Iterator<Item = String>, phase: RunnerPhase) {\n+    // phase_cargo_miri set `MIRI_BE_RUSTC` for when build scripts directly invoke the driver;\n+    // however, if we get called back by cargo here, we'll carefully compute the right flags\n+    // ourselves, so we first un-do what the earlier phase did.\n+    env::remove_var(\"MIRI_BE_RUSTC\");\n+\n     let verbose = std::env::var(\"MIRI_VERBOSE\")\n         .map_or(0, |verbose| verbose.parse().expect(\"verbosity flag must be an integer\"));\n \n     let binary = binary_args.next().unwrap();\n     let file = File::open(&binary)\n-        .unwrap_or_else(|_| show_error(format!(\"file {:?} not found or `cargo-miri` invoked incorrectly; please only invoke this binary through `cargo miri`\", binary)));\n+        .unwrap_or_else(|_| show_error(format!(\n+            \"file {:?} not found or `cargo-miri` invoked incorrectly; please only invoke this binary through `cargo miri`\", binary\n+        )));\n     let file = BufReader::new(file);\n \n     let info = serde_json::from_reader(file).unwrap_or_else(|_| {\n@@ -1077,10 +1098,6 @@ fn phase_runner(mut binary_args: impl Iterator<Item = String>, phase: RunnerPhas\n             cmd.arg(arg);\n         }\n     }\n-    // Set sysroot (if we are inside rustdoc, we already did that in `phase_cargo_rustdoc`).\n-    if phase != RunnerPhase::Rustdoc {\n-        forward_miri_sysroot(&mut cmd);\n-    }\n     // Respect `MIRIFLAGS`.\n     if let Ok(a) = env::var(\"MIRIFLAGS\") {\n         // This code is taken from `RUSTFLAGS` handling in cargo.\n@@ -1151,7 +1168,7 @@ fn phase_rustdoc(mut args: impl Iterator<Item = String>) {\n     cmd.arg(\"-Z\").arg(\"unstable-options\");\n \n     // rustdoc needs to know the right sysroot.\n-    forward_miri_sysroot(&mut cmd);\n+    cmd.arg(\"--sysroot\").arg(env::var_os(\"MIRI_SYSROOT\").unwrap());\n     // make sure the 'miri' flag is set for rustdoc\n     cmd.arg(\"--cfg\").arg(\"miri\");\n "}, {"sha": "956b8cca75b88e38a58fbc57d722c3f083d9514d", "filename": "miri", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d237be15c83339c0b40691ebadfe049fd8ac796/miri", "raw_url": "https://github.com/rust-lang/rust/raw/3d237be15c83339c0b40691ebadfe049fd8ac796/miri", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri?ref=3d237be15c83339c0b40691ebadfe049fd8ac796", "patch": "@@ -131,7 +131,11 @@ export RUSTFLAGS=\"-C link-args=-Wl,-rpath,$LIBDIR $RUSTFLAGS\"\n \n # Build a sysroot and set MIRI_SYSROOT to use it. Arguments are passed to `cargo miri setup`.\n build_sysroot() {\n-    export MIRI_SYSROOT=\"$($CARGO run $CARGO_EXTRA_FLAGS --manifest-path \"$MIRIDIR\"/cargo-miri/Cargo.toml -q -- miri setup --print-sysroot \"$@\")\"\n+    if ! MIRI_SYSROOT=\"$($CARGO run $CARGO_EXTRA_FLAGS --manifest-path \"$MIRIDIR\"/cargo-miri/Cargo.toml -q -- miri setup --print-sysroot \"$@\")\"; then\n+        echo \"'cargo miri setup' failed\"\n+        exit 1\n+    fi\n+    export MIRI_SYSROOT\n }\n \n # Prepare and set MIRI_SYSROOT. Respects `MIRI_TEST_TARGET` and takes into account\n@@ -201,7 +205,7 @@ run)\n     $CARGO build $CARGO_EXTRA_FLAGS --manifest-path \"$MIRIDIR\"/Cargo.toml\n     find_sysroot\n     # Then run the actual command.\n-    exec $CARGO run $CARGO_EXTRA_FLAGS --manifest-path \"$MIRIDIR\"/Cargo.toml -- --sysroot \"$MIRI_SYSROOT\" $MIRIFLAGS \"$@\"\n+    exec $CARGO run $CARGO_EXTRA_FLAGS --manifest-path \"$MIRIDIR\"/Cargo.toml -- $MIRIFLAGS \"$@\"\n     ;;\n fmt)\n     find \"$MIRIDIR\" -not \\( -name target -prune \\) -name '*.rs' \\"}, {"sha": "489eb959906c97066fcc201b339f90f4b8c8024f", "filename": "src/bin/miri.rs", "status": "modified", "additions": 35, "deletions": 23, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3d237be15c83339c0b40691ebadfe049fd8ac796/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d237be15c83339c0b40691ebadfe049fd8ac796/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=3d237be15c83339c0b40691ebadfe049fd8ac796", "patch": "@@ -27,7 +27,7 @@ use rustc_middle::{\n     },\n     ty::{query::ExternProviders, TyCtxt},\n };\n-use rustc_session::{search_paths::PathKind, CtfeBacktrace};\n+use rustc_session::{config::CrateType, search_paths::PathKind, CtfeBacktrace};\n \n use miri::{BacktraceStyle, ProvenanceMode};\n \n@@ -60,6 +60,10 @@ impl rustc_driver::Callbacks for MiriCompilerCalls {\n \n         queries.global_ctxt().unwrap().peek_mut().enter(|tcx| {\n             init_late_loggers(tcx);\n+            if !tcx.sess.crate_types().contains(&CrateType::Executable) {\n+                tcx.sess.fatal(\"miri only makes sense on bin crates\");\n+            }\n+\n             let (entry_def_id, entry_type) = if let Some(entry_def) = tcx.entry_fn(()) {\n                 entry_def\n             } else {\n@@ -204,9 +208,9 @@ fn init_late_loggers(tcx: TyCtxt<'_>) {\n     }\n }\n \n-/// Returns the \"default sysroot\" that Miri will use if no `--sysroot` flag is set.\n+/// Returns the \"default sysroot\" that Miri will use for host things if no `--sysroot` flag is set.\n /// Should be a compile-time constant.\n-fn compile_time_sysroot() -> Option<String> {\n+fn host_sysroot() -> Option<String> {\n     if option_env!(\"RUSTC_STAGE\").is_some() {\n         // This is being built as part of rustc, and gets shipped with rustup.\n         // We can rely on the sysroot computation in librustc_session.\n@@ -227,7 +231,7 @@ fn compile_time_sysroot() -> Option<String> {\n                 if toolchain_runtime != toolchain {\n                     show_error(format!(\n                         \"This Miri got built with local toolchain `{toolchain}`, but now is being run under a different toolchain. \\n\\\n-                    Make sure to run Miri in the toolchain it got built with, e.g. via `cargo +{toolchain} miri`.\"\n+                        Make sure to run Miri in the toolchain it got built with, e.g. via `cargo +{toolchain} miri`.\"\n                     ));\n                 }\n             }\n@@ -246,25 +250,42 @@ fn compile_time_sysroot() -> Option<String> {\n /// Execute a compiler with the given CLI arguments and callbacks.\n fn run_compiler(\n     mut args: Vec<String>,\n+    target_crate: bool,\n     callbacks: &mut (dyn rustc_driver::Callbacks + Send),\n-    insert_default_args: bool,\n ) -> ! {\n     // Make sure we use the right default sysroot. The default sysroot is wrong,\n     // because `get_or_default_sysroot` in `librustc_session` bases that on `current_exe`.\n     //\n-    // Make sure we always call `compile_time_sysroot` as that also does some sanity-checks\n-    // of the environment we were built in.\n-    // FIXME: Ideally we'd turn a bad build env into a compile-time error via CTFE or so.\n-    if let Some(sysroot) = compile_time_sysroot() {\n-        let sysroot_flag = \"--sysroot\";\n-        if !args.iter().any(|e| e == sysroot_flag) {\n+    // Make sure we always call `host_sysroot` as that also does some sanity-checks\n+    // of the environment we were built in and whether it matches what we are running in.\n+    let host_default_sysroot = host_sysroot();\n+    // Now see if we even need to set something.\n+    let sysroot_flag = \"--sysroot\";\n+    if !args.iter().any(|e| e == sysroot_flag) {\n+        // No sysroot was set, let's see if we have a custom default we want to configure.\n+        let default_sysroot = if target_crate {\n+            // Using the built-in default here would be plain wrong, so we *require*\n+            // the env var to make sure things make sense.\n+            Some(env::var(\"MIRI_SYSROOT\").unwrap_or_else(|_| {\n+                show_error(format!(\n+                    \"Miri was invoked in 'target' mode without `MIRI_SYSROOT` or `--sysroot` being set\"\n+                ))\n+            }))\n+        } else {\n+            host_default_sysroot\n+        };\n+        if let Some(sysroot) = default_sysroot {\n             // We need to overwrite the default that librustc_session would compute.\n             args.push(sysroot_flag.to_owned());\n             args.push(sysroot);\n         }\n     }\n \n-    if insert_default_args {\n+    // Don't insert `MIRI_DEFAULT_ARGS`, in particular, `--cfg=miri`, if we are building\n+    // a \"host\" crate. That may cause procedural macros (and probably build scripts) to\n+    // depend on Miri-only symbols, such as `miri_resolve_frame`:\n+    // https://github.com/rust-lang/miri/issues/1760\n+    if target_crate {\n         // Some options have different defaults in Miri than in plain rustc; apply those by making\n         // them the first arguments after the binary name (but later arguments can overwrite them).\n         args.splice(1..1, miri::MIRI_DEFAULT_ARGS.iter().map(ToString::to_string));\n@@ -302,13 +323,8 @@ fn main() {\n         // We cannot use `rustc_driver::main` as we need to adjust the CLI arguments.\n         run_compiler(\n             env::args().collect(),\n+            target_crate,\n             &mut MiriBeRustCompilerCalls { target_crate },\n-            // Don't insert `MIRI_DEFAULT_ARGS`, in particular, `--cfg=miri`, if we are building\n-            // a \"host\" crate. That may cause procedural macros (and probably build scripts) to\n-            // depend on Miri-only symbols, such as `miri_resolve_frame`:\n-            // https://github.com/rust-lang/miri/issues/1760\n-            #[rustfmt::skip]\n-            /* insert_default_args: */ target_crate,\n         )\n     }\n \n@@ -502,9 +518,5 @@ fn main() {\n \n     debug!(\"rustc arguments: {:?}\", rustc_args);\n     debug!(\"crate arguments: {:?}\", miri_config.args);\n-    run_compiler(\n-        rustc_args,\n-        &mut MiriCompilerCalls { miri_config },\n-        /* insert_default_args: */ true,\n-    )\n+    run_compiler(rustc_args, /* target_crate: */ true, &mut MiriCompilerCalls { miri_config })\n }"}, {"sha": "a297dd27dbc9455d5f5079e2852cb4cca5543c8a", "filename": "test-cargo-miri/Cargo.lock", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d237be15c83339c0b40691ebadfe049fd8ac796/test-cargo-miri%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3d237be15c83339c0b40691ebadfe049fd8ac796/test-cargo-miri%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2FCargo.lock?ref=3d237be15c83339c0b40691ebadfe049fd8ac796", "patch": "@@ -2,6 +2,12 @@\n # It is not intended for manual editing.\n version = 3\n \n+[[package]]\n+name = \"autocfg\"\n+version = \"1.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa\"\n+\n [[package]]\n name = \"byteorder\"\n version = \"0.5.3\"\n@@ -18,6 +24,7 @@ checksum = \"14c189c53d098945499cdfa7ecc63567cf3886b3332b312a5b4585d8d3a6a610\"\n name = \"cargo-miri-test\"\n version = \"0.1.0\"\n dependencies = [\n+ \"autocfg\",\n  \"byteorder 0.5.3\",\n  \"byteorder 1.4.3\",\n  \"cdylib\","}, {"sha": "5d9e5d143b3b35b18867ca2b22bf461366871279", "filename": "test-cargo-miri/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d237be15c83339c0b40691ebadfe049fd8ac796/test-cargo-miri%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3d237be15c83339c0b40691ebadfe049fd8ac796/test-cargo-miri%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2FCargo.toml?ref=3d237be15c83339c0b40691ebadfe049fd8ac796", "patch": "@@ -21,6 +21,9 @@ issue_rust_86261 = { path = \"issue-rust-86261\" }\n byteorder_2 = { package = \"byteorder\", version = \"0.5\" } # to test dev-dependencies behave as expected, with renaming\n serde_derive = \"1.0\" # not actually used, but exercises some unique code path (`--extern` .so file)\n \n+[build-dependencies]\n+autocfg = \"1\"\n+\n [lib]\n test = false # test that this is respected (will show in the output)\n "}, {"sha": "6c1f4d80d3392c26c13b3f4bd48bf6b5f18b9de0", "filename": "test-cargo-miri/build.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3d237be15c83339c0b40691ebadfe049fd8ac796/test-cargo-miri%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d237be15c83339c0b40691ebadfe049fd8ac796/test-cargo-miri%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Fbuild.rs?ref=3d237be15c83339c0b40691ebadfe049fd8ac796", "patch": "@@ -20,4 +20,21 @@ fn main() {\n     println!(\"cargo:rerun-if-changed=build.rs\");\n     println!(\"cargo:rerun-if-env-changed=MIRITESTVAR\");\n     println!(\"cargo:rustc-env=MIRITESTVAR=testval\");\n+\n+    // Test that autocfg works. This invokes RUSTC.\n+    let a = autocfg::new();\n+    assert!(a.probe_sysroot_crate(\"std\"));\n+    assert!(!a.probe_sysroot_crate(\"doesnotexist\"));\n+    assert!(a.probe_rustc_version(1, 0));\n+    assert!(!a.probe_rustc_version(2, 0));\n+    assert!(a.probe_type(\"i128\"));\n+    assert!(!a.probe_type(\"doesnotexist\"));\n+    assert!(a.probe_trait(\"Send\"));\n+    assert!(!a.probe_trait(\"doesnotexist\"));\n+    assert!(a.probe_path(\"std::num\"));\n+    assert!(!a.probe_path(\"doesnotexist\"));\n+    assert!(a.probe_constant(\"i32::MAX\"));\n+    assert!(!a.probe_constant(\"doesnotexist\"));\n+    assert!(a.probe_expression(\"Box::new(0)\"));\n+    assert!(!a.probe_expression(\"doesnotexist\"));\n }"}, {"sha": "48e0ae855be39601abc8d201c4ea50015c21ebb5", "filename": "tests/compiletest.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d237be15c83339c0b40691ebadfe049fd8ac796/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d237be15c83339c0b40691ebadfe049fd8ac796/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=3d237be15c83339c0b40691ebadfe049fd8ac796", "patch": "@@ -24,10 +24,6 @@ fn run_tests(mode: Mode, path: &str, target: Option<String>) -> Result<()> {\n         flags.push(\"-Dwarnings\".into());\n         flags.push(\"-Dunused\".into());\n     }\n-    if let Some(sysroot) = env::var_os(\"MIRI_SYSROOT\") {\n-        flags.push(\"--sysroot\".into());\n-        flags.push(sysroot);\n-    }\n     if let Ok(extra_flags) = env::var(\"MIRIFLAGS\") {\n         for flag in extra_flags.split_whitespace() {\n             flags.push(flag.into());"}]}