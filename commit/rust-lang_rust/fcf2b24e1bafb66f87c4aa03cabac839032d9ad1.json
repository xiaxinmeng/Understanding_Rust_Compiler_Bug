{"sha": "fcf2b24e1bafb66f87c4aa03cabac839032d9ad1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjZjJiMjRlMWJhZmI2NmY4N2M0YWEwM2NhYmFjODM5MDMyZDlhZDE=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-05-18T01:23:31Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-05-18T12:20:27Z"}, "message": "Introduce `MatcherPosHandle`.\n\nThis lets us store most `MatcherPos` instances on the stack. This speeds\nup various runs of html5ever, the best by 3%.", "tree": {"sha": "34b54d8066857cd16b3f5d3431fc394efc01c2a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34b54d8066857cd16b3f5d3431fc394efc01c2a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fcf2b24e1bafb66f87c4aa03cabac839032d9ad1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fcf2b24e1bafb66f87c4aa03cabac839032d9ad1", "html_url": "https://github.com/rust-lang/rust/commit/fcf2b24e1bafb66f87c4aa03cabac839032d9ad1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fcf2b24e1bafb66f87c4aa03cabac839032d9ad1/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6872377357dbbf373cfd2aae352cb74cfcc66f34", "url": "https://api.github.com/repos/rust-lang/rust/commits/6872377357dbbf373cfd2aae352cb74cfcc66f34", "html_url": "https://github.com/rust-lang/rust/commit/6872377357dbbf373cfd2aae352cb74cfcc66f34"}], "stats": {"total": 70, "additions": 59, "deletions": 11}, "files": [{"sha": "6b7b875de3962e777c8aaa4a7eeed941fb29c356", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 59, "deletions": 11, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/fcf2b24e1bafb66f87c4aa03cabac839032d9ad1/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcf2b24e1bafb66f87c4aa03cabac839032d9ad1/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=fcf2b24e1bafb66f87c4aa03cabac839032d9ad1", "patch": "@@ -97,6 +97,7 @@ use tokenstream::TokenStream;\n use util::small_vector::SmallVector;\n \n use std::mem;\n+use std::ops::{Deref, DerefMut};\n use std::rc::Rc;\n use std::collections::HashMap;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n@@ -186,7 +187,7 @@ struct MatcherPos<'a> {\n     sep: Option<Token>,\n     /// The \"parent\" matcher position if we are in a repetition. That is, the matcher position just\n     /// before we enter the sequence.\n-    up: Option<Box<MatcherPos<'a>>>,\n+    up: Option<MatcherPosHandle<'a>>,\n \n     // Specifically used to \"unzip\" token trees. By \"unzip\", we mean to unwrap the delimiters from\n     // a delimited token tree (e.g. something wrapped in `(` `)`) or to get the contents of a doc\n@@ -206,6 +207,49 @@ impl<'a> MatcherPos<'a> {\n     }\n }\n \n+// Lots of MatcherPos instances are created at runtime. Allocating them on the\n+// heap is slow. Furthermore, using SmallVec<MatcherPos> to allocate them all\n+// on the stack is also slow, because MatcherPos is quite a large type and\n+// instances get moved around a lot between vectors, which requires lots of\n+// slow memcpy calls.\n+//\n+// Therefore, the initial MatcherPos is always allocated on the stack,\n+// subsequent ones (of which there aren't that many) are allocated on the heap,\n+// and this type is used to encapsulate both cases.\n+enum MatcherPosHandle<'a> {\n+    Ref(&'a mut MatcherPos<'a>),\n+    Box(Box<MatcherPos<'a>>),\n+}\n+\n+impl<'a> Clone for MatcherPosHandle<'a> {\n+    // This always produces a new Box.\n+    fn clone(&self) -> Self {\n+        MatcherPosHandle::Box(match *self {\n+            MatcherPosHandle::Ref(ref r) => Box::new((**r).clone()),\n+            MatcherPosHandle::Box(ref b) => b.clone(),\n+        })\n+    }\n+}\n+\n+impl<'a> Deref for MatcherPosHandle<'a> {\n+    type Target = MatcherPos<'a>;\n+    fn deref(&self) -> &Self::Target {\n+        match *self {\n+            MatcherPosHandle::Ref(ref r) => r,\n+            MatcherPosHandle::Box(ref b) => b,\n+        }\n+    }\n+}\n+\n+impl<'a> DerefMut for MatcherPosHandle<'a> {\n+    fn deref_mut(&mut self) -> &mut MatcherPos<'a> {\n+        match *self {\n+            MatcherPosHandle::Ref(ref mut r) => r,\n+            MatcherPosHandle::Box(ref mut b) => b,\n+        }\n+    }\n+}\n+\n /// Represents the possible results of an attempted parse.\n pub enum ParseResult<T> {\n     /// Parsed successfully.\n@@ -241,10 +285,10 @@ fn create_matches(len: usize) -> Vec<Rc<Vec<NamedMatch>>> {\n \n /// Generate the top-level matcher position in which the \"dot\" is before the first token of the\n /// matcher `ms` and we are going to start matching at position `lo` in the source.\n-fn initial_matcher_pos(ms: &[TokenTree], lo: BytePos) -> Box<MatcherPos> {\n+fn initial_matcher_pos(ms: &[TokenTree], lo: BytePos) -> MatcherPos {\n     let match_idx_hi = count_names(ms);\n     let matches = create_matches(match_idx_hi);\n-    Box::new(MatcherPos {\n+    MatcherPos {\n         // Start with the top level matcher given to us\n         top_elts: TtSeq(ms), // \"elts\" is an abbr. for \"elements\"\n         // The \"dot\" is before the first token of the matcher\n@@ -267,7 +311,7 @@ fn initial_matcher_pos(ms: &[TokenTree], lo: BytePos) -> Box<MatcherPos> {\n         seq_op: None,\n         sep: None,\n         up: None,\n-    })\n+    }\n }\n \n /// `NamedMatch` is a pattern-match result for a single `token::MATCH_NONTERMINAL`:\n@@ -396,10 +440,10 @@ fn token_name_eq(t1: &Token, t2: &Token) -> bool {\n /// A `ParseResult`. Note that matches are kept track of through the items generated.\n fn inner_parse_loop<'a>(\n     sess: &ParseSess,\n-    cur_items: &mut SmallVector<Box<MatcherPos<'a>>>,\n-    next_items: &mut Vec<Box<MatcherPos<'a>>>,\n-    eof_items: &mut SmallVector<Box<MatcherPos<'a>>>,\n-    bb_items: &mut SmallVector<Box<MatcherPos<'a>>>,\n+    cur_items: &mut SmallVector<MatcherPosHandle<'a>>,\n+    next_items: &mut Vec<MatcherPosHandle<'a>>,\n+    eof_items: &mut SmallVector<MatcherPosHandle<'a>>,\n+    bb_items: &mut SmallVector<MatcherPosHandle<'a>>,\n     token: &Token,\n     span: syntax_pos::Span,\n ) -> ParseResult<()> {\n@@ -502,7 +546,7 @@ fn inner_parse_loop<'a>(\n                     }\n \n                     let matches = create_matches(item.matches.len());\n-                    cur_items.push(Box::new(MatcherPos {\n+                    cur_items.push(MatcherPosHandle::Box(Box::new(MatcherPos {\n                         stack: vec![],\n                         sep: seq.separator.clone(),\n                         seq_op: Some(seq.op),\n@@ -514,7 +558,7 @@ fn inner_parse_loop<'a>(\n                         up: Some(item),\n                         sp_lo: sp.lo(),\n                         top_elts: Tt(TokenTree::Sequence(sp, seq)),\n-                    }));\n+                    })));\n                 }\n \n                 // We need to match a metavar (but the identifier is invalid)... this is an error\n@@ -596,7 +640,11 @@ pub fn parse(\n     // processes all of these possible matcher positions and produces posible next positions into\n     // `next_items`. After some post-processing, the contents of `next_items` replenish `cur_items`\n     // and we start over again.\n-    let mut cur_items = SmallVector::one(initial_matcher_pos(ms, parser.span.lo()));\n+    //\n+    // This MatcherPos instance is allocated on the stack. All others -- and\n+    // there are frequently *no* others! -- are allocated on the heap.\n+    let mut initial = initial_matcher_pos(ms, parser.span.lo());\n+    let mut cur_items = SmallVector::one(MatcherPosHandle::Ref(&mut initial));\n     let mut next_items = Vec::new();\n \n     loop {"}]}