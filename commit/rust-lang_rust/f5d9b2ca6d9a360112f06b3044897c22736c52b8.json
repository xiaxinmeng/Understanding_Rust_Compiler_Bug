{"sha": "f5d9b2ca6d9a360112f06b3044897c22736c52b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1ZDliMmNhNmQ5YTM2MDExMmYwNmIzMDQ0ODk3YzIyNzM2YzUyYjg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-13T08:02:54Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-25T03:59:53Z"}, "message": "native: Add tests and cleanup entry points\n\nThis adds a few smoke tests associated with libnative tasks (not much code to\ntest here anyway), and cleans up the entry points a little bit to be a little\nmore like libgreen.\n\nThe I/O code doesn't need much testing because that's all tested in libstd (with\nthe iotest! macro).", "tree": {"sha": "eeb0d0206872b42c34d68e0f66da379a11c44563", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eeb0d0206872b42c34d68e0f66da379a11c44563"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5d9b2ca6d9a360112f06b3044897c22736c52b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5d9b2ca6d9a360112f06b3044897c22736c52b8", "html_url": "https://github.com/rust-lang/rust/commit/f5d9b2ca6d9a360112f06b3044897c22736c52b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5d9b2ca6d9a360112f06b3044897c22736c52b8/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "018d60509c04cdebdf8b0d9e2b58f2604538e516", "url": "https://api.github.com/repos/rust-lang/rust/commits/018d60509c04cdebdf8b0d9e2b58f2604538e516", "html_url": "https://github.com/rust-lang/rust/commit/018d60509c04cdebdf8b0d9e2b58f2604538e516"}], "stats": {"total": 156, "additions": 139, "deletions": 17}, "files": [{"sha": "c1a378c7e3cc1748b308bf16445fcd09d195e265", "filename": "src/libnative/io/file.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5d9b2ca6d9a360112f06b3044897c22736c52b8/src%2Flibnative%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d9b2ca6d9a360112f06b3044897c22736c52b8/src%2Flibnative%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile.rs?ref=f5d9b2ca6d9a360112f06b3044897c22736c52b8", "patch": "@@ -899,8 +899,7 @@ pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n \n #[cfg(test)]\n mod tests {\n-    use std::io::native::file::{CFile, FileDesc};\n-    use std::io::fs;\n+    use super::{CFile, FileDesc};\n     use std::io;\n     use std::libc;\n     use std::os;"}, {"sha": "40d8f6f0b46d4354f7aec40e5eceb2648f578cef", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 41, "deletions": 15, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f5d9b2ca6d9a360112f06b3044897c22736c52b8/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d9b2ca6d9a360112f06b3044897c22736c52b8/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=f5d9b2ca6d9a360112f06b3044897c22736c52b8", "patch": "@@ -24,38 +24,64 @@\n #[crate_type = \"rlib\"];\n #[crate_type = \"dylib\"];\n \n+#[cfg(stage0, test)] extern mod green;\n+\n // NB this crate explicitly does *not* allow glob imports, please seriously\n-//    consider whether they're needed before adding that feature here.\n+//    consider whether they're needed before adding that feature here (the\n+//    answer is that you don't need them)\n \n-use std::cast;\n use std::os;\n use std::rt;\n-use std::task::try;\n \n pub mod io;\n pub mod task;\n \n+\n // XXX: this should not exist here\n-#[cfg(stage0)]\n+#[cfg(stage0, notready)]\n #[lang = \"start\"]\n-pub fn start(main: *u8, argc: int, argv: **u8) -> int {\n-    rt::init(argc, argv);\n+pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int {\n+    use std::cast;\n+    use std::task::try;\n \n-    // Bootstrap ourselves by installing a local Task and then immediately\n-    // spawning a thread to run 'main'. Always spawn a new thread for main so\n-    // the stack size of 'main' is known (and the bounds can be set\n-    // appropriately).\n-    //\n-    // Once the main task has completed, then we wait for everyone else to exit.\n-    task::run(task::new(), proc() {\n+    do start(argc, argv) {\n+        // Instead of invoking main directly on this thread, invoke it on\n+        // another spawned thread that we are guaranteed to know the size of the\n+        // stack of. Currently, we do not have a method of figuring out the size\n+        // of the main thread's stack, so for stack overflow detection to work\n+        // we must spawn the task in a subtask which we know the stack size of.\n         let main: extern \"Rust\" fn() = unsafe { cast::transmute(main) };\n         match do try { main() } {\n             Ok(()) => { os::set_exit_status(0); }\n             Err(..) => { os::set_exit_status(rt::DEFAULT_ERROR_CODE); }\n         }\n-    });\n-    task::wait_for_completion();\n+    }\n+}\n \n+/// Executes the given procedure after initializing the runtime with the given\n+/// argc/argv.\n+///\n+/// This procedure is guaranteed to run on the thread calling this function, but\n+/// the stack bounds for this rust task will *not* be set. Care must be taken\n+/// for this function to not overflow its stack.\n+///\n+/// This function will only return once *all* native threads in the system have\n+/// exited.\n+pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n+    rt::init(argc, argv);\n+    let exit_code = run(main);\n     unsafe { rt::cleanup(); }\n+    return exit_code;\n+}\n+\n+/// Executes a procedure on the current thread in a Rust task context.\n+///\n+/// This function has all of the same details as `start` except for a different\n+/// number of arguments.\n+pub fn run(main: proc()) -> int {\n+    // Create a task, run the procedure in it, and then wait for everything.\n+    task::run(task::new(), main);\n+    task::wait_for_completion();\n+\n     os::get_exit_status()\n }"}, {"sha": "f0502a43990f82191e6eeb3713c91a3de7396956", "filename": "src/libnative/task.rs", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/f5d9b2ca6d9a360112f06b3044897c22736c52b8/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d9b2ca6d9a360112f06b3044897c22736c52b8/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=f5d9b2ca6d9a360112f06b3044897c22736c52b8", "patch": "@@ -260,3 +260,100 @@ impl Drop for Ops {\n         unsafe { self.lock.destroy() }\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::rt::Runtime;\n+    use std::rt::local::Local;\n+    use std::rt::task::Task;\n+    use std::task;\n+    use super::{spawn, spawn_opts, Ops};\n+\n+    #[test]\n+    fn smoke() {\n+        let (p, c) = Chan::new();\n+        do spawn {\n+            c.send(());\n+        }\n+        p.recv();\n+    }\n+\n+    #[test]\n+    fn smoke_fail() {\n+        let (p, c) = Chan::<()>::new();\n+        do spawn {\n+            let _c = c;\n+            fail!()\n+        }\n+        assert_eq!(p.recv_opt(), None);\n+    }\n+\n+    #[test]\n+    fn smoke_opts() {\n+        let mut opts = task::default_task_opts();\n+        opts.name = Some(SendStrStatic(\"test\"));\n+        opts.stack_size = Some(20 * 4096);\n+        let (p, c) = Chan::new();\n+        opts.notify_chan = Some(c);\n+        spawn_opts(opts, proc() {});\n+        assert!(p.recv().is_ok());\n+    }\n+\n+    #[test]\n+    fn smoke_opts_fail() {\n+        let mut opts = task::default_task_opts();\n+        let (p, c) = Chan::new();\n+        opts.notify_chan = Some(c);\n+        spawn_opts(opts, proc() { fail!() });\n+        assert!(p.recv().is_err());\n+    }\n+\n+    #[test]\n+    fn yield_test() {\n+        let (p, c) = Chan::new();\n+        do spawn {\n+            10.times(task::deschedule);\n+            c.send(());\n+        }\n+        p.recv();\n+    }\n+\n+    #[test]\n+    fn spawn_children() {\n+        let (p, c) = Chan::new();\n+        do spawn {\n+            let (p, c2) = Chan::new();\n+            do spawn {\n+                let (p, c3) = Chan::new();\n+                do spawn {\n+                    c3.send(());\n+                }\n+                p.recv();\n+                c2.send(());\n+            }\n+            p.recv();\n+            c.send(());\n+        }\n+        p.recv();\n+    }\n+\n+    #[test]\n+    fn spawn_inherits() {\n+        let (p, c) = Chan::new();\n+        do spawn {\n+            let c = c;\n+            do spawn {\n+                let mut task: ~Task = Local::take();\n+                match task.maybe_take_runtime::<Ops>() {\n+                    Some(ops) => {\n+                        task.put_runtime(ops as ~Runtime);\n+                    }\n+                    None => fail!(),\n+                }\n+                Local::put(task);\n+                c.send(());\n+            }\n+        }\n+        p.recv();\n+    }\n+}"}]}