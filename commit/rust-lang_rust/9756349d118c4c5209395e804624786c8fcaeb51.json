{"sha": "9756349d118c4c5209395e804624786c8fcaeb51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3NTYzNDlkMTE4YzRjNTIwOTM5NWU4MDQ2MjQ3ODZjOGZjYWViNTE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-24T04:48:10Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-29T05:26:22Z"}, "message": "debuginfo: extract metadata.rs", "tree": {"sha": "3109ba9b1864f2fb334b82a6444b34deb8a9df5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3109ba9b1864f2fb334b82a6444b34deb8a9df5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9756349d118c4c5209395e804624786c8fcaeb51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9756349d118c4c5209395e804624786c8fcaeb51", "html_url": "https://github.com/rust-lang/rust/commit/9756349d118c4c5209395e804624786c8fcaeb51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9756349d118c4c5209395e804624786c8fcaeb51/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "024e86fad591b1057d5d36315860ede235721fd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/024e86fad591b1057d5d36315860ede235721fd0", "html_url": "https://github.com/rust-lang/rust/commit/024e86fad591b1057d5d36315860ede235721fd0"}], "stats": {"total": 1172, "additions": 604, "deletions": 568}, "files": [{"sha": "33ec225450b6a6c5fb1c9f67cfdcb7732facfd6a", "filename": "src/librustc_trans/trans/debuginfo/create.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9756349d118c4c5209395e804624786c8fcaeb51/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9756349d118c4c5209395e804624786c8fcaeb51/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate.rs?ref=9756349d118c4c5209395e804624786c8fcaeb51", "patch": "@@ -11,8 +11,9 @@\n // Module-Internal debug info creation functions.\n \n use super::utils::{span_start, DIB};\n+use super::metadata::{type_metadata, file_metadata};\n \n-use super::{set_debug_location, type_metadata, file_metadata, DW_TAG_auto_variable, DW_TAG_arg_variable};\n+use super::{set_debug_location, DW_TAG_auto_variable, DW_TAG_arg_variable};\n use super::VariableKind::{self, ArgumentVariable, CapturedVariable, LocalVariable};\n use super::VariableAccess::{self, DirectVariable, IndirectVariable};\n use super::InternalDebugLocation::{self, UnknownLocation};"}, {"sha": "fb5c5ec67f3e10e44757b78438a4ba207be1e360", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "added", "additions": 597, "deletions": 0, "changes": 597, "blob_url": "https://github.com/rust-lang/rust/blob/9756349d118c4c5209395e804624786c8fcaeb51/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9756349d118c4c5209395e804624786c8fcaeb51/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=9756349d118c4c5209395e804624786c8fcaeb51", "patch": "@@ -0,0 +1,597 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://!rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://!www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://!opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::utils::{debug_context, DIB, span_start, bytes_to_bits, size_and_align_of,\n+                  get_namespace_and_span_for_item};\n+use super::{prepare_struct_metadata, prepare_tuple_metadata, prepare_enum_metadata,\n+            composite_type_metadata, UNKNOWN_FILE_METADATA, UNKNOWN_SCOPE_METADATA,\n+            UniqueTypeId, MemberDescription, FLAGS_NONE};\n+use super::MemberOffset::ComputedMemberOffset;\n+use super::types::compute_debuginfo_type_name;\n+use super::create::create_DIArray;\n+\n+use llvm;\n+use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor};\n+use trans::type_of;\n+use trans::common::{CrateContext, FunctionContext, NormalizingClosureTyper};\n+use trans::type_::Type;\n+use middle::ty::{self, Ty, ClosureTyper};\n+use session::config;\n+use util::ppaux;\n+use util::common::path2cstr;\n+\n+use libc::{c_uint, c_longlong};\n+use std::ffi::CString;\n+use std::path::Path;\n+use std::ptr;\n+use syntax::codemap::Span;\n+use syntax::{ast, codemap};\n+\n+const DW_LANG_RUST: c_uint = 0x9000;\n+#[allow(non_upper_case_globals)]\n+const DW_ATE_boolean: c_uint = 0x02;\n+#[allow(non_upper_case_globals)]\n+const DW_ATE_float: c_uint = 0x04;\n+#[allow(non_upper_case_globals)]\n+const DW_ATE_signed: c_uint = 0x05;\n+#[allow(non_upper_case_globals)]\n+const DW_ATE_unsigned: c_uint = 0x07;\n+#[allow(non_upper_case_globals)]\n+const DW_ATE_unsigned_char: c_uint = 0x08;\n+\n+\n+// Returns from the enclosing function if the type metadata with the given\n+// unique id can be found in the type map\n+macro_rules! return_if_metadata_created_in_meantime {\n+    ($cx: expr, $unique_type_id: expr) => (\n+        match debug_context($cx).type_map\n+                                .borrow()\n+                                .find_metadata_for_unique_id($unique_type_id) {\n+            Some(metadata) => return MetadataCreationResult::new(metadata, true),\n+            None => { /* proceed normally */ }\n+        };\n+    )\n+}\n+\n+fn fixed_vec_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                unique_type_id: UniqueTypeId,\n+                                element_type: Ty<'tcx>,\n+                                len: Option<u64>,\n+                                span: Span)\n+                                -> MetadataCreationResult {\n+    let element_type_metadata = type_metadata(cx, element_type, span);\n+\n+    return_if_metadata_created_in_meantime!(cx, unique_type_id);\n+\n+    let element_llvm_type = type_of::type_of(cx, element_type);\n+    let (element_type_size, element_type_align) = size_and_align_of(cx, element_llvm_type);\n+\n+    let (array_size_in_bytes, upper_bound) = match len {\n+        Some(len) => (element_type_size * len, len as c_longlong),\n+        None => (0, -1)\n+    };\n+\n+    let subrange = unsafe {\n+        llvm::LLVMDIBuilderGetOrCreateSubrange(DIB(cx), 0, upper_bound)\n+    };\n+\n+    let subscripts = create_DIArray(DIB(cx), &[subrange]);\n+    let metadata = unsafe {\n+        llvm::LLVMDIBuilderCreateArrayType(\n+            DIB(cx),\n+            bytes_to_bits(array_size_in_bytes),\n+            bytes_to_bits(element_type_align),\n+            element_type_metadata,\n+            subscripts)\n+    };\n+\n+    return MetadataCreationResult::new(metadata, false);\n+}\n+\n+fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                vec_type: Ty<'tcx>,\n+                                element_type: Ty<'tcx>,\n+                                unique_type_id: UniqueTypeId,\n+                                span: Span)\n+                                -> MetadataCreationResult {\n+    let data_ptr_type = ty::mk_ptr(cx.tcx(), ty::mt {\n+        ty: element_type,\n+        mutbl: ast::MutImmutable\n+    });\n+\n+    let element_type_metadata = type_metadata(cx, data_ptr_type, span);\n+\n+    return_if_metadata_created_in_meantime!(cx, unique_type_id);\n+\n+    let slice_llvm_type = type_of::type_of(cx, vec_type);\n+    let slice_type_name = compute_debuginfo_type_name(cx, vec_type, true);\n+\n+    let member_llvm_types = slice_llvm_type.field_types();\n+    assert!(slice_layout_is_correct(cx,\n+                                    &member_llvm_types[..],\n+                                    element_type));\n+    let member_descriptions = [\n+        MemberDescription {\n+            name: \"data_ptr\".to_string(),\n+            llvm_type: member_llvm_types[0],\n+            type_metadata: element_type_metadata,\n+            offset: ComputedMemberOffset,\n+            flags: FLAGS_NONE\n+        },\n+        MemberDescription {\n+            name: \"length\".to_string(),\n+            llvm_type: member_llvm_types[1],\n+            type_metadata: type_metadata(cx, cx.tcx().types.usize, span),\n+            offset: ComputedMemberOffset,\n+            flags: FLAGS_NONE\n+        },\n+    ];\n+\n+    assert!(member_descriptions.len() == member_llvm_types.len());\n+\n+    let loc = span_start(cx, span);\n+    let file_metadata = file_metadata(cx, &loc.file.name);\n+\n+    let metadata = composite_type_metadata(cx,\n+                                           slice_llvm_type,\n+                                           &slice_type_name[..],\n+                                           unique_type_id,\n+                                           &member_descriptions,\n+                                           UNKNOWN_SCOPE_METADATA,\n+                                           file_metadata,\n+                                           span);\n+    return MetadataCreationResult::new(metadata, false);\n+\n+    fn slice_layout_is_correct<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                         member_llvm_types: &[Type],\n+                                         element_type: Ty<'tcx>)\n+                                         -> bool {\n+        member_llvm_types.len() == 2 &&\n+        member_llvm_types[0] == type_of::type_of(cx, element_type).ptr_to() &&\n+        member_llvm_types[1] == cx.int_type()\n+    }\n+}\n+\n+fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                      unique_type_id: UniqueTypeId,\n+                                      signature: &ty::PolyFnSig<'tcx>,\n+                                      span: Span)\n+                                      -> MetadataCreationResult\n+{\n+    let signature = ty::erase_late_bound_regions(cx.tcx(), signature);\n+\n+    let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.inputs.len() + 1);\n+\n+    // return type\n+    signature_metadata.push(match signature.output {\n+        ty::FnConverging(ret_ty) => match ret_ty.sty {\n+            ty::ty_tup(ref tys) if tys.is_empty() => ptr::null_mut(),\n+            _ => type_metadata(cx, ret_ty, span)\n+        },\n+        ty::FnDiverging => diverging_type_metadata(cx)\n+    });\n+\n+    // regular arguments\n+    for &argument_type in &signature.inputs {\n+        signature_metadata.push(type_metadata(cx, argument_type, span));\n+    }\n+\n+    return_if_metadata_created_in_meantime!(cx, unique_type_id);\n+\n+    return MetadataCreationResult::new(\n+        unsafe {\n+            llvm::LLVMDIBuilderCreateSubroutineType(\n+                DIB(cx),\n+                UNKNOWN_FILE_METADATA,\n+                create_DIArray(DIB(cx), &signature_metadata[..]))\n+        },\n+        false);\n+}\n+\n+// FIXME(1563) This is all a bit of a hack because 'trait pointer' is an ill-\n+// defined concept. For the case of an actual trait pointer (i.e., Box<Trait>,\n+// &Trait), trait_object_type should be the whole thing (e.g, Box<Trait>) and\n+// trait_type should be the actual trait (e.g., Trait). Where the trait is part\n+// of a DST struct, there is no trait_object_type and the results of this\n+// function will be a little bit weird.\n+fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                    trait_type: Ty<'tcx>,\n+                                    trait_object_type: Option<Ty<'tcx>>,\n+                                    unique_type_id: UniqueTypeId)\n+                                    -> DIType {\n+    // The implementation provided here is a stub. It makes sure that the trait\n+    // type is assigned the correct name, size, namespace, and source location.\n+    // But it does not describe the trait's methods.\n+\n+    let def_id = match trait_type.sty {\n+        ty::ty_trait(ref data) => data.principal_def_id(),\n+        _ => {\n+            let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_type);\n+            cx.sess().bug(&format!(\"debuginfo: Unexpected trait-object type in \\\n+                                   trait_pointer_metadata(): {}\",\n+                                   &pp_type_name[..]));\n+        }\n+    };\n+\n+    let trait_object_type = trait_object_type.unwrap_or(trait_type);\n+    let trait_type_name =\n+        compute_debuginfo_type_name(cx, trait_object_type, false);\n+\n+    let (containing_scope, _) = get_namespace_and_span_for_item(cx, def_id);\n+\n+    let trait_llvm_type = type_of::type_of(cx, trait_object_type);\n+\n+    composite_type_metadata(cx,\n+                            trait_llvm_type,\n+                            &trait_type_name[..],\n+                            unique_type_id,\n+                            &[],\n+                            containing_scope,\n+                            UNKNOWN_FILE_METADATA,\n+                            codemap::DUMMY_SP)\n+}\n+\n+pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                               t: Ty<'tcx>,\n+                               usage_site_span: Span)\n+                               -> DIType {\n+    // Get the unique type id of this type.\n+    let unique_type_id = {\n+        let mut type_map = debug_context(cx).type_map.borrow_mut();\n+        // First, try to find the type in TypeMap. If we have seen it before, we\n+        // can exit early here.\n+        match type_map.find_metadata_for_type(t) {\n+            Some(metadata) => {\n+                return metadata;\n+            },\n+            None => {\n+                // The Ty is not in the TypeMap but maybe we have already seen\n+                // an equivalent type (e.g. only differing in region arguments).\n+                // In order to find out, generate the unique type id and look\n+                // that up.\n+                let unique_type_id = type_map.get_unique_type_id_of_type(cx, t);\n+                match type_map.find_metadata_for_unique_id(unique_type_id) {\n+                    Some(metadata) => {\n+                        // There is already an equivalent type in the TypeMap.\n+                        // Register this Ty as an alias in the cache and\n+                        // return the cached metadata.\n+                        type_map.register_type_with_metadata(cx, t, metadata);\n+                        return metadata;\n+                    },\n+                    None => {\n+                        // There really is no type metadata for this type, so\n+                        // proceed by creating it.\n+                        unique_type_id\n+                    }\n+                }\n+            }\n+        }\n+    };\n+\n+    debug!(\"type_metadata: {:?}\", t);\n+\n+    let sty = &t.sty;\n+    let MetadataCreationResult { metadata, already_stored_in_typemap } = match *sty {\n+        ty::ty_bool     |\n+        ty::ty_char     |\n+        ty::ty_int(_)   |\n+        ty::ty_uint(_)  |\n+        ty::ty_float(_) => {\n+            MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n+        }\n+        ty::ty_tup(ref elements) if elements.is_empty() => {\n+            MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n+        }\n+        ty::ty_enum(def_id, _) => {\n+            prepare_enum_metadata(cx, t, def_id, unique_type_id, usage_site_span).finalize(cx)\n+        }\n+        ty::ty_vec(typ, len) => {\n+            fixed_vec_metadata(cx, unique_type_id, typ, len.map(|x| x as u64), usage_site_span)\n+        }\n+        ty::ty_str => {\n+            fixed_vec_metadata(cx, unique_type_id, cx.tcx().types.i8, None, usage_site_span)\n+        }\n+        ty::ty_trait(..) => {\n+            MetadataCreationResult::new(\n+                        trait_pointer_metadata(cx, t, None, unique_type_id),\n+            false)\n+        }\n+        ty::ty_uniq(ty) | ty::ty_ptr(ty::mt{ty, ..}) | ty::ty_rptr(_, ty::mt{ty, ..}) => {\n+            match ty.sty {\n+                ty::ty_vec(typ, None) => {\n+                    vec_slice_metadata(cx, t, typ, unique_type_id, usage_site_span)\n+                }\n+                ty::ty_str => {\n+                    vec_slice_metadata(cx, t, cx.tcx().types.u8, unique_type_id, usage_site_span)\n+                }\n+                ty::ty_trait(..) => {\n+                    MetadataCreationResult::new(\n+                        trait_pointer_metadata(cx, ty, Some(t), unique_type_id),\n+                        false)\n+                }\n+                _ => {\n+                    let pointee_metadata = type_metadata(cx, ty, usage_site_span);\n+\n+                    match debug_context(cx).type_map\n+                                           .borrow()\n+                                           .find_metadata_for_unique_id(unique_type_id) {\n+                        Some(metadata) => return metadata,\n+                        None => { /* proceed normally */ }\n+                    };\n+\n+                    MetadataCreationResult::new(pointer_type_metadata(cx, t, pointee_metadata),\n+                                                false)\n+                }\n+            }\n+        }\n+        ty::ty_bare_fn(_, ref barefnty) => {\n+            subroutine_type_metadata(cx, unique_type_id, &barefnty.sig, usage_site_span)\n+        }\n+        ty::ty_closure(def_id, substs) => {\n+            let typer = NormalizingClosureTyper::new(cx.tcx());\n+            let sig = typer.closure_type(def_id, substs).sig;\n+            subroutine_type_metadata(cx, unique_type_id, &sig, usage_site_span)\n+        }\n+        ty::ty_struct(def_id, substs) => {\n+            prepare_struct_metadata(cx,\n+                                    t,\n+                                    def_id,\n+                                    substs,\n+                                    unique_type_id,\n+                                    usage_site_span).finalize(cx)\n+        }\n+        ty::ty_tup(ref elements) => {\n+            prepare_tuple_metadata(cx,\n+                                   t,\n+                                   &elements[..],\n+                                   unique_type_id,\n+                                   usage_site_span).finalize(cx)\n+        }\n+        _ => {\n+            cx.sess().bug(&format!(\"debuginfo: unexpected type in type_metadata: {:?}\",\n+                                  sty))\n+        }\n+    };\n+\n+    {\n+        let mut type_map = debug_context(cx).type_map.borrow_mut();\n+\n+        if already_stored_in_typemap {\n+            // Also make sure that we already have a TypeMap entry entry for the unique type id.\n+            let metadata_for_uid = match type_map.find_metadata_for_unique_id(unique_type_id) {\n+                Some(metadata) => metadata,\n+                None => {\n+                    let unique_type_id_str =\n+                        type_map.get_unique_type_id_as_string(unique_type_id);\n+                    let error_message = format!(\"Expected type metadata for unique \\\n+                                                 type id '{}' to already be in \\\n+                                                 the debuginfo::TypeMap but it \\\n+                                                 was not. (Ty = {})\",\n+                                                &unique_type_id_str[..],\n+                                                ppaux::ty_to_string(cx.tcx(), t));\n+                    cx.sess().span_bug(usage_site_span, &error_message[..]);\n+                }\n+            };\n+\n+            match type_map.find_metadata_for_type(t) {\n+                Some(metadata) => {\n+                    if metadata != metadata_for_uid {\n+                        let unique_type_id_str =\n+                            type_map.get_unique_type_id_as_string(unique_type_id);\n+                        let error_message = format!(\"Mismatch between Ty and \\\n+                                                     UniqueTypeId maps in \\\n+                                                     debuginfo::TypeMap. \\\n+                                                     UniqueTypeId={}, Ty={}\",\n+                            &unique_type_id_str[..],\n+                            ppaux::ty_to_string(cx.tcx(), t));\n+                        cx.sess().span_bug(usage_site_span, &error_message[..]);\n+                    }\n+                }\n+                None => {\n+                    type_map.register_type_with_metadata(cx, t, metadata);\n+                }\n+            }\n+        } else {\n+            type_map.register_type_with_metadata(cx, t, metadata);\n+            type_map.register_unique_id_with_metadata(cx, unique_type_id, metadata);\n+        }\n+    }\n+\n+    metadata\n+}\n+\n+pub fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n+    match debug_context(cx).created_files.borrow().get(full_path) {\n+        Some(file_metadata) => return *file_metadata,\n+        None => ()\n+    }\n+\n+    debug!(\"file_metadata: {}\", full_path);\n+\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let work_dir = cx.sess().working_dir.to_str().unwrap();\n+    let file_name =\n+        if full_path.starts_with(work_dir) {\n+            &full_path[work_dir.len() + 1..full_path.len()]\n+        } else {\n+            full_path\n+        };\n+\n+    let file_name = CString::new(file_name).unwrap();\n+    let work_dir = CString::new(work_dir).unwrap();\n+    let file_metadata = unsafe {\n+        llvm::LLVMDIBuilderCreateFile(DIB(cx), file_name.as_ptr(),\n+                                      work_dir.as_ptr())\n+    };\n+\n+    let mut created_files = debug_context(cx).created_files.borrow_mut();\n+    created_files.insert(full_path.to_string(), file_metadata);\n+    return file_metadata;\n+}\n+\n+/// Finds the scope metadata node for the given AST node.\n+pub fn scope_metadata(fcx: &FunctionContext,\n+                  node_id: ast::NodeId,\n+                  error_reporting_span: Span)\n+               -> DIScope {\n+    let scope_map = &fcx.debug_context\n+                        .get_ref(fcx.ccx, error_reporting_span)\n+                        .scope_map;\n+    match scope_map.borrow().get(&node_id).cloned() {\n+        Some(scope_metadata) => scope_metadata,\n+        None => {\n+            let node = fcx.ccx.tcx().map.get(node_id);\n+\n+            fcx.ccx.sess().span_bug(error_reporting_span,\n+                &format!(\"debuginfo: Could not find scope info for node {:?}\",\n+                        node));\n+        }\n+    }\n+}\n+\n+fn diverging_type_metadata(cx: &CrateContext) -> DIType {\n+    unsafe {\n+        llvm::LLVMDIBuilderCreateBasicType(\n+            DIB(cx),\n+            \"!\\0\".as_ptr() as *const _,\n+            bytes_to_bits(0),\n+            bytes_to_bits(0),\n+            DW_ATE_unsigned)\n+    }\n+}\n+\n+fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                 t: Ty<'tcx>) -> DIType {\n+\n+    debug!(\"basic_type_metadata: {:?}\", t);\n+\n+    let (name, encoding) = match t.sty {\n+        ty::ty_tup(ref elements) if elements.is_empty() =>\n+            (\"()\".to_string(), DW_ATE_unsigned),\n+        ty::ty_bool => (\"bool\".to_string(), DW_ATE_boolean),\n+        ty::ty_char => (\"char\".to_string(), DW_ATE_unsigned_char),\n+        ty::ty_int(int_ty) => match int_ty {\n+            ast::TyIs => (\"isize\".to_string(), DW_ATE_signed),\n+            ast::TyI8 => (\"i8\".to_string(), DW_ATE_signed),\n+            ast::TyI16 => (\"i16\".to_string(), DW_ATE_signed),\n+            ast::TyI32 => (\"i32\".to_string(), DW_ATE_signed),\n+            ast::TyI64 => (\"i64\".to_string(), DW_ATE_signed)\n+        },\n+        ty::ty_uint(uint_ty) => match uint_ty {\n+            ast::TyUs => (\"usize\".to_string(), DW_ATE_unsigned),\n+            ast::TyU8 => (\"u8\".to_string(), DW_ATE_unsigned),\n+            ast::TyU16 => (\"u16\".to_string(), DW_ATE_unsigned),\n+            ast::TyU32 => (\"u32\".to_string(), DW_ATE_unsigned),\n+            ast::TyU64 => (\"u64\".to_string(), DW_ATE_unsigned)\n+        },\n+        ty::ty_float(float_ty) => match float_ty {\n+            ast::TyF32 => (\"f32\".to_string(), DW_ATE_float),\n+            ast::TyF64 => (\"f64\".to_string(), DW_ATE_float),\n+        },\n+        _ => cx.sess().bug(\"debuginfo::basic_type_metadata - t is invalid type\")\n+    };\n+\n+    let llvm_type = type_of::type_of(cx, t);\n+    let (size, align) = size_and_align_of(cx, llvm_type);\n+    let name = CString::new(name).unwrap();\n+    let ty_metadata = unsafe {\n+        llvm::LLVMDIBuilderCreateBasicType(\n+            DIB(cx),\n+            name.as_ptr(),\n+            bytes_to_bits(size),\n+            bytes_to_bits(align),\n+            encoding)\n+    };\n+\n+    return ty_metadata;\n+}\n+\n+fn pointer_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                   pointer_type: Ty<'tcx>,\n+                                   pointee_type_metadata: DIType)\n+                                   -> DIType {\n+    let pointer_llvm_type = type_of::type_of(cx, pointer_type);\n+    let (pointer_size, pointer_align) = size_and_align_of(cx, pointer_llvm_type);\n+    let name = compute_debuginfo_type_name(cx, pointer_type, false);\n+    let name = CString::new(name).unwrap();\n+    let ptr_metadata = unsafe {\n+        llvm::LLVMDIBuilderCreatePointerType(\n+            DIB(cx),\n+            pointee_type_metadata,\n+            bytes_to_bits(pointer_size),\n+            bytes_to_bits(pointer_align),\n+            name.as_ptr())\n+    };\n+    return ptr_metadata;\n+}\n+\n+pub fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n+    let work_dir = &cx.sess().working_dir;\n+    let compile_unit_name = match cx.sess().local_crate_source_file {\n+        None => fallback_path(cx),\n+        Some(ref abs_path) => {\n+            if abs_path.is_relative() {\n+                cx.sess().warn(\"debuginfo: Invalid path to crate's local root source file!\");\n+                fallback_path(cx)\n+            } else {\n+                match abs_path.relative_from(work_dir) {\n+                    Some(ref p) if p.is_relative() => {\n+                        if p.starts_with(Path::new(\"./\")) {\n+                            path2cstr(p)\n+                        } else {\n+                            path2cstr(&Path::new(\".\").join(p))\n+                        }\n+                    }\n+                    _ => fallback_path(cx)\n+                }\n+            }\n+        }\n+    };\n+\n+    debug!(\"compile_unit_metadata: {:?}\", compile_unit_name);\n+    let producer = format!(\"rustc version {}\",\n+                           (option_env!(\"CFG_VERSION\")).expect(\"CFG_VERSION\"));\n+\n+    let compile_unit_name = compile_unit_name.as_ptr();\n+    let work_dir = path2cstr(&work_dir);\n+    let producer = CString::new(producer).unwrap();\n+    let flags = \"\\0\";\n+    let split_name = \"\\0\";\n+    return unsafe {\n+        llvm::LLVMDIBuilderCreateCompileUnit(\n+            debug_context(cx).builder,\n+            DW_LANG_RUST,\n+            compile_unit_name,\n+            work_dir.as_ptr(),\n+            producer.as_ptr(),\n+            cx.sess().opts.optimize != config::No,\n+            flags.as_ptr() as *const _,\n+            0,\n+            split_name.as_ptr() as *const _)\n+    };\n+\n+    fn fallback_path(cx: &CrateContext) -> CString {\n+        CString::new(cx.link_meta().crate_name.clone()).unwrap()\n+    }\n+}\n+\n+pub struct MetadataCreationResult {\n+    metadata: DIType,\n+    already_stored_in_typemap: bool\n+}\n+\n+impl MetadataCreationResult {\n+    pub fn new(metadata: DIType, already_stored_in_typemap: bool) -> MetadataCreationResult {\n+        MetadataCreationResult {\n+            metadata: metadata,\n+            already_stored_in_typemap: already_stored_in_typemap\n+        }\n+    }\n+}"}, {"sha": "d0ae478008106bac2981e086b300b60dc03d73a6", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 3, "deletions": 566, "changes": 569, "blob_url": "https://github.com/rust-lang/rust/blob/9756349d118c4c5209395e804624786c8fcaeb51/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9756349d118c4c5209395e804624786c8fcaeb51/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=9756349d118c4c5209395e804624786c8fcaeb51", "patch": "@@ -16,13 +16,15 @@ mod utils;\n mod create;\n mod namespace;\n mod types;\n+mod metadata;\n \n use self::utils::{debug_context, DIB, span_start, bytes_to_bits, size_and_align_of,\n                   assert_type_for_node_id, get_namespace_and_span_for_item, fn_should_be_ignored,\n                   contains_nodebug_attribute, create_scope_map};\n use self::create::{declare_local, create_DIArray, is_node_local_to_unit};\n use self::namespace::{namespace_for_item, NamespaceTreeNode};\n use self::types::{compute_debuginfo_type_name, push_debuginfo_type_name};\n+use self::metadata::{type_metadata, file_metadata, scope_metadata, compile_unit_metadata, MetadataCreationResult};\n \n use self::VariableAccess::*;\n use self::VariableKind::*;\n@@ -48,37 +50,22 @@ use middle::pat_util;\n use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n use util::nodemap::{DefIdMap, NodeMap, FnvHashMap, FnvHashSet};\n use util::ppaux;\n-use util::common::path2cstr;\n \n-use libc::{c_uint, c_longlong};\n+use libc::c_uint;\n use std::cell::{Cell, RefCell};\n use std::ffi::CString;\n-use std::path::Path;\n use std::ptr;\n use std::rc::Rc;\n use syntax::util::interner::Interner;\n use syntax::codemap::{Span, Pos};\n use syntax::{ast, codemap, ast_util, ast_map};\n use syntax::parse::token::{self, special_idents};\n \n-const DW_LANG_RUST: c_uint = 0x9000;\n-\n #[allow(non_upper_case_globals)]\n const DW_TAG_auto_variable: c_uint = 0x100;\n #[allow(non_upper_case_globals)]\n const DW_TAG_arg_variable: c_uint = 0x101;\n \n-#[allow(non_upper_case_globals)]\n-const DW_ATE_boolean: c_uint = 0x02;\n-#[allow(non_upper_case_globals)]\n-const DW_ATE_float: c_uint = 0x04;\n-#[allow(non_upper_case_globals)]\n-const DW_ATE_signed: c_uint = 0x05;\n-#[allow(non_upper_case_globals)]\n-const DW_ATE_unsigned: c_uint = 0x07;\n-#[allow(non_upper_case_globals)]\n-const DW_ATE_unsigned_char: c_uint = 0x08;\n-\n const UNKNOWN_LINE_NUMBER: c_uint = 0;\n const UNKNOWN_COLUMN_NUMBER: c_uint = 0;\n \n@@ -450,19 +437,6 @@ impl<'tcx> TypeMap<'tcx> {\n     }\n }\n \n-// Returns from the enclosing function if the type metadata with the given\n-// unique id can be found in the type map\n-macro_rules! return_if_metadata_created_in_meantime {\n-    ($cx: expr, $unique_type_id: expr) => (\n-        match debug_context($cx).type_map\n-                                .borrow()\n-                                .find_metadata_for_unique_id($unique_type_id) {\n-            Some(metadata) => return MetadataCreationResult::new(metadata, true),\n-            None => { /* proceed normally */ }\n-        };\n-    )\n-}\n-\n \n /// A context object for maintaining all state needed by the debuginfo module.\n pub struct CrateDebugContext<'tcx> {\n@@ -1436,183 +1410,6 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-\n-fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n-    let work_dir = &cx.sess().working_dir;\n-    let compile_unit_name = match cx.sess().local_crate_source_file {\n-        None => fallback_path(cx),\n-        Some(ref abs_path) => {\n-            if abs_path.is_relative() {\n-                cx.sess().warn(\"debuginfo: Invalid path to crate's local root source file!\");\n-                fallback_path(cx)\n-            } else {\n-                match abs_path.relative_from(work_dir) {\n-                    Some(ref p) if p.is_relative() => {\n-                        if p.starts_with(Path::new(\"./\")) {\n-                            path2cstr(p)\n-                        } else {\n-                            path2cstr(&Path::new(\".\").join(p))\n-                        }\n-                    }\n-                    _ => fallback_path(cx)\n-                }\n-            }\n-        }\n-    };\n-\n-    debug!(\"compile_unit_metadata: {:?}\", compile_unit_name);\n-    let producer = format!(\"rustc version {}\",\n-                           (option_env!(\"CFG_VERSION\")).expect(\"CFG_VERSION\"));\n-\n-    let compile_unit_name = compile_unit_name.as_ptr();\n-    let work_dir = path2cstr(&work_dir);\n-    let producer = CString::new(producer).unwrap();\n-    let flags = \"\\0\";\n-    let split_name = \"\\0\";\n-    return unsafe {\n-        llvm::LLVMDIBuilderCreateCompileUnit(\n-            debug_context(cx).builder,\n-            DW_LANG_RUST,\n-            compile_unit_name,\n-            work_dir.as_ptr(),\n-            producer.as_ptr(),\n-            cx.sess().opts.optimize != config::No,\n-            flags.as_ptr() as *const _,\n-            0,\n-            split_name.as_ptr() as *const _)\n-    };\n-\n-    fn fallback_path(cx: &CrateContext) -> CString {\n-        CString::new(cx.link_meta().crate_name.clone()).unwrap()\n-    }\n-}\n-\n-\n-fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n-    match debug_context(cx).created_files.borrow().get(full_path) {\n-        Some(file_metadata) => return *file_metadata,\n-        None => ()\n-    }\n-\n-    debug!(\"file_metadata: {}\", full_path);\n-\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let work_dir = cx.sess().working_dir.to_str().unwrap();\n-    let file_name =\n-        if full_path.starts_with(work_dir) {\n-            &full_path[work_dir.len() + 1..full_path.len()]\n-        } else {\n-            full_path\n-        };\n-\n-    let file_name = CString::new(file_name).unwrap();\n-    let work_dir = CString::new(work_dir).unwrap();\n-    let file_metadata = unsafe {\n-        llvm::LLVMDIBuilderCreateFile(DIB(cx), file_name.as_ptr(),\n-                                      work_dir.as_ptr())\n-    };\n-\n-    let mut created_files = debug_context(cx).created_files.borrow_mut();\n-    created_files.insert(full_path.to_string(), file_metadata);\n-    return file_metadata;\n-}\n-\n-/// Finds the scope metadata node for the given AST node.\n-fn scope_metadata(fcx: &FunctionContext,\n-                  node_id: ast::NodeId,\n-                  error_reporting_span: Span)\n-               -> DIScope {\n-    let scope_map = &fcx.debug_context\n-                        .get_ref(fcx.ccx, error_reporting_span)\n-                        .scope_map;\n-    match scope_map.borrow().get(&node_id).cloned() {\n-        Some(scope_metadata) => scope_metadata,\n-        None => {\n-            let node = fcx.ccx.tcx().map.get(node_id);\n-\n-            fcx.ccx.sess().span_bug(error_reporting_span,\n-                &format!(\"debuginfo: Could not find scope info for node {:?}\",\n-                        node));\n-        }\n-    }\n-}\n-\n-fn diverging_type_metadata(cx: &CrateContext) -> DIType {\n-    unsafe {\n-        llvm::LLVMDIBuilderCreateBasicType(\n-            DIB(cx),\n-            \"!\\0\".as_ptr() as *const _,\n-            bytes_to_bits(0),\n-            bytes_to_bits(0),\n-            DW_ATE_unsigned)\n-    }\n-}\n-\n-fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                 t: Ty<'tcx>) -> DIType {\n-\n-    debug!(\"basic_type_metadata: {:?}\", t);\n-\n-    let (name, encoding) = match t.sty {\n-        ty::ty_tup(ref elements) if elements.is_empty() =>\n-            (\"()\".to_string(), DW_ATE_unsigned),\n-        ty::ty_bool => (\"bool\".to_string(), DW_ATE_boolean),\n-        ty::ty_char => (\"char\".to_string(), DW_ATE_unsigned_char),\n-        ty::ty_int(int_ty) => match int_ty {\n-            ast::TyIs => (\"isize\".to_string(), DW_ATE_signed),\n-            ast::TyI8 => (\"i8\".to_string(), DW_ATE_signed),\n-            ast::TyI16 => (\"i16\".to_string(), DW_ATE_signed),\n-            ast::TyI32 => (\"i32\".to_string(), DW_ATE_signed),\n-            ast::TyI64 => (\"i64\".to_string(), DW_ATE_signed)\n-        },\n-        ty::ty_uint(uint_ty) => match uint_ty {\n-            ast::TyUs => (\"usize\".to_string(), DW_ATE_unsigned),\n-            ast::TyU8 => (\"u8\".to_string(), DW_ATE_unsigned),\n-            ast::TyU16 => (\"u16\".to_string(), DW_ATE_unsigned),\n-            ast::TyU32 => (\"u32\".to_string(), DW_ATE_unsigned),\n-            ast::TyU64 => (\"u64\".to_string(), DW_ATE_unsigned)\n-        },\n-        ty::ty_float(float_ty) => match float_ty {\n-            ast::TyF32 => (\"f32\".to_string(), DW_ATE_float),\n-            ast::TyF64 => (\"f64\".to_string(), DW_ATE_float),\n-        },\n-        _ => cx.sess().bug(\"debuginfo::basic_type_metadata - t is invalid type\")\n-    };\n-\n-    let llvm_type = type_of::type_of(cx, t);\n-    let (size, align) = size_and_align_of(cx, llvm_type);\n-    let name = CString::new(name).unwrap();\n-    let ty_metadata = unsafe {\n-        llvm::LLVMDIBuilderCreateBasicType(\n-            DIB(cx),\n-            name.as_ptr(),\n-            bytes_to_bits(size),\n-            bytes_to_bits(align),\n-            encoding)\n-    };\n-\n-    return ty_metadata;\n-}\n-\n-fn pointer_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                   pointer_type: Ty<'tcx>,\n-                                   pointee_type_metadata: DIType)\n-                                   -> DIType {\n-    let pointer_llvm_type = type_of::type_of(cx, pointer_type);\n-    let (pointer_size, pointer_align) = size_and_align_of(cx, pointer_llvm_type);\n-    let name = compute_debuginfo_type_name(cx, pointer_type, false);\n-    let name = CString::new(name).unwrap();\n-    let ptr_metadata = unsafe {\n-        llvm::LLVMDIBuilderCreatePointerType(\n-            DIB(cx),\n-            pointee_type_metadata,\n-            bytes_to_bits(pointer_size),\n-            bytes_to_bits(pointer_align),\n-            name.as_ptr())\n-    };\n-    return ptr_metadata;\n-}\n-\n //=-----------------------------------------------------------------------------\n // Common facilities for record-like types (structs, enums, tuples)\n //=-----------------------------------------------------------------------------\n@@ -2484,366 +2281,6 @@ fn create_struct_stub(cx: &CrateContext,\n     return metadata_stub;\n }\n \n-fn fixed_vec_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                unique_type_id: UniqueTypeId,\n-                                element_type: Ty<'tcx>,\n-                                len: Option<u64>,\n-                                span: Span)\n-                                -> MetadataCreationResult {\n-    let element_type_metadata = type_metadata(cx, element_type, span);\n-\n-    return_if_metadata_created_in_meantime!(cx, unique_type_id);\n-\n-    let element_llvm_type = type_of::type_of(cx, element_type);\n-    let (element_type_size, element_type_align) = size_and_align_of(cx, element_llvm_type);\n-\n-    let (array_size_in_bytes, upper_bound) = match len {\n-        Some(len) => (element_type_size * len, len as c_longlong),\n-        None => (0, -1)\n-    };\n-\n-    let subrange = unsafe {\n-        llvm::LLVMDIBuilderGetOrCreateSubrange(DIB(cx), 0, upper_bound)\n-    };\n-\n-    let subscripts = create_DIArray(DIB(cx), &[subrange]);\n-    let metadata = unsafe {\n-        llvm::LLVMDIBuilderCreateArrayType(\n-            DIB(cx),\n-            bytes_to_bits(array_size_in_bytes),\n-            bytes_to_bits(element_type_align),\n-            element_type_metadata,\n-            subscripts)\n-    };\n-\n-    return MetadataCreationResult::new(metadata, false);\n-}\n-\n-fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                vec_type: Ty<'tcx>,\n-                                element_type: Ty<'tcx>,\n-                                unique_type_id: UniqueTypeId,\n-                                span: Span)\n-                                -> MetadataCreationResult {\n-    let data_ptr_type = ty::mk_ptr(cx.tcx(), ty::mt {\n-        ty: element_type,\n-        mutbl: ast::MutImmutable\n-    });\n-\n-    let element_type_metadata = type_metadata(cx, data_ptr_type, span);\n-\n-    return_if_metadata_created_in_meantime!(cx, unique_type_id);\n-\n-    let slice_llvm_type = type_of::type_of(cx, vec_type);\n-    let slice_type_name = compute_debuginfo_type_name(cx, vec_type, true);\n-\n-    let member_llvm_types = slice_llvm_type.field_types();\n-    assert!(slice_layout_is_correct(cx,\n-                                    &member_llvm_types[..],\n-                                    element_type));\n-    let member_descriptions = [\n-        MemberDescription {\n-            name: \"data_ptr\".to_string(),\n-            llvm_type: member_llvm_types[0],\n-            type_metadata: element_type_metadata,\n-            offset: ComputedMemberOffset,\n-            flags: FLAGS_NONE\n-        },\n-        MemberDescription {\n-            name: \"length\".to_string(),\n-            llvm_type: member_llvm_types[1],\n-            type_metadata: type_metadata(cx, cx.tcx().types.usize, span),\n-            offset: ComputedMemberOffset,\n-            flags: FLAGS_NONE\n-        },\n-    ];\n-\n-    assert!(member_descriptions.len() == member_llvm_types.len());\n-\n-    let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, &loc.file.name);\n-\n-    let metadata = composite_type_metadata(cx,\n-                                           slice_llvm_type,\n-                                           &slice_type_name[..],\n-                                           unique_type_id,\n-                                           &member_descriptions,\n-                                           UNKNOWN_SCOPE_METADATA,\n-                                           file_metadata,\n-                                           span);\n-    return MetadataCreationResult::new(metadata, false);\n-\n-    fn slice_layout_is_correct<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                         member_llvm_types: &[Type],\n-                                         element_type: Ty<'tcx>)\n-                                         -> bool {\n-        member_llvm_types.len() == 2 &&\n-        member_llvm_types[0] == type_of::type_of(cx, element_type).ptr_to() &&\n-        member_llvm_types[1] == cx.int_type()\n-    }\n-}\n-\n-fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                      unique_type_id: UniqueTypeId,\n-                                      signature: &ty::PolyFnSig<'tcx>,\n-                                      span: Span)\n-                                      -> MetadataCreationResult\n-{\n-    let signature = ty::erase_late_bound_regions(cx.tcx(), signature);\n-\n-    let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.inputs.len() + 1);\n-\n-    // return type\n-    signature_metadata.push(match signature.output {\n-        ty::FnConverging(ret_ty) => match ret_ty.sty {\n-            ty::ty_tup(ref tys) if tys.is_empty() => ptr::null_mut(),\n-            _ => type_metadata(cx, ret_ty, span)\n-        },\n-        ty::FnDiverging => diverging_type_metadata(cx)\n-    });\n-\n-    // regular arguments\n-    for &argument_type in &signature.inputs {\n-        signature_metadata.push(type_metadata(cx, argument_type, span));\n-    }\n-\n-    return_if_metadata_created_in_meantime!(cx, unique_type_id);\n-\n-    return MetadataCreationResult::new(\n-        unsafe {\n-            llvm::LLVMDIBuilderCreateSubroutineType(\n-                DIB(cx),\n-                UNKNOWN_FILE_METADATA,\n-                create_DIArray(DIB(cx), &signature_metadata[..]))\n-        },\n-        false);\n-}\n-\n-// FIXME(1563) This is all a bit of a hack because 'trait pointer' is an ill-\n-// defined concept. For the case of an actual trait pointer (i.e., Box<Trait>,\n-// &Trait), trait_object_type should be the whole thing (e.g, Box<Trait>) and\n-// trait_type should be the actual trait (e.g., Trait). Where the trait is part\n-// of a DST struct, there is no trait_object_type and the results of this\n-// function will be a little bit weird.\n-fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                    trait_type: Ty<'tcx>,\n-                                    trait_object_type: Option<Ty<'tcx>>,\n-                                    unique_type_id: UniqueTypeId)\n-                                    -> DIType {\n-    // The implementation provided here is a stub. It makes sure that the trait\n-    // type is assigned the correct name, size, namespace, and source location.\n-    // But it does not describe the trait's methods.\n-\n-    let def_id = match trait_type.sty {\n-        ty::ty_trait(ref data) => data.principal_def_id(),\n-        _ => {\n-            let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_type);\n-            cx.sess().bug(&format!(\"debuginfo: Unexpected trait-object type in \\\n-                                   trait_pointer_metadata(): {}\",\n-                                   &pp_type_name[..]));\n-        }\n-    };\n-\n-    let trait_object_type = trait_object_type.unwrap_or(trait_type);\n-    let trait_type_name =\n-        compute_debuginfo_type_name(cx, trait_object_type, false);\n-\n-    let (containing_scope, _) = get_namespace_and_span_for_item(cx, def_id);\n-\n-    let trait_llvm_type = type_of::type_of(cx, trait_object_type);\n-\n-    composite_type_metadata(cx,\n-                            trait_llvm_type,\n-                            &trait_type_name[..],\n-                            unique_type_id,\n-                            &[],\n-                            containing_scope,\n-                            UNKNOWN_FILE_METADATA,\n-                            codemap::DUMMY_SP)\n-}\n-\n-fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                           t: Ty<'tcx>,\n-                           usage_site_span: Span)\n-                           -> DIType {\n-    // Get the unique type id of this type.\n-    let unique_type_id = {\n-        let mut type_map = debug_context(cx).type_map.borrow_mut();\n-        // First, try to find the type in TypeMap. If we have seen it before, we\n-        // can exit early here.\n-        match type_map.find_metadata_for_type(t) {\n-            Some(metadata) => {\n-                return metadata;\n-            },\n-            None => {\n-                // The Ty is not in the TypeMap but maybe we have already seen\n-                // an equivalent type (e.g. only differing in region arguments).\n-                // In order to find out, generate the unique type id and look\n-                // that up.\n-                let unique_type_id = type_map.get_unique_type_id_of_type(cx, t);\n-                match type_map.find_metadata_for_unique_id(unique_type_id) {\n-                    Some(metadata) => {\n-                        // There is already an equivalent type in the TypeMap.\n-                        // Register this Ty as an alias in the cache and\n-                        // return the cached metadata.\n-                        type_map.register_type_with_metadata(cx, t, metadata);\n-                        return metadata;\n-                    },\n-                    None => {\n-                        // There really is no type metadata for this type, so\n-                        // proceed by creating it.\n-                        unique_type_id\n-                    }\n-                }\n-            }\n-        }\n-    };\n-\n-    debug!(\"type_metadata: {:?}\", t);\n-\n-    let sty = &t.sty;\n-    let MetadataCreationResult { metadata, already_stored_in_typemap } = match *sty {\n-        ty::ty_bool     |\n-        ty::ty_char     |\n-        ty::ty_int(_)   |\n-        ty::ty_uint(_)  |\n-        ty::ty_float(_) => {\n-            MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n-        }\n-        ty::ty_tup(ref elements) if elements.is_empty() => {\n-            MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n-        }\n-        ty::ty_enum(def_id, _) => {\n-            prepare_enum_metadata(cx, t, def_id, unique_type_id, usage_site_span).finalize(cx)\n-        }\n-        ty::ty_vec(typ, len) => {\n-            fixed_vec_metadata(cx, unique_type_id, typ, len.map(|x| x as u64), usage_site_span)\n-        }\n-        ty::ty_str => {\n-            fixed_vec_metadata(cx, unique_type_id, cx.tcx().types.i8, None, usage_site_span)\n-        }\n-        ty::ty_trait(..) => {\n-            MetadataCreationResult::new(\n-                        trait_pointer_metadata(cx, t, None, unique_type_id),\n-            false)\n-        }\n-        ty::ty_uniq(ty) | ty::ty_ptr(ty::mt{ty, ..}) | ty::ty_rptr(_, ty::mt{ty, ..}) => {\n-            match ty.sty {\n-                ty::ty_vec(typ, None) => {\n-                    vec_slice_metadata(cx, t, typ, unique_type_id, usage_site_span)\n-                }\n-                ty::ty_str => {\n-                    vec_slice_metadata(cx, t, cx.tcx().types.u8, unique_type_id, usage_site_span)\n-                }\n-                ty::ty_trait(..) => {\n-                    MetadataCreationResult::new(\n-                        trait_pointer_metadata(cx, ty, Some(t), unique_type_id),\n-                        false)\n-                }\n-                _ => {\n-                    let pointee_metadata = type_metadata(cx, ty, usage_site_span);\n-\n-                    match debug_context(cx).type_map\n-                                           .borrow()\n-                                           .find_metadata_for_unique_id(unique_type_id) {\n-                        Some(metadata) => return metadata,\n-                        None => { /* proceed normally */ }\n-                    };\n-\n-                    MetadataCreationResult::new(pointer_type_metadata(cx, t, pointee_metadata),\n-                                                false)\n-                }\n-            }\n-        }\n-        ty::ty_bare_fn(_, ref barefnty) => {\n-            subroutine_type_metadata(cx, unique_type_id, &barefnty.sig, usage_site_span)\n-        }\n-        ty::ty_closure(def_id, substs) => {\n-            let typer = NormalizingClosureTyper::new(cx.tcx());\n-            let sig = typer.closure_type(def_id, substs).sig;\n-            subroutine_type_metadata(cx, unique_type_id, &sig, usage_site_span)\n-        }\n-        ty::ty_struct(def_id, substs) => {\n-            prepare_struct_metadata(cx,\n-                                    t,\n-                                    def_id,\n-                                    substs,\n-                                    unique_type_id,\n-                                    usage_site_span).finalize(cx)\n-        }\n-        ty::ty_tup(ref elements) => {\n-            prepare_tuple_metadata(cx,\n-                                   t,\n-                                   &elements[..],\n-                                   unique_type_id,\n-                                   usage_site_span).finalize(cx)\n-        }\n-        _ => {\n-            cx.sess().bug(&format!(\"debuginfo: unexpected type in type_metadata: {:?}\",\n-                                  sty))\n-        }\n-    };\n-\n-    {\n-        let mut type_map = debug_context(cx).type_map.borrow_mut();\n-\n-        if already_stored_in_typemap {\n-            // Also make sure that we already have a TypeMap entry entry for the unique type id.\n-            let metadata_for_uid = match type_map.find_metadata_for_unique_id(unique_type_id) {\n-                Some(metadata) => metadata,\n-                None => {\n-                    let unique_type_id_str =\n-                        type_map.get_unique_type_id_as_string(unique_type_id);\n-                    let error_message = format!(\"Expected type metadata for unique \\\n-                                                 type id '{}' to already be in \\\n-                                                 the debuginfo::TypeMap but it \\\n-                                                 was not. (Ty = {})\",\n-                                                &unique_type_id_str[..],\n-                                                ppaux::ty_to_string(cx.tcx(), t));\n-                    cx.sess().span_bug(usage_site_span, &error_message[..]);\n-                }\n-            };\n-\n-            match type_map.find_metadata_for_type(t) {\n-                Some(metadata) => {\n-                    if metadata != metadata_for_uid {\n-                        let unique_type_id_str =\n-                            type_map.get_unique_type_id_as_string(unique_type_id);\n-                        let error_message = format!(\"Mismatch between Ty and \\\n-                                                     UniqueTypeId maps in \\\n-                                                     debuginfo::TypeMap. \\\n-                                                     UniqueTypeId={}, Ty={}\",\n-                            &unique_type_id_str[..],\n-                            ppaux::ty_to_string(cx.tcx(), t));\n-                        cx.sess().span_bug(usage_site_span, &error_message[..]);\n-                    }\n-                }\n-                None => {\n-                    type_map.register_type_with_metadata(cx, t, metadata);\n-                }\n-            }\n-        } else {\n-            type_map.register_type_with_metadata(cx, t, metadata);\n-            type_map.register_unique_id_with_metadata(cx, unique_type_id, metadata);\n-        }\n-    }\n-\n-    metadata\n-}\n-\n-struct MetadataCreationResult {\n-    metadata: DIType,\n-    already_stored_in_typemap: bool\n-}\n-\n-impl MetadataCreationResult {\n-    fn new(metadata: DIType, already_stored_in_typemap: bool) -> MetadataCreationResult {\n-        MetadataCreationResult {\n-            metadata: metadata,\n-            already_stored_in_typemap: already_stored_in_typemap\n-        }\n-    }\n-}\n \n #[derive(Copy, Clone, PartialEq)]\n enum InternalDebugLocation {"}, {"sha": "48c11dd7ebbe06ee92637f425de029127ea72348", "filename": "src/librustc_trans/trans/debuginfo/utils.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9756349d118c4c5209395e804624786c8fcaeb51/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9756349d118c4c5209395e804624786c8fcaeb51/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs?ref=9756349d118c4c5209395e804624786c8fcaeb51", "patch": "@@ -10,8 +10,9 @@\n \n // Utility Functions.\n \n-use super::{FunctionDebugContext, CrateDebugContext, file_metadata};\n+use super::{FunctionDebugContext, CrateDebugContext};\n use super::namespace::namespace_for_item;\n+use super::metadata::file_metadata;\n \n use llvm;\n use llvm::debuginfo::{DIScope, DISubprogram, DIBuilderRef};"}]}