{"sha": "14de6ec8d8fe082d48252240d7b768c188fbfc47", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0ZGU2ZWM4ZDhmZTA4MmQ0ODI1MjI0MGQ3Yjc2OGMxODhmYmZjNDc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-07-18T09:15:17Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-07-31T09:30:33Z"}, "message": "CTFE: throw unsupported error when partially overwriting a pointer", "tree": {"sha": "1cc616a9a63241a4282ca3b4d3b1da3fb1653991", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1cc616a9a63241a4282ca3b4d3b1da3fb1653991"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14de6ec8d8fe082d48252240d7b768c188fbfc47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14de6ec8d8fe082d48252240d7b768c188fbfc47", "html_url": "https://github.com/rust-lang/rust/commit/14de6ec8d8fe082d48252240d7b768c188fbfc47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14de6ec8d8fe082d48252240d7b768c188fbfc47/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e66a8c260c0bcc4e7a8943f01d75d70ff640fb38", "url": "https://api.github.com/repos/rust-lang/rust/commits/e66a8c260c0bcc4e7a8943f01d75d70ff640fb38", "html_url": "https://github.com/rust-lang/rust/commit/e66a8c260c0bcc4e7a8943f01d75d70ff640fb38"}], "stats": {"total": 96, "additions": 69, "deletions": 27}, "files": [{"sha": "a29b42b45df375f2a158c7d76756d1ebaa8b30a1", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/14de6ec8d8fe082d48252240d7b768c188fbfc47/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14de6ec8d8fe082d48252240d7b768c188fbfc47/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=14de6ec8d8fe082d48252240d7b768c188fbfc47", "patch": "@@ -12,7 +12,7 @@ use rustc_span::DUMMY_SP;\n use rustc_target::abi::{Align, HasDataLayout, Size};\n \n use super::{\n-    read_target_uint, write_target_uint, AllocId, InterpError, InterpResult, Pointer,\n+    read_target_uint, write_target_uint, AllocId, InterpError, InterpResult, Pointer, Provenance,\n     ResourceExhaustionInfo, Scalar, ScalarMaybeUninit, UndefinedBehaviorInfo, UninitBytesAccess,\n     UnsupportedOpInfo,\n };\n@@ -53,18 +53,22 @@ pub struct Allocation<Tag = AllocId, Extra = ()> {\n pub enum AllocError {\n     /// Encountered a pointer where we needed raw bytes.\n     ReadPointerAsBytes,\n+    /// Partially overwriting a pointer.\n+    PartialPointerOverwrite(Size),\n     /// Using uninitialized data where it is not allowed.\n     InvalidUninitBytes(Option<UninitBytesAccess>),\n }\n pub type AllocResult<T = ()> = Result<T, AllocError>;\n \n impl AllocError {\n     pub fn to_interp_error<'tcx>(self, alloc_id: AllocId) -> InterpError<'tcx> {\n+        use AllocError::*;\n         match self {\n-            AllocError::ReadPointerAsBytes => {\n-                InterpError::Unsupported(UnsupportedOpInfo::ReadPointerAsBytes)\n-            }\n-            AllocError::InvalidUninitBytes(info) => InterpError::UndefinedBehavior(\n+            ReadPointerAsBytes => InterpError::Unsupported(UnsupportedOpInfo::ReadPointerAsBytes),\n+            PartialPointerOverwrite(offset) => InterpError::Unsupported(\n+                UnsupportedOpInfo::PartialPointerOverwrite(Pointer::new(alloc_id, offset)),\n+            ),\n+            InvalidUninitBytes(info) => InterpError::UndefinedBehavior(\n                 UndefinedBehaviorInfo::InvalidUninitBytes(info.map(|b| (alloc_id, b))),\n             ),\n         }\n@@ -218,7 +222,7 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n }\n \n /// Byte accessors.\n-impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n+impl<Tag: Provenance, Extra> Allocation<Tag, Extra> {\n     /// The last argument controls whether we error out when there are uninitialized\n     /// or pointer bytes. You should never call this, call `get_bytes` or\n     /// `get_bytes_with_uninit_and_ptr` instead,\n@@ -275,30 +279,35 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     /// Most likely, you want to use the `PlaceTy` and `OperandTy`-based methods\n     /// on `InterpCx` instead.\n-    pub fn get_bytes_mut(&mut self, cx: &impl HasDataLayout, range: AllocRange) -> &mut [u8] {\n+    pub fn get_bytes_mut(\n+        &mut self,\n+        cx: &impl HasDataLayout,\n+        range: AllocRange,\n+    ) -> AllocResult<&mut [u8]> {\n         self.mark_init(range, true);\n-        self.clear_relocations(cx, range);\n+        self.clear_relocations(cx, range)?;\n \n-        &mut self.bytes[range.start.bytes_usize()..range.end().bytes_usize()]\n+        Ok(&mut self.bytes[range.start.bytes_usize()..range.end().bytes_usize()])\n     }\n \n     /// A raw pointer variant of `get_bytes_mut` that avoids invalidating existing aliases into this memory.\n-    pub fn get_bytes_mut_ptr(&mut self, cx: &impl HasDataLayout, range: AllocRange) -> *mut [u8] {\n+    pub fn get_bytes_mut_ptr(\n+        &mut self,\n+        cx: &impl HasDataLayout,\n+        range: AllocRange,\n+    ) -> AllocResult<*mut [u8]> {\n         self.mark_init(range, true);\n-        // This also clears relocations that just overlap with the written range. So writing to some\n-        // byte can de-initialize its neighbors! See\n-        // <https://github.com/rust-lang/rust/issues/87184> for details.\n-        self.clear_relocations(cx, range);\n+        self.clear_relocations(cx, range)?;\n \n         assert!(range.end().bytes_usize() <= self.bytes.len()); // need to do our own bounds-check\n         let begin_ptr = self.bytes.as_mut_ptr().wrapping_add(range.start.bytes_usize());\n         let len = range.end().bytes_usize() - range.start.bytes_usize();\n-        ptr::slice_from_raw_parts_mut(begin_ptr, len)\n+        Ok(ptr::slice_from_raw_parts_mut(begin_ptr, len))\n     }\n }\n \n /// Reading and writing.\n-impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n+impl<Tag: Provenance, Extra> Allocation<Tag, Extra> {\n     /// Validates that `ptr.offset` and `ptr.offset + size` do not point to the middle of a\n     /// relocation. If `allow_uninit_and_ptr` is `false`, also enforces that the memory in the\n     /// given range contains neither relocations nor uninitialized bytes.\n@@ -395,7 +404,7 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n         };\n \n         let endian = cx.data_layout().endian;\n-        let dst = self.get_bytes_mut(cx, range);\n+        let dst = self.get_bytes_mut(cx, range)?;\n         write_target_uint(endian, dst, bytes).unwrap();\n \n         // See if we have to also write a relocation.\n@@ -433,13 +442,16 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// uninitialized. This is a somewhat odd \"spooky action at a distance\",\n     /// but it allows strictly more code to run than if we would just error\n     /// immediately in that case.\n-    fn clear_relocations(&mut self, cx: &impl HasDataLayout, range: AllocRange) {\n+    fn clear_relocations(&mut self, cx: &impl HasDataLayout, range: AllocRange) -> AllocResult\n+    where\n+        Tag: Provenance,\n+    {\n         // Find the start and end of the given range and its outermost relocations.\n         let (first, last) = {\n             // Find all relocations overlapping the given range.\n             let relocations = self.get_relocations(cx, range);\n             if relocations.is_empty() {\n-                return;\n+                return Ok(());\n             }\n \n             (\n@@ -450,17 +462,27 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n         let start = range.start;\n         let end = range.end();\n \n-        // Mark parts of the outermost relocations as uninitialized if they partially fall outside the\n-        // given range.\n+        // We need to handle clearing the relocations from parts of a pointer. See\n+        // <https://github.com/rust-lang/rust/issues/87184> for details.\n         if first < start {\n+            if Tag::ERR_ON_PARTIAL_PTR_OVERWRITE {\n+                return Err(AllocError::PartialPointerOverwrite(first));\n+            }\n             self.init_mask.set_range(first, start, false);\n         }\n         if last > end {\n+            if Tag::ERR_ON_PARTIAL_PTR_OVERWRITE {\n+                return Err(AllocError::PartialPointerOverwrite(\n+                    last - cx.data_layout().pointer_size,\n+                ));\n+            }\n             self.init_mask.set_range(end, last, false);\n         }\n \n         // Forget all the relocations.\n         self.relocations.0.remove_range(first..last);\n+\n+        Ok(())\n     }\n \n     /// Errors if there are relocations overlapping with the edges of the"}, {"sha": "fb35f36f03055cd63d7d59fc814dd98b8e9025d0", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14de6ec8d8fe082d48252240d7b768c188fbfc47/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14de6ec8d8fe082d48252240d7b768c188fbfc47/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=14de6ec8d8fe082d48252240d7b768c188fbfc47", "patch": "@@ -404,6 +404,9 @@ pub enum UnsupportedOpInfo {\n     Unsupported(String),\n     /// Encountered a pointer where we needed raw bytes.\n     ReadPointerAsBytes,\n+    /// Overwriting parts ofa  pointer; the resulting state cannot be represented in our\n+    /// `Allocation` data structure.\n+    PartialPointerOverwrite(Pointer<AllocId>),\n     //\n     // The variants below are only reachable from CTFE/const prop, miri will never emit them.\n     //\n@@ -418,9 +421,12 @@ impl fmt::Display for UnsupportedOpInfo {\n         use UnsupportedOpInfo::*;\n         match self {\n             Unsupported(ref msg) => write!(f, \"{}\", msg),\n-            ReadExternStatic(did) => write!(f, \"cannot read from extern static ({:?})\", did),\n-            ReadPointerAsBytes => write!(f, \"unable to turn pointer into raw bytes\",),\n+            ReadPointerAsBytes => write!(f, \"unable to turn pointer into raw bytes\"),\n+            PartialPointerOverwrite(ptr) => {\n+                write!(f, \"unable to overwrite parts of a pointer in memory at {:?}\", ptr)\n+            }\n             ThreadLocalStatic(did) => write!(f, \"cannot access thread local static ({:?})\", did),\n+            ReadExternStatic(did) => write!(f, \"cannot read from extern static ({:?})\", did),\n         }\n     }\n }"}, {"sha": "3eee45a9230d1ffbd68e3d17e55f7e136dc97fbc", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/14de6ec8d8fe082d48252240d7b768c188fbfc47/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14de6ec8d8fe082d48252240d7b768c188fbfc47/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=14de6ec8d8fe082d48252240d7b768c188fbfc47", "patch": "@@ -108,6 +108,10 @@ pub trait Provenance: Copy + fmt::Debug {\n     /// If `false`, ptr-to-int casts are not supported. The offset *must* be relative in that case.\n     const OFFSET_IS_ADDR: bool;\n \n+    /// We also use this trait to control whether to abort execution when a pointer is being partially overwritten\n+    /// (this avoids a separate trait in `allocation.rs` just for this purpose).\n+    const ERR_ON_PARTIAL_PTR_OVERWRITE: bool;\n+\n     /// Determines how a pointer should be printed.\n     fn fmt(ptr: &Pointer<Self>, f: &mut fmt::Formatter<'_>) -> fmt::Result\n     where\n@@ -123,6 +127,9 @@ impl Provenance for AllocId {\n     // so ptr-to-int casts are not possible (since we do not know the global physical offset).\n     const OFFSET_IS_ADDR: bool = false;\n \n+    // For now, do not allow this, so that we keep our options open.\n+    const ERR_ON_PARTIAL_PTR_OVERWRITE: bool = true;\n+\n     fn fmt(ptr: &Pointer<Self>, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // Forward `alternate` flag to `alloc_id` printing.\n         if f.alternate() {"}, {"sha": "4d13274a1200d2d8cfad0c0a6df51e6dcce3f2a4", "filename": "compiler/rustc_mir/src/interpret/memory.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/14de6ec8d8fe082d48252240d7b768c188fbfc47/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14de6ec8d8fe082d48252240d7b768c188fbfc47/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs?ref=14de6ec8d8fe082d48252240d7b768c188fbfc47", "patch": "@@ -907,7 +907,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n }\n \n /// Reading and writing.\n-impl<'tcx, 'a, Tag: Copy, Extra> AllocRefMut<'a, 'tcx, Tag, Extra> {\n+impl<'tcx, 'a, Tag: Provenance, Extra> AllocRefMut<'a, 'tcx, Tag, Extra> {\n     pub fn write_scalar(\n         &mut self,\n         range: AllocRange,\n@@ -928,7 +928,7 @@ impl<'tcx, 'a, Tag: Copy, Extra> AllocRefMut<'a, 'tcx, Tag, Extra> {\n     }\n }\n \n-impl<'tcx, 'a, Tag: Copy, Extra> AllocRef<'a, 'tcx, Tag, Extra> {\n+impl<'tcx, 'a, Tag: Provenance, Extra> AllocRef<'a, 'tcx, Tag, Extra> {\n     pub fn read_scalar(&self, range: AllocRange) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         Ok(self\n             .alloc\n@@ -998,7 +998,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n         // Side-step AllocRef and directly access the underlying bytes more efficiently.\n         // (We are staying inside the bounds here so all is good.)\n-        let bytes = alloc_ref.alloc.get_bytes_mut(&alloc_ref.tcx, alloc_ref.range);\n+        let alloc_id = alloc_ref.alloc_id;\n+        let bytes = alloc_ref\n+            .alloc\n+            .get_bytes_mut(&alloc_ref.tcx, alloc_ref.range)\n+            .map_err(move |e| e.to_interp_error(alloc_id))?;\n         // `zip` would stop when the first iterator ends; we want to definitely\n         // cover all of `bytes`.\n         for dest in bytes {\n@@ -1072,7 +1076,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let (dest_alloc, extra) = self.get_raw_mut(dest_alloc_id)?;\n         let dest_range = alloc_range(dest_offset, size * num_copies);\n         M::memory_written(extra, &mut dest_alloc.extra, dest.provenance, dest_range)?;\n-        let dest_bytes = dest_alloc.get_bytes_mut_ptr(&tcx, dest_range).as_mut_ptr();\n+        let dest_bytes = dest_alloc\n+            .get_bytes_mut_ptr(&tcx, dest_range)\n+            .map_err(|e| e.to_interp_error(dest_alloc_id))?\n+            .as_mut_ptr();\n \n         if compressed.no_bytes_init() {\n             // Fast path: If all bytes are `uninit` then there is nothing to copy. The target range"}]}