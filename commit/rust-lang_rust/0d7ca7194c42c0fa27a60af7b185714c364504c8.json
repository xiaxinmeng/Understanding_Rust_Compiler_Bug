{"sha": "0d7ca7194c42c0fa27a60af7b185714c364504c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkN2NhNzE5NGM0MmMwZmEyN2E2MGFmN2IxODU3MTRjMzY0NTA0Yzg=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-09-17T07:15:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-09-17T07:15:36Z"}, "message": "Merge pull request #446 from RalfJung/zero-sized-accesses\n\nStrictly enforce pointer validity even for zero-sized accesses", "tree": {"sha": "0756373b088d68ec307ae6358efb4eda45af167f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0756373b088d68ec307ae6358efb4eda45af167f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d7ca7194c42c0fa27a60af7b185714c364504c8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbn1SYCRBK7hj4Ov3rIwAAdHIIAFk2wnaZJ/DOpPtAVDBqf3C/\nqiUhdCW2AcYWLoynvPGyuW1imYPT08sQZMFFoVogQDYJWzylZJ2MBR87p2UuJcsh\nT6hB1lphwNzXGtuYhXZ1RzUrvpaHNH+Rk8flwwycCqdQUR+n3P5ywQjUSJzQoSEW\n0BM2AJs/zMBkfr+W3nHotxAvTq8VrMf/Cux0N5gC6bV3gH4fQ5916cZBfuahVK1O\nwQsJfliqELXveVykC78MFJXil9+mGis1/UdpyLzrlS6hAhgqqo1YG7sAPHTXfOF0\nr2/gBXZemEsz+sKJVBDKaAka835OS6hdECNbblPYEuaQIy/3jM+D3KDW9ve5SS0=\n=tsGu\n-----END PGP SIGNATURE-----\n", "payload": "tree 0756373b088d68ec307ae6358efb4eda45af167f\nparent 63c2a2fc058bfd5d1de3670613c8f0640c6ab438\nparent c096d3405389089bab4379161a1546094b1db479\nauthor Ralf Jung <post@ralfj.de> 1537168536 +0200\ncommitter GitHub <noreply@github.com> 1537168536 +0200\n\nMerge pull request #446 from RalfJung/zero-sized-accesses\n\nStrictly enforce pointer validity even for zero-sized accesses"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d7ca7194c42c0fa27a60af7b185714c364504c8", "html_url": "https://github.com/rust-lang/rust/commit/0d7ca7194c42c0fa27a60af7b185714c364504c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d7ca7194c42c0fa27a60af7b185714c364504c8/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63c2a2fc058bfd5d1de3670613c8f0640c6ab438", "url": "https://api.github.com/repos/rust-lang/rust/commits/63c2a2fc058bfd5d1de3670613c8f0640c6ab438", "html_url": "https://github.com/rust-lang/rust/commit/63c2a2fc058bfd5d1de3670613c8f0640c6ab438"}, {"sha": "c096d3405389089bab4379161a1546094b1db479", "url": "https://api.github.com/repos/rust-lang/rust/commits/c096d3405389089bab4379161a1546094b1db479", "html_url": "https://github.com/rust-lang/rust/commit/c096d3405389089bab4379161a1546094b1db479"}], "stats": {"total": 72, "additions": 50, "deletions": 22}, "files": [{"sha": "60c47a93057647ff1989ea6aeb06f9a8c66f73cf", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d7ca7194c42c0fa27a60af7b185714c364504c8/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/0d7ca7194c42c0fa27a60af7b185714c364504c8/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=0d7ca7194c42c0fa27a60af7b185714c364504c8", "patch": "@@ -1 +1 @@\n-nightly-2018-09-15\n+nightly-2018-09-17"}, {"sha": "5ee82bf56adb3c8714ad8d57ffcd9bc554a3e04a", "filename": "src/intrinsic.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0d7ca7194c42c0fa27a60af7b185714c364504c8/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7ca7194c42c0fa27a60af7b185714c364504c8/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=0d7ca7194c42c0fa27a60af7b185714c364504c8", "patch": "@@ -145,21 +145,17 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 let elem_layout = self.layout_of(elem_ty)?;\n                 let elem_size = elem_layout.size.bytes();\n                 let count = self.read_scalar(args[2])?.to_usize(&self)?;\n-                if count * elem_size != 0 {\n-                    // TODO: We do not even validate alignment for the 0-bytes case.  libstd relies on this in vec::IntoIter::next.\n-                    // Also see the write_bytes intrinsic.\n-                    let elem_align = elem_layout.align;\n-                    let src = self.read_scalar(args[0])?.not_undef()?;\n-                    let dest = self.read_scalar(args[1])?.not_undef()?;\n-                    self.memory.copy(\n-                        src,\n-                        elem_align,\n-                        dest,\n-                        elem_align,\n-                        Size::from_bytes(count * elem_size),\n-                        intrinsic_name.ends_with(\"_nonoverlapping\"),\n-                    )?;\n-                }\n+                let elem_align = elem_layout.align;\n+                let src = self.read_scalar(args[0])?.not_undef()?;\n+                let dest = self.read_scalar(args[1])?.not_undef()?;\n+                self.memory.copy(\n+                    src,\n+                    elem_align,\n+                    dest,\n+                    elem_align,\n+                    Size::from_bytes(count * elem_size),\n+                    intrinsic_name.ends_with(\"_nonoverlapping\"),\n+                )?;\n             }\n \n             \"discriminant_value\" => {\n@@ -436,12 +432,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 let val_byte = self.read_scalar(args[1])?.to_u8()?;\n                 let ptr = self.read_scalar(args[0])?.not_undef()?;\n                 let count = self.read_scalar(args[2])?.to_usize(&self)?;\n-                if count > 0 {\n-                    // HashMap relies on write_bytes on a NULL ptr with count == 0 to work\n-                    // TODO: Should we, at least, validate the alignment? (Also see the copy intrinsic)\n-                    self.memory.check_align(ptr, ty_layout.align)?;\n-                    self.memory.write_repeat(ptr, val_byte, ty_layout.size * count)?;\n-                }\n+                self.memory.check_align(ptr, ty_layout.align)?;\n+                self.memory.write_repeat(ptr, val_byte, ty_layout.size * count)?;\n             }\n \n             name => return err!(Unimplemented(format!(\"unimplemented intrinsic: {}\", name))),"}, {"sha": "e46e327e6111e3914e9337b05bde112a5e26a144", "filename": "tests/compile-fail/copy_null.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0d7ca7194c42c0fa27a60af7b185714c364504c8/tests%2Fcompile-fail%2Fcopy_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7ca7194c42c0fa27a60af7b185714c364504c8/tests%2Fcompile-fail%2Fcopy_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcopy_null.rs?ref=0d7ca7194c42c0fa27a60af7b185714c364504c8", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//error-pattern: invalid use of NULL pointer\n+\n+fn main() {\n+    let mut data = [0u16; 4];\n+    let ptr = &mut data[0] as *mut u16;\n+    // Even copying 0 elements from NULL should error\n+    unsafe { ptr.copy_from(std::ptr::null(), 0); }\n+}"}, {"sha": "0f04dc68db90cace6adb5c5a806231b6dfc0558a", "filename": "tests/compile-fail/copy_unaligned.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0d7ca7194c42c0fa27a60af7b185714c364504c8/tests%2Fcompile-fail%2Fcopy_unaligned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7ca7194c42c0fa27a60af7b185714c364504c8/tests%2Fcompile-fail%2Fcopy_unaligned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcopy_unaligned.rs?ref=0d7ca7194c42c0fa27a60af7b185714c364504c8", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//error-pattern: tried to access memory with alignment 1, but alignment 2 is required\n+\n+fn main() {\n+    let mut data = [0u16; 8];\n+    let ptr = (&mut data[0] as *mut u16 as *mut u8).wrapping_add(1) as *mut u16;\n+    // Even copying 0 elements to something unaligned should error\n+    unsafe { ptr.copy_from(&data[5], 0); }\n+}"}]}