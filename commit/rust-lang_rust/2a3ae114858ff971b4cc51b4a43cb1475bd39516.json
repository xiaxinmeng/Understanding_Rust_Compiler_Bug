{"sha": "2a3ae114858ff971b4cc51b4a43cb1475bd39516", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhM2FlMTE0ODU4ZmY5NzFiNGNjNTFiNGE0M2NiMTQ3NWJkMzk1MTY=", "commit": {"author": {"name": "ThibsG", "email": "Thibs@debian.com", "date": "2020-10-23T07:24:25Z"}, "committer": {"name": "ThibsG", "email": "Thibs@debian.com", "date": "2020-10-26T10:02:07Z"}, "message": "Move fixable `map_unwrap_or` cases to rustfixed test", "tree": {"sha": "dce3984f69c328a175893b7a77c3a2902ab8a801", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dce3984f69c328a175893b7a77c3a2902ab8a801"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a3ae114858ff971b4cc51b4a43cb1475bd39516", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a3ae114858ff971b4cc51b4a43cb1475bd39516", "html_url": "https://github.com/rust-lang/rust/commit/2a3ae114858ff971b4cc51b4a43cb1475bd39516", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a3ae114858ff971b4cc51b4a43cb1475bd39516/comments", "author": {"login": "ThibsG", "id": 12683889, "node_id": "MDQ6VXNlcjEyNjgzODg5", "avatar_url": "https://avatars.githubusercontent.com/u/12683889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThibsG", "html_url": "https://github.com/ThibsG", "followers_url": "https://api.github.com/users/ThibsG/followers", "following_url": "https://api.github.com/users/ThibsG/following{/other_user}", "gists_url": "https://api.github.com/users/ThibsG/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThibsG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThibsG/subscriptions", "organizations_url": "https://api.github.com/users/ThibsG/orgs", "repos_url": "https://api.github.com/users/ThibsG/repos", "events_url": "https://api.github.com/users/ThibsG/events{/privacy}", "received_events_url": "https://api.github.com/users/ThibsG/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ThibsG", "id": 12683889, "node_id": "MDQ6VXNlcjEyNjgzODg5", "avatar_url": "https://avatars.githubusercontent.com/u/12683889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThibsG", "html_url": "https://github.com/ThibsG", "followers_url": "https://api.github.com/users/ThibsG/followers", "following_url": "https://api.github.com/users/ThibsG/following{/other_user}", "gists_url": "https://api.github.com/users/ThibsG/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThibsG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThibsG/subscriptions", "organizations_url": "https://api.github.com/users/ThibsG/orgs", "repos_url": "https://api.github.com/users/ThibsG/repos", "events_url": "https://api.github.com/users/ThibsG/events{/privacy}", "received_events_url": "https://api.github.com/users/ThibsG/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fec6f568daababf3520e2a818b4c1db79266b92", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fec6f568daababf3520e2a818b4c1db79266b92", "html_url": "https://github.com/rust-lang/rust/commit/3fec6f568daababf3520e2a818b4c1db79266b92"}], "stats": {"total": 264, "additions": 172, "deletions": 92}, "files": [{"sha": "4e977051ab7796e053c6370949c6ae849e8941bd", "filename": "tests/ui/map_unwrap_or.rs", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2a3ae114858ff971b4cc51b4a43cb1475bd39516/tests%2Fui%2Fmap_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3ae114858ff971b4cc51b4a43cb1475bd39516/tests%2Fui%2Fmap_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_unwrap_or.rs?ref=2a3ae114858ff971b4cc51b4a43cb1475bd39516", "patch": "@@ -1,4 +1,3 @@\n-// FIXME: Add \"run-rustfix\" once it's supported for multipart suggestions\n // aux-build:option_helpers.rs\n \n #![warn(clippy::map_unwrap_or)]\n@@ -13,10 +12,6 @@ fn option_methods() {\n     let opt = Some(1);\n \n     // Check for `option.map(_).unwrap_or(_)` use.\n-    // Single line case.\n-    let _ = opt.map(|x| x + 1)\n-        // Should lint even though this call is on a separate line.\n-        .unwrap_or(0);\n     // Multi-line cases.\n     let _ = opt.map(|x| {\n         x + 1\n@@ -47,10 +42,6 @@ fn option_methods() {\n     let _ = Some(\"prefix\").map(|p| format!(\"{}.\", p)).unwrap_or(id);\n \n     // Check for `option.map(_).unwrap_or_else(_)` use.\n-    // single line case\n-    let _ = opt.map(|x| x + 1)\n-        // Should lint even though this call is on a separate line.\n-        .unwrap_or_else(|| 0);\n     // Multi-line cases.\n     let _ = opt.map(|x| {\n         x + 1\n@@ -60,40 +51,8 @@ fn option_methods() {\n         .unwrap_or_else(||\n             0\n         );\n-    // Macro case.\n-    // Should not lint.\n-    let _ = opt_map!(opt, |x| x + 1).unwrap_or_else(|| 0);\n-\n-    // Issue #4144\n-    {\n-        let mut frequencies = HashMap::new();\n-        let word = \"foo\";\n-\n-        frequencies\n-            .get_mut(word)\n-            .map(|count| {\n-                *count += 1;\n-            })\n-            .unwrap_or_else(|| {\n-                frequencies.insert(word.to_owned(), 1);\n-            });\n-    }\n-}\n-\n-fn result_methods() {\n-    let res: Result<i32, ()> = Ok(1);\n-\n-    // Check for `result.map(_).unwrap_or_else(_)` use.\n-    // single line case\n-    let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0); // should lint even though this call is on a separate line\n-                                                      // multi line cases\n-    let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0);\n-    let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0);\n-    // macro case\n-    let _ = opt_map!(res, |x| x + 1).unwrap_or_else(|e| 0); // should not lint\n }\n \n fn main() {\n     option_methods();\n-    result_methods();\n }"}, {"sha": "3fd4bdfd2b93f18c76b164797d2ec6fcae866795", "filename": "tests/ui/map_unwrap_or.stderr", "status": "modified", "additions": 10, "deletions": 51, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/2a3ae114858ff971b4cc51b4a43cb1475bd39516/tests%2Fui%2Fmap_unwrap_or.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a3ae114858ff971b4cc51b4a43cb1475bd39516/tests%2Fui%2Fmap_unwrap_or.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_unwrap_or.stderr?ref=2a3ae114858ff971b4cc51b4a43cb1475bd39516", "patch": "@@ -1,20 +1,5 @@\n error: called `map(<f>).unwrap_or(<a>)` on an `Option` value. This can be done more directly by calling `map_or(<a>, <f>)` instead\n-  --> $DIR/map_unwrap_or.rs:17:13\n-   |\n-LL |       let _ = opt.map(|x| x + 1)\n-   |  _____________^\n-LL | |         // Should lint even though this call is on a separate line.\n-LL | |         .unwrap_or(0);\n-   | |_____________________^\n-   |\n-   = note: `-D clippy::map-unwrap-or` implied by `-D warnings`\n-help: use `map_or(<a>, <f>)` instead\n-   |\n-LL |     let _ = opt.map_or(0, |x| x + 1);\n-   |                 ^^^^^^ ^^          --\n-\n-error: called `map(<f>).unwrap_or(<a>)` on an `Option` value. This can be done more directly by calling `map_or(<a>, <f>)` instead\n-  --> $DIR/map_unwrap_or.rs:21:13\n+  --> $DIR/map_unwrap_or.rs:16:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -23,6 +8,7 @@ LL | |     }\n LL | |     ).unwrap_or(0);\n    | |__________________^\n    |\n+   = note: `-D clippy::map-unwrap-or` implied by `-D warnings`\n help: use `map_or(<a>, <f>)` instead\n    |\n LL |     let _ = opt.map_or(0, |x| {\n@@ -32,7 +18,7 @@ LL |     );\n    |\n \n error: called `map(<f>).unwrap_or(<a>)` on an `Option` value. This can be done more directly by calling `map_or(<a>, <f>)` instead\n-  --> $DIR/map_unwrap_or.rs:25:13\n+  --> $DIR/map_unwrap_or.rs:20:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -49,7 +35,7 @@ LL |         }, |x| x + 1);\n    |\n \n error: called `map(<f>).unwrap_or(None)` on an `Option` value. This can be done more directly by calling `and_then(<f>)` instead\n-  --> $DIR/map_unwrap_or.rs:30:13\n+  --> $DIR/map_unwrap_or.rs:25:13\n    |\n LL |     let _ = opt.map(|x| Some(x + 1)).unwrap_or(None);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -60,7 +46,7 @@ LL |     let _ = opt.and_then(|x| Some(x + 1));\n    |                 ^^^^^^^^                --\n \n error: called `map(<f>).unwrap_or(None)` on an `Option` value. This can be done more directly by calling `and_then(<f>)` instead\n-  --> $DIR/map_unwrap_or.rs:32:13\n+  --> $DIR/map_unwrap_or.rs:27:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -78,7 +64,7 @@ LL |     );\n    |\n \n error: called `map(<f>).unwrap_or(None)` on an `Option` value. This can be done more directly by calling `and_then(<f>)` instead\n-  --> $DIR/map_unwrap_or.rs:36:13\n+  --> $DIR/map_unwrap_or.rs:31:13\n    |\n LL |       let _ = opt\n    |  _____________^\n@@ -92,7 +78,7 @@ LL |         .and_then(|x| Some(x + 1));\n    |          ^^^^^^^^                --\n \n error: called `map(<f>).unwrap_or(<a>)` on an `Option` value. This can be done more directly by calling `map_or(<a>, <f>)` instead\n-  --> $DIR/map_unwrap_or.rs:47:13\n+  --> $DIR/map_unwrap_or.rs:42:13\n    |\n LL |     let _ = Some(\"prefix\").map(|p| format!(\"{}.\", p)).unwrap_or(id);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -103,16 +89,7 @@ LL |     let _ = Some(\"prefix\").map_or(id, |p| format!(\"{}.\", p));\n    |                            ^^^^^^ ^^^                      --\n \n error: called `map(<f>).unwrap_or_else(<g>)` on an `Option` value. This can be done more directly by calling `map_or_else(<g>, <f>)` instead\n-  --> $DIR/map_unwrap_or.rs:51:13\n-   |\n-LL |       let _ = opt.map(|x| x + 1)\n-   |  _____________^\n-LL | |         // Should lint even though this call is on a separate line.\n-LL | |         .unwrap_or_else(|| 0);\n-   | |_____________________________^ help: try this: `opt.map_or_else(|| 0, |x| x + 1)`\n-\n-error: called `map(<f>).unwrap_or_else(<g>)` on an `Option` value. This can be done more directly by calling `map_or_else(<g>, <f>)` instead\n-  --> $DIR/map_unwrap_or.rs:55:13\n+  --> $DIR/map_unwrap_or.rs:46:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -122,7 +99,7 @@ LL | |     ).unwrap_or_else(|| 0);\n    | |__________________________^\n \n error: called `map(<f>).unwrap_or_else(<g>)` on an `Option` value. This can be done more directly by calling `map_or_else(<g>, <f>)` instead\n-  --> $DIR/map_unwrap_or.rs:59:13\n+  --> $DIR/map_unwrap_or.rs:50:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -131,23 +108,5 @@ LL | |             0\n LL | |         );\n    | |_________^\n \n-error: called `map(<f>).unwrap_or_else(<g>)` on a `Result` value. This can be done more directly by calling `.map_or_else(<g>, <f>)` instead\n-  --> $DIR/map_unwrap_or.rs:88:13\n-   |\n-LL |     let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0); // should lint even though this call is on a separate line\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `res.map_or_else(|e| 0, |x| x + 1)`\n-\n-error: called `map(<f>).unwrap_or_else(<g>)` on a `Result` value. This can be done more directly by calling `.map_or_else(<g>, <f>)` instead\n-  --> $DIR/map_unwrap_or.rs:90:13\n-   |\n-LL |     let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `res.map_or_else(|e| 0, |x| x + 1)`\n-\n-error: called `map(<f>).unwrap_or_else(<g>)` on a `Result` value. This can be done more directly by calling `.map_or_else(<g>, <f>)` instead\n-  --> $DIR/map_unwrap_or.rs:91:13\n-   |\n-LL |     let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `res.map_or_else(|e| 0, |x| x + 1)`\n-\n-error: aborting due to 13 previous errors\n+error: aborting due to 8 previous errors\n "}, {"sha": "cb2492a3be082fc85120a048b96183e2aa376aa0", "filename": "tests/ui/map_unwrap_or_else_fixable.fixed", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/2a3ae114858ff971b4cc51b4a43cb1475bd39516/tests%2Fui%2Fmap_unwrap_or_else_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2a3ae114858ff971b4cc51b4a43cb1475bd39516/tests%2Fui%2Fmap_unwrap_or_else_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_unwrap_or_else_fixable.fixed?ref=2a3ae114858ff971b4cc51b4a43cb1475bd39516", "patch": "@@ -0,0 +1,59 @@\n+// run-rustfix\n+// aux-build:option_helpers.rs\n+\n+#![warn(clippy::map_unwrap_or)]\n+\n+#[macro_use]\n+extern crate option_helpers;\n+\n+use std::collections::HashMap;\n+\n+#[rustfmt::skip]\n+fn option_methods() {\n+    let opt = Some(1);\n+\n+    // Check for `option.map(_).unwrap_or_else(_)` use.\n+    // single line case\n+    let _ = opt.map_or_else(|| 0, |x| x + 1);\n+\n+    // Macro case.\n+    // Should not lint.\n+    let _ = opt_map!(opt, |x| x + 1).unwrap_or_else(|| 0);\n+\n+    // Check for `option.map(_).unwrap_or_else(_)` use.\n+    // single line case\n+    let _ = opt.map_or_else(|| 0, |x| x + 1);\n+\n+    // Issue #4144\n+    {\n+        let mut frequencies = HashMap::new();\n+        let word = \"foo\";\n+\n+        frequencies\n+            .get_mut(word)\n+            .map(|count| {\n+                *count += 1;\n+            })\n+            .unwrap_or_else(|| {\n+                frequencies.insert(word.to_owned(), 1);\n+            });\n+    }\n+}\n+\n+fn result_methods() {\n+    let res: Result<i32, ()> = Ok(1);\n+\n+    // Check for `result.map(_).unwrap_or_else(_)` use.\n+    // single line case\n+    let _ = res.map_or_else(|_e| 0, |x| x + 1); // should lint even though this call is on a separate line\n+                                                       // multi line cases\n+    let _ = res.map_or_else(|_e| 0, |x| x + 1);\n+    let _ = res.map_or_else(|_e| 0, |x| x + 1);\n+    // macro case\n+    let _ = opt_map!(res, |x| x + 1).unwrap_or_else(|_e| 0); // should not lint\n+}\n+\n+fn main() {\n+    option_methods();\n+    result_methods();\n+}"}, {"sha": "ed762dacd87c257b312cd1a0276b8cbb3de07a26", "filename": "tests/ui/map_unwrap_or_else_fixable.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2a3ae114858ff971b4cc51b4a43cb1475bd39516/tests%2Fui%2Fmap_unwrap_or_else_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3ae114858ff971b4cc51b4a43cb1475bd39516/tests%2Fui%2Fmap_unwrap_or_else_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_unwrap_or_else_fixable.rs?ref=2a3ae114858ff971b4cc51b4a43cb1475bd39516", "patch": "@@ -0,0 +1,63 @@\n+// run-rustfix\n+// aux-build:option_helpers.rs\n+\n+#![warn(clippy::map_unwrap_or)]\n+\n+#[macro_use]\n+extern crate option_helpers;\n+\n+use std::collections::HashMap;\n+\n+#[rustfmt::skip]\n+fn option_methods() {\n+    let opt = Some(1);\n+\n+    // Check for `option.map(_).unwrap_or_else(_)` use.\n+    // single line case\n+    let _ = opt.map(|x| x + 1)\n+        // Should lint even though this call is on a separate line.\n+        .unwrap_or_else(|| 0);\n+\n+    // Macro case.\n+    // Should not lint.\n+    let _ = opt_map!(opt, |x| x + 1).unwrap_or_else(|| 0);\n+\n+    // Check for `option.map(_).unwrap_or_else(_)` use.\n+    // single line case\n+    let _ = opt.map(|x| x + 1)\n+        // Should lint even though this call is on a separate line.\n+        .unwrap_or_else(|| 0);\n+\n+    // Issue #4144\n+    {\n+        let mut frequencies = HashMap::new();\n+        let word = \"foo\";\n+\n+        frequencies\n+            .get_mut(word)\n+            .map(|count| {\n+                *count += 1;\n+            })\n+            .unwrap_or_else(|| {\n+                frequencies.insert(word.to_owned(), 1);\n+            });\n+    }\n+}\n+\n+fn result_methods() {\n+    let res: Result<i32, ()> = Ok(1);\n+\n+    // Check for `result.map(_).unwrap_or_else(_)` use.\n+    // single line case\n+    let _ = res.map(|x| x + 1).unwrap_or_else(|_e| 0); // should lint even though this call is on a separate line\n+                                                       // multi line cases\n+    let _ = res.map(|x| x + 1).unwrap_or_else(|_e| 0);\n+    let _ = res.map(|x| x + 1).unwrap_or_else(|_e| 0);\n+    // macro case\n+    let _ = opt_map!(res, |x| x + 1).unwrap_or_else(|_e| 0); // should not lint\n+}\n+\n+fn main() {\n+    option_methods();\n+    result_methods();\n+}"}, {"sha": "2cb76d70684d10d01d1870ee514540e849298642", "filename": "tests/ui/map_unwrap_or_else_fixable.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2a3ae114858ff971b4cc51b4a43cb1475bd39516/tests%2Fui%2Fmap_unwrap_or_else_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a3ae114858ff971b4cc51b4a43cb1475bd39516/tests%2Fui%2Fmap_unwrap_or_else_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_unwrap_or_else_fixable.stderr?ref=2a3ae114858ff971b4cc51b4a43cb1475bd39516", "patch": "@@ -0,0 +1,40 @@\n+error: called `map(<f>).unwrap_or_else(<g>)` on an `Option` value. This can be done more directly by calling `map_or_else(<g>, <f>)` instead\n+  --> $DIR/map_unwrap_or_else_fixable.rs:17:13\n+   |\n+LL |       let _ = opt.map(|x| x + 1)\n+   |  _____________^\n+LL | |         // Should lint even though this call is on a separate line.\n+LL | |         .unwrap_or_else(|| 0);\n+   | |_____________________________^ help: try this: `opt.map_or_else(|| 0, |x| x + 1)`\n+   |\n+   = note: `-D clippy::map-unwrap-or` implied by `-D warnings`\n+\n+error: called `map(<f>).unwrap_or_else(<g>)` on an `Option` value. This can be done more directly by calling `map_or_else(<g>, <f>)` instead\n+  --> $DIR/map_unwrap_or_else_fixable.rs:27:13\n+   |\n+LL |       let _ = opt.map(|x| x + 1)\n+   |  _____________^\n+LL | |         // Should lint even though this call is on a separate line.\n+LL | |         .unwrap_or_else(|| 0);\n+   | |_____________________________^ help: try this: `opt.map_or_else(|| 0, |x| x + 1)`\n+\n+error: called `map(<f>).unwrap_or_else(<g>)` on a `Result` value. This can be done more directly by calling `.map_or_else(<g>, <f>)` instead\n+  --> $DIR/map_unwrap_or_else_fixable.rs:52:13\n+   |\n+LL |     let _ = res.map(|x| x + 1).unwrap_or_else(|_e| 0); // should lint even though this call is on a separate line\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `res.map_or_else(|_e| 0, |x| x + 1)`\n+\n+error: called `map(<f>).unwrap_or_else(<g>)` on a `Result` value. This can be done more directly by calling `.map_or_else(<g>, <f>)` instead\n+  --> $DIR/map_unwrap_or_else_fixable.rs:54:13\n+   |\n+LL |     let _ = res.map(|x| x + 1).unwrap_or_else(|_e| 0);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `res.map_or_else(|_e| 0, |x| x + 1)`\n+\n+error: called `map(<f>).unwrap_or_else(<g>)` on a `Result` value. This can be done more directly by calling `.map_or_else(<g>, <f>)` instead\n+  --> $DIR/map_unwrap_or_else_fixable.rs:55:13\n+   |\n+LL |     let _ = res.map(|x| x + 1).unwrap_or_else(|_e| 0);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `res.map_or_else(|_e| 0, |x| x + 1)`\n+\n+error: aborting due to 5 previous errors\n+"}]}