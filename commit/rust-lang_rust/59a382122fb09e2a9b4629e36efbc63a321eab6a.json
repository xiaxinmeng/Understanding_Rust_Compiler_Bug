{"sha": "59a382122fb09e2a9b4629e36efbc63a321eab6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5YTM4MjEyMmZiMDllMmE5YjQ2MjllMzZlZmJjNjNhMzIxZWFiNmE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-05-11T14:41:37Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-05-22T16:48:56Z"}, "message": "Simplify use of keyword symbols", "tree": {"sha": "4ebc598c88ba0ca2a11848b1cd2e142cd340ed15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ebc598c88ba0ca2a11848b1cd2e142cd340ed15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59a382122fb09e2a9b4629e36efbc63a321eab6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59a382122fb09e2a9b4629e36efbc63a321eab6a", "html_url": "https://github.com/rust-lang/rust/commit/59a382122fb09e2a9b4629e36efbc63a321eab6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59a382122fb09e2a9b4629e36efbc63a321eab6a/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37ff5d388f8c004ca248adb635f1cc84d347eda0", "url": "https://api.github.com/repos/rust-lang/rust/commits/37ff5d388f8c004ca248adb635f1cc84d347eda0", "html_url": "https://github.com/rust-lang/rust/commit/37ff5d388f8c004ca248adb635f1cc84d347eda0"}], "stats": {"total": 1038, "additions": 503, "deletions": 535}, "files": [{"sha": "7cf5b4a9021dfff43e4b75e498b27501148c2938", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -64,7 +64,7 @@ use syntax::ptr::P;\n use syntax::source_map::{respan, CompilerDesugaringKind, Spanned};\n use syntax::source_map::CompilerDesugaringKind::IfTemporary;\n use syntax::std_inject;\n-use syntax::symbol::{keywords, Symbol, sym};\n+use syntax::symbol::{kw, sym, Symbol};\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::parse::token::Token;\n use syntax::visit::{self, Visitor};\n@@ -927,11 +927,11 @@ impl<'a> LoweringContext<'a> {\n                 hir::LifetimeParamKind::InBand,\n             ),\n             ParamName::Fresh(_) => (\n-                keywords::UnderscoreLifetime.name().as_interned_str(),\n+                kw::UnderscoreLifetime.as_interned_str(),\n                 hir::LifetimeParamKind::Elided,\n             ),\n             ParamName::Error => (\n-                keywords::UnderscoreLifetime.name().as_interned_str(),\n+                kw::UnderscoreLifetime.as_interned_str(),\n                 hir::LifetimeParamKind::Error,\n             ),\n         };\n@@ -1415,7 +1415,7 @@ impl<'a> LoweringContext<'a> {\n                     P(hir::Path {\n                         res,\n                         segments: hir_vec![hir::PathSegment::from_ident(\n-                            keywords::SelfUpper.ident()\n+                            Ident::with_empty_ctxt(kw::SelfUpper)\n                         )],\n                         span: t.span,\n                     }),\n@@ -1614,7 +1614,7 @@ impl<'a> LoweringContext<'a> {\n         trace!(\"registering existential type with id {:#?}\", exist_ty_id);\n         let exist_ty_item = hir::Item {\n             hir_id: exist_ty_id,\n-            ident: keywords::Invalid.ident(),\n+            ident: Ident::with_empty_ctxt(kw::Invalid),\n             attrs: Default::default(),\n             node: exist_ty_item_kind,\n             vis: respan(span.shrink_to_lo(), hir::VisibilityKind::Inherited),\n@@ -1747,7 +1747,7 @@ impl<'a> LoweringContext<'a> {\n \n                     let (name, kind) = match name {\n                         hir::LifetimeName::Underscore => (\n-                            hir::ParamName::Plain(keywords::UnderscoreLifetime.ident()),\n+                            hir::ParamName::Plain(Ident::with_empty_ctxt(kw::UnderscoreLifetime)),\n                             hir::LifetimeParamKind::Elided,\n                         ),\n                         hir::LifetimeName::Param(param_name) => (\n@@ -2296,7 +2296,7 @@ impl<'a> LoweringContext<'a> {\n             .iter()\n             .map(|arg| match arg.pat.node {\n                 PatKind::Ident(_, ident, _) => ident,\n-                _ => Ident::new(keywords::Invalid.name(), arg.pat.span),\n+                _ => Ident::new(kw::Invalid, arg.pat.span),\n             })\n             .collect()\n     }\n@@ -2585,9 +2585,9 @@ impl<'a> LoweringContext<'a> {\n     fn lower_lifetime(&mut self, l: &Lifetime) -> hir::Lifetime {\n         let span = l.ident.span;\n         match l.ident {\n-            ident if ident.name == keywords::StaticLifetime.name() =>\n+            ident if ident.name == kw::StaticLifetime =>\n                 self.new_named_lifetime(l.id, span, hir::LifetimeName::Static),\n-            ident if ident.name == keywords::UnderscoreLifetime.name() =>\n+            ident if ident.name == kw::UnderscoreLifetime =>\n                 match self.anonymous_lifetime_mode {\n                     AnonymousLifetimeMode::CreateParameter => {\n                         let fresh_name = self.collect_fresh_in_band_lifetime(span);\n@@ -2709,7 +2709,7 @@ impl<'a> LoweringContext<'a> {\n                 // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n                 // `rustc::ty` expects `Self` to be only used for a trait's `Self`.\n                 // Instead, use `gensym(\"Self\")` to create a distinct name that looks the same.\n-                let ident = if param.ident.name == keywords::SelfUpper.name() {\n+                let ident = if param.ident.name == kw::SelfUpper {\n                     param.ident.gensym()\n                 } else {\n                     param.ident\n@@ -3325,7 +3325,7 @@ impl<'a> LoweringContext<'a> {\n \n                 // Correctly resolve `self` imports.\n                 if path.segments.len() > 1\n-                    && path.segments.last().unwrap().ident.name == keywords::SelfLower.name()\n+                    && path.segments.last().unwrap().ident.name == kw::SelfLower\n                 {\n                     let _ = path.segments.pop();\n                     if rename.is_none() {"}, {"sha": "77fd8cc062f33e389d41f037a4451bd3298b600d", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -5,7 +5,7 @@ use crate::session::CrateDisambiguator;\n use syntax::ast::*;\n use syntax::ext::hygiene::Mark;\n use syntax::visit;\n-use syntax::symbol::keywords;\n+use syntax::symbol::kw;\n use syntax::symbol::Symbol;\n use syntax::parse::token::{self, Token};\n use syntax_pos::Span;\n@@ -138,7 +138,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         // information we encapsulate into, the better\n         let def_data = match i.node {\n             ItemKind::Impl(..) => DefPathData::Impl,\n-            ItemKind::Mod(..) if i.ident == keywords::Invalid.ident() => {\n+            ItemKind::Mod(..) if i.ident == Ident::with_empty_ctxt(kw::Invalid) => {\n                 return visit::walk_item(self, i);\n             }\n             ItemKind::Mod(..) | ItemKind::Trait(..) | ItemKind::TraitAlias(..) |"}, {"sha": "e5ca97b82ab4826f5533a35eddea2469d4a8c040", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -519,7 +519,7 @@ impl<'hir> Map<'hir> {\n     pub fn ty_param_name(&self, id: HirId) -> Name {\n         match self.get_by_hir_id(id) {\n             Node::Item(&Item { node: ItemKind::Trait(..), .. }) |\n-            Node::Item(&Item { node: ItemKind::TraitAlias(..), .. }) => keywords::SelfUpper.name(),\n+            Node::Item(&Item { node: ItemKind::TraitAlias(..), .. }) => kw::SelfUpper,\n             Node::GenericParam(param) => param.name.ident().name,\n             _ => bug!(\"ty_param_name: {} not a type parameter\", self.hir_to_string(id)),\n         }"}, {"sha": "e5e6c408a0620ccb249cd82540fea4846bd41b52", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -24,7 +24,7 @@ use syntax::ast::{Attribute, Label, LitKind, StrStyle, FloatTy, IntTy, UintTy};\n use syntax::attr::{InlineAttr, OptimizeAttr};\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::ptr::P;\n-use syntax::symbol::{Symbol, keywords};\n+use syntax::symbol::{Symbol, kw};\n use syntax::tokenstream::TokenStream;\n use syntax::util::parser::ExprPrecedence;\n use crate::ty::AdtKind;\n@@ -160,7 +160,7 @@ pub struct Lifetime {\n     pub span: Span,\n \n     /// Either \"`'a`\", referring to a named lifetime definition,\n-    /// or \"``\" (i.e., `keywords::Invalid`), for elision placeholders.\n+    /// or \"``\" (i.e., `kw::Invalid`), for elision placeholders.\n     ///\n     /// HIR lowering inserts these placeholders in type paths that\n     /// refer to type definitions needing lifetime parameters,\n@@ -199,7 +199,8 @@ impl ParamName {\n     pub fn ident(&self) -> Ident {\n         match *self {\n             ParamName::Plain(ident) => ident,\n-            ParamName::Error | ParamName::Fresh(_) => keywords::UnderscoreLifetime.ident(),\n+            ParamName::Fresh(_) |\n+            ParamName::Error => Ident::with_empty_ctxt(kw::UnderscoreLifetime),\n         }\n     }\n \n@@ -233,10 +234,10 @@ pub enum LifetimeName {\n impl LifetimeName {\n     pub fn ident(&self) -> Ident {\n         match *self {\n-            LifetimeName::Implicit => keywords::Invalid.ident(),\n-            LifetimeName::Error => keywords::Invalid.ident(),\n-            LifetimeName::Underscore => keywords::UnderscoreLifetime.ident(),\n-            LifetimeName::Static => keywords::StaticLifetime.ident(),\n+            LifetimeName::Implicit => Ident::with_empty_ctxt(kw::Invalid),\n+            LifetimeName::Error => Ident::with_empty_ctxt(kw::Invalid),\n+            LifetimeName::Underscore => Ident::with_empty_ctxt(kw::UnderscoreLifetime),\n+            LifetimeName::Static => Ident::with_empty_ctxt(kw::StaticLifetime),\n             LifetimeName::Param(param_name) => param_name.ident(),\n         }\n     }\n@@ -305,7 +306,7 @@ pub struct Path {\n \n impl Path {\n     pub fn is_global(&self) -> bool {\n-        !self.segments.is_empty() && self.segments[0].ident.name == keywords::PathRoot.name()\n+        !self.segments.is_empty() && self.segments[0].ident.name == kw::PathRoot\n     }\n }\n "}, {"sha": "60511ecc883ce5aaf42d8bf447213596e48d218a", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -7,7 +7,7 @@ use syntax::print::pp::{self, Breaks};\n use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n use syntax::print::pprust::{self, PrintState};\n use syntax::ptr::P;\n-use syntax::symbol::keywords;\n+use syntax::symbol::kw;\n use syntax::util::parser::{self, AssocOp, Fixity};\n use syntax_pos::{self, BytePos, FileName};\n \n@@ -798,7 +798,7 @@ impl<'a> State<'a> {\n             hir::VisibilityKind::Restricted { ref path, .. } => {\n                 self.s.word(\"pub(\")?;\n                 if path.segments.len() == 1 &&\n-                   path.segments[0].ident.name == keywords::Super.name() {\n+                   path.segments[0].ident.name == kw::Super {\n                     // Special case: `super` can print like `pub(super)`.\n                     self.s.word(\"super\")?;\n                 } else {\n@@ -1559,7 +1559,7 @@ impl<'a> State<'a> {\n             if i > 0 {\n                 self.s.word(\"::\")?\n             }\n-            if segment.ident.name != keywords::PathRoot.name() {\n+            if segment.ident.name != kw::PathRoot {\n                self.print_ident(segment.ident)?;\n                segment.with_generic_args(|generic_args| {\n                    self.print_generic_args(generic_args, segment.infer_types,\n@@ -1572,7 +1572,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_path_segment(&mut self, segment: &hir::PathSegment) -> io::Result<()> {\n-        if segment.ident.name != keywords::PathRoot.name() {\n+        if segment.ident.name != kw::PathRoot {\n            self.print_ident(segment.ident)?;\n            segment.with_generic_args(|generic_args| {\n                self.print_generic_args(generic_args, segment.infer_types, false)\n@@ -1599,7 +1599,7 @@ impl<'a> State<'a> {\n                     if i > 0 {\n                         self.s.word(\"::\")?\n                     }\n-                    if segment.ident.name != keywords::PathRoot.name() {\n+                    if segment.ident.name != kw::PathRoot {\n                         self.print_ident(segment.ident)?;\n                         segment.with_generic_args(|generic_args| {\n                             self.print_generic_args(generic_args,"}, {"sha": "91a19852c6c0e06b290a48c98e8713f8aa52501c", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -112,7 +112,7 @@ use std::io;\n use std::rc::Rc;\n use syntax::ast::{self, NodeId};\n use syntax::ptr::P;\n-use syntax::symbol::{keywords, sym};\n+use syntax::symbol::{kw, sym};\n use syntax_pos::Span;\n \n use crate::hir;\n@@ -1552,7 +1552,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 let sp = ident.span;\n                 let var = self.variable(hir_id, sp);\n                 // Ignore unused self.\n-                if ident.name != keywords::SelfLower.name() {\n+                if ident.name != kw::SelfLower {\n                     if !self.warn_about_unused(vec![sp], hir_id, entry_ln, var) {\n                         if self.live_on_entry(entry_ln, var).is_none() {\n                             self.report_dead_assign(hir_id, sp, var, true);"}, {"sha": "6a4d2e0966b96e57a73ee4afdd1d33bc3abbb312", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -23,7 +23,7 @@ use std::mem::replace;\n use syntax::ast;\n use syntax::attr;\n use syntax::ptr::P;\n-use syntax::symbol::{keywords, sym};\n+use syntax::symbol::{kw, sym};\n use syntax_pos::Span;\n \n use crate::hir::intravisit::{self, NestedVisitorMap, Visitor};\n@@ -711,7 +711,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         GenericParamKind::Lifetime { .. } => {\n                             let (name, reg) = Region::early(&self.tcx.hir(), &mut index, &param);\n                             if let hir::ParamName::Plain(param_name) = name {\n-                                if param_name.name == keywords::UnderscoreLifetime.name() {\n+                                if param_name.name == kw::UnderscoreLifetime {\n                                     // Pick the elided lifetime \"definition\" if one exists\n                                     // and use it to make an elision scope.\n                                     elision = Some(reg);\n@@ -1602,7 +1602,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     } {\n                         debug!(\"id = {:?} span = {:?} name = {:?}\", id, span, name);\n \n-                        if name == keywords::UnderscoreLifetime.ident() {\n+                        if name == ast::Ident::with_empty_ctxt(kw::UnderscoreLifetime) {\n                             continue;\n                         }\n \n@@ -2525,8 +2525,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         for (i, (lifetime_i, lifetime_i_name)) in lifetimes.iter().enumerate() {\n             if let hir::ParamName::Plain(_) = lifetime_i_name {\n                 let name = lifetime_i_name.ident().name;\n-                if name == keywords::UnderscoreLifetime.name()\n-                    || name == keywords::StaticLifetime.name()\n+                if name == kw::UnderscoreLifetime\n+                    || name == kw::StaticLifetime\n                 {\n                     let mut err = struct_span_err!(\n                         self.tcx.sess,"}, {"sha": "b5a17684c0ff24a1d124a64fb04e172f43546a6f", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -74,7 +74,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::source_map::MultiSpan;\n use syntax::feature_gate;\n-use syntax::symbol::{Symbol, keywords, InternedString, sym};\n+use syntax::symbol::{Symbol, InternedString, kw, sym};\n use syntax_pos::Span;\n \n use crate::hir;\n@@ -2735,7 +2735,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     #[inline]\n     pub fn mk_self_type(self) -> Ty<'tcx> {\n-        self.mk_ty_param(0, keywords::SelfUpper.name().as_interned_str())\n+        self.mk_ty_param(0, kw::SelfUpper.as_interned_str())\n     }\n \n     pub fn mk_param_from_def(self, param: &ty::GenericParamDef) -> Kind<'tcx> {"}, {"sha": "a2c89489b95dcee2162a8bd0d6894a47c0425a6c", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -47,7 +47,7 @@ use std::ops::Range;\n use syntax::ast::{self, Name, Ident, NodeId};\n use syntax::attr;\n use syntax::ext::hygiene::Mark;\n-use syntax::symbol::{keywords, sym, Symbol, LocalInternedString, InternedString};\n+use syntax::symbol::{kw, sym, Symbol, LocalInternedString, InternedString};\n use syntax_pos::Span;\n \n use smallvec;\n@@ -835,7 +835,7 @@ impl ty::EarlyBoundRegion {\n     /// Does this early bound region have a name? Early bound regions normally\n     /// always have names except when using anonymous lifetimes (`'_`).\n     pub fn has_name(&self) -> bool {\n-        self.name != keywords::UnderscoreLifetime.name().as_interned_str()\n+        self.name != kw::UnderscoreLifetime.as_interned_str()\n     }\n }\n "}, {"sha": "5199da8fbbc5a048f90f948b6dd5e1612fbf6153", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -980,7 +980,7 @@ impl<F: fmt::Write> Printer<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F> {\n             if self.tcx.sess.rust_2018() {\n                 // We add the `crate::` keyword on Rust 2018, only when desired.\n                 if SHOULD_PREFIX_WITH_CRATE.with(|flag| flag.get()) {\n-                    write!(self, \"{}\", keywords::Crate.name())?;\n+                    write!(self, \"{}\", kw::Crate)?;\n                     self.empty_path = false;\n                 }\n             }"}, {"sha": "0b5a6fce5cb8759056f2ad85e2898efe1c95229a", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -22,7 +22,7 @@ use std::marker::PhantomData;\n use std::ops::Range;\n use rustc_target::spec::abi;\n use syntax::ast::{self, Ident};\n-use syntax::symbol::{keywords, InternedString};\n+use syntax::symbol::{kw, InternedString};\n \n use serialize;\n use self::InferTy::*;\n@@ -1121,7 +1121,7 @@ impl<'a, 'gcx, 'tcx> ParamTy {\n     }\n \n     pub fn for_self() -> ParamTy {\n-        ParamTy::new(0, keywords::SelfUpper.name().as_interned_str())\n+        ParamTy::new(0, kw::SelfUpper.as_interned_str())\n     }\n \n     pub fn for_def(def: &ty::GenericParamDef) -> ParamTy {\n@@ -1136,7 +1136,7 @@ impl<'a, 'gcx, 'tcx> ParamTy {\n         // FIXME(#50125): Ignoring `Self` with `index != 0` might lead to weird behavior elsewhere,\n         // but this should only be possible when using `-Z continue-parse-after-error` like\n         // `compile-fail/issue-36638.rs`.\n-        self.name.as_symbol() == keywords::SelfUpper.name() && self.index == 0\n+        self.name.as_symbol() == kw::SelfUpper && self.index == 0\n     }\n }\n "}, {"sha": "fed12c9a29fd2d9f8d31c3e71aaff2365576b58e", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -10,7 +10,7 @@ use crate::debuginfo::{self, VariableAccess, VariableKind, FunctionDebugContext}\n use crate::traits::*;\n \n use syntax_pos::{DUMMY_SP, NO_EXPANSION, BytePos, Span};\n-use syntax::symbol::keywords;\n+use syntax::symbol::kw;\n \n use std::iter;\n \n@@ -496,7 +496,7 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n                 };\n                 bx.declare_local(\n                     &fx.debug_context,\n-                    arg_decl.name.unwrap_or(keywords::Invalid.name()),\n+                    arg_decl.name.unwrap_or(kw::Invalid),\n                     arg_ty, scope,\n                     variable_access,\n                     VariableKind::ArgumentVariable(arg_index + 1),\n@@ -613,7 +613,7 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n \n                 bx.declare_local(\n                     &fx.debug_context,\n-                    arg_decl.name.unwrap_or(keywords::Invalid.name()),\n+                    arg_decl.name.unwrap_or(kw::Invalid),\n                     arg.layout.ty,\n                     scope,\n                     variable_access,"}, {"sha": "d52e497cf63d9a14d8b78885285f3614239e107a", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -42,7 +42,7 @@ use syntax::edition::Edition;\n use syntax::feature_gate::{AttributeGate, AttributeTemplate, AttributeType};\n use syntax::feature_gate::{Stability, deprecated_attributes};\n use syntax_pos::{BytePos, Span, SyntaxContext};\n-use syntax::symbol::{Symbol, keywords, sym};\n+use syntax::symbol::{Symbol, kw, sym};\n use syntax::errors::{Applicability, DiagnosticBuilder};\n use syntax::print::pprust::expr_to_string;\n use syntax::visit::FnKind;\n@@ -607,7 +607,7 @@ impl EarlyLintPass for AnonymousParameters {\n                 for arg in sig.decl.inputs.iter() {\n                     match arg.pat.node {\n                         ast::PatKind::Ident(_, ident, None) => {\n-                            if ident.name == keywords::Invalid.name() {\n+                            if ident.name == kw::Invalid {\n                                 let ty_snip = cx\n                                     .sess\n                                     .source_map()"}, {"sha": "34f7e04c1642038d1d2c1f28fc907ee662cb834f", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -12,7 +12,7 @@ use syntax::attr;\n use syntax::errors::Applicability;\n use syntax::feature_gate::{AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n use syntax::print::pprust;\n-use syntax::symbol::{keywords, sym};\n+use syntax::symbol::{kw, sym};\n use syntax::symbol::Symbol;\n use syntax::util::parser;\n use syntax_pos::Span;\n@@ -455,7 +455,7 @@ impl UnusedImportBraces {\n             match items[0].0.kind {\n                 ast::UseTreeKind::Simple(rename, ..) => {\n                     let orig_ident = items[0].0.prefix.segments.last().unwrap().ident;\n-                    if orig_ident.name == keywords::SelfLower.name() {\n+                    if orig_ident.name == kw::SelfLower {\n                         return;\n                     }\n                     node_ident = rename.unwrap_or(orig_ident);"}, {"sha": "3883682fa9df57f6ec88c4b113d44c634fec6708", "filename": "src/librustc_macros/src/symbols.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_macros%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_macros%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fsymbols.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -97,7 +97,6 @@ pub fn symbols(input: TokenStream) -> TokenStream {\n     let mut keyword_stream = quote! {};\n     let mut symbols_stream = quote! {};\n     let mut prefill_stream = quote! {};\n-    let mut from_str_stream = quote! {};\n     let mut counter = 0u32;\n     let mut keys = HashSet::<String>::new();\n \n@@ -115,12 +114,7 @@ pub fn symbols(input: TokenStream) -> TokenStream {\n             #value,\n         });\n         keyword_stream.extend(quote! {\n-            pub const #name: Keyword = Keyword {\n-                ident: Ident::with_empty_ctxt(super::Symbol::new(#counter))\n-            };\n-        });\n-        from_str_stream.extend(quote! {\n-            #value => Ok(#name),\n+            pub const #name: Symbol = Symbol::new(#counter);\n         });\n         counter += 1;\n     }\n@@ -145,17 +139,6 @@ pub fn symbols(input: TokenStream) -> TokenStream {\n         macro_rules! keywords {\n             () => {\n                 #keyword_stream\n-\n-                impl std::str::FromStr for Keyword {\n-                    type Err = ();\n-\n-                    fn from_str(s: &str) -> Result<Self, ()> {\n-                        match s {\n-                            #from_str_stream\n-                            _ => Err(()),\n-                        }\n-                    }\n-                }\n             }\n         }\n "}, {"sha": "dfc3439fc5539ce7c96d718478cd016bf08c6a0b", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -33,7 +33,7 @@ use std::u32;\n use syntax::ast;\n use syntax::attr;\n use syntax::source_map::Spanned;\n-use syntax::symbol::{keywords, sym};\n+use syntax::symbol::{kw, sym};\n use syntax_pos::{self, FileName, SourceFile, Span};\n use log::{debug, trace};\n \n@@ -1042,7 +1042,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             self.lazy_seq(body.arguments.iter().map(|arg| {\n                 match arg.pat.node {\n                     PatKind::Binding(_, _, ident, _) => ident.name,\n-                    _ => keywords::Invalid.name(),\n+                    _ => kw::Invalid,\n                 }\n             }))\n         })"}, {"sha": "4bee7f9c4bf8616745d81365454d9a82a7ef23b5", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -8,7 +8,7 @@ use rustc::mir::{Terminator, TerminatorKind};\n use rustc::ty::{self, Const, DefIdTree, Ty, TyS, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n use syntax_pos::Span;\n-use syntax_pos::symbol::keywords;\n+use syntax_pos::symbol::kw;\n \n use crate::dataflow::move_paths::InitLocation;\n use crate::borrow_check::MirBorrowckCtxt;\n@@ -256,7 +256,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                             // Deliberately fall into this case for all implicit self types,\n                             // so that we don't fall in to the next case with them.\n                             *kind == mir::ImplicitSelfKind::MutRef\n-                        } else if Some(keywords::SelfLower.name()) == local_decl.name {\n+                        } else if Some(kw::SelfLower) == local_decl.name {\n                             // Otherwise, check if the name is the self kewyord - in which case\n                             // we have an explicit self. Do the same thing in this case and check\n                             // for a `self: &mut Self` to suggest removing the `&mut`."}, {"sha": "18ca105070e8f9149b4c5342775cc914f7626184", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -15,7 +15,7 @@ use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_errors::{Diagnostic, DiagnosticBuilder};\n use std::collections::VecDeque;\n use syntax::errors::Applicability;\n-use syntax::symbol::keywords;\n+use syntax::symbol::kw;\n use syntax_pos::Span;\n \n mod region_name;\n@@ -631,7 +631,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     \"add_static_impl_trait_suggestion: has_static_predicate={:?}\",\n                     has_static_predicate\n                 );\n-                let static_str = keywords::StaticLifetime.name();\n+                let static_str = kw::StaticLifetime;\n                 // If there is a static predicate, then the only sensible suggestion is to replace\n                 // fr with `'static`.\n                 if has_static_predicate {"}, {"sha": "f3cfc1a59a9811dfa05376085cd5c7eb5b63fec6", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -12,7 +12,7 @@ use rustc::ty::subst::{SubstsRef, UnpackedKind};\n use rustc::ty::{self, RegionKind, RegionVid, Ty, TyCtxt};\n use rustc::ty::print::RegionHighlightMode;\n use rustc_errors::DiagnosticBuilder;\n-use syntax::symbol::keywords;\n+use syntax::symbol::kw;\n use syntax_pos::Span;\n use syntax_pos::symbol::InternedString;\n \n@@ -216,7 +216,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n \n             ty::ReStatic => Some(RegionName {\n-                name: keywords::StaticLifetime.name().as_interned_str(),\n+                name: kw::StaticLifetime.as_interned_str(),\n                 source: RegionNameSource::Static\n             }),\n "}, {"sha": "199b0176601e19fc01f0978000ce584ff84f2564", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -20,7 +20,7 @@ use std::mem;\n use std::u32;\n use rustc_target::spec::abi::Abi;\n use syntax::attr::{self, UnwindAttr};\n-use syntax::symbol::keywords;\n+use syntax::symbol::kw;\n use syntax_pos::Span;\n \n use super::lints;\n@@ -660,7 +660,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 ty::UpvarCapture::ByRef(..) => true,\n             };\n             let mut debuginfo = UpvarDebuginfo {\n-                debug_name: keywords::Invalid.name(),\n+                debug_name: kw::Invalid,\n                 by_ref,\n             };\n             let mut mutability = Mutability::Not;"}, {"sha": "3091570d14802b48b448f083969b20b964911fdd", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -15,7 +15,7 @@ use rustc_data_structures::fx::FxHashMap;\n use syntax::ast::*;\n use syntax::attr;\n use syntax::source_map::Spanned;\n-use syntax::symbol::{keywords, sym};\n+use syntax::symbol::{kw, sym};\n use syntax::ptr::P;\n use syntax::visit::{self, Visitor};\n use syntax::{span_err, struct_span_err, walk_list};\n@@ -177,9 +177,9 @@ impl<'a> AstValidator<'a> {\n     }\n \n     fn check_lifetime(&self, ident: Ident) {\n-        let valid_names = [keywords::UnderscoreLifetime.name(),\n-                           keywords::StaticLifetime.name(),\n-                           keywords::Invalid.name()];\n+        let valid_names = [kw::UnderscoreLifetime,\n+                           kw::StaticLifetime,\n+                           kw::Invalid];\n         if !valid_names.contains(&ident.name) && ident.without_first_quote().is_reserved() {\n             self.err_handler().span_err(ident.span, \"lifetimes cannot use keyword names\");\n         }"}, {"sha": "1df42a95042751d3160892ab931b3c8adf252253", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -27,7 +27,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast::Ident;\n use syntax::attr;\n-use syntax::symbol::{keywords, sym};\n+use syntax::symbol::{kw, sym};\n use syntax_pos::Span;\n \n use std::{cmp, fmt, mem};\n@@ -844,7 +844,7 @@ impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n                    span: Span, // span of the field pattern, e.g., `x: 0`\n                    def: &'tcx ty::AdtDef, // definition of the struct or enum\n                    field: &'tcx ty::FieldDef) { // definition of the field\n-        let ident = Ident::new(keywords::Invalid.name(), use_ctxt);\n+        let ident = Ident::new(kw::Invalid, use_ctxt);\n         let current_hir = self.current_item;\n         let def_id = self.tcx.adjust_ident(ident, def.did, current_hir).1;\n         if !def.is_enum() && !field.vis.is_accessible_from(def_id, self.tcx) {"}, {"sha": "782f36a77daccb80760eaada84e9f55f5e30703e", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -37,7 +37,7 @@ use syntax::feature_gate::is_builtin_attr;\n use syntax::parse::token::{self, Token};\n use syntax::span_err;\n use syntax::std_inject::injected_crate_name;\n-use syntax::symbol::{keywords, sym};\n+use syntax::symbol::{kw, sym};\n use syntax::visit::{self, Visitor};\n \n use syntax_pos::{Span, DUMMY_SP};\n@@ -143,15 +143,15 @@ impl<'a> Resolver<'a> {\n             }\n             _ => None,\n         }.map(|ctxt| Segment::from_ident(Ident::new(\n-            keywords::PathRoot.name(), use_tree.prefix.span.shrink_to_lo().with_ctxt(ctxt)\n+            kw::PathRoot, use_tree.prefix.span.shrink_to_lo().with_ctxt(ctxt)\n         )));\n \n         let prefix = crate_root.into_iter().chain(prefix_iter).collect::<Vec<_>>();\n         debug!(\"build_reduced_graph_for_use_tree: prefix={:?}\", prefix);\n \n         let empty_for_self = |prefix: &[Segment]| {\n             prefix.is_empty() ||\n-            prefix.len() == 1 && prefix[0].ident.name == keywords::PathRoot.name()\n+            prefix.len() == 1 && prefix[0].ident.name == kw::PathRoot\n         };\n         match use_tree.kind {\n             ast::UseTreeKind::Simple(rename, ..) => {\n@@ -162,7 +162,7 @@ impl<'a> Resolver<'a> {\n \n                 if nested {\n                     // Correctly handle `self`\n-                    if source.ident.name == keywords::SelfLower.name() {\n+                    if source.ident.name == kw::SelfLower {\n                         type_ns_only = true;\n \n                         if empty_for_self(&module_path) {\n@@ -183,14 +183,14 @@ impl<'a> Resolver<'a> {\n                     }\n                 } else {\n                     // Disallow `self`\n-                    if source.ident.name == keywords::SelfLower.name() {\n+                    if source.ident.name == kw::SelfLower {\n                         resolve_error(self,\n                                       use_tree.span,\n                                       ResolutionError::SelfImportsOnlyAllowedWithin);\n                     }\n \n                     // Disallow `use $crate;`\n-                    if source.ident.name == keywords::DollarCrate.name() && module_path.is_empty() {\n+                    if source.ident.name == kw::DollarCrate && module_path.is_empty() {\n                         let crate_root = self.resolve_crate_root(source.ident);\n                         let crate_name = match crate_root.kind {\n                             ModuleKind::Def(.., name) => name,\n@@ -199,11 +199,11 @@ impl<'a> Resolver<'a> {\n                         // HACK(eddyb) unclear how good this is, but keeping `$crate`\n                         // in `source` breaks `src/test/compile-fail/import-crate-var.rs`,\n                         // while the current crate doesn't have a valid `crate_name`.\n-                        if crate_name != keywords::Invalid.name() {\n+                        if crate_name != kw::Invalid {\n                             // `crate_name` should not be interpreted as relative.\n                             module_path.push(Segment {\n                                 ident: Ident {\n-                                    name: keywords::PathRoot.name(),\n+                                    name: kw::PathRoot,\n                                     span: source.ident.span,\n                                 },\n                                 id: Some(self.session.next_node_id()),\n@@ -221,7 +221,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n \n-                if ident.name == keywords::Crate.name() {\n+                if ident.name == kw::Crate {\n                     self.session.span_err(ident.span,\n                         \"crate root imports need to be explicitly named: \\\n                          `use crate as name;`\");\n@@ -276,7 +276,7 @@ impl<'a> Resolver<'a> {\n                 // Ensure there is at most one `self` in the list\n                 let self_spans = items.iter().filter_map(|&(ref use_tree, _)| {\n                     if let ast::UseTreeKind::Simple(..) = use_tree.kind {\n-                        if use_tree.ident().name == keywords::SelfLower.name() {\n+                        if use_tree.ident().name == kw::SelfLower {\n                             return Some(use_tree.span);\n                         }\n                     }\n@@ -311,7 +311,7 @@ impl<'a> Resolver<'a> {\n                     let new_span = prefix[prefix.len() - 1].ident.span;\n                     let tree = ast::UseTree {\n                         prefix: ast::Path::from_ident(\n-                            Ident::new(keywords::SelfLower.name(), new_span)\n+                            Ident::new(kw::SelfLower, new_span)\n                         ),\n                         kind: ast::UseTreeKind::Simple(\n                             Some(Ident::from_str_and_span(\"__dummy\", new_span).gensym()),\n@@ -350,7 +350,7 @@ impl<'a> Resolver<'a> {\n             }\n \n             ItemKind::ExternCrate(orig_name) => {\n-                let module = if orig_name.is_none() && ident.name == keywords::SelfLower.name() {\n+                let module = if orig_name.is_none() && ident.name == kw::SelfLower {\n                     self.session\n                         .struct_span_err(item.span, \"`extern crate self;` requires renaming\")\n                         .span_suggestion(\n@@ -361,7 +361,7 @@ impl<'a> Resolver<'a> {\n                         )\n                         .emit();\n                     return;\n-                } else if orig_name == Some(keywords::SelfLower.name()) {\n+                } else if orig_name == Some(kw::SelfLower) {\n                     self.graph_root\n                 } else {\n                     let crate_id = self.crate_loader.process_extern_crate(item, &self.definitions);\n@@ -420,7 +420,7 @@ impl<'a> Resolver<'a> {\n \n             ItemKind::GlobalAsm(..) => {}\n \n-            ItemKind::Mod(..) if ident == keywords::Invalid.ident() => {} // Crate root\n+            ItemKind::Mod(..) if ident == Ident::with_empty_ctxt(kw::Invalid) => {} // Crate root\n \n             ItemKind::Mod(..) => {\n                 let def_id = self.definitions.local_def_id(item.id);\n@@ -831,7 +831,7 @@ impl<'a> Resolver<'a> {\n                         \"an `extern crate` loading macros must be at the crate root\");\n                 }\n                 if let ItemKind::ExternCrate(Some(orig_name)) = item.node {\n-                    if orig_name == keywords::SelfLower.name() {\n+                    if orig_name == kw::SelfLower {\n                         self.session.span_err(attr.span,\n                             \"`macro_use` is not supported on `extern crate self`\");\n                     }"}, {"sha": "730927d2bb57030eb724dd552dd9ac8c85b67fcf", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -7,7 +7,7 @@ use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::session::{Session, config::nightly_options};\n use syntax::ast::{self, Expr, ExprKind, Ident};\n use syntax::ext::base::MacroKind;\n-use syntax::symbol::{Symbol, keywords};\n+use syntax::symbol::{Symbol, kw};\n use syntax_pos::{BytePos, Span};\n \n type Res = def::Res<ast::NodeId>;\n@@ -48,7 +48,7 @@ impl<'a> Resolver<'a> {\n             let item_span = path.last().unwrap().ident.span;\n             let (mod_prefix, mod_str) = if path.len() == 1 {\n                 (String::new(), \"this scope\".to_string())\n-            } else if path.len() == 2 && path[0].ident.name == keywords::PathRoot.name() {\n+            } else if path.len() == 2 && path[0].ident.name == kw::PathRoot {\n                 (String::new(), \"the crate root\".to_string())\n             } else {\n                 let mod_path = &path[..path.len() - 1];\n@@ -454,13 +454,13 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         match (path.get(0), path.get(1)) {\n             // `{{root}}::ident::...` on both editions.\n             // On 2015 `{{root}}` is usually added implicitly.\n-            (Some(fst), Some(snd)) if fst.ident.name == keywords::PathRoot.name() &&\n+            (Some(fst), Some(snd)) if fst.ident.name == kw::PathRoot &&\n                                       !snd.ident.is_path_segment_keyword() => {}\n             // `ident::...` on 2018.\n             (Some(fst), _) if fst.ident.span.rust_2018() &&\n                               !fst.ident.is_path_segment_keyword() => {\n                 // Insert a placeholder that's later replaced by `self`/`super`/etc.\n-                path.insert(0, Segment::from_ident(keywords::Invalid.ident()));\n+                path.insert(0, Segment::from_ident(Ident::with_empty_ctxt(kw::Invalid)));\n             }\n             _ => return None,\n         }\n@@ -485,7 +485,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         parent_scope: &ParentScope<'b>,\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `self` and check if that is valid.\n-        path[0].ident.name = keywords::SelfLower.name();\n+        path[0].ident.name = kw::SelfLower;\n         let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n@@ -509,7 +509,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         parent_scope: &ParentScope<'b>,\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n-        path[0].ident.name = keywords::Crate.name();\n+        path[0].ident.name = kw::Crate;\n         let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n@@ -540,7 +540,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         parent_scope: &ParentScope<'b>,\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n-        path[0].ident.name = keywords::Super.name();\n+        path[0].ident.name = kw::Super;\n         let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {"}, {"sha": "748cf691f8dd5d122cb788f99845cbbd2545c964", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -43,7 +43,7 @@ use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::base::MacroKind;\n-use syntax::symbol::{Symbol, keywords, sym};\n+use syntax::symbol::{Symbol, kw, sym};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use syntax::visit::{self, FnKind, Visitor};\n@@ -820,7 +820,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n                 self.smart_resolve_path(ty.id, qself.as_ref(), path, PathSource::Type);\n             }\n             TyKind::ImplicitSelf => {\n-                let self_ty = keywords::SelfUpper.ident();\n+                let self_ty = Ident::with_empty_ctxt(kw::SelfUpper);\n                 let res = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, Some(ty.id), ty.span)\n                               .map_or(Res::Err, |d| d.res());\n                 self.record_partial_res(ty.id, PartialRes::new(res));\n@@ -1817,18 +1817,17 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         is_value: bool\n     ) -> hir::Path {\n         let root = if crate_root.is_some() {\n-            keywords::PathRoot\n+            kw::PathRoot\n         } else {\n-            keywords::Crate\n+            kw::Crate\n         };\n-        let segments = iter::once(root.ident())\n+        let segments = iter::once(Ident::with_empty_ctxt(root))\n             .chain(\n                 crate_root.into_iter()\n                     .chain(components.iter().cloned())\n                     .map(Ident::with_empty_ctxt)\n             ).map(|i| self.new_ast_path_segment(i)).collect::<Vec<_>>();\n \n-\n         let path = ast::Path {\n             span,\n             segments,\n@@ -1866,7 +1865,7 @@ impl<'a> Resolver<'a> {\n         let path = if path_str.starts_with(\"::\") {\n             ast::Path {\n                 span,\n-                segments: iter::once(keywords::PathRoot.ident())\n+                segments: iter::once(Ident::with_empty_ctxt(kw::PathRoot))\n                     .chain({\n                         path_str.split(\"::\").skip(1).map(Ident::from_str)\n                     })\n@@ -1961,7 +1960,7 @@ impl<'a> Resolver<'a> {\n         let root_module_kind = ModuleKind::Def(\n             DefKind::Mod,\n             root_def_id,\n-            keywords::Invalid.name(),\n+            kw::Invalid,\n         );\n         let graph_root = arenas.alloc_module(ModuleData {\n             no_implicit_prelude: attr::contains_name(&krate.attrs, sym::no_implicit_prelude),\n@@ -2187,10 +2186,10 @@ impl<'a> Resolver<'a> {\n                                       path_span: Span)\n                                       -> Option<LexicalScopeBinding<'a>> {\n         assert!(ns == TypeNS  || ns == ValueNS);\n-        if ident.name == keywords::Invalid.name() {\n+        if ident.name == kw::Invalid {\n             return Some(LexicalScopeBinding::Res(Res::Err));\n         }\n-        ident.span = if ident.name == keywords::SelfUpper.name() {\n+        ident.span = if ident.name == kw::SelfUpper {\n             // FIXME(jseyfried) improve `Self` hygiene\n             ident.span.with_ctxt(SyntaxContext::empty())\n         } else if ns == TypeNS {\n@@ -2405,7 +2404,7 @@ impl<'a> Resolver<'a> {\n \n     fn resolve_crate_root(&mut self, ident: Ident) -> Module<'a> {\n         let mut ctxt = ident.span.ctxt();\n-        let mark = if ident.name == keywords::DollarCrate.name() {\n+        let mark = if ident.name == kw::DollarCrate {\n             // When resolving `$crate` from a `macro_rules!` invoked in a `macro`,\n             // we don't want to pretend that the `macro_rules!` definition is in the `macro`\n             // as described in `SyntaxContext::apply_mark`, so we ignore prepended modern marks.\n@@ -2851,7 +2850,7 @@ impl<'a> Resolver<'a> {\n         let mut self_type_rib = Rib::new(NormalRibKind);\n \n         // Plain insert (no renaming, since types are not currently hygienic)\n-        self_type_rib.bindings.insert(keywords::SelfUpper.ident(), self_res);\n+        self_type_rib.bindings.insert(Ident::with_empty_ctxt(kw::SelfUpper), self_res);\n         self.ribs[TypeNS].push(self_type_rib);\n         f(self);\n         self.ribs[TypeNS].pop();\n@@ -2862,7 +2861,7 @@ impl<'a> Resolver<'a> {\n     {\n         let self_res = Res::SelfCtor(impl_id);\n         let mut self_type_rib = Rib::new(NormalRibKind);\n-        self_type_rib.bindings.insert(keywords::SelfUpper.ident(), self_res);\n+        self_type_rib.bindings.insert(Ident::with_empty_ctxt(kw::SelfUpper), self_res);\n         self.ribs[ValueNS].push(self_type_rib);\n         f(self);\n         self.ribs[ValueNS].pop();\n@@ -3199,7 +3198,7 @@ impl<'a> Resolver<'a> {\n             }\n             None => {\n                 // A completely fresh binding, add to the lists if it's valid.\n-                if ident.name != keywords::Invalid.name() {\n+                if ident.name != kw::Invalid {\n                     bindings.insert(ident, outer_pat_id);\n                     self.ribs[ValueNS].last_mut().unwrap().bindings.insert(ident, res);\n                 }\n@@ -3494,13 +3493,13 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn self_type_is_available(&mut self, span: Span) -> bool {\n-        let binding = self.resolve_ident_in_lexical_scope(keywords::SelfUpper.ident(),\n+        let binding = self.resolve_ident_in_lexical_scope(Ident::with_empty_ctxt(kw::SelfUpper),\n                                                           TypeNS, None, span);\n         if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n     }\n \n     fn self_value_is_available(&mut self, self_span: Span, path_span: Span) -> bool {\n-        let ident = Ident::new(keywords::SelfLower.name(), self_span);\n+        let ident = Ident::new(kw::SelfLower, self_span);\n         let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None, path_span);\n         if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n     }\n@@ -3657,8 +3656,8 @@ impl<'a> Resolver<'a> {\n         };\n \n         if path.len() > 1 && !global_by_default && result.base_res() != Res::Err &&\n-           path[0].ident.name != keywords::PathRoot.name() &&\n-           path[0].ident.name != keywords::DollarCrate.name() {\n+           path[0].ident.name != kw::PathRoot &&\n+           path[0].ident.name != kw::DollarCrate {\n             let unqualified_result = {\n                 match self.resolve_path_without_parent_scope(\n                     &[*path.last().unwrap()],\n@@ -3739,11 +3738,11 @@ impl<'a> Resolver<'a> {\n             let name = ident.name;\n \n             allow_super &= ns == TypeNS &&\n-                (name == keywords::SelfLower.name() ||\n-                 name == keywords::Super.name());\n+                (name == kw::SelfLower ||\n+                 name == kw::Super);\n \n             if ns == TypeNS {\n-                if allow_super && name == keywords::Super.name() {\n+                if allow_super && name == kw::Super {\n                     let mut ctxt = ident.span.ctxt().modern();\n                     let self_module = match i {\n                         0 => Some(self.resolve_self(&mut ctxt, self.current_module)),\n@@ -3768,25 +3767,25 @@ impl<'a> Resolver<'a> {\n                     };\n                 }\n                 if i == 0 {\n-                    if name == keywords::SelfLower.name() {\n+                    if name == kw::SelfLower {\n                         let mut ctxt = ident.span.ctxt().modern();\n                         module = Some(ModuleOrUniformRoot::Module(\n                             self.resolve_self(&mut ctxt, self.current_module)));\n                         continue;\n                     }\n-                    if name == keywords::PathRoot.name() && ident.span.rust_2018() {\n+                    if name == kw::PathRoot && ident.span.rust_2018() {\n                         module = Some(ModuleOrUniformRoot::ExternPrelude);\n                         continue;\n                     }\n-                    if name == keywords::PathRoot.name() &&\n+                    if name == kw::PathRoot &&\n                        ident.span.rust_2015() && self.session.rust_2018() {\n                         // `::a::b` from 2015 macro on 2018 global edition\n                         module = Some(ModuleOrUniformRoot::CrateRootAndExternPrelude);\n                         continue;\n                     }\n-                    if name == keywords::PathRoot.name() ||\n-                       name == keywords::Crate.name() ||\n-                       name == keywords::DollarCrate.name() {\n+                    if name == kw::PathRoot ||\n+                       name == kw::Crate ||\n+                       name == kw::DollarCrate {\n                         // `::a::b`, `crate::a::b` or `$crate::a::b`\n                         module = Some(ModuleOrUniformRoot::Module(\n                             self.resolve_crate_root(ident)));\n@@ -3797,12 +3796,12 @@ impl<'a> Resolver<'a> {\n \n             // Report special messages for path segment keywords in wrong positions.\n             if ident.is_path_segment_keyword() && i != 0 {\n-                let name_str = if name == keywords::PathRoot.name() {\n+                let name_str = if name == kw::PathRoot {\n                     \"crate root\".to_string()\n                 } else {\n                     format!(\"`{}`\", name)\n                 };\n-                let label = if i == 1 && path[0].ident.name == keywords::PathRoot.name() {\n+                let label = if i == 1 && path[0].ident.name == kw::PathRoot {\n                     format!(\"global paths cannot start with {}\", name_str)\n                 } else {\n                     format!(\"{} in paths can only be used in start position\", name_str)\n@@ -3971,13 +3970,13 @@ impl<'a> Resolver<'a> {\n \n         // We're only interested in `use` paths which should start with\n         // `{{root}}` currently.\n-        if first_name != keywords::PathRoot.name() {\n+        if first_name != kw::PathRoot {\n             return\n         }\n \n         match path.get(1) {\n             // If this import looks like `crate::...` it's already good\n-            Some(Segment { ident, .. }) if ident.name == keywords::Crate.name() => return,\n+            Some(Segment { ident, .. }) if ident.name == kw::Crate => return,\n             // Otherwise go below to see if it's an extern crate\n             Some(_) => {}\n             // If the path has length one (and it's `PathRoot` most likely)\n@@ -4670,7 +4669,7 @@ impl<'a> Resolver<'a> {\n     {\n         let mut candidates = Vec::new();\n         let mut seen_modules = FxHashSet::default();\n-        let not_local_module = crate_name != keywords::Crate.ident();\n+        let not_local_module = crate_name != Ident::with_empty_ctxt(kw::Crate);\n         let mut worklist = vec![(start_module, Vec::<ast::PathSegment>::new(), not_local_module)];\n \n         while let Some((in_module,\n@@ -4764,7 +4763,8 @@ impl<'a> Resolver<'a> {\n         where FilterFn: Fn(Res) -> bool\n     {\n         let mut suggestions = self.lookup_import_candidates_from_module(\n-            lookup_ident, namespace, self.graph_root, keywords::Crate.ident(), &filter_fn);\n+            lookup_ident, namespace, self.graph_root, Ident::with_empty_ctxt(kw::Crate), &filter_fn\n+        );\n \n         if lookup_ident.span.rust_2018() {\n             let extern_prelude_names = self.extern_prelude.clone();\n@@ -4883,7 +4883,7 @@ impl<'a> Resolver<'a> {\n                 } else {\n                     let ctxt = ident.span.ctxt();\n                     Some(Segment::from_ident(Ident::new(\n-                        keywords::PathRoot.name(), path.span.shrink_to_lo().with_ctxt(ctxt)\n+                        kw::PathRoot, path.span.shrink_to_lo().with_ctxt(ctxt)\n                     )))\n                 };\n \n@@ -5352,17 +5352,17 @@ impl<'a> Resolver<'a> {\n }\n \n fn is_self_type(path: &[Segment], namespace: Namespace) -> bool {\n-    namespace == TypeNS && path.len() == 1 && path[0].ident.name == keywords::SelfUpper.name()\n+    namespace == TypeNS && path.len() == 1 && path[0].ident.name == kw::SelfUpper\n }\n \n fn is_self_value(path: &[Segment], namespace: Namespace) -> bool {\n-    namespace == ValueNS && path.len() == 1 && path[0].ident.name == keywords::SelfLower.name()\n+    namespace == ValueNS && path.len() == 1 && path[0].ident.name == kw::SelfLower\n }\n \n fn names_to_string(idents: &[Ident]) -> String {\n     let mut result = String::new();\n     for (i, ident) in idents.iter()\n-                            .filter(|ident| ident.name != keywords::PathRoot.name())\n+                            .filter(|ident| ident.name != kw::PathRoot)\n                             .enumerate() {\n         if i > 0 {\n             result.push_str(\"::\");"}, {"sha": "9bb607a2cc28f54c7e9c5204e1cb6ede42071ac4", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -22,7 +22,7 @@ use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{\n     feature_err, is_builtin_attr_name, AttributeGate, GateIssue, Stability, BUILTIN_ATTRIBUTES,\n };\n-use syntax::symbol::{Symbol, keywords, sym};\n+use syntax::symbol::{Symbol, kw, sym};\n use syntax::visit::Visitor;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -137,10 +137,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n         }\n         impl<'a> Visitor<'a> for ResolveDollarCrates<'a, '_> {\n             fn visit_ident(&mut self, ident: Ident) {\n-                if ident.name == keywords::DollarCrate.name() {\n+                if ident.name == kw::DollarCrate {\n                     let name = match self.resolver.resolve_crate_root(ident).kind {\n-                        ModuleKind::Def(.., name) if name != keywords::Invalid.name() => name,\n-                        _ => keywords::Crate.name(),\n+                        ModuleKind::Def(.., name) if name != kw::Invalid => name,\n+                        _ => kw::Crate,\n                     };\n                     ident.span.ctxt().set_dollar_crate_name(name);\n                 }\n@@ -415,7 +415,7 @@ impl<'a> Resolver<'a> {\n         if kind == MacroKind::Bang && path.len() == 1 &&\n            path[0].ident.span.ctxt().outer().expn_info()\n                .map_or(false, |info| info.local_inner_macros) {\n-            let root = Ident::new(keywords::DollarCrate.name(), path[0].ident.span);\n+            let root = Ident::new(kw::DollarCrate, path[0].ident.span);\n             path.insert(0, Segment::from_ident(root));\n         }\n \n@@ -613,7 +613,7 @@ impl<'a> Resolver<'a> {\n                     _ => Err(Determinacy::Determined),\n                 }\n                 WhereToResolve::CrateRoot => {\n-                    let root_ident = Ident::new(keywords::PathRoot.name(), orig_ident.span);\n+                    let root_ident = Ident::new(kw::PathRoot, orig_ident.span);\n                     let root_module = self.resolve_crate_root(root_ident);\n                     let binding = self.resolve_ident_in_module_ext(\n                         ModuleOrUniformRoot::Module(root_module),"}, {"sha": "ab873ea270127d2d385fdd674fa879012ae4c9ed", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -29,7 +29,7 @@ use rustc::{bug, span_bug};\n use syntax::ast::{self, Ident, Name, NodeId, CRATE_NODE_ID};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::hygiene::Mark;\n-use syntax::symbol::{keywords, sym};\n+use syntax::symbol::{kw, sym};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::{struct_span_err, unwrap_or};\n use syntax_pos::{MultiSpan, Span};\n@@ -217,15 +217,15 @@ impl<'a> Resolver<'a> {\n                     parent_scope.expect(\"no parent scope for a single-segment import\");\n \n                 if ns == TypeNS {\n-                    if ident.name == keywords::Crate.name() ||\n-                        ident.name == keywords::DollarCrate.name() {\n+                    if ident.name == kw::Crate ||\n+                        ident.name == kw::DollarCrate {\n                         let module = self.resolve_crate_root(ident);\n                         let binding = (module, ty::Visibility::Public,\n                                         module.span, Mark::root())\n                                         .to_name_binding(self.arenas);\n                         return Ok(binding);\n-                    } else if ident.name == keywords::Super.name() ||\n-                                ident.name == keywords::SelfLower.name() {\n+                    } else if ident.name == kw::Super ||\n+                                ident.name == kw::SelfLower {\n                         // FIXME: Implement these with renaming requirements so that e.g.\n                         // `use super;` doesn't work, but `use super as name;` does.\n                         // Fall through here to get an error from `early_resolve_...`.\n@@ -992,7 +992,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n                     // 2 segments, so the `resolve_path` above won't trigger it.\n                     let mut full_path = directive.module_path.clone();\n-                    full_path.push(Segment::from_ident(keywords::Invalid.ident()));\n+                    full_path.push(Segment::from_ident(Ident::with_empty_ctxt(kw::Invalid)));\n                     self.lint_if_path_starts_with_module(\n                         directive.crate_lint(),\n                         &full_path,\n@@ -1484,8 +1484,8 @@ fn import_path_to_string(names: &[Ident],\n                          subclass: &ImportDirectiveSubclass<'_>,\n                          span: Span) -> String {\n     let pos = names.iter()\n-        .position(|p| span == p.span && p.name != keywords::PathRoot.name());\n-    let global = !names.is_empty() && names[0].name == keywords::PathRoot.name();\n+        .position(|p| span == p.span && p.name != kw::PathRoot);\n+    let global = !names.is_empty() && names[0].name == kw::PathRoot;\n     if let Some(pos) = pos {\n         let names = if global { &names[1..pos + 1] } else { &names[..pos + 1] };\n         names_to_string(names)"}, {"sha": "a20a91b3e6f6d88e522c8b6fd24edb5ad5660bcb", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -123,7 +123,7 @@ use syntax::attr;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::ptr::P;\n use syntax::source_map::{DUMMY_SP, original_sp};\n-use syntax::symbol::{Symbol, LocalInternedString, keywords, sym};\n+use syntax::symbol::{Symbol, LocalInternedString, kw, sym};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use std::cell::{Cell, RefCell, Ref, RefMut};\n@@ -3290,7 +3290,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 Ok(method)\n             }\n             Err(error) => {\n-                if segment.ident.name != keywords::Invalid.name() {\n+                if segment.ident.name != kw::Invalid {\n                     self.report_method_error(span,\n                                              rcvr_t,\n                                              segment.ident,\n@@ -3402,7 +3402,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             err.emit();\n             field_ty\n-        } else if field.name == keywords::Invalid.name() {\n+        } else if field.name == kw::Invalid {\n             self.tcx().types.err\n         } else if self.method_exists(field, expr_t, expr.hir_id, true) {\n             let mut err = type_error_struct!(self.tcx().sess, field.span, expr_t, E0615,\n@@ -4672,7 +4672,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 method::MethodError::PrivateMatch(kind, def_id, _) => Ok((kind, def_id)),\n                 _ => Err(ErrorReported),\n             };\n-            if item_name.name != keywords::Invalid.name() {\n+            if item_name.name != kw::Invalid {\n                 self.report_method_error(\n                     span,\n                     ty,"}, {"sha": "2a4d8f304b59266adf1f2652054320270e621966", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -39,7 +39,7 @@ use syntax::ast::{Ident, MetaItemKind};\n use syntax::attr::{InlineAttr, OptimizeAttr, list_contains_name, mark_used};\n use syntax::source_map::Spanned;\n use syntax::feature_gate;\n-use syntax::symbol::{InternedString, keywords, Symbol, sym};\n+use syntax::symbol::{InternedString, kw, Symbol, sym};\n use syntax_pos::{Span, DUMMY_SP};\n \n use rustc::hir::def::{CtorKind, Res, DefKind};\n@@ -939,7 +939,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n \n                     opt_self = Some(ty::GenericParamDef {\n                         index: 0,\n-                        name: keywords::SelfUpper.name().as_interned_str(),\n+                        name: kw::SelfUpper.as_interned_str(),\n                         def_id: tcx.hir().local_def_id_from_hir_id(param_id),\n                         pure_wrt_drop: false,\n                         kind: ty::GenericParamDefKind::Type {\n@@ -1008,7 +1008,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n                         synthetic,\n                         ..\n                     } => {\n-                        if param.name.ident().name == keywords::SelfUpper.name() {\n+                        if param.name.ident().name == kw::SelfUpper {\n                             span_bug!(\n                                 param.span,\n                                 \"`Self` should not be the name of a regular parameter\"\n@@ -1038,7 +1038,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n                         }\n                     }\n                     GenericParamKind::Const { .. } => {\n-                        if param.name.ident().name == keywords::SelfUpper.name() {\n+                        if param.name.ident().name == kw::SelfUpper {\n                             span_bug!(\n                                 param.span,\n                                 \"`Self` should not be the name of a regular parameter\","}, {"sha": "1bbbe581c3ce15c259b9f127027a83f8251eeafa", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -31,8 +31,7 @@ use syntax::attr;\n use syntax::ext::base::MacroKind;\n use syntax::source_map::{dummy_spanned, Spanned};\n use syntax::ptr::P;\n-use syntax::symbol::keywords::{self, Keyword};\n-use syntax::symbol::{Symbol, sym};\n+use syntax::symbol::{Symbol, kw, sym};\n use syntax::symbol::InternedString;\n use syntax_pos::{self, Pos, FileName};\n \n@@ -43,7 +42,6 @@ use std::default::Default;\n use std::{mem, slice, vec};\n use std::iter::{FromIterator, once};\n use std::rc::Rc;\n-use std::str::FromStr;\n use std::cell::RefCell;\n use std::sync::Arc;\n use std::u32;\n@@ -309,10 +307,9 @@ impl Clean<ExternalCrate> for CrateNum {\n                 for attr in attrs.lists(sym::doc) {\n                     if let Some(v) = attr.value_str() {\n                         if attr.check_name(sym::keyword) {\n-                            keyword = Keyword::from_str(&v.as_str()).ok()\n-                                                                    .map(|x| x.name().to_string());\n-                            if keyword.is_some() {\n-                                break\n+                            if v.is_doc_keyword() {\n+                                keyword = Some(v.to_string());\n+                                break;\n                             }\n                             // FIXME: should warn on unknown keywords?\n                         }\n@@ -1702,7 +1699,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n         let stripped_typarams = gens.params.iter().filter_map(|param| match param.kind {\n             ty::GenericParamDefKind::Lifetime => None,\n             ty::GenericParamDefKind::Type { .. } => {\n-                if param.name.as_symbol() == keywords::SelfUpper.name() {\n+                if param.name.as_symbol() == kw::SelfUpper {\n                     assert_eq!(param.index, 0);\n                     return None;\n                 }\n@@ -3596,7 +3593,7 @@ fn qpath_to_string(p: &hir::QPath) -> String {\n         if i > 0 {\n             s.push_str(\"::\");\n         }\n-        if seg.ident.name != keywords::PathRoot.name() {\n+        if seg.ident.name != kw::PathRoot {\n             s.push_str(&*seg.ident.as_str());\n         }\n     }\n@@ -4176,7 +4173,7 @@ fn resolve_type(cx: &DocContext<'_>,\n             hir::Float(float_ty) => return Primitive(float_ty.into()),\n         },\n         Res::SelfTy(..) if path.segments.len() == 1 => {\n-            return Generic(keywords::SelfUpper.name().to_string());\n+            return Generic(kw::SelfUpper.to_string());\n         }\n         Res::Def(DefKind::TyParam, _) if path.segments.len() == 1 => {\n             return Generic(format!(\"{:#}\", path));"}, {"sha": "71d8665f3b3055b8a56740ddca17c40ef7242b4b", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -44,7 +44,7 @@ pub fn render<T: fmt::Display, S: fmt::Display>(\n     <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">\\\n     <meta name=\\\"generator\\\" content=\\\"rustdoc\\\">\\\n     <meta name=\\\"description\\\" content=\\\"{description}\\\">\\\n-    <meta name=\\\"keywords\\\" content=\\\"{keywords}\\\">\\\n+    <meta name=\\\"keywords\\\" content=\\\"{kw}\\\">\\\n     <title>{title}</title>\\\n     <link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{static_root_path}normalize{suffix}.css\\\">\\\n     <link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{static_root_path}rustdoc{suffix}.css\\\" \\"}, {"sha": "0df00e7f4416df0471a260fe4c27f40aea1648b0", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -10,7 +10,7 @@ use crate::parse::token;\n use crate::print::pprust;\n use crate::ptr::P;\n use crate::source_map::{dummy_spanned, respan, Spanned};\n-use crate::symbol::{keywords, Symbol};\n+use crate::symbol::{kw, Symbol};\n use crate::tokenstream::TokenStream;\n use crate::ThinVec;\n \n@@ -65,7 +65,7 @@ impl fmt::Debug for Lifetime {\n pub struct Path {\n     pub span: Span,\n     /// The segments in the path: the things separated by `::`.\n-    /// Global paths begin with `keywords::PathRoot`.\n+    /// Global paths begin with `kw::PathRoot`.\n     pub segments: Vec<PathSegment>,\n }\n \n@@ -100,7 +100,7 @@ impl Path {\n     }\n \n     pub fn is_global(&self) -> bool {\n-        !self.segments.is_empty() && self.segments[0].ident.name == keywords::PathRoot.name()\n+        !self.segments.is_empty() && self.segments[0].ident.name == kw::PathRoot\n     }\n }\n \n@@ -128,7 +128,7 @@ impl PathSegment {\n         PathSegment { ident, id: DUMMY_NODE_ID, args: None }\n     }\n     pub fn path_root(span: Span) -> Self {\n-        PathSegment::from_ident(Ident::new(keywords::PathRoot.name(), span))\n+        PathSegment::from_ident(Ident::new(kw::PathRoot, span))\n     }\n }\n \n@@ -1782,7 +1782,7 @@ pub type ExplicitSelf = Spanned<SelfKind>;\n impl Arg {\n     pub fn to_self(&self) -> Option<ExplicitSelf> {\n         if let PatKind::Ident(BindingMode::ByValue(mutbl), ident, _) = self.pat.node {\n-            if ident.name == keywords::SelfLower.name() {\n+            if ident.name == kw::SelfLower {\n                 return match self.ty.node {\n                     TyKind::ImplicitSelf => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n                     TyKind::Rptr(lt, MutTy { ref ty, mutbl }) if ty.node.is_implicit_self() => {\n@@ -1800,7 +1800,7 @@ impl Arg {\n \n     pub fn is_self(&self) -> bool {\n         if let PatKind::Ident(_, ident, _) = self.pat.node {\n-            ident.name == keywords::SelfLower.name()\n+            ident.name == kw::SelfLower\n         } else {\n             false\n         }"}, {"sha": "3e93ac23a531b6bb6963c22052fb6a23aaa21cee", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -22,7 +22,7 @@ use crate::parse::parser::Parser;\n use crate::parse::{self, ParseSess, PResult};\n use crate::parse::token::{self, Token};\n use crate::ptr::P;\n-use crate::symbol::{keywords, Symbol, sym};\n+use crate::symbol::{kw, sym, Symbol};\n use crate::ThinVec;\n use crate::tokenstream::{TokenStream, TokenTree, DelimSpan};\n use crate::GLOBALS;\n@@ -90,7 +90,7 @@ impl NestedMetaItem {\n         self.meta_item().and_then(|meta_item| meta_item.ident())\n     }\n     pub fn name_or_empty(&self) -> Symbol {\n-        self.ident().unwrap_or(keywords::Invalid.ident()).name\n+        self.ident().unwrap_or(Ident::invalid()).name\n     }\n \n     /// Gets the string value if self is a MetaItem and the MetaItem is a\n@@ -168,7 +168,7 @@ impl Attribute {\n         }\n     }\n     pub fn name_or_empty(&self) -> Symbol {\n-        self.ident().unwrap_or(keywords::Invalid.ident()).name\n+        self.ident().unwrap_or(Ident::invalid()).name\n     }\n \n     pub fn value_str(&self) -> Option<Symbol> {\n@@ -206,7 +206,7 @@ impl MetaItem {\n         }\n     }\n     pub fn name_or_empty(&self) -> Symbol {\n-        self.ident().unwrap_or(keywords::Invalid.ident()).name\n+        self.ident().unwrap_or(Ident.invalid()).name\n     }\n \n     // #[attribute(name = \"value\")]"}, {"sha": "e9476e2fdfd51c27ccda0d44ecb27eb7068c5c27", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -7,7 +7,7 @@ use crate::ext::base::{ExtCtxt, MacEager, MacResult};\n use crate::ext::build::AstBuilder;\n use crate::parse::token;\n use crate::ptr::P;\n-use crate::symbol::keywords;\n+use crate::symbol::kw;\n use crate::tokenstream::{TokenTree};\n \n use smallvec::smallvec;\n@@ -185,7 +185,7 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt<'_>,\n             (descriptions.len(), ecx.expr_vec(span, descriptions))\n         });\n \n-    let static_ = ecx.lifetime(span, keywords::StaticLifetime.ident());\n+    let static_ = ecx.lifetime(span, Ident::with_empty_ctxt(kw::StaticLifetime));\n     let ty_str = ecx.ty_rptr(\n         span,\n         ecx.ty_ident(span, ecx.ident_of(\"str\")),"}, {"sha": "f1a20d54065743fd4de8578406d75aa0f6b64662", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -10,7 +10,7 @@ use crate::mut_visit::{self, MutVisitor};\n use crate::parse::{self, parser, DirectoryOwnership};\n use crate::parse::token;\n use crate::ptr::P;\n-use crate::symbol::{keywords, Ident, Symbol, sym};\n+use crate::symbol::{kw, sym, Ident, Symbol};\n use crate::ThinVec;\n use crate::tokenstream::{self, TokenStream};\n \n@@ -971,7 +971,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n     pub fn std_path(&self, components: &[&str]) -> Vec<ast::Ident> {\n         let def_site = DUMMY_SP.apply_mark(self.current_expansion.mark);\n-        iter::once(Ident::new(keywords::DollarCrate.name(), def_site))\n+        iter::once(Ident::new(kw::DollarCrate, def_site))\n             .chain(components.iter().map(|s| self.ident_of(s)))\n             .collect()\n     }"}, {"sha": "77d5fa238f2143ffebd5ec130526bef5a51e983e", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -3,7 +3,7 @@ use crate::attr;\n use crate::source_map::{dummy_spanned, respan, Spanned};\n use crate::ext::base::ExtCtxt;\n use crate::ptr::P;\n-use crate::symbol::{Symbol, keywords};\n+use crate::symbol::{Symbol, kw};\n use crate::ThinVec;\n \n use rustc_target::spec::abi::Abi;\n@@ -628,7 +628,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr_path(self.path_ident(span, id))\n     }\n     fn expr_self(&self, span: Span) -> P<ast::Expr> {\n-        self.expr_ident(span, keywords::SelfLower.ident())\n+        self.expr_ident(span, Ident::with_empty_ctxt(kw::SelfLower))\n     }\n \n     fn expr_binary(&self, sp: Span, op: ast::BinOpKind,\n@@ -1175,7 +1175,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 vis: ast::Visibility, vp: P<ast::UseTree>) -> P<ast::Item> {\n         P(ast::Item {\n             id: ast::DUMMY_NODE_ID,\n-            ident: keywords::Invalid.ident(),\n+            ident: Ident::with_empty_ctxt(kw::Invalid),\n             attrs: vec![],\n             node: ast::ItemKind::Use(vp),\n             vis,"}, {"sha": "5f9c84c61265325fd5ba081243e9abf56814248b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -14,7 +14,7 @@ use crate::parse::token::{self, Token};\n use crate::parse::parser::Parser;\n use crate::ptr::P;\n use crate::symbol::Symbol;\n-use crate::symbol::{keywords, sym};\n+use crate::symbol::{kw, sym};\n use crate::tokenstream::{TokenStream, TokenTree};\n use crate::visit::{self, Visitor};\n use crate::util::map_in_place::MapInPlace;\n@@ -198,7 +198,7 @@ fn macro_bang_format(path: &ast::Path) -> ExpnFormat {\n         if i != 0 {\n             path_str.push_str(\"::\");\n         }\n-        if segment.ident.name != keywords::PathRoot.name() {\n+        if segment.ident.name != kw::PathRoot {\n             path_str.push_str(&segment.ident.as_str())\n         }\n     }\n@@ -271,7 +271,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             attrs: krate.attrs,\n             span: krate.span,\n             node: ast::ItemKind::Mod(krate.module),\n-            ident: keywords::Invalid.ident(),\n+            ident: Ident::with_empty_ctxt(kw::Invalid),\n             id: ast::DUMMY_NODE_ID,\n             vis: respan(krate.span.shrink_to_lo(), ast::VisibilityKind::Public),\n             tokens: None,\n@@ -708,7 +708,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         };\n         let path = &mac.node.path;\n \n-        let ident = ident.unwrap_or_else(|| keywords::Invalid.ident());\n+        let ident = ident.unwrap_or_else(|| Ident::with_empty_ctxt(kw::Invalid));\n         let validate_and_set_expn_info = |this: &mut Self, // arg instead of capture\n                                           def_site_span: Option<Span>,\n                                           allow_internal_unstable,\n@@ -736,7 +736,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n             }\n \n-            if ident.name != keywords::Invalid.name() {\n+            if ident.name != kw::Invalid {\n                 let msg = format!(\"macro {}! expects no ident argument, given '{}'\", path, ident);\n                 this.cx.span_err(path.span, &msg);\n                 this.cx.trace_macros_diag();\n@@ -792,7 +792,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             }\n \n             IdentTT { ref expander, span: tt_span, ref allow_internal_unstable } => {\n-                if ident.name == keywords::Invalid.name() {\n+                if ident.name == kw::Invalid {\n                     self.cx.span_err(path.span,\n                                     &format!(\"macro {}! expects an ident argument\", path));\n                     self.cx.trace_macros_diag();\n@@ -828,7 +828,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             }\n \n             SyntaxExtension::ProcMacro { ref expander, ref allow_internal_unstable, edition } => {\n-                if ident.name != keywords::Invalid.name() {\n+                if ident.name != kw::Invalid {\n                     let msg =\n                         format!(\"macro {}! expects no ident argument, given '{}'\", path, ident);\n                     self.cx.span_err(path.span, &msg);\n@@ -929,7 +929,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 invoc.expansion_data.mark.set_expn_info(expn_info);\n                 let span = span.with_ctxt(self.cx.backtrace());\n                 let dummy = ast::MetaItem { // FIXME(jseyfried) avoid this\n-                    path: Path::from_ident(keywords::Invalid.ident()),\n+                    path: Path::from_ident(Ident::with_empty_ctxt(kw::Invalid)),\n                     span: DUMMY_SP,\n                     node: ast::MetaItemKind::Word,\n                 };\n@@ -1338,7 +1338,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 })\n             }\n             ast::ItemKind::Mod(ast::Mod { inner, .. }) => {\n-                if item.ident == keywords::Invalid.ident() {\n+                if item.ident == Ident::with_empty_ctxt(kw::Invalid) {\n                     return noop_flat_map_item(item, self);\n                 }\n "}, {"sha": "9ba1ff0ec7ea8252aceec8ead003039adc4d4bfc", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -6,7 +6,7 @@ use crate::ext::hygiene::Mark;\n use crate::tokenstream::TokenStream;\n use crate::mut_visit::*;\n use crate::ptr::P;\n-use crate::symbol::keywords;\n+use crate::symbol::kw;\n use crate::ThinVec;\n \n use smallvec::{smallvec, SmallVec};\n@@ -22,7 +22,7 @@ pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId) -> AstFragment {\n         })\n     }\n \n-    let ident = keywords::Invalid.ident();\n+    let ident = ast::Ident::with_empty_ctxt(kw::Invalid);\n     let attrs = Vec::new();\n     let generics = ast::Generics::default();\n     let vis = dummy_spanned(ast::VisibilityKind::Inherited);"}, {"sha": "fa1f85c0e7b572a3f4cd903c7bec7acb95afea40", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -80,7 +80,7 @@ use crate::parse::{Directory, ParseSess};\n use crate::parse::parser::{Parser, PathStyle};\n use crate::parse::token::{self, DocComment, Nonterminal, Token};\n use crate::print::pprust;\n-use crate::symbol::keywords;\n+use crate::symbol::kw;\n use crate::tokenstream::{DelimSpan, TokenStream};\n \n use errors::FatalError;\n@@ -382,7 +382,7 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n             TokenTree::Delimited(_, ref delim) => for next_m in &delim.tts {\n                 n_rec(sess, next_m, res.by_ref(), ret_val)?;\n             },\n-            TokenTree::MetaVarDecl(span, _, id) if id.name == keywords::Invalid.name() => {\n+            TokenTree::MetaVarDecl(span, _, id) if id.name == kw::Invalid => {\n                 if sess.missing_fragment_specifiers.borrow_mut().remove(&span) {\n                     return Err((span, \"missing fragment specifier\".to_string()));\n                 }\n@@ -587,7 +587,7 @@ fn inner_parse_loop<'root, 'tt>(\n                 }\n \n                 // We need to match a metavar (but the identifier is invalid)... this is an error\n-                TokenTree::MetaVarDecl(span, _, id) if id.name == keywords::Invalid.name() => {\n+                TokenTree::MetaVarDecl(span, _, id) if id.name == kw::Invalid => {\n                     if sess.missing_fragment_specifiers.borrow_mut().remove(&span) {\n                         return Error(span, \"missing fragment specifier\".to_string());\n                     }\n@@ -802,7 +802,7 @@ pub fn parse(\n /// We prohibit passing `_` to macros expecting `ident` for now.\n fn get_macro_ident(token: &Token) -> Option<(Ident, bool)> {\n     match *token {\n-        token::Ident(ident, is_raw) if ident.name != keywords::Underscore.name() =>\n+        token::Ident(ident, is_raw) if ident.name != kw::Underscore =>\n             Some((ident, is_raw)),\n         _ => None,\n     }"}, {"sha": "8adee4be75fbeb0e572c109003666fa3bcf8eaa2", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -1107,7 +1107,7 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n                     _ => IsInFollow::No(tokens),\n                 }\n             },\n-            \"\" => IsInFollow::Yes, // keywords::Invalid\n+            \"\" => IsInFollow::Yes, // kw::Invalid\n             _ => IsInFollow::Invalid(format!(\"invalid fragment specifier `{}`\", frag),\n                                      VALID_FRAGMENT_NAMES_MSG),\n         }"}, {"sha": "2f1a983467440e231701ac9b8173dc2fd71f5f2a", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -6,7 +6,7 @@ use crate::parse::{token, ParseSess};\n use crate::print::pprust;\n use crate::tokenstream::{self, DelimSpan};\n use crate::ast;\n-use crate::symbol::keywords;\n+use crate::symbol::kw;\n \n use syntax_pos::{edition::Edition, BytePos, Span};\n \n@@ -228,7 +228,7 @@ pub fn parse(\n                 result.push(TokenTree::MetaVarDecl(\n                     span,\n                     ident,\n-                    keywords::Invalid.ident(),\n+                    ast::Ident::with_empty_ctxt(kw::Invalid),\n                 ));\n             }\n \n@@ -319,8 +319,8 @@ where\n             Some(tokenstream::TokenTree::Token(ident_span, ref token)) if token.is_ident() => {\n                 let (ident, is_raw) = token.ident().unwrap();\n                 let span = ident_span.with_lo(span.lo());\n-                if ident.name == keywords::Crate.name() && !is_raw {\n-                    let ident = ast::Ident::new(keywords::DollarCrate.name(), ident.span);\n+                if ident.name == kw::Crate && !is_raw {\n+                    let ident = ast::Ident::new(kw::DollarCrate, ident.span);\n                     TokenTree::Token(span, token::Ident(ident, is_raw))\n                 } else {\n                     TokenTree::MetaVar(span, ident)\n@@ -334,7 +334,7 @@ where\n                     pprust::token_to_string(&tok)\n                 );\n                 sess.span_diagnostic.span_err(span, &msg);\n-                TokenTree::MetaVar(span, keywords::Invalid.ident())\n+                TokenTree::MetaVar(span, ast::Ident::with_empty_ctxt(kw::Invalid))\n             }\n \n             // There are no more tokens. Just return the `$` we already have."}, {"sha": "8dae4756c82c3d2afa611b59baa7dd56051ff861", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -11,7 +11,7 @@ use crate::ast::*;\n use crate::source_map::{Spanned, respan};\n use crate::parse::token::{self, Token};\n use crate::ptr::P;\n-use crate::symbol::keywords;\n+use crate::symbol::kw;\n use crate::ThinVec;\n use crate::tokenstream::*;\n use crate::util::map_in_place::MapInPlace;\n@@ -977,7 +977,7 @@ pub fn noop_visit_mod<T: MutVisitor>(Mod { inner, items, inline: _ }: &mut Mod,\n pub fn noop_visit_crate<T: MutVisitor>(krate: &mut Crate, vis: &mut T) {\n     visit_clobber(krate, |Crate { module, attrs, span }| {\n         let item = P(Item {\n-            ident: keywords::Invalid.ident(),\n+            ident: Ident::with_empty_ctxt(kw::Invalid),\n             attrs,\n             id: DUMMY_NODE_ID,\n             vis: respan(span.shrink_to_lo(), VisibilityKind::Public),"}, {"sha": "6db1a6694936eada73cb98b76d855a6b4493e27f", "filename": "src/libsyntax/parse/literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fparse%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fparse%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fliteral.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -6,7 +6,7 @@ use crate::parse::PResult;\n use crate::parse::token::{self, Token};\n use crate::parse::unescape::{unescape_str, unescape_char, unescape_byte_str, unescape_byte};\n use crate::print::pprust;\n-use crate::symbol::{keywords, Symbol};\n+use crate::symbol::{kw, Symbol};\n use crate::tokenstream::{TokenStream, TokenTree};\n \n use errors::{Applicability, Handler};"}, {"sha": "0099dd3d3c8ecfa80f8028f339c605b8a7f9ae73", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 209, "deletions": 206, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -46,7 +46,7 @@ use crate::ptr::P;\n use crate::parse::PResult;\n use crate::ThinVec;\n use crate::tokenstream::{self, DelimSpan, TokenTree, TokenStream, TreeAndJoint};\n-use crate::symbol::{keywords, sym, Symbol};\n+use crate::symbol::{kw, sym, Symbol};\n \n use errors::{Applicability, DiagnosticBuilder, DiagnosticId, FatalError};\n use rustc_target::spec::abi::{self, Abi};\n@@ -379,7 +379,7 @@ impl TokenCursor {\n #[derive(Clone, PartialEq)]\n crate enum TokenType {\n     Token(token::Token),\n-    Keyword(keywords::Keyword),\n+    Keyword(Symbol),\n     Operator,\n     Lifetime,\n     Ident,\n@@ -392,7 +392,7 @@ impl TokenType {\n     crate fn to_string(&self) -> String {\n         match *self {\n             TokenType::Token(ref t) => format!(\"`{}`\", pprust::token_to_string(t)),\n-            TokenType::Keyword(kw) => format!(\"`{}`\", kw.name()),\n+            TokenType::Keyword(kw) => format!(\"`{}`\", kw),\n             TokenType::Operator => \"an operator\".to_string(),\n             TokenType::Lifetime => \"lifetime\".to_string(),\n             TokenType::Ident => \"identifier\".to_string(),\n@@ -510,7 +510,7 @@ impl From<P<Expr>> for LhsExpr {\n \n /// Creates a placeholder argument.\n fn dummy_arg(span: Span) -> Arg {\n-    let ident = Ident::new(keywords::Invalid.name(), span);\n+    let ident = Ident::new(kw::Invalid, span);\n     let pat = P(Pat {\n         id: ast::DUMMY_NODE_ID,\n         node: PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), ident, None),\n@@ -771,15 +771,15 @@ impl<'a> Parser<'a> {\n                 TokenType::Token(token::Semi) => true, // we expect a `;` here\n                 _ => false,\n             }) && ( // a `;` would be expected before the current keyword\n-                self.token.is_keyword(keywords::Break) ||\n-                self.token.is_keyword(keywords::Continue) ||\n-                self.token.is_keyword(keywords::For) ||\n-                self.token.is_keyword(keywords::If) ||\n-                self.token.is_keyword(keywords::Let) ||\n-                self.token.is_keyword(keywords::Loop) ||\n-                self.token.is_keyword(keywords::Match) ||\n-                self.token.is_keyword(keywords::Return) ||\n-                self.token.is_keyword(keywords::While)\n+                self.token.is_keyword(kw::Break) ||\n+                self.token.is_keyword(kw::Continue) ||\n+                self.token.is_keyword(kw::For) ||\n+                self.token.is_keyword(kw::If) ||\n+                self.token.is_keyword(kw::Let) ||\n+                self.token.is_keyword(kw::Loop) ||\n+                self.token.is_keyword(kw::Match) ||\n+                self.token.is_keyword(kw::Return) ||\n+                self.token.is_keyword(kw::While)\n             );\n             let cm = self.sess.source_map();\n             match (cm.lookup_line(self.span.lo()), cm.lookup_line(sp.lo())) {\n@@ -913,14 +913,14 @@ impl<'a> Parser<'a> {\n         is_present\n     }\n \n-    fn check_keyword(&mut self, kw: keywords::Keyword) -> bool {\n+    fn check_keyword(&mut self, kw: Symbol) -> bool {\n         self.expected_tokens.push(TokenType::Keyword(kw));\n         self.token.is_keyword(kw)\n     }\n \n     /// If the next token is the given keyword, eats it and returns\n     /// `true`. Otherwise, returns `false`.\n-    pub fn eat_keyword(&mut self, kw: keywords::Keyword) -> bool {\n+    pub fn eat_keyword(&mut self, kw: Symbol) -> bool {\n         if self.check_keyword(kw) {\n             self.bump();\n             true\n@@ -929,7 +929,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn eat_keyword_noexpect(&mut self, kw: keywords::Keyword) -> bool {\n+    fn eat_keyword_noexpect(&mut self, kw: Symbol) -> bool {\n         if self.token.is_keyword(kw) {\n             self.bump();\n             true\n@@ -941,7 +941,7 @@ impl<'a> Parser<'a> {\n     /// If the given word is not a keyword, signals an error.\n     /// If the next token is not the given word, signals an error.\n     /// Otherwise, eats it.\n-    fn expect_keyword(&mut self, kw: keywords::Keyword) -> PResult<'a, ()> {\n+    fn expect_keyword(&mut self, kw: Symbol) -> PResult<'a, ()> {\n         if !self.eat_keyword(kw) {\n             self.unexpected()\n         } else {\n@@ -1375,9 +1375,9 @@ impl<'a> Parser<'a> {\n \n     /// Is the current token one of the keywords that signals a bare function type?\n     fn token_is_bare_fn_keyword(&mut self) -> bool {\n-        self.check_keyword(keywords::Fn) ||\n-            self.check_keyword(keywords::Unsafe) ||\n-            self.check_keyword(keywords::Extern)\n+        self.check_keyword(kw::Fn) ||\n+            self.check_keyword(kw::Unsafe) ||\n+            self.check_keyword(kw::Extern)\n     }\n \n     /// Parses a `TyKind::BareFn` type.\n@@ -1395,13 +1395,13 @@ impl<'a> Parser<'a> {\n         */\n \n         let unsafety = self.parse_unsafety();\n-        let abi = if self.eat_keyword(keywords::Extern) {\n+        let abi = if self.eat_keyword(kw::Extern) {\n             self.parse_opt_abi()?.unwrap_or(Abi::C)\n         } else {\n             Abi::Rust\n         };\n \n-        self.expect_keyword(keywords::Fn)?;\n+        self.expect_keyword(kw::Fn)?;\n         let (inputs, c_variadic) = self.parse_fn_args(false, true)?;\n         let ret_ty = self.parse_ret_ty(false)?;\n         let decl = P(FnDecl {\n@@ -1419,7 +1419,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses asyncness: `async` or nothing.\n     fn parse_asyncness(&mut self) -> IsAsync {\n-        if self.eat_keyword(keywords::Async) {\n+        if self.eat_keyword(kw::Async) {\n             IsAsync::Async {\n                 closure_id: ast::DUMMY_NODE_ID,\n                 return_impl_trait_id: ast::DUMMY_NODE_ID,\n@@ -1432,7 +1432,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses unsafety: `unsafe` or nothing.\n     fn parse_unsafety(&mut self) -> Unsafety {\n-        if self.eat_keyword(keywords::Unsafe) {\n+        if self.eat_keyword(kw::Unsafe) {\n             Unsafety::Unsafe\n         } else {\n             Unsafety::Normal\n@@ -1462,10 +1462,10 @@ impl<'a> Parser<'a> {\n                          mut attrs: Vec<Attribute>) -> PResult<'a, TraitItem> {\n         let lo = self.span;\n         self.eat_bad_pub();\n-        let (name, node, generics) = if self.eat_keyword(keywords::Type) {\n+        let (name, node, generics) = if self.eat_keyword(kw::Type) {\n             self.parse_trait_item_assoc_ty()?\n         } else if self.is_const_item() {\n-            self.expect_keyword(keywords::Const)?;\n+            self.expect_keyword(kw::Const)?;\n             let ident = self.parse_ident()?;\n             self.expect(&token::Colon)?;\n             let ty = self.parse_ty()?;\n@@ -1480,7 +1480,9 @@ impl<'a> Parser<'a> {\n             (ident, TraitItemKind::Const(ty, default), ast::Generics::default())\n         } else if let Some(mac) = self.parse_assoc_macro_invoc(\"trait\", None, &mut false)? {\n             // trait item macro.\n-            (keywords::Invalid.ident(), ast::TraitItemKind::Macro(mac), ast::Generics::default())\n+            (Ident::with_empty_ctxt(kw::Invalid),\n+             ast::TraitItemKind::Macro(mac),\n+             ast::Generics::default())\n         } else {\n             let (constness, unsafety, mut asyncness, abi) = self.parse_fn_front_matter()?;\n \n@@ -1654,7 +1656,7 @@ impl<'a> Parser<'a> {\n             // Reference\n             self.expect_and()?;\n             self.parse_borrowed_pointee()?\n-        } else if self.eat_keyword_noexpect(keywords::Typeof) {\n+        } else if self.eat_keyword_noexpect(kw::Typeof) {\n             // `typeof(EXPR)`\n             // In order to not be ambiguous, the type must be surrounded by parens.\n             self.expect(&token::OpenDelim(token::Paren))?;\n@@ -1664,13 +1666,13 @@ impl<'a> Parser<'a> {\n             };\n             self.expect(&token::CloseDelim(token::Paren))?;\n             TyKind::Typeof(e)\n-        } else if self.eat_keyword(keywords::Underscore) {\n+        } else if self.eat_keyword(kw::Underscore) {\n             // A type to be inferred `_`\n             TyKind::Infer\n         } else if self.token_is_bare_fn_keyword() {\n             // Function pointer type\n             self.parse_ty_bare_fn(Vec::new())?\n-        } else if self.check_keyword(keywords::For) {\n+        } else if self.check_keyword(kw::For) {\n             // Function pointer type or bound list (trait object type) starting with a poly-trait.\n             //   `for<'lt> [unsafe] [extern \"ABI\"] fn (&'lt S) -> T`\n             //   `for<'lt> Trait1<'lt> + Trait2 + 'a`\n@@ -1683,12 +1685,12 @@ impl<'a> Parser<'a> {\n                 let parse_plus = allow_plus && self.check_plus();\n                 self.parse_remaining_bounds(lifetime_defs, path, lo, parse_plus)?\n             }\n-        } else if self.eat_keyword(keywords::Impl) {\n+        } else if self.eat_keyword(kw::Impl) {\n             // Always parse bounds greedily for better error recovery.\n             let bounds = self.parse_generic_bounds(None)?;\n             impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n             TyKind::ImplTrait(ast::DUMMY_NODE_ID, bounds)\n-        } else if self.check_keyword(keywords::Dyn) &&\n+        } else if self.check_keyword(kw::Dyn) &&\n                   (self.span.rust_2018() ||\n                    self.look_ahead(1, |t| t.can_begin_bound() &&\n                                           !can_continue_type_after_non_fn_ident(t))) {\n@@ -1766,9 +1768,9 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_ptr(&mut self) -> PResult<'a, MutTy> {\n-        let mutbl = if self.eat_keyword(keywords::Mut) {\n+        let mutbl = if self.eat_keyword(kw::Mut) {\n             Mutability::Mutable\n-        } else if self.eat_keyword(keywords::Const) {\n+        } else if self.eat_keyword(kw::Const) {\n             Mutability::Immutable\n         } else {\n             let span = self.prev_span;\n@@ -1790,7 +1792,7 @@ impl<'a> Parser<'a> {\n                 _ => 0,\n             }\n             token::BinOp(token::And) | token::AndAnd => 1,\n-            _ if self.token.is_keyword(keywords::Mut) => 1,\n+            _ if self.token.is_keyword(kw::Mut) => 1,\n             _ => 0,\n         };\n \n@@ -1891,7 +1893,7 @@ impl<'a> Parser<'a> {\n             }\n             match ty {\n                 Ok(ty) => {\n-                    let ident = Ident::new(keywords::Invalid.name(), self.prev_span);\n+                    let ident = Ident::new(kw::Invalid, self.prev_span);\n                     let pat = P(Pat {\n                         id: ast::DUMMY_NODE_ID,\n                         node: PatKind::Ident(\n@@ -2006,7 +2008,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_ident_or_underscore(&mut self) -> PResult<'a, ast::Ident> {\n         match self.token {\n-            token::Ident(ident, false) if ident.name == keywords::Underscore.name() => {\n+            token::Ident(ident, false) if ident.name == kw::Underscore => {\n                 let span = self.span;\n                 self.bump();\n                 Ok(Ident::new(ident.name, span))\n@@ -2034,7 +2036,7 @@ impl<'a> Parser<'a> {\n         // above). `path_span` has the span of that path, or an empty\n         // span in the case of something like `<T>::Bar`.\n         let (mut path, path_span);\n-        if self.eat_keyword(keywords::As) {\n+        if self.eat_keyword(kw::As) {\n             let path_lo = self.span;\n             path = self.parse_path(PathStyle::Type)?;\n             path_span = path_lo.to(self.prev_span);\n@@ -2233,7 +2235,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses mutability (`mut` or nothing).\n     fn parse_mutability(&mut self) -> Mutability {\n-        if self.eat_keyword(keywords::Mut) {\n+        if self.eat_keyword(kw::Mut) {\n             Mutability::Mutable\n         } else {\n             Mutability::Immutable\n@@ -2465,37 +2467,37 @@ impl<'a> Parser<'a> {\n                     hi = path.span;\n                     return Ok(self.mk_expr(lo.to(hi), ExprKind::Path(Some(qself), path), attrs));\n                 }\n-                if self.span.rust_2018() && self.check_keyword(keywords::Async) {\n+                if self.span.rust_2018() && self.check_keyword(kw::Async) {\n                     return if self.is_async_block() { // check for `async {` and `async move {`\n                         self.parse_async_block(attrs)\n                     } else {\n                         self.parse_lambda_expr(attrs)\n                     };\n                 }\n-                if self.check_keyword(keywords::Move) || self.check_keyword(keywords::Static) {\n+                if self.check_keyword(kw::Move) || self.check_keyword(kw::Static) {\n                     return self.parse_lambda_expr(attrs);\n                 }\n-                if self.eat_keyword(keywords::If) {\n+                if self.eat_keyword(kw::If) {\n                     return self.parse_if_expr(attrs);\n                 }\n-                if self.eat_keyword(keywords::For) {\n+                if self.eat_keyword(kw::For) {\n                     let lo = self.prev_span;\n                     return self.parse_for_expr(None, lo, attrs);\n                 }\n-                if self.eat_keyword(keywords::While) {\n+                if self.eat_keyword(kw::While) {\n                     let lo = self.prev_span;\n                     return self.parse_while_expr(None, lo, attrs);\n                 }\n                 if let Some(label) = self.eat_label() {\n                     let lo = label.ident.span;\n                     self.expect(&token::Colon)?;\n-                    if self.eat_keyword(keywords::While) {\n+                    if self.eat_keyword(kw::While) {\n                         return self.parse_while_expr(Some(label), lo, attrs)\n                     }\n-                    if self.eat_keyword(keywords::For) {\n+                    if self.eat_keyword(kw::For) {\n                         return self.parse_for_expr(Some(label), lo, attrs)\n                     }\n-                    if self.eat_keyword(keywords::Loop) {\n+                    if self.eat_keyword(kw::Loop) {\n                         return self.parse_loop_expr(Some(label), lo, attrs)\n                     }\n                     if self.token == token::OpenDelim(token::Brace) {\n@@ -2509,24 +2511,24 @@ impl<'a> Parser<'a> {\n                     err.span_label(self.span, msg);\n                     return Err(err);\n                 }\n-                if self.eat_keyword(keywords::Loop) {\n+                if self.eat_keyword(kw::Loop) {\n                     let lo = self.prev_span;\n                     return self.parse_loop_expr(None, lo, attrs);\n                 }\n-                if self.eat_keyword(keywords::Continue) {\n+                if self.eat_keyword(kw::Continue) {\n                     let label = self.eat_label();\n                     let ex = ExprKind::Continue(label);\n                     let hi = self.prev_span;\n                     return Ok(self.mk_expr(lo.to(hi), ex, attrs));\n                 }\n-                if self.eat_keyword(keywords::Match) {\n+                if self.eat_keyword(kw::Match) {\n                     let match_sp = self.prev_span;\n                     return self.parse_match_expr(attrs).map_err(|mut err| {\n                         err.span_label(match_sp, \"while parsing this match expression\");\n                         err\n                     });\n                 }\n-                if self.eat_keyword(keywords::Unsafe) {\n+                if self.eat_keyword(kw::Unsafe) {\n                     return self.parse_block_expr(\n                         None,\n                         lo,\n@@ -2540,18 +2542,18 @@ impl<'a> Parser<'a> {\n                 }\n                 if self.is_try_block() {\n                     let lo = self.span;\n-                    assert!(self.eat_keyword(keywords::Try));\n+                    assert!(self.eat_keyword(kw::Try));\n                     return self.parse_try_block(lo, attrs);\n                 }\n-                if self.eat_keyword(keywords::Return) {\n+                if self.eat_keyword(kw::Return) {\n                     if self.token.can_begin_expr() {\n                         let e = self.parse_expr()?;\n                         hi = e.span;\n                         ex = ExprKind::Ret(Some(e));\n                     } else {\n                         ex = ExprKind::Ret(None);\n                     }\n-                } else if self.eat_keyword(keywords::Break) {\n+                } else if self.eat_keyword(kw::Break) {\n                     let label = self.eat_label();\n                     let e = if self.token.can_begin_expr()\n                                && !(self.token == token::OpenDelim(token::Brace)\n@@ -2563,22 +2565,22 @@ impl<'a> Parser<'a> {\n                     };\n                     ex = ExprKind::Break(label, e);\n                     hi = self.prev_span;\n-                } else if self.eat_keyword(keywords::Yield) {\n+                } else if self.eat_keyword(kw::Yield) {\n                     if self.token.can_begin_expr() {\n                         let e = self.parse_expr()?;\n                         hi = e.span;\n                         ex = ExprKind::Yield(Some(e));\n                     } else {\n                         ex = ExprKind::Yield(None);\n                     }\n-                } else if self.token.is_keyword(keywords::Let) {\n+                } else if self.token.is_keyword(kw::Let) {\n                     // Catch this syntax error here, instead of in `parse_ident`, so\n                     // that we can explicitly mention that let is not to be used as an expression\n                     let mut db = self.fatal(\"expected expression, found statement (`let`)\");\n                     db.span_label(self.span, \"expected expression\");\n                     db.note(\"variable declaration using `let` is a statement\");\n                     return Err(db);\n-                } else if self.span.rust_2018() && self.eat_keyword(keywords::Await) {\n+                } else if self.span.rust_2018() && self.eat_keyword(kw::Await) {\n                     let (await_hi, e_kind) = self.parse_await_macro_or_alt(lo, self.prev_span)?;\n                     hi = await_hi;\n                     ex = e_kind;\n@@ -2879,7 +2881,7 @@ impl<'a> Parser<'a> {\n \n     // Assuming we have just parsed `.`, continue parsing into an expression.\n     fn parse_dot_suffix(&mut self, self_arg: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n-        if self.span.rust_2018() && self.eat_keyword(keywords::Await) {\n+        if self.span.rust_2018() && self.eat_keyword(kw::Await) {\n             let span = lo.to(self.prev_span);\n             let await_expr = self.mk_expr(\n                 span,\n@@ -3250,7 +3252,7 @@ impl<'a> Parser<'a> {\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n                 (lo.to(span), ExprKind::AddrOf(m, e))\n             }\n-            token::Ident(..) if self.token.is_keyword(keywords::In) => {\n+            token::Ident(..) if self.token.is_keyword(kw::In) => {\n                 self.bump();\n                 let place = self.parse_expr_res(\n                     Restrictions::NO_STRUCT_LITERAL,\n@@ -3261,7 +3263,7 @@ impl<'a> Parser<'a> {\n                 let blk_expr = self.mk_expr(span, ExprKind::Block(blk, None), ThinVec::new());\n                 (lo.to(span), ExprKind::ObsoleteInPlace(place, blk_expr))\n             }\n-            token::Ident(..) if self.token.is_keyword(keywords::Box) => {\n+            token::Ident(..) if self.token.is_keyword(kw::Box) => {\n                 self.bump();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n@@ -3683,7 +3685,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses an `if` or `if let` expression (`if` token already eaten).\n     fn parse_if_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n-        if self.check_keyword(keywords::Let) {\n+        if self.check_keyword(kw::Let) {\n             return self.parse_if_let_expr(attrs);\n         }\n         let lo = self.prev_span;\n@@ -3693,7 +3695,7 @@ impl<'a> Parser<'a> {\n         // verify that the last statement is either an implicit return (no `;`) or an explicit\n         // return. This won't catch blocks with an explicit `return`, but that would be caught by\n         // the dead code lint.\n-        if self.eat_keyword(keywords::Else) || !cond.returns() {\n+        if self.eat_keyword(kw::Else) || !cond.returns() {\n             let sp = self.sess.source_map().next_point(lo);\n             let mut err = self.diagnostic()\n                 .struct_span_err(sp, \"missing condition for `if` statemement\");\n@@ -3709,7 +3711,7 @@ impl<'a> Parser<'a> {\n         })?;\n         let mut els: Option<P<Expr>> = None;\n         let mut hi = thn.span;\n-        if self.eat_keyword(keywords::Else) {\n+        if self.eat_keyword(kw::Else) {\n             let elexpr = self.parse_else_expr()?;\n             hi = elexpr.span;\n             els = Some(elexpr);\n@@ -3721,12 +3723,12 @@ impl<'a> Parser<'a> {\n     fn parse_if_let_expr(&mut self, attrs: ThinVec<Attribute>)\n                              -> PResult<'a, P<Expr>> {\n         let lo = self.prev_span;\n-        self.expect_keyword(keywords::Let)?;\n+        self.expect_keyword(kw::Let)?;\n         let pats = self.parse_pats()?;\n         self.expect(&token::Eq)?;\n         let expr = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n         let thn = self.parse_block()?;\n-        let (hi, els) = if self.eat_keyword(keywords::Else) {\n+        let (hi, els) = if self.eat_keyword(kw::Else) {\n             let expr = self.parse_else_expr()?;\n             (expr.span, Some(expr))\n         } else {\n@@ -3741,7 +3743,7 @@ impl<'a> Parser<'a> {\n                              -> PResult<'a, P<Expr>>\n     {\n         let lo = self.span;\n-        let movability = if self.eat_keyword(keywords::Static) {\n+        let movability = if self.eat_keyword(kw::Static) {\n             Movability::Static\n         } else {\n             Movability::Movable\n@@ -3751,7 +3753,7 @@ impl<'a> Parser<'a> {\n         } else {\n             IsAsync::NotAsync\n         };\n-        let capture_clause = if self.eat_keyword(keywords::Move) {\n+        let capture_clause = if self.eat_keyword(kw::Move) {\n             CaptureBy::Value\n         } else {\n             CaptureBy::Ref\n@@ -3779,7 +3781,7 @@ impl<'a> Parser<'a> {\n \n     // `else` token already eaten\n     fn parse_else_expr(&mut self) -> PResult<'a, P<Expr>> {\n-        if self.eat_keyword(keywords::If) {\n+        if self.eat_keyword(kw::If) {\n             return self.parse_if_expr(ThinVec::new());\n         } else {\n             let blk = self.parse_block()?;\n@@ -3794,7 +3796,7 @@ impl<'a> Parser<'a> {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n \n         let pat = self.parse_top_level_pat()?;\n-        if !self.eat_keyword(keywords::In) {\n+        if !self.eat_keyword(kw::In) {\n             let in_span = self.prev_span.between(self.span);\n             let mut err = self.sess.span_diagnostic\n                 .struct_span_err(in_span, \"missing `in` in `for` loop\");\n@@ -3806,7 +3808,7 @@ impl<'a> Parser<'a> {\n             err.emit();\n         }\n         let in_span = self.prev_span;\n-        if self.eat_keyword(keywords::In) {\n+        if self.eat_keyword(kw::In) {\n             // a common typo: `for _ in in bar {}`\n             let mut err = self.sess.span_diagnostic.struct_span_err(\n                 self.prev_span,\n@@ -3835,7 +3837,7 @@ impl<'a> Parser<'a> {\n     fn parse_while_expr(&mut self, opt_label: Option<Label>,\n                             span_lo: Span,\n                             mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n-        if self.token.is_keyword(keywords::Let) {\n+        if self.token.is_keyword(kw::Let) {\n             return self.parse_while_let_expr(opt_label, span_lo, attrs);\n         }\n         let cond = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n@@ -3849,7 +3851,7 @@ impl<'a> Parser<'a> {\n     fn parse_while_let_expr(&mut self, opt_label: Option<Label>,\n                                 span_lo: Span,\n                                 mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n-        self.expect_keyword(keywords::Let)?;\n+        self.expect_keyword(kw::Let)?;\n         let pats = self.parse_pats()?;\n         self.expect(&token::Eq)?;\n         let expr = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n@@ -3874,8 +3876,8 @@ impl<'a> Parser<'a> {\n         -> PResult<'a, P<Expr>>\n     {\n         let span_lo = self.span;\n-        self.expect_keyword(keywords::Async)?;\n-        let capture_clause = if self.eat_keyword(keywords::Move) {\n+        self.expect_keyword(kw::Async)?;\n+        let capture_clause = if self.eat_keyword(kw::Move) {\n             CaptureBy::Value\n         } else {\n             CaptureBy::Ref\n@@ -3893,7 +3895,7 @@ impl<'a> Parser<'a> {\n     {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n-        if self.eat_keyword(keywords::Catch) {\n+        if self.eat_keyword(kw::Catch) {\n             let mut error = self.struct_span_err(self.prev_span,\n                                                  \"keyword `catch` cannot follow a `try` block\");\n             error.help(\"try using `match` on the result of the `try` block instead\");\n@@ -3947,7 +3949,7 @@ impl<'a> Parser<'a> {\n     crate fn parse_arm(&mut self) -> PResult<'a, Arm> {\n         let attrs = self.parse_outer_attributes()?;\n         let pats = self.parse_pats()?;\n-        let guard = if self.eat_keyword(keywords::If) {\n+        let guard = if self.eat_keyword(kw::If) {\n             Some(Guard::If(self.parse_expr()?))\n         } else {\n             None\n@@ -4211,10 +4213,10 @@ impl<'a> Parser<'a> {\n             (pat, fieldname, false)\n         } else {\n             // Parsing a pattern of the form \"(box) (ref) (mut) fieldname\"\n-            let is_box = self.eat_keyword(keywords::Box);\n+            let is_box = self.eat_keyword(kw::Box);\n             let boxed_span = self.span;\n-            let is_ref = self.eat_keyword(keywords::Ref);\n-            let is_mut = self.eat_keyword(keywords::Mut);\n+            let is_ref = self.eat_keyword(kw::Ref);\n+            let is_mut = self.eat_keyword(kw::Mut);\n             let fieldname = self.parse_ident()?;\n             hi = self.prev_span;\n \n@@ -4493,13 +4495,13 @@ impl<'a> Parser<'a> {\n                 pat = PatKind::Slice(before, slice, after);\n             }\n             // At this point, token != &, &&, (, [\n-            _ => if self.eat_keyword(keywords::Underscore) {\n+            _ => if self.eat_keyword(kw::Underscore) {\n                 // Parse _\n                 pat = PatKind::Wild;\n-            } else if self.eat_keyword(keywords::Mut) {\n+            } else if self.eat_keyword(kw::Mut) {\n                 // Parse mut ident @ pat / mut ref ident @ pat\n                 let mutref_span = self.prev_span.to(self.span);\n-                let binding_mode = if self.eat_keyword(keywords::Ref) {\n+                let binding_mode = if self.eat_keyword(kw::Ref) {\n                     self.diagnostic()\n                         .struct_span_err(mutref_span, \"the order of `mut` and `ref` is incorrect\")\n                         .span_suggestion(\n@@ -4513,11 +4515,11 @@ impl<'a> Parser<'a> {\n                     BindingMode::ByValue(Mutability::Mutable)\n                 };\n                 pat = self.parse_pat_ident(binding_mode)?;\n-            } else if self.eat_keyword(keywords::Ref) {\n+            } else if self.eat_keyword(kw::Ref) {\n                 // Parse ref ident @ pat / ref mut ident @ pat\n                 let mutbl = self.parse_mutability();\n                 pat = self.parse_pat_ident(BindingMode::ByRef(mutbl))?;\n-            } else if self.eat_keyword(keywords::Box) {\n+            } else if self.eat_keyword(kw::Box) {\n                 // Parse box pat\n                 let subpat = self.parse_pat_with_range_pat(false, None)?;\n                 pat = PatKind::Box(subpat);\n@@ -4816,10 +4818,10 @@ impl<'a> Parser<'a> {\n     }\n \n     fn is_async_block(&self) -> bool {\n-        self.token.is_keyword(keywords::Async) &&\n+        self.token.is_keyword(kw::Async) &&\n         (\n             ( // `async move {`\n-                self.look_ahead(1, |t| t.is_keyword(keywords::Move)) &&\n+                self.look_ahead(1, |t| t.is_keyword(kw::Move)) &&\n                 self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))\n             ) || ( // `async {`\n                 self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace))\n@@ -4828,54 +4830,54 @@ impl<'a> Parser<'a> {\n     }\n \n     fn is_async_fn(&self) -> bool {\n-        self.token.is_keyword(keywords::Async) &&\n-            self.look_ahead(1, |t| t.is_keyword(keywords::Fn))\n+        self.token.is_keyword(kw::Async) &&\n+            self.look_ahead(1, |t| t.is_keyword(kw::Fn))\n     }\n \n     fn is_do_catch_block(&self) -> bool {\n-        self.token.is_keyword(keywords::Do) &&\n-        self.look_ahead(1, |t| t.is_keyword(keywords::Catch)) &&\n+        self.token.is_keyword(kw::Do) &&\n+        self.look_ahead(1, |t| t.is_keyword(kw::Catch)) &&\n         self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace)) &&\n         !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n     }\n \n     fn is_try_block(&self) -> bool {\n-        self.token.is_keyword(keywords::Try) &&\n+        self.token.is_keyword(kw::Try) &&\n         self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) &&\n         self.span.rust_2018() &&\n         // prevent `while try {} {}`, `if try {} {} else {}`, etc.\n         !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n     }\n \n     fn is_union_item(&self) -> bool {\n-        self.token.is_keyword(keywords::Union) &&\n+        self.token.is_keyword(kw::Union) &&\n         self.look_ahead(1, |t| t.is_ident() && !t.is_reserved_ident())\n     }\n \n     fn is_crate_vis(&self) -> bool {\n-        self.token.is_keyword(keywords::Crate) && self.look_ahead(1, |t| t != &token::ModSep)\n+        self.token.is_keyword(kw::Crate) && self.look_ahead(1, |t| t != &token::ModSep)\n     }\n \n     fn is_existential_type_decl(&self) -> bool {\n-        self.token.is_keyword(keywords::Existential) &&\n-        self.look_ahead(1, |t| t.is_keyword(keywords::Type))\n+        self.token.is_keyword(kw::Existential) &&\n+        self.look_ahead(1, |t| t.is_keyword(kw::Type))\n     }\n \n     fn is_auto_trait_item(&self) -> bool {\n         // auto trait\n-        (self.token.is_keyword(keywords::Auto)\n-            && self.look_ahead(1, |t| t.is_keyword(keywords::Trait)))\n+        (self.token.is_keyword(kw::Auto)\n+            && self.look_ahead(1, |t| t.is_keyword(kw::Trait)))\n         || // unsafe auto trait\n-        (self.token.is_keyword(keywords::Unsafe) &&\n-         self.look_ahead(1, |t| t.is_keyword(keywords::Auto)) &&\n-         self.look_ahead(2, |t| t.is_keyword(keywords::Trait)))\n+        (self.token.is_keyword(kw::Unsafe) &&\n+         self.look_ahead(1, |t| t.is_keyword(kw::Auto)) &&\n+         self.look_ahead(2, |t| t.is_keyword(kw::Trait)))\n     }\n \n     fn eat_macro_def(&mut self, attrs: &[Attribute], vis: &Visibility, lo: Span)\n                      -> PResult<'a, Option<P<Item>>> {\n         let token_lo = self.span;\n         let (ident, def) = match self.token {\n-            token::Ident(ident, false) if ident.name == keywords::Macro.name() => {\n+            token::Ident(ident, false) if ident.name == kw::Macro => {\n                 self.bump();\n                 let ident = self.parse_ident()?;\n                 let tokens = if self.check(&token::OpenDelim(token::Brace)) {\n@@ -4933,7 +4935,7 @@ impl<'a> Parser<'a> {\n         let attrs = self.parse_outer_attributes()?;\n         let lo = self.span;\n \n-        Ok(Some(if self.eat_keyword(keywords::Let) {\n+        Ok(Some(if self.eat_keyword(kw::Let) {\n             Stmt {\n                 id: ast::DUMMY_NODE_ID,\n                 node: StmtKind::Local(self.parse_local(attrs.into())?),\n@@ -4986,7 +4988,7 @@ impl<'a> Parser<'a> {\n \n             // it's a macro invocation\n             let id = match self.token {\n-                token::OpenDelim(_) => keywords::Invalid.ident(), // no special identifier\n+                token::OpenDelim(_) => Ident::with_empty_ctxt(kw::Invalid), // no special identifier\n                 _ => self.parse_ident()?,\n             };\n \n@@ -4998,7 +5000,7 @@ impl<'a> Parser<'a> {\n                 _ => {\n                     // we only expect an ident if we didn't parse one\n                     // above.\n-                    let ident_str = if id.name == keywords::Invalid.name() {\n+                    let ident_str = if id.name == kw::Invalid {\n                         \"identifier, \"\n                     } else {\n                         \"\"\n@@ -5021,7 +5023,7 @@ impl<'a> Parser<'a> {\n                 MacStmtStyle::NoBraces\n             };\n \n-            if id.name == keywords::Invalid.name() {\n+            if id.name == kw::Invalid {\n                 let mac = respan(lo.to(hi), Mac_ { path: pth, tts, delim });\n                 let node = if delim == MacDelimiter::Brace ||\n                               self.token == token::Semi || self.token == token::Eof {\n@@ -5139,7 +5141,7 @@ impl<'a> Parser<'a> {\n             let tok = self.this_token_descr();\n             let mut e = self.span_fatal(sp, &format!(\"expected `{{`, found {}\", tok));\n             let do_not_suggest_help =\n-                self.token.is_keyword(keywords::In) || self.token == token::Colon;\n+                self.token.is_keyword(kw::In) || self.token == token::Colon;\n \n             if self.token.is_ident_named(\"and\") {\n                 e.span_suggestion_short(\n@@ -5332,7 +5334,7 @@ impl<'a> Parser<'a> {\n             let is_bound_start = self.check_path() || self.check_lifetime() ||\n                                  self.check(&token::Not) || // used for error reporting only\n                                  self.check(&token::Question) ||\n-                                 self.check_keyword(keywords::For) ||\n+                                 self.check_keyword(kw::For) ||\n                                  self.check(&token::OpenDelim(token::Paren));\n             if is_bound_start {\n                 let lo = self.span;\n@@ -5510,7 +5512,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_const_param(&mut self, preceding_attrs: Vec<Attribute>) -> PResult<'a, GenericParam> {\n-        self.expect_keyword(keywords::Const)?;\n+        self.expect_keyword(kw::Const)?;\n         let ident = self.parse_ident()?;\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n@@ -5547,7 +5549,7 @@ impl<'a> Parser<'a> {\n                     bounds,\n                     kind: ast::GenericParamKind::Lifetime,\n                 });\n-            } else if self.check_keyword(keywords::Const) {\n+            } else if self.check_keyword(kw::Const) {\n                 // Parse const parameter.\n                 params.push(self.parse_const_param(attrs)?);\n             } else if self.check_ident() {\n@@ -5851,7 +5853,7 @@ impl<'a> Parser<'a> {\n             span: syntax_pos::DUMMY_SP,\n         };\n \n-        if !self.eat_keyword(keywords::Where) {\n+        if !self.eat_keyword(kw::Where) {\n             return Ok(where_clause);\n         }\n         let lo = self.prev_span;\n@@ -6017,7 +6019,7 @@ impl<'a> Parser<'a> {\n             _ => unreachable!()\n         };\n         let isolated_self = |this: &mut Self, n| {\n-            this.look_ahead(n, |t| t.is_keyword(keywords::SelfLower)) &&\n+            this.look_ahead(n, |t| t.is_keyword(kw::SelfLower)) &&\n             this.look_ahead(n + 1, |t| t != &token::ModSep)\n         };\n \n@@ -6035,7 +6037,7 @@ impl<'a> Parser<'a> {\n                 (if isolated_self(self, 1) {\n                     self.bump();\n                     SelfKind::Region(None, Mutability::Immutable)\n-                } else if self.look_ahead(1, |t| t.is_keyword(keywords::Mut)) &&\n+                } else if self.look_ahead(1, |t| t.is_keyword(kw::Mut)) &&\n                           isolated_self(self, 2) {\n                     self.bump();\n                     self.bump();\n@@ -6046,7 +6048,7 @@ impl<'a> Parser<'a> {\n                     let lt = self.expect_lifetime();\n                     SelfKind::Region(Some(lt), Mutability::Immutable)\n                 } else if self.look_ahead(1, |t| t.is_lifetime()) &&\n-                          self.look_ahead(2, |t| t.is_keyword(keywords::Mut)) &&\n+                          self.look_ahead(2, |t| t.is_keyword(kw::Mut)) &&\n                           isolated_self(self, 3) {\n                     self.bump();\n                     let lt = self.expect_lifetime();\n@@ -6093,7 +6095,7 @@ impl<'a> Parser<'a> {\n                     } else {\n                         SelfKind::Value(Mutability::Immutable)\n                     }, eself_ident, eself_hi)\n-                } else if self.token.is_keyword(keywords::Mut) &&\n+                } else if self.token.is_keyword(kw::Mut) &&\n                           isolated_self(self, 1) {\n                     // mut self\n                     // mut self: TYPE\n@@ -6224,9 +6226,9 @@ impl<'a> Parser<'a> {\n     /// Returns `true` if we are looking at `const ID`\n     /// (returns `false` for things like `const fn`, etc.).\n     fn is_const_item(&self) -> bool {\n-        self.token.is_keyword(keywords::Const) &&\n-            !self.look_ahead(1, |t| t.is_keyword(keywords::Fn)) &&\n-            !self.look_ahead(1, |t| t.is_keyword(keywords::Unsafe))\n+        self.token.is_keyword(kw::Const) &&\n+            !self.look_ahead(1, |t| t.is_keyword(kw::Fn)) &&\n+            !self.look_ahead(1, |t| t.is_keyword(kw::Unsafe))\n     }\n \n     /// Parses all the \"front matter\" for a `fn` declaration, up to\n@@ -6245,22 +6247,22 @@ impl<'a> Parser<'a> {\n             Abi\n         )>\n     {\n-        let is_const_fn = self.eat_keyword(keywords::Const);\n+        let is_const_fn = self.eat_keyword(kw::Const);\n         let const_span = self.prev_span;\n         let unsafety = self.parse_unsafety();\n         let asyncness = self.parse_asyncness();\n         let asyncness = respan(self.prev_span, asyncness);\n         let (constness, unsafety, abi) = if is_const_fn {\n             (respan(const_span, Constness::Const), unsafety, Abi::Rust)\n         } else {\n-            let abi = if self.eat_keyword(keywords::Extern) {\n+            let abi = if self.eat_keyword(kw::Extern) {\n                 self.parse_opt_abi()?.unwrap_or(Abi::C)\n             } else {\n                 Abi::Rust\n             };\n             (respan(self.prev_span, Constness::NotConst), unsafety, abi)\n         };\n-        if !self.eat_keyword(keywords::Fn) {\n+        if !self.eat_keyword(kw::Fn) {\n             // It is possible for `expect_one_of` to recover given the contents of\n             // `self.expected_tokens`, therefore, do not use `self.unexpected()` which doesn't\n             // account for this.\n@@ -6304,7 +6306,7 @@ impl<'a> Parser<'a> {\n         } else if self.is_const_item() {\n             // This parses the grammar:\n             //     ImplItemConst = \"const\" Ident \":\" Ty \"=\" Expr \";\"\n-            self.expect_keyword(keywords::Const)?;\n+            self.expect_keyword(kw::Const)?;\n             let name = self.parse_ident()?;\n             self.expect(&token::Colon)?;\n             let typ = self.parse_ty()?;\n@@ -6394,7 +6396,7 @@ impl<'a> Parser<'a> {\n         // code copied from parse_macro_use_or_failure... abstraction!\n         if let Some(mac) = self.parse_assoc_macro_invoc(\"impl\", Some(vis), at_end)? {\n             // method macro\n-            Ok((keywords::Invalid.ident(), vec![], ast::Generics::default(),\n+            Ok((Ident::with_empty_ctxt(kw::Invalid), vec![], ast::Generics::default(),\n                 ast::ImplItemKind::Macro(mac)))\n         } else {\n             let (constness, unsafety, mut asyncness, abi) = self.parse_fn_front_matter()?;\n@@ -6502,7 +6504,7 @@ impl<'a> Parser<'a> {\n              self.look_ahead(1, |t| t.is_lifetime() || t.is_ident()) &&\n                 self.look_ahead(2, |t| t == &token::Gt || t == &token::Comma ||\n                                        t == &token::Colon || t == &token::Eq) ||\n-             self.look_ahead(1, |t| t.is_keyword(keywords::Const)))\n+             self.look_ahead(1, |t| t.is_keyword(kw::Const)))\n     }\n \n     fn parse_impl_body(&mut self) -> PResult<'a, (Vec<ImplItem>, Vec<Attribute>)> {\n@@ -6552,8 +6554,8 @@ impl<'a> Parser<'a> {\n         };\n \n         // Parse both types and traits as a type, then reinterpret if necessary.\n-        let err_path = |span| ast::Path::from_ident(Ident::new(keywords::Invalid.name(), span));\n-        let ty_first = if self.token.is_keyword(keywords::For) &&\n+        let err_path = |span| ast::Path::from_ident(Ident::new(kw::Invalid, span));\n+        let ty_first = if self.token.is_keyword(kw::For) &&\n                           self.look_ahead(1, |t| t != &token::Lt) {\n             let span = self.prev_span.between(self.span);\n             self.struct_span_err(span, \"missing trait in a trait impl\").emit();\n@@ -6563,7 +6565,7 @@ impl<'a> Parser<'a> {\n         };\n \n         // If `for` is missing we try to recover.\n-        let has_for = self.eat_keyword(keywords::For);\n+        let has_for = self.eat_keyword(kw::For);\n         let missing_for_span = self.prev_span.between(self.span);\n \n         let ty_second = if self.token == token::DotDot {\n@@ -6614,11 +6616,11 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        Ok((keywords::Invalid.ident(), item_kind, Some(attrs)))\n+        Ok((Ident::with_empty_ctxt(kw::Invalid), item_kind, Some(attrs)))\n     }\n \n     fn parse_late_bound_lifetime_defs(&mut self) -> PResult<'a, Vec<GenericParam>> {\n-        if self.eat_keyword(keywords::For) {\n+        if self.eat_keyword(kw::For) {\n             self.expect_lt()?;\n             let params = self.parse_generic_params()?;\n             self.expect_gt()?;\n@@ -6650,7 +6652,7 @@ impl<'a> Parser<'a> {\n         // Otherwise if we look ahead and see a paren we parse a tuple-style\n         // struct.\n \n-        let vdata = if self.token.is_keyword(keywords::Where) {\n+        let vdata = if self.token.is_keyword(kw::Where) {\n             generics.where_clause = self.parse_where_clause()?;\n             if self.eat(&token::Semi) {\n                 // If we see a: `struct Foo<T> where T: Copy;` style decl.\n@@ -6692,7 +6694,7 @@ impl<'a> Parser<'a> {\n \n         let mut generics = self.parse_generics()?;\n \n-        let vdata = if self.token.is_keyword(keywords::Where) {\n+        let vdata = if self.token.is_keyword(kw::Where) {\n             generics.where_clause = self.parse_where_clause()?;\n             let (fields, recovered) = self.parse_record_struct_body()?;\n             VariantData::Struct(fields, recovered)\n@@ -6844,13 +6846,13 @@ impl<'a> Parser<'a> {\n     pub fn parse_visibility(&mut self, can_take_tuple: bool) -> PResult<'a, Visibility> {\n         maybe_whole!(self, NtVis, |x| x);\n \n-        self.expected_tokens.push(TokenType::Keyword(keywords::Crate));\n+        self.expected_tokens.push(TokenType::Keyword(kw::Crate));\n         if self.is_crate_vis() {\n             self.bump(); // `crate`\n             return Ok(respan(self.prev_span, VisibilityKind::Crate(CrateSugar::JustCrate)));\n         }\n \n-        if !self.eat_keyword(keywords::Pub) {\n+        if !self.eat_keyword(kw::Pub) {\n             // We need a span for our `Spanned<VisibilityKind>`, but there's inherently no\n             // keyword to grab a span from for inherited visibility; an empty span at the\n             // beginning of the current token would seem to be the \"Schelling span\".\n@@ -6863,7 +6865,7 @@ impl<'a> Parser<'a> {\n             // `()` or a tuple might be allowed. For example, `struct Struct(pub (), pub (usize));`.\n             // Because of this, we only `bump` the `(` if we're assured it is appropriate to do so\n             // by the following tokens.\n-            if self.look_ahead(1, |t| t.is_keyword(keywords::Crate)) &&\n+            if self.look_ahead(1, |t| t.is_keyword(kw::Crate)) &&\n                 self.look_ahead(2, |t| t != &token::ModSep) // account for `pub(crate::foo)`\n             {\n                 // `pub(crate)`\n@@ -6875,7 +6877,7 @@ impl<'a> Parser<'a> {\n                     VisibilityKind::Crate(CrateSugar::PubCrate),\n                 );\n                 return Ok(vis)\n-            } else if self.look_ahead(1, |t| t.is_keyword(keywords::In)) {\n+            } else if self.look_ahead(1, |t| t.is_keyword(kw::In)) {\n                 // `pub(in path)`\n                 self.bump(); // `(`\n                 self.bump(); // `in`\n@@ -6887,8 +6889,8 @@ impl<'a> Parser<'a> {\n                 });\n                 return Ok(vis)\n             } else if self.look_ahead(2, |t| t == &token::CloseDelim(token::Paren)) &&\n-                      self.look_ahead(1, |t| t.is_keyword(keywords::Super) ||\n-                                             t.is_keyword(keywords::SelfLower))\n+                      self.look_ahead(1, |t| t.is_keyword(kw::Super) ||\n+                                             t.is_keyword(kw::SelfLower))\n             {\n                 // `pub(self)` or `pub(super)`\n                 self.bump(); // `(`\n@@ -6926,14 +6928,14 @@ impl<'a> Parser<'a> {\n     /// Parses defaultness (i.e., `default` or nothing).\n     fn parse_defaultness(&mut self) -> Defaultness {\n         // `pub` is included for better error messages\n-        if self.check_keyword(keywords::Default) &&\n-           self.look_ahead(1, |t| t.is_keyword(keywords::Impl) ||\n-                                  t.is_keyword(keywords::Const) ||\n-                                  t.is_keyword(keywords::Fn) ||\n-                                  t.is_keyword(keywords::Unsafe) ||\n-                                  t.is_keyword(keywords::Extern) ||\n-                                  t.is_keyword(keywords::Type) ||\n-                                  t.is_keyword(keywords::Pub)) {\n+        if self.check_keyword(kw::Default) &&\n+           self.look_ahead(1, |t| t.is_keyword(kw::Impl) ||\n+                                  t.is_keyword(kw::Const) ||\n+                                  t.is_keyword(kw::Fn) ||\n+                                  t.is_keyword(kw::Unsafe) ||\n+                                  t.is_keyword(kw::Extern) ||\n+                                  t.is_keyword(kw::Type) ||\n+                                  t.is_keyword(kw::Pub)) {\n             self.bump(); // `default`\n             Defaultness::Default\n         } else {\n@@ -7257,7 +7259,7 @@ impl<'a> Parser<'a> {\n     /// Parses a function declaration from a foreign module.\n     fn parse_item_foreign_fn(&mut self, vis: ast::Visibility, lo: Span, attrs: Vec<Attribute>)\n                              -> PResult<'a, ForeignItem> {\n-        self.expect_keyword(keywords::Fn)?;\n+        self.expect_keyword(kw::Fn)?;\n \n         let (ident, mut generics) = self.parse_fn_header()?;\n         let decl = self.parse_fn_decl(true)?;\n@@ -7297,7 +7299,7 @@ impl<'a> Parser<'a> {\n     /// Parses a type from a foreign module.\n     fn parse_item_foreign_type(&mut self, vis: ast::Visibility, lo: Span, attrs: Vec<Attribute>)\n                              -> PResult<'a, ForeignItem> {\n-        self.expect_keyword(keywords::Type)?;\n+        self.expect_keyword(kw::Type)?;\n \n         let ident = self.parse_ident()?;\n         let hi = self.span;\n@@ -7316,7 +7318,7 @@ impl<'a> Parser<'a> {\n         let error_msg = \"crate name using dashes are not valid in `extern crate` statements\";\n         let suggestion_msg = \"if the original crate name uses dashes you need to use underscores \\\n                               in the code\";\n-        let mut ident = if self.token.is_keyword(keywords::SelfLower) {\n+        let mut ident = if self.token.is_keyword(kw::SelfLower) {\n             self.parse_path_segment_ident()\n         } else {\n             self.parse_ident()\n@@ -7412,7 +7414,7 @@ impl<'a> Parser<'a> {\n             abi,\n             items: foreign_items\n         };\n-        let invalid = keywords::Invalid.ident();\n+        let invalid = Ident::with_empty_ctxt(kw::Invalid);\n         Ok(self.mk_item(lo.to(prev_span), invalid, ItemKind::ForeignMod(m), visibility, attrs))\n     }\n \n@@ -7425,11 +7427,11 @@ impl<'a> Parser<'a> {\n     fn eat_type(&mut self) -> Option<PResult<'a, (Ident, AliasKind, ast::Generics)>> {\n         // This parses the grammar:\n         //     Ident [\"<\"...\">\"] [\"where\" ...] (\"=\" | \":\") Ty \";\"\n-        if self.check_keyword(keywords::Type) ||\n-           self.check_keyword(keywords::Existential) &&\n-                self.look_ahead(1, |t| t.is_keyword(keywords::Type)) {\n-            let existential = self.eat_keyword(keywords::Existential);\n-            assert!(self.eat_keyword(keywords::Type));\n+        if self.check_keyword(kw::Type) ||\n+           self.check_keyword(kw::Existential) &&\n+                self.look_ahead(1, |t| t.is_keyword(kw::Type)) {\n+            let existential = self.eat_keyword(kw::Existential);\n+            assert!(self.eat_keyword(kw::Type));\n             Some(self.parse_existential_or_alias(existential))\n         } else {\n             None\n@@ -7580,10 +7582,10 @@ impl<'a> Parser<'a> {\n     }\n \n     fn is_static_global(&mut self) -> bool {\n-        if self.check_keyword(keywords::Static) {\n+        if self.check_keyword(kw::Static) {\n             // Check if this could be a closure\n             !self.look_ahead(1, |token| {\n-                if token.is_keyword(keywords::Move) {\n+                if token.is_keyword(kw::Move) {\n                     return true;\n                 }\n                 match *token {\n@@ -7653,24 +7655,25 @@ impl<'a> Parser<'a> {\n \n         let visibility = self.parse_visibility(false)?;\n \n-        if self.eat_keyword(keywords::Use) {\n+        if self.eat_keyword(kw::Use) {\n             // USE ITEM\n             let item_ = ItemKind::Use(P(self.parse_use_tree()?));\n             self.expect(&token::Semi)?;\n \n             let span = lo.to(self.prev_span);\n-            let item = self.mk_item(span, keywords::Invalid.ident(), item_, visibility, attrs);\n+            let item =\n+                self.mk_item(span, Ident::with_empty_ctxt(kw::Invalid), item_, visibility, attrs);\n             return Ok(Some(item));\n         }\n \n-        if self.eat_keyword(keywords::Extern) {\n-            if self.eat_keyword(keywords::Crate) {\n+        if self.eat_keyword(kw::Extern) {\n+            if self.eat_keyword(kw::Crate) {\n                 return Ok(Some(self.parse_item_extern_crate(lo, visibility, attrs)?));\n             }\n \n             let opt_abi = self.parse_opt_abi()?;\n \n-            if self.eat_keyword(keywords::Fn) {\n+            if self.eat_keyword(kw::Fn) {\n                 // EXTERN FUNCTION ITEM\n                 let fn_span = self.prev_span;\n                 let abi = opt_abi.unwrap_or(Abi::C);\n@@ -7696,7 +7699,7 @@ impl<'a> Parser<'a> {\n         if self.is_static_global() {\n             self.bump();\n             // STATIC ITEM\n-            let m = if self.eat_keyword(keywords::Mut) {\n+            let m = if self.eat_keyword(kw::Mut) {\n                 Mutability::Mutable\n             } else {\n                 Mutability::Immutable\n@@ -7710,11 +7713,11 @@ impl<'a> Parser<'a> {\n                                     maybe_append(attrs, extra_attrs));\n             return Ok(Some(item));\n         }\n-        if self.eat_keyword(keywords::Const) {\n+        if self.eat_keyword(kw::Const) {\n             let const_span = self.prev_span;\n-            if self.check_keyword(keywords::Fn)\n-                || (self.check_keyword(keywords::Unsafe)\n-                    && self.look_ahead(1, |t| t.is_keyword(keywords::Fn))) {\n+            if self.check_keyword(kw::Fn)\n+                || (self.check_keyword(kw::Unsafe)\n+                    && self.look_ahead(1, |t| t.is_keyword(kw::Fn))) {\n                 // CONST FUNCTION ITEM\n                 let unsafety = self.parse_unsafety();\n                 self.bump();\n@@ -7733,7 +7736,7 @@ impl<'a> Parser<'a> {\n             }\n \n             // CONST ITEM\n-            if self.eat_keyword(keywords::Mut) {\n+            if self.eat_keyword(kw::Mut) {\n                 let prev_span = self.prev_span;\n                 let mut err = self.diagnostic()\n                     .struct_span_err(prev_span, \"const globals cannot be mutable\");\n@@ -7758,18 +7761,18 @@ impl<'a> Parser<'a> {\n \n         // `unsafe async fn` or `async fn`\n         if (\n-            self.check_keyword(keywords::Unsafe) &&\n-            self.look_ahead(1, |t| t.is_keyword(keywords::Async))\n+            self.check_keyword(kw::Unsafe) &&\n+            self.look_ahead(1, |t| t.is_keyword(kw::Async))\n         ) || (\n-            self.check_keyword(keywords::Async) &&\n-            self.look_ahead(1, |t| t.is_keyword(keywords::Fn))\n+            self.check_keyword(kw::Async) &&\n+            self.look_ahead(1, |t| t.is_keyword(kw::Fn))\n         )\n         {\n             // ASYNC FUNCTION ITEM\n             let unsafety = self.parse_unsafety();\n-            self.expect_keyword(keywords::Async)?;\n+            self.expect_keyword(kw::Async)?;\n             let async_span = self.prev_span;\n-            self.expect_keyword(keywords::Fn)?;\n+            self.expect_keyword(kw::Fn)?;\n             let fn_span = self.prev_span;\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_fn(unsafety,\n@@ -7795,17 +7798,17 @@ impl<'a> Parser<'a> {\n             }\n             return Ok(Some(item));\n         }\n-        if self.check_keyword(keywords::Unsafe) &&\n-            (self.look_ahead(1, |t| t.is_keyword(keywords::Trait)) ||\n-            self.look_ahead(1, |t| t.is_keyword(keywords::Auto)))\n+        if self.check_keyword(kw::Unsafe) &&\n+            (self.look_ahead(1, |t| t.is_keyword(kw::Trait)) ||\n+            self.look_ahead(1, |t| t.is_keyword(kw::Auto)))\n         {\n             // UNSAFE TRAIT ITEM\n             self.bump(); // `unsafe`\n-            let is_auto = if self.eat_keyword(keywords::Trait) {\n+            let is_auto = if self.eat_keyword(kw::Trait) {\n                 IsAuto::No\n             } else {\n-                self.expect_keyword(keywords::Auto)?;\n-                self.expect_keyword(keywords::Trait)?;\n+                self.expect_keyword(kw::Auto)?;\n+                self.expect_keyword(kw::Trait)?;\n                 IsAuto::Yes\n             };\n             let (ident, item_, extra_attrs) =\n@@ -7818,23 +7821,23 @@ impl<'a> Parser<'a> {\n                                     maybe_append(attrs, extra_attrs));\n             return Ok(Some(item));\n         }\n-        if self.check_keyword(keywords::Impl) ||\n-           self.check_keyword(keywords::Unsafe) &&\n-                self.look_ahead(1, |t| t.is_keyword(keywords::Impl)) ||\n-           self.check_keyword(keywords::Default) &&\n-                self.look_ahead(1, |t| t.is_keyword(keywords::Impl)) ||\n-           self.check_keyword(keywords::Default) &&\n-                self.look_ahead(1, |t| t.is_keyword(keywords::Unsafe)) {\n+        if self.check_keyword(kw::Impl) ||\n+           self.check_keyword(kw::Unsafe) &&\n+                self.look_ahead(1, |t| t.is_keyword(kw::Impl)) ||\n+           self.check_keyword(kw::Default) &&\n+                self.look_ahead(1, |t| t.is_keyword(kw::Impl)) ||\n+           self.check_keyword(kw::Default) &&\n+                self.look_ahead(1, |t| t.is_keyword(kw::Unsafe)) {\n             // IMPL ITEM\n             let defaultness = self.parse_defaultness();\n             let unsafety = self.parse_unsafety();\n-            self.expect_keyword(keywords::Impl)?;\n+            self.expect_keyword(kw::Impl)?;\n             let (ident, item, extra_attrs) = self.parse_item_impl(unsafety, defaultness)?;\n             let span = lo.to(self.prev_span);\n             return Ok(Some(self.mk_item(span, ident, item, visibility,\n                                         maybe_append(attrs, extra_attrs))));\n         }\n-        if self.check_keyword(keywords::Fn) {\n+        if self.check_keyword(kw::Fn) {\n             // FUNCTION ITEM\n             self.bump();\n             let fn_span = self.prev_span;\n@@ -7851,18 +7854,18 @@ impl<'a> Parser<'a> {\n                                     maybe_append(attrs, extra_attrs));\n             return Ok(Some(item));\n         }\n-        if self.check_keyword(keywords::Unsafe)\n+        if self.check_keyword(kw::Unsafe)\n             && self.look_ahead(1, |t| *t != token::OpenDelim(token::Brace)) {\n             // UNSAFE FUNCTION ITEM\n             self.bump(); // `unsafe`\n             // `{` is also expected after `unsafe`, in case of error, include it in the diagnostic\n             self.check(&token::OpenDelim(token::Brace));\n-            let abi = if self.eat_keyword(keywords::Extern) {\n+            let abi = if self.eat_keyword(kw::Extern) {\n                 self.parse_opt_abi()?.unwrap_or(Abi::C)\n             } else {\n                 Abi::Rust\n             };\n-            self.expect_keyword(keywords::Fn)?;\n+            self.expect_keyword(kw::Fn)?;\n             let fn_span = self.prev_span;\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_fn(Unsafety::Unsafe,\n@@ -7877,7 +7880,7 @@ impl<'a> Parser<'a> {\n                                     maybe_append(attrs, extra_attrs));\n             return Ok(Some(item));\n         }\n-        if self.eat_keyword(keywords::Mod) {\n+        if self.eat_keyword(kw::Mod) {\n             // MODULE ITEM\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_mod(&attrs[..])?;\n@@ -7904,7 +7907,7 @@ impl<'a> Parser<'a> {\n                                     attrs);\n             return Ok(Some(item));\n         }\n-        if self.eat_keyword(keywords::Enum) {\n+        if self.eat_keyword(kw::Enum) {\n             // ENUM ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_enum()?;\n             let prev_span = self.prev_span;\n@@ -7915,15 +7918,15 @@ impl<'a> Parser<'a> {\n                                     maybe_append(attrs, extra_attrs));\n             return Ok(Some(item));\n         }\n-        if self.check_keyword(keywords::Trait)\n-            || (self.check_keyword(keywords::Auto)\n-                && self.look_ahead(1, |t| t.is_keyword(keywords::Trait)))\n+        if self.check_keyword(kw::Trait)\n+            || (self.check_keyword(kw::Auto)\n+                && self.look_ahead(1, |t| t.is_keyword(kw::Trait)))\n         {\n-            let is_auto = if self.eat_keyword(keywords::Trait) {\n+            let is_auto = if self.eat_keyword(kw::Trait) {\n                 IsAuto::No\n             } else {\n-                self.expect_keyword(keywords::Auto)?;\n-                self.expect_keyword(keywords::Trait)?;\n+                self.expect_keyword(kw::Auto)?;\n+                self.expect_keyword(kw::Trait)?;\n                 IsAuto::Yes\n             };\n             // TRAIT ITEM\n@@ -7937,7 +7940,7 @@ impl<'a> Parser<'a> {\n                                     maybe_append(attrs, extra_attrs));\n             return Ok(Some(item));\n         }\n-        if self.eat_keyword(keywords::Struct) {\n+        if self.eat_keyword(kw::Struct) {\n             // STRUCT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_struct()?;\n             let prev_span = self.prev_span;\n@@ -8078,8 +8081,8 @@ impl<'a> Parser<'a> {\n \n         // FOREIGN STATIC ITEM\n         // Treat `const` as `static` for error recovery, but don't add it to expected tokens.\n-        if self.check_keyword(keywords::Static) || self.token.is_keyword(keywords::Const) {\n-            if self.token.is_keyword(keywords::Const) {\n+        if self.check_keyword(kw::Static) || self.token.is_keyword(kw::Const) {\n+            if self.token.is_keyword(kw::Const) {\n                 self.diagnostic()\n                     .struct_span_err(self.span, \"extern items cannot be `const`\")\n                     .span_suggestion(\n@@ -8093,19 +8096,19 @@ impl<'a> Parser<'a> {\n             return Ok(self.parse_item_foreign_static(visibility, lo, attrs)?);\n         }\n         // FOREIGN FUNCTION ITEM\n-        if self.check_keyword(keywords::Fn) {\n+        if self.check_keyword(kw::Fn) {\n             return Ok(self.parse_item_foreign_fn(visibility, lo, attrs)?);\n         }\n         // FOREIGN TYPE ITEM\n-        if self.check_keyword(keywords::Type) {\n+        if self.check_keyword(kw::Type) {\n             return Ok(self.parse_item_foreign_type(visibility, lo, attrs)?);\n         }\n \n         match self.parse_assoc_macro_invoc(\"extern\", Some(&visibility), &mut false)? {\n             Some(mac) => {\n                 Ok(\n                     ForeignItem {\n-                        ident: keywords::Invalid.ident(),\n+                        ident: Ident::with_empty_ctxt(kw::Invalid),\n                         span: lo.to(self.prev_span),\n                         id: ast::DUMMY_NODE_ID,\n                         attrs,\n@@ -8152,7 +8155,7 @@ impl<'a> Parser<'a> {\n             let id = if self.token.is_ident() {\n                 self.parse_ident()?\n             } else {\n-                keywords::Invalid.ident() // no special identifier\n+                Ident::with_empty_ctxt(kw::Invalid) // no special identifier\n             };\n             // eat a matched-delimiter token tree:\n             let (delim, tts) = self.expect_delimited_token_tree()?;\n@@ -8345,7 +8348,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_rename(&mut self) -> PResult<'a, Option<Ident>> {\n-        if self.eat_keyword(keywords::As) {\n+        if self.eat_keyword(kw::As) {\n             self.parse_ident_or_underscore().map(Some)\n         } else {\n             Ok(None)"}, {"sha": "663eace6b6289c503926abe3df5b55a55a1fa4b3", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -8,7 +8,7 @@ use crate::ast::{self};\n use crate::parse::ParseSess;\n use crate::print::pprust;\n use crate::ptr::P;\n-use crate::symbol::keywords;\n+use crate::symbol::kw;\n use crate::syntax::parse::parse_stream_from_source_str;\n use crate::tokenstream::{self, DelimSpan, TokenStream, TokenTree};\n \n@@ -110,28 +110,28 @@ pub(crate) fn ident_can_begin_expr(ident: ast::Ident, is_raw: bool) -> bool {\n     !ident_token.is_reserved_ident() ||\n     ident_token.is_path_segment_keyword() ||\n     [\n-        keywords::Async.name(),\n+        kw::Async,\n \n         // FIXME: remove when `await!(..)` syntax is removed\n         // https://github.com/rust-lang/rust/issues/60610\n-        keywords::Await.name(),\n-\n-        keywords::Do.name(),\n-        keywords::Box.name(),\n-        keywords::Break.name(),\n-        keywords::Continue.name(),\n-        keywords::False.name(),\n-        keywords::For.name(),\n-        keywords::If.name(),\n-        keywords::Loop.name(),\n-        keywords::Match.name(),\n-        keywords::Move.name(),\n-        keywords::Return.name(),\n-        keywords::True.name(),\n-        keywords::Unsafe.name(),\n-        keywords::While.name(),\n-        keywords::Yield.name(),\n-        keywords::Static.name(),\n+        kw::Await,\n+\n+        kw::Do,\n+        kw::Box,\n+        kw::Break,\n+        kw::Continue,\n+        kw::False,\n+        kw::For,\n+        kw::If,\n+        kw::Loop,\n+        kw::Match,\n+        kw::Move,\n+        kw::Return,\n+        kw::True,\n+        kw::Unsafe,\n+        kw::While,\n+        kw::Yield,\n+        kw::Static,\n     ].contains(&ident.name)\n }\n \n@@ -141,14 +141,14 @@ fn ident_can_begin_type(ident: ast::Ident, is_raw: bool) -> bool {\n     !ident_token.is_reserved_ident() ||\n     ident_token.is_path_segment_keyword() ||\n     [\n-        keywords::Underscore.name(),\n-        keywords::For.name(),\n-        keywords::Impl.name(),\n-        keywords::Fn.name(),\n-        keywords::Unsafe.name(),\n-        keywords::Extern.name(),\n-        keywords::Typeof.name(),\n-        keywords::Dyn.name(),\n+        kw::Underscore,\n+        kw::For,\n+        kw::Impl,\n+        kw::Fn,\n+        kw::Unsafe,\n+        kw::Extern,\n+        kw::Typeof,\n+        kw::Dyn,\n     ].contains(&ident.name)\n }\n \n@@ -306,7 +306,7 @@ impl Token {\n \n     /// Returns `true` if the token can appear at the start of a generic bound.\n     crate fn can_begin_bound(&self) -> bool {\n-        self.is_path_start() || self.is_lifetime() || self.is_keyword(keywords::For) ||\n+        self.is_path_start() || self.is_lifetime() || self.is_keyword(kw::For) ||\n         self == &Question || self == &OpenDelim(Paren)\n     }\n \n@@ -324,8 +324,8 @@ impl Token {\n         match *self {\n             Literal(..)  => true,\n             BinOp(Minus) => true,\n-            Ident(ident, false) if ident.name == keywords::True.name() => true,\n-            Ident(ident, false) if ident.name == keywords::False.name() => true,\n+            Ident(ident, false) if ident.name == kw::True => true,\n+            Ident(ident, false) if ident.name == kw::False => true,\n             Interpolated(ref nt) => match **nt {\n                 NtLiteral(..) => true,\n                 _             => false,\n@@ -386,8 +386,8 @@ impl Token {\n \n     /// Returns `true` if the token is either the `mut` or `const` keyword.\n     crate fn is_mutability(&self) -> bool {\n-        self.is_keyword(keywords::Mut) ||\n-        self.is_keyword(keywords::Const)\n+        self.is_keyword(kw::Mut) ||\n+        self.is_keyword(kw::Const)\n     }\n \n     crate fn is_qpath_start(&self) -> bool {\n@@ -400,8 +400,8 @@ impl Token {\n     }\n \n     /// Returns `true` if the token is a given keyword, `kw`.\n-    pub fn is_keyword(&self, kw: keywords::Keyword) -> bool {\n-        self.ident().map(|(ident, is_raw)| ident.name == kw.name() && !is_raw).unwrap_or(false)\n+    pub fn is_keyword(&self, kw: Symbol) -> bool {\n+        self.ident().map(|(ident, is_raw)| ident.name == kw && !is_raw).unwrap_or(false)\n     }\n \n     pub fn is_path_segment_keyword(&self) -> bool {\n@@ -566,8 +566,8 @@ impl Token {\n \n             (&Lifetime(a), &Lifetime(b)) => a.name == b.name,\n             (&Ident(a, b), &Ident(c, d)) => b == d && (a.name == c.name ||\n-                                                       a.name == keywords::DollarCrate.name() ||\n-                                                       c.name == keywords::DollarCrate.name()),\n+                                                       a.name == kw::DollarCrate ||\n+                                                       c.name == kw::DollarCrate),\n \n             (&Literal(ref a, b), &Literal(ref c, d)) => {\n                 b == d && a.probably_equal_for_proc_macro(c)"}, {"sha": "2e072522d24a431254566ff6c11d89b951fed1b3", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -13,7 +13,7 @@ use crate::print::pp::{self, Breaks};\n use crate::print::pp::Breaks::{Consistent, Inconsistent};\n use crate::ptr::P;\n use crate::std_inject;\n-use crate::symbol::{keywords, sym};\n+use crate::symbol::{kw, sym};\n use crate::tokenstream::{self, TokenStream, TokenTree};\n \n use rustc_target::spec::abi::{self, Abi};\n@@ -641,8 +641,8 @@ pub trait PrintState<'a> {\n             if i > 0 {\n                 self.writer().word(\"::\")?\n             }\n-            if segment.ident.name != keywords::PathRoot.name() {\n-                if segment.ident.name == keywords::DollarCrate.name() {\n+            if segment.ident.name != kw::PathRoot {\n+                if segment.ident.name == kw::DollarCrate {\n                     self.print_dollar_crate(segment.ident)?;\n                 } else {\n                     self.writer().word(segment.ident.as_str().to_string())?;\n@@ -1340,7 +1340,7 @@ impl<'a> State<'a> {\n                 self.s.word(\";\")?;\n             }\n             ast::ItemKind::Mac(ref mac) => {\n-                if item.ident.name == keywords::Invalid.name() {\n+                if item.ident.name == kw::Invalid {\n                     self.print_mac(mac)?;\n                     match mac.node.delim {\n                         MacDelimiter::Brace => {}\n@@ -2400,8 +2400,8 @@ impl<'a> State<'a> {\n                           colons_before_params: bool)\n                           -> io::Result<()>\n     {\n-        if segment.ident.name != keywords::PathRoot.name() {\n-            if segment.ident.name == keywords::DollarCrate.name() {\n+        if segment.ident.name != kw::PathRoot {\n+            if segment.ident.name == kw::DollarCrate {\n                 self.print_dollar_crate(segment.ident)?;\n             } else {\n                 self.print_ident(segment.ident)?;\n@@ -2984,7 +2984,7 @@ impl<'a> State<'a> {\n                     self.print_explicit_self(&eself)?;\n                 } else {\n                     let invalid = if let PatKind::Ident(_, ident, _) = input.pat.node {\n-                        ident.name == keywords::Invalid.name()\n+                        ident.name == kw::Invalid\n                     } else {\n                         false\n                     };"}, {"sha": "5f6cf9440611dfd0a97c7ca94da927800f44f64f", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -2,7 +2,7 @@ use crate::ast;\n use crate::attr;\n use crate::edition::Edition;\n use crate::ext::hygiene::{Mark, SyntaxContext};\n-use crate::symbol::{Ident, Symbol, keywords, sym};\n+use crate::symbol::{Ident, Symbol, kw, sym};\n use crate::source_map::{ExpnInfo, MacroAttribute, dummy_spanned, respan};\n use crate::ptr::P;\n use crate::tokenstream::TokenStream;\n@@ -107,7 +107,7 @@ pub fn maybe_inject_crates_ref(\n         vis: respan(span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n         node: ast::ItemKind::Use(P(ast::UseTree {\n             prefix: ast::Path {\n-                segments: iter::once(keywords::PathRoot.ident())\n+                segments: iter::once(ast::Ident::with_empty_ctxt(kw::PathRoot))\n                     .chain(\n                         [name, \"prelude\", \"v1\"].iter().cloned()\n                             .map(ast::Ident::from_str)\n@@ -118,7 +118,7 @@ pub fn maybe_inject_crates_ref(\n             span,\n         })),\n         id: ast::DUMMY_NODE_ID,\n-        ident: keywords::Invalid.ident(),\n+        ident: ast::Ident::with_empty_ctxt(kw::Invalid),\n         span,\n         tokens: None,\n     }));"}, {"sha": "206320f58b766b1452f9f0902b799035ac6741cb", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -29,7 +29,7 @@ use crate::parse::{token, ParseSess};\n use crate::print::pprust;\n use crate::ast::{self, Ident};\n use crate::ptr::P;\n-use crate::symbol::{self, Symbol, keywords, sym};\n+use crate::symbol::{self, Symbol, kw, sym};\n use crate::ThinVec;\n \n struct Test {\n@@ -100,7 +100,7 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n \n     fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n         let ident = i.ident;\n-        if ident.name != keywords::Invalid.name() {\n+        if ident.name != kw::Invalid {\n             self.cx.path.push(ident);\n         }\n         debug!(\"current path: {}\", path_name_i(&self.cx.path));\n@@ -139,7 +139,7 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n             }\n             item.node = ast::ItemKind::Mod(module);\n         }\n-        if ident.name != keywords::Invalid.name() {\n+        if ident.name != kw::Invalid {\n             self.cx.path.pop();\n         }\n         smallvec![P(item)]"}, {"sha": "6789fea28cad6daf1798c2da3e1c31d5e9282931", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -1,5 +1,5 @@\n use crate::parse::token::{Token, BinOpToken};\n-use crate::symbol::keywords;\n+use crate::symbol::kw;\n use crate::ast::{self, BinOpKind};\n \n /// Associative operator with precedence.\n@@ -100,7 +100,7 @@ impl AssocOp {\n             // DotDotDot is no longer supported, but we need some way to display the error\n             Token::DotDotDot => Some(DotDotEq),\n             Token::Colon => Some(Colon),\n-            _ if t.is_keyword(keywords::As) => Some(As),\n+            _ if t.is_keyword(kw::As) => Some(As),\n             _ => None\n         }\n     }"}, {"sha": "a39e0a6e9730380e74a890636281fb9a33208ea4", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -7,7 +7,7 @@ use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n-use syntax::symbol::{Symbol, keywords, sym};\n+use syntax::symbol::{Symbol, kw, sym};\n use syntax_pos::Span;\n \n pub fn expand_deriving_clone(cx: &mut ExtCtxt<'_>,\n@@ -129,7 +129,8 @@ fn cs_clone_shallow(name: &str,\n     let mut stmts = Vec::new();\n     if is_union {\n         // let _: AssertParamIsCopy<Self>;\n-        let self_ty = cx.ty_path(cx.path_ident(trait_span, keywords::SelfUpper.ident()));\n+        let self_ty =\n+            cx.ty_path(cx.path_ident(trait_span, ast::Ident::with_empty_ctxt(kw::SelfUpper)));\n         assert_ty_bounds(cx, &mut stmts, self_ty, trait_span, \"AssertParamIsCopy\");\n     } else {\n         match *substr.fields {"}, {"sha": "5b4bf6b86182c0580f137a5d9d461658eaa9bf5d", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -191,7 +191,7 @@ use syntax::ext::build::AstBuilder;\n use syntax::source_map::{self, respan};\n use syntax::util::map_in_place::MapInPlace;\n use syntax::ptr::P;\n-use syntax::symbol::{Symbol, keywords, sym};\n+use syntax::symbol::{Symbol, kw, sym};\n use syntax::parse::ParseSess;\n use syntax_pos::{DUMMY_SP, Span};\n \n@@ -686,7 +686,7 @@ impl<'a> TraitDef<'a> {\n         };\n \n         cx.item(self.span,\n-                keywords::Invalid.ident(),\n+                Ident::with_empty_ctxt(kw::Invalid),\n                 a,\n                 ast::ItemKind::Impl(unsafety,\n                                     ast::ImplPolarity::Positive,\n@@ -929,8 +929,8 @@ impl<'a> MethodDef<'a> {\n \n         let args = {\n             let self_args = explicit_self.map(|explicit_self| {\n-                ast::Arg::from_self(explicit_self,\n-                                    keywords::SelfLower.ident().with_span_pos(trait_.span))\n+                let ident = Ident::with_empty_ctxt(kw::SelfLower).with_span_pos(trait_.span);\n+                ast::Arg::from_self(explicit_self, ident)\n             });\n             let nonself_args = arg_types.into_iter()\n                 .map(|(name, ty)| cx.arg(trait_.span, name, ty));"}, {"sha": "362ea9ed2291f03d03dba86deacae0e41b0a6098", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -10,7 +10,7 @@ use syntax::ext::build::AstBuilder;\n use syntax::source_map::{respan, DUMMY_SP};\n use syntax::ptr::P;\n use syntax_pos::Span;\n-use syntax_pos::symbol::keywords;\n+use syntax_pos::symbol::kw;\n \n /// The types of pointers\n #[derive(Clone)]\n@@ -86,7 +86,7 @@ impl<'a> Path<'a> {\n             PathKind::Local => cx.path_all(span, false, idents, params, Vec::new()),\n             PathKind::Std => {\n                 let def_site = DUMMY_SP.apply_mark(cx.current_expansion.mark);\n-                idents.insert(0, Ident::new(keywords::DollarCrate.name(), def_site));\n+                idents.insert(0, Ident::new(kw::DollarCrate, def_site));\n                 cx.path_all(span, false, idents, params, Vec::new())\n             }\n         }"}, {"sha": "72a66ae3845d0c53032a04a0a22364544c611955", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -6,7 +6,7 @@\n use syntax::ast::{self, Ident, GenericArg};\n use syntax::ext::base::{self, *};\n use syntax::ext::build::AstBuilder;\n-use syntax::symbol::{keywords, Symbol, sym};\n+use syntax::symbol::{kw, sym, Symbol};\n use syntax_pos::Span;\n use syntax::tokenstream;\n \n@@ -24,7 +24,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt<'_>,\n     let sp = sp.apply_mark(cx.current_expansion.mark);\n     let e = match env::var(&*var.as_str()) {\n         Err(..) => {\n-            let lt = cx.lifetime(sp, keywords::StaticLifetime.ident());\n+            let lt = cx.lifetime(sp, Ident::with_empty_ctxt(kw::StaticLifetime));\n             cx.expr_path(cx.path_all(sp,\n                                      true,\n                                      cx.std_path(&[\"option\", \"Option\", \"None\"]),"}, {"sha": "a485bb19808db2a90a7495f73d7a62332673a607", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -13,7 +13,7 @@ use syntax::mut_visit::MutVisitor;\n use syntax::parse::ParseSess;\n use syntax::ptr::P;\n use syntax::symbol::Symbol;\n-use syntax::symbol::{keywords, sym};\n+use syntax::symbol::{kw, sym};\n use syntax::visit::{self, Visitor};\n \n use syntax_pos::{Span, DUMMY_SP};\n@@ -378,7 +378,7 @@ fn mk_decls(\n     let custom_derive = Ident::from_str(\"custom_derive\");\n     let attr = Ident::from_str(\"attr\");\n     let bang = Ident::from_str(\"bang\");\n-    let crate_kw = Ident::with_empty_ctxt(keywords::Crate.name());\n+    let crate_kw = Ident::with_empty_ctxt(kw::Crate);\n \n     let decls = {\n         let local_path = |sp: Span, name| {"}, {"sha": "69e83f5a84ceddd77e3cc298ea71ad2f60b3005f", "filename": "src/libsyntax_ext/proc_macro_server.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_server.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -14,7 +14,7 @@ use syntax::parse::lexer::comments;\n use syntax::parse::{self, token, ParseSess};\n use syntax::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream, TreeAndJoint};\n use syntax_pos::hygiene::{SyntaxContext, Transparency};\n-use syntax_pos::symbol::{keywords, Symbol};\n+use syntax_pos::symbol::{kw, Symbol};\n use syntax_pos::{BytePos, FileName, MultiSpan, Pos, SourceFile, Span};\n \n trait FromInternal<T> {\n@@ -142,7 +142,7 @@ impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n             Question => op!('?'),\n             SingleQuote => op!('\\''),\n \n-            Ident(ident, false) if ident.name == keywords::DollarCrate.name() =>\n+            Ident(ident, false) if ident.name == kw::DollarCrate =>\n                 tt!(Ident::dollar_crate()),\n             Ident(ident, is_raw) => tt!(Ident::new(ident.name, is_raw)),\n             Lifetime(ident) => {\n@@ -347,7 +347,7 @@ impl Ident {\n     }\n     fn dollar_crate(span: Span) -> Ident {\n         // `$crate` is accepted as an ident only if it comes from the compiler.\n-        Ident { sym: keywords::DollarCrate.name(), is_raw: false, span }\n+        Ident { sym: kw::DollarCrate, is_raw: false, span }\n     }\n }\n "}, {"sha": "61ef94560ccb95c6b718dd3bcdf3ebc56cc55f4f", "filename": "src/libsyntax_ext/trace_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax_ext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax_ext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftrace_macros.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -1,6 +1,6 @@\n use syntax::ext::base::{self, ExtCtxt};\n use syntax::feature_gate;\n-use syntax::symbol::{keywords, sym};\n+use syntax::symbol::{kw, sym};\n use syntax_pos::Span;\n use syntax::tokenstream::TokenTree;\n \n@@ -17,10 +17,10 @@ pub fn expand_trace_macros(cx: &mut ExtCtxt<'_>,\n     }\n \n     match (tt.len(), tt.first()) {\n-        (1, Some(&TokenTree::Token(_, ref tok))) if tok.is_keyword(keywords::True) => {\n+        (1, Some(&TokenTree::Token(_, ref tok))) if tok.is_keyword(kw::True) => {\n             cx.set_trace_macros(true);\n         }\n-        (1, Some(&TokenTree::Token(_, ref tok))) if tok.is_keyword(keywords::False) => {\n+        (1, Some(&TokenTree::Token(_, ref tok))) if tok.is_keyword(kw::False) => {\n             cx.set_trace_macros(false);\n         }\n         _ => cx.span_err(sp, \"trace_macros! accepts only `true` or `false`\"),"}, {"sha": "e8dcd8171c91fc14b9c518087c6279ac95ecc888", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -8,7 +8,7 @@\n use crate::GLOBALS;\n use crate::Span;\n use crate::edition::Edition;\n-use crate::symbol::{keywords, Symbol};\n+use crate::symbol::{kw, Symbol};\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -192,7 +192,7 @@ impl HygieneData {\n                 prev_ctxt: SyntaxContext(0),\n                 opaque: SyntaxContext(0),\n                 opaque_and_semitransparent: SyntaxContext(0),\n-                dollar_crate_name: keywords::DollarCrate.name(),\n+                dollar_crate_name: kw::DollarCrate,\n             }],\n             markings: FxHashMap::default(),\n         }\n@@ -245,7 +245,7 @@ impl SyntaxContext {\n                 prev_ctxt: SyntaxContext::empty(),\n                 opaque: SyntaxContext::empty(),\n                 opaque_and_semitransparent: SyntaxContext::empty(),\n-                dollar_crate_name: keywords::DollarCrate.name(),\n+                dollar_crate_name: kw::DollarCrate,\n             });\n             SyntaxContext(data.syntax_contexts.len() as u32 - 1)\n         })\n@@ -312,7 +312,7 @@ impl SyntaxContext {\n                         prev_ctxt,\n                         opaque: new_opaque,\n                         opaque_and_semitransparent: new_opaque,\n-                        dollar_crate_name: keywords::DollarCrate.name(),\n+                        dollar_crate_name: kw::DollarCrate,\n                     });\n                     new_opaque\n                 });\n@@ -330,7 +330,7 @@ impl SyntaxContext {\n                         prev_ctxt,\n                         opaque,\n                         opaque_and_semitransparent: new_opaque_and_semitransparent,\n-                        dollar_crate_name: keywords::DollarCrate.name(),\n+                        dollar_crate_name: kw::DollarCrate,\n                     });\n                     new_opaque_and_semitransparent\n                 });\n@@ -346,7 +346,7 @@ impl SyntaxContext {\n                     prev_ctxt,\n                     opaque,\n                     opaque_and_semitransparent,\n-                    dollar_crate_name: keywords::DollarCrate.name(),\n+                    dollar_crate_name: kw::DollarCrate,\n                 });\n                 new_opaque_and_semitransparent_and_transparent\n             })\n@@ -512,7 +512,7 @@ impl SyntaxContext {\n                 &mut data.syntax_contexts[self.0 as usize].dollar_crate_name, dollar_crate_name\n             );\n             assert!(dollar_crate_name == prev_dollar_crate_name ||\n-                    prev_dollar_crate_name == keywords::DollarCrate.name(),\n+                    prev_dollar_crate_name == kw::DollarCrate,\n                     \"$crate name is reset for a syntax context\");\n         })\n     }"}, {"sha": "6bcf83869a9745a93f30c5ad47381b349a109b5d", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 19, "deletions": 36, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a382122fb09e2a9b4629e36efbc63a321eab6a/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=59a382122fb09e2a9b4629e36efbc63a321eab6a", "patch": "@@ -692,7 +692,7 @@ impl Ident {\n     /// Transforms an underscore identifier into one with the same name, but\n     /// gensymed. Leaves non-underscore identifiers unchanged.\n     pub fn gensym_if_underscore(self) -> Ident {\n-        if self.name == keywords::Underscore.name() { self.gensym() } else { self }\n+        if self.name == kw::Underscore { self.gensym() } else { self }\n     }\n \n     // WARNING: this function is deprecated and will be removed in the future.\n@@ -864,8 +864,8 @@ impl Interner {\n         this.strings.reserve(init.len());\n \n         // We can't allocate empty strings in the arena, so handle this here.\n-        assert!(keywords::Invalid.name().as_u32() == 0 && init[0].is_empty());\n-        this.names.insert(\"\", keywords::Invalid.name());\n+        assert!(kw::Invalid.as_u32() == 0 && init[0].is_empty());\n+        this.names.insert(\"\", kw::Invalid);\n         this.strings.push(\"\");\n \n         for string in &init[1..] {\n@@ -926,26 +926,9 @@ impl Interner {\n     }\n }\n \n-pub mod keywords {\n-    use super::{Symbol, Ident};\n-\n-    #[derive(Clone, Copy, PartialEq, Eq)]\n-    pub struct Keyword {\n-        ident: Ident,\n-    }\n-\n-    impl Keyword {\n-        #[inline]\n-        pub fn ident(self) -> Ident {\n-            self.ident\n-        }\n-\n-        #[inline]\n-        pub fn name(self) -> Symbol {\n-            self.ident.name\n-        }\n-    }\n-\n+// This module has a very short name because it's used a lot.\n+pub mod kw {\n+    use super::Symbol;\n     keywords!();\n }\n \n@@ -957,32 +940,32 @@ pub mod sym {\n \n impl Symbol {\n     fn is_used_keyword_2018(self) -> bool {\n-        self == keywords::Dyn.name()\n+        self == kw::Dyn\n     }\n \n     fn is_unused_keyword_2018(self) -> bool {\n-        self >= keywords::Async.name() && self <= keywords::Try.name()\n+        self >= kw::Async && self <= kw::Try\n     }\n }\n \n impl Ident {\n     // Returns `true` for reserved identifiers used internally for elided lifetimes,\n     // unnamed method parameters, crate root module, error recovery etc.\n     pub fn is_special(self) -> bool {\n-        self.name <= keywords::Underscore.name()\n+        self.name <= kw::Underscore\n     }\n \n     /// Returns `true` if the token is a keyword used in the language.\n     pub fn is_used_keyword(self) -> bool {\n         // Note: `span.edition()` is relatively expensive, don't call it unless necessary.\n-        self.name >= keywords::As.name() && self.name <= keywords::While.name() ||\n+        self.name >= kw::As && self.name <= kw::While ||\n         self.name.is_used_keyword_2018() && self.span.rust_2018()\n     }\n \n     /// Returns `true` if the token is a keyword reserved for possible future use.\n     pub fn is_unused_keyword(self) -> bool {\n         // Note: `span.edition()` is relatively expensive, don't call it unless necessary.\n-        self.name >= keywords::Abstract.name() && self.name <= keywords::Yield.name() ||\n+        self.name >= kw::Abstract && self.name <= kw::Yield ||\n         self.name.is_unused_keyword_2018() && self.span.rust_2018()\n     }\n \n@@ -993,17 +976,17 @@ impl Ident {\n \n     /// A keyword or reserved identifier that can be used as a path segment.\n     pub fn is_path_segment_keyword(self) -> bool {\n-        self.name == keywords::Super.name() ||\n-        self.name == keywords::SelfLower.name() ||\n-        self.name == keywords::SelfUpper.name() ||\n-        self.name == keywords::Crate.name() ||\n-        self.name == keywords::PathRoot.name() ||\n-        self.name == keywords::DollarCrate.name()\n+        self.name == kw::Super ||\n+        self.name == kw::SelfLower ||\n+        self.name == kw::SelfUpper ||\n+        self.name == kw::Crate ||\n+        self.name == kw::PathRoot ||\n+        self.name == kw::DollarCrate\n     }\n \n     /// This identifier can be a raw identifier.\n     pub fn can_be_raw(self) -> bool {\n-        self.name != keywords::Invalid.name() && self.name != keywords::Underscore.name() &&\n+        self.name != kw::Invalid && self.name != kw::Underscore &&\n         !self.is_path_segment_keyword()\n     }\n \n@@ -1267,7 +1250,7 @@ mod tests {\n     fn without_first_quote_test() {\n         GLOBALS.set(&Globals::new(edition::DEFAULT_EDITION), || {\n             let i = Ident::from_str(\"'break\");\n-            assert_eq!(i.without_first_quote().name, keywords::Break.name());\n+            assert_eq!(i.without_first_quote().name, kw::Break);\n         });\n     }\n }"}]}