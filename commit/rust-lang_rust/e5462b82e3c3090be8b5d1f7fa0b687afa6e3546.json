{"sha": "e5462b82e3c3090be8b5d1f7fa0b687afa6e3546", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1NDYyYjgyZTNjMzA5MGJlOGI1ZDFmN2ZhMGI2ODdhZmE2ZTM1NDY=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-06-27T22:15:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-06-27T22:15:37Z"}, "message": "Rollup merge of #49987 - clarcharr:split_ascii_whitespace, r=SimonSapin\n\nAdd str::split_ascii_whitespace.\n\nAs mentioned in #48656.\n\nWhile `str::split_whitespace` now works in `libcore`, it still makes sense to offer this method, considering how it is still more performant in cases where only ASCII is necessary.", "tree": {"sha": "038c8066457355be5193c16c4efe8e9a2bc3af21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/038c8066457355be5193c16c4efe8e9a2bc3af21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5462b82e3c3090be8b5d1f7fa0b687afa6e3546", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbNAyJCRBK7hj4Ov3rIwAAdHIIADicqFOD+ue/Boxr13cQy1O+\nbl2fp3/Lz1u6gWhg2TSZYUSN3GHywU2XqHhdTHqxq/tJ3D+aY/8saBFkp3iY71mr\nL0Ph1nnUsS5Bal2oHWMniPcTRdPZuvmmuSo+iTllWW/HT5jcpLwnEm+H0qLN1ddl\niKy5kRmHdAQ/pJmQfE+EbkgWMSc9ECXV6+0igc+0FhqVP6BTo4k89eU/0dYxIiYZ\nTZlf+VS7uTcb98WO2jt04hFeYcMdwd05FOmtsbCrNXhPVTE1E7cwb+gKGsg+eW27\nQRrZHmol90RASOQOBVZm/v47xNiTUwSz0Bm/xXvY7wbj9Ki1bDkU6VHeEELc8SU=\n=Rcpz\n-----END PGP SIGNATURE-----\n", "payload": "tree 038c8066457355be5193c16c4efe8e9a2bc3af21\nparent 23b55161ab4cb6d4bf868ac575bd174ca2de0ffa\nparent b5cee029a55cd35fcdad52acb294a04ebff1f341\nauthor kennytm <kennytm@gmail.com> 1530137737 +0800\ncommitter GitHub <noreply@github.com> 1530137737 +0800\n\nRollup merge of #49987 - clarcharr:split_ascii_whitespace, r=SimonSapin\n\nAdd str::split_ascii_whitespace.\n\nAs mentioned in #48656.\n\nWhile `str::split_whitespace` now works in `libcore`, it still makes sense to offer this method, considering how it is still more performant in cases where only ASCII is necessary.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5462b82e3c3090be8b5d1f7fa0b687afa6e3546", "html_url": "https://github.com/rust-lang/rust/commit/e5462b82e3c3090be8b5d1f7fa0b687afa6e3546", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5462b82e3c3090be8b5d1f7fa0b687afa6e3546/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23b55161ab4cb6d4bf868ac575bd174ca2de0ffa", "url": "https://api.github.com/repos/rust-lang/rust/commits/23b55161ab4cb6d4bf868ac575bd174ca2de0ffa", "html_url": "https://github.com/rust-lang/rust/commit/23b55161ab4cb6d4bf868ac575bd174ca2de0ffa"}, {"sha": "b5cee029a55cd35fcdad52acb294a04ebff1f341", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5cee029a55cd35fcdad52acb294a04ebff1f341", "html_url": "https://github.com/rust-lang/rust/commit/b5cee029a55cd35fcdad52acb294a04ebff1f341"}], "stats": {"total": 162, "additions": 158, "deletions": 4}, "files": [{"sha": "ec9b5eba561060a21efc741df7d0d9867d40796a", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e5462b82e3c3090be8b5d1f7fa0b687afa6e3546/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5462b82e3c3090be8b5d1f7fa0b687afa6e3546/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=e5462b82e3c3090be8b5d1f7fa0b687afa6e3546", "patch": "@@ -108,6 +108,7 @@\n #![cfg_attr(stage0, feature(repr_transparent))]\n #![feature(rustc_attrs)]\n #![feature(specialization)]\n+#![feature(split_ascii_whitespace)]\n #![feature(staged_api)]\n #![feature(str_internals)]\n #![feature(trusted_len)]"}, {"sha": "ec9c39c916c4720badead169b96ad7a321588696", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5462b82e3c3090be8b5d1f7fa0b687afa6e3546/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5462b82e3c3090be8b5d1f7fa0b687afa6e3546/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=e5462b82e3c3090be8b5d1f7fa0b687afa6e3546", "patch": "@@ -78,6 +78,8 @@ pub use core::str::SplitWhitespace;\n pub use core::str::pattern;\n #[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n pub use core::str::EncodeUtf16;\n+#[unstable(feature = \"split_ascii_whitespace\", issue = \"48656\")]\n+pub use core::str::SplitAsciiWhitespace;\n \n #[unstable(feature = \"slice_concat_ext\",\n            reason = \"trait should not have to exist\","}, {"sha": "5ae2f6349e5b7e335846eeafb779c40e7ca106eb", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 155, "deletions": 4, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/e5462b82e3c3090be8b5d1f7fa0b687afa6e3546/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5462b82e3c3090be8b5d1f7fa0b687afa6e3546/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=e5462b82e3c3090be8b5d1f7fa0b687afa6e3546", "patch": "@@ -21,7 +21,7 @@ use char;\n use fmt;\n use iter::{Map, Cloned, FusedIterator, TrustedLen, Filter};\n use iter_private::TrustedRandomAccess;\n-use slice::{self, SliceIndex};\n+use slice::{self, SliceIndex, Split as SliceSplit};\n use mem;\n \n pub mod pattern;\n@@ -2722,7 +2722,10 @@ impl str {\n     /// the original string slice, separated by any amount of whitespace.\n     ///\n     /// 'Whitespace' is defined according to the terms of the Unicode Derived\n-    /// Core Property `White_Space`.\n+    /// Core Property `White_Space`. If you only want to split on ASCII whitespace\n+    /// instead, use [`split_ascii_whitespace`].\n+    ///\n+    /// [`split_ascii_whitespace`]: #method.split_ascii_whitespace\n     ///\n     /// # Examples\n     ///\n@@ -2756,6 +2759,53 @@ impl str {\n         SplitWhitespace { inner: self.split(IsWhitespace).filter(IsNotEmpty) }\n     }\n \n+    /// Split a string slice by ASCII whitespace.\n+    ///\n+    /// The iterator returned will return string slices that are sub-slices of\n+    /// the original string slice, separated by any amount of ASCII whitespace.\n+    ///\n+    /// To split by Unicode `Whitespace` instead, use [`split_whitespace`].\n+    ///\n+    /// [`split_whitespace`]: #method.split_whitespace\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(split_ascii_whitespace)]\n+    /// let mut iter = \"A few words\".split_ascii_whitespace();\n+    ///\n+    /// assert_eq!(Some(\"A\"), iter.next());\n+    /// assert_eq!(Some(\"few\"), iter.next());\n+    /// assert_eq!(Some(\"words\"), iter.next());\n+    ///\n+    /// assert_eq!(None, iter.next());\n+    /// ```\n+    ///\n+    /// All kinds of ASCII whitespace are considered:\n+    ///\n+    /// ```\n+    /// let mut iter = \" Mary   had\\ta little  \\n\\t lamb\".split_whitespace();\n+    /// assert_eq!(Some(\"Mary\"), iter.next());\n+    /// assert_eq!(Some(\"had\"), iter.next());\n+    /// assert_eq!(Some(\"a\"), iter.next());\n+    /// assert_eq!(Some(\"little\"), iter.next());\n+    /// assert_eq!(Some(\"lamb\"), iter.next());\n+    ///\n+    /// assert_eq!(None, iter.next());\n+    /// ```\n+    #[unstable(feature = \"split_ascii_whitespace\", issue = \"48656\")]\n+    #[inline]\n+    pub fn split_ascii_whitespace(&self) -> SplitAsciiWhitespace {\n+        let inner = self\n+            .as_bytes()\n+            .split(IsAsciiWhitespace)\n+            .filter(IsNotEmpty)\n+            .map(UnsafeBytesToStr);\n+        SplitAsciiWhitespace { inner }\n+    }\n+\n     /// An iterator over the lines of a string, as string slices.\n     ///\n     /// Lines are ended with either a newline (`\\n`) or a carriage return with\n@@ -3895,6 +3945,20 @@ pub struct SplitWhitespace<'a> {\n     inner: Filter<Split<'a, IsWhitespace>, IsNotEmpty>,\n }\n \n+/// An iterator over the non-ASCII-whitespace substrings of a string,\n+/// separated by any amount of ASCII whitespace.\n+///\n+/// This struct is created by the [`split_ascii_whitespace`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`split_ascii_whitespace`]: ../../std/primitive.str.html#method.split_ascii_whitespace\n+/// [`str`]: ../../std/primitive.str.html\n+#[unstable(feature = \"split_ascii_whitespace\", issue = \"48656\")]\n+#[derive(Clone, Debug)]\n+pub struct SplitAsciiWhitespace<'a> {\n+    inner: Map<Filter<SliceSplit<'a, u8, IsAsciiWhitespace>, IsNotEmpty>, UnsafeBytesToStr>,\n+}\n+\n #[derive(Clone)]\n struct IsWhitespace;\n \n@@ -3914,37 +3978,98 @@ impl FnMut<(char, )> for IsWhitespace {\n     }\n }\n \n+#[derive(Clone)]\n+struct IsAsciiWhitespace;\n+\n+impl<'a> FnOnce<(&'a u8, )> for IsAsciiWhitespace {\n+    type Output = bool;\n+\n+    #[inline]\n+    extern \"rust-call\" fn call_once(mut self, arg: (&u8, )) -> bool {\n+        self.call_mut(arg)\n+    }\n+}\n+\n+impl<'a> FnMut<(&'a u8, )> for IsAsciiWhitespace {\n+    #[inline]\n+    extern \"rust-call\" fn call_mut(&mut self, arg: (&u8, )) -> bool {\n+        arg.0.is_ascii_whitespace()\n+    }\n+}\n+\n #[derive(Clone)]\n struct IsNotEmpty;\n \n impl<'a, 'b> FnOnce<(&'a &'b str, )> for IsNotEmpty {\n     type Output = bool;\n \n     #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (&&str, )) -> bool {\n+    extern \"rust-call\" fn call_once(mut self, arg: (&'a &'b str, )) -> bool {\n         self.call_mut(arg)\n     }\n }\n \n impl<'a, 'b> FnMut<(&'a &'b str, )> for IsNotEmpty {\n     #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (&&str, )) -> bool {\n+    extern \"rust-call\" fn call_mut(&mut self, arg: (&'a &'b str, )) -> bool {\n+        !arg.0.is_empty()\n+    }\n+}\n+\n+impl<'a, 'b> FnOnce<(&'a &'b [u8], )> for IsNotEmpty {\n+    type Output = bool;\n+\n+    #[inline]\n+    extern \"rust-call\" fn call_once(mut self, arg: (&'a &'b [u8], )) -> bool {\n+        self.call_mut(arg)\n+    }\n+}\n+\n+impl<'a, 'b> FnMut<(&'a &'b [u8], )> for IsNotEmpty {\n+    #[inline]\n+    extern \"rust-call\" fn call_mut(&mut self, arg: (&'a &'b [u8], )) -> bool {\n         !arg.0.is_empty()\n     }\n }\n \n+#[derive(Clone)]\n+struct UnsafeBytesToStr;\n+\n+impl<'a> FnOnce<(&'a [u8], )> for UnsafeBytesToStr {\n+    type Output = &'a str;\n+\n+    #[inline]\n+    extern \"rust-call\" fn call_once(mut self, arg: (&'a [u8], )) -> &'a str {\n+        self.call_mut(arg)\n+    }\n+}\n+\n+impl<'a> FnMut<(&'a [u8], )> for UnsafeBytesToStr {\n+    #[inline]\n+    extern \"rust-call\" fn call_mut(&mut self, arg: (&'a [u8], )) -> &'a str {\n+        unsafe { from_utf8_unchecked(arg.0) }\n+    }\n+}\n+\n \n #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n impl<'a> Iterator for SplitWhitespace<'a> {\n     type Item = &'a str;\n \n+    #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n         self.inner.next()\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n \n #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n impl<'a> DoubleEndedIterator for SplitWhitespace<'a> {\n+    #[inline]\n     fn next_back(&mut self) -> Option<&'a str> {\n         self.inner.next_back()\n     }\n@@ -3953,6 +4078,32 @@ impl<'a> DoubleEndedIterator for SplitWhitespace<'a> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a> FusedIterator for SplitWhitespace<'a> {}\n \n+#[unstable(feature = \"split_ascii_whitespace\", issue = \"48656\")]\n+impl<'a> Iterator for SplitAsciiWhitespace<'a> {\n+    type Item = &'a str;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        self.inner.next()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"split_ascii_whitespace\", issue = \"48656\")]\n+impl<'a> DoubleEndedIterator for SplitAsciiWhitespace<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        self.inner.next_back()\n+    }\n+}\n+\n+#[unstable(feature = \"split_ascii_whitespace\", issue = \"48656\")]\n+impl<'a> FusedIterator for SplitAsciiWhitespace<'a> {}\n+\n /// An iterator of [`u16`] over the string encoded as UTF-16.\n ///\n /// [`u16`]: ../../std/primitive.u16.html"}]}