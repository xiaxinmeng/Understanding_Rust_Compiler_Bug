{"sha": "8c3c4466483af5f51b49148c64844ea0d31b59da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjM2M0NDY2NDgzYWY1ZjUxYjQ5MTQ4YzY0ODQ0ZWEwZDMxYjU5ZGE=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-12-15T16:14:24Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-12-21T12:29:30Z"}, "message": "Add more tests for slice patterns", "tree": {"sha": "1db7f14958118a4ffa95d50cffaf2d71e1f6cb5c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1db7f14958118a4ffa95d50cffaf2d71e1f6cb5c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c3c4466483af5f51b49148c64844ea0d31b59da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c3c4466483af5f51b49148c64844ea0d31b59da", "html_url": "https://github.com/rust-lang/rust/commit/8c3c4466483af5f51b49148c64844ea0d31b59da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c3c4466483af5f51b49148c64844ea0d31b59da/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d490c34086cbb91f5258f72a6a98e813bc2c9ce1", "url": "https://api.github.com/repos/rust-lang/rust/commits/d490c34086cbb91f5258f72a6a98e813bc2c9ce1", "html_url": "https://github.com/rust-lang/rust/commit/d490c34086cbb91f5258f72a6a98e813bc2c9ce1"}], "stats": {"total": 678, "additions": 678, "deletions": 0}, "files": [{"sha": "0e767d9613a996b7f591cfb472aab1d58b6e82f9", "filename": "src/test/ui/array-slice-vec/subslice-patterns-const-eval-match.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/8c3c4466483af5f51b49148c64844ea0d31b59da/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-const-eval-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3c4466483af5f51b49148c64844ea0d31b59da/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-const-eval-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-const-eval-match.rs?ref=8c3c4466483af5f51b49148c64844ea0d31b59da", "patch": "@@ -0,0 +1,97 @@\n+// Test that slice subslice patterns are correctly handled in const evaluation.\n+\n+// run-pass\n+\n+#![feature(slice_patterns, const_fn, const_if_match)]\n+#[derive(PartialEq, Debug, Clone)]\n+struct N(u8);\n+\n+#[derive(PartialEq, Debug, Clone)]\n+struct Z;\n+\n+macro_rules! n {\n+    ($($e:expr),* $(,)?) => {\n+        [$(N($e)),*]\n+    }\n+}\n+\n+// This macro has an unused variable so that it can be repeated base on the\n+// number of times a repeated variable (`$e` in `z`) occurs.\n+macro_rules! zed {\n+    ($e:expr) => { Z }\n+}\n+\n+macro_rules! z {\n+    ($($e:expr),* $(,)?) => {\n+        [$(zed!($e)),*]\n+    }\n+}\n+\n+// Compare constant evaluation and runtime evaluation of a given expression.\n+macro_rules! compare_evaluation_inner {\n+    ($e:expr, $t:ty $(,)?) => {{\n+        const CONST_EVAL: $t = $e;\n+        const fn const_eval() -> $t { $e }\n+        static CONST_EVAL2: $t = const_eval();\n+        let runtime_eval = $e;\n+        assert_eq!(CONST_EVAL, runtime_eval);\n+        assert_eq!(CONST_EVAL2, runtime_eval);\n+    }}\n+}\n+\n+// Compare the result of matching `$e` against `$p` using both `if let` and\n+// `match`.\n+macro_rules! compare_evaluation {\n+    ($p:pat, $e:expr, $matches:expr, $t:ty $(,)?) => {{\n+        compare_evaluation_inner!(if let $p = $e as &[_] { $matches } else { None }, $t);\n+        compare_evaluation_inner!(match $e as &[_] { $p => $matches, _ => None }, $t);\n+    }}\n+}\n+\n+// Repeat `$test`, substituting the given macro variables with the given\n+// identifiers.\n+//\n+// For example:\n+//\n+// repeat! {\n+//     ($name); X; Y:\n+//     struct $name;\n+// }\n+//\n+// Expands to:\n+//\n+// struct X; struct Y;\n+//\n+// This is used to repeat the tests using both the `N` and `Z`\n+// types.\n+macro_rules! repeat {\n+    (($($dollar:tt $placeholder:ident)*); $($($values:ident),+);*: $($test:tt)*) => {\n+        macro_rules! single {\n+            ($($dollar $placeholder:ident),*) => { $($test)* }\n+        }\n+        $(single!($($values),+);)*\n+    }\n+}\n+\n+fn main() {\n+    repeat! {\n+        ($arr $Ty); n, N; z, Z:\n+        compare_evaluation!([_, x @ .., _], &$arr!(1, 2, 3, 4), Some(x), Option<&'static [$Ty]>);\n+        compare_evaluation!([x, .., _], &$arr!(1, 2, 3, 4), Some(x), Option<&'static $Ty>);\n+        compare_evaluation!([_, .., x], &$arr!(1, 2, 3, 4), Some(x), Option<&'static $Ty>);\n+\n+        compare_evaluation!([_, x @ .., _], &$arr!(1, 2), Some(x), Option<&'static [$Ty]>);\n+        compare_evaluation!([x, .., _], &$arr!(1, 2), Some(x), Option<&'static $Ty>);\n+        compare_evaluation!([_, .., x], &$arr!(1, 2), Some(x), Option<&'static $Ty>);\n+\n+        compare_evaluation!([_, x @ .., _], &$arr!(1), Some(x), Option<&'static [$Ty]>);\n+        compare_evaluation!([x, .., _], &$arr!(1), Some(x), Option<&'static $Ty>);\n+        compare_evaluation!([_, .., x], &$arr!(1), Some(x), Option<&'static $Ty>);\n+    }\n+\n+    compare_evaluation!([N(x), .., _], &n!(1, 2, 3, 4), Some(x), Option<&'static u8>);\n+    compare_evaluation!([_, .., N(x)], &n!(1, 2, 3, 4), Some(x), Option<&'static u8>);\n+\n+    compare_evaluation!([N(x), .., _], &n!(1, 2), Some(x), Option<&'static u8>);\n+    compare_evaluation!([_, .., N(x)], &n!(1, 2), Some(x), Option<&'static u8>);\n+}"}, {"sha": "5444f8a9051bdae248ee4b09fb684ecc93f09053", "filename": "src/test/ui/array-slice-vec/subslice-patterns-const-eval.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/8c3c4466483af5f51b49148c64844ea0d31b59da/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-const-eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3c4466483af5f51b49148c64844ea0d31b59da/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-const-eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-const-eval.rs?ref=8c3c4466483af5f51b49148c64844ea0d31b59da", "patch": "@@ -0,0 +1,97 @@\n+// Test that array subslice patterns are correctly handled in const evaluation.\n+\n+// run-pass\n+\n+#![feature(slice_patterns)]\n+\n+#[derive(PartialEq, Debug, Clone)]\n+struct N(u8);\n+\n+#[derive(PartialEq, Debug, Clone)]\n+struct Z;\n+\n+macro_rules! n {\n+    ($($e:expr),* $(,)?) => {\n+        [$(N($e)),*]\n+    }\n+}\n+\n+// This macro has an unused variable so that it can be repeated base on the\n+// number of times a repeated variable (`$e` in `z`) occurs.\n+macro_rules! zed {\n+    ($e:expr) => { Z }\n+}\n+\n+macro_rules! z {\n+    ($($e:expr),* $(,)?) => {\n+        [$(zed!($e)),*]\n+    }\n+}\n+\n+// Compare constant evaluation and runtime evaluation of a given expression.\n+macro_rules! compare_evaluation {\n+    ($e:expr, $t:ty $(,)?) => {{\n+        const CONST_EVAL: $t = $e;\n+        const fn const_eval() -> $t { $e }\n+        static CONST_EVAL2: $t = const_eval();\n+        let runtime_eval = $e;\n+        assert_eq!(CONST_EVAL, runtime_eval);\n+        assert_eq!(CONST_EVAL2, runtime_eval);\n+    }}\n+}\n+\n+// Repeat `$test`, substituting the given macro variables with the given\n+// identifiers.\n+//\n+// For example:\n+//\n+// repeat! {\n+//     ($name); X; Y:\n+//     struct $name;\n+// }\n+//\n+// Expands to:\n+//\n+// struct X; struct Y;\n+//\n+// This is used to repeat the tests using both the `N` and `Z`\n+// types.\n+macro_rules! repeat {\n+    (($($dollar:tt $placeholder:ident)*); $($($values:ident),+);*: $($test:tt)*) => {\n+        macro_rules! single {\n+            ($($dollar $placeholder:ident),*) => { $($test)* }\n+        }\n+        $(single!($($values),+);)*\n+    }\n+}\n+\n+fn main() {\n+    repeat! {\n+        ($arr $Ty); n, N; z, Z:\n+        compare_evaluation!({ let [_, x @ .., _] = $arr!(1, 2, 3, 4); x }, [$Ty; 2]);\n+        compare_evaluation!({ let [_, ref x @ .., _] = $arr!(1, 2, 3, 4); x }, &'static [$Ty; 2]);\n+        compare_evaluation!({ let [_, x @ .., _] = &$arr!(1, 2, 3, 4); x }, &'static [$Ty; 2]);\n+\n+        compare_evaluation!({ let [_, _, x @ .., _, _] = $arr!(1, 2, 3, 4); x }, [$Ty; 0]);\n+        compare_evaluation!(\n+            { let [_, _, ref x @ .., _, _] = $arr!(1, 2, 3, 4); x },\n+            &'static [$Ty; 0],\n+        );\n+        compare_evaluation!(\n+            { let [_, _, x @ .., _, _] = &$arr!(1, 2, 3, 4); x },\n+            &'static [$Ty; 0],\n+        );\n+\n+        compare_evaluation!({ let [_, .., x] = $arr!(1, 2, 3, 4); x }, $Ty);\n+        compare_evaluation!({ let [_, .., ref x] = $arr!(1, 2, 3, 4); x }, &'static $Ty);\n+        compare_evaluation!({ let [_, _y @ .., x] = &$arr!(1, 2, 3, 4); x }, &'static $Ty);\n+    }\n+\n+    compare_evaluation!({ let [_, .., N(x)] = n!(1, 2, 3, 4); x }, u8);\n+    compare_evaluation!({ let [_, .., N(ref x)] = n!(1, 2, 3, 4); x }, &'static u8);\n+    compare_evaluation!({ let [_, .., N(x)] = &n!(1, 2, 3, 4); x }, &'static u8);\n+\n+    compare_evaluation!({ let [N(x), .., _] = n!(1, 2, 3, 4); x }, u8);\n+    compare_evaluation!({ let [N(ref x), .., _] = n!(1, 2, 3, 4); x }, &'static u8);\n+    compare_evaluation!({ let [N(x), .., _] = &n!(1, 2, 3, 4); x }, &'static u8);\n+}"}, {"sha": "a70ccb7aa4b73ccd51c7f5cbee83a09a70ac9eb0", "filename": "src/test/ui/borrowck/borrowck-closures-slice-patterns-ok.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/8c3c4466483af5f51b49148c64844ea0d31b59da/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3c4466483af5f51b49148c64844ea0d31b59da/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns-ok.rs?ref=8c3c4466483af5f51b49148c64844ea0d31b59da", "patch": "@@ -0,0 +1,118 @@\n+// Check that closure captures for slice patterns are inferred correctly\n+\n+#![feature(slice_patterns)]\n+#![allow(unused_variables)]\n+\n+// run-pass\n+\n+fn arr_by_ref(x: [String; 3]) {\n+    let r = &x;\n+    let f = || {\n+        let [ref y, ref z @ ..] = x;\n+    };\n+    f();\n+    f();\n+    // Ensure `x` was borrowed\n+    drop(r);\n+    // Ensure that `x` wasn't moved from.\n+    drop(x);\n+}\n+\n+fn arr_by_mut(mut x: [String; 3]) {\n+    let mut f = || {\n+        let [ref mut y, ref mut z @ ..] = x;\n+    };\n+    f();\n+    f();\n+    drop(x);\n+}\n+\n+fn arr_by_move(x: [String; 3]) {\n+    let f = || {\n+        let [y, z @ ..] = x;\n+    };\n+    f();\n+}\n+\n+fn arr_ref_by_ref(x: &[String; 3]) {\n+    let r = &x;\n+    let f = || {\n+        let [ref y, ref z @ ..] = *x;\n+    };\n+    let g = || {\n+        let [y, z @ ..] = x;\n+    };\n+    f();\n+    g();\n+    f();\n+    g();\n+    drop(r);\n+    drop(x);\n+}\n+\n+fn arr_ref_by_mut(x: &mut [String; 3]) {\n+    let mut f = || {\n+        let [ref mut y, ref mut z @ ..] = *x;\n+    };\n+    f();\n+    f();\n+    let mut g = || {\n+        let [y, z @ ..] = x;\n+        // Ensure binding mode was chosen correctly:\n+        std::mem::swap(y, &mut z[0]);\n+    };\n+    g();\n+    g();\n+    drop(x);\n+}\n+\n+fn arr_box_by_move(x: Box<[String; 3]>) {\n+    let f = || {\n+        let [y, z @ ..] = *x;\n+    };\n+    f();\n+}\n+\n+fn slice_by_ref(x: &[String]) {\n+    let r = &x;\n+    let f = || {\n+        if let [ref y, ref z @ ..] = *x {}\n+    };\n+    let g = || {\n+        if let [y, z @ ..] = x {}\n+    };\n+    f();\n+    g();\n+    f();\n+    g();\n+    drop(r);\n+    drop(x);\n+}\n+\n+fn slice_by_mut(x: &mut [String]) {\n+    let mut f = || {\n+        if let [ref mut y, ref mut z @ ..] = *x {}\n+    };\n+    f();\n+    f();\n+    let mut g = || {\n+        if let [y, z @ ..] = x {\n+            // Ensure binding mode was chosen correctly:\n+            std::mem::swap(y, &mut z[0]);\n+        }\n+    };\n+    g();\n+    g();\n+    drop(x);\n+}\n+\n+fn main() {\n+    arr_by_ref(Default::default());\n+    arr_by_mut(Default::default());\n+    arr_by_move(Default::default());\n+    arr_ref_by_ref(&Default::default());\n+    arr_ref_by_mut(&mut Default::default());\n+    arr_box_by_move(Default::default());\n+    slice_by_ref(&<[_; 3]>::default());\n+    slice_by_mut(&mut <[_; 3]>::default());\n+}"}, {"sha": "984eb8804b7a2ea7be683182b4fc62e25c070ba4", "filename": "src/test/ui/borrowck/borrowck-closures-slice-patterns.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/8c3c4466483af5f51b49148c64844ea0d31b59da/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3c4466483af5f51b49148c64844ea0d31b59da/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns.rs?ref=8c3c4466483af5f51b49148c64844ea0d31b59da", "patch": "@@ -0,0 +1,84 @@\n+// Check that closure captures for slice patterns are inferred correctly\n+\n+#![feature(slice_patterns)]\n+\n+fn arr_by_ref(mut x: [String; 3]) {\n+    let f = || {\n+        let [ref y, ref z @ ..] = x;\n+    };\n+    let r = &mut x;\n+    //~^ ERROR cannot borrow\n+    f();\n+}\n+\n+fn arr_by_mut(mut x: [String; 3]) {\n+    let mut f = || {\n+        let [ref mut y, ref mut z @ ..] = x;\n+    };\n+    let r = &x;\n+    //~^ ERROR cannot borrow\n+    f();\n+}\n+\n+fn arr_by_move(x: [String; 3]) {\n+    let f = || {\n+        let [y, z @ ..] = x;\n+    };\n+    &x;\n+    //~^ ERROR borrow of moved value\n+}\n+\n+fn arr_ref_by_ref(x: &mut [String; 3]) {\n+    let f = || {\n+        let [ref y, ref z @ ..] = *x;\n+    };\n+    let r = &mut *x;\n+    //~^ ERROR cannot borrow\n+    f();\n+}\n+\n+fn arr_ref_by_uniq(x: &mut [String; 3]) {\n+    let mut f = || {\n+        let [ref mut y, ref mut z @ ..] = *x;\n+    };\n+    let r = &x;\n+    //~^ ERROR cannot borrow\n+    f();\n+}\n+\n+fn arr_box_by_move(x: Box<[String; 3]>) {\n+    let f = || {\n+        let [y, z @ ..] = *x;\n+    };\n+    &x;\n+    //~^ ERROR borrow of moved value\n+}\n+\n+fn slice_by_ref(x: &mut [String]) {\n+    let f = || {\n+        if let [ref y, ref z @ ..] = *x {}\n+    };\n+    let r = &mut *x;\n+    //~^ ERROR cannot borrow\n+    f();\n+}\n+\n+fn slice_by_uniq(x: &mut [String]) {\n+    let mut f = || {\n+        if let [ref mut y, ref mut z @ ..] = *x {}\n+    };\n+    let r = &x;\n+    //~^ ERROR cannot borrow\n+    f();\n+}\n+\n+fn main() {\n+    arr_by_ref(Default::default());\n+    arr_by_mut(Default::default());\n+    arr_by_move(Default::default());\n+    arr_ref_by_ref(&mut Default::default());\n+    arr_ref_by_uniq(&mut Default::default());\n+    arr_box_by_move(Default::default());\n+    slice_by_ref(&mut <[_; 3]>::default());\n+    slice_by_uniq(&mut <[_; 3]>::default());\n+}"}, {"sha": "c5b27f5f8b4032d34ae46e4f041d5f4f67c0ad77", "filename": "src/test/ui/borrowck/borrowck-closures-slice-patterns.stderr", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/8c3c4466483af5f51b49148c64844ea0d31b59da/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c3c4466483af5f51b49148c64844ea0d31b59da/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns.stderr?ref=8c3c4466483af5f51b49148c64844ea0d31b59da", "patch": "@@ -0,0 +1,114 @@\n+error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-closures-slice-patterns.rs:9:13\n+   |\n+LL |     let f = || {\n+   |             -- immutable borrow occurs here\n+LL |         let [ref y, ref z @ ..] = x;\n+   |                                   - first borrow occurs due to use of `x` in closure\n+LL |     };\n+LL |     let r = &mut x;\n+   |             ^^^^^^ mutable borrow occurs here\n+LL |\n+LL |     f();\n+   |     - immutable borrow later used here\n+\n+error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-closures-slice-patterns.rs:18:13\n+   |\n+LL |     let mut f = || {\n+   |                 -- mutable borrow occurs here\n+LL |         let [ref mut y, ref mut z @ ..] = x;\n+   |                                           - first borrow occurs due to use of `x` in closure\n+LL |     };\n+LL |     let r = &x;\n+   |             ^^ immutable borrow occurs here\n+LL |\n+LL |     f();\n+   |     - mutable borrow later used here\n+\n+error[E0382]: borrow of moved value: `x`\n+  --> $DIR/borrowck-closures-slice-patterns.rs:27:5\n+   |\n+LL | fn arr_by_move(x: [String; 3]) {\n+   |                - move occurs because `x` has type `[std::string::String; 3]`, which does not implement the `Copy` trait\n+LL |     let f = || {\n+   |             -- value moved into closure here\n+LL |         let [y, z @ ..] = x;\n+   |                           - variable moved due to use in closure\n+LL |     };\n+LL |     &x;\n+   |     ^^ value borrowed here after move\n+\n+error[E0502]: cannot borrow `*x` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-closures-slice-patterns.rs:35:13\n+   |\n+LL |     let f = || {\n+   |             -- immutable borrow occurs here\n+LL |         let [ref y, ref z @ ..] = *x;\n+   |                                    - first borrow occurs due to use of `x` in closure\n+LL |     };\n+LL |     let r = &mut *x;\n+   |             ^^^^^^^ mutable borrow occurs here\n+LL |\n+LL |     f();\n+   |     - immutable borrow later used here\n+\n+error[E0501]: cannot borrow `x` as immutable because previous closure requires unique access\n+  --> $DIR/borrowck-closures-slice-patterns.rs:44:13\n+   |\n+LL |     let mut f = || {\n+   |                 -- closure construction occurs here\n+LL |         let [ref mut y, ref mut z @ ..] = *x;\n+   |                                            - first borrow occurs due to use of `x` in closure\n+LL |     };\n+LL |     let r = &x;\n+   |             ^^ second borrow occurs here\n+LL |\n+LL |     f();\n+   |     - first borrow later used here\n+\n+error[E0382]: borrow of moved value: `x`\n+  --> $DIR/borrowck-closures-slice-patterns.rs:53:5\n+   |\n+LL | fn arr_box_by_move(x: Box<[String; 3]>) {\n+   |                    - move occurs because `x` has type `std::boxed::Box<[std::string::String; 3]>`, which does not implement the `Copy` trait\n+LL |     let f = || {\n+   |             -- value moved into closure here\n+LL |         let [y, z @ ..] = *x;\n+   |                            - variable moved due to use in closure\n+LL |     };\n+LL |     &x;\n+   |     ^^ value borrowed here after move\n+\n+error[E0502]: cannot borrow `*x` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-closures-slice-patterns.rs:61:13\n+   |\n+LL |     let f = || {\n+   |             -- immutable borrow occurs here\n+LL |         if let [ref y, ref z @ ..] = *x {}\n+   |                                       - first borrow occurs due to use of `x` in closure\n+LL |     };\n+LL |     let r = &mut *x;\n+   |             ^^^^^^^ mutable borrow occurs here\n+LL |\n+LL |     f();\n+   |     - immutable borrow later used here\n+\n+error[E0501]: cannot borrow `x` as immutable because previous closure requires unique access\n+  --> $DIR/borrowck-closures-slice-patterns.rs:70:13\n+   |\n+LL |     let mut f = || {\n+   |                 -- closure construction occurs here\n+LL |         if let [ref mut y, ref mut z @ ..] = *x {}\n+   |                                               - first borrow occurs due to use of `x` in closure\n+LL |     };\n+LL |     let r = &x;\n+   |             ^^ second borrow occurs here\n+LL |\n+LL |     f();\n+   |     - first borrow later used here\n+\n+error: aborting due to 8 previous errors\n+\n+Some errors have detailed explanations: E0382, E0501, E0502.\n+For more information about an error, try `rustc --explain E0382`."}, {"sha": "4ca60ddfec27c7c941c3eaa066f7be226cf3e85d", "filename": "src/test/ui/moves/move-out-of-array-ref.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8c3c4466483af5f51b49148c64844ea0d31b59da/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-array-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3c4466483af5f51b49148c64844ea0d31b59da/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-array-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-array-ref.rs?ref=8c3c4466483af5f51b49148c64844ea0d31b59da", "patch": "@@ -0,0 +1,36 @@\n+// Ensure that we cannot move out of a reference to a fixed-size array\n+\n+#![feature(slice_patterns)]\n+\n+struct D { _x: u8 }\n+\n+impl Drop for D { fn drop(&mut self) { } }\n+\n+fn move_elem(a: &[D; 4]) -> D {\n+    let [_, e, _, _] = *a;              //~ ERROR cannot move\n+    e\n+}\n+\n+fn move_subarr(a: &[D; 4]) -> [D; 2] {\n+    let [_, s @ .. , _] = *a;           //~ ERROR cannot move\n+    s\n+}\n+\n+fn move_elem_mut(a: &mut [D; 4]) -> D {\n+    let [_, e, _, _] = *a;              //~ ERROR cannot move\n+    e\n+}\n+\n+fn move_subarr_mut(a: &mut [D; 4]) -> [D; 2] {\n+    let [_, s @ .. , _] = *a;           //~ ERROR cannot move\n+    s\n+}\n+\n+fn main() {\n+    fn d() -> D { D { _x: 0 } }\n+\n+    move_elem(&[d(), d(), d(), d()]);\n+    move_subarr(&[d(), d(), d(), d()]);\n+    move_elem_mut(&mut [d(), d(), d(), d()]);\n+    move_subarr_mut(&mut [d(), d(), d(), d()]);\n+}"}, {"sha": "ae3d2f5f2826ac6fed5642bca720cdeb5dbf1c59", "filename": "src/test/ui/moves/move-out-of-array-ref.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8c3c4466483af5f51b49148c64844ea0d31b59da/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-array-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c3c4466483af5f51b49148c64844ea0d31b59da/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-array-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-array-ref.stderr?ref=8c3c4466483af5f51b49148c64844ea0d31b59da", "patch": "@@ -0,0 +1,47 @@\n+error[E0508]: cannot move out of type `[D; 4]`, a non-copy array\n+  --> $DIR/move-out-of-array-ref.rs:10:24\n+   |\n+LL |     let [_, e, _, _] = *a;\n+   |             -          ^^\n+   |             |          |\n+   |             |          cannot move out of here\n+   |             |          help: consider borrowing here: `&*a`\n+   |             data moved here\n+   |             move occurs because `e` has type `D`, which does not implement the `Copy` trait\n+\n+error[E0508]: cannot move out of type `[D; 4]`, a non-copy array\n+  --> $DIR/move-out-of-array-ref.rs:15:27\n+   |\n+LL |     let [_, s @ .. , _] = *a;\n+   |             ------        ^^\n+   |             |             |\n+   |             |             cannot move out of here\n+   |             |             help: consider borrowing here: `&*a`\n+   |             data moved here\n+   |             move occurs because `s` has type `[D; 2]`, which does not implement the `Copy` trait\n+\n+error[E0508]: cannot move out of type `[D; 4]`, a non-copy array\n+  --> $DIR/move-out-of-array-ref.rs:20:24\n+   |\n+LL |     let [_, e, _, _] = *a;\n+   |             -          ^^\n+   |             |          |\n+   |             |          cannot move out of here\n+   |             |          help: consider borrowing here: `&*a`\n+   |             data moved here\n+   |             move occurs because `e` has type `D`, which does not implement the `Copy` trait\n+\n+error[E0508]: cannot move out of type `[D; 4]`, a non-copy array\n+  --> $DIR/move-out-of-array-ref.rs:25:27\n+   |\n+LL |     let [_, s @ .. , _] = *a;\n+   |             ------        ^^\n+   |             |             |\n+   |             |             cannot move out of here\n+   |             |             help: consider borrowing here: `&*a`\n+   |             data moved here\n+   |             move occurs because `s` has type `[D; 2]`, which does not implement the `Copy` trait\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0508`."}, {"sha": "e460246193e5b88d58e46a4c514cf0294f10b649", "filename": "src/test/ui/moves/move-out-of-slice-2.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8c3c4466483af5f51b49148c64844ea0d31b59da/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c3c4466483af5f51b49148c64844ea0d31b59da/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.rs?ref=8c3c4466483af5f51b49148c64844ea0d31b59da", "patch": "@@ -0,0 +1,34 @@\n+#![feature(slice_patterns, unsized_locals)]\n+\n+struct A;\n+#[derive(Clone, Copy)]\n+struct C;\n+\n+fn main() {\n+    let a: Box<[A]> = Box::new([A]);\n+    match *a {\n+        //~^ ERROR cannot move out of type `[A]`, a non-copy slice\n+        [a @ ..] => {},\n+        _ => {}\n+    }\n+    let b: Box<[A]> = Box::new([A, A, A]);\n+    match *b {\n+        //~^ ERROR cannot move out of type `[A]`, a non-copy slice\n+        [_, _, b @ .., _] => {},\n+        _ => {}\n+    }\n+\n+    // `[C]` isn't `Copy`, even if `C` is.\n+    let c: Box<[C]> = Box::new([C]);\n+    match *c {\n+        //~^ ERROR cannot move out of type `[C]`, a non-copy slice\n+        [c @ ..] => {},\n+        _ => {}\n+    }\n+    let d: Box<[C]> = Box::new([C, C, C]);\n+    match *d {\n+        //~^ ERROR cannot move out of type `[C]`, a non-copy slice\n+        [_, _, d @ .., _] => {},\n+        _ => {}\n+    }\n+}"}, {"sha": "058f34b24a3b62ab2627973bbc4f7c519f6cad05", "filename": "src/test/ui/moves/move-out-of-slice-2.stderr", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8c3c4466483af5f51b49148c64844ea0d31b59da/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c3c4466483af5f51b49148c64844ea0d31b59da/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.stderr?ref=8c3c4466483af5f51b49148c64844ea0d31b59da", "patch": "@@ -0,0 +1,51 @@\n+error[E0508]: cannot move out of type `[A]`, a non-copy slice\n+  --> $DIR/move-out-of-slice-2.rs:9:11\n+   |\n+LL |     match *a {\n+   |           ^^ cannot move out of here\n+LL |\n+LL |         [a @ ..] => {},\n+   |          ------\n+   |          |\n+   |          data moved here\n+   |          move occurs because `a` has type `[A]`, which does not implement the `Copy` trait\n+\n+error[E0508]: cannot move out of type `[A]`, a non-copy slice\n+  --> $DIR/move-out-of-slice-2.rs:15:11\n+   |\n+LL |     match *b {\n+   |           ^^ cannot move out of here\n+LL |\n+LL |         [_, _, b @ .., _] => {},\n+   |                ------\n+   |                |\n+   |                data moved here\n+   |                move occurs because `b` has type `[A]`, which does not implement the `Copy` trait\n+\n+error[E0508]: cannot move out of type `[C]`, a non-copy slice\n+  --> $DIR/move-out-of-slice-2.rs:23:11\n+   |\n+LL |     match *c {\n+   |           ^^ cannot move out of here\n+LL |\n+LL |         [c @ ..] => {},\n+   |          ------\n+   |          |\n+   |          data moved here\n+   |          move occurs because `c` has type `[C]`, which does not implement the `Copy` trait\n+\n+error[E0508]: cannot move out of type `[C]`, a non-copy slice\n+  --> $DIR/move-out-of-slice-2.rs:29:11\n+   |\n+LL |     match *d {\n+   |           ^^ cannot move out of here\n+LL |\n+LL |         [_, _, d @ .., _] => {},\n+   |                ------\n+   |                |\n+   |                data moved here\n+   |                move occurs because `d` has type `[C]`, which does not implement the `Copy` trait\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0508`."}]}