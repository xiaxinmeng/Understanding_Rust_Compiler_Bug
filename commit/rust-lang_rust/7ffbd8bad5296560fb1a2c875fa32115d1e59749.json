{"sha": "7ffbd8bad5296560fb1a2c875fa32115d1e59749", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmZmJkOGJhZDUyOTY1NjBmYjFhMmM4NzVmYTMyMTE1ZDFlNTk3NDk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-17T16:35:52Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-17T19:50:31Z"}, "message": "rollup merge of #19943: steveklabnik/doc_std_vec\n\nRandom improvements to the `std::vec` docs.", "tree": {"sha": "18409a7c8e17ebd1c2bf3dfe98ab04a9585f9a6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18409a7c8e17ebd1c2bf3dfe98ab04a9585f9a6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ffbd8bad5296560fb1a2c875fa32115d1e59749", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ffbd8bad5296560fb1a2c875fa32115d1e59749", "html_url": "https://github.com/rust-lang/rust/commit/7ffbd8bad5296560fb1a2c875fa32115d1e59749", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ffbd8bad5296560fb1a2c875fa32115d1e59749/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbc3cf7a9e6db15dd859639cc016b28c14994b62", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbc3cf7a9e6db15dd859639cc016b28c14994b62", "html_url": "https://github.com/rust-lang/rust/commit/cbc3cf7a9e6db15dd859639cc016b28c14994b62"}, {"sha": "18c420ed6250f605d3a67739d5513ffe4f2914d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/18c420ed6250f605d3a67739d5513ffe4f2914d6", "html_url": "https://github.com/rust-lang/rust/commit/18c420ed6250f605d3a67739d5513ffe4f2914d6"}], "stats": {"total": 179, "additions": 105, "deletions": 74}, "files": [{"sha": "75a389a7c9500e959bfa98aec93041bef8204e1e", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 105, "deletions": 74, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/7ffbd8bad5296560fb1a2c875fa32115d1e59749/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ffbd8bad5296560fb1a2c875fa32115d1e59749/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=7ffbd8bad5296560fb1a2c875fa32115d1e59749", "patch": "@@ -11,6 +11,38 @@\n //! A growable list type, written `Vec<T>` but pronounced 'vector.'\n //!\n //! Vectors have `O(1)` indexing, push (to the end) and pop (from the end).\n+//!\n+//! # Examples\n+//!\n+//! Explicitly creating a `Vec<T>` with `new()`:\n+//!\n+//! ```\n+//! let xs: Vec<i32> = Vec::new();\n+//! ```\n+//!\n+//! Using the `vec!` macro:\n+//!\n+//! ```\n+//! let ys: Vec<i32> = vec![];\n+//!\n+//! let zs = vec![1i32, 2, 3, 4, 5];\n+//! ```\n+//!\n+//! Push:\n+//!\n+//! ```\n+//! let mut xs = vec![1i32, 2];\n+//!\n+//! xs.push(3);\n+//! ```\n+//!\n+//! And pop:\n+//!\n+//! ```\n+//! let mut xs = vec![1i32, 2];\n+//!\n+//! let two = xs.pop();\n+//! ```\n \n use core::prelude::*;\n \n@@ -32,7 +64,7 @@ use core::uint;\n \n use slice::CloneSliceExt;\n \n-/// An owned, growable vector.\n+/// A growable list type, written `Vec<T>` but pronounced 'vector.'\n ///\n /// # Examples\n ///\n@@ -66,7 +98,7 @@ use slice::CloneSliceExt;\n /// assert_eq!(vec, vec![1, 2, 3, 4]);\n /// ```\n ///\n-/// Use a `Vec` as an efficient stack:\n+/// Use a `Vec<T>` as an efficient stack:\n ///\n /// ```\n /// let mut stack = Vec::new();\n@@ -87,20 +119,17 @@ use slice::CloneSliceExt;\n ///\n /// # Capacity and reallocation\n ///\n-/// The capacity of a vector is the amount of space allocated for any future\n-/// elements that will be added onto the vector. This is not to be confused\n-/// with the *length* of a vector, which specifies the number of actual\n-/// elements within the vector. If a vector's length exceeds its capacity,\n-/// its capacity will automatically be increased, but its elements will\n-/// have to be reallocated.\n+/// The capacity of a vector is the amount of space allocated for any future elements that will be\n+/// added onto the vector. This is not to be confused with the *length* of a vector, which\n+/// specifies the number of actual elements within the vector. If a vector's length exceeds its\n+/// capacity, its capacity will automatically be increased, but its elements will have to be\n+/// reallocated.\n ///\n-/// For example, a vector with capacity 10 and length 0 would be an empty\n-/// vector with space for 10 more elements. Pushing 10 or fewer elements onto\n-/// the vector will not change its capacity or cause reallocation to occur.\n-/// However, if the vector's length is increased to 11, it will have to\n-/// reallocate, which can be slow. For this reason, it is recommended\n-/// to use `Vec::with_capacity` whenever possible to specify how big the vector\n-/// is expected to get.\n+/// For example, a vector with capacity 10 and length 0 would be an empty vector with space for 10\n+/// more elements. Pushing 10 or fewer elements onto the vector will not change its capacity or\n+/// cause reallocation to occur. However, if the vector's length is increased to 11, it will have\n+/// to reallocate, which can be slow. For this reason, it is recommended to use\n+/// `Vec::with_capacity` whenever possible to specify how big the vector is expected to get.\n #[unsafe_no_drop_flag]\n #[stable]\n pub struct Vec<T> {\n@@ -131,7 +160,7 @@ impl<'a, T> IntoCow<'a, Vec<T>, [T]> for &'a [T] where T: Clone {\n }\n \n impl<T> Vec<T> {\n-    /// Constructs a new, empty `Vec`.\n+    /// Constructs a new, empty `Vec<T>`.\n     ///\n     /// The vector will not allocate until elements are pushed onto it.\n     ///\n@@ -150,16 +179,15 @@ impl<T> Vec<T> {\n         Vec { ptr: EMPTY as *mut T, len: 0, cap: 0 }\n     }\n \n-    /// Constructs a new, empty `Vec` with the specified capacity.\n+    /// Constructs a new, empty `Vec<T>` with the specified capacity.\n     ///\n-    /// The vector will be able to hold exactly `capacity` elements without\n-    /// reallocating. If `capacity` is 0, the vector will not allocate.\n+    /// The vector will be able to hold exactly `capacity` elements without reallocating. If\n+    /// `capacity` is 0, the vector will not allocate.\n     ///\n-    /// It is important to note that this function does not specify the\n-    /// *length* of the returned vector, but only the *capacity*. (For an\n-    /// explanation of the difference between length and capacity, see\n-    /// the main `Vec` docs above, 'Capacity and reallocation'.) To create\n-    /// a vector of a given length, use `Vec::from_elem` or `Vec::from_fn`.\n+    /// It is important to note that this function does not specify the *length* of the returned\n+    /// vector, but only the *capacity*. (For an explanation of the difference between length and\n+    /// capacity, see the main `Vec<T>` docs above, 'Capacity and reallocation'.) To create a\n+    /// vector of a given length, use `Vec::from_elem` or `Vec::from_fn`.\n     ///\n     /// # Examples\n     ///\n@@ -193,10 +221,10 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Creates and initializes a `Vec`.\n+    /// Creates and initializes a `Vec<T>`.\n     ///\n-    /// Creates a `Vec` of size `length` and initializes the elements to the\n-    /// value returned by the closure `op`.\n+    /// Creates a `Vec<T>` of size `length` and initializes the elements to the value returned by\n+    /// the closure `op`.\n     ///\n     /// # Examples\n     ///\n@@ -261,10 +289,9 @@ impl<T> Vec<T> {\n \n     /// Creates a vector by copying the elements from a raw pointer.\n     ///\n-    /// This function will copy `elts` contiguous elements starting at `ptr`\n-    /// into a new allocation owned by the returned `Vec`. The elements of the\n-    /// buffer are copied into the vector without cloning, as if `ptr::read()`\n-    /// were called on them.\n+    /// This function will copy `elts` contiguous elements starting at `ptr` into a new allocation\n+    /// owned by the returned `Vec<T>`. The elements of the buffer are copied into the vector\n+    /// without cloning, as if `ptr::read()` were called on them.\n     #[inline]\n     #[unstable = \"just renamed from raw::from_buf\"]\n     pub unsafe fn from_raw_buf(ptr: *const T, elts: uint) -> Vec<T> {\n@@ -274,11 +301,10 @@ impl<T> Vec<T> {\n         dst\n     }\n \n-    /// Consumes the `Vec`, partitioning it based on a predicate.\n+    /// Consumes the `Vec<T>`, partitioning it based on a predicate.\n     ///\n-    /// Partitions the `Vec` into two `Vec`s `(A,B)`, where all elements of `A`\n-    /// satisfy `f` and all elements of `B` do not. The order of elements is\n-    /// preserved.\n+    /// Partitions the `Vec<T>` into two `Vec<T>`s `(A,B)`, where all elements of `A` satisfy `f`\n+    /// and all elements of `B` do not. The order of elements is preserved.\n     ///\n     /// # Examples\n     ///\n@@ -307,9 +333,9 @@ impl<T> Vec<T> {\n }\n \n impl<T: Clone> Vec<T> {\n-    /// Constructs a `Vec` with copies of a value.\n+    /// Constructs a `Vec<T>` with copies of a value.\n     ///\n-    /// Creates a `Vec` with `length` copies of `value`.\n+    /// Creates a `Vec<T>` with `length` copies of `value`.\n     ///\n     /// # Examples\n     ///\n@@ -332,10 +358,10 @@ impl<T: Clone> Vec<T> {\n         }\n     }\n \n-    /// Appends all elements in a slice to the `Vec`.\n+    /// Appends all elements in a slice to the `Vec<T>`.\n     ///\n     /// Iterates over the slice `other`, clones each element, and then appends\n-    /// it to this `Vec`. The `other` vector is traversed in-order.\n+    /// it to this `Vec<T>`. The `other` vector is traversed in-order.\n     ///\n     /// # Examples\n     ///\n@@ -364,9 +390,9 @@ impl<T: Clone> Vec<T> {\n         }\n     }\n \n-    /// Grows the `Vec` in-place.\n+    /// Grows the `Vec<T>` in-place.\n     ///\n-    /// Adds `n` copies of `value` to the `Vec`.\n+    /// Adds `n` copies of `value` to the `Vec<T>`.\n     ///\n     /// # Examples\n     ///\n@@ -388,7 +414,7 @@ impl<T: Clone> Vec<T> {\n \n     /// Partitions a vector based on a predicate.\n     ///\n-    /// Clones the elements of the vector, partitioning them into two `Vec`s\n+    /// Clones the elements of the vector, partitioning them into two `Vec<T>`s\n     /// `(a, b)`, where all elements of `a` satisfy `f` and all elements of `b`\n     /// do not. The order of elements is preserved.\n     ///\n@@ -647,8 +673,7 @@ unsafe fn dealloc<T>(ptr: *mut T, len: uint) {\n }\n \n impl<T> Vec<T> {\n-    /// Returns the number of elements the vector can hold without\n-    /// reallocating.\n+    /// Returns the number of elements the vector can hold without reallocating.\n     ///\n     /// # Examples\n     ///\n@@ -669,7 +694,7 @@ impl<T> Vec<T> {\n     }\n \n     /// Reserves capacity for at least `additional` more elements to be inserted in the given\n-    /// `Vec`. The collection may reserve more space to avoid frequent reallocations.\n+    /// `Vec<T>`. The collection may reserve more space to avoid frequent reallocations.\n     ///\n     /// # Panics\n     ///\n@@ -703,7 +728,7 @@ impl<T> Vec<T> {\n     }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n-    /// given `Vec`. Does nothing if the capacity is already sufficient.\n+    /// given `Vec<T>`. Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it requests. Therefore\n     /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n@@ -730,16 +755,19 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Shrinks the capacity of the vector as much as possible. It will drop\n-    /// down as close as possible to the length but the allocator may still\n-    /// inform the vector that there is space for a few more elements.\n+    /// Shrinks the capacity of the vector as much as possible.\n+    ///\n+    /// It will drop down as close as possible to the length but the allocator may still inform the\n+    /// vector that there is space for a few more elements.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// let mut vec: Vec<int> = Vec::with_capacity(10);\n+    ///\n     /// vec.push_all(&[1, 2, 3]);\n     /// assert_eq!(vec.capacity(), 10);\n+    ///\n     /// vec.shrink_to_fit();\n     /// assert!(vec.capacity() >= 3);\n     /// ```\n@@ -828,14 +856,14 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Creates a consuming iterator, that is, one that moves each\n-    /// value out of the vector (from start to end). The vector cannot\n-    /// be used after calling this.\n+    /// Creates a consuming iterator, that is, one that moves each value out of the vector (from\n+    /// start to end). The vector cannot be used after calling this.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// let v = vec![\"a\".to_string(), \"b\".to_string()];\n+    ///\n     /// for s in v.into_iter() {\n     ///     // s has type String, not &String\n     ///     println!(\"{}\", s);\n@@ -860,9 +888,8 @@ impl<T> Vec<T> {\n \n     /// Sets the length of a vector.\n     ///\n-    /// This will explicitly set the size of the vector, without actually\n-    /// modifying its buffers, so it is up to the caller to ensure that the\n-    /// vector is actually the specified size.\n+    /// This will explicitly set the size of the vector, without actually modifying its buffers, so\n+    /// it is up to the caller to ensure that the vector is actually the specified size.\n     ///\n     /// # Examples\n     ///\n@@ -878,8 +905,10 @@ impl<T> Vec<T> {\n         self.len = len;\n     }\n \n-    /// Removes an element from anywhere in the vector and return it, replacing\n-    /// it with the last element. This does not preserve ordering, but is O(1).\n+    /// Removes an element from anywhere in the vector and return it, replacing it with the last\n+    /// element.\n+    ///\n+    /// This does not preserve ordering, but is O(1).\n     ///\n     /// Returns `None` if `index` is out of bounds.\n     ///\n@@ -908,13 +937,12 @@ impl<T> Vec<T> {\n         self.pop()\n     }\n \n-    /// Inserts an element at position `index` within the vector, shifting all\n-    /// elements after position `i` one position to the right.\n+    /// Inserts an element at position `index` within the vector, shifting all elements after\n+    /// position `i` one position to the right.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `index` is not between `0` and the vector's length (both\n-    /// bounds inclusive).\n+    /// Panics if `index` is not between `0` and the vector's length (both bounds inclusive).\n     ///\n     /// # Examples\n     ///\n@@ -947,9 +975,9 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Removes and returns the element at position `index` within the vector,\n-    /// shifting all elements after position `index` one position to the left.\n-    /// Returns `None` if `i` is out of bounds.\n+    /// Removes and returns the element at position `index` within the vector, shifting all\n+    /// elements after position `index` one position to the left. Returns `None` if `i` is out of\n+    /// bounds.\n     ///\n     /// # Examples\n     ///\n@@ -988,8 +1016,8 @@ impl<T> Vec<T> {\n \n     /// Retains only the elements specified by the predicate.\n     ///\n-    /// In other words, remove all elements `e` such that `f(&e)` returns false.\n-    /// This method operates in place and preserves the order of the retained elements.\n+    /// In other words, remove all elements `e` such that `f(&e)` returns false. This method\n+    /// operates in place and preserves the order of the retained elements.\n     ///\n     /// # Examples\n     ///\n@@ -1078,8 +1106,7 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Removes the last element from a vector and returns it, or `None` if\n-    /// it is empty.\n+    /// Removes the last element from a vector and returns it, or `None` if it is empty.\n     ///\n     /// # Examples\n     ///\n@@ -1107,7 +1134,9 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let mut v = vec![1i, 2, 3];\n+    ///\n     /// v.clear();\n+    ///\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n@@ -1116,7 +1145,7 @@ impl<T> Vec<T> {\n         self.truncate(0)\n     }\n \n-    /// Return the number of elements in the vector\n+    /// Returns the number of elements in the vector.\n     ///\n     /// # Examples\n     ///\n@@ -1128,13 +1157,14 @@ impl<T> Vec<T> {\n     #[stable]\n     pub fn len(&self) -> uint { self.len }\n \n-    /// Returns true if the vector contains no elements\n+    /// Returns `true` if the vector contains no elements.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// let mut v = Vec::new();\n     /// assert!(v.is_empty());\n+    ///\n     /// v.push(1i);\n     /// assert!(!v.is_empty());\n     /// ```\n@@ -1169,7 +1199,9 @@ impl<T: PartialEq> Vec<T> {\n     ///\n     /// ```\n     /// let mut vec = vec![1i, 2, 2, 3, 2];\n+    ///\n     /// vec.dedup();\n+    ///\n     /// assert_eq!(vec, vec![1i, 2, 3, 2]);\n     /// ```\n     #[unstable = \"this function may be renamed\"]\n@@ -1442,10 +1474,9 @@ impl<T> Drop for MoveItems<T> {\n \n /// Converts an iterator of pairs into a pair of vectors.\n ///\n-/// Returns a tuple containing two vectors where the i-th element of the first\n-/// vector contains the first element of the i-th tuple of the input iterator,\n-/// and the i-th element of the second vector contains the second element\n-/// of the i-th tuple of the input iterator.\n+/// Returns a tuple containing two vectors where the i-th element of the first vector contains the\n+/// first element of the i-th tuple of the input iterator, and the i-th element of the second\n+/// vector contains the second element of the i-th tuple of the input iterator.\n #[unstable = \"this functionality may become more generic over time\"]\n pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (Vec<T>, Vec<U>) {\n     let (lo, _) = iter.size_hint();"}]}