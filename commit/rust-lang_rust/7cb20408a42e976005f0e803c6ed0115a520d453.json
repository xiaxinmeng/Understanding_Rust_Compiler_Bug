{"sha": "7cb20408a42e976005f0e803c6ed0115a520d453", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjYjIwNDA4YTQyZTk3NjAwNWYwZTgwM2M2ZWQwMTE1YTUyMGQ0NTM=", "commit": {"author": {"name": "Craig Macomber", "email": "CraigM@CraigM.info", "date": "2017-01-02T02:06:23Z"}, "committer": {"name": "Craig Macomber", "email": "CraigM@CraigM.info", "date": "2017-01-02T17:43:40Z"}, "message": "do not run outter part of benchmarks multimple times to fix issue 20142", "tree": {"sha": "9c93e99e3bf3d2484b423773bb7670a21ba3fe46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c93e99e3bf3d2484b423773bb7670a21ba3fe46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7cb20408a42e976005f0e803c6ed0115a520d453", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7cb20408a42e976005f0e803c6ed0115a520d453", "html_url": "https://github.com/rust-lang/rust/commit/7cb20408a42e976005f0e803c6ed0115a520d453", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7cb20408a42e976005f0e803c6ed0115a520d453/comments", "author": {"login": "Craig-Macomber", "id": 207204, "node_id": "MDQ6VXNlcjIwNzIwNA==", "avatar_url": "https://avatars.githubusercontent.com/u/207204?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Craig-Macomber", "html_url": "https://github.com/Craig-Macomber", "followers_url": "https://api.github.com/users/Craig-Macomber/followers", "following_url": "https://api.github.com/users/Craig-Macomber/following{/other_user}", "gists_url": "https://api.github.com/users/Craig-Macomber/gists{/gist_id}", "starred_url": "https://api.github.com/users/Craig-Macomber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Craig-Macomber/subscriptions", "organizations_url": "https://api.github.com/users/Craig-Macomber/orgs", "repos_url": "https://api.github.com/users/Craig-Macomber/repos", "events_url": "https://api.github.com/users/Craig-Macomber/events{/privacy}", "received_events_url": "https://api.github.com/users/Craig-Macomber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Craig-Macomber", "id": 207204, "node_id": "MDQ6VXNlcjIwNzIwNA==", "avatar_url": "https://avatars.githubusercontent.com/u/207204?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Craig-Macomber", "html_url": "https://github.com/Craig-Macomber", "followers_url": "https://api.github.com/users/Craig-Macomber/followers", "following_url": "https://api.github.com/users/Craig-Macomber/following{/other_user}", "gists_url": "https://api.github.com/users/Craig-Macomber/gists{/gist_id}", "starred_url": "https://api.github.com/users/Craig-Macomber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Craig-Macomber/subscriptions", "organizations_url": "https://api.github.com/users/Craig-Macomber/orgs", "repos_url": "https://api.github.com/users/Craig-Macomber/repos", "events_url": "https://api.github.com/users/Craig-Macomber/events{/privacy}", "received_events_url": "https://api.github.com/users/Craig-Macomber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df61658c8afc8b24800f5437e0000a99d04ea2b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/df61658c8afc8b24800f5437e0000a99d04ea2b0", "html_url": "https://github.com/rust-lang/rust/commit/df61658c8afc8b24800f5437e0000a99d04ea2b0"}], "stats": {"total": 245, "additions": 148, "deletions": 97}, "files": [{"sha": "3b66a31b749ee4c41fe641458da5dbbace9b2f22", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 144, "deletions": 96, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/7cb20408a42e976005f0e803c6ed0115a520d453/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cb20408a42e976005f0e803c6ed0115a520d453/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=7cb20408a42e976005f0e803c6ed0115a520d453", "patch": "@@ -185,13 +185,19 @@ impl fmt::Debug for TestFn {\n /// This is fed into functions marked with `#[bench]` to allow for\n /// set-up & tear-down before running a piece of code repeatedly via a\n /// call to `iter`.\n-#[derive(Copy, Clone)]\n+#[derive(Clone)]\n pub struct Bencher {\n-    iterations: u64,\n-    dur: Duration,\n+    mode: BenchMode,\n+    summary: Option<stats::Summary>,\n     pub bytes: u64,\n }\n \n+#[derive(Clone, PartialEq, Eq)]\n+pub enum BenchMode {\n+    Auto,\n+    Single,\n+}\n+\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum ShouldPanic {\n     No,\n@@ -1444,138 +1450,148 @@ impl Bencher {\n     pub fn iter<T, F>(&mut self, mut inner: F)\n         where F: FnMut() -> T\n     {\n-        let start = Instant::now();\n-        let k = self.iterations;\n-        for _ in 0..k {\n-            black_box(inner());\n+        if self.mode == BenchMode::Single {\n+            ns_iter_inner(&mut inner, 1);\n+            return;\n         }\n-        self.dur = start.elapsed();\n-    }\n \n-    pub fn ns_elapsed(&mut self) -> u64 {\n-        self.dur.as_secs() * 1_000_000_000 + (self.dur.subsec_nanos() as u64)\n+        self.summary = Some(iter(&mut inner));\n     }\n \n-    pub fn ns_per_iter(&mut self) -> u64 {\n-        if self.iterations == 0 {\n-            0\n-        } else {\n-            self.ns_elapsed() / cmp::max(self.iterations, 1)\n-        }\n-    }\n-\n-    pub fn bench_n<F>(&mut self, n: u64, f: F)\n-        where F: FnOnce(&mut Bencher)\n+    pub fn bench<F>(&mut self, mut f: F) -> Option<stats::Summary>\n+        where F: FnMut(&mut Bencher)\n     {\n-        self.iterations = n;\n         f(self);\n+        return self.summary;\n     }\n+}\n \n-    // This is a more statistics-driven benchmark algorithm\n-    pub fn auto_bench<F>(&mut self, mut f: F) -> stats::Summary\n-        where F: FnMut(&mut Bencher)\n-    {\n-        // Initial bench run to get ballpark figure.\n-        let mut n = 1;\n-        self.bench_n(n, |x| f(x));\n-\n-        // Try to estimate iter count for 1ms falling back to 1m\n-        // iterations if first run took < 1ns.\n-        if self.ns_per_iter() == 0 {\n-            n = 1_000_000;\n-        } else {\n-            n = 1_000_000 / cmp::max(self.ns_per_iter(), 1);\n-        }\n-        // if the first run took more than 1ms we don't want to just\n-        // be left doing 0 iterations on every loop. The unfortunate\n-        // side effect of not being able to do as many runs is\n-        // automatically handled by the statistical analysis below\n-        // (i.e. larger error bars).\n-        if n == 0 {\n-            n = 1;\n+fn ns_from_dur(dur: Duration) -> u64 {\n+    dur.as_secs() * 1_000_000_000 + (dur.subsec_nanos() as u64)\n+}\n+\n+fn ns_iter_inner<T, F>(inner: &mut F, k: u64) -> u64\n+    where F: FnMut() -> T\n+{\n+    let start = Instant::now();\n+    for _ in 0..k {\n+        black_box(inner());\n+    }\n+    return ns_from_dur(start.elapsed());\n+}\n+\n+\n+pub fn iter<T, F>(inner: &mut F) -> stats::Summary\n+    where F: FnMut() -> T\n+{\n+    // Initial bench run to get ballpark figure.\n+    let ns_single = ns_iter_inner(inner, 1);\n+\n+    // Try to estimate iter count for 1ms falling back to 1m\n+    // iterations if first run took < 1ns.\n+    let ns_target_total = 1_000_000; // 1ms\n+    let mut n = ns_target_total / cmp::max(1, ns_single);\n+\n+    // if the first run took more than 1ms we don't want to just\n+    // be left doing 0 iterations on every loop. The unfortunate\n+    // side effect of not being able to do as many runs is\n+    // automatically handled by the statistical analysis below\n+    // (i.e. larger error bars).\n+    n = cmp::max(1, n);\n+\n+    let mut total_run = Duration::new(0, 0);\n+    let samples: &mut [f64] = &mut [0.0_f64; 50];\n+    loop {\n+        let loop_start = Instant::now();\n+\n+        for p in &mut *samples {\n+            *p = ns_iter_inner(inner, n) as f64 / n as f64;\n         }\n \n-        let mut total_run = Duration::new(0, 0);\n-        let samples: &mut [f64] = &mut [0.0_f64; 50];\n-        loop {\n-            let loop_start = Instant::now();\n+        stats::winsorize(samples, 5.0);\n+        let summ = stats::Summary::new(samples);\n \n-            for p in &mut *samples {\n-                self.bench_n(n, |x| f(x));\n-                *p = self.ns_per_iter() as f64;\n-            }\n+        for p in &mut *samples {\n+            let ns = ns_iter_inner(inner, 5 * n);\n+            *p = ns as f64 / (5 * n) as f64;\n+        }\n \n-            stats::winsorize(samples, 5.0);\n-            let summ = stats::Summary::new(samples);\n+        stats::winsorize(samples, 5.0);\n+        let summ5 = stats::Summary::new(samples);\n \n-            for p in &mut *samples {\n-                self.bench_n(5 * n, |x| f(x));\n-                *p = self.ns_per_iter() as f64;\n-            }\n+        let loop_run = loop_start.elapsed();\n \n-            stats::winsorize(samples, 5.0);\n-            let summ5 = stats::Summary::new(samples);\n-            let loop_run = loop_start.elapsed();\n+        // If we've run for 100ms and seem to have converged to a\n+        // stable median.\n+        if loop_run > Duration::from_millis(100) && summ.median_abs_dev_pct < 1.0 &&\n+           summ.median - summ5.median < summ5.median_abs_dev {\n+            return summ5;\n+        }\n \n-            // If we've run for 100ms and seem to have converged to a\n-            // stable median.\n-            if loop_run > Duration::from_millis(100) && summ.median_abs_dev_pct < 1.0 &&\n-               summ.median - summ5.median < summ5.median_abs_dev {\n-                return summ5;\n-            }\n+        total_run = total_run + loop_run;\n+        // Longest we ever run for is 3s.\n+        if total_run > Duration::from_secs(3) {\n+            return summ5;\n+        }\n \n-            total_run = total_run + loop_run;\n-            // Longest we ever run for is 3s.\n-            if total_run > Duration::from_secs(3) {\n+        // If we overflow here just return the results so far. We check a\n+        // multiplier of 10 because we're about to multiply by 2 and the\n+        // next iteration of the loop will also multiply by 5 (to calculate\n+        // the summ5 result)\n+        n = match n.checked_mul(10) {\n+            Some(_) => n * 2,\n+            None => {\n                 return summ5;\n             }\n-\n-            // If we overflow here just return the results so far. We check a\n-            // multiplier of 10 because we're about to multiply by 2 and the\n-            // next iteration of the loop will also multiply by 5 (to calculate\n-            // the summ5 result)\n-            n = match n.checked_mul(10) {\n-                Some(_) => n * 2,\n-                None => return summ5,\n-            };\n-        }\n+        };\n     }\n }\n \n pub mod bench {\n     use std::cmp;\n-    use std::time::Duration;\n-    use super::{Bencher, BenchSamples};\n+    use stats;\n+    use super::{Bencher, BenchSamples, BenchMode};\n \n     pub fn benchmark<F>(f: F) -> BenchSamples\n         where F: FnMut(&mut Bencher)\n     {\n         let mut bs = Bencher {\n-            iterations: 0,\n-            dur: Duration::new(0, 0),\n+            mode: BenchMode::Auto,\n+            summary: None,\n             bytes: 0,\n         };\n \n-        let ns_iter_summ = bs.auto_bench(f);\n+        return match bs.bench(f) {\n+            Some(ns_iter_summ) => {\n+                let ns_iter = cmp::max(ns_iter_summ.median as u64, 1);\n+                let mb_s = bs.bytes * 1000 / ns_iter;\n \n-        let ns_iter = cmp::max(ns_iter_summ.median as u64, 1);\n-        let mb_s = bs.bytes * 1000 / ns_iter;\n-\n-        BenchSamples {\n-            ns_iter_summ: ns_iter_summ,\n-            mb_s: mb_s as usize,\n-        }\n+                BenchSamples {\n+                    ns_iter_summ: ns_iter_summ,\n+                    mb_s: mb_s as usize,\n+                }\n+            }\n+            None => {\n+                // iter not called, so no data.\n+                // FIXME: error in this case?\n+                let samples: &mut [f64] = &mut [0.0_f64; 1];\n+                BenchSamples {\n+                    ns_iter_summ: stats::Summary::new(samples),\n+                    mb_s: 0,\n+                }\n+            }\n+        };\n     }\n \n     pub fn run_once<F>(f: F)\n-        where F: FnOnce(&mut Bencher)\n+        where F: FnMut(&mut Bencher)\n     {\n         let mut bs = Bencher {\n-            iterations: 0,\n-            dur: Duration::new(0, 0),\n+            mode: BenchMode::Single,\n+            summary: None,\n             bytes: 0,\n         };\n-        bs.bench_n(1, f);\n+        bs.bench(f);\n     }\n }\n \n@@ -1585,6 +1601,8 @@ mod tests {\n                TestDescAndFn, TestOpts, run_test, MetricMap, StaticTestName, DynTestName,\n                DynTestFn, ShouldPanic};\n     use std::sync::mpsc::channel;\n+    use bench;\n+    use Bencher;\n \n     #[test]\n     pub fn do_not_run_ignored_tests() {\n@@ -1880,4 +1898,34 @@ mod tests {\n         m1.insert_metric(\"in-both-want-upwards-and-improved\", 1000.0, -10.0);\n         m2.insert_metric(\"in-both-want-upwards-and-improved\", 2000.0, -10.0);\n     }\n+\n+    #[test]\n+    pub fn test_bench_once_no_iter() {\n+        fn f(_: &mut Bencher) {}\n+        bench::run_once(f);\n+    }\n+\n+    #[test]\n+    pub fn test_bench_once_iter() {\n+        fn f(b: &mut Bencher) {\n+            b.iter(|| {\n+            })\n+        }\n+        bench::run_once(f);\n+    }\n+\n+    #[test]\n+    pub fn test_bench_no_iter() {\n+        fn f(_: &mut Bencher) {}\n+        bench::benchmark(f);\n+    }\n+\n+    #[test]\n+    pub fn test_bench_iter() {\n+        fn f(b: &mut Bencher) {\n+            b.iter(|| {\n+            })\n+        }\n+        bench::benchmark(f);\n+    }\n }"}, {"sha": "993fb703e51ddc79e095adc8baf4abe35e656db6", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7cb20408a42e976005f0e803c6ed0115a520d453/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cb20408a42e976005f0e803c6ed0115a520d453/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=7cb20408a42e976005f0e803c6ed0115a520d453", "patch": "@@ -120,7 +120,7 @@ pub trait Stats {\n }\n \n /// Extracted collection of all the summary statistics of a sample set.\n-#[derive(Clone, PartialEq)]\n+#[derive(Clone, PartialEq, Copy)]\n #[allow(missing_docs)]\n pub struct Summary {\n     pub sum: f64,\n@@ -896,4 +896,7 @@ mod bench {\n             v.sum();\n         })\n     }\n+\n+    #[bench]\n+    pub fn no_iter(_: &mut Bencher) {}\n }"}]}