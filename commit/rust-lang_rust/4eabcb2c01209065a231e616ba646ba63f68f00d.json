{"sha": "4eabcb2c01209065a231e616ba646ba63f68f00d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlYWJjYjJjMDEyMDkwNjVhMjMxZTYxNmJhNjQ2YmE2M2Y2OGYwMGQ=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-07T10:29:46Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-07T12:08:05Z"}, "message": "Move more things into PathCompletionContext", "tree": {"sha": "d07a0ccd1232a53d531c6c3eb00b6cf57f68a85c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d07a0ccd1232a53d531c6c3eb00b6cf57f68a85c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4eabcb2c01209065a231e616ba646ba63f68f00d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4eabcb2c01209065a231e616ba646ba63f68f00d", "html_url": "https://github.com/rust-lang/rust/commit/4eabcb2c01209065a231e616ba646ba63f68f00d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4eabcb2c01209065a231e616ba646ba63f68f00d/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e475bcdcc671161cf97d86d116a834c540f75f7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e475bcdcc671161cf97d86d116a834c540f75f7c", "html_url": "https://github.com/rust-lang/rust/commit/e475bcdcc671161cf97d86d116a834c540f75f7c"}], "stats": {"total": 108, "additions": 62, "deletions": 46}, "files": [{"sha": "8ad57a0692aa2ba2f266ee0805f80bc094efb747", "filename": "crates/ide_completion/src/completions/dot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4eabcb2c01209065a231e616ba646ba63f68f00d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eabcb2c01209065a231e616ba646ba63f68f00d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=4eabcb2c01209065a231e616ba646ba63f68f00d", "patch": "@@ -33,7 +33,7 @@ fn complete_undotted_self(acc: &mut Completions, ctx: &CompletionContext) {\n     if !ctx.config.enable_self_on_the_fly {\n         return;\n     }\n-    if !ctx.is_trivial_path || ctx.is_path_disallowed() {\n+    if !ctx.is_trivial_path() || ctx.is_path_disallowed() {\n         return;\n     }\n     ctx.scope.process_all_names(&mut |name, def| {"}, {"sha": "7bf47bf7571eac73477bde674d613c433f3b7b93", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4eabcb2c01209065a231e616ba646ba63f68f00d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eabcb2c01209065a231e616ba646ba63f68f00d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=4eabcb2c01209065a231e616ba646ba63f68f00d", "patch": "@@ -161,13 +161,13 @@ pub(crate) fn position_for_import<'a>(\n ) -> Option<&'a SyntaxNode> {\n     Some(match import_candidate {\n         Some(ImportCandidate::Path(_)) => ctx.name_ref_syntax.as_ref()?.syntax(),\n-        Some(ImportCandidate::TraitAssocItem(_)) => ctx.path_qual.as_ref()?.syntax(),\n+        Some(ImportCandidate::TraitAssocItem(_)) => ctx.path_qual()?.syntax(),\n         Some(ImportCandidate::TraitMethod(_)) => ctx.dot_receiver()?.syntax(),\n         None => ctx\n             .name_ref_syntax\n             .as_ref()\n             .map(|name_ref| name_ref.syntax())\n-            .or_else(|| ctx.path_qual.as_ref().map(|path| path.syntax()))\n+            .or_else(|| ctx.path_qual().map(|path| path.syntax()))\n             .or_else(|| ctx.dot_receiver().map(|expr| expr.syntax()))?,\n     })\n }\n@@ -190,7 +190,7 @@ fn import_assets(ctx: &CompletionContext, fuzzy_name: String) -> Option<ImportAs\n         };\n         let assets_for_path = ImportAssets::for_fuzzy_path(\n             current_module,\n-            ctx.path_qual.clone(),\n+            ctx.path_qual().cloned(),\n             fuzzy_name,\n             &ctx.sema,\n             approximate_node,"}, {"sha": "0ca97a0e44d80d33c9eb1e080fb9ffa4cb1000cf", "filename": "crates/ide_completion/src/completions/keyword.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4eabcb2c01209065a231e616ba646ba63f68f00d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eabcb2c01209065a231e616ba646ba63f68f00d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=4eabcb2c01209065a231e616ba646ba63f68f00d", "patch": "@@ -19,11 +19,12 @@ pub(crate) fn complete_use_tree_keyword(acc: &mut Completions, ctx: &CompletionC\n     };\n \n     if ctx.use_item_syntax.is_some() {\n-        if ctx.path_qual.is_none() {\n+        let qual = ctx.path_qual();\n+        if qual.is_none() {\n             kw_completion(\"crate::\").add_to(acc);\n         }\n         kw_completion(\"self\").add_to(acc);\n-        if iter::successors(ctx.path_qual.clone(), |p| p.qualifier())\n+        if iter::successors(qual.cloned(), |p| p.qualifier())\n             .all(|p| p.segment().and_then(|s| s.super_token()).is_some())\n         {\n             kw_completion(\"super::\").add_to(acc);\n@@ -128,7 +129,7 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n     }\n \n     if ctx.in_loop_body {\n-        if ctx.can_be_stmt {\n+        if ctx.can_be_stmt() {\n             add_keyword(\"continue\", \"continue;\");\n             add_keyword(\"break\", \"break;\");\n         } else {\n@@ -137,7 +138,7 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n         }\n     }\n \n-    if !ctx.is_trivial_path {\n+    if !ctx.is_trivial_path() {\n         return;\n     }\n     let fn_def = match &ctx.function_def {\n@@ -147,7 +148,7 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n \n     add_keyword(\n         \"return\",\n-        match (ctx.can_be_stmt, fn_def.ret_type().is_some()) {\n+        match (ctx.can_be_stmt(), fn_def.ret_type().is_some()) {\n             (true, true) => \"return $0;\",\n             (true, false) => \"return;\",\n             (false, true) => \"return $0\","}, {"sha": "c072de7b57bd39ad4568bced7f5125956659d1f2", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4eabcb2c01209065a231e616ba646ba63f68f00d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eabcb2c01209065a231e616ba646ba63f68f00d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=4eabcb2c01209065a231e616ba646ba63f68f00d", "patch": "@@ -10,8 +10,8 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n     if ctx.is_path_disallowed() || ctx.expects_item() {\n         return;\n     }\n-    let path = match &ctx.path_qual {\n-        Some(path) => path.clone(),\n+    let path = match ctx.path_qual() {\n+        Some(path) => path,\n         None => return,\n     };\n "}, {"sha": "59a338e7bb14973cd4d809715fd4a2f10ec93223", "filename": "crates/ide_completion/src/completions/snippet.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4eabcb2c01209065a231e616ba646ba63f68f00d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eabcb2c01209065a231e616ba646ba63f68f00d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs?ref=4eabcb2c01209065a231e616ba646ba63f68f00d", "patch": "@@ -14,15 +14,15 @@ fn snippet(ctx: &CompletionContext, cap: SnippetCap, label: &str, snippet: &str)\n }\n \n pub(crate) fn complete_expr_snippet(acc: &mut Completions, ctx: &CompletionContext) {\n-    if !(ctx.is_trivial_path && ctx.function_def.is_some()) {\n+    if !(ctx.is_trivial_path() && ctx.function_def.is_some()) {\n         return;\n     }\n     let cap = match ctx.config.snippet_cap {\n         Some(it) => it,\n         None => return,\n     };\n \n-    if ctx.can_be_stmt {\n+    if ctx.can_be_stmt() {\n         snippet(ctx, cap, \"pd\", \"eprintln!(\\\"$0 = {:?}\\\", $0);\").add_to(acc);\n         snippet(ctx, cap, \"ppd\", \"eprintln!(\\\"$0 = {:#?}\\\", $0);\").add_to(acc);\n     }"}, {"sha": "f321ed52bd07baaf4a93854c98c1a44576114562", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4eabcb2c01209065a231e616ba646ba63f68f00d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eabcb2c01209065a231e616ba646ba63f68f00d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=4eabcb2c01209065a231e616ba646ba63f68f00d", "patch": "@@ -5,7 +5,7 @@ use hir::ScopeDef;\n use crate::{CompletionContext, Completions};\n \n pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionContext) {\n-    if !ctx.is_trivial_path {\n+    if !ctx.is_trivial_path() {\n         return;\n     }\n     if ctx.is_path_disallowed() || ctx.expects_item() {"}, {"sha": "20e033d314f1f4b40c97bcd640e7b9c9f1781030", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/4eabcb2c01209065a231e616ba646ba63f68f00d/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eabcb2c01209065a231e616ba646ba63f68f00d/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=4eabcb2c01209065a231e616ba646ba63f68f00d", "patch": "@@ -33,6 +33,16 @@ pub(crate) enum PatternRefutability {\n pub(crate) struct PathCompletionContext {\n     /// If this is a call with () already there\n     call_kind: Option<CallKind>,\n+    /// A single-indent path, like `foo`. `::foo` should not be considered a trivial path.\n+    pub(super) is_trivial_path: bool,\n+    /// If not a trivial path, the prefix (qualifier).\n+    pub(super) path_qual: Option<ast::Path>,\n+    pub(super) is_path_type: bool,\n+    pub(super) has_type_args: bool,\n+    /// `true` if we are a statement or a last expr in the block.\n+    pub(super) can_be_stmt: bool,\n+    /// `true` if we expect an expression at the cursor position.\n+    pub(super) is_expr: bool,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -83,16 +93,6 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) path_context: Option<PathCompletionContext>,\n     /// FIXME: `ActiveParameter` is string-based, which is very very wrong\n     pub(super) active_parameter: Option<ActiveParameter>,\n-    /// A single-indent path, like `foo`. `::foo` should not be considered a trivial path.\n-    pub(super) is_trivial_path: bool,\n-    /// If not a trivial path, the prefix (qualifier).\n-    pub(super) path_qual: Option<ast::Path>,\n-    /// `true` if we are a statement or a last expr in the block.\n-    pub(super) can_be_stmt: bool,\n-    /// `true` if we expect an expression at the cursor position.\n-    pub(super) is_expr: bool,\n-    pub(super) is_path_type: bool,\n-    pub(super) has_type_args: bool,\n     pub(super) locals: Vec<(String, Local)>,\n \n     pub(super) previous_token: Option<SyntaxToken>,\n@@ -156,13 +156,7 @@ impl<'a> CompletionContext<'a> {\n             is_label_ref: false,\n             is_param: false,\n             is_pat_or_const: None,\n-            is_trivial_path: false,\n-            path_qual: None,\n-            can_be_stmt: false,\n-            is_expr: false,\n             path_context: None,\n-            is_path_type: false,\n-            has_type_args: false,\n             previous_token: None,\n             in_loop_body: false,\n             completion_location: None,\n@@ -280,11 +274,6 @@ impl<'a> CompletionContext<'a> {\n         matches!(self.completion_location, Some(ImmediateLocation::ItemList))\n     }\n \n-    //         fn expects_value(&self) -> bool {\n-    pub(crate) fn expects_expression(&self) -> bool {\n-        self.is_expr\n-    }\n-\n     pub(crate) fn has_block_expr_parent(&self) -> bool {\n         matches!(self.completion_location, Some(ImmediateLocation::BlockExpr))\n     }\n@@ -321,10 +310,26 @@ impl<'a> CompletionContext<'a> {\n         ) || self.attribute_under_caret.is_some()\n     }\n \n+    pub(crate) fn expects_expression(&self) -> bool {\n+        self.path_context.as_ref().map_or(false, |it| it.is_expr)\n+    }\n+\n     pub(crate) fn path_call_kind(&self) -> Option<CallKind> {\n         self.path_context.as_ref().and_then(|it| it.call_kind)\n     }\n \n+    pub(crate) fn is_trivial_path(&self) -> bool {\n+        self.path_context.as_ref().map_or(false, |it| it.is_trivial_path)\n+    }\n+\n+    pub(crate) fn path_qual(&self) -> Option<&ast::Path> {\n+        self.path_context.as_ref().and_then(|it| it.path_qual.as_ref())\n+    }\n+\n+    pub(crate) fn can_be_stmt(&self) -> bool {\n+        self.path_context.as_ref().map_or(false, |it| it.can_be_stmt)\n+    }\n+\n     fn fill_impl_def(&mut self) {\n         self.impl_def = self\n             .sema\n@@ -577,7 +582,15 @@ impl<'a> CompletionContext<'a> {\n         };\n \n         if let Some(segment) = ast::PathSegment::cast(parent) {\n-            let mut path_ctx = PathCompletionContext { call_kind: None };\n+            let path_ctx = self.path_context.get_or_insert(PathCompletionContext {\n+                call_kind: None,\n+                is_trivial_path: false,\n+                path_qual: None,\n+                has_type_args: false,\n+                is_path_type: false,\n+                can_be_stmt: false,\n+                is_expr: false,\n+            });\n             let path = segment.parent_path();\n \n             if let Some(p) = path.syntax().parent() {\n@@ -590,13 +603,11 @@ impl<'a> CompletionContext<'a> {\n                     }\n                 };\n             }\n-            self.path_context = Some(path_ctx);\n-            dbg!(&self.path_context);\n-            self.is_path_type = path.syntax().parent().and_then(ast::PathType::cast).is_some();\n-            self.has_type_args = segment.generic_arg_list().is_some();\n+            path_ctx.is_path_type = path.syntax().parent().and_then(ast::PathType::cast).is_some();\n+            path_ctx.has_type_args = segment.generic_arg_list().is_some();\n \n             if let Some(path) = path_or_use_tree_qualifier(&path) {\n-                self.path_qual = path\n+                path_ctx.path_qual = path\n                     .segment()\n                     .and_then(|it| {\n                         find_node_with_range::<ast::PathSegment>(\n@@ -614,11 +625,11 @@ impl<'a> CompletionContext<'a> {\n                 }\n             }\n \n-            self.is_trivial_path = true;\n+            path_ctx.is_trivial_path = true;\n \n             // Find either enclosing expr statement (thing with `;`) or a\n             // block. If block, check that we are the last expr.\n-            self.can_be_stmt = name_ref\n+            path_ctx.can_be_stmt = name_ref\n                 .syntax()\n                 .ancestors()\n                 .find_map(|node| {\n@@ -634,7 +645,7 @@ impl<'a> CompletionContext<'a> {\n                     None\n                 })\n                 .unwrap_or(false);\n-            self.is_expr = path.syntax().parent().and_then(ast::PathExpr::cast).is_some();\n+            path_ctx.is_expr = path.syntax().parent().and_then(ast::PathExpr::cast).is_some();\n         }\n     }\n }"}, {"sha": "750694432ea1790d494eb406483c29024ead5d02", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4eabcb2c01209065a231e616ba646ba63f68f00d/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eabcb2c01209065a231e616ba646ba63f68f00d/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=4eabcb2c01209065a231e616ba646ba63f68f00d", "patch": "@@ -275,8 +275,12 @@ impl<'a> Render<'a> {\n         };\n \n         // Add `<>` for generic types\n-        if self.ctx.completion.is_path_type\n-            && !self.ctx.completion.has_type_args\n+        if self\n+            .ctx\n+            .completion\n+            .path_context\n+            .as_ref()\n+            .map_or(false, |it| it.is_path_type && !it.has_type_args)\n             && self.ctx.completion.config.add_call_parenthesis\n         {\n             if let Some(cap) = self.ctx.snippet_cap() {"}]}