{"sha": "bf278ebd9d82e15aba014034520e18120a1d6211", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmMjc4ZWJkOWQ4MmUxNWFiYTAxNDAzNDUyMGUxODEyMGExZDYyMTE=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-11-22T20:28:02Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-12-09T20:42:52Z"}, "message": "Make const index and subslice array projections more useful\n\n* `min_length` is now exact for const index elements.\n* const index elements are always from the start.\n* make array `Subslice` `PlaceElems` count both `from` and `to` from the\n  start.", "tree": {"sha": "bd0ee514914177d22de30cf1ae8fbb0836847aa8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd0ee514914177d22de30cf1ae8fbb0836847aa8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf278ebd9d82e15aba014034520e18120a1d6211", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf278ebd9d82e15aba014034520e18120a1d6211", "html_url": "https://github.com/rust-lang/rust/commit/bf278ebd9d82e15aba014034520e18120a1d6211", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf278ebd9d82e15aba014034520e18120a1d6211/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7de9402b77ded0d8ec9e1c554521b2121449ef2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7de9402b77ded0d8ec9e1c554521b2121449ef2b", "html_url": "https://github.com/rust-lang/rust/commit/7de9402b77ded0d8ec9e1c554521b2121449ef2b"}], "stats": {"total": 164, "additions": 110, "deletions": 54}, "files": [{"sha": "afa6d8db443b7b075878cf8483d7fc4d627b5410", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bf278ebd9d82e15aba014034520e18120a1d6211/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf278ebd9d82e15aba014034520e18120a1d6211/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=bf278ebd9d82e15aba014034520e18120a1d6211", "patch": "@@ -1714,18 +1714,25 @@ pub enum ProjectionElem<V, T> {\n     ConstantIndex {\n         /// index or -index (in Python terms), depending on from_end\n         offset: u32,\n-        /// thing being indexed must be at least this long\n+        /// The thing being indexed must be at least this long. For arrays this\n+        /// is always the exact length.\n         min_length: u32,\n-        /// counting backwards from end?\n+        /// Counting backwards from end? This is always false when indexing an\n+        /// array.\n         from_end: bool,\n     },\n \n     /// These indices are generated by slice patterns.\n     ///\n-    /// slice[from:-to] in Python terms.\n+    /// If `from_end` is true `slice[from..slice.len() - to]`.\n+    /// Otherwise `array[from..to]`.\n     Subslice {\n         from: u32,\n         to: u32,\n+        /// Whether `to` counts from the start or end of the array/slice.\n+        /// For `PlaceElem`s this is `true` if and only if the base is a slice.\n+        /// For `ProjectionKind`, this can also be `true` for arrays.\n+        from_end: bool,\n     },\n \n     /// \"Downcast\" to a variant of an ADT. Currently, we only introduce\n@@ -1914,15 +1921,18 @@ impl Debug for Place<'_> {\n                 ProjectionElem::ConstantIndex { offset, min_length, from_end: true } => {\n                     write!(fmt, \"[-{:?} of {:?}]\", offset, min_length)?;\n                 }\n-                ProjectionElem::Subslice { from, to } if *to == 0 => {\n+                ProjectionElem::Subslice { from, to, from_end: true } if *to == 0 => {\n                     write!(fmt, \"[{:?}:]\", from)?;\n                 }\n-                ProjectionElem::Subslice { from, to } if *from == 0 => {\n+                ProjectionElem::Subslice { from, to, from_end: true } if *from == 0 => {\n                     write!(fmt, \"[:-{:?}]\", to)?;\n                 }\n-                ProjectionElem::Subslice { from, to } => {\n+                ProjectionElem::Subslice { from, to, from_end: true } => {\n                     write!(fmt, \"[{:?}:-{:?}]\", from, to)?;\n                 }\n+                ProjectionElem::Subslice { from, to, from_end: false } => {\n+                    write!(fmt, \"[{:?}..{:?}]\", from, to)?;\n+                }\n             }\n         }\n \n@@ -2452,7 +2462,7 @@ impl UserTypeProjection {\n     }\n \n     pub(crate) fn subslice(mut self, from: u32, to: u32) -> Self {\n-        self.projs.push(ProjectionElem::Subslice { from, to });\n+        self.projs.push(ProjectionElem::Subslice { from, to, from_end: true });\n         self\n     }\n "}, {"sha": "445fa6ea8cab31b7fb2d982994debcbb08e70175", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bf278ebd9d82e15aba014034520e18120a1d6211/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf278ebd9d82e15aba014034520e18120a1d6211/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=bf278ebd9d82e15aba014034520e18120a1d6211", "patch": "@@ -88,14 +88,17 @@ impl<'tcx> PlaceTy<'tcx> {\n             }\n             ProjectionElem::Index(_) | ProjectionElem::ConstantIndex { .. } =>\n                 PlaceTy::from_ty(self.ty.builtin_index().unwrap()),\n-            ProjectionElem::Subslice { from, to } => {\n+            ProjectionElem::Subslice { from, to, from_end } => {\n                 PlaceTy::from_ty(match self.ty.kind {\n-                    ty::Array(inner, size) => {\n+                    ty::Slice(..) => self.ty,\n+                    ty::Array(inner, _) if !from_end => {\n+                        tcx.mk_array(inner, (to - from) as u64)\n+                    }\n+                    ty::Array(inner, size) if from_end => {\n                         let size = size.eval_usize(tcx, param_env);\n                         let len = size - (from as u64) - (to as u64);\n                         tcx.mk_array(inner, len)\n                     }\n-                    ty::Slice(..) => self.ty,\n                     _ => {\n                         bug!(\"cannot subslice non-array type: `{:?}`\", self)\n                     }"}, {"sha": "5d273fe85b6d2e49657d7fb3e67ce30ea39f4c79", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf278ebd9d82e15aba014034520e18120a1d6211/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf278ebd9d82e15aba014034520e18120a1d6211/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=bf278ebd9d82e15aba014034520e18120a1d6211", "patch": "@@ -954,7 +954,7 @@ macro_rules! visit_place_fns {\n                     );\n                 }\n                 ProjectionElem::Deref |\n-                ProjectionElem::Subslice { from: _, to: _ } |\n+                ProjectionElem::Subslice { from: _, to: _, from_end: _ } |\n                 ProjectionElem::ConstantIndex { offset: _,\n                                                 min_length: _,\n                                                 from_end: _ } |"}, {"sha": "5e13cabced000768a1ac3cabc22b885fbb7e1698", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bf278ebd9d82e15aba014034520e18120a1d6211/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf278ebd9d82e15aba014034520e18120a1d6211/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=bf278ebd9d82e15aba014034520e18120a1d6211", "patch": "@@ -565,14 +565,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         let llindex = bx.sub(lllen, lloffset);\n                         cg_base.project_index(bx, llindex)\n                     }\n-                    mir::ProjectionElem::Subslice { from, to } => {\n+                    mir::ProjectionElem::Subslice { from, to, from_end } => {\n                         let mut subslice = cg_base.project_index(bx,\n                             bx.cx().const_usize(*from as u64));\n                         let projected_ty = PlaceTy::from_ty(cg_base.layout.ty)\n                             .projection_ty(tcx, elem).ty;\n                         subslice.layout = bx.cx().layout_of(self.monomorphize(&projected_ty));\n \n                         if subslice.layout.is_unsized() {\n+                            assert!(from_end, \"slice subslices should be `from_end`\");\n                             subslice.llextra = Some(bx.sub(cg_base.llextra.unwrap(),\n                                 bx.cx().const_usize((*from as u64) + (*to as u64))));\n                         }"}, {"sha": "c16471dca721727a8bda76745690d2031c1456c1", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bf278ebd9d82e15aba014034520e18120a1d6211/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf278ebd9d82e15aba014034520e18120a1d6211/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=bf278ebd9d82e15aba014034520e18120a1d6211", "patch": "@@ -673,23 +673,16 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                     }),\n                 )\n             }\n-            ProjectionElem::Subslice { from, to } => PlaceTy::from_ty(\n+            ProjectionElem::Subslice { from, to, from_end } => PlaceTy::from_ty(\n                 match base_ty.kind {\n-                    ty::Array(inner, size) => {\n-                        let size = size.eval_usize(tcx, self.cx.param_env);\n-                        let min_size = (from as u64) + (to as u64);\n-                        if let Some(rest_size) = size.checked_sub(min_size) {\n-                            tcx.mk_array(inner, rest_size)\n-                        } else {\n-                            span_mirbug_and_err!(\n-                                self,\n-                                place,\n-                                \"taking too-small slice of {:?}\",\n-                                base_ty\n-                            )\n-                        }\n+                    ty::Array(inner, _) => {\n+                        assert!(!from_end, \"array subslices should not use from_end\");\n+                        tcx.mk_array(inner, (to - from) as u64)\n                     }\n-                    ty::Slice(..) => base_ty,\n+                    ty::Slice(..) => {\n+                        assert!(from_end, \"slice subslices should use from_end\");\n+                        base_ty\n+                    },\n                     _ => span_mirbug_and_err!(self, place, \"slice of non-array {:?}\", base_ty),\n                 },\n             ),"}, {"sha": "f0420a23597849e73db31f5e88daac2add647b79", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/bf278ebd9d82e15aba014034520e18120a1d6211/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf278ebd9d82e15aba014034520e18120a1d6211/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=bf278ebd9d82e15aba014034520e18120a1d6211", "patch": "@@ -503,34 +503,62 @@ fn place_projection_conflict<'tcx>(\n                 Overlap::Disjoint\n             }\n         }\n+        (\n+            ProjectionElem::ConstantIndex { offset, min_length: _, from_end: false },\n+            ProjectionElem::Subslice { from, to, from_end: false }\n+        )\n+        | (\n+            ProjectionElem::Subslice { from, to, from_end: false },\n+            ProjectionElem::ConstantIndex { offset, min_length: _, from_end: false }\n+        ) => {\n+            if (from..to).contains(&offset) {\n+                debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX-SUBSLICE\");\n+                Overlap::EqualOrDisjoint\n+            } else {\n+                debug!(\"place_element_conflict: DISJOINT-ARRAY-CONSTANT-INDEX-SUBSLICE\");\n+                Overlap::Disjoint\n+            }\n+        }\n         (ProjectionElem::ConstantIndex { offset, min_length: _, from_end: false },\n          ProjectionElem::Subslice {from, .. })\n         | (ProjectionElem::Subslice {from, .. },\n             ProjectionElem::ConstantIndex { offset, min_length: _, from_end: false }) => {\n             if offset >= from {\n                 debug!(\n-                    \"place_element_conflict: DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX-SUBSLICE\");\n+                    \"place_element_conflict: DISJOINT-OR-EQ-SLICE-CONSTANT-INDEX-SUBSLICE\");\n                 Overlap::EqualOrDisjoint\n             } else {\n-                debug!(\"place_element_conflict: DISJOINT-ARRAY-CONSTANT-INDEX-SUBSLICE\");\n+                debug!(\"place_element_conflict: DISJOINT-SLICE-CONSTANT-INDEX-SUBSLICE\");\n                 Overlap::Disjoint\n             }\n         }\n         (ProjectionElem::ConstantIndex { offset, min_length: _, from_end: true },\n-         ProjectionElem::Subslice {from: _, to })\n-        | (ProjectionElem::Subslice {from: _, to },\n+         ProjectionElem::Subslice { to, .. })\n+        | (ProjectionElem::Subslice { to, .. },\n             ProjectionElem::ConstantIndex { offset, min_length: _, from_end: true }) => {\n             if offset > to {\n                 debug!(\"place_element_conflict: \\\n-                       DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX-SUBSLICE-FE\");\n+                       DISJOINT-OR-EQ-SLICE-CONSTANT-INDEX-SUBSLICE-FE\");\n                 Overlap::EqualOrDisjoint\n             } else {\n-                debug!(\"place_element_conflict: DISJOINT-ARRAY-CONSTANT-INDEX-SUBSLICE-FE\");\n+                debug!(\"place_element_conflict: DISJOINT-SLICE-CONSTANT-INDEX-SUBSLICE-FE\");\n+                Overlap::Disjoint\n+            }\n+        }\n+        (\n+            ProjectionElem::Subslice { from: f1, to: t1, from_end: false },\n+            ProjectionElem::Subslice { from: f2, to: t2, from_end: false }\n+        ) => {\n+            if f2 >= t1 || f1 >= t2 {\n+                debug!(\"place_element_conflict: DISJOINT-ARRAY-SUBSLICES\");\n                 Overlap::Disjoint\n+            } else {\n+                debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-SUBSLICES\");\n+                Overlap::EqualOrDisjoint\n             }\n         }\n         (ProjectionElem::Subslice { .. }, ProjectionElem::Subslice { .. }) => {\n-            debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-SUBSLICES\");\n+            debug!(\"place_element_conflict: DISJOINT-OR-EQ-SLICE-SUBSLICES\");\n              Overlap::EqualOrDisjoint\n         }\n         (ProjectionElem::Deref, _)"}, {"sha": "ec8b3c5e24bf276fb7324a72a6dc476223b7ad62", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bf278ebd9d82e15aba014034520e18120a1d6211/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf278ebd9d82e15aba014034520e18120a1d6211/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=bf278ebd9d82e15aba014034520e18120a1d6211", "patch": "@@ -2,6 +2,7 @@ use crate::build::Builder;\n use crate::build::matches::MatchPair;\n use crate::hair::*;\n use rustc::mir::*;\n+use rustc::ty;\n use smallvec::SmallVec;\n use std::u32;\n use std::convert::TryInto;\n@@ -31,9 +32,17 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                      prefix: &'pat [Pat<'tcx>],\n                                      opt_slice: Option<&'pat Pat<'tcx>>,\n                                      suffix: &'pat [Pat<'tcx>]) {\n-        let min_length = prefix.len() + suffix.len();\n-        let min_length = min_length.try_into().unwrap();\n         let tcx = self.hir.tcx();\n+        let (min_length, exact_size) = match place.ty(&self.local_decls, tcx).ty.kind {\n+            ty::Array(_, length) => (\n+                length.eval_usize(tcx, self.hir.param_env).try_into().unwrap(),\n+                true\n+            ),\n+            _ => (\n+                (prefix.len() + suffix.len()).try_into().unwrap(),\n+                false,\n+            ),\n+        };\n \n         match_pairs.extend(\n             prefix.iter()\n@@ -50,10 +59,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         );\n \n         if let Some(subslice_pat) = opt_slice {\n-            let subslice = tcx.mk_place_elem(place.clone(),ProjectionElem::Subslice {\n-                from: prefix.len() as u32,\n-                to: suffix.len() as u32\n-            });\n+            let suffix_len = suffix.len() as u32;\n+            let subslice = tcx.mk_place_elem(\n+                place.clone(),\n+                ProjectionElem::Subslice {\n+                    from: prefix.len() as u32,\n+                    to: if exact_size { min_length - suffix_len } else { suffix_len },\n+                    from_end: !exact_size,\n+                },\n+            );\n             match_pairs.push(MatchPair::new(subslice, subslice_pat));\n         }\n \n@@ -62,10 +76,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                   .rev()\n                   .enumerate()\n                   .map(|(idx, subpattern)| {\n+                      let end_offset = (idx + 1) as u32;\n                       let elem = ProjectionElem::ConstantIndex {\n-                          offset: (idx+1) as u32,\n+                          offset: if exact_size { min_length - end_offset } else { end_offset },\n                           min_length,\n-                          from_end: true,\n+                          from_end: !exact_size,\n                       };\n                       let place = tcx.mk_place_elem(place.clone(), elem);\n                       MatchPair::new(place, subpattern)"}, {"sha": "0665c0fb72c462069ec97d4bcd8322617e0541a4", "filename": "src/librustc_mir/dataflow/move_paths/abs_domain.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf278ebd9d82e15aba014034520e18120a1d6211/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf278ebd9d82e15aba014034520e18120a1d6211/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs?ref=bf278ebd9d82e15aba014034520e18120a1d6211", "patch": "@@ -49,8 +49,8 @@ impl<'tcx> Lift for PlaceElem<'tcx> {\n             ProjectionElem::Deref => ProjectionElem::Deref,\n             ProjectionElem::Field(ref f, ty) => ProjectionElem::Field(f.clone(), ty.lift()),\n             ProjectionElem::Index(ref i) => ProjectionElem::Index(i.lift()),\n-            ProjectionElem::Subslice { from, to } => {\n-                ProjectionElem::Subslice { from: from, to: to }\n+            ProjectionElem::Subslice { from, to, from_end } => {\n+                ProjectionElem::Subslice { from, to, from_end }\n             }\n             ProjectionElem::ConstantIndex { offset, min_length, from_end } => {\n                 ProjectionElem::ConstantIndex { offset, min_length, from_end }"}, {"sha": "89ef9b245ce8f55f848cd0492c0e5871c2cb3ce0", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bf278ebd9d82e15aba014034520e18120a1d6211/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf278ebd9d82e15aba014034520e18120a1d6211/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=bf278ebd9d82e15aba014034520e18120a1d6211", "patch": "@@ -1,6 +1,6 @@\n use core::slice::Iter;\n use rustc::mir::*;\n-use rustc::ty::{Ty, TyCtxt};\n+use rustc::ty::{Ty, TyCtxt, ParamEnv};\n use rustc::util::nodemap::FxHashMap;\n use rustc_index::vec::{Enumerated, Idx, IndexVec};\n use smallvec::SmallVec;\n@@ -318,8 +318,9 @@ impl<'tcx> MoveData<'tcx> {\n     pub fn gather_moves(\n         body: &Body<'tcx>,\n         tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n     ) -> Result<Self, (Self, Vec<(Place<'tcx>, MoveError<'tcx>)>)> {\n-        builder::gather_moves(body, tcx)\n+        builder::gather_moves(body, tcx, param_env)\n     }\n \n     /// For the move path `mpi`, returns the root local variable (if any) that starts the path."}, {"sha": "42fbfeca3f05d5fe5166140d7bc0520979bdf9af", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bf278ebd9d82e15aba014034520e18120a1d6211/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf278ebd9d82e15aba014034520e18120a1d6211/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=bf278ebd9d82e15aba014034520e18120a1d6211", "patch": "@@ -451,9 +451,15 @@ where\n         base: MPlaceTy<'tcx, M::PointerTag>,\n         from: u64,\n         to: u64,\n+        from_end: bool,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n-        assert!(from <= len - to);\n+        let actual_to = if from_end {\n+            assert!(from <= len - to);\n+            len - to\n+        } else {\n+            to\n+        };\n \n         // Not using layout method because that works with usize, and does not work with slices\n         // (that have count 0 in their layout).\n@@ -464,7 +470,7 @@ where\n         };\n \n         // Compute meta and new layout\n-        let inner_len = len - to - from;\n+        let inner_len = actual_to - from;\n         let (meta, ty) = match base.layout.ty.kind {\n             // It is not nice to match on the type, but that seems to be the only way to\n             // implement this.\n@@ -528,8 +534,8 @@ where\n                 self.mplace_field(base, index)?\n             }\n \n-            Subslice { from, to } =>\n-                self.mplace_subslice(base, u64::from(from), u64::from(to))?,\n+            Subslice { from, to, from_end } =>\n+                self.mplace_subslice(base, u64::from(from), u64::from(to), from_end)?,\n         })\n     }\n "}, {"sha": "8cc8883b9019f296921be22ef0cd90880150a1d0", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bf278ebd9d82e15aba014034520e18120a1d6211/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf278ebd9d82e15aba014034520e18120a1d6211/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=bf278ebd9d82e15aba014034520e18120a1d6211", "patch": "@@ -234,12 +234,11 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n \n     fn array_subpath(&self, path: Self::Path, index: u32, size: u32) -> Option<Self::Path> {\n         dataflow::move_path_children_matching(self.ctxt.move_data(), path, |e| match e {\n-            ProjectionElem::ConstantIndex { offset, min_length: _, from_end: false } => {\n+            ProjectionElem::ConstantIndex { offset, min_length, from_end } => {\n+                debug_assert!(size == *min_length, \"min_length should be exact for arrays\");\n+                assert!(!from_end, \"from_end should not be used for array element ConstantIndex\");\n                 *offset == index\n             }\n-            ProjectionElem::ConstantIndex { offset, min_length: _, from_end: true } => {\n-                size - offset == index\n-            }\n             _ => false,\n         })\n     }"}]}