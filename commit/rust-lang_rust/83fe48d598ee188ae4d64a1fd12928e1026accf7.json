{"sha": "83fe48d598ee188ae4d64a1fd12928e1026accf7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzZmU0OGQ1OThlZTE4OGFlNGQ2NGExZmQxMjkyOGUxMDI2YWNjZjc=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-02-19T15:46:43Z"}, "committer": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-02-20T16:40:02Z"}, "message": "Remove `else`, unindent.", "tree": {"sha": "18ac354b9329a2941a7d63602740189c056f03a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18ac354b9329a2941a7d63602740189c056f03a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83fe48d598ee188ae4d64a1fd12928e1026accf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83fe48d598ee188ae4d64a1fd12928e1026accf7", "html_url": "https://github.com/rust-lang/rust/commit/83fe48d598ee188ae4d64a1fd12928e1026accf7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83fe48d598ee188ae4d64a1fd12928e1026accf7/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de2f7e15ba6db2846c80c7ad4ffe391f2c5a4311", "url": "https://api.github.com/repos/rust-lang/rust/commits/de2f7e15ba6db2846c80c7ad4ffe391f2c5a4311", "html_url": "https://github.com/rust-lang/rust/commit/de2f7e15ba6db2846c80c7ad4ffe391f2c5a4311"}], "stats": {"total": 91, "additions": 45, "deletions": 46}, "files": [{"sha": "193c07166b04e6924a4f4709424539802e157e7f", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 45, "deletions": 46, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/83fe48d598ee188ae4d64a1fd12928e1026accf7/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83fe48d598ee188ae4d64a1fd12928e1026accf7/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=83fe48d598ee188ae4d64a1fd12928e1026accf7", "patch": "@@ -533,55 +533,54 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n                         if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n                             return;\n+                        }\n+                        let trait_ref = trait_predicate.to_poly_trait_ref();\n+                        let (post_message, pre_message) =\n+                            self.get_parent_trait_ref(&obligation.cause.code)\n+                                .map(|t| (format!(\" in `{}`\", t), format!(\"within `{}`, \", t)))\n+                                .unwrap_or((String::new(), String::new()));\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess,\n+                            span,\n+                            E0277,\n+                            \"the trait bound `{}` is not satisfied{}\",\n+                            trait_ref.to_predicate(),\n+                            post_message);\n+                        err.span_label(span,\n+                                        &format!(\"{}the trait `{}` is not \\\n+                                                    implemented for `{}`\",\n+                                                pre_message,\n+                                                trait_ref,\n+                                                trait_ref.self_ty()));\n+\n+                        // Try to report a help message\n+\n+                        if !trait_ref.has_infer_types() &&\n+                            self.predicate_can_apply(trait_ref) {\n+                            // If a where-clause may be useful, remind the\n+                            // user that they can add it.\n+                            //\n+                            // don't display an on-unimplemented note, as\n+                            // these notes will often be of the form\n+                            //     \"the type `T` can't be frobnicated\"\n+                            // which is somewhat confusing.\n+                            err.help(&format!(\"consider adding a `where {}` bound\",\n+                                                trait_ref.to_predicate()));\n+                        } else if let Some(s) = self.on_unimplemented_note(trait_ref,\n+                                                                            obligation) {\n+                            // If it has a custom \"#[rustc_on_unimplemented]\"\n+                            // error message, let's display it!\n+                            err.note(&s);\n                         } else {\n-                            let trait_ref = trait_predicate.to_poly_trait_ref();\n-                            let (post_message, pre_message) =\n-                                self.get_parent_trait_ref(&obligation.cause.code)\n-                                    .map(|t| (format!(\" in `{}`\", t), format!(\"within `{}`, \", t)))\n-                                    .unwrap_or((String::new(), String::new()));\n-                            let mut err = struct_span_err!(\n-                                self.tcx.sess,\n-                                span,\n-                                E0277,\n-                                \"the trait bound `{}` is not satisfied{}\",\n-                                trait_ref.to_predicate(),\n-                                post_message);\n-                            err.span_label(span,\n-                                            &format!(\"{}the trait `{}` is not \\\n-                                                        implemented for `{}`\",\n-                                                    pre_message,\n-                                                    trait_ref,\n-                                                    trait_ref.self_ty()));\n-\n-                            // Try to report a help message\n-\n-                            if !trait_ref.has_infer_types() &&\n-                                self.predicate_can_apply(trait_ref) {\n-                                // If a where-clause may be useful, remind the\n-                                // user that they can add it.\n-                                //\n-                                // don't display an on-unimplemented note, as\n-                                // these notes will often be of the form\n-                                //     \"the type `T` can't be frobnicated\"\n-                                // which is somewhat confusing.\n-                                err.help(&format!(\"consider adding a `where {}` bound\",\n-                                                    trait_ref.to_predicate()));\n-                            } else if let Some(s) = self.on_unimplemented_note(trait_ref,\n-                                                                                obligation) {\n-                                // If it has a custom \"#[rustc_on_unimplemented]\"\n-                                // error message, let's display it!\n-                                err.note(&s);\n-                            } else {\n-                                // If we can't show anything useful, try to find\n-                                // similar impls.\n-                                let impl_candidates =\n-                                    self.find_similar_impl_candidates(trait_ref);\n-                                if impl_candidates.len() > 0 {\n-                                    self.report_similar_impl_candidates(trait_ref, &mut err);\n-                                }\n+                            // If we can't show anything useful, try to find\n+                            // similar impls.\n+                            let impl_candidates =\n+                                self.find_similar_impl_candidates(trait_ref);\n+                            if impl_candidates.len() > 0 {\n+                                self.report_similar_impl_candidates(trait_ref, &mut err);\n                             }\n-                            err\n                         }\n+                        err\n                     }\n \n                     ty::Predicate::Equate(ref predicate) => {"}]}