{"sha": "623fb90b5a1f324e0ec44085116bf858cef19a00", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyM2ZiOTBiNWExZjMyNGUwZWM0NDA4NTExNmJmODU4Y2VmMTlhMDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-26T20:57:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-26T20:57:31Z"}, "message": "Auto merge of #76897 - Aaron1011:feature/min-proc-macro-metadata, r=petrochenkov\n\nEncode less metadata for proc-macro crates\n\nCurrently, we serialize the same crate metadata for proc-macro crates as\nwe do for normal crates. This is quite wasteful - almost none of this\nmetadata is ever used, and much of it can't even be deserialized (if it\ncontains a foreign `CrateNum`).\n\nThis PR changes metadata encoding to skip encoding the majority of crate\nmetadata for proc-macro crates. Most of the `Lazy<[T]>` fields are left\ncompletetly empty, while the non-lazy fields are left as-is.\n\nAdditionally, proc-macros now have a def span that does not include\ntheir body. This was done for normal functions in #75465, but was missed\nfor proc-macros.\n\nAs a result of this PR, we should only ever encode local `CrateNum`s\nwhen encoding proc-macro crates. I've added a specialized serialization\nimpl for `CrateNum` to assert this.", "tree": {"sha": "0c05ab1775fed4ee4dc141fd443a6d0d1c952bed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c05ab1775fed4ee4dc141fd443a6d0d1c952bed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/623fb90b5a1f324e0ec44085116bf858cef19a00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/623fb90b5a1f324e0ec44085116bf858cef19a00", "html_url": "https://github.com/rust-lang/rust/commit/623fb90b5a1f324e0ec44085116bf858cef19a00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/623fb90b5a1f324e0ec44085116bf858cef19a00/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e37c99fa1ca2341d652a1b1859ea9aa2ae993e1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e37c99fa1ca2341d652a1b1859ea9aa2ae993e1e", "html_url": "https://github.com/rust-lang/rust/commit/e37c99fa1ca2341d652a1b1859ea9aa2ae993e1e"}, {"sha": "b9653568a78ff3936ce78a1c65b6c83ff53702a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9653568a78ff3936ce78a1c65b6c83ff53702a4", "html_url": "https://github.com/rust-lang/rust/commit/b9653568a78ff3936ce78a1c65b6c83ff53702a4"}], "stats": {"total": 228, "additions": 168, "deletions": 60}, "files": [{"sha": "c31e941b3ffc60677e17dbfccb94aa3730793f3d", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 38, "deletions": 18, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/623fb90b5a1f324e0ec44085116bf858cef19a00/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/623fb90b5a1f324e0ec44085116bf858cef19a00/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=623fb90b5a1f324e0ec44085116bf858cef19a00", "patch": "@@ -707,7 +707,11 @@ impl CrateRoot<'_> {\n \n impl<'a, 'tcx> CrateMetadataRef<'a> {\n     fn is_proc_macro(&self, id: DefIndex) -> bool {\n-        self.root.proc_macro_data.and_then(|data| data.decode(self).find(|x| *x == id)).is_some()\n+        self.root\n+            .proc_macro_data\n+            .as_ref()\n+            .and_then(|data| data.macros.decode(self).find(|x| *x == id))\n+            .is_some()\n     }\n \n     fn maybe_kind(&self, item_id: DefIndex) -> Option<EntryKind> {\n@@ -729,7 +733,15 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     fn raw_proc_macro(&self, id: DefIndex) -> &ProcMacro {\n         // DefIndex's in root.proc_macro_data have a one-to-one correspondence\n         // with items in 'raw_proc_macros'.\n-        let pos = self.root.proc_macro_data.unwrap().decode(self).position(|i| i == id).unwrap();\n+        let pos = self\n+            .root\n+            .proc_macro_data\n+            .as_ref()\n+            .unwrap()\n+            .macros\n+            .decode(self)\n+            .position(|i| i == id)\n+            .unwrap();\n         &self.raw_proc_macros.unwrap()[pos]\n     }\n \n@@ -766,7 +778,12 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n-        self.root.tables.span.get(self, index).unwrap().decode((self, sess))\n+        self.root\n+            .tables\n+            .span\n+            .get(self, index)\n+            .unwrap_or_else(|| panic!(\"Missing span for {:?}\", index))\n+            .decode((self, sess))\n     }\n \n     fn load_proc_macro(&self, id: DefIndex, sess: &Session) -> SyntaxExtension {\n@@ -942,7 +959,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n     fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n         match self.is_proc_macro(id) {\n-            true => self.root.proc_macro_stability,\n+            true => self.root.proc_macro_data.as_ref().unwrap().stability,\n             false => self.root.tables.stability.get(self, id).map(|stab| stab.decode(self)),\n         }\n     }\n@@ -1035,24 +1052,20 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     where\n         F: FnMut(Export<hir::HirId>),\n     {\n-        if let Some(proc_macros_ids) = self.root.proc_macro_data.map(|d| d.decode(self)) {\n+        if let Some(data) = &self.root.proc_macro_data {\n             /* If we are loading as a proc macro, we want to return the view of this crate\n              * as a proc macro crate.\n              */\n             if id == CRATE_DEF_INDEX {\n-                for def_index in proc_macros_ids {\n+                let macros = data.macros.decode(self);\n+                for def_index in macros {\n                     let raw_macro = self.raw_proc_macro(def_index);\n                     let res = Res::Def(\n                         DefKind::Macro(macro_kind(raw_macro)),\n                         self.local_def_id(def_index),\n                     );\n                     let ident = self.item_ident(def_index, sess);\n-                    callback(Export {\n-                        ident,\n-                        res,\n-                        vis: ty::Visibility::Public,\n-                        span: self.get_span(def_index, sess),\n-                    });\n+                    callback(Export { ident, res, vis: ty::Visibility::Public, span: ident.span });\n                 }\n             }\n             return;\n@@ -1559,12 +1572,19 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n     fn all_def_path_hashes_and_def_ids(&self) -> Vec<(DefPathHash, DefId)> {\n         let mut def_path_hashes = self.def_path_hash_cache.lock();\n-        (0..self.num_def_ids())\n-            .map(|index| {\n-                let index = DefIndex::from_usize(index);\n-                (self.def_path_hash_unlocked(index, &mut def_path_hashes), self.local_def_id(index))\n-            })\n-            .collect()\n+        let mut def_index_to_data = |index| {\n+            (self.def_path_hash_unlocked(index, &mut def_path_hashes), self.local_def_id(index))\n+        };\n+        if let Some(data) = &self.root.proc_macro_data {\n+            std::iter::once(CRATE_DEF_INDEX)\n+                .chain(data.macros.decode(self))\n+                .map(def_index_to_data)\n+                .collect()\n+        } else {\n+            (0..self.num_def_ids())\n+                .map(|index| def_index_to_data(DefIndex::from_usize(index)))\n+                .collect()\n+        }\n     }\n \n     /// Get the `DepNodeIndex` corresponding this crate. The result of this"}, {"sha": "4102cf84a67756f8df0d0b88f9e95bf82a6f41df", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/623fb90b5a1f324e0ec44085116bf858cef19a00/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/623fb90b5a1f324e0ec44085116bf858cef19a00/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=623fb90b5a1f324e0ec44085116bf858cef19a00", "patch": "@@ -179,8 +179,11 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         })\n     }\n     proc_macro_decls_static => {\n-        cdata.root.proc_macro_decls_static.map(|index| {\n-            DefId { krate: def_id.krate, index }\n+        cdata.root.proc_macro_data.as_ref().map(|data| {\n+            DefId {\n+                krate: def_id.krate,\n+                index: data.proc_macro_decls_static,\n+            }\n         })\n     }\n     crate_disambiguator => { cdata.root.disambiguator }"}, {"sha": "c756715dbe5131dbe8d0332718772076dfee0eb1", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 101, "deletions": 35, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/623fb90b5a1f324e0ec44085116bf858cef19a00/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/623fb90b5a1f324e0ec44085116bf858cef19a00/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=623fb90b5a1f324e0ec44085116bf858cef19a00", "patch": "@@ -68,6 +68,17 @@ pub(super) struct EncodeContext<'a, 'tcx> {\n     hygiene_ctxt: &'a HygieneEncodeContext,\n }\n \n+/// If the current crate is a proc-macro, returns early with `Lazy:empty()`.\n+/// This is useful for skipping the encoding of things that aren't needed\n+/// for proc-macro crates.\n+macro_rules! empty_proc_macro {\n+    ($self:ident) => {\n+        if $self.is_proc_macro {\n+            return Lazy::empty();\n+        }\n+    };\n+}\n+\n macro_rules! encoder_methods {\n     ($($name:ident($ty:ty);)*) => {\n         $(fn $name(&mut self, value: $ty) -> Result<(), Self::Error> {\n@@ -138,6 +149,15 @@ where\n     }\n }\n \n+impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for CrateNum {\n+    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+        if *self != LOCAL_CRATE && s.is_proc_macro {\n+            panic!(\"Attempted to encode non-local CrateNum {:?} for proc-macro crate\", self);\n+        }\n+        s.emit_u32(self.as_u32())\n+    }\n+}\n+\n impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for DefIndex {\n     fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n         s.emit_u32(self.as_u32())\n@@ -418,6 +438,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let krate = self.tcx.hir().krate();\n         let vis = Spanned { span: rustc_span::DUMMY_SP, node: hir::VisibilityKind::Public };\n         self.encode_info_for_mod(hir::CRATE_HIR_ID, &krate.item.module, &krate.item.attrs, &vis);\n+\n+        // Proc-macro crates only export proc-macro items, which are looked\n+        // up using `proc_macro_data`\n+        if self.is_proc_macro {\n+            return;\n+        }\n+\n         krate.visit_all_item_likes(&mut self.as_deep_visitor());\n         for macro_def in krate.exported_macros {\n             self.visit_macro_def(macro_def);\n@@ -426,11 +453,22 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_def_path_table(&mut self) {\n         let table = self.tcx.hir().definitions().def_path_table();\n-        for (def_index, def_key, def_path_hash) in table.enumerated_keys_and_path_hashes() {\n-            let def_key = self.lazy(def_key);\n-            let def_path_hash = self.lazy(def_path_hash);\n-            self.tables.def_keys.set(def_index, def_key);\n-            self.tables.def_path_hashes.set(def_index, def_path_hash);\n+        if self.is_proc_macro {\n+            for def_index in std::iter::once(CRATE_DEF_INDEX)\n+                .chain(self.tcx.hir().krate().proc_macros.iter().map(|p| p.owner.local_def_index))\n+            {\n+                let def_key = self.lazy(table.def_key(def_index));\n+                let def_path_hash = self.lazy(table.def_path_hash(def_index));\n+                self.tables.def_keys.set(def_index, def_key);\n+                self.tables.def_path_hashes.set(def_index, def_path_hash);\n+            }\n+        } else {\n+            for (def_index, def_key, def_path_hash) in table.enumerated_keys_and_path_hashes() {\n+                let def_key = self.lazy(def_key);\n+                let def_path_hash = self.lazy(def_path_hash);\n+                self.tables.def_keys.set(def_index, def_key);\n+                self.tables.def_path_hashes.set(def_index, def_path_hash);\n+            }\n         }\n     }\n \n@@ -497,13 +535,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.lazy(adapted.iter().map(|rc| &**rc))\n     }\n \n-    fn is_proc_macro(&self) -> bool {\n-        self.tcx.sess.crate_types().contains(&CrateType::ProcMacro)\n-    }\n-\n     fn encode_crate_root(&mut self) -> Lazy<CrateRoot<'tcx>> {\n-        let is_proc_macro = self.is_proc_macro();\n-\n         let mut i = self.position();\n \n         // Encode the crate deps\n@@ -575,15 +607,16 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             self.lazy(interpret_alloc_index)\n         };\n \n-        i = self.position();\n-        let tables = self.tables.encode(&mut self.opaque);\n-        let tables_bytes = self.position() - i;\n-\n-        // Encode the proc macro data\n+        // Encode the proc macro data. This affects 'tables',\n+        // so we need to do this before we encode the tables\n         i = self.position();\n         let proc_macro_data = self.encode_proc_macros();\n         let proc_macro_data_bytes = self.position() - i;\n \n+        i = self.position();\n+        let tables = self.tables.encode(&mut self.opaque);\n+        let tables_bytes = self.position() - i;\n+\n         // Encode exported symbols info. This is prefetched in `encode_metadata` so we encode\n         // this as late as possible to give the prefetching as much time as possible to complete.\n         i = self.position();\n@@ -624,18 +657,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             has_panic_handler: tcx.has_panic_handler(LOCAL_CRATE),\n             has_default_lib_allocator,\n             plugin_registrar_fn: tcx.plugin_registrar_fn(LOCAL_CRATE).map(|id| id.index),\n-            proc_macro_decls_static: if is_proc_macro {\n-                let id = tcx.proc_macro_decls_static(LOCAL_CRATE).unwrap();\n-                Some(id.index)\n-            } else {\n-                None\n-            },\n             proc_macro_data,\n-            proc_macro_stability: if is_proc_macro {\n-                tcx.lookup_stability(DefId::local(CRATE_DEF_INDEX)).copied()\n-            } else {\n-                None\n-            },\n             compiler_builtins: tcx.sess.contains_name(&attrs, sym::compiler_builtins),\n             needs_allocator: tcx.sess.contains_name(&attrs, sym::needs_allocator),\n             needs_panic_runtime: tcx.sess.contains_name(&attrs, sym::needs_panic_runtime),\n@@ -800,8 +822,13 @@ impl EncodeContext<'a, 'tcx> {\n         let def_id = local_def_id.to_def_id();\n         debug!(\"EncodeContext::encode_info_for_mod({:?})\", def_id);\n \n-        let data = ModData {\n-            reexports: match tcx.module_exports(local_def_id) {\n+        // If we are encoding a proc-macro crates, `encode_info_for_mod` will\n+        // only ever get called for the crate root. We still want to encode\n+        // the crate root for consistency with other crates (some of the resolver\n+        // code uses it). However, we skip encoding anything relating to child\n+        // items - we encode information about proc-macros later on.\n+        let reexports = if !self.is_proc_macro {\n+            match tcx.module_exports(local_def_id) {\n                 Some(exports) => {\n                     let hir = self.tcx.hir();\n                     self.lazy(\n@@ -811,17 +838,27 @@ impl EncodeContext<'a, 'tcx> {\n                     )\n                 }\n                 _ => Lazy::empty(),\n-            },\n+            }\n+        } else {\n+            Lazy::empty()\n+        };\n+\n+        let data = ModData {\n+            reexports,\n             expansion: tcx.hir().definitions().expansion_that_defined(local_def_id),\n         };\n \n         record!(self.tables.kind[def_id] <- EntryKind::Mod(self.lazy(data)));\n         record!(self.tables.visibility[def_id] <- ty::Visibility::from_hir(vis, id, self.tcx));\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         record!(self.tables.attributes[def_id] <- attrs);\n-        record!(self.tables.children[def_id] <- md.item_ids.iter().map(|item_id| {\n-            tcx.hir().local_def_id(item_id.id).local_def_index\n-        }));\n+        if self.is_proc_macro {\n+            record!(self.tables.children[def_id] <- &[]);\n+        } else {\n+            record!(self.tables.children[def_id] <- md.item_ids.iter().map(|item_id| {\n+                tcx.hir().local_def_id(item_id.id).local_def_index\n+            }));\n+        }\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n     }\n@@ -1481,11 +1518,13 @@ impl EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_native_libraries(&mut self) -> Lazy<[NativeLib]> {\n+        empty_proc_macro!(self);\n         let used_libraries = self.tcx.native_libraries(LOCAL_CRATE);\n         self.lazy(used_libraries.iter().cloned())\n     }\n \n     fn encode_foreign_modules(&mut self) -> Lazy<[ForeignModule]> {\n+        empty_proc_macro!(self);\n         let foreign_modules = self.tcx.foreign_modules(LOCAL_CRATE);\n         self.lazy(foreign_modules.iter().cloned())\n     }\n@@ -1509,17 +1548,37 @@ impl EncodeContext<'a, 'tcx> {\n         (syntax_contexts.encode(&mut self.opaque), expn_data_table.encode(&mut self.opaque))\n     }\n \n-    fn encode_proc_macros(&mut self) -> Option<Lazy<[DefIndex]>> {\n+    fn encode_proc_macros(&mut self) -> Option<ProcMacroData> {\n         let is_proc_macro = self.tcx.sess.crate_types().contains(&CrateType::ProcMacro);\n         if is_proc_macro {\n             let tcx = self.tcx;\n-            Some(self.lazy(tcx.hir().krate().proc_macros.iter().map(|p| p.owner.local_def_index)))\n+            let hir = tcx.hir();\n+\n+            let proc_macro_decls_static = tcx.proc_macro_decls_static(LOCAL_CRATE).unwrap().index;\n+            let stability = tcx.lookup_stability(DefId::local(CRATE_DEF_INDEX)).copied();\n+            let macros = self.lazy(hir.krate().proc_macros.iter().map(|p| p.owner.local_def_index));\n+\n+            // Normally, this information is encoded when we walk the items\n+            // defined in this crate. However, we skip doing that for proc-macro crates,\n+            // so we manually encode just the information that we need\n+            for proc_macro in &hir.krate().proc_macros {\n+                let id = proc_macro.owner.local_def_index;\n+                let span = self.lazy(hir.span(*proc_macro));\n+                // Proc-macros may have attributes like `#[allow_internal_unstable]`,\n+                // so downstream crates need access to them.\n+                let attrs = self.lazy(hir.attrs(*proc_macro));\n+                self.tables.span.set(id, span);\n+                self.tables.attributes.set(id, attrs);\n+            }\n+\n+            Some(ProcMacroData { proc_macro_decls_static, stability, macros })\n         } else {\n             None\n         }\n     }\n \n     fn encode_crate_deps(&mut self) -> Lazy<[CrateDep]> {\n+        empty_proc_macro!(self);\n         let crates = self.tcx.crates();\n \n         let mut deps = crates\n@@ -1555,18 +1614,21 @@ impl EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_lib_features(&mut self) -> Lazy<[(Symbol, Option<Symbol>)]> {\n+        empty_proc_macro!(self);\n         let tcx = self.tcx;\n         let lib_features = tcx.lib_features();\n         self.lazy(lib_features.to_vec())\n     }\n \n     fn encode_diagnostic_items(&mut self) -> Lazy<[(Symbol, DefIndex)]> {\n+        empty_proc_macro!(self);\n         let tcx = self.tcx;\n         let diagnostic_items = tcx.diagnostic_items(LOCAL_CRATE);\n         self.lazy(diagnostic_items.iter().map(|(&name, def_id)| (name, def_id.index)))\n     }\n \n     fn encode_lang_items(&mut self) -> Lazy<[(DefIndex, usize)]> {\n+        empty_proc_macro!(self);\n         let tcx = self.tcx;\n         let lang_items = tcx.lang_items();\n         let lang_items = lang_items.items().iter();\n@@ -1581,12 +1643,14 @@ impl EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_lang_items_missing(&mut self) -> Lazy<[lang_items::LangItem]> {\n+        empty_proc_macro!(self);\n         let tcx = self.tcx;\n         self.lazy(&tcx.lang_items().missing)\n     }\n \n     /// Encodes an index, mapping each trait to its (local) implementations.\n     fn encode_impls(&mut self) -> Lazy<[TraitImpls]> {\n+        empty_proc_macro!(self);\n         debug!(\"EncodeContext::encode_impls()\");\n         let tcx = self.tcx;\n         let mut visitor = ImplVisitor { tcx, impls: FxHashMap::default() };\n@@ -1625,6 +1689,7 @@ impl EncodeContext<'a, 'tcx> {\n         &mut self,\n         exported_symbols: &[(ExportedSymbol<'tcx>, SymbolExportLevel)],\n     ) -> Lazy<[(ExportedSymbol<'tcx>, SymbolExportLevel)]> {\n+        empty_proc_macro!(self);\n         // The metadata symbol name is special. It should not show up in\n         // downstream crates.\n         let metadata_symbol_name = SymbolName::new(self.tcx, &metadata_symbol_name(self.tcx));\n@@ -1641,6 +1706,7 @@ impl EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_dylib_dependency_formats(&mut self) -> Lazy<[Option<LinkagePreference>]> {\n+        empty_proc_macro!(self);\n         let formats = self.tcx.dependency_formats(LOCAL_CRATE);\n         for (ty, arr) in formats.iter() {\n             if *ty != CrateType::Dylib {"}, {"sha": "1a127035d4ff7f470b894c31d6bbead8cd308f64", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/623fb90b5a1f324e0ec44085116bf858cef19a00/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/623fb90b5a1f324e0ec44085116bf858cef19a00/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=623fb90b5a1f324e0ec44085116bf858cef19a00", "patch": "@@ -172,6 +172,29 @@ macro_rules! Lazy {\n type SyntaxContextTable = Lazy<Table<u32, Lazy<SyntaxContextData>>>;\n type ExpnDataTable = Lazy<Table<u32, Lazy<ExpnData>>>;\n \n+#[derive(MetadataEncodable, MetadataDecodable)]\n+crate struct ProcMacroData {\n+    proc_macro_decls_static: DefIndex,\n+    stability: Option<attr::Stability>,\n+    macros: Lazy<[DefIndex]>,\n+}\n+\n+/// Serialized metadata for a crate.\n+/// When compiling a proc-macro crate, we encode many of\n+/// the `Lazy<[T]>` fields as `Lazy::empty()`. This serves two purposes:\n+///\n+/// 1. We avoid performing unnecessary work. Proc-macro crates can only\n+/// export proc-macros functions, which are compiled into a shared library.\n+/// As a result, a large amount of the information we normally store\n+/// (e.g. optimized MIR) is unneeded by downstream crates.\n+/// 2. We avoid serializing invalid `CrateNum`s. When we deserialize\n+/// a proc-macro crate, we don't load any of its dependencies (since we\n+/// just need to invoke a native function from the shared library).\n+/// This means that any foreign `CrateNum`s that we serialize cannot be\n+/// deserialized, since we will not know how to map them into the current\n+/// compilation session. If we were to serialize a proc-macro crate like\n+/// a normal crate, much of what we serialized would be unusable in addition\n+/// to being unused.\n #[derive(MetadataEncodable, MetadataDecodable)]\n crate struct CrateRoot<'tcx> {\n     name: Symbol,\n@@ -185,8 +208,6 @@ crate struct CrateRoot<'tcx> {\n     has_panic_handler: bool,\n     has_default_lib_allocator: bool,\n     plugin_registrar_fn: Option<DefIndex>,\n-    proc_macro_decls_static: Option<DefIndex>,\n-    proc_macro_stability: Option<attr::Stability>,\n \n     crate_deps: Lazy<[CrateDep]>,\n     dylib_dependency_formats: Lazy<[Option<LinkagePreference>]>,\n@@ -198,12 +219,10 @@ crate struct CrateRoot<'tcx> {\n     foreign_modules: Lazy<[ForeignModule]>,\n     impls: Lazy<[TraitImpls]>,\n     interpret_alloc_index: Lazy<[u32]>,\n+    proc_macro_data: Option<ProcMacroData>,\n \n     tables: LazyTables<'tcx>,\n \n-    /// The DefIndex's of any proc macros declared by this crate.\n-    proc_macro_data: Option<Lazy<[DefIndex]>>,\n-\n     exported_symbols: Lazy!([(ExportedSymbol<'tcx>, SymbolExportLevel)]),\n \n     syntax_contexts: SyntaxContextTable,"}]}