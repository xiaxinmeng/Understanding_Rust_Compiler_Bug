{"sha": "2c59e03de22c33d2382305eec0f951bef4ddcb93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjNTllMDNkZTIyYzMzZDIzODIzMDVlZWMwZjk1MWJlZjRkZGNiOTM=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-03-29T03:19:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-03-29T03:19:24Z"}, "message": "Rollup merge of #40838 - lukaramu:std-net-docs, r=GuillaumeGomez\n\nImprove std::net docs\n\nFixes #29363\n\nSummary:\n* Added a _lot_ of missing links, both to other types/methods and to IETF RFCs, and changed occurences of just \"RFC\" to \"IETF RFC\"\n* Expanded a bunch of top-level docs, specifically the module docs & the docs for `TcpListener`, `TcpStream`, `UdpSocket`, `IpAddr`, `Ipv4Addr`, `Ipv6Addr`, `SocketAddr`, `SocketAddrV4`, `SocketAddrV6`,\n* Expanded method docs for `SocketAddrV6`, `AddrParseError`,\n* Various edits for clarity, consistency, and accuracy\n\nSee the commit descriptions for more detail.\n\nThings not done quite as laid out in the task list in #29363:\n* `AddrParseError` still doesn't have examples, but I wasn't quite sure how to do them; other `FromStr` error types don't have any, either\n* I didn't link to an IETF RFC in `IpAddr`, but in `Ipv4Addr` and `Ipv6Addr` and linked tho those from `IpAddr`; this seems more appropriate to me\n* Similarly, I didn't really exand `SocketAddr`'s docs, but elaborated on `SocketAddrV4` and `SocketAddrV6`'s and linked to them from `SocketAddr`\n\nTheres definitely still room for improvement, but this should be a good first effort :smile:", "tree": {"sha": "6ac6bdfe93eb24c24acef347183afd0c7b39f54d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ac6bdfe93eb24c24acef347183afd0c7b39f54d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c59e03de22c33d2382305eec0f951bef4ddcb93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c59e03de22c33d2382305eec0f951bef4ddcb93", "html_url": "https://github.com/rust-lang/rust/commit/2c59e03de22c33d2382305eec0f951bef4ddcb93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c59e03de22c33d2382305eec0f951bef4ddcb93/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88badb98c74f764f6e4baea3f6c9d3fd16013023", "url": "https://api.github.com/repos/rust-lang/rust/commits/88badb98c74f764f6e4baea3f6c9d3fd16013023", "html_url": "https://github.com/rust-lang/rust/commit/88badb98c74f764f6e4baea3f6c9d3fd16013023"}, {"sha": "b8cbc5d46af4b15bfeca324aa37d8c2ca054e58e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8cbc5d46af4b15bfeca324aa37d8c2ca054e58e", "html_url": "https://github.com/rust-lang/rust/commit/b8cbc5d46af4b15bfeca324aa37d8c2ca054e58e"}], "stats": {"total": 616, "additions": 476, "deletions": 140}, "files": [{"sha": "36c06dc0b58d057d8a0f6df048b48e8837ebfafd", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 154, "deletions": 44, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/2c59e03de22c33d2382305eec0f951bef4ddcb93/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c59e03de22c33d2382305eec0f951bef4ddcb93/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=2c59e03de22c33d2382305eec0f951bef4ddcb93", "patch": "@@ -20,34 +20,95 @@ use vec;\n use iter;\n use slice;\n \n-/// Representation of a socket address for networking applications.\n+/// An internet socket address, either IPv4 or IPv6.\n ///\n-/// A socket address can either represent the IPv4 or IPv6 protocol and is\n-/// paired with at least a port number as well. Each protocol may have more\n-/// specific information about the address available to it as well.\n+/// Internet socket addresses consist of an [IP address], a 16-bit port number, as well\n+/// as possibly some version-dependent additional information. See [`SocketAddrV4`]'s and\n+/// [`SocketAddrV6`]'s respective documentation for more details.\n+///\n+/// [IP address]: ../../std/net/enum.IpAddr.html\n+/// [`SocketAddrV4`]: ../../std/net/struct.SocketAddrV4.html\n+/// [`SocketAddrV6`]: ../../std/net/struct.SocketAddrV6.html\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+///\n+/// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+///\n+/// assert_eq!(\"127.0.0.1:8080\".parse(), Ok(socket));\n+/// assert_eq!(socket.port(), 8080);\n+/// assert_eq!(socket.is_ipv4(), true);\n+/// ```\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum SocketAddr {\n-    /// An IPv4 socket address which is a (ip, port) combination.\n+    /// An IPv4 socket address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     V4(#[stable(feature = \"rust1\", since = \"1.0.0\")] SocketAddrV4),\n     /// An IPv6 socket address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     V6(#[stable(feature = \"rust1\", since = \"1.0.0\")] SocketAddrV6),\n }\n \n-/// An IPv4 socket address which is a (ip, port) combination.\n+/// An IPv4 socket address.\n+///\n+/// IPv4 socket addresses consist of an [IPv4 address] and a 16-bit port number, as\n+/// stated in [IETF RFC 793].\n+///\n+/// See [`SocketAddr`] for a type encompassing both IPv4 and IPv6 socket addresses.\n+///\n+/// [IETF RFC 793]: https://tools.ietf.org/html/rfc793\n+/// [IPv4 address]: ../../std/net/struct.Ipv4Addr.html\n+/// [`SocketAddr`]: ../../std/net/enum.SocketAddr.html\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::net::{Ipv4Addr, SocketAddrV4};\n+///\n+/// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n+///\n+/// assert_eq!(\"127.0.0.1:8080\".parse(), Ok(socket));\n+/// assert_eq!(socket.ip(), &Ipv4Addr::new(127, 0, 0, 1));\n+/// assert_eq!(socket.port(), 8080);\n+/// ```\n #[derive(Copy)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SocketAddrV4 { inner: c::sockaddr_in }\n \n /// An IPv6 socket address.\n+///\n+/// IPv6 socket addresses consist of an [Ipv6 address], a 16-bit port number, as well\n+/// as fields containing the traffic class, the flow label, and a scope identifier\n+/// (see [IETF RFC 2553, Section 3.3] for more details).\n+///\n+/// See [`SocketAddr`] for a type encompassing both IPv4 and IPv6 socket addresses.\n+///\n+/// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n+/// [IPv6 address]: ../../std/net/struct.Ipv6Addr.html\n+/// [`SocketAddr`]: ../../std/net/enum.SocketAddr.html\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::net::{Ipv6Addr, SocketAddrV6};\n+///\n+/// let socket = SocketAddrV6::new(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n+///\n+/// assert_eq!(\"[2001:db8::1]:8080\".parse(), Ok(socket));\n+/// assert_eq!(socket.ip(), &Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1));\n+/// assert_eq!(socket.port(), 8080);\n+/// ```\n #[derive(Copy)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SocketAddrV6 { inner: c::sockaddr_in6 }\n \n impl SocketAddr {\n-    /// Creates a new socket address from the (ip, port) pair.\n+    /// Creates a new socket address from an [IP address] and a port number.\n+    ///\n+    /// [IP address]: ../../std/net/enum.IpAddr.html\n     ///\n     /// # Examples\n     ///\n@@ -84,7 +145,7 @@ impl SocketAddr {\n         }\n     }\n \n-    /// Change the IP address associated with this socket address.\n+    /// Changes the IP address associated with this socket address.\n     ///\n     /// # Examples\n     ///\n@@ -123,7 +184,7 @@ impl SocketAddr {\n         }\n     }\n \n-    /// Change the port number associated with this socket address.\n+    /// Changes the port number associated with this socket address.\n     ///\n     /// # Examples\n     ///\n@@ -142,8 +203,13 @@ impl SocketAddr {\n         }\n     }\n \n-    /// Returns true if the IP in this `SocketAddr` is a valid IPv4 address,\n-    /// false if it's a valid IPv6 address.\n+    /// Returns [`true`] if the [IP address] in this `SocketAddr` is an\n+    /// [IPv4 address], and [`false`] otherwise.\n+    ///\n+    /// [`true`]: ../../std/primitive.bool.html\n+    /// [`false`]: ../../std/primitive.bool.html\n+    /// [IP address]: ../../std/net/enum.IpAddr.html\n+    /// [IPv4 address]: ../../std/net/enum.IpAddr.html#variant.V4\n     ///\n     /// # Examples\n     ///\n@@ -164,8 +230,13 @@ impl SocketAddr {\n         }\n     }\n \n-    /// Returns true if the IP in this `SocketAddr` is a valid IPv6 address,\n-    /// false if it's a valid IPv4 address.\n+    /// Returns [`true`] if the [IP address] in this `SocketAddr` is an\n+    /// [IPv6 address], and [`false`] otherwise.\n+    ///\n+    /// [`true`]: ../../std/primitive.bool.html\n+    /// [`false`]: ../../std/primitive.bool.html\n+    /// [IP address]: ../../std/net/enum.IpAddr.html\n+    /// [IPv6 address]: ../../std/net/enum.IpAddr.html#variant.V6\n     ///\n     /// # Examples\n     ///\n@@ -189,7 +260,9 @@ impl SocketAddr {\n }\n \n impl SocketAddrV4 {\n-    /// Creates a new socket address from the (ip, port) pair.\n+    /// Creates a new socket address from an [IPv4 address] and a port number.\n+    ///\n+    /// [IPv4 address]: ../../std/net/struct.Ipv4Addr.html\n     ///\n     /// # Examples\n     ///\n@@ -227,7 +300,7 @@ impl SocketAddrV4 {\n         }\n     }\n \n-    /// Change the IP address associated with this socket address.\n+    /// Changes the IP address associated with this socket address.\n     ///\n     /// # Examples\n     ///\n@@ -258,7 +331,7 @@ impl SocketAddrV4 {\n         ntoh(self.inner.sin_port)\n     }\n \n-    /// Change the port number associated with this socket address.\n+    /// Changes the port number associated with this socket address.\n     ///\n     /// # Examples\n     ///\n@@ -276,8 +349,14 @@ impl SocketAddrV4 {\n }\n \n impl SocketAddrV6 {\n-    /// Creates a new socket address from the ip/port/flowinfo/scope_id\n-    /// components.\n+    /// Creates a new socket address from an [IPv6 address], a 16-bit port number,\n+    /// and the `flowinfo` and `scope_id` fields.\n+    ///\n+    /// For more information on the meaning and layout of the `flowinfo` and `scope_id`\n+    /// parameters, see [IETF RFC 2553, Section 3.3].\n+    ///\n+    /// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n+    /// [IPv6 address]: ../../std/net/struct.Ipv6Addr.html\n     ///\n     /// # Examples\n     ///\n@@ -318,7 +397,7 @@ impl SocketAddrV6 {\n         }\n     }\n \n-    /// Change the IP address associated with this socket address.\n+    /// Changes the IP address associated with this socket address.\n     ///\n     /// # Examples\n     ///\n@@ -349,7 +428,7 @@ impl SocketAddrV6 {\n         ntoh(self.inner.sin6_port)\n     }\n \n-    /// Change the port number associated with this socket address.\n+    /// Changes the port number associated with this socket address.\n     ///\n     /// # Examples\n     ///\n@@ -365,8 +444,17 @@ impl SocketAddrV6 {\n         self.inner.sin6_port = hton(new_port);\n     }\n \n-    /// Returns the flow information associated with this address,\n-    /// corresponding to the `sin6_flowinfo` field in C.\n+    /// Returns the flow information associated with this address.\n+    ///\n+    /// This information corresponds to the `sin6_flowinfo` field in C's `netinet/in.h`,\n+    /// as specified in [IETF RFC 2553, Section 3.3].\n+    /// It combines information about the flow label and the traffic class as specified\n+    /// in [IETF RFC 2460], respectively [Section 6] and [Section 7].\n+    ///\n+    /// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n+    /// [IETF RFC 2460]: https://tools.ietf.org/html/rfc2460\n+    /// [Section 6]: https://tools.ietf.org/html/rfc2460#section-6\n+    /// [Section 7]: https://tools.ietf.org/html/rfc2460#section-7\n     ///\n     /// # Examples\n     ///\n@@ -381,7 +469,11 @@ impl SocketAddrV6 {\n         self.inner.sin6_flowinfo\n     }\n \n-    /// Change the flow information associated with this socket address.\n+    /// Changes the flow information associated with this socket address.\n+    ///\n+    /// See the [`flowinfo`] method's documentation for more details.\n+    ///\n+    /// [`flowinfo`]: #method.flowinfo\n     ///\n     /// # Examples\n     ///\n@@ -397,8 +489,12 @@ impl SocketAddrV6 {\n         self.inner.sin6_flowinfo = new_flowinfo;\n     }\n \n-    /// Returns the scope ID associated with this address,\n-    /// corresponding to the `sin6_scope_id` field in C.\n+    /// Returns the scope ID associated with this address.\n+    ///\n+    /// This information corresponds to the `sin6_scope_id` field in C's `netinet/in.h`,\n+    /// as specified in [IETF RFC 2553, Section 3.3].\n+    ///\n+    /// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n     ///\n     /// # Examples\n     ///\n@@ -415,6 +511,10 @@ impl SocketAddrV6 {\n \n     /// Change the scope ID associated with this socket address.\n     ///\n+    /// See the [`scope_id`] method's documentation for more details.\n+    ///\n+    /// [`scope_id`]: #method.scope_id\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -559,37 +659,51 @@ impl hash::Hash for SocketAddrV6 {\n }\n \n /// A trait for objects which can be converted or resolved to one or more\n-/// `SocketAddr` values.\n+/// [`SocketAddr`] values.\n ///\n /// This trait is used for generic address resolution when constructing network\n /// objects.  By default it is implemented for the following types:\n ///\n-///  * `SocketAddr`, `SocketAddrV4`, `SocketAddrV6` - `to_socket_addrs` is\n-///    identity function.\n+///  * [`SocketAddr`]: [`to_socket_addrs`] is the identity function.\n ///\n-///  * `(IpvNAddr, u16)` - `to_socket_addrs` constructs `SocketAddr` trivially.\n+///  * [`SocketAddrV4`], [`SocketAddrV6`], `(`[`IpAddr`]`, `[`u16`]`)`,\n+///    `(`[`Ipv4Addr`]`, `[`u16`]`)`, `(`[`Ipv6Addr`]`, `[`u16`]`)`:\n+///    [`to_socket_addrs`] constructs a [`SocketAddr`] trivially.\n ///\n-///  * `(&str, u16)` - the string should be either a string representation of an\n-///    IP address expected by `FromStr` implementation for `IpvNAddr` or a host\n+///  * `(`[`&str`]`, `[`u16`]`)`: the string should be either a string representation\n+///    of an [`IpAddr`] address as expected by [`FromStr`] implementation or a host\n ///    name.\n ///\n-///  * `&str` - the string should be either a string representation of a\n-///    `SocketAddr` as expected by its `FromStr` implementation or a string like\n-///    `<host_name>:<port>` pair where `<port>` is a `u16` value.\n+///  * [`&str`]: the string should be either a string representation of a\n+///    [`SocketAddr`] as expected by its [`FromStr`] implementation or a string like\n+///    `<host_name>:<port>` pair where `<port>` is a [`u16`] value.\n ///\n-/// This trait allows constructing network objects like `TcpStream` or\n-/// `UdpSocket` easily with values of various types for the bind/connection\n+/// This trait allows constructing network objects like [`TcpStream`] or\n+/// [`UdpSocket`] easily with values of various types for the bind/connection\n /// address. It is needed because sometimes one type is more appropriate than\n /// the other: for simple uses a string like `\"localhost:12345\"` is much nicer\n-/// than manual construction of the corresponding `SocketAddr`, but sometimes\n-/// `SocketAddr` value is *the* main source of the address, and converting it to\n+/// than manual construction of the corresponding [`SocketAddr`], but sometimes\n+/// [`SocketAddr`] value is *the* main source of the address, and converting it to\n /// some other type (e.g. a string) just for it to be converted back to\n-/// `SocketAddr` in constructor methods is pointless.\n+/// [`SocketAddr`] in constructor methods is pointless.\n ///\n /// Addresses returned by the operating system that are not IP addresses are\n /// silently ignored.\n ///\n-/// Some examples:\n+/// [`FromStr`]: ../../std/str/trait.FromStr.html\n+/// [`IpAddr`]: ../../std/net/enum.IpAddr.html\n+/// [`Ipv4Addr`]: ../../std/net/struct.Ipv4Addr.html\n+/// [`Ipv6Addr`]: ../../std/net/struct.Ipv6Addr.html\n+/// [`SocketAddr`]: ../../std/net/enum.SocketAddr.html\n+/// [`SocketAddrV4`]: ../../std/net/struct.SocketAddrV4.html\n+/// [`SocketAddrV6`]: ../../std/net/struct.SocketAddrV6.html\n+/// [`&str`]: ../../std/primitive.str.html\n+/// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n+/// [`to_socket_addrs`]: #tymethod.to_socket_addrs\n+/// [`UdpSocket`]: ../../std/net/struct.UdpSocket.html\n+/// [`u16`]: ../../std/primitive.u16.html\n+///\n+/// # Examples\n ///\n /// ```no_run\n /// use std::net::{SocketAddrV4, TcpStream, UdpSocket, TcpListener, Ipv4Addr};\n@@ -629,10 +743,6 @@ pub trait ToSocketAddrs {\n     ///\n     /// Note that this function may block the current thread while resolution is\n     /// performed.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Any errors encountered during resolution will be returned as an `Err`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn to_socket_addrs(&self) -> io::Result<Self::Iter>;\n }"}, {"sha": "c46fe4a58c7e246f919c74ec28afb9b679f63948", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 181, "deletions": 66, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/2c59e03de22c33d2382305eec0f951bef4ddcb93/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c59e03de22c33d2382305eec0f951bef4ddcb93/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=2c59e03de22c33d2382305eec0f951bef4ddcb93", "patch": "@@ -21,44 +21,100 @@ use net::{hton, ntoh};\n use sys::net::netc as c;\n use sys_common::{AsInner, FromInner};\n \n-/// An IP address, either an IPv4 or IPv6 address.\n+/// An IP address, either IPv4 or IPv6.\n ///\n-/// # Examples\n+/// This enum can contain either an [`Ipv4Addr`] or an [`Ipv6Addr`], see their\n+/// respective documentation for more details.\n ///\n-/// Constructing an IPv4 address:\n+/// [`Ipv4Addr`]: ../../std/net/struct.Ipv4Addr.html\n+/// [`Ipv6Addr`]: ../../std/net/struct.Ipv6Addr.html\n ///\n-/// ```\n-/// use std::net::{IpAddr, Ipv4Addr};\n+/// # Examples\n ///\n-/// IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1));\n /// ```\n+/// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n ///\n-/// Constructing an IPv6 address:\n+/// let localhost_v4 = IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1));\n+/// let localhost_v6 = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n ///\n-/// ```\n-/// use std::net::{IpAddr, Ipv6Addr};\n+/// assert_eq!(\"127.0.0.1\".parse(), Ok(localhost_v4));\n+/// assert_eq!(\"::1\".parse(), Ok(localhost_v6));\n ///\n-/// IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n+/// assert_eq!(localhost_v4.is_ipv6(), false);\n+/// assert_eq!(localhost_v4.is_ipv4(), true);\n /// ```\n #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n #[derive(Copy, Clone, Eq, PartialEq, Debug, Hash, PartialOrd, Ord)]\n pub enum IpAddr {\n-    /// Representation of an IPv4 address.\n+    /// An IPv4 address.\n     #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n     V4(#[stable(feature = \"ip_addr\", since = \"1.7.0\")] Ipv4Addr),\n-    /// Representation of an IPv6 address.\n+    /// An IPv6 address.\n     #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n     V6(#[stable(feature = \"ip_addr\", since = \"1.7.0\")] Ipv6Addr),\n }\n \n-/// Representation of an IPv4 address.\n+/// An IPv4 address.\n+///\n+/// IPv4 addresses are defined as 32-bit integers in [IETF RFC 791].\n+/// They are usually represented as four octets.\n+///\n+/// See [`IpAddr`] for a type encompassing both IPv4 and IPv6 addresses.\n+///\n+/// [IETF RFC 791]: https://tools.ietf.org/html/rfc791\n+/// [`IpAddr`]: ../../std/net/enum.IpAddr.html\n+///\n+/// # Textual representation\n+///\n+/// `Ipv4Addr` provides a [`FromStr`] implementation. The four octets are in decimal\n+/// notation, divided by `.` (this is called \"dot-decimal notation\").\n+///\n+/// [`FromStr`]: ../../std/str/trait.FromStr.html\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::net::Ipv4Addr;\n+///\n+/// let localhost = Ipv4Addr::new(127, 0, 0, 1);\n+/// assert_eq!(\"127.0.0.1\".parse(), Ok(localhost));\n+/// assert_eq!(localhost.is_loopback(), true);\n+/// ```\n #[derive(Copy)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Ipv4Addr {\n     inner: c::in_addr,\n }\n \n-/// Representation of an IPv6 address.\n+/// An IPv6 address.\n+///\n+/// IPv6 addresses are defined as 128-bit integers in [IETF RFC 4291].\n+/// They are usually represented as eight 16-bit segments.\n+///\n+/// See [`IpAddr`] for a type encompassing both IPv4 and IPv6 addresses.\n+///\n+/// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n+/// [`IpAddr`]: ../../std/net/enum.IpAddr.html\n+///\n+/// # Textual representation\n+///\n+/// `Ipv6Addr` provides a [`FromStr`] implementation. There are many ways to represent\n+/// an IPv6 address in text, but in general, each segments is written in hexadecimal\n+/// notation, and segments are separated by `:`. For more information, see\n+/// [IETF RFC 5952].\n+///\n+/// [`FromStr`]: ../../std/str/trait.FromStr.html\n+/// [IETF RFC 5952]: https://tools.ietf.org/html/rfc5952\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::net::Ipv6Addr;\n+///\n+/// let localhost = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\n+/// assert_eq!(\"::1\".parse(), Ok(localhost));\n+/// assert_eq!(localhost.is_loopback(), true);\n+/// ```\n #[derive(Copy)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Ipv6Addr {\n@@ -78,10 +134,14 @@ pub enum Ipv6MulticastScope {\n }\n \n impl IpAddr {\n-    /// Returns true for the special 'unspecified' address ([IPv4], [IPv6]).\n+    /// Returns [`true`] for the special 'unspecified' address.\n+    ///\n+    /// See the documentation for [`Ipv4Addr::is_unspecified`][IPv4] and\n+    /// [`Ipv6Addr::is_unspecified`][IPv6] for more details.\n     ///\n     /// [IPv4]: ../../std/net/struct.Ipv4Addr.html#method.is_unspecified\n     /// [IPv6]: ../../std/net/struct.Ipv6Addr.html#method.is_unspecified\n+    /// [`true`]: ../../std/primitive.bool.html\n     ///\n     /// # Examples\n     ///\n@@ -99,10 +159,14 @@ impl IpAddr {\n         }\n     }\n \n-    /// Returns true if this is a loopback address ([IPv4], [IPv6]).\n+    /// Returns [`true`] if this is a loopback address.\n+    ///\n+    /// See the documentation for [`Ipv4Addr::is_loopback`][IPv4] and\n+    /// [`Ipv6Addr::is_loopback`][IPv6] for more details.\n     ///\n     /// [IPv4]: ../../std/net/struct.Ipv4Addr.html#method.is_loopback\n     /// [IPv6]: ../../std/net/struct.Ipv6Addr.html#method.is_loopback\n+    /// [`true`]: ../../std/primitive.bool.html\n     ///\n     /// # Examples\n     ///\n@@ -120,10 +184,14 @@ impl IpAddr {\n         }\n     }\n \n-    /// Returns true if the address appears to be globally routable ([IPv4], [IPv6]).\n+    /// Returns [`true`] if the address appears to be globally routable.\n+    ///\n+    /// See the documentation for [`Ipv4Addr::is_global`][IPv4] and\n+    /// [`Ipv6Addr::is_global`][IPv6] for more details.\n     ///\n     /// [IPv4]: ../../std/net/struct.Ipv4Addr.html#method.is_global\n     /// [IPv6]: ../../std/net/struct.Ipv6Addr.html#method.is_global\n+    /// [`true`]: ../../std/primitive.bool.html\n     ///\n     /// # Examples\n     ///\n@@ -145,10 +213,14 @@ impl IpAddr {\n         }\n     }\n \n-    /// Returns true if this is a multicast address ([IPv4], [IPv6]).\n+    /// Returns [`true`] if this is a multicast address.\n+    ///\n+    /// See the documentation for [`Ipv4Addr::is_multicast`][IPv4] and\n+    /// [`Ipv6Addr::is_multicast`][IPv6] for more details.\n     ///\n     /// [IPv4]: ../../std/net/struct.Ipv4Addr.html#method.is_multicast\n     /// [IPv6]: ../../std/net/struct.Ipv6Addr.html#method.is_multicast\n+    /// [`true`]: ../../std/primitive.bool.html\n     ///\n     /// # Examples\n     ///\n@@ -166,10 +238,14 @@ impl IpAddr {\n         }\n     }\n \n-    /// Returns true if this address is in a range designated for documentation ([IPv4], [IPv6]).\n+    /// Returns [`true`] if this address is in a range designated for documentation.\n+    ///\n+    /// See the documentation for [`Ipv4Addr::is_documentation`][IPv4] and\n+    /// [`Ipv6Addr::is_documentation`][IPv6] for more details.\n     ///\n     /// [IPv4]: ../../std/net/struct.Ipv4Addr.html#method.is_documentation\n     /// [IPv6]: ../../std/net/struct.Ipv6Addr.html#method.is_documentation\n+    /// [`true`]: ../../std/primitive.bool.html\n     ///\n     /// # Examples\n     ///\n@@ -191,7 +267,11 @@ impl IpAddr {\n         }\n     }\n \n-    /// Returns true if this address is a valid IPv4 address, false if it's a valid IPv6 address.\n+    /// Returns [`true`] if this address is an [IPv4 address], and [`false`] otherwise.\n+    ///\n+    /// [`true`]: ../../std/primitive.bool.html\n+    /// [`false`]: ../../std/primitive.bool.html\n+    /// [IPv4 address]: #variant.V4\n     ///\n     /// # Examples\n     ///\n@@ -212,7 +292,11 @@ impl IpAddr {\n         }\n     }\n \n-    /// Returns true if this address is a valid IPv6 address, false if it's a valid IPv4 address.\n+    /// Returns [`true`] if this address is an [IPv6 address], and [`false`] otherwise.\n+    ///\n+    /// [`true`]: ../../std/primitive.bool.html\n+    /// [`false`]: ../../std/primitive.bool.html\n+    /// [IPv6 address]: #variant.V6\n     ///\n     /// # Examples\n     ///\n@@ -274,12 +358,13 @@ impl Ipv4Addr {\n         [(bits >> 24) as u8, (bits >> 16) as u8, (bits >> 8) as u8, bits as u8]\n     }\n \n-    /// Returns true for the special 'unspecified' address (0.0.0.0).\n+    /// Returns [`true`] for the special 'unspecified' address (0.0.0.0).\n     ///\n     /// This property is defined in _UNIX Network Programming, Second Edition_,\n     /// W. Richard Stevens, p. 891; see also [ip7].\n     ///\n     /// [ip7]: http://man7.org/linux/man-pages/man7/ip.7.html\n+    /// [`true`]: ../../std/primitive.bool.html\n     ///\n     /// # Examples\n     ///\n@@ -294,11 +379,12 @@ impl Ipv4Addr {\n         self.inner.s_addr == 0\n     }\n \n-    /// Returns true if this is a loopback address (127.0.0.0/8).\n+    /// Returns [`true`] if this is a loopback address (127.0.0.0/8).\n     ///\n-    /// This property is defined by [RFC 1122].\n+    /// This property is defined by [IETF RFC 1122].\n     ///\n-    /// [RFC 1122]: https://tools.ietf.org/html/rfc1122\n+    /// [IETF RFC 1122]: https://tools.ietf.org/html/rfc1122\n+    /// [`true`]: ../../std/primitive.bool.html\n     ///\n     /// # Examples\n     ///\n@@ -313,15 +399,16 @@ impl Ipv4Addr {\n         self.octets()[0] == 127\n     }\n \n-    /// Returns true if this is a private address.\n+    /// Returns [`true`] if this is a private address.\n     ///\n-    /// The private address ranges are defined in [RFC 1918] and include:\n+    /// The private address ranges are defined in [IETF RFC 1918] and include:\n     ///\n     ///  - 10.0.0.0/8\n     ///  - 172.16.0.0/12\n     ///  - 192.168.0.0/16\n     ///\n-    /// [RFC 1918]: https://tools.ietf.org/html/rfc1918\n+    /// [IETF RFC 1918]: https://tools.ietf.org/html/rfc1918\n+    /// [`true`]: ../../std/primitive.bool.html\n     ///\n     /// # Examples\n     ///\n@@ -346,11 +433,12 @@ impl Ipv4Addr {\n         }\n     }\n \n-    /// Returns true if the address is link-local (169.254.0.0/16).\n+    /// Returns [`true`] if the address is link-local (169.254.0.0/16).\n     ///\n-    /// This property is defined by [RFC 3927].\n+    /// This property is defined by [IETF RFC 3927].\n     ///\n-    /// [RFC 3927]: https://tools.ietf.org/html/rfc3927\n+    /// [IETF RFC 3927]: https://tools.ietf.org/html/rfc3927\n+    /// [`true`]: ../../std/primitive.bool.html\n     ///\n     /// # Examples\n     ///\n@@ -366,7 +454,7 @@ impl Ipv4Addr {\n         self.octets()[0] == 169 && self.octets()[1] == 254\n     }\n \n-    /// Returns true if the address appears to be globally routable.\n+    /// Returns [`true`] if the address appears to be globally routable.\n     /// See [iana-ipv4-special-registry][ipv4-sr].\n     ///\n     /// The following return false:\n@@ -379,6 +467,7 @@ impl Ipv4Addr {\n     /// - the unspecified address (0.0.0.0)\n     ///\n     /// [ipv4-sr]: http://goo.gl/RaZ7lg\n+    /// [`true`]: ../../std/primitive.bool.html\n     ///\n     /// # Examples\n     ///\n@@ -400,12 +489,13 @@ impl Ipv4Addr {\n         !self.is_broadcast() && !self.is_documentation() && !self.is_unspecified()\n     }\n \n-    /// Returns true if this is a multicast address (224.0.0.0/4).\n+    /// Returns [`true`] if this is a multicast address (224.0.0.0/4).\n     ///\n     /// Multicast addresses have a most significant octet between 224 and 239,\n-    /// and is defined by [RFC 5771].\n+    /// and is defined by [IETF RFC 5771].\n     ///\n-    /// [RFC 5771]: https://tools.ietf.org/html/rfc5771\n+    /// [IETF RFC 5771]: https://tools.ietf.org/html/rfc5771\n+    /// [`true`]: ../../std/primitive.bool.html\n     ///\n     /// # Examples\n     ///\n@@ -421,11 +511,12 @@ impl Ipv4Addr {\n         self.octets()[0] >= 224 && self.octets()[0] <= 239\n     }\n \n-    /// Returns true if this is a broadcast address (255.255.255.255).\n+    /// Returns [`true`] if this is a broadcast address (255.255.255.255).\n     ///\n-    /// A broadcast address has all octets set to 255 as defined in [RFC 919].\n+    /// A broadcast address has all octets set to 255 as defined in [IETF RFC 919].\n     ///\n-    /// [RFC 919]: https://tools.ietf.org/html/rfc919\n+    /// [IETF RFC 919]: https://tools.ietf.org/html/rfc919\n+    /// [`true`]: ../../std/primitive.bool.html\n     ///\n     /// # Examples\n     ///\n@@ -441,15 +532,16 @@ impl Ipv4Addr {\n         self.octets()[2] == 255 && self.octets()[3] == 255\n     }\n \n-    /// Returns true if this address is in a range designated for documentation.\n+    /// Returns [`true`] if this address is in a range designated for documentation.\n     ///\n-    /// This is defined in [RFC 5737]:\n+    /// This is defined in [IETF RFC 5737]:\n     ///\n     /// - 192.0.2.0/24 (TEST-NET-1)\n     /// - 198.51.100.0/24 (TEST-NET-2)\n     /// - 203.0.113.0/24 (TEST-NET-3)\n     ///\n-    /// [RFC 5737]: https://tools.ietf.org/html/rfc5737\n+    /// [IETF RFC 5737]: https://tools.ietf.org/html/rfc5737\n+    /// [`true`]: ../../std/primitive.bool.html\n     ///\n     /// # Examples\n     ///\n@@ -471,10 +563,12 @@ impl Ipv4Addr {\n         }\n     }\n \n-    /// Converts this address to an IPv4-compatible IPv6 address.\n+    /// Converts this address to an IPv4-compatible [IPv6 address].\n     ///\n     /// a.b.c.d becomes ::a.b.c.d\n     ///\n+    /// [IPv6 address]: ../../std/net/struct.Ipv6Addr.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -490,10 +584,12 @@ impl Ipv4Addr {\n                       ((self.octets()[2] as u16) << 8) | self.octets()[3] as u16)\n     }\n \n-    /// Converts this address to an IPv4-mapped IPv6 address.\n+    /// Converts this address to an IPv4-mapped [IPv6 address].\n     ///\n     /// a.b.c.d becomes ::ffff:a.b.c.d\n     ///\n+    /// [IPv6 address]: ../../std/net/struct.Ipv6Addr.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -717,11 +813,12 @@ impl Ipv6Addr {\n         ]\n     }\n \n-    /// Returns true for the special 'unspecified' address (::).\n+    /// Returns [`true`] for the special 'unspecified' address (::).\n     ///\n-    /// This property is defined in [RFC 4291].\n+    /// This property is defined in [IETF RFC 4291].\n     ///\n-    /// [RFC 4291]: https://tools.ietf.org/html/rfc4291\n+    /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n+    /// [`true`]: ../../std/primitive.bool.html\n     ///\n     /// # Examples\n     ///\n@@ -736,11 +833,12 @@ impl Ipv6Addr {\n         self.segments() == [0, 0, 0, 0, 0, 0, 0, 0]\n     }\n \n-    /// Returns true if this is a loopback address (::1).\n+    /// Returns [`true`] if this is a loopback address (::1).\n     ///\n-    /// This property is defined in [RFC 4291].\n+    /// This property is defined in [IETF RFC 4291].\n     ///\n-    /// [RFC 4291]: https://tools.ietf.org/html/rfc4291\n+    /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n+    /// [`true`]: ../../std/primitive.bool.html\n     ///\n     /// # Examples\n     ///\n@@ -755,14 +853,17 @@ impl Ipv6Addr {\n         self.segments() == [0, 0, 0, 0, 0, 0, 0, 1]\n     }\n \n-    /// Returns true if the address appears to be globally routable.\n+    /// Returns [`true`] if the address appears to be globally routable.\n     ///\n-    /// The following return false:\n+    /// The following return [`false`]:\n     ///\n     /// - the loopback address\n     /// - link-local, site-local, and unique local unicast addresses\n     /// - interface-, link-, realm-, admin- and site-local multicast addresses\n     ///\n+    /// [`true`]: ../../std/primitive.bool.html\n+    /// [`false`]: ../../std/primitive.bool.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -784,11 +885,12 @@ impl Ipv6Addr {\n         }\n     }\n \n-    /// Returns true if this is a unique local address (fc00::/7).\n+    /// Returns [`true`] if this is a unique local address (fc00::/7).\n     ///\n-    /// This property is defined in [RFC 4193].\n+    /// This property is defined in [IETF RFC 4193].\n     ///\n-    /// [RFC 4193]: https://tools.ietf.org/html/rfc4193\n+    /// [IETF RFC 4193]: https://tools.ietf.org/html/rfc4193\n+    /// [`true`]: ../../std/primitive.bool.html\n     ///\n     /// # Examples\n     ///\n@@ -807,11 +909,12 @@ impl Ipv6Addr {\n         (self.segments()[0] & 0xfe00) == 0xfc00\n     }\n \n-    /// Returns true if the address is unicast and link-local (fe80::/10).\n+    /// Returns [`true`] if the address is unicast and link-local (fe80::/10).\n     ///\n-    /// This property is defined in [RFC 4291].\n+    /// This property is defined in [IETF RFC 4291].\n     ///\n-    /// [RFC 4291]: https://tools.ietf.org/html/rfc4291\n+    /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n+    /// [`true`]: ../../std/primitive.bool.html\n     ///\n     /// # Examples\n     ///\n@@ -830,9 +933,11 @@ impl Ipv6Addr {\n         (self.segments()[0] & 0xffc0) == 0xfe80\n     }\n \n-    /// Returns true if this is a deprecated unicast site-local address\n+    /// Returns [`true`] if this is a deprecated unicast site-local address\n     /// (fec0::/10).\n     ///\n+    /// [`true`]: ../../std/primitive.bool.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -850,12 +955,13 @@ impl Ipv6Addr {\n         (self.segments()[0] & 0xffc0) == 0xfec0\n     }\n \n-    /// Returns true if this is an address reserved for documentation\n+    /// Returns [`true`] if this is an address reserved for documentation\n     /// (2001:db8::/32).\n     ///\n-    /// This property is defined in [RFC 3849].\n+    /// This property is defined in [IETF RFC 3849].\n     ///\n-    /// [RFC 3849]: https://tools.ietf.org/html/rfc3849\n+    /// [IETF RFC 3849]: https://tools.ietf.org/html/rfc3849\n+    /// [`true`]: ../../std/primitive.bool.html\n     ///\n     /// # Examples\n     ///\n@@ -874,7 +980,7 @@ impl Ipv6Addr {\n         (self.segments()[0] == 0x2001) && (self.segments()[1] == 0xdb8)\n     }\n \n-    /// Returns true if the address is a globally routable unicast address.\n+    /// Returns [`true`] if the address is a globally routable unicast address.\n     ///\n     /// The following return false:\n     ///\n@@ -885,6 +991,8 @@ impl Ipv6Addr {\n     /// - the unspecified address\n     /// - the address range reserved for documentation\n     ///\n+    /// [`true`]: ../../std/primitive.bool.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -937,11 +1045,13 @@ impl Ipv6Addr {\n         }\n     }\n \n-    /// Returns true if this is a multicast address (ff00::/8).\n+    /// Returns [`true`] if this is a multicast address (ff00::/8).\n+    ///\n+    /// This property is defined by [IETF RFC 4291].\n     ///\n-    /// This property is defined by [RFC 4291].\n+    /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n+    /// [`true`]: ../../std/primitive.bool.html\n     ///\n-    /// [RFC 4291]: https://tools.ietf.org/html/rfc4291\n     /// # Examples\n     ///\n     /// ```\n@@ -955,11 +1065,16 @@ impl Ipv6Addr {\n         (self.segments()[0] & 0xff00) == 0xff00\n     }\n \n-    /// Converts this address to an IPv4 address. Returns None if this address is\n+    /// Converts this address to an [IPv4 address]. Returns [`None`] if this address is\n     /// neither IPv4-compatible or IPv4-mapped.\n     ///\n     /// ::a.b.c.d and ::ffff:a.b.c.d become a.b.c.d\n     ///\n+    /// [IPv4 address]: ../../std/net/struct.Ipv4Addr.html\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n+    /// # Examples\n+    ///\n     /// ```\n     /// use std::net::{Ipv4Addr, Ipv6Addr};\n     ///"}, {"sha": "9fcb93e2032b3ce40489f2cb6d4be9cd103cdb24", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 45, "deletions": 6, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2c59e03de22c33d2382305eec0f951bef4ddcb93/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c59e03de22c33d2382305eec0f951bef4ddcb93/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=2c59e03de22c33d2382305eec0f951bef4ddcb93", "patch": "@@ -9,6 +9,32 @@\n // except according to those terms.\n \n //! Networking primitives for TCP/UDP communication.\n+//!\n+//! This module provides networking functionality for the Transmission Control and User\n+//! Datagram Protocols, as well as types for IP and socket addresses.\n+//!\n+//! # Organization\n+//!\n+//! * [`TcpListener`] and [`TcpStream`] provide functionality for communication over TCP\n+//! * [`UdpSocket`] provides functionality for communication over UDP\n+//! * [`IpAddr`] represents IP addresses of either IPv4 or IPv6; [`Ipv4Addr`] and\n+//!   [`Ipv6Addr`] are respectively IPv4 and IPv6 addresses\n+//! * [`SocketAddr`] represents socket addresses of either IPv4 or IPv6; [`SocketAddrV4`]\n+//!   and [`SocketAddrV6`] are respectively IPv4 and IPv6 socket addresses\n+//! * [`ToSocketAddrs`] is a trait that used for generic address resolution when interacting\n+//!   with networking objects like [`TcpListener`], [`TcpStream`] or [`UdpSocket`]\n+//! * Other types are return or parameter types for various methods in this module\n+//!\n+//! [`IpAddr`]: ../../std/net/enum.IpAddr.html\n+//! [`Ipv4Addr`]: ../../std/net/struct.Ipv4Addr.html\n+//! [`Ipv6Addr`]: ../../std/net/struct.Ipv6Addr.html\n+//! [`SocketAddr`]: ../../std/net/enum.SocketAddr.html\n+//! [`SocketAddrV4`]: ../../std/net/struct.SocketAddrV4.html\n+//! [`SocketAddrV6`]: ../../std/net/struct.SocketAddrV6.html\n+//! [`TcpListener`]: ../../std/net/struct.TcpListener.html\n+//! [`TcpStream`]: ../../std/net/struct.TcpStream.html\n+//! [`ToSocketAddrs`]: ../../std/net/trait.ToSocketAddrs.html\n+//! [`UdpSocket`]: ../../std/net/struct.UdpSocket.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -43,17 +69,30 @@ mod test;\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Shutdown {\n-    /// Indicates that the reading portion of this stream/socket should be shut\n-    /// down. All currently blocked and future reads will return `Ok(0)`.\n+    /// The reading portion of the [`TcpStream`] should be shut down.\n+    ///\n+    /// All currently blocked and future [reads] will return [`Ok(0)`].\n+    ///\n+    /// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n+    /// [reads]: ../../std/io/trait.Read.html\n+    /// [`Ok(0)`]: ../../std/result/enum.Result.html#variant.Ok\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Read,\n-    /// Indicates that the writing portion of this stream/socket should be shut\n-    /// down. All currently blocked and future writes will return an error.\n+    /// The writing portion of the [`TcpStream`] should be shut down.\n+    ///\n+    /// All currently blocked and future [writes] will return an error.\n+    ///\n+    /// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n+    /// [writes]: ../../std/io/trait.Write.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Write,\n-    /// Shut down both the reading and writing portions of this stream.\n+    /// Both the reading and the writing portions of the [`TcpStream`] should be shut down.\n+    ///\n+    /// See [`Shutdown::Read`] and [`Shutdown::Write`] for more information.\n     ///\n-    /// See `Shutdown::Read` and `Shutdown::Write` for more information.\n+    /// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n+    /// [`Shutdown::Read`]: #variant.Read\n+    /// [`Shutdown::Write`]: #variant.Write\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Both,\n }"}, {"sha": "7d7c67ff3f9f767fcc80801af177543767797851", "filename": "src/libstd/net/parser.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2c59e03de22c33d2382305eec0f951bef4ddcb93/src%2Flibstd%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c59e03de22c33d2382305eec0f951bef4ddcb93/src%2Flibstd%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fparser.rs?ref=2c59e03de22c33d2382305eec0f951bef4ddcb93", "patch": "@@ -368,7 +368,19 @@ impl FromStr for SocketAddr {\n     }\n }\n \n-/// An error returned when parsing an IP address or a socket address.\n+/// An error which can be returned when parsing an IP address or a socket address.\n+///\n+/// This error is used as the error type for the [`FromStr`] implementation for\n+/// [`IpAddr`], [`Ipv4Addr`], [`Ipv6Addr`], [`SocketAddr`], [`SocketAddrV4`], and\n+/// [`SocketAddrV6`].\n+///\n+/// [`FromStr`]: ../../std/str/trait.FromStr.html\n+/// [`IpAddr`]: ../../std/net/enum.IpAddr.html\n+/// [`Ipv4Addr`]: ../../std/net/struct.Ipv4Addr.html\n+/// [`Ipv6Addr`]: ../../std/net/struct.Ipv6Addr.html\n+/// [`SocketAddr`]: ../../std/net/enum.SocketAddr.html\n+/// [`SocketAddrV4`]: ../../std/net/struct.SocketAddrV4.html\n+/// [`SocketAddrV6`]: ../../std/net/struct.SocketAddrV6.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct AddrParseError(());"}, {"sha": "cf119720e5a17cc1d3f9ae62cfb772d5c6d49287", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 58, "deletions": 18, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/2c59e03de22c33d2382305eec0f951bef4ddcb93/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c59e03de22c33d2382305eec0f951bef4ddcb93/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=2c59e03de22c33d2382305eec0f951bef4ddcb93", "patch": "@@ -17,10 +17,25 @@ use sys_common::net as net_imp;\n use sys_common::{AsInner, FromInner, IntoInner};\n use time::Duration;\n \n-/// A structure which represents a TCP stream between a local socket and a\n-/// remote socket.\n+/// A TCP stream between a local and a remote socket.\n ///\n-/// The socket will be closed when the value is dropped.\n+/// After creating a `TcpStream` by either [`connect`]ing to a remote host or\n+/// [`accept`]ing a connection on a [`TcpListener`], data can be transmitted\n+/// by [reading] and [writing] to it.\n+///\n+/// The connection will be closed when the value is dropped. The reading and writing\n+/// portions of the connection can also be shut down individually with the [`shutdown`]\n+/// method.\n+///\n+/// The Transmission Control Protocol is specified in [IETF RFC 793].\n+///\n+/// [`accept`]: ../../std/net/struct.TcpListener.html#method.accept\n+/// [`connect`]: #method.connect\n+/// [IETF RFC 793]: https://tools.ietf.org/html/rfc793\n+/// [reading]: ../../std/io/trait.Read.html\n+/// [`shutdown`]: #method.shutdown\n+/// [`TcpListener`]: ../../std/net/struct.TcpListener.html\n+/// [writing]: ../../std/io/trait.Write.html\n ///\n /// # Examples\n ///\n@@ -39,7 +54,21 @@ use time::Duration;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct TcpStream(net_imp::TcpStream);\n \n-/// A structure representing a socket server.\n+/// A TCP socket server, listening for connections.\n+///\n+/// After creating a `TcpListener` by [`bind`]ing it to a socket address, it listens\n+/// for incoming TCP connections. These can be accepted by calling [`accept`] or by\n+/// iterating over the [`Incoming`] iterator returned by [`incoming`].\n+///\n+/// The socket will be closed when the value is dropped.\n+///\n+/// The Transmission Control Protocol is specified in [IETF RFC 793].\n+///\n+/// [`accept`]: #method.accept\n+/// [`bind`]: #method.bind\n+/// [IETF RFC 793]: https://tools.ietf.org/html/rfc793\n+/// [`Incoming`]: ../../std/net/struct.Incoming.html\n+/// [`incoming`]: #method.incoming\n ///\n /// # Examples\n ///\n@@ -65,16 +94,14 @@ pub struct TcpStream(net_imp::TcpStream);\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct TcpListener(net_imp::TcpListener);\n \n-/// An infinite iterator over the connections from a `TcpListener`.\n-///\n-/// This iterator will infinitely yield [`Some`] of the accepted connections. It\n-/// is equivalent to calling `accept` in a loop.\n+/// An iterator that infinitely [`accept`]s connections on a [`TcpListener`].\n ///\n /// This `struct` is created by the [`incoming`] method on [`TcpListener`].\n+/// See its documentation for more.\n ///\n-/// [`Some`]: ../../std/option/enum.Option.html#variant.Some\n-/// [`incoming`]: struct.TcpListener.html#method.incoming\n-/// [`TcpListener`]: struct.TcpListener.html\n+/// [`accept`]: ../../std/net/struct.TcpListener.html#method.accept\n+/// [`incoming`]: ../../std/net/struct.TcpListener.html#method.incoming\n+/// [`TcpListener`]: ../../std/net/struct.TcpListener.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct Incoming<'a> { listener: &'a TcpListener }\n@@ -83,11 +110,15 @@ impl TcpStream {\n     /// Opens a TCP connection to a remote host.\n     ///\n     /// `addr` is an address of the remote host. Anything which implements\n-    /// `ToSocketAddrs` trait can be supplied for the address; see this trait\n+    /// [`ToSocketAddrs`] trait can be supplied for the address; see this trait\n     /// documentation for concrete examples.\n-    /// In case `ToSocketAddrs::to_socket_addrs()` returns more than one entry,\n+    /// In case [`ToSocketAddrs::to_socket_addrs()`] returns more than one entry,\n     /// then the first valid and reachable address is used.\n     ///\n+    /// [`ToSocketAddrs`]: ../../std/net/trait.ToSocketAddrs.html\n+    /// [`ToSocketAddrs::to_socket_addrs()`]:\n+    /// ../../std/net/trait.ToSocketAddrs.html#tymethod.to_socket_addrs\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -494,11 +525,14 @@ impl TcpListener {\n     ///\n     /// Binding with a port number of 0 will request that the OS assigns a port\n     /// to this listener. The port allocated can be queried via the\n-    /// `local_addr` method.\n+    /// [`local_addr`] method.\n     ///\n-    /// The address type can be any implementor of `ToSocketAddrs` trait. See\n+    /// The address type can be any implementor of [`ToSocketAddrs`] trait. See\n     /// its documentation for concrete examples.\n     ///\n+    /// [`local_addr`]: #method.local_addr\n+    /// [`ToSocketAddrs`]: ../../std/net/trait.ToSocketAddrs.html\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -529,10 +563,12 @@ impl TcpListener {\n \n     /// Creates a new independently owned handle to the underlying socket.\n     ///\n-    /// The returned `TcpListener` is a reference to the same socket that this\n+    /// The returned [`TcpListener`] is a reference to the same socket that this\n     /// object references. Both handles can be used to accept incoming\n     /// connections and options set on one listener will affect the other.\n     ///\n+    /// [`TcpListener`]: ../../std/net/struct.TcpListener.html\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -549,9 +585,11 @@ impl TcpListener {\n     /// Accept a new incoming connection from this listener.\n     ///\n     /// This function will block the calling thread until a new TCP connection\n-    /// is established. When established, the corresponding `TcpStream` and the\n+    /// is established. When established, the corresponding [`TcpStream`] and the\n     /// remote peer's address will be returned.\n     ///\n+    /// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -572,10 +610,12 @@ impl TcpListener {\n     /// listener.\n     ///\n     /// The returned iterator will never return [`None`] and will also not yield\n-    /// the peer's [`SocketAddr`] structure.\n+    /// the peer's [`SocketAddr`] structure. Iterating over it is equivalent to\n+    /// calling [`accept`] in a loop.\n     ///\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     /// [`SocketAddr`]: ../../std/net/enum.SocketAddr.html\n+    /// [`accept`]: #method.accept\n     ///\n     /// # Examples\n     ///"}, {"sha": "cdf04f7f1a484bb02f5f257000060fe82d98b7b8", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2c59e03de22c33d2382305eec0f951bef4ddcb93/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c59e03de22c33d2382305eec0f951bef4ddcb93/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=2c59e03de22c33d2382305eec0f951bef4ddcb93", "patch": "@@ -15,11 +15,29 @@ use sys_common::net as net_imp;\n use sys_common::{AsInner, FromInner, IntoInner};\n use time::Duration;\n \n-/// A User Datagram Protocol socket.\n+/// A UDP socket.\n ///\n-/// This is an implementation of a bound UDP socket. This supports both IPv4 and\n-/// IPv6 addresses, and there is no corresponding notion of a server because UDP\n-/// is a datagram protocol.\n+/// After creating a `UdpSocket` by [`bind`]ing it to a socket address, data can be\n+/// [sent to] and [received from] any other socket address.\n+///\n+/// Although UDP is a connectionless protocol, this implementation provides an interface\n+/// to set an address where data should be sent and received from. After setting a remote\n+/// address with [`connect`], data can be sent to and received from that address with\n+/// [`send`] and [`recv`].\n+///\n+/// As stated in the User Datagram Protocol's specification in [IETF RFC 768], UDP is\n+/// an unordered, unreliable protocol; refer to [`TcpListener`] and [`TcpStream`] for TCP\n+/// primitives.\n+///\n+/// [`bind`]: #method.bind\n+/// [`connect`]: #method.connect\n+/// [IETF RFC 768]: https://tools.ietf.org/html/rfc768\n+/// [`recv`]: #method.recv\n+/// [received from]: #method.recv_from\n+/// [`send`]: #method.send\n+/// [sent to]: #method.send_to\n+/// [`TcpListener`]: ../../std/net/struct.TcpListener.html\n+/// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n ///\n /// # Examples\n ///\n@@ -582,9 +600,11 @@ impl UdpSocket {\n     /// Receives data on the socket from the remote address to which it is\n     /// connected.\n     ///\n-    /// The `connect` method will connect this socket to a remote address. This\n+    /// The [`connect`] method will connect this socket to a remote address. This\n     /// method will fail if the socket is not connected.\n     ///\n+    /// [`connect`]: #method.connect\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run"}]}