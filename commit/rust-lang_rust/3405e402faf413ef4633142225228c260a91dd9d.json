{"sha": "3405e402faf413ef4633142225228c260a91dd9d", "node_id": "C_kwDOAAsO6NoAKDM0MDVlNDAyZmFmNDEzZWY0NjMzMTQyMjI1MjI4YzI2MGE5MWRkOWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-31T15:56:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-31T15:56:28Z"}, "message": "Auto merge of #78802 - faern:simplify-socketaddr, r=joshtriplett\n\nImplement network primitives with ideal Rust layout, not C system layout\n\nThis PR is the result of this internals forum thread: https://internals.rust-lang.org/t/why-are-socketaddrv4-socketaddrv6-based-on-low-level-sockaddr-in-6/13321.\n\nInstead of basing `std:::net::{Ipv4Addr, Ipv6Addr, SocketAddrV4, SocketAddrV6}` on system (C) structs, they are encoded in a more optimal and idiomatic Rust way.\n\nThis changes the public API of std by introducing structural equality impls for all four types here, which means that `match ipv4addr { SOME_CONSTANT => ... }` will now compile, whereas previously this was an error. No other intentional changes are introduced to public API.\n\nIt's possible to observe the current layout of these types (e.g., by pointer casting); most but not all libraries which were found by Crater to do this have had updates issued and affected versions yanked. See report below.\n\n### Benefits of this change\n\n- It will become possible to move these fundamental network types from `std` into `core` ([RFC](https://github.com/rust-lang/rfcs/pull/2832)).\n- Some methods that can't be made `const fn`s today can be made `const fn`s with this change.\n- `SocketAddrV4` only occupies 6 bytes instead of 16 bytes.\n- These simple primitives become easier to read and uses less `unsafe`.\n- Makes these types support structural equality, which means you can now (for instance) match an `Ipv4Addr` against a constant\n\n### ~Remaining~ Previous problems\n\nThis change obviously changes the memory layout of the types. And it turns out some libraries invalidly assumes the memory layout and does very dangerous pointer casts to convert them. These libraries will have undefined behaviour and perform invalid memory access until patched.\n\n- [x] - `mio` - Issue: https://github.com/tokio-rs/mio/issues/1386.\n  - [x] `0.7` branch https://github.com/tokio-rs/mio/pull/1388\n  - [x] `0.7.6` published https://github.com/tokio-rs/mio/pull/1398\n  - [x] Yank all `0.7` versions older than `0.7.6`\n  - [x] Report `<0.7.6` to RustSec Advisory Database https://rustsec.org/advisories/RUSTSEC-2020-0081.html\n- [x] - `socket2` - Issue: https://github.com/rust-lang/socket2-rs/issues/119.\n  - [x] `0.3.x` branch https://github.com/rust-lang/socket2-rs/pull/120\n  - [x] `0.3.16` published\n  - [x] `master` branch https://github.com/rust-lang/socket2-rs/pull/122\n  - [x] Yank all `0.3` versions older than `0.3.16`\n  - [x] Report `<0.3.16` to RustSec Advisory Database https://rustsec.org/advisories/RUSTSEC-2020-0079.html\n- [x] - `net2` - Issue: https://github.com/deprecrated/net2-rs/issues/105\n  - [x] https://github.com/deprecrated/net2-rs/pull/106\n  - [x] `0.2.36` published\n  - [x] Yank all `0.2` versions older than `0.2.36`\n  - [x] Report `<0.2.36` to RustSec Advisory Database https://rustsec.org/advisories/RUSTSEC-2020-0078.html\n- [x] - `miow` - Issue: https://github.com/yoshuawuyts/miow/issues/38\n  - [x] `0.3.x` - https://github.com/yoshuawuyts/miow/pull/39\n  - [x] `0.3.6` published\n  - [x] `0.2.x` - https://github.com/yoshuawuyts/miow/pull/40\n  - [x] `0.2.2` published\n  - [x] Yanked all `0.2` versions older than `0.2.2`\n  - [x] Yanked all `0.3` versions older than `0.3.6`\n  - [x] Report `<0.2.2` and `<0.3.6` to RustSec Advisory Database https://rustsec.org/advisories/RUSTSEC-2020-0080.html\n- [x] - `quinn master` (aka what became 0.7) - https://github.com/quinn-rs/quinn/issues/968 https://github.com/quinn-rs/quinn/pull/987\n  - [x] - `quinn 0.6` - https://github.com/quinn-rs/quinn/pull/1045\n  - [x] - `quinn 0.5` - https://github.com/quinn-rs/quinn/pull/1046\n  - [x] - Release `0.7.0`, `0.6.2` and `0.5.4`\n- [x] - `nb-connect` - https://github.com/smol-rs/nb-connect/issues/1\n  - [x] - Release `1.0.3`\n  - [x] - Yank all versions older than `1.0.3`\n- [x] - `shadowsocks-rust` - https://github.com/shadowsocks/shadowsocks-rust/issues/462\n- [ ] - `rio` - https://github.com/spacejam/rio/issues/44\n- [ ] - `seaslug` - https://github.com/spacejam/seaslug/issues/1\n\n#### Fixed crate versions\n\nAll crates I have found that assumed the memory layout have been fixed and published. The crates and versions that will continue working even as/if this PR is merged is (please upgrade these to help unblock this PR):\n\n* `net2 0.2.36`\n* `socket2 0.3.16`\n* `miow 0.2.2`\n* `miow 0.3.6`\n* `mio 0.7.6`\n* `mio 0.6.23` - Never had the invalid assumption itself, but has now been bumped to only allow fixed dependencies (`net2` + `miow`)\n* `nb-connect 1.0.3`\n* `quinn 0.5.4`\n* `quinn 0.6.2`\n\n### Release notes draft\n\nThis release changes the memory layout of `Ipv4Addr`, `Ipv6Addr`, `SocketAddrV4` and `SocketAddrV6`. The standard library no longer implements these as the corresponding `libc` structs (`sockaddr_in`, `sockaddr_in6` etc.). This internal representation was never exposed, but some crates relied on it anyway by unsafely transmuting. This change will cause those crates to make invalid memory accesses. Notably `net2 <0.2.36`, `socket2 <0.3.16`, `mio <0.7.6`, `miow <0.3.6` and a few other crates are affected. All known affected crates have been patched and have had fixed versions published over a year ago. If any affected crate is still in your dependency tree, you need to upgrade them before using this version of Rust.", "tree": {"sha": "1e9eba2e7f7cf89df5021ec2a6050f0357d5c3b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e9eba2e7f7cf89df5021ec2a6050f0357d5c3b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3405e402faf413ef4633142225228c260a91dd9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3405e402faf413ef4633142225228c260a91dd9d", "html_url": "https://github.com/rust-lang/rust/commit/3405e402faf413ef4633142225228c260a91dd9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3405e402faf413ef4633142225228c260a91dd9d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5a7d8f945f4259fb6b8c4953a65248243c054d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5a7d8f945f4259fb6b8c4953a65248243c054d1", "html_url": "https://github.com/rust-lang/rust/commit/e5a7d8f945f4259fb6b8c4953a65248243c054d1"}, {"sha": "73bb371ad3dd401a8f6dca518ad2bbf0bad590e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/73bb371ad3dd401a8f6dca518ad2bbf0bad590e5", "html_url": "https://github.com/rust-lang/rust/commit/73bb371ad3dd401a8f6dca518ad2bbf0bad590e5"}], "stats": {"total": 419, "additions": 172, "deletions": 247}, "files": [{"sha": "53fee952a7a7a76c720c1a481aa6f9d682f435ae", "filename": "library/std/src/net/addr.rs", "status": "modified", "additions": 63, "deletions": 102, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/3405e402faf413ef4633142225228c260a91dd9d/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3405e402faf413ef4633142225228c260a91dd9d/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs?ref=3405e402faf413ef4633142225228c260a91dd9d", "patch": "@@ -7,12 +7,12 @@ use crate::hash;\n use crate::io::{self, Write};\n use crate::iter;\n use crate::mem;\n-use crate::net::{htons, ntohs, IpAddr, Ipv4Addr, Ipv6Addr};\n+use crate::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n use crate::option;\n use crate::slice;\n use crate::sys::net::netc as c;\n use crate::sys_common::net::LookupHost;\n-use crate::sys_common::{AsInner, FromInner, IntoInner};\n+use crate::sys_common::{FromInner, IntoInner};\n use crate::vec;\n \n /// An internet socket address, either IPv4 or IPv6.\n@@ -73,12 +73,11 @@ pub enum SocketAddr {\n /// assert_eq!(socket.ip(), &Ipv4Addr::new(127, 0, 0, 1));\n /// assert_eq!(socket.port(), 8080);\n /// ```\n-#[derive(Copy)]\n+#[derive(Copy, Clone, Eq, PartialEq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SocketAddrV4 {\n-    // Do not assume that this struct is implemented as the underlying system representation.\n-    // The memory layout is not part of the stable interface that std exposes.\n-    inner: c::sockaddr_in,\n+    ip: Ipv4Addr,\n+    port: u16,\n }\n \n /// An IPv6 socket address.\n@@ -107,12 +106,13 @@ pub struct SocketAddrV4 {\n /// assert_eq!(socket.ip(), &Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1));\n /// assert_eq!(socket.port(), 8080);\n /// ```\n-#[derive(Copy)]\n+#[derive(Copy, Clone, Eq, PartialEq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SocketAddrV6 {\n-    // Do not assume that this struct is implemented as the underlying system representation.\n-    // The memory layout is not part of the stable interface that std exposes.\n-    inner: c::sockaddr_in6,\n+    ip: Ipv6Addr,\n+    port: u16,\n+    flowinfo: u32,\n+    scope_id: u32,\n }\n \n impl SocketAddr {\n@@ -131,7 +131,8 @@ impl SocketAddr {\n     /// ```\n     #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n     #[must_use]\n-    pub fn new(ip: IpAddr, port: u16) -> SocketAddr {\n+    #[rustc_const_unstable(feature = \"const_socketaddr\", issue = \"82485\")]\n+    pub const fn new(ip: IpAddr, port: u16) -> SocketAddr {\n         match ip {\n             IpAddr::V4(a) => SocketAddr::V4(SocketAddrV4::new(a, port)),\n             IpAddr::V6(a) => SocketAddr::V6(SocketAddrV6::new(a, port, 0, 0)),\n@@ -277,15 +278,9 @@ impl SocketAddrV4 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use]\n-    pub fn new(ip: Ipv4Addr, port: u16) -> SocketAddrV4 {\n-        SocketAddrV4 {\n-            inner: c::sockaddr_in {\n-                sin_family: c::AF_INET as c::sa_family_t,\n-                sin_port: htons(port),\n-                sin_addr: ip.into_inner(),\n-                ..unsafe { mem::zeroed() }\n-            },\n-        }\n+    #[rustc_const_unstable(feature = \"const_socketaddr\", issue = \"82485\")]\n+    pub const fn new(ip: Ipv4Addr, port: u16) -> SocketAddrV4 {\n+        SocketAddrV4 { ip, port }\n     }\n \n     /// Returns the IP address associated with this socket address.\n@@ -302,9 +297,7 @@ impl SocketAddrV4 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature = \"const_socketaddr\", issue = \"82485\")]\n     pub const fn ip(&self) -> &Ipv4Addr {\n-        // SAFETY: `Ipv4Addr` is `#[repr(C)] struct { _: in_addr; }`.\n-        // It is safe to cast from `&in_addr` to `&Ipv4Addr`.\n-        unsafe { &*(&self.inner.sin_addr as *const c::in_addr as *const Ipv4Addr) }\n+        &self.ip\n     }\n \n     /// Changes the IP address associated with this socket address.\n@@ -320,7 +313,7 @@ impl SocketAddrV4 {\n     /// ```\n     #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n     pub fn set_ip(&mut self, new_ip: Ipv4Addr) {\n-        self.inner.sin_addr = new_ip.into_inner()\n+        self.ip = new_ip;\n     }\n \n     /// Returns the port number associated with this socket address.\n@@ -337,7 +330,7 @@ impl SocketAddrV4 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature = \"const_socketaddr\", issue = \"82485\")]\n     pub const fn port(&self) -> u16 {\n-        ntohs(self.inner.sin_port)\n+        self.port\n     }\n \n     /// Changes the port number associated with this socket address.\n@@ -353,7 +346,7 @@ impl SocketAddrV4 {\n     /// ```\n     #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n     pub fn set_port(&mut self, new_port: u16) {\n-        self.inner.sin_port = htons(new_port);\n+        self.port = new_port;\n     }\n }\n \n@@ -376,17 +369,9 @@ impl SocketAddrV6 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use]\n-    pub fn new(ip: Ipv6Addr, port: u16, flowinfo: u32, scope_id: u32) -> SocketAddrV6 {\n-        SocketAddrV6 {\n-            inner: c::sockaddr_in6 {\n-                sin6_family: c::AF_INET6 as c::sa_family_t,\n-                sin6_port: htons(port),\n-                sin6_addr: *ip.as_inner(),\n-                sin6_flowinfo: flowinfo,\n-                sin6_scope_id: scope_id,\n-                ..unsafe { mem::zeroed() }\n-            },\n-        }\n+    #[rustc_const_unstable(feature = \"const_socketaddr\", issue = \"82485\")]\n+    pub const fn new(ip: Ipv6Addr, port: u16, flowinfo: u32, scope_id: u32) -> SocketAddrV6 {\n+        SocketAddrV6 { ip, port, flowinfo, scope_id }\n     }\n \n     /// Returns the IP address associated with this socket address.\n@@ -403,7 +388,7 @@ impl SocketAddrV6 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature = \"const_socketaddr\", issue = \"82485\")]\n     pub const fn ip(&self) -> &Ipv6Addr {\n-        unsafe { &*(&self.inner.sin6_addr as *const c::in6_addr as *const Ipv6Addr) }\n+        &self.ip\n     }\n \n     /// Changes the IP address associated with this socket address.\n@@ -419,7 +404,7 @@ impl SocketAddrV6 {\n     /// ```\n     #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n     pub fn set_ip(&mut self, new_ip: Ipv6Addr) {\n-        self.inner.sin6_addr = *new_ip.as_inner()\n+        self.ip = new_ip;\n     }\n \n     /// Returns the port number associated with this socket address.\n@@ -436,7 +421,7 @@ impl SocketAddrV6 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature = \"const_socketaddr\", issue = \"82485\")]\n     pub const fn port(&self) -> u16 {\n-        ntohs(self.inner.sin6_port)\n+        self.port\n     }\n \n     /// Changes the port number associated with this socket address.\n@@ -452,7 +437,7 @@ impl SocketAddrV6 {\n     /// ```\n     #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n     pub fn set_port(&mut self, new_port: u16) {\n-        self.inner.sin6_port = htons(new_port);\n+        self.port = new_port;\n     }\n \n     /// Returns the flow information associated with this address.\n@@ -479,7 +464,7 @@ impl SocketAddrV6 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature = \"const_socketaddr\", issue = \"82485\")]\n     pub const fn flowinfo(&self) -> u32 {\n-        self.inner.sin6_flowinfo\n+        self.flowinfo\n     }\n \n     /// Changes the flow information associated with this socket address.\n@@ -497,7 +482,7 @@ impl SocketAddrV6 {\n     /// ```\n     #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n     pub fn set_flowinfo(&mut self, new_flowinfo: u32) {\n-        self.inner.sin6_flowinfo = new_flowinfo;\n+        self.flowinfo = new_flowinfo;\n     }\n \n     /// Returns the scope ID associated with this address.\n@@ -519,7 +504,7 @@ impl SocketAddrV6 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature = \"const_socketaddr\", issue = \"82485\")]\n     pub const fn scope_id(&self) -> u32 {\n-        self.inner.sin6_scope_id\n+        self.scope_id\n     }\n \n     /// Changes the scope ID associated with this socket address.\n@@ -537,19 +522,48 @@ impl SocketAddrV6 {\n     /// ```\n     #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n     pub fn set_scope_id(&mut self, new_scope_id: u32) {\n-        self.inner.sin6_scope_id = new_scope_id;\n+        self.scope_id = new_scope_id;\n     }\n }\n \n impl FromInner<c::sockaddr_in> for SocketAddrV4 {\n     fn from_inner(addr: c::sockaddr_in) -> SocketAddrV4 {\n-        SocketAddrV4 { inner: addr }\n+        SocketAddrV4 { ip: Ipv4Addr::from_inner(addr.sin_addr), port: u16::from_be(addr.sin_port) }\n     }\n }\n \n impl FromInner<c::sockaddr_in6> for SocketAddrV6 {\n     fn from_inner(addr: c::sockaddr_in6) -> SocketAddrV6 {\n-        SocketAddrV6 { inner: addr }\n+        SocketAddrV6 {\n+            ip: Ipv6Addr::from_inner(addr.sin6_addr),\n+            port: u16::from_be(addr.sin6_port),\n+            flowinfo: addr.sin6_flowinfo,\n+            scope_id: addr.sin6_scope_id,\n+        }\n+    }\n+}\n+\n+impl IntoInner<c::sockaddr_in> for SocketAddrV4 {\n+    fn into_inner(self) -> c::sockaddr_in {\n+        c::sockaddr_in {\n+            sin_family: c::AF_INET as c::sa_family_t,\n+            sin_port: self.port.to_be(),\n+            sin_addr: self.ip.into_inner(),\n+            ..unsafe { mem::zeroed() }\n+        }\n+    }\n+}\n+\n+impl IntoInner<c::sockaddr_in6> for SocketAddrV6 {\n+    fn into_inner(self) -> c::sockaddr_in6 {\n+        c::sockaddr_in6 {\n+            sin6_family: c::AF_INET6 as c::sa_family_t,\n+            sin6_port: self.port.to_be(),\n+            sin6_addr: self.ip.into_inner(),\n+            sin6_flowinfo: self.flowinfo,\n+            sin6_scope_id: self.scope_id,\n+            ..unsafe { mem::zeroed() }\n+        }\n     }\n }\n \n@@ -582,19 +596,6 @@ impl<I: Into<IpAddr>> From<(I, u16)> for SocketAddr {\n     }\n }\n \n-impl<'a> IntoInner<(*const c::sockaddr, c::socklen_t)> for &'a SocketAddr {\n-    fn into_inner(self) -> (*const c::sockaddr, c::socklen_t) {\n-        match *self {\n-            SocketAddr::V4(ref a) => {\n-                (a as *const _ as *const _, mem::size_of_val(a) as c::socklen_t)\n-            }\n-            SocketAddr::V6(ref a) => {\n-                (a as *const _ as *const _, mem::size_of_val(a) as c::socklen_t)\n-            }\n-        }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for SocketAddr {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -688,40 +689,6 @@ impl fmt::Debug for SocketAddrV6 {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Clone for SocketAddrV4 {\n-    fn clone(&self) -> SocketAddrV4 {\n-        *self\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Clone for SocketAddrV6 {\n-    fn clone(&self) -> SocketAddrV6 {\n-        *self\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl PartialEq for SocketAddrV4 {\n-    fn eq(&self, other: &SocketAddrV4) -> bool {\n-        self.inner.sin_port == other.inner.sin_port\n-            && self.inner.sin_addr.s_addr == other.inner.sin_addr.s_addr\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl PartialEq for SocketAddrV6 {\n-    fn eq(&self, other: &SocketAddrV6) -> bool {\n-        self.inner.sin6_port == other.inner.sin6_port\n-            && self.inner.sin6_addr.s6_addr == other.inner.sin6_addr.s6_addr\n-            && self.inner.sin6_flowinfo == other.inner.sin6_flowinfo\n-            && self.inner.sin6_scope_id == other.inner.sin6_scope_id\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Eq for SocketAddrV4 {}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Eq for SocketAddrV6 {}\n-\n #[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n impl PartialOrd for SocketAddrV4 {\n     fn partial_cmp(&self, other: &SocketAddrV4) -> Option<Ordering> {\n@@ -753,19 +720,13 @@ impl Ord for SocketAddrV6 {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl hash::Hash for SocketAddrV4 {\n     fn hash<H: hash::Hasher>(&self, s: &mut H) {\n-        (self.inner.sin_port, self.inner.sin_addr.s_addr).hash(s)\n+        (self.port, self.ip).hash(s)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl hash::Hash for SocketAddrV6 {\n     fn hash<H: hash::Hasher>(&self, s: &mut H) {\n-        (\n-            self.inner.sin6_port,\n-            &self.inner.sin6_addr.s6_addr,\n-            self.inner.sin6_flowinfo,\n-            self.inner.sin6_scope_id,\n-        )\n-            .hash(s)\n+        (self.port, &self.ip, self.flowinfo, self.scope_id).hash(s)\n     }\n }\n "}, {"sha": "41ca9ba842588f82f29d7d01bc8ee548b3fbcb2e", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 34, "deletions": 113, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/3405e402faf413ef4633142225228c260a91dd9d/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3405e402faf413ef4633142225228c260a91dd9d/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=3405e402faf413ef4633142225228c260a91dd9d", "patch": "@@ -4,20 +4,16 @@ mod tests;\n \n use crate::cmp::Ordering;\n use crate::fmt::{self, Write as FmtWrite};\n-use crate::hash;\n use crate::io::Write as IoWrite;\n use crate::mem::transmute;\n use crate::sys::net::netc as c;\n-use crate::sys_common::{AsInner, FromInner, IntoInner};\n+use crate::sys_common::{FromInner, IntoInner};\n \n /// An IP address, either IPv4 or IPv6.\n ///\n /// This enum can contain either an [`Ipv4Addr`] or an [`Ipv6Addr`], see their\n /// respective documentation for more details.\n ///\n-/// The size of an `IpAddr` instance may vary depending on the target operating\n-/// system.\n-///\n /// # Examples\n ///\n /// ```\n@@ -50,9 +46,6 @@ pub enum IpAddr {\n ///\n /// See [`IpAddr`] for a type encompassing both IPv4 and IPv6 addresses.\n ///\n-/// The size of an `Ipv4Addr` struct may vary depending on the target operating\n-/// system.\n-///\n /// [IETF RFC 791]: https://tools.ietf.org/html/rfc791\n ///\n /// # Textual representation\n@@ -77,20 +70,17 @@ pub enum IpAddr {\n /// assert!(\"0000000.0.0.0\".parse::<Ipv4Addr>().is_err()); // first octet is a zero in octal\n /// assert!(\"0xcb.0x0.0x71.0x00\".parse::<Ipv4Addr>().is_err()); // all octets are in hex\n /// ```\n-#[derive(Copy)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Ipv4Addr {\n-    inner: c::in_addr,\n+    octets: [u8; 4],\n }\n \n /// An IPv6 address.\n ///\n /// IPv6 addresses are defined as 128-bit integers in [IETF RFC 4291].\n /// They are usually represented as eight 16-bit segments.\n ///\n-/// The size of an `Ipv6Addr` struct may vary depending on the target operating\n-/// system.\n-///\n /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n ///\n /// # Embedding IPv4 Addresses\n@@ -162,10 +152,10 @@ pub struct Ipv4Addr {\n /// assert_eq!(\"::1\".parse(), Ok(localhost));\n /// assert_eq!(localhost.is_loopback(), true);\n /// ```\n-#[derive(Copy)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Ipv6Addr {\n-    inner: c::in6_addr,\n+    octets: [u8; 16],\n }\n \n /// Scope of an [IPv6 multicast address] as defined in [IETF RFC 7346 section 2].\n@@ -461,9 +451,7 @@ impl Ipv4Addr {\n     #[must_use]\n     #[inline]\n     pub const fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {\n-        // `s_addr` is stored as BE on all machine and the array is in BE order.\n-        // So the native endian conversion method is used so that it's never swapped.\n-        Ipv4Addr { inner: c::in_addr { s_addr: u32::from_ne_bytes([a, b, c, d]) } }\n+        Ipv4Addr { octets: [a, b, c, d] }\n     }\n \n     /// An IPv4 address with the address pointing to localhost: `127.0.0.1`\n@@ -523,8 +511,7 @@ impl Ipv4Addr {\n     #[must_use]\n     #[inline]\n     pub const fn octets(&self) -> [u8; 4] {\n-        // This returns the order we want because s_addr is stored in big-endian.\n-        self.inner.s_addr.to_ne_bytes()\n+        self.octets\n     }\n \n     /// Returns [`true`] for the special 'unspecified' address (`0.0.0.0`).\n@@ -547,7 +534,7 @@ impl Ipv4Addr {\n     #[must_use]\n     #[inline]\n     pub const fn is_unspecified(&self) -> bool {\n-        self.inner.s_addr == 0\n+        u32::from_be_bytes(self.octets) == 0\n     }\n \n     /// Returns [`true`] if this is a loopback address (`127.0.0.0/8`).\n@@ -910,9 +897,7 @@ impl Ipv4Addr {\n     #[inline]\n     pub const fn to_ipv6_compatible(&self) -> Ipv6Addr {\n         let [a, b, c, d] = self.octets();\n-        Ipv6Addr {\n-            inner: c::in6_addr { s6_addr: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, a, b, c, d] },\n-        }\n+        Ipv6Addr { octets: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, a, b, c, d] }\n     }\n \n     /// Converts this address to an [IPv4-mapped] [`IPv6` address].\n@@ -937,9 +922,7 @@ impl Ipv4Addr {\n     #[inline]\n     pub const fn to_ipv6_mapped(&self) -> Ipv6Addr {\n         let [a, b, c, d] = self.octets();\n-        Ipv6Addr {\n-            inner: c::in6_addr { s6_addr: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, a, b, c, d] },\n-        }\n+        Ipv6Addr { octets: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, a, b, c, d] }\n     }\n }\n \n@@ -1034,22 +1017,6 @@ impl fmt::Debug for Ipv4Addr {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Clone for Ipv4Addr {\n-    #[inline]\n-    fn clone(&self) -> Ipv4Addr {\n-        *self\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl PartialEq for Ipv4Addr {\n-    #[inline]\n-    fn eq(&self, other: &Ipv4Addr) -> bool {\n-        self.inner.s_addr == other.inner.s_addr\n-    }\n-}\n-\n #[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n impl PartialEq<Ipv4Addr> for IpAddr {\n     #[inline]\n@@ -1072,21 +1039,6 @@ impl PartialEq<IpAddr> for Ipv4Addr {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Eq for Ipv4Addr {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl hash::Hash for Ipv4Addr {\n-    #[inline]\n-    fn hash<H: hash::Hasher>(&self, s: &mut H) {\n-        // NOTE:\n-        // * hash in big endian order\n-        // * in netbsd, `in_addr` has `repr(packed)`, we need to\n-        //   copy `s_addr` to avoid unsafe borrowing\n-        { self.inner.s_addr }.hash(s)\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialOrd for Ipv4Addr {\n     #[inline]\n@@ -1121,15 +1073,21 @@ impl PartialOrd<IpAddr> for Ipv4Addr {\n impl Ord for Ipv4Addr {\n     #[inline]\n     fn cmp(&self, other: &Ipv4Addr) -> Ordering {\n-        // Compare as native endian\n-        u32::from_be(self.inner.s_addr).cmp(&u32::from_be(other.inner.s_addr))\n+        self.octets.cmp(&other.octets)\n     }\n }\n \n impl IntoInner<c::in_addr> for Ipv4Addr {\n     #[inline]\n     fn into_inner(self) -> c::in_addr {\n-        self.inner\n+        // `s_addr` is stored as BE on all machines and the array is in BE order.\n+        // So the native endian conversion method is used so that it's never swapped.\n+        c::in_addr { s_addr: u32::from_ne_bytes(self.octets) }\n+    }\n+}\n+impl FromInner<c::in_addr> for Ipv4Addr {\n+    fn from_inner(addr: c::in_addr) -> Ipv4Addr {\n+        Ipv4Addr { octets: addr.s_addr.to_ne_bytes() }\n     }\n }\n \n@@ -1147,8 +1105,7 @@ impl From<Ipv4Addr> for u32 {\n     /// ```\n     #[inline]\n     fn from(ip: Ipv4Addr) -> u32 {\n-        let ip = ip.octets();\n-        u32::from_be_bytes(ip)\n+        u32::from_be_bytes(ip.octets)\n     }\n }\n \n@@ -1166,7 +1123,7 @@ impl From<u32> for Ipv4Addr {\n     /// ```\n     #[inline]\n     fn from(ip: u32) -> Ipv4Addr {\n-        Ipv4Addr::from(ip.to_be_bytes())\n+        Ipv4Addr { octets: ip.to_be_bytes() }\n     }\n }\n \n@@ -1184,7 +1141,7 @@ impl From<[u8; 4]> for Ipv4Addr {\n     /// ```\n     #[inline]\n     fn from(octets: [u8; 4]) -> Ipv4Addr {\n-        Ipv4Addr::new(octets[0], octets[1], octets[2], octets[3])\n+        Ipv4Addr { octets }\n     }\n }\n \n@@ -1234,13 +1191,9 @@ impl Ipv6Addr {\n             h.to_be(),\n         ];\n         Ipv6Addr {\n-            inner: c::in6_addr {\n-                // All elements in `addr16` are big endian.\n-                // SAFETY: `[u16; 8]` is always safe to transmute to `[u8; 16]`.\n-                // rustc_allow_const_fn_unstable: the transmute could be written as stable const\n-                // code, but that leads to worse code generation (#75085)\n-                s6_addr: unsafe { transmute::<_, [u8; 16]>(addr16) },\n-            },\n+            // All elements in `addr16` are big endian.\n+            // SAFETY: `[u16; 8]` is always safe to transmute to `[u8; 16]`.\n+            octets: unsafe { transmute::<_, [u8; 16]>(addr16) },\n         }\n     }\n \n@@ -1285,11 +1238,9 @@ impl Ipv6Addr {\n     #[must_use]\n     #[inline]\n     pub const fn segments(&self) -> [u16; 8] {\n-        // All elements in `s6_addr` must be big endian.\n+        // All elements in `self.octets` must be big endian.\n         // SAFETY: `[u8; 16]` is always safe to transmute to `[u16; 8]`.\n-        // rustc_allow_const_fn_unstable: the transmute could be written as stable const code, but\n-        // that leads to worse code generation (#75085)\n-        let [a, b, c, d, e, f, g, h] = unsafe { transmute::<_, [u16; 8]>(self.inner.s6_addr) };\n+        let [a, b, c, d, e, f, g, h] = unsafe { transmute::<_, [u16; 8]>(self.octets) };\n         // We want native endian u16\n         [\n             u16::from_be(a),\n@@ -1748,7 +1699,7 @@ impl Ipv6Addr {\n     #[must_use]\n     #[inline]\n     pub const fn octets(&self) -> [u8; 16] {\n-        self.inner.s6_addr\n+        self.octets\n     }\n }\n \n@@ -1856,22 +1807,6 @@ impl fmt::Debug for Ipv6Addr {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Clone for Ipv6Addr {\n-    #[inline]\n-    fn clone(&self) -> Ipv6Addr {\n-        *self\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl PartialEq for Ipv6Addr {\n-    #[inline]\n-    fn eq(&self, other: &Ipv6Addr) -> bool {\n-        self.inner.s6_addr == other.inner.s6_addr\n-    }\n-}\n-\n #[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n impl PartialEq<IpAddr> for Ipv6Addr {\n     #[inline]\n@@ -1894,17 +1829,6 @@ impl PartialEq<Ipv6Addr> for IpAddr {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Eq for Ipv6Addr {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl hash::Hash for Ipv6Addr {\n-    #[inline]\n-    fn hash<H: hash::Hasher>(&self, s: &mut H) {\n-        self.inner.s6_addr.hash(s)\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialOrd for Ipv6Addr {\n     #[inline]\n@@ -1943,16 +1867,15 @@ impl Ord for Ipv6Addr {\n     }\n }\n \n-impl AsInner<c::in6_addr> for Ipv6Addr {\n-    #[inline]\n-    fn as_inner(&self) -> &c::in6_addr {\n-        &self.inner\n+impl IntoInner<c::in6_addr> for Ipv6Addr {\n+    fn into_inner(self) -> c::in6_addr {\n+        c::in6_addr { s6_addr: self.octets }\n     }\n }\n impl FromInner<c::in6_addr> for Ipv6Addr {\n     #[inline]\n     fn from_inner(addr: c::in6_addr) -> Ipv6Addr {\n-        Ipv6Addr { inner: addr }\n+        Ipv6Addr { octets: addr.s6_addr }\n     }\n }\n \n@@ -1973,8 +1896,7 @@ impl From<Ipv6Addr> for u128 {\n     /// ```\n     #[inline]\n     fn from(ip: Ipv6Addr) -> u128 {\n-        let ip = ip.octets();\n-        u128::from_be_bytes(ip)\n+        u128::from_be_bytes(ip.octets)\n     }\n }\n #[stable(feature = \"i128\", since = \"1.26.0\")]\n@@ -2025,8 +1947,7 @@ impl From<[u8; 16]> for Ipv6Addr {\n     /// ```\n     #[inline]\n     fn from(octets: [u8; 16]) -> Ipv6Addr {\n-        let inner = c::in6_addr { s6_addr: octets };\n-        Ipv6Addr::from_inner(inner)\n+        Ipv6Addr { octets }\n     }\n }\n "}, {"sha": "c29509331d7a9eaa13fdad6e9c85463bdd22c8f2", "filename": "library/std/src/net/ip/tests.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3405e402faf413ef4633142225228c260a91dd9d/library%2Fstd%2Fsrc%2Fnet%2Fip%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3405e402faf413ef4633142225228c260a91dd9d/library%2Fstd%2Fsrc%2Fnet%2Fip%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip%2Ftests.rs?ref=3405e402faf413ef4633142225228c260a91dd9d", "patch": "@@ -944,3 +944,26 @@ fn ip_const() {\n     const IS_IP_V6: bool = IP_ADDRESS.is_ipv6();\n     assert!(!IS_IP_V6);\n }\n+\n+#[test]\n+fn structural_match() {\n+    // test that all IP types can be structurally matched upon\n+\n+    const IPV4: Ipv4Addr = Ipv4Addr::LOCALHOST;\n+    match IPV4 {\n+        Ipv4Addr::LOCALHOST => {}\n+        _ => unreachable!(),\n+    }\n+\n+    const IPV6: Ipv6Addr = Ipv6Addr::LOCALHOST;\n+    match IPV6 {\n+        Ipv6Addr::LOCALHOST => {}\n+        _ => unreachable!(),\n+    }\n+\n+    const IP: IpAddr = IpAddr::V4(Ipv4Addr::LOCALHOST);\n+    match IP {\n+        IpAddr::V4(Ipv4Addr::LOCALHOST) => {}\n+        _ => unreachable!(),\n+    }\n+}"}, {"sha": "e7a40bdaf8e9989e66f225cc94fb4aaedda403f8", "filename": "library/std/src/net/mod.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3405e402faf413ef4633142225228c260a91dd9d/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3405e402faf413ef4633142225228c260a91dd9d/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs?ref=3405e402faf413ef4633142225228c260a91dd9d", "patch": "@@ -69,15 +69,6 @@ pub enum Shutdown {\n     Both,\n }\n \n-#[inline]\n-const fn htons(i: u16) -> u16 {\n-    i.to_be()\n-}\n-#[inline]\n-const fn ntohs(i: u16) -> u16 {\n-    u16::from_be(i)\n-}\n-\n fn each_addr<A: ToSocketAddrs, F, T>(addr: A, mut f: F) -> io::Result<T>\n where\n     F: FnMut(io::Result<&SocketAddr>) -> io::Result<T>,"}, {"sha": "4c4cd7d1d1d86e13fbfb352b474c684aed279263", "filename": "library/std/src/sys/sgx/net.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3405e402faf413ef4633142225228c260a91dd9d/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3405e402faf413ef4633142225228c260a91dd9d/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fnet.rs?ref=3405e402faf413ef4633142225228c260a91dd9d", "patch": "@@ -538,6 +538,4 @@ pub mod netc {\n \n     #[derive(Copy, Clone)]\n     pub struct sockaddr {}\n-\n-    pub type socklen_t = usize;\n }"}, {"sha": "462a45b01ab49b2c99cae5d3184407599df970e1", "filename": "library/std/src/sys/unix/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3405e402faf413ef4633142225228c260a91dd9d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3405e402faf413ef4633142225228c260a91dd9d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs?ref=3405e402faf413ef4633142225228c260a91dd9d", "patch": "@@ -139,8 +139,8 @@ impl Socket {\n     pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {\n         self.set_nonblocking(true)?;\n         let r = unsafe {\n-            let (addrp, len) = addr.into_inner();\n-            cvt(libc::connect(self.as_raw_fd(), addrp, len))\n+            let (addr, len) = addr.into_inner();\n+            cvt(libc::connect(self.as_raw_fd(), addr.as_ptr(), len))\n         };\n         self.set_nonblocking(false)?;\n "}, {"sha": "a5204a0845378d6ae65633d16f4aadf50643a066", "filename": "library/std/src/sys/unsupported/net.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3405e402faf413ef4633142225228c260a91dd9d/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3405e402faf413ef4633142225228c260a91dd9d/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fnet.rs?ref=3405e402faf413ef4633142225228c260a91dd9d", "patch": "@@ -363,6 +363,4 @@ pub mod netc {\n \n     #[derive(Copy, Clone)]\n     pub struct sockaddr {}\n-\n-    pub type socklen_t = usize;\n }"}, {"sha": "590d268c38087f51db6eb3562e50a1f7450e60cf", "filename": "library/std/src/sys/wasi/net.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3405e402faf413ef4633142225228c260a91dd9d/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3405e402faf413ef4633142225228c260a91dd9d/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fnet.rs?ref=3405e402faf413ef4633142225228c260a91dd9d", "patch": "@@ -524,6 +524,4 @@ pub mod netc {\n \n     #[derive(Copy, Clone)]\n     pub struct sockaddr {}\n-\n-    pub type socklen_t = usize;\n }"}, {"sha": "e0701a498fad749ba2dafec3c15aabc2970c22b8", "filename": "library/std/src/sys/windows/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3405e402faf413ef4633142225228c260a91dd9d/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3405e402faf413ef4633142225228c260a91dd9d/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs?ref=3405e402faf413ef4633142225228c260a91dd9d", "patch": "@@ -143,8 +143,8 @@ impl Socket {\n     pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {\n         self.set_nonblocking(true)?;\n         let result = {\n-            let (addrp, len) = addr.into_inner();\n-            let result = unsafe { c::connect(self.as_raw_socket(), addrp, len) };\n+            let (addr, len) = addr.into_inner();\n+            let result = unsafe { c::connect(self.as_raw_socket(), addr.as_ptr(), len) };\n             cvt(result).map(drop)\n         };\n         self.set_nonblocking(false)?;"}, {"sha": "33d336c4317b7ac0e40599a3007ecde124fec091", "filename": "library/std/src/sys_common/net.rs", "status": "modified", "additions": 48, "deletions": 13, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3405e402faf413ef4633142225228c260a91dd9d/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3405e402faf413ef4633142225228c260a91dd9d/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs?ref=3405e402faf413ef4633142225228c260a91dd9d", "patch": "@@ -10,7 +10,7 @@ use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n use crate::ptr;\n use crate::sys::net::netc as c;\n use crate::sys::net::{cvt, cvt_gai, cvt_r, init, wrlen_t, Socket};\n-use crate::sys_common::{AsInner, FromInner, IntoInner};\n+use crate::sys_common::{FromInner, IntoInner};\n use crate::time::Duration;\n \n use libc::{c_int, c_void};\n@@ -224,8 +224,8 @@ impl TcpStream {\n \n         let sock = Socket::new(addr, c::SOCK_STREAM)?;\n \n-        let (addrp, len) = addr.into_inner();\n-        cvt_r(|| unsafe { c::connect(sock.as_raw(), addrp, len) })?;\n+        let (addr, len) = addr.into_inner();\n+        cvt_r(|| unsafe { c::connect(sock.as_raw(), addr.as_ptr(), len) })?;\n         Ok(TcpStream { inner: sock })\n     }\n \n@@ -395,8 +395,8 @@ impl TcpListener {\n         setsockopt(&sock, c::SOL_SOCKET, c::SO_REUSEADDR, 1 as c_int)?;\n \n         // Bind our new socket\n-        let (addrp, len) = addr.into_inner();\n-        cvt(unsafe { c::bind(sock.as_raw(), addrp, len as _) })?;\n+        let (addr, len) = addr.into_inner();\n+        cvt(unsafe { c::bind(sock.as_raw(), addr.as_ptr(), len as _) })?;\n \n         cfg_if::cfg_if! {\n             if #[cfg(target_os = \"horizon\")] {\n@@ -500,8 +500,8 @@ impl UdpSocket {\n         init();\n \n         let sock = Socket::new(addr, c::SOCK_DGRAM)?;\n-        let (addrp, len) = addr.into_inner();\n-        cvt(unsafe { c::bind(sock.as_raw(), addrp, len as _) })?;\n+        let (addr, len) = addr.into_inner();\n+        cvt(unsafe { c::bind(sock.as_raw(), addr.as_ptr(), len as _) })?;\n         Ok(UdpSocket { inner: sock })\n     }\n \n@@ -531,14 +531,14 @@ impl UdpSocket {\n \n     pub fn send_to(&self, buf: &[u8], dst: &SocketAddr) -> io::Result<usize> {\n         let len = cmp::min(buf.len(), <wrlen_t>::MAX as usize) as wrlen_t;\n-        let (dstp, dstlen) = dst.into_inner();\n+        let (dst, dstlen) = dst.into_inner();\n         let ret = cvt(unsafe {\n             c::sendto(\n                 self.inner.as_raw(),\n                 buf.as_ptr() as *const c_void,\n                 len,\n                 MSG_NOSIGNAL,\n-                dstp,\n+                dst.as_ptr(),\n                 dstlen,\n             )\n         })?;\n@@ -621,7 +621,7 @@ impl UdpSocket {\n \n     pub fn join_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> {\n         let mreq = c::ipv6_mreq {\n-            ipv6mr_multiaddr: *multiaddr.as_inner(),\n+            ipv6mr_multiaddr: multiaddr.into_inner(),\n             ipv6mr_interface: to_ipv6mr_interface(interface),\n         };\n         setsockopt(&self.inner, c::IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP, mreq)\n@@ -637,7 +637,7 @@ impl UdpSocket {\n \n     pub fn leave_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> {\n         let mreq = c::ipv6_mreq {\n-            ipv6mr_multiaddr: *multiaddr.as_inner(),\n+            ipv6mr_multiaddr: multiaddr.into_inner(),\n             ipv6mr_interface: to_ipv6mr_interface(interface),\n         };\n         setsockopt(&self.inner, c::IPPROTO_IPV6, IPV6_DROP_MEMBERSHIP, mreq)\n@@ -677,8 +677,8 @@ impl UdpSocket {\n     }\n \n     pub fn connect(&self, addr: io::Result<&SocketAddr>) -> io::Result<()> {\n-        let (addrp, len) = addr?.into_inner();\n-        cvt_r(|| unsafe { c::connect(self.inner.as_raw(), addrp, len) }).map(drop)\n+        let (addr, len) = addr?.into_inner();\n+        cvt_r(|| unsafe { c::connect(self.inner.as_raw(), addr.as_ptr(), len) }).map(drop)\n     }\n }\n \n@@ -700,3 +700,38 @@ impl fmt::Debug for UdpSocket {\n         res.field(name, &self.inner.as_raw()).finish()\n     }\n }\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Converting SocketAddr to libc representation\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// A type with the same memory layout as `c::sockaddr`. Used in converting Rust level\n+/// SocketAddr* types into their system representation. The benefit of this specific\n+/// type over using `c::sockaddr_storage` is that this type is exactly as large as it\n+/// needs to be and not a lot larger. And it can be initialized more cleanly from Rust.\n+#[repr(C)]\n+pub(crate) union SocketAddrCRepr {\n+    v4: c::sockaddr_in,\n+    v6: c::sockaddr_in6,\n+}\n+\n+impl SocketAddrCRepr {\n+    pub fn as_ptr(&self) -> *const c::sockaddr {\n+        self as *const _ as *const c::sockaddr\n+    }\n+}\n+\n+impl<'a> IntoInner<(SocketAddrCRepr, c::socklen_t)> for &'a SocketAddr {\n+    fn into_inner(self) -> (SocketAddrCRepr, c::socklen_t) {\n+        match *self {\n+            SocketAddr::V4(ref a) => {\n+                let sockaddr = SocketAddrCRepr { v4: a.into_inner() };\n+                (sockaddr, mem::size_of::<c::sockaddr_in>() as c::socklen_t)\n+            }\n+            SocketAddr::V6(ref a) => {\n+                let sockaddr = SocketAddrCRepr { v6: a.into_inner() };\n+                (sockaddr, mem::size_of::<c::sockaddr_in6>() as c::socklen_t)\n+            }\n+        }\n+    }\n+}"}]}