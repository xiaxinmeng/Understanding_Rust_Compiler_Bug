{"sha": "0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhYjhkNWRhZGQ3MmI4ZDQ0Y2M3OWExNzU2YzBhMDBmZWM2MTllZmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-01T13:01:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-01T13:01:57Z"}, "message": "Auto merge of #21805 - nikomatsakis:closure-inference-refactor-1, r=eddyb\n\nCurrently, we only infer the kind of a closure based on the expected type or explicit annotation. If neither applies, we currently report an error. This pull request changes that case to defer the decision until we are able to analyze the actions of the closure: closures which mutate their environment require `FnMut`, closures which move out of their environment require `FnOnce`.\r\n\r\nThis PR is not the end of the story:\r\n\r\n- It does not remove the explicit annotations nor disregard them. The latter is the logical next step to removing them (we'll need a snapshot before we can do anything anyhow). Disregarding explicit annotations might expose more bugs since right now all closures in libstd/rustc use explicit annotations or the expected type, so this inference never kicks in.\r\n- The interaction with instantiating type parameter fallbacks leaves something to be desired. This is mostly just saying that the algorithm from https://github.com/rust-lang/rfcs/pull/213 needs to be implemented, which is a separate bug. There are some semi-subtle interactions though because not knowing whether a closure is `Fn` vs `FnMut` prevents us from resolving obligations like `F : FnMut(...)`, which can in turn prevent unification of some type parameters, which might (in turn) lead to undesired fallback. We can improve this situation however -- even if we don't know whether (or just how) `F : FnMut(..)` holds or not for some closure type `F`, we can still perform unification since we *do* know the argument and return types. Once kind inference is done, we can complete the `F : FnMut(..)` analysis -- which might yield an error if (e.g.) the `F` moves out of its environment. \r\n\r\nr? @nick29581", "tree": {"sha": "5ac2cc900562623bec214091e1f4c82682d5a4c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ac2cc900562623bec214091e1f4c82682d5a4c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "html_url": "https://github.com/rust-lang/rust/commit/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1f9cb705df95171fce4e575374c959509e58dea", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1f9cb705df95171fce4e575374c959509e58dea", "html_url": "https://github.com/rust-lang/rust/commit/f1f9cb705df95171fce4e575374c959509e58dea"}, {"sha": "870aea216bb6f6d6a238c03e186a01bff8820ac0", "url": "https://api.github.com/repos/rust-lang/rust/commits/870aea216bb6f6d6a238c03e186a01bff8820ac0", "html_url": "https://github.com/rust-lang/rust/commit/870aea216bb6f6d6a238c03e186a01bff8820ac0"}], "stats": {"total": 1616, "additions": 1201, "deletions": 415}, "files": [{"sha": "bf2f5bd22c4639424e5d084db504c3d70102a52f", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -139,10 +139,11 @@ pub enum astencode_tag { // Reserves 0x40 -- 0x5f\n     tag_table_adjustments = 0x51,\n     tag_table_moves_map = 0x52,\n     tag_table_capture_map = 0x53,\n-    tag_table_closures = 0x54,\n-    tag_table_upvar_capture_map = 0x55,\n-    tag_table_capture_modes = 0x56,\n-    tag_table_object_cast_map = 0x57,\n+    tag_table_closure_tys = 0x54,\n+    tag_table_closure_kinds = 0x55,\n+    tag_table_upvar_capture_map = 0x56,\n+    tag_table_capture_modes = 0x57,\n+    tag_table_object_cast_map = 0x58,\n }\n \n static first_astencode_tag: uint = tag_ast as uint;\n@@ -225,10 +226,7 @@ pub struct LinkMeta {\n     pub crate_hash: Svh,\n }\n \n-pub const tag_closures: uint = 0x95;\n-pub const tag_closure: uint = 0x96;\n-pub const tag_closure_type: uint = 0x97;\n-pub const tag_closure_kind: uint = 0x98;\n+// GAP 0x94...0x98\n \n pub const tag_struct_fields: uint = 0x99;\n pub const tag_struct_field: uint = 0x9a;"}, {"sha": "e09d29b98b09a47517f88795246a485ba2e8f228", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -618,17 +618,6 @@ fn encode_visibility(rbml_w: &mut Encoder, visibility: ast::Visibility) {\n     rbml_w.end_tag();\n }\n \n-fn encode_closure_kind(rbml_w: &mut Encoder, kind: ty::ClosureKind) {\n-    rbml_w.start_tag(tag_closure_kind);\n-    let ch = match kind {\n-        ty::FnClosureKind => 'f',\n-        ty::FnMutClosureKind => 'm',\n-        ty::FnOnceClosureKind => 'o',\n-    };\n-    rbml_w.wr_str(&ch.to_string()[]);\n-    rbml_w.end_tag();\n-}\n-\n fn encode_explicit_self(rbml_w: &mut Encoder,\n                         explicit_self: &ty::ExplicitSelfCategory) {\n     rbml_w.start_tag(tag_item_trait_method_explicit_self);\n@@ -1843,24 +1832,6 @@ fn encode_macro_defs(rbml_w: &mut Encoder,\n     rbml_w.end_tag();\n }\n \n-fn encode_closures<'a>(ecx: &'a EncodeContext, rbml_w: &'a mut Encoder) {\n-    rbml_w.start_tag(tag_closures);\n-    for (closure_id, closure) in ecx.tcx.closures.borrow().iter() {\n-        if closure_id.krate != ast::LOCAL_CRATE {\n-            continue\n-        }\n-\n-        rbml_w.start_tag(tag_closure);\n-        encode_def_id(rbml_w, *closure_id);\n-        rbml_w.start_tag(tag_closure_type);\n-        write_closure_type(ecx, rbml_w, &closure.closure_type);\n-        rbml_w.end_tag();\n-        encode_closure_kind(rbml_w, closure.kind);\n-        rbml_w.end_tag();\n-    }\n-    rbml_w.end_tag();\n-}\n-\n fn encode_struct_field_attrs(rbml_w: &mut Encoder, krate: &ast::Crate) {\n     struct StructFieldVisitor<'a, 'b:'a> {\n         rbml_w: &'a mut Encoder<'b>,\n@@ -2069,7 +2040,6 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n         native_lib_bytes: u64,\n         plugin_registrar_fn_bytes: u64,\n         macro_defs_bytes: u64,\n-        closure_bytes: u64,\n         impl_bytes: u64,\n         misc_bytes: u64,\n         item_bytes: u64,\n@@ -2084,7 +2054,6 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n         native_lib_bytes: 0,\n         plugin_registrar_fn_bytes: 0,\n         macro_defs_bytes: 0,\n-        closure_bytes: 0,\n         impl_bytes: 0,\n         misc_bytes: 0,\n         item_bytes: 0,\n@@ -2154,11 +2123,6 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n     encode_macro_defs(&mut rbml_w, krate);\n     stats.macro_defs_bytes = rbml_w.writer.tell().unwrap() - i;\n \n-    // Encode the types of all closures in this crate.\n-    i = rbml_w.writer.tell().unwrap();\n-    encode_closures(&ecx, &mut rbml_w);\n-    stats.closure_bytes = rbml_w.writer.tell().unwrap() - i;\n-\n     // Encode the def IDs of impls, for coherence checking.\n     i = rbml_w.writer.tell().unwrap();\n     encode_impls(&ecx, krate, &mut rbml_w);\n@@ -2199,7 +2163,6 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n         println!(\"          native bytes: {}\", stats.native_lib_bytes);\n         println!(\"plugin registrar bytes: {}\", stats.plugin_registrar_fn_bytes);\n         println!(\"       macro def bytes: {}\", stats.macro_defs_bytes);\n-        println!(\"         closure bytes: {}\", stats.closure_bytes);\n         println!(\"            impl bytes: {}\", stats.impl_bytes);\n         println!(\"            misc bytes: {}\", stats.misc_bytes);\n         println!(\"            item bytes: {}\", stats.item_bytes);"}, {"sha": "3764324734132320fbea223d6f5db1303f7f4b44", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 39, "deletions": 58, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -647,30 +647,7 @@ impl<'tcx> tr for MethodOrigin<'tcx> {\n }\n \n pub fn encode_closure_kind(ebml_w: &mut Encoder, kind: ty::ClosureKind) {\n-    use serialize::Encoder;\n-\n-    ebml_w.emit_enum(\"ClosureKind\", |ebml_w| {\n-        match kind {\n-            ty::FnClosureKind => {\n-                ebml_w.emit_enum_variant(\"FnClosureKind\", 0, 3, |_| {\n-                    Ok(())\n-                })\n-            }\n-            ty::FnMutClosureKind => {\n-                ebml_w.emit_enum_variant(\"FnMutClosureKind\", 1, 3, |_| {\n-                    Ok(())\n-                })\n-            }\n-            ty::FnOnceClosureKind => {\n-                ebml_w.emit_enum_variant(\"FnOnceClosureKind\",\n-                                         2,\n-                                         3,\n-                                         |_| {\n-                    Ok(())\n-                })\n-            }\n-        }\n-    }).unwrap()\n+    kind.encode(ebml_w).unwrap();\n }\n \n pub trait vtable_decoder_helpers<'tcx> {\n@@ -1310,12 +1287,20 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for closure in tcx.closures.borrow().get(&ast_util::local_def(id)).iter() {\n-        rbml_w.tag(c::tag_table_closures, |rbml_w| {\n+    for &closure_type in tcx.closure_tys.borrow().get(&ast_util::local_def(id)).iter() {\n+        rbml_w.tag(c::tag_table_closure_tys, |rbml_w| {\n+            rbml_w.id(id);\n+            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                rbml_w.emit_closure_type(ecx, closure_type);\n+            })\n+        })\n+    }\n+\n+    for &&closure_kind in tcx.closure_kinds.borrow().get(&ast_util::local_def(id)).iter() {\n+        rbml_w.tag(c::tag_table_closure_kinds, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                rbml_w.emit_closure_type(ecx, &closure.closure_type);\n-                encode_closure_kind(rbml_w, closure.kind)\n+                encode_closure_kind(rbml_w, closure_kind)\n             })\n         })\n     }\n@@ -1354,8 +1339,10 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                            -> subst::Substs<'tcx>;\n     fn read_auto_adjustment<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                     -> ty::AutoAdjustment<'tcx>;\n-    fn read_closure<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                            -> ty::Closure<'tcx>;\n+    fn read_closure_kind<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                 -> ty::ClosureKind;\n+    fn read_closure_ty<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                               -> ty::ClosureTy<'tcx>;\n     fn read_auto_deref_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                    -> ty::AutoDerefRef<'tcx>;\n     fn read_autoref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1782,35 +1769,23 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_closure<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                            -> ty::Closure<'tcx> {\n-        let closure_type = self.read_opaque(|this, doc| {\n+    fn read_closure_kind<'b, 'c>(&mut self, _dcx: &DecodeContext<'b, 'c, 'tcx>)\n+                                 -> ty::ClosureKind\n+    {\n+        Decodable::decode(self).ok().unwrap()\n+    }\n+\n+    fn read_closure_ty<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n+                               -> ty::ClosureTy<'tcx>\n+    {\n+        self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_ty_closure_data(\n                 doc.data,\n                 dcx.cdata.cnum,\n                 doc.start,\n                 dcx.tcx,\n                 |s, a| this.convert_def_id(dcx, s, a)))\n-        }).unwrap();\n-        let variants = &[\n-            \"FnClosureKind\",\n-            \"FnMutClosureKind\",\n-            \"FnOnceClosureKind\"\n-        ];\n-        let kind = self.read_enum(\"ClosureKind\", |this| {\n-            this.read_enum_variant(variants, |_, i| {\n-                Ok(match i {\n-                    0 => ty::FnClosureKind,\n-                    1 => ty::FnMutClosureKind,\n-                    2 => ty::FnOnceClosureKind,\n-                    _ => panic!(\"bad enum variant for ty::ClosureKind\"),\n-                })\n-            })\n-        }).unwrap();\n-        ty::Closure {\n-            closure_type: closure_type,\n-            kind: kind,\n-        }\n+        }).unwrap()\n     }\n \n     /// Converts a def-id that appears in a type.  The correct\n@@ -1937,11 +1912,17 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         let adj: ty::AutoAdjustment = val_dsr.read_auto_adjustment(dcx);\n                         dcx.tcx.adjustments.borrow_mut().insert(id, adj);\n                     }\n-                    c::tag_table_closures => {\n-                        let closure =\n-                            val_dsr.read_closure(dcx);\n-                        dcx.tcx.closures.borrow_mut().insert(ast_util::local_def(id),\n-                                                             closure);\n+                    c::tag_table_closure_tys => {\n+                        let closure_ty =\n+                            val_dsr.read_closure_ty(dcx);\n+                        dcx.tcx.closure_tys.borrow_mut().insert(ast_util::local_def(id),\n+                                                                closure_ty);\n+                    }\n+                    c::tag_table_closure_kinds => {\n+                        let closure_kind =\n+                            val_dsr.read_closure_kind(dcx);\n+                        dcx.tcx.closure_kinds.borrow_mut().insert(ast_util::local_def(id),\n+                                                                  closure_kind);\n                     }\n                     _ => {\n                         dcx.tcx.sess.bug("}, {"sha": "4a0bed57433ae7a60c79acb156b4e6d8f3ab3a9b", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -260,12 +260,10 @@ impl OverloadedCallType {\n     fn from_closure(tcx: &ty::ctxt, closure_did: ast::DefId)\n                     -> OverloadedCallType {\n         let trait_did =\n-            tcx.closures\n+            tcx.closure_kinds\n                .borrow()\n                .get(&closure_did)\n-               .expect(\"OverloadedCallType::from_closure: didn't \\\n-                        find closure id\")\n-               .kind\n+               .expect(\"OverloadedCallType::from_closure: didn't find closure id\")\n                .trait_did(tcx);\n         OverloadedCallType::from_trait_id(tcx, trait_did)\n     }"}, {"sha": "1330ad86bfc92e6ebda4781b62a895fe161809bc", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -594,8 +594,16 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n               let ty = try!(self.node_ty(fn_node_id));\n               match ty.sty {\n                   ty::ty_closure(closure_id, _, _) => {\n-                      let kind = self.typer.closure_kind(closure_id);\n-                      self.cat_upvar(id, span, var_id, fn_node_id, kind)\n+                      match self.typer.closure_kind(closure_id) {\n+                          Some(kind) => {\n+                              self.cat_upvar(id, span, var_id, fn_node_id, kind)\n+                          }\n+                          None => {\n+                              self.tcx().sess.span_bug(\n+                                  span,\n+                                  &*format!(\"No closure kind for {:?}\", closure_id));\n+                          }\n+                      }\n                   }\n                   _ => {\n                       self.tcx().sess.span_bug("}, {"sha": "106c07baaa7a1889a09d216370fa1356b670e456", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -1024,12 +1024,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                kind,\n                obligation.repr(self.tcx()));\n \n-        let closure_kind = self.closure_typer.closure_kind(closure_def_id);\n-\n-        debug!(\"closure_kind = {:?}\", closure_kind);\n-\n-        if closure_kind == kind {\n-            candidates.vec.push(ClosureCandidate(closure_def_id, substs.clone()));\n+        match self.closure_typer.closure_kind(closure_def_id) {\n+            Some(closure_kind) => {\n+                debug!(\"assemble_unboxed_candidates: closure_kind = {:?}\", closure_kind);\n+                if closure_kind == kind {\n+                    candidates.vec.push(ClosureCandidate(closure_def_id, substs.clone()));\n+                }\n+            }\n+            None => {\n+                debug!(\"assemble_unboxed_candidates: closure_kind not yet known\");\n+                candidates.ambiguous = true;\n+            }\n         }\n \n         Ok(())"}, {"sha": "fb1d9fcada1cecb4e113d0b27d2205435c48a757", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -790,7 +790,11 @@ pub struct ctxt<'tcx> {\n \n     /// Records the type of each closure. The def ID is the ID of the\n     /// expression defining the closure.\n-    pub closures: RefCell<DefIdMap<Closure<'tcx>>>,\n+    pub closure_kinds: RefCell<DefIdMap<ClosureKind>>,\n+\n+    /// Records the type of each closure. The def ID is the ID of the\n+    /// expression defining the closure.\n+    pub closure_tys: RefCell<DefIdMap<ClosureTy<'tcx>>>,\n \n     pub node_lint_levels: RefCell<FnvHashMap<(ast::NodeId, lint::LintId),\n                                               lint::LevelSource>>,\n@@ -2251,16 +2255,7 @@ pub struct ItemSubsts<'tcx> {\n     pub substs: Substs<'tcx>,\n }\n \n-/// Records information about each closure.\n-#[derive(Clone)]\n-pub struct Closure<'tcx> {\n-    /// The type of the closure.\n-    pub closure_type: ClosureTy<'tcx>,\n-    /// The kind of closure this is.\n-    pub kind: ClosureKind,\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable)]\n pub enum ClosureKind {\n     FnClosureKind,\n     FnMutClosureKind,\n@@ -2288,14 +2283,22 @@ impl ClosureKind {\n pub trait ClosureTyper<'tcx> {\n     fn param_env<'a>(&'a self) -> &'a ty::ParameterEnvironment<'a, 'tcx>;\n \n-    fn closure_kind(&self, def_id: ast::DefId) -> ty::ClosureKind;\n+    /// Is this a `Fn`, `FnMut` or `FnOnce` closure? During typeck,\n+    /// returns `None` if the kind of this closure has not yet been\n+    /// inferred.\n+    fn closure_kind(&self,\n+                    def_id: ast::DefId)\n+                    -> Option<ty::ClosureKind>;\n \n+    /// Returns the argument/return types of this closure.\n     fn closure_type(&self,\n                     def_id: ast::DefId,\n                     substs: &subst::Substs<'tcx>)\n                     -> ty::ClosureTy<'tcx>;\n \n-    // Returns `None` if the upvar types cannot yet be definitively determined.\n+    /// Returns the set of all upvars and their transformed\n+    /// types. During typeck, maybe return `None` if the upvar types\n+    /// have not yet been inferred.\n     fn closure_upvars(&self,\n                       def_id: ast::DefId,\n                       substs: &Substs<'tcx>)\n@@ -2391,7 +2394,8 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         extern_const_variants: RefCell::new(DefIdMap()),\n         method_map: RefCell::new(FnvHashMap()),\n         dependency_formats: RefCell::new(FnvHashMap()),\n-        closures: RefCell::new(DefIdMap()),\n+        closure_kinds: RefCell::new(DefIdMap()),\n+        closure_tys: RefCell::new(DefIdMap()),\n         node_lint_levels: RefCell::new(FnvHashMap()),\n         transmute_restrictions: RefCell::new(Vec::new()),\n         stability: RefCell::new(stability),\n@@ -2438,15 +2442,15 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn closure_kind(&self, def_id: ast::DefId) -> ty::ClosureKind {\n-        self.closures.borrow()[def_id].kind\n+        self.closure_kinds.borrow()[def_id]\n     }\n \n     pub fn closure_type(&self,\n                         def_id: ast::DefId,\n                         substs: &subst::Substs<'tcx>)\n                         -> ty::ClosureTy<'tcx>\n     {\n-        self.closures.borrow()[def_id].closure_type.subst(self, substs)\n+        self.closure_tys.borrow()[def_id].subst(self, substs)\n     }\n }\n \n@@ -5635,32 +5639,26 @@ pub fn closure_upvars<'tcx>(typer: &mc::Typer<'tcx>,\n                             closure_expr_id: closure_id.node\n                         };\n \n-                        let captured_freevar_ty = match typer.upvar_capture(upvar_id) {\n-                            Some(UpvarCapture::ByValue) => {\n-                                freevar_ty\n-                            }\n-\n-                            Some(UpvarCapture::ByRef(borrow)) => {\n-                                mk_rptr(tcx,\n-                                        tcx.mk_region(borrow.region),\n-                                        ty::mt {\n-                                            ty: freevar_ty,\n-                                            mutbl: borrow.kind.to_mutbl_lossy(),\n-                                        })\n-                            }\n+                        typer.upvar_capture(upvar_id).map(|capture| {\n+                            let freevar_ref_ty = match capture {\n+                                UpvarCapture::ByValue => {\n+                                    freevar_ty\n+                                }\n+                                UpvarCapture::ByRef(borrow) => {\n+                                    mk_rptr(tcx,\n+                                            tcx.mk_region(borrow.region),\n+                                            ty::mt {\n+                                                ty: freevar_ty,\n+                                                mutbl: borrow.kind.to_mutbl_lossy(),\n+                                            })\n+                                }\n+                            };\n \n-                            None => {\n-                                // FIXME(#16640) we should really return None here;\n-                                // but that requires better inference integration,\n-                                // for now gin up something.\n-                                freevar_ty\n+                            ClosureUpvar {\n+                                def: freevar.def,\n+                                span: freevar.span,\n+                                ty: freevar_ref_ty,\n                             }\n-                        };\n-\n-                        Some(ClosureUpvar {\n-                            def: freevar.def,\n-                            span: freevar.span,\n-                            ty: captured_freevar_ty,\n                         })\n                     })\n                     .collect()\n@@ -6473,8 +6471,11 @@ impl<'a,'tcx> ClosureTyper<'tcx> for ty::ParameterEnvironment<'a,'tcx> {\n         self\n     }\n \n-    fn closure_kind(&self, def_id: ast::DefId) -> ty::ClosureKind {\n-        self.tcx.closure_kind(def_id)\n+    fn closure_kind(&self,\n+                    def_id: ast::DefId)\n+                    -> Option<ty::ClosureKind>\n+    {\n+        Some(self.tcx.closure_kind(def_id))\n     }\n \n     fn closure_type(&self,"}, {"sha": "15cf37dc2f2f04b33430fbfb0b222908c07d8f96", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -405,9 +405,9 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         }\n         ty_str => \"str\".to_string(),\n         ty_closure(ref did, _, substs) => {\n-            let closures = cx.closures.borrow();\n-            closures.get(did).map(|cl| {\n-                closure_to_string(cx, &cl.closure_type.subst(cx, substs))\n+            let closure_tys = cx.closure_tys.borrow();\n+            closure_tys.get(did).map(|closure_type| {\n+                closure_to_string(cx, &closure_type.subst(cx, substs))\n             }).unwrap_or_else(|| {\n                 if did.krate == ast::LOCAL_CRATE {\n                     let span = cx.map.span(did.node);"}, {"sha": "9ec3db0f602af00bb76091c4ac05b4b074aff203", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -273,7 +273,7 @@ pub fn self_type_for_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n pub fn kind_for_closure(ccx: &CrateContext, closure_id: ast::DefId) -> ty::ClosureKind {\n-    ccx.tcx().closures.borrow()[closure_id].kind\n+    ccx.tcx().closure_kinds.borrow()[closure_id]\n }\n \n pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,"}, {"sha": "8473ce1b797e360b7b06c9f3e6e6cd8fad1767d1", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -125,7 +125,7 @@ pub fn get_or_create_declaration_if_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tc\n                                                       closure_id: ast::DefId,\n                                                       substs: &Substs<'tcx>)\n                                                       -> Option<Datum<'tcx, Rvalue>> {\n-    if !ccx.tcx().closures.borrow().contains_key(&closure_id) {\n+    if !ccx.tcx().closure_kinds.borrow().contains_key(&closure_id) {\n         // Not a closure.\n         return None\n     }"}, {"sha": "5782b3987cb485b245be12d8ecbe97296115351f", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -693,7 +693,10 @@ impl<'blk, 'tcx> ty::ClosureTyper<'tcx> for BlockS<'blk, 'tcx> {\n         &self.fcx.param_env\n     }\n \n-    fn closure_kind(&self, def_id: ast::DefId) -> ty::ClosureKind {\n+    fn closure_kind(&self,\n+                    def_id: ast::DefId)\n+                    -> Option<ty::ClosureKind>\n+    {\n         let typer = NormalizingClosureTyper::new(self.tcx());\n         typer.closure_kind(def_id)\n     }\n@@ -1065,8 +1068,11 @@ impl<'a,'tcx> ty::ClosureTyper<'tcx> for NormalizingClosureTyper<'a,'tcx> {\n         &self.param_env\n     }\n \n-    fn closure_kind(&self, def_id: ast::DefId) -> ty::ClosureKind {\n-        self.param_env.tcx.closure_kind(def_id)\n+    fn closure_kind(&self,\n+                    def_id: ast::DefId)\n+                    -> Option<ty::ClosureKind>\n+    {\n+        self.param_env.closure_kind(def_id)\n     }\n \n     fn closure_type(&self,"}, {"sha": "c4b7ffb87296e8a79a1277f7284d6180b0f84f61", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -30,7 +30,7 @@ use syntax::print::pprust;\n use syntax::ptr::P;\n \n pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n-                           pat: &ast::Pat,\n+                           pat: &'tcx ast::Pat,\n                            expected: Ty<'tcx>)\n {\n     let fcx = pcx.fcx;\n@@ -157,9 +157,10 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         }\n         ast::PatIdent(_, ref path, _) => {\n             let path = ast_util::ident_to_path(path.span, path.node);\n-            check_pat_enum(pcx, pat, &path, &Some(vec![]), expected);\n+            check_pat_enum(pcx, pat, &path, Some(&[]), expected);\n         }\n         ast::PatEnum(ref path, ref subpats) => {\n+            let subpats = subpats.as_ref().map(|v| &v[]);\n             check_pat_enum(pcx, pat, path, subpats, expected);\n         }\n         ast::PatStruct(ref path, ref fields, etc) => {\n@@ -335,9 +336,9 @@ pub fn check_dereferencable<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n }\n \n pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                             expr: &ast::Expr,\n-                             discrim: &ast::Expr,\n-                             arms: &[ast::Arm],\n+                             expr: &'tcx ast::Expr,\n+                             discrim: &'tcx ast::Expr,\n+                             arms: &'tcx [ast::Arm],\n                              expected: Expectation<'tcx>,\n                              match_src: ast::MatchSource) {\n     let tcx = fcx.ccx.tcx;\n@@ -424,8 +425,8 @@ pub struct pat_ctxt<'a, 'tcx: 'a> {\n     pub map: PatIdMap,\n }\n \n-pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n-                                  path: &ast::Path, fields: &[Spanned<ast::FieldPat>],\n+pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n+                                  path: &ast::Path, fields: &'tcx [Spanned<ast::FieldPat>],\n                                   etc: bool, expected: Ty<'tcx>) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n@@ -483,10 +484,12 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n                             variant_def_id, etc);\n }\n \n-pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n-                                path: &ast::Path, subpats: &Option<Vec<P<ast::Pat>>>,\n-                                expected: Ty<'tcx>) {\n-\n+pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n+                                pat: &ast::Pat,\n+                                path: &ast::Path,\n+                                subpats: Option<&'tcx [P<ast::Pat>]>,\n+                                expected: Ty<'tcx>)\n+{\n     // Typecheck the path.\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n@@ -536,7 +539,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n                 \"`{}` does not name a non-struct variant or a tuple struct\", name);\n             fcx.write_error(pat.id);\n \n-            if let Some(ref subpats) = *subpats {\n+            if let Some(subpats) = subpats {\n                 for pat in subpats.iter() {\n                     check_pat(pcx, &**pat, tcx.types.err);\n                 }\n@@ -545,7 +548,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n         }\n     };\n \n-    if let Some(ref subpats) = *subpats {\n+    if let Some(subpats) = subpats {\n         if subpats.len() == arg_tys.len() {\n             for (subpat, arg_ty) in subpats.iter().zip(arg_tys.iter()) {\n                 check_pat(pcx, &**subpat, *arg_ty);\n@@ -579,7 +582,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n /// `etc` is true if the pattern said '...' and false otherwise.\n pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                                          span: Span,\n-                                         fields: &[Spanned<ast::FieldPat>],\n+                                         fields: &'tcx [Spanned<ast::FieldPat>],\n                                          struct_fields: &[ty::field<'tcx>],\n                                          struct_id: ast::DefId,\n                                          etc: bool) {"}, {"sha": "93c6445606eb896ebe2bb0b7025a0bdc6ceadd19", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 182, "deletions": 22, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -13,6 +13,8 @@ use super::AutorefArgs;\n use super::check_argument_types;\n use super::check_expr;\n use super::check_method_argument_types;\n+use super::demand;\n+use super::DeferredCallResolution;\n use super::err_args;\n use super::Expectation;\n use super::expected_types_for_fn_args;\n@@ -24,13 +26,14 @@ use super::TupleArgumentsFlag;\n use super::UnresolvedTypeAction;\n use super::write_call;\n \n+use CrateCtxt;\n use middle::infer;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, ClosureTyper};\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::ptr::P;\n-use CrateCtxt;\n+use util::ppaux::Repr;\n \n /// Check that it is legal to call methods of the trait corresponding\n /// to `trait_id` (this only cares about the trait, not the specific\n@@ -66,9 +69,9 @@ pub fn check_legal_trait_for_method_call(ccx: &CrateCtxt, span: Span, trait_id:\n }\n \n pub fn check_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                            call_expr: &ast::Expr,\n-                            callee_expr: &ast::Expr,\n-                            arg_exprs: &[P<ast::Expr>],\n+                            call_expr: &'tcx ast::Expr,\n+                            callee_expr: &'tcx ast::Expr,\n+                            arg_exprs: &'tcx [P<ast::Expr>],\n                             expected: Expectation<'tcx>)\n {\n     check_expr(fcx, callee_expr);\n@@ -96,24 +99,35 @@ pub fn check_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             confirm_builtin_call(fcx, call_expr, callee_ty, arg_exprs, expected);\n         }\n \n+        Some(CallStep::DeferredClosure(fn_sig)) => {\n+            confirm_deferred_closure_call(fcx, call_expr, arg_exprs, expected, fn_sig);\n+        }\n+\n         Some(CallStep::Overloaded(method_callee)) => {\n-            confirm_overloaded_call(fcx, call_expr, arg_exprs, method_callee, expected);\n+            confirm_overloaded_call(fcx, call_expr, callee_expr,\n+                                    arg_exprs, expected, method_callee);\n         }\n     }\n }\n \n enum CallStep<'tcx> {\n     Builtin,\n+    DeferredClosure(ty::FnSig<'tcx>),\n     Overloaded(ty::MethodCallee<'tcx>)\n }\n \n fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                      call_expr: &ast::Expr,\n-                                      callee_expr: &ast::Expr,\n+                                      call_expr: &'tcx ast::Expr,\n+                                      callee_expr: &'tcx ast::Expr,\n                                       adjusted_ty: Ty<'tcx>,\n                                       autoderefref: ty::AutoDerefRef<'tcx>)\n                                       -> Option<CallStep<'tcx>>\n {\n+    debug!(\"try_overloaded_call_step(call_expr={}, adjusted_ty={}, autoderefref={})\",\n+           call_expr.repr(fcx.tcx()),\n+           adjusted_ty.repr(fcx.tcx()),\n+           autoderefref.repr(fcx.tcx()));\n+\n     // If the callee is a bare function or a closure, then we're all set.\n     match structurally_resolved_type(fcx, callee_expr.span, adjusted_ty).sty {\n         ty::ty_bare_fn(..) => {\n@@ -123,9 +137,45 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             return Some(CallStep::Builtin);\n         }\n \n+        ty::ty_closure(def_id, _, substs) => {\n+            assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n+\n+            // Check whether this is a call to a closure where we\n+            // haven't yet decided on whether the closure is fn vs\n+            // fnmut vs fnonce. If so, we have to defer further processing.\n+            if fcx.closure_kind(def_id).is_none() {\n+                let closure_ty =\n+                    fcx.closure_type(def_id, substs);\n+                let fn_sig =\n+                    fcx.infcx().replace_late_bound_regions_with_fresh_var(call_expr.span,\n+                                                                          infer::FnCall,\n+                                                                          &closure_ty.sig).0;\n+                fcx.record_deferred_call_resolution(\n+                    def_id,\n+                    box CallResolution {call_expr: call_expr,\n+                                        callee_expr: callee_expr,\n+                                        adjusted_ty: adjusted_ty,\n+                                        autoderefref: autoderefref,\n+                                        fn_sig: fn_sig.clone(),\n+                                        closure_def_id: def_id});\n+                return Some(CallStep::DeferredClosure(fn_sig));\n+            }\n+        }\n+\n         _ => {}\n     }\n \n+    try_overloaded_call_traits(fcx, call_expr, callee_expr, adjusted_ty, autoderefref)\n+        .map(|method_callee| CallStep::Overloaded(method_callee))\n+}\n+\n+fn try_overloaded_call_traits<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                       call_expr: &ast::Expr,\n+                                       callee_expr: &ast::Expr,\n+                                       adjusted_ty: Ty<'tcx>,\n+                                       autoderefref: ty::AutoDerefRef<'tcx>)\n+                                       -> Option<ty::MethodCallee<'tcx>>\n+{\n     // Try the options that are least restrictive on the caller first.\n     for &(opt_trait_def_id, method_name) in [\n         (fcx.tcx().lang_items.fn_trait(), token::intern(\"call\")),\n@@ -147,7 +197,7 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                None) {\n             None => continue,\n             Some(method_callee) => {\n-                return Some(CallStep::Overloaded(method_callee));\n+                return Some(method_callee);\n             }\n         }\n     }\n@@ -158,7 +208,7 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                  call_expr: &ast::Expr,\n                                  callee_ty: Ty<'tcx>,\n-                                 arg_exprs: &[P<ast::Expr>],\n+                                 arg_exprs: &'tcx [P<ast::Expr>],\n                                  expected: Expectation<'tcx>)\n {\n     let error_fn_sig;\n@@ -215,22 +265,132 @@ fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     write_call(fcx, call_expr, fn_sig.output);\n }\n \n+fn confirm_deferred_closure_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                                          call_expr: &ast::Expr,\n+                                          arg_exprs: &'tcx [P<ast::Expr>],\n+                                          expected: Expectation<'tcx>,\n+                                          fn_sig: ty::FnSig<'tcx>)\n+{\n+    // `fn_sig` is the *signature* of the cosure being called. We\n+    // don't know the full details yet (`Fn` vs `FnMut` etc), but we\n+    // do know the types expected for each argument and the return\n+    // type.\n+\n+    let expected_arg_tys =\n+        expected_types_for_fn_args(fcx,\n+                                   call_expr.span,\n+                                   expected,\n+                                   fn_sig.output.clone(),\n+                                   &*fn_sig.inputs);\n+\n+    check_argument_types(fcx,\n+                         call_expr.span,\n+                         &*fn_sig.inputs,\n+                         &*expected_arg_tys,\n+                         arg_exprs,\n+                         AutorefArgs::No,\n+                         fn_sig.variadic,\n+                         TupleArgumentsFlag::TupleArguments);\n+\n+    write_call(fcx, call_expr, fn_sig.output);\n+}\n+\n fn confirm_overloaded_call<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                     call_expr: &ast::Expr,\n-                                    arg_exprs: &[P<ast::Expr>],\n-                                    method_callee: ty::MethodCallee<'tcx>,\n-                                    expected: Expectation<'tcx>)\n+                                    callee_expr: &'tcx ast::Expr,\n+                                    arg_exprs: &'tcx [P<ast::Expr>],\n+                                    expected: Expectation<'tcx>,\n+                                    method_callee: ty::MethodCallee<'tcx>)\n {\n-    let output_type = check_method_argument_types(fcx,\n-                                                  call_expr.span,\n-                                                  method_callee.ty,\n-                                                  call_expr,\n-                                                  arg_exprs,\n-                                                  AutorefArgs::No,\n-                                                  TupleArgumentsFlag::TupleArguments,\n-                                                  expected);\n+    let output_type =\n+        check_method_argument_types(fcx,\n+                                    call_expr.span,\n+                                    method_callee.ty,\n+                                    callee_expr,\n+                                    arg_exprs,\n+                                    AutorefArgs::No,\n+                                    TupleArgumentsFlag::TupleArguments,\n+                                    expected);\n+    write_call(fcx, call_expr, output_type);\n+\n+    write_overloaded_call_method_map(fcx, call_expr, method_callee);\n+}\n+\n+fn write_overloaded_call_method_map<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                             call_expr: &ast::Expr,\n+                                             method_callee: ty::MethodCallee<'tcx>) {\n     let method_call = ty::MethodCall::expr(call_expr.id);\n     fcx.inh.method_map.borrow_mut().insert(method_call, method_callee);\n-    write_call(fcx, call_expr, output_type);\n }\n \n+struct CallResolution<'tcx> {\n+    call_expr: &'tcx ast::Expr,\n+    callee_expr: &'tcx ast::Expr,\n+    adjusted_ty: Ty<'tcx>,\n+    autoderefref: ty::AutoDerefRef<'tcx>,\n+    fn_sig: ty::FnSig<'tcx>,\n+    closure_def_id: ast::DefId,\n+}\n+\n+impl<'tcx> Repr<'tcx> for CallResolution<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        format!(\"CallResolution(call_expr={}, callee_expr={}, adjusted_ty={}, \\\n+                autoderefref={}, fn_sig={}, closure_def_id={})\",\n+                self.call_expr.repr(tcx),\n+                self.callee_expr.repr(tcx),\n+                self.adjusted_ty.repr(tcx),\n+                self.autoderefref.repr(tcx),\n+                self.fn_sig.repr(tcx),\n+                self.closure_def_id.repr(tcx))\n+    }\n+}\n+\n+impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n+    fn resolve<'a>(&mut self, fcx: &FnCtxt<'a,'tcx>) {\n+        debug!(\"DeferredCallResolution::resolve() {}\",\n+               self.repr(fcx.tcx()));\n+\n+        // we should not be invoked until the closure kind has been\n+        // determined by upvar inference\n+        assert!(fcx.closure_kind(self.closure_def_id).is_some());\n+\n+        // We may now know enough to figure out fn vs fnmut etc.\n+        match try_overloaded_call_traits(fcx, self.call_expr, self.callee_expr,\n+                                         self.adjusted_ty, self.autoderefref.clone()) {\n+            Some(method_callee) => {\n+                // One problem is that when we get here, we are going\n+                // to have a newly instantiated function signature\n+                // from the call trait. This has to be reconciled with\n+                // the older function signature we had before. In\n+                // principle we *should* be able to fn_sigs(), but we\n+                // can't because of the annoying need for a TypeTrace.\n+                // (This always bites me, should find a way to\n+                // refactor it.)\n+                let method_sig =\n+                    ty::assert_no_late_bound_regions(fcx.tcx(),\n+                                                     ty::ty_fn_sig(method_callee.ty));\n+\n+                debug!(\"attempt_resolution: method_callee={}\",\n+                       method_callee.repr(fcx.tcx()));\n+\n+                for (&method_arg_ty, &self_arg_ty) in\n+                    method_sig.inputs[1..].iter().zip(self.fn_sig.inputs.iter())\n+                {\n+                    demand::eqtype(fcx, self.call_expr.span, self_arg_ty, method_arg_ty);\n+                }\n+\n+                demand::eqtype(fcx,\n+                               self.call_expr.span,\n+                               method_sig.output.unwrap(),\n+                               self.fn_sig.output.unwrap());\n+\n+                write_overloaded_call_method_map(fcx, self.call_expr, method_callee);\n+            }\n+            None => {\n+                fcx.tcx().sess.span_bug(\n+                    self.call_expr.span,\n+                    \"failed to find an overloaded call trait for closure call\");\n+            }\n+        }\n+    }\n+}"}, {"sha": "808dbd4b319109d331678b40c15b71b1ca451d21", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 19, "deletions": 26, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -26,8 +26,8 @@ pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                    expr: &ast::Expr,\n                                    _capture: ast::CaptureClause,\n                                    opt_kind: Option<ast::ClosureKind>,\n-                                   decl: &ast::FnDecl,\n-                                   body: &ast::Block,\n+                                   decl: &'tcx ast::FnDecl,\n+                                   body: &'tcx ast::Block,\n                                    expected: Expectation<'tcx>) {\n     debug!(\"check_expr_closure(expr={},expected={})\",\n            expr.repr(fcx.tcx()),\n@@ -42,20 +42,14 @@ pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n             // If users didn't specify what sort of closure they want,\n             // examine the expected type. For now, if we see explicit\n             // evidence than an unboxed closure is desired, we'll use\n-            // that, otherwise we'll error, requesting an annotation.\n+            // that. Otherwise, we leave it unspecified, to be filled\n+            // in by upvar inference.\n             match expected_sig_and_kind {\n                 None => { // don't have information about the kind, request explicit annotation\n-                    // NB We still need to typeck the body, so assume `FnMut` kind just for that\n-                    let kind = ty::FnMutClosureKind;\n-\n-                    check_closure(fcx, expr, kind, decl, body, None);\n-\n-                    span_err!(fcx.ccx.tcx.sess, expr.span, E0187,\n-                        \"can't infer the \\\"kind\\\" of the closure; explicitly annotate it; e.g. \\\n-                        `|&:| {{}}`\");\n+                    check_closure(fcx, expr, None, decl, body, None);\n                 },\n                 Some((sig, kind)) => {\n-                    check_closure(fcx, expr, kind, decl, body, Some(sig));\n+                    check_closure(fcx, expr, Some(kind), decl, body, Some(sig));\n                 }\n             }\n         }\n@@ -68,21 +62,21 @@ pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n             };\n \n             let expected_sig = expected_sig_and_kind.map(|t| t.0);\n-            check_closure(fcx, expr, kind, decl, body, expected_sig);\n+            check_closure(fcx, expr, Some(kind), decl, body, expected_sig);\n         }\n     }\n }\n \n fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                           expr: &ast::Expr,\n-                          kind: ty::ClosureKind,\n-                          decl: &ast::FnDecl,\n-                          body: &ast::Block,\n+                          opt_kind: Option<ty::ClosureKind>,\n+                          decl: &'tcx ast::FnDecl,\n+                          body: &'tcx ast::Block,\n                           expected_sig: Option<ty::FnSig<'tcx>>) {\n     let expr_def_id = ast_util::local_def(expr.id);\n \n-    debug!(\"check_closure kind={:?} expected_sig={}\",\n-           kind,\n+    debug!(\"check_closure opt_kind={:?} expected_sig={}\",\n+           opt_kind,\n            expected_sig.repr(fcx.tcx()));\n \n     let mut fn_ty = astconv::ty_of_closure(\n@@ -124,17 +118,16 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     // the `closures` table.\n     fn_ty.sig.0.inputs = vec![ty::mk_tup(fcx.tcx(), fn_ty.sig.0.inputs)];\n \n-    debug!(\"closure for {} --> sig={} kind={:?}\",\n+    debug!(\"closure for {} --> sig={} opt_kind={:?}\",\n            expr_def_id.repr(fcx.tcx()),\n            fn_ty.sig.repr(fcx.tcx()),\n-           kind);\n-\n-    let closure = ty::Closure {\n-        closure_type: fn_ty,\n-        kind: kind,\n-    };\n+           opt_kind);\n \n-    fcx.inh.closures.borrow_mut().insert(expr_def_id, closure);\n+    fcx.inh.closure_tys.borrow_mut().insert(expr_def_id, fn_ty);\n+    match opt_kind {\n+        Some(kind) => { fcx.inh.closure_kinds.borrow_mut().insert(expr_def_id, kind); }\n+        None => { }\n+    }\n }\n \n fn deduce_expectations_from_expected_type<'a,'tcx>("}, {"sha": "c326116cbd5449b3fbbf8709212af0a69039d67b", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -31,8 +31,8 @@ use util::ppaux::Repr;\n struct ConfirmContext<'a, 'tcx:'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     span: Span,\n-    self_expr: &'a ast::Expr,\n-    call_expr: &'a ast::Expr,\n+    self_expr: &'tcx ast::Expr,\n+    call_expr: &'tcx ast::Expr,\n }\n \n struct InstantiatedMethodSig<'tcx> {\n@@ -51,8 +51,8 @@ struct InstantiatedMethodSig<'tcx> {\n \n pub fn confirm<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                          span: Span,\n-                         self_expr: &ast::Expr,\n-                         call_expr: &ast::Expr,\n+                         self_expr: &'tcx ast::Expr,\n+                         call_expr: &'tcx ast::Expr,\n                          unadjusted_self_ty: Ty<'tcx>,\n                          pick: probe::Pick<'tcx>,\n                          supplied_method_types: Vec<Ty<'tcx>>)\n@@ -70,8 +70,8 @@ pub fn confirm<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     fn new(fcx: &'a FnCtxt<'a, 'tcx>,\n            span: Span,\n-           self_expr: &'a ast::Expr,\n-           call_expr: &'a ast::Expr)\n+           self_expr: &'tcx ast::Expr,\n+           call_expr: &'tcx ast::Expr)\n            -> ConfirmContext<'a, 'tcx>\n     {\n         ConfirmContext { fcx: fcx, span: span, self_expr: self_expr, call_expr: call_expr }"}, {"sha": "88455b3385a1e10a7fb98a855912850407850a46", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -44,6 +44,9 @@ pub enum MethodError {\n \n     // Multiple methods might apply.\n     Ambiguity(Vec<CandidateSource>),\n+\n+    // Using a `Fn`/`FnMut`/etc method on a raw closure type before we have inferred its kind.\n+    ClosureAmbiguity(/* DefId of fn trait */ ast::DefId),\n }\n \n // A pared down enum describing just the places from which a method\n@@ -65,9 +68,10 @@ pub fn exists<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         -> bool\n {\n     match probe::probe(fcx, span, method_name, self_ty, call_expr_id) {\n-        Ok(_) => true,\n-        Err(NoMatch(_, _)) => false,\n-        Err(Ambiguity(_)) => true,\n+        Ok(..) => true,\n+        Err(NoMatch(..)) => false,\n+        Err(Ambiguity(..)) => true,\n+        Err(ClosureAmbiguity(..)) => true,\n     }\n }\n \n@@ -90,8 +94,8 @@ pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         method_name: ast::Name,\n                         self_ty: Ty<'tcx>,\n                         supplied_method_types: Vec<Ty<'tcx>>,\n-                        call_expr: &ast::Expr,\n-                        self_expr: &ast::Expr)\n+                        call_expr: &'tcx ast::Expr,\n+                        self_expr: &'tcx ast::Expr)\n                         -> Result<MethodCallee<'tcx>, MethodError>\n {\n     debug!(\"lookup(method_name={}, self_ty={}, call_expr={}, self_expr={})\","}, {"sha": "e9ea0921bc9e83dac2399e0d0c959c8c56e0e4a0", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 40, "deletions": 28, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::{MethodError,Ambiguity,NoMatch};\n+use super::{MethodError};\n use super::MethodIndex;\n use super::{CandidateSource,ImplSource,TraitSource};\n use super::suggest;\n@@ -129,7 +129,7 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // take place in the `fcx.infcx().probe` below.\n     let steps = match create_steps(fcx, span, self_ty) {\n         Some(steps) => steps,\n-        None => return Err(NoMatch(Vec::new(), Vec::new())),\n+        None => return Err(MethodError::NoMatch(Vec::new(), Vec::new())),\n     };\n \n     // Create a list of simplified self types, if we can.\n@@ -158,7 +158,7 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         let (steps, opt_simplified_steps) = dummy.take().unwrap();\n         let mut probe_cx = ProbeContext::new(fcx, span, method_name, steps, opt_simplified_steps);\n         probe_cx.assemble_inherent_candidates();\n-        probe_cx.assemble_extension_candidates_for_traits_in_scope(call_expr_id);\n+        try!(probe_cx.assemble_extension_candidates_for_traits_in_scope(call_expr_id));\n         probe_cx.pick()\n     })\n }\n@@ -444,29 +444,34 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_extension_candidates_for_traits_in_scope(&mut self,\n                                                          expr_id: ast::NodeId)\n+                                                         -> Result<(),MethodError>\n     {\n         let mut duplicates = HashSet::new();\n         let opt_applicable_traits = self.fcx.ccx.trait_map.get(&expr_id);\n         for applicable_traits in opt_applicable_traits.into_iter() {\n             for &trait_did in applicable_traits.iter() {\n                 if duplicates.insert(trait_did) {\n-                    self.assemble_extension_candidates_for_trait(trait_did);\n+                    try!(self.assemble_extension_candidates_for_trait(trait_did));\n                 }\n             }\n         }\n+        Ok(())\n     }\n \n-    fn assemble_extension_candidates_for_all_traits(&mut self) {\n+    fn assemble_extension_candidates_for_all_traits(&mut self) -> Result<(),MethodError> {\n         let mut duplicates = HashSet::new();\n         for trait_info in suggest::all_traits(self.fcx.ccx) {\n             if duplicates.insert(trait_info.def_id) {\n-                self.assemble_extension_candidates_for_trait(trait_info.def_id)\n+                try!(self.assemble_extension_candidates_for_trait(trait_info.def_id));\n             }\n         }\n+        Ok(())\n     }\n \n     fn assemble_extension_candidates_for_trait(&mut self,\n-                                               trait_def_id: ast::DefId) {\n+                                               trait_def_id: ast::DefId)\n+                                               -> Result<(),MethodError>\n+    {\n         debug!(\"assemble_extension_candidates_for_trait(trait_def_id={})\",\n                trait_def_id.repr(self.tcx()));\n \n@@ -478,26 +483,27 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                        .position(|item| item.name() == self.method_name);\n         let matching_index = match matching_index {\n             Some(i) => i,\n-            None => { return; }\n+            None => { return Ok(()); }\n         };\n         let method = match (&*trait_items)[matching_index].as_opt_method() {\n             Some(m) => m,\n-            None => { return; }\n+            None => { return Ok(()); }\n         };\n \n         // Check whether `trait_def_id` defines a method with suitable name:\n         if !self.has_applicable_self(&*method) {\n             debug!(\"method has inapplicable self\");\n-            return self.record_static_candidate(TraitSource(trait_def_id));\n+            self.record_static_candidate(TraitSource(trait_def_id));\n+            return Ok(());\n         }\n \n         self.assemble_extension_candidates_for_trait_impls(trait_def_id,\n                                                            method.clone(),\n                                                            matching_index);\n \n-        self.assemble_closure_candidates(trait_def_id,\n-                                         method.clone(),\n-                                         matching_index);\n+        try!(self.assemble_closure_candidates(trait_def_id,\n+                                              method.clone(),\n+                                              matching_index));\n \n         self.assemble_projection_candidates(trait_def_id,\n                                             method.clone(),\n@@ -506,6 +512,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         self.assemble_where_clause_candidates(trait_def_id,\n                                               method,\n                                               matching_index);\n+\n+        Ok(())\n     }\n \n     fn assemble_extension_candidates_for_trait_impls(&mut self,\n@@ -576,6 +584,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                    trait_def_id: ast::DefId,\n                                    method_ty: Rc<ty::Method<'tcx>>,\n                                    method_index: uint)\n+                                   -> Result<(),MethodError>\n     {\n         // Check if this is one of the Fn,FnMut,FnOnce traits.\n         let tcx = self.tcx();\n@@ -586,7 +595,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         } else if Some(trait_def_id) == tcx.lang_items.fn_once_trait() {\n             ty::FnOnceClosureKind\n         } else {\n-            return;\n+            return Ok(());\n         };\n \n         // Check if there is an unboxed-closure self-type in the list of receivers.\n@@ -598,19 +607,16 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 _ => continue,\n             };\n \n-            let closures = self.fcx.inh.closures.borrow();\n-            let closure_data = match closures.get(&closure_def_id) {\n-                Some(data) => data,\n+            let closure_kinds = self.fcx.inh.closure_kinds.borrow();\n+            let closure_kind = match closure_kinds.get(&closure_def_id) {\n+                Some(&k) => k,\n                 None => {\n-                    self.tcx().sess.span_bug(\n-                        self.span,\n-                        &format!(\"No entry for closure: {}\",\n-                                closure_def_id.repr(self.tcx()))[]);\n+                    return Err(MethodError::ClosureAmbiguity(trait_def_id));\n                 }\n             };\n \n             // this closure doesn't implement the right kind of `Fn` trait\n-            if closure_data.kind != kind {\n+            if closure_kind != kind {\n                 continue;\n             }\n \n@@ -630,6 +636,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 kind: ClosureCandidate(trait_def_id, method_index)\n             });\n         }\n+\n+        Ok(())\n     }\n \n     fn assemble_projection_candidates(&mut self,\n@@ -735,11 +743,11 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         let span = self.span;\n         let tcx = self.tcx();\n \n-        self.assemble_extension_candidates_for_all_traits();\n+        try!(self.assemble_extension_candidates_for_all_traits());\n \n         let out_of_scope_traits = match self.pick_core() {\n             Some(Ok(p)) => vec![p.method_ty.container.id()],\n-            Some(Err(Ambiguity(v))) => v.into_iter().map(|source| {\n+            Some(Err(MethodError::Ambiguity(v))) => v.into_iter().map(|source| {\n                 match source {\n                     TraitSource(id) => id,\n                     ImplSource(impl_id) => {\n@@ -752,14 +760,18 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                     }\n                 }\n             }).collect(),\n-            Some(Err(NoMatch(_, others))) => {\n+            Some(Err(MethodError::NoMatch(_, others))) => {\n                 assert!(others.is_empty());\n                 vec![]\n             }\n+            Some(Err(MethodError::ClosureAmbiguity(..))) => {\n+                // this error only occurs when assembling candidates\n+                tcx.sess.span_bug(span, \"encountered ClosureAmbiguity from pick_core\");\n+            }\n             None => vec![],\n         };\n-;\n-        Err(NoMatch(static_candidates, out_of_scope_traits))\n+\n+        Err(MethodError::NoMatch(static_candidates, out_of_scope_traits))\n     }\n \n     fn pick_core(&mut self) -> Option<PickResult<'tcx>> {\n@@ -895,7 +907,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         if applicable_candidates.len() > 1 {\n             let sources = probes.iter().map(|p| p.to_source()).collect();\n-            return Some(Err(Ambiguity(sources)));\n+            return Some(Err(MethodError::Ambiguity(sources)));\n         }\n \n         applicable_candidates.pop().map(|probe| {"}, {"sha": "bd5060c940e5025505e5ec8d4fe9c0700f211c88", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -22,6 +22,7 @@ use util::ppaux::UserString;\n \n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n+use syntax::print::pprust;\n \n use std::cell;\n use std::cmp::Ordering;\n@@ -32,6 +33,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                               span: Span,\n                               rcvr_ty: Ty<'tcx>,\n                               method_name: ast::Name,\n+                              callee_expr: &ast::Expr,\n                               error: MethodError)\n {\n     match error {\n@@ -84,6 +86,18 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n             report_candidates(fcx, span, method_name, sources);\n         }\n+\n+        MethodError::ClosureAmbiguity(trait_def_id) => {\n+            fcx.sess().span_err(\n+                span,\n+                &*format!(\"the `{}` method from the `{}` trait cannot be explicitly \\\n+                           invoked on this closure as we have not yet inferred what \\\n+                           kind of closure it is; use overloaded call notation instead \\\n+                           (e.g., `{}()`)\",\n+                          method_name.user_string(fcx.tcx()),\n+                          ty::item_path_str(fcx.tcx(), trait_def_id),\n+                          pprust::expr_to_string(callee_expr)));\n+        }\n     }\n \n     fn report_candidates(fcx: &FnCtxt,"}, {"sha": "c193e1ef48364814aa247428310927f3d0e9df24", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 146, "deletions": 103, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -110,6 +110,7 @@ use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n use util::lev_distance::lev_distance;\n \n use std::cell::{Cell, Ref, RefCell};\n+use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::mem::replace;\n use std::rc::Rc;\n use std::iter::repeat;\n@@ -160,7 +161,8 @@ pub struct Inherited<'a, 'tcx: 'a> {\n     adjustments: RefCell<NodeMap<ty::AutoAdjustment<'tcx>>>,\n     method_map: MethodMap<'tcx>,\n     upvar_capture_map: RefCell<ty::UpvarCaptureMap>,\n-    closures: RefCell<DefIdMap<ty::Closure<'tcx>>>,\n+    closure_tys: RefCell<DefIdMap<ty::ClosureTy<'tcx>>>,\n+    closure_kinds: RefCell<DefIdMap<ty::ClosureKind>>,\n     object_cast_map: ObjectCastMap<'tcx>,\n \n     // A mapping from each fn's id to its signature, with all bound\n@@ -170,8 +172,23 @@ pub struct Inherited<'a, 'tcx: 'a> {\n \n     // Tracks trait obligations incurred during this function body.\n     fulfillment_cx: RefCell<traits::FulfillmentContext<'tcx>>,\n+\n+    // When we process a call like `c()` where `c` is a closure type,\n+    // we may not have decided yet whether `c` is a `Fn`, `FnMut`, or\n+    // `FnOnce` closure. In that case, we defer full resolution of the\n+    // call until upvar inference can kick in and make the\n+    // decision. We keep these deferred resolutions grouped by the\n+    // def-id of the closure, so that once we decide, we can easily go\n+    // back and process them.\n+    deferred_call_resolutions: RefCell<DefIdMap<Vec<DeferredCallResolutionHandler<'tcx>>>>,\n+}\n+\n+trait DeferredCallResolution<'tcx> {\n+    fn resolve<'a>(&mut self, fcx: &FnCtxt<'a,'tcx>);\n }\n \n+type DeferredCallResolutionHandler<'tcx> = Box<DeferredCallResolution<'tcx>+'tcx>;\n+\n /// When type-checking an expression, we propagate downward\n /// whatever type hint we are able in the form of an `Expectation`.\n #[derive(Copy)]\n@@ -339,16 +356,19 @@ impl<'a, 'tcx> ty::ClosureTyper<'tcx> for FnCtxt<'a, 'tcx> {\n         &self.inh.param_env\n     }\n \n-    fn closure_kind(&self, def_id: ast::DefId) -> ty::ClosureKind {\n-        self.inh.closures.borrow()[def_id].kind\n+    fn closure_kind(&self,\n+                    def_id: ast::DefId)\n+                    -> Option<ty::ClosureKind>\n+    {\n+        self.inh.closure_kinds.borrow().get(&def_id).cloned()\n     }\n \n     fn closure_type(&self,\n                     def_id: ast::DefId,\n                     substs: &subst::Substs<'tcx>)\n                     -> ty::ClosureTy<'tcx>\n     {\n-        self.inh.closures.borrow()[def_id].closure_type.subst(self.tcx(), substs)\n+        self.inh.closure_tys.borrow()[def_id].subst(self.tcx(), substs)\n     }\n \n     fn closure_upvars(&self,\n@@ -374,9 +394,11 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n             method_map: RefCell::new(FnvHashMap()),\n             object_cast_map: RefCell::new(NodeMap()),\n             upvar_capture_map: RefCell::new(FnvHashMap()),\n-            closures: RefCell::new(DefIdMap()),\n+            closure_tys: RefCell::new(DefIdMap()),\n+            closure_kinds: RefCell::new(DefIdMap()),\n             fn_sig_map: RefCell::new(NodeMap()),\n             fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n+            deferred_call_resolutions: RefCell::new(DefIdMap()),\n         }\n     }\n \n@@ -425,13 +447,13 @@ fn static_inherited_fields<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>)\n \n struct CheckItemTypesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for CheckItemTypesVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &ast::Item) {\n+impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, i: &'tcx ast::Item) {\n         check_item(self.ccx, i);\n         visit::walk_item(self, i);\n     }\n \n-    fn visit_ty(&mut self, t: &ast::Ty) {\n+    fn visit_ty(&mut self, t: &'tcx ast::Ty) {\n         match t.node {\n             ast::TyFixedLengthVec(_, ref expr) => {\n                 check_const_in_type(self.ccx, &**expr, self.ccx.tcx.types.uint);\n@@ -459,8 +481,8 @@ pub fn check_item_types(ccx: &CrateCtxt) {\n }\n \n fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                           decl: &ast::FnDecl,\n-                           body: &ast::Block,\n+                           decl: &'tcx ast::FnDecl,\n+                           body: &'tcx ast::Block,\n                            id: ast::NodeId,\n                            raw_fty: Ty<'tcx>,\n                            param_env: ty::ParameterEnvironment<'a, 'tcx>)\n@@ -480,8 +502,9 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             let fcx = check_fn(ccx, fn_ty.unsafety, id, &fn_sig,\n                                decl, id, body, &inh);\n \n-            vtable::select_all_fcx_obligations_or_error(&fcx);\n+            vtable::select_all_fcx_obligations_and_apply_defaults(&fcx);\n             upvar::closure_analyze_fn(&fcx, id, decl, body);\n+            vtable::select_all_fcx_obligations_or_error(&fcx);\n             regionck::regionck_fn(&fcx, id, decl, body);\n             writeback::resolve_type_vars_in_fn(&fcx, decl, body);\n         }\n@@ -512,9 +535,9 @@ impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n     // Add explicitly-declared locals.\n-    fn visit_local(&mut self, local: &ast::Local) {\n+    fn visit_local(&mut self, local: &'tcx ast::Local) {\n         let o_ty = match local.ty {\n             Some(ref ty) => Some(self.fcx.to_ty(&**ty)),\n             None => None\n@@ -528,7 +551,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n     }\n \n     // Add pattern bindings.\n-    fn visit_pat(&mut self, p: &ast::Pat) {\n+    fn visit_pat(&mut self, p: &'tcx ast::Pat) {\n         if let ast::PatIdent(_, ref path1, _) = p.node {\n             if pat_util::pat_is_binding(&self.fcx.ccx.tcx.def_map, p) {\n                 let var_ty = self.assign(p.span, p.id, None);\n@@ -546,7 +569,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n         visit::walk_pat(self, p);\n     }\n \n-    fn visit_block(&mut self, b: &ast::Block) {\n+    fn visit_block(&mut self, b: &'tcx ast::Block) {\n         // non-obvious: the `blk` variable maps to region lb, so\n         // we have to keep this up-to-date.  This\n         // is... unfortunate.  It'd be nice to not need this.\n@@ -555,7 +578,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n \n     // Since an expr occurs as part of the type fixed size arrays we\n     // need to record the type for that node\n-    fn visit_ty(&mut self, t: &ast::Ty) {\n+    fn visit_ty(&mut self, t: &'tcx ast::Ty) {\n         match t.node {\n             ast::TyFixedLengthVec(ref ty, ref count_expr) => {\n                 self.visit_ty(&**ty);\n@@ -566,8 +589,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n     }\n \n     // Don't descend into fns and items\n-    fn visit_fn(&mut self, _: visit::FnKind<'v>, _: &'v ast::FnDecl,\n-                _: &'v ast::Block, _: Span, _: ast::NodeId) { }\n+    fn visit_fn(&mut self, _: visit::FnKind<'tcx>, _: &'tcx ast::FnDecl,\n+                _: &'tcx ast::Block, _: Span, _: ast::NodeId) { }\n     fn visit_item(&mut self, _: &ast::Item) { }\n \n }\n@@ -582,9 +605,9 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n                       unsafety: ast::Unsafety,\n                       unsafety_id: ast::NodeId,\n                       fn_sig: &ty::FnSig<'tcx>,\n-                      decl: &ast::FnDecl,\n+                      decl: &'tcx ast::FnDecl,\n                       fn_id: ast::NodeId,\n-                      body: &ast::Block,\n+                      body: &'tcx ast::Block,\n                       inherited: &'a Inherited<'a, 'tcx>)\n                       -> FnCtxt<'a, 'tcx>\n {\n@@ -677,7 +700,7 @@ pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n     }\n }\n \n-pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n+pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n     debug!(\"check_item(it.id={}, it.ident={})\",\n            it.id,\n            ty::item_path_str(ccx.tcx, local_def(it.id)));\n@@ -829,7 +852,7 @@ fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n /// * `method`: the method definition\n fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                item_generics: &ty::Generics<'tcx>,\n-                               method: &ast::Method) {\n+                               method: &'tcx ast::Method) {\n     debug!(\"check_method_body(item_generics={}, method.id={})\",\n             item_generics.repr(ccx.tcx),\n             method.id);\n@@ -1133,10 +1156,10 @@ fn check_cast_inner<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n }\n \n-fn check_cast(fcx: &FnCtxt,\n-              cast_expr: &ast::Expr,\n-              e: &ast::Expr,\n-              t: &ast::Ty) {\n+fn check_cast<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                       cast_expr: &ast::Expr,\n+                       e: &'tcx ast::Expr,\n+                       t: &ast::Ty) {\n     let id = cast_expr.id;\n     let span = cast_expr.span;\n \n@@ -1279,6 +1302,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if ty::type_has_ty_infer(t) || ty::type_is_error(t) { Err(()) } else { Ok(t) }\n     }\n \n+    fn record_deferred_call_resolution(&self,\n+                                       closure_def_id: ast::DefId,\n+                                       r: DeferredCallResolutionHandler<'tcx>) {\n+        let mut deferred_call_resolutions = self.inh.deferred_call_resolutions.borrow_mut();\n+        let mut vec = match deferred_call_resolutions.entry(closure_def_id) {\n+            Occupied(entry) => entry.into_mut(),\n+            Vacant(entry) => entry.insert(Vec::new()),\n+        };\n+        vec.push(r);\n+    }\n+\n+    fn remove_deferred_call_resolutions(&self,\n+                                        closure_def_id: ast::DefId)\n+                                        -> Vec<DeferredCallResolutionHandler<'tcx>>\n+    {\n+        let mut deferred_call_resolutions = self.inh.deferred_call_resolutions.borrow_mut();\n+        deferred_call_resolutions.remove(&closure_def_id).unwrap_or(Vec::new())\n+    }\n+\n     pub fn tag(&self) -> String {\n         format!(\"{:?}\", self as *const FnCtxt)\n     }\n@@ -2068,7 +2110,7 @@ fn autoderef_for_index<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                             method_call: MethodCall,\n                             expr: &ast::Expr,\n-                            base_expr: &ast::Expr,\n+                            base_expr: &'tcx ast::Expr,\n                             adjusted_ty: Ty<'tcx>,\n                             adjustment: ty::AutoDerefRef<'tcx>,\n                             lvalue_pref: LvaluePreference,\n@@ -2138,8 +2180,8 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          sp: Span,\n                                          method_fn_ty: Ty<'tcx>,\n-                                         callee_expr: &ast::Expr,\n-                                         args_no_rcvr: &[P<ast::Expr>],\n+                                         callee_expr: &'tcx ast::Expr,\n+                                         args_no_rcvr: &'tcx [P<ast::Expr>],\n                                          autoref_args: AutorefArgs,\n                                          tuple_arguments: TupleArgumentsFlag,\n                                          expected: Expectation<'tcx>)\n@@ -2194,7 +2236,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   sp: Span,\n                                   fn_inputs: &[Ty<'tcx>],\n                                   expected_arg_tys: &[Ty<'tcx>],\n-                                  args: &[P<ast::Expr>],\n+                                  args: &'tcx [P<ast::Expr>],\n                                   autoref_args: AutorefArgs,\n                                   variadic: bool,\n                                   tuple_arguments: TupleArgumentsFlag) {\n@@ -2462,50 +2504,50 @@ pub fn valid_range_bounds(ccx: &CrateCtxt,\n }\n \n pub fn check_expr_has_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                     expr: &ast::Expr,\n+                                     expr: &'tcx ast::Expr,\n                                      expected: Ty<'tcx>) {\n     check_expr_with_unifier(\n         fcx, expr, ExpectHasType(expected), NoPreference,\n         || demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr)));\n }\n \n fn check_expr_coercable_to_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                          expr: &ast::Expr,\n+                                          expr: &'tcx ast::Expr,\n                                           expected: Ty<'tcx>) {\n     check_expr_with_unifier(\n         fcx, expr, ExpectHasType(expected), NoPreference,\n         || demand::coerce(fcx, expr.span, expected, expr));\n }\n \n-fn check_expr_with_hint<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, expr: &ast::Expr,\n+fn check_expr_with_hint<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, expr: &'tcx ast::Expr,\n                                   expected: Ty<'tcx>) {\n     check_expr_with_unifier(\n         fcx, expr, ExpectHasType(expected), NoPreference,\n         || ())\n }\n \n fn check_expr_with_expectation<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                         expr: &ast::Expr,\n+                                         expr: &'tcx ast::Expr,\n                                          expected: Expectation<'tcx>) {\n     check_expr_with_unifier(\n         fcx, expr, expected, NoPreference,\n         || ())\n }\n \n fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                                         expr: &ast::Expr,\n+                                                         expr: &'tcx ast::Expr,\n                                                          expected: Expectation<'tcx>,\n                                                          lvalue_pref: LvaluePreference)\n {\n     check_expr_with_unifier(fcx, expr, expected, lvalue_pref, || ())\n }\n \n-fn check_expr(fcx: &FnCtxt, expr: &ast::Expr)  {\n+fn check_expr<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, expr: &'tcx ast::Expr)  {\n     check_expr_with_unifier(fcx, expr, NoExpectation, NoPreference, || ())\n }\n \n-fn check_expr_with_lvalue_pref(fcx: &FnCtxt, expr: &ast::Expr,\n-                               lvalue_pref: LvaluePreference)  {\n+fn check_expr_with_lvalue_pref<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, expr: &'tcx ast::Expr,\n+                                        lvalue_pref: LvaluePreference)  {\n     check_expr_with_unifier(fcx, expr, NoExpectation, lvalue_pref, || ())\n }\n \n@@ -2613,7 +2655,7 @@ fn expected_types_for_fn_args<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n /// that there are actually multiple representations for `ty_err`, so avoid\n /// that when err needs to be handled differently.\n fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n-                                        expr: &ast::Expr,\n+                                        expr: &'tcx ast::Expr,\n                                         expected: Expectation<'tcx>,\n                                         lvalue_pref: LvaluePreference,\n                                         unifier: F) where\n@@ -2624,9 +2666,9 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // Checks a method call.\n     fn check_method_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                   expr: &ast::Expr,\n+                                   expr: &'tcx ast::Expr,\n                                    method_name: ast::SpannedIdent,\n-                                   args: &[P<ast::Expr>],\n+                                   args: &'tcx [P<ast::Expr>],\n                                    tps: &[P<ast::Ty>],\n                                    expected: Expectation<'tcx>,\n                                    lvalue_pref: LvaluePreference) {\n@@ -2653,7 +2695,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 method_ty\n             }\n             Err(error) => {\n-                method::report_error(fcx, method_name.span, expr_t, method_name.node.name, error);\n+                method::report_error(fcx, method_name.span, expr_t,\n+                                     method_name.node.name, rcvr, error);\n                 fcx.write_error(expr.id);\n                 fcx.tcx().types.err\n             }\n@@ -2675,9 +2718,9 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     // A generic function for checking the then and else in an if\n     // or if-else.\n     fn check_then_else<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                 cond_expr: &ast::Expr,\n-                                 then_blk: &ast::Block,\n-                                 opt_else_expr: Option<&ast::Expr>,\n+                                 cond_expr: &'tcx ast::Expr,\n+                                 then_blk: &'tcx ast::Block,\n+                                 opt_else_expr: Option<&'tcx ast::Expr>,\n                                  id: ast::NodeId,\n                                  sp: Span,\n                                  expected: Expectation<'tcx>) {\n@@ -2717,12 +2760,12 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     fn lookup_op_method<'a, 'tcx, F>(fcx: &'a FnCtxt<'a, 'tcx>,\n-                                     op_ex: &ast::Expr,\n+                                     op_ex: &'tcx ast::Expr,\n                                      lhs_ty: Ty<'tcx>,\n                                      opname: ast::Name,\n                                      trait_did: Option<ast::DefId>,\n                                      lhs: &'a ast::Expr,\n-                                     rhs: Option<&P<ast::Expr>>,\n+                                     rhs: Option<&'tcx P<ast::Expr>>,\n                                      unbound_method: F,\n                                      autoref_args: AutorefArgs) -> Ty<'tcx> where\n         F: FnOnce(),\n@@ -2803,12 +2846,12 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     // could be either an expr_binop or an expr_assign_binop\n-    fn check_binop(fcx: &FnCtxt,\n-                   expr: &ast::Expr,\n-                   op: ast::BinOp,\n-                   lhs: &ast::Expr,\n-                   rhs: &P<ast::Expr>,\n-                   is_binop_assignment: IsBinopAssignment) {\n+    fn check_binop<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                            expr: &'tcx ast::Expr,\n+                            op: ast::BinOp,\n+                            lhs: &'tcx ast::Expr,\n+                            rhs: &'tcx P<ast::Expr>,\n+                            is_binop_assignment: IsBinopAssignment) {\n         let tcx = fcx.ccx.tcx;\n \n         let lvalue_pref = match is_binop_assignment {\n@@ -2923,11 +2966,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     fn check_user_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                  ex: &ast::Expr,\n-                                  lhs_expr: &ast::Expr,\n+                                  ex: &'tcx ast::Expr,\n+                                  lhs_expr: &'tcx ast::Expr,\n                                   lhs_resolved_t: Ty<'tcx>,\n                                   op: ast::BinOp,\n-                                  rhs: &P<ast::Expr>) -> Ty<'tcx> {\n+                                  rhs: &'tcx P<ast::Expr>) -> Ty<'tcx> {\n         let tcx = fcx.ccx.tcx;\n         let lang = &tcx.lang_items;\n         let (name, trait_did) = match op.node {\n@@ -2966,8 +3009,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                  op_str: &str,\n                                  mname: &str,\n                                  trait_did: Option<ast::DefId>,\n-                                 ex: &ast::Expr,\n-                                 rhs_expr: &ast::Expr,\n+                                 ex: &'tcx ast::Expr,\n+                                 rhs_expr: &'tcx ast::Expr,\n                                  rhs_t: Ty<'tcx>,\n                                  op: ast::UnOp) -> Ty<'tcx> {\n        lookup_op_method(fcx, ex, rhs_t, token::intern(mname),\n@@ -2980,11 +3023,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     // Check field access expressions\n-    fn check_field(fcx: &FnCtxt,\n-                   expr: &ast::Expr,\n-                   lvalue_pref: LvaluePreference,\n-                   base: &ast::Expr,\n-                   field: &ast::SpannedIdent) {\n+    fn check_field<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                            expr: &'tcx ast::Expr,\n+                            lvalue_pref: LvaluePreference,\n+                            base: &'tcx ast::Expr,\n+                            field: &ast::SpannedIdent) {\n         let tcx = fcx.ccx.tcx;\n         check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n@@ -3077,11 +3120,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     // Check tuple index expressions\n-    fn check_tup_field(fcx: &FnCtxt,\n-                       expr: &ast::Expr,\n-                       lvalue_pref: LvaluePreference,\n-                       base: &ast::Expr,\n-                       idx: codemap::Spanned<uint>) {\n+    fn check_tup_field<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                                expr: &'tcx ast::Expr,\n+                                lvalue_pref: LvaluePreference,\n+                                base: &'tcx ast::Expr,\n+                                idx: codemap::Spanned<uint>) {\n         let tcx = fcx.ccx.tcx;\n         check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n@@ -3149,7 +3192,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                 node_id: ast::NodeId,\n                                                 substitutions: &'tcx subst::Substs<'tcx>,\n                                                 field_types: &[ty::field_ty],\n-                                                ast_fields: &[ast::Field],\n+                                                ast_fields: &'tcx [ast::Field],\n                                                 check_completeness: bool,\n                                                 enum_id_opt: Option<ast::DefId>)  {\n         let tcx = fcx.ccx.tcx;\n@@ -3252,12 +3295,12 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n     }\n \n-    fn check_struct_constructor(fcx: &FnCtxt,\n-                                id: ast::NodeId,\n-                                span: codemap::Span,\n-                                class_id: ast::DefId,\n-                                fields: &[ast::Field],\n-                                base_expr: Option<&ast::Expr>) {\n+    fn check_struct_constructor<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                                         id: ast::NodeId,\n+                                         span: codemap::Span,\n+                                         class_id: ast::DefId,\n+                                         fields: &'tcx [ast::Field],\n+                                         base_expr: Option<&'tcx ast::Expr>) {\n         let tcx = fcx.ccx.tcx;\n \n         // Generate the struct type.\n@@ -3294,12 +3337,12 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.write_ty(id, struct_type);\n     }\n \n-    fn check_struct_enum_variant(fcx: &FnCtxt,\n-                                 id: ast::NodeId,\n-                                 span: codemap::Span,\n-                                 enum_id: ast::DefId,\n-                                 variant_id: ast::DefId,\n-                                 fields: &[ast::Field]) {\n+    fn check_struct_enum_variant<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                                          id: ast::NodeId,\n+                                          span: codemap::Span,\n+                                          enum_id: ast::DefId,\n+                                          variant_id: ast::DefId,\n+                                          fields: &'tcx [ast::Field]) {\n         let tcx = fcx.ccx.tcx;\n \n         // Look up the number of type parameters and the raw type, and\n@@ -3324,10 +3367,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.write_ty(id, enum_type);\n     }\n \n-    fn check_struct_fields_on_error(fcx: &FnCtxt,\n-                                    id: ast::NodeId,\n-                                    fields: &[ast::Field],\n-                                    base_expr: &Option<P<ast::Expr>>) {\n+    fn check_struct_fields_on_error<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                                             id: ast::NodeId,\n+                                             fields: &'tcx [ast::Field],\n+                                             base_expr: &'tcx Option<P<ast::Expr>>) {\n         // Make sure to still write the types\n         // otherwise we might ICE\n         fcx.write_error(id);\n@@ -4126,15 +4169,15 @@ impl<'tcx> Repr<'tcx> for Expectation<'tcx> {\n     }\n }\n \n-pub fn check_decl_initializer(fcx: &FnCtxt,\n-                              nid: ast::NodeId,\n-                              init: &ast::Expr)\n+pub fn check_decl_initializer<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                                       nid: ast::NodeId,\n+                                       init: &'tcx ast::Expr)\n {\n     let local_ty = fcx.local_ty(init.span, nid);\n     check_expr_coercable_to_type(fcx, init, local_ty)\n }\n \n-pub fn check_decl_local(fcx: &FnCtxt, local: &ast::Local)  {\n+pub fn check_decl_local<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, local: &'tcx ast::Local)  {\n     let tcx = fcx.ccx.tcx;\n \n     let t = fcx.local_ty(local.span, local.id);\n@@ -4159,7 +4202,7 @@ pub fn check_decl_local(fcx: &FnCtxt, local: &ast::Local)  {\n     }\n }\n \n-pub fn check_stmt(fcx: &FnCtxt, stmt: &ast::Stmt)  {\n+pub fn check_stmt<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, stmt: &'tcx ast::Stmt)  {\n     let node_id;\n     let mut saw_bot = false;\n     let mut saw_err = false;\n@@ -4204,7 +4247,7 @@ pub fn check_stmt(fcx: &FnCtxt, stmt: &ast::Stmt)  {\n     }\n }\n \n-pub fn check_block_no_value(fcx: &FnCtxt, blk: &ast::Block)  {\n+pub fn check_block_no_value<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, blk: &'tcx ast::Block)  {\n     check_block_with_expected(fcx, blk, ExpectHasType(ty::mk_nil(fcx.tcx())));\n     let blkty = fcx.node_ty(blk.id);\n     if ty::type_is_error(blkty) {\n@@ -4216,7 +4259,7 @@ pub fn check_block_no_value(fcx: &FnCtxt, blk: &ast::Block)  {\n }\n \n fn check_block_with_expected<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                       blk: &ast::Block,\n+                                       blk: &'tcx ast::Block,\n                                        expected: Expectation<'tcx>) {\n     let prev = {\n         let mut fcx_ps = fcx.ps.borrow_mut();\n@@ -4299,17 +4342,17 @@ fn check_block_with_expected<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n /// length expression in a fixed-length vector, but someday it might be\n /// extended to type-level numeric literals.\n fn check_const_in_type<'a,'tcx>(ccx: &'a CrateCtxt<'a,'tcx>,\n-                                expr: &ast::Expr,\n+                                expr: &'tcx ast::Expr,\n                                 expected_type: Ty<'tcx>) {\n     let inh = static_inherited_fields(ccx);\n     let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(expected_type), expr.id);\n     check_const_with_ty(&fcx, expr.span, expr, expected_type);\n }\n \n-fn check_const(ccx: &CrateCtxt,\n-               sp: Span,\n-               e: &ast::Expr,\n-               id: ast::NodeId) {\n+fn check_const<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                        sp: Span,\n+                        e: &'tcx ast::Expr,\n+                        id: ast::NodeId) {\n     let inh = static_inherited_fields(ccx);\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n     let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), e.id);\n@@ -4319,7 +4362,7 @@ fn check_const(ccx: &CrateCtxt,\n \n fn check_const_with_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                  _: Span,\n-                                 e: &ast::Expr,\n+                                 e: &'tcx ast::Expr,\n                                  declty: Ty<'tcx>) {\n     // Gather locals in statics (because of block expressions).\n     // This is technically unnecessary because locals in static items are forbidden,\n@@ -4420,10 +4463,10 @@ pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n     }\n }\n \n-pub fn check_enum_variants(ccx: &CrateCtxt,\n-                           sp: Span,\n-                           vs: &[P<ast::Variant>],\n-                           id: ast::NodeId) {\n+pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                                    sp: Span,\n+                                    vs: &'tcx [P<ast::Variant>],\n+                                    id: ast::NodeId) {\n \n     fn disr_in_range(ccx: &CrateCtxt,\n                      ty: attr::IntType,\n@@ -4453,7 +4496,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n     }\n \n     fn do_check<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                          vs: &[P<ast::Variant>],\n+                          vs: &'tcx [P<ast::Variant>],\n                           id: ast::NodeId,\n                           hint: attr::ReprAttr)\n                           -> Vec<Rc<ty::VariantInfo<'tcx>>> {"}, {"sha": "f7babadd41fd18ebcc56acbe396530d1e576172f", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 177, "deletions": 36, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -46,7 +46,9 @@ use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n use middle::ty::{self};\n use middle::infer::{InferCtxt, UpvarRegion};\n+use std::collections::HashSet;\n use syntax::ast;\n+use syntax::ast_util;\n use syntax::codemap::Span;\n use syntax::visit::{self, Visitor};\n use util::ppaux::Repr;\n@@ -56,20 +58,26 @@ use util::ppaux::Repr;\n \n pub fn closure_analyze_fn(fcx: &FnCtxt,\n                           _id: ast::NodeId,\n-                          decl: &ast::FnDecl,\n-                          body: &ast::Block) {\n+                          _decl: &ast::FnDecl,\n+                          body: &ast::Block)\n+{\n     let mut seed = SeedBorrowKind::new(fcx);\n     seed.visit_block(body);\n+    let closures_with_inferred_kinds = seed.closures_with_inferred_kinds;\n \n-    let mut adjust = AdjustBorrowKind::new(fcx);\n-    adjust.analyze_fn(decl, body);\n+    let mut adjust = AdjustBorrowKind::new(fcx, &closures_with_inferred_kinds);\n+    adjust.visit_block(body);\n+\n+    // it's our job to process these.\n+    assert!(fcx.inh.deferred_call_resolutions.borrow().is_empty());\n }\n \n ///////////////////////////////////////////////////////////////////////////\n // SEED BORROW KIND\n \n struct SeedBorrowKind<'a,'tcx:'a> {\n     fcx: &'a FnCtxt<'a,'tcx>,\n+    closures_with_inferred_kinds: HashSet<ast::NodeId>,\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for SeedBorrowKind<'a, 'tcx> {\n@@ -105,7 +113,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for SeedBorrowKind<'a, 'tcx> {\n \n impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n     fn new(fcx: &'a FnCtxt<'a,'tcx>) -> SeedBorrowKind<'a,'tcx> {\n-        SeedBorrowKind { fcx: fcx }\n+        SeedBorrowKind { fcx: fcx, closures_with_inferred_kinds: HashSet::new() }\n     }\n \n     fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n@@ -121,6 +129,14 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n                      capture_clause: ast::CaptureClause,\n                      _body: &ast::Block)\n     {\n+        let closure_def_id = ast_util::local_def(expr.id);\n+        if !self.fcx.inh.closure_kinds.borrow().contains_key(&closure_def_id) {\n+            self.closures_with_inferred_kinds.insert(expr.id);\n+            self.fcx.inh.closure_kinds.borrow_mut().insert(closure_def_id, ty::FnClosureKind);\n+            debug!(\"check_closure: adding closure_id={} to closures_with_inferred_kinds\",\n+                   closure_def_id.repr(self.tcx()));\n+        }\n+\n         ty::with_freevars(self.tcx(), expr.id, |freevars| {\n             for freevar in freevars.iter() {\n                 let var_node_id = freevar.def.local_node_id();\n@@ -151,29 +167,78 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n // ADJUST BORROW KIND\n \n struct AdjustBorrowKind<'a,'tcx:'a> {\n-    fcx: &'a FnCtxt<'a,'tcx>\n+    fcx: &'a FnCtxt<'a,'tcx>,\n+    closures_with_inferred_kinds: &'a HashSet<ast::NodeId>,\n }\n \n impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n-    fn new(fcx: &'a FnCtxt<'a,'tcx>) -> AdjustBorrowKind<'a,'tcx> {\n-        AdjustBorrowKind { fcx: fcx }\n+    fn new(fcx: &'a FnCtxt<'a,'tcx>,\n+           closures_with_inferred_kinds: &'a HashSet<ast::NodeId>)\n+           -> AdjustBorrowKind<'a,'tcx> {\n+        AdjustBorrowKind { fcx: fcx, closures_with_inferred_kinds: closures_with_inferred_kinds }\n     }\n \n     fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n         self.fcx.tcx()\n     }\n \n-    fn analyze_fn(&mut self, decl: &ast::FnDecl, body: &ast::Block) {\n+    fn analyze_closure(&mut self, id: ast::NodeId, decl: &ast::FnDecl, body: &ast::Block) {\n         /*!\n          * Analysis starting point.\n          */\n \n         self.visit_block(body);\n \n-        debug!(\"analyzing fn body with id {}\", body.id);\n+        debug!(\"analyzing closure `{}` with fn body id `{}`\", id, body.id);\n \n         let mut euv = euv::ExprUseVisitor::new(self, self.fcx);\n         euv.walk_fn(decl, body);\n+\n+        // If we had not yet settled on a closure kind for this closure,\n+        // then we should have by now. Process and remove any deferred resolutions.\n+        //\n+        // Interesting fact: all calls to this closure must come\n+        // *after* its definition.  Initially, I thought that some\n+        // kind of fixed-point iteration would be required, due to the\n+        // possibility of twisted examples like this one:\n+        //\n+        // ```rust\n+        // let mut closure0 = None;\n+        // let vec = vec!(1, 2, 3);\n+        //\n+        // loop {\n+        //     {\n+        //         let closure1 = || {\n+        //             match closure0.take() {\n+        //                 Some(c) => {\n+        //                     return c(); // (*) call to `closure0` before it is defined\n+        //                 }\n+        //                 None => { }\n+        //             }\n+        //         };\n+        //         closure1();\n+        //     }\n+        //\n+        //     closure0 = || vec;\n+        // }\n+        // ```\n+        //\n+        // However, this turns out to be wrong. Examples like this\n+        // fail to compile because the type of the variable `c` above\n+        // is an inference variable.  And in fact since closure types\n+        // cannot be written, there is no way to make this example\n+        // work without a boxed closure. This implies that we can't\n+        // have two closures that recursively call one another without\n+        // some form of boxing (and hence explicit writing of a\n+        // closure kind) involved. Huzzah. -nmatsakis\n+        let closure_def_id = ast_util::local_def(id);\n+        if self.closures_with_inferred_kinds.contains(&id) {\n+            let mut deferred_call_resolutions =\n+                self.fcx.remove_deferred_call_resolutions(closure_def_id);\n+            for deferred_call_resolution in deferred_call_resolutions.iter_mut() {\n+                deferred_call_resolution.resolve(self.fcx);\n+            }\n+        }\n     }\n \n     fn adjust_upvar_borrow_kind_for_consume(&self,\n@@ -198,13 +263,29 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n         match guarantor.cat {\n             mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n             mc::cat_deref(_, _, mc::Implicit(..)) => {\n-                if let mc::NoteUpvarRef(upvar_id) = cmt.note {\n-                    debug!(\"adjust_upvar_borrow_kind_for_consume: \\\n-                            setting upvar_id={:?} to by value\",\n-                           upvar_id);\n+                match cmt.note {\n+                    mc::NoteUpvarRef(upvar_id) => {\n+                        debug!(\"adjust_upvar_borrow_kind_for_consume: \\\n+                                setting upvar_id={:?} to by value\",\n+                               upvar_id);\n \n-                    let mut upvar_capture_map = self.fcx.inh.upvar_capture_map.borrow_mut();\n-                    upvar_capture_map.insert(upvar_id, ty::UpvarCapture::ByValue);\n+                        // to move out of an upvar, this must be a FnOnce closure\n+                        self.adjust_closure_kind(upvar_id.closure_expr_id, ty::FnOnceClosureKind);\n+\n+                        let mut upvar_capture_map = self.fcx.inh.upvar_capture_map.borrow_mut();\n+                        upvar_capture_map.insert(upvar_id, ty::UpvarCapture::ByValue);\n+                    }\n+                    mc::NoteClosureEnv(upvar_id) => {\n+                        // we get just a closureenv ref if this is a\n+                        // `move` closure, or if the upvar has already\n+                        // been inferred to by-value. In any case, we\n+                        // must still adjust the kind of the closure\n+                        // to be a FnOnce closure to permit moves out\n+                        // of the environment.\n+                        self.adjust_closure_kind(upvar_id.closure_expr_id, ty::FnOnceClosureKind);\n+                    }\n+                    mc::NoteNone => {\n+                    }\n                 }\n             }\n             _ => { }\n@@ -229,15 +310,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n \n             mc::cat_deref(base, _, mc::BorrowedPtr(..)) |\n             mc::cat_deref(base, _, mc::Implicit(..)) => {\n-                if let mc::NoteUpvarRef(upvar_id) = cmt.note {\n-                    // if this is an implicit deref of an\n-                    // upvar, then we need to modify the\n-                    // borrow_kind of the upvar to make sure it\n-                    // is inferred to mutable if necessary\n-                    let mut upvar_capture_map = self.fcx.inh.upvar_capture_map.borrow_mut();\n-                    let ub = &mut upvar_capture_map[upvar_id];\n-                    self.adjust_upvar_borrow_kind(upvar_id, ub, ty::MutBorrow);\n-                } else {\n+                if !self.try_adjust_upvar_deref(&cmt.note, ty::MutBorrow) {\n                     // assignment to deref of an `&mut`\n                     // borrowed pointer implies that the\n                     // pointer itself must be unique, but not\n@@ -271,15 +344,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n \n             mc::cat_deref(base, _, mc::BorrowedPtr(..)) |\n             mc::cat_deref(base, _, mc::Implicit(..)) => {\n-                if let mc::NoteUpvarRef(upvar_id) = cmt.note {\n-                    // if this is an implicit deref of an\n-                    // upvar, then we need to modify the\n-                    // borrow_kind of the upvar to make sure it\n-                    // is inferred to unique if necessary\n-                    let mut ub = self.fcx.inh.upvar_capture_map.borrow_mut();\n-                    let ub = &mut ub[upvar_id];\n-                    self.adjust_upvar_borrow_kind(upvar_id, ub, ty::UniqueImmBorrow);\n-                } else {\n+                if !self.try_adjust_upvar_deref(&cmt.note, ty::UniqueImmBorrow) {\n                     // for a borrowed pointer to be unique, its\n                     // base must be unique\n                     self.adjust_upvar_borrow_kind_for_unique(base);\n@@ -295,6 +360,48 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n         }\n     }\n \n+    fn try_adjust_upvar_deref(&self,\n+                              note: &mc::Note,\n+                              borrow_kind: ty::BorrowKind)\n+                              -> bool\n+    {\n+        assert!(match borrow_kind {\n+            ty::MutBorrow => true,\n+            ty::UniqueImmBorrow => true,\n+\n+            // imm borrows never require adjusting any kinds, so we don't wind up here\n+            ty::ImmBorrow => false,\n+        });\n+\n+        match *note {\n+            mc::NoteUpvarRef(upvar_id) => {\n+                // if this is an implicit deref of an\n+                // upvar, then we need to modify the\n+                // borrow_kind of the upvar to make sure it\n+                // is inferred to mutable if necessary\n+                let mut upvar_capture_map = self.fcx.inh.upvar_capture_map.borrow_mut();\n+                let ub = &mut upvar_capture_map[upvar_id];\n+                self.adjust_upvar_borrow_kind(upvar_id, ub, borrow_kind);\n+\n+                // also need to be in an FnMut closure since this is not an ImmBorrow\n+                self.adjust_closure_kind(upvar_id.closure_expr_id, ty::FnMutClosureKind);\n+\n+                true\n+            }\n+            mc::NoteClosureEnv(upvar_id) => {\n+                // this kind of deref occurs in a `move` closure, or\n+                // for a by-value upvar; in either case, to mutate an\n+                // upvar, we need to be an FnMut closure\n+                self.adjust_closure_kind(upvar_id.closure_expr_id, ty::FnMutClosureKind);\n+\n+                true\n+            }\n+            mc::NoteNone => {\n+                false\n+            }\n+        }\n+    }\n+\n     /// We infer the borrow_kind with which to borrow upvars in a stack closure. The borrow_kind\n     /// basically follows a lattice of `imm < unique-imm < mut`, moving from left to right as needed\n     /// (but never right to left). Here the argument `mutbl` is the borrow_kind that is required by\n@@ -328,6 +435,40 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n             }\n         }\n     }\n+\n+    fn adjust_closure_kind(&self,\n+                           closure_id: ast::NodeId,\n+                           new_kind: ty::ClosureKind) {\n+        debug!(\"adjust_closure_kind(closure_id={}, new_kind={:?})\",\n+               closure_id, new_kind);\n+\n+        if !self.closures_with_inferred_kinds.contains(&closure_id) {\n+            return;\n+        }\n+\n+        let closure_def_id = ast_util::local_def(closure_id);\n+        let mut closure_kinds = self.fcx.inh.closure_kinds.borrow_mut();\n+        let existing_kind = closure_kinds[closure_def_id];\n+\n+        debug!(\"adjust_closure_kind: closure_id={}, existing_kind={:?}, new_kind={:?}\",\n+               closure_id, existing_kind, new_kind);\n+\n+        match (existing_kind, new_kind) {\n+            (ty::FnClosureKind, ty::FnClosureKind) |\n+            (ty::FnMutClosureKind, ty::FnClosureKind) |\n+            (ty::FnMutClosureKind, ty::FnMutClosureKind) |\n+            (ty::FnOnceClosureKind, _) => {\n+                // no change needed\n+            }\n+\n+            (ty::FnClosureKind, ty::FnMutClosureKind) |\n+            (ty::FnClosureKind, ty::FnOnceClosureKind) |\n+            (ty::FnMutClosureKind, ty::FnOnceClosureKind) => {\n+                // new kind is stronger than the old kind\n+                closure_kinds.insert(closure_def_id, new_kind);\n+            }\n+        }\n+    }\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for AdjustBorrowKind<'a, 'tcx> {\n@@ -336,14 +477,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for AdjustBorrowKind<'a, 'tcx> {\n                 decl: &'v ast::FnDecl,\n                 body: &'v ast::Block,\n                 span: Span,\n-                _id: ast::NodeId)\n+                id: ast::NodeId)\n     {\n         match fn_kind {\n             visit::FkItemFn(..) | visit::FkMethod(..) => {\n                 // ignore nested fn items\n             }\n             visit::FkFnBlock => {\n-                self.analyze_fn(decl, body);\n+                self.analyze_closure(id, decl, body);\n                 visit::walk_fn(self, fn_kind, decl, body, span);\n             }\n         }"}, {"sha": "5cf71a9be6a024677e458e3dc7f4bba8a6c9c811", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -277,12 +277,22 @@ fn check_object_type_binds_all_associated_types<'tcx>(tcx: &ty::ctxt<'tcx>,\n     }\n }\n \n-pub fn select_all_fcx_obligations_or_error(fcx: &FnCtxt) {\n-    debug!(\"select_all_fcx_obligations_or_error\");\n+pub fn select_all_fcx_obligations_and_apply_defaults(fcx: &FnCtxt) {\n+    debug!(\"select_all_fcx_obligations_and_apply_defaults\");\n \n     select_fcx_obligations_where_possible(fcx);\n     fcx.default_type_parameters();\n+    select_fcx_obligations_where_possible(fcx);\n+}\n+\n+pub fn select_all_fcx_obligations_or_error(fcx: &FnCtxt) {\n+    debug!(\"select_all_fcx_obligations_or_error\");\n+\n+    // upvar inference should have ensured that all deferrred call\n+    // resolutions are handled by now.\n+    assert!(fcx.inh.deferred_call_resolutions.borrow().is_empty());\n \n+    select_all_fcx_obligations_and_apply_defaults(fcx);\n     let mut fulfillment_cx = fcx.inh.fulfillment_cx.borrow_mut();\n     let r = fulfillment_cx.select_all_or_error(fcx.infcx(), fcx);\n     match r {"}, {"sha": "0eaecf8ac0574c6c52f37f57bb966edaeaa528d2", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -204,14 +204,13 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             return\n         }\n \n-        for (def_id, closure) in self.fcx.inh.closures.borrow().iter() {\n-            let closure_ty = self.resolve(&closure.closure_type,\n-                                          ResolvingClosure(*def_id));\n-            let closure = ty::Closure {\n-                closure_type: closure_ty,\n-                kind: closure.kind,\n-            };\n-            self.fcx.tcx().closures.borrow_mut().insert(*def_id, closure);\n+        for (def_id, closure_ty) in self.fcx.inh.closure_tys.borrow().iter() {\n+            let closure_ty = self.resolve(closure_ty, ResolvingClosure(*def_id));\n+            self.fcx.tcx().closure_tys.borrow_mut().insert(*def_id, closure_ty);\n+        }\n+\n+        for (def_id, &closure_kind) in self.fcx.inh.closure_kinds.borrow().iter() {\n+            self.fcx.tcx().closure_kinds.borrow_mut().insert(*def_id, closure_kind);\n         }\n     }\n "}, {"sha": "7398e6f1089bcddaf76b9ed95ea01ec2cb2d7348", "filename": "src/test/compile-fail/unboxed-closures-failed-recursive-fn-1.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Fcompile-fail%2Funboxed-closures-failed-recursive-fn-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Fcompile-fail%2Funboxed-closures-failed-recursive-fn-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-failed-recursive-fn-1.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Various unsuccessful attempts to put the unboxed closure kind\n+// inference into an awkward position that might require fixed point\n+// iteration (basically where inferring the kind of a closure `c`\n+// would require knowing the kind of `c`). I currently believe this is\n+// impossible.\n+\n+fn a() {\n+    // This case of recursion wouldn't even require fixed-point\n+    // iteration, but it still doesn't work. The weird structure with\n+    // the `Option` is to avoid giving any useful hints about the `Fn`\n+    // kind via the expected type.\n+    let mut factorial: Option<Box<Fn(u32) -> u32>> = None;\n+\n+    let f = |x: u32| -> u32 {\n+        let g = factorial.as_ref().unwrap();\n+        if x == 0 {1} else {x * g(x-1)}\n+    };\n+\n+    factorial = Some(Box::new(f));\n+    //~^ ERROR cannot assign to `factorial` because it is borrowed\n+}\n+\n+fn main() { }"}, {"sha": "f40c8fc7474947a01db763c316ab46afff760cd1", "filename": "src/test/compile-fail/unboxed-closures-failed-recursive-fn-2.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Fcompile-fail%2Funboxed-closures-failed-recursive-fn-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Fcompile-fail%2Funboxed-closures-failed-recursive-fn-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-failed-recursive-fn-2.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Various unsuccessful attempts to put the unboxed closure kind\n+// inference into an awkward position that might require fixed point\n+// iteration (basically where inferring the kind of a closure `c`\n+// would require knowing the kind of `c`). I currently believe this is\n+// impossible.\n+\n+fn a() {\n+    let mut closure0 = None;\n+    let vec = vec!(1, 2, 3);\n+\n+    loop {\n+        {\n+            let closure1 = || {\n+                match closure0.take() {\n+                    Some(c) => {\n+                        return c();\n+                        //~^ ERROR the type of this value must be known in this context\n+                    }\n+                    None => { }\n+                }\n+            };\n+            closure1();\n+        }\n+\n+        closure0 = || vec;\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "f993b8fa8c4d1ec92ade3857b6c6c7227a23170e", "filename": "src/test/compile-fail/unboxed-closures-infer-explicit-call-too-early.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-explicit-call-too-early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-explicit-call-too-early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-explicit-call-too-early.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+\n+fn main() {\n+    let mut zero = || {};\n+    let () = zero.call_mut(());\n+    //~^ ERROR we have not yet inferred what kind of closure it is\n+}\n+"}, {"sha": "afbc141b5d246aa8390d13001e41c26ede2e424e", "filename": "src/test/compile-fail/unboxed-closures-infer-fnmut-calling-fnmut-no-mut.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-fnmut-calling-fnmut-no-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-fnmut-calling-fnmut-no-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-fnmut-calling-fnmut-no-mut.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to infer a suitable kind for this closure\n+// that is just called (`FnMut`).\n+\n+fn main() {\n+    let mut counter = 0;\n+\n+    // Here this must be inferred to FnMut so that it can mutate counter,\n+    // but we forgot the mut.\n+    let tick1 = || {\n+        counter += 1;\n+    };\n+\n+    // In turn, tick2 must be inferred to FnMut so that it can call\n+    // tick1, but we forgot the mut. The error message we currently\n+    // get seems... suboptimal.\n+    let tick2 = || { //~ ERROR closure cannot assign to immutable local variable `tick1`\n+        tick1();\n+    };\n+\n+    tick2(); //~ ERROR cannot borrow\n+}\n+"}, {"sha": "9e4ed30799686b80686f21f102e41a369b8d76bb", "filename": "src/test/compile-fail/unboxed-closures-infer-fnmut-missing-mut.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-fnmut-missing-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-fnmut-missing-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-fnmut-missing-mut.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to infer a suitable kind for this closure\n+// that is just called (`FnMut`).\n+\n+fn main() {\n+    let mut counter = 0;\n+    let tick = || counter += 1;\n+    tick(); //~ ERROR cannot borrow immutable local variable `tick` as mutable\n+}"}, {"sha": "de17d25b4c360fc8ef0a70bd8743d99671f0c4fd", "filename": "src/test/compile-fail/unboxed-closures-infer-fnmut-move-missing-mut.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-fnmut-move-missing-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-fnmut-move-missing-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-fnmut-move-missing-mut.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to infer a suitable kind for this closure\n+// that is just called (`FnMut`).\n+\n+fn main() {\n+    let mut counter = 0;\n+    let tick = move || counter += 1;\n+    tick(); //~ ERROR cannot borrow immutable local variable `tick` as mutable\n+}"}, {"sha": "0050fbdde2639eb7fe8b0d207efd950de625b195", "filename": "src/test/compile-fail/unboxed-closures-infer-fnonce-call-twice.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-fnonce-call-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-fnonce-call-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-fnonce-call-twice.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to infer a suitable kind for this closure\n+// that is just called (`FnMut`).\n+\n+use std::mem;\n+\n+fn main() {\n+    let mut counter: Vec<i32> = Vec::new();\n+    let tick = || mem::drop(counter);\n+    tick();\n+    tick(); //~ ERROR use of moved value: `tick`\n+}"}, {"sha": "f9709b8c596974c4a0e8d2e58c47d573c5e9cc65", "filename": "src/test/compile-fail/unboxed-closures-infer-fnonce-move-call-twice.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-fnonce-move-call-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-fnonce-move-call-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-fnonce-move-call-twice.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to infer a suitable kind for this closure\n+// that is just called (`FnMut`).\n+\n+use std::mem;\n+\n+fn main() {\n+    let mut counter: Vec<i32> = Vec::new();\n+    let tick = move || mem::drop(counter);\n+    tick();\n+    tick(); //~ ERROR use of moved value: `tick`\n+}"}, {"sha": "215b2c6798e40c80f30333dd4edbc1a34120b3b6", "filename": "src/test/compile-fail/unboxed-closures-recursive-fn-using-fn-mut.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Fcompile-fail%2Funboxed-closures-recursive-fn-using-fn-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Fcompile-fail%2Funboxed-closures-recursive-fn-using-fn-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-recursive-fn-using-fn-mut.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(core,unboxed_closures)]\n+\n+use std::marker::CovariantType;\n+\n+// A erroneous variant of `run-pass/unboxed_closures-infer-recursive-fn.rs`\n+// where we attempt to perform mutation in the recursive function. This fails to compile\n+// because it winds up requiring `FnMut` which enforces linearity.\n+\n+struct YCombinator<F,A,R> {\n+    func: F,\n+    marker: CovariantType<(A,R)>,\n+}\n+\n+impl<F,A,R> YCombinator<F,A,R> {\n+    fn new(f: F) -> YCombinator<F,A,R> {\n+        YCombinator { func: f, marker: CovariantType }\n+    }\n+}\n+\n+impl<A,R,F : FnMut(&mut FnMut(A) -> R, A) -> R> FnMut<(A,)> for YCombinator<F,A,R> {\n+    type Output = R;\n+\n+    extern \"rust-call\" fn call_mut(&mut self, (arg,): (A,)) -> R {\n+        (self.func)(self, arg)\n+            //~^ ERROR cannot borrow `*self` as mutable more than once at a time\n+    }\n+}\n+\n+fn main() {\n+    let mut counter = 0;\n+    let factorial = |recur: &mut FnMut(u32) -> u32, arg: u32| -> u32 {\n+        counter += 1;\n+        if arg == 0 {1} else {arg * recur(arg-1)}\n+    };\n+    let mut factorial: YCombinator<_,u32,u32> = YCombinator::new(factorial);\n+    let mut r = factorial(10);\n+    assert_eq!(3628800, r);\n+}"}, {"sha": "09b8c8f4454b5ea3e11a9e1ba9134b1063fb18ea", "filename": "src/test/run-pass/unboxed-closures-infer-fnmut-calling-fnmut.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-fnmut-calling-fnmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-fnmut-calling-fnmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-fnmut-calling-fnmut.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to infer a suitable kind for this closure\n+// that is just called (`FnMut`).\n+\n+fn main() {\n+    let mut counter = 0;\n+\n+    {\n+        // Here this must be inferred to FnMut so that it can mutate counter:\n+        let mut tick1 = || counter += 1;\n+\n+        // In turn, tick2 must be inferred to FnMut so that it can call tick1:\n+        let mut tick2 = || { tick1(); tick1(); };\n+\n+        tick2();\n+    }\n+\n+    assert_eq!(counter, 2);\n+}\n+"}, {"sha": "794527249bffaaf55d9da303bbd046c70de181e9", "filename": "src/test/run-pass/unboxed-closures-infer-fnmut-move.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-fnmut-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-fnmut-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-fnmut-move.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to infer a suitable kind for this `move`\n+// closure that is just called (`FnMut`).\n+\n+fn main() {\n+    let mut counter = 0;\n+\n+    let v = {\n+        let mut tick = move || { counter += 1; counter };\n+        tick();\n+        tick()\n+    };\n+\n+    assert_eq!(counter, 0);\n+    assert_eq!(v, 2);\n+}"}, {"sha": "67f36b9a9203cfa0fe04b69df050ef7eb7665151", "filename": "src/test/run-pass/unboxed-closures-infer-fnmut.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-fnmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-fnmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-fnmut.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to infer a suitable kind for this closure\n+// that is just called (`FnMut`).\n+\n+fn main() {\n+    let mut counter = 0;\n+\n+    {\n+        let mut tick = || counter += 1;\n+        tick();\n+        tick();\n+    }\n+\n+    assert_eq!(counter, 2);\n+}"}, {"sha": "9f8fc80819bfd39331be9016d3de78e9ad4264ab", "filename": "src/test/run-pass/unboxed-closures-infer-fnonce-move.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-fnonce-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-fnonce-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-fnonce-move.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unsafe_destructor)]\n+\n+// Test that we are able to infer a suitable kind for this `move`\n+// closure that is just called (`FnOnce`).\n+\n+use std::mem;\n+\n+struct DropMe<'a>(&'a mut i32);\n+\n+#[unsafe_destructor]\n+impl<'a> Drop for DropMe<'a> {\n+    fn drop(&mut self) {\n+        *self.0 += 1;\n+    }\n+}\n+\n+fn main() {\n+    let mut counter = 0;\n+\n+    {\n+        let drop_me = DropMe(&mut counter);\n+        let tick = move || mem::drop(drop_me);\n+        tick();\n+    }\n+\n+    assert_eq!(counter, 1);\n+}"}, {"sha": "f0f10139c5b86fa3d4570789098fd1c4d5c58b9e", "filename": "src/test/run-pass/unboxed-closures-infer-fnonce.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-fnonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-fnonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-fnonce.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unsafe_destructor)]\n+\n+// Test that we are able to infer a suitable kind for this closure\n+// that is just called (`FnOnce`).\n+\n+use std::mem;\n+\n+struct DropMe<'a>(&'a mut i32);\n+\n+#[unsafe_destructor]\n+impl<'a> Drop for DropMe<'a> {\n+    fn drop(&mut self) {\n+        *self.0 += 1;\n+    }\n+}\n+\n+fn main() {\n+    let mut counter = 0;\n+\n+    {\n+        let drop_me = DropMe(&mut counter);\n+        let tick = || mem::drop(drop_me);\n+        tick();\n+    }\n+\n+    assert_eq!(counter, 1);\n+}"}, {"sha": "1f9b821178c46f43eac85ce007b66afc76a87761", "filename": "src/test/run-pass/unboxed-closures-infer-recursive-fn.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-recursive-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab8d5dadd72b8d44cc79a1756c0a00fec619efa/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-recursive-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-recursive-fn.rs?ref=0ab8d5dadd72b8d44cc79a1756c0a00fec619efa", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(core,unboxed_closures)]\n+\n+use std::marker::CovariantType;\n+\n+// Test that we are able to infer a suitable kind for a \"recursive\"\n+// closure.  As far as I can tell, coding up a recursive closure\n+// requires the good ol' [Y Combinator].\n+//\n+// [Y Combinator]: http://en.wikipedia.org/wiki/Fixed-point_combinator#Y_combinator\n+\n+struct YCombinator<F,A,R> {\n+    func: F,\n+    marker: CovariantType<(A,R)>,\n+}\n+\n+impl<F,A,R> YCombinator<F,A,R> {\n+    fn new(f: F) -> YCombinator<F,A,R> {\n+        YCombinator { func: f, marker: CovariantType }\n+    }\n+}\n+\n+impl<A,R,F : Fn(&Fn(A) -> R, A) -> R> Fn<(A,)> for YCombinator<F,A,R> {\n+    type Output = R;\n+\n+    extern \"rust-call\" fn call(&self, (arg,): (A,)) -> R {\n+        (self.func)(self, arg)\n+    }\n+}\n+\n+fn main() {\n+    let factorial = |recur: &Fn(u32) -> u32, arg: u32| -> u32 {\n+        if arg == 0 {1} else {arg * recur(arg-1)}\n+    };\n+    let factorial: YCombinator<_,u32,u32> = YCombinator::new(factorial);\n+    let r = factorial(10);\n+    assert_eq!(3628800, r);\n+}"}]}