{"sha": "99111606fcda4fdb0646e4f7ee0f6cbcb76fb84a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5MTExNjA2ZmNkYTRmZGIwNjQ2ZTRmN2VlMGY2Y2JjYjc2ZmI4NGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-11T21:54:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-11T21:54:31Z"}, "message": "Auto merge of #73761 - rijenkii:master, r=KodrAus\n\nAdd `peek` and `peek_from` to `UnixStream` and `UnixDatagram`\n\nThis is my first PR, so I'm sure I've done some things wrong.\n\nThis PR:\n  * adds `peek` function to `UnixStream`;\n  * adds `peek` and `peek_from` to `UnixDatagram`;\n  * moves `UnixDatagram::recv_from` implementation to a private function `recv_from_flags`, as `peek_from` uses the same code, just with different flags.\n\nI've taken the documentation from `TcpStream` and `UdpStream`, so it may or may not make sense (I'm bad with english words).\nAlso, I'm not sure what I should write in the `unstable` attribute, so I've made up the name and set the issue to \"none\".\n\nCloses #68565.", "tree": {"sha": "51009f5f6a8807768441b04360e1e7891e617aa0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51009f5f6a8807768441b04360e1e7891e617aa0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99111606fcda4fdb0646e4f7ee0f6cbcb76fb84a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99111606fcda4fdb0646e4f7ee0f6cbcb76fb84a", "html_url": "https://github.com/rust-lang/rust/commit/99111606fcda4fdb0646e4f7ee0f6cbcb76fb84a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99111606fcda4fdb0646e4f7ee0f6cbcb76fb84a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc57bd8c7e3e28f8bed4fced3973bfe04949918f", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc57bd8c7e3e28f8bed4fced3973bfe04949918f", "html_url": "https://github.com/rust-lang/rust/commit/bc57bd8c7e3e28f8bed4fced3973bfe04949918f"}, {"sha": "64b8fd7920e177023364c7d9dada0d3f8fad3911", "url": "https://api.github.com/repos/rust-lang/rust/commits/64b8fd7920e177023364c7d9dada0d3f8fad3911", "html_url": "https://github.com/rust-lang/rust/commit/64b8fd7920e177023364c7d9dada0d3f8fad3911"}], "stats": {"total": 212, "additions": 192, "deletions": 20}, "files": [{"sha": "3fbd0cb58b120a972089e5ba3accb6c358d5a0cd", "filename": "library/std/src/sys/unix/ext/net.rs", "status": "modified", "additions": 112, "deletions": 20, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/99111606fcda4fdb0646e4f7ee0f6cbcb76fb84a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99111606fcda4fdb0646e4f7ee0f6cbcb76fb84a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet.rs?ref=99111606fcda4fdb0646e4f7ee0f6cbcb76fb84a", "patch": "@@ -594,6 +594,32 @@ impl UnixStream {\n     pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n         self.0.shutdown(how)\n     }\n+\n+    /// Receives data on the socket from the remote address to which it is\n+    /// connected, without removing that data from the queue. On success,\n+    /// returns the number of bytes peeked.\n+    ///\n+    /// Successive calls return the same data. This is accomplished by passing\n+    /// `MSG_PEEK` as a flag to the underlying `recv` system call.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_peek)]\n+    ///\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     let mut buf = [0; 10];\n+    ///     let len = socket.peek(&mut buf).expect(\"peek failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_peek\", issue = \"none\")]\n+    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.peek(buf)\n+    }\n }\n \n #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n@@ -1291,6 +1317,33 @@ impl UnixDatagram {\n         SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n     }\n \n+    fn recv_from_flags(\n+        &self,\n+        buf: &mut [u8],\n+        flags: libc::c_int,\n+    ) -> io::Result<(usize, SocketAddr)> {\n+        let mut count = 0;\n+        let addr = SocketAddr::new(|addr, len| unsafe {\n+            count = libc::recvfrom(\n+                *self.0.as_inner(),\n+                buf.as_mut_ptr() as *mut _,\n+                buf.len(),\n+                flags,\n+                addr,\n+                len,\n+            );\n+            if count > 0 {\n+                1\n+            } else if count == 0 {\n+                0\n+            } else {\n+                -1\n+            }\n+        })?;\n+\n+        Ok((count as usize, addr))\n+    }\n+\n     /// Receives data from the socket.\n     ///\n     /// On success, returns the number of bytes read and the address from\n@@ -1311,26 +1364,7 @@ impl UnixDatagram {\n     /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-        let mut count = 0;\n-        let addr = SocketAddr::new(|addr, len| unsafe {\n-            count = libc::recvfrom(\n-                *self.0.as_inner(),\n-                buf.as_mut_ptr() as *mut _,\n-                buf.len(),\n-                0,\n-                addr,\n-                len,\n-            );\n-            if count > 0 {\n-                1\n-            } else if count == 0 {\n-                0\n-            } else {\n-                -1\n-            }\n-        })?;\n-\n-        Ok((count as usize, addr))\n+        self.recv_from_flags(buf, 0)\n     }\n \n     /// Receives data from the socket.\n@@ -1601,6 +1635,64 @@ impl UnixDatagram {\n     pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n         self.0.shutdown(how)\n     }\n+\n+    /// Receives data on the socket from the remote address to which it is\n+    /// connected, without removing that data from the queue. On success,\n+    /// returns the number of bytes peeked.\n+    ///\n+    /// Successive calls return the same data. This is accomplished by passing\n+    /// `MSG_PEEK` as a flag to the underlying `recv` system call.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_peek)]\n+    ///\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixDatagram::bind(\"/tmp/sock\")?;\n+    ///     let mut buf = [0; 10];\n+    ///     let len = socket.peek(&mut buf).expect(\"peek failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_peek\", issue = \"none\")]\n+    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.peek(buf)\n+    }\n+\n+    /// Receives a single datagram message on the socket, without removing it from the\n+    /// queue. On success, returns the number of bytes read and the origin.\n+    ///\n+    /// The function must be called with valid byte array `buf` of sufficient size to\n+    /// hold the message bytes. If a message is too long to fit in the supplied buffer,\n+    /// excess bytes may be discarded.\n+    ///\n+    /// Successive calls return the same data. This is accomplished by passing\n+    /// `MSG_PEEK` as a flag to the underlying `recvfrom` system call.\n+    ///\n+    /// Do not use this function to implement busy waiting, instead use `libc::poll` to\n+    /// synchronize IO events on one or more sockets.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_peek)]\n+    ///\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixDatagram::bind(\"/tmp/sock\")?;\n+    ///     let mut buf = [0; 10];\n+    ///     let (len, addr) = socket.peek_from(&mut buf).expect(\"peek failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_peek\", issue = \"none\")]\n+    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.recv_from_flags(buf, libc::MSG_PEEK)\n+    }\n }\n \n #[stable(feature = \"unix_socket\", since = \"1.10.0\")]"}, {"sha": "ee73a6ed538fffb377056a14d2afa151e5ca354c", "filename": "library/std/src/sys/unix/ext/net/tests.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/99111606fcda4fdb0646e4f7ee0f6cbcb76fb84a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99111606fcda4fdb0646e4f7ee0f6cbcb76fb84a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Ftests.rs?ref=99111606fcda4fdb0646e4f7ee0f6cbcb76fb84a", "patch": "@@ -372,3 +372,83 @@ fn test_unix_datagram_timeout_zero_duration() {\n fn abstract_namespace_not_allowed() {\n     assert!(UnixStream::connect(\"\\0asdf\").is_err());\n }\n+\n+#[test]\n+fn test_unix_stream_peek() {\n+    let (txdone, rxdone) = crate::sync::mpsc::channel();\n+\n+    let dir = tmpdir();\n+    let path = dir.path().join(\"sock\");\n+\n+    let listener = or_panic!(UnixListener::bind(&path));\n+    let thread = thread::spawn(move || {\n+        let mut stream = or_panic!(listener.accept()).0;\n+        or_panic!(stream.write_all(&[1, 3, 3, 7]));\n+        or_panic!(rxdone.recv());\n+    });\n+\n+    let mut stream = or_panic!(UnixStream::connect(&path));\n+    let mut buf = [0; 10];\n+    for _ in 0..2 {\n+        assert_eq!(or_panic!(stream.peek(&mut buf)), 4);\n+    }\n+    assert_eq!(or_panic!(stream.read(&mut buf)), 4);\n+\n+    or_panic!(stream.set_nonblocking(true));\n+    match stream.peek(&mut buf) {\n+        Ok(_) => panic!(\"expected error\"),\n+        Err(ref e) if e.kind() == ErrorKind::WouldBlock => {}\n+        Err(e) => panic!(\"unexpected error: {}\", e),\n+    }\n+\n+    or_panic!(txdone.send(()));\n+    thread.join().unwrap();\n+}\n+\n+#[test]\n+fn test_unix_datagram_peek() {\n+    let dir = tmpdir();\n+    let path1 = dir.path().join(\"sock\");\n+\n+    let sock1 = or_panic!(UnixDatagram::bind(&path1));\n+    let sock2 = or_panic!(UnixDatagram::unbound());\n+    or_panic!(sock2.connect(&path1));\n+\n+    let msg = b\"hello world\";\n+    or_panic!(sock2.send(msg));\n+    for _ in 0..2 {\n+        let mut buf = [0; 11];\n+        let size = or_panic!(sock1.peek(&mut buf));\n+        assert_eq!(size, 11);\n+        assert_eq!(msg, &buf[..]);\n+    }\n+\n+    let mut buf = [0; 11];\n+    let size = or_panic!(sock1.recv(&mut buf));\n+    assert_eq!(size, 11);\n+    assert_eq!(msg, &buf[..]);\n+}\n+\n+#[test]\n+fn test_unix_datagram_peek_from() {\n+    let dir = tmpdir();\n+    let path1 = dir.path().join(\"sock\");\n+\n+    let sock1 = or_panic!(UnixDatagram::bind(&path1));\n+    let sock2 = or_panic!(UnixDatagram::unbound());\n+    or_panic!(sock2.connect(&path1));\n+\n+    let msg = b\"hello world\";\n+    or_panic!(sock2.send(msg));\n+    for _ in 0..2 {\n+        let mut buf = [0; 11];\n+        let (size, _) = or_panic!(sock1.peek_from(&mut buf));\n+        assert_eq!(size, 11);\n+        assert_eq!(msg, &buf[..]);\n+    }\n+\n+    let mut buf = [0; 11];\n+    let size = or_panic!(sock1.recv(&mut buf));\n+    assert_eq!(size, 11);\n+    assert_eq!(msg, &buf[..]);\n+}"}]}