{"sha": "c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4NzM5Y2IwYmM3ZjczNWFiNjcwZjRhYzZjYzE0M2YyYWQ5ZWY1NWM=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-17T00:27:04Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-17T17:35:59Z"}, "message": "Error checking for protocols. We'll need spans though.", "tree": {"sha": "712f8ab442cc08cb11b25ffc45f335b8217b6878", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/712f8ab442cc08cb11b25ffc45f335b8217b6878"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c", "html_url": "https://github.com/rust-lang/rust/commit/c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "156eceb24a44451dd34e8408301b9711478317e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/156eceb24a44451dd34e8408301b9711478317e4", "html_url": "https://github.com/rust-lang/rust/commit/156eceb24a44451dd34e8408301b9711478317e4"}], "stats": {"total": 415, "additions": 274, "deletions": 141}, "files": [{"sha": "040f34ca00bc9fcd5f809155215c1f6209c552d3", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c", "patch": "@@ -23,6 +23,29 @@ impl extensions <T:copy, U:copy> for (T, U) {\n \n }\n \n+impl extensions<A: copy, B: copy> for (&[A], &[B]) {\n+    fn zip() -> ~[(A, B)] {\n+        let (a, b) = self;\n+        vec::zip(a, b)\n+    }\n+\n+    fn map<C>(f: fn(A, B) -> C) -> ~[C] {\n+        let (a, b) = self;\n+        vec::map2(a, b, f)\n+    }\n+}\n+\n+impl extensions<A: copy, B: copy> for (~[A], ~[B]) {\n+    fn zip() -> ~[(A, B)] {\n+        let (a, b) = self;\n+        vec::zip(a, b)\n+    }\n+\n+    fn map<C>(f: fn(A, B) -> C) -> ~[C] {\n+        let (a, b) = self;\n+        vec::map2(a, b, f)\n+    }\n+}\n \n #[test]\n fn test_tuple() {"}, {"sha": "f6b15ff19d9d16162bdae8dddba8e19a1770b8b0", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c", "patch": "@@ -100,6 +100,7 @@ iface ext_ctxt {\n     fn bt_pop();\n     fn span_fatal(sp: span, msg: ~str) -> !;\n     fn span_err(sp: span, msg: ~str);\n+    fn span_warn(sp: span, msg: ~str);\n     fn span_unimpl(sp: span, msg: ~str) -> !;\n     fn span_bug(sp: span, msg: ~str) -> !;\n     fn bug(msg: ~str) -> !;\n@@ -148,6 +149,10 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_err(sp, msg);\n         }\n+        fn span_warn(sp: span, msg: ~str) {\n+            self.print_backtrace();\n+            self.parse_sess.span_diagnostic.span_warn(sp, msg);\n+        }\n         fn span_unimpl(sp: span, msg: ~str) -> ! {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_unimpl(sp, msg);"}, {"sha": "bea1c8cae0cbe5e9d3f3a47fce5e488ce7db9ca8", "filename": "src/libsyntax/ext/pipes.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c/src%2Flibsyntax%2Fext%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c/src%2Flibsyntax%2Fext%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes.rs?ref=c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c", "patch": "@@ -8,7 +8,9 @@ import parse::common::parser_common;\n \n import pipes::parse_proto::proto_parser;\n \n-import pipes::pipec::methods;\n+import pipes::pipec::compile;\n+import pipes::proto::{visit, protocol};\n+import pipes::check::proto_check;\n \n fn expand_proto(cx: ext_ctxt, _sp: span, id: ast::ident,\n                 tt: ~[ast::token_tree]) -> base::mac_result\n@@ -22,5 +24,9 @@ fn expand_proto(cx: ext_ctxt, _sp: span, id: ast::ident,\n \n     let proto = rust_parser.parse_proto(id);\n \n+    // check for errors\n+    visit(proto, cx);\n+\n+    // compile\n     base::mr_item(proto.compile(cx))\n }"}, {"sha": "7cf96707bca919b7a58208e08fdbe848033aca47", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c", "patch": "@@ -0,0 +1,74 @@\n+/// Correctness for protocols\n+\n+/*\n+\n+This section of code makes sure the protocol is likely to generate\n+correct code. The correctness criteria include:\n+\n+  * No protocols transition to states that don't exist.\n+  * Messages step to states with the right number of type parameters.\n+\n+In addition, this serves as a lint pass. Lint warns for the following\n+things.\n+\n+  * States with no messages, it's better to step to !.\n+\n+It would also be nice to warn about unreachable states, but the\n+visitor infrastructure for protocols doesn't currently work well for\n+that.\n+\n+*/\n+\n+import dvec::extensions;\n+\n+import ext::base::ext_ctxt;\n+\n+import ast::{ident};\n+\n+import proto::{state, protocol, next_state, methods};\n+import ast_builder::empty_span;\n+\n+impl proto_check of proto::visitor<(), (), ()>  for ext_ctxt {\n+    fn visit_proto(_proto: protocol,\n+                   _states: &[()]) { }\n+\n+    fn visit_state(state: state, _m: &[()]) {\n+        if state.messages.len() == 0 {\n+            self.span_warn(\n+                empty_span(), // use a real span!\n+                #fmt(\"state %s contains no messages, \\\n+                      consider stepping to a terminal state instead\",\n+                     *state.name))\n+        }\n+    }\n+\n+    fn visit_message(name: ident, _tys: &[@ast::ty],\n+                     this: state, next: next_state) {\n+         alt next {\n+           some({state: next, tys: next_tys}) {\n+             let proto = this.proto;\n+             if !proto.has_state(next) {\n+                 // This should be a span fatal, but then we need to\n+                 // track span information.\n+                 self.span_err(\n+                     empty_span(),\n+                     #fmt(\"message %s steps to undefined state, %s\",\n+                          *name, *next));\n+            }\n+\n+            let next = proto.get_state(next);\n+\n+            if next.ty_params.len() != next_tys.len() {\n+                self.span_err(\n+                    empty_span(), // use a real span\n+                    #fmt(\"message %s target (%s) \\\n+                          needs %u type parameters, but got %u\",\n+                         *name, *next.name,\n+                         next.ty_params.len(),\n+                         next_tys.len()));\n+            }\n+          }\n+          none { }\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "4af75fa90e7b2616d46fa057e53ca4b694fde176", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 13, "deletions": 140, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c", "patch": "@@ -5,6 +5,8 @@ import to_str::to_str;\n import dvec::dvec;\n import dvec::extensions;\n \n+import tuple::extensions;\n+\n import ast::ident;\n import util::interner;\n import interner::{intern, get};\n@@ -14,57 +16,13 @@ import ext::base::{mk_ctxt, ext_ctxt};\n import parse;\n import parse::*;\n \n+import proto::*;\n+\n import ast_builder::ast_builder;\n import ast_builder::methods;\n import ast_builder::path;\n \n-enum direction {\n-    send, recv\n-}\n-\n-impl of to_str for direction {\n-    fn to_str() -> ~str {\n-        alt self {\n-          send { ~\"send\" }\n-          recv { ~\"recv\" }\n-        }\n-    }\n-}\n-\n-impl methods for direction {\n-    fn reverse() -> direction {\n-        alt self {\n-          send { recv }\n-          recv { send }\n-        }\n-    }\n-}\n-\n-type next_state = option<{state: ident, tys: ~[@ast::ty]}>;\n-\n-enum message {\n-    // name, data, current state, next state\n-    message(ident, ~[@ast::ty], state, next_state)\n-}\n-\n-impl methods for message {\n-    fn name() -> ident {\n-        alt self {\n-          message(id, _, _, _) {\n-            id\n-          }\n-        }\n-    }\n-\n-    // Return the type parameters actually used by this message\n-    fn get_params() -> ~[ast::ty_param] {\n-        alt self {\n-          message(_, _, this, _) {\n-            this.ty_params\n-          }\n-        }\n-    }\n-\n+impl compile for message {\n     fn gen_send(cx: ext_ctxt) -> @ast::item {\n         #debug(\"pipec: gen_send\");\n         alt self {\n@@ -154,34 +112,7 @@ impl methods for message {\n     }\n }\n \n-enum state {\n-    state_(@{\n-        name: ident,\n-        dir: direction,\n-        ty_params: ~[ast::ty_param],\n-        messages: dvec<message>,\n-        proto: protocol,\n-    }),\n-}\n-\n-impl methods for state {\n-    fn add_message(name: ident, +data: ~[@ast::ty], next: next_state) {\n-        self.messages.push(message(name, data, self,\n-                                   next));\n-    }\n-\n-    fn filename() -> ~str {\n-        (*self).proto.filename()\n-    }\n-\n-    fn data_name() -> ident {\n-        self.name\n-    }\n-\n-    fn to_ty(cx: ext_ctxt) -> @ast::ty {\n-        cx.ty_path(path(self.name).add_tys(cx.ty_vars(self.ty_params)))\n-    }\n-\n+impl compile for state {\n     fn to_type_decls(cx: ext_ctxt) -> ~[@ast::item] {\n         #debug(\"pipec: to_type_decls\");\n         // This compiles into two different type declarations. Say the\n@@ -248,47 +179,7 @@ impl methods for state {\n     }\n }\n \n-enum protocol {\n-    protocol_(@{\n-        name: ident,\n-        states: dvec<state>,\n-    }),\n-}\n-\n-fn protocol(name: ident) -> protocol {\n-    protocol_(@{name: name, states: dvec()})\n-}\n-\n-impl methods for protocol {\n-    fn add_state(name: ident, dir: direction) -> state {\n-        self.add_state_poly(name, dir, ~[])\n-    }\n-\n-    /// Get or create a state.\n-    fn get_state(name: ident) -> state {\n-        self.states.find(|i| i.name == name).get()\n-    }\n-\n-    fn add_state_poly(name: ident, dir: direction,\n-                      +ty_params: ~[ast::ty_param]) -> state {\n-        let messages = dvec();\n-\n-        let state = state_(@{\n-            name: name,\n-            dir: dir,\n-            ty_params: ty_params,\n-            messages: messages,\n-            proto: self\n-        });\n-\n-        self.states.push(state);\n-        state\n-    }\n-\n-    fn filename() -> ~str {\n-        ~\"proto://\" + *self.name\n-    }\n-\n+impl compile for protocol {\n     fn gen_init(cx: ext_ctxt) -> @ast::item {\n         let start_state = self.states[0];\n \n@@ -302,18 +193,12 @@ impl methods for protocol {\n           }\n         };\n \n-        parse_item_from_source_str(\n-            self.filename(),\n-            @#fmt(\"fn init%s() -> (client::%s, server::%s)\\\n-                   { %s }\",\n-                  start_state.ty_params.to_source(),\n-                  start_state.to_ty(cx).to_source(),\n-                  start_state.to_ty(cx).to_source(),\n-                  body.to_source()),\n-            cx.cfg(),\n-            ~[],\n-            ast::public,\n-            cx.parse_sess()).get()\n+        cx.parse_item(#fmt(\"fn init%s() -> (client::%s, server::%s)\\\n+                            { %s }\",\n+                           start_state.ty_params.to_source(),\n+                           start_state.to_ty(cx).to_source(),\n+                           start_state.to_ty(cx).to_source(),\n+                           body.to_source()))\n     }\n \n     fn compile(cx: ext_ctxt) -> @ast::item {\n@@ -407,15 +292,3 @@ impl parse_utils for ext_ctxt {\n             self.parse_sess())\n     }\n }\n-\n-impl methods<A: copy, B: copy> for (~[A], ~[B]) {\n-    fn zip() -> ~[(A, B)] {\n-        let (a, b) = self;\n-        vec::zip(a, b)\n-    }\n-\n-    fn map<C>(f: fn(A, B) -> C) -> ~[C] {\n-        let (a, b) = self;\n-        vec::map2(a, b, f)\n-    }\n-}"}, {"sha": "1df3466286cbbb132614436f418b6792081bad23", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c", "patch": "@@ -0,0 +1,150 @@\n+import to_str::to_str;\n+import dvec::{dvec, extensions};\n+\n+import ast::{ident};\n+\n+import ast_builder::{path, methods, ast_builder};\n+\n+enum direction {\n+    send, recv\n+}\n+\n+impl of to_str for direction {\n+    fn to_str() -> ~str {\n+        alt self {\n+          send { ~\"send\" }\n+          recv { ~\"recv\" }\n+        }\n+    }\n+}\n+\n+impl methods for direction {\n+    fn reverse() -> direction {\n+        alt self {\n+          send { recv }\n+          recv { send }\n+        }\n+    }\n+}\n+\n+type next_state = option<{state: ident, tys: ~[@ast::ty]}>;\n+\n+enum message {\n+    // name, data, current state, next state\n+    message(ident, ~[@ast::ty], state, next_state)\n+}\n+\n+impl methods for message {\n+    fn name() -> ident {\n+        alt self {\n+          message(id, _, _, _) {\n+            id\n+          }\n+        }\n+    }\n+\n+    /// Return the type parameters actually used by this message\n+    fn get_params() -> ~[ast::ty_param] {\n+        alt self {\n+          message(_, _, this, _) {\n+            this.ty_params\n+          }\n+        }\n+    }\n+}\n+\n+enum state {\n+    state_(@{\n+        name: ident,\n+        dir: direction,\n+        ty_params: ~[ast::ty_param],\n+        messages: dvec<message>,\n+        proto: protocol,\n+    }),\n+}\n+\n+impl methods for state {\n+    fn add_message(name: ident, +data: ~[@ast::ty], next: next_state) {\n+        self.messages.push(message(name, data, self,\n+                                   next));\n+    }\n+\n+    fn filename() -> ~str {\n+        (*self).proto.filename()\n+    }\n+\n+    fn data_name() -> ident {\n+        self.name\n+    }\n+\n+    fn to_ty(cx: ext_ctxt) -> @ast::ty {\n+        cx.ty_path(path(self.name).add_tys(cx.ty_vars(self.ty_params)))\n+    }\n+}\n+\n+enum protocol {\n+    protocol_(@{\n+        name: ident,\n+        states: dvec<state>,\n+    }),\n+}\n+\n+fn protocol(name: ident) -> protocol {\n+    protocol_(@{name: name, states: dvec()})\n+}\n+\n+impl methods for protocol {\n+    fn add_state(name: ident, dir: direction) -> state {\n+        self.add_state_poly(name, dir, ~[])\n+    }\n+\n+    /// Get or create a state.\n+    fn get_state(name: ident) -> state {\n+        self.states.find(|i| i.name == name).get()\n+    }\n+\n+    fn has_state(name: ident) -> bool {\n+        self.states.find(|i| i.name == name) != none\n+    }\n+\n+    fn add_state_poly(name: ident, dir: direction,\n+                      +ty_params: ~[ast::ty_param]) -> state {\n+        let messages = dvec();\n+\n+        let state = state_(@{\n+            name: name,\n+            dir: dir,\n+            ty_params: ty_params,\n+            messages: messages,\n+            proto: self\n+        });\n+\n+        self.states.push(state);\n+        state\n+    }\n+\n+    fn filename() -> ~str {\n+        ~\"proto://\" + *self.name\n+    }\n+}\n+\n+trait visitor<Tproto, Tstate, Tmessage> {\n+    fn visit_proto(proto: protocol, st: &[Tstate]) -> Tproto;\n+    fn visit_state(state: state, m: &[Tmessage]) -> Tstate;\n+    fn visit_message(name: ident, tys: &[@ast::ty],\n+                     this: state, next: next_state) -> Tmessage;\n+}\n+\n+fn visit<Tproto, Tstate, Tmessage, V: visitor<Tproto, Tstate, Tmessage>>(\n+    proto: protocol, visitor: V) -> Tproto {\n+\n+    // the copy keywords prevent recursive use of dvec\n+    let states = do (copy proto.states).map_to_vec |s| {\n+        let messages = do (copy s.messages).map_to_vec |m| {\n+            let message(name, tys, this, next) = m;\n+            visitor.visit_message(name, tys, this, next)\n+        };\n+        visitor.visit_state(s, messages)\n+    };\n+    visitor.visit_proto(proto, states)\n+}"}, {"sha": "9750f2d5bd12ae0cfd7e722041b290603cfe5d18", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=c8739cb0bc7f735ab670f4ac6cc143f2ad9ef55c", "patch": "@@ -85,5 +85,7 @@ mod ext {\n         mod ast_builder;\n         mod parse_proto;\n         mod pipec;\n+        mod proto;\n+        mod check;\n     }\n }"}]}