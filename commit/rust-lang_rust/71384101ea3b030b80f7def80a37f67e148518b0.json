{"sha": "71384101ea3b030b80f7def80a37f67e148518b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxMzg0MTAxZWEzYjAzMGI4MGY3ZGVmODBhMzdmNjdlMTQ4NTE4YjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-20T10:19:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-20T10:19:58Z"}, "message": "Auto merge of #74010 - pierwill:pierwill-o-notation, r=GuillaumeGomez\n\nUse italics for O notation\n\nIn documentation, I think it makes sense to italicize O notation (*O(n)*) as opposed to using back-ticks (`O(n)`). Visually, back-ticks focus the reader on the literal characters being used, making them ideal for representing code. Using italics, as far I can tell, more closely follows typographic conventions in mathematics and computer science.\n\nJust a suggestion, of course! \ud83d\ude07", "tree": {"sha": "b2cdb190bf396f3b8fc7ffb65e6b0145d27bfd9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2cdb190bf396f3b8fc7ffb65e6b0145d27bfd9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71384101ea3b030b80f7def80a37f67e148518b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71384101ea3b030b80f7def80a37f67e148518b0", "html_url": "https://github.com/rust-lang/rust/commit/71384101ea3b030b80f7def80a37f67e148518b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71384101ea3b030b80f7def80a37f67e148518b0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05630b06fdf76c25c6ccf2e9ac3567592eae6c67", "url": "https://api.github.com/repos/rust-lang/rust/commits/05630b06fdf76c25c6ccf2e9ac3567592eae6c67", "html_url": "https://github.com/rust-lang/rust/commit/05630b06fdf76c25c6ccf2e9ac3567592eae6c67"}, {"sha": "76b8420168a2e14abf025a07ee4e32d87956d940", "url": "https://api.github.com/repos/rust-lang/rust/commits/76b8420168a2e14abf025a07ee4e32d87956d940", "html_url": "https://github.com/rust-lang/rust/commit/76b8420168a2e14abf025a07ee4e32d87956d940"}], "stats": {"total": 102, "additions": 51, "deletions": 51}, "files": [{"sha": "8398cfa3bd34e2ea07fbca98e3ce7ec9a7d1f1ed", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/71384101ea3b030b80f7def80a37f67e148518b0/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71384101ea3b030b80f7def80a37f67e148518b0/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=71384101ea3b030b80f7def80a37f67e148518b0", "patch": "@@ -1,9 +1,9 @@\n //! A priority queue implemented with a binary heap.\n //!\n-//! Insertion and popping the largest element have `O(log(n))` time complexity.\n-//! Checking the largest element is `O(1)`. Converting a vector to a binary heap\n-//! can be done in-place, and has `O(n)` complexity. A binary heap can also be\n-//! converted to a sorted vector in-place, allowing it to be used for an `O(n * log(n))`\n+//! Insertion and popping the largest element have *O*(log(*n*)) time complexity.\n+//! Checking the largest element is *O*(1). Converting a vector to a binary heap\n+//! can be done in-place, and has *O*(*n*) complexity. A binary heap can also be\n+//! converted to a sorted vector in-place, allowing it to be used for an *O*(*n* \\* log(*n*))\n //! in-place heapsort.\n //!\n //! # Examples\n@@ -235,7 +235,7 @@ use super::SpecExtend;\n ///\n /// | [push] | [pop]     | [peek]/[peek\\_mut] |\n /// |--------|-----------|--------------------|\n-/// | O(1)~  | O(log(n)) | O(1)               |\n+/// | O(1)~  | *O*(log(*n*)) | *O*(1)               |\n ///\n /// The value for `push` is an expected cost; the method documentation gives a\n /// more detailed analysis.\n@@ -398,7 +398,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Time complexity\n     ///\n-    /// Cost is `O(1)` in the worst case.\n+    /// Cost is *O*(1) in the worst case.\n     #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n     pub fn peek_mut(&mut self) -> Option<PeekMut<'_, T>> {\n         if self.is_empty() { None } else { Some(PeekMut { heap: self, sift: true }) }\n@@ -422,7 +422,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Time complexity\n     ///\n-    /// The worst case cost of `pop` on a heap containing *n* elements is `O(log(n))`.\n+    /// The worst case cost of `pop` on a heap containing *n* elements is *O*(log(*n*)).\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<T> {\n         self.data.pop().map(|mut item| {\n@@ -455,15 +455,15 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// The expected cost of `push`, averaged over every possible ordering of\n     /// the elements being pushed, and over a sufficiently large number of\n-    /// pushes, is `O(1)`. This is the most meaningful cost metric when pushing\n+    /// pushes, is *O*(1). This is the most meaningful cost metric when pushing\n     /// elements that are *not* already in any sorted pattern.\n     ///\n     /// The time complexity degrades if elements are pushed in predominantly\n     /// ascending order. In the worst case, elements are pushed in ascending\n-    /// sorted order and the amortized cost per push is `O(log(n))` against a heap\n+    /// sorted order and the amortized cost per push is *O*(log(*n*)) against a heap\n     /// containing *n* elements.\n     ///\n-    /// The worst case cost of a *single* call to `push` is `O(n)`. The worst case\n+    /// The worst case cost of a *single* call to `push` is *O*(*n*). The worst case\n     /// occurs when capacity is exhausted and needs a resize. The resize cost\n     /// has been amortized in the previous figures.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -643,7 +643,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// The remaining elements will be removed on drop in heap order.\n     ///\n     /// Note:\n-    /// * `.drain_sorted()` is `O(n * log(n))`; much slower than `.drain()`.\n+    /// * `.drain_sorted()` is *O*(*n* \\* log(*n*)); much slower than `.drain()`.\n     ///   You should use the latter for most cases.\n     ///\n     /// # Examples\n@@ -756,7 +756,7 @@ impl<T> BinaryHeap<T> {\n     ///\n     /// # Time complexity\n     ///\n-    /// Cost is `O(1)` in the worst case.\n+    /// Cost is *O*(1) in the worst case.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn peek(&self) -> Option<&T> {\n         self.data.get(0)\n@@ -1312,7 +1312,7 @@ unsafe impl<T: Ord> TrustedLen for DrainSorted<'_, T> {}\n impl<T: Ord> From<Vec<T>> for BinaryHeap<T> {\n     /// Converts a `Vec<T>` into a `BinaryHeap<T>`.\n     ///\n-    /// This conversion happens in-place, and has `O(n)` time complexity.\n+    /// This conversion happens in-place, and has *O*(*n*) time complexity.\n     fn from(vec: Vec<T>) -> BinaryHeap<T> {\n         let mut heap = BinaryHeap { data: vec };\n         heap.rebuild();"}, {"sha": "1f875f6c5217f4897cb67711b05670b9dfae509a", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/71384101ea3b030b80f7def80a37f67e148518b0/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71384101ea3b030b80f7def80a37f67e148518b0/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=71384101ea3b030b80f7def80a37f67e148518b0", "patch": "@@ -404,7 +404,7 @@ impl<T> LinkedList<T> {\n     /// This reuses all the nodes from `other` and moves them into `self`. After\n     /// this operation, `other` becomes empty.\n     ///\n-    /// This operation should compute in `O(1)` time and `O(1)` memory.\n+    /// This operation should compute in *O*(1) time and *O*(1) memory.\n     ///\n     /// # Examples\n     ///\n@@ -561,7 +561,7 @@ impl<T> LinkedList<T> {\n \n     /// Returns `true` if the `LinkedList` is empty.\n     ///\n-    /// This operation should compute in `O(1)` time.\n+    /// This operation should compute in *O*(1) time.\n     ///\n     /// # Examples\n     ///\n@@ -582,7 +582,7 @@ impl<T> LinkedList<T> {\n \n     /// Returns the length of the `LinkedList`.\n     ///\n-    /// This operation should compute in `O(1)` time.\n+    /// This operation should compute in *O*(1) time.\n     ///\n     /// # Examples\n     ///\n@@ -608,7 +608,7 @@ impl<T> LinkedList<T> {\n \n     /// Removes all elements from the `LinkedList`.\n     ///\n-    /// This operation should compute in `O(n)` time.\n+    /// This operation should compute in *O*(*n*) time.\n     ///\n     /// # Examples\n     ///\n@@ -751,7 +751,7 @@ impl<T> LinkedList<T> {\n \n     /// Adds an element first in the list.\n     ///\n-    /// This operation should compute in `O(1)` time.\n+    /// This operation should compute in *O*(1) time.\n     ///\n     /// # Examples\n     ///\n@@ -774,7 +774,7 @@ impl<T> LinkedList<T> {\n     /// Removes the first element and returns it, or `None` if the list is\n     /// empty.\n     ///\n-    /// This operation should compute in `O(1)` time.\n+    /// This operation should compute in *O*(1) time.\n     ///\n     /// # Examples\n     ///\n@@ -797,7 +797,7 @@ impl<T> LinkedList<T> {\n \n     /// Appends an element to the back of a list.\n     ///\n-    /// This operation should compute in `O(1)` time.\n+    /// This operation should compute in *O*(1) time.\n     ///\n     /// # Examples\n     ///\n@@ -817,7 +817,7 @@ impl<T> LinkedList<T> {\n     /// Removes the last element from a list and returns it, or `None` if\n     /// it is empty.\n     ///\n-    /// This operation should compute in `O(1)` time.\n+    /// This operation should compute in *O*(1) time.\n     ///\n     /// # Examples\n     ///\n@@ -838,7 +838,7 @@ impl<T> LinkedList<T> {\n     /// Splits the list into two at the given index. Returns everything after the given index,\n     /// including the index.\n     ///\n-    /// This operation should compute in `O(n)` time.\n+    /// This operation should compute in *O*(*n*) time.\n     ///\n     /// # Panics\n     ///\n@@ -894,7 +894,7 @@ impl<T> LinkedList<T> {\n \n     /// Removes the element at the given index and returns it.\n     ///\n-    /// This operation should compute in `O(n)` time.\n+    /// This operation should compute in *O*(*n*) time.\n     ///\n     /// # Panics\n     /// Panics if at >= len"}, {"sha": "fa65d6ce8d725bba49eb2da48829b79d85accfca", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/71384101ea3b030b80f7def80a37f67e148518b0/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71384101ea3b030b80f7def80a37f67e148518b0/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=71384101ea3b030b80f7def80a37f67e148518b0", "patch": "@@ -1,7 +1,7 @@\n //! A double-ended queue implemented with a growable ring buffer.\n //!\n-//! This queue has `O(1)` amortized inserts and removals from both ends of the\n-//! container. It also has `O(1)` indexing like a vector. The contained elements\n+//! This queue has *O*(1) amortized inserts and removals from both ends of the\n+//! container. It also has *O*(1) indexing like a vector. The contained elements\n //! are not required to be copyable, and the queue will be sendable if the\n //! contained type is sendable.\n \n@@ -1512,7 +1512,7 @@ impl<T> VecDeque<T> {\n     /// Removes an element from anywhere in the `VecDeque` and returns it,\n     /// replacing it with the first element.\n     ///\n-    /// This does not preserve ordering, but is `O(1)`.\n+    /// This does not preserve ordering, but is *O*(1).\n     ///\n     /// Returns `None` if `index` is out of bounds.\n     ///\n@@ -1547,7 +1547,7 @@ impl<T> VecDeque<T> {\n     /// Removes an element from anywhere in the `VecDeque` and returns it, replacing it with the\n     /// last element.\n     ///\n-    /// This does not preserve ordering, but is `O(1)`.\n+    /// This does not preserve ordering, but is *O*(1).\n     ///\n     /// Returns `None` if `index` is out of bounds.\n     ///\n@@ -2331,7 +2331,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// # Complexity\n     ///\n-    /// Takes `O(min(mid, len() - mid))` time and no extra space.\n+    /// Takes `*O*(min(mid, len() - mid))` time and no extra space.\n     ///\n     /// # Examples\n     ///\n@@ -2374,7 +2374,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// # Complexity\n     ///\n-    /// Takes `O(min(k, len() - k))` time and no extra space.\n+    /// Takes `*O*(min(k, len() - k))` time and no extra space.\n     ///\n     /// # Examples\n     ///\n@@ -3076,15 +3076,15 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n     /// [`Vec<T>`]: crate::vec::Vec\n     /// [`VecDeque<T>`]: crate::collections::VecDeque\n     ///\n-    /// This never needs to re-allocate, but does need to do `O(n)` data movement if\n+    /// This never needs to re-allocate, but does need to do *O*(*n*) data movement if\n     /// the circular buffer doesn't happen to be at the beginning of the allocation.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// // This one is O(1).\n+    /// // This one is *O*(1).\n     /// let deque: VecDeque<_> = (1..5).collect();\n     /// let ptr = deque.as_slices().0.as_ptr();\n     /// let vec = Vec::from(deque);"}, {"sha": "15f10df9a45cc097b6fe5c2160d2efa6814ee898", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71384101ea3b030b80f7def80a37f67e148518b0/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71384101ea3b030b80f7def80a37f67e148518b0/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=71384101ea3b030b80f7def80a37f67e148518b0", "patch": "@@ -1162,7 +1162,7 @@ impl String {\n \n     /// Removes a [`char`] from this `String` at a byte position and returns it.\n     ///\n-    /// This is an `O(n)` operation, as it requires copying every element in the\n+    /// This is an *O*(*n*) operation, as it requires copying every element in the\n     /// buffer.\n     ///\n     /// # Panics\n@@ -1262,7 +1262,7 @@ impl String {\n \n     /// Inserts a character into this `String` at a byte position.\n     ///\n-    /// This is an `O(n)` operation as it requires copying every element in the\n+    /// This is an *O*(*n*) operation as it requires copying every element in the\n     /// buffer.\n     ///\n     /// # Panics\n@@ -1309,7 +1309,7 @@ impl String {\n \n     /// Inserts a string slice into this `String` at a byte position.\n     ///\n-    /// This is an `O(n)` operation as it requires copying every element in the\n+    /// This is an *O*(*n*) operation as it requires copying every element in the\n     /// buffer.\n     ///\n     /// # Panics\n@@ -1971,7 +1971,7 @@ impl hash::Hash for String {\n ///\n /// This consumes the `String` on the left-hand side and re-uses its buffer (growing it if\n /// necessary). This is done to avoid allocating a new `String` and copying the entire contents on\n-/// every operation, which would lead to `O(n^2)` running time when building an `n`-byte string by\n+/// every operation, which would lead to *O*(*n*^2) running time when building an *n*-byte string by\n /// repeated concatenation.\n ///\n /// The string on the right-hand side is only borrowed; its contents are copied into the returned"}, {"sha": "210ac078b4fe70a667d998ddce972b5e8d751dd3", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/71384101ea3b030b80f7def80a37f67e148518b0/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71384101ea3b030b80f7def80a37f67e148518b0/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=71384101ea3b030b80f7def80a37f67e148518b0", "patch": "@@ -1672,7 +1672,7 @@ impl<T> [T] {\n     /// Sorts the slice, but may not preserve the order of equal elements.\n     ///\n     /// This sort is unstable (i.e., may reorder equal elements), in-place\n-    /// (i.e., does not allocate), and `O(n * log(n))` worst-case.\n+    /// (i.e., does not allocate), and *O*(*n* \\* log(*n*)) worst-case.\n     ///\n     /// # Current implementation\n     ///\n@@ -1708,7 +1708,7 @@ impl<T> [T] {\n     /// elements.\n     ///\n     /// This sort is unstable (i.e., may reorder equal elements), in-place\n-    /// (i.e., does not allocate), and `O(n * log(n))` worst-case.\n+    /// (i.e., does not allocate), and *O*(*n* \\* log(*n*)) worst-case.\n     ///\n     /// The comparator function must define a total ordering for the elements in the slice. If\n     /// the ordering is not total, the order of the elements is unspecified. An order is a\n@@ -1763,8 +1763,8 @@ impl<T> [T] {\n     /// elements.\n     ///\n     /// This sort is unstable (i.e., may reorder equal elements), in-place\n-    /// (i.e., does not allocate), and `O(m * n * log(n))` worst-case, where the key function is\n-    /// `O(m)`.\n+    /// (i.e., does not allocate), and *O*(m \\* *n* \\* log(*n*)) worst-case, where the key function is\n+    /// *O*(*m*).\n     ///\n     /// # Current implementation\n     ///\n@@ -1803,7 +1803,7 @@ impl<T> [T] {\n     /// This reordering has the additional property that any value at position `i < index` will be\n     /// less than or equal to any value at a position `j > index`. Additionally, this reordering is\n     /// unstable (i.e. any number of equal elements may end up at position `index`), in-place\n-    /// (i.e. does not allocate), and `O(n)` worst-case. This function is also/ known as \"kth\n+    /// (i.e. does not allocate), and *O*(*n*) worst-case. This function is also/ known as \"kth\n     /// element\" in other libraries. It returns a triplet of the following values: all elements less\n     /// than the one at the given index, the value at the given index, and all elements greater than\n     /// the one at the given index.\n@@ -1852,7 +1852,7 @@ impl<T> [T] {\n     /// This reordering has the additional property that any value at position `i < index` will be\n     /// less than or equal to any value at a position `j > index` using the comparator function.\n     /// Additionally, this reordering is unstable (i.e. any number of equal elements may end up at\n-    /// position `index`), in-place (i.e. does not allocate), and `O(n)` worst-case. This function\n+    /// position `index`), in-place (i.e. does not allocate), and *O*(*n*) worst-case. This function\n     /// is also known as \"kth element\" in other libraries. It returns a triplet of the following\n     /// values: all elements less than the one at the given index, the value at the given index,\n     /// and all elements greater than the one at the given index, using the provided comparator\n@@ -1906,7 +1906,7 @@ impl<T> [T] {\n     /// This reordering has the additional property that any value at position `i < index` will be\n     /// less than or equal to any value at a position `j > index` using the key extraction function.\n     /// Additionally, this reordering is unstable (i.e. any number of equal elements may end up at\n-    /// position `index`), in-place (i.e. does not allocate), and `O(n)` worst-case. This function\n+    /// position `index`), in-place (i.e. does not allocate), and *O*(*n*) worst-case. This function\n     /// is also known as \"kth element\" in other libraries. It returns a triplet of the following\n     /// values: all elements less than the one at the given index, the value at the given index, and\n     /// all elements greater than the one at the given index, using the provided key extraction"}, {"sha": "972a33d6489e986919558cfcd15f1bfaac392f02", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71384101ea3b030b80f7def80a37f67e148518b0/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71384101ea3b030b80f7def80a37f67e148518b0/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=71384101ea3b030b80f7def80a37f67e148518b0", "patch": "@@ -121,7 +121,7 @@ where\n \n /// Partially sorts a slice by shifting several out-of-order elements around.\n ///\n-/// Returns `true` if the slice is sorted at the end. This function is `O(n)` worst-case.\n+/// Returns `true` if the slice is sorted at the end. This function is *O*(*n*) worst-case.\n #[cold]\n fn partial_insertion_sort<T, F>(v: &mut [T], is_less: &mut F) -> bool\n where\n@@ -168,7 +168,7 @@ where\n     false\n }\n \n-/// Sorts a slice using insertion sort, which is `O(n^2)` worst-case.\n+/// Sorts a slice using insertion sort, which is *O*(*n*^2) worst-case.\n fn insertion_sort<T, F>(v: &mut [T], is_less: &mut F)\n where\n     F: FnMut(&T, &T) -> bool,\n@@ -178,7 +178,7 @@ where\n     }\n }\n \n-/// Sorts `v` using heapsort, which guarantees `O(n * log(n))` worst-case.\n+/// Sorts `v` using heapsort, which guarantees *O*(*n* \\* log(*n*)) worst-case.\n #[cold]\n pub fn heapsort<T, F>(v: &mut [T], is_less: &mut F)\n where\n@@ -751,7 +751,7 @@ where\n     }\n }\n \n-/// Sorts `v` using pattern-defeating quicksort, which is `O(n * log(n))` worst-case.\n+/// Sorts `v` using pattern-defeating quicksort, which is *O*(*n* \\* log(*n*)) worst-case.\n pub fn quicksort<T, F>(v: &mut [T], mut is_less: F)\n where\n     F: FnMut(&T, &T) -> bool,"}, {"sha": "2bb421a47efa689632dcc42dc445a584c0a8f845", "filename": "src/librustc_data_structures/sorted_map/index_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71384101ea3b030b80f7def80a37f67e148518b0/src%2Flibrustc_data_structures%2Fsorted_map%2Findex_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71384101ea3b030b80f7def80a37f67e148518b0/src%2Flibrustc_data_structures%2Fsorted_map%2Findex_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsorted_map%2Findex_map.rs?ref=71384101ea3b030b80f7def80a37f67e148518b0", "patch": "@@ -7,8 +7,8 @@ use std::iter::FromIterator;\n use crate::stable_hasher::{HashStable, StableHasher};\n use rustc_index::vec::{Idx, IndexVec};\n \n-/// An indexed multi-map that preserves insertion order while permitting both `O(log n)` lookup of\n-/// an item by key and `O(1)` lookup by index.\n+/// An indexed multi-map that preserves insertion order while permitting both *O*(log *n*) lookup of\n+/// an item by key and *O*(1) lookup by index.\n ///\n /// This data structure is a hybrid of an [`IndexVec`] and a [`SortedMap`]. Like `IndexVec`,\n /// `SortedIndexMultiMap` assigns a typed index to each item while preserving insertion order.\n@@ -20,7 +20,7 @@ use rustc_index::vec::{Idx, IndexVec};\n /// items will be yielded in insertion order.\n ///\n /// Unlike a general-purpose map like `BTreeSet` or `HashSet`, `SortedMap` and\n-/// `SortedIndexMultiMap` require `O(n)` time to insert a single item. This is because we may need\n+/// `SortedIndexMultiMap` require *O*(*n*) time to insert a single item. This is because we may need\n /// to insert into the middle of the sorted array. Users should avoid mutating this data structure\n /// in-place.\n ///"}, {"sha": "dd2fbaf6a94f35b9dce7717db1132ffeb7a6e5a0", "filename": "src/librustc_index/bit_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71384101ea3b030b80f7def80a37f67e148518b0/src%2Flibrustc_index%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71384101ea3b030b80f7def80a37f67e148518b0/src%2Flibrustc_index%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Fbit_set.rs?ref=71384101ea3b030b80f7def80a37f67e148518b0", "patch": "@@ -772,7 +772,7 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     }\n \n     /// Returns those indices that are true in rows `a` and `b`. This\n-    /// is an O(n) operation where `n` is the number of elements\n+    /// is an *O*(*n*) operation where *n* is the number of elements\n     /// (somewhat independent from the actual size of the\n     /// intersection, in particular).\n     pub fn intersect_rows(&self, row1: R, row2: R) -> Vec<C> {"}, {"sha": "b6488ae61b153ee2c1cb6ffeb0184f7d70dbace5", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71384101ea3b030b80f7def80a37f67e148518b0/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71384101ea3b030b80f7def80a37f67e148518b0/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=71384101ea3b030b80f7def80a37f67e148518b0", "patch": "@@ -86,7 +86,7 @@\n //! cost are suffixed with a `~`.\n //!\n //! All amortized costs are for the potential need to resize when capacity is\n-//! exhausted. If a resize occurs it will take O(n) time. Our collections never\n+//! exhausted. If a resize occurs it will take *O*(*n*) time. Our collections never\n //! automatically shrink, so removal operations aren't amortized. Over a\n //! sufficiently large series of operations, the average cost per operation will\n //! deterministically equal the given cost."}]}