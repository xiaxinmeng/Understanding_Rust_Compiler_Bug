{"sha": "6f2a161b1bbe6234188d6cfb3cabddef1e6ef20f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmMmExNjFiMWJiZTYyMzQxODhkNmNmYjNjYWJkZGVmMWU2ZWYyMGY=", "commit": {"author": {"name": "Michael Hewson", "email": "michael@michaelhewson.ca", "date": "2018-10-09T00:40:57Z"}, "committer": {"name": "Michael Hewson", "email": "michael@michaelhewson.ca", "date": "2018-11-01T22:16:59Z"}, "message": "Add layout sanity checks in object safety\n\nIf object-safety checks succeed for a receiver type, make sure the\nreceiver\u2019s abi is\na) a Scalar, when Self = ()\nb) a ScalarPair, when Self = dyn Trait", "tree": {"sha": "8364fe1143a73faadc2ffd0442f5ececfa2162fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8364fe1143a73faadc2ffd0442f5ececfa2162fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f2a161b1bbe6234188d6cfb3cabddef1e6ef20f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f2a161b1bbe6234188d6cfb3cabddef1e6ef20f", "html_url": "https://github.com/rust-lang/rust/commit/6f2a161b1bbe6234188d6cfb3cabddef1e6ef20f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f2a161b1bbe6234188d6cfb3cabddef1e6ef20f/comments", "author": {"login": "mikeyhew", "id": 6751033, "node_id": "MDQ6VXNlcjY3NTEwMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6751033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikeyhew", "html_url": "https://github.com/mikeyhew", "followers_url": "https://api.github.com/users/mikeyhew/followers", "following_url": "https://api.github.com/users/mikeyhew/following{/other_user}", "gists_url": "https://api.github.com/users/mikeyhew/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikeyhew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikeyhew/subscriptions", "organizations_url": "https://api.github.com/users/mikeyhew/orgs", "repos_url": "https://api.github.com/users/mikeyhew/repos", "events_url": "https://api.github.com/users/mikeyhew/events{/privacy}", "received_events_url": "https://api.github.com/users/mikeyhew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mikeyhew", "id": 6751033, "node_id": "MDQ6VXNlcjY3NTEwMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6751033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikeyhew", "html_url": "https://github.com/mikeyhew", "followers_url": "https://api.github.com/users/mikeyhew/followers", "following_url": "https://api.github.com/users/mikeyhew/following{/other_user}", "gists_url": "https://api.github.com/users/mikeyhew/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikeyhew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikeyhew/subscriptions", "organizations_url": "https://api.github.com/users/mikeyhew/orgs", "repos_url": "https://api.github.com/users/mikeyhew/repos", "events_url": "https://api.github.com/users/mikeyhew/events{/privacy}", "received_events_url": "https://api.github.com/users/mikeyhew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74ef46cfa2c7d8befbd82faf973268957d5b718d", "url": "https://api.github.com/repos/rust-lang/rust/commits/74ef46cfa2c7d8befbd82faf973268957d5b718d", "html_url": "https://github.com/rust-lang/rust/commit/74ef46cfa2c7d8befbd82faf973268957d5b718d"}], "stats": {"total": 100, "additions": 100, "deletions": 0}, "files": [{"sha": "7e2b56379521aa1c2a9bcf649433c0af84bf9788", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/6f2a161b1bbe6234188d6cfb3cabddef1e6ef20f/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f2a161b1bbe6234188d6cfb3cabddef1e6ef20f/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=6f2a161b1bbe6234188d6cfb3cabddef1e6ef20f", "patch": "@@ -326,12 +326,112 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         if receiver_ty != self.mk_self_type() {\n             if !self.receiver_is_dispatchable(method, receiver_ty) {\n                 return Some(MethodViolationCode::UndispatchableReceiver);\n+            } else {\n+                // sanity check to make sure the receiver actually has the layout of a pointer\n+\n+                use ty::layout::Abi;\n+\n+                let param_env = self.param_env(method.def_id);\n+\n+                let abi_of_ty = |ty: Ty<'tcx>| -> &Abi {\n+                    match self.layout_of(param_env.and(ty)) {\n+                        Ok(layout) => &layout.abi,\n+                        Err(err) => bug!(\n+                            \"Error: {}\\n while computing layout for type {:?}\", err, ty\n+                        )\n+                    }\n+                };\n+\n+                // e.g. Rc<()>\n+                let unit_receiver_ty = self.receiver_for_self_ty(\n+                    receiver_ty, self.mk_unit(), method.def_id\n+                );\n+\n+                match abi_of_ty(unit_receiver_ty) {\n+                    &Abi::Scalar(..) => (),\n+                    abi => bug!(\"Receiver when Self = () should have a Scalar ABI, found {:?}\", abi)\n+                }\n+\n+                let trait_object_ty = self.object_ty_for_trait(\n+                    trait_def_id, self.mk_region(ty::ReStatic)\n+                );\n+\n+                // e.g. Rc<dyn Trait>\n+                let trait_object_receiver = self.receiver_for_self_ty(\n+                    receiver_ty, trait_object_ty, method.def_id\n+                );\n+\n+                match abi_of_ty(trait_object_receiver) {\n+                    &Abi::ScalarPair(..) => (),\n+                    abi => bug!(\n+                        \"Receiver when Self = {} should have a ScalarPair ABI, found {:?}\",\n+                        trait_object_ty, abi\n+                    )\n+                }\n             }\n         }\n \n         None\n     }\n \n+    /// performs a type substitution to produce the version of receiver_ty when `Self = self_ty`\n+    /// e.g. for receiver_ty = `Rc<Self>` and self_ty = `Foo`, returns `Rc<Foo>`\n+    fn receiver_for_self_ty(\n+        self, receiver_ty: Ty<'tcx>, self_ty: Ty<'tcx>, method_def_id: DefId\n+    ) -> Ty<'tcx> {\n+        let substs = Substs::for_item(self, method_def_id, |param, _| {\n+            if param.index == 0 {\n+                self_ty.into()\n+            } else {\n+                self.mk_param_from_def(param)\n+            }\n+        });\n+\n+        receiver_ty.subst(self, substs)\n+    }\n+\n+    /// creates the object type for the current trait. For example,\n+    /// if the current trait is `Deref`, then this will be\n+    /// `dyn Deref<Target=Self::Target> + 'static`\n+    fn object_ty_for_trait(self, trait_def_id: DefId, lifetime: ty::Region<'tcx>) -> Ty<'tcx> {\n+        debug!(\"object_ty_for_trait: trait_def_id={:?}\", trait_def_id);\n+\n+        let trait_ref = ty::TraitRef::identity(self, trait_def_id);\n+\n+        let trait_predicate = ty::ExistentialPredicate::Trait(\n+            ty::ExistentialTraitRef::erase_self_ty(self, trait_ref)\n+        );\n+\n+        let mut associated_types = traits::supertraits(self, ty::Binder::dummy(trait_ref))\n+            .flat_map(|trait_ref| self.associated_items(trait_ref.def_id()))\n+            .filter(|item| item.kind == ty::AssociatedKind::Type)\n+            .collect::<Vec<_>>();\n+\n+        // existential predicates need to be in a specific order\n+        associated_types.sort_by_key(|item| self.def_path_hash(item.def_id));\n+\n+        let projection_predicates = associated_types.into_iter().map(|item| {\n+            ty::ExistentialPredicate::Projection(ty::ExistentialProjection {\n+                ty: self.mk_projection(item.def_id, trait_ref.substs),\n+                item_def_id: item.def_id,\n+                substs: trait_ref.substs,\n+            })\n+        });\n+\n+        let existential_predicates = self.mk_existential_predicates(\n+            iter::once(trait_predicate).chain(projection_predicates)\n+        );\n+\n+        let object_ty = self.mk_dynamic(\n+            ty::Binder::dummy(existential_predicates),\n+            lifetime,\n+        );\n+\n+        debug!(\"object_ty_for_trait: object_ty=`{}`\", object_ty);\n+\n+        object_ty\n+    }\n+\n     /// checks the method's receiver (the `self` argument) can be dispatched on when `Self` is a\n     /// trait object. We require that `DispatchableFromDyn` be implemented for the receiver type\n     /// in the following way:"}]}