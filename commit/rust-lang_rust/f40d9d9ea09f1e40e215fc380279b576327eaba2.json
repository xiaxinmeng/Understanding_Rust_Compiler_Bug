{"sha": "f40d9d9ea09f1e40e215fc380279b576327eaba2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0MGQ5ZDllYTA5ZjFlNDBlMjE1ZmMzODAyNzliNTc2MzI3ZWFiYTI=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-04-27T16:17:31Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-04-30T12:27:53Z"}, "message": "Regression tests for #24805.\n\nThe new functionality being tested here is that a drop impl bounded by\n`UserDefined` does not cause dropck to inject its conservative\nconstraints on region inference.", "tree": {"sha": "45a77c1109fe4466e8a7865d6125d14581df1764", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45a77c1109fe4466e8a7865d6125d14581df1764"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f40d9d9ea09f1e40e215fc380279b576327eaba2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f40d9d9ea09f1e40e215fc380279b576327eaba2", "html_url": "https://github.com/rust-lang/rust/commit/f40d9d9ea09f1e40e215fc380279b576327eaba2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f40d9d9ea09f1e40e215fc380279b576327eaba2/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db88e5a498ff8a4c7aa6951095e2d217822b11bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/db88e5a498ff8a4c7aa6951095e2d217822b11bf", "html_url": "https://github.com/rust-lang/rust/commit/db88e5a498ff8a4c7aa6951095e2d217822b11bf"}], "stats": {"total": 191, "additions": 191, "deletions": 0}, "files": [{"sha": "37ef81e6866efd4c72722442175a20b73ff11357", "filename": "src/test/compile-fail/issue-24805-dropck-child-has-items-via-parent.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f40d9d9ea09f1e40e215fc380279b576327eaba2/src%2Ftest%2Fcompile-fail%2Fissue-24805-dropck-child-has-items-via-parent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40d9d9ea09f1e40e215fc380279b576327eaba2/src%2Ftest%2Fcompile-fail%2Fissue-24805-dropck-child-has-items-via-parent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-24805-dropck-child-has-items-via-parent.rs?ref=f40d9d9ea09f1e40e215fc380279b576327eaba2", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that child trait who only has items via its *parent* trait\n+// does cause dropck to inject extra region constraints.\n+\n+#![allow(non_camel_case_types)]\n+\n+trait Parent { fn foo(&self); }\n+trait Child: Parent { }\n+\n+impl Parent for i32 { fn foo(&self) { } }\n+impl<'a> Parent for &'a D_Child<i32> {\n+    fn foo(&self) {\n+        println!(\"accessing child value: {}\", self.0);\n+    }\n+}\n+\n+impl Child for i32 { }\n+impl<'a> Child for &'a D_Child<i32> { }\n+\n+struct D_Child<T:Child>(T);\n+impl <T:Child> Drop for D_Child<T> { fn drop(&mut self) { self.0.foo() } }\n+\n+fn f_child() {\n+    // `_d` and `d1` are assigned the *same* lifetime by region inference ...\n+    let (_d, d1);\n+\n+    d1 = D_Child(1);\n+    // ... we store a reference to `d1` within `_d` ...\n+    _d = D_Child(&d1); //~ ERROR `d1` does not live long enough\n+\n+    // ... dropck *should* complain, because Drop of _d could (and\n+    // does) access the already dropped `d1` via the `foo` method.\n+}\n+\n+fn main() {\n+    f_child();\n+}"}, {"sha": "0da1b9fc6e196644300e048fc9e2a5fd6637d911", "filename": "src/test/compile-fail/issue-24805-dropck-trait-has-items.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f40d9d9ea09f1e40e215fc380279b576327eaba2/src%2Ftest%2Fcompile-fail%2Fissue-24805-dropck-trait-has-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40d9d9ea09f1e40e215fc380279b576327eaba2/src%2Ftest%2Fcompile-fail%2Fissue-24805-dropck-trait-has-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-24805-dropck-trait-has-items.rs?ref=f40d9d9ea09f1e40e215fc380279b576327eaba2", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that traits with various kinds of associated items cause\n+// dropck to inject extra region constraints.\n+\n+#![allow(non_camel_case_types)]\n+\n+trait HasSelfMethod { fn m1(&self) { } }\n+trait HasMethodWithSelfArg { fn m2(x: &Self) { } }\n+trait HasType { type Something; }\n+\n+impl HasSelfMethod for i32 { }\n+impl HasMethodWithSelfArg for i32 { }\n+impl HasType for i32 { type Something = (); }\n+\n+impl<'a,T> HasSelfMethod for &'a T { }\n+impl<'a,T> HasMethodWithSelfArg for &'a T { }\n+impl<'a,T> HasType for &'a T { type Something = (); }\n+\n+// e.g. `impl_drop!(Send, D_Send)` expands to:\n+//   ```rust\n+//   struct D_Send<T:Send>(T);\n+//   impl<T:Send> Drop for D_Send<T> { fn drop(&mut self) { } }\n+//   ```\n+macro_rules! impl_drop {\n+    ($Bound:ident, $Id:ident) => {\n+        struct $Id<T:$Bound>(T);\n+        impl <T:$Bound> Drop for $Id<T> { fn drop(&mut self) { } }\n+    }\n+}\n+\n+impl_drop!{HasSelfMethod,        D_HasSelfMethod}\n+impl_drop!{HasMethodWithSelfArg, D_HasMethodWithSelfArg}\n+impl_drop!{HasType,              D_HasType}\n+\n+fn f_sm() {\n+    let (_d, d1);\n+    d1 = D_HasSelfMethod(1);\n+    _d = D_HasSelfMethod(&d1); //~ ERROR `d1` does not live long enough\n+}\n+fn f_mwsa() {\n+    let (_d, d1);\n+    d1 = D_HasMethodWithSelfArg(1);\n+    _d = D_HasMethodWithSelfArg(&d1); //~ ERROR `d1` does not live long enough\n+}\n+fn f_t() {\n+    let (_d, d1);\n+    d1 = D_HasType(1);\n+    _d = D_HasType(&d1); //~ ERROR `d1` does not live long enough\n+}\n+\n+fn main() {\n+    f_sm();\n+    f_mwsa();\n+    f_t();\n+}"}, {"sha": "4512bcc2000bf56971654451e65708d932dc58d9", "filename": "src/test/run-pass/issue-24805-dropck-itemless.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/f40d9d9ea09f1e40e215fc380279b576327eaba2/src%2Ftest%2Frun-pass%2Fissue-24805-dropck-itemless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40d9d9ea09f1e40e215fc380279b576327eaba2/src%2Ftest%2Frun-pass%2Fissue-24805-dropck-itemless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-24805-dropck-itemless.rs?ref=f40d9d9ea09f1e40e215fc380279b576327eaba2", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that item-less traits do not cause dropck to inject extra\n+// region constraints.\n+\n+#![allow(non_camel_case_types)]\n+\n+trait UserDefined { }\n+\n+impl UserDefined for i32 { }\n+impl<'a, T> UserDefined for &'a T { }\n+\n+// e.g. `impl_drop!(Send, D_Send)` expands to:\n+//   ```rust\n+//   struct D_Send<T:Send>(T);\n+//   impl<T:Send> Drop for D_Send<T> { fn drop(&mut self) { } }\n+//   ```\n+macro_rules! impl_drop {\n+    ($Bound:ident, $Id:ident) => {\n+        struct $Id<T:$Bound>(T);\n+        impl <T:$Bound> Drop for $Id<T> { fn drop(&mut self) { } }\n+    }\n+}\n+\n+impl_drop!{Send,         D_Send}\n+impl_drop!{Sized,        D_Sized}\n+\n+// See note below regarding Issue 24895\n+// impl_drop!{Copy,         D_Copy}\n+\n+impl_drop!{Sync,         D_Sync}\n+impl_drop!{UserDefined,  D_UserDefined}\n+\n+macro_rules! body {\n+    ($id:ident) => { {\n+        // `_d` and `d1` are assigned the *same* lifetime by region inference ...\n+        let (_d, d1);\n+\n+        d1 = $id(1);\n+        // ... we store a reference to `d1` within `_d` ...\n+        _d = $id(&d1);\n+\n+        // ... a *conservative* dropck will thus complain, because it\n+        // thinks Drop of _d could access the already dropped `d1`.\n+    } }\n+}\n+\n+fn f_send() { body!(D_Send) }\n+fn f_sized() { body!(D_Sized) }\n+fn f_sync() { body!(D_Sync) }\n+\n+// Issue 24895: Copy: Clone implies `impl<T:Copy> Drop for ...` can\n+// access a user-defined clone() method, which causes this test case\n+// to fail.\n+//\n+// If 24895 is resolved by removing the `Copy: Clone` relationship,\n+// then this definition and the call below should be uncommented. If\n+// it is resolved by deciding to keep the `Copy: Clone` relationship,\n+// then this comment and the associated bits of code can all be\n+// removed.\n+\n+// fn f_copy() { body!(D_Copy) }\n+\n+fn f_userdefined() { body!(D_UserDefined) }\n+\n+fn main() {\n+    f_send();\n+    f_sized();\n+    // See note above regarding Issue 24895.\n+    // f_copy();\n+    f_sync();\n+    f_userdefined();\n+}"}]}