{"sha": "8f53bdb45fb340ddd3630550b69675a880224d08", "node_id": "C_kwDOAAsO6NoAKDhmNTNiZGI0NWZiMzQwZGRkMzYzMDU1MGI2OTY3NWE4ODAyMjRkMDg", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-23T11:26:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-23T11:26:48Z"}, "message": "Rollup merge of #94285 - bjorn3:sync_cg_clif-2022-02-23, r=bjorn3\n\nSync rustc_codegen_cranelift\n\nr? `@ghost`\n\n`@rustbot` label +A-codegen +A-cranelift +T-compiler", "tree": {"sha": "04b67fd798dcf45b4e42a332be616934b9536aab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04b67fd798dcf45b4e42a332be616934b9536aab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f53bdb45fb340ddd3630550b69675a880224d08", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiFhn4CRBK7hj4Ov3rIwAAnm4IADfDfFdOHc4ANoVOjhGAHb6P\noR8KUjgY37damtKdTiBxZsPvy2eXFAFz7wiXVmY3VFN/2Fr4Vd8rmlBakvjAKbPR\n4NweA/mrnYdu6xvPKQtwvCIhXkSzEhaPei1isQylGUkm6gokw1dJWsynHpnqv7st\nPIrebztTB6lBLX+AgazFM0wvCHHhkYqIpDanQ+KisGI+3TNRuLIZURKdEFebHGMP\nwmR66ktPovz2ycY6CiJ4+5qLugdtucYwbC2sCwnGZkDYVkhHX6ktEBzU1PN0fBAy\n4jhossx42xGmcvwVr0br5VazKJk44nJK48sZognTo5kiR5y7C1LXchDfPbl1h/8=\n=++0u\n-----END PGP SIGNATURE-----\n", "payload": "tree 04b67fd798dcf45b4e42a332be616934b9536aab\nparent ecf2faacfffe42a12caf75144ed51a836353267e\nparent f596dce542d31e56eac60836cc8d3621511410d9\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1645615608 +0100\ncommitter GitHub <noreply@github.com> 1645615608 +0100\n\nRollup merge of #94285 - bjorn3:sync_cg_clif-2022-02-23, r=bjorn3\n\nSync rustc_codegen_cranelift\n\nr? `@ghost`\n\n`@rustbot` label +A-codegen +A-cranelift +T-compiler\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f53bdb45fb340ddd3630550b69675a880224d08", "html_url": "https://github.com/rust-lang/rust/commit/8f53bdb45fb340ddd3630550b69675a880224d08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f53bdb45fb340ddd3630550b69675a880224d08/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecf2faacfffe42a12caf75144ed51a836353267e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecf2faacfffe42a12caf75144ed51a836353267e", "html_url": "https://github.com/rust-lang/rust/commit/ecf2faacfffe42a12caf75144ed51a836353267e"}, {"sha": "f596dce542d31e56eac60836cc8d3621511410d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f596dce542d31e56eac60836cc8d3621511410d9", "html_url": "https://github.com/rust-lang/rust/commit/f596dce542d31e56eac60836cc8d3621511410d9"}], "stats": {"total": 1650, "additions": 842, "deletions": 808}, "files": [{"sha": "f15e319e3b80709b1a335215e499656a3f10132d", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=8f53bdb45fb340ddd3630550b69675a880224d08", "patch": "@@ -4,9 +4,9 @@ version = 3\n \n [[package]]\n name = \"anyhow\"\n-version = \"1.0.51\"\n+version = \"1.0.53\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8b26702f315f53b6071259e15dd9d64528213b44d61de1ec926eca7715d62203\"\n+checksum = \"94a45b455c14666b85fc40a019e8ab9eb75e3a124e05494f5397122bc9eb06e0\"\n \n [[package]]\n name = \"ar\"\n@@ -33,18 +33,18 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.78.0\"\n+version = \"0.81.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cc0cb7df82c8cf8f2e6a8dd394a0932a71369c160cc9b027dca414fced242513\"\n+checksum = \"71447555acc6c875c52c407d572fc1327dc5c34cba72b4b2e7ad048aa4e4fd19\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.78.0\"\n+version = \"0.81.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fe4463c15fa42eee909e61e5eac4866b7c6d22d0d8c621e57a0c5380753bfa8c\"\n+checksum = \"ec9a10261891a7a919b0d4f6aa73582e88441d9a8f6173c88efbe4a5a362ea67\"\n dependencies = [\n  \"cranelift-bforest\",\n  \"cranelift-codegen-meta\",\n@@ -59,31 +59,30 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.78.0\"\n+version = \"0.81.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"793f6a94a053a55404ea16e1700202a88101672b8cd6b4df63e13cde950852bf\"\n+checksum = \"815755d76fcbcf6e17ab888545b28ab775f917cb12ce0797e60cd41a2288692c\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n- \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.78.0\"\n+version = \"0.81.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"44aa1846df275bce5eb30379d65964c7afc63c05a117076e62a119c25fe174be\"\n+checksum = \"23ea92f2a67335a2e4d3c9c65624c3b14ae287d595b0650822c41824febab66b\"\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.78.0\"\n+version = \"0.81.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a3a45d8d6318bf8fc518154d9298eab2a8154ec068a8885ff113f6db8d69bb3a\"\n+checksum = \"bd25847875e388c500ad3624b4d2e14067955c93185194a7222246a25b91c975\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.78.0\"\n+version = \"0.81.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e07339bd461766deb7605169de039e01954768ff730fa1254e149001884a8525\"\n+checksum = \"308bcfb7eb47bdf5ff6e1ace262af4ed39ec19f204c751fffb037e0e82a0c8bf\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -93,9 +92,9 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.78.0\"\n+version = \"0.81.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0e8f0d60fb5d67f7a1e5c49db38ba96d1c846921faef02085fc5590b74781747\"\n+checksum = \"f560b3a314b8d15facf411e5d29b917c3e787a2bbc3fcdc5183bc0c5b7d4fe01\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -111,21 +110,19 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.78.0\"\n+version = \"0.81.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"825ac7e0959cbe7ddc9cc21209f0319e611a57f9fcb2b723861fe7ef2017e651\"\n+checksum = \"3a57aba9e603d694d1430ff38bd914bae23ef9c2e44b25a65e318905807e654c\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n- \"cranelift-entity\",\n- \"log\",\n ]\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.78.0\"\n+version = \"0.81.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"03e2fca76ff57e0532936a71e3fc267eae6a19a86656716479c66e7f912e3d7b\"\n+checksum = \"12cdc799aee673be2317e631d4569a1ba0a7e77a07a7ce45557086d2e02e9514\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"libc\",\n@@ -134,9 +131,9 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.78.0\"\n+version = \"0.81.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"55500d0fc9bb05c0944fc4506649249d28f55bd4fe95b87f0e55bf41058f0e6d\"\n+checksum = \"502a7333836052fcdf4425d7f7a21264d99f862d32b9c3a0e47cd920487a9b60\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -148,18 +145,18 @@ dependencies = [\n \n [[package]]\n name = \"crc32fast\"\n-version = \"1.3.0\"\n+version = \"1.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"738c290dfaea84fc1ca15ad9c168d083b05a714e1efddd8edaab678dc28d2836\"\n+checksum = \"a2209c310e29876f7f0b2721e7e26b84aff178aa3da5d091f9bfbf47669e60e3\"\n dependencies = [\n  \"cfg-if\",\n ]\n \n [[package]]\n name = \"gimli\"\n-version = \"0.25.0\"\n+version = \"0.26.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f0a01e0497841a3b2db4f8afa483cce65f7e96a3498bd6c541734792aeac8fe7\"\n+checksum = \"78cc372d058dcf6d5ecd98510e7fbc9e5aec4d21de70f65fea8fecebcd881bd4\"\n dependencies = [\n  \"indexmap\",\n ]\n@@ -182,9 +179,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.112\"\n+version = \"0.2.116\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1b03d17f364a3a042d5e5d46b053bbbf82c92c9430c592dd4c064dc6ee997125\"\n+checksum = \"565dbd88872dbe4cc8a46e527f26483c1d1f7afa6b884a3bd6cd893d4f98da74\"\n \n [[package]]\n name = \"libloading\"\n@@ -233,9 +230,9 @@ dependencies = [\n \n [[package]]\n name = \"regalloc\"\n-version = \"0.0.32\"\n+version = \"0.0.34\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a6304468554ed921da3d32c355ea107b8d13d7b8996c3adfb7aab48d3bc321f4\"\n+checksum = \"62446b1d3ebf980bdc68837700af1d77b37bc430e524bf95319c6eada2a4cc02\"\n dependencies = [\n  \"log\",\n  \"rustc-hash\",\n@@ -281,9 +278,9 @@ dependencies = [\n \n [[package]]\n name = \"smallvec\"\n-version = \"1.7.0\"\n+version = \"1.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1ecab6c735a6bb4139c0caafd0cc3635748bbb3acf4550e8138122099251f309\"\n+checksum = \"f2dd574626839106c320a323308629dcb1acfc96e32a8cba364ddc61ac23ee83\"\n \n [[package]]\n name = \"target-lexicon\""}, {"sha": "178404af42d677406b189edeb1e047d566fe7c30", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=8f53bdb45fb340ddd3630550b69675a880224d08", "patch": "@@ -8,14 +8,14 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { version = \"0.78.0\", features = [\"unwind\", \"all-arch\"] }\n-cranelift-frontend = \"0.78.0\"\n-cranelift-module = \"0.78.0\"\n-cranelift-native = \"0.78.0\"\n-cranelift-jit = { version = \"0.78.0\", optional = true }\n-cranelift-object = \"0.78.0\"\n+cranelift-codegen = { version = \"0.81.0\", features = [\"unwind\", \"all-arch\"] }\n+cranelift-frontend = \"0.81.0\"\n+cranelift-module = \"0.81.0\"\n+cranelift-native = \"0.81.0\"\n+cranelift-jit = { version = \"0.81.0\", optional = true }\n+cranelift-object = \"0.81.0\"\n target-lexicon = \"0.12.0\"\n-gimli = { version = \"0.25.0\", default-features = false, features = [\"write\"]}\n+gimli = { version = \"0.26.0\", default-features = false, features = [\"write\"]}\n object = { version = \"0.27.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n \n ar = { git = \"https://github.com/bjorn3/rust-ar.git\", branch = \"do_not_remove_cg_clif_ranlib\" }"}, {"sha": "b97863951429c87bb61f64a02399d6801445e96d", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=8f53bdb45fb340ddd3630550b69675a880224d08", "patch": "@@ -34,15 +34,15 @@ dependencies = [\n \n [[package]]\n name = \"autocfg\"\n-version = \"1.0.1\"\n+version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a\"\n+checksum = \"d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.72\"\n+version = \"1.0.73\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"22a9137b95ea06864e018375b72adfb7db6e6f68cfc8df5a04d00288050485ee\"\n+checksum = \"2fff2a6927b3bb87f9595d67196a70493f627687a71d87a0d692242c33f58c11\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -56,7 +56,7 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.66\"\n+version = \"0.1.70\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -110,9 +110,9 @@ dependencies = [\n \n [[package]]\n name = \"hashbrown\"\n-version = \"0.11.2\"\n+version = \"0.12.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ab5ef0d4909ef3724cc8cce6ccc8572c5c817592e9285f5464f8e86f8bd3726e\"\n+checksum = \"8c21d40587b92fa6a6c6e3c1bdbf87d75511db5672f9c93175574b3a00df1758\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n@@ -121,9 +121,9 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.1.19\"\n+version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"62b467343b94ba476dcb2500d242dadbb39557df889310ac77c5d99100aaac33\"\n+checksum = \"1ab7905ea95c6d9af62940f9d7dd9596d54c334ae2c15300c482051292d5637f\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\",\n@@ -132,9 +132,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.112\"\n+version = \"0.2.119\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1b03d17f364a3a042d5e5d46b053bbbf82c92c9430c592dd4c064dc6ee997125\"\n+checksum = \"1bf2e165bb3457c8e098ea76f3e3bc9db55f87aa90d52d0e6be741470916aaa4\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -319,9 +319,9 @@ dependencies = [\n \n [[package]]\n name = \"wasi\"\n-version = \"0.9.0+wasi-snapshot-preview1\"\n+version = \"0.11.0+wasi-snapshot-preview1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cccddf32554fecc6acb585f82a32a72e28b48f8c4c1883ddfeeeaa96f7d8e519\"\n+checksum = \"9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\","}, {"sha": "0a56eb131ed30f3a7e2a0bd13ef5e74a39569115", "filename": "compiler/rustc_codegen_cranelift/build_system/build_backend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs?ref=8f53bdb45fb340ddd3630550b69675a880224d08", "patch": "@@ -49,7 +49,7 @@ pub(crate) fn build_backend(\n     cmd.env(\"RUSTFLAGS\", rustflags);\n \n     eprintln!(\"[BUILD] rustc_codegen_cranelift\");\n-    crate::utils::spawn_and_wait(cmd);\n+    super::utils::spawn_and_wait(cmd);\n \n     Path::new(\"target\").join(host_triple).join(channel)\n }"}, {"sha": "c9c003d461095754bb0425786ab3ab796a3490b0", "filename": "compiler/rustc_codegen_cranelift/build_system/build_sysroot.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs?ref=8f53bdb45fb340ddd3630550b69675a880224d08", "patch": "@@ -3,9 +3,9 @@ use std::fs;\n use std::path::{Path, PathBuf};\n use std::process::{self, Command};\n \n-use crate::rustc_info::{get_file_name, get_rustc_version};\n-use crate::utils::{spawn_and_wait, try_hard_link};\n-use crate::SysrootKind;\n+use super::rustc_info::{get_file_name, get_rustc_version};\n+use super::utils::{spawn_and_wait, try_hard_link};\n+use super::SysrootKind;\n \n pub(crate) fn build_sysroot(\n     channel: &str,\n@@ -52,7 +52,7 @@ pub(crate) fn build_sysroot(\n         .arg(\"-g\");\n     spawn_and_wait(build_cargo_wrapper_cmd);\n \n-    let default_sysroot = crate::rustc_info::get_default_sysroot();\n+    let default_sysroot = super::rustc_info::get_default_sysroot();\n \n     let rustlib = target_dir.join(\"lib\").join(\"rustlib\");\n     let host_rustlib_lib = rustlib.join(host_triple).join(\"lib\");\n@@ -167,7 +167,7 @@ fn build_clif_sysroot_for_triple(\n \n     let build_dir = Path::new(\"build_sysroot\").join(\"target\").join(triple).join(channel);\n \n-    if !crate::config::get_bool(\"keep_sysroot\") {\n+    if !super::config::get_bool(\"keep_sysroot\") {\n         // Cleanup the target dir with the exception of build scripts and the incremental cache\n         for dir in [\"build\", \"deps\", \"examples\", \"native\"] {\n             if build_dir.join(dir).exists() {"}, {"sha": "b228da3981fdb58913fe2ee7692188e083896f15", "filename": "compiler/rustc_codegen_cranelift/build_system/mod.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs?ref=8f53bdb45fb340ddd3630550b69675a880224d08", "patch": "@@ -0,0 +1,127 @@\n+use std::env;\n+use std::path::PathBuf;\n+use std::process;\n+\n+mod build_backend;\n+mod build_sysroot;\n+mod config;\n+mod prepare;\n+mod rustc_info;\n+mod utils;\n+\n+fn usage() {\n+    eprintln!(\"Usage:\");\n+    eprintln!(\"  ./y.rs prepare\");\n+    eprintln!(\n+        \"  ./y.rs build [--debug] [--sysroot none|clif|llvm] [--target-dir DIR] [--no-unstable-features]\"\n+    );\n+}\n+\n+macro_rules! arg_error {\n+    ($($err:tt)*) => {{\n+        eprintln!($($err)*);\n+        usage();\n+        std::process::exit(1);\n+    }};\n+}\n+\n+enum Command {\n+    Build,\n+}\n+\n+#[derive(Copy, Clone)]\n+pub(crate) enum SysrootKind {\n+    None,\n+    Clif,\n+    Llvm,\n+}\n+\n+pub fn main() {\n+    env::set_var(\"CG_CLIF_DISPLAY_CG_TIME\", \"1\");\n+    env::set_var(\"CG_CLIF_DISABLE_INCR_CACHE\", \"1\");\n+    // The target dir is expected in the default location. Guard against the user changing it.\n+    env::set_var(\"CARGO_TARGET_DIR\", \"target\");\n+\n+    let mut args = env::args().skip(1);\n+    let command = match args.next().as_deref() {\n+        Some(\"prepare\") => {\n+            if args.next().is_some() {\n+                arg_error!(\"./x.rs prepare doesn't expect arguments\");\n+            }\n+            prepare::prepare();\n+            process::exit(0);\n+        }\n+        Some(\"build\") => Command::Build,\n+        Some(flag) if flag.starts_with('-') => arg_error!(\"Expected command found flag {}\", flag),\n+        Some(command) => arg_error!(\"Unknown command {}\", command),\n+        None => {\n+            usage();\n+            process::exit(0);\n+        }\n+    };\n+\n+    let mut target_dir = PathBuf::from(\"build\");\n+    let mut channel = \"release\";\n+    let mut sysroot_kind = SysrootKind::Clif;\n+    let mut use_unstable_features = true;\n+    while let Some(arg) = args.next().as_deref() {\n+        match arg {\n+            \"--target-dir\" => {\n+                target_dir = PathBuf::from(args.next().unwrap_or_else(|| {\n+                    arg_error!(\"--target-dir requires argument\");\n+                }))\n+            }\n+            \"--debug\" => channel = \"debug\",\n+            \"--sysroot\" => {\n+                sysroot_kind = match args.next().as_deref() {\n+                    Some(\"none\") => SysrootKind::None,\n+                    Some(\"clif\") => SysrootKind::Clif,\n+                    Some(\"llvm\") => SysrootKind::Llvm,\n+                    Some(arg) => arg_error!(\"Unknown sysroot kind {}\", arg),\n+                    None => arg_error!(\"--sysroot requires argument\"),\n+                }\n+            }\n+            \"--no-unstable-features\" => use_unstable_features = false,\n+            flag if flag.starts_with(\"-\") => arg_error!(\"Unknown flag {}\", flag),\n+            arg => arg_error!(\"Unexpected argument {}\", arg),\n+        }\n+    }\n+\n+    let host_triple = if let Ok(host_triple) = std::env::var(\"HOST_TRIPLE\") {\n+        host_triple\n+    } else if let Some(host_triple) = config::get_value(\"host\") {\n+        host_triple\n+    } else {\n+        rustc_info::get_host_triple()\n+    };\n+    let target_triple = if let Ok(target_triple) = std::env::var(\"TARGET_TRIPLE\") {\n+        if target_triple != \"\" {\n+            target_triple\n+        } else {\n+            host_triple.clone() // Empty target triple can happen on GHA\n+        }\n+    } else if let Some(target_triple) = config::get_value(\"target\") {\n+        target_triple\n+    } else {\n+        host_triple.clone()\n+    };\n+\n+    if target_triple.ends_with(\"-msvc\") {\n+        eprintln!(\"The MSVC toolchain is not yet supported by rustc_codegen_cranelift.\");\n+        eprintln!(\"Switch to the MinGW toolchain for Windows support.\");\n+        eprintln!(\"Hint: You can use `rustup set default-host x86_64-pc-windows-gnu` to\");\n+        eprintln!(\"set the global default target to MinGW\");\n+        process::exit(1);\n+    }\n+\n+    let cg_clif_build_dir =\n+        build_backend::build_backend(channel, &host_triple, use_unstable_features);\n+    build_sysroot::build_sysroot(\n+        channel,\n+        sysroot_kind,\n+        &target_dir,\n+        cg_clif_build_dir,\n+        &host_triple,\n+        &target_triple,\n+    );\n+}"}, {"sha": "4a7df2cebbcb6efff9376857115f6e6c1b6cec4e", "filename": "compiler/rustc_codegen_cranelift/build_system/prepare.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs?ref=8f53bdb45fb340ddd3630550b69675a880224d08", "patch": "@@ -5,8 +5,8 @@ use std::fs;\n use std::path::Path;\n use std::process::Command;\n \n-use crate::rustc_info::{get_file_name, get_rustc_path, get_rustc_version};\n-use crate::utils::{copy_dir_recursively, spawn_and_wait};\n+use super::rustc_info::{get_file_name, get_rustc_path, get_rustc_version};\n+use super::utils::{copy_dir_recursively, spawn_and_wait};\n \n pub(crate) fn prepare() {\n     prepare_sysroot();\n@@ -92,7 +92,7 @@ fn prepare_sysroot() {\n     clone_repo(\n         \"build_sysroot/compiler-builtins\",\n         \"https://github.com/rust-lang/compiler-builtins.git\",\n-        \"0.1.66\",\n+        \"0.1.70\",\n     );\n     apply_patches(\"compiler-builtins\", Path::new(\"build_sysroot/compiler-builtins\"));\n }"}, {"sha": "ea1f8c1e8920a9a1b432430d97946e1114889803", "filename": "compiler/rustc_codegen_cranelift/clean_all.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh?ref=8f53bdb45fb340ddd3630550b69675a880224d08", "patch": "@@ -2,5 +2,5 @@\n set -e\n \n rm -rf build_sysroot/{sysroot_src/,target/,compiler-builtins/,rustc_version}\n-rm -rf target/ build/ perf.data{,.old}\n+rm -rf target/ build/ perf.data{,.old} y.bin\n rm -rf rand/ regex/ simple-raytracer/ portable-simd/"}, {"sha": "460e42d1d8cc3bb1eb5fe70b029f14d9fe8437c1", "filename": "compiler/rustc_codegen_cranelift/patches/0001-compiler-builtins-Disable-128bit-atomic-operations.patch", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-compiler-builtins-Disable-128bit-atomic-operations.patch", "raw_url": "https://github.com/rust-lang/rust/raw/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-compiler-builtins-Disable-128bit-atomic-operations.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-compiler-builtins-Disable-128bit-atomic-operations.patch?ref=8f53bdb45fb340ddd3630550b69675a880224d08", "patch": "@@ -13,33 +13,33 @@ index 107762c..2d1ae10 100644\n --- a/src/mem/mod.rs\n +++ b/src/mem/mod.rs\n @@ -137,10 +137,6 @@ intrinsics! {\n-     pub extern \"C\" fn __llvm_memcpy_element_unordered_atomic_8(dest: *mut u64, src: *const u64, bytes: usize) -> () {\n+     pub unsafe extern \"C\" fn __llvm_memcpy_element_unordered_atomic_8(dest: *mut u64, src: *const u64, bytes: usize) -> () {\n          memcpy_element_unordered_atomic(dest, src, bytes);\n      }\n -    #[cfg(target_has_atomic_load_store = \"128\")]\n--    pub extern \"C\" fn __llvm_memcpy_element_unordered_atomic_16(dest: *mut u128, src: *const u128, bytes: usize) -> () {\n+-    pub unsafe extern \"C\" fn __llvm_memcpy_element_unordered_atomic_16(dest: *mut u128, src: *const u128, bytes: usize) -> () {\n -        memcpy_element_unordered_atomic(dest, src, bytes);\n -    }\n  \n      #[cfg(target_has_atomic_load_store = \"8\")]\n-     pub extern \"C\" fn __llvm_memmove_element_unordered_atomic_1(dest: *mut u8, src: *const u8, bytes: usize) -> () {\n+     pub unsafe extern \"C\" fn __llvm_memmove_element_unordered_atomic_1(dest: *mut u8, src: *const u8, bytes: usize) -> () {\n @@ -158,10 +154,6 @@ intrinsics! {\n-     pub extern \"C\" fn __llvm_memmove_element_unordered_atomic_8(dest: *mut u64, src: *const u64, bytes: usize) -> () {\n+     pub unsafe extern \"C\" fn __llvm_memmove_element_unordered_atomic_8(dest: *mut u64, src: *const u64, bytes: usize) -> () {\n          memmove_element_unordered_atomic(dest, src, bytes);\n      }\n -    #[cfg(target_has_atomic_load_store = \"128\")]\n--    pub extern \"C\" fn __llvm_memmove_element_unordered_atomic_16(dest: *mut u128, src: *const u128, bytes: usize) -> () {\n+-    pub unsafe extern \"C\" fn __llvm_memmove_element_unordered_atomic_16(dest: *mut u128, src: *const u128, bytes: usize) -> () {\n -        memmove_element_unordered_atomic(dest, src, bytes);\n -    }\n  \n      #[cfg(target_has_atomic_load_store = \"8\")]\n-     pub extern \"C\" fn __llvm_memset_element_unordered_atomic_1(s: *mut u8, c: u8, bytes: usize) -> () {\n+     pub unsafe extern \"C\" fn __llvm_memset_element_unordered_atomic_1(s: *mut u8, c: u8, bytes: usize) -> () {\n @@ -179,8 +171,4 @@ intrinsics! {\n-     pub extern \"C\" fn __llvm_memset_element_unordered_atomic_8(s: *mut u64, c: u8, bytes: usize) -> () {\n+     pub unsafe extern \"C\" fn __llvm_memset_element_unordered_atomic_8(s: *mut u64, c: u8, bytes: usize) -> () {\n          memset_element_unordered_atomic(s, c, bytes);\n      }\n -    #[cfg(target_has_atomic_load_store = \"128\")]\n--    pub extern \"C\" fn __llvm_memset_element_unordered_atomic_16(s: *mut u128, c: u8, bytes: usize) -> () {\n+-    pub unsafe extern \"C\" fn __llvm_memset_element_unordered_atomic_16(s: *mut u128, c: u8, bytes: usize) -> () {\n -        memset_element_unordered_atomic(s, c, bytes);\n -    }\n  }"}, {"sha": "1c45c7573c8137817fc705efb38674a2e5e0de4b", "filename": "compiler/rustc_codegen_cranelift/patches/0022-sysroot-Disable-not-compiling-tests.patch", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-sysroot-Disable-not-compiling-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-sysroot-Disable-not-compiling-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-sysroot-Disable-not-compiling-tests.patch?ref=8f53bdb45fb340ddd3630550b69675a880224d08", "patch": "@@ -22,7 +22,7 @@ index 0000000..46fd999\n +[package]\n +name = \"core\"\n +version = \"0.0.0\"\n-+edition = \"2018\"\n++edition = \"2021\"\n +\n +[lib]\n +name = \"coretests\"\n@@ -44,7 +44,7 @@ index 1a6be3a..42dbd59 100644\n --- a/library/core/tests/ptr.rs\n +++ b/library/core/tests/ptr.rs\n @@ -250,6 +250,7 @@ fn test_unsized_nonnull() {\n-     assert!(ys == zs);\n+     };\n  }\n  \n +/*"}, {"sha": "8e6652af3747b8bb6a93fceade8da19c371251f8", "filename": "compiler/rustc_codegen_cranelift/patches/0027-sysroot-128bit-atomic-operations.patch", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-sysroot-128bit-atomic-operations.patch", "raw_url": "https://github.com/rust-lang/rust/raw/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-sysroot-128bit-atomic-operations.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-sysroot-128bit-atomic-operations.patch?ref=8f53bdb45fb340ddd3630550b69675a880224d08", "patch": "@@ -8,7 +8,6 @@ Cranelift doesn't support them yet\n  library/core/src/panic/unwind_safe.rs |  6 -----\n  library/core/src/sync/atomic.rs       | 38 ---------------------------\n  library/core/tests/atomic.rs          |  4 ---\n- library/std/src/time/monotonic.rs     |  6 +++--\n  4 files changed, 4 insertions(+), 50 deletions(-)\n \n diff --git a/library/core/src/panic/unwind_safe.rs b/library/core/src/panic/unwind_safe.rs\n@@ -99,38 +98,6 @@ index b735957..ea728b6 100644\n      #[cfg(target_has_atomic = \"ptr\")]\n      assert_eq!(align_of::<AtomicUsize>(), size_of::<AtomicUsize>());\n      #[cfg(target_has_atomic = \"ptr\")]\n-diff --git a/library/std/src/time/monotonic.rs b/library/std/src/time/monotonic.rs\n-index fa96b7a..2854f9c 100644\n---- a/library/std/src/time/monotonic.rs\n-+++ b/library/std/src/time/monotonic.rs\n-@@ -5,7 +5,7 @@ pub(super) fn monotonize(raw: time::Instant) -> time::Instant {\n-     inner::monotonize(raw)\n- }\n- \n--#[cfg(any(all(target_has_atomic = \"64\", not(target_has_atomic = \"128\")), target_arch = \"aarch64\"))]\n-+#[cfg(target_has_atomic = \"64\")]\n- pub mod inner {\n-     use crate::sync::atomic::AtomicU64;\n-     use crate::sync::atomic::Ordering::*;\n-@@ -70,6 +70,7 @@ pub mod inner {\n-     }\n- }\n- \n-+/*\n- #[cfg(all(target_has_atomic = \"128\", not(target_arch = \"aarch64\")))]\n- pub mod inner {\n-     use crate::sync::atomic::AtomicU128;\n-@@ -94,8 +95,9 @@ pub mod inner {\n-         ZERO.checked_add_duration(&Duration::new(secs, nanos)).unwrap()\n-     }\n- }\n-+*/\n- \n--#[cfg(not(any(target_has_atomic = \"64\", target_has_atomic = \"128\")))]\n-+#[cfg(not(target_has_atomic = \"64\"))]\n- pub mod inner {\n-     use crate::cmp;\n-     use crate::sys::time;\n -- \n 2.26.2.7.g19db9cfb68\n "}, {"sha": "1019b1f069e50e386c6d6d7cd6eb8e0ea991e783", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=8f53bdb45fb340ddd3630550b69675a880224d08", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2021-12-30\"\n+channel = \"nightly-2022-02-23\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "b146ea360376af05487e2d87c59602b39fce00a7", "filename": "compiler/rustc_codegen_cranelift/scripts/test_rustc_tests.sh", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh?ref=8f53bdb45fb340ddd3630550b69675a880224d08", "patch": "@@ -8,7 +8,7 @@ source ./scripts/setup_rust_fork.sh\n echo \"[TEST] Test suite of rustc\"\n pushd rust\n \n-cargo install ripgrep\n+command -v rg >/dev/null 2>&1 || cargo install ripgrep\n \n rm -r src/test/ui/{extern/,panics/,unsized-locals/,lto/,simd*,linkage*,unwind-*.rs} || true\n for test in $(rg --files-with-matches \"asm!|catch_unwind|should_panic|lto|// needs-asm-support\" src/test/ui); do\n@@ -78,6 +78,8 @@ rm src/test/ui/intrinsics/const-eval-select-x86_64.rs # same\n rm src/test/ui/match/issue-82392.rs # differing error\n rm src/test/ui/consts/min_const_fn/address_of_const.rs # same\n rm src/test/ui/consts/issue-miri-1910.rs # same\n+rm src/test/ui/generic-associated-types/bugs/issue-80626.rs # same\n+rm src/test/ui/generic-associated-types/bugs/issue-89008.rs # same\n rm src/test/ui/type-alias-impl-trait/cross_crate_ice*.rs # requires removed aux dep\n \n rm src/test/ui/allocator/no_std-alloc-error-handler-default.rs # missing rust_oom definition\n@@ -98,6 +100,7 @@ rm src/test/ui/abi/stack-protector.rs # requires stack protector support\n rm src/test/incremental/issue-80691-bad-eval-cache.rs # wrong exit code\n rm src/test/incremental/spike-neg1.rs # errors out for some reason\n rm src/test/incremental/spike-neg2.rs # same\n+rm src/test/ui/issues/issue-74564-if-expr-stack-overflow.rs # gives a stackoverflow before the backend runs\n \n rm src/test/incremental/thinlto/cgu_invalidated_when_import_{added,removed}.rs # requires LLVM\n "}, {"sha": "82247b47888e77f2021a6f328a34d347c577000f", "filename": "compiler/rustc_codegen_cranelift/src/allocator.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs?ref=8f53bdb45fb340ddd3630550b69675a880224d08", "patch": "@@ -3,7 +3,6 @@\n \n use crate::prelude::*;\n \n-use cranelift_codegen::binemit::{NullStackMapSink, NullTrapSink};\n use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n \n /// Returns whether an allocator shim was created\n@@ -91,9 +90,7 @@ fn codegen_inner(\n             bcx.seal_all_blocks();\n             bcx.finalize();\n         }\n-        module\n-            .define_function(func_id, &mut ctx, &mut NullTrapSink {}, &mut NullStackMapSink {})\n-            .unwrap();\n+        module.define_function(func_id, &mut ctx).unwrap();\n         unwind_context.add_function(func_id, &ctx, module.isa());\n     }\n \n@@ -130,8 +127,6 @@ fn codegen_inner(\n         bcx.seal_all_blocks();\n         bcx.finalize();\n     }\n-    module\n-        .define_function(func_id, &mut ctx, &mut NullTrapSink {}, &mut NullStackMapSink {})\n-        .unwrap();\n+    module.define_function(func_id, &mut ctx).unwrap();\n     unwind_context.add_function(func_id, &ctx, module.isa());\n }"}, {"sha": "0a6ef6441fa035625c2772480095ef02ef12942a", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 40, "deletions": 16, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=8f53bdb45fb340ddd3630550b69675a880224d08", "patch": "@@ -1,13 +1,15 @@\n //! Codegen of a single function\n \n-use cranelift_codegen::binemit::{NullStackMapSink, NullTrapSink};\n use rustc_ast::InlineAsmOptions;\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::layout::FnAbiOf;\n \n+use indexmap::IndexSet;\n+\n use crate::constant::ConstantCx;\n use crate::prelude::*;\n+use crate::pretty_clif::CommentWriter;\n \n pub(crate) fn codegen_fn<'tcx>(\n     cx: &mut crate::CodegenCx<'tcx>,\n@@ -99,27 +101,54 @@ pub(crate) fn codegen_fn<'tcx>(\n \n     // Recover all necessary data from fx, before accessing func will prevent future access to it.\n     let instance = fx.instance;\n-    let mut clif_comments = fx.clif_comments;\n+    let clif_comments = fx.clif_comments;\n     let source_info_set = fx.source_info_set;\n     let local_map = fx.local_map;\n \n     fx.constants_cx.finalize(fx.tcx, &mut *fx.module);\n \n-    // Store function in context\n-    let context = &mut cx.cached_context;\n-    context.func = func;\n-\n     crate::pretty_clif::write_clif_file(\n         tcx,\n         \"unopt\",\n         module.isa(),\n         instance,\n-        &context,\n+        &func,\n         &clif_comments,\n     );\n \n     // Verify function\n-    verify_func(tcx, &clif_comments, &context.func);\n+    verify_func(tcx, &clif_comments, &func);\n+\n+    compile_fn(\n+        cx,\n+        module,\n+        instance,\n+        symbol_name.name,\n+        func_id,\n+        func,\n+        clif_comments,\n+        source_info_set,\n+        local_map,\n+    );\n+}\n+\n+fn compile_fn<'tcx>(\n+    cx: &mut crate::CodegenCx<'tcx>,\n+    module: &mut dyn Module,\n+    instance: Instance<'tcx>,\n+    symbol_name: &str,\n+    func_id: FuncId,\n+    func: Function,\n+    mut clif_comments: CommentWriter,\n+    source_info_set: IndexSet<SourceInfo>,\n+    local_map: IndexVec<mir::Local, CPlace<'tcx>>,\n+) {\n+    let tcx = cx.tcx;\n+\n+    // Store function in context\n+    let context = &mut cx.cached_context;\n+    context.clear();\n+    context.func = func;\n \n     // If the return block is not reachable, then the SSA builder may have inserted an `iconst.i128`\n     // instruction, which doesn't have an encoding.\n@@ -145,9 +174,7 @@ pub(crate) fn codegen_fn<'tcx>(\n     // Define function\n     tcx.sess.time(\"define function\", || {\n         context.want_disasm = crate::pretty_clif::should_write_ir(tcx);\n-        module\n-            .define_function(func_id, context, &mut NullTrapSink {}, &mut NullStackMapSink {})\n-            .unwrap()\n+        module.define_function(func_id, context).unwrap()\n     });\n \n     // Write optimized function to file for debugging\n@@ -156,7 +183,7 @@ pub(crate) fn codegen_fn<'tcx>(\n         \"opt\",\n         module.isa(),\n         instance,\n-        &context,\n+        &context.func,\n         &clif_comments,\n     );\n \n@@ -177,7 +204,7 @@ pub(crate) fn codegen_fn<'tcx>(\n             debug_context.define_function(\n                 instance,\n                 func_id,\n-                symbol_name.name,\n+                symbol_name,\n                 isa,\n                 context,\n                 &source_info_set,\n@@ -186,9 +213,6 @@ pub(crate) fn codegen_fn<'tcx>(\n         }\n         unwind_context.add_function(func_id, &context, isa);\n     });\n-\n-    // Clear context to make it usable for the next function\n-    context.clear();\n }\n \n pub(crate) fn verify_func("}, {"sha": "2e047c7eea14e49d739aa97ce9b0dee6c9ba9bb3", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=8f53bdb45fb340ddd3630550b69675a880224d08", "patch": "@@ -56,6 +56,9 @@ fn emit_module(\n \n     let tmp_file = tcx.output_filenames(()).temp_path(OutputType::Object, Some(&name));\n     let obj = product.object.write().unwrap();\n+\n+    tcx.sess.prof.artifact_size(\"object_file\", name.clone(), obj.len().try_into().unwrap());\n+\n     if let Err(err) = std::fs::write(&tmp_file, obj) {\n         tcx.sess.fatal(&format!(\"error writing object file: {}\", err));\n     }"}, {"sha": "9e07528313dd8911d2f5cd2056818afe8ab646c1", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=8f53bdb45fb340ddd3630550b69675a880224d08", "patch": "@@ -7,7 +7,6 @@ use std::lazy::SyncOnceCell;\n use std::os::raw::{c_char, c_int};\n use std::sync::{mpsc, Mutex};\n \n-use cranelift_codegen::binemit::{NullStackMapSink, NullTrapSink};\n use rustc_codegen_ssa::CrateInfo;\n use rustc_middle::mir::mono::MonoItem;\n use rustc_session::Session;\n@@ -381,12 +380,5 @@ fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx>, module: &mut JITModule, inst: In\n     let ret_vals = trampoline_builder.func.dfg.inst_results(call_inst).to_vec();\n     trampoline_builder.ins().return_(&ret_vals);\n \n-    module\n-        .define_function(\n-            func_id,\n-            &mut cx.cached_context,\n-            &mut NullTrapSink {},\n-            &mut NullStackMapSink {},\n-        )\n-        .unwrap();\n+    module.define_function(func_id, &mut cx.cached_context).unwrap();\n }"}, {"sha": "098862b0662f398c0e917b2482dc492664843e93", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs?ref=8f53bdb45fb340ddd3630550b69675a880224d08", "patch": "@@ -8,14 +8,14 @@ use rustc_middle::ty::subst::SubstsRef;\n pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     intrinsic: &str,\n-    substs: SubstsRef<'tcx>,\n+    _substs: SubstsRef<'tcx>,\n     args: &[mir::Operand<'tcx>],\n     destination: Option<(CPlace<'tcx>, BasicBlock)>,\n ) {\n     let ret = destination.unwrap().0;\n \n     intrinsic_match! {\n-        fx, intrinsic, substs, args,\n+        fx, intrinsic, args,\n         _ => {\n             fx.tcx.sess.warn(&format!(\"unsupported llvm intrinsic {}; replacing with trap\", intrinsic));\n             crate::trap::trap_unimplemented(fx, intrinsic);\n@@ -52,8 +52,8 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, res);\n         };\n         \"llvm.x86.sse2.cmp.ps\" | \"llvm.x86.sse2.cmp.pd\", (c x, c y, o kind) {\n-            let kind_const = crate::constant::mir_operand_get_const_val(fx, kind).expect(\"llvm.x86.sse2.cmp.* kind not const\");\n-            let flt_cc = match kind_const.try_to_bits(Size::from_bytes(1)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", kind_const)) {\n+            let kind = crate::constant::mir_operand_get_const_val(fx, kind).expect(\"llvm.x86.sse2.cmp.* kind not const\");\n+            let flt_cc = match kind.try_to_bits(Size::from_bytes(1)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", kind)) {\n                 0 => FloatCC::Equal,\n                 1 => FloatCC::LessThan,\n                 2 => FloatCC::LessThanOrEqual,\n@@ -73,32 +73,30 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n                 kind => unreachable!(\"kind {:?}\", kind),\n             };\n \n-            simd_pair_for_each_lane(fx, x, y, ret, |fx, lane_layout, res_lane_layout, x_lane, y_lane| {\n-                let res_lane = match lane_layout.ty.kind() {\n+            simd_pair_for_each_lane(fx, x, y, ret, &|fx, lane_ty, res_lane_ty, x_lane, y_lane| {\n+                let res_lane = match lane_ty.kind() {\n                     ty::Float(_) => fx.bcx.ins().fcmp(flt_cc, x_lane, y_lane),\n-                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n+                    _ => unreachable!(\"{:?}\", lane_ty),\n                 };\n-                bool_to_zero_or_max_uint(fx, res_lane_layout, res_lane)\n+                bool_to_zero_or_max_uint(fx, res_lane_ty, res_lane)\n             });\n         };\n         \"llvm.x86.sse2.psrli.d\", (c a, o imm8) {\n             let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8).expect(\"llvm.x86.sse2.psrli.d imm8 not const\");\n-            simd_for_each_lane(fx, a, ret, |fx, _lane_layout, res_lane_layout, lane| {\n-                let res_lane = match imm8.try_to_bits(Size::from_bytes(4)).unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8)) {\n+            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| {\n+                match imm8.try_to_bits(Size::from_bytes(4)).unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8)) {\n                     imm8 if imm8 < 32 => fx.bcx.ins().ushr_imm(lane, i64::from(imm8 as u8)),\n                     _ => fx.bcx.ins().iconst(types::I32, 0),\n-                };\n-                CValue::by_val(res_lane, res_lane_layout)\n+                }\n             });\n         };\n         \"llvm.x86.sse2.pslli.d\", (c a, o imm8) {\n             let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8).expect(\"llvm.x86.sse2.psrli.d imm8 not const\");\n-            simd_for_each_lane(fx, a, ret, |fx, _lane_layout, res_lane_layout, lane| {\n-                let res_lane = match imm8.try_to_bits(Size::from_bytes(4)).unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8)) {\n+            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| {\n+                match imm8.try_to_bits(Size::from_bytes(4)).unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8)) {\n                     imm8 if imm8 < 32 => fx.bcx.ins().ishl_imm(lane, i64::from(imm8 as u8)),\n                     _ => fx.bcx.ins().iconst(types::I32, 0),\n-                };\n-                CValue::by_val(res_lane, res_lane_layout)\n+                }\n             });\n         };\n         \"llvm.x86.sse2.storeu.dq\", (v mem_addr, c a) {"}, {"sha": "4dfb13476c287f7bbe06692b3025f9547097db60", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 300, "deletions": 332, "changes": 632, "blob_url": "https://github.com/rust-lang/rust/blob/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=8f53bdb45fb340ddd3630550b69675a880224d08", "patch": "@@ -9,7 +9,8 @@ pub(crate) use cpuid::codegen_cpuid_call;\n pub(crate) use llvm::codegen_llvm_intrinsic_call;\n \n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_span::symbol::{kw, sym};\n+use rustc_middle::ty::subst::SubstsRef;\n+use rustc_span::symbol::{kw, sym, Symbol};\n \n use crate::prelude::*;\n use cranelift_codegen::ir::AtomicRmwOp;\n@@ -30,116 +31,52 @@ macro intrinsic_pat {\n }\n \n macro intrinsic_arg {\n-    (o $fx:expr, $arg:ident) => {\n-        $arg\n-    },\n+    (o $fx:expr, $arg:ident) => {},\n     (c $fx:expr, $arg:ident) => {\n-        codegen_operand($fx, $arg)\n+        let $arg = codegen_operand($fx, $arg);\n     },\n     (v $fx:expr, $arg:ident) => {\n-        codegen_operand($fx, $arg).load_scalar($fx)\n-    }\n-}\n-\n-macro intrinsic_substs {\n-    ($substs:expr, $index:expr,) => {},\n-    ($substs:expr, $index:expr, $first:ident $(,$rest:ident)*) => {\n-        let $first = $substs.type_at($index);\n-        intrinsic_substs!($substs, $index+1, $($rest),*);\n+        let $arg = codegen_operand($fx, $arg).load_scalar($fx);\n     }\n }\n \n macro intrinsic_match {\n-    ($fx:expr, $intrinsic:expr, $substs:expr, $args:expr,\n+    ($fx:expr, $intrinsic:expr, $args:expr,\n     _ => $unknown:block;\n     $(\n-        $($($name:tt).*)|+ $(if $cond:expr)?, $(<$($subst:ident),*>)? ($($a:ident $arg:ident),*) $content:block;\n+        $($($name:tt).*)|+ $(if $cond:expr)?, ($($a:ident $arg:ident),*) $content:block;\n     )*) => {\n-        let _ = $substs; // Silence warning when substs is unused.\n         match $intrinsic {\n             $(\n                 $(intrinsic_pat!($($name).*))|* $(if $cond)? => {\n-                    #[allow(unused_parens, non_snake_case)]\n-                    {\n-                        $(\n-                            intrinsic_substs!($substs, 0, $($subst),*);\n-                        )?\n-                        if let [$($arg),*] = $args {\n-                            let ($($arg,)*) = (\n-                                $(intrinsic_arg!($a $fx, $arg),)*\n-                            );\n-                            #[warn(unused_parens, non_snake_case)]\n-                            {\n-                                $content\n-                            }\n-                        } else {\n-                            bug!(\"wrong number of args for intrinsic {:?}\", $intrinsic);\n-                        }\n-                    }\n-                }\n-            )*\n-            _ => $unknown,\n-        }\n-    }\n-}\n-\n-macro call_intrinsic_match {\n-    ($fx:expr, $intrinsic:expr, $substs:expr, $ret:expr, $destination:expr, $args:expr, $(\n-        $name:ident($($arg:ident),*) -> $ty:ident => $func:ident,\n-    )*) => {\n-        match $intrinsic {\n-            $(\n-                sym::$name => {\n-                    assert!($substs.is_empty());\n-                    if let [$(ref $arg),*] = *$args {\n-                        let ($($arg,)*) = (\n-                            $(codegen_operand($fx, $arg),)*\n-                        );\n-                        let res = $fx.easy_call(stringify!($func), &[$($arg),*], $fx.tcx.types.$ty);\n-                        $ret.write_cvalue($fx, res);\n-\n-                        if let Some((_, dest)) = $destination {\n-                            let ret_block = $fx.get_block(dest);\n-                            $fx.bcx.ins().jump(ret_block, &[]);\n-                            return;\n-                        } else {\n-                            unreachable!();\n-                        }\n+                    if let [$($arg),*] = $args {\n+                        $(intrinsic_arg!($a $fx, $arg);)*\n+                        $content\n                     } else {\n                         bug!(\"wrong number of args for intrinsic {:?}\", $intrinsic);\n                     }\n                 }\n             )*\n-            _ => {}\n-        }\n-    }\n-}\n-\n-macro validate_atomic_type($fx:ident, $intrinsic:ident, $span:ident, $ty:expr) {\n-    match $ty.kind() {\n-        ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n-        _ => {\n-            $fx.tcx.sess.span_err(\n-                $span,\n-                &format!(\n-                    \"`{}` intrinsic: expected basic integer or raw pointer type, found `{:?}`\",\n-                    $intrinsic, $ty\n-                ),\n-            );\n-            // Prevent verifier error\n-            crate::trap::trap_unreachable($fx, \"compilation should not have succeeded\");\n-            return;\n+            _ => $unknown,\n         }\n     }\n }\n \n-macro validate_simd_type($fx:ident, $intrinsic:ident, $span:ident, $ty:expr) {\n-    if !$ty.is_simd() {\n-        $fx.tcx.sess.span_err($span, &format!(\"invalid monomorphization of `{}` intrinsic: expected SIMD input type, found non-SIMD `{}`\", $intrinsic, $ty));\n-        // Prevent verifier error\n-        crate::trap::trap_unreachable($fx, \"compilation should not have succeeded\");\n-        return;\n-    }\n+fn report_atomic_type_validation_error<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    intrinsic: Symbol,\n+    span: Span,\n+    ty: Ty<'tcx>,\n+) {\n+    fx.tcx.sess.span_err(\n+        span,\n+        &format!(\n+            \"`{}` intrinsic: expected basic integer or raw pointer type, found `{:?}`\",\n+            intrinsic, ty\n+        ),\n+    );\n+    // Prevent verifier error\n+    crate::trap::trap_unreachable(fx, \"compilation should not have succeeded\");\n }\n \n pub(crate) fn clif_vector_type<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx>) -> Option<Type> {\n@@ -159,12 +96,7 @@ fn simd_for_each_lane<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     val: CValue<'tcx>,\n     ret: CPlace<'tcx>,\n-    f: impl Fn(\n-        &mut FunctionCx<'_, '_, 'tcx>,\n-        TyAndLayout<'tcx>,\n-        TyAndLayout<'tcx>,\n-        Value,\n-    ) -> CValue<'tcx>,\n+    f: &dyn Fn(&mut FunctionCx<'_, '_, 'tcx>, Ty<'tcx>, Ty<'tcx>, Value) -> Value,\n ) {\n     let layout = val.layout();\n \n@@ -177,7 +109,8 @@ fn simd_for_each_lane<'tcx>(\n     for lane_idx in 0..lane_count {\n         let lane = val.value_lane(fx, lane_idx).load_scalar(fx);\n \n-        let res_lane = f(fx, lane_layout, ret_lane_layout, lane);\n+        let res_lane = f(fx, lane_layout.ty, ret_lane_layout.ty, lane);\n+        let res_lane = CValue::by_val(res_lane, ret_lane_layout);\n \n         ret.place_lane(fx, lane_idx).write_cvalue(fx, res_lane);\n     }\n@@ -188,13 +121,7 @@ fn simd_pair_for_each_lane<'tcx>(\n     x: CValue<'tcx>,\n     y: CValue<'tcx>,\n     ret: CPlace<'tcx>,\n-    f: impl Fn(\n-        &mut FunctionCx<'_, '_, 'tcx>,\n-        TyAndLayout<'tcx>,\n-        TyAndLayout<'tcx>,\n-        Value,\n-        Value,\n-    ) -> CValue<'tcx>,\n+    f: &dyn Fn(&mut FunctionCx<'_, '_, 'tcx>, Ty<'tcx>, Ty<'tcx>, Value, Value) -> Value,\n ) {\n     assert_eq!(x.layout(), y.layout());\n     let layout = x.layout();\n@@ -209,7 +136,8 @@ fn simd_pair_for_each_lane<'tcx>(\n         let x_lane = x.value_lane(fx, lane_idx).load_scalar(fx);\n         let y_lane = y.value_lane(fx, lane_idx).load_scalar(fx);\n \n-        let res_lane = f(fx, lane_layout, ret_lane_layout, x_lane, y_lane);\n+        let res_lane = f(fx, lane_layout.ty, ret_lane_layout.ty, x_lane, y_lane);\n+        let res_lane = CValue::by_val(res_lane, ret_lane_layout);\n \n         ret.place_lane(fx, lane_idx).write_cvalue(fx, res_lane);\n     }\n@@ -220,7 +148,7 @@ fn simd_reduce<'tcx>(\n     val: CValue<'tcx>,\n     acc: Option<Value>,\n     ret: CPlace<'tcx>,\n-    f: impl Fn(&mut FunctionCx<'_, '_, 'tcx>, TyAndLayout<'tcx>, Value, Value) -> Value,\n+    f: &dyn Fn(&mut FunctionCx<'_, '_, 'tcx>, Ty<'tcx>, Value, Value) -> Value,\n ) {\n     let (lane_count, lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n     let lane_layout = fx.layout_of(lane_ty);\n@@ -230,7 +158,7 @@ fn simd_reduce<'tcx>(\n         if let Some(acc) = acc { (acc, 0) } else { (val.value_lane(fx, 0).load_scalar(fx), 1) };\n     for lane_idx in start_lane..lane_count {\n         let lane = val.value_lane(fx, lane_idx).load_scalar(fx);\n-        res_val = f(fx, lane_layout, res_val, lane);\n+        res_val = f(fx, lane_layout.ty, res_val, lane);\n     }\n     let res = CValue::by_val(res_val, lane_layout);\n     ret.write_cvalue(fx, res);\n@@ -241,7 +169,7 @@ fn simd_reduce_bool<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     val: CValue<'tcx>,\n     ret: CPlace<'tcx>,\n-    f: impl Fn(&mut FunctionCx<'_, '_, 'tcx>, Value, Value) -> Value,\n+    f: &dyn Fn(&mut FunctionCx<'_, '_, 'tcx>, Value, Value) -> Value,\n ) {\n     let (lane_count, _lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n     assert!(ret.layout().ty.is_bool());\n@@ -264,10 +192,10 @@ fn simd_reduce_bool<'tcx>(\n \n fn bool_to_zero_or_max_uint<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    layout: TyAndLayout<'tcx>,\n+    ty: Ty<'tcx>,\n     val: Value,\n-) -> CValue<'tcx> {\n-    let ty = fx.clif_type(layout.ty).unwrap();\n+) -> Value {\n+    let ty = fx.clif_type(ty).unwrap();\n \n     let int_ty = match ty {\n         types::F32 => types::I32,\n@@ -282,122 +210,7 @@ fn bool_to_zero_or_max_uint<'tcx>(\n         res = fx.bcx.ins().bitcast(ty, res);\n     }\n \n-    CValue::by_val(res, layout)\n-}\n-\n-macro simd_cmp {\n-    ($fx:expr, $cc:ident|$cc_f:ident($x:ident, $y:ident) -> $ret:ident) => {\n-        let vector_ty = clif_vector_type($fx.tcx, $x.layout());\n-\n-        if let Some(vector_ty) = vector_ty {\n-            let x = $x.load_scalar($fx);\n-            let y = $y.load_scalar($fx);\n-            let val = if vector_ty.lane_type().is_float() {\n-                $fx.bcx.ins().fcmp(FloatCC::$cc_f, x, y)\n-            } else {\n-                $fx.bcx.ins().icmp(IntCC::$cc, x, y)\n-            };\n-\n-            // HACK This depends on the fact that icmp for vectors represents bools as 0 and !0, not 0 and 1.\n-            let val = $fx.bcx.ins().raw_bitcast(vector_ty, val);\n-\n-            $ret.write_cvalue($fx, CValue::by_val(val, $ret.layout()));\n-        } else {\n-            simd_pair_for_each_lane(\n-                $fx,\n-                $x,\n-                $y,\n-                $ret,\n-                |fx, lane_layout, res_lane_layout, x_lane, y_lane| {\n-                    let res_lane = match lane_layout.ty.kind() {\n-                        ty::Uint(_) | ty::Int(_) => fx.bcx.ins().icmp(IntCC::$cc, x_lane, y_lane),\n-                        ty::Float(_) => fx.bcx.ins().fcmp(FloatCC::$cc_f, x_lane, y_lane),\n-                        _ => unreachable!(\"{:?}\", lane_layout.ty),\n-                    };\n-                    bool_to_zero_or_max_uint(fx, res_lane_layout, res_lane)\n-                },\n-            );\n-        }\n-    },\n-    ($fx:expr, $cc_u:ident|$cc_s:ident|$cc_f:ident($x:ident, $y:ident) -> $ret:ident) => {\n-        // FIXME use vector icmp when possible\n-        simd_pair_for_each_lane(\n-            $fx,\n-            $x,\n-            $y,\n-            $ret,\n-            |fx, lane_layout, res_lane_layout, x_lane, y_lane| {\n-                let res_lane = match lane_layout.ty.kind() {\n-                    ty::Uint(_) => fx.bcx.ins().icmp(IntCC::$cc_u, x_lane, y_lane),\n-                    ty::Int(_) => fx.bcx.ins().icmp(IntCC::$cc_s, x_lane, y_lane),\n-                    ty::Float(_) => fx.bcx.ins().fcmp(FloatCC::$cc_f, x_lane, y_lane),\n-                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n-                };\n-                bool_to_zero_or_max_uint(fx, res_lane_layout, res_lane)\n-            },\n-        );\n-    },\n-}\n-\n-macro simd_int_binop {\n-    ($fx:expr, $op:ident($x:ident, $y:ident) -> $ret:ident) => {\n-        simd_int_binop!($fx, $op|$op($x, $y) -> $ret);\n-    },\n-    ($fx:expr, $op_u:ident|$op_s:ident($x:ident, $y:ident) -> $ret:ident) => {\n-        simd_pair_for_each_lane(\n-            $fx,\n-            $x,\n-            $y,\n-            $ret,\n-            |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n-                let res_lane = match lane_layout.ty.kind() {\n-                    ty::Uint(_) => fx.bcx.ins().$op_u(x_lane, y_lane),\n-                    ty::Int(_) => fx.bcx.ins().$op_s(x_lane, y_lane),\n-                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n-                };\n-                CValue::by_val(res_lane, ret_lane_layout)\n-            },\n-        );\n-    },\n-}\n-\n-macro simd_int_flt_binop {\n-    ($fx:expr, $op:ident|$op_f:ident($x:ident, $y:ident) -> $ret:ident) => {\n-        simd_int_flt_binop!($fx, $op|$op|$op_f($x, $y) -> $ret);\n-    },\n-    ($fx:expr, $op_u:ident|$op_s:ident|$op_f:ident($x:ident, $y:ident) -> $ret:ident) => {\n-        simd_pair_for_each_lane(\n-            $fx,\n-            $x,\n-            $y,\n-            $ret,\n-            |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n-                let res_lane = match lane_layout.ty.kind() {\n-                    ty::Uint(_) => fx.bcx.ins().$op_u(x_lane, y_lane),\n-                    ty::Int(_) => fx.bcx.ins().$op_s(x_lane, y_lane),\n-                    ty::Float(_) => fx.bcx.ins().$op_f(x_lane, y_lane),\n-                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n-                };\n-                CValue::by_val(res_lane, ret_lane_layout)\n-            },\n-        );\n-    },\n-}\n-\n-macro simd_flt_binop($fx:expr, $op:ident($x:ident, $y:ident) -> $ret:ident) {\n-    simd_pair_for_each_lane(\n-        $fx,\n-        $x,\n-        $y,\n-        $ret,\n-        |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n-            let res_lane = match lane_layout.ty.kind() {\n-                ty::Float(_) => fx.bcx.ins().$op(x_lane, y_lane),\n-                _ => unreachable!(\"{:?}\", lane_layout.ty),\n-            };\n-            CValue::by_val(res_lane, ret_lane_layout)\n-        },\n-    );\n+    res\n }\n \n pub(crate) fn codegen_intrinsic_call<'tcx>(\n@@ -428,59 +241,111 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n     };\n \n     if intrinsic.as_str().starts_with(\"simd_\") {\n-        self::simd::codegen_simd_intrinsic_call(fx, instance, args, ret, span);\n+        self::simd::codegen_simd_intrinsic_call(fx, intrinsic, substs, args, ret, span);\n         let ret_block = fx.get_block(destination.expect(\"SIMD intrinsics don't diverge\").1);\n         fx.bcx.ins().jump(ret_block, &[]);\n-        return;\n+    } else if codegen_float_intrinsic_call(fx, intrinsic, args, ret) {\n+        let ret_block = fx.get_block(destination.expect(\"Float intrinsics don't diverge\").1);\n+        fx.bcx.ins().jump(ret_block, &[]);\n+    } else {\n+        codegen_regular_intrinsic_call(\n+            fx,\n+            instance,\n+            intrinsic,\n+            substs,\n+            args,\n+            ret,\n+            span,\n+            destination,\n+        );\n     }\n+}\n \n-    let usize_layout = fx.layout_of(fx.tcx.types.usize);\n+fn codegen_float_intrinsic_call<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    intrinsic: Symbol,\n+    args: &[mir::Operand<'tcx>],\n+    ret: CPlace<'tcx>,\n+) -> bool {\n+    let (name, arg_count, ty) = match intrinsic {\n+        sym::expf32 => (\"expf\", 1, fx.tcx.types.f32),\n+        sym::expf64 => (\"exp\", 1, fx.tcx.types.f64),\n+        sym::exp2f32 => (\"exp2f\", 1, fx.tcx.types.f32),\n+        sym::exp2f64 => (\"exp2\", 1, fx.tcx.types.f64),\n+        sym::sqrtf32 => (\"sqrtf\", 1, fx.tcx.types.f32),\n+        sym::sqrtf64 => (\"sqrt\", 1, fx.tcx.types.f64),\n+        sym::powif32 => (\"__powisf2\", 2, fx.tcx.types.f32), // compiler-builtins\n+        sym::powif64 => (\"__powidf2\", 2, fx.tcx.types.f64), // compiler-builtins\n+        sym::powf32 => (\"powf\", 2, fx.tcx.types.f32),\n+        sym::powf64 => (\"pow\", 2, fx.tcx.types.f64),\n+        sym::logf32 => (\"logf\", 1, fx.tcx.types.f32),\n+        sym::logf64 => (\"log\", 1, fx.tcx.types.f64),\n+        sym::log2f32 => (\"log2f\", 1, fx.tcx.types.f32),\n+        sym::log2f64 => (\"log2\", 1, fx.tcx.types.f64),\n+        sym::log10f32 => (\"log10f\", 1, fx.tcx.types.f32),\n+        sym::log10f64 => (\"log10\", 1, fx.tcx.types.f64),\n+        sym::fabsf32 => (\"fabsf\", 1, fx.tcx.types.f32),\n+        sym::fabsf64 => (\"fabs\", 1, fx.tcx.types.f64),\n+        sym::fmaf32 => (\"fmaf\", 3, fx.tcx.types.f32),\n+        sym::fmaf64 => (\"fma\", 3, fx.tcx.types.f64),\n+        sym::copysignf32 => (\"copysignf\", 2, fx.tcx.types.f32),\n+        sym::copysignf64 => (\"copysign\", 2, fx.tcx.types.f64),\n+        sym::floorf32 => (\"floorf\", 1, fx.tcx.types.f32),\n+        sym::floorf64 => (\"floor\", 1, fx.tcx.types.f64),\n+        sym::ceilf32 => (\"ceilf\", 1, fx.tcx.types.f32),\n+        sym::ceilf64 => (\"ceil\", 1, fx.tcx.types.f64),\n+        sym::truncf32 => (\"truncf\", 1, fx.tcx.types.f32),\n+        sym::truncf64 => (\"trunc\", 1, fx.tcx.types.f64),\n+        sym::roundf32 => (\"roundf\", 1, fx.tcx.types.f32),\n+        sym::roundf64 => (\"round\", 1, fx.tcx.types.f64),\n+        sym::sinf32 => (\"sinf\", 1, fx.tcx.types.f32),\n+        sym::sinf64 => (\"sin\", 1, fx.tcx.types.f64),\n+        sym::cosf32 => (\"cosf\", 1, fx.tcx.types.f32),\n+        sym::cosf64 => (\"cos\", 1, fx.tcx.types.f64),\n+        _ => return false,\n+    };\n \n-    call_intrinsic_match! {\n-        fx, intrinsic, substs, ret, destination, args,\n-        expf32(flt) -> f32 => expf,\n-        expf64(flt) -> f64 => exp,\n-        exp2f32(flt) -> f32 => exp2f,\n-        exp2f64(flt) -> f64 => exp2,\n-        sqrtf32(flt) -> f32 => sqrtf,\n-        sqrtf64(flt) -> f64 => sqrt,\n-        powif32(a, x) -> f32 => __powisf2, // compiler-builtins\n-        powif64(a, x) -> f64 => __powidf2, // compiler-builtins\n-        powf32(a, x) -> f32 => powf,\n-        powf64(a, x) -> f64 => pow,\n-        logf32(flt) -> f32 => logf,\n-        logf64(flt) -> f64 => log,\n-        log2f32(flt) -> f32 => log2f,\n-        log2f64(flt) -> f64 => log2,\n-        log10f32(flt) -> f32 => log10f,\n-        log10f64(flt) -> f64 => log10,\n-        fabsf32(flt) -> f32 => fabsf,\n-        fabsf64(flt) -> f64 => fabs,\n-        fmaf32(x, y, z) -> f32 => fmaf,\n-        fmaf64(x, y, z) -> f64 => fma,\n-        copysignf32(x, y) -> f32 => copysignf,\n-        copysignf64(x, y) -> f64 => copysign,\n-\n-        // rounding variants\n-        // FIXME use clif insts\n-        floorf32(flt) -> f32 => floorf,\n-        floorf64(flt) -> f64 => floor,\n-        ceilf32(flt) -> f32 => ceilf,\n-        ceilf64(flt) -> f64 => ceil,\n-        truncf32(flt) -> f32 => truncf,\n-        truncf64(flt) -> f64 => trunc,\n-        roundf32(flt) -> f32 => roundf,\n-        roundf64(flt) -> f64 => round,\n-\n-        // trigonometry\n-        sinf32(flt) -> f32 => sinf,\n-        sinf64(flt) -> f64 => sin,\n-        cosf32(flt) -> f32 => cosf,\n-        cosf64(flt) -> f64 => cos,\n+    if args.len() != arg_count {\n+        bug!(\"wrong number of args for intrinsic {:?}\", intrinsic);\n     }\n \n+    let (a, b, c);\n+    let args = match args {\n+        [x] => {\n+            a = [codegen_operand(fx, x)];\n+            &a as &[_]\n+        }\n+        [x, y] => {\n+            b = [codegen_operand(fx, x), codegen_operand(fx, y)];\n+            &b\n+        }\n+        [x, y, z] => {\n+            c = [codegen_operand(fx, x), codegen_operand(fx, y), codegen_operand(fx, z)];\n+            &c\n+        }\n+        _ => unreachable!(),\n+    };\n+\n+    let res = fx.easy_call(name, &args, ty);\n+    ret.write_cvalue(fx, res);\n+\n+    true\n+}\n+\n+fn codegen_regular_intrinsic_call<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    instance: Instance<'tcx>,\n+    intrinsic: Symbol,\n+    substs: SubstsRef<'tcx>,\n+    args: &[mir::Operand<'tcx>],\n+    ret: CPlace<'tcx>,\n+    span: Span,\n+    destination: Option<(CPlace<'tcx>, BasicBlock)>,\n+) {\n+    let usize_layout = fx.layout_of(fx.tcx.types.usize);\n+\n     intrinsic_match! {\n-        fx, intrinsic, substs, args,\n+        fx, intrinsic, args,\n         _ => {\n             fx.tcx.sess.span_fatal(span, &format!(\"unsupported intrinsic {}\", intrinsic));\n         };\n@@ -492,7 +357,8 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         breakpoint, () {\n             fx.bcx.ins().debugtrap();\n         };\n-        copy | copy_nonoverlapping, <elem_ty> (v src, v dst, v count) {\n+        copy | copy_nonoverlapping, (v src, v dst, v count) {\n+            let elem_ty = substs.type_at(0);\n             let elem_size: u64 = fx.layout_of(elem_ty).size.bytes();\n             assert_eq!(args.len(), 3);\n             let byte_amount = if elem_size != 1 {\n@@ -510,7 +376,8 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             }\n         };\n         // NOTE: the volatile variants have src and dst swapped\n-        volatile_copy_memory | volatile_copy_nonoverlapping_memory, <elem_ty> (v dst, v src, v count) {\n+        volatile_copy_memory | volatile_copy_nonoverlapping_memory, (v dst, v src, v count) {\n+            let elem_ty = substs.type_at(0);\n             let elem_size: u64 = fx.layout_of(elem_ty).size.bytes();\n             assert_eq!(args.len(), 3);\n             let byte_amount = if elem_size != 1 {\n@@ -528,8 +395,8 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 fx.bcx.call_memmove(fx.target_config, dst, src, byte_amount);\n             }\n         };\n-        size_of_val, <T> (c ptr) {\n-            let layout = fx.layout_of(T);\n+        size_of_val, (c ptr) {\n+            let layout = fx.layout_of(substs.type_at(0));\n             let size = if layout.is_unsized() {\n                 let (_ptr, info) = ptr.load_scalar_pair(fx);\n                 let (size, _align) = crate::unsize::size_and_align_of_dst(fx, layout, info);\n@@ -542,8 +409,8 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             };\n             ret.write_cvalue(fx, CValue::by_val(size, usize_layout));\n         };\n-        min_align_of_val, <T> (c ptr) {\n-            let layout = fx.layout_of(T);\n+        min_align_of_val, (c ptr) {\n+            let layout = fx.layout_of(substs.type_at(0));\n             let align = if layout.is_unsized() {\n                 let (_ptr, info) = ptr.load_scalar_pair(fx);\n                 let (_size, align) = crate::unsize::size_and_align_of_dst(fx, layout, info);\n@@ -557,12 +424,13 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, CValue::by_val(align, usize_layout));\n         };\n \n-        unchecked_add | unchecked_sub | unchecked_div | exact_div | unchecked_rem\n+        unchecked_add | unchecked_sub | unchecked_mul | unchecked_div | exact_div | unchecked_rem\n         | unchecked_shl | unchecked_shr, (c x, c y) {\n             // FIXME trap on overflow\n             let bin_op = match intrinsic {\n                 sym::unchecked_add => BinOp::Add,\n                 sym::unchecked_sub => BinOp::Sub,\n+                sym::unchecked_mul => BinOp::Mul,\n                 sym::unchecked_div | sym::exact_div => BinOp::Div,\n                 sym::unchecked_rem => BinOp::Rem,\n                 sym::unchecked_shl => BinOp::Shl,\n@@ -589,15 +457,15 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             );\n             ret.write_cvalue(fx, res);\n         };\n-        saturating_add | saturating_sub, <T> (c lhs, c rhs) {\n+        saturating_add | saturating_sub, (c lhs, c rhs) {\n             assert_eq!(lhs.layout().ty, rhs.layout().ty);\n             let bin_op = match intrinsic {\n                 sym::saturating_add => BinOp::Add,\n                 sym::saturating_sub => BinOp::Sub,\n                 _ => unreachable!(),\n             };\n \n-            let signed = type_sign(T);\n+            let signed = type_sign(lhs.layout().ty);\n \n             let checked_res = crate::num::codegen_checked_int_binop(\n                 fx,\n@@ -607,7 +475,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             );\n \n             let (val, has_overflow) = checked_res.load_scalar_pair(fx);\n-            let clif_ty = fx.clif_type(T).unwrap();\n+            let clif_ty = fx.clif_type(lhs.layout().ty).unwrap();\n \n             let (min, max) = type_min_max_value(&mut fx.bcx, clif_ty, signed);\n \n@@ -629,17 +497,19 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 _ => unreachable!(),\n             };\n \n-            let res = CValue::by_val(val, fx.layout_of(T));\n+            let res = CValue::by_val(val, lhs.layout());\n \n             ret.write_cvalue(fx, res);\n         };\n-        rotate_left, <T>(v x, v y) {\n-            let layout = fx.layout_of(T);\n+        rotate_left, (c x, v y) {\n+            let layout = x.layout();\n+            let x = x.load_scalar(fx);\n             let res = fx.bcx.ins().rotl(x, y);\n             ret.write_cvalue(fx, CValue::by_val(res, layout));\n         };\n-        rotate_right, <T>(v x, v y) {\n-            let layout = fx.layout_of(T);\n+        rotate_right, (c x, v y) {\n+            let layout = x.layout();\n+            let x = x.load_scalar(fx);\n             let res = fx.bcx.ins().rotr(x, y);\n             ret.write_cvalue(fx, CValue::by_val(res, layout));\n         };\n@@ -675,29 +545,33 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             // FIXME use emit_small_memset\n             fx.bcx.call_memset(fx.target_config, dst_ptr, val, count);\n         };\n-        ctlz | ctlz_nonzero, <T> (v arg) {\n+        ctlz | ctlz_nonzero, (c arg) {\n+            let val = arg.load_scalar(fx);\n             // FIXME trap on `ctlz_nonzero` with zero arg.\n-            let res = fx.bcx.ins().clz(arg);\n-            let res = CValue::by_val(res, fx.layout_of(T));\n+            let res = fx.bcx.ins().clz(val);\n+            let res = CValue::by_val(res, arg.layout());\n             ret.write_cvalue(fx, res);\n         };\n-        cttz | cttz_nonzero, <T> (v arg) {\n+        cttz | cttz_nonzero, (c arg) {\n+            let val = arg.load_scalar(fx);\n             // FIXME trap on `cttz_nonzero` with zero arg.\n-            let res = fx.bcx.ins().ctz(arg);\n-            let res = CValue::by_val(res, fx.layout_of(T));\n+            let res = fx.bcx.ins().ctz(val);\n+            let res = CValue::by_val(res, arg.layout());\n             ret.write_cvalue(fx, res);\n         };\n-        ctpop, <T> (v arg) {\n-            let res = fx.bcx.ins().popcnt(arg);\n-            let res = CValue::by_val(res, fx.layout_of(T));\n+        ctpop, (c arg) {\n+            let val = arg.load_scalar(fx);\n+            let res = fx.bcx.ins().popcnt(val);\n+            let res = CValue::by_val(res, arg.layout());\n             ret.write_cvalue(fx, res);\n         };\n-        bitreverse, <T> (v arg) {\n-            let res = fx.bcx.ins().bitrev(arg);\n-            let res = CValue::by_val(res, fx.layout_of(T));\n+        bitreverse, (c arg) {\n+            let val = arg.load_scalar(fx);\n+            let res = fx.bcx.ins().bitrev(val);\n+            let res = CValue::by_val(res, arg.layout());\n             ret.write_cvalue(fx, res);\n         };\n-        bswap, <T> (v arg) {\n+        bswap, (c arg) {\n             // FIXME(CraneStation/cranelift#794) add bswap instruction to cranelift\n             fn swap(bcx: &mut FunctionBuilder<'_>, v: Value) -> Value {\n                 match bcx.func.dfg.value_type(v) {\n@@ -773,16 +647,17 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                     ty => unreachable!(\"bswap {}\", ty),\n                 }\n             }\n-            let res = CValue::by_val(swap(&mut fx.bcx, arg), fx.layout_of(T));\n+            let val = arg.load_scalar(fx);\n+            let res = CValue::by_val(swap(&mut fx.bcx, val), arg.layout());\n             ret.write_cvalue(fx, res);\n         };\n-        assert_inhabited | assert_zero_valid | assert_uninit_valid, <T> () {\n-            let layout = fx.layout_of(T);\n+        assert_inhabited | assert_zero_valid | assert_uninit_valid, () {\n+            let layout = fx.layout_of(substs.type_at(0));\n             if layout.abi.is_uninhabited() {\n                 with_no_trimmed_paths!({\n                     crate::base::codegen_panic(\n                         fx,\n-                        &format!(\"attempted to instantiate uninhabited type `{}`\", T),\n+                        &format!(\"attempted to instantiate uninhabited type `{}`\", layout.ty),\n                         span,\n                     )\n                 });\n@@ -793,7 +668,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 with_no_trimmed_paths!({\n                     crate::base::codegen_panic(\n                         fx,\n-                        &format!(\"attempted to zero-initialize type `{}`, which is invalid\", T),\n+                        &format!(\"attempted to zero-initialize type `{}`, which is invalid\", layout.ty),\n                         span,\n                     );\n                 });\n@@ -804,7 +679,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 with_no_trimmed_paths!({\n                     crate::base::codegen_panic(\n                         fx,\n-                        &format!(\"attempted to leave type `{}` uninitialized, which is invalid\", T),\n+                        &format!(\"attempted to leave type `{}` uninitialized, which is invalid\", layout.ty),\n                         span,\n                     )\n                 });\n@@ -838,10 +713,11 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, val);\n         };\n \n-        ptr_offset_from, <T> (v ptr, v base) {\n+        ptr_offset_from, (v ptr, v base) {\n+            let ty = substs.type_at(0);\n             let isize_layout = fx.layout_of(fx.tcx.types.isize);\n \n-            let pointee_size: u64 = fx.layout_of(T).size.bytes();\n+            let pointee_size: u64 = fx.layout_of(ty).size.bytes();\n             let diff = fx.bcx.ins().isub(ptr, base);\n             // FIXME this can be an exact division.\n             let val = CValue::by_val(fx.bcx.ins().sdiv_imm(diff, pointee_size as i64), isize_layout);\n@@ -870,25 +746,45 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             // FIXME use a compiler fence once Cranelift supports it\n             fx.bcx.ins().fence();\n         };\n-        _ if intrinsic.as_str().starts_with(\"atomic_load\"), <T> (v ptr) {\n-            validate_atomic_type!(fx, intrinsic, span, T);\n-            let ty = fx.clif_type(T).unwrap();\n+        _ if intrinsic.as_str().starts_with(\"atomic_load\"), (v ptr) {\n+            let ty = substs.type_at(0);\n+            match ty.kind() {\n+                ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n+                _ => {\n+                    report_atomic_type_validation_error(fx, intrinsic, span, ty);\n+                    return;\n+                }\n+            }\n+            let clif_ty = fx.clif_type(ty).unwrap();\n \n-            let val = fx.bcx.ins().atomic_load(ty, MemFlags::trusted(), ptr);\n+            let val = fx.bcx.ins().atomic_load(clif_ty, MemFlags::trusted(), ptr);\n \n-            let val = CValue::by_val(val, fx.layout_of(T));\n+            let val = CValue::by_val(val, fx.layout_of(ty));\n             ret.write_cvalue(fx, val);\n         };\n         _ if intrinsic.as_str().starts_with(\"atomic_store\"), (v ptr, c val) {\n-            validate_atomic_type!(fx, intrinsic, span, val.layout().ty);\n+            let ty = substs.type_at(0);\n+            match ty.kind() {\n+                ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n+                _ => {\n+                    report_atomic_type_validation_error(fx, intrinsic, span, ty);\n+                    return;\n+                }\n+            }\n \n             let val = val.load_scalar(fx);\n \n             fx.bcx.ins().atomic_store(MemFlags::trusted(), val, ptr);\n         };\n         _ if intrinsic.as_str().starts_with(\"atomic_xchg\"), (v ptr, c new) {\n             let layout = new.layout();\n-            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            match layout.ty.kind() {\n+                ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n+                _ => {\n+                    report_atomic_type_validation_error(fx, intrinsic, span, layout.ty);\n+                    return;\n+                }\n+            }\n             let ty = fx.clif_type(layout.ty).unwrap();\n \n             let new = new.load_scalar(fx);\n@@ -900,7 +796,13 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n         _ if intrinsic.as_str().starts_with(\"atomic_cxchg\"), (v ptr, c test_old, c new) { // both atomic_cxchg_* and atomic_cxchgweak_*\n             let layout = new.layout();\n-            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            match layout.ty.kind() {\n+                ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n+                _ => {\n+                    report_atomic_type_validation_error(fx, intrinsic, span, layout.ty);\n+                    return;\n+                }\n+            }\n \n             let test_old = test_old.load_scalar(fx);\n             let new = new.load_scalar(fx);\n@@ -914,7 +816,13 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n \n         _ if intrinsic.as_str().starts_with(\"atomic_xadd\"), (v ptr, c amount) {\n             let layout = amount.layout();\n-            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            match layout.ty.kind() {\n+                ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n+                _ => {\n+                    report_atomic_type_validation_error(fx, intrinsic, span, layout.ty);\n+                    return;\n+                }\n+            }\n             let ty = fx.clif_type(layout.ty).unwrap();\n \n             let amount = amount.load_scalar(fx);\n@@ -926,7 +834,13 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n         _ if intrinsic.as_str().starts_with(\"atomic_xsub\"), (v ptr, c amount) {\n             let layout = amount.layout();\n-            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            match layout.ty.kind() {\n+                ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n+                _ => {\n+                    report_atomic_type_validation_error(fx, intrinsic, span, layout.ty);\n+                    return;\n+                }\n+            }\n             let ty = fx.clif_type(layout.ty).unwrap();\n \n             let amount = amount.load_scalar(fx);\n@@ -938,7 +852,13 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n         _ if intrinsic.as_str().starts_with(\"atomic_and\"), (v ptr, c src) {\n             let layout = src.layout();\n-            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            match layout.ty.kind() {\n+                ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n+                _ => {\n+                    report_atomic_type_validation_error(fx, intrinsic, span, layout.ty);\n+                    return;\n+                }\n+            }\n             let ty = fx.clif_type(layout.ty).unwrap();\n \n             let src = src.load_scalar(fx);\n@@ -950,7 +870,13 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n         _ if intrinsic.as_str().starts_with(\"atomic_or\"), (v ptr, c src) {\n             let layout = src.layout();\n-            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            match layout.ty.kind() {\n+                ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n+                _ => {\n+                    report_atomic_type_validation_error(fx, intrinsic, span, layout.ty);\n+                    return;\n+                }\n+            }\n             let ty = fx.clif_type(layout.ty).unwrap();\n \n             let src = src.load_scalar(fx);\n@@ -962,7 +888,13 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n         _ if intrinsic.as_str().starts_with(\"atomic_xor\"), (v ptr, c src) {\n             let layout = src.layout();\n-            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            match layout.ty.kind() {\n+                ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n+                _ => {\n+                    report_atomic_type_validation_error(fx, intrinsic, span, layout.ty);\n+                    return;\n+                }\n+            }\n             let ty = fx.clif_type(layout.ty).unwrap();\n \n             let src = src.load_scalar(fx);\n@@ -974,7 +906,13 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n         _ if intrinsic.as_str().starts_with(\"atomic_nand\"), (v ptr, c src) {\n             let layout = src.layout();\n-            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            match layout.ty.kind() {\n+                ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n+                _ => {\n+                    report_atomic_type_validation_error(fx, intrinsic, span, layout.ty);\n+                    return;\n+                }\n+            }\n             let ty = fx.clif_type(layout.ty).unwrap();\n \n             let src = src.load_scalar(fx);\n@@ -986,7 +924,13 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n         _ if intrinsic.as_str().starts_with(\"atomic_max\"), (v ptr, c src) {\n             let layout = src.layout();\n-            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            match layout.ty.kind() {\n+                ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n+                _ => {\n+                    report_atomic_type_validation_error(fx, intrinsic, span, layout.ty);\n+                    return;\n+                }\n+            }\n             let ty = fx.clif_type(layout.ty).unwrap();\n \n             let src = src.load_scalar(fx);\n@@ -998,7 +942,13 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n         _ if intrinsic.as_str().starts_with(\"atomic_umax\"), (v ptr, c src) {\n             let layout = src.layout();\n-            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            match layout.ty.kind() {\n+                ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n+                _ => {\n+                    report_atomic_type_validation_error(fx, intrinsic, span, layout.ty);\n+                    return;\n+                }\n+            }\n             let ty = fx.clif_type(layout.ty).unwrap();\n \n             let src = src.load_scalar(fx);\n@@ -1010,7 +960,13 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n         _ if intrinsic.as_str().starts_with(\"atomic_min\"), (v ptr, c src) {\n             let layout = src.layout();\n-            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            match layout.ty.kind() {\n+                ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n+                _ => {\n+                    report_atomic_type_validation_error(fx, intrinsic, span, layout.ty);\n+                    return;\n+                }\n+            }\n             let ty = fx.clif_type(layout.ty).unwrap();\n \n             let src = src.load_scalar(fx);\n@@ -1022,7 +978,13 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n         _ if intrinsic.as_str().starts_with(\"atomic_umin\"), (v ptr, c src) {\n             let layout = src.layout();\n-            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            match layout.ty.kind() {\n+                ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n+                _ => {\n+                    report_atomic_type_validation_error(fx, intrinsic, span, layout.ty);\n+                    return;\n+                }\n+            }\n             let ty = fx.clif_type(layout.ty).unwrap();\n \n             let src = src.load_scalar(fx);\n@@ -1107,18 +1069,14 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, CValue::by_val(res, ret.layout()));\n         };\n \n-        raw_eq, <T>(v lhs_ref, v rhs_ref) {\n-            fn type_by_size(size: Size) -> Option<Type> {\n-                Type::int(size.bits().try_into().ok()?)\n-            }\n-\n-            let size = fx.layout_of(T).layout.size;\n+        raw_eq, (v lhs_ref, v rhs_ref) {\n+            let size = fx.layout_of(substs.type_at(0)).layout.size;\n             // FIXME add and use emit_small_memcmp\n             let is_eq_value =\n                 if size == Size::ZERO {\n                     // No bytes means they're trivially equal\n                     fx.bcx.ins().iconst(types::I8, 1)\n-                } else if let Some(clty) = type_by_size(size) {\n+                } else if let Some(clty) = size.bits().try_into().ok().and_then(Type::int) {\n                     // Can't use `trusted` for these loads; they could be unaligned.\n                     let mut flags = MemFlags::new();\n                     flags.set_notrap();\n@@ -1141,6 +1099,16 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, CValue::by_val(is_eq_value, ret.layout()));\n         };\n \n+        const_allocate, (c _size, c _align) {\n+            // returns a null pointer at runtime.\n+            let null = fx.bcx.ins().iconst(fx.pointer_type, 0);\n+            ret.write_cvalue(fx, CValue::by_val(null, ret.layout()));\n+        };\n+\n+        const_deallocate, (c _ptr, c _size, c _align) {\n+            // nop at runtime.\n+        };\n+\n         black_box, (c a) {\n             // FIXME implement black_box semantics\n             ret.write_cvalue(fx, a);"}, {"sha": "4153bc08e8ad4f3c9f40845f3098b0ebd8e9f622", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 270, "deletions": 177, "changes": 447, "blob_url": "https://github.com/rust-lang/rust/blob/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=8f53bdb45fb340ddd3630550b69675a880224d08", "patch": "@@ -1,71 +1,116 @@\n //! Codegen `extern \"platform-intrinsic\"` intrinsics.\n \n+use rustc_middle::ty::subst::SubstsRef;\n+use rustc_span::Symbol;\n+\n use super::*;\n use crate::prelude::*;\n \n+fn report_simd_type_validation_error(\n+    fx: &mut FunctionCx<'_, '_, '_>,\n+    intrinsic: Symbol,\n+    span: Span,\n+    ty: Ty<'_>,\n+) {\n+    fx.tcx.sess.span_err(span, &format!(\"invalid monomorphization of `{}` intrinsic: expected SIMD input type, found non-SIMD `{}`\", intrinsic, ty));\n+    // Prevent verifier error\n+    crate::trap::trap_unreachable(fx, \"compilation should not have succeeded\");\n+}\n+\n pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    instance: Instance<'tcx>,\n+    intrinsic: Symbol,\n+    _substs: SubstsRef<'tcx>,\n     args: &[mir::Operand<'tcx>],\n     ret: CPlace<'tcx>,\n     span: Span,\n ) {\n-    let def_id = instance.def_id();\n-    let substs = instance.substs;\n-\n-    let intrinsic = fx.tcx.item_name(def_id);\n-\n     intrinsic_match! {\n-        fx, intrinsic, substs, args,\n+        fx, intrinsic, args,\n         _ => {\n             fx.tcx.sess.span_fatal(span, &format!(\"Unknown SIMD intrinsic {}\", intrinsic));\n         };\n \n         simd_cast, (c a) {\n-            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n-            simd_for_each_lane(fx, a, ret, |fx, lane_layout, ret_lane_layout, lane| {\n-                let ret_lane_ty = fx.clif_type(ret_lane_layout.ty).unwrap();\n+            if !a.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, a.layout().ty);\n+                return;\n+            }\n+\n+            simd_for_each_lane(fx, a, ret, &|fx, lane_ty, ret_lane_ty, lane| {\n+                let ret_lane_clif_ty = fx.clif_type(ret_lane_ty).unwrap();\n \n-                let from_signed = type_sign(lane_layout.ty);\n-                let to_signed = type_sign(ret_lane_layout.ty);\n+                let from_signed = type_sign(lane_ty);\n+                let to_signed = type_sign(ret_lane_ty);\n \n-                let ret_lane = clif_int_or_float_cast(fx, lane, from_signed, ret_lane_ty, to_signed);\n-                CValue::by_val(ret_lane, ret_lane_layout)\n+                clif_int_or_float_cast(fx, lane, from_signed, ret_lane_clif_ty, to_signed)\n             });\n         };\n \n-        simd_eq, (c x, c y) {\n-            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n-            simd_cmp!(fx, Equal|Equal(x, y) -> ret);\n-        };\n-        simd_ne, (c x, c y) {\n-            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n-            simd_cmp!(fx, NotEqual|NotEqual(x, y) -> ret);\n-        };\n-        simd_lt, (c x, c y) {\n-            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n-            simd_cmp!(fx, UnsignedLessThan|SignedLessThan|LessThan(x, y) -> ret);\n-        };\n-        simd_le, (c x, c y) {\n-            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n-            simd_cmp!(fx, UnsignedLessThanOrEqual|SignedLessThanOrEqual|LessThanOrEqual(x, y) -> ret);\n-        };\n-        simd_gt, (c x, c y) {\n-            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n-            simd_cmp!(fx, UnsignedGreaterThan|SignedGreaterThan|GreaterThan(x, y) -> ret);\n-        };\n-        simd_ge, (c x, c y) {\n-            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n-            simd_cmp!(\n-                fx,\n-                UnsignedGreaterThanOrEqual|SignedGreaterThanOrEqual|GreaterThanOrEqual\n-                (x, y) -> ret\n-            );\n+        simd_eq | simd_ne | simd_lt | simd_le | simd_gt | simd_ge, (c x, c y) {\n+            if !x.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, x.layout().ty);\n+                return;\n+            }\n+\n+            // FIXME use vector instructions when possible\n+            simd_pair_for_each_lane(fx, x, y, ret, &|fx, lane_ty, res_lane_ty, x_lane, y_lane| {\n+                let res_lane = match (lane_ty.kind(), intrinsic) {\n+                    (ty::Uint(_), sym::simd_eq) => fx.bcx.ins().icmp(IntCC::Equal, x_lane, y_lane),\n+                    (ty::Uint(_), sym::simd_ne) => fx.bcx.ins().icmp(IntCC::NotEqual, x_lane, y_lane),\n+                    (ty::Uint(_), sym::simd_lt) => {\n+                        fx.bcx.ins().icmp(IntCC::UnsignedLessThan, x_lane, y_lane)\n+                    }\n+                    (ty::Uint(_), sym::simd_le) => {\n+                        fx.bcx.ins().icmp(IntCC::UnsignedLessThanOrEqual, x_lane, y_lane)\n+                    }\n+                    (ty::Uint(_), sym::simd_gt) => {\n+                        fx.bcx.ins().icmp(IntCC::UnsignedGreaterThan, x_lane, y_lane)\n+                    }\n+                    (ty::Uint(_), sym::simd_ge) => {\n+                        fx.bcx.ins().icmp(IntCC::UnsignedGreaterThanOrEqual, x_lane, y_lane)\n+                    }\n+\n+                    (ty::Int(_), sym::simd_eq) => fx.bcx.ins().icmp(IntCC::Equal, x_lane, y_lane),\n+                    (ty::Int(_), sym::simd_ne) => fx.bcx.ins().icmp(IntCC::NotEqual, x_lane, y_lane),\n+                    (ty::Int(_), sym::simd_lt) => fx.bcx.ins().icmp(IntCC::SignedLessThan, x_lane, y_lane),\n+                    (ty::Int(_), sym::simd_le) => {\n+                        fx.bcx.ins().icmp(IntCC::SignedLessThanOrEqual, x_lane, y_lane)\n+                    }\n+                    (ty::Int(_), sym::simd_gt) => {\n+                        fx.bcx.ins().icmp(IntCC::SignedGreaterThan, x_lane, y_lane)\n+                    }\n+                    (ty::Int(_), sym::simd_ge) => {\n+                        fx.bcx.ins().icmp(IntCC::SignedGreaterThanOrEqual, x_lane, y_lane)\n+                    }\n+\n+                    (ty::Float(_), sym::simd_eq) => fx.bcx.ins().fcmp(FloatCC::Equal, x_lane, y_lane),\n+                    (ty::Float(_), sym::simd_ne) => fx.bcx.ins().fcmp(FloatCC::NotEqual, x_lane, y_lane),\n+                    (ty::Float(_), sym::simd_lt) => fx.bcx.ins().fcmp(FloatCC::LessThan, x_lane, y_lane),\n+                    (ty::Float(_), sym::simd_le) => {\n+                        fx.bcx.ins().fcmp(FloatCC::LessThanOrEqual, x_lane, y_lane)\n+                    }\n+                    (ty::Float(_), sym::simd_gt) => fx.bcx.ins().fcmp(FloatCC::GreaterThan, x_lane, y_lane),\n+                    (ty::Float(_), sym::simd_ge) => {\n+                        fx.bcx.ins().fcmp(FloatCC::GreaterThanOrEqual, x_lane, y_lane)\n+                    }\n+\n+                    _ => unreachable!(),\n+                };\n+\n+                let ty = fx.clif_type(res_lane_ty).unwrap();\n+\n+                let res_lane = fx.bcx.ins().bint(ty, res_lane);\n+                fx.bcx.ins().ineg(res_lane)\n+            });\n         };\n \n         // simd_shuffle32<T, U>(x: T, y: T, idx: [u32; 32]) -> U\n         _ if intrinsic.as_str().starts_with(\"simd_shuffle\"), (c x, c y, o idx) {\n-            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n+            if !x.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, x.layout().ty);\n+                return;\n+            }\n \n             // If this intrinsic is the older \"simd_shuffleN\" form, simply parse the integer.\n             // If there is no suffix, use the index array length.\n@@ -167,7 +212,11 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         };\n \n         simd_extract, (c v, o idx) {\n-            validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n+            if !v.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, v.layout().ty);\n+                return;\n+            }\n+\n             let idx_const = if let Some(idx_const) = crate::constant::mir_operand_get_const_val(fx, idx) {\n                 idx_const\n             } else {\n@@ -195,95 +244,82 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         };\n \n         simd_neg, (c a) {\n-            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n-            simd_for_each_lane(fx, a, ret, |fx, lane_layout, ret_lane_layout, lane| {\n-                let ret_lane = match lane_layout.ty.kind() {\n+            if !a.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, a.layout().ty);\n+                return;\n+            }\n+\n+            simd_for_each_lane(fx, a, ret, &|fx, lane_ty, _ret_lane_ty, lane| {\n+                match lane_ty.kind() {\n                     ty::Int(_) => fx.bcx.ins().ineg(lane),\n                     ty::Float(_) => fx.bcx.ins().fneg(lane),\n                     _ => unreachable!(),\n-                };\n-                CValue::by_val(ret_lane, ret_lane_layout)\n+                }\n             });\n         };\n \n-        simd_fabs, (c a) {\n-            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n-            simd_for_each_lane(fx, a, ret, |fx, _lane_layout, ret_lane_layout, lane| {\n-                let ret_lane = fx.bcx.ins().fabs(lane);\n-                CValue::by_val(ret_lane, ret_lane_layout)\n-            });\n-        };\n+        simd_add | simd_sub | simd_mul | simd_div | simd_rem\n+        | simd_shl | simd_shr | simd_and | simd_or | simd_xor, (c x, c y) {\n+            if !x.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, x.layout().ty);\n+                return;\n+            }\n \n-        simd_fsqrt, (c a) {\n-            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n-            simd_for_each_lane(fx, a, ret, |fx, _lane_layout, ret_lane_layout, lane| {\n-                let ret_lane = fx.bcx.ins().sqrt(lane);\n-                CValue::by_val(ret_lane, ret_lane_layout)\n+            // FIXME use vector instructions when possible\n+            simd_pair_for_each_lane(fx, x, y, ret, &|fx, lane_ty, _ret_lane_ty, x_lane, y_lane| match (\n+                lane_ty.kind(),\n+                intrinsic,\n+            ) {\n+                (ty::Uint(_), sym::simd_add) => fx.bcx.ins().iadd(x_lane, y_lane),\n+                (ty::Uint(_), sym::simd_sub) => fx.bcx.ins().isub(x_lane, y_lane),\n+                (ty::Uint(_), sym::simd_mul) => fx.bcx.ins().imul(x_lane, y_lane),\n+                (ty::Uint(_), sym::simd_div) => fx.bcx.ins().udiv(x_lane, y_lane),\n+                (ty::Uint(_), sym::simd_rem) => fx.bcx.ins().urem(x_lane, y_lane),\n+\n+                (ty::Int(_), sym::simd_add) => fx.bcx.ins().iadd(x_lane, y_lane),\n+                (ty::Int(_), sym::simd_sub) => fx.bcx.ins().isub(x_lane, y_lane),\n+                (ty::Int(_), sym::simd_mul) => fx.bcx.ins().imul(x_lane, y_lane),\n+                (ty::Int(_), sym::simd_div) => fx.bcx.ins().sdiv(x_lane, y_lane),\n+                (ty::Int(_), sym::simd_rem) => fx.bcx.ins().srem(x_lane, y_lane),\n+\n+                (ty::Float(_), sym::simd_add) => fx.bcx.ins().fadd(x_lane, y_lane),\n+                (ty::Float(_), sym::simd_sub) => fx.bcx.ins().fsub(x_lane, y_lane),\n+                (ty::Float(_), sym::simd_mul) => fx.bcx.ins().fmul(x_lane, y_lane),\n+                (ty::Float(_), sym::simd_div) => fx.bcx.ins().fdiv(x_lane, y_lane),\n+                (ty::Float(FloatTy::F32), sym::simd_rem) => fx.lib_call(\n+                    \"fmodf\",\n+                    vec![AbiParam::new(types::F32), AbiParam::new(types::F32)],\n+                    vec![AbiParam::new(types::F32)],\n+                    &[x_lane, y_lane],\n+                )[0],\n+                (ty::Float(FloatTy::F64), sym::simd_rem) => fx.lib_call(\n+                    \"fmod\",\n+                    vec![AbiParam::new(types::F64), AbiParam::new(types::F64)],\n+                    vec![AbiParam::new(types::F64)],\n+                    &[x_lane, y_lane],\n+                )[0],\n+\n+                (ty::Uint(_), sym::simd_shl) => fx.bcx.ins().ishl(x_lane, y_lane),\n+                (ty::Uint(_), sym::simd_shr) => fx.bcx.ins().ushr(x_lane, y_lane),\n+                (ty::Uint(_), sym::simd_and) => fx.bcx.ins().band(x_lane, y_lane),\n+                (ty::Uint(_), sym::simd_or) => fx.bcx.ins().bor(x_lane, y_lane),\n+                (ty::Uint(_), sym::simd_xor) => fx.bcx.ins().bxor(x_lane, y_lane),\n+\n+                (ty::Int(_), sym::simd_shl) => fx.bcx.ins().ishl(x_lane, y_lane),\n+                (ty::Int(_), sym::simd_shr) => fx.bcx.ins().sshr(x_lane, y_lane),\n+                (ty::Int(_), sym::simd_and) => fx.bcx.ins().band(x_lane, y_lane),\n+                (ty::Int(_), sym::simd_or) => fx.bcx.ins().bor(x_lane, y_lane),\n+                (ty::Int(_), sym::simd_xor) => fx.bcx.ins().bxor(x_lane, y_lane),\n+\n+                _ => unreachable!(),\n             });\n         };\n \n-        simd_add, (c x, c y) {\n-            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n-            simd_int_flt_binop!(fx, iadd|fadd(x, y) -> ret);\n-        };\n-        simd_sub, (c x, c y) {\n-            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n-            simd_int_flt_binop!(fx, isub|fsub(x, y) -> ret);\n-        };\n-        simd_mul, (c x, c y) {\n-            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n-            simd_int_flt_binop!(fx, imul|fmul(x, y) -> ret);\n-        };\n-        simd_div, (c x, c y) {\n-            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n-            simd_int_flt_binop!(fx, udiv|sdiv|fdiv(x, y) -> ret);\n-        };\n-        simd_rem, (c x, c y) {\n-            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n-            simd_pair_for_each_lane(fx, x, y, ret, |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n-                let res_lane = match lane_layout.ty.kind() {\n-                    ty::Uint(_) => fx.bcx.ins().urem(x_lane, y_lane),\n-                    ty::Int(_) => fx.bcx.ins().srem(x_lane, y_lane),\n-                    ty::Float(FloatTy::F32) => fx.lib_call(\n-                        \"fmodf\",\n-                        vec![AbiParam::new(types::F32), AbiParam::new(types::F32)],\n-                        vec![AbiParam::new(types::F32)],\n-                        &[x_lane, y_lane],\n-                    )[0],\n-                    ty::Float(FloatTy::F64) => fx.lib_call(\n-                        \"fmod\",\n-                        vec![AbiParam::new(types::F64), AbiParam::new(types::F64)],\n-                        vec![AbiParam::new(types::F64)],\n-                        &[x_lane, y_lane],\n-                    )[0],\n-                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n-                };\n-                CValue::by_val(res_lane, ret_lane_layout)\n-            });\n-        };\n-        simd_shl, (c x, c y) {\n-            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n-            simd_int_binop!(fx, ishl(x, y) -> ret);\n-        };\n-        simd_shr, (c x, c y) {\n-            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n-            simd_int_binop!(fx, ushr|sshr(x, y) -> ret);\n-        };\n-        simd_and, (c x, c y) {\n-            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n-            simd_int_binop!(fx, band(x, y) -> ret);\n-        };\n-        simd_or, (c x, c y) {\n-            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n-            simd_int_binop!(fx, bor(x, y) -> ret);\n-        };\n-        simd_xor, (c x, c y) {\n-            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n-            simd_int_binop!(fx, bxor(x, y) -> ret);\n-        };\n-\n         simd_fma, (c a, c b, c c) {\n-            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n+            if !a.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, a.layout().ty);\n+                return;\n+            }\n             assert_eq!(a.layout(), b.layout());\n             assert_eq!(a.layout(), c.layout());\n             let layout = a.layout();\n@@ -305,19 +341,34 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             }\n         };\n \n-        simd_fmin, (c x, c y) {\n-            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n-            simd_flt_binop!(fx, fmin(x, y) -> ret);\n-        };\n-        simd_fmax, (c x, c y) {\n-            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n-            simd_flt_binop!(fx, fmax(x, y) -> ret);\n+        simd_fmin | simd_fmax, (c x, c y) {\n+            if !x.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, x.layout().ty);\n+                return;\n+            }\n+\n+            // FIXME use vector instructions when possible\n+            simd_pair_for_each_lane(fx, x, y, ret, &|fx, lane_ty, _ret_lane_ty, x_lane, y_lane| {\n+                match lane_ty.kind() {\n+                    ty::Float(_) => {},\n+                    _ => unreachable!(\"{:?}\", lane_ty),\n+                }\n+                match intrinsic {\n+                    sym::simd_fmin => fx.bcx.ins().fmin(x_lane, y_lane),\n+                    sym::simd_fmax => fx.bcx.ins().fmax(x_lane, y_lane),\n+                    _ => unreachable!(),\n+                }\n+            });\n         };\n \n         simd_round, (c a) {\n-            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n-            simd_for_each_lane(fx, a, ret, |fx, lane_layout, ret_lane_layout, lane| {\n-                let res_lane = match lane_layout.ty.kind() {\n+            if !a.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, a.layout().ty);\n+                return;\n+            }\n+\n+            simd_for_each_lane(fx, a, ret, &|fx, lane_ty, _ret_lane_ty, lane| {\n+                match lane_ty.kind() {\n                     ty::Float(FloatTy::F32) => fx.lib_call(\n                         \"roundf\",\n                         vec![AbiParam::new(types::F32)],\n@@ -330,37 +381,41 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                         vec![AbiParam::new(types::F64)],\n                         &[lane],\n                     )[0],\n-                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n-                };\n-                CValue::by_val(res_lane, ret_lane_layout)\n-            });\n-        };\n-        simd_ceil, (c a) {\n-            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n-            simd_for_each_lane(fx, a, ret, |fx, _lane_layout, ret_lane_layout, lane| {\n-                let ret_lane = fx.bcx.ins().ceil(lane);\n-                CValue::by_val(ret_lane, ret_lane_layout)\n-            });\n-        };\n-        simd_floor, (c a) {\n-            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n-            simd_for_each_lane(fx, a, ret, |fx, _lane_layout, ret_lane_layout, lane| {\n-                let ret_lane = fx.bcx.ins().floor(lane);\n-                CValue::by_val(ret_lane, ret_lane_layout)\n+                    _ => unreachable!(\"{:?}\", lane_ty),\n+                }\n             });\n         };\n-        simd_trunc, (c a) {\n-            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n-            simd_for_each_lane(fx, a, ret, |fx, _lane_layout, ret_lane_layout, lane| {\n-                let ret_lane = fx.bcx.ins().trunc(lane);\n-                CValue::by_val(ret_lane, ret_lane_layout)\n+\n+        simd_fabs | simd_fsqrt | simd_ceil | simd_floor | simd_trunc, (c a) {\n+            if !a.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, a.layout().ty);\n+                return;\n+            }\n+\n+            simd_for_each_lane(fx, a, ret, &|fx, lane_ty, _ret_lane_ty, lane| {\n+                match lane_ty.kind() {\n+                    ty::Float(_) => {},\n+                    _ => unreachable!(\"{:?}\", lane_ty),\n+                }\n+                match intrinsic {\n+                    sym::simd_fabs => fx.bcx.ins().fabs(lane),\n+                    sym::simd_fsqrt => fx.bcx.ins().sqrt(lane),\n+                    sym::simd_ceil => fx.bcx.ins().ceil(lane),\n+                    sym::simd_floor => fx.bcx.ins().floor(lane),\n+                    sym::simd_trunc => fx.bcx.ins().trunc(lane),\n+                    _ => unreachable!(),\n+                }\n             });\n         };\n \n         simd_reduce_add_ordered | simd_reduce_add_unordered, (c v, v acc) {\n-            validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n-            simd_reduce(fx, v, Some(acc), ret, |fx, lane_layout, a, b| {\n-                if lane_layout.ty.is_floating_point() {\n+            if !v.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, v.layout().ty);\n+                return;\n+            }\n+\n+            simd_reduce(fx, v, Some(acc), ret, &|fx, lane_ty, a, b| {\n+                if lane_ty.is_floating_point() {\n                     fx.bcx.ins().fadd(a, b)\n                 } else {\n                     fx.bcx.ins().iadd(a, b)\n@@ -369,9 +424,13 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         };\n \n         simd_reduce_mul_ordered | simd_reduce_mul_unordered, (c v, v acc) {\n-            validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n-            simd_reduce(fx, v, Some(acc), ret, |fx, lane_layout, a, b| {\n-                if lane_layout.ty.is_floating_point() {\n+            if !v.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, v.layout().ty);\n+                return;\n+            }\n+\n+            simd_reduce(fx, v, Some(acc), ret, &|fx, lane_ty, a, b| {\n+                if lane_ty.is_floating_point() {\n                     fx.bcx.ins().fmul(a, b)\n                 } else {\n                     fx.bcx.ins().imul(a, b)\n@@ -380,34 +439,58 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         };\n \n         simd_reduce_all, (c v) {\n-            validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n-            simd_reduce_bool(fx, v, ret, |fx, a, b| fx.bcx.ins().band(a, b));\n+            if !v.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, v.layout().ty);\n+                return;\n+            }\n+\n+            simd_reduce_bool(fx, v, ret, &|fx, a, b| fx.bcx.ins().band(a, b));\n         };\n \n         simd_reduce_any, (c v) {\n-            validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n-            simd_reduce_bool(fx, v, ret, |fx, a, b| fx.bcx.ins().bor(a, b));\n+            if !v.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, v.layout().ty);\n+                return;\n+            }\n+\n+            simd_reduce_bool(fx, v, ret, &|fx, a, b| fx.bcx.ins().bor(a, b));\n         };\n \n         simd_reduce_and, (c v) {\n-            validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n-            simd_reduce(fx, v, None, ret, |fx, _layout, a, b| fx.bcx.ins().band(a, b));\n+            if !v.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, v.layout().ty);\n+                return;\n+            }\n+\n+            simd_reduce(fx, v, None, ret, &|fx, _ty, a, b| fx.bcx.ins().band(a, b));\n         };\n \n         simd_reduce_or, (c v) {\n-            validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n-            simd_reduce(fx, v, None, ret, |fx, _layout, a, b| fx.bcx.ins().bor(a, b));\n+            if !v.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, v.layout().ty);\n+                return;\n+            }\n+\n+            simd_reduce(fx, v, None, ret, &|fx, _ty, a, b| fx.bcx.ins().bor(a, b));\n         };\n \n         simd_reduce_xor, (c v) {\n-            validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n-            simd_reduce(fx, v, None, ret, |fx, _layout, a, b| fx.bcx.ins().bxor(a, b));\n+            if !v.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, v.layout().ty);\n+                return;\n+            }\n+\n+            simd_reduce(fx, v, None, ret, &|fx, _ty, a, b| fx.bcx.ins().bxor(a, b));\n         };\n \n         simd_reduce_min, (c v) {\n-            validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n-            simd_reduce(fx, v, None, ret, |fx, layout, a, b| {\n-                let lt = match layout.ty.kind() {\n+            if !v.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, v.layout().ty);\n+                return;\n+            }\n+\n+            simd_reduce(fx, v, None, ret, &|fx, ty, a, b| {\n+                let lt = match ty.kind() {\n                     ty::Int(_) => fx.bcx.ins().icmp(IntCC::SignedLessThan, a, b),\n                     ty::Uint(_) => fx.bcx.ins().icmp(IntCC::UnsignedLessThan, a, b),\n                     ty::Float(_) => fx.bcx.ins().fcmp(FloatCC::LessThan, a, b),\n@@ -418,9 +501,13 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         };\n \n         simd_reduce_max, (c v) {\n-            validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n-            simd_reduce(fx, v, None, ret, |fx, layout, a, b| {\n-                let gt = match layout.ty.kind() {\n+            if !v.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, v.layout().ty);\n+                return;\n+            }\n+\n+            simd_reduce(fx, v, None, ret, &|fx, ty, a, b| {\n+                let gt = match ty.kind() {\n                     ty::Int(_) => fx.bcx.ins().icmp(IntCC::SignedGreaterThan, a, b),\n                     ty::Uint(_) => fx.bcx.ins().icmp(IntCC::UnsignedGreaterThan, a, b),\n                     ty::Float(_) => fx.bcx.ins().fcmp(FloatCC::GreaterThan, a, b),\n@@ -431,8 +518,14 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         };\n \n         simd_select, (c m, c a, c b) {\n-            validate_simd_type!(fx, intrinsic, span, m.layout().ty);\n-            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n+            if !m.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, m.layout().ty);\n+                return;\n+            }\n+            if !a.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, a.layout().ty);\n+                return;\n+            }\n             assert_eq!(a.layout(), b.layout());\n \n             let (lane_count, lane_ty) = a.layout().ty.simd_size_and_type(fx.tcx);"}, {"sha": "9ce727279c27c876095a3e41f01698800ee57609", "filename": "compiler/rustc_codegen_cranelift/src/main_shim.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs?ref=8f53bdb45fb340ddd3630550b69675a880224d08", "patch": "@@ -1,4 +1,3 @@\n-use cranelift_codegen::binemit::{NullStackMapSink, NullTrapSink};\n use rustc_hir::LangItem;\n use rustc_middle::ty::subst::GenericArg;\n use rustc_middle::ty::AssocKind;\n@@ -152,8 +151,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n             bcx.seal_all_blocks();\n             bcx.finalize();\n         }\n-        m.define_function(cmain_func_id, &mut ctx, &mut NullTrapSink {}, &mut NullStackMapSink {})\n-            .unwrap();\n+        m.define_function(cmain_func_id, &mut ctx).unwrap();\n         unwind_context.add_function(cmain_func_id, &ctx, m.isa());\n     }\n }"}, {"sha": "d1f89adb3bb916789436685d774ff220b159ed9f", "filename": "compiler/rustc_codegen_cranelift/src/optimize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs?ref=8f53bdb45fb340ddd3630550b69675a880224d08", "patch": "@@ -15,6 +15,6 @@ pub(crate) fn optimize_function<'tcx>(\n ) {\n     // FIXME classify optimizations over opt levels once we have more\n \n-    crate::pretty_clif::write_clif_file(tcx, \"preopt\", isa, instance, &ctx, &*clif_comments);\n+    crate::pretty_clif::write_clif_file(tcx, \"preopt\", isa, instance, &ctx.func, &*clif_comments);\n     crate::base::verify_func(tcx, &*clif_comments, &ctx.func);\n }"}, {"sha": "ca7116b887d5a622a298d336ade72684f18413df", "filename": "compiler/rustc_codegen_cranelift/src/pretty_clif.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs?ref=8f53bdb45fb340ddd3630550b69675a880224d08", "patch": "@@ -234,20 +234,16 @@ pub(crate) fn write_clif_file<'tcx>(\n     postfix: &str,\n     isa: &dyn cranelift_codegen::isa::TargetIsa,\n     instance: Instance<'tcx>,\n-    context: &cranelift_codegen::Context,\n+    func: &cranelift_codegen::ir::Function,\n     mut clif_comments: &CommentWriter,\n ) {\n     write_ir_file(\n         tcx,\n         || format!(\"{}.{}.clif\", tcx.symbol_name(instance).name, postfix),\n         |file| {\n             let mut clif = String::new();\n-            cranelift_codegen::write::decorate_function(\n-                &mut clif_comments,\n-                &mut clif,\n-                &context.func,\n-            )\n-            .unwrap();\n+            cranelift_codegen::write::decorate_function(&mut clif_comments, &mut clif, func)\n+                .unwrap();\n \n             for flag in isa.flags().iter() {\n                 writeln!(file, \"set {}\", flag)?;"}, {"sha": "18528d542972990c42cf28d447e487e118b6acf9", "filename": "compiler/rustc_codegen_cranelift/y.rs", "status": "modified", "additions": 3, "deletions": 130, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f53bdb45fb340ddd3630550b69675a880224d08/compiler%2Frustc_codegen_cranelift%2Fy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fy.rs?ref=8f53bdb45fb340ddd3630550b69675a880224d08", "patch": "@@ -23,136 +23,9 @@ exec ${0/.rs/.bin} $@\n //!\n //! The name `y.rs` was chosen to not conflict with rustc's `x.py`.\n \n-use std::env;\n-use std::path::PathBuf;\n-use std::process;\n-\n-#[path = \"build_system/build_backend.rs\"]\n-mod build_backend;\n-#[path = \"build_system/build_sysroot.rs\"]\n-mod build_sysroot;\n-#[path = \"build_system/config.rs\"]\n-mod config;\n-#[path = \"build_system/prepare.rs\"]\n-mod prepare;\n-#[path = \"build_system/rustc_info.rs\"]\n-mod rustc_info;\n-#[path = \"build_system/utils.rs\"]\n-mod utils;\n-\n-fn usage() {\n-    eprintln!(\"Usage:\");\n-    eprintln!(\"  ./y.rs prepare\");\n-    eprintln!(\n-        \"  ./y.rs build [--debug] [--sysroot none|clif|llvm] [--target-dir DIR] [--no-unstable-features]\"\n-    );\n-}\n-\n-macro_rules! arg_error {\n-    ($($err:tt)*) => {{\n-        eprintln!($($err)*);\n-        usage();\n-        std::process::exit(1);\n-    }};\n-}\n-\n-enum Command {\n-    Build,\n-}\n-\n-#[derive(Copy, Clone)]\n-enum SysrootKind {\n-    None,\n-    Clif,\n-    Llvm,\n-}\n+#[path = \"build_system/mod.rs\"]\n+mod build_system;\n \n fn main() {\n-    env::set_var(\"CG_CLIF_DISPLAY_CG_TIME\", \"1\");\n-    env::set_var(\"CG_CLIF_DISABLE_INCR_CACHE\", \"1\");\n-    // The target dir is expected in the default location. Guard against the user changing it.\n-    env::set_var(\"CARGO_TARGET_DIR\", \"target\");\n-\n-    let mut args = env::args().skip(1);\n-    let command = match args.next().as_deref() {\n-        Some(\"prepare\") => {\n-            if args.next().is_some() {\n-                arg_error!(\"./x.rs prepare doesn't expect arguments\");\n-            }\n-            prepare::prepare();\n-            process::exit(0);\n-        }\n-        Some(\"build\") => Command::Build,\n-        Some(flag) if flag.starts_with('-') => arg_error!(\"Expected command found flag {}\", flag),\n-        Some(command) => arg_error!(\"Unknown command {}\", command),\n-        None => {\n-            usage();\n-            process::exit(0);\n-        }\n-    };\n-\n-    let mut target_dir = PathBuf::from(\"build\");\n-    let mut channel = \"release\";\n-    let mut sysroot_kind = SysrootKind::Clif;\n-    let mut use_unstable_features = true;\n-    while let Some(arg) = args.next().as_deref() {\n-        match arg {\n-            \"--target-dir\" => {\n-                target_dir = PathBuf::from(args.next().unwrap_or_else(|| {\n-                    arg_error!(\"--target-dir requires argument\");\n-                }))\n-            }\n-            \"--debug\" => channel = \"debug\",\n-            \"--sysroot\" => {\n-                sysroot_kind = match args.next().as_deref() {\n-                    Some(\"none\") => SysrootKind::None,\n-                    Some(\"clif\") => SysrootKind::Clif,\n-                    Some(\"llvm\") => SysrootKind::Llvm,\n-                    Some(arg) => arg_error!(\"Unknown sysroot kind {}\", arg),\n-                    None => arg_error!(\"--sysroot requires argument\"),\n-                }\n-            }\n-            \"--no-unstable-features\" => use_unstable_features = false,\n-            flag if flag.starts_with(\"-\") => arg_error!(\"Unknown flag {}\", flag),\n-            arg => arg_error!(\"Unexpected argument {}\", arg),\n-        }\n-    }\n-\n-    let host_triple = if let Ok(host_triple) = std::env::var(\"HOST_TRIPLE\") {\n-        host_triple\n-    } else if let Some(host_triple) = crate::config::get_value(\"host\") {\n-        host_triple\n-    } else {\n-        rustc_info::get_host_triple()\n-    };\n-    let target_triple = if let Ok(target_triple) = std::env::var(\"TARGET_TRIPLE\") {\n-        if target_triple != \"\" {\n-            target_triple\n-        } else {\n-            host_triple.clone() // Empty target triple can happen on GHA\n-        }\n-    } else if let Some(target_triple) = crate::config::get_value(\"target\") {\n-        target_triple\n-    } else {\n-        host_triple.clone()\n-    };\n-\n-    if target_triple.ends_with(\"-msvc\") {\n-        eprintln!(\"The MSVC toolchain is not yet supported by rustc_codegen_cranelift.\");\n-        eprintln!(\"Switch to the MinGW toolchain for Windows support.\");\n-        eprintln!(\"Hint: You can use `rustup set default-host x86_64-pc-windows-gnu` to\");\n-        eprintln!(\"set the global default target to MinGW\");\n-        process::exit(1);\n-    }\n-\n-    let cg_clif_build_dir =\n-        build_backend::build_backend(channel, &host_triple, use_unstable_features);\n-    build_sysroot::build_sysroot(\n-        channel,\n-        sysroot_kind,\n-        &target_dir,\n-        cg_clif_build_dir,\n-        &host_triple,\n-        &target_triple,\n-    );\n+    build_system::main();\n }"}]}