{"sha": "87b0cf4541c319b6626c5583bfbeed6ece7306c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3YjBjZjQ1NDFjMzE5YjY2MjZjNTU4M2JmYmVlZDZlY2U3MzA2YzE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-10-06T03:03:56Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-10-08T22:53:42Z"}, "message": "rustfmt'ing", "tree": {"sha": "14f5773cbe7a5d2c892c95b66f8f6ef2148265e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14f5773cbe7a5d2c892c95b66f8f6ef2148265e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87b0cf4541c319b6626c5583bfbeed6ece7306c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87b0cf4541c319b6626c5583bfbeed6ece7306c1", "html_url": "https://github.com/rust-lang/rust/commit/87b0cf4541c319b6626c5583bfbeed6ece7306c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87b0cf4541c319b6626c5583bfbeed6ece7306c1/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b4f28e531b7fa9ad6dd3cd14cd953a7bbf8b326", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b4f28e531b7fa9ad6dd3cd14cd953a7bbf8b326", "html_url": "https://github.com/rust-lang/rust/commit/2b4f28e531b7fa9ad6dd3cd14cd953a7bbf8b326"}], "stats": {"total": 1214, "additions": 660, "deletions": 554}, "files": [{"sha": "681fc6144f35036975e4b1a66199f64e88aaa9de", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 660, "deletions": 554, "changes": 1214, "blob_url": "https://github.com/rust-lang/rust/blob/87b0cf4541c319b6626c5583bfbeed6ece7306c1/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87b0cf4541c319b6626c5583bfbeed6ece7306c1/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=87b0cf4541c319b6626c5583bfbeed6ece7306c1", "patch": "@@ -121,24 +121,26 @@ pub fn lower_view_path(_lctx: &LoweringContext, view_path: &ViewPath) -> P<hir::\n             }\n             ViewPathList(ref path, ref path_list_idents) => {\n                 hir::ViewPathList(lower_path(_lctx, path),\n-                             path_list_idents.iter().map(|path_list_ident| {\n-                                Spanned {\n-                                    node: match path_list_ident.node {\n-                                        PathListIdent { id, name, rename } =>\n-                                            hir::PathListIdent {\n-                                                id: id,\n-                                                name: name.name,\n-                                                rename: rename.map(|x| x.name),\n-                                            },\n-                                        PathListMod { id, rename } =>\n-                                            hir::PathListMod {\n-                                                id: id,\n-                                                rename: rename.map(|x| x.name)\n-                                            }\n-                                    },\n-                                    span: path_list_ident.span\n-                                }\n-                             }).collect())\n+                                  path_list_idents.iter()\n+                                                  .map(|path_list_ident| {\n+                                                      Spanned {\n+                                                          node: match path_list_ident.node {\n+                                                              PathListIdent { id, name, rename } =>\n+                                                                  hir::PathListIdent {\n+                                                                  id: id,\n+                                                                  name: name.name,\n+                                                                  rename: rename.map(|x| x.name),\n+                                                              },\n+                                                              PathListMod { id, rename } =>\n+                                                                  hir::PathListMod {\n+                                                                  id: id,\n+                                                                  rename: rename.map(|x| x.name),\n+                                                              },\n+                                                          },\n+                                                          span: path_list_ident.span,\n+                                                      }\n+                                                  })\n+                                                  .collect())\n             }\n         },\n         span: view_path.span,\n@@ -158,17 +160,22 @@ pub fn lower_decl(_lctx: &LoweringContext, d: &Decl) -> P<hir::Decl> {\n     match d.node {\n         DeclLocal(ref l) => P(Spanned {\n             node: hir::DeclLocal(lower_local(_lctx, l)),\n-            span: d.span\n+            span: d.span,\n         }),\n         DeclItem(ref it) => P(Spanned {\n             node: hir::DeclItem(lower_item(_lctx, it)),\n-            span: d.span\n+            span: d.span,\n         }),\n     }\n }\n \n pub fn lower_ty_binding(_lctx: &LoweringContext, b: &TypeBinding) -> P<hir::TypeBinding> {\n-    P(hir::TypeBinding { id: b.id, name: b.ident.name, ty: lower_ty(_lctx, &b.ty), span: b.span })\n+    P(hir::TypeBinding {\n+        id: b.id,\n+        name: b.ident.name,\n+        ty: lower_ty(_lctx, &b.ty),\n+        span: b.span,\n+    })\n }\n \n pub fn lower_ty(_lctx: &LoweringContext, t: &Ty) -> P<hir::Ty> {\n@@ -179,7 +186,8 @@ pub fn lower_ty(_lctx: &LoweringContext, t: &Ty) -> P<hir::Ty> {\n             TyVec(ref ty) => hir::TyVec(lower_ty(_lctx, ty)),\n             TyPtr(ref mt) => hir::TyPtr(lower_mt(_lctx, mt)),\n             TyRptr(ref region, ref mt) => {\n-                hir::TyRptr(lower_opt_lifetime(_lctx, region), lower_mt(_lctx, mt))\n+                hir::TyRptr(lower_opt_lifetime(_lctx, region),\n+                            lower_mt(_lctx, mt))\n             }\n             TyBareFn(ref f) => {\n                 hir::TyBareFn(P(hir::BareFnTy {\n@@ -201,8 +209,7 @@ pub fn lower_ty(_lctx: &LoweringContext, t: &Ty) -> P<hir::Ty> {\n                 hir::TyPath(qself, lower_path(_lctx, path))\n             }\n             TyObjectSum(ref ty, ref bounds) => {\n-                hir::TyObjectSum(lower_ty(_lctx, ty),\n-                            lower_bounds(_lctx, bounds))\n+                hir::TyObjectSum(lower_ty(_lctx, ty), lower_bounds(_lctx, bounds))\n             }\n             TyFixedLengthVec(ref ty, ref e) => {\n                 hir::TyFixedLengthVec(lower_ty(_lctx, ty), lower_expr(_lctx, e))\n@@ -234,8 +241,9 @@ pub fn lower_variant(_lctx: &LoweringContext, v: &Variant) -> P<hir::Variant> {\n             attrs: v.node.attrs.clone(),\n             kind: match v.node.kind {\n                 TupleVariantKind(ref variant_args) => {\n-                    hir::TupleVariantKind(variant_args.iter().map(|ref x|\n-                        lower_variant_arg(_lctx, x)).collect())\n+                    hir::TupleVariantKind(variant_args.iter()\n+                                                      .map(|ref x| lower_variant_arg(_lctx, x))\n+                                                      .collect())\n                 }\n                 StructVariantKind(ref struct_def) => {\n                     hir::StructVariantKind(lower_struct_def(_lctx, struct_def))\n@@ -250,11 +258,15 @@ pub fn lower_variant(_lctx: &LoweringContext, v: &Variant) -> P<hir::Variant> {\n pub fn lower_path(_lctx: &LoweringContext, p: &Path) -> hir::Path {\n     hir::Path {\n         global: p.global,\n-        segments: p.segments.iter().map(|&PathSegment {identifier, ref parameters}|\n-            hir::PathSegment {\n-                identifier: identifier,\n-                parameters: lower_path_parameters(_lctx, parameters),\n-            }).collect(),\n+        segments: p.segments\n+                   .iter()\n+                   .map(|&PathSegment { identifier, ref parameters }| {\n+                       hir::PathSegment {\n+                           identifier: identifier,\n+                           parameters: lower_path_parameters(_lctx, parameters),\n+                       }\n+                   })\n+                   .collect(),\n         span: p.span,\n     }\n }\n@@ -294,12 +306,12 @@ pub fn lower_parenthesized_parameter_data(_lctx: &LoweringContext,\n \n pub fn lower_local(_lctx: &LoweringContext, l: &Local) -> P<hir::Local> {\n     P(hir::Local {\n-            id: l.id,\n-            ty: l.ty.as_ref().map(|t| lower_ty(_lctx, t)),\n-            pat: lower_pat(_lctx, &l.pat),\n-            init: l.init.as_ref().map(|e| lower_expr(_lctx, e)),\n-            span: l.span,\n-        })\n+        id: l.id,\n+        ty: l.ty.as_ref().map(|t| lower_ty(_lctx, t)),\n+        pat: lower_pat(_lctx, &l.pat),\n+        init: l.init.as_ref().map(|e| lower_expr(_lctx, e)),\n+        span: l.span,\n+    })\n }\n \n pub fn lower_explicit_self_underscore(_lctx: &LoweringContext,\n@@ -327,11 +339,18 @@ pub fn lower_mutability(_lctx: &LoweringContext, m: Mutability) -> hir::Mutabili\n }\n \n pub fn lower_explicit_self(_lctx: &LoweringContext, s: &ExplicitSelf) -> hir::ExplicitSelf {\n-    Spanned { node: lower_explicit_self_underscore(_lctx, &s.node), span: s.span }\n+    Spanned {\n+        node: lower_explicit_self_underscore(_lctx, &s.node),\n+        span: s.span,\n+    }\n }\n \n pub fn lower_arg(_lctx: &LoweringContext, arg: &Arg) -> hir::Arg {\n-    hir::Arg { id: arg.id, pat: lower_pat(_lctx, &arg.pat), ty: lower_ty(_lctx, &arg.ty) }\n+    hir::Arg {\n+        id: arg.id,\n+        pat: lower_pat(_lctx, &arg.pat),\n+        ty: lower_ty(_lctx, &arg.ty),\n+    }\n }\n \n pub fn lower_fn_decl(_lctx: &LoweringContext, decl: &FnDecl) -> P<hir::FnDecl> {\n@@ -375,13 +394,17 @@ pub fn lower_ty_params(_lctx: &LoweringContext,\n }\n \n pub fn lower_lifetime(_lctx: &LoweringContext, l: &Lifetime) -> hir::Lifetime {\n-    hir::Lifetime { id: l.id, name: l.name, span: l.span }\n+    hir::Lifetime {\n+        id: l.id,\n+        name: l.name,\n+        span: l.span,\n+    }\n }\n \n pub fn lower_lifetime_def(_lctx: &LoweringContext, l: &LifetimeDef) -> hir::LifetimeDef {\n     hir::LifetimeDef {\n         lifetime: lower_lifetime(_lctx, &l.lifetime),\n-        bounds: lower_lifetimes(_lctx, &l.bounds)\n+        bounds: lower_lifetimes(_lctx, &l.bounds),\n     }\n }\n \n@@ -412,8 +435,10 @@ pub fn lower_generics(_lctx: &LoweringContext, g: &Generics) -> hir::Generics {\n pub fn lower_where_clause(_lctx: &LoweringContext, wc: &WhereClause) -> hir::WhereClause {\n     hir::WhereClause {\n         id: wc.id,\n-        predicates: wc.predicates.iter().map(|predicate|\n-            lower_where_predicate(_lctx, predicate)).collect(),\n+        predicates: wc.predicates\n+                      .iter()\n+                      .map(|predicate| lower_where_predicate(_lctx, predicate))\n+                      .collect(),\n     }\n }\n \n@@ -429,7 +454,7 @@ pub fn lower_where_predicate(_lctx: &LoweringContext,\n                 bound_lifetimes: lower_lifetime_defs(_lctx, bound_lifetimes),\n                 bounded_ty: lower_ty(_lctx, bounded_ty),\n                 bounds: bounds.iter().map(|x| lower_ty_param_bound(_lctx, x)).collect(),\n-                span: span\n+                span: span,\n             })\n         }\n         WherePredicate::RegionPredicate(WhereRegionPredicate{ ref lifetime,\n@@ -438,7 +463,7 @@ pub fn lower_where_predicate(_lctx: &LoweringContext,\n             hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n                 span: span,\n                 lifetime: lower_lifetime(_lctx, lifetime),\n-                bounds: bounds.iter().map(|bound| lower_lifetime(_lctx, bound)).collect()\n+                bounds: bounds.iter().map(|bound| lower_lifetime(_lctx, bound)).collect(),\n             })\n         }\n         WherePredicate::EqPredicate(WhereEqPredicate{ id,\n@@ -448,8 +473,8 @@ pub fn lower_where_predicate(_lctx: &LoweringContext,\n             hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                 id: id,\n                 path: lower_path(_lctx, path),\n-                ty:lower_ty(_lctx, ty),\n-                span: span\n+                ty: lower_ty(_lctx, ty),\n+                span: span,\n             })\n         }\n     }\n@@ -463,7 +488,10 @@ pub fn lower_struct_def(_lctx: &LoweringContext, sd: &StructDef) -> P<hir::Struc\n }\n \n pub fn lower_trait_ref(_lctx: &LoweringContext, p: &TraitRef) -> hir::TraitRef {\n-    hir::TraitRef { path: lower_path(_lctx, &p.path), ref_id: p.ref_id }\n+    hir::TraitRef {\n+        path: lower_path(_lctx, &p.path),\n+        ref_id: p.ref_id,\n+    }\n }\n \n pub fn lower_poly_trait_ref(_lctx: &LoweringContext, p: &PolyTraitRef) -> hir::PolyTraitRef {\n@@ -489,15 +517,20 @@ pub fn lower_struct_field(_lctx: &LoweringContext, f: &StructField) -> hir::Stru\n pub fn lower_field(_lctx: &LoweringContext, f: &Field) -> hir::Field {\n     hir::Field {\n         name: respan(f.ident.span, f.ident.node.name),\n-        expr: lower_expr(_lctx, &f.expr), span: f.span\n+        expr: lower_expr(_lctx, &f.expr),\n+        span: f.span,\n     }\n }\n \n pub fn lower_mt(_lctx: &LoweringContext, mt: &MutTy) -> hir::MutTy {\n-    hir::MutTy { ty: lower_ty(_lctx, &mt.ty), mutbl: lower_mutability(_lctx, mt.mutbl) }\n+    hir::MutTy {\n+        ty: lower_ty(_lctx, &mt.ty),\n+        mutbl: lower_mutability(_lctx, mt.mutbl),\n+    }\n }\n \n-pub fn lower_opt_bounds(_lctx: &LoweringContext, b: &Option<OwnedSlice<TyParamBound>>)\n+pub fn lower_opt_bounds(_lctx: &LoweringContext,\n+                        b: &Option<OwnedSlice<TyParamBound>>)\n                         -> Option<OwnedSlice<hir::TyParamBound>> {\n     b.as_ref().map(|ref bounds| lower_bounds(_lctx, bounds))\n }\n@@ -507,7 +540,10 @@ fn lower_bounds(_lctx: &LoweringContext, bounds: &TyParamBounds) -> hir::TyParam\n }\n \n fn lower_variant_arg(_lctx: &LoweringContext, va: &VariantArg) -> hir::VariantArg {\n-    hir::VariantArg { id: va.id, ty: lower_ty(_lctx, &va.ty) }\n+    hir::VariantArg {\n+        id: va.id,\n+        ty: lower_ty(_lctx, &va.ty),\n+    }\n }\n \n pub fn lower_block(_lctx: &LoweringContext, b: &Block) -> P<hir::Block> {\n@@ -527,45 +563,47 @@ pub fn lower_item_underscore(_lctx: &LoweringContext, i: &Item_) -> hir::Item_ {\n             hir::ItemUse(lower_view_path(_lctx, view_path))\n         }\n         ItemStatic(ref t, m, ref e) => {\n-            hir::ItemStatic(lower_ty(_lctx, t), lower_mutability(_lctx, m), lower_expr(_lctx, e))\n+            hir::ItemStatic(lower_ty(_lctx, t),\n+                            lower_mutability(_lctx, m),\n+                            lower_expr(_lctx, e))\n         }\n         ItemConst(ref t, ref e) => {\n             hir::ItemConst(lower_ty(_lctx, t), lower_expr(_lctx, e))\n         }\n         ItemFn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n-            hir::ItemFn(\n-                lower_fn_decl(_lctx, decl),\n-                lower_unsafety(_lctx, unsafety),\n-                lower_constness(_lctx, constness),\n-                abi,\n-                lower_generics(_lctx, generics),\n-                lower_block(_lctx, body)\n-            )\n+            hir::ItemFn(lower_fn_decl(_lctx, decl),\n+                        lower_unsafety(_lctx, unsafety),\n+                        lower_constness(_lctx, constness),\n+                        abi,\n+                        lower_generics(_lctx, generics),\n+                        lower_block(_lctx, body))\n         }\n         ItemMod(ref m) => hir::ItemMod(lower_mod(_lctx, m)),\n         ItemForeignMod(ref nm) => hir::ItemForeignMod(lower_foreign_mod(_lctx, nm)),\n         ItemTy(ref t, ref generics) => {\n             hir::ItemTy(lower_ty(_lctx, t), lower_generics(_lctx, generics))\n         }\n         ItemEnum(ref enum_definition, ref generics) => {\n-            hir::ItemEnum(\n-                hir::EnumDef {\n-                    variants: enum_definition.variants.iter().map(|x| {\n-                        lower_variant(_lctx, x)\n-                    }).collect(),\n-                },\n-                lower_generics(_lctx, generics))\n+            hir::ItemEnum(hir::EnumDef {\n+                              variants: enum_definition.variants\n+                                                       .iter()\n+                                                       .map(|x| lower_variant(_lctx, x))\n+                                                       .collect(),\n+                          },\n+                          lower_generics(_lctx, generics))\n         }\n         ItemStruct(ref struct_def, ref generics) => {\n             let struct_def = lower_struct_def(_lctx, struct_def);\n             hir::ItemStruct(struct_def, lower_generics(_lctx, generics))\n         }\n         ItemDefaultImpl(unsafety, ref trait_ref) => {\n-            hir::ItemDefaultImpl(lower_unsafety(_lctx, unsafety), lower_trait_ref(_lctx, trait_ref))\n+            hir::ItemDefaultImpl(lower_unsafety(_lctx, unsafety),\n+                                 lower_trait_ref(_lctx, trait_ref))\n         }\n         ItemImpl(unsafety, polarity, ref generics, ref ifce, ref ty, ref impl_items) => {\n-            let new_impl_items =\n-                impl_items.iter().map(|item| lower_impl_item(_lctx, item)).collect();\n+            let new_impl_items = impl_items.iter()\n+                                           .map(|item| lower_impl_item(_lctx, item))\n+                                           .collect();\n             let ifce = ifce.as_ref().map(|trait_ref| lower_trait_ref(_lctx, trait_ref));\n             hir::ItemImpl(lower_unsafety(_lctx, unsafety),\n                           lower_impl_polarity(_lctx, polarity),\n@@ -611,11 +649,11 @@ pub fn lower_trait_item(_lctx: &LoweringContext, i: &TraitItem) -> P<hir::TraitI\n \n pub fn lower_impl_item(_lctx: &LoweringContext, i: &ImplItem) -> P<hir::ImplItem> {\n     P(hir::ImplItem {\n-            id: i.id,\n-            name: i.ident.name,\n-            attrs: i.attrs.clone(),\n-            vis: lower_visibility(_lctx, i.vis),\n-            node: match i.node  {\n+        id: i.id,\n+        name: i.ident.name,\n+        attrs: i.attrs.clone(),\n+        vis: lower_visibility(_lctx, i.vis),\n+        node: match i.node {\n             ConstImplItem(ref ty, ref expr) => {\n                 hir::ConstImplItem(lower_ty(_lctx, ty), lower_expr(_lctx, expr))\n             }\n@@ -631,7 +669,10 @@ pub fn lower_impl_item(_lctx: &LoweringContext, i: &ImplItem) -> P<hir::ImplItem\n }\n \n pub fn lower_mod(_lctx: &LoweringContext, m: &Mod) -> hir::Mod {\n-    hir::Mod { inner: m.inner, items: m.items.iter().map(|x| lower_item(_lctx, x)).collect() }\n+    hir::Mod {\n+        inner: m.inner,\n+        items: m.items.iter().map(|x| lower_item(_lctx, x)).collect(),\n+    }\n }\n \n pub fn lower_crate(_lctx: &LoweringContext, c: &Crate) -> hir::Crate {\n@@ -684,15 +725,16 @@ pub fn lower_foreign_item(_lctx: &LoweringContext, i: &ForeignItem) -> P<hir::Fo\n         attrs: i.attrs.clone(),\n         node: match i.node {\n             ForeignItemFn(ref fdec, ref generics) => {\n-                hir::ForeignItemFn(lower_fn_decl(_lctx, fdec), lower_generics(_lctx, generics))\n+                hir::ForeignItemFn(lower_fn_decl(_lctx, fdec),\n+                                   lower_generics(_lctx, generics))\n             }\n             ForeignItemStatic(ref t, m) => {\n                 hir::ForeignItemStatic(lower_ty(_lctx, t), m)\n             }\n         },\n-            vis: lower_visibility(_lctx, i.vis),\n-            span: i.span,\n-        })\n+        vis: lower_visibility(_lctx, i.vis),\n+        span: i.span,\n+    })\n }\n \n pub fn lower_method_sig(_lctx: &LoweringContext, sig: &MethodSig) -> hir::MethodSig {\n@@ -756,13 +798,13 @@ pub fn lower_binop(_lctx: &LoweringContext, b: BinOp) -> hir::BinOp {\n \n pub fn lower_pat(_lctx: &LoweringContext, p: &Pat) -> P<hir::Pat> {\n     P(hir::Pat {\n-            id: p.id,\n-            node: match p.node {\n+        id: p.id,\n+        node: match p.node {\n             PatWild(k) => hir::PatWild(lower_pat_wild_kind(_lctx, k)),\n             PatIdent(ref binding_mode, pth1, ref sub) => {\n                 hir::PatIdent(lower_binding_mode(_lctx, binding_mode),\n-                        pth1,\n-                        sub.as_ref().map(|x| lower_pat(_lctx, x)))\n+                              pth1,\n+                              sub.as_ref().map(|x| lower_pat(_lctx, x)))\n             }\n             PatLit(ref e) => hir::PatLit(lower_expr(_lctx, e)),\n             PatEnum(ref pth, ref pats) => {\n@@ -779,14 +821,18 @@ pub fn lower_pat(_lctx: &LoweringContext, p: &Pat) -> P<hir::Pat> {\n             }\n             PatStruct(ref pth, ref fields, etc) => {\n                 let pth = lower_path(_lctx, pth);\n-                let fs = fields.iter().map(|f| {\n-                    Spanned { span: f.span,\n-                              node: hir::FieldPat {\n-                                  name: f.node.ident.name,\n-                                  pat: lower_pat(_lctx, &f.node.pat),\n-                                  is_shorthand: f.node.is_shorthand,\n-                              }}\n-                }).collect();\n+                let fs = fields.iter()\n+                               .map(|f| {\n+                                   Spanned {\n+                                       span: f.span,\n+                                       node: hir::FieldPat {\n+                                           name: f.node.ident.name,\n+                                           pat: lower_pat(_lctx, &f.node.pat),\n+                                           is_shorthand: f.node.is_shorthand,\n+                                       },\n+                                   }\n+                               })\n+                               .collect();\n                 hir::PatStruct(pth, fs, etc)\n             }\n             PatTup(ref elts) => hir::PatTup(elts.iter().map(|x| lower_pat(_lctx, x)).collect()),\n@@ -795,11 +841,11 @@ pub fn lower_pat(_lctx: &LoweringContext, p: &Pat) -> P<hir::Pat> {\n                                                           lower_mutability(_lctx, mutbl)),\n             PatRange(ref e1, ref e2) => {\n                 hir::PatRange(lower_expr(_lctx, e1), lower_expr(_lctx, e2))\n-            },\n+            }\n             PatVec(ref before, ref slice, ref after) => {\n                 hir::PatVec(before.iter().map(|x| lower_pat(_lctx, x)).collect(),\n-                       slice.as_ref().map(|x| lower_pat(_lctx, x)),\n-                       after.iter().map(|x| lower_pat(_lctx, x)).collect())\n+                            slice.as_ref().map(|x| lower_pat(_lctx, x)),\n+                            after.iter().map(|x| lower_pat(_lctx, x)).collect())\n             }\n             PatMac(_) => panic!(\"Shouldn't exist here\"),\n         },\n@@ -852,160 +898,161 @@ impl<'a> Drop for CachedIdSetter<'a> {\n \n pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n     P(hir::Expr {\n-            id: e.id,\n-            node: match e.node {\n-                // Issue #22181:\n-                // Eventually a desugaring for `box EXPR`\n-                // (similar to the desugaring above for `in PLACE BLOCK`)\n-                // should go here, desugaring\n-                //\n+        id: e.id,\n+        node: match e.node {\n+            // Issue #22181:\n+            // Eventually a desugaring for `box EXPR`\n+            // (similar to the desugaring above for `in PLACE BLOCK`)\n+            // should go here, desugaring\n+            //\n+            // to:\n+            //\n+            // let mut place = BoxPlace::make_place();\n+            // let raw_place = Place::pointer(&mut place);\n+            // let value = $value;\n+            // unsafe {\n+            //     ::std::ptr::write(raw_place, value);\n+            //     Boxed::finalize(place)\n+            // }\n+            //\n+            // But for now there are type-inference issues doing that.\n+            ExprBox(ref e) => {\n+                hir::ExprBox(lower_expr(lctx, e))\n+            }\n+\n+            // Desugar ExprBox: `in (PLACE) EXPR`\n+            ExprInPlace(ref placer, ref value_expr) => {\n                 // to:\n                 //\n-                // let mut place = BoxPlace::make_place();\n+                // let p = PLACE;\n+                // let mut place = Placer::make_place(p);\n                 // let raw_place = Place::pointer(&mut place);\n-                // let value = $value;\n-                // unsafe {\n-                //     ::std::ptr::write(raw_place, value);\n-                //     Boxed::finalize(place)\n-                // }\n-                //\n-                // But for now there are type-inference issues doing that.\n-                ExprBox(ref e) => {\n-                    hir::ExprBox(lower_expr(lctx, e))\n-                }\n-\n-                // Desugar ExprBox: `in (PLACE) EXPR`\n-                ExprInPlace(ref placer, ref value_expr) => {\n-                    // to:\n-                    //\n-                    // let p = PLACE;\n-                    // let mut place = Placer::make_place(p);\n-                    // let raw_place = Place::pointer(&mut place);\n-                    // push_unsafe!({\n-                    //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n-                    //     InPlace::finalize(place)\n-                    // })\n-                    let _old_cached = CachedIdSetter::new(lctx, e.id);\n-\n-                    let placer_expr = lower_expr(lctx, placer);\n-                    let value_expr = lower_expr(lctx, value_expr);\n-\n-                    let placer_ident = token::gensym_ident(\"placer\");\n-                    let agent_ident = token::gensym_ident(\"place\");\n-                    let p_ptr_ident = token::gensym_ident(\"p_ptr\");\n-\n-                    let make_place = [\"ops\", \"Placer\", \"make_place\"];\n-                    let place_pointer = [\"ops\", \"Place\", \"pointer\"];\n-                    let move_val_init = [\"intrinsics\", \"move_val_init\"];\n-                    let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n-\n-                    let make_call = |lctx, p, args| {\n-                        let path = core_path(lctx, e.span, p);\n-                        let path = expr_path(lctx, path);\n-                        expr_call(lctx, e.span, path, args)\n-                    };\n+                // push_unsafe!({\n+                //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n+                //     InPlace::finalize(place)\n+                // })\n+                let _old_cached = CachedIdSetter::new(lctx, e.id);\n+\n+                let placer_expr = lower_expr(lctx, placer);\n+                let value_expr = lower_expr(lctx, value_expr);\n+\n+                let placer_ident = token::gensym_ident(\"placer\");\n+                let agent_ident = token::gensym_ident(\"place\");\n+                let p_ptr_ident = token::gensym_ident(\"p_ptr\");\n+\n+                let make_place = [\"ops\", \"Placer\", \"make_place\"];\n+                let place_pointer = [\"ops\", \"Place\", \"pointer\"];\n+                let move_val_init = [\"intrinsics\", \"move_val_init\"];\n+                let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n+\n+                let make_call = |lctx, p, args| {\n+                    let path = core_path(lctx, e.span, p);\n+                    let path = expr_path(lctx, path);\n+                    expr_call(lctx, e.span, path, args)\n+                };\n \n-                    let mk_stmt_let = |lctx, bind, expr| {\n-                        stmt_let(lctx, e.span, false, bind, expr)\n-                    };\n-                    let mk_stmt_let_mut = |lctx, bind, expr| {\n-                        stmt_let(lctx, e.span, true, bind, expr)\n-                    };\n+                let mk_stmt_let = |lctx, bind, expr| stmt_let(lctx, e.span, false, bind, expr);\n+                let mk_stmt_let_mut = |lctx, bind, expr| stmt_let(lctx, e.span, true, bind, expr);\n \n-                    // let placer = <placer_expr> ;\n-                    let s1 = mk_stmt_let(lctx, placer_ident, placer_expr);\n+                // let placer = <placer_expr> ;\n+                let s1 = mk_stmt_let(lctx, placer_ident, placer_expr);\n \n-                    // let mut place = Placer::make_place(placer);\n-                    let s2 = {\n-                        let call = make_call(lctx, &make_place, vec![expr_ident(lctx, e.span, placer_ident)]);\n-                        mk_stmt_let_mut(lctx, agent_ident, call)\n-                    };\n+                // let mut place = Placer::make_place(placer);\n+                let s2 = {\n+                    let call = make_call(lctx,\n+                                         &make_place,\n+                                         vec![expr_ident(lctx, e.span, placer_ident)]);\n+                    mk_stmt_let_mut(lctx, agent_ident, call)\n+                };\n \n-                    // let p_ptr = Place::pointer(&mut place);\n-                    let s3 = {\n-                        let args = vec![expr_mut_addr_of(lctx, e.span, expr_ident(lctx, e.span, agent_ident))];\n-                        let call = make_call(lctx, &place_pointer, args);\n-                        mk_stmt_let(lctx, p_ptr_ident, call)\n-                    };\n+                // let p_ptr = Place::pointer(&mut place);\n+                let s3 = {\n+                    let args = vec![expr_mut_addr_of(lctx,\n+                                                     e.span,\n+                                                     expr_ident(lctx, e.span, agent_ident))];\n+                    let call = make_call(lctx, &place_pointer, args);\n+                    mk_stmt_let(lctx, p_ptr_ident, call)\n+                };\n \n-                    // pop_unsafe!(EXPR));\n-                    let pop_unsafe_expr =\n-                        signal_block_expr(lctx,\n-                                          vec![],\n-                                          signal_block_expr(lctx,\n-                                                            vec![],\n-                                                            value_expr,\n-                                                            e.span,\n-                                                            hir::PopUnstableBlock),\n-                                          e.span,\n-                                          hir::PopUnsafeBlock(hir::CompilerGenerated));\n-\n-                    // push_unsafe!({\n-                    //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n-                    //     InPlace::finalize(place)\n-                    // })\n-                    let expr = {\n-                        let call_move_val_init =\n-                            hir::StmtSemi(make_call(lctx,\n+                // pop_unsafe!(EXPR));\n+                let pop_unsafe_expr =\n+                    signal_block_expr(lctx,\n+                                      vec![],\n+                                      signal_block_expr(lctx,\n+                                                        vec![],\n+                                                        value_expr,\n+                                                        e.span,\n+                                                        hir::PopUnstableBlock),\n+                                      e.span,\n+                                      hir::PopUnsafeBlock(hir::CompilerGenerated));\n+\n+                // push_unsafe!({\n+                //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n+                //     InPlace::finalize(place)\n+                // })\n+                let expr = {\n+                    let call_move_val_init = hir::StmtSemi(make_call(lctx,\n                                                     &move_val_init,\n                                                     vec![expr_ident(lctx, e.span, p_ptr_ident),\n                                                          pop_unsafe_expr]),\n-                                          lctx.next_id());\n-                        let call_move_val_init = respan(e.span, call_move_val_init);\n-\n-                        let call = make_call(lctx, &inplace_finalize, vec![expr_ident(lctx, e.span, agent_ident)]);\n-                        signal_block_expr(lctx,\n-                                          vec![P(call_move_val_init)],\n-                                          call,\n-                                          e.span,\n-                                          hir::PushUnsafeBlock(hir::CompilerGenerated))\n-                    };\n+                                                           lctx.next_id());\n+                    let call_move_val_init = respan(e.span, call_move_val_init);\n+\n+                    let call = make_call(lctx,\n+                                         &inplace_finalize,\n+                                         vec![expr_ident(lctx, e.span, agent_ident)]);\n+                    signal_block_expr(lctx,\n+                                      vec![P(call_move_val_init)],\n+                                      call,\n+                                      e.span,\n+                                      hir::PushUnsafeBlock(hir::CompilerGenerated))\n+                };\n \n-                    return signal_block_expr(lctx,\n-                                             vec![s1, s2, s3],\n-                                             expr,\n-                                             e.span,\n-                                             hir::PushUnstableBlock);\n-                }\n-                \n-                ExprVec(ref exprs) => {\n-                    hir::ExprVec(exprs.iter().map(|x| lower_expr(lctx, x)).collect())\n-                }\n-                ExprRepeat(ref expr, ref count) => {\n-                    hir::ExprRepeat(lower_expr(lctx, expr), lower_expr(lctx, count))\n-                }\n-                ExprTup(ref elts) => {\n-                    hir::ExprTup(elts.iter().map(|x| lower_expr(lctx, x)).collect())\n-                }\n-                ExprCall(ref f, ref args) => {\n-                    hir::ExprCall(lower_expr(lctx, f),\n-                             args.iter().map(|x| lower_expr(lctx, x)).collect())\n-                }\n-                ExprMethodCall(i, ref tps, ref args) => {\n-                    hir::ExprMethodCall(\n-                        respan(i.span, i.node.name),\n-                        tps.iter().map(|x| lower_ty(lctx, x)).collect(),\n-                        args.iter().map(|x| lower_expr(lctx, x)).collect())\n-                }\n-                ExprBinary(binop, ref lhs, ref rhs) => {\n-                    hir::ExprBinary(lower_binop(lctx, binop),\n-                            lower_expr(lctx, lhs),\n-                            lower_expr(lctx, rhs))\n-                }\n-                ExprUnary(op, ref ohs) => {\n-                    hir::ExprUnary(lower_unop(lctx, op), lower_expr(lctx, ohs))\n-                }\n-                ExprLit(ref l) => hir::ExprLit(P((**l).clone())),\n-                ExprCast(ref expr, ref ty) => {\n-                    hir::ExprCast(lower_expr(lctx, expr), lower_ty(lctx, ty))\n-                }\n-                ExprAddrOf(m, ref ohs) => {\n-                    hir::ExprAddrOf(lower_mutability(lctx, m), lower_expr(lctx, ohs))\n-                }\n-                // More complicated than you might expect because the else branch\n-                // might be `if let`.\n-                ExprIf(ref cond, ref blk, ref else_opt) => {\n-                    let else_opt = else_opt.as_ref().map(|els| match els.node {\n+                return signal_block_expr(lctx,\n+                                         vec![s1, s2, s3],\n+                                         expr,\n+                                         e.span,\n+                                         hir::PushUnstableBlock);\n+            }\n+\n+            ExprVec(ref exprs) => {\n+                hir::ExprVec(exprs.iter().map(|x| lower_expr(lctx, x)).collect())\n+            }\n+            ExprRepeat(ref expr, ref count) => {\n+                hir::ExprRepeat(lower_expr(lctx, expr), lower_expr(lctx, count))\n+            }\n+            ExprTup(ref elts) => {\n+                hir::ExprTup(elts.iter().map(|x| lower_expr(lctx, x)).collect())\n+            }\n+            ExprCall(ref f, ref args) => {\n+                hir::ExprCall(lower_expr(lctx, f),\n+                              args.iter().map(|x| lower_expr(lctx, x)).collect())\n+            }\n+            ExprMethodCall(i, ref tps, ref args) => {\n+                hir::ExprMethodCall(respan(i.span, i.node.name),\n+                                    tps.iter().map(|x| lower_ty(lctx, x)).collect(),\n+                                    args.iter().map(|x| lower_expr(lctx, x)).collect())\n+            }\n+            ExprBinary(binop, ref lhs, ref rhs) => {\n+                hir::ExprBinary(lower_binop(lctx, binop),\n+                                lower_expr(lctx, lhs),\n+                                lower_expr(lctx, rhs))\n+            }\n+            ExprUnary(op, ref ohs) => {\n+                hir::ExprUnary(lower_unop(lctx, op), lower_expr(lctx, ohs))\n+            }\n+            ExprLit(ref l) => hir::ExprLit(P((**l).clone())),\n+            ExprCast(ref expr, ref ty) => {\n+                hir::ExprCast(lower_expr(lctx, expr), lower_ty(lctx, ty))\n+            }\n+            ExprAddrOf(m, ref ohs) => {\n+                hir::ExprAddrOf(lower_mutability(lctx, m), lower_expr(lctx, ohs))\n+            }\n+            // More complicated than you might expect because the else branch\n+            // might be `if let`.\n+            ExprIf(ref cond, ref blk, ref else_opt) => {\n+                let else_opt = else_opt.as_ref().map(|els| {\n+                    match els.node {\n                         ExprIfLet(..) => {\n                             let _old_cached = CachedIdSetter::new(lctx, e.id);\n                             // wrap the if-let expr in a block\n@@ -1015,71 +1062,72 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                 expr: Some(lower_expr(lctx, els)),\n                                 id: lctx.next_id(),\n                                 rules: hir::DefaultBlock,\n-                                span: span\n+                                span: span,\n                             });\n                             expr_block(lctx, blk)\n                         }\n-                        _ => lower_expr(lctx, els)\n-                    });\n+                        _ => lower_expr(lctx, els),\n+                    }\n+                });\n \n-                    hir::ExprIf(lower_expr(lctx, cond),\n-                                lower_block(lctx, blk),\n-                                else_opt)\n-                }\n-                ExprWhile(ref cond, ref body, opt_ident) => {\n-                    hir::ExprWhile(lower_expr(lctx, cond),\n-                              lower_block(lctx, body),\n-                              opt_ident)\n-                }\n-                ExprLoop(ref body, opt_ident) => {\n-                    hir::ExprLoop(lower_block(lctx, body),\n-                            opt_ident)\n-                }\n-                ExprMatch(ref expr, ref arms) => {\n-                    hir::ExprMatch(lower_expr(lctx, expr),\n-                            arms.iter().map(|x| lower_arm(lctx, x)).collect(),\n-                            hir::MatchSource::Normal)\n-                }\n-                ExprClosure(capture_clause, ref decl, ref body) => {\n-                    hir::ExprClosure(lower_capture_clause(lctx, capture_clause),\n-                                lower_fn_decl(lctx, decl),\n-                                lower_block(lctx, body))\n-                }\n-                ExprBlock(ref blk) => hir::ExprBlock(lower_block(lctx, blk)),\n-                ExprAssign(ref el, ref er) => {\n-                    hir::ExprAssign(lower_expr(lctx, el), lower_expr(lctx, er))\n-                }\n-                ExprAssignOp(op, ref el, ref er) => {\n-                    hir::ExprAssignOp(lower_binop(lctx, op),\n-                                lower_expr(lctx, el),\n-                                lower_expr(lctx, er))\n-                }\n-                ExprField(ref el, ident) => {\n-                    hir::ExprField(lower_expr(lctx, el), respan(ident.span, ident.node.name))\n-                }\n-                ExprTupField(ref el, ident) => {\n-                    hir::ExprTupField(lower_expr(lctx, el), ident)\n-                }\n-                ExprIndex(ref el, ref er) => {\n-                    hir::ExprIndex(lower_expr(lctx, el), lower_expr(lctx, er))\n-                }\n-                ExprRange(ref e1, ref e2) => {\n-                    hir::ExprRange(e1.as_ref().map(|x| lower_expr(lctx, x)),\n-                              e2.as_ref().map(|x| lower_expr(lctx, x)))\n-                }\n-                ExprPath(ref qself, ref path) => {\n-                    let qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n-                        hir::QSelf {\n-                            ty: lower_ty(lctx, ty),\n-                            position: position\n-                        }\n-                    });\n-                    hir::ExprPath(qself, lower_path(lctx, path))\n-                }\n-                ExprBreak(opt_ident) => hir::ExprBreak(opt_ident),\n-                ExprAgain(opt_ident) => hir::ExprAgain(opt_ident),\n-                ExprRet(ref e) => hir::ExprRet(e.as_ref().map(|x| lower_expr(lctx, x))),\n-                ExprInlineAsm(InlineAsm {\n+                hir::ExprIf(lower_expr(lctx, cond),\n+                            lower_block(lctx, blk),\n+                            else_opt)\n+            }\n+            ExprWhile(ref cond, ref body, opt_ident) => {\n+                hir::ExprWhile(lower_expr(lctx, cond),\n+                               lower_block(lctx, body),\n+                               opt_ident)\n+            }\n+            ExprLoop(ref body, opt_ident) => {\n+                hir::ExprLoop(lower_block(lctx, body), opt_ident)\n+            }\n+            ExprMatch(ref expr, ref arms) => {\n+                hir::ExprMatch(lower_expr(lctx, expr),\n+                               arms.iter().map(|x| lower_arm(lctx, x)).collect(),\n+                               hir::MatchSource::Normal)\n+            }\n+            ExprClosure(capture_clause, ref decl, ref body) => {\n+                hir::ExprClosure(lower_capture_clause(lctx, capture_clause),\n+                                 lower_fn_decl(lctx, decl),\n+                                 lower_block(lctx, body))\n+            }\n+            ExprBlock(ref blk) => hir::ExprBlock(lower_block(lctx, blk)),\n+            ExprAssign(ref el, ref er) => {\n+                hir::ExprAssign(lower_expr(lctx, el), lower_expr(lctx, er))\n+            }\n+            ExprAssignOp(op, ref el, ref er) => {\n+                hir::ExprAssignOp(lower_binop(lctx, op),\n+                                  lower_expr(lctx, el),\n+                                  lower_expr(lctx, er))\n+            }\n+            ExprField(ref el, ident) => {\n+                hir::ExprField(lower_expr(lctx, el),\n+                               respan(ident.span, ident.node.name))\n+            }\n+            ExprTupField(ref el, ident) => {\n+                hir::ExprTupField(lower_expr(lctx, el), ident)\n+            }\n+            ExprIndex(ref el, ref er) => {\n+                hir::ExprIndex(lower_expr(lctx, el), lower_expr(lctx, er))\n+            }\n+            ExprRange(ref e1, ref e2) => {\n+                hir::ExprRange(e1.as_ref().map(|x| lower_expr(lctx, x)),\n+                               e2.as_ref().map(|x| lower_expr(lctx, x)))\n+            }\n+            ExprPath(ref qself, ref path) => {\n+                let qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n+                    hir::QSelf {\n+                        ty: lower_ty(lctx, ty),\n+                        position: position,\n+                    }\n+                });\n+                hir::ExprPath(qself, lower_path(lctx, path))\n+            }\n+            ExprBreak(opt_ident) => hir::ExprBreak(opt_ident),\n+            ExprAgain(opt_ident) => hir::ExprAgain(opt_ident),\n+            ExprRet(ref e) => hir::ExprRet(e.as_ref().map(|x| lower_expr(lctx, x))),\n+            ExprInlineAsm(InlineAsm {\n                     ref inputs,\n                     ref outputs,\n                     ref asm,\n@@ -1090,271 +1138,289 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     dialect,\n                     expn_id,\n                 }) => hir::ExprInlineAsm(hir::InlineAsm {\n-                    inputs: inputs.iter().map(|&(ref c, ref input)| {\n-                        (c.clone(), lower_expr(lctx, input))\n-                    }).collect(),\n-                    outputs: outputs.iter().map(|&(ref c, ref out, ref is_rw)| {\n-                        (c.clone(), lower_expr(lctx, out), *is_rw)\n-                    }).collect(),\n-                    asm: asm.clone(),\n-                    asm_str_style: asm_str_style,\n-                    clobbers: clobbers.clone(),\n-                    volatile: volatile,\n-                    alignstack: alignstack,\n-                    dialect: dialect,\n-                    expn_id: expn_id,\n-                }),\n-                ExprStruct(ref path, ref fields, ref maybe_expr) => {\n-                    hir::ExprStruct(lower_path(lctx, path),\n-                            fields.iter().map(|x| lower_field(lctx, x)).collect(),\n-                            maybe_expr.as_ref().map(|x| lower_expr(lctx, x)))\n-                },\n-                ExprParen(ref ex) => {\n-                    return lower_expr(lctx, ex);\n-                }\n+                inputs: inputs.iter()\n+                              .map(|&(ref c, ref input)| (c.clone(), lower_expr(lctx, input)))\n+                              .collect(),\n+                outputs: outputs.iter()\n+                                .map(|&(ref c, ref out, ref is_rw)| {\n+                                    (c.clone(), lower_expr(lctx, out), *is_rw)\n+                                })\n+                                .collect(),\n+                asm: asm.clone(),\n+                asm_str_style: asm_str_style,\n+                clobbers: clobbers.clone(),\n+                volatile: volatile,\n+                alignstack: alignstack,\n+                dialect: dialect,\n+                expn_id: expn_id,\n+            }),\n+            ExprStruct(ref path, ref fields, ref maybe_expr) => {\n+                hir::ExprStruct(lower_path(lctx, path),\n+                                fields.iter().map(|x| lower_field(lctx, x)).collect(),\n+                                maybe_expr.as_ref().map(|x| lower_expr(lctx, x)))\n+            }\n+            ExprParen(ref ex) => {\n+                return lower_expr(lctx, ex);\n+            }\n \n-                // Desugar ExprIfLet\n-                // From: `if let <pat> = <sub_expr> <body> [<else_opt>]`\n-                ExprIfLet(ref pat, ref sub_expr, ref body, ref else_opt) => {\n-                    // to:\n-                    //\n-                    //   match <sub_expr> {\n-                    //     <pat> => <body>,\n-                    //     [_ if <else_opt_if_cond> => <else_opt_if_body>,]\n-                    //     _ => [<else_opt> | ()]\n-                    //   }\n-                \n-                    let _old_cached = CachedIdSetter::new(lctx, e.id);\n-\n-                    // `<pat> => <body>`\n-                    let pat_arm = {\n-                        let body_expr = expr_block(lctx, lower_block(lctx, body));\n-                        arm(vec![lower_pat(lctx, pat)], body_expr)\n-                    };\n+            // Desugar ExprIfLet\n+            // From: `if let <pat> = <sub_expr> <body> [<else_opt>]`\n+            ExprIfLet(ref pat, ref sub_expr, ref body, ref else_opt) => {\n+                // to:\n+                //\n+                //   match <sub_expr> {\n+                //     <pat> => <body>,\n+                //     [_ if <else_opt_if_cond> => <else_opt_if_body>,]\n+                //     _ => [<else_opt> | ()]\n+                //   }\n+\n+                let _old_cached = CachedIdSetter::new(lctx, e.id);\n+\n+                // `<pat> => <body>`\n+                let pat_arm = {\n+                    let body_expr = expr_block(lctx, lower_block(lctx, body));\n+                    arm(vec![lower_pat(lctx, pat)], body_expr)\n+                };\n \n-                    // `[_ if <else_opt_if_cond> => <else_opt_if_body>,]`\n-                    let mut else_opt = else_opt.as_ref().map(|e| lower_expr(lctx, e));\n-                    let else_if_arms = {\n-                        let mut arms = vec![];\n-                        loop {\n-                            let else_opt_continue = else_opt\n-                                .and_then(|els| els.and_then(|els| match els.node {\n-                                // else if\n-                                hir::ExprIf(cond, then, else_opt) => {\n-                                    let pat_under = pat_wild(lctx, e.span);\n-                                    arms.push(hir::Arm {\n-                                        attrs: vec![],\n-                                        pats: vec![pat_under],\n-                                        guard: Some(cond),\n-                                        body: expr_block(lctx, then)\n-                                    });\n-                                    else_opt.map(|else_opt| (else_opt, true))\n-                                }\n-                                _ => Some((P(els), false))\n-                            }));\n-                            match else_opt_continue {\n-                                Some((e, true)) => {\n-                                    else_opt = Some(e);\n-                                }\n-                                Some((e, false)) => {\n-                                    else_opt = Some(e);\n-                                    break;\n-                                }\n-                                None => {\n-                                    else_opt = None;\n-                                    break;\n+                // `[_ if <else_opt_if_cond> => <else_opt_if_body>,]`\n+                let mut else_opt = else_opt.as_ref().map(|e| lower_expr(lctx, e));\n+                let else_if_arms = {\n+                    let mut arms = vec![];\n+                    loop {\n+                        let else_opt_continue = else_opt.and_then(|els| {\n+                            els.and_then(|els| {\n+                                match els.node {\n+                                    // else if\n+                                    hir::ExprIf(cond, then, else_opt) => {\n+                                        let pat_under = pat_wild(lctx, e.span);\n+                                        arms.push(hir::Arm {\n+                                            attrs: vec![],\n+                                            pats: vec![pat_under],\n+                                            guard: Some(cond),\n+                                            body: expr_block(lctx, then),\n+                                        });\n+                                        else_opt.map(|else_opt| (else_opt, true))\n+                                    }\n+                                    _ => Some((P(els), false)),\n                                 }\n+                            })\n+                        });\n+                        match else_opt_continue {\n+                            Some((e, true)) => {\n+                                else_opt = Some(e);\n+                            }\n+                            Some((e, false)) => {\n+                                else_opt = Some(e);\n+                                break;\n+                            }\n+                            None => {\n+                                else_opt = None;\n+                                break;\n                             }\n                         }\n-                        arms\n-                    };\n+                    }\n+                    arms\n+                };\n \n-                    let contains_else_clause = else_opt.is_some();\n+                let contains_else_clause = else_opt.is_some();\n \n-                    // `_ => [<else_opt> | ()]`\n-                    let else_arm = {\n-                        let pat_under = pat_wild(lctx, e.span);\n-                        let else_expr = else_opt.unwrap_or_else(|| expr_tuple(lctx, e.span, vec![]));\n-                        arm(vec![pat_under], else_expr)\n-                    };\n+                // `_ => [<else_opt> | ()]`\n+                let else_arm = {\n+                    let pat_under = pat_wild(lctx, e.span);\n+                    let else_expr = else_opt.unwrap_or_else(|| expr_tuple(lctx, e.span, vec![]));\n+                    arm(vec![pat_under], else_expr)\n+                };\n \n-                    let mut arms = Vec::with_capacity(else_if_arms.len() + 2);\n-                    arms.push(pat_arm);\n-                    arms.extend(else_if_arms);\n-                    arms.push(else_arm);\n-\n-                    let match_expr = expr(lctx,\n-                                          e.span,\n-                                          hir::ExprMatch(lower_expr(lctx, sub_expr), arms,\n-                                                 hir::MatchSource::IfLetDesugar {\n-                                                     contains_else_clause: contains_else_clause,\n-                                                 }));\n-                    return match_expr;\n-                }\n+                let mut arms = Vec::with_capacity(else_if_arms.len() + 2);\n+                arms.push(pat_arm);\n+                arms.extend(else_if_arms);\n+                arms.push(else_arm);\n+\n+                let match_expr = expr(lctx,\n+                                      e.span,\n+                                      hir::ExprMatch(lower_expr(lctx, sub_expr),\n+                                                     arms,\n+                                                     hir::MatchSource::IfLetDesugar {\n+                                                         contains_else_clause: contains_else_clause,\n+                                                     }));\n+                return match_expr;\n+            }\n \n-                // Desugar ExprWhileLet\n-                // From: `[opt_ident]: while let <pat> = <sub_expr> <body>`\n-                ExprWhileLet(ref pat, ref sub_expr, ref body, opt_ident) => {\n-                    // to:\n-                    //\n-                    //   [opt_ident]: loop {\n-                    //     match <sub_expr> {\n-                    //       <pat> => <body>,\n-                    //       _ => break\n-                    //     }\n-                    //   }\n-\n-                    let _old_cached = CachedIdSetter::new(lctx, e.id);\n-\n-                    // `<pat> => <body>`\n-                    let pat_arm = {\n-                        let body_expr = expr_block(lctx, lower_block(lctx, body));\n-                        arm(vec![lower_pat(lctx, pat)], body_expr)\n-                    };\n+            // Desugar ExprWhileLet\n+            // From: `[opt_ident]: while let <pat> = <sub_expr> <body>`\n+            ExprWhileLet(ref pat, ref sub_expr, ref body, opt_ident) => {\n+                // to:\n+                //\n+                //   [opt_ident]: loop {\n+                //     match <sub_expr> {\n+                //       <pat> => <body>,\n+                //       _ => break\n+                //     }\n+                //   }\n+\n+                let _old_cached = CachedIdSetter::new(lctx, e.id);\n+\n+                // `<pat> => <body>`\n+                let pat_arm = {\n+                    let body_expr = expr_block(lctx, lower_block(lctx, body));\n+                    arm(vec![lower_pat(lctx, pat)], body_expr)\n+                };\n \n-                    // `_ => break`\n-                    let break_arm = {\n-                        let pat_under = pat_wild(lctx, e.span);\n-                        let break_expr = expr_break(lctx, e.span);\n-                        arm(vec![pat_under], break_expr)\n-                    };\n+                // `_ => break`\n+                let break_arm = {\n+                    let pat_under = pat_wild(lctx, e.span);\n+                    let break_expr = expr_break(lctx, e.span);\n+                    arm(vec![pat_under], break_expr)\n+                };\n \n-                    // // `match <sub_expr> { ... }`\n-                    let arms = vec![pat_arm, break_arm];\n-                    let match_expr = expr(lctx,\n-                                          e.span,\n-                                          hir::ExprMatch(lower_expr(lctx, sub_expr), arms, hir::MatchSource::WhileLetDesugar));\n+                // `match <sub_expr> { ... }`\n+                let arms = vec![pat_arm, break_arm];\n+                let match_expr = expr(lctx,\n+                                      e.span,\n+                                      hir::ExprMatch(lower_expr(lctx, sub_expr),\n+                                                     arms,\n+                                                     hir::MatchSource::WhileLetDesugar));\n+\n+                // `[opt_ident]: loop { ... }`\n+                let loop_block = block_expr(lctx, match_expr);\n+                return expr(lctx, e.span, hir::ExprLoop(loop_block, opt_ident));\n+            }\n \n-                    // `[opt_ident]: loop { ... }`\n-                    let loop_block = block_expr(lctx, match_expr);\n-                    return expr(lctx, e.span, hir::ExprLoop(loop_block, opt_ident));\n-                }\n+            // Desugar ExprForLoop\n+            // From: `[opt_ident]: for <pat> in <head> <body>`\n+            ExprForLoop(ref pat, ref head, ref body, opt_ident) => {\n+                // to:\n+                //\n+                //   {\n+                //     let result = match ::std::iter::IntoIterator::into_iter(<head>) {\n+                //       mut iter => {\n+                //         [opt_ident]: loop {\n+                //           match ::std::iter::Iterator::next(&mut iter) {\n+                //             ::std::option::Option::Some(<pat>) => <body>,\n+                //             ::std::option::Option::None => break\n+                //           }\n+                //         }\n+                //       }\n+                //     };\n+                //     result\n+                //   }\n+\n+                let _old_cached = CachedIdSetter::new(lctx, e.id);\n+\n+                // expand <head>\n+                let head = lower_expr(lctx, head);\n+\n+                let iter = token::gensym_ident(\"iter\");\n+\n+                // `::std::option::Option::Some(<pat>) => <body>`\n+                let pat_arm = {\n+                    let body_block = lower_block(lctx, body);\n+                    let body_span = body_block.span;\n+                    let body_expr = P(hir::Expr {\n+                        id: lctx.next_id(),\n+                        node: hir::ExprBlock(body_block),\n+                        span: body_span,\n+                    });\n+                    let pat = lower_pat(lctx, pat);\n+                    let some_pat = pat_some(lctx, e.span, pat);\n \n-                // Desugar ExprForLoop\n-                // From: `[opt_ident]: for <pat> in <head> <body>`\n-                ExprForLoop(ref pat, ref head, ref body, opt_ident) => {\n-                    // to:\n-                    //\n-                    //   {\n-                    //     let result = match ::std::iter::IntoIterator::into_iter(<head>) {\n-                    //       mut iter => {\n-                    //         [opt_ident]: loop {\n-                    //           match ::std::iter::Iterator::next(&mut iter) {\n-                    //             ::std::option::Option::Some(<pat>) => <body>,\n-                    //             ::std::option::Option::None => break\n-                    //           }\n-                    //         }\n-                    //       }\n-                    //     };\n-                    //     result\n-                    //   }\n-\n-                    let _old_cached = CachedIdSetter::new(lctx, e.id);\n-\n-                    // expand <head>\n-                    let head = lower_expr(lctx, head);\n-\n-                    let iter = token::gensym_ident(\"iter\");\n-\n-                    // `::std::option::Option::Some(<pat>) => <body>`\n-                    let pat_arm = {\n-                        let body_block = lower_block(lctx, body);\n-                        let body_span = body_block.span;\n-                        let body_expr = P(hir::Expr {\n-                            id: lctx.next_id(),\n-                            node: hir::ExprBlock(body_block),\n-                            span: body_span,\n-                        });\n-                        let pat = lower_pat(lctx, pat);\n-                        let some_pat = pat_some(lctx, e.span, pat);\n+                    arm(vec![some_pat], body_expr)\n+                };\n \n-                        arm(vec![some_pat], body_expr)\n-                    };\n+                // `::std::option::Option::None => break`\n+                let break_arm = {\n+                    let break_expr = expr_break(lctx, e.span);\n \n-                    // `::std::option::Option::None => break`\n-                    let break_arm = {\n-                        let break_expr = expr_break(lctx, e.span);\n+                    arm(vec![pat_none(lctx, e.span)], break_expr)\n+                };\n \n-                        arm(vec![pat_none(lctx, e.span)], break_expr)\n-                    };\n+                // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n+                let match_expr = {\n+                    let next_path = {\n+                        let strs = std_path(lctx, &[\"iter\", \"Iterator\", \"next\"]);\n \n-                    // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n-                    let match_expr = {\n-                        let next_path = {\n-                            let strs = std_path(lctx, &[\"iter\", \"Iterator\", \"next\"]);\n-\n-                            path_global(e.span, strs)\n-                        };\n-                        let ref_mut_iter = expr_mut_addr_of(lctx, e.span, expr_ident(lctx, e.span, iter));\n-                        let next_expr =\n-                            expr_call(lctx, e.span, expr_path(lctx, next_path), vec![ref_mut_iter]);\n-                        let arms = vec![pat_arm, break_arm];\n-\n-                        expr(lctx,\n-                             e.span,\n-                             hir::ExprMatch(next_expr, arms, hir::MatchSource::ForLoopDesugar))\n+                        path_global(e.span, strs)\n                     };\n+                    let ref_mut_iter = expr_mut_addr_of(lctx,\n+                                                        e.span,\n+                                                        expr_ident(lctx, e.span, iter));\n+                    let next_expr = expr_call(lctx,\n+                                              e.span,\n+                                              expr_path(lctx, next_path),\n+                                              vec![ref_mut_iter]);\n+                    let arms = vec![pat_arm, break_arm];\n \n-                    // `[opt_ident]: loop { ... }`\n-                    let loop_block = block_expr(lctx, match_expr);\n-                    let loop_expr = expr(lctx, e.span, hir::ExprLoop(loop_block, opt_ident));\n-\n-                    // `mut iter => { ... }`\n-                    let iter_arm = {\n-                        let iter_pat =\n-                            pat_ident_binding_mode(lctx, e.span, iter, hir::BindByValue(hir::MutMutable));\n-                        arm(vec![iter_pat], loop_expr)\n-                    };\n+                    expr(lctx,\n+                         e.span,\n+                         hir::ExprMatch(next_expr, arms, hir::MatchSource::ForLoopDesugar))\n+                };\n \n-                    // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n-                    let into_iter_expr = {\n-                        let into_iter_path = {\n-                            let strs = std_path(lctx, &[\"iter\", \"IntoIterator\", \"into_iter\"]);\n+                // `[opt_ident]: loop { ... }`\n+                let loop_block = block_expr(lctx, match_expr);\n+                let loop_expr = expr(lctx, e.span, hir::ExprLoop(loop_block, opt_ident));\n+\n+                // `mut iter => { ... }`\n+                let iter_arm = {\n+                    let iter_pat = pat_ident_binding_mode(lctx,\n+                                                          e.span,\n+                                                          iter,\n+                                                          hir::BindByValue(hir::MutMutable));\n+                    arm(vec![iter_pat], loop_expr)\n+                };\n \n-                            path_global(e.span, strs)\n-                        };\n+                // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n+                let into_iter_expr = {\n+                    let into_iter_path = {\n+                        let strs = std_path(lctx, &[\"iter\", \"IntoIterator\", \"into_iter\"]);\n \n-                        expr_call(lctx, e.span, expr_path(lctx, into_iter_path), vec![head])\n+                        path_global(e.span, strs)\n                     };\n \n-                    let match_expr = expr_match(lctx, e.span, into_iter_expr, vec![iter_arm]);\n-\n-                    // `{ let result = ...; result }`\n-                    let result_ident = token::gensym_ident(\"result\");\n-                    return expr_block(lctx,\n-                                      block_all(lctx,\n-                                                e.span,\n-                                                vec![stmt_let(lctx, e.span,\n-                                                              false,\n-                                                              result_ident,\n-                                                              match_expr)],\n-                                                Some(expr_ident(lctx, e.span, result_ident))))\n-                }\n+                    expr_call(lctx,\n+                              e.span,\n+                              expr_path(lctx, into_iter_path),\n+                              vec![head])\n+                };\n \n-                ExprMac(_) => panic!(\"Shouldn't exist here\"),\n-            },\n-            span: e.span,\n-        })\n+                let match_expr = expr_match(lctx, e.span, into_iter_expr, vec![iter_arm]);\n+\n+                // `{ let result = ...; result }`\n+                let result_ident = token::gensym_ident(\"result\");\n+                return expr_block(lctx,\n+                                  block_all(lctx,\n+                                            e.span,\n+                                            vec![stmt_let(lctx,\n+                                                          e.span,\n+                                                          false,\n+                                                          result_ident,\n+                                                          match_expr)],\n+                                            Some(expr_ident(lctx, e.span, result_ident))))\n+            }\n+\n+            ExprMac(_) => panic!(\"Shouldn't exist here\"),\n+        },\n+        span: e.span,\n+    })\n }\n \n pub fn lower_stmt(_lctx: &LoweringContext, s: &Stmt) -> P<hir::Stmt> {\n     match s.node {\n         StmtDecl(ref d, id) => {\n             P(Spanned {\n                 node: hir::StmtDecl(lower_decl(_lctx, d), id),\n-                span: s.span\n+                span: s.span,\n             })\n         }\n         StmtExpr(ref e, id) => {\n             P(Spanned {\n                 node: hir::StmtExpr(lower_expr(_lctx, e), id),\n-                span: s.span\n+                span: s.span,\n             })\n         }\n         StmtSemi(ref e, id) => {\n             P(Spanned {\n                 node: hir::StmtSemi(lower_expr(_lctx, e), id),\n-                span: s.span\n+                span: s.span,\n             })\n         }\n         StmtMac(..) => panic!(\"Shouldn't exist here\"),\n@@ -1437,15 +1503,19 @@ fn arm(pats: Vec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n         attrs: vec!(),\n         pats: pats,\n         guard: None,\n-        body: expr\n+        body: expr,\n     }\n }\n \n fn expr_break(lctx: &LoweringContext, span: Span) -> P<hir::Expr> {\n     expr(lctx, span, hir::ExprBreak(None))\n }\n \n-fn expr_call(lctx: &LoweringContext, span: Span, e: P<hir::Expr>, args: Vec<P<hir::Expr>>) -> P<hir::Expr> {\n+fn expr_call(lctx: &LoweringContext,\n+             span: Span,\n+             e: P<hir::Expr>,\n+             args: Vec<P<hir::Expr>>)\n+             -> P<hir::Expr> {\n     expr(lctx, span, hir::ExprCall(e, args))\n }\n \n@@ -1461,8 +1531,14 @@ fn expr_path(lctx: &LoweringContext, path: hir::Path) -> P<hir::Expr> {\n     expr(lctx, path.span, hir::ExprPath(None, path))\n }\n \n-fn expr_match(lctx: &LoweringContext, span: Span, arg: P<hir::Expr>, arms: Vec<hir::Arm>) -> P<hir::Expr> {\n-    expr(lctx, span, hir::ExprMatch(arg, arms, hir::MatchSource::Normal))\n+fn expr_match(lctx: &LoweringContext,\n+              span: Span,\n+              arg: P<hir::Expr>,\n+              arms: Vec<hir::Arm>)\n+              -> P<hir::Expr> {\n+    expr(lctx,\n+         span,\n+         hir::ExprMatch(arg, arms, hir::MatchSource::Normal))\n }\n \n fn expr_block(lctx: &LoweringContext, b: P<hir::Block>) -> P<hir::Expr> {\n@@ -1481,7 +1557,12 @@ fn expr(lctx: &LoweringContext, span: Span, node: hir::Expr_) -> P<hir::Expr> {\n     })\n }\n \n-fn stmt_let(lctx: &LoweringContext, sp: Span, mutbl: bool, ident: Ident, ex: P<hir::Expr>) -> P<hir::Stmt> {\n+fn stmt_let(lctx: &LoweringContext,\n+            sp: Span,\n+            mutbl: bool,\n+            ident: Ident,\n+            ex: P<hir::Expr>)\n+            -> P<hir::Stmt> {\n     let pat = if mutbl {\n         pat_ident_binding_mode(lctx, sp, ident, hir::BindByValue(hir::MutMutable))\n     } else {\n@@ -1505,14 +1586,15 @@ fn block_expr(lctx: &LoweringContext, expr: P<hir::Expr>) -> P<hir::Block> {\n fn block_all(lctx: &LoweringContext,\n              span: Span,\n              stmts: Vec<P<hir::Stmt>>,\n-             expr: Option<P<hir::Expr>>) -> P<hir::Block> {\n-        P(hir::Block {\n-            stmts: stmts,\n-            expr: expr,\n-            id: lctx.next_id(),\n-            rules: hir::DefaultBlock,\n-            span: span,\n-        })\n+             expr: Option<P<hir::Expr>>)\n+             -> P<hir::Block> {\n+    P(hir::Block {\n+        stmts: stmts,\n+        expr: expr,\n+        id: lctx.next_id(),\n+        rules: hir::DefaultBlock,\n+        span: span,\n+    })\n }\n \n fn pat_some(lctx: &LoweringContext, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n@@ -1527,7 +1609,11 @@ fn pat_none(lctx: &LoweringContext, span: Span) -> P<hir::Pat> {\n     pat_enum(lctx, span, path, vec![])\n }\n \n-fn pat_enum(lctx: &LoweringContext, span: Span, path: hir::Path, subpats: Vec<P<hir::Pat>>) -> P<hir::Pat> {\n+fn pat_enum(lctx: &LoweringContext,\n+            span: Span,\n+            path: hir::Path,\n+            subpats: Vec<P<hir::Pat>>)\n+            -> P<hir::Pat> {\n     let pt = hir::PatEnum(path, Some(subpats));\n     pat(lctx, span, pt)\n }\n@@ -1539,8 +1625,14 @@ fn pat_ident(lctx: &LoweringContext, span: Span, ident: Ident) -> P<hir::Pat> {\n fn pat_ident_binding_mode(lctx: &LoweringContext,\n                           span: Span,\n                           ident: Ident,\n-                          bm: hir::BindingMode) -> P<hir::Pat> {\n-    let pat_ident = hir::PatIdent(bm, Spanned{span: span, node: ident}, None);\n+                          bm: hir::BindingMode)\n+                          -> P<hir::Pat> {\n+    let pat_ident = hir::PatIdent(bm,\n+                                  Spanned {\n+                                      span: span,\n+                                      node: ident,\n+                                  },\n+                                  None);\n     pat(lctx, span, pat_ident)\n }\n \n@@ -1549,43 +1641,48 @@ fn pat_wild(lctx: &LoweringContext, span: Span) -> P<hir::Pat> {\n }\n \n fn pat(lctx: &LoweringContext, span: Span, pat: hir::Pat_) -> P<hir::Pat> {\n-    P(hir::Pat { id: lctx.next_id(), node: pat, span: span })\n+    P(hir::Pat {\n+        id: lctx.next_id(),\n+        node: pat,\n+        span: span,\n+    })\n }\n \n fn path_ident(span: Span, id: Ident) -> hir::Path {\n     path(span, vec!(id))\n }\n \n-fn path(span: Span, strs: Vec<Ident> ) -> hir::Path {\n+fn path(span: Span, strs: Vec<Ident>) -> hir::Path {\n     path_all(span, false, strs, Vec::new(), Vec::new(), Vec::new())\n }\n \n-fn path_global(span: Span, strs: Vec<Ident> ) -> hir::Path {\n+fn path_global(span: Span, strs: Vec<Ident>) -> hir::Path {\n     path_all(span, true, strs, Vec::new(), Vec::new(), Vec::new())\n }\n \n fn path_all(sp: Span,\n             global: bool,\n-            mut idents: Vec<Ident> ,\n+            mut idents: Vec<Ident>,\n             lifetimes: Vec<hir::Lifetime>,\n             types: Vec<P<hir::Ty>>,\n-            bindings: Vec<P<hir::TypeBinding>> )\n+            bindings: Vec<P<hir::TypeBinding>>)\n             -> hir::Path {\n     let last_identifier = idents.pop().unwrap();\n     let mut segments: Vec<hir::PathSegment> = idents.into_iter()\n                                                     .map(|ident| {\n-        hir::PathSegment {\n-            identifier: ident,\n-            parameters: hir::PathParameters::none(),\n-        }\n-    }).collect();\n+                                                        hir::PathSegment {\n+                                                            identifier: ident,\n+                                                            parameters: hir::PathParameters::none(),\n+                                                        }\n+                                                    })\n+                                                    .collect();\n     segments.push(hir::PathSegment {\n         identifier: last_identifier,\n         parameters: hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n             lifetimes: lifetimes,\n             types: OwnedSlice::from_vec(types),\n             bindings: OwnedSlice::from_vec(bindings),\n-        })\n+        }),\n     });\n     hir::Path {\n         span: sp,\n@@ -1610,9 +1707,18 @@ fn core_path(lctx: &LoweringContext, span: Span, components: &[&str]) -> hir::Pa\n     path_global(span, idents)\n }\n \n-fn signal_block_expr(lctx: &LoweringContext, stmts: Vec<P<hir::Stmt>>, expr: P<hir::Expr>, span: Span, rule: hir::BlockCheckMode) -> P<hir::Expr> {\n-    expr_block(lctx, P(hir::Block {\n-        rules: rule, span: span, id: lctx.next_id(),\n-        stmts: stmts, expr: Some(expr),\n-    }))\n+fn signal_block_expr(lctx: &LoweringContext,\n+                     stmts: Vec<P<hir::Stmt>>,\n+                     expr: P<hir::Expr>,\n+                     span: Span,\n+                     rule: hir::BlockCheckMode)\n+                     -> P<hir::Expr> {\n+    expr_block(lctx,\n+               P(hir::Block {\n+                   rules: rule,\n+                   span: span,\n+                   id: lctx.next_id(),\n+                   stmts: stmts,\n+                   expr: Some(expr),\n+               }))\n }"}]}