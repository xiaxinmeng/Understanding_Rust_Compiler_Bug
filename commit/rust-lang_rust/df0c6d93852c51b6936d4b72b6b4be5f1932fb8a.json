{"sha": "df0c6d93852c51b6936d4b72b6b4be5f1932fb8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmMGM2ZDkzODUyYzUxYjY5MzZkNGI3MmI2YjRiZTVmMTkzMmZiOGE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-11-23T09:29:41Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-12-26T20:55:25Z"}, "message": "save-analysis: emit names of items that a glob import actually imports.\n\nThere is also some work here to make resolve a bit more stable - it no longer overwrites a specific import with a glob import.\n\n[breaking-change]\n\nImport shadowing of single/list imports by globs is now forbidden. An interesting case is where a glob import imports a re-export (`pub use`) of a single import. This still counts as a single import for the purposes of shadowing .You can usually fix any bustage by re-ordering such imports. A single import may still shadow (override) a glob import or the prelude.", "tree": {"sha": "3bf587ea195de3cbe01ddbcfe33cd81b61c82727", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bf587ea195de3cbe01ddbcfe33cd81b61c82727"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a", "html_url": "https://github.com/rust-lang/rust/commit/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd3cf4c05fdec03ab22df27f33191f4851e18cc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd3cf4c05fdec03ab22df27f33191f4851e18cc9", "html_url": "https://github.com/rust-lang/rust/commit/bd3cf4c05fdec03ab22df27f33191f4851e18cc9"}], "stats": {"total": 333, "additions": 270, "deletions": 63}, "files": [{"sha": "51cebbfb52c58ca80262f8d7f34e3e39f7812254", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=df0c6d93852c51b6936d4b72b6b4be5f1932fb8a", "patch": "@@ -146,6 +146,13 @@ pub fn get_impl_or_trait_item<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId)\n                                     tcx)\n }\n \n+pub fn get_trait_name(cstore: &cstore::CStore, def: ast::DefId) -> ast::Name {\n+    let cdata = cstore.get_crate_data(def.krate);\n+    decoder::get_trait_name(cstore.intr.clone(),\n+                            &*cdata,\n+                            def.node)\n+}\n+\n pub fn get_trait_item_name_and_kind(cstore: &cstore::CStore, def: ast::DefId)\n                                     -> (ast::Name, def::TraitItemKind) {\n     let cdata = cstore.get_crate_data(def.krate);"}, {"sha": "ee928828827b7ab1935698d5fd933168adc1edd0", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=df0c6d93852c51b6936d4b72b6b4be5f1932fb8a", "patch": "@@ -781,6 +781,14 @@ pub fn get_impl_items(cdata: Cmd, impl_id: ast::NodeId)\n     impl_items\n }\n \n+pub fn get_trait_name(intr: Rc<IdentInterner>,\n+                      cdata: Cmd,\n+                      id: ast::NodeId)\n+                      -> ast::Name {\n+    let doc = lookup_item(id, cdata.data());\n+    item_name(&*intr, doc)\n+}\n+\n pub fn get_trait_item_name_and_kind(intr: Rc<IdentInterner>,\n                                     cdata: Cmd,\n                                     id: ast::NodeId)"}, {"sha": "79e24ad56e467aeccdb51601302d6f9a35153aa1", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=df0c6d93852c51b6936d4b72b6b4be5f1932fb8a", "patch": "@@ -105,6 +105,7 @@ pub struct CrateAnalysis<'tcx> {\n     pub ty_cx: ty::ctxt<'tcx>,\n     pub reachable: NodeSet,\n     pub name: String,\n+    pub glob_map: Option<middle::resolve::GlobMap>,\n }\n \n #[deriving(Copy, PartialEq, Eq, Hash)]"}, {"sha": "c727bea4c2c4f71884a8a0f225665b4923410d1f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=df0c6d93852c51b6936d4b72b6b4be5f1932fb8a", "patch": "@@ -342,17 +342,24 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     let lang_items = time(time_passes, \"language item collection\", (), |_|\n                           middle::lang_items::collect_language_items(krate, &sess));\n \n-    let resolve::CrateMap {\n+    let make_glob_map = match save_analysis(&sess) {\n+        true => middle::resolve::MakeGlobMap::Yes,\n+        false => middle::resolve::MakeGlobMap::No,\n+    };\n         def_map,\n         freevars,\n         capture_mode_map,\n         export_map,\n         trait_map,\n         external_exports,\n-        last_private_map\n+        last_private_map,\n+        glob_map,\n     } =\n         time(time_passes, \"resolution\", (),\n-             |_| resolve::resolve_crate(&sess, &lang_items, krate));\n+             |_| resolve::resolve_crate(&sess,\n+                                        &lang_items,\n+                                        krate,\n+                                        make_glob_map));\n \n     // Discard MTWT tables that aren't required past resolution.\n     syntax::ext::mtwt::clear_tables();\n@@ -454,14 +461,19 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n         public_items: public_items,\n         reachable: reachable_map,\n         name: name,\n+        glob_map: glob_map,\n     }\n }\n \n+fn save_analysis(sess: &Session) -> bool {\n+    (sess.opts.debugging_opts & config::SAVE_ANALYSIS) != 0\n+}\n+\n pub fn phase_save_analysis(sess: &Session,\n                            krate: &ast::Crate,\n                            analysis: &ty::CrateAnalysis,\n                            odir: &Option<Path>) {\n-    if (sess.opts.debugging_opts & config::SAVE_ANALYSIS) == 0 {\n+    if !save_analysis(sess) {\n         return;\n     }\n     time(sess.time_passes(), \"save analysis\", krate, |krate|"}, {"sha": "1ef1486dd54d25b70fed7e2febead7013bc6c73a", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=df0c6d93852c51b6936d4b72b6b4be5f1932fb8a", "patch": "@@ -123,7 +123,7 @@ fn test_env<F>(source_string: &str,\n     // run just enough stuff to build a tcx:\n     let lang_items = lang_items::collect_language_items(krate, &sess);\n     let resolve::CrateMap { def_map, freevars, capture_mode_map, .. } =\n-        resolve::resolve_crate(&sess, &lang_items, krate);\n+        resolve::resolve_crate(&sess, &ast_map, &lang_items, krate, resolve::MakeGlobMap::No);\n     let named_region_map = resolve_lifetime::krate(&sess, krate, &def_map);\n     let region_map = region::resolve_crate(&sess, krate);\n     let stability_index = stability::Index::build(krate);"}, {"sha": "c09014cdb7a24785f1b0bacc2c43d2d4d8bd4fdc", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=df0c6d93852c51b6936d4b72b6b4be5f1932fb8a", "patch": "@@ -28,19 +28,19 @@ use syntax::ast::{ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::visit::{mod, Visitor};\n \n-struct UnusedImportCheckVisitor<'a, 'b:'a> {\n-    resolver: &'a mut Resolver<'b>\n+struct UnusedImportCheckVisitor<'a, 'b:'a, 'tcx:'b> {\n+    resolver: &'a mut Resolver<'b, 'tcx>\n }\n \n // Deref and DerefMut impls allow treating UnusedImportCheckVisitor as Resolver.\n-impl<'a, 'b> Deref<Resolver<'b>> for UnusedImportCheckVisitor<'a, 'b> {\n-    fn deref<'c>(&'c self) -> &'c Resolver<'b> {\n+impl<'a, 'b, 'tcx> Deref<Resolver<'b, 'tcx>> for UnusedImportCheckVisitor<'a, 'b, 'tcx:'b> {\n+    fn deref<'c>(&'c self) -> &'c Resolver<'b, 'tcx> {\n         &*self.resolver\n     }\n }\n \n-impl<'a, 'b> DerefMut<Resolver<'b>> for UnusedImportCheckVisitor<'a, 'b> {\n-    fn deref_mut<'c>(&'c mut self) -> &'c mut Resolver<'b> {\n+impl<'a, 'b, 'tcx> DerefMut<Resolver<'b, 'tcx>> for UnusedImportCheckVisitor<'a, 'b, 'tcx:'b> {\n+    fn deref_mut<'c>(&'c mut self) -> &'c mut Resolver<'b, 'tcx> {\n         &mut *self.resolver\n     }\n }\n@@ -104,7 +104,7 @@ impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n     }\n }\n \n-impl<'a, 'b, 'v> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b> {\n+impl<'a, 'b, 'v, 'tcx> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n     fn visit_view_item(&mut self, vi: &ViewItem) {\n         // Ignore is_public import statements because there's no way to be sure\n         // whether they're used or not. Also ignore imports with a dummy span"}, {"sha": "815a8400a37fbf58f1be332b88eae5074f5d5760", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 180, "deletions": 49, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=df0c6d93852c51b6936d4b72b6b4be5f1932fb8a", "patch": "@@ -82,6 +82,7 @@ use syntax::ast::{Variant, ViewItem, ViewItemExternCrate};\n use syntax::ast::{ViewItemUse, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::ast::{Visibility};\n use syntax::ast;\n+use syntax::ast_map;\n use syntax::ast_util::{mod, PostExpansionMethod, local_def, walk_pat};\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::mtwt;\n@@ -109,6 +110,10 @@ struct BindingInfo {\n // Map from the name in a pattern to its binding mode.\n type BindingMap = HashMap<Name, BindingInfo>;\n \n+// Map from the NodeId of a glob import to a list of items which are actually\n+// imported.\n+pub type GlobMap = HashMap<NodeId, HashSet<Name>>;\n+\n #[deriving(Copy, PartialEq)]\n enum PatternBindingMode {\n     RefutableMode,\n@@ -168,7 +173,7 @@ enum NameDefinition {\n     ImportNameDefinition(Def, LastPrivate) //< The name identifies an import.\n }\n \n-impl<'a, 'v> Visitor<'v> for Resolver<'a> {\n+impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n         self.resolve_item(item);\n     }\n@@ -340,14 +345,24 @@ impl Rib {\n     }\n }\n \n+/// Whether an import can be shadowed by another import.\n+#[deriving(Show,PartialEq,Clone)]\n+enum Shadowable {\n+    Always,\n+    /// Means that the recorded import obeys the glob shadowing rules, i.e., can\n+    /// only be shadowed by another glob import.\n+    Glob,\n+    Never\n+}\n+\n /// One import directive.\n struct ImportDirective {\n     module_path: Vec<Name>,\n     subclass: ImportDirectiveSubclass,\n     span: Span,\n     id: NodeId,\n     is_public: bool, // see note in ImportResolution about how to use this\n-    shadowable: bool,\n+    shadowable: Shadowable,\n }\n \n impl ImportDirective {\n@@ -356,7 +371,7 @@ impl ImportDirective {\n            span: Span,\n            id: NodeId,\n            is_public: bool,\n-           shadowable: bool)\n+           shadowable: Shadowable)\n            -> ImportDirective {\n         ImportDirective {\n             module_path: module_path,\n@@ -374,13 +389,13 @@ impl ImportDirective {\n struct Target {\n     target_module: Rc<Module>,\n     bindings: Rc<NameBindings>,\n-    shadowable: bool,\n+    shadowable: Shadowable,\n }\n \n impl Target {\n     fn new(target_module: Rc<Module>,\n            bindings: Rc<NameBindings>,\n-           shadowable: bool)\n+           shadowable: Shadowable)\n            -> Target {\n         Target {\n             target_module: target_module,\n@@ -442,6 +457,15 @@ impl ImportResolution {\n             ValueNS => self.value_id,\n         }\n     }\n+\n+    fn shadowable(&self, namespace: Namespace) -> Shadowable {\n+        let target = self.target_for_namespace(namespace);\n+        if target.is_none() {\n+            return Shadowable::Always;\n+        }\n+\n+        target.unwrap().shadowable\n+    }\n }\n \n /// The link from a module up to its nearest parent node.\n@@ -842,9 +866,11 @@ fn namespace_error_to_string(ns: NamespaceError) -> &'static str {\n }\n \n /// The main resolver class.\n-struct Resolver<'a> {\n+struct Resolver<'a, 'tcx:'a> {\n     session: &'a Session,\n \n+    ast_map: &'a ast_map::Map<'tcx>,\n+\n     graph_root: NameBindings,\n \n     trait_item_map: FnvHashMap<(Name, DefId), TraitItemKind>,\n@@ -895,16 +921,21 @@ struct Resolver<'a> {\n     // so as to avoid printing duplicate errors\n     emit_errors: bool,\n \n+    make_glob_map: bool,\n+    // Maps imports to the names of items actually imported (this actually maps\n+    // all imports, but only glob imports are actually interesting).\n+    glob_map: GlobMap,\n+\n     used_imports: HashSet<(NodeId, Namespace)>,\n     used_crates: HashSet<CrateNum>,\n }\n \n-struct BuildReducedGraphVisitor<'a, 'b:'a> {\n-    resolver: &'a mut Resolver<'b>,\n+struct BuildReducedGraphVisitor<'a, 'b:'a, 'tcx:'b> {\n+    resolver: &'a mut Resolver<'b, 'tcx>,\n     parent: ReducedGraphParent\n }\n \n-impl<'a, 'b, 'v> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b> {\n+impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n \n     fn visit_item(&mut self, item: &Item) {\n         let p = self.resolver.build_reduced_graph_for_item(item, self.parent.clone());\n@@ -939,15 +970,32 @@ impl<'a, 'b, 'v> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b> {\n \n }\n \n+<<<<<<< HEAD:src/librustc_resolve/lib.rs\n+=======\n+struct UnusedImportCheckVisitor<'a, 'b:'a, 'tcx:'b> {\n+    resolver: &'a mut Resolver<'b, 'tcx>\n+}\n+\n+impl<'a, 'b, 'v, 'tcx> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n+    fn visit_view_item(&mut self, vi: &ViewItem) {\n+        self.resolver.check_for_item_unused_imports(vi);\n+        visit::walk_view_item(self, vi);\n+    }\n+}\n+\n+>>>>>>> save-analysis: emit names of items that a glob import actually imports.:src/librustc/middle/resolve.rs\n #[deriving(PartialEq)]\n enum FallbackChecks {\n     Everything,\n     OnlyTraitAndStatics\n }\n \n \n-impl<'a> Resolver<'a> {\n-    fn new(session: &'a Session, crate_span: Span) -> Resolver<'a> {\n+impl<'a, 'tcx> Resolver<'a, 'tcx> {\n+    fn new(session: &'a Session,\n+           ast_map: &'a ast_map::Map<'tcx>,\n+           crate_span: Span,\n+           make_glob_map: MakeGlobMap) -> Resolver<'a, 'tcx> {\n         let graph_root = NameBindings::new();\n \n         graph_root.define_module(NoParentLink,\n@@ -962,6 +1010,8 @@ impl<'a> Resolver<'a> {\n         Resolver {\n             session: session,\n \n+            ast_map: ast_map,\n+\n             // The outermost module has def ID 0; this is not reflected in the\n             // AST.\n \n@@ -997,6 +1047,8 @@ impl<'a> Resolver<'a> {\n             last_private: NodeMap::new(),\n \n             emit_errors: true,\n+            make_glob_map: make_glob_map == MakeGlobMap::Yes,\n+            glob_map: HashMap::new(),\n         }\n     }\n \n@@ -1610,6 +1662,11 @@ impl<'a> Resolver<'a> {\n                                  attr.name() == token::get_name(\n                                     special_idents::prelude_import.name)\n                              });\n+                let shadowable = if shadowable {\n+                    Shadowable::Always\n+                } else {\n+                    Shadowable::Never\n+                };\n \n                 match view_path.node {\n                     ViewPathSimple(binding, ref full_path, id) => {\n@@ -1680,7 +1737,11 @@ impl<'a> Resolver<'a> {\n                                                     view_path.span,\n                                                     id,\n                                                     is_public,\n-                                                    shadowable);\n+                                                    if shadowable == Shadowable::Never {\n+                                                        Shadowable::Glob\n+                                                    } else {\n+                                                        shadowable\n+                                                    });\n                     }\n                 }\n             }\n@@ -2131,7 +2192,7 @@ impl<'a> Resolver<'a> {\n                               span: Span,\n                               id: NodeId,\n                               is_public: bool,\n-                              shadowable: bool) {\n+                              shadowable: Shadowable) {\n         module_.imports.borrow_mut().push(ImportDirective::new(module_path,\n                                                                subclass,\n                                                                span,\n@@ -2326,6 +2387,29 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    #[inline]\n+    fn record_import_use(&mut self, import_id: NodeId, name: Name) {\n+        if !self.make_glob_map {\n+            return;\n+        }\n+        if self.glob_map.contains_key(&import_id) {\n+            self.glob_map[import_id].insert(name);\n+            return;\n+        }\n+\n+        let mut new_set = HashSet::new();\n+        new_set.insert(name);\n+        self.glob_map.insert(import_id, new_set);\n+    }\n+\n+    fn get_trait_name(&self, did: DefId) -> Name {\n+        if did.krate == LOCAL_CRATE {\n+            self.ast_map.expect_item(did.node).ident.name\n+        } else {\n+            csearch::get_trait_name(&self.session.cstore, did)\n+        }\n+    }\n+\n     /// Attempts to resolve the given import. The return value indicates\n     /// failure if we're certain the name does not exist, indeterminate if we\n     /// don't know whether the name exists at the moment due to other\n@@ -2338,8 +2422,7 @@ impl<'a> Resolver<'a> {\n         let mut resolution_result = Failed(None);\n         let module_path = &import_directive.module_path;\n \n-        debug!(\"(resolving import for module) resolving import `{}::...` in \\\n-                `{}`\",\n+        debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n                self.names_to_string(module_path[]),\n                self.module_to_string(&*module_));\n \n@@ -2526,7 +2609,8 @@ impl<'a> Resolver<'a> {\n \n                         fn get_binding(this: &mut Resolver,\n                                        import_resolution: &ImportResolution,\n-                                       namespace: Namespace)\n+                                       namespace: Namespace,\n+                                       source: &Name)\n                                     -> NamespaceResult {\n \n                             // Import resolutions must be declared with \"pub\"\n@@ -2550,6 +2634,7 @@ impl<'a> Resolver<'a> {\n                                     let id = import_resolution.id(namespace);\n                                     // track used imports and extern crates as well\n                                     this.used_imports.insert((id, namespace));\n+                                    this.record_import_use(id, *source);\n                                     match target_module.def_id.get() {\n                                         Some(DefId{krate: kid, ..}) => {\n                                             this.used_crates.insert(kid);\n@@ -2564,13 +2649,17 @@ impl<'a> Resolver<'a> {\n                         // The name is an import which has been fully\n                         // resolved. We can, therefore, just follow it.\n                         if value_result.is_unknown() {\n-                            value_result = get_binding(self, import_resolution,\n-                                                       ValueNS);\n+                            value_result = get_binding(self,\n+                                                       import_resolution,\n+                                                       ValueNS,\n+                                                       &source);\n                             value_used_reexport = import_resolution.is_public;\n                         }\n                         if type_result.is_unknown() {\n-                            type_result = get_binding(self, import_resolution,\n-                                                      TypeNS);\n+                            type_result = get_binding(self,\n+                                                      import_resolution,\n+                                                      TypeNS,\n+                                                      &source);\n                             type_used_reexport = import_resolution.is_public;\n                         }\n \n@@ -2752,7 +2841,7 @@ impl<'a> Resolver<'a> {\n         return Success(());\n     }\n \n-    // Resolves a glob import. Note that this function cannot panic; it either\n+    // Resolves a glob import. Note that this function cannot fail; it either\n     // succeeds or bails out (as importing * from an empty module or a module\n     // that exports nothing is valid).\n     fn resolve_glob_import(&mut self,\n@@ -2883,7 +2972,9 @@ impl<'a> Resolver<'a> {\n \n         let mut import_resolutions = module_.import_resolutions.borrow_mut();\n         let dest_import_resolution = match import_resolutions.entry(name) {\n-            Occupied(entry) => entry.into_mut(),\n+            Occupied(entry) => {\n+                entry.into_mut()\n+            }\n             Vacant(entry) => {\n                 // Create a new import resolution from this child.\n                 entry.set(ImportResolution::new(id, is_public))\n@@ -2899,19 +2990,33 @@ impl<'a> Resolver<'a> {\n         // Merge the child item into the import resolution.\n         if name_bindings.defined_in_namespace_with(ValueNS, IMPORTABLE | PUBLIC) {\n             debug!(\"(resolving glob import) ... for value target\");\n-            dest_import_resolution.value_target =\n-                Some(Target::new(containing_module.clone(),\n-                                 name_bindings.clone(),\n-                                 import_directive.shadowable));\n-            dest_import_resolution.value_id = id;\n+            if dest_import_resolution.shadowable(ValueNS) == Shadowable::Never {\n+                let msg = format!(\"a value named `{}` has already been imported \\\n+                                   in this module\",\n+                                  token::get_name(name).get());\n+                self.session.span_err(import_directive.span, msg.as_slice());\n+            } else {\n+                dest_import_resolution.value_target =\n+                    Some(Target::new(containing_module.clone(),\n+                                     name_bindings.clone(),\n+                                     import_directive.shadowable));\n+                dest_import_resolution.value_id = id;\n+            }\n         }\n         if name_bindings.defined_in_namespace_with(TypeNS, IMPORTABLE | PUBLIC) {\n             debug!(\"(resolving glob import) ... for type target\");\n-            dest_import_resolution.type_target =\n-                Some(Target::new(containing_module,\n-                                 name_bindings.clone(),\n-                                 import_directive.shadowable));\n-            dest_import_resolution.type_id = id;\n+            if dest_import_resolution.shadowable(TypeNS) == Shadowable::Never {\n+                let msg = format!(\"a type named `{}` has already been imported \\\n+                                   in this module\",\n+                                  token::get_name(name).get());\n+                self.session.span_err(import_directive.span, msg.as_slice());\n+            } else {\n+                dest_import_resolution.type_target =\n+                    Some(Target::new(containing_module,\n+                                     name_bindings.clone(),\n+                                     import_directive.shadowable));\n+                dest_import_resolution.type_id = id;\n+            }\n         }\n         dest_import_resolution.is_public = is_public;\n \n@@ -2933,7 +3038,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         match *target {\n-            Some(ref target) if !target.shadowable => {\n+            Some(ref target) if target.shadowable != Shadowable::Always => {\n                 let msg = format!(\"a {} named `{}` has already been imported \\\n                                    in this module\",\n                                   match namespace {\n@@ -2976,7 +3081,7 @@ impl<'a> Resolver<'a> {\n                  .borrow()\n                  .contains_key(&name) {\n             match import_resolution.type_target {\n-                Some(ref target) if !target.shadowable => {\n+                Some(ref target) if target.shadowable != Shadowable::Always => {\n                     let msg = format!(\"import `{0}` conflicts with imported \\\n                                        crate in this module \\\n                                        (maybe you meant `use {0}::*`?)\",\n@@ -2998,7 +3103,7 @@ impl<'a> Resolver<'a> {\n         };\n \n         match import_resolution.value_target {\n-            Some(ref target) if !target.shadowable => {\n+            Some(ref target) if target.shadowable != Shadowable::Always => {\n                 if let Some(ref value) = *name_bindings.value_def.borrow() {\n                     let msg = format!(\"import `{}` conflicts with value \\\n                                        in this module\",\n@@ -3014,7 +3119,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         match import_resolution.type_target {\n-            Some(ref target) if !target.shadowable => {\n+            Some(ref target) if target.shadowable != Shadowable::Always => {\n                 if let Some(ref ty) = *name_bindings.type_def.borrow() {\n                     match ty.module_def {\n                         None => {\n@@ -3347,7 +3452,7 @@ impl<'a> Resolver<'a> {\n                 debug!(\"top name bindings succeeded\");\n                 return Success((Target::new(module_.clone(),\n                                             name_bindings.clone(),\n-                                            false),\n+                                            Shadowable::Never),\n                                false));\n             }\n             Some(_) | None => { /* Not found; continue. */ }\n@@ -3369,9 +3474,11 @@ impl<'a> Resolver<'a> {\n                     debug!(\"(resolving item in lexical scope) using \\\n                             import resolution\");\n                     // track used imports and extern crates as well\n-                    self.used_imports.insert((import_resolution.id(namespace), namespace));\n+                    let id = import_resolution.id(namespace);\n+                    self.used_imports.insert((id, namespace));\n+                    self.record_import_use(id, name);\n                     if let Some(DefId{krate: kid, ..}) = target.target_module.def_id.get() {\n-                        self.used_crates.insert(kid);\n+                         self.used_crates.insert(kid);\n                     }\n                     return Success((target, false));\n                 }\n@@ -3384,7 +3491,9 @@ impl<'a> Resolver<'a> {\n                 let name_bindings =\n                     Rc::new(Resolver::create_name_bindings_from_module(module));\n                 debug!(\"lower name bindings succeeded\");\n-                return Success((Target::new(module_, name_bindings, false),\n+                return Success((Target::new(module_,\n+                                            name_bindings,\n+                                            Shadowable::Never),\n                                 false));\n             }\n         }\n@@ -3608,7 +3717,7 @@ impl<'a> Resolver<'a> {\n                 debug!(\"(resolving name in module) found node as child\");\n                 return Success((Target::new(module_.clone(),\n                                             name_bindings.clone(),\n-                                            false),\n+                                            Shadowable::Never),\n                                false));\n             }\n             Some(_) | None => {\n@@ -3645,7 +3754,9 @@ impl<'a> Resolver<'a> {\n                         debug!(\"(resolving name in module) resolved to \\\n                                 import\");\n                         // track used imports and extern crates as well\n-                        self.used_imports.insert((import_resolution.id(namespace), namespace));\n+                        let id = import_resolution.id(namespace);\n+                        self.used_imports.insert((id, namespace));\n+                        self.record_import_use(id, name);\n                         if let Some(DefId{krate: kid, ..}) = target.target_module.def_id.get() {\n                             self.used_crates.insert(kid);\n                         }\n@@ -3661,7 +3772,9 @@ impl<'a> Resolver<'a> {\n             if let Some(module) = module_.external_module_children.borrow().get(&name).cloned() {\n                 let name_bindings =\n                     Rc::new(Resolver::create_name_bindings_from_module(module));\n-                return Success((Target::new(module_, name_bindings, false),\n+                return Success((Target::new(module_,\n+                                            name_bindings,\n+                                            Shadowable::Never),\n                                 false));\n             }\n         }\n@@ -5171,6 +5284,7 @@ impl<'a> Resolver<'a> {\n                             let id = import_resolution.id(namespace);\n                             // track imports and extern crates as well\n                             self.used_imports.insert((id, namespace));\n+                            self.record_import_use(id, name);\n                             match target.target_module.def_id.get() {\n                                 Some(DefId{krate: kid, ..}) => {\n                                     self.used_crates.insert(kid);\n@@ -5859,7 +5973,10 @@ impl<'a> Resolver<'a> {\n                 };\n                 if self.trait_item_map.contains_key(&(name, did)) {\n                     add_trait_info(&mut found_traits, did, name);\n-                    self.used_imports.insert((import.type_id, TypeNS));\n+                    let id = import.type_id;\n+                    self.used_imports.insert((id, TypeNS));\n+                    let trait_name = self.get_trait_name(did);\n+                    self.record_import_use(id, trait_name);\n                     if let Some(DefId{krate: kid, ..}) = target.target_module.def_id.get() {\n                         self.used_crates.insert(kid);\n                     }\n@@ -5993,14 +6110,23 @@ pub struct CrateMap {\n     pub trait_map: TraitMap,\n     pub external_exports: ExternalExports,\n     pub last_private_map: LastPrivateMap,\n+    pub glob_map: Option<GlobMap>\n+}\n+\n+#[deriving(PartialEq)]\n+pub enum MakeGlobMap {\n+    Yes,\n+    No\n }\n \n /// Entry point to crate resolution.\n-pub fn resolve_crate(session: &Session,\n-                     _: &LanguageItems,\n-                     krate: &Crate)\n-                  -> CrateMap {\n-    let mut resolver = Resolver::new(session, krate.span);\n+pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n+                               ast_map: &'a ast_map::Map<'tcx>,\n+                               _: &LanguageItems,\n+                               krate: &Crate,\n+                               make_glob_map: MakeGlobMap)\n+                               -> CrateMap {\n+    let mut resolver = Resolver::new(session, ast_map, krate.span, make_glob_map);\n \n     resolver.build_reduced_graph(krate);\n     session.abort_if_errors();\n@@ -6024,5 +6150,10 @@ pub fn resolve_crate(session: &Session,\n         trait_map: resolver.trait_map,\n         external_exports: resolver.external_exports,\n         last_private_map: resolver.last_private,\n+        glob_map: if resolver.make_glob_map {\n+                        Some(resolver.glob_map)\n+                    } else {\n+                        None\n+                    },\n     }\n }"}, {"sha": "f491bc84b62c476d158e71bc714d2c691b23ed27", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=df0c6d93852c51b6936d4b72b6b4be5f1932fb8a", "patch": "@@ -1197,7 +1197,28 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                                self.cur_scope);\n                         self.write_sub_paths_truncated(path);\n                     }\n-                    ast::ViewPathGlob(ref path, _) => {\n+                    ast::ViewPathGlob(ref path, id) => {\n+                        // Make a comma-separated list of names of imported modules.\n+                        let mut name_string = String::new();\n+                        let glob_map = &self.analysis.glob_map;\n+                        let glob_map = glob_map.as_ref().unwrap();\n+                        if glob_map.contains_key(&id) {\n+                            let names = glob_map.index(&id);\n+                            for n in names.iter() {\n+                                if name_string.len() > 0 {\n+                                    name_string.push_str(\", \");\n+                                }\n+                                name_string.push_str(n.as_str());\n+                            }\n+                        }\n+\n+                        let sub_span = self.span.sub_span_of_token(path.span,\n+                                                                   token::BinOp(token::Star));\n+                        self.fmt.use_glob_str(path.span,\n+                                              sub_span,\n+                                              id,\n+                                              name_string.as_slice(),\n+                                              self.cur_scope);\n                         self.write_sub_paths(path);\n                     }\n                     ast::ViewPathList(ref path, ref list, _) => {\n@@ -1482,6 +1503,7 @@ pub fn process_crate(sess: &Session,\n         return;\n     }\n \n+    assert!(analysis.glob_map.is_some());\n     let cratename = match attr::find_crate_name(krate.attrs[]) {\n         Some(name) => name.get().to_string(),\n         None => {"}, {"sha": "b2dd9218f1797333420281fc6f6e7eabcac3f5eb", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=df0c6d93852c51b6936d4b72b6b4be5f1932fb8a", "patch": "@@ -74,6 +74,7 @@ pub enum Row {\n     Impl,\n     Module,\n     UseAlias,\n+    UseGlob,\n     ExternCrate,\n     Inheritance,\n     MethodCall,\n@@ -125,6 +126,7 @@ impl<'a> FmtStrs<'a> {\n             UseAlias => (\"use_alias\",\n                          vec!(\"id\",\"refid\",\"refidcrate\",\"name\",\"scopeid\"),\n                          true, true),\n+            UseGlob => (\"use_glob\", vec!(\"id\",\"value\",\"scopeid\"), true, true),\n             ExternCrate => (\"extern_crate\",\n                             vec!(\"id\",\"name\",\"location\",\"crate\",\"scopeid\"),\n                             true, true),\n@@ -480,6 +482,18 @@ impl<'a> FmtStrs<'a> {\n                               svec!(id, mod_node, mod_crate, name, parent));\n     }\n \n+    pub fn use_glob_str(&mut self,\n+                        span: Span,\n+                        sub_span: Option<Span>,\n+                        id: NodeId,\n+                        values: &str,\n+                        parent: NodeId) {\n+        self.check_and_record(UseGlob,\n+                              span,\n+                              sub_span,\n+                              svec!(id, values, parent));\n+    }\n+\n     pub fn extern_crate_str(&mut self,\n                           span: Span,\n                           sub_span: Option<Span>,"}, {"sha": "e9d862d3781bbf47b21c72f3233667ebf820ae6a", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=df0c6d93852c51b6936d4b72b6b4be5f1932fb8a", "patch": "@@ -280,6 +280,19 @@ impl<'a> SpanUtils<'a> {\n         }\n     }\n \n+    pub fn sub_span_of_token(&self, span: Span, tok: Token) -> Option<Span> {\n+        let mut toks = self.retokenise_span(span);\n+        loop {\n+            let next = toks.real_token();\n+            if next.tok == token::Eof {\n+                return None;\n+            }\n+            if next.tok == tok {\n+                return self.make_sub_span(span, Some(next.sp));\n+            }\n+        }\n+    }\n+\n     pub fn sub_span_after_keyword(&self,\n                               span: Span,\n                               keyword: keywords::Keyword) -> Option<Span> {"}, {"sha": "4b1b92b552cec577f9dea057972c2efd1f03f0f0", "filename": "src/librustc_trans/trans/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df0c6d93852c51b6936d4b72b6b4be5f1932fb8a/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmod.rs?ref=df0c6d93852c51b6936d4b72b6b4be5f1932fb8a", "patch": "@@ -69,4 +69,3 @@ pub struct CrateTranslation {\n     pub crate_formats: dependency_format::Dependencies,\n     pub no_builtins: bool,\n }\n-"}]}