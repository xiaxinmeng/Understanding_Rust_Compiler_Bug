{"sha": "74ebad4b63ce2ccaa6051b60031a6597ee4468ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0ZWJhZDRiNjNjZTJjY2FhNjA1MWI2MDAzMWE2NTk3ZWU0NDY4ZWM=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-10-16T12:06:07Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-10-16T12:44:40Z"}, "message": "Use SipHasher128 in StableHasher.", "tree": {"sha": "4e063c45eb2a4bdb8e48c72e35ce4d950c7c1977", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e063c45eb2a4bdb8e48c72e35ce4d950c7c1977"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74ebad4b63ce2ccaa6051b60031a6597ee4468ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74ebad4b63ce2ccaa6051b60031a6597ee4468ec", "html_url": "https://github.com/rust-lang/rust/commit/74ebad4b63ce2ccaa6051b60031a6597ee4468ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74ebad4b63ce2ccaa6051b60031a6597ee4468ec/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25014b5379143f975e62407180f082daac0ddaed", "url": "https://api.github.com/repos/rust-lang/rust/commits/25014b5379143f975e62407180f082daac0ddaed", "html_url": "https://github.com/rust-lang/rust/commit/25014b5379143f975e62407180f082daac0ddaed"}], "stats": {"total": 135, "additions": 70, "deletions": 65}, "files": [{"sha": "f3bb3b385667ed041d768cf584e49eb0007dc620", "filename": "src/librustc/ich/fingerprint.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/74ebad4b63ce2ccaa6051b60031a6597ee4468ec/src%2Flibrustc%2Fich%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ebad4b63ce2ccaa6051b60031a6597ee4468ec/src%2Flibrustc%2Fich%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Ffingerprint.rs?ref=74ebad4b63ce2ccaa6051b60031a6597ee4468ec", "patch": "@@ -9,8 +9,6 @@\n // except according to those terms.\n \n use rustc_data_structures::stable_hasher;\n-use std::mem;\n-use std::slice;\n \n #[derive(Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Clone, Copy, RustcEncodable, RustcDecodable)]\n pub struct Fingerprint(u64, u64);\n@@ -54,16 +52,9 @@ impl ::std::fmt::Display for Fingerprint {\n }\n \n impl stable_hasher::StableHasherResult for Fingerprint {\n-    fn finish(mut hasher: stable_hasher::StableHasher<Self>) -> Self {\n-        let hash_bytes: &[u8] = hasher.finalize();\n-\n-        assert!(hash_bytes.len() >= mem::size_of::<u64>() * 2);\n-        let hash_bytes: &[u64] = unsafe {\n-            slice::from_raw_parts(hash_bytes.as_ptr() as *const u64, 2)\n-        };\n-\n-        // The bytes returned bytes the Blake2B hasher are always little-endian.\n-        Fingerprint(u64::from_le(hash_bytes[0]), u64::from_le(hash_bytes[1]))\n+    fn finish(hasher: stable_hasher::StableHasher<Self>) -> Self {\n+        let (_0, _1) = hasher.finalize();\n+        Fingerprint(_0, _1)\n     }\n }\n "}, {"sha": "3a20343033c233af91d976973b83e54e0b8ca37c", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/74ebad4b63ce2ccaa6051b60031a6597ee4468ec/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ebad4b63ce2ccaa6051b60031a6597ee4468ec/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=74ebad4b63ce2ccaa6051b60031a6597ee4468ec", "patch": "@@ -28,6 +28,7 @@\n #![feature(fn_traits)]\n #![feature(unsize)]\n #![feature(i128_type)]\n+#![feature(i128)]\n #![feature(conservative_impl_trait)]\n #![feature(specialization)]\n "}, {"sha": "3e5269001100aee46dbbae4515af4936ed2fb0f5", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 66, "deletions": 53, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/74ebad4b63ce2ccaa6051b60031a6597ee4468ec/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ebad4b63ce2ccaa6051b60031a6597ee4468ec/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=74ebad4b63ce2ccaa6051b60031a6597ee4468ec", "patch": "@@ -11,16 +11,7 @@\n use std::hash::{Hash, Hasher, BuildHasher};\n use std::marker::PhantomData;\n use std::mem;\n-use blake2b::Blake2bHasher;\n-use rustc_serialize::leb128;\n-\n-fn write_unsigned_leb128_to_buf(buf: &mut [u8; 16], value: u64) -> usize {\n-    leb128::write_unsigned_leb128_to(value as u128, |i, v| buf[i] = v)\n-}\n-\n-fn write_signed_leb128_to_buf(buf: &mut [u8; 16], value: i64) -> usize {\n-    leb128::write_signed_leb128_to(value as i128, |i, v| buf[i] = v)\n-}\n+use sip128::SipHasher128;\n \n /// When hashing something that ends up affecting properties like symbol names. We\n /// want these symbol names to be calculated independent of other factors like\n@@ -41,7 +32,7 @@ fn write_signed_leb128_to_buf(buf: &mut [u8; 16], value: i64) -> usize {\n /// and allows for variable output lengths through its type\n /// parameter.\n pub struct StableHasher<W> {\n-    state: Blake2bHasher,\n+    state: SipHasher128,\n     bytes_hashed: u64,\n     width: PhantomData<W>,\n }\n@@ -59,7 +50,7 @@ pub trait StableHasherResult: Sized {\n impl<W: StableHasherResult> StableHasher<W> {\n     pub fn new() -> Self {\n         StableHasher {\n-            state: Blake2bHasher::new(mem::size_of::<W>(), &[]),\n+            state: SipHasher128::new_with_keys(0, 0),\n             bytes_hashed: 0,\n             width: PhantomData,\n         }\n@@ -71,65 +62,67 @@ impl<W: StableHasherResult> StableHasher<W> {\n }\n \n impl StableHasherResult for [u8; 20] {\n-    fn finish(mut hasher: StableHasher<Self>) -> Self {\n-        let mut result: [u8; 20] = [0; 20];\n-        result.copy_from_slice(hasher.state.finalize());\n-        result\n+    fn finish(hasher: StableHasher<Self>) -> Self {\n+        let (_0, _1) = hasher.finalize();\n+\n+        [\n+            (_0 >>  0) as u8,\n+            (_0 >>  8) as u8,\n+            (_0 >> 16) as u8,\n+            (_0 >> 24) as u8,\n+            (_0 >> 32) as u8,\n+            (_0 >> 40) as u8,\n+            (_0 >> 48) as u8,\n+            (_0 >> 56) as u8,\n+\n+            17,\n+            33,\n+            47,\n+            3,\n+\n+            (_1 >>  0) as u8,\n+            (_1 >>  8) as u8,\n+            (_1 >> 16) as u8,\n+            (_1 >> 24) as u8,\n+            (_1 >> 32) as u8,\n+            (_1 >> 40) as u8,\n+            (_1 >> 48) as u8,\n+            (_1 >> 56) as u8,\n+        ]\n     }\n }\n \n impl StableHasherResult for u128 {\n-    fn finish(mut hasher: StableHasher<Self>) -> Self {\n-        let hash_bytes: &[u8] = hasher.finalize();\n-        assert!(hash_bytes.len() >= mem::size_of::<u128>());\n-\n-        unsafe {\n-            ::std::ptr::read_unaligned(hash_bytes.as_ptr() as *const u128)\n-        }\n+    fn finish(hasher: StableHasher<Self>) -> Self {\n+        let (_0, _1) = hasher.finalize();\n+        (_0 as u128) | ((_1 as u128) << 64)\n     }\n }\n \n impl StableHasherResult for u64 {\n-    fn finish(mut hasher: StableHasher<Self>) -> Self {\n-        hasher.state.finalize();\n-        hasher.state.finish()\n+    fn finish(hasher: StableHasher<Self>) -> Self {\n+        hasher.finalize().0\n     }\n }\n \n impl<W> StableHasher<W> {\n     #[inline]\n-    pub fn finalize(&mut self) -> &[u8] {\n-        self.state.finalize()\n+    pub fn finalize(self) -> (u64, u64) {\n+        self.state.finish128()\n     }\n \n     #[inline]\n     pub fn bytes_hashed(&self) -> u64 {\n         self.bytes_hashed\n     }\n-\n-    #[inline]\n-    fn write_uleb128(&mut self, value: u64) {\n-        let mut buf = [0; 16];\n-        let len = write_unsigned_leb128_to_buf(&mut buf, value);\n-        self.state.write(&buf[..len]);\n-        self.bytes_hashed += len as u64;\n-    }\n-\n-    #[inline]\n-    fn write_ileb128(&mut self, value: i64) {\n-        let mut buf = [0; 16];\n-        let len = write_signed_leb128_to_buf(&mut buf, value);\n-        self.state.write(&buf[..len]);\n-        self.bytes_hashed += len as u64;\n-    }\n }\n \n // For the non-u8 integer cases we leb128 encode them first. Because small\n // integers dominate, this significantly and cheaply reduces the number of\n // bytes hashed, which is good because blake2b is expensive.\n impl<W> Hasher for StableHasher<W> {\n     fn finish(&self) -> u64 {\n-        panic!(\"use StableHasher::finish instead\");\n+        panic!(\"use StableHasher::finalize instead\");\n     }\n \n     #[inline]\n@@ -146,22 +139,32 @@ impl<W> Hasher for StableHasher<W> {\n \n     #[inline]\n     fn write_u16(&mut self, i: u16) {\n-        self.write_uleb128(i as u64);\n+        self.state.write_u16(i.to_le());\n+        self.bytes_hashed += 2;\n     }\n \n     #[inline]\n     fn write_u32(&mut self, i: u32) {\n-        self.write_uleb128(i as u64);\n+        self.state.write_u32(i.to_le());\n+        self.bytes_hashed += 4;\n     }\n \n     #[inline]\n     fn write_u64(&mut self, i: u64) {\n-        self.write_uleb128(i);\n+        self.state.write_u64(i.to_le());\n+        self.bytes_hashed += 8;\n+    }\n+\n+    #[inline]\n+    fn write_u128(&mut self, i: u128) {\n+        self.state.write_u128(i.to_le());\n+        self.bytes_hashed += 16;\n     }\n \n     #[inline]\n     fn write_usize(&mut self, i: usize) {\n-        self.write_uleb128(i as u64);\n+        self.state.write_usize(i.to_le());\n+        self.bytes_hashed += ::std::mem::size_of::<usize>() as u64;\n     }\n \n     #[inline]\n@@ -172,22 +175,32 @@ impl<W> Hasher for StableHasher<W> {\n \n     #[inline]\n     fn write_i16(&mut self, i: i16) {\n-        self.write_ileb128(i as i64);\n+        self.state.write_i16(i.to_le());\n+        self.bytes_hashed += 2;\n     }\n \n     #[inline]\n     fn write_i32(&mut self, i: i32) {\n-        self.write_ileb128(i as i64);\n+        self.state.write_i32(i.to_le());\n+        self.bytes_hashed += 4;\n     }\n \n     #[inline]\n     fn write_i64(&mut self, i: i64) {\n-        self.write_ileb128(i);\n+        self.state.write_i64(i.to_le());\n+        self.bytes_hashed += 8;\n+    }\n+\n+    #[inline]\n+    fn write_i128(&mut self, i: i128) {\n+        self.state.write_i128(i.to_le());\n+        self.bytes_hashed += 16;\n     }\n \n     #[inline]\n     fn write_isize(&mut self, i: isize) {\n-        self.write_ileb128(i as i64);\n+        self.state.write_isize(i.to_le());\n+        self.bytes_hashed += ::std::mem::size_of::<isize>() as u64;\n     }\n }\n "}]}