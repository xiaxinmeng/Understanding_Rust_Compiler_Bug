{"sha": "63e2e2e32674ebe662b927c139931ffd8a352313", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzZTJlMmUzMjY3NGViZTY2MmI5MjdjMTM5OTMxZmZkOGEzNTIzMTM=", "commit": {"author": {"name": "Thom Chiovoloni", "email": "tchiovoloni@mozilla.com", "date": "2020-07-05T17:20:01Z"}, "committer": {"name": "Thom Chiovoloni", "email": "tchiovoloni@mozilla.com", "date": "2020-07-05T17:23:50Z"}, "message": "Avoid `vec!` allocation in `is_ascii_slice_*` benches", "tree": {"sha": "fa4dad65301fc45c537b4d48ff54c14fca2f2847", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa4dad65301fc45c537b4d48ff54c14fca2f2847"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63e2e2e32674ebe662b927c139931ffd8a352313", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63e2e2e32674ebe662b927c139931ffd8a352313", "html_url": "https://github.com/rust-lang/rust/commit/63e2e2e32674ebe662b927c139931ffd8a352313", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63e2e2e32674ebe662b927c139931ffd8a352313/comments", "author": null, "committer": null, "parents": [{"sha": "980d8e1a0b18e89129cce23bb5a46c6a498dc5d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/980d8e1a0b18e89129cce23bb5a46c6a498dc5d2", "html_url": "https://github.com/rust-lang/rust/commit/980d8e1a0b18e89129cce23bb5a46c6a498dc5d2"}], "stats": {"total": 45, "additions": 36, "deletions": 9}, "files": [{"sha": "96f2b9a90c664264fc8855d67b331ed11e362327", "filename": "src/libcore/benches/ascii.rs", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/63e2e2e32674ebe662b927c139931ffd8a352313/src%2Flibcore%2Fbenches%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e2e2e32674ebe662b927c139931ffd8a352313/src%2Flibcore%2Fbenches%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fascii.rs?ref=63e2e2e32674ebe662b927c139931ffd8a352313", "patch": "@@ -58,7 +58,31 @@ macro_rules! benches {\n                 }\n             )+\n         }\n-    }\n+    };\n+\n+    // For some tests the vec allocation tends to dominate, so it can be avoided.\n+    (@readonly $( fn $name: ident($arg: ident: &[u8]) $body: block )+) => {\n+        benches!(@ro mod short_readonly SHORT $($name $arg $body)+);\n+        benches!(@ro mod medium_readonly MEDIUM $($name $arg $body)+);\n+        benches!(@ro mod long_readonly LONG $($name $arg $body)+);\n+    };\n+    (@ro mod $mod_name: ident $input: ident $($name: ident $arg: ident $body: block)+) => {\n+        mod $mod_name {\n+            use super::*;\n+\n+            $(\n+                #[bench]\n+                fn $name(bencher: &mut Bencher) {\n+                    bencher.bytes = $input.len() as u64;\n+                    let vec = $input.as_bytes().to_vec();\n+                    bencher.iter(|| {\n+                        let $arg = black_box(&vec[..]);\n+                        black_box($body)\n+                    })\n+                }\n+            )+\n+        }\n+    };\n }\n \n use test::black_box;\n@@ -230,14 +254,6 @@ benches! {\n         }\n     }\n \n-    fn is_ascii_slice_libcore(bytes: &mut [u8]) {\n-        bytes.is_ascii()\n-    }\n-\n-    fn is_ascii_slice_iter_all(bytes: &mut [u8]) {\n-        bytes.iter().all(|b| b.is_ascii())\n-    }\n-\n     @iter\n \n     is_ascii,\n@@ -253,6 +269,17 @@ benches! {\n     is_ascii_control,\n }\n \n+benches! {\n+    @readonly\n+    fn is_ascii_slice_libcore(bytes: &[u8]) {\n+        bytes.is_ascii()\n+    }\n+\n+    fn is_ascii_slice_iter_all(bytes: &[u8]) {\n+        bytes.iter().all(|b| b.is_ascii())\n+    }\n+}\n+\n macro_rules! repeat {\n     ($s: expr) => {\n         concat!($s, $s, $s, $s, $s, $s, $s, $s, $s, $s)"}]}