{"sha": "4b1dfbd86c5ab59a856e191556bf1c8f7e103f60", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiMWRmYmQ4NmM1YWI1OWE4NTZlMTkxNTU2YmYxYzhmN2UxMDNmNjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-11T15:50:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-11T15:50:33Z"}, "message": "Auto merge of #40308 - nikomatsakis:incr-comp-isolate-task, r=mw\n\nfirst pass at isolating dep-graph tasks\n\nThis intentionally leaves `DepGraph::in_task()`, the more common form,\nalone. Eventually all uses of `DepGraph::in_task()` should be ported\nto `with_task()`, but I wanted to start with a smaller subset.\n\nI also used `AssertDepGraphSafe` on the closures that are found in\ntrans. This is because the types there are non-trivial and I wanted to\nlay down the mechanism and come back to the more subtle cases.\n\nThe current approach taken in this PR has a downside: it is necessary\nto manually \"reify\" fn types into fn pointers when starting a task,\nlike so:\n\n    dep_graph.with_task(..., task_fn as fn(_))\n\nthis is because `with_task` takes some type `T` that implements\n`DepGraphTask` rather than taking a `fn()` type directly. *This* is so\nthat we can accept closure and also so that we can accept fns with\nmultiple arities. I am not sure this is the right approach.\n\nOriginally I wanted to use closures bound by an auto trait, but that\napproach has some limitations:\n\n- the trait cannot have a `read()` method; since the current method\n  is unused, that may not be a problem.\n- more importantly, we would want the auto trait to be \"undefined\" for all types\n  *by default* -- that is, this use case doesn't really fit the typical\n  auto trait scenario. For example, imagine that there is a `u32` loaded\n  out of a `hir::Node` -- we don't really want to be passing that\n  `u32` into the task!", "tree": {"sha": "a69c08cc00c42afe629a01f13152aa1d3cc237a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a69c08cc00c42afe629a01f13152aa1d3cc237a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60", "html_url": "https://github.com/rust-lang/rust/commit/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d0be0d72a8fe87c1a038f014beb7f64ba249b29", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d0be0d72a8fe87c1a038f014beb7f64ba249b29", "html_url": "https://github.com/rust-lang/rust/commit/5d0be0d72a8fe87c1a038f014beb7f64ba249b29"}, {"sha": "4d5441fe3dc0869b3f6637e6320c9091b8d9efa0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d5441fe3dc0869b3f6637e6320c9091b8d9efa0", "html_url": "https://github.com/rust-lang/rust/commit/4d5441fe3dc0869b3f6637e6320c9091b8d9efa0"}], "stats": {"total": 217, "additions": 169, "deletions": 48}, "files": [{"sha": "8be5d4327e72ec2c134e7746ecaa11985fc69b3c", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=4b1dfbd86c5ab59a856e191556bf1c8f7e103f60", "patch": "@@ -18,6 +18,7 @@ use std::sync::Arc;\n use super::dep_node::{DepNode, WorkProductId};\n use super::query::DepGraphQuery;\n use super::raii;\n+use super::safe::DepGraphSafe;\n use super::thread::{DepGraphThreadData, DepMessage};\n \n #[derive(Clone)]\n@@ -76,11 +77,38 @@ impl DepGraph {\n         op()\n     }\n \n-    pub fn with_task<OP,R>(&self, key: DepNode<DefId>, op: OP) -> R\n-        where OP: FnOnce() -> R\n+    /// Starts a new dep-graph task. Dep-graph tasks are specified\n+    /// using a free function (`task`) and **not** a closure -- this\n+    /// is intentional because we want to exercise tight control over\n+    /// what state they have access to. In particular, we want to\n+    /// prevent implicit 'leaks' of tracked state into the task (which\n+    /// could then be read without generating correct edges in the\n+    /// dep-graph -- see the [README] for more details on the\n+    /// dep-graph). To this end, the task function gets exactly two\n+    /// pieces of state: the context `cx` and an argument `arg`. Both\n+    /// of these bits of state must be of some type that implements\n+    /// `DepGraphSafe` and hence does not leak.\n+    ///\n+    /// The choice of two arguments is not fundamental. One argument\n+    /// would work just as well, since multiple values can be\n+    /// collected using tuples. However, using two arguments works out\n+    /// to be quite convenient, since it is common to need a context\n+    /// (`cx`) and some argument (e.g., a `DefId` identifying what\n+    /// item to process).\n+    ///\n+    /// For cases where you need some other number of arguments:\n+    ///\n+    /// - If you only need one argument, just use `()` for the `arg`\n+    ///   parameter.\n+    /// - If you need 3+ arguments, use a tuple for the\n+    ///   `arg` parameter.\n+    ///\n+    /// [README]: README.md\n+    pub fn with_task<C, A, R>(&self, key: DepNode<DefId>, cx: C, arg: A, task: fn(C, A) -> R) -> R\n+        where C: DepGraphSafe, A: DepGraphSafe\n     {\n         let _task = self.in_task(key);\n-        op()\n+        task(cx, arg)\n     }\n \n     pub fn read(&self, v: DepNode<DefId>) {"}, {"sha": "a9f0a44e4208c031f7ade3e7bd5756ba3d103b9a", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=4b1dfbd86c5ab59a856e191556bf1c8f7e103f60", "patch": "@@ -15,6 +15,7 @@ mod edges;\n mod graph;\n mod query;\n mod raii;\n+mod safe;\n mod shadow;\n mod thread;\n mod visit;\n@@ -25,6 +26,8 @@ pub use self::dep_node::WorkProductId;\n pub use self::graph::DepGraph;\n pub use self::graph::WorkProduct;\n pub use self::query::DepGraphQuery;\n+pub use self::safe::AssertDepGraphSafe;\n+pub use self::safe::DepGraphSafe;\n pub use self::visit::visit_all_bodies_in_krate;\n pub use self::visit::visit_all_item_likes_in_krate;\n pub use self::raii::DepTask;"}, {"sha": "f85f0338ed997b6c7e0e5f260679d14797dc301b", "filename": "src/librustc/dep_graph/safe.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fsafe.rs?ref=4b1dfbd86c5ab59a856e191556bf1c8f7e103f60", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir::BodyId;\n+use hir::def_id::DefId;\n+use syntax::ast::NodeId;\n+use ty::TyCtxt;\n+\n+/// The `DepGraphSafe` trait is used to specify what kinds of values\n+/// are safe to \"leak\" into a task. The idea is that this should be\n+/// only be implemented for things like the tcx as well as various id\n+/// types, which will create reads in the dep-graph whenever the trait\n+/// loads anything that might depend on the input program.\n+pub trait DepGraphSafe {\n+}\n+\n+/// A `BodyId` on its own doesn't give access to any particular state.\n+/// You must fetch the state from the various maps or generate\n+/// on-demand queries, all of which create reads.\n+impl DepGraphSafe for BodyId {\n+}\n+\n+/// A `NodeId` on its own doesn't give access to any particular state.\n+/// You must fetch the state from the various maps or generate\n+/// on-demand queries, all of which create reads.\n+impl DepGraphSafe for NodeId {\n+}\n+\n+/// A `DefId` on its own doesn't give access to any particular state.\n+/// You must fetch the state from the various maps or generate\n+/// on-demand queries, all of which create reads.\n+impl DepGraphSafe for DefId {\n+}\n+\n+/// The type context itself can be used to access all kinds of tracked\n+/// state, but those accesses should always generate read events.\n+impl<'a, 'gcx, 'tcx> DepGraphSafe for TyCtxt<'a, 'gcx, 'tcx> {\n+}\n+\n+/// Tuples make it easy to build up state.\n+impl<A, B> DepGraphSafe for (A, B)\n+    where A: DepGraphSafe, B: DepGraphSafe\n+{\n+}\n+\n+/// No data here! :)\n+impl DepGraphSafe for () {\n+}\n+\n+/// A convenient override that lets you pass arbitrary state into a\n+/// task. Every use should be accompanied by a comment explaining why\n+/// it makes sense (or how it could be refactored away in the future).\n+pub struct AssertDepGraphSafe<T>(pub T);\n+\n+impl<T> DepGraphSafe for AssertDepGraphSafe<T> {\n+}"}, {"sha": "b441a231874a6def39ca5a95e1da7f07aa93869d", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=4b1dfbd86c5ab59a856e191556bf1c8f7e103f60", "patch": "@@ -61,13 +61,16 @@ pub struct LoanDataFlowOperator;\n pub type LoanDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, LoanDataFlowOperator>;\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.dep_graph.with_task(DepNode::BorrowCheckKrate, || {\n+    tcx.dep_graph.with_task(DepNode::BorrowCheckKrate, tcx, (), check_crate_task);\n+\n+    fn check_crate_task<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, (): ()) {\n         tcx.visit_all_bodies_in_krate(|body_owner_def_id, body_id| {\n-            tcx.dep_graph.with_task(DepNode::BorrowCheck(body_owner_def_id), || {\n-                borrowck_fn(tcx, body_id);\n-            });\n+            tcx.dep_graph.with_task(DepNode::BorrowCheck(body_owner_def_id),\n+                                    tcx,\n+                                    body_id,\n+                                    borrowck_fn);\n         });\n-    });\n+    }\n }\n \n /// Collection of conclusions determined via borrow checker analyses."}, {"sha": "2789250649674505d9568b537a7f2899f49d6df9", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=4b1dfbd86c5ab59a856e191556bf1c8f7e103f60", "patch": "@@ -192,7 +192,11 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 clean_work_products.insert(wp.clone());\n             }\n \n-            tcx.dep_graph.with_task(n, || ()); // create the node with no inputs\n+            tcx.dep_graph.with_task(n, (), (), create_node);\n+\n+            fn create_node((): (), (): ()) {\n+                // just create the node with no inputs\n+            }\n         }\n     }\n "}, {"sha": "58f23a5c81bd7fa1cc9f557bf0aab1a994b0cb40", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=4b1dfbd86c5ab59a856e191556bf1c8f7e103f60", "patch": "@@ -38,11 +38,13 @@ use std::cell::RefCell;\n use std::mem;\n \n pub fn build_mir_for_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.dep_graph.with_task(DepNode::MirKrate, || {\n+    tcx.dep_graph.with_task(DepNode::MirKrate, tcx, (), build_mir_for_crate_task);\n+\n+    fn build_mir_for_crate_task<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, (): ()) {\n         tcx.visit_all_bodies_in_krate(|body_owner_def_id, _body_id| {\n             tcx.item_mir(body_owner_def_id);\n         });\n-    });\n+    }\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "1b43491e73c8f420e6efafcb5c308e46483ad2fa", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=4b1dfbd86c5ab59a856e191556bf1c8f7e103f60", "patch": "@@ -41,7 +41,7 @@ use rustc::mir::tcx::LvalueTy;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n-use rustc::dep_graph::{DepNode, WorkProduct};\n+use rustc::dep_graph::{AssertDepGraphSafe, DepNode, WorkProduct};\n use rustc::hir::map as hir_map;\n use rustc::util::common::time;\n use session::config::{self, NoDebugInfo};\n@@ -1211,21 +1211,40 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Instantiate translation items without filling out definitions yet...\n     for ccx in crate_context_list.iter_need_trans() {\n-        let cgu = ccx.codegen_unit();\n-        let trans_items = cgu.items_in_deterministic_order(tcx, &symbol_map);\n-\n-        tcx.dep_graph.with_task(cgu.work_product_dep_node(), || {\n+        let dep_node = ccx.codegen_unit().work_product_dep_node();\n+        tcx.dep_graph.with_task(dep_node,\n+                                ccx,\n+                                AssertDepGraphSafe(symbol_map.clone()),\n+                                trans_decl_task);\n+\n+        fn trans_decl_task<'a, 'tcx>(ccx: CrateContext<'a, 'tcx>,\n+                                     symbol_map: AssertDepGraphSafe<Rc<SymbolMap<'tcx>>>) {\n+            // FIXME(#40304): Instead of this, the symbol-map should be an\n+            // on-demand thing that we compute.\n+            let AssertDepGraphSafe(symbol_map) = symbol_map;\n+            let cgu = ccx.codegen_unit();\n+            let trans_items = cgu.items_in_deterministic_order(ccx.tcx(), &symbol_map);\n             for (trans_item, linkage) in trans_items {\n                 trans_item.predefine(&ccx, linkage);\n             }\n-        });\n+        }\n     }\n \n     // ... and now that we have everything pre-defined, fill out those definitions.\n     for ccx in crate_context_list.iter_need_trans() {\n-        let cgu = ccx.codegen_unit();\n-        let trans_items = cgu.items_in_deterministic_order(tcx, &symbol_map);\n-        tcx.dep_graph.with_task(cgu.work_product_dep_node(), || {\n+        let dep_node = ccx.codegen_unit().work_product_dep_node();\n+        tcx.dep_graph.with_task(dep_node,\n+                                ccx,\n+                                AssertDepGraphSafe(symbol_map.clone()),\n+                                trans_def_task);\n+\n+        fn trans_def_task<'a, 'tcx>(ccx: CrateContext<'a, 'tcx>,\n+                                    symbol_map: AssertDepGraphSafe<Rc<SymbolMap<'tcx>>>) {\n+            // FIXME(#40304): Instead of this, the symbol-map should be an\n+            // on-demand thing that we compute.\n+            let AssertDepGraphSafe(symbol_map) = symbol_map;\n+            let cgu = ccx.codegen_unit();\n+            let trans_items = cgu.items_in_deterministic_order(ccx.tcx(), &symbol_map);\n             for (trans_item, _) in trans_items {\n                 trans_item.define(&ccx);\n             }\n@@ -1247,7 +1266,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             if ccx.sess().opts.debuginfo != NoDebugInfo {\n                 debuginfo::finalize(&ccx);\n             }\n-        });\n+        }\n     }\n \n     symbol_names_test::report_symbol_names(&shared_ccx);"}, {"sha": "52851ea995d4b7c42edd769695931a5fc707a064", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=4b1dfbd86c5ab59a856e191556bf1c8f7e103f60", "patch": "@@ -10,7 +10,8 @@\n \n use llvm;\n use llvm::{ContextRef, ModuleRef, ValueRef};\n-use rustc::dep_graph::{DepGraph, DepNode, DepTrackingMap, DepTrackingMapConfig, WorkProduct};\n+use rustc::dep_graph::{DepGraph, DepGraphSafe, DepNode, DepTrackingMap,\n+                       DepTrackingMapConfig, WorkProduct};\n use middle::cstore::LinkMeta;\n use rustc::hir;\n use rustc::hir::def::ExportMap;\n@@ -274,6 +275,9 @@ pub struct CrateContext<'a, 'tcx: 'a> {\n     index: usize,\n }\n \n+impl<'a, 'tcx> DepGraphSafe for CrateContext<'a, 'tcx> {\n+}\n+\n pub struct CrateContextIterator<'a, 'tcx: 'a> {\n     shared: &'a SharedCrateContext<'a, 'tcx>,\n     local_ccxs: &'a [LocalCrateContext<'tcx>],"}, {"sha": "5a582a523ea1c910a6c52102b4104b2ec352ccfc", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4b1dfbd86c5ab59a856e191556bf1c8f7e103f60", "patch": "@@ -539,13 +539,15 @@ pub fn check_item_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CompileResult\n }\n \n pub fn check_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CompileResult {\n-    tcx.sess.track_errors(|| {\n-        tcx.dep_graph.with_task(DepNode::TypeckBodiesKrate, || {\n-            tcx.visit_all_bodies_in_krate(|body_owner_def_id, _body_id| {\n-                tcx.item_tables(body_owner_def_id);\n-            });\n+    return tcx.sess.track_errors(|| {\n+        tcx.dep_graph.with_task(DepNode::TypeckBodiesKrate, tcx, (), check_item_bodies_task);\n+    });\n+\n+    fn check_item_bodies_task<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, (): ()) {\n+        tcx.visit_all_bodies_in_krate(|body_owner_def_id, _body_id| {\n+            tcx.item_tables(body_owner_def_id);\n         });\n-    })\n+    }\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "2417745571910b3c848b213ff12d57f696b358d4", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b1dfbd86c5ab59a856e191556bf1c8f7e103f60/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=4b1dfbd86c5ab59a856e191556bf1c8f7e103f60", "patch": "@@ -165,15 +165,10 @@ impl<'a, 'tcx> CollectItemTypesVisitor<'a, 'tcx> {\n     /// 4. This is added by the code in `visit_expr` when we write to `item_types`.\n     /// 5. This is added by the code in `convert_item` when we write to `item_types`;\n     ///    note that this write occurs inside the `CollectItemSig` task.\n-    /// 6. Added by explicit `read` below\n-    fn with_collect_item_sig<OP>(&self, id: ast::NodeId, op: OP)\n-        where OP: FnOnce()\n-    {\n+    /// 6. Added by reads from within `op`.\n+    fn with_collect_item_sig(&self, id: ast::NodeId, op: fn(TyCtxt<'a, 'tcx, 'tcx>, ast::NodeId)) {\n         let def_id = self.tcx.hir.local_def_id(id);\n-        self.tcx.dep_graph.with_task(DepNode::CollectItemSig(def_id), || {\n-            self.tcx.hir.read(id);\n-            op();\n-        });\n+        self.tcx.dep_graph.with_task(DepNode::CollectItemSig(def_id), self.tcx, id, op);\n     }\n }\n \n@@ -183,7 +178,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        self.with_collect_item_sig(item.id, || convert_item(self.tcx, item));\n+        self.with_collect_item_sig(item.id, convert_item);\n         intravisit::walk_item(self, item);\n     }\n \n@@ -216,16 +211,12 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        self.with_collect_item_sig(trait_item.id, || {\n-            convert_trait_item(self.tcx, trait_item)\n-        });\n+        self.with_collect_item_sig(trait_item.id, convert_trait_item);\n         intravisit::walk_trait_item(self, trait_item);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n-        self.with_collect_item_sig(impl_item.id, || {\n-            convert_impl_item(self.tcx, impl_item)\n-        });\n+        self.with_collect_item_sig(impl_item.id, convert_impl_item);\n         intravisit::walk_impl_item(self, impl_item);\n     }\n }\n@@ -493,9 +484,10 @@ fn ensure_no_ty_param_bounds(tcx: TyCtxt,\n     }\n }\n \n-fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &hir::Item) {\n+fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n+    let it = tcx.hir.expect_item(item_id);\n     debug!(\"convert: item {} with id {}\", it.name, it.id);\n-    let def_id = tcx.hir.local_def_id(it.id);\n+    let def_id = tcx.hir.local_def_id(item_id);\n     match it.node {\n         // These don't define types.\n         hir::ItemExternCrate(_) | hir::ItemUse(..) | hir::ItemMod(_) => {\n@@ -560,7 +552,8 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &hir::Item) {\n     }\n }\n \n-fn convert_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_item: &hir::TraitItem) {\n+fn convert_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_item_id: ast::NodeId) {\n+    let trait_item = tcx.hir.expect_trait_item(trait_item_id);\n     let def_id = tcx.hir.local_def_id(trait_item.id);\n     tcx.item_generics(def_id);\n \n@@ -577,8 +570,8 @@ fn convert_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_item: &hir::T\n     tcx.item_predicates(def_id);\n }\n \n-fn convert_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_item: &hir::ImplItem) {\n-    let def_id = tcx.hir.local_def_id(impl_item.id);\n+fn convert_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_item_id: ast::NodeId) {\n+    let def_id = tcx.hir.local_def_id(impl_item_id);\n     tcx.item_generics(def_id);\n     tcx.item_type(def_id);\n     tcx.item_predicates(def_id);"}]}