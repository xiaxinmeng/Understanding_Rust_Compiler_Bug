{"sha": "0d88db1693a07095555d07d14ffdcb373b6bc352", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkODhkYjE2OTNhMDcwOTU1NTVkMDdkMTRmZmRjYjM3M2I2YmMzNTI=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-03-13T15:21:54Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-03-13T15:21:54Z"}, "message": "Reuse the query caching infrastructure for const eval", "tree": {"sha": "b449c6b91b871716b3b444db6fc0a67b334d6153", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b449c6b91b871716b3b444db6fc0a67b334d6153"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d88db1693a07095555d07d14ffdcb373b6bc352", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlqn7JIACgkQpp+NIls6\n19mpzw/+K+NU89Yq3RXkmsFw4VotHgiracLoxvxDSgrURjMvsnenMspz+HLIqTj2\nLgAlRm3N6CLgwlZpaHDb7MgirNwy3O9u0uKxcc1NxwPv1mWOQuDxBmKQ2sdtzxwR\nde8zx4rBEm0dnsr4gz+Dl7uUeEzCs0usApB8aJWrD2+PrSpA0Av1lT1lIQghotAH\nLVHOjnTWgnqg2H+sfIabq/qa9rQzDaHHIfikKbXf52bMf26YWhJ4OdU1gdIug6sK\nAgj/Y0Zo8F0IqH0TY4sZ79GjuKWDkYHAq2FI6jHZBl6aFmoSJdPG/Jo4kJuFsswl\npezewTXOGr3aaAV1Da5W7XFL30rR27Ns2Pd4luV3k5HYzOpJSPAhQULhgZZcrNbH\nCkjSYAyaIWwKvDIelFq+SnDe59JdNXvwPCBx8CvcvIX3k/UjOwJjMD5MmAnd9mwF\nYTmv4IVstLS99Gq9Cl3bZ/8wFrW94T2tUhUtnNU+zxQxNX1rdsJz7IEm1IpXMYJv\niD6cR7hjQf7pr4wp/GLTMG6qgDuahz0MncZOS8ZfXtfuIlFUYc6316TRm2/7IXVK\noQBbDpOdtoCxL7ftgQPMCSj5xLD0gC36ltWq+4DiSL9J48tUNhi6kfEWxpLTwTcP\nhHTYhFC8htWdTPgvLkFqQPFNgk+ce3ecR4gZ0OhdP3eGJdjspJo=\n=M1VE\n-----END PGP SIGNATURE-----", "payload": "tree b449c6b91b871716b3b444db6fc0a67b334d6153\nparent af099bb2401bc9fe7aa753a20086d51c49816bcd\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1520954514 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1520954514 +0100\n\nReuse the query caching infrastructure for const eval\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d88db1693a07095555d07d14ffdcb373b6bc352", "html_url": "https://github.com/rust-lang/rust/commit/0d88db1693a07095555d07d14ffdcb373b6bc352", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d88db1693a07095555d07d14ffdcb373b6bc352/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af099bb2401bc9fe7aa753a20086d51c49816bcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/af099bb2401bc9fe7aa753a20086d51c49816bcd", "html_url": "https://github.com/rust-lang/rust/commit/af099bb2401bc9fe7aa753a20086d51c49816bcd"}], "stats": {"total": 77, "additions": 16, "deletions": 61}, "files": [{"sha": "bcd58e993044d84e8096701d2ae1468f45aa04ad", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d88db1693a07095555d07d14ffdcb373b6bc352/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d88db1693a07095555d07d14ffdcb373b6bc352/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=0d88db1693a07095555d07d14ffdcb373b6bc352", "patch": "@@ -158,15 +158,15 @@ impl<'tcx> QueryDescription<'tcx> for queries::const_eval<'tcx> {\n     }\n \n     #[inline]\n-    fn cache_on_disk(key: Self::Key) -> bool {\n-        key.value.instance.def_id().is_local()\n+    fn cache_on_disk(_key: Self::Key) -> bool {\n+        true\n     }\n \n     #[inline]\n     fn try_load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               id: SerializedDepNodeIndex)\n                               -> Option<Self::Value> {\n-        tcx.on_disk_query_result_cache.load_constant(tcx, id).map(Ok)\n+        tcx.on_disk_query_result_cache.try_load_query_result(tcx, id).map(Ok)\n     }\n }\n "}, {"sha": "35e874b74d9ae3a70dc93078d92c098da4b8e860", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 7, "deletions": 56, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0d88db1693a07095555d07d14ffdcb373b6bc352/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d88db1693a07095555d07d14ffdcb373b6bc352/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=0d88db1693a07095555d07d14ffdcb373b6bc352", "patch": "@@ -75,10 +75,6 @@ pub struct OnDiskCache<'sess> {\n     // A map from dep-node to the position of any associated diagnostics in\n     // `serialized_data`.\n     prev_diagnostics_index: FxHashMap<SerializedDepNodeIndex, AbsoluteBytePos>,\n-\n-    // A map from dep-node to the position of any associated constants in\n-    // `serialized_data`.\n-    prev_constants_index: FxHashMap<SerializedDepNodeIndex, AbsoluteBytePos>,\n }\n \n // This type is used only for (de-)serialization.\n@@ -88,10 +84,8 @@ struct Footer {\n     prev_cnums: Vec<(u32, String, CrateDisambiguator)>,\n     query_result_index: EncodedQueryResultIndex,\n     diagnostics_index: EncodedQueryResultIndex,\n-    constants_index: EncodedConstantsIndex,\n }\n \n-type EncodedConstantsIndex = Vec<(SerializedDepNodeIndex, AbsoluteBytePos)>;\n type EncodedQueryResultIndex = Vec<(SerializedDepNodeIndex, AbsoluteBytePos)>;\n type EncodedDiagnosticsIndex = Vec<(SerializedDepNodeIndex, AbsoluteBytePos)>;\n type EncodedDiagnostics = Vec<Diagnostic>;\n@@ -145,7 +139,6 @@ impl<'sess> OnDiskCache<'sess> {\n             current_diagnostics: RefCell::new(FxHashMap()),\n             query_result_index: footer.query_result_index.into_iter().collect(),\n             prev_diagnostics_index: footer.diagnostics_index.into_iter().collect(),\n-            prev_constants_index: footer.constants_index.into_iter().collect(),\n             synthetic_expansion_infos: RefCell::new(FxHashMap()),\n         }\n     }\n@@ -161,7 +154,6 @@ impl<'sess> OnDiskCache<'sess> {\n             current_diagnostics: RefCell::new(FxHashMap()),\n             query_result_index: FxHashMap(),\n             prev_diagnostics_index: FxHashMap(),\n-            prev_constants_index: FxHashMap(),\n             synthetic_expansion_infos: RefCell::new(FxHashMap()),\n         }\n     }\n@@ -229,46 +221,25 @@ impl<'sess> OnDiskCache<'sess> {\n                 encode_query_results::<symbol_name, _>(tcx, enc, qri)?;\n                 encode_query_results::<check_match, _>(tcx, enc, qri)?;\n                 encode_query_results::<trans_fn_attrs, _>(tcx, enc, qri)?;\n-            }\n \n-            // encode successful constant evaluations\n-            let constants_index = {\n-                let mut constants_index = EncodedConstantsIndex::new();\n-                use ty::maps::queries::const_eval;\n+                // const eval is special, it only encodes successfully evaluated constants\n                 use ty::maps::plumbing::GetCacheInternal;\n-                use ty::maps::config::QueryDescription;\n                 for (key, entry) in const_eval::get_cache_internal(tcx).map.iter() {\n-                    if let Ok(ref constant) = entry.value {\n-                        if const_eval::cache_on_disk(key.clone()) {\n-                            trace!(\"caching constant {:?} with value {:#?}\", key, constant);\n+                    use ty::maps::config::QueryDescription;\n+                    if const_eval::cache_on_disk(key.clone()) {\n+                        if let Ok(ref value) = entry.value {\n                             let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n \n                             // Record position of the cache entry\n-                            constants_index.push((\n-                                dep_node,\n-                                AbsoluteBytePos::new(encoder.position()),\n-                            ));\n-                            let did = key.value.instance.def_id();\n-                            let constant = if key.value.promoted.is_none()\n-                                           && tcx.is_static(did).is_some() {\n-                                // memorize the allocation for the static, too, so\n-                                // we can refer to the static, not just read its value\n-                                // since we have had a successful query, the cached value must\n-                                // exist, so we can unwrap it\n-                                let cached = tcx.interpret_interner.get_cached(did).unwrap();\n-                                (constant, Some(cached))\n-                            } else {\n-                                (constant, None)\n-                            };\n+                            qri.push((dep_node, AbsoluteBytePos::new(enc.position())));\n \n                             // Encode the type check tables with the SerializedDepNodeIndex\n                             // as tag.\n-                            encoder.encode_tagged(dep_node, &constant)?;\n+                            enc.encode_tagged(dep_node, value)?;\n                         }\n                     }\n                 }\n-                constants_index\n-            };\n+            }\n \n             // Encode diagnostics\n             let diagnostics_index = {\n@@ -303,7 +274,6 @@ impl<'sess> OnDiskCache<'sess> {\n                 prev_cnums,\n                 query_result_index,\n                 diagnostics_index,\n-                constants_index,\n             })?;\n \n             // Encode the position of the footer as the last 8 bytes of the\n@@ -326,25 +296,6 @@ impl<'sess> OnDiskCache<'sess> {\n         })\n     }\n \n-    /// Load a constant emitted during the previous compilation session.\n-    pub fn load_constant<'a, 'tcx>(&self,\n-                                      tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                      dep_node_index: SerializedDepNodeIndex)\n-                                      -> Option<&'tcx ty::Const<'tcx>> {\n-        type Encoded<'tcx> = (ty::Const<'tcx>, Option<interpret::AllocId>);\n-        let constant: Option<Encoded<'tcx>> = self.load_indexed(\n-            tcx,\n-            dep_node_index,\n-            &self.prev_constants_index,\n-            \"constants\");\n-\n-        constant.map(|(c, _alloc_id)| {\n-            // the AllocId decoding already registers the AllocId to its DefId\n-            // so we don't need to take additional actions here\n-            tcx.mk_const(c)\n-        })\n-    }\n-\n     /// Load a diagnostic emitted during the previous compilation session.\n     pub fn load_diagnostics<'a, 'tcx>(&self,\n                                       tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "82eb28287b033c16c87e186421042ade8ff36138", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0d88db1693a07095555d07d14ffdcb373b6bc352/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d88db1693a07095555d07d14ffdcb373b6bc352/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=0d88db1693a07095555d07d14ffdcb373b6bc352", "patch": "@@ -110,6 +110,7 @@ fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n         span = mir.span;\n         let layout = ecx.layout_of(mir.return_ty().subst(tcx, cid.instance.substs))?;\n         let alloc = tcx.interpret_interner.get_cached(cid.instance.def_id());\n+        let is_static = tcx.is_static(cid.instance.def_id()).is_some();\n         let alloc = match alloc {\n             Some(alloc) => {\n                 assert!(cid.promoted.is_none());\n@@ -123,7 +124,7 @@ fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n                     layout.align,\n                     None,\n                 )?;\n-                if tcx.is_static(cid.instance.def_id()).is_some() {\n+                if is_static {\n                     tcx.interpret_interner.cache(cid.instance.def_id(), ptr.alloc_id);\n                 }\n                 let internally_mutable = !layout.ty.is_freeze(tcx, param_env, mir.span);\n@@ -151,8 +152,11 @@ fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n             }\n         };\n         let ptr = MemoryPointer::new(alloc, 0).into();\n+        // always try to read the value and report errors\n         let value = match ecx.try_read_value(ptr, layout.align, layout.ty)? {\n-            Some(val) => val,\n+            // if it's a constant (so it needs no address, directly compute its value)\n+            Some(val) if !is_static => val,\n+            // point at the allocation\n             _ => Value::ByRef(ptr, layout.align),\n         };\n         Ok((value, ptr, layout.ty))"}]}