{"sha": "90c8d6bbe4725ca83e79e73e9cdf1f66840db79f", "node_id": "C_kwDOAAsO6NoAKDkwYzhkNmJiZTQ3MjVjYTgzZTc5ZTczZTljZGYxZjY2ODQwZGI3OWY", "commit": {"author": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2023-02-17T09:32:33Z"}, "committer": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2023-02-17T09:32:39Z"}, "message": "add predicate evaluation logic", "tree": {"sha": "f048c0a43938c553b152b3a36a19c36238d52651", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f048c0a43938c553b152b3a36a19c36238d52651"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90c8d6bbe4725ca83e79e73e9cdf1f66840db79f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90c8d6bbe4725ca83e79e73e9cdf1f66840db79f", "html_url": "https://github.com/rust-lang/rust/commit/90c8d6bbe4725ca83e79e73e9cdf1f66840db79f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90c8d6bbe4725ca83e79e73e9cdf1f66840db79f/comments", "author": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e919d7e348932287cc33ec70cdc6f59ab48de255", "url": "https://api.github.com/repos/rust-lang/rust/commits/e919d7e348932287cc33ec70cdc6f59ab48de255", "html_url": "https://github.com/rust-lang/rust/commit/e919d7e348932287cc33ec70cdc6f59ab48de255"}], "stats": {"total": 142, "additions": 124, "deletions": 18}, "files": [{"sha": "2badd66e346f106e68b8eb46240c13d2ad2f9d59", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 52, "deletions": 5, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/90c8d6bbe4725ca83e79e73e9cdf1f66840db79f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c8d6bbe4725ca83e79e73e9cdf1f66840db79f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=90c8d6bbe4725ca83e79e73e9cdf1f66840db79f", "patch": "@@ -9,8 +9,8 @@ use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_middle::ty::subst::InternalSubsts;\n-use rustc_middle::ty::ToPredicate;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{GenericPredicates, ToPredicate};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -151,7 +151,8 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n     trace!(?generics);\n \n     // Collect the predicates that were written inline by the user on each\n-    // type parameter (e.g., `<T: Foo>`).\n+    // type parameter (e.g., `<T: Foo>`). Also add `ConstArgHasType` predicates\n+    // for each const parameter.\n     for param in ast_generics.params {\n         match param.kind {\n             // We already dealt with early bound lifetimes above.\n@@ -175,7 +176,19 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                 trace!(?predicates);\n             }\n             GenericParamKind::Const { .. } => {\n-                // Bounds on const parameters are currently not possible.\n+                let name = param.name.ident().name;\n+                let param_const = ty::ParamConst::new(index, name);\n+\n+                let ct_ty = tcx.type_of(param.def_id.to_def_id()).subst_identity();\n+\n+                let ct = tcx.mk_const(param_const, ct_ty);\n+\n+                let predicate = ty::Binder::dummy(ty::PredicateKind::Clause(\n+                    ty::Clause::ConstArgHasType(ct, ct_ty),\n+                ))\n+                .to_predicate(tcx);\n+                predicates.insert((predicate, param.span));\n+\n                 index += 1;\n             }\n         }\n@@ -439,7 +452,9 @@ pub(super) fn explicit_predicates_of<'tcx>(\n             let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n             let parent_def_id = tcx.hir().get_parent_item(hir_id);\n \n-            if tcx.hir().opt_const_param_default_param_def_id(hir_id).is_some() {\n+            if let Some(defaulted_param_def_id) =\n+                tcx.hir().opt_const_param_default_param_def_id(hir_id)\n+            {\n                 // In `generics_of` we set the generics' parent to be our parent's parent which means that\n                 // we lose out on the predicates of our actual parent if we dont return those predicates here.\n                 // (See comment in `generics_of` for more information on why the parent shenanigans is necessary)\n@@ -452,7 +467,39 @@ pub(super) fn explicit_predicates_of<'tcx>(\n                 //\n                 // In the above code we want the anon const to have predicates in its param env for `T: Trait`\n                 // and we would be calling `explicit_predicates_of(Foo)` here\n-                return tcx.explicit_predicates_of(parent_def_id);\n+                let parent_preds = tcx.explicit_predicates_of(parent_def_id);\n+\n+                // If we dont filter out `ConstArgHasType` predicates then every single defaulted const parameter\n+                // will ICE because of #106994. FIXME(generic_const_exprs): remove this when a more general solution\n+                // to #106994 is implemented.\n+                let filtered_predicates = parent_preds\n+                    .predicates\n+                    .into_iter()\n+                    .filter(|(pred, _)| {\n+                        if let ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, _)) =\n+                            pred.kind().skip_binder()\n+                        {\n+                            match ct.kind() {\n+                                ty::ConstKind::Param(param_const) => {\n+                                    let defaulted_param_idx = tcx\n+                                        .generics_of(parent_def_id)\n+                                        .param_def_id_to_index[&defaulted_param_def_id.to_def_id()];\n+                                    param_const.index < defaulted_param_idx\n+                                }\n+                                _ => bug!(\n+                                    \"`ConstArgHasType` in `predicates_of`\\\n+                                 that isn't a `Param` const\"\n+                                ),\n+                            }\n+                        } else {\n+                            true\n+                        }\n+                    })\n+                    .cloned();\n+                return GenericPredicates {\n+                    parent: parent_preds.parent,\n+                    predicates: { tcx.arena.alloc_from_iter(filtered_predicates) },\n+                };\n             }\n \n             let parent_def_kind = tcx.def_kind(parent_def_id);"}, {"sha": "4741e4b095d22afc0bee5cee96d203719457da3e", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/90c8d6bbe4725ca83e79e73e9cdf1f66840db79f/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c8d6bbe4725ca83e79e73e9cdf1f66840db79f/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=90c8d6bbe4725ca83e79e73e9cdf1f66840db79f", "patch": "@@ -496,6 +496,16 @@ fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tc\n                 )\n                 .emit();\n         }\n+        ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..)) => {\n+            // FIXME(min_specialization), FIXME(const_generics):\n+            // It probably isn't right to allow _every_ `ConstArgHasType` but I am somewhat unsure\n+            // about the actual rules that would be sound. Can't just always error here because otherwise\n+            // std/core doesn't even compile as they have `const N: usize` in some specializing impls.\n+            //\n+            // While we do not support constructs like `<T, const N: T>` there is probably no risk of\n+            // soundness bugs, but when we support generic const parameter types this will need to be\n+            // revisited.\n+        }\n         _ => {\n             tcx.sess\n                 .struct_span_err(span, &format!(\"cannot specialize on predicate `{}`\", predicate))"}, {"sha": "58dfca75c65f7188d6ae6be8a11847042101740b", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/90c8d6bbe4725ca83e79e73e9cdf1f66840db79f/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c8d6bbe4725ca83e79e73e9cdf1f66840db79f/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=90c8d6bbe4725ca83e79e73e9cdf1f66840db79f", "patch": "@@ -159,9 +159,21 @@ where\n                 _region,\n             ))) => ty.visit_with(self),\n             ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..)) => ControlFlow::Continue(()),\n+            ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n+                ct.visit_with(self)?;\n+                ty.visit_with(self)\n+            }\n             ty::PredicateKind::ConstEvaluatable(ct) => ct.visit_with(self),\n             ty::PredicateKind::WellFormed(arg) => arg.visit_with(self),\n-            _ => bug!(\"unexpected predicate: {:?}\", predicate),\n+\n+            ty::PredicateKind::ObjectSafe(_)\n+            | ty::PredicateKind::ClosureKind(_, _, _)\n+            | ty::PredicateKind::Subtype(_)\n+            | ty::PredicateKind::Coerce(_)\n+            | ty::PredicateKind::ConstEquate(_, _)\n+            | ty::PredicateKind::TypeWellFormedFromEnv(_)\n+            | ty::PredicateKind::Ambiguous\n+            | ty::PredicateKind::AliasEq(_, _) => bug!(\"unexpected predicate: {:?}\", predicate),\n         }\n     }\n "}, {"sha": "6890811fd046e581898138c7e2da3a19540087b4", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/90c8d6bbe4725ca83e79e73e9cdf1f66840db79f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c8d6bbe4725ca83e79e73e9cdf1f66840db79f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=90c8d6bbe4725ca83e79e73e9cdf1f66840db79f", "patch": "@@ -25,7 +25,7 @@ use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::Obligation;\n use rustc_middle::infer::canonical::Certainty as OldCertainty;\n use rustc_middle::traits::solve::{ExternalConstraints, ExternalConstraintsData};\n-use rustc_middle::ty::{self, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{\n     CoercePredicate, RegionOutlivesPredicate, SubtypePredicate, ToPredicate, TypeOutlivesPredicate,\n };\n@@ -290,8 +290,8 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 ty::PredicateKind::Clause(ty::Clause::RegionOutlives(predicate)) => {\n                     self.compute_region_outlives_goal(Goal { param_env, predicate })\n                 }\n-                ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..)) => {\n-                    unimplemented!()\n+                ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n+                    self.compute_const_arg_has_type_goal(Goal { param_env, predicate: (ct, ty) })\n                 }\n                 ty::PredicateKind::Subtype(predicate) => {\n                     self.compute_subtype_goal(Goal { param_env, predicate })\n@@ -474,6 +474,16 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    fn compute_const_arg_has_type_goal(\n+        &mut self,\n+        goal: Goal<'tcx, (ty::Const<'tcx>, Ty<'tcx>)>,\n+    ) -> QueryResult<'tcx> {\n+        let (ct, ty) = goal.predicate;\n+        let nested_goals = self.infcx.eq(goal.param_env, ct.ty(), ty)?;\n+        self.evaluate_all_and_make_canonical_response(nested_goals)\n+    }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {"}, {"sha": "2511e9a955a56471709e8206a75c49c19eaa861a", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/90c8d6bbe4725ca83e79e73e9cdf1f66840db79f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c8d6bbe4725ca83e79e73e9cdf1f66840db79f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=90c8d6bbe4725ca83e79e73e9cdf1f66840db79f", "patch": "@@ -1283,9 +1283,11 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         \"AliasEq predicate should never be the predicate cause of a SelectionError\"\n                     ),\n \n-                    ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..)) => {\n-                        // FIXME: don't know how selection error works so unsure when this is reachable (if it is)\n-                        unimplemented!()\n+                    ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n+                        self.tcx.sess.struct_span_err(\n+                            span,\n+                            &format!(\"the constant `{}` is not of type `{}`\", ct, ty),\n+                        )\n                     }\n                 }\n             }"}, {"sha": "deeed930e50e240a88e7858a87fe74283c45902f", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/90c8d6bbe4725ca83e79e73e9cdf1f66840db79f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c8d6bbe4725ca83e79e73e9cdf1f66840db79f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=90c8d6bbe4725ca83e79e73e9cdf1f66840db79f", "patch": "@@ -601,8 +601,18 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 ty::PredicateKind::AliasEq(..) => {\n                     bug!(\"AliasEq is only used for new solver\")\n                 }\n-                ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..)) => {\n-                    unimplemented!()\n+                ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n+                    match self\n+                        .selcx\n+                        .infcx\n+                        .at(&obligation.cause, obligation.param_env)\n+                        .eq(ct.ty(), ty)\n+                    {\n+                        Ok(inf_ok) => ProcessResult::Changed(mk_pending(inf_ok.into_obligations())),\n+                        Err(_) => ProcessResult::Error(FulfillmentErrorCode::CodeSelectionError(\n+                            SelectionError::Unimplemented,\n+                        )),\n+                    }\n                 }\n             },\n         }"}, {"sha": "e6fc9bb92397941443689ac1dcf793ffdacf4445", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/90c8d6bbe4725ca83e79e73e9cdf1f66840db79f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c8d6bbe4725ca83e79e73e9cdf1f66840db79f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=90c8d6bbe4725ca83e79e73e9cdf1f66840db79f", "patch": "@@ -993,8 +993,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     bug!(\"AliasEq is only used for new solver\")\n                 }\n                 ty::PredicateKind::Ambiguous => Ok(EvaluatedToAmbig),\n-                ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..)) => {\n-                    unimplemented!()\n+                ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n+                    match self.infcx.at(&obligation.cause, obligation.param_env).eq(ct.ty(), ty) {\n+                        Ok(inf_ok) => self.evaluate_predicates_recursively(\n+                            previous_stack,\n+                            inf_ok.into_obligations(),\n+                        ),\n+                        Err(_) => Ok(EvaluatedToErr),\n+                    }\n                 }\n             }\n         })"}, {"sha": "257a9e31e14b2a842cae9abf99bded3f33dc30fc", "filename": "tests/ui/const-generics/nested-type.min.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/90c8d6bbe4725ca83e79e73e9cdf1f66840db79f/tests%2Fui%2Fconst-generics%2Fnested-type.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/90c8d6bbe4725ca83e79e73e9cdf1f66840db79f/tests%2Fui%2Fconst-generics%2Fnested-type.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fnested-type.min.stderr?ref=90c8d6bbe4725ca83e79e73e9cdf1f66840db79f", "patch": "@@ -1,3 +1,11 @@\n+error[E0015]: cannot call non-const fn `Foo::{constant#0}::Foo::<17>::value` in constants\n+  --> $DIR/nested-type.rs:15:5\n+   |\n+LL |     Foo::<17>::value()\n+   |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n+\n error: `[u8; {\n            struct Foo<const N: usize>;\n        \n@@ -24,5 +32,6 @@ LL | | }]>;\n    = note: the only supported types are integers, `bool` and `char`\n    = help: more complex types are supported with `#![feature(adt_const_params)]`\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0015`."}, {"sha": "5240f5c3b0b64b8d4cc3919b3cd167ecdfb3ce15", "filename": "tests/ui/const-generics/nested-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90c8d6bbe4725ca83e79e73e9cdf1f66840db79f/tests%2Fui%2Fconst-generics%2Fnested-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c8d6bbe4725ca83e79e73e9cdf1f66840db79f/tests%2Fui%2Fconst-generics%2Fnested-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fnested-type.rs?ref=90c8d6bbe4725ca83e79e73e9cdf1f66840db79f", "patch": "@@ -13,7 +13,7 @@ struct Foo<const N: [u8; { //[min]~ ERROR `[u8; _]` is forbidden\n     }\n \n     Foo::<17>::value()\n-    //[full]~^ ERROR cannot call non-const fn\n+    //~^ ERROR cannot call non-const fn\n }]>;\n \n fn main() {}"}]}