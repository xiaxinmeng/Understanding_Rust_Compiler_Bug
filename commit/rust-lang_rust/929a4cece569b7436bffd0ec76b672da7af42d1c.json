{"sha": "929a4cece569b7436bffd0ec76b672da7af42d1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyOWE0Y2VjZTU2OWI3NDM2YmZmZDBlYzc2YjY3MmRhN2FmNDJkMWM=", "commit": {"author": {"name": "Oliver Schneider", "email": "public.oliver.schneider@kit.edu", "date": "2018-01-29T14:12:45Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-03-08T07:34:14Z"}, "message": "Use IndexVec instead of FxHashMap", "tree": {"sha": "7693b4599981c98ae219f037cf474562a78dac3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7693b4599981c98ae219f037cf474562a78dac3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/929a4cece569b7436bffd0ec76b672da7af42d1c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlqg53YACgkQpp+NIls6\n19ngeg//ZkxefTs1bnsBNLnFILz2LbXR+KOPmtApIKUTofqOc2owUutz+kB0lvCe\n0sQZwF9EfoVHWzi9v8T3NNfWP4QEVxrvMELXVtZ2K2M4K+PDJGCcFjArhXQF8m1F\nnKTmCIJZfP91+bqMMjnxvn3R/wGj5NhL3za156vYbogHfjuAtOpG+zE5rW7i/z44\nA/h8DII9YvXvkHoE2cLRCIC+MceKp+NqdIYAX3nar47UIAD+VjtgXHUtfNKwv8U+\n2A+vFdRWnuVYjsVJxGGtjDk5vAV7H6mvEsT+FUUfSLDYGwLqaKw4weZMHKfoarEz\nLbHlE5xvbnCxZtdzOWESUUd3btHtQolZBP0FaNwY39VctHxx/EvASlizvM3jJur6\naIca8zt/A1LcAlWmrj0GcSCdQCQ8bveFXo5r+P2fmMf+1oZGztmJSmndQIgxKllV\n84XosSySr/AX2CmdWNk3eHv8evwrvu9f2LN3zbisRGnTqvXtGnwAAOxuIVm+Q9sa\nU8L0NdeaGUzF41WQN1LKU0/zVIEMrs7SJZTgvQbR72Kn5Ft2MNUD7wgenDr/skPN\nLvJNxyDeccNeJ9FH1iKglvDdCVYVlH6yh3TcXRDJRh+ZR3WENIrIL5azHphmTPDs\nHUWxzTumMMw33AKDsEZ2KCaoTi/lD+WLwgcsliwjrDU/a/vWSMY=\n=yIj2\n-----END PGP SIGNATURE-----", "payload": "tree 7693b4599981c98ae219f037cf474562a78dac3a\nparent 8c8a4335323c3c5fe917aff4ba4acb22804abf3e\nauthor Oliver Schneider <public.oliver.schneider@kit.edu> 1517235165 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1520494454 +0100\n\nUse IndexVec instead of FxHashMap\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/929a4cece569b7436bffd0ec76b672da7af42d1c", "html_url": "https://github.com/rust-lang/rust/commit/929a4cece569b7436bffd0ec76b672da7af42d1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/929a4cece569b7436bffd0ec76b672da7af42d1c/comments", "author": null, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c8a4335323c3c5fe917aff4ba4acb22804abf3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c8a4335323c3c5fe917aff4ba4acb22804abf3e", "html_url": "https://github.com/rust-lang/rust/commit/8c8a4335323c3c5fe917aff4ba4acb22804abf3e"}], "stats": {"total": 43, "additions": 19, "deletions": 24}, "files": [{"sha": "e1a1c47373015c25fcd1cb892ba6a1d767206533", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/929a4cece569b7436bffd0ec76b672da7af42d1c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/929a4cece569b7436bffd0ec76b672da7af42d1c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=929a4cece569b7436bffd0ec76b672da7af42d1c", "patch": "@@ -15,16 +15,17 @@\n \n use rustc::mir::{Constant, Literal, Location, Place, Mir, Operand, Rvalue, Local};\n use rustc::mir::{NullOp, StatementKind, Statement, BasicBlock, LocalKind};\n-use rustc::mir::TerminatorKind;\n+use rustc::mir::{TerminatorKind, ClearCrossCrate, SourceInfo};\n use rustc::mir::visit::Visitor;\n+use rustc::ty::layout::LayoutOf;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{TyCtxt, self, Instance};\n use rustc::mir::interpret::{Value, PrimVal, GlobalId};\n use interpret::{eval_body_with_mir, eval_body, mk_borrowck_eval_cx, unary_op, ValTy};\n-use rustc::util::nodemap::FxHashMap;\n use transform::{MirPass, MirSource};\n use syntax::codemap::Span;\n use rustc::ty::subst::Substs;\n+use rustc_data_structures::indexed_vec::IndexVec;\n \n pub struct ConstProp;\n \n@@ -35,9 +36,10 @@ impl MirPass for ConstProp {\n                           mir: &mut Mir<'tcx>) {\n         trace!(\"ConstProp starting for {:?}\", source.def_id);\n \n-        // First, find optimization opportunities. This is done in a pre-pass to keep the MIR\n-        // read-only so that we can do global analyses on the MIR in the process (e.g.\n-        // `Place::ty()`).\n+        // FIXME(oli-obk, eddyb) Optimize locals (or even local paths) to hold\n+        // constants, instead of just checking for const-folding succeeding.\n+        // That would require an uniform one-def no-mutation analysis\n+        // and RPO (or recursing when needing the value of a local).\n         let mut optimization_finder = OptimizationFinder::new(mir, tcx, source);\n         optimization_finder.visit_mir(mir);\n \n@@ -52,7 +54,7 @@ struct OptimizationFinder<'b, 'a, 'tcx:'a+'b> {\n     mir: &'b Mir<'tcx>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     source: MirSource,\n-    places: FxHashMap<Local, Const<'tcx>>,\n+    places: IndexVec<Local, Option<Const<'tcx>>>,\n }\n \n impl<'b, 'a, 'tcx:'b> OptimizationFinder<'b, 'a, 'tcx> {\n@@ -65,7 +67,7 @@ impl<'b, 'a, 'tcx:'b> OptimizationFinder<'b, 'a, 'tcx> {\n             mir,\n             tcx,\n             source,\n-            places: FxHashMap::default(),\n+            places: IndexVec::from_elem(None, &mir.local_decls),\n         }\n     }\n \n@@ -117,7 +119,7 @@ impl<'b, 'a, 'tcx:'b> OptimizationFinder<'b, 'a, 'tcx> {\n         match *op {\n             Operand::Constant(ref c) => self.eval_constant(c),\n             Operand::Move(ref place) | Operand::Copy(ref place) => match *place {\n-                Place::Local(loc) => self.places.get(&loc).cloned(),\n+                Place::Local(loc) => self.places[loc].clone(),\n                 // FIXME(oli-obk): field and index projections\n                 Place::Projection(_) => None,\n                 _ => None,\n@@ -129,8 +131,9 @@ impl<'b, 'a, 'tcx:'b> OptimizationFinder<'b, 'a, 'tcx> {\n         &mut self,\n         rvalue: &Rvalue<'tcx>,\n         place_ty: ty::Ty<'tcx>,\n-        span: Span,\n+        source_info: SourceInfo,\n     ) -> Option<Const<'tcx>> {\n+        let span = source_info.span;\n         match *rvalue {\n             // No need to overwrite an already evaluated constant\n             Rvalue::Use(Operand::Constant(box Constant {\n@@ -213,20 +216,12 @@ impl<'b, 'a, 'tcx:'b> OptimizationFinder<'b, 'a, 'tcx> {\n                 let ecx = mk_borrowck_eval_cx(self.tcx, instance, self.mir, span).unwrap();\n \n                 let r = ecx.value_to_primval(ValTy { value: right.0, ty: right.1 }).ok()?;\n-                let param_env = ParamEnv::empty(traits::Reveal::All);\n-                let bits = (self.tcx, param_env).layout_of(left.ty).unwrap().size.bits();\n-                if r >= bits as u128 {\n-                    let data = &self.mir[location.block];\n-                    let stmt_idx = location.statement_index;\n-                    let source_info = if stmt_idx < data.statements.len() {\n-                        data.statements[stmt_idx].source_info\n-                    } else {\n-                        data.terminator().source_info\n-                    };\n-                    let span = source_info.span;\n+                let param_env = self.tcx.param_env(self.source.def_id);\n+                let bits = (self.tcx, param_env).layout_of(left.1).unwrap().size.bits();\n+                if r.to_bytes().ok()? >= bits as u128 {\n                     let scope_info = match self.mir.visibility_scope_info {\n                         ClearCrossCrate::Set(ref data) => data,\n-                        ClearCrossCrate::Clear => return,\n+                        ClearCrossCrate::Clear => return None,\n                     };\n                     let node_id = scope_info[source_info.scope].lint_root;\n                     self.tcx.lint_node(\n@@ -369,13 +364,13 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n             let place_ty = place\n                 .ty(&self.mir.local_decls, self.tcx)\n                 .to_ty(self.tcx);\n-            let span = statement.source_info.span;\n-            if let Some(value) = self.const_prop(rval, place_ty, span) {\n+            if let Some(value) = self.const_prop(rval, place_ty, statement.source_info) {\n                 if let Place::Local(local) = *place {\n                     if self.mir.local_kind(local) == LocalKind::Temp\n                         && CanConstProp::check(local, self.mir) {\n                         trace!(\"storing {:?} to {:?}\", value, local);\n-                        assert!(self.places.insert(local, value).is_none());\n+                        assert!(self.places[local].is_none());\n+                        self.places[local] = Some(value);\n                     }\n                 }\n             }"}]}