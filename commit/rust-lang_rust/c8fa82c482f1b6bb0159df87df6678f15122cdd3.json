{"sha": "c8fa82c482f1b6bb0159df87df6678f15122cdd3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4ZmE4MmM0ODJmMWI2YmIwMTU5ZGY4N2RmNjY3OGYxNTEyMmNkZDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-16T20:49:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-16T20:49:27Z"}, "message": "Auto merge of #63756 - Zoxc:sharded-dep-graph-1, r=nikomatsakis\n\nUse more fine grained locks for the dep graph\n\nSplit out from https://github.com/rust-lang/rust/pull/61845.\n\nr? @michaelwoerister cc @aturon", "tree": {"sha": "7d1ff51e6e1e3108b29bf3e20682eb9643afdaf8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d1ff51e6e1e3108b29bf3e20682eb9643afdaf8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8fa82c482f1b6bb0159df87df6678f15122cdd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8fa82c482f1b6bb0159df87df6678f15122cdd3", "html_url": "https://github.com/rust-lang/rust/commit/c8fa82c482f1b6bb0159df87df6678f15122cdd3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8fa82c482f1b6bb0159df87df6678f15122cdd3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e8a4b441c5da21a2cb19448728ade5baa299c66", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e8a4b441c5da21a2cb19448728ade5baa299c66", "html_url": "https://github.com/rust-lang/rust/commit/0e8a4b441c5da21a2cb19448728ade5baa299c66"}, {"sha": "b6a5740117a66b59a00a40bbfbce6e4f378825de", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6a5740117a66b59a00a40bbfbce6e4f378825de", "html_url": "https://github.com/rust-lang/rust/commit/b6a5740117a66b59a00a40bbfbce6e4f378825de"}], "stats": {"total": 132, "additions": 72, "deletions": 60}, "files": [{"sha": "5d2d30f8debb3f0030ef1fdd213b589b94eeb731", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 72, "deletions": 60, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/c8fa82c482f1b6bb0159df87df6678f15122cdd3/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8fa82c482f1b6bb0159df87df6678f15122cdd3/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=c8fa82c482f1b6bb0159df87df6678f15122cdd3", "patch": "@@ -3,7 +3,8 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::vec::{Idx, IndexVec};\n use smallvec::SmallVec;\n-use rustc_data_structures::sync::{Lrc, Lock, AtomicU32, Ordering};\n+use rustc_data_structures::sync::{Lrc, Lock, AtomicU32, AtomicU64, Ordering};\n+use std::sync::atomic::Ordering::SeqCst;\n use std::env;\n use std::hash::Hash;\n use std::collections::hash_map::Entry;\n@@ -53,7 +54,7 @@ struct DepGraphData {\n     /// tracking. The `current` field is the dependency graph of only the\n     /// current compilation session: We don't merge the previous dep-graph into\n     /// current one anymore.\n-    current: Lock<CurrentDepGraph>,\n+    current: CurrentDepGraph,\n \n     /// The dep-graph from the previous compilation session. It contains all\n     /// nodes and edges as well as all fingerprints of nodes that have them.\n@@ -95,7 +96,7 @@ impl DepGraph {\n             data: Some(Lrc::new(DepGraphData {\n                 previous_work_products: prev_work_products,\n                 dep_node_debug: Default::default(),\n-                current: Lock::new(CurrentDepGraph::new(prev_graph_node_count)),\n+                current: CurrentDepGraph::new(prev_graph_node_count),\n                 emitting_diagnostics: Default::default(),\n                 emitting_diagnostics_cond_var: Condvar::new(),\n                 previous: prev_graph,\n@@ -117,13 +118,12 @@ impl DepGraph {\n     }\n \n     pub fn query(&self) -> DepGraphQuery {\n-        let current_dep_graph = self.data.as_ref().unwrap().current.borrow();\n-        let nodes: Vec<_> = current_dep_graph.data.iter().map(|n| n.node).collect();\n+        let data = self.data.as_ref().unwrap().current.data.lock();\n+        let nodes: Vec<_> = data.iter().map(|n| n.node).collect();\n         let mut edges = Vec::new();\n-        for (from, edge_targets) in current_dep_graph.data.iter()\n-                                                           .map(|d| (d.node, &d.edges)) {\n+        for (from, edge_targets) in data.iter().map(|d| (d.node, &d.edges)) {\n             for &edge_target in edge_targets.iter() {\n-                let to = current_dep_graph.data[edge_target].node;\n+                let to = data[edge_target].node;\n                 edges.push((from, to));\n             }\n         }\n@@ -202,7 +202,7 @@ impl DepGraph {\n                 read_set: Default::default(),\n             }),\n             |data, key, fingerprint, task| {\n-                data.borrow_mut().complete_task(key, task.unwrap(), fingerprint)\n+                data.complete_task(key, task.unwrap(), fingerprint)\n             },\n             hash_result)\n     }\n@@ -223,7 +223,7 @@ impl DepGraph {\n         self.with_task_impl(key, cx, input, true, identity_fn,\n             |_| None,\n             |data, key, fingerprint, _| {\n-                data.borrow_mut().alloc_node(key, SmallVec::new(), fingerprint)\n+                data.alloc_node(key, SmallVec::new(), fingerprint)\n             },\n             hash_result::<R>)\n     }\n@@ -236,7 +236,7 @@ impl DepGraph {\n         no_tcx: bool,\n         task: fn(C, A) -> R,\n         create_task: fn(DepNode) -> Option<TaskDeps>,\n-        finish_task_and_alloc_depnode: fn(&Lock<CurrentDepGraph>,\n+        finish_task_and_alloc_depnode: fn(&CurrentDepGraph,\n                                           DepNode,\n                                           Fingerprint,\n                                           Option<TaskDeps>) -> DepNodeIndex,\n@@ -350,7 +350,6 @@ impl DepGraph {\n                 (r, task_deps.into_inner())\n             });\n             let dep_node_index = data.current\n-                                     .borrow_mut()\n                                      .complete_anon_task(dep_kind, task_deps);\n             (result, dep_node_index)\n         } else {\n@@ -374,18 +373,17 @@ impl DepGraph {\n         self.with_task_impl(key, cx, arg, false, task,\n             |_| None,\n             |data, key, fingerprint, _| {\n-                let mut current = data.borrow_mut();\n-                current.alloc_node(key, smallvec![], fingerprint)\n+                data.alloc_node(key, smallvec![], fingerprint)\n             },\n             hash_result)\n     }\n \n     #[inline]\n     pub fn read(&self, v: DepNode) {\n         if let Some(ref data) = self.data {\n-            let current = data.current.borrow_mut();\n-            if let Some(&dep_node_index) = current.node_to_node_index.get(&v) {\n-                std::mem::drop(current);\n+            let map = data.current.node_to_node_index.lock();\n+            if let Some(dep_node_index) = map.get(&v).copied() {\n+                std::mem::drop(map);\n                 data.read_index(dep_node_index);\n             } else {\n                 bug!(\"DepKind {:?} should be pre-allocated but isn't.\", v.kind)\n@@ -406,8 +404,8 @@ impl DepGraph {\n             .as_ref()\n             .unwrap()\n             .current\n-            .borrow_mut()\n             .node_to_node_index\n+            .lock()\n             .get(dep_node)\n             .cloned()\n             .unwrap()\n@@ -416,16 +414,16 @@ impl DepGraph {\n     #[inline]\n     pub fn dep_node_exists(&self, dep_node: &DepNode) -> bool {\n         if let Some(ref data) = self.data {\n-            data.current.borrow_mut().node_to_node_index.contains_key(dep_node)\n+            data.current.node_to_node_index.lock().contains_key(dep_node)\n         } else {\n             false\n         }\n     }\n \n     #[inline]\n     pub fn fingerprint_of(&self, dep_node_index: DepNodeIndex) -> Fingerprint {\n-        let current = self.data.as_ref().expect(\"dep graph enabled\").current.borrow_mut();\n-        current.data[dep_node_index].fingerprint\n+        let data = self.data.as_ref().expect(\"dep graph enabled\").current.data.lock();\n+        data[dep_node_index].fingerprint\n     }\n \n     pub fn prev_fingerprint_of(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n@@ -479,32 +477,29 @@ impl DepGraph {\n \n     pub fn edge_deduplication_data(&self) -> Option<(u64, u64)> {\n         if cfg!(debug_assertions) {\n-            let current_dep_graph = self.data.as_ref().unwrap().current.borrow();\n+            let current_dep_graph = &self.data.as_ref().unwrap().current;\n \n-            Some((current_dep_graph.total_read_count,\n-                  current_dep_graph.total_duplicate_read_count))\n+            Some((current_dep_graph.total_read_count.load(SeqCst),\n+                  current_dep_graph.total_duplicate_read_count.load(SeqCst)))\n         } else {\n             None\n         }\n     }\n \n     pub fn serialize(&self) -> SerializedDepGraph {\n-        let current_dep_graph = self.data.as_ref().unwrap().current.borrow();\n+        let data = self.data.as_ref().unwrap().current.data.lock();\n \n         let fingerprints: IndexVec<SerializedDepNodeIndex, _> =\n-            current_dep_graph.data.iter().map(|d| d.fingerprint).collect();\n+            data.iter().map(|d| d.fingerprint).collect();\n         let nodes: IndexVec<SerializedDepNodeIndex, _> =\n-            current_dep_graph.data.iter().map(|d| d.node).collect();\n+            data.iter().map(|d| d.node).collect();\n \n-        let total_edge_count: usize = current_dep_graph.data.iter()\n-                                                            .map(|d| d.edges.len())\n-                                                            .sum();\n+        let total_edge_count: usize = data.iter().map(|d| d.edges.len()).sum();\n \n         let mut edge_list_indices = IndexVec::with_capacity(nodes.len());\n         let mut edge_list_data = Vec::with_capacity(total_edge_count);\n \n-        for (current_dep_node_index, edges) in current_dep_graph.data.iter_enumerated()\n-                                                                .map(|(i, d)| (i, &d.edges)) {\n+        for (current_dep_node_index, edges) in data.iter_enumerated().map(|(i, d)| (i, &d.edges)) {\n             let start = edge_list_data.len() as u32;\n             // This should really just be a memcpy :/\n             edge_list_data.extend(edges.iter().map(|i| SerializedDepNodeIndex::new(i.index())));\n@@ -600,7 +595,7 @@ impl DepGraph {\n \n         #[cfg(not(parallel_compiler))]\n         {\n-            debug_assert!(!data.current.borrow().node_to_node_index.contains_key(dep_node));\n+            debug_assert!(!data.current.node_to_node_index.lock().contains_key(dep_node));\n             debug_assert!(data.colors.get(prev_dep_node_index).is_none());\n         }\n \n@@ -733,15 +728,13 @@ impl DepGraph {\n         // There may be multiple threads trying to mark the same dep node green concurrently\n \n         let dep_node_index = {\n-            let mut current = data.current.borrow_mut();\n-\n             // Copy the fingerprint from the previous graph,\n             // so we don't have to recompute it\n             let fingerprint = data.previous.fingerprint_by_index(prev_dep_node_index);\n \n             // We allocating an entry for the node in the current dependency graph and\n             // adding all the appropriate edges imported from the previous graph\n-            current.intern_node(*dep_node, current_deps, fingerprint)\n+            data.current.intern_node(*dep_node, current_deps, fingerprint)\n         };\n \n         // ... emitting any stored diagnostic ...\n@@ -917,9 +910,27 @@ struct DepNodeData {\n     fingerprint: Fingerprint,\n }\n \n+/// `CurrentDepGraph` stores the dependency graph for the current session.\n+/// It will be populated as we run queries or tasks.\n+///\n+/// The nodes in it are identified by an index (`DepNodeIndex`).\n+/// The data for each node is stored in its `DepNodeData`, found in the `data` field.\n+///\n+/// We never remove nodes from the graph: they are only added.\n+///\n+/// This struct uses two locks internally. The `data` and `node_to_node_index` fields are\n+/// locked separately. Operations that take a `DepNodeIndex` typically just access\n+/// the data field.\n+///\n+/// The only operation that must manipulate both locks is adding new nodes, in which case\n+/// we first acquire the `node_to_node_index` lock and then, once a new node is to be inserted,\n+/// acquire the lock on `data.`\n pub(super) struct CurrentDepGraph {\n-    data: IndexVec<DepNodeIndex, DepNodeData>,\n-    node_to_node_index: FxHashMap<DepNode, DepNodeIndex>,\n+    data: Lock<IndexVec<DepNodeIndex, DepNodeData>>,\n+    node_to_node_index: Lock<FxHashMap<DepNode, DepNodeIndex>>,\n+\n+    /// Used to trap when a specific edge is added to the graph.\n+    /// This is used for debug purposes and is only active with `debug_assertions`.\n     #[allow(dead_code)]\n     forbidden_edge: Option<EdgeFilter>,\n \n@@ -936,8 +947,10 @@ pub(super) struct CurrentDepGraph {\n     /// the `DepGraph` is created.\n     anon_id_seed: Fingerprint,\n \n-    total_read_count: u64,\n-    total_duplicate_read_count: u64,\n+    /// These are simple counters that are for profiling and\n+    /// debugging and only active with `debug_assertions`.\n+    total_read_count: AtomicU64,\n+    total_duplicate_read_count: AtomicU64,\n }\n \n impl CurrentDepGraph {\n@@ -971,28 +984,28 @@ impl CurrentDepGraph {\n         let new_node_count_estimate = (prev_graph_node_count * 102) / 100 + 200;\n \n         CurrentDepGraph {\n-            data: IndexVec::with_capacity(new_node_count_estimate),\n-            node_to_node_index: FxHashMap::with_capacity_and_hasher(\n+            data: Lock::new(IndexVec::with_capacity(new_node_count_estimate)),\n+            node_to_node_index: Lock::new(FxHashMap::with_capacity_and_hasher(\n                 new_node_count_estimate,\n                 Default::default(),\n-            ),\n+            )),\n             anon_id_seed: stable_hasher.finish(),\n             forbidden_edge,\n-            total_read_count: 0,\n-            total_duplicate_read_count: 0,\n+            total_read_count: AtomicU64::new(0),\n+            total_duplicate_read_count: AtomicU64::new(0),\n         }\n     }\n \n     fn complete_task(\n-        &mut self,\n+        &self,\n         node: DepNode,\n         task_deps: TaskDeps,\n         fingerprint: Fingerprint\n     ) -> DepNodeIndex {\n         self.alloc_node(node, task_deps.reads, fingerprint)\n     }\n \n-    fn complete_anon_task(&mut self, kind: DepKind, task_deps: TaskDeps) -> DepNodeIndex {\n+    fn complete_anon_task(&self, kind: DepKind, task_deps: TaskDeps) -> DepNodeIndex {\n         debug_assert!(!kind.is_eval_always());\n \n         let mut hasher = StableHasher::new();\n@@ -1017,28 +1030,27 @@ impl CurrentDepGraph {\n     }\n \n     fn alloc_node(\n-        &mut self,\n+        &self,\n         dep_node: DepNode,\n         edges: SmallVec<[DepNodeIndex; 8]>,\n         fingerprint: Fingerprint\n     ) -> DepNodeIndex {\n-        debug_assert!(!self.node_to_node_index.contains_key(&dep_node));\n+        debug_assert!(!self.node_to_node_index.lock().contains_key(&dep_node));\n         self.intern_node(dep_node, edges, fingerprint)\n     }\n \n     fn intern_node(\n-        &mut self,\n+        &self,\n         dep_node: DepNode,\n         edges: SmallVec<[DepNodeIndex; 8]>,\n         fingerprint: Fingerprint\n     ) -> DepNodeIndex {\n-        debug_assert_eq!(self.node_to_node_index.len(), self.data.len());\n-\n-        match self.node_to_node_index.entry(dep_node) {\n+        match self.node_to_node_index.lock().entry(dep_node) {\n             Entry::Occupied(entry) => *entry.get(),\n             Entry::Vacant(entry) => {\n-                let dep_node_index = DepNodeIndex::new(self.data.len());\n-                self.data.push(DepNodeData {\n+                let mut data = self.data.lock();\n+                let dep_node_index = DepNodeIndex::new(data.len());\n+                data.push(DepNodeData {\n                     node: dep_node,\n                     edges,\n                     fingerprint\n@@ -1057,17 +1069,17 @@ impl DepGraphData {\n             if let Some(task_deps) = icx.task_deps {\n                 let mut task_deps = task_deps.lock();\n                 if cfg!(debug_assertions) {\n-                    self.current.lock().total_read_count += 1;\n+                    self.current.total_read_count.fetch_add(1, SeqCst);\n                 }\n                 if task_deps.read_set.insert(source) {\n                     task_deps.reads.push(source);\n \n                     #[cfg(debug_assertions)]\n                     {\n                         if let Some(target) = task_deps.node {\n-                            let graph = self.current.lock();\n-                            if let Some(ref forbidden_edge) = graph.forbidden_edge {\n-                                let source = graph.data[source].node;\n+                            let data = self.current.data.lock();\n+                            if let Some(ref forbidden_edge) = self.current.forbidden_edge {\n+                                let source = data[source].node;\n                                 if forbidden_edge.test(&source, &target) {\n                                     bug!(\"forbidden edge {:?} -> {:?} created\",\n                                         source,\n@@ -1077,7 +1089,7 @@ impl DepGraphData {\n                         }\n                     }\n                 } else if cfg!(debug_assertions) {\n-                    self.current.lock().total_duplicate_read_count += 1;\n+                    self.current.total_duplicate_read_count.fetch_add(1, SeqCst);\n                 }\n             }\n         })"}]}