{"sha": "93fb12e3d0644f6a8ddfa2ac1d6b0a1d8341e287", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzZmIxMmUzZDA2NDRmNmE4ZGRmYTJhYzFkNmIwYTFkODM0MWUyODc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-17T08:01:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-17T08:01:56Z"}, "message": "auto merge of #11498 : c-a/rust/optimize_vuint_at, r=alexcrichton\n\nUse a lookup table, SHIFT_MASK_TABLE, that for every possible four\r\nbit prefix holds the number of times the value should be right shifted and what\r\nthe right shifted value should be masked with. This way we can get rid of the\r\nbranches which in my testing gives approximately a 2x speedup.\r\n\r\nTimings on Intel(R) Core(TM) i5-3570K CPU @ 3.40GHz\r\n\r\n-- Before --\r\nrunning 5 tests\r\ntest ebml::tests::test_vuint_at ... ok\r\ntest ebml::bench::vuint_at_A_aligned          ... bench:       494 ns/iter (+/- 3)\r\ntest ebml::bench::vuint_at_A_unaligned        ... bench:       494 ns/iter (+/- 4)\r\ntest ebml::bench::vuint_at_D_aligned          ... bench:       467 ns/iter (+/- 5)\r\ntest ebml::bench::vuint_at_D_unaligned        ... bench:       467 ns/iter (+/- 5)\r\n\r\n-- After --\r\nrunning 5 tests\r\ntest ebml::tests::test_vuint_at ... ok\r\ntest ebml::bench::vuint_at_A_aligned ... bench: 181 ns/iter (+/- 2)\r\ntest ebml::bench::vuint_at_A_unaligned ... bench: 192 ns/iter (+/- 1)\r\ntest ebml::bench::vuint_at_D_aligned ... bench: 181 ns/iter (+/- 3)\r\ntest ebml::bench::vuint_at_D_unaligned ... bench: 197 ns/iter (+/- 6)", "tree": {"sha": "172385992ea44c1eeb621c3905f51a7838401f2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/172385992ea44c1eeb621c3905f51a7838401f2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93fb12e3d0644f6a8ddfa2ac1d6b0a1d8341e287", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93fb12e3d0644f6a8ddfa2ac1d6b0a1d8341e287", "html_url": "https://github.com/rust-lang/rust/commit/93fb12e3d0644f6a8ddfa2ac1d6b0a1d8341e287", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93fb12e3d0644f6a8ddfa2ac1d6b0a1d8341e287/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fdc81262a5d44f10e335384b5d69b938d6d729c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fdc81262a5d44f10e335384b5d69b938d6d729c", "html_url": "https://github.com/rust-lang/rust/commit/5fdc81262a5d44f10e335384b5d69b938d6d729c"}, {"sha": "f4c9ed42aa1f5b83aa2f0ee3fbb5a89919d208d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4c9ed42aa1f5b83aa2f0ee3fbb5a89919d208d4", "html_url": "https://github.com/rust-lang/rust/commit/f4c9ed42aa1f5b83aa2f0ee3fbb5a89919d208d4"}], "stats": {"total": 102, "additions": 79, "deletions": 23}, "files": [{"sha": "a927c3b02bc575581202f8e0fd87a70809387a3e", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 79, "deletions": 23, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/93fb12e3d0644f6a8ddfa2ac1d6b0a1d8341e287/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93fb12e3d0644f6a8ddfa2ac1d6b0a1d8341e287/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=93fb12e3d0644f6a8ddfa2ac1d6b0a1d8341e287", "patch": "@@ -90,7 +90,7 @@ pub mod reader {\n \n     // ebml reading\n \n-    struct Res {\n+    pub struct Res {\n         val: uint,\n         next: uint\n     }\n@@ -130,32 +130,40 @@ pub mod reader {\n             return vuint_at_slow(data, start);\n         }\n \n+        // Lookup table for parsing EBML Element IDs as per http://ebml.sourceforge.net/specs/\n+        // The Element IDs are parsed by reading a big endian u32 positioned at data[start].\n+        // Using the four most significant bits of the u32 we lookup in the table below how the\n+        // element ID should be derived from it.\n+        //\n+        // The table stores tuples (shift, mask) where shift is the number the u32 should be right\n+        // shifted with and mask is the value the right shifted value should be masked with.\n+        // If for example the most significant bit is set this means it's a class A ID and the u32\n+        // should be right shifted with 24 and masked with 0x7f. Therefore we store (24, 0x7f) at\n+        // index 0x8 - 0xF (four bit numbers where the most significant bit is set).\n+        //\n+        // By storing the number of shifts and masks in a table instead of checking in order if\n+        // the most significant bit is set, the second most significant bit is set etc. we can\n+        // replace up to three \"and+branch\" with a single table lookup which gives us a measured\n+        // speedup of around 2x on x86_64.\n+        static SHIFT_MASK_TABLE: [(u32, u32), ..16] = [\n+            (0, 0x0), (0, 0x0fffffff),\n+            (8, 0x1fffff), (8, 0x1fffff),\n+            (16, 0x3fff), (16, 0x3fff), (16, 0x3fff), (16, 0x3fff),\n+            (24, 0x7f), (24, 0x7f), (24, 0x7f), (24, 0x7f),\n+            (24, 0x7f), (24, 0x7f), (24, 0x7f), (24, 0x7f)\n+        ];\n+\n         unsafe {\n             let (ptr, _): (*u8, uint) = transmute(data);\n             let ptr = offset(ptr, start as int);\n             let ptr: *i32 = transmute(ptr);\n-            let val = from_be32(*ptr);\n-            let val: u32 = transmute(val);\n-            if (val & 0x80000000) != 0 {\n-                Res {\n-                    val: ((val >> 24) & 0x7f) as uint,\n-                    next: start + 1\n-                }\n-            } else if (val & 0x40000000) != 0 {\n-                Res {\n-                    val: ((val >> 16) & 0x3fff) as uint,\n-                    next: start + 2\n-                }\n-            } else if (val & 0x20000000) != 0 {\n-                Res {\n-                    val: ((val >> 8) & 0x1fffff) as uint,\n-                    next: start + 3\n-                }\n-            } else {\n-                Res {\n-                    val: (val & 0x0fffffff) as uint,\n-                    next: start + 4\n-                }\n+            let val = from_be32(*ptr) as u32;\n+\n+            let i = (val >> 28u) as uint;\n+            let (shift, mask) = SHIFT_MASK_TABLE[i];\n+            Res {\n+                val: ((val >> shift) & mask) as uint,\n+                next: start + (((32 - shift) >> 3) as uint)\n             }\n         }\n     }\n@@ -938,6 +946,54 @@ mod tests {\n     use std::io::mem::MemWriter;\n     use std::option::{None, Option, Some};\n \n+    #[test]\n+    fn test_vuint_at() {\n+        let data = [\n+            0x80,\n+            0xff,\n+            0x40, 0x00,\n+            0x7f, 0xff,\n+            0x20, 0x00, 0x00,\n+            0x3f, 0xff, 0xff,\n+            0x10, 0x00, 0x00, 0x00,\n+            0x1f, 0xff, 0xff, 0xff\n+        ];\n+\n+        let mut res: reader::Res;\n+\n+        // Class A\n+        res = reader::vuint_at(data, 0);\n+        assert_eq!(res.val, 0);\n+        assert_eq!(res.next, 1);\n+        res = reader::vuint_at(data, res.next);\n+        assert_eq!(res.val, (1 << 7) - 1);\n+        assert_eq!(res.next, 2);\n+\n+        // Class B\n+        res = reader::vuint_at(data, res.next);\n+        assert_eq!(res.val, 0);\n+        assert_eq!(res.next, 4);\n+        res = reader::vuint_at(data, res.next);\n+        assert_eq!(res.val, (1 << 14) - 1);\n+        assert_eq!(res.next, 6);\n+\n+        // Class C\n+        res = reader::vuint_at(data, res.next);\n+        assert_eq!(res.val, 0);\n+        assert_eq!(res.next, 9);\n+        res = reader::vuint_at(data, res.next);\n+        assert_eq!(res.val, (1 << 21) - 1);\n+        assert_eq!(res.next, 12);\n+\n+        // Class D\n+        res = reader::vuint_at(data, res.next);\n+        assert_eq!(res.val, 0);\n+        assert_eq!(res.next, 16);\n+        res = reader::vuint_at(data, res.next);\n+        assert_eq!(res.val, (1 << 28) - 1);\n+        assert_eq!(res.next, 20);\n+    }\n+\n     #[test]\n     fn test_option_int() {\n         fn test_v(v: Option<int>) {"}]}