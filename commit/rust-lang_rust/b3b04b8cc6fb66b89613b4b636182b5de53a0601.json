{"sha": "b3b04b8cc6fb66b89613b4b636182b5de53a0601", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzYjA0YjhjYzZmYjY2Yjg5NjEzYjRiNjM2MTgyYjVkZTUzYTA2MDE=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2018-06-27T04:59:43Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2018-07-04T21:36:07Z"}, "message": "Avoid overflow in step counter\n\nThis removes the `usize` argument to `inc_step_counter`. Now, the step\ncounter increments by exactly one for every terminator evaluated. After\n`STEPS_UNTIL_DETECTOR_ENABLED` steps elapse, the detector is run every\n`DETECTOR_SNAPSHOT_PERIOD` steps. The step counter is only kept modulo\nthis period.", "tree": {"sha": "c0d8c27d2099e210a6f487ce63e0cb2051247139", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0d8c27d2099e210a6f487ce63e0cb2051247139"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3b04b8cc6fb66b89613b4b636182b5de53a0601", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3b04b8cc6fb66b89613b4b636182b5de53a0601", "html_url": "https://github.com/rust-lang/rust/commit/b3b04b8cc6fb66b89613b4b636182b5de53a0601", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3b04b8cc6fb66b89613b4b636182b5de53a0601/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "647ba29b90155e07cf569060d344242b3ee474eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/647ba29b90155e07cf569060d344242b3ee474eb", "html_url": "https://github.com/rust-lang/rust/commit/647ba29b90155e07cf569060d344242b3ee474eb"}], "stats": {"total": 53, "additions": 27, "deletions": 26}, "files": [{"sha": "363ad537b3f36f4eac621594e5daf94063f69b8c", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b3b04b8cc6fb66b89613b4b636182b5de53a0601/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b04b8cc6fb66b89613b4b636182b5de53a0601/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=b3b04b8cc6fb66b89613b4b636182b5de53a0601", "patch": "@@ -43,9 +43,11 @@ pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// The maximum number of stack frames allowed\n     pub(crate) stack_limit: usize,\n \n-    /// The number of terminators to be evaluated before enabling the infinite\n-    /// loop detector.\n-    pub(crate) steps_until_detector_enabled: isize,\n+    /// When this value is negative, it indicates the number of interpreter\n+    /// steps *until* the loop detector is enabled. When it is positive, it is\n+    /// the number of steps after the detector has been enabled modulo the loop\n+    /// detector period.\n+    pub(crate) steps_since_detector_enabled: isize,\n \n     pub(crate) loop_detector: InfiniteLoopDetector<'a, 'mir, 'tcx, M>,\n }\n@@ -148,14 +150,15 @@ type EvalSnapshot<'a, 'mir, 'tcx, M>\n pub(crate) struct InfiniteLoopDetector<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// The set of all `EvalSnapshot` *hashes* observed by this detector.\n     ///\n-    /// When a collision occurs in this table, we store the full snapshot in `snapshots`.\n+    /// When a collision occurs in this table, we store the full snapshot in\n+    /// `snapshots`.\n     hashes: FxHashSet<u64>,\n \n     /// The set of all `EvalSnapshot`s observed by this detector.\n     ///\n-    /// An `EvalSnapshot` will only be fully cloned once it has caused a collision in `hashes`. As\n-    /// a result, the detector must observe at least *two* full cycles of an infinite loop before\n-    /// it triggers.\n+    /// An `EvalSnapshot` will only be fully cloned once it has caused a\n+    /// collision in `hashes`. As a result, the detector must observe at least\n+    /// *two* full cycles of an infinite loop before it triggers.\n     snapshots: FxHashSet<EvalSnapshot<'a, 'mir, 'tcx, M>>,\n }\n \n@@ -291,7 +294,7 @@ impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf\n     }\n }\n \n-const MAX_TERMINATORS: isize = 1_000_000;\n+const STEPS_UNTIL_DETECTOR_ENABLED: isize = 1_000_000;\n \n impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub fn new(\n@@ -310,16 +313,16 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             stack: Vec::new(),\n             stack_limit: tcx.sess.const_eval_stack_frame_limit,\n             loop_detector: Default::default(),\n-            steps_until_detector_enabled: MAX_TERMINATORS,\n+            steps_since_detector_enabled: -STEPS_UNTIL_DETECTOR_ENABLED,\n         }\n     }\n \n     pub(crate) fn with_fresh_body<F: FnOnce(&mut Self) -> R, R>(&mut self, f: F) -> R {\n         let stack = mem::replace(&mut self.stack, Vec::new());\n-        let steps = mem::replace(&mut self.steps_until_detector_enabled, MAX_TERMINATORS);\n+        let steps = mem::replace(&mut self.steps_since_detector_enabled, -STEPS_UNTIL_DETECTOR_ENABLED);\n         let r = f(self);\n         self.stack = stack;\n-        self.steps_until_detector_enabled = steps;\n+        self.steps_since_detector_enabled = steps;\n         r\n     }\n \n@@ -661,8 +664,6 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             }\n \n             Aggregate(ref kind, ref operands) => {\n-                self.inc_step_counter_and_detect_loops(operands.len())?;\n-\n                 let (dest, active_field_index) = match **kind {\n                     mir::AggregateKind::Adt(adt_def, variant_index, _, active_field_index) => {\n                         self.write_discriminant_value(dest_ty, dest, variant_index)?;"}, {"sha": "25f45fff04d1ee6613553d8e71b9c6dc34f1d24f", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b3b04b8cc6fb66b89613b4b636182b5de53a0601/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b04b8cc6fb66b89613b4b636182b5de53a0601/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=b3b04b8cc6fb66b89613b4b636182b5de53a0601", "patch": "@@ -12,23 +12,23 @@ use super::{EvalContext, Machine};\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     where M: Clone + Eq + Hash,\n {\n-    /// Returns `true` if the loop detector should take a snapshot during the current step.\n-    pub fn is_loop_detector_scheduled(&self) -> bool {\n+    pub fn inc_step_counter_and_detect_loops(&mut self) -> EvalResult<'tcx, ()> {\n         /// The number of steps between loop detector snapshots.\n         /// Should be a power of two for performance reasons.\n-        const DETECTOR_SNAPSHOT_PERIOD: isize = 1 << 8;\n+        const DETECTOR_SNAPSHOT_PERIOD: isize = 256;\n \n-        let steps = self.steps_until_detector_enabled;\n-        steps <= 0 && steps % DETECTOR_SNAPSHOT_PERIOD == 0\n-    }\n+        {\n+            let steps = &mut self.steps_since_detector_enabled;\n \n-    pub fn inc_step_counter_and_detect_loops(&mut self, n: usize) -> EvalResult<'tcx, ()> {\n-        // TODO: Remove `as` cast\n-        self.steps_until_detector_enabled =\n-            self.steps_until_detector_enabled.saturating_sub(n as isize);\n+            *steps += 1;\n+            if *steps < 0 {\n+                return Ok(());\n+            }\n \n-        if !self.is_loop_detector_scheduled() {\n-            return Ok(());\n+            *steps %= DETECTOR_SNAPSHOT_PERIOD;\n+            if *steps != 0 {\n+                return Ok(());\n+            }\n         }\n \n         if self.loop_detector.is_empty() {\n@@ -61,7 +61,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             return Ok(true);\n         }\n \n-        self.inc_step_counter_and_detect_loops(1)?;\n+        self.inc_step_counter_and_detect_loops()?;\n \n         let terminator = basic_block.terminator();\n         assert_eq!(old_frames, self.cur_frame());"}]}