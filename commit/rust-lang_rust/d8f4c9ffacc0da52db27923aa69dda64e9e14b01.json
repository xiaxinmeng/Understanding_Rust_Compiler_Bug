{"sha": "d8f4c9ffacc0da52db27923aa69dda64e9e14b01", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4ZjRjOWZmYWNjMGRhNTJkYjI3OTIzYWE2OWRkYTY0ZTllMTRiMDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-12T01:20:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-12T01:20:33Z"}, "message": "Auto merge of #55525 - nnethercote:MatcherPos-stack-SmallVec, r=nnethercote\n\nMake `MatcherPos::stack` a `SmallVec`.\n\nThis avoids some allocations.\n\nThis seems like a trivial change, but the compiler rejects it:\n```\n   Compiling syntax v0.0.0 (/home/njn/moz/rust1/src/libsyntax)\nerror[E0597]: `initial` does not live long enough=========>           ] 89/110: syntax\n   --> libsyntax/ext/tt/macro_parser.rs:647:57\n    |\n647 |     let mut cur_items = smallvec![MatcherPosHandle::Ref(&mut initial)];\n    |                                                         ^^^^^^^^^^^^ borrowed value does not live long enough\n...\n762 | }\n    | -\n    | |\n    | `initial` dropped here while still borrowed\n    | borrow later used here, when `initial` is dropped\n\nerror: aborting due to previous error\n```\nThis is either a compiler bug, or there's some subtle thing I don't understand. The lifetimes sure seem straightforward: `initial` is declared, and then `cur_items` is declared immediately afterward, and it uses a reference to `initial`. The error message makes it sound like the compiler is dropping the variables in the wrong order.\n\nr? @nikomatsakis, any idea what the problem is?", "tree": {"sha": "3374953474bddf401d7b7ef31688ca9aa46598bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3374953474bddf401d7b7ef31688ca9aa46598bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8f4c9ffacc0da52db27923aa69dda64e9e14b01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8f4c9ffacc0da52db27923aa69dda64e9e14b01", "html_url": "https://github.com/rust-lang/rust/commit/d8f4c9ffacc0da52db27923aa69dda64e9e14b01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8f4c9ffacc0da52db27923aa69dda64e9e14b01/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "775eab58835f9bc0f1f01ccbb79725dce0c73b51", "url": "https://api.github.com/repos/rust-lang/rust/commits/775eab58835f9bc0f1f01ccbb79725dce0c73b51", "html_url": "https://github.com/rust-lang/rust/commit/775eab58835f9bc0f1f01ccbb79725dce0c73b51"}, {"sha": "68e76dca09da9a59d29e27872645ba38222ca98d", "url": "https://api.github.com/repos/rust-lang/rust/commits/68e76dca09da9a59d29e27872645ba38222ca98d", "html_url": "https://github.com/rust-lang/rust/commit/68e76dca09da9a59d29e27872645ba38222ca98d"}], "stats": {"total": 91, "additions": 57, "deletions": 34}, "files": [{"sha": "7a0a764d4639ae117bc78e33ce412a8b5d5c1f9a", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 57, "deletions": 34, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/d8f4c9ffacc0da52db27923aa69dda64e9e14b01/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8f4c9ffacc0da52db27923aa69dda64e9e14b01/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=d8f4c9ffacc0da52db27923aa69dda64e9e14b01", "patch": "@@ -107,12 +107,12 @@ use std::rc::Rc;\n /// Either a sequence of token trees or a single one. This is used as the representation of the\n /// sequence of tokens that make up a matcher.\n #[derive(Clone)]\n-enum TokenTreeOrTokenTreeSlice<'a> {\n+enum TokenTreeOrTokenTreeSlice<'tt> {\n     Tt(TokenTree),\n-    TtSeq(&'a [TokenTree]),\n+    TtSeq(&'tt [TokenTree]),\n }\n \n-impl<'a> TokenTreeOrTokenTreeSlice<'a> {\n+impl<'tt> TokenTreeOrTokenTreeSlice<'tt> {\n     /// Returns the number of constituent top-level token trees of `self` (top-level in that it\n     /// will not recursively descend into subtrees).\n     fn len(&self) -> usize {\n@@ -136,23 +136,41 @@ impl<'a> TokenTreeOrTokenTreeSlice<'a> {\n /// This is used by `inner_parse_loop` to keep track of delimited submatchers that we have\n /// descended into.\n #[derive(Clone)]\n-struct MatcherTtFrame<'a> {\n+struct MatcherTtFrame<'tt> {\n     /// The \"parent\" matcher that we are descending into.\n-    elts: TokenTreeOrTokenTreeSlice<'a>,\n+    elts: TokenTreeOrTokenTreeSlice<'tt>,\n     /// The position of the \"dot\" in `elts` at the time we descended.\n     idx: usize,\n }\n \n type NamedMatchVec = SmallVec<[NamedMatch; 4]>;\n \n-/// Represents a single \"position\" (aka \"matcher position\", aka \"item\"), as described in the module\n-/// documentation.\n+/// Represents a single \"position\" (aka \"matcher position\", aka \"item\"), as\n+/// described in the module documentation.\n+///\n+/// Here:\n+///\n+/// - `'root` represents the lifetime of the stack slot that holds the root\n+///   `MatcherPos`. As described in `MatcherPosHandle`, the root `MatcherPos`\n+///   structure is stored on the stack, but subsequent instances are put into\n+///   the heap.\n+/// - `'tt` represents the lifetime of the token trees that this matcher\n+///   position refers to.\n+///\n+/// It is important to distinguish these two lifetimes because we have a\n+/// `SmallVec<TokenTreeOrTokenTreeSlice<'tt>>` below, and the destructor of\n+/// that is considered to possibly access the data from its elements (it lacks\n+/// a `#[may_dangle]` attribute). As a result, the compiler needs to know that\n+/// all the elements in that `SmallVec` strictly outlive the root stack slot\n+/// lifetime. By separating `'tt` from `'root`, we can show that.\n #[derive(Clone)]\n-struct MatcherPos<'a> {\n+struct MatcherPos<'root, 'tt: 'root> {\n     /// The token or sequence of tokens that make up the matcher\n-    top_elts: TokenTreeOrTokenTreeSlice<'a>,\n+    top_elts: TokenTreeOrTokenTreeSlice<'tt>,\n+\n     /// The position of the \"dot\" in this matcher\n     idx: usize,\n+\n     /// The first span of source source that the beginning of this matcher corresponds to. In other\n     /// words, the token in the source whose span is `sp_open` is matched against the first token of\n     /// the matcher.\n@@ -182,26 +200,31 @@ struct MatcherPos<'a> {\n     /// in this matcher.\n     match_hi: usize,\n \n-    // Specifically used if we are matching a repetition. If we aren't both should be `None`.\n+    // The following fields are used if we are matching a repetition. If we aren't, they should be\n+    // `None`.\n+\n     /// The KleeneOp of this sequence if we are in a repetition.\n     seq_op: Option<quoted::KleeneOp>,\n-    /// The separator if we are in a repetition\n+\n+    /// The separator if we are in a repetition.\n     sep: Option<Token>,\n+\n     /// The \"parent\" matcher position if we are in a repetition. That is, the matcher position just\n     /// before we enter the sequence.\n-    up: Option<MatcherPosHandle<'a>>,\n+    up: Option<MatcherPosHandle<'root, 'tt>>,\n \n-    // Specifically used to \"unzip\" token trees. By \"unzip\", we mean to unwrap the delimiters from\n-    // a delimited token tree (e.g. something wrapped in `(` `)`) or to get the contents of a doc\n-    // comment...\n+    /// Specifically used to \"unzip\" token trees. By \"unzip\", we mean to unwrap the delimiters from\n+    /// a delimited token tree (e.g. something wrapped in `(` `)`) or to get the contents of a doc\n+    /// comment...\n+    ///\n     /// When matching against matchers with nested delimited submatchers (e.g. `pat ( pat ( .. )\n     /// pat ) pat`), we need to keep track of the matchers we are descending into. This stack does\n     /// that where the bottom of the stack is the outermost matcher.\n-    // Also, throughout the comments, this \"descent\" is often referred to as \"unzipping\"...\n-    stack: Vec<MatcherTtFrame<'a>>,\n+    /// Also, throughout the comments, this \"descent\" is often referred to as \"unzipping\"...\n+    stack: SmallVec<[MatcherTtFrame<'tt>; 1]>,\n }\n \n-impl<'a> MatcherPos<'a> {\n+impl<'root, 'tt> MatcherPos<'root, 'tt> {\n     /// Add `m` as a named match for the `idx`-th metavar.\n     fn push_match(&mut self, idx: usize, m: NamedMatch) {\n         let matches = Rc::make_mut(&mut self.matches[idx]);\n@@ -218,12 +241,12 @@ impl<'a> MatcherPos<'a> {\n // Therefore, the initial MatcherPos is always allocated on the stack,\n // subsequent ones (of which there aren't that many) are allocated on the heap,\n // and this type is used to encapsulate both cases.\n-enum MatcherPosHandle<'a> {\n-    Ref(&'a mut MatcherPos<'a>),\n-    Box(Box<MatcherPos<'a>>),\n+enum MatcherPosHandle<'root, 'tt: 'root> {\n+    Ref(&'root mut MatcherPos<'root, 'tt>),\n+    Box(Box<MatcherPos<'root, 'tt>>),\n }\n \n-impl<'a> Clone for MatcherPosHandle<'a> {\n+impl<'root, 'tt> Clone for MatcherPosHandle<'root, 'tt> {\n     // This always produces a new Box.\n     fn clone(&self) -> Self {\n         MatcherPosHandle::Box(match *self {\n@@ -233,8 +256,8 @@ impl<'a> Clone for MatcherPosHandle<'a> {\n     }\n }\n \n-impl<'a> Deref for MatcherPosHandle<'a> {\n-    type Target = MatcherPos<'a>;\n+impl<'root, 'tt> Deref for MatcherPosHandle<'root, 'tt> {\n+    type Target = MatcherPos<'root, 'tt>;\n     fn deref(&self) -> &Self::Target {\n         match *self {\n             MatcherPosHandle::Ref(ref r) => r,\n@@ -243,8 +266,8 @@ impl<'a> Deref for MatcherPosHandle<'a> {\n     }\n }\n \n-impl<'a> DerefMut for MatcherPosHandle<'a> {\n-    fn deref_mut(&mut self) -> &mut MatcherPos<'a> {\n+impl<'root, 'tt> DerefMut for MatcherPosHandle<'root, 'tt> {\n+    fn deref_mut(&mut self) -> &mut MatcherPos<'root, 'tt> {\n         match *self {\n             MatcherPosHandle::Ref(ref mut r) => r,\n             MatcherPosHandle::Box(ref mut b) => b,\n@@ -292,7 +315,7 @@ fn create_matches(len: usize) -> Box<[Rc<NamedMatchVec>]> {\n \n /// Generate the top-level matcher position in which the \"dot\" is before the first token of the\n /// matcher `ms` and we are going to start matching at the span `open` in the source.\n-fn initial_matcher_pos(ms: &[TokenTree], open: Span) -> MatcherPos {\n+fn initial_matcher_pos<'root, 'tt>(ms: &'tt [TokenTree], open: Span) -> MatcherPos<'root, 'tt> {\n     let match_idx_hi = count_names(ms);\n     let matches = create_matches(match_idx_hi);\n     MatcherPos {\n@@ -312,7 +335,7 @@ fn initial_matcher_pos(ms: &[TokenTree], open: Span) -> MatcherPos {\n         match_hi: match_idx_hi,\n \n         // Haven't descended into any delimiters, so empty stack\n-        stack: vec![],\n+        stack: smallvec![],\n \n         // Haven't descended into any sequences, so both of these are `None`.\n         seq_op: None,\n@@ -445,12 +468,12 @@ fn token_name_eq(t1: &Token, t2: &Token) -> bool {\n /// # Returns\n ///\n /// A `ParseResult`. Note that matches are kept track of through the items generated.\n-fn inner_parse_loop<'a>(\n+fn inner_parse_loop<'root, 'tt>(\n     sess: &ParseSess,\n-    cur_items: &mut SmallVec<[MatcherPosHandle<'a>; 1]>,\n-    next_items: &mut Vec<MatcherPosHandle<'a>>,\n-    eof_items: &mut SmallVec<[MatcherPosHandle<'a>; 1]>,\n-    bb_items: &mut SmallVec<[MatcherPosHandle<'a>; 1]>,\n+    cur_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n+    next_items: &mut Vec<MatcherPosHandle<'root, 'tt>>,\n+    eof_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n+    bb_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n     token: &Token,\n     span: syntax_pos::Span,\n ) -> ParseResult<()> {\n@@ -554,7 +577,7 @@ fn inner_parse_loop<'a>(\n \n                     let matches = create_matches(item.matches.len());\n                     cur_items.push(MatcherPosHandle::Box(Box::new(MatcherPos {\n-                        stack: vec![],\n+                        stack: smallvec![],\n                         sep: seq.separator.clone(),\n                         seq_op: Some(seq.op),\n                         idx: 0,"}]}