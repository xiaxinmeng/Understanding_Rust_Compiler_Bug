{"sha": "59183180f718fc2212828e180f2f856f0db1bb9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5MTgzMTgwZjcxOGZjMjIxMjgyOGUxODBmMmY4NTZmMGRiMWJiOWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-29T21:03:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-29T21:03:11Z"}, "message": "Auto merge of #56225 - alexreg:type_alias_enum_variants, r=petrochenkov\n\nImplement RFC 2338, \"Type alias enum variants\"\n\nThis PR implements [RFC 2338](https://github.com/rust-lang/rfcs/pull/2338), allowing one to write code like the following.\n\n```rust\n#![feature(type_alias_enum_variants)]\n\nenum Foo {\n    Bar(i32),\n    Baz { i: i32 },\n}\n\ntype Alias = Foo;\n\nfn main() {\n    let t = Alias::Bar(0);\n    let t = Alias::Baz { i: 0 };\n    match t {\n        Alias::Bar(_i) => {}\n        Alias::Baz { i: _i } => {}\n    }\n}\n```\n\nSince `Self` can be considered a type alias in this context, it also enables using `Self::Variant` as both a constructor and pattern.\n\nFixes issues #56199 and #56611.\n\nN.B., after discussing the syntax for type arguments on enum variants with @petrochenkov and @eddyb (there are also a few comments on the [tracking issue](https://github.com/rust-lang/rust/issues/49683)), the consensus seems to be treat the syntax as follows, which ought to be backwards-compatible.\n\n```rust\nOption::<u8>::None; // OK\nOption::None::<u8>; // OK, but lint in near future (hard error next edition?)\nAlias::<u8>::None; // OK\nAlias::None::<u8>; // Error\n```\n\nI do not know if this will need an FCP, but let's start one if so.", "tree": {"sha": "23910eebcb2479fd05771ffaa6a447d9b73371e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23910eebcb2479fd05771ffaa6a447d9b73371e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59183180f718fc2212828e180f2f856f0db1bb9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59183180f718fc2212828e180f2f856f0db1bb9c", "html_url": "https://github.com/rust-lang/rust/commit/59183180f718fc2212828e180f2f856f0db1bb9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59183180f718fc2212828e180f2f856f0db1bb9c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "007115746c6d0234742719dd67efba054abe97ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/007115746c6d0234742719dd67efba054abe97ce", "html_url": "https://github.com/rust-lang/rust/commit/007115746c6d0234742719dd67efba054abe97ce"}, {"sha": "a4fa7ef2b90880623499e86324b7b40626a02f9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4fa7ef2b90880623499e86324b7b40626a02f9d", "html_url": "https://github.com/rust-lang/rust/commit/a4fa7ef2b90880623499e86324b7b40626a02f9d"}], "stats": {"total": 2363, "additions": 1605, "deletions": 758}, "files": [{"sha": "bcdeafc4b113717c431d8f833ae20a6a5c54e441", "filename": "src/doc/unstable-book/src/language-features/type-alias-enum-variants.md", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftype-alias-enum-variants.md", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftype-alias-enum-variants.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftype-alias-enum-variants.md?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -0,0 +1,36 @@\n+# `type_alias_enum_variants`\n+\n+The tracking issue for this feature is: [#49683]\n+\n+[#49683]: https://github.com/rust-lang/rust/issues/49683\n+\n+------------------------\n+\n+The `type_alias_enum_variants` feature enables the use of variants on type\n+aliases that refer to enums, as both a constructor and a pattern. That is,\n+it allows for the syntax `EnumAlias::Variant`, which behaves exactly the same\n+as `Enum::Variant` (assuming that `EnumAlias` is an alias for some enum type\n+`Enum`).\n+\n+Note that since `Self` exists as a type alias, this feature also enables the\n+use of the syntax `Self::Variant` within an impl block for an enum type.\n+\n+```rust\n+#![feature(type_alias_enum_variants)]\n+\n+enum Foo {\n+    Bar(i32),\n+    Baz { i: i32 },\n+}\n+\n+type Alias = Foo;\n+\n+fn main() {\n+    let t = Alias::Bar(0);\n+    let t = Alias::Baz { i: 0 };\n+    match t {\n+        Alias::Bar(_i) => {}\n+        Alias::Baz { i: _i } => {}\n+    }\n+}\n+```"}, {"sha": "74ae711a47372afcc2d5819b2e7ec8afa62ab97c", "filename": "src/libproc_macro/bridge/rpc.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibproc_macro%2Fbridge%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibproc_macro%2Fbridge%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Frpc.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,4 +1,4 @@\n-//! Serialization for client<->server communication.\n+//! Serialization for client-server communication.\n \n use std::any::Any;\n use std::char;\n@@ -71,15 +71,18 @@ macro_rules! rpc_encode_decode {\n     (enum $name:ident $(<$($T:ident),+>)* { $($variant:ident $(($field:ident))*),* $(,)* }) => {\n         impl<S, $($($T: Encode<S>),+)*> Encode<S> for $name $(<$($T),+>)* {\n             fn encode(self, w: &mut Writer, s: &mut S) {\n-                // HACK(eddyb) `Tag` enum duplicated between the\n+                // HACK(eddyb): `Tag` enum duplicated between the\n                 // two impls as there's no other place to stash it.\n-                #[repr(u8)] enum Tag { $($variant),* }\n                 #[allow(non_upper_case_globals)]\n-                impl Tag { $(const $variant: u8 = Tag::$variant as u8;)* }\n+                mod tag {\n+                    #[repr(u8)] enum Tag { $($variant),* }\n+\n+                    $(pub const $variant: u8 = Tag::$variant as u8;)*\n+                }\n \n                 match self {\n                     $($name::$variant $(($field))* => {\n-                        <Tag>::$variant.encode(w, s);\n+                        tag::$variant.encode(w, s);\n                         $($field.encode(w, s);)*\n                     })*\n                 }\n@@ -90,14 +93,17 @@ macro_rules! rpc_encode_decode {\n             for $name $(<$($T),+>)*\n         {\n             fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n-                // HACK(eddyb) `Tag` enum duplicated between the\n+                // HACK(eddyb): `Tag` enum duplicated between the\n                 // two impls as there's no other place to stash it.\n-                #[repr(u8)] enum Tag { $($variant),* }\n                 #[allow(non_upper_case_globals)]\n-                impl Tag { $(const $variant: u8 = Tag::$variant as u8;)* }\n+                mod tag {\n+                    #[repr(u8)] enum Tag { $($variant),* }\n+\n+                    $(pub const $variant: u8 = Tag::$variant as u8;)*\n+                }\n \n                 match u8::decode(r, s) {\n-                    $(<Tag>::$variant => {\n+                    $(tag::$variant => {\n                         $(let $field = DecodeMut::decode(r, s);)*\n                         $name::$variant $(($field))*\n                     })*"}, {"sha": "d4f891c874a40cc4eb31f235e76a56e016134f85", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -454,7 +454,7 @@ pub fn walk_trait_ref<'v, V>(visitor: &mut V, trait_ref: &'v TraitRef)\n \n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n     visitor.visit_vis(&item.vis);\n-    visitor.visit_name(item.span, item.name);\n+    visitor.visit_ident(item.ident);\n     match item.node {\n         ItemKind::ExternCrate(orig_name) => {\n             visitor.visit_id(item.id);\n@@ -472,7 +472,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_nested_body(body);\n         }\n         ItemKind::Fn(ref declaration, header, ref generics, body_id) => {\n-            visitor.visit_fn(FnKind::ItemFn(item.name,\n+            visitor.visit_fn(FnKind::ItemFn(item.ident.name,\n                                             generics,\n                                             header,\n                                             &item.vis,\n@@ -528,7 +528,8 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         ItemKind::Union(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics);\n             visitor.visit_id(item.id);\n-            visitor.visit_variant_data(struct_definition, item.name, generics, item.id, item.span);\n+            visitor.visit_variant_data(struct_definition, item.ident.name, generics, item.id,\n+                                       item.span);\n         }\n         ItemKind::Trait(.., ref generics, ref bounds, ref trait_item_refs) => {\n             visitor.visit_id(item.id);\n@@ -569,9 +570,9 @@ pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n                                         variant: &'v Variant,\n                                         generics: &'v Generics,\n                                         parent_item_id: NodeId) {\n-    visitor.visit_name(variant.span, variant.node.name);\n+    visitor.visit_ident(variant.node.ident);\n     visitor.visit_variant_data(&variant.node.data,\n-                               variant.node.name,\n+                               variant.node.ident.name,\n                                generics,\n                                parent_item_id,\n                                variant.span);\n@@ -720,7 +721,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v ForeignItem) {\n     visitor.visit_id(foreign_item.id);\n     visitor.visit_vis(&foreign_item.vis);\n-    visitor.visit_name(foreign_item.span, foreign_item.name);\n+    visitor.visit_ident(foreign_item.ident);\n \n     match foreign_item.node {\n         ForeignItemKind::Fn(ref function_declaration, ref param_names, ref generics) => {"}, {"sha": "359bd37488241667e19920175a4812a06023bba1", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1360,7 +1360,7 @@ impl<'a> LoweringContext<'a> {\n             let exist_ty_item = hir::Item {\n                 id: exist_ty_id.node_id,\n                 hir_id: exist_ty_id.hir_id,\n-                name: keywords::Invalid.name(),\n+                ident: keywords::Invalid.ident(),\n                 attrs: Default::default(),\n                 node: exist_ty_item_kind,\n                 vis: respan(span.shrink_to_lo(), hir::VisibilityKind::Inherited),\n@@ -1563,7 +1563,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_variant(&mut self, v: &Variant) -> hir::Variant {\n         Spanned {\n             node: hir::VariantKind {\n-                name: v.node.ident.name,\n+                ident: v.node.ident,\n                 attrs: self.lower_attrs(&v.node.attrs),\n                 data: self.lower_variant_data(&v.node.data),\n                 disr_expr: v.node.disr_expr.as_ref().map(|e| self.lower_anon_const(e)),\n@@ -2737,7 +2737,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_item_kind(\n         &mut self,\n         id: NodeId,\n-        name: &mut Name,\n+        ident: &mut Ident,\n         attrs: &hir::HirVec<Attribute>,\n         vis: &mut hir::Visibility,\n         i: &ItemKind,\n@@ -2751,7 +2751,7 @@ impl<'a> LoweringContext<'a> {\n                     span: use_tree.span,\n                 };\n \n-                self.lower_use_tree(use_tree, &prefix, id, vis, name, attrs)\n+                self.lower_use_tree(use_tree, &prefix, id, vis, ident, attrs)\n             }\n             ItemKind::Static(ref t, m, ref e) => {\n                 let value = self.lower_body(None, |this| this.lower_expr(e));\n@@ -2943,7 +2943,7 @@ impl<'a> LoweringContext<'a> {\n         prefix: &Path,\n         id: NodeId,\n         vis: &mut hir::Visibility,\n-        name: &mut Name,\n+        ident: &mut Ident,\n         attrs: &hir::HirVec<Attribute>,\n     ) -> hir::ItemKind {\n         debug!(\"lower_use_tree(tree={:?})\", tree);\n@@ -2959,28 +2959,28 @@ impl<'a> LoweringContext<'a> {\n \n         match tree.kind {\n             UseTreeKind::Simple(rename, id1, id2) => {\n-                *name = tree.ident().name;\n+                *ident = tree.ident();\n \n-                // First apply the prefix to the path\n+                // First, apply the prefix to the path.\n                 let mut path = Path {\n                     segments,\n                     span: path.span,\n                 };\n \n-                // Correctly resolve `self` imports\n+                // Correctly resolve `self` imports.\n                 if path.segments.len() > 1\n                     && path.segments.last().unwrap().ident.name == keywords::SelfLower.name()\n                 {\n                     let _ = path.segments.pop();\n                     if rename.is_none() {\n-                        *name = path.segments.last().unwrap().ident.name;\n+                        *ident = path.segments.last().unwrap().ident;\n                     }\n                 }\n \n                 let parent_def_index = self.current_hir_id_owner.last().unwrap().0;\n                 let mut defs = self.expect_full_def_from_use(id);\n-                // we want to return *something* from this function, so hang onto the first item\n-                // for later\n+                // We want to return *something* from this function, so hold onto the first item\n+                // for later.\n                 let ret_def = defs.next().unwrap_or(Def::Err);\n \n                 // Here, we are looping over namespaces, if they exist for the definition\n@@ -2990,7 +2990,7 @@ impl<'a> LoweringContext<'a> {\n                 // two imports.\n                 for (def, &new_node_id) in defs.zip([id1, id2].iter()) {\n                     let vis = vis.clone();\n-                    let name = name.clone();\n+                    let ident = ident.clone();\n                     let mut path = path.clone();\n                     for seg in &mut path.segments {\n                         seg.id = self.sess.next_node_id();\n@@ -3031,7 +3031,7 @@ impl<'a> LoweringContext<'a> {\n                             hir::Item {\n                                 id: new_id.node_id,\n                                 hir_id: new_id.hir_id,\n-                                name: name,\n+                                ident,\n                                 attrs: attrs.clone(),\n                                 node: item,\n                                 vis,\n@@ -3057,8 +3057,8 @@ impl<'a> LoweringContext<'a> {\n                 hir::ItemKind::Use(path, hir::UseKind::Glob)\n             }\n             UseTreeKind::Nested(ref trees) => {\n-                // Nested imports are desugared into simple\n-                // imports. So if we start with\n+                // Nested imports are desugared into simple imports.\n+                // So, if we start with\n                 //\n                 // ```\n                 // pub(x) use foo::{a, b};\n@@ -3079,14 +3079,14 @@ impl<'a> LoweringContext<'a> {\n                 // `self.items`. However, the structure of this\n                 // function also requires us to return one item, and\n                 // for that we return the `{}` import (called the\n-                // \"`ListStem`\").\n+                // `ListStem`).\n \n                 let prefix = Path {\n                     segments,\n                     span: prefix.span.to(path.span),\n                 };\n \n-                // Add all the nested PathListItems to the HIR.\n+                // Add all the nested `PathListItem`s to the HIR.\n                 for &(ref use_tree, id) in trees {\n                     self.allocate_hir_id_counter(id, &use_tree);\n \n@@ -3096,10 +3096,10 @@ impl<'a> LoweringContext<'a> {\n                     } = self.lower_node_id(id);\n \n                     let mut vis = vis.clone();\n-                    let mut name = name.clone();\n+                    let mut ident = ident.clone();\n                     let mut prefix = prefix.clone();\n \n-                    // Give the segments new ids since they are being cloned.\n+                    // Give the segments new node-ids since they are being cloned.\n                     for seg in &mut prefix.segments {\n                         seg.id = self.sess.next_node_id();\n                     }\n@@ -3114,7 +3114,7 @@ impl<'a> LoweringContext<'a> {\n                                                        &prefix,\n                                                        new_id,\n                                                        &mut vis,\n-                                                       &mut name,\n+                                                       &mut ident,\n                                                        attrs);\n \n                         let vis_kind = match vis.node {\n@@ -3138,7 +3138,7 @@ impl<'a> LoweringContext<'a> {\n                             hir::Item {\n                                 id: new_id,\n                                 hir_id: new_hir_id,\n-                                name,\n+                                ident,\n                                 attrs: attrs.clone(),\n                                 node: item,\n                                 vis,\n@@ -3165,7 +3165,7 @@ impl<'a> LoweringContext<'a> {\n                         *vis = respan(prefix.span.shrink_to_lo(), hir::VisibilityKind::Inherited);\n                     }\n                     hir::VisibilityKind::Restricted { .. } => {\n-                        // do nothing here, as described in the comment on the match\n+                        // Do nothing here, as described in the comment on the match.\n                     }\n                 }\n \n@@ -3413,15 +3413,15 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     pub fn lower_item(&mut self, i: &Item) -> Option<hir::Item> {\n-        let mut name = i.ident.name;\n+        let mut ident = i.ident;\n         let mut vis = self.lower_visibility(&i.vis, None);\n         let attrs = self.lower_attrs(&i.attrs);\n         if let ItemKind::MacroDef(ref def) = i.node {\n             if !def.legacy || attr::contains_name(&i.attrs, \"macro_export\") ||\n                               attr::contains_name(&i.attrs, \"rustc_doc_only_macro\") {\n                 let body = self.lower_token_stream(def.stream());\n                 self.exported_macros.push(hir::MacroDef {\n-                    name,\n+                    name: ident.name,\n                     vis,\n                     attrs,\n                     id: i.id,\n@@ -3433,14 +3433,14 @@ impl<'a> LoweringContext<'a> {\n             return None;\n         }\n \n-        let node = self.lower_item_kind(i.id, &mut name, &attrs, &mut vis, &i.node);\n+        let node = self.lower_item_kind(i.id, &mut ident, &attrs, &mut vis, &i.node);\n \n         let LoweredNodeId { node_id, hir_id } = self.lower_node_id(i.id);\n \n         Some(hir::Item {\n             id: node_id,\n             hir_id,\n-            name,\n+            ident,\n             attrs,\n             node,\n             vis,\n@@ -3453,7 +3453,7 @@ impl<'a> LoweringContext<'a> {\n         let def_id = self.resolver.definitions().local_def_id(node_id);\n         hir::ForeignItem {\n             id: node_id,\n-            name: i.ident.name,\n+            ident: i.ident,\n             attrs: self.lower_attrs(&i.attrs),\n             node: match i.node {\n                 ForeignItemKind::Fn(ref fdec, ref generics) => {"}, {"sha": "837a20ac0f2f02590b8cab93b62580817d7206d7", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -228,7 +228,7 @@ impl<'a> FnLikeNode<'a> {\n                 ast::ItemKind::Fn(ref decl, header, ref generics, block) =>\n                     item_fn(ItemFnParts {\n                         id: i.id,\n-                        name: i.name,\n+                        name: i.ident.name,\n                         decl: &decl,\n                         body: block,\n                         vis: &i.vis,"}, {"sha": "188d487d6448545769960dd1f7af71e1f8aaaf14", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -813,11 +813,11 @@ impl<'hir> Map<'hir> {\n     /// Returns the name associated with the given NodeId's AST.\n     pub fn name(&self, id: NodeId) -> Name {\n         match self.get(id) {\n-            Node::Item(i) => i.name,\n-            Node::ForeignItem(i) => i.name,\n+            Node::Item(i) => i.ident.name,\n+            Node::ForeignItem(fi) => fi.ident.name,\n             Node::ImplItem(ii) => ii.ident.name,\n             Node::TraitItem(ti) => ti.ident.name,\n-            Node::Variant(v) => v.node.name,\n+            Node::Variant(v) => v.node.ident.name,\n             Node::Field(f) => f.ident.name,\n             Node::Lifetime(lt) => lt.name.ident().name,\n             Node::GenericParam(param) => param.name.ident().name,\n@@ -953,7 +953,7 @@ impl<'a, 'hir> NodesMatchingSuffix<'a, 'hir> {\n             loop {\n                 if let Node::Item(item) = map.find(id)? {\n                     if item_is_mod(&item) {\n-                        return Some((id, item.name))\n+                        return Some((id, item.ident.name))\n                     }\n                 }\n                 let parent = map.get_parent(id);\n@@ -1009,9 +1009,9 @@ trait Named {\n \n impl<T:Named> Named for Spanned<T> { fn name(&self) -> Name { self.node.name() } }\n \n-impl Named for Item { fn name(&self) -> Name { self.name } }\n-impl Named for ForeignItem { fn name(&self) -> Name { self.name } }\n-impl Named for VariantKind { fn name(&self) -> Name { self.name } }\n+impl Named for Item { fn name(&self) -> Name { self.ident.name } }\n+impl Named for ForeignItem { fn name(&self) -> Name { self.ident.name } }\n+impl Named for VariantKind { fn name(&self) -> Name { self.ident.name } }\n impl Named for StructField { fn name(&self) -> Name { self.ident.name } }\n impl Named for TraitItem { fn name(&self) -> Name { self.ident.name } }\n impl Named for ImplItem { fn name(&self) -> Name { self.ident.name } }\n@@ -1194,7 +1194,7 @@ fn node_id_to_string(map: &Map<'_>, id: NodeId, include_id: bool) -> String {\n         }\n         Some(Node::Variant(ref variant)) => {\n             format!(\"variant {} in {}{}\",\n-                    variant.node.name,\n+                    variant.node.ident,\n                     path_str(), id_str)\n         }\n         Some(Node::Field(ref field)) => {"}, {"sha": "e6fa079207e59f0ed6510ce5b42628aa3859a8b3", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -420,7 +420,7 @@ pub struct GenericArgs {\n     /// The generic arguments for this path segment.\n     pub args: HirVec<GenericArg>,\n     /// Bindings (equality constraints) on associated types, if present.\n-    /// E.g., `Foo<A=Bar>`.\n+    /// E.g., `Foo<A = Bar>`.\n     pub bindings: HirVec<TypeBinding>,\n     /// Were arguments written in parenthesized form `Fn(T) -> U`?\n     /// This is required mostly for pretty-printing and diagnostics,\n@@ -2015,7 +2015,7 @@ pub struct EnumDef {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct VariantKind {\n-    pub name: Name,\n+    pub ident: Ident,\n     pub attrs: HirVec<Attribute>,\n     pub data: VariantData,\n     /// Explicit discriminant, e.g., `Foo = 1`\n@@ -2176,7 +2176,7 @@ pub struct ItemId {\n /// The name might be a dummy name in case of anonymous items\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Item {\n-    pub name: Name,\n+    pub ident: Ident,\n     pub id: NodeId,\n     pub hir_id: HirId,\n     pub attrs: HirVec<Attribute>,\n@@ -2331,7 +2331,7 @@ pub enum AssociatedItemKind {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct ForeignItem {\n-    pub name: Name,\n+    pub ident: Ident,\n     pub attrs: HirVec<Attribute>,\n     pub node: ForeignItemKind,\n     pub id: NodeId,"}, {"sha": "d7acdefcc7d7119ccb36866b91f79d745a5a7ef5", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -452,7 +452,7 @@ impl<'a> State<'a> {\n                                   abi: Abi::Rust,\n                                   asyncness: hir::IsAsync::NotAsync,\n                               },\n-                              Some(item.name),\n+                              Some(item.ident.name),\n                               generics,\n                               &item.vis,\n                               arg_names,\n@@ -466,7 +466,7 @@ impl<'a> State<'a> {\n                 if m {\n                     self.word_space(\"mut\")?;\n                 }\n-                self.print_name(item.name)?;\n+                self.print_ident(item.ident)?;\n                 self.word_space(\":\")?;\n                 self.print_type(&t)?;\n                 self.s.word(\";\")?;\n@@ -475,7 +475,7 @@ impl<'a> State<'a> {\n             }\n             hir::ForeignItemKind::Type => {\n                 self.head(visibility_qualified(&item.vis, \"type\"))?;\n-                self.print_name(item.name)?;\n+                self.print_ident(item.ident)?;\n                 self.s.word(\";\")?;\n                 self.end()?; // end the head-ibox\n                 self.end() // end the outer cbox\n@@ -535,7 +535,7 @@ impl<'a> State<'a> {\n                     self.s.word(\"as\")?;\n                     self.s.space()?;\n                 }\n-                self.print_name(item.name)?;\n+                self.print_ident(item.ident)?;\n                 self.s.word(\";\")?;\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n@@ -546,10 +546,10 @@ impl<'a> State<'a> {\n \n                 match kind {\n                     hir::UseKind::Single => {\n-                        if path.segments.last().unwrap().ident.name != item.name {\n+                        if path.segments.last().unwrap().ident != item.ident {\n                             self.s.space()?;\n                             self.word_space(\"as\")?;\n-                            self.print_name(item.name)?;\n+                            self.print_ident(item.ident)?;\n                         }\n                         self.s.word(\";\")?;\n                     }\n@@ -564,7 +564,7 @@ impl<'a> State<'a> {\n                 if m == hir::MutMutable {\n                     self.word_space(\"mut\")?;\n                 }\n-                self.print_name(item.name)?;\n+                self.print_ident(item.ident)?;\n                 self.word_space(\":\")?;\n                 self.print_type(&ty)?;\n                 self.s.space()?;\n@@ -577,7 +577,7 @@ impl<'a> State<'a> {\n             }\n             hir::ItemKind::Const(ref ty, expr) => {\n                 self.head(visibility_qualified(&item.vis, \"const\"))?;\n-                self.print_name(item.name)?;\n+                self.print_ident(item.ident)?;\n                 self.word_space(\":\")?;\n                 self.print_type(&ty)?;\n                 self.s.space()?;\n@@ -592,7 +592,7 @@ impl<'a> State<'a> {\n                 self.head(\"\")?;\n                 self.print_fn(decl,\n                               header,\n-                              Some(item.name),\n+                              Some(item.ident.name),\n                               typarams,\n                               &item.vis,\n                               &[],\n@@ -604,7 +604,7 @@ impl<'a> State<'a> {\n             }\n             hir::ItemKind::Mod(ref _mod) => {\n                 self.head(visibility_qualified(&item.vis, \"mod\"))?;\n-                self.print_name(item.name)?;\n+                self.print_ident(item.ident)?;\n                 self.nbsp()?;\n                 self.bopen()?;\n                 self.print_mod(_mod, &item.attrs)?;\n@@ -624,7 +624,7 @@ impl<'a> State<'a> {\n             }\n             hir::ItemKind::Ty(ref ty, ref generics) => {\n                 self.head(visibility_qualified(&item.vis, \"type\"))?;\n-                self.print_name(item.name)?;\n+                self.print_ident(item.ident)?;\n                 self.print_generic_params(&generics.params)?;\n                 self.end()?; // end the inner ibox\n \n@@ -637,7 +637,7 @@ impl<'a> State<'a> {\n             }\n             hir::ItemKind::Existential(ref exist) => {\n                 self.head(visibility_qualified(&item.vis, \"existential type\"))?;\n-                self.print_name(item.name)?;\n+                self.print_ident(item.ident)?;\n                 self.print_generic_params(&exist.generics.params)?;\n                 self.end()?; // end the inner ibox\n \n@@ -659,15 +659,16 @@ impl<'a> State<'a> {\n                 self.end()?; // end the outer ibox\n             }\n             hir::ItemKind::Enum(ref enum_definition, ref params) => {\n-                self.print_enum_def(enum_definition, params, item.name, item.span, &item.vis)?;\n+                self.print_enum_def(enum_definition, params, item.ident.name, item.span,\n+                                    &item.vis)?;\n             }\n             hir::ItemKind::Struct(ref struct_def, ref generics) => {\n                 self.head(visibility_qualified(&item.vis, \"struct\"))?;\n-                self.print_struct(struct_def, generics, item.name, item.span, true)?;\n+                self.print_struct(struct_def, generics, item.ident.name, item.span, true)?;\n             }\n             hir::ItemKind::Union(ref struct_def, ref generics) => {\n                 self.head(visibility_qualified(&item.vis, \"union\"))?;\n-                self.print_struct(struct_def, generics, item.name, item.span, true)?;\n+                self.print_struct(struct_def, generics, item.ident.name, item.span, true)?;\n             }\n             hir::ItemKind::Impl(unsafety,\n                           polarity,\n@@ -714,7 +715,7 @@ impl<'a> State<'a> {\n                 self.print_is_auto(is_auto)?;\n                 self.print_unsafety(unsafety)?;\n                 self.word_nbsp(\"trait\")?;\n-                self.print_name(item.name)?;\n+                self.print_ident(item.ident)?;\n                 self.print_generic_params(&generics.params)?;\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 for b in bounds.iter() {\n@@ -739,7 +740,7 @@ impl<'a> State<'a> {\n                 self.head(\"\")?;\n                 self.print_visibility(&item.vis)?;\n                 self.word_nbsp(\"trait\")?;\n-                self.print_name(item.name)?;\n+                self.print_ident(item.ident)?;\n                 self.print_generic_params(&generics.params)?;\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 // FIXME(durka) this seems to be some quite outdated syntax\n@@ -897,7 +898,7 @@ impl<'a> State<'a> {\n     pub fn print_variant(&mut self, v: &hir::Variant) -> io::Result<()> {\n         self.head(\"\")?;\n         let generics = hir::Generics::empty();\n-        self.print_struct(&v.node.data, &generics, v.node.name, v.span, false)?;\n+        self.print_struct(&v.node.data, &generics, v.node.ident.name, v.span, false)?;\n         if let Some(ref d) = v.node.disr_expr {\n             self.s.space()?;\n             self.word_space(\"=\")?;"}, {"sha": "8ff60e5f5622588838e23fa327b9f8dd3824319f", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -818,7 +818,7 @@ impl_stable_hash_for!(struct hir::EnumDef {\n });\n \n impl_stable_hash_for!(struct hir::VariantKind {\n-    name,\n+    ident -> (ident.name),\n     attrs,\n     data,\n     disr_expr\n@@ -852,7 +852,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Item {\n-            name,\n+            ident,\n             ref attrs,\n             id: _,\n             hir_id: _,\n@@ -862,7 +862,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {\n         } = *self;\n \n         hcx.hash_hir_item_like(|hcx| {\n-            name.hash_stable(hcx, hasher);\n+            ident.name.hash_stable(hcx, hasher);\n             attrs.hash_stable(hcx, hasher);\n             node.hash_stable(hcx, hasher);\n             vis.hash_stable(hcx, hasher);\n@@ -926,7 +926,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::AssociatedItemKind {\n }\n \n impl_stable_hash_for!(struct hir::ForeignItem {\n-    name,\n+    ident -> (ident.name),\n     attrs,\n     node,\n     id,"}, {"sha": "0c769c91801b8a9ff3cb2ccf96dbbeb22695cb08", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -557,7 +557,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n             self.warn_dead_code(\n                 item.id,\n                 span,\n-                item.name,\n+                item.ident.name,\n                 item.node.descriptive_variant(),\n                 participle,\n             );\n@@ -572,7 +572,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n                      g: &'tcx hir::Generics,\n                      id: ast::NodeId) {\n         if self.should_warn_about_variant(&variant.node) {\n-            self.warn_dead_code(variant.node.data.id(), variant.span, variant.node.name,\n+            self.warn_dead_code(variant.node.data.id(), variant.span, variant.node.ident.name,\n                                 \"variant\", \"constructed\");\n         } else {\n             intravisit::walk_variant(self, variant, g, id);\n@@ -581,7 +581,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, fi: &'tcx hir::ForeignItem) {\n         if self.should_warn_about_foreign_item(fi) {\n-            self.warn_dead_code(fi.id, fi.span, fi.name,\n+            self.warn_dead_code(fi.id, fi.span, fi.ident.name,\n                                 fi.node.descriptive_variant(), \"used\");\n         }\n         intravisit::walk_foreign_item(self, fi);"}, {"sha": "6b593a1a9f9b248a56abbafc8c027f15cec4d522", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -86,7 +86,7 @@ fn entry_point_type(item: &Item, at_root: bool) -> EntryPointType {\n                 EntryPointType::Start\n             } else if attr::contains_name(&item.attrs, \"main\") {\n                 EntryPointType::MainAttr\n-            } else if item.name == \"main\" {\n+            } else if item.ident.name == \"main\" {\n                 if at_root {\n                     // This is a top-level function so can be 'main'.\n                     EntryPointType::MainNamed"}, {"sha": "36d51c5971278cd41c3dd80407bd85739513eac8", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -2040,7 +2040,7 @@ impl<'tcx> Debug for Place<'tcx> {\n             Promoted(ref promoted) => write!(fmt, \"({:?}: {:?})\", promoted.0, promoted.1),\n             Projection(ref data) => match data.elem {\n                 ProjectionElem::Downcast(ref adt_def, index) => {\n-                    write!(fmt, \"({:?} as {})\", data.base, adt_def.variants[index].name)\n+                    write!(fmt, \"({:?} as {})\", data.base, adt_def.variants[index].ident)\n                 }\n                 ProjectionElem::Deref => write!(fmt, \"(*{:?})\", data.base),\n                 ProjectionElem::Field(field, ty) => {"}, {"sha": "171c53b7b20ba7e56082b85c2257a200327e325b", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,7 +1,7 @@\n use session::{self, DataTypeKind};\n use ty::{self, Ty, TyCtxt, TypeFoldable, ReprOptions};\n \n-use syntax::ast::{self, IntTy, UintTy};\n+use syntax::ast::{self, Ident, IntTy, UintTy};\n use syntax::attr;\n use syntax_pos::DUMMY_SP;\n \n@@ -1228,7 +1228,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n         let adt_kind = adt_def.adt_kind();\n         let adt_packed = adt_def.repr.packed();\n \n-        let build_variant_info = |n: Option<ast::Name>,\n+        let build_variant_info = |n: Option<Ident>,\n                                   flds: &[ast::Name],\n                                   layout: TyLayout<'tcx>| {\n             let mut min_size = Size::ZERO;\n@@ -1273,15 +1273,15 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n         match layout.variants {\n             Variants::Single { index } => {\n                 debug!(\"print-type-size `{:#?}` variant {}\",\n-                       layout, adt_def.variants[index].name);\n+                       layout, adt_def.variants[index].ident);\n                 if !adt_def.variants.is_empty() {\n                     let variant_def = &adt_def.variants[index];\n                     let fields: Vec<_> =\n                         variant_def.fields.iter().map(|f| f.ident.name).collect();\n                     record(adt_kind.into(),\n                            adt_packed,\n                            None,\n-                           vec![build_variant_info(Some(variant_def.name),\n+                           vec![build_variant_info(Some(variant_def.ident),\n                                                    &fields,\n                                                    layout)]);\n                 } else {\n@@ -1299,7 +1299,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     adt_def.variants.iter_enumerated().map(|(i, variant_def)| {\n                         let fields: Vec<_> =\n                             variant_def.fields.iter().map(|f| f.ident.name).collect();\n-                        build_variant_info(Some(variant_def.name),\n+                        build_variant_info(Some(variant_def.ident),\n                                            &fields,\n                                            layout.for_variant(self, i))\n                     })"}, {"sha": "8348aa8a956126cd8a0d3f4379f7bed267a92c95", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1780,7 +1780,7 @@ pub struct VariantDef {\n     /// The variant's `DefId`. If this is a tuple-like struct,\n     /// this is the `DefId` of the struct's ctor.\n     pub did: DefId,\n-    pub name: Name, // struct's name if this is a struct\n+    pub ident: Ident, // struct's name if this is a struct\n     pub discr: VariantDiscr,\n     pub fields: Vec<FieldDef>,\n     pub ctor_kind: CtorKind,\n@@ -1804,15 +1804,15 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n     /// remove this hack and use the constructor DefId everywhere.\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                did: DefId,\n-               name: Name,\n+               ident: Ident,\n                discr: VariantDiscr,\n                fields: Vec<FieldDef>,\n                adt_kind: AdtKind,\n                ctor_kind: CtorKind,\n                attribute_def_id: DefId)\n                -> Self\n     {\n-        debug!(\"VariantDef::new({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?})\", did, name, discr,\n+        debug!(\"VariantDef::new({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?})\", did, ident, discr,\n                fields, adt_kind, ctor_kind, attribute_def_id);\n         let mut flags = VariantFlags::NO_VARIANT_FLAGS;\n         if adt_kind == AdtKind::Struct && tcx.has_attr(attribute_def_id, \"non_exhaustive\") {\n@@ -1821,7 +1821,7 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n         }\n         VariantDef {\n             did,\n-            name,\n+            ident,\n             discr,\n             fields,\n             ctor_kind,\n@@ -1837,7 +1837,7 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n \n impl_stable_hash_for!(struct VariantDef {\n     did,\n-    name,\n+    ident -> (ident.name),\n     discr,\n     fields,\n     ctor_kind,\n@@ -1978,8 +1978,6 @@ impl_stable_hash_for!(struct ReprFlags {\n     bits\n });\n \n-\n-\n /// Represents the repr options provided by the user,\n #[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Default)]\n pub struct ReprOptions {"}, {"sha": "0fd04e9d20393ccebf7fd688de88220ac00f3357", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1215,7 +1215,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                         name: if fallback {\n                             String::new()\n                         } else {\n-                            adt.variants[index].name.as_str().to_string()\n+                            adt.variants[index].ident.as_str().to_string()\n                         },\n                         type_metadata: variant_type_metadata,\n                         offset: Size::ZERO,\n@@ -1255,7 +1255,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                         name: if fallback {\n                             String::new()\n                         } else {\n-                            adt.variants[i].name.as_str().to_string()\n+                            adt.variants[i].ident.as_str().to_string()\n                         },\n                         type_metadata: variant_type_metadata,\n                         offset: Size::ZERO,\n@@ -1321,7 +1321,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                        self.layout,\n                                        self.layout.fields.offset(0),\n                                        self.layout.field(cx, 0).size);\n-                    name.push_str(&adt.variants[*niche_variants.start()].name.as_str());\n+                    name.push_str(&adt.variants[*niche_variants.start()].ident.as_str());\n \n                     // Create the (singleton) list of descriptions of union members.\n                     vec![\n@@ -1365,7 +1365,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                         };\n \n                         MemberDescription {\n-                            name: adt.variants[i].name.as_str().to_string(),\n+                            name: adt.variants[i].ident.as_str().to_string(),\n                             type_metadata: variant_type_metadata,\n                             offset: Size::ZERO,\n                             size: self.layout.size,\n@@ -1433,7 +1433,7 @@ fn describe_enum_variant(\n     containing_scope: &'ll DIScope,\n     span: Span,\n ) -> (&'ll DICompositeType, MemberDescriptionFactory<'ll, 'tcx>) {\n-    let variant_name = variant.name.as_str();\n+    let variant_name = variant.ident.as_str();\n     let unique_type_id = debug_context(cx).type_map\n                                           .borrow_mut()\n                                           .get_unique_type_id_of_enum_variant(\n@@ -1527,7 +1527,7 @@ fn prepare_enum_metadata(\n         let enumerators_metadata: Vec<_> = def.discriminants(cx.tcx)\n             .zip(&def.variants)\n             .map(|((_, discr), v)| {\n-                let name = SmallCStr::new(&v.name.as_str());\n+                let name = SmallCStr::new(&v.ident.as_str());\n                 unsafe {\n                     Some(llvm::LLVMRustDIBuilderCreateEnumerator(\n                         DIB(cx),"}, {"sha": "97128c2d2a2ce519ab709d49a7a87ce4b2f38bd7", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -60,7 +60,7 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                  = (&layout.ty.sty, &layout.variants)\n             {\n                 if def.is_enum() && !def.variants.is_empty() {\n-                    write!(&mut name, \"::{}\", def.variants[index].name).unwrap();\n+                    write!(&mut name, \"::{}\", def.variants[index].ident).unwrap();\n                 }\n             }\n             Some(name)"}, {"sha": "a5f7d676862e08b1ca0b41a2966a4fa0ddac5941", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -261,7 +261,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n             assert!(idx < names.len());\n             for item in &m.item_ids {\n                 let item = this.infcx.tcx.hir().expect_item(item.id);\n-                if item.name.to_string() == names[idx] {\n+                if item.ident.to_string() == names[idx] {\n                     return search(this, item, idx + 1, names);\n                 }\n             }"}, {"sha": "2694a04b94ce4c3106bdd2f81486325e6b0026da", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -278,7 +278,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n \n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         if let hir::ItemKind::Mod(_) = it.node {\n-            self.check_snake_case(cx, \"module\", &it.name.as_str(), Some(it.span));\n+            self.check_snake_case(cx, \"module\", &it.ident.as_str(), Some(it.span));\n         }\n     }\n \n@@ -354,10 +354,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n                 if attr::find_by_name(&it.attrs, \"no_mangle\").is_some() {\n                     return;\n                 }\n-                NonUpperCaseGlobals::check_upper_case(cx, \"static variable\", it.name, it.span);\n+                NonUpperCaseGlobals::check_upper_case(cx, \"static variable\", it.ident.name,\n+                                                      it.span);\n             }\n             hir::ItemKind::Const(..) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"constant\", it.name, it.span);\n+                NonUpperCaseGlobals::check_upper_case(cx, \"constant\", it.ident.name,\n+                                                      it.span);\n             }\n             _ => {}\n         }"}, {"sha": "642681a73a8a0a57c2f878efdffe9ce7b4bf78f7", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -837,7 +837,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                                 let bytes = variant_layout.size.bytes().saturating_sub(discr_size);\n \n                                 debug!(\"- variant `{}` is {} bytes large\",\n-                                       variant.node.name,\n+                                       variant.node.ident,\n                                        bytes);\n                                 bytes\n                             })"}, {"sha": "dc8db5be5820ab4024778b5c224cc07ad3f49bfc", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -553,7 +553,7 @@ impl<'a, 'tcx> CrateMetadata {\n         ty::VariantDef::new(\n             tcx,\n             def_id,\n-            self.item_name(index).as_symbol(),\n+            Ident::from_interned_str(self.item_name(index)),\n             data.discr,\n             item.children.decode(self).map(|index| {\n                 let f = self.entry(index);"}, {"sha": "7b1ed2b0b26ea7e253bcaed968015676db7b3ad4", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -481,10 +481,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                             }\n                         }\n                         AdtKind::Enum => {\n-                            let def = match *qpath {\n-                                hir::QPath::Resolved(_, ref path) => path.def,\n-                                hir::QPath::TypeRelative(..) => Def::Err,\n-                            };\n+                            let def = cx.tables().qpath_def(qpath, expr.hir_id);\n                             match def {\n                                 Def::Variant(variant_id) => {\n                                     assert!(base.is_none());"}, {"sha": "f758e488877158ace2e54508113ca17dd908cac1", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -306,7 +306,7 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n                 let pat_ty = cx.tables.pat_ty(p);\n                 if let ty::Adt(edef, _) = pat_ty.sty {\n                     if edef.is_enum() && edef.variants.iter().any(|variant| {\n-                        variant.name == ident.name && variant.ctor_kind == CtorKind::Const\n+                        variant.ident == ident && variant.ctor_kind == CtorKind::Const\n                     }) {\n                         let ty_path = cx.tcx.item_path_str(edef.did);\n                         let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,"}, {"sha": "62ec52aac134605238e442c4661383277d8d261e", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -280,7 +280,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                 let mut start_or_continue = || if first { first = false; \"\" } else { \", \" };\n \n                 if let Some(variant) = variant {\n-                    write!(f, \"{}\", variant.name)?;\n+                    write!(f, \"{}\", variant.ident)?;\n \n                     // Only for Adt we can have `S {...}`,\n                     // which we handle separately here."}, {"sha": "a5fb44587400a1323e412e3a061967f19189fcdb", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -246,7 +246,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n         variant_id: VariantIdx,\n         new_op: OpTy<'tcx, M::PointerTag>\n     ) -> EvalResult<'tcx> {\n-        let name = old_op.layout.ty.ty_adt_def().unwrap().variants[variant_id].name;\n+        let name = old_op.layout.ty.ty_adt_def().unwrap().variants[variant_id].ident.name;\n         self.visit_elem(new_op, PathElem::Variant(name))\n     }\n "}, {"sha": "8454dbc3410c9510702917647ef996ea2a0d2e0a", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -304,7 +304,7 @@ impl<'a> Resolver<'a> {\n                     let features = self.session.features_untracked();\n                     if attr_kind == NonMacroAttrKind::Custom {\n                         assert!(path.segments.len() == 1);\n-                        let name = path.segments[0].ident.name.as_str();\n+                        let name = path.segments[0].ident.as_str();\n                         if name.starts_with(\"rustc_\") {\n                             if !features.rustc_attrs {\n                                 let msg = \"unless otherwise specified, attributes with the prefix \\"}, {"sha": "1db7141917f98e7cfdfa386d11f39901e5b53e1d", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 189, "deletions": 24, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -31,6 +31,12 @@ use std::collections::BTreeSet;\n use std::iter;\n use std::slice;\n \n+use super::{check_type_alias_enum_variants_enabled};\n+use rustc_data_structures::fx::FxHashSet;\n+\n+#[derive(Debug)]\n+pub struct PathSeg(pub DefId, pub usize);\n+\n pub trait AstConv<'gcx, 'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n \n@@ -563,7 +569,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n \n         let has_self = generic_params.has_self;\n         let (_, potential_assoc_types) = Self::check_generic_arg_count(\n-            self.tcx(),\n+            tcx,\n             span,\n             &generic_params,\n             &generic_args,\n@@ -588,7 +594,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         };\n \n         let substs = Self::create_substs_for_generic_args(\n-            self.tcx(),\n+            tcx,\n             def_id,\n             &[][..],\n             self_ty.is_some(),\n@@ -1290,7 +1296,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         // item is declared.\n         let bound = match (&ty.sty, ty_path_def) {\n             (_, Def::SelfTy(Some(_), Some(impl_def_id))) => {\n-                // `Self` in an impl of a trait -- we have a concrete `self` type and a\n+                // `Self` in an impl of a trait -- we have a concrete self type and a\n                 // trait reference.\n                 let trait_ref = match tcx.impl_trait_ref(impl_def_id) {\n                     Some(trait_ref) => trait_ref,\n@@ -1317,13 +1323,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             }\n             (&ty::Adt(adt_def, _substs), Def::Enum(_did)) => {\n                 let ty_str = ty.to_string();\n-                // Incorrect enum variant\n+                // Incorrect enum variant.\n                 let mut err = tcx.sess.struct_span_err(\n                     span,\n                     &format!(\"no variant `{}` on enum `{}`\", &assoc_name.as_str(), ty_str),\n                 );\n-                // Check if it was a typo\n-                let input = adt_def.variants.iter().map(|variant| &variant.name);\n+                // Check if it was a typo.\n+                let input = adt_def.variants.iter().map(|variant| &variant.ident.name);\n                 if let Some(suggested_name) = find_best_match_for_name(\n                     input,\n                     &assoc_name.as_str(),\n@@ -1342,7 +1348,24 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 return (tcx.types.err, Def::Err);\n             }\n             _ => {\n-                // Don't print TyErr to the user.\n+                // Check if we have an enum variant.\n+                match ty.sty {\n+                    ty::Adt(adt_def, _) if adt_def.is_enum() => {\n+                        let variant_def = adt_def.variants.iter().find(|vd| {\n+                            tcx.hygienic_eq(assoc_name, vd.ident, adt_def.did)\n+                        });\n+                        if let Some(variant_def) = variant_def {\n+                            check_type_alias_enum_variants_enabled(tcx, span);\n+\n+                            let def = Def::Variant(variant_def.did);\n+                            tcx.check_stability(def.def_id(), Some(ref_id), span);\n+                            return (ty, def);\n+                        }\n+                    },\n+                    _ => (),\n+                }\n+\n+                // Don't print `TyErr` to the user.\n                 if !ty.references_error() {\n                     self.report_ambiguous_associated_type(span,\n                                                           &ty.to_string(),\n@@ -1358,8 +1381,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         let item = tcx.associated_items(trait_did).find(|i| {\n             Namespace::from(i.kind) == Namespace::Type &&\n                 i.ident.modern() == assoc_ident\n-        })\n-        .expect(\"missing associated type\");\n+        }).expect(\"missing associated type\");\n \n         let ty = self.projected_ty_from_poly_trait_ref(span, item.def_id, bound);\n         let ty = self.normalize_ty(span, ty);\n@@ -1410,7 +1432,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         self.normalize_ty(span, tcx.mk_projection(item_def_id, trait_ref.substs))\n     }\n \n-    pub fn prohibit_generics<'a, T: IntoIterator<Item = &'a hir::PathSegment>>(&self, segments: T) {\n+    pub fn prohibit_generics<'a, T: IntoIterator<Item = &'a hir::PathSegment>>(\n+            &self, segments: T) -> bool {\n+        let mut has_err = false;\n         for segment in segments {\n             segment.with_generic_args(|generic_args| {\n                 let (mut err_for_lt, mut err_for_ty) = (false, false);\n@@ -1419,32 +1443,36 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                         hir::GenericArg::Lifetime(lt) => {\n                             if err_for_lt { continue }\n                             err_for_lt = true;\n+                            has_err = true;\n                             (struct_span_err!(self.tcx().sess, lt.span, E0110,\n-                                              \"lifetime parameters are not allowed on this type\"),\n+                                              \"lifetime arguments are not allowed on this entity\"),\n                              lt.span,\n                              \"lifetime\")\n                         }\n                         hir::GenericArg::Type(ty) => {\n                             if err_for_ty { continue }\n                             err_for_ty = true;\n+                            has_err = true;\n                             (struct_span_err!(self.tcx().sess, ty.span, E0109,\n-                                              \"type parameters are not allowed on this type\"),\n+                                              \"type arguments are not allowed on this entity\"),\n                              ty.span,\n                              \"type\")\n                         }\n                     };\n-                    span_err.span_label(span, format!(\"{} parameter not allowed\", kind))\n+                    span_err.span_label(span, format!(\"{} argument not allowed\", kind))\n                             .emit();\n                     if err_for_lt && err_for_ty {\n                         break;\n                     }\n                 }\n                 for binding in &generic_args.bindings {\n+                    has_err = true;\n                     Self::prohibit_assoc_ty_binding(self.tcx(), binding.span);\n                     break;\n                 }\n             })\n         }\n+        has_err\n     }\n \n     pub fn prohibit_assoc_ty_binding(tcx: TyCtxt, span: Span) {\n@@ -1453,6 +1481,134 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         err.span_label(span, \"associated type not allowed here\").emit();\n     }\n \n+    pub fn def_ids_for_path_segments(&self,\n+                                     segments: &[hir::PathSegment],\n+                                     self_ty: Option<Ty<'tcx>>,\n+                                     def: Def)\n+                                     -> Vec<PathSeg> {\n+        // We need to extract the type parameters supplied by the user in\n+        // the path `path`. Due to the current setup, this is a bit of a\n+        // tricky-process; the problem is that resolve only tells us the\n+        // end-point of the path resolution, and not the intermediate steps.\n+        // Luckily, we can (at least for now) deduce the intermediate steps\n+        // just from the end-point.\n+        //\n+        // There are basically five cases to consider:\n+        //\n+        // 1. Reference to a constructor of a struct:\n+        //\n+        //        struct Foo<T>(...)\n+        //\n+        //    In this case, the parameters are declared in the type space.\n+        //\n+        // 2. Reference to a constructor of an enum variant:\n+        //\n+        //        enum E<T> { Foo(...) }\n+        //\n+        //    In this case, the parameters are defined in the type space,\n+        //    but may be specified either on the type or the variant.\n+        //\n+        // 3. Reference to a fn item or a free constant:\n+        //\n+        //        fn foo<T>() { }\n+        //\n+        //    In this case, the path will again always have the form\n+        //    `a::b::foo::<T>` where only the final segment should have\n+        //    type parameters. However, in this case, those parameters are\n+        //    declared on a value, and hence are in the `FnSpace`.\n+        //\n+        // 4. Reference to a method or an associated constant:\n+        //\n+        //        impl<A> SomeStruct<A> {\n+        //            fn foo<B>(...)\n+        //        }\n+        //\n+        //    Here we can have a path like\n+        //    `a::b::SomeStruct::<A>::foo::<B>`, in which case parameters\n+        //    may appear in two places. The penultimate segment,\n+        //    `SomeStruct::<A>`, contains parameters in TypeSpace, and the\n+        //    final segment, `foo::<B>` contains parameters in fn space.\n+        //\n+        // 5. Reference to a local variable\n+        //\n+        //    Local variables can't have any type parameters.\n+        //\n+        // The first step then is to categorize the segments appropriately.\n+\n+        let tcx = self.tcx();\n+\n+        assert!(!segments.is_empty());\n+        let last = segments.len() - 1;\n+\n+        let mut path_segs = vec![];\n+\n+        match def {\n+            // Case 1. Reference to a struct constructor.\n+            Def::StructCtor(def_id, ..) |\n+            Def::SelfCtor(.., def_id) => {\n+                // Everything but the final segment should have no\n+                // parameters at all.\n+                let generics = tcx.generics_of(def_id);\n+                // Variant and struct constructors use the\n+                // generics of their parent type definition.\n+                let generics_def_id = generics.parent.unwrap_or(def_id);\n+                path_segs.push(PathSeg(generics_def_id, last));\n+            }\n+\n+            // Case 2. Reference to a variant constructor.\n+            Def::Variant(def_id) |\n+            Def::VariantCtor(def_id, ..) => {\n+                let adt_def = self_ty.map(|t| t.ty_adt_def().unwrap());\n+                let (generics_def_id, index) = if let Some(adt_def) = adt_def {\n+                    debug_assert!(adt_def.is_enum());\n+                    (adt_def.did, last)\n+                } else if last >= 1 && segments[last - 1].args.is_some() {\n+                    // Everything but the penultimate segment should have no\n+                    // parameters at all.\n+                    let enum_def_id = tcx.parent_def_id(def_id).unwrap();\n+                    (enum_def_id, last - 1)\n+                } else {\n+                    // FIXME: lint here recommending `Enum::<...>::Variant` form\n+                    // instead of `Enum::Variant::<...>` form.\n+\n+                    // Everything but the final segment should have no\n+                    // parameters at all.\n+                    let generics = tcx.generics_of(def_id);\n+                    // Variant and struct constructors use the\n+                    // generics of their parent type definition.\n+                    (generics.parent.unwrap_or(def_id), last)\n+                };\n+                path_segs.push(PathSeg(generics_def_id, index));\n+            }\n+\n+            // Case 3. Reference to a top-level value.\n+            Def::Fn(def_id) |\n+            Def::Const(def_id) |\n+            Def::Static(def_id, _) => {\n+                path_segs.push(PathSeg(def_id, last));\n+            }\n+\n+            // Case 4. Reference to a method or associated const.\n+            Def::Method(def_id) |\n+            Def::AssociatedConst(def_id) => {\n+                if segments.len() >= 2 {\n+                    let generics = tcx.generics_of(def_id);\n+                    path_segs.push(PathSeg(generics.parent.unwrap(), last - 1));\n+                }\n+                path_segs.push(PathSeg(def_id, last));\n+            }\n+\n+            // Case 5. Local variable, no generics.\n+            Def::Local(..) | Def::Upvar(..) => {}\n+\n+            _ => bug!(\"unexpected definition: {:?}\", def),\n+        }\n+\n+        debug!(\"path_segs = {:?}\", path_segs);\n+\n+        path_segs\n+    }\n+\n     // Check a type `Path` and convert it to a `Ty`.\n     pub fn def_to_ty(&self,\n                      opt_self_ty: Option<Ty<'tcx>>,\n@@ -1483,14 +1639,24 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 self.prohibit_generics(path.segments.split_last().unwrap().1);\n                 self.ast_path_to_ty(span, did, path.segments.last().unwrap())\n             }\n-            Def::Variant(did) if permit_variants => {\n+            Def::Variant(_) if permit_variants => {\n                 // Convert \"variant type\" as if it were a real type.\n                 // The resulting `Ty` is type of the variant's enum for now.\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(path.segments.split_last().unwrap().1);\n-                self.ast_path_to_ty(span,\n-                                    tcx.parent_def_id(did).unwrap(),\n-                                    path.segments.last().unwrap())\n+\n+                let path_segs = self.def_ids_for_path_segments(&path.segments, None, path.def);\n+                let generic_segs: FxHashSet<_> =\n+                    path_segs.iter().map(|PathSeg(_, index)| index).collect();\n+                self.prohibit_generics(path.segments.iter().enumerate().filter_map(|(index, seg)| {\n+                    if !generic_segs.contains(&index) {\n+                        Some(seg)\n+                    } else {\n+                        None\n+                    }\n+                }));\n+\n+                let PathSeg(def_id, index) = path_segs.last().unwrap();\n+                self.ast_path_to_ty(span, *def_id, &path.segments[*index])\n             }\n             Def::TyParam(did) => {\n                 assert_eq!(opt_self_ty, None);\n@@ -1504,25 +1670,24 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 tcx.mk_ty_param(index, tcx.hir().name(node_id).as_interned_str())\n             }\n             Def::SelfTy(_, Some(def_id)) => {\n-                // `Self` in impl (we know the concrete type)\n-\n+                // `Self` in impl (we know the concrete type).\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n-\n                 tcx.at(span).type_of(def_id)\n             }\n             Def::SelfTy(Some(_), None) => {\n-                // `Self` in trait\n+                // `Self` in trait.\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n                 tcx.mk_self_type()\n             }\n             Def::AssociatedTy(def_id) => {\n-                self.prohibit_generics(&path.segments[..path.segments.len()-2]);\n+                debug_assert!(path.segments.len() >= 2);\n+                self.prohibit_generics(&path.segments[..path.segments.len() - 2]);\n                 self.qpath_to_ty(span,\n                                  opt_self_ty,\n                                  def_id,\n-                                 &path.segments[path.segments.len()-2],\n+                                 &path.segments[path.segments.len() - 2],\n                                  path.segments.last().unwrap())\n             }\n             Def::PrimTy(prim_ty) => {"}, {"sha": "b66c383edb51e85d2deee7586469c723c1612b45", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -17,6 +17,8 @@ use util::nodemap::FxHashMap;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::cmp;\n \n+use super::report_unexpected_variant_def;\n+\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// The `is_arg` argument indicates whether this pattern is the\n     /// *outermost* pattern in an argument (e.g., in `fn foo(&x:\n@@ -273,7 +275,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             PatKind::Tuple(ref elements, ddpos) => {\n                 let mut expected_len = elements.len();\n                 if ddpos.is_some() {\n-                    // Require known type only when `..` is present\n+                    // Require known type only when `..` is present.\n                     if let ty::Tuple(ref tys) =\n                             self.structurally_resolved_type(pat.span, expected).sty {\n                         expected_len = tys.len();\n@@ -282,8 +284,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let max_len = cmp::max(expected_len, elements.len());\n \n                 let element_tys_iter = (0..max_len).map(|_| self.next_ty_var(\n-                    // FIXME: MiscVariable for now, obtaining the span and name information\n-                    //        from all tuple elements isn't trivial.\n+                    // FIXME: `MiscVariable` for now -- obtaining the span and name information\n+                    // from all tuple elements isn't trivial.\n                     TypeVariableOrigin::TypeInference(pat.span)));\n                 let element_tys = tcx.mk_type_list(element_tys_iter);\n                 let pat_ty = tcx.mk_ty(ty::Tuple(element_tys));\n@@ -736,12 +738,6 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                       expected: Ty<'tcx>) -> Ty<'tcx>\n     {\n         let tcx = self.tcx;\n-        let report_unexpected_def = |def: Def| {\n-            span_err!(tcx.sess, pat.span, E0533,\n-                      \"expected unit struct/variant or constant, found {} `{}`\",\n-                      def.kind_name(),\n-                      hir::print::to_string(tcx.hir(), |s| s.print_qpath(qpath, false)));\n-        };\n \n         // Resolve the path and check the definition for errors.\n         let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(qpath, pat.id, pat.span);\n@@ -751,7 +747,11 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 return tcx.types.err;\n             }\n             Def::Method(..) => {\n-                report_unexpected_def(def);\n+                report_unexpected_variant_def(tcx, &def, pat.span, qpath);\n+                return tcx.types.err;\n+            }\n+            Def::VariantCtor(_, CtorKind::Fictive) => {\n+                report_unexpected_variant_def(tcx, &def, pat.span, qpath);\n                 return tcx.types.err;\n             }\n             Def::VariantCtor(_, CtorKind::Const) |\n@@ -952,7 +952,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 if plural == \"\" {\n                     let input = unmentioned_fields.iter().map(|field| &field.name);\n                     let suggested_name =\n-                        find_best_match_for_name(input, &ident.name.as_str(), None);\n+                        find_best_match_for_name(input, &ident.as_str(), None);\n                     if let Some(suggested_name) = suggested_name {\n                         err.span_suggestion(*span, \"did you mean\", suggested_name.to_string());\n                         // we don't want to throw `E0027` in case we have thrown `E0026` for them"}, {"sha": "a36b21921436ecaf9cba86641274bdfbd891e4ed", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -71,7 +71,7 @@ fn equate_intrinsic_type<'a, 'tcx>(\n pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       it: &hir::ForeignItem) {\n     let param = |n| tcx.mk_ty_param(n, Symbol::intern(&format!(\"P{}\", n)).as_interned_str());\n-    let name = it.name.as_str();\n+    let name = it.ident.as_str();\n \n     let mk_va_list_ty = || {\n         tcx.lang_items().va_list().map(|did| {\n@@ -393,7 +393,7 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let def_id = tcx.hir().local_def_id(it.id);\n     let i_n_tps = tcx.generics_of(def_id).own_counts().types;\n-    let name = it.name.as_str();\n+    let name = it.ident.as_str();\n \n     let (n_tps, inputs, output) = match &*name {\n         \"simd_eq\" | \"simd_ne\" | \"simd_lt\" | \"simd_le\" | \"simd_gt\" | \"simd_ge\" => {"}, {"sha": "fe5f43e3c01ef7cc56990d7d0a6dcda48e4d78b9", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 44, "deletions": 13, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,4 +1,4 @@\n-//! Method lookup: the secret sauce of Rust. See the [rustc guide] chapter.\n+//! Method lookup: the secret sauce of Rust. See the [rustc guide] for more information.\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/method-lookup.html\n \n@@ -8,7 +8,7 @@ mod suggest;\n \n pub use self::MethodError::*;\n pub use self::CandidateSource::*;\n-pub use self::suggest::TraitInfo;\n+pub use self::suggest::{SelfSource, TraitInfo};\n \n use check::FnCtxt;\n use namespace::Namespace;\n@@ -25,6 +25,7 @@ use rustc::infer::{self, InferOk};\n use syntax::ast;\n use syntax_pos::Span;\n \n+use crate::{check_type_alias_enum_variants_enabled};\n use self::probe::{IsSuggestion, ProbeScope};\n \n pub fn provide(providers: &mut ty::query::Providers) {\n@@ -362,21 +363,51 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         self_ty: Ty<'tcx>,\n                         expr_id: ast::NodeId)\n                         -> Result<Def, MethodError<'tcx>> {\n+        debug!(\"resolve_ufcs: method_name={:?} self_ty={:?} expr_id={:?}\",\n+            method_name,\n+            self_ty,\n+            expr_id\n+        );\n+\n+        let tcx = self.tcx;\n+\n         let mode = probe::Mode::Path;\n-        let pick = self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n-                                       self_ty, expr_id, ProbeScope::TraitsInScope)?;\n+        match self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n+                                  self_ty, expr_id, ProbeScope::TraitsInScope) {\n+            Ok(pick) => {\n+                if let Some(import_id) = pick.import_id {\n+                    let import_def_id = tcx.hir().local_def_id(import_id);\n+                    debug!(\"resolve_ufcs: used_trait_import: {:?}\", import_def_id);\n+                    Lrc::get_mut(&mut self.tables.borrow_mut().used_trait_imports)\n+                                                .unwrap().insert(import_def_id);\n+                }\n \n-        if let Some(import_id) = pick.import_id {\n-            let import_def_id = self.tcx.hir().local_def_id(import_id);\n-            debug!(\"used_trait_import: {:?}\", import_def_id);\n-            Lrc::get_mut(&mut self.tables.borrow_mut().used_trait_imports)\n-                                        .unwrap().insert(import_def_id);\n-        }\n+                let def = pick.item.def();\n+                tcx.check_stability(def.def_id(), Some(expr_id), span);\n \n-        let def = pick.item.def();\n-        self.tcx.check_stability(def.def_id(), Some(expr_id), span);\n+                Ok(def)\n+            }\n+            Err(err) => {\n+                // Check if we have an enum variant.\n+                match self_ty.sty {\n+                    ty::Adt(adt_def, _) if adt_def.is_enum() => {\n+                        let variant_def = adt_def.variants.iter().find(|vd| {\n+                            tcx.hygienic_eq(method_name, vd.ident, adt_def.did)\n+                        });\n+                        if let Some(variant_def) = variant_def {\n+                            check_type_alias_enum_variants_enabled(tcx, span);\n+\n+                            let def = Def::VariantCtor(variant_def.did, variant_def.ctor_kind);\n+                            tcx.check_stability(def.def_id(), Some(expr_id), span);\n+                            return Ok(def);\n+                        }\n+                    },\n+                    _ => (),\n+                }\n \n-        Ok(def)\n+                Err(err)\n+            }\n+        }\n     }\n \n     /// Find item with name `item_name` defined in impl/trait `def_id`"}, {"sha": "98c425655d2d3c1bef6e4138a85fcb6220c07a0e", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 41, "deletions": 33, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -6,7 +6,7 @@ use errors::{Applicability, DiagnosticBuilder};\n use middle::lang_items::FnOnceTraitLangItem;\n use namespace::Namespace;\n use rustc_data_structures::sync::Lrc;\n-use rustc::hir::{self, Node};\n+use rustc::hir::{self, ExprKind, Node, QPath};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n use rustc::hir::map as hir_map;\n@@ -60,13 +60,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn report_method_error(&self,\n-                               span: Span,\n-                               rcvr_ty: Ty<'tcx>,\n-                               item_name: ast::Ident,\n-                               rcvr_expr: Option<&hir::Expr>,\n-                               error: MethodError<'tcx>,\n-                               args: Option<&'gcx [hir::Expr]>) {\n+    pub fn report_method_error<'b>(&self,\n+                                   span: Span,\n+                                   rcvr_ty: Ty<'tcx>,\n+                                   item_name: ast::Ident,\n+                                   source: SelfSource<'b>,\n+                                   error: MethodError<'tcx>,\n+                                   args: Option<&'gcx [hir::Expr]>) {\n         // Avoid suggestions when we don't know what's going on.\n         if rcvr_ty.references_error() {\n             return;\n@@ -185,7 +185,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     \"method\"\n                 } else if actual.is_enum() {\n                     if let Adt(ref adt_def, _) = actual.sty {\n-                        let names = adt_def.variants.iter().map(|s| &s.name);\n+                        let names = adt_def.variants.iter().map(|s| &s.ident.name);\n                         suggestion = find_best_match_for_name(names,\n                                                               &item_name.as_str(),\n                                                               None);\n@@ -212,10 +212,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         .filter_map(|info|\n                             self.associated_item(info.def_id, item_name, Namespace::Value)\n                         );\n-                    if let (true, false, Some(expr), Some(_)) = (actual.is_numeric(),\n-                                                                 actual.has_concrete_skeleton(),\n-                                                                 rcvr_expr,\n-                                                                 candidates.next()) {\n+                    if let (true, false, SelfSource::MethodCall(expr), Some(_)) =\n+                           (actual.is_numeric(),\n+                            actual.has_concrete_skeleton(),\n+                            source,\n+                            candidates.next()) {\n                         let mut err = struct_span_err!(\n                             tcx.sess,\n                             span,\n@@ -231,7 +232,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             \"f32\"\n                         };\n                         match expr.node {\n-                            hir::ExprKind::Lit(ref lit) => {\n+                            ExprKind::Lit(ref lit) => {\n                                 // numeric literal\n                                 let snippet = tcx.sess.source_map().span_to_snippet(lit.span)\n                                     .unwrap_or_else(|_| \"<numeric literal>\".to_owned());\n@@ -247,9 +248,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                     Applicability::MaybeIncorrect,\n                                 );\n                             }\n-                            hir::ExprKind::Path(ref qpath) => {\n+                            ExprKind::Path(ref qpath) => {\n                                 // local binding\n-                                if let &hir::QPath::Resolved(_, ref path) = &qpath {\n+                                if let &QPath::Resolved(_, ref path) = &qpath {\n                                     if let hir::def::Def::Local(node_id) = path.def {\n                                         let span = tcx.hir().span(node_id);\n                                         let snippet = tcx.sess.source_map().span_to_snippet(span)\n@@ -294,15 +295,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     } else {\n                         let mut err = struct_span_err!(\n                             tcx.sess,\n-                            span,\n+                            item_name.span,\n                             E0599,\n                             \"no {} named `{}` found for type `{}` in the current scope\",\n                             item_kind,\n                             item_name,\n                             ty_str\n                         );\n                         if let Some(suggestion) = suggestion {\n-                            err.note(&format!(\"did you mean `{}::{}`?\", ty_str, suggestion));\n+                            // enum variant\n+                            err.help(&format!(\"did you mean `{}`?\", suggestion));\n                         }\n                         err\n                     }\n@@ -326,7 +328,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 // If the method name is the name of a field with a function or closure type,\n                 // give a helping note that it has to be called as `(x.f)(...)`.\n-                if let Some(expr) = rcvr_expr {\n+                if let SelfSource::MethodCall(expr) = source {\n                     for (ty, _) in self.autoderef(span, rcvr_ty) {\n                         if let ty::Adt(def, substs) = ty.sty {\n                             if !def.is_enum() {\n@@ -377,10 +379,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     }\n \n-                    if let Some(expr) = rcvr_expr {\n+                    if let SelfSource::MethodCall(expr) = source {\n                         if let Ok(expr_string) = tcx.sess.source_map().span_to_snippet(expr.span) {\n                             report_function!(expr.span, expr_string);\n-                        } else if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) =\n+                        } else if let ExprKind::Path(QPath::Resolved(_, ref path)) =\n                             expr.node\n                         {\n                             if let Some(segment) = path.segments.last() {\n@@ -396,7 +398,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     err.span_label(span, \"this is an associated function, not a method\");\n                 }\n                 if static_sources.len() == 1 {\n-                    if let Some(expr) = rcvr_expr {\n+                    if let SelfSource::MethodCall(expr) = source {\n                         err.span_suggestion_with_applicability(expr.span.to(span),\n                                             \"use associated function syntax instead\",\n                                             format!(\"{}::{}\",\n@@ -433,7 +435,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                   span,\n                                                   rcvr_ty,\n                                                   item_name,\n-                                                  rcvr_expr,\n+                                                  source,\n                                                   out_of_scope_traits);\n                 }\n \n@@ -571,18 +573,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn suggest_traits_to_import(&self,\n-                                err: &mut DiagnosticBuilder,\n-                                span: Span,\n-                                rcvr_ty: Ty<'tcx>,\n-                                item_name: ast::Ident,\n-                                rcvr_expr: Option<&hir::Expr>,\n-                                valid_out_of_scope_traits: Vec<DefId>) {\n+    fn suggest_traits_to_import<'b>(&self,\n+                                    err: &mut DiagnosticBuilder,\n+                                    span: Span,\n+                                    rcvr_ty: Ty<'tcx>,\n+                                    item_name: ast::Ident,\n+                                    source: SelfSource<'b>,\n+                                    valid_out_of_scope_traits: Vec<DefId>) {\n         if self.suggest_valid_traits(err, valid_out_of_scope_traits) {\n             return;\n         }\n \n-        let type_is_local = self.type_derefs_to_local(span, rcvr_ty, rcvr_expr);\n+        let type_is_local = self.type_derefs_to_local(span, rcvr_ty, source);\n \n         // There are no traits implemented, so lets suggest some traits to\n         // implement, by finding ones that have the item name, and are\n@@ -643,7 +645,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn type_derefs_to_local(&self,\n                             span: Span,\n                             rcvr_ty: Ty<'tcx>,\n-                            rcvr_expr: Option<&hir::Expr>) -> bool {\n+                            source: SelfSource) -> bool {\n         fn is_local(ty: Ty) -> bool {\n             match ty.sty {\n                 ty::Adt(def, _) => def.did.is_local(),\n@@ -663,14 +665,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // This occurs for UFCS desugaring of `T::method`, where there is no\n         // receiver expression for the method call, and thus no autoderef.\n-        if rcvr_expr.is_none() {\n+        if let SelfSource::QPath(_) = source {\n             return is_local(self.resolve_type_vars_with_obligations(rcvr_ty));\n         }\n \n         self.autoderef(span, rcvr_ty).any(|(ty, _)| is_local(ty))\n     }\n }\n \n+#[derive(Copy, Clone)]\n+pub enum SelfSource<'a> {\n+    QPath(&'a hir::Ty),\n+    MethodCall(&'a hir::Expr /* rcvr */),\n+}\n+\n #[derive(Copy, Clone)]\n pub struct TraitInfo {\n     pub def_id: DefId,"}, {"sha": "39beb2832851b0bf95ff6e18629423290a99c407", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 144, "deletions": 203, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -83,10 +83,10 @@ mod generator_interior;\n mod intrinsic;\n mod op;\n \n-use astconv::AstConv;\n+use astconv::{AstConv, PathSeg};\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n-use rustc::hir::{self, GenericArg, ItemKind, Node, PatKind};\n-use rustc::hir::def::Def;\n+use rustc::hir::{self, ExprKind, GenericArg, ItemKind, Node, PatKind, QPath};\n+use rustc::hir::def::{CtorKind, Def};\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -101,14 +101,14 @@ use rustc::infer::opaque_types::OpaqueTypeDecl;\n use rustc::infer::type_variable::{TypeVariableOrigin};\n use rustc::middle::region;\n use rustc::mir::interpret::{ConstValue, GlobalId};\n-use rustc::ty::subst::{CanonicalUserSubsts, UnpackedKind, Subst, Substs,\n-                       UserSelfTy, UserSubsts};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n use rustc::ty::{self, AdtKind, Ty, TyCtxt, GenericParamDefKind, RegionKind, Visibility,\n                 ToPolyTraitRef, ToPredicate};\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::query::Providers;\n+use rustc::ty::subst::{CanonicalUserSubsts, UnpackedKind, Subst, Substs,\n+                       UserSelfTy, UserSubsts};\n use rustc::ty::util::{Representability, IntTypeExt, Discr};\n use rustc::ty::layout::VariantIdx;\n use syntax_pos::{self, BytePos, Span, MultiSpan};\n@@ -142,7 +142,7 @@ use self::autoderef::Autoderef;\n use self::callee::DeferredCallResolution;\n use self::coercion::{CoerceMany, DynamicCoerceMany};\n pub use self::compare_method::{compare_impl_method, compare_const_impl};\n-use self::method::MethodCallee;\n+use self::method::{MethodCallee, SelfSource};\n use self::TupleArgumentsFlag::*;\n \n /// The type of a local binding, including the revealed type for anon types.\n@@ -507,9 +507,6 @@ impl<'gcx, 'tcx> EnclosingBreakables<'gcx, 'tcx> {\n     }\n }\n \n-#[derive(Debug)]\n-struct PathSeg(DefId, usize);\n-\n pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     body_id: ast::NodeId,\n \n@@ -1327,7 +1324,7 @@ pub fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Ite\n         }\n         hir::ItemKind::Fn(..) => {} // entirely within check_item_body\n         hir::ItemKind::Impl(.., ref impl_item_refs) => {\n-            debug!(\"ItemKind::Impl {} with id {}\", it.name, it.id);\n+            debug!(\"ItemKind::Impl {} with id {}\", it.ident, it.id);\n             let impl_def_id = tcx.hir().local_def_id(it.id);\n             if let Some(impl_trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n                 check_impl_items_against_trait(\n@@ -1864,6 +1861,16 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     check_representable(tcx, sp, def_id);\n }\n \n+fn report_unexpected_variant_def<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                                 def: &Def,\n+                                                 span: Span,\n+                                                 qpath: &QPath) {\n+    span_err!(tcx.sess, span, E0533,\n+              \"expected unit struct/variant or constant, found {} `{}`\",\n+              def.kind_name(),\n+              hir::print::to_string(tcx.hir(), |s| s.print_qpath(qpath, false)));\n+}\n+\n impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n@@ -2947,7 +2954,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 let is_closure = match arg.node {\n-                    hir::ExprKind::Closure(..) => true,\n+                    ExprKind::Closure(..) => true,\n                     _ => false\n                 };\n \n@@ -3097,8 +3104,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n-            // Add help to type error if this is an `if` condition with an assignment\n-            if let (ExpectIfCondition, &hir::ExprKind::Assign(ref lhs, ref rhs))\n+            // Add help to type error if this is an `if` condition with an assignment.\n+            if let (ExpectIfCondition, &ExprKind::Assign(ref lhs, ref rhs))\n                  = (expected, &expr.node)\n             {\n                 let msg = \"try comparing for equality\";\n@@ -3244,7 +3251,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     self.report_method_error(span,\n                                              rcvr_t,\n                                              segment.ident,\n-                                             Some(rcvr),\n+                                             SelfSource::MethodCall(rcvr),\n                                              error,\n                                              Some(args));\n                 }\n@@ -3529,7 +3536,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 ty::Adt(adt, ..) if adt.is_enum() => {\n                     struct_span_err!(self.tcx.sess, field.ident.span, E0559,\n                                      \"{} `{}::{}` has no field named `{}`\",\n-                                     kind_name, actual, variant.name, field.ident)\n+                                     kind_name, actual, variant.ident, field.ident)\n                 }\n                 _ => {\n                     struct_span_err!(self.tcx.sess, field.ident.span, E0560,\n@@ -3551,7 +3558,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if adt.is_enum() {\n                         err.span_label(field.ident.span,\n                                        format!(\"`{}::{}` does not have this field\",\n-                                               ty, variant.name));\n+                                               ty, variant.ident));\n                     } else {\n                         err.span_label(field.ident.span,\n                                        format!(\"`{}` does not have this field\", ty));\n@@ -3691,12 +3698,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn check_struct_path(&self,\n-                             qpath: &hir::QPath,\n+                             qpath: &QPath,\n                              node_id: ast::NodeId)\n                              -> Option<(&'tcx ty::VariantDef,  Ty<'tcx>)> {\n         let path_span = match *qpath {\n-            hir::QPath::Resolved(_, ref path) => path.span,\n-            hir::QPath::TypeRelative(ref qself, _) => qself.span\n+            QPath::Resolved(_, ref path) => path.span,\n+            QPath::TypeRelative(ref qself, _) => qself.span\n         };\n         let (def, ty) = self.finish_resolving_struct_path(qpath, path_span, node_id);\n         let variant = match def {\n@@ -3749,7 +3756,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn check_expr_struct(&self,\n                          expr: &hir::Expr,\n                          expected: Expectation<'tcx>,\n-                         qpath: &hir::QPath,\n+                         qpath: &QPath,\n                          fields: &'gcx [hir::Field],\n                          base_expr: &'gcx Option<P<hir::Expr>>) -> Ty<'tcx>\n     {\n@@ -3763,8 +3770,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n \n         let path_span = match *qpath {\n-            hir::QPath::Resolved(_, ref path) => path.span,\n-            hir::QPath::TypeRelative(ref qself, _) => qself.span\n+            QPath::Resolved(_, ref path) => path.span,\n+            QPath::TypeRelative(ref qself, _) => qself.span\n         };\n \n         // Prohibit struct expressions when non-exhaustive flag is set.\n@@ -3836,9 +3843,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Warn for non-block expressions with diverging children.\n         match expr.node {\n-            hir::ExprKind::Block(..) |\n-            hir::ExprKind::Loop(..) | hir::ExprKind::While(..) |\n-            hir::ExprKind::If(..) | hir::ExprKind::Match(..) => {}\n+            ExprKind::Block(..) |\n+            ExprKind::Loop(..) | ExprKind::While(..) |\n+            ExprKind::If(..) | ExprKind::Match(..) => {}\n \n             _ => self.warn_if_unreachable(expr.id, expr.span, \"expression\")\n         }\n@@ -3879,7 +3886,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx;\n         let id = expr.id;\n         match expr.node {\n-            hir::ExprKind::Box(ref subexpr) => {\n+            ExprKind::Box(ref subexpr) => {\n                 let expected_inner = expected.to_option(self).map_or(NoExpectation, |ty| {\n                     match ty.sty {\n                         ty::Adt(def, _) if def.is_box()\n@@ -3891,16 +3898,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 tcx.mk_box(referent_ty)\n             }\n \n-            hir::ExprKind::Lit(ref lit) => {\n+            ExprKind::Lit(ref lit) => {\n                 self.check_lit(&lit, expected)\n             }\n-            hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n+            ExprKind::Binary(op, ref lhs, ref rhs) => {\n                 self.check_binop(expr, op, lhs, rhs)\n             }\n-            hir::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n+            ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n                 self.check_binop_assign(expr, op, lhs, rhs)\n             }\n-            hir::ExprKind::Unary(unop, ref oprnd) => {\n+            ExprKind::Unary(unop, ref oprnd) => {\n                 let expected_inner = match unop {\n                     hir::UnNot | hir::UnNeg => {\n                         expected\n@@ -3968,7 +3975,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 oprnd_t\n             }\n-            hir::ExprKind::AddrOf(mutbl, ref oprnd) => {\n+            ExprKind::AddrOf(mutbl, ref oprnd) => {\n                 let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n                     match ty.sty {\n                         ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n@@ -4008,13 +4015,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     tcx.mk_ref(region, tm)\n                 }\n             }\n-            hir::ExprKind::Path(ref qpath) => {\n+            ExprKind::Path(ref qpath) => {\n                 let (def, opt_ty, segs) = self.resolve_ty_and_def_ufcs(qpath, expr.id, expr.span);\n-                let ty = if def != Def::Err {\n-                    self.instantiate_value_path(segs, opt_ty, def, expr.span, id).0\n-                } else {\n-                    self.set_tainted_by_errors();\n-                    tcx.types.err\n+                let ty = match def {\n+                    Def::Err => {\n+                        self.set_tainted_by_errors();\n+                        tcx.types.err\n+                    }\n+                    Def::VariantCtor(_, CtorKind::Fictive) => {\n+                        report_unexpected_variant_def(tcx, &def, expr.span, qpath);\n+                        tcx.types.err\n+                    }\n+                    _ => self.instantiate_value_path(segs, opt_ty, def, expr.span, id).0,\n                 };\n \n                 if let ty::FnDef(..) = ty.sty {\n@@ -4061,13 +4073,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 ty\n             }\n-            hir::ExprKind::InlineAsm(_, ref outputs, ref inputs) => {\n+            ExprKind::InlineAsm(_, ref outputs, ref inputs) => {\n                 for expr in outputs.iter().chain(inputs.iter()) {\n                     self.check_expr(expr);\n                 }\n                 tcx.mk_unit()\n             }\n-            hir::ExprKind::Break(destination, ref expr_opt) => {\n+            ExprKind::Break(destination, ref expr_opt) => {\n                 if let Ok(target_id) = destination.target_id {\n                     let (e_ty, cause);\n                     if let Some(ref e) = *expr_opt {\n@@ -4140,7 +4152,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                         // ... except when we try to 'break rust;'.\n                         // ICE this expression in particular (see #43162).\n-                        if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = e.node {\n+                        if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.node {\n                             if path.segments.len() == 1 && path.segments[0].ident.name == \"rust\" {\n                                 fatally_break_rust(self.tcx.sess);\n                             }\n@@ -4151,15 +4163,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n             }\n-            hir::ExprKind::Continue(destination) => {\n+            ExprKind::Continue(destination) => {\n                 if destination.target_id.is_ok() {\n                     tcx.types.never\n                 } else {\n                     // There was an error; make type-check fail.\n                     tcx.types.err\n                 }\n             }\n-            hir::ExprKind::Ret(ref expr_opt) => {\n+            ExprKind::Ret(ref expr_opt) => {\n                 if self.ret_coercion.is_none() {\n                     struct_span_err!(self.tcx.sess, expr.span, E0572,\n                                      \"return statement outside of function body\").emit();\n@@ -4191,7 +4203,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 tcx.types.never\n             }\n-            hir::ExprKind::Assign(ref lhs, ref rhs) => {\n+            ExprKind::Assign(ref lhs, ref rhs) => {\n                 let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n \n                 let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n@@ -4221,11 +4233,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     tcx.mk_unit()\n                 }\n             }\n-            hir::ExprKind::If(ref cond, ref then_expr, ref opt_else_expr) => {\n+            ExprKind::If(ref cond, ref then_expr, ref opt_else_expr) => {\n                 self.check_then_else(&cond, then_expr, opt_else_expr.as_ref().map(|e| &**e),\n                                      expr.span, expected)\n             }\n-            hir::ExprKind::While(ref cond, ref body, _) => {\n+            ExprKind::While(ref cond, ref body, _) => {\n                 let ctxt = BreakableCtxt {\n                     // cannot use break with a value from a while loop\n                     coerce: None,\n@@ -4249,7 +4261,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 self.tcx.mk_unit()\n             }\n-            hir::ExprKind::Loop(ref body, _, source) => {\n+            ExprKind::Loop(ref body, _, source) => {\n                 let coerce = match source {\n                     // you can only use break with a value from a normal `loop { }`\n                     hir::LoopSource::Loop => {\n@@ -4289,22 +4301,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 ctxt.coerce.map(|c| c.complete(self)).unwrap_or_else(|| self.tcx.mk_unit())\n             }\n-            hir::ExprKind::Match(ref discrim, ref arms, match_src) => {\n+            ExprKind::Match(ref discrim, ref arms, match_src) => {\n                 self.check_match(expr, &discrim, arms, expected, match_src)\n             }\n-            hir::ExprKind::Closure(capture, ref decl, body_id, _, gen) => {\n+            ExprKind::Closure(capture, ref decl, body_id, _, gen) => {\n                 self.check_expr_closure(expr, capture, &decl, body_id, gen, expected)\n             }\n-            hir::ExprKind::Block(ref body, _) => {\n+            ExprKind::Block(ref body, _) => {\n                 self.check_block_with_expected(&body, expected)\n             }\n-            hir::ExprKind::Call(ref callee, ref args) => {\n+            ExprKind::Call(ref callee, ref args) => {\n                 self.check_call(expr, &callee, args, expected)\n             }\n-            hir::ExprKind::MethodCall(ref segment, span, ref args) => {\n+            ExprKind::MethodCall(ref segment, span, ref args) => {\n                 self.check_method_call(expr, segment, span, args, expected, needs)\n             }\n-            hir::ExprKind::Cast(ref e, ref t) => {\n+            ExprKind::Cast(ref e, ref t) => {\n                 // Find the type of `e`. Supply hints based on the type we are casting to,\n                 // if appropriate.\n                 let t_cast = self.to_ty_saving_user_provided_ty(t);\n@@ -4329,12 +4341,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ExprKind::Type(ref e, ref t) => {\n+            ExprKind::Type(ref e, ref t) => {\n                 let ty = self.to_ty_saving_user_provided_ty(&t);\n                 self.check_expr_eq_type(&e, ty);\n                 ty\n             }\n-            hir::ExprKind::Array(ref args) => {\n+            ExprKind::Array(ref args) => {\n                 let uty = expected.to_option(self).and_then(|uty| {\n                     match uty.sty {\n                         ty::Array(ty, _) | ty::Slice(ty) => Some(ty),\n@@ -4358,7 +4370,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 };\n                 tcx.mk_array(element_ty, args.len() as u64)\n             }\n-            hir::ExprKind::Repeat(ref element, ref count) => {\n+            ExprKind::Repeat(ref element, ref count) => {\n                 let count_def_id = tcx.hir().local_def_id(count.id);\n                 let param_env = ty::ParamEnv::empty();\n                 let substs = Substs::identity_for_item(tcx.global_tcx(), count_def_id);\n@@ -4414,7 +4426,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     tcx.types.err\n                 }\n             }\n-            hir::ExprKind::Tup(ref elts) => {\n+            ExprKind::Tup(ref elts) => {\n                 let flds = expected.only_has_type(self).and_then(|ty| {\n                     let ty = self.resolve_type_vars_with_obligations(ty);\n                     match ty.sty {\n@@ -4444,13 +4456,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     tuple\n                 }\n             }\n-            hir::ExprKind::Struct(ref qpath, ref fields, ref base_expr) => {\n+            ExprKind::Struct(ref qpath, ref fields, ref base_expr) => {\n                 self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n             }\n-            hir::ExprKind::Field(ref base, field) => {\n+            ExprKind::Field(ref base, field) => {\n                 self.check_field(expr, needs, &base, field)\n             }\n-            hir::ExprKind::Index(ref base, ref idx) => {\n+            ExprKind::Index(ref base, ref idx) => {\n                 let base_t = self.check_expr_with_needs(&base, needs);\n                 let idx_t = self.check_expr(&idx);\n \n@@ -4476,7 +4488,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 let mut needs_note = true;\n                                 // If the index is an integer, we can show the actual\n                                 // fixed expression:\n-                                if let hir::ExprKind::Lit(ref lit) = idx.node {\n+                                if let ExprKind::Lit(ref lit) = idx.node {\n                                     if let ast::LitKind::Int(i,\n                                             ast::LitIntType::Unsuffixed) = lit.node {\n                                         let snip = tcx.sess.source_map().span_to_snippet(base.span);\n@@ -4501,7 +4513,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ExprKind::Yield(ref value) => {\n+            ExprKind::Yield(ref value) => {\n                 match self.yield_ty {\n                     Some(ty) => {\n                         self.check_expr_coercable_to_type(&value, ty);\n@@ -4522,21 +4534,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // Finish resolving a path in a struct expression or pattern `S::A { .. }` if necessary.\n     // The newly resolved definition is written into `type_dependent_defs`.\n     fn finish_resolving_struct_path(&self,\n-                                    qpath: &hir::QPath,\n+                                    qpath: &QPath,\n                                     path_span: Span,\n                                     node_id: ast::NodeId)\n                                     -> (Def, Ty<'tcx>)\n     {\n         match *qpath {\n-            hir::QPath::Resolved(ref maybe_qself, ref path) => {\n+            QPath::Resolved(ref maybe_qself, ref path) => {\n                 let self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself));\n                 let ty = AstConv::def_to_ty(self, self_ty, path, true);\n                 (path.def, ty)\n             }\n-            hir::QPath::TypeRelative(ref qself, ref segment) => {\n+            QPath::TypeRelative(ref qself, ref segment) => {\n                 let ty = self.to_ty(qself);\n \n-                let def = if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = qself.node {\n+                let def = if let hir::TyKind::Path(QPath::Resolved(_, ref path)) = qself.node {\n                     path.def\n                 } else {\n                     Def::Err\n@@ -4556,19 +4568,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // Resolve associated value path into a base type and associated constant or method definition.\n     // The newly resolved definition is written into `type_dependent_defs`.\n     pub fn resolve_ty_and_def_ufcs<'b>(&self,\n-                                       qpath: &'b hir::QPath,\n+                                       qpath: &'b QPath,\n                                        node_id: ast::NodeId,\n                                        span: Span)\n                                        -> (Def, Option<Ty<'tcx>>, &'b [hir::PathSegment])\n     {\n-        let (ty, item_segment) = match *qpath {\n-            hir::QPath::Resolved(ref opt_qself, ref path) => {\n+        let (ty, qself, item_segment) = match *qpath {\n+            QPath::Resolved(ref opt_qself, ref path) => {\n                 return (path.def,\n                         opt_qself.as_ref().map(|qself| self.to_ty(qself)),\n                         &path.segments[..]);\n             }\n-            hir::QPath::TypeRelative(ref qself, ref segment) => {\n-                (self.to_ty(qself), segment)\n+            QPath::TypeRelative(ref qself, ref segment) => {\n+                (self.to_ty(qself), qself, segment)\n             }\n         };\n         let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n@@ -4586,7 +4598,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     _ => Def::Err,\n                 };\n                 if item_name.name != keywords::Invalid.name() {\n-                    self.report_method_error(span, ty, item_name, None, error, None);\n+                    self.report_method_error(span,\n+                                             ty,\n+                                             item_name,\n+                                             SelfSource::QPath(qself),\n+                                             error,\n+                                             None);\n                 }\n                 def\n             }\n@@ -4601,7 +4618,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   local: &'gcx hir::Local,\n                                   init: &'gcx hir::Expr) -> Ty<'tcx>\n     {\n-        // FIXME(tschottdorf): contains_explicit_ref_binding() must be removed\n+        // FIXME(tschottdorf): `contains_explicit_ref_binding()` must be removed\n         // for #42640 (default match binding modes).\n         //\n         // See #44848.\n@@ -4646,7 +4663,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn check_stmt(&self, stmt: &'gcx hir::Stmt) {\n-        // Don't do all the complex logic below for DeclItem.\n+        // Don't do all the complex logic below for `DeclItem`.\n         match stmt.node {\n             hir::StmtKind::Decl(ref decl, _) => {\n                 if let hir::DeclKind::Item(_) = decl.node {\n@@ -4658,7 +4675,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         self.warn_if_unreachable(stmt.node.id(), stmt.span, \"statement\");\n \n-        // Hide the outer diverging and has_errors flags.\n+        // Hide the outer diverging and `has_errors` flags.\n         let old_diverges = self.diverges.get();\n         let old_has_errors = self.has_errors.get();\n         self.diverges.set(Diverges::Maybe);\n@@ -4670,19 +4687,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     hir::DeclKind::Local(ref l) => {\n                         self.check_decl_local(&l);\n                     }\n-                    hir::DeclKind::Item(_) => {/* ignore for now */}\n+                    // Ignore for now.\n+                    hir::DeclKind::Item(_) => ()\n                 }\n             }\n             hir::StmtKind::Expr(ref expr, _) => {\n-                // Check with expected type of ()\n+                // Check with expected type of `()`.\n                 self.check_expr_has_type_or_error(&expr, self.tcx.mk_unit());\n             }\n             hir::StmtKind::Semi(ref expr, _) => {\n                 self.check_expr(&expr);\n             }\n         }\n \n-        // Combine the diverging and has_error flags.\n+        // Combine the diverging and `has_error` flags.\n         self.diverges.set(self.diverges.get() | old_diverges);\n         self.has_errors.set(self.has_errors.get() | old_has_errors);\n     }\n@@ -4811,13 +4829,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let parent = self.tcx.hir().get(fn_id);\n \n             if let Node::Item(&hir::Item {\n-                name, node: hir::ItemKind::Fn(ref decl, ..), ..\n+                ident, node: hir::ItemKind::Fn(ref decl, ..), ..\n             }) = parent {\n                 decl.clone().and_then(|decl| {\n                     // This is less than ideal, it will not suggest a return type span on any\n                     // method called `main`, regardless of whether it is actually the entry point,\n                     // but it will still present it as the reason for the expected type.\n-                    Some((decl, name != Symbol::intern(\"main\")))\n+                    Some((decl, ident.name != Symbol::intern(\"main\")))\n                 })\n             } else if let Node::TraitItem(&hir::TraitItem {\n                 node: hir::TraitItemKind::Method(hir::MethodSig {\n@@ -4928,13 +4946,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // `BlockTailExpression` only relevant if the tail expr would be\n             // useful on its own.\n             match expression.node {\n-                hir::ExprKind::Call(..) |\n-                hir::ExprKind::MethodCall(..) |\n-                hir::ExprKind::If(..) |\n-                hir::ExprKind::While(..) |\n-                hir::ExprKind::Loop(..) |\n-                hir::ExprKind::Match(..) |\n-                hir::ExprKind::Block(..) => {\n+                ExprKind::Call(..) |\n+                ExprKind::MethodCall(..) |\n+                ExprKind::If(..) |\n+                ExprKind::While(..) |\n+                ExprKind::Loop(..) |\n+                ExprKind::Match(..) |\n+                ExprKind::Block(..) => {\n                     let sp = self.tcx.sess.source_map().next_point(cause_span);\n                     err.span_suggestion_with_applicability(\n                         sp,\n@@ -5038,101 +5056,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Applicability::MachineApplicable);\n     }\n \n-    fn def_ids_for_path_segments(&self,\n-                                 segments: &[hir::PathSegment],\n-                                 def: Def)\n-                                 -> Vec<PathSeg> {\n-        // We need to extract the type parameters supplied by the user in\n-        // the path `path`. Due to the current setup, this is a bit of a\n-        // tricky-process; the problem is that resolve only tells us the\n-        // end-point of the path resolution, and not the intermediate steps.\n-        // Luckily, we can (at least for now) deduce the intermediate steps\n-        // just from the end-point.\n-        //\n-        // There are basically four cases to consider:\n-        //\n-        // 1. Reference to a constructor of enum variant or struct:\n-        //\n-        //        struct Foo<T>(...)\n-        //        enum E<T> { Foo(...) }\n-        //\n-        //    In these cases, the parameters are declared in the type\n-        //    space.\n-        //\n-        // 2. Reference to a fn item or a free constant:\n-        //\n-        //        fn foo<T>() { }\n-        //\n-        //    In this case, the path will again always have the form\n-        //    `a::b::foo::<T>` where only the final segment should have\n-        //    type parameters. However, in this case, those parameters are\n-        //    declared on a value, and hence are in the `FnSpace`.\n-        //\n-        // 3. Reference to a method or an associated constant:\n-        //\n-        //        impl<A> SomeStruct<A> {\n-        //            fn foo<B>(...)\n-        //        }\n-        //\n-        //    Here we can have a path like\n-        //    `a::b::SomeStruct::<A>::foo::<B>`, in which case parameters\n-        //    may appear in two places. The penultimate segment,\n-        //    `SomeStruct::<A>`, contains parameters in TypeSpace, and the\n-        //    final segment, `foo::<B>` contains parameters in fn space.\n-        //\n-        // 4. Reference to a local variable\n-        //\n-        //    Local variables can't have any type parameters.\n-        //\n-        // The first step then is to categorize the segments appropriately.\n-\n-        assert!(!segments.is_empty());\n-        let last = segments.len() - 1;\n-\n-        let mut path_segs = vec![];\n-\n-        match def {\n-            // Case 1. Reference to a struct/variant constructor.\n-            Def::StructCtor(def_id, ..) |\n-            Def::VariantCtor(def_id, ..) |\n-            Def::SelfCtor(.., def_id) => {\n-                // Everything but the final segment should have no\n-                // parameters at all.\n-                let generics = self.tcx.generics_of(def_id);\n-                // Variant and struct constructors use the\n-                // generics of their parent type definition.\n-                let generics_def_id = generics.parent.unwrap_or(def_id);\n-                path_segs.push(PathSeg(generics_def_id, last));\n-            }\n-\n-            // Case 2. Reference to a top-level value.\n-            Def::Fn(def_id) |\n-            Def::Const(def_id) |\n-            Def::Static(def_id, _) => {\n-                path_segs.push(PathSeg(def_id, last));\n-            }\n-\n-            // Case 3. Reference to a method or associated const.\n-            Def::Method(def_id) |\n-            Def::AssociatedConst(def_id) => {\n-                if segments.len() >= 2 {\n-                    let generics = self.tcx.generics_of(def_id);\n-                    path_segs.push(PathSeg(generics.parent.unwrap(), last - 1));\n-                }\n-                path_segs.push(PathSeg(def_id, last));\n-            }\n-\n-            // Case 4. Local variable, no generics.\n-            Def::Local(..) | Def::Upvar(..) => {}\n-\n-            _ => bug!(\"unexpected definition: {:?}\", def),\n-        }\n-\n-        debug!(\"path_segs = {:?}\", path_segs);\n-\n-        path_segs\n-    }\n-\n     // Instantiates the given path, which must refer to an item with the given\n     // number of type parameters and type.\n     pub fn instantiate_value_path(&self,\n@@ -5150,16 +5073,29 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             node_id,\n         );\n \n-        let path_segs = self.def_ids_for_path_segments(segments, def);\n+        let tcx = self.tcx;\n+\n+        let path_segs = AstConv::def_ids_for_path_segments(self, segments, self_ty, def);\n \n         let mut user_self_ty = None;\n+        let mut is_alias_variant_ctor = false;\n         match def {\n+            Def::VariantCtor(_, _) => {\n+                if let Some(self_ty) = self_ty {\n+                    let adt_def = self_ty.ty_adt_def().unwrap();\n+                    user_self_ty = Some(UserSelfTy {\n+                        impl_def_id: adt_def.did,\n+                        self_ty,\n+                    });\n+                    is_alias_variant_ctor = true;\n+                }\n+            }\n             Def::Method(def_id) |\n             Def::AssociatedConst(def_id) => {\n-                let container = self.tcx.associated_item(def_id).container;\n+                let container = tcx.associated_item(def_id).container;\n                 match container {\n                     ty::TraitContainer(trait_did) => {\n-                        callee::check_legal_trait_for_method_call(self.tcx, span, trait_did)\n+                        callee::check_legal_trait_for_method_call(tcx, span, trait_did)\n                     }\n                     ty::ImplContainer(impl_def_id) => {\n                         if segments.len() == 1 {\n@@ -5185,21 +5121,25 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // provided (if any) into their appropriate spaces. We'll also report\n         // errors if type parameters are provided in an inappropriate place.\n \n-        let generic_segs = path_segs.iter().map(|PathSeg(_, index)| index)\n-            .collect::<FxHashSet<_>>();\n-        AstConv::prohibit_generics(self, segments.iter().enumerate().filter_map(|(index, seg)| {\n-            if !generic_segs.contains(&index) {\n+        let generic_segs: FxHashSet<_> = path_segs.iter().map(|PathSeg(_, index)| index).collect();\n+        let generics_has_err = AstConv::prohibit_generics(\n+                self, segments.iter().enumerate().filter_map(|(index, seg)| {\n+            if !generic_segs.contains(&index) || is_alias_variant_ctor {\n                 Some(seg)\n             } else {\n                 None\n             }\n         }));\n+        if generics_has_err {\n+            // Don't try to infer type parameters when prohibited generic arguments were given.\n+            user_self_ty = None;\n+        }\n \n         match def {\n             Def::Local(nid) | Def::Upvar(nid, ..) => {\n                 let ty = self.local_ty(span, nid).decl_ty;\n                 let ty = self.normalize_associated_types_in(span, &ty);\n-                self.write_ty(self.tcx.hir().node_to_hir_id(node_id), ty);\n+                self.write_ty(tcx.hir().node_to_hir_id(node_id), ty);\n                 return (ty, def);\n             }\n             _ => {}\n@@ -5215,13 +5155,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut infer_args_for_err = FxHashSet::default();\n         for &PathSeg(def_id, index) in &path_segs {\n             let seg = &segments[index];\n-            let generics = self.tcx.generics_of(def_id);\n+            let generics = tcx.generics_of(def_id);\n             // Argument-position `impl Trait` is treated as a normal generic\n             // parameter internally, but we don't allow users to specify the\n             // parameter's value explicitly, so we have to do some error-\n             // checking here.\n             let suppress_errors = AstConv::check_generic_arg_count_for_call(\n-                self.tcx,\n+                tcx,\n                 span,\n                 &generics,\n                 &seg,\n@@ -5234,7 +5174,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let has_self = path_segs.last().map(|PathSeg(def_id, _)| {\n-            self.tcx.generics_of(*def_id).has_self\n+            tcx.generics_of(*def_id).has_self\n         }).unwrap_or(false);\n \n         let mut new_def = def;\n@@ -5247,10 +5187,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     Some(adt_def) if adt_def.has_ctor() => {\n                         let variant = adt_def.non_enum_variant();\n                         new_def = Def::StructCtor(variant.did, variant.ctor_kind);\n-                        (variant.did, self.tcx.type_of(variant.did))\n+                        (variant.did, tcx.type_of(variant.did))\n                     }\n                     _ => {\n-                        let mut err = self.tcx.sess.struct_span_err(span,\n+                        let mut err = tcx.sess.struct_span_err(span,\n                             \"the `Self` constructor can only be used with tuple or unit structs\");\n                         if let Some(adt_def) = adt_def {\n                             match adt_def.adt_kind() {\n@@ -5268,7 +5208,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                         err.emit();\n \n-                        (impl_def_id, self.tcx.types.err)\n+                        (impl_def_id, tcx.types.err)\n                     }\n                 }\n             }\n@@ -5277,13 +5217,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 // The things we are substituting into the type should not contain\n                 // escaping late-bound regions, and nor should the base type scheme.\n-                let ty = self.tcx.type_of(def_id);\n+                let ty = tcx.type_of(def_id);\n                 (def_id, ty)\n             }\n         };\n \n         let substs = AstConv::create_substs_for_generic_args(\n-            self.tcx,\n+            tcx,\n             def_id,\n             &[][..],\n             has_self,\n@@ -5329,10 +5269,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             // If we have a default, then we it doesn't matter that we're not\n                             // inferring the type arguments: we provide the default where any\n                             // is missing.\n-                            let default = self.tcx.type_of(param.def_id);\n+                            let default = tcx.type_of(param.def_id);\n                             self.normalize_ty(\n                                 span,\n-                                default.subst_spanned(self.tcx, substs.unwrap(), Some(span))\n+                                default.subst_spanned(tcx, substs.unwrap(), Some(span))\n                             ).into()\n                         } else {\n                             // If no type arguments were provided, we have to infer them.\n@@ -5349,7 +5289,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         assert!(!ty.has_escaping_bound_vars());\n \n         // First, store the \"user substs\" for later.\n-        let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n+        let hir_id = tcx.hir().node_to_hir_id(node_id);\n         self.write_user_substs_from_substs(hir_id, substs, user_self_ty);\n \n         // Add all the obligations that are required, substituting and\n@@ -5365,10 +5305,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n             // In the case of `Foo<T>::method` and `<Foo<T>>::method`, if `method`\n-            // is inherent, there is no `Self` parameter, instead, the impl needs\n+            // is inherent, there is no `Self` parameter; instead, the impl needs\n             // type parameters, which we can infer by unifying the provided `Self`\n             // with the substituted impl type.\n-            let ty = self.tcx.type_of(impl_def_id);\n+            // This also occurs for an enum variant on a type alias.\n+            let ty = tcx.type_of(impl_def_id);\n \n             let impl_ty = self.instantiate_type_scheme(span, &substs, &ty);\n             match self.at(&self.misc(span), self.param_env).sup(impl_ty, self_ty) {\n@@ -5405,7 +5346,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // If our calling expression is indeed the function itself, we're good!\n         // If not, generate an error that this can only be called directly.\n         if let Node::Expr(expr) = self.tcx.hir().get(self.tcx.hir().get_parent_node(node_id)) {\n-            if let hir::ExprKind::Call(ref callee, ..) = expr.node {\n+            if let ExprKind::Call(ref callee, ..) = expr.node {\n                 if callee.id == node_id {\n                     return\n                 }"}, {"sha": "bf767726ef715d9f2321aecf4c6fd1c4c7ae9999", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -154,7 +154,7 @@ fn unused_crates_lint<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) {\n \n         // If the extern crate isn't in the extern prelude,\n         // there is no way it can be written as an `use`.\n-        let orig_name = extern_crate.orig_name.unwrap_or(item.name);\n+        let orig_name = extern_crate.orig_name.unwrap_or(item.ident.name);\n         if !tcx.extern_prelude.get(&orig_name).map_or(false, |from_item| !from_item) {\n             continue;\n         }\n@@ -173,8 +173,8 @@ fn unused_crates_lint<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) {\n             visibility_qualified(&item.vis, \"use\")\n         );\n         let base_replacement = match extern_crate.orig_name {\n-            Some(orig_name) => format!(\"use {} as {};\", orig_name, item.name),\n-            None => format!(\"use {};\", item.name),\n+            Some(orig_name) => format!(\"use {} as {};\", orig_name, item.ident.name),\n+            None => format!(\"use {};\", item.ident.name),\n         };\n         let replacement = visibility_qualified(&item.vis, base_replacement);\n         tcx.struct_span_lint_node(lint, id, extern_crate.span, msg)\n@@ -219,7 +219,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CollectExternCrateVisitor<'a, 'tcx> {\n                     def_id: extern_crate_def_id,\n                     span: item.span,\n                     orig_name,\n-                    warn_if_unused: !item.name.as_str().starts_with('_'),\n+                    warn_if_unused: !item.ident.as_str().starts_with('_'),\n                 }\n             );\n         }"}, {"sha": "9fc2f11b19738f83dee2578f36df64965e71954f", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -33,7 +33,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc_target::spec::abi;\n \n use syntax::ast;\n-use syntax::ast::MetaItemKind;\n+use syntax::ast::{Ident, MetaItemKind};\n use syntax::attr::{InlineAttr, list_contains_name, mark_used};\n use syntax::source_map::Spanned;\n use syntax::feature_gate;\n@@ -385,7 +385,7 @@ fn is_param<'a, 'tcx>(\n \n fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n     let it = tcx.hir().expect_item(item_id);\n-    debug!(\"convert: item {} with id {}\", it.name, it.id);\n+    debug!(\"convert: item {} with id {}\", it.ident, it.id);\n     let def_id = tcx.hir().local_def_id(item_id);\n     match it.node {\n         // These don't define types.\n@@ -533,7 +533,7 @@ fn convert_enum_variant_types<'a, 'tcx>(\n                     format!(\"overflowed on value after {}\", prev_discr.unwrap()),\n                 ).note(&format!(\n                     \"explicitly set `{} = {}` if that is desired outcome\",\n-                    variant.node.name, wrapped_discr\n+                    variant.node.ident, wrapped_discr\n                 ))\n                 .emit();\n                 None\n@@ -556,7 +556,7 @@ fn convert_enum_variant_types<'a, 'tcx>(\n fn convert_variant<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     did: DefId,\n-    name: ast::Name,\n+    ident: Ident,\n     discr: ty::VariantDiscr,\n     def: &hir::VariantData,\n     adt_kind: ty::AdtKind,\n@@ -593,12 +593,13 @@ fn convert_variant<'a, 'tcx>(\n         .collect();\n     ty::VariantDef::new(tcx,\n         did,\n-        name,\n+        ident,\n         discr,\n         fields,\n         adt_kind,\n         CtorKind::from_hir(def),\n-        attribute_def_id)\n+        attribute_def_id\n+    )\n }\n \n fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::AdtDef {\n@@ -628,7 +629,7 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Ad\n                         };\n                         distance_from_explicit += 1;\n \n-                        convert_variant(tcx, did, v.node.name, discr, &v.node.data, AdtKind::Enum,\n+                        convert_variant(tcx, did, v.node.ident, discr, &v.node.data, AdtKind::Enum,\n                                         did)\n                     })\n                     .collect(),\n@@ -646,7 +647,7 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Ad\n                 std::iter::once(convert_variant(\n                     tcx,\n                     ctor_id.unwrap_or(def_id),\n-                    item.name,\n+                    item.ident,\n                     ty::VariantDiscr::Relative(0),\n                     def,\n                     AdtKind::Struct,\n@@ -659,7 +660,7 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Ad\n             std::iter::once(convert_variant(\n                 tcx,\n                 def_id,\n-                item.name,\n+                item.ident,\n                 ty::VariantDiscr::Relative(0),\n                 def,\n                 AdtKind::Union,"}, {"sha": "5910a8b3110d0f3b787c504e6e6e54aa06da83ff", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1291,7 +1291,7 @@ You tried to give a type parameter to a type which doesn't need it. Erroneous\n code example:\n \n ```compile_fail,E0109\n-type X = u32<i32>; // error: type parameters are not allowed on this type\n+type X = u32<i32>; // error: type arguments are not allowed on this entity\n ```\n \n Please check that you used the correct type and recheck its definition. Perhaps"}, {"sha": "c55a1258ce955ab158f1f8ecfb5089da3e7c735c", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -111,6 +111,7 @@ use rustc::infer::InferOk;\n use rustc::lint;\n use rustc::middle;\n use rustc::session;\n+use rustc::session::config::nightly_options;\n use rustc::traits::{ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt};\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -129,6 +130,22 @@ pub struct TypeAndSubsts<'tcx> {\n     ty: Ty<'tcx>,\n }\n \n+fn check_type_alias_enum_variants_enabled<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                                          span: Span) {\n+    if !tcx.features().type_alias_enum_variants {\n+        let mut err = tcx.sess.struct_span_err(\n+            span,\n+            \"enum variants on type aliases are experimental\"\n+        );\n+        if nightly_options::is_nightly_build() {\n+            help!(&mut err,\n+                \"add `#![feature(type_alias_enum_variants)]` to the \\\n+                crate attributes to enable\");\n+        }\n+        err.emit();\n+    }\n+}\n+\n fn require_c_abi_if_variadic(tcx: TyCtxt,\n                              decl: &hir::FnDecl,\n                              abi: Abi,"}, {"sha": "38b2452b420e943eb387832cb3faf0c19bcfcbbf", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -2967,7 +2967,7 @@ impl<'tcx> Clean<Item> for ty::VariantDef {\n             }\n         };\n         Item {\n-            name: Some(self.name.clean(cx)),\n+            name: Some(self.ident.clean(cx)),\n             attrs: inline::load_attrs(cx, self.did),\n             source: cx.tcx.def_span(self.did).clean(cx),\n             visibility: Some(Inherited),\n@@ -3183,13 +3183,22 @@ fn qpath_to_string(p: &hir::QPath) -> String {\n     s\n }\n \n+impl Clean<String> for Ident {\n+    #[inline]\n+    fn clean(&self, cx: &DocContext) -> String {\n+        self.name.clean(cx)\n+    }\n+}\n+\n impl Clean<String> for ast::Name {\n+    #[inline]\n     fn clean(&self, _: &DocContext) -> String {\n         self.to_string()\n     }\n }\n \n impl Clean<String> for InternedString {\n+    #[inline]\n     fn clean(&self, _: &DocContext) -> String {\n         self.to_string()\n     }\n@@ -3616,7 +3625,7 @@ impl Clean<Item> for hir::ForeignItem {\n         };\n \n         Item {\n-            name: Some(self.name.clean(cx)),\n+            name: Some(self.ident.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n             def_id: cx.tcx.hir().local_def_id(self.id),\n@@ -3951,7 +3960,7 @@ pub fn path_to_def_local(tcx: &TyCtxt, path: &[&str]) -> Option<DefId> {\n \n         for item_id in mem::replace(&mut items, HirVec::new()).iter() {\n             let item = tcx.hir().expect_item(item_id.id);\n-            if item.name == *segment {\n+            if item.ident.name == *segment {\n                 if path_it.peek().is_none() {\n                     return Some(tcx.hir().local_def_id(item_id.id))\n                 }"}, {"sha": "fdc1c0616187a8ed61acb26ad09afd2241d67a42", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -632,7 +632,7 @@ fn handle_variant(cx: &DocContext, def: Def) -> Result<(Def, Option<String>), ()\n     };\n     let parent_def = Def::Enum(parent);\n     let variant = cx.tcx.expect_variant_def(def);\n-    Ok((parent_def, Some(format!(\"{}.v\", variant.name))))\n+    Ok((parent_def, Some(format!(\"{}.v\", variant.ident.name))))\n }\n \n const PRIMITIVES: &[(&str, Def)] = &["}, {"sha": "24bb00f4112421a116862882156a1c111792e22b", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -811,7 +811,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n         let name = if let hir::ItemKind::Impl(.., ref ty, _) = item.node {\n             self.map.node_to_pretty_string(ty.id)\n         } else {\n-            item.name.to_string()\n+            item.ident.to_string()\n         };\n \n         self.visit_testable(name, &item.attrs, |this| {\n@@ -832,7 +832,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n     }\n \n     fn visit_foreign_item(&mut self, item: &'hir hir::ForeignItem) {\n-        self.visit_testable(item.name.to_string(), &item.attrs, |this| {\n+        self.visit_testable(item.ident.to_string(), &item.attrs, |this| {\n             intravisit::walk_foreign_item(this, item);\n         });\n     }\n@@ -841,7 +841,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n                      v: &'hir hir::Variant,\n                      g: &'hir hir::Generics,\n                      item_id: ast::NodeId) {\n-        self.visit_testable(v.node.name.to_string(), &v.node.attrs, |this| {\n+        self.visit_testable(v.node.ident.to_string(), &v.node.attrs, |this| {\n             intravisit::walk_variant(this, v, g, item_id);\n         });\n     }"}, {"sha": "953ab7c2565bfab9a1eafce0c6668d5156b38d33", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n         Enum {\n             name,\n             variants: def.variants.iter().map(|v| Variant {\n-                name: v.node.name,\n+                name: v.node.ident.name,\n                 attrs: v.node.attrs.clone(),\n                 stab: self.stability(v.node.data.id()),\n                 depr: self.deprecation(v.node.data.id()),\n@@ -263,7 +263,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n     fn maybe_inline_local(&mut self,\n                           id: ast::NodeId,\n                           def: Def,\n-                          renamed: Option<ast::Name>,\n+                          renamed: Option<ast::Ident>,\n                           glob: bool,\n                           om: &mut Module,\n                           please_inline: bool) -> bool {\n@@ -357,14 +357,14 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                 om.foreigns.push(hir::ForeignMod {\n                     abi: tcx.hir().get_foreign_abi(it.id),\n                     items: vec![hir::ForeignItem {\n-                        name: renamed.unwrap_or(it.name),\n+                        ident: renamed.unwrap_or(it.ident),\n                         .. it.clone()\n                     }].into(),\n                 });\n                 true\n             }\n             Node::MacroDef(def) if !glob => {\n-                om.macros.push(self.visit_local_macro(def, renamed));\n+                om.macros.push(self.visit_local_macro(def, renamed.map(|i| i.name)));\n                 true\n             }\n             _ => false,\n@@ -374,9 +374,9 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n     }\n \n     pub fn visit_item(&mut self, item: &hir::Item,\n-                      renamed: Option<ast::Name>, om: &mut Module) {\n+                      renamed: Option<ast::Ident>, om: &mut Module) {\n         debug!(\"Visiting item {:?}\", item);\n-        let name = renamed.unwrap_or(item.name);\n+        let ident = renamed.unwrap_or(item.ident);\n \n         if item.vis.node.is_pub() {\n             let def_id = self.cx.tcx.hir().local_def_id(item.id);\n@@ -403,7 +403,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                 om.extern_crates.push(ExternCrate {\n                     cnum: self.cx.tcx.extern_mod_stmt_cnum(def_id)\n                                 .unwrap_or(LOCAL_CRATE),\n-                    name,\n+                    name: ident.name,\n                     path: orig_name.map(|x|x.to_string()),\n                     vis: item.vis.clone(),\n                     attrs: item.attrs.clone(),\n@@ -433,10 +433,10 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                             _ => false,\n                         }\n                     });\n-                    let name = if is_glob { None } else { Some(name) };\n+                    let ident = if is_glob { None } else { Some(ident) };\n                     if self.maybe_inline_local(item.id,\n                                                path.def,\n-                                               name,\n+                                               ident,\n                                                is_glob,\n                                                om,\n                                                please_inline) {\n@@ -445,7 +445,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                 }\n \n                 om.imports.push(Import {\n-                    name,\n+                    name: ident.name,\n                     id: item.id,\n                     vis: item.vis.clone(),\n                     attrs: item.attrs.clone(),\n@@ -460,21 +460,21 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                                                      item.vis.clone(),\n                                                      item.id,\n                                                      m,\n-                                                     Some(name)));\n+                                                     Some(ident.name)));\n             },\n             hir::ItemKind::Enum(ref ed, ref gen) =>\n-                om.enums.push(self.visit_enum_def(item, name, ed, gen)),\n+                om.enums.push(self.visit_enum_def(item, ident.name, ed, gen)),\n             hir::ItemKind::Struct(ref sd, ref gen) =>\n-                om.structs.push(self.visit_variant_data(item, name, sd, gen)),\n+                om.structs.push(self.visit_variant_data(item, ident.name, sd, gen)),\n             hir::ItemKind::Union(ref sd, ref gen) =>\n-                om.unions.push(self.visit_union_data(item, name, sd, gen)),\n+                om.unions.push(self.visit_union_data(item, ident.name, sd, gen)),\n             hir::ItemKind::Fn(ref fd, header, ref gen, body) =>\n-                self.visit_fn(om, item, name, &**fd, header, gen, body),\n+                self.visit_fn(om, item, ident.name, &**fd, header, gen, body),\n             hir::ItemKind::Ty(ref ty, ref gen) => {\n                 let t = Typedef {\n                     ty: ty.clone(),\n                     gen: gen.clone(),\n-                    name,\n+                    name: ident.name,\n                     id: item.id,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n@@ -487,7 +487,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n             hir::ItemKind::Existential(ref exist_ty) => {\n                 let t = Existential {\n                     exist_ty: exist_ty.clone(),\n-                    name,\n+                    name: ident.name,\n                     id: item.id,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n@@ -503,7 +503,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                     mutability: mut_.clone(),\n                     expr: exp.clone(),\n                     id: item.id,\n-                    name,\n+                    name: ident.name,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n                     vis: item.vis.clone(),\n@@ -517,7 +517,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                     type_: ty.clone(),\n                     expr: exp.clone(),\n                     id: item.id,\n-                    name,\n+                    name: ident.name,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n                     vis: item.vis.clone(),\n@@ -533,7 +533,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                 let t = Trait {\n                     is_auto,\n                     unsafety,\n-                    name,\n+                    name: ident.name,\n                     items,\n                     generics: gen.clone(),\n                     bounds: b.iter().cloned().collect(),"}, {"sha": "3f2122e24a6426cd78b3e3564756789a04665145", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -471,11 +471,14 @@ declare_features! (\n     // Allows `const _: TYPE = VALUE`.\n     (active, underscore_const_names, \"1.31.0\", Some(54912), None),\n \n-    // `reason = ` in lint attributes and `expect` lint attribute\n+    // Adds `reason` and `expect` lint attributes.\n     (active, lint_reasons, \"1.31.0\", Some(54503), None),\n \n     // `extern crate self as foo;` puts local crate root into extern prelude under name `foo`.\n     (active, extern_crate_self, \"1.31.0\", Some(56409), None),\n+\n+    // Allows paths to enum variants on type aliases.\n+    (active, type_alias_enum_variants, \"1.31.0\", Some(49683), None),\n );\n \n declare_features! ("}, {"sha": "efef4ab00aed2411a1748490021b80c9c4b46fd1", "filename": "src/test/compile-fail-fulldeps/auxiliary/lint_group_plugin_test.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_group_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_group_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_group_plugin_test.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+\n+#![feature(plugin_registrar)]\n+#![feature(box_syntax, rustc_private)]\n+\n+// Load rustc as a plugin to get macros.\n+#[macro_use]\n+extern crate rustc;\n+extern crate rustc_plugin;\n+\n+use rustc::hir;\n+use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LateLintPassObject, LintArray};\n+use rustc_plugin::Registry;\n+\n+declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");\n+\n+declare_lint!(PLEASE_LINT, Warn, \"Warn about items named 'pleaselintme'\");\n+\n+struct Pass;\n+\n+impl LintPass for Pass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(TEST_LINT, PLEASE_LINT)\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+        match &*it.ident.as_str() {\n+            \"lintme\" => cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\"),\n+            \"pleaselintme\" => cx.span_lint(PLEASE_LINT, it.span, \"item is named 'pleaselintme'\"),\n+            _ => {}\n+        }\n+    }\n+}\n+\n+#[plugin_registrar]\n+pub fn plugin_registrar(reg: &mut Registry) {\n+    reg.register_late_lint_pass(box Pass);\n+    reg.register_lint_group(\"lint_me\", None, vec![TEST_LINT, PLEASE_LINT]);\n+}"}, {"sha": "0743f998979221f95010ded9f136cfa517d50b0d", "filename": "src/test/run-pass/enum-variant-generic-args.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Frun-pass%2Fenum-variant-generic-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Frun-pass%2Fenum-variant-generic-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-variant-generic-args.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -0,0 +1,42 @@\n+#![feature(irrefutable_let_patterns)]\n+#![feature(type_alias_enum_variants)]\n+\n+#![allow(irrefutable_let_patterns)]\n+\n+#[allow(dead_code)]\n+enum Enum<T> { TSVariant(T), SVariant { v: T } }\n+type Alias<T> = Enum<T>;\n+type AliasFixed = Enum<()>;\n+\n+macro_rules! is_variant {\n+    (TSVariant, $expr:expr) => (is_variant!(@check TSVariant, (_), $expr));\n+    (SVariant, $expr:expr) => (is_variant!(@check SVariant, { v: _ }, $expr));\n+    (@check $variant:ident, $matcher:tt, $expr:expr) => (\n+        assert!(if let Enum::$variant::<()> $matcher = $expr { true } else { false },\n+                \"expr does not have correct type\");\n+    );\n+}\n+\n+fn main() {\n+    // Tuple struct variant\n+\n+    is_variant!(TSVariant, Enum::TSVariant(()));\n+    is_variant!(TSVariant, Enum::TSVariant::<()>(()));\n+    is_variant!(TSVariant, Enum::<()>::TSVariant(()));\n+\n+    is_variant!(TSVariant, Alias::TSVariant(()));\n+    is_variant!(TSVariant, Alias::<()>::TSVariant(()));\n+\n+    is_variant!(TSVariant, AliasFixed::TSVariant(()));\n+\n+    // Struct variant\n+\n+    is_variant!(SVariant, Enum::SVariant { v: () });\n+    is_variant!(SVariant, Enum::SVariant::<()> { v: () });\n+    is_variant!(SVariant, Enum::<()>::SVariant { v: () });\n+\n+    is_variant!(SVariant, Alias::SVariant { v: () });\n+    is_variant!(SVariant, Alias::<()>::SVariant { v: () });\n+\n+    is_variant!(SVariant, AliasFixed::SVariant { v: () });\n+}"}, {"sha": "0cf413babcbf658f38ba1975fa0093d3eedafcac", "filename": "src/test/run-pass/type-alias-enum-variants-2.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Frun-pass%2Ftype-alias-enum-variants-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Frun-pass%2Ftype-alias-enum-variants-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-alias-enum-variants-2.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -0,0 +1,30 @@\n+#![feature(type_alias_enum_variants)]\n+\n+#[derive(Debug, PartialEq, Eq)]\n+enum Foo {\n+    Bar(i32),\n+    Baz { i: i32 },\n+}\n+\n+type FooAlias = Foo;\n+type OptionAlias = Option<i32>;\n+\n+impl Foo {\n+    fn foo() -> Self {\n+        Self::Bar(3)\n+    }\n+}\n+\n+fn main() {\n+    let t = FooAlias::Bar(1);\n+    assert_eq!(t, Foo::Bar(1));\n+    let t = FooAlias::Baz { i: 2 };\n+    assert_eq!(t, Foo::Baz { i: 2 });\n+    match t {\n+        FooAlias::Bar(_i) => {}\n+        FooAlias::Baz { i } => { assert_eq!(i, 2); }\n+    }\n+    assert_eq!(Foo::foo(), Foo::Bar(3));\n+\n+    assert_eq!(OptionAlias::Some(4), Option::Some(4));\n+}"}, {"sha": "0cf413babcbf658f38ba1975fa0093d3eedafcac", "filename": "src/test/run-pass/type-alias-enum-variants.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Frun-pass%2Ftype-alias-enum-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Frun-pass%2Ftype-alias-enum-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-alias-enum-variants.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -0,0 +1,30 @@\n+#![feature(type_alias_enum_variants)]\n+\n+#[derive(Debug, PartialEq, Eq)]\n+enum Foo {\n+    Bar(i32),\n+    Baz { i: i32 },\n+}\n+\n+type FooAlias = Foo;\n+type OptionAlias = Option<i32>;\n+\n+impl Foo {\n+    fn foo() -> Self {\n+        Self::Bar(3)\n+    }\n+}\n+\n+fn main() {\n+    let t = FooAlias::Bar(1);\n+    assert_eq!(t, Foo::Bar(1));\n+    let t = FooAlias::Baz { i: 2 };\n+    assert_eq!(t, Foo::Baz { i: 2 });\n+    match t {\n+        FooAlias::Bar(_i) => {}\n+        FooAlias::Baz { i } => { assert_eq!(i, 2); }\n+    }\n+    assert_eq!(Foo::foo(), Foo::Bar(3));\n+\n+    assert_eq!(OptionAlias::Some(4), Option::Some(4));\n+}"}, {"sha": "bca1d7a72b4abc77cb687271b5e9732976662f7e", "filename": "src/test/ui-fulldeps/auxiliary/lint_group_plugin_test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint_group_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint_group_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint_group_plugin_test.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -3,7 +3,7 @@\n #![feature(plugin_registrar)]\n #![feature(box_syntax, rustc_private)]\n \n-// Load rustc as a plugin to get macros\n+// Load rustc as a plugin to get macros.\n #[macro_use]\n extern crate rustc;\n extern crate rustc_plugin;\n@@ -26,7 +26,7 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n-        match &*it.name.as_str() {\n+        match &*it.ident.as_str() {\n             \"lintme\" => cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\"),\n             \"pleaselintme\" => cx.span_lint(PLEASE_LINT, it.span, \"item is named 'pleaselintme'\"),\n             _ => {}"}, {"sha": "7a650afe5f8fa89123ca2f48e33b4d2b7a622590", "filename": "src/test/ui-fulldeps/lint-group-plugin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui-fulldeps%2Flint-group-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui-fulldeps%2Flint-group-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flint-group-plugin.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,6 +1,7 @@\n // run-pass\n // aux-build:lint_group_plugin_test.rs\n // ignore-stage1\n+\n #![feature(plugin)]\n #![plugin(lint_group_plugin_test)]\n #![allow(dead_code)]"}, {"sha": "b566048c75ee658a84651a90b16461680afff402", "filename": "src/test/ui-fulldeps/lint-group-plugin.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui-fulldeps%2Flint-group-plugin.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui-fulldeps%2Flint-group-plugin.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flint-group-plugin.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,13 +1,13 @@\n warning: item is named 'lintme'\n-  --> $DIR/lint-group-plugin.rs:8:1\n+  --> $DIR/lint-group-plugin.rs:9:1\n    |\n LL | fn lintme() { } //~ WARNING item is named 'lintme'\n    | ^^^^^^^^^^^^^^^\n    |\n    = note: #[warn(test_lint)] on by default\n \n warning: item is named 'pleaselintme'\n-  --> $DIR/lint-group-plugin.rs:9:1\n+  --> $DIR/lint-group-plugin.rs:10:1\n    |\n LL | fn pleaselintme() { } //~ WARNING item is named 'pleaselintme'\n    | ^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "de172049872f54ea29cab51d4ba56ef890b9fc77", "filename": "src/test/ui/associated-const/associated-const-no-item.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-no-item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-no-item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-no-item.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,8 +1,10 @@\n error[E0599]: no associated item named `ID` found for type `i32` in the current scope\n-  --> $DIR/associated-const-no-item.rs:5:16\n+  --> $DIR/associated-const-no-item.rs:5:23\n    |\n LL | const X: i32 = <i32>::ID;\n-   |                ^^^^^^^^^ associated item not found in `i32`\n+   |                -------^^\n+   |                |\n+   |                associated item not found in `i32`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `ID`, perhaps you need to implement it:"}, {"sha": "c594385eec2d67c98be02d51c79ceec4aec82c86", "filename": "src/test/ui/bogus-tag.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fbogus-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fbogus-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbogus-tag.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -3,8 +3,8 @@ enum Color { Rgb(isize, isize, isize), Rgba(isize, isize, isize, isize), }\n fn main() {\n     let red: Color = Color::Rgb(255, 0, 0);\n     match red {\n-      Color::Rgb(r, g, b) => { println!(\"rgb\"); }\n-      Color::Hsl(h, s, l) => { println!(\"hsl\"); }\n-      //~^ ERROR no variant\n+        Color::Rgb(r, g, b) => { println!(\"rgb\"); }\n+        Color::Hsl(h, s, l) => { println!(\"hsl\"); }\n+        //~^ ERROR no variant\n     }\n }"}, {"sha": "3750df841720c64efadedf61037598aa6c7b35a3", "filename": "src/test/ui/bogus-tag.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fbogus-tag.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fbogus-tag.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbogus-tag.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,11 +1,11 @@\n error[E0599]: no variant named `Hsl` found for type `Color` in the current scope\n-  --> $DIR/bogus-tag.rs:7:7\n+  --> $DIR/bogus-tag.rs:7:16\n    |\n LL | enum Color { Rgb(isize, isize, isize), Rgba(isize, isize, isize, isize), }\n    | ---------- variant `Hsl` not found here\n ...\n-LL |       Color::Hsl(h, s, l) => { println!(\"hsl\"); }\n-   |       ^^^^^^^^^^^^^^^^^^^ variant not found in `Color`\n+LL |         Color::Hsl(h, s, l) => { println!(\"hsl\"); }\n+   |         -------^^^--------- variant not found in `Color`\n \n error: aborting due to previous error\n "}, {"sha": "92fd9f26777f1c605be896acca8241756241806b", "filename": "src/test/ui/did_you_mean/bad-assoc-pat.stderr", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-pat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-pat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-pat.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -23,28 +23,36 @@ LL |         &(u8,)::AssocItem => {}\n    |          ^^^^^^^^^^^^^^^^ help: try: `<(u8,)>::AssocItem`\n \n error[E0599]: no associated item named `AssocItem` found for type `[u8]` in the current scope\n-  --> $DIR/bad-assoc-pat.rs:3:9\n+  --> $DIR/bad-assoc-pat.rs:3:15\n    |\n LL |         [u8]::AssocItem => {}\n-   |         ^^^^^^^^^^^^^^^ associated item not found in `[u8]`\n+   |         ------^^^^^^^^^\n+   |         |\n+   |         associated item not found in `[u8]`\n \n error[E0599]: no associated item named `AssocItem` found for type `(u8, u8)` in the current scope\n-  --> $DIR/bad-assoc-pat.rs:6:9\n+  --> $DIR/bad-assoc-pat.rs:6:19\n    |\n LL |         (u8, u8)::AssocItem => {}\n-   |         ^^^^^^^^^^^^^^^^^^^ associated item not found in `(u8, u8)`\n+   |         ----------^^^^^^^^^\n+   |         |\n+   |         associated item not found in `(u8, u8)`\n \n error[E0599]: no associated item named `AssocItem` found for type `_` in the current scope\n-  --> $DIR/bad-assoc-pat.rs:9:9\n+  --> $DIR/bad-assoc-pat.rs:9:12\n    |\n LL |         _::AssocItem => {}\n-   |         ^^^^^^^^^^^^ associated item not found in `_`\n+   |         ---^^^^^^^^^\n+   |         |\n+   |         associated item not found in `_`\n \n error[E0599]: no associated item named `AssocItem` found for type `(u8,)` in the current scope\n-  --> $DIR/bad-assoc-pat.rs:14:10\n+  --> $DIR/bad-assoc-pat.rs:14:17\n    |\n LL |         &(u8,)::AssocItem => {}\n-   |          ^^^^^^^^^^^^^^^^ associated item not found in `(u8,)`\n+   |          -------^^^^^^^^^\n+   |          |\n+   |          associated item not found in `(u8,)`\n \n error: aborting due to 8 previous errors\n "}, {"sha": "af4253779a4f56c7fbe65baff0b5cd28a4dc7db3", "filename": "src/test/ui/dont-suggest-private-trait-method.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fdont-suggest-private-trait-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fdont-suggest-private-trait-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdont-suggest-private-trait-method.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,11 +1,13 @@\n error[E0599]: no function or associated item named `new` found for type `T` in the current scope\n-  --> $DIR/dont-suggest-private-trait-method.rs:4:5\n+  --> $DIR/dont-suggest-private-trait-method.rs:4:8\n    |\n LL | struct T;\n    | --------- function or associated item `new` not found for this\n ...\n LL |     T::new();\n-   |     ^^^^^^ function or associated item not found in `T`\n+   |     ---^^^\n+   |     |\n+   |     function or associated item not found in `T`\n \n error: aborting due to previous error\n "}, {"sha": "d3e1cebd26fe1e27bedd4909c9322573fc07188b", "filename": "src/test/ui/empty/empty-struct-braces-expr.stderr", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fempty%2Fempty-struct-braces-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fempty%2Fempty-struct-braces-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fempty%2Fempty-struct-braces-expr.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -47,20 +47,24 @@ LL |     let xe1 = XEmpty1(); //~ ERROR expected function, found struct `XEmpty1\n    |               did you mean `XEmpty1 { /* fields */ }`?\n \n error[E0599]: no variant named `Empty3` found for type `empty_struct::XE` in the current scope\n-  --> $DIR/empty-struct-braces-expr.rs:22:15\n+  --> $DIR/empty-struct-braces-expr.rs:22:19\n    |\n LL |     let xe3 = XE::Empty3; //~ ERROR no variant named `Empty3` found for type\n-   |               ^^^^^^^^^^ variant not found in `empty_struct::XE`\n+   |               ----^^^^^^\n+   |               |\n+   |               variant not found in `empty_struct::XE`\n    |\n-   = note: did you mean `empty_struct::XE::XEmpty3`?\n+   = help: did you mean `XEmpty3`?\n \n error[E0599]: no variant named `Empty3` found for type `empty_struct::XE` in the current scope\n-  --> $DIR/empty-struct-braces-expr.rs:23:15\n+  --> $DIR/empty-struct-braces-expr.rs:23:19\n    |\n LL |     let xe3 = XE::Empty3(); //~ ERROR no variant named `Empty3` found for type\n-   |               ^^^^^^^^^^ variant not found in `empty_struct::XE`\n+   |               ----^^^^^^\n+   |               |\n+   |               variant not found in `empty_struct::XE`\n    |\n-   = note: did you mean `empty_struct::XE::XEmpty3`?\n+   = help: did you mean `XEmpty3`?\n \n error: aborting due to 8 previous errors\n "}, {"sha": "6eddd70964546ce9a6735932b8fb78594ce3140b", "filename": "src/test/ui/enum-variant-generic-args.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fenum-variant-generic-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fenum-variant-generic-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum-variant-generic-args.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -0,0 +1,73 @@\n+#![feature(type_alias_enum_variants)]\n+\n+enum Enum<T> { TSVariant(T), SVariant { v: T } }\n+type Alias<T> = Enum<T>;\n+type AliasFixed = Enum<()>;\n+\n+impl<T> Enum<T> {\n+    fn ts_variant() {\n+        Self::TSVariant(());\n+        //~^ ERROR mismatched types [E0308]\n+        Self::TSVariant::<()>(());\n+        //~^ ERROR type arguments are not allowed on this entity [E0109]\n+        Self::<()>::TSVariant(());\n+        //~^ ERROR type arguments are not allowed on this entity [E0109]\n+        //~^^ ERROR mismatched types [E0308]\n+        Self::<()>::TSVariant::<()>(());\n+        //~^ ERROR type arguments are not allowed on this entity [E0109]\n+        //~^^ ERROR type arguments are not allowed on this entity [E0109]\n+    }\n+\n+    fn s_variant() {\n+        Self::SVariant { v: () };\n+        //~^ ERROR mismatched types [E0308]\n+        Self::SVariant::<()> { v: () };\n+        //~^ ERROR type arguments are not allowed on this entity [E0109]\n+        //~^^ ERROR mismatched types [E0308]\n+        Self::<()>::SVariant { v: () };\n+        //~^ ERROR type arguments are not allowed on this entity [E0109]\n+        //~^^ ERROR mismatched types [E0308]\n+        Self::<()>::SVariant::<()> { v: () };\n+        //~^ ERROR type arguments are not allowed on this entity [E0109]\n+        //~^^ ERROR type arguments are not allowed on this entity [E0109]\n+        //~^^^ ERROR mismatched types [E0308]\n+    }\n+}\n+\n+fn main() {\n+    // Tuple struct variant\n+\n+    Enum::<()>::TSVariant::<()>(());\n+    //~^ ERROR type arguments are not allowed on this entity [E0109]\n+\n+    Alias::TSVariant::<()>(());\n+    //~^ ERROR type arguments are not allowed on this entity [E0109]\n+    Alias::<()>::TSVariant::<()>(());\n+    //~^ ERROR type arguments are not allowed on this entity [E0109]\n+\n+    AliasFixed::TSVariant::<()>(());\n+    //~^ ERROR type arguments are not allowed on this entity [E0109]\n+    AliasFixed::<()>::TSVariant(());\n+    //~^ ERROR wrong number of type arguments: expected 0, found 1 [E0107]\n+    AliasFixed::<()>::TSVariant::<()>(());\n+    //~^ ERROR type arguments are not allowed on this entity [E0109]\n+    //~^^ ERROR wrong number of type arguments: expected 0, found 1 [E0107]\n+\n+    // Struct variant\n+\n+    Enum::<()>::SVariant::<()> { v: () };\n+    //~^ ERROR type arguments are not allowed on this entity [E0109]\n+\n+    Alias::SVariant::<()> { v: () };\n+    //~^ ERROR type arguments are not allowed on this entity [E0109]\n+    Alias::<()>::SVariant::<()> { v: () };\n+    //~^ ERROR type arguments are not allowed on this entity [E0109]\n+\n+    AliasFixed::SVariant::<()> { v: () };\n+    //~^ ERROR type arguments are not allowed on this entity [E0109]\n+    AliasFixed::<()>::SVariant { v: () };\n+    //~^ ERROR wrong number of type arguments: expected 0, found 1 [E0107]\n+    AliasFixed::<()>::SVariant::<()> { v: () };\n+    //~^ ERROR type arguments are not allowed on this entity [E0109]\n+    //~^^ ERROR wrong number of type arguments: expected 0, found 1 [E0107]\n+}"}, {"sha": "4d3b576734643f5c32295d611cad086fc652368e", "filename": "src/test/ui/enum-variant-generic-args.stderr", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fenum-variant-generic-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fenum-variant-generic-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum-variant-generic-args.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -0,0 +1,190 @@\n+error[E0308]: mismatched types\n+  --> $DIR/enum-variant-generic-args.rs:9:25\n+   |\n+LL |         Self::TSVariant(());\n+   |                         ^^ expected type parameter, found ()\n+   |\n+   = note: expected type `T`\n+              found type `()`\n+\n+error[E0109]: type arguments are not allowed on this entity\n+  --> $DIR/enum-variant-generic-args.rs:11:27\n+   |\n+LL |         Self::TSVariant::<()>(());\n+   |                           ^^ type argument not allowed\n+\n+error[E0109]: type arguments are not allowed on this entity\n+  --> $DIR/enum-variant-generic-args.rs:13:16\n+   |\n+LL |         Self::<()>::TSVariant(());\n+   |                ^^ type argument not allowed\n+\n+error[E0308]: mismatched types\n+  --> $DIR/enum-variant-generic-args.rs:13:31\n+   |\n+LL |         Self::<()>::TSVariant(());\n+   |                               ^^ expected type parameter, found ()\n+   |\n+   = note: expected type `T`\n+              found type `()`\n+\n+error[E0109]: type arguments are not allowed on this entity\n+  --> $DIR/enum-variant-generic-args.rs:16:16\n+   |\n+LL |         Self::<()>::TSVariant::<()>(());\n+   |                ^^ type argument not allowed\n+\n+error[E0109]: type arguments are not allowed on this entity\n+  --> $DIR/enum-variant-generic-args.rs:16:33\n+   |\n+LL |         Self::<()>::TSVariant::<()>(());\n+   |                                 ^^ type argument not allowed\n+\n+error[E0308]: mismatched types\n+  --> $DIR/enum-variant-generic-args.rs:22:29\n+   |\n+LL |         Self::SVariant { v: () };\n+   |                             ^^ expected type parameter, found ()\n+   |\n+   = note: expected type `T`\n+              found type `()`\n+\n+error[E0109]: type arguments are not allowed on this entity\n+  --> $DIR/enum-variant-generic-args.rs:24:26\n+   |\n+LL |         Self::SVariant::<()> { v: () };\n+   |                          ^^ type argument not allowed\n+\n+error[E0308]: mismatched types\n+  --> $DIR/enum-variant-generic-args.rs:24:35\n+   |\n+LL |         Self::SVariant::<()> { v: () };\n+   |                                   ^^ expected type parameter, found ()\n+   |\n+   = note: expected type `T`\n+              found type `()`\n+\n+error[E0109]: type arguments are not allowed on this entity\n+  --> $DIR/enum-variant-generic-args.rs:27:16\n+   |\n+LL |         Self::<()>::SVariant { v: () };\n+   |                ^^ type argument not allowed\n+\n+error[E0308]: mismatched types\n+  --> $DIR/enum-variant-generic-args.rs:27:35\n+   |\n+LL |         Self::<()>::SVariant { v: () };\n+   |                                   ^^ expected type parameter, found ()\n+   |\n+   = note: expected type `T`\n+              found type `()`\n+\n+error[E0109]: type arguments are not allowed on this entity\n+  --> $DIR/enum-variant-generic-args.rs:30:16\n+   |\n+LL |         Self::<()>::SVariant::<()> { v: () };\n+   |                ^^ type argument not allowed\n+\n+error[E0109]: type arguments are not allowed on this entity\n+  --> $DIR/enum-variant-generic-args.rs:30:32\n+   |\n+LL |         Self::<()>::SVariant::<()> { v: () };\n+   |                                ^^ type argument not allowed\n+\n+error[E0308]: mismatched types\n+  --> $DIR/enum-variant-generic-args.rs:30:41\n+   |\n+LL |         Self::<()>::SVariant::<()> { v: () };\n+   |                                         ^^ expected type parameter, found ()\n+   |\n+   = note: expected type `T`\n+              found type `()`\n+\n+error[E0109]: type arguments are not allowed on this entity\n+  --> $DIR/enum-variant-generic-args.rs:40:29\n+   |\n+LL |     Enum::<()>::TSVariant::<()>(());\n+   |                             ^^ type argument not allowed\n+\n+error[E0109]: type arguments are not allowed on this entity\n+  --> $DIR/enum-variant-generic-args.rs:43:24\n+   |\n+LL |     Alias::TSVariant::<()>(());\n+   |                        ^^ type argument not allowed\n+\n+error[E0109]: type arguments are not allowed on this entity\n+  --> $DIR/enum-variant-generic-args.rs:45:30\n+   |\n+LL |     Alias::<()>::TSVariant::<()>(());\n+   |                              ^^ type argument not allowed\n+\n+error[E0109]: type arguments are not allowed on this entity\n+  --> $DIR/enum-variant-generic-args.rs:48:29\n+   |\n+LL |     AliasFixed::TSVariant::<()>(());\n+   |                             ^^ type argument not allowed\n+\n+error[E0107]: wrong number of type arguments: expected 0, found 1\n+  --> $DIR/enum-variant-generic-args.rs:50:18\n+   |\n+LL |     AliasFixed::<()>::TSVariant(());\n+   |                  ^^ unexpected type argument\n+\n+error[E0107]: wrong number of type arguments: expected 0, found 1\n+  --> $DIR/enum-variant-generic-args.rs:52:18\n+   |\n+LL |     AliasFixed::<()>::TSVariant::<()>(());\n+   |                  ^^ unexpected type argument\n+\n+error[E0109]: type arguments are not allowed on this entity\n+  --> $DIR/enum-variant-generic-args.rs:52:35\n+   |\n+LL |     AliasFixed::<()>::TSVariant::<()>(());\n+   |                                   ^^ type argument not allowed\n+\n+error[E0109]: type arguments are not allowed on this entity\n+  --> $DIR/enum-variant-generic-args.rs:58:28\n+   |\n+LL |     Enum::<()>::SVariant::<()> { v: () };\n+   |                            ^^ type argument not allowed\n+\n+error[E0109]: type arguments are not allowed on this entity\n+  --> $DIR/enum-variant-generic-args.rs:61:23\n+   |\n+LL |     Alias::SVariant::<()> { v: () };\n+   |                       ^^ type argument not allowed\n+\n+error[E0109]: type arguments are not allowed on this entity\n+  --> $DIR/enum-variant-generic-args.rs:63:29\n+   |\n+LL |     Alias::<()>::SVariant::<()> { v: () };\n+   |                             ^^ type argument not allowed\n+\n+error[E0109]: type arguments are not allowed on this entity\n+  --> $DIR/enum-variant-generic-args.rs:66:28\n+   |\n+LL |     AliasFixed::SVariant::<()> { v: () };\n+   |                            ^^ type argument not allowed\n+\n+error[E0107]: wrong number of type arguments: expected 0, found 1\n+  --> $DIR/enum-variant-generic-args.rs:68:18\n+   |\n+LL |     AliasFixed::<()>::SVariant { v: () };\n+   |                  ^^ unexpected type argument\n+\n+error[E0107]: wrong number of type arguments: expected 0, found 1\n+  --> $DIR/enum-variant-generic-args.rs:70:18\n+   |\n+LL |     AliasFixed::<()>::SVariant::<()> { v: () };\n+   |                  ^^ unexpected type argument\n+\n+error[E0109]: type arguments are not allowed on this entity\n+  --> $DIR/enum-variant-generic-args.rs:70:34\n+   |\n+LL |     AliasFixed::<()>::SVariant::<()> { v: () };\n+   |                                  ^^ type argument not allowed\n+\n+error: aborting due to 28 previous errors\n+\n+Some errors occurred: E0107, E0109, E0308.\n+For more information about an error, try `rustc --explain E0107`."}, {"sha": "a5508f98085762aceb71e897bebf3b73a5eff537", "filename": "src/test/ui/error-codes/E0109.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Ferror-codes%2FE0109.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Ferror-codes%2FE0109.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0109.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,8 +1,8 @@\n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/E0109.rs:1:14\n    |\n LL | type X = u32<i32>; //~ ERROR E0109\n-   |              ^^^ type parameter not allowed\n+   |              ^^^ type argument not allowed\n \n error: aborting due to previous error\n "}, {"sha": "764b62b8dfecf5dafa8922fea20108ca99662ecd", "filename": "src/test/ui/error-codes/E0110.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Ferror-codes%2FE0110.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Ferror-codes%2FE0110.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0110.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,4 +1,3 @@\n type X = u32<'static>; //~ ERROR E0110\n \n-fn main() {\n-}\n+fn main() {}"}, {"sha": "a644ac92cefbfe5c0e1cef840c795b458d8b7849", "filename": "src/test/ui/error-codes/E0110.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Ferror-codes%2FE0110.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Ferror-codes%2FE0110.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0110.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,8 +1,8 @@\n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/E0110.rs:1:14\n    |\n LL | type X = u32<'static>; //~ ERROR E0110\n-   |              ^^^^^^^ lifetime parameter not allowed\n+   |              ^^^^^^^ lifetime argument not allowed\n \n error: aborting due to previous error\n "}, {"sha": "85110889e9a7b1a65769a60a42a7c6f98c600192", "filename": "src/test/ui/error-codes/E0599.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Ferror-codes%2FE0599.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Ferror-codes%2FE0599.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0599.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,11 +1,11 @@\n error[E0599]: no associated item named `NotEvenReal` found for type `Foo` in the current scope\n-  --> $DIR/E0599.rs:4:15\n+  --> $DIR/E0599.rs:4:20\n    |\n LL | struct Foo;\n    | ----------- associated item `NotEvenReal` not found for this\n ...\n LL |     || if let Foo::NotEvenReal() = Foo {}; //~ ERROR E0599\n-   |               ^^^^^^^^^^^^^^^^^^ associated item not found in `Foo`\n+   |               -----^^^^^^^^^^^-- associated item not found in `Foo`\n \n error: aborting due to previous error\n "}, {"sha": "8997c1824ca6d02901062af8ffee5b54700cbfe8", "filename": "src/test/ui/feature-gates/feature-gate-type_alias_enum_variants.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_enum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_enum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_enum_variants.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum Foo {\n+    Bar(i32),\n+    Baz { i: i32 },\n+}\n+\n+type Alias = Foo;\n+\n+fn main() {\n+    let t = Alias::Bar(0);\n+    //~^ ERROR enum variants on type aliases are experimental\n+    let t = Alias::Baz { i: 0 };\n+    //~^ ERROR enum variants on type aliases are experimental\n+    match t {\n+        Alias::Bar(_i) => {}\n+        //~^ ERROR enum variants on type aliases are experimental\n+        Alias::Baz { i: _i } => {}\n+        //~^ ERROR enum variants on type aliases are experimental\n+    }\n+}"}, {"sha": "cba643e18ca1acfbb358b7c3a7bc7d1aa675b164", "filename": "src/test/ui/feature-gates/feature-gate-type_alias_enum_variants.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_enum_variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_enum_variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_enum_variants.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -0,0 +1,34 @@\n+error: enum variants on type aliases are experimental\n+  --> $DIR/feature-gate-type_alias_enum_variants.rs:19:13\n+   |\n+LL |     let t = Alias::Bar(0);\n+   |             ^^^^^^^^^^\n+   |\n+   = help: add `#![feature(type_alias_enum_variants)]` to the crate attributes to enable\n+\n+error: enum variants on type aliases are experimental\n+  --> $DIR/feature-gate-type_alias_enum_variants.rs:21:13\n+   |\n+LL |     let t = Alias::Baz { i: 0 };\n+   |             ^^^^^^^^^^\n+   |\n+   = help: add `#![feature(type_alias_enum_variants)]` to the crate attributes to enable\n+\n+error: enum variants on type aliases are experimental\n+  --> $DIR/feature-gate-type_alias_enum_variants.rs:24:9\n+   |\n+LL |         Alias::Bar(_i) => {}\n+   |         ^^^^^^^^^^^^^^\n+   |\n+   = help: add `#![feature(type_alias_enum_variants)]` to the crate attributes to enable\n+\n+error: enum variants on type aliases are experimental\n+  --> $DIR/feature-gate-type_alias_enum_variants.rs:26:9\n+   |\n+LL |         Alias::Baz { i: _i } => {}\n+   |         ^^^^^^^^^^\n+   |\n+   = help: add `#![feature(type_alias_enum_variants)]` to the crate attributes to enable\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "13176b8b8fb15bbd6691c970bd60c84939ccd251", "filename": "src/test/ui/invalid/invalid-path-in-const.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Finvalid%2Finvalid-path-in-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Finvalid%2Finvalid-path-in-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid%2Finvalid-path-in-const.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,8 +1,10 @@\n error[E0599]: no associated item named `DOESNOTEXIST` found for type `u32` in the current scope\n-  --> $DIR/invalid-path-in-const.rs:2:18\n+  --> $DIR/invalid-path-in-const.rs:2:23\n    |\n LL |     fn f(a: [u8; u32::DOESNOTEXIST]) {}\n-   |                  ^^^^^^^^^^^^^^^^^ associated item not found in `u32`\n+   |                  -----^^^^^^^^^^^^\n+   |                  |\n+   |                  associated item not found in `u32`\n \n error: aborting due to previous error\n "}, {"sha": "413a0d9a4943a168e9897a3d887bbd1cc3e9b56e", "filename": "src/test/ui/issues/issue-22706.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-22706.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-22706.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22706.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,3 +1,3 @@\n fn is_copy<T: ::std::marker<i32>::Copy>() {}\n-//~^ ERROR type parameters are not allowed on this type [E0109]\n+//~^ ERROR type arguments are not allowed on this entity [E0109]\n fn main() {}"}, {"sha": "a3cf716903d20bb6148d3e6bd46dc6661963dd41", "filename": "src/test/ui/issues/issue-22706.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-22706.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-22706.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22706.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,8 +1,8 @@\n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/issue-22706.rs:1:29\n    |\n LL | fn is_copy<T: ::std::marker<i32>::Copy>() {}\n-   |                             ^^^ type parameter not allowed\n+   |                             ^^^ type argument not allowed\n \n error: aborting due to previous error\n "}, {"sha": "97962adc2d2862d3fd4d13ccba90efb8166aef42", "filename": "src/test/ui/issues/issue-22933-2.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-22933-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-22933-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22933-2.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,11 +1,13 @@\n error[E0599]: no variant named `PIE` found for type `Delicious` in the current scope\n-  --> $DIR/issue-22933-2.rs:4:44\n+  --> $DIR/issue-22933-2.rs:4:55\n    |\n LL | enum Delicious {\n    | -------------- variant `PIE` not found here\n ...\n LL |     ApplePie = Delicious::Apple as isize | Delicious::PIE as isize,\n-   |                                            ^^^^^^^^^^^^^^ variant not found in `Delicious`\n+   |                                            -----------^^^\n+   |                                            |\n+   |                                            variant not found in `Delicious`\n \n error: aborting due to previous error\n "}, {"sha": "aa0052f97013e9582305f5e4e3c41bda006661e7", "filename": "src/test/ui/issues/issue-22933-3.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-22933-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-22933-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22933-3.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,8 +1,10 @@\n error[E0599]: no associated item named `MIN` found for type `u8` in the current scope\n-  --> $DIR/issue-22933-3.rs:1:18\n+  --> $DIR/issue-22933-3.rs:1:22\n    |\n LL | const FOO: [u32; u8::MIN as usize] = [];\n-   |                  ^^^^^^^ associated item not found in `u8`\n+   |                  ----^^^\n+   |                  |\n+   |                  associated item not found in `u8`\n \n error: aborting due to previous error\n "}, {"sha": "98c4f867ad6a0fe1a86eab1d26861a1352183774", "filename": "src/test/ui/issues/issue-23173.stderr", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-23173.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-23173.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23173.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,38 +1,46 @@\n error[E0599]: no variant named `Homura` found for type `Token` in the current scope\n-  --> $DIR/issue-23173.rs:9:16\n+  --> $DIR/issue-23173.rs:9:23\n    |\n LL | enum Token { LeftParen, RightParen, Plus, Minus, /* etc */ }\n    | ---------- variant `Homura` not found here\n ...\n LL |     use_token(&Token::Homura);\n-   |                ^^^^^^^^^^^^^ variant not found in `Token`\n+   |                -------^^^^^^\n+   |                |\n+   |                variant not found in `Token`\n \n error[E0599]: no function or associated item named `method` found for type `Struct` in the current scope\n-  --> $DIR/issue-23173.rs:11:5\n+  --> $DIR/issue-23173.rs:11:13\n    |\n LL | struct Struct {\n    | ------------- function or associated item `method` not found for this\n ...\n LL |     Struct::method();\n-   |     ^^^^^^^^^^^^^^ function or associated item not found in `Struct`\n+   |     --------^^^^^^\n+   |     |\n+   |     function or associated item not found in `Struct`\n \n error[E0599]: no function or associated item named `method` found for type `Struct` in the current scope\n-  --> $DIR/issue-23173.rs:13:5\n+  --> $DIR/issue-23173.rs:13:13\n    |\n LL | struct Struct {\n    | ------------- function or associated item `method` not found for this\n ...\n LL |     Struct::method;\n-   |     ^^^^^^^^^^^^^^ function or associated item not found in `Struct`\n+   |     --------^^^^^^\n+   |     |\n+   |     function or associated item not found in `Struct`\n \n error[E0599]: no associated item named `Assoc` found for type `Struct` in the current scope\n-  --> $DIR/issue-23173.rs:15:5\n+  --> $DIR/issue-23173.rs:15:13\n    |\n LL | struct Struct {\n    | ------------- associated item `Assoc` not found for this\n ...\n LL |     Struct::Assoc;\n-   |     ^^^^^^^^^^^^^ associated item not found in `Struct`\n+   |     --------^^^^^\n+   |     |\n+   |     associated item not found in `Struct`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "208d0cc499a80024011d2467439b515ac5f6e582", "filename": "src/test/ui/issues/issue-23217.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-23217.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-23217.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23217.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,12 +1,14 @@\n error[E0599]: no variant named `A` found for type `SomeEnum` in the current scope\n-  --> $DIR/issue-23217.rs:2:9\n+  --> $DIR/issue-23217.rs:2:19\n    |\n LL | pub enum SomeEnum {\n    | ----------------- variant `A` not found here\n LL |     B = SomeEnum::A,\n-   |         ^^^^^^^^^^^ variant not found in `SomeEnum`\n+   |         ----------^\n+   |         |\n+   |         variant not found in `SomeEnum`\n    |\n-   = note: did you mean `SomeEnum::B`?\n+   = help: did you mean `B`?\n \n error: aborting due to previous error\n "}, {"sha": "146ebad6ce17567fc636095c2e417801d923521f", "filename": "src/test/ui/issues/issue-28344.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-28344.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-28344.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-28344.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -5,10 +5,12 @@ LL |     let x: u8 = BitXor::bitor(0 as u8, 0 as u8);\n    |                 ^^^^^^^^^^^^^ associated type `Output` must be specified\n \n error[E0599]: no function or associated item named `bitor` found for type `dyn std::ops::BitXor<_>` in the current scope\n-  --> $DIR/issue-28344.rs:4:17\n+  --> $DIR/issue-28344.rs:4:25\n    |\n LL |     let x: u8 = BitXor::bitor(0 as u8, 0 as u8);\n-   |                 ^^^^^^^^^^^^^ function or associated item not found in `dyn std::ops::BitXor<_>`\n+   |                 --------^^^^^\n+   |                 |\n+   |                 function or associated item not found in `dyn std::ops::BitXor<_>`\n    |\n    = help: did you mean `bitxor`?\n \n@@ -19,10 +21,12 @@ LL |     let g = BitXor::bitor;\n    |             ^^^^^^^^^^^^^ associated type `Output` must be specified\n \n error[E0599]: no function or associated item named `bitor` found for type `dyn std::ops::BitXor<_>` in the current scope\n-  --> $DIR/issue-28344.rs:8:13\n+  --> $DIR/issue-28344.rs:8:21\n    |\n LL |     let g = BitXor::bitor;\n-   |             ^^^^^^^^^^^^^ function or associated item not found in `dyn std::ops::BitXor<_>`\n+   |             --------^^^^^\n+   |             |\n+   |             function or associated item not found in `dyn std::ops::BitXor<_>`\n    |\n    = help: did you mean `bitxor`?\n "}, {"sha": "eccb474c15eb6e07dc6d65ed9824ea1ac74208ee", "filename": "src/test/ui/issues/issue-28586.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-28586.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-28586.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-28586.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,8 +1,10 @@\n error[E0599]: no associated item named `BYTES` found for type `usize` in the current scope\n-  --> $DIR/issue-28586.rs:4:19\n+  --> $DIR/issue-28586.rs:4:26\n    |\n LL | impl Foo for [u8; usize::BYTES] {}\n-   |                   ^^^^^^^^^^^^ associated item not found in `usize`\n+   |                   -------^^^^^\n+   |                   |\n+   |                   associated item not found in `usize`\n \n error: aborting due to previous error\n "}, {"sha": "d5dbd5f64885c2f695189680bfb507281bf8c248", "filename": "src/test/ui/issues/issue-28971.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-28971.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-28971.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-28971.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,13 +1,13 @@\n error[E0599]: no variant named `Baz` found for type `Foo` in the current scope\n-  --> $DIR/issue-28971.rs:9:13\n+  --> $DIR/issue-28971.rs:9:18\n    |\n LL | enum Foo {\n    | -------- variant `Baz` not found here\n ...\n LL |             Foo::Baz(..) => (),\n-   |             ^^^^^^^^^^^^ variant not found in `Foo`\n+   |             -----^^^---- variant not found in `Foo`\n    |\n-   = note: did you mean `Foo::Bar`?\n+   = help: did you mean `Bar`?\n \n error: aborting due to previous error\n "}, {"sha": "555bdb1236fe6f8820c9acf64ce1af31728b89d3", "filename": "src/test/ui/issues/issue-30123.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-30123.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-30123.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30123.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,8 +1,10 @@\n error[E0599]: no function or associated item named `new_undirected` found for type `issue_30123_aux::Graph<i32, i32>` in the current scope\n-  --> $DIR/issue-30123.rs:7:14\n+  --> $DIR/issue-30123.rs:7:33\n    |\n LL |     let ug = Graph::<i32, i32>::new_undirected();\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ function or associated item not found in `issue_30123_aux::Graph<i32, i32>`\n+   |              -------------------^^^^^^^^^^^^^^\n+   |              |\n+   |              function or associated item not found in `issue_30123_aux::Graph<i32, i32>`\n \n error: aborting due to previous error\n "}, {"sha": "8c094364795646d1cf823406abda1bdaad0a8fa6", "filename": "src/test/ui/issues/issue-38919.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-38919.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-38919.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-38919.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,8 +1,10 @@\n error[E0599]: no associated item named `Item` found for type `T` in the current scope\n-  --> $DIR/issue-38919.rs:2:5\n+  --> $DIR/issue-38919.rs:2:8\n    |\n LL |     T::Item; //~ ERROR no associated item named `Item` found for type `T` in the current scope\n-   |     ^^^^^^^ associated item not found in `T`\n+   |     ---^^^^\n+   |     |\n+   |     associated item not found in `T`\n \n error: aborting due to previous error\n "}, {"sha": "e851e79faee06fe699e82cd4affa97b118c68c76", "filename": "src/test/ui/issues/issue-39559.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-39559.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-39559.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39559.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,8 +1,10 @@\n error[E0599]: no function or associated item named `dim` found for type `D` in the current scope\n-  --> $DIR/issue-39559.rs:14:18\n+  --> $DIR/issue-39559.rs:14:21\n    |\n LL |     entries: [T; D::dim()],\n-   |                  ^^^^^^ function or associated item not found in `D`\n+   |                  ---^^^\n+   |                  |\n+   |                  function or associated item not found in `D`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `dim`, perhaps you need to implement it:"}, {"sha": "8e46d88018112ced7bc8d5d3ee7dc5d636d8f446", "filename": "src/test/ui/issues/issue-3973.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-3973.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-3973.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3973.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -8,13 +8,15 @@ LL | |     }\n    | |_____^ not a member of trait `ToString_`\n \n error[E0599]: no function or associated item named `new` found for type `Point` in the current scope\n-  --> $DIR/issue-3973.rs:22:13\n+  --> $DIR/issue-3973.rs:22:20\n    |\n LL | struct Point {\n    | ------------ function or associated item `new` not found for this\n ...\n LL |     let p = Point::new(0.0, 0.0);\n-   |             ^^^^^^^^^^ function or associated item not found in `Point`\n+   |             -------^^^\n+   |             |\n+   |             function or associated item not found in `Point`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "36b9e8a1e8afa72f93790f153fd3f7f81312a660", "filename": "src/test/ui/issues/issue-42880.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-42880.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-42880.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-42880.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,8 +1,8 @@\n error[E0599]: no associated item named `String` found for type `std::string::String` in the current scope\n-  --> $DIR/issue-42880.rs:4:15\n+  --> $DIR/issue-42880.rs:4:22\n    |\n LL |     let f = |&Value::String(_)| (); //~ ERROR no associated item named\n-   |               ^^^^^^^^^^^^^^^^ associated item not found in `std::string::String`\n+   |               -------^^^^^^--- associated item not found in `std::string::String`\n \n error: aborting due to previous error\n "}, {"sha": "e30f04753762ef9332c5be737a45248fc6d18b74", "filename": "src/test/ui/issues/issue-7950.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-7950.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fissues%2Fissue-7950.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-7950.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,11 +1,13 @@\n error[E0599]: no function or associated item named `bar` found for type `Foo` in the current scope\n-  --> $DIR/issue-7950.rs:6:5\n+  --> $DIR/issue-7950.rs:6:10\n    |\n LL | struct Foo;\n    | ----------- function or associated item `bar` not found for this\n ...\n LL |     Foo::bar();\n-   |     ^^^^^^^^ function or associated item not found in `Foo`\n+   |     -----^^^\n+   |     |\n+   |     function or associated item not found in `Foo`\n \n error: aborting due to previous error\n "}, {"sha": "51313033a02ddf07b7c66cfd04dab3dc27afb3a0", "filename": "src/test/ui/lexical-scopes.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Flexical-scopes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Flexical-scopes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flexical-scopes.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -9,10 +9,12 @@ LL | use T;\n    |\n \n error[E0599]: no function or associated item named `f` found for type `Foo` in the current scope\n-  --> $DIR/lexical-scopes.rs:10:5\n+  --> $DIR/lexical-scopes.rs:10:10\n    |\n LL |     Foo::f(); //~ ERROR no function or associated item named `f`\n-   |     ^^^^^^ function or associated item not found in `Foo`\n+   |     -----^\n+   |     |\n+   |     function or associated item not found in `Foo`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ec809d44e942a82ca57e33a03c12cac7eef928c3", "filename": "src/test/ui/mod-subitem-as-enum-variant.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fmod-subitem-as-enum-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fmod-subitem-as-enum-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmod-subitem-as-enum-variant.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -0,0 +1,10 @@\n+\n+mod Mod {\n+    pub struct FakeVariant<T>(pub T);\n+}\n+\n+fn main() {\n+    Mod::FakeVariant::<i32>(0);\n+    Mod::<i32>::FakeVariant(0);\n+    //~^ ERROR type arguments are not allowed on this entity [E0109]\n+}"}, {"sha": "d62bad81c3d8dd61b4010ab93e2316376b79d85e", "filename": "src/test/ui/mod-subitem-as-enum-variant.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fmod-subitem-as-enum-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fmod-subitem-as-enum-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmod-subitem-as-enum-variant.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -0,0 +1,9 @@\n+error[E0109]: type arguments are not allowed on this entity\n+  --> $DIR/mod-subitem-as-enum-variant.rs:8:11\n+   |\n+LL |     Mod::<i32>::FakeVariant(0);\n+   |           ^^^ type argument not allowed\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0109`."}, {"sha": "b5df0fb76ca6a8db8e6a03221a34d224c43f9698", "filename": "src/test/ui/prim-with-args.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fprim-with-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fprim-with-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprim-with-args.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,27 +1,27 @@\n fn main() {\n \n-let x: isize<isize>; //~ ERROR type parameters are not allowed on this type\n-let x: i8<isize>; //~ ERROR type parameters are not allowed on this type\n-let x: i16<isize>; //~ ERROR type parameters are not allowed on this type\n-let x: i32<isize>; //~ ERROR type parameters are not allowed on this type\n-let x: i64<isize>; //~ ERROR type parameters are not allowed on this type\n-let x: usize<isize>; //~ ERROR type parameters are not allowed on this type\n-let x: u8<isize>; //~ ERROR type parameters are not allowed on this type\n-let x: u16<isize>; //~ ERROR type parameters are not allowed on this type\n-let x: u32<isize>; //~ ERROR type parameters are not allowed on this type\n-let x: u64<isize>; //~ ERROR type parameters are not allowed on this type\n-let x: char<isize>; //~ ERROR type parameters are not allowed on this type\n+let x: isize<isize>; //~ ERROR type arguments are not allowed on this entity\n+let x: i8<isize>; //~ ERROR type arguments are not allowed on this entity\n+let x: i16<isize>; //~ ERROR type arguments are not allowed on this entity\n+let x: i32<isize>; //~ ERROR type arguments are not allowed on this entity\n+let x: i64<isize>; //~ ERROR type arguments are not allowed on this entity\n+let x: usize<isize>; //~ ERROR type arguments are not allowed on this entity\n+let x: u8<isize>; //~ ERROR type arguments are not allowed on this entity\n+let x: u16<isize>; //~ ERROR type arguments are not allowed on this entity\n+let x: u32<isize>; //~ ERROR type arguments are not allowed on this entity\n+let x: u64<isize>; //~ ERROR type arguments are not allowed on this entity\n+let x: char<isize>; //~ ERROR type arguments are not allowed on this entity\n \n-let x: isize<'static>; //~ ERROR lifetime parameters are not allowed on this type\n-let x: i8<'static>; //~ ERROR lifetime parameters are not allowed on this type\n-let x: i16<'static>; //~ ERROR lifetime parameters are not allowed on this type\n-let x: i32<'static>; //~ ERROR lifetime parameters are not allowed on this type\n-let x: i64<'static>; //~ ERROR lifetime parameters are not allowed on this type\n-let x: usize<'static>; //~ ERROR lifetime parameters are not allowed on this type\n-let x: u8<'static>; //~ ERROR lifetime parameters are not allowed on this type\n-let x: u16<'static>; //~ ERROR lifetime parameters are not allowed on this type\n-let x: u32<'static>; //~ ERROR lifetime parameters are not allowed on this type\n-let x: u64<'static>; //~ ERROR lifetime parameters are not allowed on this type\n-let x: char<'static>; //~ ERROR lifetime parameters are not allowed on this type\n+let x: isize<'static>; //~ ERROR lifetime arguments are not allowed on this entity\n+let x: i8<'static>; //~ ERROR lifetime arguments are not allowed on this entity\n+let x: i16<'static>; //~ ERROR lifetime arguments are not allowed on this entity\n+let x: i32<'static>; //~ ERROR lifetime arguments are not allowed on this entity\n+let x: i64<'static>; //~ ERROR lifetime arguments are not allowed on this entity\n+let x: usize<'static>; //~ ERROR lifetime arguments are not allowed on this entity\n+let x: u8<'static>; //~ ERROR lifetime arguments are not allowed on this entity\n+let x: u16<'static>; //~ ERROR lifetime arguments are not allowed on this entity\n+let x: u32<'static>; //~ ERROR lifetime arguments are not allowed on this entity\n+let x: u64<'static>; //~ ERROR lifetime arguments are not allowed on this entity\n+let x: char<'static>; //~ ERROR lifetime arguments are not allowed on this entity\n \n }"}, {"sha": "91259e87efc0228a90ed8e2a00cf0f6de77add8c", "filename": "src/test/ui/prim-with-args.stderr", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fprim-with-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fprim-with-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprim-with-args.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,134 +1,134 @@\n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/prim-with-args.rs:3:14\n    |\n-LL | let x: isize<isize>; //~ ERROR type parameters are not allowed on this type\n-   |              ^^^^^ type parameter not allowed\n+LL | let x: isize<isize>; //~ ERROR type arguments are not allowed on this entity\n+   |              ^^^^^ type argument not allowed\n \n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/prim-with-args.rs:4:11\n    |\n-LL | let x: i8<isize>; //~ ERROR type parameters are not allowed on this type\n-   |           ^^^^^ type parameter not allowed\n+LL | let x: i8<isize>; //~ ERROR type arguments are not allowed on this entity\n+   |           ^^^^^ type argument not allowed\n \n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/prim-with-args.rs:5:12\n    |\n-LL | let x: i16<isize>; //~ ERROR type parameters are not allowed on this type\n-   |            ^^^^^ type parameter not allowed\n+LL | let x: i16<isize>; //~ ERROR type arguments are not allowed on this entity\n+   |            ^^^^^ type argument not allowed\n \n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/prim-with-args.rs:6:12\n    |\n-LL | let x: i32<isize>; //~ ERROR type parameters are not allowed on this type\n-   |            ^^^^^ type parameter not allowed\n+LL | let x: i32<isize>; //~ ERROR type arguments are not allowed on this entity\n+   |            ^^^^^ type argument not allowed\n \n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/prim-with-args.rs:7:12\n    |\n-LL | let x: i64<isize>; //~ ERROR type parameters are not allowed on this type\n-   |            ^^^^^ type parameter not allowed\n+LL | let x: i64<isize>; //~ ERROR type arguments are not allowed on this entity\n+   |            ^^^^^ type argument not allowed\n \n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/prim-with-args.rs:8:14\n    |\n-LL | let x: usize<isize>; //~ ERROR type parameters are not allowed on this type\n-   |              ^^^^^ type parameter not allowed\n+LL | let x: usize<isize>; //~ ERROR type arguments are not allowed on this entity\n+   |              ^^^^^ type argument not allowed\n \n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/prim-with-args.rs:9:11\n    |\n-LL | let x: u8<isize>; //~ ERROR type parameters are not allowed on this type\n-   |           ^^^^^ type parameter not allowed\n+LL | let x: u8<isize>; //~ ERROR type arguments are not allowed on this entity\n+   |           ^^^^^ type argument not allowed\n \n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/prim-with-args.rs:10:12\n    |\n-LL | let x: u16<isize>; //~ ERROR type parameters are not allowed on this type\n-   |            ^^^^^ type parameter not allowed\n+LL | let x: u16<isize>; //~ ERROR type arguments are not allowed on this entity\n+   |            ^^^^^ type argument not allowed\n \n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/prim-with-args.rs:11:12\n    |\n-LL | let x: u32<isize>; //~ ERROR type parameters are not allowed on this type\n-   |            ^^^^^ type parameter not allowed\n+LL | let x: u32<isize>; //~ ERROR type arguments are not allowed on this entity\n+   |            ^^^^^ type argument not allowed\n \n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/prim-with-args.rs:12:12\n    |\n-LL | let x: u64<isize>; //~ ERROR type parameters are not allowed on this type\n-   |            ^^^^^ type parameter not allowed\n+LL | let x: u64<isize>; //~ ERROR type arguments are not allowed on this entity\n+   |            ^^^^^ type argument not allowed\n \n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/prim-with-args.rs:13:13\n    |\n-LL | let x: char<isize>; //~ ERROR type parameters are not allowed on this type\n-   |             ^^^^^ type parameter not allowed\n+LL | let x: char<isize>; //~ ERROR type arguments are not allowed on this entity\n+   |             ^^^^^ type argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/prim-with-args.rs:15:14\n    |\n-LL | let x: isize<'static>; //~ ERROR lifetime parameters are not allowed on this type\n-   |              ^^^^^^^ lifetime parameter not allowed\n+LL | let x: isize<'static>; //~ ERROR lifetime arguments are not allowed on this entity\n+   |              ^^^^^^^ lifetime argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/prim-with-args.rs:16:11\n    |\n-LL | let x: i8<'static>; //~ ERROR lifetime parameters are not allowed on this type\n-   |           ^^^^^^^ lifetime parameter not allowed\n+LL | let x: i8<'static>; //~ ERROR lifetime arguments are not allowed on this entity\n+   |           ^^^^^^^ lifetime argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/prim-with-args.rs:17:12\n    |\n-LL | let x: i16<'static>; //~ ERROR lifetime parameters are not allowed on this type\n-   |            ^^^^^^^ lifetime parameter not allowed\n+LL | let x: i16<'static>; //~ ERROR lifetime arguments are not allowed on this entity\n+   |            ^^^^^^^ lifetime argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/prim-with-args.rs:18:12\n    |\n-LL | let x: i32<'static>; //~ ERROR lifetime parameters are not allowed on this type\n-   |            ^^^^^^^ lifetime parameter not allowed\n+LL | let x: i32<'static>; //~ ERROR lifetime arguments are not allowed on this entity\n+   |            ^^^^^^^ lifetime argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/prim-with-args.rs:19:12\n    |\n-LL | let x: i64<'static>; //~ ERROR lifetime parameters are not allowed on this type\n-   |            ^^^^^^^ lifetime parameter not allowed\n+LL | let x: i64<'static>; //~ ERROR lifetime arguments are not allowed on this entity\n+   |            ^^^^^^^ lifetime argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/prim-with-args.rs:20:14\n    |\n-LL | let x: usize<'static>; //~ ERROR lifetime parameters are not allowed on this type\n-   |              ^^^^^^^ lifetime parameter not allowed\n+LL | let x: usize<'static>; //~ ERROR lifetime arguments are not allowed on this entity\n+   |              ^^^^^^^ lifetime argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/prim-with-args.rs:21:11\n    |\n-LL | let x: u8<'static>; //~ ERROR lifetime parameters are not allowed on this type\n-   |           ^^^^^^^ lifetime parameter not allowed\n+LL | let x: u8<'static>; //~ ERROR lifetime arguments are not allowed on this entity\n+   |           ^^^^^^^ lifetime argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/prim-with-args.rs:22:12\n    |\n-LL | let x: u16<'static>; //~ ERROR lifetime parameters are not allowed on this type\n-   |            ^^^^^^^ lifetime parameter not allowed\n+LL | let x: u16<'static>; //~ ERROR lifetime arguments are not allowed on this entity\n+   |            ^^^^^^^ lifetime argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/prim-with-args.rs:23:12\n    |\n-LL | let x: u32<'static>; //~ ERROR lifetime parameters are not allowed on this type\n-   |            ^^^^^^^ lifetime parameter not allowed\n+LL | let x: u32<'static>; //~ ERROR lifetime arguments are not allowed on this entity\n+   |            ^^^^^^^ lifetime argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/prim-with-args.rs:24:12\n    |\n-LL | let x: u64<'static>; //~ ERROR lifetime parameters are not allowed on this type\n-   |            ^^^^^^^ lifetime parameter not allowed\n+LL | let x: u64<'static>; //~ ERROR lifetime arguments are not allowed on this entity\n+   |            ^^^^^^^ lifetime argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/prim-with-args.rs:25:13\n    |\n-LL | let x: char<'static>; //~ ERROR lifetime parameters are not allowed on this type\n-   |             ^^^^^^^ lifetime parameter not allowed\n+LL | let x: char<'static>; //~ ERROR lifetime arguments are not allowed on this entity\n+   |             ^^^^^^^ lifetime argument not allowed\n \n error: aborting due to 22 previous errors\n "}, {"sha": "8412983fda54901b3b429fd440634d464f12c9c9", "filename": "src/test/ui/qualified/qualified-path-params-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fqualified%2Fqualified-path-params-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fqualified%2Fqualified-path-params-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fqualified%2Fqualified-path-params-2.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -16,7 +16,7 @@ impl S {\n }\n \n type A = <S as Tr>::A::f<u8>;\n-//~^ ERROR type parameters are not allowed on this type\n+//~^ ERROR type arguments are not allowed on this entity\n //~| ERROR ambiguous associated type\n \n fn main() {}"}, {"sha": "4e073841b9740cf32cc5962ed0bfe248b92f1451", "filename": "src/test/ui/qualified/qualified-path-params-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fqualified%2Fqualified-path-params-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fqualified%2Fqualified-path-params-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fqualified%2Fqualified-path-params-2.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,8 +1,8 @@\n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/qualified-path-params-2.rs:18:26\n    |\n LL | type A = <S as Tr>::A::f<u8>;\n-   |                          ^^ type parameter not allowed\n+   |                          ^^ type argument not allowed\n \n error[E0223]: ambiguous associated type\n   --> $DIR/qualified-path-params-2.rs:18:10"}, {"sha": "9d35e167075ae854f346e02c2e6dae300dc8bfb1", "filename": "src/test/ui/rfc-2005-default-binding-mode/no-double-error.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fno-double-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fno-double-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fno-double-error.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,8 +1,10 @@\n error[E0599]: no associated item named `XXX` found for type `u32` in the current scope\n-  --> $DIR/no-double-error.rs:8:9\n+  --> $DIR/no-double-error.rs:8:14\n    |\n LL |         u32::XXX => { } //~ ERROR no associated item named\n-   |         ^^^^^^^^ associated item not found in `u32`\n+   |         -----^^^\n+   |         |\n+   |         associated item not found in `u32`\n \n error: aborting due to previous error\n "}, {"sha": "5414bb4a6d20efc91092a132076649d05d8839b6", "filename": "src/test/ui/rfc1598-generic-associated-types/collections.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fcollections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fcollections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fcollections.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -2,7 +2,7 @@\n //~^ WARNING the feature `generic_associated_types` is incomplete\n #![feature(associated_type_defaults)]\n \n-// FIXME(#44265): \"lifetime parameters are not allowed on this type\" errors will be addressed in a\n+// FIXME(#44265): \"lifetime arguments are not allowed on this entity\" errors will be addressed in a\n // follow-up PR.\n \n // A Collection trait and collection families. Based on\n@@ -15,14 +15,14 @@ trait Collection<T> {\n     // Test associated type defaults with parameters\n     type Sibling<U>: Collection<U> =\n         <<Self as Collection<T>>::Family as CollectionFamily>::Member<U>;\n-    //~^ ERROR type parameters are not allowed on this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this entity [E0109]\n \n     fn empty() -> Self;\n \n     fn add(&mut self, value: T);\n \n     fn iterate<'iter>(&'iter self) -> Self::Iter<'iter>;\n-    //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+    //~^ ERROR lifetime arguments are not allowed on this entity [E0110]\n }\n \n trait CollectionFamily {\n@@ -48,13 +48,13 @@ impl<T> Collection<T> for Vec<T> {\n     }\n \n     fn iterate<'iter>(&'iter self) -> Self::Iter<'iter> {\n-    //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+    //~^ ERROR lifetime arguments are not allowed on this entity [E0110]\n         self.iter()\n     }\n }\n \n fn floatify<C>(ints: &C) -> <<C as Collection<i32>>::Family as CollectionFamily>::Member<f32>\n-//~^ ERROR type parameters are not allowed on this type [E0109]\n+//~^ ERROR type arguments are not allowed on this entity [E0109]\n where\n     C: Collection<i32>,\n {\n@@ -66,7 +66,7 @@ where\n }\n \n fn floatify_sibling<C>(ints: &C) -> <C as Collection<i32>>::Sibling<f32>\n-//~^ ERROR type parameters are not allowed on this type [E0109]\n+//~^ ERROR type arguments are not allowed on this entity [E0109]\n where\n     C: Collection<i32>,\n {"}, {"sha": "eeed04bd89213b96bd2f0a3d8935bf59c689cdc5", "filename": "src/test/ui/rfc1598-generic-associated-types/collections.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fcollections.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fcollections.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fcollections.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -4,35 +4,35 @@ warning: the feature `generic_associated_types` is incomplete and may cause the\n LL | #![feature(generic_associated_types)]\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/collections.rs:56:90\n    |\n LL | fn floatify<C>(ints: &C) -> <<C as Collection<i32>>::Family as CollectionFamily>::Member<f32>\n-   |                                                                                          ^^^ type parameter not allowed\n+   |                                                                                          ^^^ type argument not allowed\n \n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/collections.rs:68:69\n    |\n LL | fn floatify_sibling<C>(ints: &C) -> <C as Collection<i32>>::Sibling<f32>\n-   |                                                                     ^^^ type parameter not allowed\n+   |                                                                     ^^^ type argument not allowed\n \n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/collections.rs:17:71\n    |\n LL |         <<Self as Collection<T>>::Family as CollectionFamily>::Member<U>;\n-   |                                                                       ^ type parameter not allowed\n+   |                                                                       ^ type argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/collections.rs:24:50\n    |\n LL |     fn iterate<'iter>(&'iter self) -> Self::Iter<'iter>;\n-   |                                                  ^^^^^ lifetime parameter not allowed\n+   |                                                  ^^^^^ lifetime argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/collections.rs:50:50\n    |\n LL |     fn iterate<'iter>(&'iter self) -> Self::Iter<'iter> {\n-   |                                                  ^^^^^ lifetime parameter not allowed\n+   |                                                  ^^^^^ lifetime argument not allowed\n \n error: aborting due to 5 previous errors\n "}, {"sha": "d9c482e23e47c24d16d07c1c801c79eed61ffafd", "filename": "src/test/ui/rfc1598-generic-associated-types/construct_with_other_type.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -3,7 +3,7 @@\n \n use std::ops::Deref;\n \n-// FIXME(#44265): \"lifetime parameters are not allowed on this type\" errors will be addressed in a\n+// FIXME(#44265): \"lifetime arguments are not allowed on this entity\" errors will be addressed in a\n // follow-up PR.\n \n trait Foo {\n@@ -15,15 +15,15 @@ trait Baz {\n \n     // This weird type tests that we can use universal function call syntax to access the Item on\n     type Baa<'a>: Deref<Target = <Self::Quux<'a> as Foo>::Bar<'a, 'static>>;\n-    //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n-    //~| ERROR lifetime parameters are not allowed on this type [E0110]\n+    //~^ ERROR lifetime arguments are not allowed on this entity [E0110]\n+    //~| ERROR lifetime arguments are not allowed on this entity [E0110]\n }\n \n impl<T> Baz for T where T: Foo {\n     type Quux<'a> = T;\n \n     type Baa<'a> = &'a <T as Foo>::Bar<'a, 'static>;\n-    //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+    //~^ ERROR lifetime arguments are not allowed on this entity [E0110]\n }\n \n fn main() {}"}, {"sha": "fd6116d2da23a249cefe7079afc69af3569b181b", "filename": "src/test/ui/rfc1598-generic-associated-types/construct_with_other_type.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -4,23 +4,23 @@ warning: the feature `generic_associated_types` is incomplete and may cause the\n LL | #![feature(generic_associated_types)]\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/construct_with_other_type.rs:17:46\n    |\n LL |     type Baa<'a>: Deref<Target = <Self::Quux<'a> as Foo>::Bar<'a, 'static>>;\n-   |                                              ^^ lifetime parameter not allowed\n+   |                                              ^^ lifetime argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/construct_with_other_type.rs:17:63\n    |\n LL |     type Baa<'a>: Deref<Target = <Self::Quux<'a> as Foo>::Bar<'a, 'static>>;\n-   |                                                               ^^ lifetime parameter not allowed\n+   |                                                               ^^ lifetime argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/construct_with_other_type.rs:25:40\n    |\n LL |     type Baa<'a> = &'a <T as Foo>::Bar<'a, 'static>;\n-   |                                        ^^ lifetime parameter not allowed\n+   |                                        ^^ lifetime argument not allowed\n \n error: aborting due to 3 previous errors\n "}, {"sha": "2e6d7470b49a2be64907b75a69a43718835b273f", "filename": "src/test/ui/rfc1598-generic-associated-types/generic_associated_type_undeclared_lifetimes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fgeneric_associated_type_undeclared_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fgeneric_associated_type_undeclared_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fgeneric_associated_type_undeclared_lifetimes.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -3,20 +3,20 @@\n \n use std::ops::Deref;\n \n-// FIXME(#44265): \"lifetime parameters are not allowed on this type\" errors will be addressed in a\n+// FIXME(#44265): \"lifetime arguments are not allowed on this entity\" errors will be addressed in a\n // follow-up PR.\n \n trait Iterable {\n     type Item<'a>;\n     type Iter<'a>: Iterator<Item = Self::Item<'a>>\n-    //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+    //~^ ERROR lifetime arguments are not allowed on this entity [E0110]\n         + Deref<Target = Self::Item<'b>>;\n     //~^ ERROR undeclared lifetime\n-    //~| ERROR lifetime parameters are not allowed on this type [E0110]\n+    //~| ERROR lifetime arguments are not allowed on this entity [E0110]\n \n     fn iter<'a>(&'a self) -> Self::Iter<'undeclared>;\n     //~^ ERROR undeclared lifetime\n-    //~| ERROR lifetime parameters are not allowed on this type [E0110]\n+    //~| ERROR lifetime arguments are not allowed on this entity [E0110]\n }\n \n fn main() {}"}, {"sha": "3cebab6389557db0e6828df279995fd2a89485e3", "filename": "src/test/ui/rfc1598-generic-associated-types/generic_associated_type_undeclared_lifetimes.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fgeneric_associated_type_undeclared_lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fgeneric_associated_type_undeclared_lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fgeneric_associated_type_undeclared_lifetimes.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -16,23 +16,23 @@ error[E0261]: use of undeclared lifetime name `'undeclared`\n LL |     fn iter<'a>(&'a self) -> Self::Iter<'undeclared>;\n    |                                         ^^^^^^^^^^^ undeclared lifetime\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/generic_associated_type_undeclared_lifetimes.rs:11:47\n    |\n LL |     type Iter<'a>: Iterator<Item = Self::Item<'a>>\n-   |                                               ^^ lifetime parameter not allowed\n+   |                                               ^^ lifetime argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/generic_associated_type_undeclared_lifetimes.rs:13:37\n    |\n LL |         + Deref<Target = Self::Item<'b>>;\n-   |                                     ^^ lifetime parameter not allowed\n+   |                                     ^^ lifetime argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/generic_associated_type_undeclared_lifetimes.rs:17:41\n    |\n LL |     fn iter<'a>(&'a self) -> Self::Iter<'undeclared>;\n-   |                                         ^^^^^^^^^^^ lifetime parameter not allowed\n+   |                                         ^^^^^^^^^^^ lifetime argument not allowed\n \n error: aborting due to 5 previous errors\n "}, {"sha": "69258506651c4fb29d3354e82153cfe1e62419dc", "filename": "src/test/ui/rfc1598-generic-associated-types/iterable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -3,16 +3,16 @@\n \n use std::ops::Deref;\n \n-// FIXME(#44265): \"lifetime parameters are not allowed on this type\" errors will be addressed in a\n+// FIXME(#44265): \"lifetime arguments are not allowed on this entity\" errors will be addressed in a\n // follow-up PR.\n \n trait Iterable {\n     type Item<'a>;\n     type Iter<'a>: Iterator<Item = Self::Item<'a>>;\n-    //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+    //~^ ERROR lifetime arguments are not allowed on this entity [E0110]\n \n     fn iter<'a>(&'a self) -> Self::Iter<'a>;\n-    //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+    //~^ ERROR lifetime arguments are not allowed on this entity [E0110]\n }\n \n // Impl for struct type\n@@ -21,7 +21,7 @@ impl<T> Iterable for Vec<T> {\n     type Iter<'a> = std::slice::Iter<'a, T>;\n \n     fn iter<'a>(&'a self) -> Self::Iter<'a> {\n-    //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+    //~^ ERROR lifetime arguments are not allowed on this entity [E0110]\n         self.iter()\n     }\n }\n@@ -32,18 +32,18 @@ impl<T> Iterable for [T] {\n     type Iter<'a> = std::slice::Iter<'a, T>;\n \n     fn iter<'a>(&'a self) -> Self::Iter<'a> {\n-    //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+    //~^ ERROR lifetime arguments are not allowed on this entity [E0110]\n         self.iter()\n     }\n }\n \n fn make_iter<'a, I: Iterable>(it: &'a I) -> I::Iter<'a> {\n-    //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+    //~^ ERROR lifetime arguments are not allowed on this entity [E0110]\n     it.iter()\n }\n \n fn get_first<'a, I: Iterable>(it: &'a I) -> Option<I::Item<'a>> {\n-    //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+    //~^ ERROR lifetime arguments are not allowed on this entity [E0110]\n     it.iter().next()\n }\n "}, {"sha": "cc3ade6f39d906f1713925427fd77baf4ea590fe", "filename": "src/test/ui/rfc1598-generic-associated-types/iterable.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -4,41 +4,41 @@ warning: the feature `generic_associated_types` is incomplete and may cause the\n LL | #![feature(generic_associated_types)]\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/iterable.rs:11:47\n    |\n LL |     type Iter<'a>: Iterator<Item = Self::Item<'a>>;\n-   |                                               ^^ lifetime parameter not allowed\n+   |                                               ^^ lifetime argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/iterable.rs:40:53\n    |\n LL | fn make_iter<'a, I: Iterable>(it: &'a I) -> I::Iter<'a> {\n-   |                                                     ^^ lifetime parameter not allowed\n+   |                                                     ^^ lifetime argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/iterable.rs:45:60\n    |\n LL | fn get_first<'a, I: Iterable>(it: &'a I) -> Option<I::Item<'a>> {\n-   |                                                            ^^ lifetime parameter not allowed\n+   |                                                            ^^ lifetime argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/iterable.rs:14:41\n    |\n LL |     fn iter<'a>(&'a self) -> Self::Iter<'a>;\n-   |                                         ^^ lifetime parameter not allowed\n+   |                                         ^^ lifetime argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/iterable.rs:23:41\n    |\n LL |     fn iter<'a>(&'a self) -> Self::Iter<'a> {\n-   |                                         ^^ lifetime parameter not allowed\n+   |                                         ^^ lifetime argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/iterable.rs:34:41\n    |\n LL |     fn iter<'a>(&'a self) -> Self::Iter<'a> {\n-   |                                         ^^ lifetime parameter not allowed\n+   |                                         ^^ lifetime argument not allowed\n \n error: aborting due to 6 previous errors\n "}, {"sha": "851e331a0e965a953f8680dbe479c7307d07d3a9", "filename": "src/test/ui/rfc1598-generic-associated-types/parameter_number_and_kind.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fparameter_number_and_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fparameter_number_and_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fparameter_number_and_kind.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -2,7 +2,7 @@\n //~^ WARNING the feature `generic_associated_types` is incomplete\n #![feature(associated_type_defaults)]\n \n-// FIXME(#44265): \"lifetime parameters are not allowed on this type\" errors will be addressed in a\n+// FIXME(#44265): \"lifetime arguments are not allowed on this entity\" errors will be addressed in a\n // follow-up PR.\n \n // FIXME(#44265): Update expected errors once E110 is resolved, now does not get past `trait Foo`.\n@@ -15,13 +15,13 @@ trait Foo {\n     type E<'a, T>;\n     // Test parameters in default values\n     type FOk<T> = Self::E<'static, T>;\n-    //~^ ERROR type parameters are not allowed on this type [E0109]\n-    //~| ERROR lifetime parameters are not allowed on this type [E0110]\n+    //~^ ERROR type arguments are not allowed on this entity [E0109]\n+    //~| ERROR lifetime arguments are not allowed on this entity [E0110]\n     type FErr1 = Self::E<'static, 'static>; // Error\n-    //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+    //~^ ERROR lifetime arguments are not allowed on this entity [E0110]\n     type FErr2<T> = Self::E<'static, T, u32>; // Error\n-    //~^ ERROR type parameters are not allowed on this type [E0109]\n-    //~| ERROR lifetime parameters are not allowed on this type [E0110]\n+    //~^ ERROR type arguments are not allowed on this entity [E0109]\n+    //~| ERROR lifetime arguments are not allowed on this entity [E0110]\n }\n \n struct Fooy;"}, {"sha": "265b0fab77061f3cf6d28635cc79e5befc1083b9", "filename": "src/test/ui/rfc1598-generic-associated-types/parameter_number_and_kind.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fparameter_number_and_kind.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fparameter_number_and_kind.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fparameter_number_and_kind.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -4,35 +4,35 @@ warning: the feature `generic_associated_types` is incomplete and may cause the\n LL | #![feature(generic_associated_types)]\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/parameter_number_and_kind.rs:17:27\n    |\n LL |     type FOk<T> = Self::E<'static, T>;\n-   |                           ^^^^^^^ lifetime parameter not allowed\n+   |                           ^^^^^^^ lifetime argument not allowed\n \n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/parameter_number_and_kind.rs:17:36\n    |\n LL |     type FOk<T> = Self::E<'static, T>;\n-   |                                    ^ type parameter not allowed\n+   |                                    ^ type argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/parameter_number_and_kind.rs:20:26\n    |\n LL |     type FErr1 = Self::E<'static, 'static>; // Error\n-   |                          ^^^^^^^ lifetime parameter not allowed\n+   |                          ^^^^^^^ lifetime argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/parameter_number_and_kind.rs:22:29\n    |\n LL |     type FErr2<T> = Self::E<'static, T, u32>; // Error\n-   |                             ^^^^^^^ lifetime parameter not allowed\n+   |                             ^^^^^^^ lifetime argument not allowed\n \n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/parameter_number_and_kind.rs:22:38\n    |\n LL |     type FErr2<T> = Self::E<'static, T, u32>; // Error\n-   |                                      ^ type parameter not allowed\n+   |                                      ^ type argument not allowed\n \n error: aborting due to 5 previous errors\n "}, {"sha": "2d188aed427788dc0810f32b4bf217bc4e98abdc", "filename": "src/test/ui/rfc1598-generic-associated-types/pointer_family.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fpointer_family.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fpointer_family.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fpointer_family.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,7 +1,7 @@\n #![feature(generic_associated_types)]\n //~^ WARNING the feature `generic_associated_types` is incomplete\n \n-// FIXME(#44265): \"type parameter not allowed\" errors will be addressed in a follow-up PR.\n+// FIXME(#44265): \"type argument not allowed\" errors will be addressed in a follow-up PR.\n \n use std::rc::Rc;\n use std::sync::Arc;\n@@ -10,15 +10,15 @@ use std::ops::Deref;\n trait PointerFamily {\n     type Pointer<T>: Deref<Target = T>;\n     fn new<T>(value: T) -> Self::Pointer<T>;\n-    //~^ ERROR type parameters are not allowed on this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this entity [E0109]\n }\n \n struct ArcFamily;\n \n impl PointerFamily for ArcFamily {\n     type Pointer<T> = Arc<T>;\n     fn new<T>(value: T) -> Self::Pointer<T> {\n-    //~^ ERROR type parameters are not allowed on this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this entity [E0109]\n         Arc::new(value)\n     }\n }\n@@ -28,14 +28,14 @@ struct RcFamily;\n impl PointerFamily for RcFamily {\n     type Pointer<T> = Rc<T>;\n     fn new<T>(value: T) -> Self::Pointer<T> {\n-    //~^ ERROR type parameters are not allowed on this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this entity [E0109]\n         Rc::new(value)\n     }\n }\n \n struct Foo<P: PointerFamily> {\n     bar: P::Pointer<String>,\n-    //~^ ERROR type parameters are not allowed on this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this entity [E0109]\n }\n \n fn main() {}"}, {"sha": "2b9eed2a688a2b1ecfecaa3f2bedf9cadf11be0e", "filename": "src/test/ui/rfc1598-generic-associated-types/pointer_family.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fpointer_family.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fpointer_family.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fpointer_family.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -4,29 +4,29 @@ warning: the feature `generic_associated_types` is incomplete and may cause the\n LL | #![feature(generic_associated_types)]\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/pointer_family.rs:37:21\n    |\n LL |     bar: P::Pointer<String>,\n-   |                     ^^^^^^ type parameter not allowed\n+   |                     ^^^^^^ type argument not allowed\n \n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/pointer_family.rs:12:42\n    |\n LL |     fn new<T>(value: T) -> Self::Pointer<T>;\n-   |                                          ^ type parameter not allowed\n+   |                                          ^ type argument not allowed\n \n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/pointer_family.rs:20:42\n    |\n LL |     fn new<T>(value: T) -> Self::Pointer<T> {\n-   |                                          ^ type parameter not allowed\n+   |                                          ^ type argument not allowed\n \n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/pointer_family.rs:30:42\n    |\n LL |     fn new<T>(value: T) -> Self::Pointer<T> {\n-   |                                          ^ type parameter not allowed\n+   |                                          ^ type argument not allowed\n \n error: aborting due to 4 previous errors\n "}, {"sha": "1ef154447903b2472d37e4f8fca335ed3c2e2ab3", "filename": "src/test/ui/rfc1598-generic-associated-types/streaming_iterator.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fstreaming_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fstreaming_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fstreaming_iterator.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,7 +1,7 @@\n #![feature(generic_associated_types)]\n //~^ WARNING the feature `generic_associated_types` is incomplete\n \n-// FIXME(#44265): \"lifetime parameter not allowed on this type\" errors will be addressed in a\n+// FIXME(#44265): \"lifetime argument not allowed on this type\" errors will be addressed in a\n // follow-up PR\n \n use std::fmt::Display;\n@@ -10,21 +10,21 @@ trait StreamingIterator {\n     type Item<'a>;\n     // Applying the lifetime parameter `'a` to `Self::Item` inside the trait.\n     fn next<'a>(&'a self) -> Option<Self::Item<'a>>;\n-    //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+    //~^ ERROR lifetime arguments are not allowed on this entity [E0110]\n }\n \n struct Foo<T: StreamingIterator> {\n     // Applying a concrete lifetime to the constructor outside the trait.\n     bar: <T as StreamingIterator>::Item<'static>,\n-    //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+    //~^ ERROR lifetime arguments are not allowed on this entity [E0110]\n }\n \n // Users can bound parameters by the type constructed by that trait's associated type constructor\n // of a trait using HRTB. Both type equality bounds and trait bounds of this kind are valid:\n //FIXME(sunjay): This next line should parse and be valid\n //fn foo<T: for<'a> StreamingIterator<Item<'a>=&'a [i32]>>(iter: T) { /* ... */ }\n fn foo<T>(iter: T) where T: StreamingIterator, for<'a> T::Item<'a>: Display { /* ... */ }\n-//~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+//~^ ERROR lifetime arguments are not allowed on this entity [E0110]\n \n // Full example of enumerate iterator\n \n@@ -36,9 +36,9 @@ struct StreamEnumerate<I> {\n \n impl<I: StreamingIterator> StreamingIterator for StreamEnumerate<I> {\n     type Item<'a> = (usize, I::Item<'a>);\n-    //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+    //~^ ERROR lifetime arguments are not allowed on this entity [E0110]\n     fn next<'a>(&'a self) -> Option<Self::Item<'a>> {\n-        //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n+        //~^ ERROR lifetime arguments are not allowed on this entity [E0110]\n         match self.iter.next() {\n             None => None,\n             Some(val) => {"}, {"sha": "5afbba5d2d7446d663824ce2f076fc5d2a726068", "filename": "src/test/ui/rfc1598-generic-associated-types/streaming_iterator.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fstreaming_iterator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fstreaming_iterator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fstreaming_iterator.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -4,35 +4,35 @@ warning: the feature `generic_associated_types` is incomplete and may cause the\n LL | #![feature(generic_associated_types)]\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/streaming_iterator.rs:18:41\n    |\n LL |     bar: <T as StreamingIterator>::Item<'static>,\n-   |                                         ^^^^^^^ lifetime parameter not allowed\n+   |                                         ^^^^^^^ lifetime argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/streaming_iterator.rs:26:64\n    |\n LL | fn foo<T>(iter: T) where T: StreamingIterator, for<'a> T::Item<'a>: Display { /* ... */ }\n-   |                                                                ^^ lifetime parameter not allowed\n+   |                                                                ^^ lifetime argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/streaming_iterator.rs:12:48\n    |\n LL |     fn next<'a>(&'a self) -> Option<Self::Item<'a>>;\n-   |                                                ^^ lifetime parameter not allowed\n+   |                                                ^^ lifetime argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/streaming_iterator.rs:38:37\n    |\n LL |     type Item<'a> = (usize, I::Item<'a>);\n-   |                                     ^^ lifetime parameter not allowed\n+   |                                     ^^ lifetime argument not allowed\n \n-error[E0110]: lifetime parameters are not allowed on this type\n+error[E0110]: lifetime arguments are not allowed on this entity\n   --> $DIR/streaming_iterator.rs:40:48\n    |\n LL |     fn next<'a>(&'a self) -> Option<Self::Item<'a>> {\n-   |                                                ^^ lifetime parameter not allowed\n+   |                                                ^^ lifetime argument not allowed\n \n error: aborting due to 5 previous errors\n "}, {"sha": "e4c17680c90a528228d1b4733cfcb662e0a63b7b", "filename": "src/test/ui/rust-2018/trait-import-suggestions.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frust-2018%2Ftrait-import-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Frust-2018%2Ftrait-import-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Ftrait-import-suggestions.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -27,10 +27,12 @@ LL |     x.baz(); //~ ERROR no method named `baz`\n    |       ^^^\n \n error[E0599]: no function or associated item named `from_str` found for type `u32` in the current scope\n-  --> $DIR/trait-import-suggestions.rs:30:13\n+  --> $DIR/trait-import-suggestions.rs:30:18\n    |\n LL |     let y = u32::from_str(\"33\"); //~ ERROR no function or associated item named `from_str`\n-   |             ^^^^^^^^^^^^^ function or associated item not found in `u32`\n+   |             -----^^^^^^^^\n+   |             |\n+   |             function or associated item not found in `u32`\n    |\n    = help: items from traits can only be used if the trait is in scope\n help: the following trait is implemented but not in scope, perhaps add a `use` for it:"}, {"sha": "7c770852d22d25fcc472fa3ff22b4e475997599e", "filename": "src/test/ui/structs/struct-path-associated-type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-associated-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-associated-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-associated-type.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -13,7 +13,7 @@ fn f<T: Tr>() {\n     //~^ ERROR expected struct, variant or union type, found associated type\n     let z = T::A::<u8> {};\n     //~^ ERROR expected struct, variant or union type, found associated type\n-    //~| ERROR type parameters are not allowed on this type\n+    //~| ERROR type arguments are not allowed on this entity\n     match S {\n         T::A {} => {}\n         //~^ ERROR expected struct, variant or union type, found associated type\n@@ -22,7 +22,7 @@ fn f<T: Tr>() {\n \n fn g<T: Tr<A = S>>() {\n     let s = T::A {}; // OK\n-    let z = T::A::<u8> {}; //~ ERROR type parameters are not allowed on this type\n+    let z = T::A::<u8> {}; //~ ERROR type arguments are not allowed on this entity\n     match S {\n         T::A {} => {} // OK\n     }\n@@ -31,7 +31,7 @@ fn g<T: Tr<A = S>>() {\n fn main() {\n     let s = S::A {}; //~ ERROR ambiguous associated type\n     let z = S::A::<u8> {}; //~ ERROR ambiguous associated type\n-    //~^ ERROR type parameters are not allowed on this type\n+    //~^ ERROR type arguments are not allowed on this entity\n     match S {\n         S::A {} => {} //~ ERROR ambiguous associated type\n     }"}, {"sha": "80824d98478386b333c39ce1c6c29b41d1e0faa6", "filename": "src/test/ui/structs/struct-path-associated-type.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-associated-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-associated-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-associated-type.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -4,11 +4,11 @@ error[E0071]: expected struct, variant or union type, found associated type\n LL |     let s = T::A {};\n    |             ^^^^ not a struct\n \n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/struct-path-associated-type.rs:14:20\n    |\n LL |     let z = T::A::<u8> {};\n-   |                    ^^ type parameter not allowed\n+   |                    ^^ type argument not allowed\n \n error[E0071]: expected struct, variant or union type, found associated type\n   --> $DIR/struct-path-associated-type.rs:14:13\n@@ -22,23 +22,23 @@ error[E0071]: expected struct, variant or union type, found associated type\n LL |         T::A {} => {}\n    |         ^^^^ not a struct\n \n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/struct-path-associated-type.rs:25:20\n    |\n-LL |     let z = T::A::<u8> {}; //~ ERROR type parameters are not allowed on this type\n-   |                    ^^ type parameter not allowed\n+LL |     let z = T::A::<u8> {}; //~ ERROR type arguments are not allowed on this entity\n+   |                    ^^ type argument not allowed\n \n error[E0223]: ambiguous associated type\n   --> $DIR/struct-path-associated-type.rs:32:13\n    |\n LL |     let s = S::A {}; //~ ERROR ambiguous associated type\n    |             ^^^^ help: use fully-qualified syntax: `<S as Trait>::A`\n \n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/struct-path-associated-type.rs:33:20\n    |\n LL |     let z = S::A::<u8> {}; //~ ERROR ambiguous associated type\n-   |                    ^^ type parameter not allowed\n+   |                    ^^ type argument not allowed\n \n error[E0223]: ambiguous associated type\n   --> $DIR/struct-path-associated-type.rs:33:13"}, {"sha": "51ed9e5457eb763cd3e4e22ddd62eba3408cfaa7", "filename": "src/test/ui/structs/struct-path-self.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -6,7 +6,7 @@ trait Tr {\n         //~^ ERROR expected struct, variant or union type, found Self\n         let z = Self::<u8> {};\n         //~^ ERROR expected struct, variant or union type, found Self\n-        //~| ERROR type parameters are not allowed on this type\n+        //~| ERROR type arguments are not allowed on this entity\n         match s {\n             Self { .. } => {}\n             //~^ ERROR expected struct, variant or union type, found Self\n@@ -17,7 +17,7 @@ trait Tr {\n impl Tr for S {\n     fn f() {\n         let s = Self {}; // OK\n-        let z = Self::<u8> {}; //~ ERROR type parameters are not allowed on this type\n+        let z = Self::<u8> {}; //~ ERROR type arguments are not allowed on this entity\n         match s {\n             Self { .. } => {} // OK\n         }\n@@ -27,7 +27,7 @@ impl Tr for S {\n impl S {\n     fn g() {\n         let s = Self {}; // OK\n-        let z = Self::<u8> {}; //~ ERROR type parameters are not allowed on this type\n+        let z = Self::<u8> {}; //~ ERROR type arguments are not allowed on this entity\n         match s {\n             Self { .. } => {} // OK\n         }"}, {"sha": "cda6b7a533f65e2ad204cb81587f48c9107b6bbd", "filename": "src/test/ui/structs/struct-path-self.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -4,11 +4,11 @@ error[E0071]: expected struct, variant or union type, found Self\n LL |         let s = Self {};\n    |                 ^^^^ not a struct\n \n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/struct-path-self.rs:7:24\n    |\n LL |         let z = Self::<u8> {};\n-   |                        ^^ type parameter not allowed\n+   |                        ^^ type argument not allowed\n \n error[E0071]: expected struct, variant or union type, found Self\n   --> $DIR/struct-path-self.rs:7:17\n@@ -22,17 +22,17 @@ error[E0071]: expected struct, variant or union type, found Self\n LL |             Self { .. } => {}\n    |             ^^^^ not a struct\n \n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/struct-path-self.rs:20:24\n    |\n-LL |         let z = Self::<u8> {}; //~ ERROR type parameters are not allowed on this type\n-   |                        ^^ type parameter not allowed\n+LL |         let z = Self::<u8> {}; //~ ERROR type arguments are not allowed on this entity\n+   |                        ^^ type argument not allowed\n \n-error[E0109]: type parameters are not allowed on this type\n+error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/struct-path-self.rs:30:24\n    |\n-LL |         let z = Self::<u8> {}; //~ ERROR type parameters are not allowed on this type\n-   |                        ^^ type parameter not allowed\n+LL |         let z = Self::<u8> {}; //~ ERROR type arguments are not allowed on this entity\n+   |                        ^^ type argument not allowed\n \n error: aborting due to 6 previous errors\n "}, {"sha": "c65a9a3ed945ca3da0f37dba4bf65c4bf8266c4b", "filename": "src/test/ui/traits/trait-item-privacy.stderr", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Ftraits%2Ftrait-item-privacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Ftraits%2Ftrait-item-privacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-item-privacy.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -33,26 +33,30 @@ LL |     c.a(); //~ ERROR method `a` is private\n    |       ^\n \n error[E0599]: no function or associated item named `a` found for type `S` in the current scope\n-  --> $DIR/trait-item-privacy.rs:78:5\n+  --> $DIR/trait-item-privacy.rs:78:8\n    |\n LL | struct S;\n    | --------- function or associated item `a` not found for this\n ...\n LL |     S::a(&S);\n-   |     ^^^^ function or associated item not found in `S`\n+   |     ---^\n+   |     |\n+   |     function or associated item not found in `S`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `a`, perhaps you need to implement it:\n            candidate #1: `method::A`\n \n error[E0599]: no function or associated item named `b` found for type `S` in the current scope\n-  --> $DIR/trait-item-privacy.rs:80:5\n+  --> $DIR/trait-item-privacy.rs:80:8\n    |\n LL | struct S;\n    | --------- function or associated item `b` not found for this\n ...\n LL |     S::b(&S);\n-   |     ^^^^ function or associated item not found in `S`\n+   |     ---^\n+   |     |\n+   |     function or associated item not found in `S`\n    |\n    = help: items from traits can only be used if the trait is in scope\n help: the following trait is implemented but not in scope, perhaps add a `use` for it:\n@@ -67,26 +71,30 @@ LL |     C::a(&S); //~ ERROR method `a` is private\n    |     ^^^^\n \n error[E0599]: no associated item named `A` found for type `S` in the current scope\n-  --> $DIR/trait-item-privacy.rs:97:5\n+  --> $DIR/trait-item-privacy.rs:97:8\n    |\n LL | struct S;\n    | --------- associated item `A` not found for this\n ...\n LL |     S::A; //~ ERROR no associated item named `A` found for type `S` in the current scope\n-   |     ^^^^ associated item not found in `S`\n+   |     ---^\n+   |     |\n+   |     associated item not found in `S`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `A`, perhaps you need to implement it:\n            candidate #1: `assoc_const::A`\n \n error[E0599]: no associated item named `B` found for type `S` in the current scope\n-  --> $DIR/trait-item-privacy.rs:98:5\n+  --> $DIR/trait-item-privacy.rs:98:8\n    |\n LL | struct S;\n    | --------- associated item `B` not found for this\n ...\n LL |     S::B; //~ ERROR no associated item named `B` found for type `S` in the current scope\n-   |     ^^^^ associated item not found in `S`\n+   |     ---^\n+   |     |\n+   |     associated item not found in `S`\n    |\n    = help: items from traits can only be used if the trait is in scope\n help: the following trait is implemented but not in scope, perhaps add a `use` for it:"}, {"sha": "f97592f5d3b150ce55182fede7a4b6f648c96cd1", "filename": "src/test/ui/type-alias-enum-variants-panic.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Ftype-alias-enum-variants-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Ftype-alias-enum-variants-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants-panic.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -0,0 +1,17 @@\n+// ignore-tidy-linelength\n+\n+#![feature(type_alias_enum_variants)]\n+\n+#![allow(unreachable_code)]\n+\n+enum Enum { Variant {} }\n+type Alias = Enum;\n+\n+fn main() {\n+    Alias::Variant;\n+    //~^ ERROR expected unit struct/variant or constant, found struct variant `<Alias>::Variant` [E0533]\n+    let Alias::Variant = panic!();\n+    //~^ ERROR expected unit struct/variant or constant, found struct variant `<Alias>::Variant` [E0533]\n+    let Alias::Variant(..) = panic!();\n+    //~^ ERROR expected tuple struct/variant, found struct variant `<Alias>::Variant` [E0164]\n+}"}, {"sha": "3480d116383eea2546361d4e1e429576616a1483", "filename": "src/test/ui/type-alias-enum-variants-panic.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Ftype-alias-enum-variants-panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Ftype-alias-enum-variants-panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants-panic.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -0,0 +1,22 @@\n+error[E0533]: expected unit struct/variant or constant, found struct variant `<Alias>::Variant`\n+  --> $DIR/type-alias-enum-variants-panic.rs:11:5\n+   |\n+LL |     Alias::Variant;\n+   |     ^^^^^^^^^^^^^^\n+\n+error[E0533]: expected unit struct/variant or constant, found struct variant `<Alias>::Variant`\n+  --> $DIR/type-alias-enum-variants-panic.rs:13:9\n+   |\n+LL |     let Alias::Variant = panic!();\n+   |         ^^^^^^^^^^^^^^\n+\n+error[E0164]: expected tuple struct/variant, found struct variant `<Alias>::Variant`\n+  --> $DIR/type-alias-enum-variants-panic.rs:15:9\n+   |\n+LL |     let Alias::Variant(..) = panic!();\n+   |         ^^^^^^^^^^^^^^^^^^ not a tuple variant or struct\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors occurred: E0164, E0533.\n+For more information about an error, try `rustc --explain E0164`."}, {"sha": "3ec200d57c55dc4766968af9b75226006736fe9b", "filename": "src/test/ui/type-alias-enum-variants.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Ftype-alias-enum-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Ftype-alias-enum-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants.rs?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -0,0 +1,11 @@\n+#![feature(type_alias_enum_variants)]\n+\n+type Alias<T> = Option<T>;\n+\n+fn main() {\n+    let _ = Option::<u8>::None; // OK\n+    let _ = Option::None::<u8>; // OK (Lint in future!)\n+    let _ = Alias::<u8>::None; // OK\n+    let _ = Alias::None::<u8>; // Error\n+    //~^ type arguments are not allowed on this entity\n+}"}, {"sha": "cf81f5b27ac6b3d89d0eebf075f3533579a3cff7", "filename": "src/test/ui/type-alias-enum-variants.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Ftype-alias-enum-variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Ftype-alias-enum-variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -0,0 +1,9 @@\n+error[E0109]: type arguments are not allowed on this entity\n+  --> $DIR/type-alias-enum-variants.rs:9:27\n+   |\n+LL |     let _ = Alias::None::<u8>; // Error\n+   |                           ^^ type argument not allowed\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0109`."}, {"sha": "a576fdde1173e2f836efe5547a3d77454cbd45db", "filename": "src/test/ui/ufcs/ufcs-partially-resolved.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fufcs%2Fufcs-partially-resolved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Fufcs%2Fufcs-partially-resolved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fufcs%2Fufcs-partially-resolved.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -187,16 +187,20 @@ LL |     let _: <u8 as Tr>::Y::NN; //~ ERROR ambiguous associated type\n    |            ^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<<u8 as Tr>::Y as Trait>::NN`\n \n error[E0599]: no associated item named `NN` found for type `<u8 as Tr>::Y` in the current scope\n-  --> $DIR/ufcs-partially-resolved.rs:38:5\n+  --> $DIR/ufcs-partially-resolved.rs:38:20\n    |\n LL |     <u8 as Tr>::Y::NN; //~ ERROR no associated item named `NN` found for type `<u8 as Tr>::Y`\n-   |     ^^^^^^^^^^^^^^^^^ associated item not found in `<u8 as Tr>::Y`\n+   |     ---------------^^\n+   |     |\n+   |     associated item not found in `<u8 as Tr>::Y`\n \n error[E0599]: no associated item named `N` found for type `<u8 as Dr>::X` in the current scope\n-  --> $DIR/ufcs-partially-resolved.rs:55:5\n+  --> $DIR/ufcs-partially-resolved.rs:55:20\n    |\n LL |     <u8 as Dr>::X::N; //~ ERROR no associated item named `N` found for type `<u8 as Dr>::X`\n-   |     ^^^^^^^^^^^^^^^^ associated item not found in `<u8 as Dr>::X`\n+   |     ---------------^\n+   |     |\n+   |     associated item not found in `<u8 as Dr>::X`\n \n error: aborting due to 32 previous errors\n "}, {"sha": "b295b39d33c1d9445502f5928f88c559a4a9c44d", "filename": "src/test/ui/unspecified-self-in-trait-ref.stderr", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Funspecified-self-in-trait-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59183180f718fc2212828e180f2f856f0db1bb9c/src%2Ftest%2Fui%2Funspecified-self-in-trait-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funspecified-self-in-trait-ref.stderr?ref=59183180f718fc2212828e180f2f856f0db1bb9c", "patch": "@@ -1,26 +1,34 @@\n error[E0599]: no function or associated item named `lol` found for type `dyn Foo<_>` in the current scope\n-  --> $DIR/unspecified-self-in-trait-ref.rs:10:13\n+  --> $DIR/unspecified-self-in-trait-ref.rs:10:18\n    |\n LL |     let a = Foo::lol();\n-   |             ^^^^^^^^ function or associated item not found in `dyn Foo<_>`\n+   |             -----^^^\n+   |             |\n+   |             function or associated item not found in `dyn Foo<_>`\n \n error[E0599]: no function or associated item named `lol` found for type `dyn Foo<_>` in the current scope\n-  --> $DIR/unspecified-self-in-trait-ref.rs:12:13\n+  --> $DIR/unspecified-self-in-trait-ref.rs:12:23\n    |\n LL |     let b = Foo::<_>::lol();\n-   |             ^^^^^^^^^^^^^ function or associated item not found in `dyn Foo<_>`\n+   |             ----------^^^\n+   |             |\n+   |             function or associated item not found in `dyn Foo<_>`\n \n error[E0599]: no function or associated item named `lol` found for type `dyn Bar<_, _>` in the current scope\n-  --> $DIR/unspecified-self-in-trait-ref.rs:14:13\n+  --> $DIR/unspecified-self-in-trait-ref.rs:14:18\n    |\n LL |     let c = Bar::lol();\n-   |             ^^^^^^^^ function or associated item not found in `dyn Bar<_, _>`\n+   |             -----^^^\n+   |             |\n+   |             function or associated item not found in `dyn Bar<_, _>`\n \n error[E0599]: no function or associated item named `lol` found for type `dyn Bar<usize, _>` in the current scope\n-  --> $DIR/unspecified-self-in-trait-ref.rs:16:13\n+  --> $DIR/unspecified-self-in-trait-ref.rs:16:30\n    |\n LL |     let d = Bar::<usize, _>::lol();\n-   |             ^^^^^^^^^^^^^^^^^^^^ function or associated item not found in `dyn Bar<usize, _>`\n+   |             -----------------^^^\n+   |             |\n+   |             function or associated item not found in `dyn Bar<usize, _>`\n \n error[E0393]: the type parameter `A` must be explicitly specified\n   --> $DIR/unspecified-self-in-trait-ref.rs:18:13"}]}