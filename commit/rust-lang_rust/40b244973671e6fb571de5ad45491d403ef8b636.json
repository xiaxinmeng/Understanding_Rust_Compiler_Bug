{"sha": "40b244973671e6fb571de5ad45491d403ef8b636", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwYjI0NDk3MzY3MWU2ZmI1NzFkZTVhZDQ1NDkxZDQwM2VmOGI2MzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-14T23:22:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-14T23:22:20Z"}, "message": "auto merge of #18018 : gamazeps/rust/isuue16736, r=cmr\n\nCloses #16736\r\nlinked to #18009", "tree": {"sha": "7f3d76f6617cf94bf1d8d321b040ab584b8436ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f3d76f6617cf94bf1d8d321b040ab584b8436ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40b244973671e6fb571de5ad45491d403ef8b636", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40b244973671e6fb571de5ad45491d403ef8b636", "html_url": "https://github.com/rust-lang/rust/commit/40b244973671e6fb571de5ad45491d403ef8b636", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40b244973671e6fb571de5ad45491d403ef8b636/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "232f4b34041edaf0496d7ac2c3cde28780730b1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/232f4b34041edaf0496d7ac2c3cde28780730b1e", "html_url": "https://github.com/rust-lang/rust/commit/232f4b34041edaf0496d7ac2c3cde28780730b1e"}, {"sha": "1ef5e388b9026841804eaf2bd885b98a7e405e8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ef5e388b9026841804eaf2bd885b98a7e405e8b", "html_url": "https://github.com/rust-lang/rust/commit/1ef5e388b9026841804eaf2bd885b98a7e405e8b"}], "stats": {"total": 209, "additions": 105, "deletions": 104}, "files": [{"sha": "81f30097ea58eb947c53a1b3372afacf36dbb31f", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 105, "deletions": 104, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/40b244973671e6fb571de5ad45491d403ef8b636/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40b244973671e6fb571de5ad45491d403ef8b636/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=40b244973671e6fb571de5ad45491d403ef8b636", "patch": "@@ -69,13 +69,13 @@ use core::fmt;\n use core::iter::{Chain, Enumerate, Repeat, Skip, Take};\n use core::iter;\n use core::slice;\n-use core::uint;\n+use core::u32;\n use std::hash;\n \n use {Mutable, Set, MutableSet, MutableSeq};\n use vec::Vec;\n \n-type MatchWords<'a> = Chain<MaskWords<'a>, Skip<Take<Enumerate<Repeat<uint>>>>>;\n+type MatchWords<'a> = Chain<MaskWords<'a>, Skip<Take<Enumerate<Repeat<u32>>>>>;\n // Take two BitV's, and return iterators of their words, where the shorter one\n // has been padded with 0's\n fn match_words <'a,'b>(a: &'a Bitv, b: &'b Bitv) -> (MatchWords<'a>, MatchWords<'b>) {\n@@ -84,11 +84,11 @@ fn match_words <'a,'b>(a: &'a Bitv, b: &'b Bitv) -> (MatchWords<'a>, MatchWords<\n \n     // have to uselessly pretend to pad the longer one for type matching\n     if a_len < b_len {\n-        (a.mask_words(0).chain(Repeat::new(0u).enumerate().take(b_len).skip(a_len)),\n-         b.mask_words(0).chain(Repeat::new(0u).enumerate().take(0).skip(0)))\n+        (a.mask_words(0).chain(Repeat::new(0u32).enumerate().take(b_len).skip(a_len)),\n+         b.mask_words(0).chain(Repeat::new(0u32).enumerate().take(0).skip(0)))\n     } else {\n-        (a.mask_words(0).chain(Repeat::new(0u).enumerate().take(0).skip(0)),\n-         b.mask_words(0).chain(Repeat::new(0u).enumerate().take(a_len).skip(b_len)))\n+        (a.mask_words(0).chain(Repeat::new(0u32).enumerate().take(0).skip(0)),\n+         b.mask_words(0).chain(Repeat::new(0u32).enumerate().take(a_len).skip(b_len)))\n     }\n }\n \n@@ -124,7 +124,7 @@ static FALSE: bool = false;\n /// ```\n pub struct Bitv {\n     /// Internal representation of the bit vector\n-    storage: Vec<uint>,\n+    storage: Vec<u32>,\n     /// The number of valid bits in the internal representation\n     nbits: uint\n }\n@@ -141,16 +141,16 @@ impl Index<uint,bool> for Bitv {\n }\n \n struct MaskWords<'a> {\n-    iter: slice::Items<'a, uint>,\n-    next_word: Option<&'a uint>,\n-    last_word_mask: uint,\n+    iter: slice::Items<'a, u32>,\n+    next_word: Option<&'a u32>,\n+    last_word_mask: u32,\n     offset: uint\n }\n \n-impl<'a> Iterator<(uint, uint)> for MaskWords<'a> {\n+impl<'a> Iterator<(uint, u32)> for MaskWords<'a> {\n     /// Returns (offset, word)\n     #[inline]\n-    fn next<'a>(&'a mut self) -> Option<(uint, uint)> {\n+    fn next<'a>(&'a mut self) -> Option<(uint, u32)> {\n         let ret = self.next_word;\n         match ret {\n             Some(&w) => {\n@@ -170,7 +170,7 @@ impl<'a> Iterator<(uint, uint)> for MaskWords<'a> {\n \n impl Bitv {\n     #[inline]\n-    fn process(&mut self, other: &Bitv, op: |uint, uint| -> uint) -> bool {\n+    fn process(&mut self, other: &Bitv, op: |u32, u32| -> u32) -> bool {\n         let len = other.storage.len();\n         assert_eq!(self.storage.len(), len);\n         let mut changed = false;\n@@ -199,7 +199,7 @@ impl Bitv {\n           next_word: iter.next(),\n           iter: iter,\n           last_word_mask: {\n-              let rem = self.nbits % uint::BITS;\n+              let rem = self.nbits % u32::BITS;\n               if rem > 0 {\n                   (1 << rem) - 1\n               } else { !0 }\n@@ -236,15 +236,15 @@ impl Bitv {\n     /// ```\n     pub fn with_capacity(nbits: uint, init: bool) -> Bitv {\n         let mut bitv = Bitv {\n-            storage: Vec::from_elem((nbits + uint::BITS - 1) / uint::BITS,\n-                                    if init { !0u } else { 0u }),\n+            storage: Vec::from_elem((nbits + u32::BITS - 1) / u32::BITS,\n+                                    if init { !0u32 } else { 0u32 }),\n             nbits: nbits\n         };\n \n         // Zero out any unused bits in the highest word if necessary\n-        let used_bits = bitv.nbits % uint::BITS;\n+        let used_bits = bitv.nbits % u32::BITS;\n         if init && used_bits != 0 {\n-            let largest_used_word = (bitv.nbits + uint::BITS - 1) / uint::BITS - 1;\n+            let largest_used_word = (bitv.nbits + u32::BITS - 1) / u32::BITS - 1;\n             *bitv.storage.get_mut(largest_used_word) &= (1 << used_bits) - 1;\n         }\n \n@@ -272,8 +272,8 @@ impl Bitv {\n     #[inline]\n     pub fn get(&self, i: uint) -> bool {\n         assert!(i < self.nbits);\n-        let w = i / uint::BITS;\n-        let b = i % uint::BITS;\n+        let w = i / u32::BITS;\n+        let b = i % u32::BITS;\n         let x = self.storage[w] & (1 << b);\n         x != 0\n     }\n@@ -296,8 +296,8 @@ impl Bitv {\n     #[inline]\n     pub fn set(&mut self, i: uint, x: bool) {\n         assert!(i < self.nbits);\n-        let w = i / uint::BITS;\n-        let b = i % uint::BITS;\n+        let w = i / u32::BITS;\n+        let b = i % u32::BITS;\n         let flag = 1 << b;\n         *self.storage.get_mut(w) = if x { self.storage[w] | flag }\n                           else { self.storage[w] & !flag };\n@@ -319,7 +319,7 @@ impl Bitv {\n     /// ```\n     #[inline]\n     pub fn set_all(&mut self) {\n-        for w in self.storage.iter_mut() { *w = !0u; }\n+        for w in self.storage.iter_mut() { *w = !0u32; }\n     }\n \n     /// Flips all bits.\n@@ -453,12 +453,12 @@ impl Bitv {\n     /// ```\n     #[inline]\n     pub fn all(&self) -> bool {\n-        let mut last_word = !0u;\n+        let mut last_word = !0u32;\n         // Check that every word but the last is all-ones...\n         self.mask_words(0).all(|(_, elem)|\n-            { let tmp = last_word; last_word = elem; tmp == !0u }) &&\n+            { let tmp = last_word; last_word = elem; tmp == !0u32 }) &&\n         // ...and that the last word is ones as far as it needs to be\n-        (last_word == ((1 << self.nbits % uint::BITS) - 1) || last_word == !0u)\n+        (last_word == ((1 << self.nbits % u32::BITS) - 1) || last_word == !0u32)\n     }\n \n     /// Returns an iterator over the elements of the vector in order.\n@@ -615,10 +615,10 @@ impl Bitv {\n     pub fn truncate(&mut self, len: uint) {\n         if len < self.len() {\n             self.nbits = len;\n-            let word_len = (len + uint::BITS - 1) / uint::BITS;\n+            let word_len = (len + u32::BITS - 1) / u32::BITS;\n             self.storage.truncate(word_len);\n-            if len % uint::BITS > 0 {\n-                let mask = (1 << len % uint::BITS) - 1;\n+            if len % u32::BITS > 0 {\n+                let mask = (1 << len % u32::BITS) - 1;\n                 *self.storage.get_mut(word_len - 1) &= mask;\n             }\n         }\n@@ -638,7 +638,7 @@ impl Bitv {\n     /// ```\n     pub fn reserve(&mut self, size: uint) {\n         let old_size = self.storage.len();\n-        let new_size = (size + uint::BITS - 1) / uint::BITS;\n+        let new_size = (size + u32::BITS - 1) / u32::BITS;\n         if old_size < new_size {\n             self.storage.grow(new_size - old_size, 0);\n         }\n@@ -658,7 +658,7 @@ impl Bitv {\n     /// ```\n     #[inline]\n     pub fn capacity(&self) -> uint {\n-        self.storage.len() * uint::BITS\n+        self.storage.len() * u32::BITS\n     }\n \n     /// Grows the `Bitv` in-place, adding `n` copies of `value` to the `Bitv`.\n@@ -675,12 +675,12 @@ impl Bitv {\n     /// ```\n     pub fn grow(&mut self, n: uint, value: bool) {\n         let new_nbits = self.nbits + n;\n-        let new_nwords = (new_nbits + uint::BITS - 1) / uint::BITS;\n+        let new_nwords = (new_nbits + u32::BITS - 1) / u32::BITS;\n         let full_value = if value { !0 } else { 0 };\n         // Correct the old tail word\n-        let old_last_word = (self.nbits + uint::BITS - 1) / uint::BITS - 1;\n-        if self.nbits % uint::BITS > 0 {\n-            let overhang = self.nbits % uint::BITS; // # of already-used bits\n+        let old_last_word = (self.nbits + u32::BITS - 1) / u32::BITS - 1;\n+        if self.nbits % u32::BITS > 0 {\n+            let overhang = self.nbits % u32::BITS; // # of already-used bits\n             let mask = !((1 << overhang) - 1);  // e.g. 5 unused bits => 111110....0\n             if value {\n                 *self.storage.get_mut(old_last_word) |= mask;\n@@ -701,7 +701,7 @@ impl Bitv {\n             // Zero out and unused bits in the new tail word\n             if value {\n                 let tail_word = new_nwords - 1;\n-                let used_bits = new_nbits % uint::BITS;\n+                let used_bits = new_nbits % u32::BITS;\n                 *self.storage.get_mut(tail_word) &= (1 << used_bits) - 1;\n             }\n         }\n@@ -729,8 +729,8 @@ impl Bitv {\n     pub fn pop(&mut self) -> bool {\n         let ret = self.get(self.nbits - 1);\n         // If we are unusing a whole word, make sure it is zeroed out\n-        if self.nbits % uint::BITS == 1 {\n-            *self.storage.get_mut(self.nbits / uint::BITS) = 0;\n+        if self.nbits % u32::BITS == 1 {\n+            *self.storage.get_mut(self.nbits / u32::BITS) = 0;\n         }\n         self.nbits -= 1;\n         ret\n@@ -751,7 +751,7 @@ impl Bitv {\n     pub fn push(&mut self, elem: bool) {\n         let insert_pos = self.nbits;\n         self.nbits += 1;\n-        if self.storage.len() * uint::BITS < self.nbits {\n+        if self.storage.len() * u32::BITS < self.nbits {\n             self.storage.push(0);\n         }\n         self.set(insert_pos, elem);\n@@ -775,7 +775,7 @@ impl Bitv {\n /// ```\n pub fn from_bytes(bytes: &[u8]) -> Bitv {\n     from_fn(bytes.len() * 8, |i| {\n-        let b = bytes[i / 8] as uint;\n+        let b = bytes[i / 8] as u32;\n         let offset = i % 8;\n         b >> (7 - offset) & 1 == 1\n     })\n@@ -813,7 +813,7 @@ impl Collection for Bitv {\n impl Mutable for Bitv {\n     #[inline]\n     fn clear(&mut self) {\n-        for w in self.storage.iter_mut() { *w = 0u; }\n+        for w in self.storage.iter_mut() { *w = 0u32; }\n     }\n }\n \n@@ -1168,7 +1168,7 @@ impl BitvSet {\n     }\n \n     #[inline]\n-    fn other_op(&mut self, other: &BitvSet, f: |uint, uint| -> uint) {\n+    fn other_op(&mut self, other: &BitvSet, f: |u32, u32| -> u32) {\n         // Expand the vector if necessary\n         self.reserve(other.capacity());\n \n@@ -1218,10 +1218,10 @@ impl BitvSet {\n         // Truncate\n         let trunc_len = cmp::max(old_len - n, 1);\n         bitv.storage.truncate(trunc_len);\n-        bitv.nbits = trunc_len * uint::BITS;\n+        bitv.nbits = trunc_len * u32::BITS;\n     }\n \n-    /// Iterator over each uint stored in the `BitvSet`.\n+    /// Iterator over each u32 stored in the `BitvSet`.\n     ///\n     /// # Example\n     ///\n@@ -1238,10 +1238,10 @@ impl BitvSet {\n     /// ```\n     #[inline]\n     pub fn iter<'a>(&'a self) -> BitPositions<'a> {\n-        BitPositions {set: self, next_idx: 0}\n+        BitPositions {set: self, next_idx: 0u}\n     }\n \n-    /// Iterator over each uint stored in `self` union `other`.\n+    /// Iterator over each u32 stored in `self` union `other`.\n     /// See [union_with](#method.union_with) for an efficient in-place version.\n     ///\n     /// # Example\n@@ -1264,8 +1264,8 @@ impl BitvSet {\n             set: self,\n             other: other,\n             merge: |w1, w2| w1 | w2,\n-            current_word: 0,\n-            next_idx: 0\n+            current_word: 0u32,\n+            next_idx: 0u\n         }\n     }\n \n@@ -1293,7 +1293,7 @@ impl BitvSet {\n             set: self,\n             other: other,\n             merge: |w1, w2| w1 & w2,\n-            current_word: 0,\n+            current_word: 0u32,\n             next_idx: 0\n         }.take(min)\n     }\n@@ -1328,12 +1328,12 @@ impl BitvSet {\n             set: self,\n             other: other,\n             merge: |w1, w2| w1 & !w2,\n-            current_word: 0,\n+            current_word: 0u32,\n             next_idx: 0\n         }\n     }\n \n-    /// Iterator over each uint stored in the symmetric difference of `self` and `other`.\n+    /// Iterator over each u32 stored in the symmetric difference of `self` and `other`.\n     /// See [symmetric_difference_with](#method.symmetric_difference_with) for\n     /// an efficient in-place version.\n     ///\n@@ -1357,7 +1357,7 @@ impl BitvSet {\n             set: self,\n             other: other,\n             merge: |w1, w2| w1 ^ w2,\n-            current_word: 0,\n+            current_word: 0u32,\n             next_idx: 0\n         }\n     }\n@@ -1575,8 +1575,8 @@ pub struct BitPositions<'a> {\n pub struct TwoBitPositions<'a> {\n     set: &'a BitvSet,\n     other: &'a BitvSet,\n-    merge: |uint, uint|: 'a -> uint,\n-    current_word: uint,\n+    merge: |u32, u32|: 'a -> u32,\n+    current_word: u32,\n     next_idx: uint\n }\n \n@@ -1604,13 +1604,13 @@ impl<'a> Iterator<uint> for TwoBitPositions<'a> {\n     fn next(&mut self) -> Option<uint> {\n         while self.next_idx < self.set.capacity() ||\n               self.next_idx < self.other.capacity() {\n-            let bit_idx = self.next_idx % uint::BITS;\n+            let bit_idx = self.next_idx % u32::BITS;\n             if bit_idx == 0 {\n                 let &BitvSet(ref s_bitv) = self.set;\n                 let &BitvSet(ref o_bitv) = self.other;\n                 // Merging the two words is a bit of an awkward dance since\n                 // one Bitv might be longer than the other\n-                let word_idx = self.next_idx / uint::BITS;\n+                let word_idx = self.next_idx / u32::BITS;\n                 let w1 = if word_idx < s_bitv.storage.len() {\n                              s_bitv.storage[word_idx]\n                          } else { 0 };\n@@ -1639,6 +1639,7 @@ impl<'a> Iterator<uint> for TwoBitPositions<'a> {\n mod tests {\n     use std::prelude::*;\n     use std::iter::range_step;\n+    use std::u32;\n     use std::uint;\n     use std::rand;\n     use std::rand::Rng;\n@@ -2128,9 +2129,9 @@ mod tests {\n \n     #[test]\n     fn test_bitv_set_basic() {\n-        // calculate nbits with uint::BITS granularity\n+        // calculate nbits with u32::BITS granularity\n         fn calc_nbits(bits: uint) -> uint {\n-            uint::BITS * ((bits + uint::BITS - 1) / uint::BITS)\n+            u32::BITS * ((bits + u32::BITS - 1) / u32::BITS)\n         }\n \n         let mut b = BitvSet::new();\n@@ -2426,7 +2427,7 @@ mod tests {\n         assert!(a.insert(1000));\n         assert!(a.remove(&1000));\n         a.shrink_to_fit();\n-        assert_eq!(a.capacity(), uint::BITS);\n+        assert_eq!(a.capacity(), u32::BITS);\n     }\n \n     #[test]\n@@ -2526,70 +2527,70 @@ mod tests {\n \n     #[test]\n     fn test_bitv_push_pop() {\n-        let mut s = Bitv::with_capacity(5 * uint::BITS - 2, false);\n-        assert_eq!(s.len(), 5 * uint::BITS - 2);\n-        assert_eq!(s.get(5 * uint::BITS - 3), false);\n+        let mut s = Bitv::with_capacity(5 * u32::BITS - 2, false);\n+        assert_eq!(s.len(), 5 * u32::BITS - 2);\n+        assert_eq!(s.get(5 * u32::BITS - 3), false);\n         s.push(true);\n         s.push(true);\n-        assert_eq!(s.get(5 * uint::BITS - 2), true);\n-        assert_eq!(s.get(5 * uint::BITS - 1), true);\n+        assert_eq!(s.get(5 * u32::BITS - 2), true);\n+        assert_eq!(s.get(5 * u32::BITS - 1), true);\n         // Here the internal vector will need to be extended\n         s.push(false);\n-        assert_eq!(s.get(5 * uint::BITS), false);\n+        assert_eq!(s.get(5 * u32::BITS), false);\n         s.push(false);\n-        assert_eq!(s.get(5 * uint::BITS + 1), false);\n-        assert_eq!(s.len(), 5 * uint::BITS + 2);\n+        assert_eq!(s.get(5 * u32::BITS + 1), false);\n+        assert_eq!(s.len(), 5 * u32::BITS + 2);\n         // Pop it all off\n         assert_eq!(s.pop(), false);\n         assert_eq!(s.pop(), false);\n         assert_eq!(s.pop(), true);\n         assert_eq!(s.pop(), true);\n-        assert_eq!(s.len(), 5 * uint::BITS - 2);\n+        assert_eq!(s.len(), 5 * u32::BITS - 2);\n     }\n \n     #[test]\n     fn test_bitv_truncate() {\n-        let mut s = Bitv::with_capacity(5 * uint::BITS, true);\n+        let mut s = Bitv::with_capacity(5 * u32::BITS, true);\n \n-        assert_eq!(s, Bitv::with_capacity(5 * uint::BITS, true));\n-        assert_eq!(s.len(), 5 * uint::BITS);\n-        s.truncate(4 * uint::BITS);\n-        assert_eq!(s, Bitv::with_capacity(4 * uint::BITS, true));\n-        assert_eq!(s.len(), 4 * uint::BITS);\n+        assert_eq!(s, Bitv::with_capacity(5 * u32::BITS, true));\n+        assert_eq!(s.len(), 5 * u32::BITS);\n+        s.truncate(4 * u32::BITS);\n+        assert_eq!(s, Bitv::with_capacity(4 * u32::BITS, true));\n+        assert_eq!(s.len(), 4 * u32::BITS);\n         // Truncating to a size > s.len() should be a noop\n-        s.truncate(5 * uint::BITS);\n-        assert_eq!(s, Bitv::with_capacity(4 * uint::BITS, true));\n-        assert_eq!(s.len(), 4 * uint::BITS);\n-        s.truncate(3 * uint::BITS - 10);\n-        assert_eq!(s, Bitv::with_capacity(3 * uint::BITS - 10, true));\n-        assert_eq!(s.len(), 3 * uint::BITS - 10);\n+        s.truncate(5 * u32::BITS);\n+        assert_eq!(s, Bitv::with_capacity(4 * u32::BITS, true));\n+        assert_eq!(s.len(), 4 * u32::BITS);\n+        s.truncate(3 * u32::BITS - 10);\n+        assert_eq!(s, Bitv::with_capacity(3 * u32::BITS - 10, true));\n+        assert_eq!(s.len(), 3 * u32::BITS - 10);\n         s.truncate(0);\n         assert_eq!(s, Bitv::with_capacity(0, true));\n         assert_eq!(s.len(), 0);\n     }\n \n     #[test]\n     fn test_bitv_reserve() {\n-        let mut s = Bitv::with_capacity(5 * uint::BITS, true);\n+        let mut s = Bitv::with_capacity(5 * u32::BITS, true);\n         // Check capacity\n-        assert_eq!(s.capacity(), 5 * uint::BITS);\n-        s.reserve(2 * uint::BITS);\n-        assert_eq!(s.capacity(), 5 * uint::BITS);\n-        s.reserve(7 * uint::BITS);\n-        assert_eq!(s.capacity(), 7 * uint::BITS);\n-        s.reserve(7 * uint::BITS);\n-        assert_eq!(s.capacity(), 7 * uint::BITS);\n-        s.reserve(7 * uint::BITS + 1);\n-        assert_eq!(s.capacity(), 8 * uint::BITS);\n+        assert_eq!(s.capacity(), 5 * u32::BITS);\n+        s.reserve(2 * u32::BITS);\n+        assert_eq!(s.capacity(), 5 * u32::BITS);\n+        s.reserve(7 * u32::BITS);\n+        assert_eq!(s.capacity(), 7 * u32::BITS);\n+        s.reserve(7 * u32::BITS);\n+        assert_eq!(s.capacity(), 7 * u32::BITS);\n+        s.reserve(7 * u32::BITS + 1);\n+        assert_eq!(s.capacity(), 8 * u32::BITS);\n         // Check that length hasn't changed\n-        assert_eq!(s.len(), 5 * uint::BITS);\n+        assert_eq!(s.len(), 5 * u32::BITS);\n         s.push(true);\n         s.push(false);\n         s.push(true);\n-        assert_eq!(s.get(5 * uint::BITS - 1), true);\n-        assert_eq!(s.get(5 * uint::BITS - 0), true);\n-        assert_eq!(s.get(5 * uint::BITS + 1), false);\n-        assert_eq!(s.get(5 * uint::BITS + 2), true);\n+        assert_eq!(s.get(5 * u32::BITS - 1), true);\n+        assert_eq!(s.get(5 * u32::BITS - 0), true);\n+        assert_eq!(s.get(5 * u32::BITS + 1), false);\n+        assert_eq!(s.get(5 * u32::BITS + 2), true);\n     }\n \n     #[test]\n@@ -2636,7 +2637,7 @@ mod tests {\n         let mut bitv = 0 as uint;\n         b.iter(|| {\n             for _ in range(0u, 100) {\n-                bitv |= 1 << ((r.next_u32() as uint) % uint::BITS);\n+                bitv |= 1 << ((r.next_u32() as uint) % u32::BITS);\n             }\n             &bitv\n         })\n@@ -2669,10 +2670,10 @@ mod tests {\n     #[bench]\n     fn bench_bitv_set_small(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bitv = Bitv::with_capacity(uint::BITS, false);\n+        let mut bitv = Bitv::with_capacity(u32::BITS, false);\n         b.iter(|| {\n             for _ in range(0u, 100) {\n-                bitv.set((r.next_u32() as uint) % uint::BITS, true);\n+                bitv.set((r.next_u32() as uint) % u32::BITS, true);\n             }\n             &bitv\n         })\n@@ -2684,7 +2685,7 @@ mod tests {\n         let mut bitv = BitvSet::new();\n         b.iter(|| {\n             for _ in range(0u, 100) {\n-                bitv.insert((r.next_u32() as uint) % uint::BITS);\n+                bitv.insert((r.next_u32() as uint) % u32::BITS);\n             }\n             &bitv\n         })\n@@ -2713,9 +2714,9 @@ mod tests {\n \n     #[bench]\n     fn bench_bitv_small_iter(b: &mut Bencher) {\n-        let bitv = Bitv::with_capacity(uint::BITS, false);\n+        let bitv = Bitv::with_capacity(u32::BITS, false);\n         b.iter(|| {\n-            let mut sum = 0;\n+            let mut sum = 0u;\n             for _ in range(0u, 10) {\n                 for pres in bitv.iter() {\n                     sum += pres as uint;\n@@ -2729,7 +2730,7 @@ mod tests {\n     fn bench_bitv_big_iter(b: &mut Bencher) {\n         let bitv = Bitv::with_capacity(BENCH_BITS, false);\n         b.iter(|| {\n-            let mut sum = 0;\n+            let mut sum = 0u;\n             for pres in bitv.iter() {\n                 sum += pres as uint;\n             }\n@@ -2742,9 +2743,9 @@ mod tests {\n         let bitv = BitvSet::from_bitv(from_fn(BENCH_BITS,\n                                               |idx| {idx % 3 == 0}));\n         b.iter(|| {\n-            let mut sum = 0;\n+            let mut sum = 0u;\n             for idx in bitv.iter() {\n-                sum += idx;\n+                sum += idx as uint;\n             }\n             sum\n         })"}]}