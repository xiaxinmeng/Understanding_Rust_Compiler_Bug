{"sha": "74b2e9979738ce413209aa4342fc35afe68c68de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0YjJlOTk3OTczOGNlNDEzMjA5YWE0MzQyZmMzNWFmZTY4YzY4ZGU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-18T22:14:40Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-19T02:09:41Z"}, "message": "Report errors better when failing to open files for sub-parsers", "tree": {"sha": "1a6c24b0e8ea072cb651f60170e420e1a64686ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a6c24b0e8ea072cb651f60170e420e1a64686ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74b2e9979738ce413209aa4342fc35afe68c68de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74b2e9979738ce413209aa4342fc35afe68c68de", "html_url": "https://github.com/rust-lang/rust/commit/74b2e9979738ce413209aa4342fc35afe68c68de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74b2e9979738ce413209aa4342fc35afe68c68de/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72cc1aca175044ceb003a8b270940bec1da85460", "url": "https://api.github.com/repos/rust-lang/rust/commits/72cc1aca175044ceb003a8b270940bec1da85460", "html_url": "https://github.com/rust-lang/rust/commit/72cc1aca175044ceb003a8b270940bec1da85460"}], "stats": {"total": 97, "additions": 72, "deletions": 25}, "files": [{"sha": "1bd3ec8423e1370c1f86ec94a9cc890662958fdd", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/74b2e9979738ce413209aa4342fc35afe68c68de/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74b2e9979738ce413209aa4342fc35afe68c68de/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=74b2e9979738ce413209aa4342fc35afe68c68de", "patch": "@@ -58,9 +58,10 @@ fn expand_include(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                   _body: ast::mac_body) -> @ast::expr {\n     let args = get_mac_args(cx, sp, arg, 1u, option::Some(1u), ~\"include\");\n     let file = expr_to_str(cx, args[0], ~\"include_str! requires a string\");\n-    let p = parse::new_parser_from_file(cx.parse_sess(), cx.cfg(),\n-                                        &res_rel_file(cx, sp, &Path(file)),\n-                                        parse::parser::SOURCE_FILE);\n+    let p = parse::new_sub_parser_from_file(\n+        cx.parse_sess(), cx.cfg(),\n+        &res_rel_file(cx, sp, &Path(file)),\n+        parse::parser::SOURCE_FILE, sp);\n     return p.parse_expr();\n }\n "}, {"sha": "fc9474bab24ae3e8588acf4b20390ef62d24add0", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 44, "deletions": 15, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/74b2e9979738ce413209aa4342fc35afe68c68de/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74b2e9979738ce413209aa4342fc35afe68c68de/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=74b2e9979738ce413209aa4342fc35afe68c68de", "patch": "@@ -6,6 +6,7 @@ export next_node_id;\n export new_parser_from_file, new_parser_etc_from_file;\n export new_parser_from_source_str;\n export new_parser_from_tt;\n+export new_sub_parser_from_file;\n export parse_crate_from_file, parse_crate_from_crate_file;\n export parse_crate_from_source_str;\n export parse_expr_from_source_str, parse_item_from_source_str;\n@@ -20,7 +21,7 @@ use util::interner;\n use diagnostic::{span_handler, mk_span_handler, mk_handler, emitter};\n use lexer::{reader, string_reader};\n use parse::token::{ident_interner, mk_ident_interner};\n-use codemap::{CodeMap, FileMap, CharPos, BytePos};\n+use codemap::{span, CodeMap, FileMap, CharPos, BytePos};\n \n type parse_sess = @{\n     cm: @codemap::CodeMap,\n@@ -61,8 +62,8 @@ fn parse_crate_from_file(input: &Path, cfg: ast::crate_cfg,\n \n fn parse_crate_from_crate_file(input: &Path, cfg: ast::crate_cfg,\n                                sess: parse_sess) -> @ast::crate {\n-    let p = new_parser_from_file(sess, cfg, input,\n-                                 parser::CRATE_FILE);\n+    let p = new_crate_parser_from_file(sess, cfg, input,\n+                                       parser::CRATE_FILE);\n     let lo = p.span.lo;\n     let prefix = input.dir_path();\n     let leading_attrs = p.parse_inner_attrs_and_next();\n@@ -84,8 +85,8 @@ fn parse_crate_from_crate_file(input: &Path, cfg: ast::crate_cfg,\n \n fn parse_crate_from_source_file(input: &Path, cfg: ast::crate_cfg,\n                                 sess: parse_sess) -> @ast::crate {\n-    let p = new_parser_from_file(sess, cfg, input,\n-                                 parser::SOURCE_FILE);\n+    let p = new_crate_parser_from_file(sess, cfg, input,\n+                                       parser::SOURCE_FILE);\n     let r = p.parse_crate_mod(cfg);\n     return r;\n }\n@@ -163,17 +164,45 @@ fn new_parser_from_source_str(sess: parse_sess, cfg: ast::crate_cfg,\n }\n \n fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n-                        path: &Path, ftype: parser::file_type) -> Parser {\n-    let res = io::read_whole_file_str(path);\n-    match res {\n-      result::Ok(_) => { /* Continue. */ }\n-      result::Err(e) => sess.span_diagnostic.handler().fatal(e)\n+                        path: &Path,\n+                        ftype: parser::file_type) -> Result<Parser, ~str> {\n+    match io::read_whole_file_str(path) {\n+      result::Ok(move src) => {\n+          let filemap = sess.cm.new_filemap(path.to_str(), @move src);\n+          let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap,\n+                                              sess.interner);\n+\n+          Ok(Parser(sess, cfg, srdr as reader, ftype))\n+\n+      }\n+      result::Err(move e) => Err(move e)\n+    }\n+}\n+\n+/// Create a new parser for an entire crate, handling errors as appropriate\n+/// if the file doesn't exist\n+fn new_crate_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n+                              path: &Path,\n+                              ftype: parser::file_type) -> Parser {\n+    match new_parser_from_file(sess, cfg, path, ftype) {\n+        Ok(move parser) => move parser,\n+        Err(move e) => {\n+            sess.span_diagnostic.handler().fatal(e)\n+        }\n+    }\n+}\n+\n+/// Create a new parser based on a span from an existing parser. Handles\n+/// error messages correctly when the file does not exist.\n+fn new_sub_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n+                            path: &Path, ftype: parser::file_type,\n+                            sp: span) -> Parser {\n+    match new_parser_from_file(sess, cfg, path, ftype) {\n+        Ok(move parser) => move parser,\n+        Err(move e) => {\n+            sess.span_diagnostic.span_fatal(sp, e)\n+        }\n     }\n-    let src = @result::unwrap(res);\n-    let filemap = sess.cm.new_filemap(path.to_str(), src);\n-    let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap,\n-                                        sess.interner);\n-    return Parser(sess, cfg, srdr as reader, ftype);\n }\n \n fn new_parser_from_tt(sess: parse_sess, cfg: ast::crate_cfg,"}, {"sha": "1873a34627052fa8994b3d0757726e6a4e50561c", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/74b2e9979738ce413209aa4342fc35afe68c68de/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74b2e9979738ce413209aa4342fc35afe68c68de/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=74b2e9979738ce413209aa4342fc35afe68c68de", "patch": "@@ -1,6 +1,7 @@\n use parser::{Parser, SOURCE_FILE};\n use attr::parser_attr;\n use ast_util::mk_sp;\n+use codemap::span;\n \n export eval_crate_directives_to_mod;\n export eval_src_mod;\n@@ -64,8 +65,10 @@ fn parse_companion_mod(cx: ctx, prefix: &Path, suffix: &Option<Path>)\n     let modpath = &companion_file(prefix, suffix);\n     if file_exists(modpath) {\n         debug!(\"found companion mod\");\n-        let p0 = new_parser_from_file(cx.sess, cx.cfg,\n-                                      modpath, SOURCE_FILE);\n+        // XXX: Using a dummy span, but this code will go away soon\n+        let p0 = new_sub_parser_from_file(cx.sess, cx.cfg,\n+                                          modpath, SOURCE_FILE,\n+                                          ast_util::dummy_sp());\n         let inner_attrs = p0.parse_inner_attrs_and_next();\n         let m0 = p0.parse_mod_items(token::EOF, inner_attrs.next);\n         return (m0.view_items, m0.items, inner_attrs.inner);\n@@ -82,7 +85,8 @@ fn cdir_path_opt(default: ~str, attrs: ~[ast::attribute]) -> ~str {\n }\n \n fn eval_src_mod(cx: ctx, prefix: &Path, id: ast::ident,\n-                outer_attrs: ~[ast::attribute]) -> (ast::item_, ~[ast::attribute]) {\n+                outer_attrs: ~[ast::attribute],\n+                sp: span) -> (ast::item_, ~[ast::attribute]) {\n     let file_path = Path(cdir_path_opt(\n         cx.sess.interner.get(id) + ~\".rs\", outer_attrs));\n     let full_path = if file_path.is_absolute {\n@@ -91,8 +95,8 @@ fn eval_src_mod(cx: ctx, prefix: &Path, id: ast::ident,\n         prefix.push_many(file_path.components)\n     };\n     let p0 =\n-        new_parser_from_file(cx.sess, cx.cfg,\n-                             &full_path, SOURCE_FILE);\n+        new_sub_parser_from_file(cx.sess, cx.cfg,\n+                                 &full_path, SOURCE_FILE, sp);\n     let inner_attrs = p0.parse_inner_attrs_and_next();\n     let mod_attrs = vec::append(outer_attrs, inner_attrs.inner);\n     let first_item_outer_attrs = inner_attrs.next;\n@@ -117,7 +121,7 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: &Path,\n                         items: &mut ~[@ast::item]) {\n     match cdir.node {\n       ast::cdir_src_mod(vis, id, attrs) => {\n-        let (m, mod_attrs) = eval_src_mod(cx, prefix, id, attrs);\n+        let (m, mod_attrs) = eval_src_mod(cx, prefix, id, attrs, cdir.span);\n         let i = mk_item(cx, cdir.span.lo, cdir.span.hi,\n                            /* FIXME (#2543) */ copy id,\n                            m, vis, mod_attrs);"}, {"sha": "9d71f83b28d5075822b9ff8a9b4b741e1c9399b2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74b2e9979738ce413209aa4342fc35afe68c68de/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74b2e9979738ce413209aa4342fc35afe68c68de/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=74b2e9979738ce413209aa4342fc35afe68c68de", "patch": "@@ -2959,6 +2959,7 @@ impl Parser {\n     }\n \n     fn parse_item_mod(outer_attrs: ~[ast::attribute]) -> item_info {\n+        let id_span = self.span;\n         let id = self.parse_ident();\n         if self.token == token::SEMI {\n             self.bump();\n@@ -2969,7 +2970,8 @@ impl Parser {\n             };\n             let prefix = Path(self.sess.cm.span_to_filename(copy self.span));\n             let prefix = prefix.dir_path();\n-            let (m, attrs) = eval::eval_src_mod(eval_ctx, &prefix, id, outer_attrs);\n+            let (m, attrs) = eval::eval_src_mod(eval_ctx, &prefix, id,\n+                                                outer_attrs, id_span);\n             (id, m, Some(move attrs))\n         } else {\n             self.expect(token::LBRACE);"}, {"sha": "5e571af8955e0c0013d813428aeba2b66ed08a30", "filename": "src/test/compile-fail/mod_file_not_exist.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/74b2e9979738ce413209aa4342fc35afe68c68de/src%2Ftest%2Fcompile-fail%2Fmod_file_not_exist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74b2e9979738ce413209aa4342fc35afe68c68de/src%2Ftest%2Fcompile-fail%2Fmod_file_not_exist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmod_file_not_exist.rs?ref=74b2e9979738ce413209aa4342fc35afe68c68de", "patch": "@@ -0,0 +1,5 @@\n+mod not_a_real_file; //~ ERROR not_a_real_file.rs\n+\n+fn main() {\n+    assert mod_file_aux::bar() == 10;\n+}\n\\ No newline at end of file"}, {"sha": "3baa18be9f1f69e092a348012e73c2ddf6955084", "filename": "src/test/compile-fail/mod_file_with_path_attr.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74b2e9979738ce413209aa4342fc35afe68c68de/src%2Ftest%2Fcompile-fail%2Fmod_file_with_path_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74b2e9979738ce413209aa4342fc35afe68c68de/src%2Ftest%2Fcompile-fail%2Fmod_file_with_path_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmod_file_with_path_attr.rs?ref=74b2e9979738ce413209aa4342fc35afe68c68de", "patch": "@@ -0,0 +1,6 @@\n+#[path = \"not_a_real_file.rs\"]\n+mod m; //~ ERROR not_a_real_file.rs\n+\n+fn main() {\n+    assert m::foo() == 10;\n+}\n\\ No newline at end of file"}]}